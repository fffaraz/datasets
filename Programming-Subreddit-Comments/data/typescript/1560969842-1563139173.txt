This is the proper way to type your `res` and `req` using Express. You can find an example here. [https://truetocode.com/extend-express-request-and-response-typescript-declaration-merging/](https://truetocode.com/extend-express-request-and-response-typescript-declaration-merging/)
This looks promising!
This looks promising!
The naming scheme like the alphabet of single character imports and uppercased methods are a bit unusual.
Does it have sum types?
Yes
What's the point of that? And why wrap functions?
Nice library! I really like your docs site. This is a nice utility library that I would happily use in my next typescript project. A few comments: &gt; import {A, B, C, F, I, N, O, S, T, U} from 'ts-toolbelt' I generally do appreciate an alias, but it is usually secondary to a longer explicit name. I apologize, but this import statement made me cringe a bit. I had no idea what those single letter names mean. I realize they do help with readability of the code, and I could see how it could get very terse...but still, I think at least having the option to use the explicit name is preferable. I did see in your [docs](https://github.com/pirix-gh/ts-toolbelt#-documentation-) that you have a dictionary for these names...why not just export these names, with the addition of the helpful aliases?
[removed]
I x-posted this on /r/frontend, I created this package to provide a lightweight drop-in replacement for zxcvbn. This is my first TypeScript project so I'm looking for feedback on approach as well as implementation and style details. Let me know what you think!
&gt; at most 128 characters Why? There should be no technical reason for this. &gt; at least 3 of: &gt; - at least 1 uppercase character (A-Z) &gt; - at least 1 lowercase character (a-z) &gt; - at least 1 digit (0-9) &gt; - at least 1 special character (punctuation) ‚Äî !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\]^_\{|}~` This promotes unsafe passwords. &gt; not more than 2 identical characters in a row (e.g., 111 not allowed) And this is honestly the dumbest thing I've read in a while.
&gt; import {A, B, C, F, I, N, O, S, T, U} from 'ts-toolbelt' I'd immediately reject any code review with this line. It's the opposite of maintainable.
What is the obsession with single letter variables in the TypeScript community? It's honestly one of the worst things about TypeScript imo. We don't do it in our code, so why is it done with types?
[https://en.wikipedia.org/wiki/Wrapper\_function#Purpose](https://en.wikipedia.org/wiki/Wrapper_function#Purpose)
But you don't want to retain any original properties in these scenarios. Maybe I'm missing something, but I've never had any need to do that...
Function wrapping is a common pattern in functional programming. It's also common for users to set static properties on functions. Example of libraries that do this: Gulp (\`task.description\`), \`execa\` (\`execa.sync()\`), Lodash. This also happens when using classes with static properties. When wrapping those functions, you just want the extra behavior added by the wrapper, not remove the existing behavior/properties of the wrapped function. Losing those properties (which were here for a reason) is not a good side effect of function wrapping. Finally (as mentioned above), keeping \`name\` and \`toString()\` after wrapping a function makes debugging nicer.
Possibly because mathematics uses single letter variables and some of the folks doing the advanced type stuff understand the math. I don't, I understand unions and intersections but I wouldn't recognise the set theory operators on a page.
Have you ever written a decorator?
&gt; import {Any, Boolean, Class, Function, Iteration, Number, Object, String, Tuple, Union} from 'ts-toolbelt' Don't know if this is a recent addition, but it's there now.
Hi, thanks for the feedback! Good idea to export these names with the other "full" names. I've built it this way because you can combine types together to create more types, it could quickly become unreadable. In fact the types work exactly like functions in JavaScript (maybe I should have mentioned that). And the other reason why is that I couldn't put all of them in the same namespace (as type names are shared between categories e.g. \`Pop\` is shared between \`Tuple\` and \`Union\` but are absolutely different). So thanks for this feedback, I updated the package (v1.1.0) based on your feedback. And updated the documentation for the import flavors. Many thanks :)
I've updated it, you can now use different import flavors (with the full names)
Was not a shot at you personally! But thanks for doing that though :)
I did, even made a few decorator powered libraries.
Don't worry, I take critics very well. Critical thinking is the only way of improving.
I've never heard of wrapping in functional programming tbh, only currying. Using properties for function configuration, well that's something I'd consider a very bad practice. That breaks function purity and makes it impossible to determine how it will behave in runtime.
**Fixed**
The 128 length did seem a little arbitrary, not sure why that is. Why doea it promote unsafe passwords? What do you use for password requirements?
Is it possible to write a generic function that actually returns something of type `T.Last&lt;A&gt;` without resorting to type casts?
I've edited my post. It's difficult to specify password requirements. Generally (if applicable and allowed) I add and force two-factor authentication. Additionally you should always log login attempts with invalid credentials, and block subsequent login attempts (e.g. after 3 invalid login attempts, block the user for 1 hour, after 6 invalid logins for a day). This alone can prevent most attempts already. Otherwise it should be a combination and a selection of rules. Length is the best safety factor, the more characters you have, the more possible combinations you get. If I provide a password that has over 60 characters, then it really does not matter if there's a symbol in it or a capital letter. The "no character 3 times in a row" is something I'd drop completely. And a nice feature for such a library would be to provide a strength score, and also provide reasons for the strength (when validated successfully).
You would have to pass the type parameter on the function explicitly. Here's why: [https://github.com/Microsoft/TypeScript/issues/5453#issuecomment-478301595](https://github.com/Microsoft/TypeScript/issues/5453#issuecomment-478301595)
Also: Consider a newer ECMAScript target (or support multiple targets) to avoid the `downlevelIteration`, if it's not necessary.
&gt; Using properties for function configuration, well that's something I'd consider a very bad practice. Absolutely agreed.
&gt;Why does it promote unsafe passwords? 1. The more restrictions a password has, the less work a brute force cracker has to perform, since it can eliminate those same restrictions (i.e. it can skip any iteration that includes 3 of the same character) 2. The more restrictions and forced use of "special" characters, the more likely a user is to write the password down somewhere, usually somewhere accessible like a sticky note, leaving it more likely that a malicious actor could simply look at the password. In general, pass phrases (without character limits) tend to be more secure because the user is more likely to actually memorize it rather than write it down somewhere. There are issues with this method as well, though, including dictionary-based brute force attacks.
Wrapping functions is one of the most common features in functional programming. It's basically how what HOF are doing. Check the examples on https://en.wikipedia.org/wiki/Higher-order_function Static properties on functions does not preclude function purity. Function purity is about the body of the function. Static properties are outside the body of the function. Having static properties does not change anything about a function's purity, as long as those static properties are not referenced inside the function body. ``` const identity = value =&gt; value // `identity` is still pure after this statement identity.staticProperty = true ```
Memoization is not a function wrapping, it's a special case of currying. Function wrapper by definition doesn't have any logic inside and works as a simple pass-through. You only need wrapping in languages like Java which don't allow multi-inheritance. You don't need function wrapping in JS because you have other mechanisms in place. If you're doing currying then copying function properties to the upstream doesn't make any sense, because consumers are not using original un-curried version in the first place and are unaware of its existence. As they should. By copying additional irrelevant meta-data you're exposing implementation to the consumers, which is a bad practice. If the function doesn't use properties assigned to itself (which is a weird and broken concept on its own) then they are irrelevant and there's no need to copy them to the upstream. Speaking of .name and toString() you will only get anything meaningful from them if you're debugging with console.log() which is an instant no-no in my books. If you want to identify something uniquely (either object or function or whatever) then you should not rely on .name because optimisers might remove this information, so you should have an object/function registry instead. So far you've only managed to convince me that this library is trying to solve non-existent problem caused by following bad practices.
To quote your previous comments: \- function wrappers are useless ("why wrap functions?"). Or they are only useful for "multi-inheritance" "in languages like Java". \- function wrappers are not used in functional programming ("I've never heard of wrapping in functional programming") \- function static properties are "properties for function configuration" and make functions impure \- memoization is a type of currying ("Memoization is not a function wrapping, it's a special case of currying") \- function wrappers "do not have any logic inside" except for being "a simple pass-through" \- \`function.name\` and \`function.toString()\` are only used "with console.log()" &amp;#x200B; Based on this we are probably lacking enough common ground to have any fruitful discussion on this topic.
So decorators are useful but function wrappers are not? Interesting point of view.
Decorators are not function wrappers by any means. Do you even have any experience with decorators?
I did not say they were the same (please check my comment again). I'm just finding interesting that you find "decorators" useful but not "function wrappers", that's it.
Interesting. Any idea on the accuracy? Would changing the border radius on a button from 10 to 11px cause it to fail?
You sacrificed too much security from zxcvbn, you are disregarding length in the security of the password, the most easy way for a human to increase the length of password without them forgetting it
I keep getting this: ‚úñ Failed to compile Error: Cannot create an explicit namespace object for module "index" because it contains a reexported external namespace at error (/Users/am/Development/cycle/api-client-nodejs copy/node_modules/rollup/dist/rollup.js:9365:30) randomly. If I isolate where the issue is happening, comment it out, then build, it works of course. If I then uncomment it out, build expecting it to fail....it also works? Idk what's going on there. In addition, I don't know how to set up paths properly. I removed relative paths (../etc/whatever) but in the production build they stay as (etc/whatever) and aren't aliased properly.
Why would you need something like O.merge? Isn't that just the same as &amp;`{a} &amp; {b?}`?
Because will preserve it visually, like if you typed it. On bigger objects, it might become harder to read. Or imagine if fields overlapped? I make sure that all the types are computed this way, for the developer's comfort
Great post, man!
Would you file a report on [TSDX issue](https://github.com/palmerhq/tsdx/issues) page?
React create app w/ typescript. Dump that in a `src/client` folder. Find a simple Express Typescript setup for backend. There are many questions, though. What kind of auth setup do you need? If you need a full-stack, monolithic project then maybe try to find a TS/Express/React boilerplate on Github w/ google.
I don't like binding the mapping to DTO, to persistence and to model into a single class. Doesn't feel very single responsibility, especially considering the API, the database and the modal should be fairly separate.
Interfaces without class implementations are very useful to describe JSON API requests/responses, as well as data structures used by third-party libraries. Of course you can nearly always use `type NewBorn = {...}` instead of `interface`, and leave interfaces solely for situations where an implementing class is required.
&gt; just wonder has anyone tried to use interface without "implements", instead, use it as a Type? This is how I almost always use interfaces. I don't use classes.
I don't have a reference or anything to back me up, but I definitely use `interface` instead of `type` when e.g. describing the structure of an "options argument": ````ts function foo(opts: {a?: number, b?: string, c?: boolean}) { ... } ```` becomes ````ts interface FooOpts {a?: number, b?: string, c?: boolean}; function foo(opts: FooOpts) { ... } ```` I've seen the pattern in a number of library typings so I assumed it was correct. I would be interested to hear what the TS development team thinks about it, though.
Try Matterhorn github project. its a server side TYpescript API based template. for Angular you can use a number of available templates. Let me know, if you want more help in Matterhorn.
For this use case it makes nearly no difference whether you use `interface` or `type`. Only difference is that with `interface` you can make use of declaration merging, whereas `type` does not support this. I doubt the TS development team will respond to it, and I don't think it's necessary.
You have no idea how angry I was after paying 7k‚Ç¨ x 5 for my school... And then discover that they forgot to teach us functional programming, having to re-learn everything from the bottom up. I agree with you, classes are useless, function + object is the way to go (defined with Interfaces)
lol they ‚Äúforgot‚Äù? jeezus
I agree (by rodrigocfd)
We had a small course of OCaml... But all the rest was C, C++, Java, C# and the non-functional paradigm they convey
Classes are not useless, but each paradigm solve their own set of problems. Use the right tool for the job.
The absolute, black and white answer is - it depends. One approach to the dilemma of functional, OO, or other decision is to design in JavaScript and then apply the type mechanism that makes the most sense. The idea of TypeScript is to support types in a way that doesn't get in the way of swiss-army knife that is JavaScript. And if you do that and it all seems awkward anyway, that is usually a sign that your JavaScript design was a little wonky. Occasionally, it is due to something in TypeScript that is still being worked on, but as of version 3 those are hard to find.
They are heavy and rigid. Here's why: A class can be thought of having an object that has properties + methods + constructor. Now, take all of that away, forget about the ***new*** keyword and you're left with pure data structures (objects) and pure functions. So why use a class at all? A cute syntactic sugar? First, you can consider that a class can be replaced with an object + functions (as methods). Now, believe it or not but it's far more lightweight than a class and much more flexible. Why? Classes are not supported everywhere. So atm we transpile them (usually with Babel) to code that will emulate it... That is nothing less than an object. It brings more execution complexity (which you might not care about, but I do) because there's more code. **+1 point** Classes have only one constructor while an object + functions can be constructed by many different constructors (which are just functions). So you are not bound to a single logic anymore to initialise your object. **+1 point** Classes can only inherit from a single parent while objects can inherit from multiple object (with the spread operator) without risk of field overlap (last in wins). Multi-inheritance made a breeze. **+1 point** Functions and objects are like the bricks and the cement for software. To me, a class is like having the bricks and the cement at once, its less convenient and piggy. You can absolutely cover all use-cases for classes with objects + functions. And with TypeScript it's just amazing. You're then left with (if you lay it out property): \- Pure data objects These objects don't have methods \- Pure behavior objects These objects only have methods that receive pure data objects Which means that you have full control over the testing and your i/o. If you're not convinced, the amazing React team explains why classes were dropped [https://youtu.be/dpw9EHDh2bM](https://youtu.be/dpw9EHDh2bM)
I largely agree with you, but I think you're throwing the baby out with the bathwater here. Classes do have some valid uses. The biggest one being encapsulation. There's really no way to separate the implementation from the interface when it comes to objects because there are no private properties. This is a pretty big deal. What if you decide you want to use a completely different data structure to represent the object internally, but it's already being used in hundreds of places in a way that relies on that internal structure? Sure, you can prefix it with an underscore and just hope everyone understands the convention, but of course not everyone will. &gt;Classes are not supported everywhere. So atm we transpile them (usually with Babel) to code that will emulate it... That is nothing less than an object. It brings more execution complexity (which you might not care about, but I do) because there's more code Kind of a weird argument to make in the typescript subreddit lol &gt;Classes have only one constructor while an object + functions can be constructed by many different constructors (which are just functions) Technically true, but irrelevant in practice. You can just declare static methods that instantiate it however you want. Or there's inheritance if you really have to always instantiate it with `new` &gt;Classes can only inherit from a single parent while objects can inherit from multiple object (with the spread operator) without risk of field overlap (last in wins). Multi-inheritance made a breeze This is true, but don't forget classes are just templates for objects. You can instantiate an object from a class, and then still mix in other things with it afterwards in the same way
Objects do have privates. It's simply variables (const) that are only accessible within the scope of its constructor function (or any function in general). So it's 100% private.
Yes... but now you have 1. Functions, which are tied to 2. Internal private data, which is 3. Mutable, which makes your functions impure It's starting to sound a lot like a class to me. At that point the only real difference is syntax. But maybe that's what you mean by this: &gt;The class is just a syntactic sugar to attract Java peps. In which case we agree but I just don't see the differences in syntax as something important enough to argue over ¬Ø\\\_(„ÉÑ)\_/¬Ø The program is going to behave the same in the end.
Internal mutable state does not automatically make a function impure. Purity is defined as: - Its return value is the same for the same arguments (no variation with local static variables, non-local variables, mutable reference arguments or input streams from I/O devices). - Its evaluation has no side effects (no mutation of local static variables, non-local variables, mutable reference arguments or I/O streams).
Thanks! I was just getting tired
&gt; The annoying thing about TS playground is that it takes you to that blank page when you run, do you know why it does that? Because the TS Playground is pretty shitty. Use this better alternative instead: https://typescript-play.js.org/
wow that was so fast, thanks for the suggestion! I'll check it out.
Okay, followup question, how do I do it with more than one type? I thought I understood it but here's where I ran into trouble: type VehicleType = 'car' | 'boat' | 'plane'; interface CarConfig { wheelCount: number } interface BoatConfig { name: string } interface PlaneConfig { isJetPowered: boolean } interface Configuration&lt;T extends VehicleType&gt; { type: VehicleType config: T extends 'car' ? CarConfig : T extends 'boat' ? BoatConfig : T extends 'plane' ? PlaneConfig : never } type VehicleConfig = Configuration&lt;'car'&gt; | Configuration&lt;'boat'&gt; | Configuration&lt;'plane'&gt; const vehicle: VehicleConfig; if (vehicle.type === 'car') { const config = vehicle.config // expect CarConfig, got CarConfig | BoatConfig | PlaneConfig }else if(vehicle.type === 'boat'){ const config = vehicle.config // expect BoatConfig, got CarConfig | BoatConfig | PlaneConfig }else{ const config = vehicle.config // expect PlaneConfig, got CarConfig | BoatConfig | PlaneConfig }
At this point we must just be talking about two different things. What I thought they meant was something like this function createCounter { let count = 0; return () =&gt; count++; } const counter = createCounter(); counter(); //0 counter(); //1 counter(); //2 Which definitely violates the first rule
Yes, that would violate purity. I was just saying that encapsulated mutable state does not automatically mean the function is not pure.
Repl.it installs npm dependencies which I assume takes longer. It's also running on a real Linux system, whereas the playground sites just run the compiler in your browser.
Thanks :)
Yeah, this is much better, thanks for the link!
Can you provide a sandbox at [https://codesandbox.io](https://codesandbox.io) or someplace similar?
Any scenarios where I would want to use `ParamsOf&lt;T&gt;` over the built-in `Parameters&lt;T&gt;`? Cool library though, thanks for sharing!
I believe this kind of type narrowing issue has been fixed in typescript 3.5 (I could be wrong), but what that error is saying is that the compiler has interpreted that `false` as as `boolean` (which can be `true` OR `false`), instead of the literal boolean value of `false`, which the interface requires. One way to workaround that would to change that patch call to: patch({ loading: false as const }) Which tells the compiler that you want that value to be interpreted as literally `false`, not `boolean`.
&gt;what that error is saying is that the compiler has interpreted that false as as boolean (which can be true OR false), instead of the literal boolean value of false, which the interface requires &amp;#x200B; I don't totally get how this is a meaningful difference and why TypeScript would check for this. I was also able to "fix" this by having the compiler interpret this as 'as boolean': `patch({ loading: false as boolean })`
It's also possible that the patch method may be need to be modified, because that method is changing the type from false to boolean.
Because the compiler can differentiate between `true` `false` and `boolean`, you can make some pretty neat things type safe. For example: interface ResponseBase { hasError: boolean; error?: Error; data?: string; } interface ResponseError extends ResponseBase { hasError: true; error: Error; data?: never; } interface ResponseSuccess extends ResponseBase { hasError: false; error?: never; data: string; } type UnknownResponse = ResponseError | ResponseSuccess; function getResponse(): UnknownResponse { return Math.random() &gt; 0.5 ? { hasError: false, data: 'Server responded, yay' } : { hasError: true, error: new Error('Internal Server Error') }; } const resp = getResponse(); if (resp.hasError) { console.log(resp.error); } else { console.log(resp.data); } In this case, because the compiler knows that when hasError is true, it's successful and there is data, vs when it's false there will be an error.
...a more complex example because I'm bored. interface BaseDTO&lt;TPayload = any&gt; { type: string; payload: TPayload; } interface StringDTO extends BaseDTO&lt;string&gt; { type: 'string'; } interface NumberDTO extends BaseDTO&lt;number&gt; { type: 'number'; } interface ComplexObjectDTO extends BaseDTO&lt;ComplexObject&gt; { type: 'ComplexObject'; } interface ComplexObject { a: { b: { c: { d: string; }; }; }; } type DTO = StringDTO | NumberDTO | ComplexObjectDTO; const dtos: DTO[] = [ { type: 'string', payload: 'Hello!' }, { type: 'number', payload: 42 }, { type: 'ComplexObject', payload: { a: { b: { c: { d: 'HELLO!' } } } } }, ]; for (const dto of dtos) { if (dto.type === 'string') { console.log(dto.payload.toUpperCase()); } if (dto.type === 'number') { console.log(dto.payload * 10); } if (dto.type === 'ComplexObject') { console.log(dto.payload.a.b.c.d.toLowerCase()); } }
You're welcome, thank you. It's the same. It just decided (as a design choice) that I would re-code all the utility types that exist (only a few).
If \`as const\` is still not supported (I dont remember if it is as of 3.4), you can still use \`as false\`. Yes, seems stupid but sometimes this happens.
The most common usage of const assertions are when some API accepts string enums (a common pattern in JS). For instance, `type Method = 'get'|'post'` should fail on a different string. TS has some rules on when to infer an expression as const or not, when those rules dont apply to your case you may need to cast `as const` (or `'post' as 'post'` on older TS versions)
Those online editors are using Microsoft's [Monaco Web Editor](https://microsoft.github.io/monaco-editor/). &amp;#x200B; As it stands, the best overall developer experience for TypeScript appears to be [vscode](https://code.visualstudio.com/) (which is also using Monaco). I expect other editors may be reaching vscode parity mostly because TypeScript provides so many hooks for editors of all kinds. I use vscode so i can't speak for other editors, but generally, vscode has always been the premier development experience for TS. &amp;#x200B; Good Luck
Check out nestjs. The cli will set everything for live compilation.
&gt; I believe this kind of type narrowing issue has been fixed in typescript 3.5 Well, then he should just update his TypeScript vers.... oh, he's using Angular. Well, then out of luck. TypeScript support is really bad with Angular.
Thanks, very cool
That profile picture kinda needs an explanation
That's casual Todd Howard, xd
And **another** library that does not enable the `strict` compiler flags. Why use TypeScript for type-safety, but then don't make use of TypeScripts type-safety features?
It will also add NestJS.
I love it
https://firecubestudios.github.io/ https://github.com/FireCubeStudios/FireCubeStudios.github.io
Oh, I am fairly new to the TypeScript world, and I did not know about that. Thanks for the info, I will enable it in the next release and fix the errors/warnings :)
There is no bundle.js in your repository, which you reference from your index.html file.
I second Nestjs! It is awesome! You can also use nodemon if you want (I use it with nest)
It just works!
Which tutorial are you using? I can help make sure there aren't any problems with it.
While this does not directly answer your question, I really need to ask: Did you consider an alternative architecture better suited for serverless? For example an event-based system really shines with severless (you scale executing functions with the amount of events in the queue), while a RESTful system is rather.. meh (you will *randomly* get cold-starts and have slow requests).
Interesting! No, to be honest this is the first I'm hearing of it. Can you point me to any documentation/introduction? We are using serverless.com with handlers assigned to http paths but if theres a different pattern I'd love to see an example.
Oh the subject is so large, there's so much to read about. DDD, CQRS, event/message queues. Simplified, instead of having a synchronous API (REST), you have an asynchronous API (event based). - Message is sent to the server that something happened (e.g. user saved something). - There is no response. The message is not taken. Instead it is stored in an event queue (depending on what happened). This is very fast, as this is the **only** thing you do. - You have listeners / workers that wait for these events. They take the event out of the queue and handle it. - The result can vary, but it's common that the result is another event. Or two events. Or three. Each event is placed in a queue again, and you have listeners/workers waiting for them. - You can also have a response. That is pushed via WebSockets (or comparable technology) to the client. The functions scale with the amount of events in the queue. Azure Functions has no limitation how many functions can run. You suddenly have 60.000 events? Then 60.000 functions are executed to handle these 60.000 events. The result is 120.000 events? Then 120.000 functions are started to handle them. No event? No function is running. You also get a cleaner architecture, as the functions are much smaller. They just deal with the one aspect: "What happened? I respond." This is **very** simplified. But that is what Serverless architectures are great for.
Thanks! I'm new to js world but when I worked with C# we used CQRS w/ an async bus and I've also worked w SignalR (client/server websockets), so its all familiar.
It is not possible without explicitly specifying the properties. &gt; Is that possible yet? No, and it won't ever be. It's explicitly against the design goals of TypeScript.
Thanks and yes i use VS Code too, it's awesome. But i like simple little repls in the browser for tinkering around and doing code challenges and for sharing, stuff like that. The one that /u/[AngularBeginner](https://www.reddit.com/user/AngularBeginner/) mentioned, [https://typescript-play.js.org/](https://typescript-play.js.org/), is great so far!
Wait, I believe you can actually do something with genetics and the `keyof` keyword. It's on the TypeScript documentation page on advanced types.
No. `keyof` creates a type. Types are compile-time only. The `keyof` operator does not create strings that are available at runtime, which is necessary for what he wants. But `keyof` can be used to limit the strings that are passed, should he decide to explicitly provide the property names.
Why is that? Seems like being able to copy JUST the fields of an object makes the most sense... this data is available at compile time too not just runtime.
You need to know at runtime which properties you need to copy, but that information is not available at runtime. It's only available at compile time. Your only option is to be explicit: const newObj: MyType = { prop1: oldObj.prop1, prop2: oldObj.prop2, ... }; But there is no way to get a dynamic behavior without any hacks/workarounds beyond what the TypeScript compiler offers.
So you're just saying reflection is the issue here? They have support for keyof so they know at compile time whether it is or is not ... so they could add this just not via reflection.
&gt; so they could add this just not via reflection. I expanded my comment on why they will not do this. It's against the explicit non-goal number 5. They don't want to emit run-time type information, and that's what this would be.
Start up times for a node app in AWS are pretty low, at least compared to java. Restful APIs backed by lambdas can and do work fine. And they scale up quite happily. Start up times are the same regardless of whether you are processing a rest request or processing a message from a queue.
The AWS well architected papers are worth reading if you haven't already. https://aws.amazon.com/architecture/well-architected/
&gt; I expanded my comment on why they will not do this. It's against the explicit non-goal number 5. They don't want to emit run-time type information, and that's what this would be. Yes.... not asking you to repeat yourself just saying that this isn't runtime type information. This is all available at compile time just like keyof. &gt; Add or rely on run-time type information in programs, or emit different code based on the results of the type system. Instead, encourage programming patterns that do not require run-time metadata. ... I want this at compile time. Unfortunately, there's no way around this problem. JSON serialization can simply have extra fields and there's no way to pull out an exact subset.
&gt; ... I want this at compile time. Creating a copy of an object is a run-time operation. In order to only copy the known properties, you need to have the names of the properties (compile time information) available at run-time.
 [https://nestjs.com/](https://nestjs.com/)
Downvotes for what feels like a relevant question. :(
Title had my interest. When I saw the swagger generation plugin, it had my attention. &amp;#x200B; How hard would it be to retrofit an existing express app to this?
Little known secret, you can actually use [repl.it](https://repl.it) to host web socket application backends. Its quite the neat little thing. Basically [repl.it](https://repl.it) amounts to a free transient backend hosting solution. I use it for a couple of small prototypes.
You should put more effort in requests for help. There is nearly no information available in your post.
I am sorry , I wrote this after trying to get things right after 6-7 hours of frustration. This is my first time asking for help here on reddit , I will get better with time
you say that, but there's still no additional info added in this post or your original post :( without info about how typescript is setup in your project, you're wasting everyone's time including yours
Plus backend... I'm migrating from Java and now doing all my work in node and typescript. It's not perfect but pretty darn good
For the better or worse, I've gotten used to seeing this sort of thing. As long as the package is completely open source, the advertisement's not too in-your-face, I'm ok with it and glad that someone's getting paid to make/maintain open source projects.
how did you get involved? just curious!
its ok I figured out the problem I had to first run npm build before posting on GitHub.
I had several function wrappers where I wanted to keep the \`name\` property. For example, Gulp tasks use the \`name\` property to decide what's printed on the console, and I wanted to wrap those Gulp tasks. I found that mimic-fn was doing almost this, without the extra function wrapping step. I decided to create keep-func-props ([https://github.com/ehmicky/keep-func-props](https://github.com/ehmicky/keep-func-props)) as a thin library around mimic-fn, then send PRs to mimic-fn instead of re-inventing the whole thing. After several PRs, sindresorhus invited me to join as a co-maintainer.
After 6-7 hours you should first take a long break.
TIL a REST api is synchronous ? Each request spawns a thread in Java, saying that a REST api is synchronous doesn‚Äôt make any sense since REST is framework and language agnostic: it is just an architecture.
Yes, conceptually REST is synchronous. You focus on the implementation details, which are irrelevant to the architectural concept. In REST you send a request, and you expect the result to be in the response of that request. A single request, and until the response is ready the connection/request will "linger" around. The opposite is an asynchronous API. You send a request, which is finished immediately (no result in the response). Once the response is ready it will be pushed to the client (e.g. via WebSockets).
You‚Äôre just talking from the client point of view. From the server point of view, REST is not synchronous.
No chance with interfaces, as others have said. However, if you can use a class you do get the runtime info so you'd be able to write something to do what you want.
I think [io-ts](https://github.com/gcanti/io-ts) is the closest thing to that.
[io-ts](https://github.com/gcanti/io-ts) provides a pretty sophisticated reflection/validation system for run-time types (from which you can get compile-time types.) But it also is unfortunately not easy to strip unwanted properties. There are ways, but they have drawbacks. Using a userland run-time type system is also fraught with unfortunate limitations in other ways. One trick to create an interface and have some basic reflection without a lot of code duplication might be to write: const FooType = { id: 0, name: "", description: "" } type Foo = typeof FooType So you can use FooType to iterate through the keys in a generic way. Once you start needing deeper type information, handling nested structures, unions, intersections, it all gets much more complicated.
The workflow with validation and pipes in Nest is so nice
Thanks I had no idea. i like Repl.it I just wish it was faster. it's noticeably slower for me than typescript-play.
Though this post is probably for educative purposes, I'll mention this anyway. Generator functions would be my preferred route for doing something like this, and they work well here: function* range(min: number, max?: number) { if (max === undefined) { max = min min = 0 } for (let n = min; n &lt; max; n++) { yield n } } // logs from 0 to 9 for (const n of range(0, 10)) { console.log(n) } // python-like short form for (const n of range(10)) { console.log(n) }
[removed]
&gt; How hard would it be to retrofit an existing express app to this? I wouldn't say hard, it'll just take some time. NestJS follows Angular's programming paradigms, which are pretty different from express, but NestJS uses express under the hood by default so shouldn't be too hard, just read the docs: https://nestjs.com/
Oh sure! I agree with you :) If you read the post to the end you will see that the last section of the post says: &gt; Next up. The next post would be the last in this series. In it, we would quickly explore generators in JavaScript and see how they can be put to use in defining Iterators.
Fair enough! I did read the post, but I guess I missed that bit, lol
Everything in the docs is around a net new app. So it was hard to envision what a migration looks like. I'm wondering if it's a one week project. I think I'll just have to start a new project and look at the file structure and try it out. Ideally I could just create the bootup file and replace my controllers.
A lot of what I see (and what I've done) is to go with creating a core library, so something like this - libs - feature-a - feature-b - core - feature c This core can then be imported across all the features - [you can sort of see it here](https://github.com/tanepiper/ngx-tinynodes/tree/master/libs) although this repo isn't quite clean right now, and I can't share commercial work. This is an Angular/NX project but the same holds for other frameworks and server-side projects.
&gt; type AssociativeArray&lt;T = any&gt; = {[key: string]: T} | T[]; Please use `unknown` instead of `any`.
Didn't know about \`unknown\`, thanks. I'm a bit confused about your second statement. What exactly do you mean by that?
Accessing `data['some_invalid_key']` will return the type `T`, when it actually is `undefined`. By setting the type of your indexer to `T | undefined` you force the dev to check if he actually got a valid value (assuming you have `strictNullChecks` enabled (which you **really** should)).
Excellent comments üëç
have a look into composite projects https://www.typescriptlang.org/docs/handbook/project-references.html
Get it now. Thanks for your input!
I've been using Nrwl Nx lately and it really helped me structure projects with interrelated libs. You should definitely check it out for your research: https://nx.dev
Does this code typecheck? When I play around with it, I get errors about "type AssociativeArray doesn't have key 0". It makes sense -- you don't know whether you are dealing with an object or an array, and typescript generally dislikes code that only works on part of a type.
I use the same approach and it works reasonably well. Do you have any specific problems that are not solved? If not I would just keep your setup.
The only issue so far is that once projects start cross-referencing each other, everything tends to go to hell from the TS types perspective. I'm trying to separate out some of the independent builds and was wondering if this should even be built or emit anything. Also saw a JSConf video recently where Airbnb was discussing sharing types between teams. Got me thinking if I should be generating or writing d.ts files and dropping them in an @types folder or including them in a tsconfig somewhere.
Great works! Congrats! Is there a typescript documentation for this?
Cherish this! [https://github.com/David-Else/zen-typescript-starter-project](https://github.com/David-Else/zen-typescript-starter-project) I spent months messing about getting what I consider a perfect TypeScript dev environment, I am sure you can change it easily to make it do what you want. I use vs-code live server extension [https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) , but if you want just `npm install live-server` [https://www.npmjs.com/package/live-server](https://www.npmjs.com/package/live-server) either globally or as a dependency/dev dependency and run that. It should work out of the box.
Thanks mate , I owe you my promotion at work :P
yea that one was a wow moment for me too :)
I just use ramda `Dictionary`
You can try using an in memory database. Sqlite has an in memory mode.
Well, you first need to check whether you have an array or an object. Write a type-guard for this.
I happened across this in my searches but it seems it's very targeted towards builds and ingesting \`d.ts\` files. Like I stated in my OP, we have 3 Front-Ends, a GraphQL layer, and then some support packages like a \`styles\` packages, these shared \`types\`, and an \`e2e\` testing package. &amp;#x200B; With the exception of maybe the styles and types packages (Which I'm not sure if I should be building anyway), the others don't really need to emit any declaration files because they're either immediately getting bundled into a webpack file or in the case of GQL, thrown into a \`dist\` folder, copied into a Docker container, and directly executed. I'm not building a babel-esque package monorepo with dozens of plugins which are all imported by other projects and should provide type declarations for JS files. &amp;#x200B; Do you think Project References are still a good fit for this use-case?
Yup, that's my point. If you are going to use this associative array type, you need type guards and so on, which the bog post elides.
the main use case is build speed. it‚Äòs not to get d.ts files but to have incremental builds. usually for these kind of projects you have shared models (probably your types?) and some shared logic. but i would even split the other projects into multiple projects if they have some size. it‚Äòs basically a concept similiar to shared libraries. (e.g. DLLs on windows)
we are doing something similar to you but we have a /shared folder in the root of the monorepo and all projects import types and other shared code from there. no project imports anything from another project, although I'm not sure why that would be a problem.
Thanks for your comment @hobozilla. It is **really** hard to distinguish what is singularly responsible. It's often misunderstood that singular responsibility is to "do one thing only". When we're talking about functions, that's a great rule of thumb, yes. But in Uncle Bob's "Clean Architecture", he addresses that common misconception and explains that the Single Responsibility Principle definition was meant to describe the fact that **‚ÄúA module should be responsible to one, and only one, actor.‚Äù** The reason that stands to be important is that the actors of the system will always identify new requirements and need changes to be made, so we should organize our code to "be responsible to one, and only one actor". &amp;#x200B; In my article, the Mapper pattern is used to *convert a domain model in a particular subdomain to the (2) other representations* it will be required to be in throughout the duration of a use case. That's what it *does*. In my application, Traders are the ones that deal with Vinyl, and Traders only. And that's the **only actor** it's responsible for. See what I mean? Now, if it's your personal preference to separate the functions into different files, that's cool too. But it's personal preference. I'd simply recommend to keep those files really close though. Kent C. Dodds has a good article on [colocation](https://kentcdodds.com/blog/colocation) of components. If you're still not sold, here's another article I wrote on the topic of Domain Knowledge &amp; Singular Responsibility. [https://khalilstemmler.com/articles/solid-principles/single-responsibility/](https://khalilstemmler.com/articles/solid-principles/single-responsibility/)
Thanks :) glad you enjoyed it.
Seems like a good way to replace JSDoc type definitions, which is the primary reason I have moved to typescript. Has been an interesting read.
Hopefully most of those options will become moot when using a Typescript+Babel build process.
Yes, I'll discuss this in a next article. But before going that way, we were using namespaces + system module + outFile so this setup seemed like an initial revolution
You forgot the most important of all! :) `"strict": true,`
Should be the default imo. Why else use typescript?
It's default, run \`npx tsc --init\` and see.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/transtechcoven] [Hey smart people. Would someone be able to help me out with a TypeScript issue?](https://www.reddit.com/r/TransTechCoven/comments/c4yso5/hey_smart_people_would_someone_be_able_to_help_me/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thanks for the organizational structure üëçüèæ - nice work
Hey folks, I'm ideally after any and all feedback in that issue but I can also port over some concrete ideas from the discussion in here too.
This is great, thanks!
You can run \`tsc --init\` on your newly created project to get a sample \`tsconfig.json\` with most of the options with documentation as well. But it maybe using different organization as you did. Give it a try.
Does tsconfig handle extended Jason with comments?
I just wish for the compiler API to be fully documented.
You can also run `tsc --init` on your new project and get a sample `tsconfig.json` with most of the sample configurations with documentation. It shares some common organization with yours but differ in others like JSX.
Yep, they use their own internal parser that handles comments, both `// ` and `/* */`. (it's not json5 but works the same)
Thanks! There is definitely a plan to have typescript work out of the box as well as the ability to generate typescript-based projects. In the mean time you could just convert any generated project to typescript while keeping the "ayakashi.config.js" file in javascript and setting "allowJS" to true in tsconfig. Then just make sure you are running the project from inside the build/dist folder. Let me know how it goes!
Hmmm, tsconfig.json is documented on schemastore.org but if this is different, perhaps consider submitting a pull request there?
Thanks I didn't know! I was inspired by it without knowing it, having seen it in a few places. I count 84 options in mine and 47 in `tsc --init`. I'll look into the discrepancy tomorrow.
Thanks for the info, I hadn't seen it - [http://json.schemastore.org/tsconfig](http://json.schemastore.org/tsconfig). It looks like there are 95 fields with `"description"`text there, 84 in my version, and 48 in the `tsc --init` version. I'm curious why there's such a difference and why it hasn't been more common to have a fleshed out tsconfig more readily available. (given the responses and upvotes we're seeing here I wasn't the only one!)
Thank you for your response. Yes, I got it using memory database. But trying with mocking concept. Database mocking or dummy connection like that.
The response format is clearly provided, and yet people still fuck it up... Amazing.
```typescript * items(): IterableIterator&lt;[string, T[keyof T]]&gt; { const proxy = this as unknown as T; for(const k in proxy) { yield [k, proxy[k]]; } } ```
You could do something like the following: class Dict&lt;T&gt; { constructor(obj: T) { Object.assign(this, obj); } // Typescript is really good at inferring the actual type // We do have to give typescript a hint that this is of type T // Note that if you start adding other properties to this class they will also be yielded, // but they will not be typed correctly * items(this: T) { for (let k in this) { // The 'as const' statement converts the array to a tuple instead of being (K | this[K])[] yield [k, this[k]] as const } } } function dict&lt;T&gt;(obj: T): Dict&lt;T&gt; { // to avoid using "new" return new Dict&lt;T&gt;(obj); } // USAGE type FoodType = 'main' | 'dessert' interface Food { type: FoodType, origin: string } const pizza: Food = {origin: 'Italy', type: "main"}; const crepe: Food = {origin: 'France', type: "dessert"}; const foodRatings: { [name: string]: [Food, number] } = {pizza: [pizza, 10], crepe: [crepe, 8]}; const foodDict = dict(foodRatings); for (let [name, [food, rating]] of foodDict.items()) { }
There are some usecases like migration from javascript to typescript, these flags might help though
Really nice! I think you should file a ticket for it [here](https://github.com/microsoft/TypeScript/issues/new/choose). It would be nice to see this as default behavior for `tsc --init`
&gt;applying the obj to 'this' is not playing nice with typescript. Classes without private properties are generally not nice in TypeScript. Object literals are implicitly assignable, but a check with `instanceof` will fail. Having a private field will make the class nominal typed.
aaaand into my saved posts you go :) thanks for this bruv!
make it a pull request, this will help so many people!
https://github.com/bytegames/bytes/blob/master/tsconfig.json Another project without the `strict` flag...
https://github.com/Microsoft/TypeScript/issues/2983
What about it
Thanks for the heads-up!
Thanks for pointing out! My mistake, I'll add soon.
It's not the default value. If it's missing, the default value is \`false\`.
That's exactly our use case. We migrated a big library from Javascript to Typescript and it was such a big quest to put types everywhere that we had to start with \`strict\` off. Now we have almost completed everywhere and we're ready to put \`strict: true\`.
Thanks for the link, i'm still a beginner so a lot of this goes over my head currently but it's good to knowledgeable and skilled folks are on such things. Thanks!
\`tsc --init\` 3.5.2 output: [https://pastebin.com/raw/tryGpkEQ](https://pastebin.com/raw/tryGpkEQ)
This is the default value for "tsc --init" command, but what if you start with no config file at all, or with an empty tsconfig.json that only contains {} ?
Of course I was talking about the config generated by running "tsc --init". The default values listed here in the table https://www.typescriptlang.org/docs/handbook/compiler-options.html.
This. Is there something that we can use to find dead code? I have one code base, two entry points. One for the client, one for the server. It should be possible to find at least the files that are nowhere imported, right?
Where do we use Typescript playground in real life ? ü§î
https://devblogs.microsoft.com/typescript/announcing-typescript-3-5/ &gt; We‚Äôre anticipating 3.6 will bring a better experience for authoring and consuming generators It is first new language feature on the list: https://github.com/microsoft/TypeScript/issues/31639
Awesome, Thanks! great timing.
To sumbit a ts issue
Just remember kids: Dont google "ts playground" at work.
Right, use Bing search.
Would be awesome if they could add the missing TypeScript versions. Is that an option, /u/orta?
I made that mistake once...
Hmmm - would work better if the code-windows were responsive...
They could format the code of the default examples.
To properly format code in the good Reddit design: - Indent every line by 4 spaces. - Have an empty line before and after the code.
You are right! That is the 2nd time you reminded me, I feel embarrassed. Reddit really needs to sort out their formatting setup, there should be a reminder built in.
Reddit just doesn't care about their good design anymore, and they want to push their crappy new design (which supports the formatting using the three backticks).
Could you share the definitions of \`Zombie\`, \`Bullet\` and \`ScreenText\`? Also \`Object.entries(context.entities: : GameContext) \` is not valid typescript according to the typescript playground, and I never seen this syntax before, are you sure reddit didn't change this as you were struggling with the formatting options?
THANKS so much for looking into this! I have tried to put together a working example that strips the complexity of my code out to reveal the problem. The code below runs OK in the VS Code Quokka testing environment BUT won't compile with strict mode, and gives me: ``` error TS2339: Property 'flatMap' does not exist on type '[string, { update(): void; } | { update(): void; }[]][]'. error TS7006: Parameter 'keyValueArray' implicitly has an 'any' type. ``` I don't know why `flatMap` does not exist on an Array, as it does! Also, I can't seem to type `keyValueArray` ``` interface Updateable { update(): void; } const test1 = { hero: { update() { console.log('updated hero in object'); }, }, zombies: [ { update() { console.log('updated zombie 1 in array of objects'); }, }, { update() { console.log('updated zombie 2 in array of objects'); }, }, ], }; Object.entries(test1)` .flatMap(keyValueArray =&gt; { const [key, objOrArrayValue] = keyValueArray; if (objOrArrayValue instanceof Array) { return objOrArrayValue; } return [objOrArrayValue]; }) .forEach((obj: Updateable) =&gt; obj.update()); ```
According to [https://stackoverflow.com/questions/53556409/typescript-flatmap-flat-flatten-doesnt-exist-on-type-any](https://stackoverflow.com/questions/53556409/typescript-flatmap-flat-flatten-doesnt-exist-on-type-any) To make sure typescript known about the "flatmap" function, you need to make sure your "lib" setting in your \`tsconfig.ts\` contains \`esnext\`
Is support for \`Object.entries()\` and \`\[\].flatmap()\` still planned in the playground? all the target library levels don't work with those functions
It‚Äôs not reddits job to make sure you format your post correctly. That‚Äôs what the preview option is for.
Oh that's awesome! I was just asking here the other day for alternatives to [repl.it](https://repl.it) typeScript and TS playground out of frustration with some quibbles so this timing is great!
Here's my attempt. [https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHtx1NAPAFQD5kBvAKGUuQG1QATCADwC4QBXAWwCNoBdZtJjDYQeIsgA+yfGQC+ZMgBsIYZAGdgHAA7KAglCjMMWHFFztu0YgF4aARgA0AJgcBmXgG4lK5KLWQ6AHkQJAFjYVNzTh4oGxpqRxd3B2oAFgcAVgcANl5Pb1U-APwAd2BQwRNRMwsYuOoGxN4U1wdUvJTqLNyUgHYHAA483gUYNhCwYExkYQBrCF0QAE8AOQh-CDp9KDglgAo4AyMhETxaqwBKUgoqKBU2KBBkQ6g5BTmF5bWNrYNdvY02j0BguZA+i1W6wC23+RU2wSQoPBXyhmxh+zhdFK5QgFyAA](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMIHtx1NAPAFQD5kBvAKGUuQG1QATCADwC4QBXAWwCNoBdZtJjDYQeIsgA+yfGQC+ZMgBsIYZAGdgHAA7KAglCjMMWHFFztu0YgF4aARgA0AJgcBmXgG4lK5KLWQ6AHkQJAFjYVNzTh4oGxpqRxd3B2oAFgcAVgcANl5Pb1U-APwAd2BQwRNRMwsYuOoGxN4U1wdUvJTqLNyUgHYHAA483gUYNhCwYExkYQBrCF0QAE8AOQh-CDp9KDglgAo4AyMhETxaqwBKUgoqKBU2KBBkQ6g5BTmF5bWNrYNdvY02j0BguZA+i1W6wC23+RU2wSQoPBXyhmxh+zhdFK5QgFyAA)
That is beautiful! Thank you, so nice. I'm going to save study this. &amp;#x200B; Do you have a name for this sort of type? It's like a recursive type where Container&lt;T&gt; keeps referencing its self? &amp;#x200B; Thanks!
I think it's just called recursive types and that exactly what it does yes! References itself until it can reference the generic.
Thanks, i'll have to keep studying this concept because it's a little mind bending right now but seems very elegant and practical! I appreciate your time and effort showing this! :)
A ha! I found that was a little out of date, you can set \`"target": "es2019"\` and it now \`.flatMap\` works! I will have to see if I can get the rest of the function's typing working now. Cheers.
I have never found a preview, that was one of my annoyances. Is that not why this pointless forum exists? [https://www.reddit.com/r/PostPreview/](https://www.reddit.com/r/PostPreview/)
No problem. I'm still learning typescript as well, there might be better solutions! Happy to help.
Thanks for helping a less advanced beginner than yourself :) Hope with more skills and knowledge someday i can pay it back to other beginners.
&gt;Comment asHarmonicAscendantcommentBoldItalicsLinkStrikethroughInline CodeSuperscriptSpoilerHeadingBulleted ListNumbered ListQuote BlockCode BlockTableMarkdown modeSwitch to markdown &gt; &gt;Sort by flatmap() should definitely work with target es2019, it does in the compiler, but es2019 is missing in the playground.
One thing to note is that it seems to work with interfaces, but not type aliases. My first try was `type nestedEl = number | nestedEl[]; type nestedArray = nestedEl[];`, but that fails because type aliases can't recurse directly.
Oh good tip, thanks.
I also hate the feature of reddit redesign that when you press reply, it automatically quotes any text you selected on the page
 interface Fubar&lt;T&gt; extends Array&lt;Fubar&lt;T&gt; | T&gt; { }
Curiosity got the best of me.. should've just listened but nooo.. had to find out.. at work nonetheless
```ts type NestedArray&lt;T&gt; = Array&lt;NestedArray&lt;T&gt;&gt; | Array&lt;T&gt; ```
Not sure if good or bad for OP's use case, but I believe any given nested array could have a mix of leaves (`T`) and nodes (`Array&lt;...&gt;`)
Hm, it looks like they got rid of the preview feature when they did the re-design. **That's stupid.** It used to show the preview post under the text editor. I haven't used reddit on desktop since the redesign so I didn't know.
Hard to say for older versions, because it relies on the editor &lt;-&gt; typescript [mapping lib](https://github.com/microsoft/monaco-typescript) which doesn't get shipped on every typescript version. I'm aiming to add support for it to not be directly tied to one version of TypeScript. Though I'm not sure about that working out well with older versions which aren't in there ATM
Before I was on the TS team, we used it to send syntax samples to each other all the time also
As in you'd want those polyfilled into the playground runtime already, so you can use them when you hit "Run"?
Thanks for the interface! on mobile now but will play with this later. Appreciate the help!
Thanks, I'll just consider the more straightforward case for now and when I get the hang of it more, consider more mixed types.
Good to see all these similar but unique takes on the problem, really helps drive the gist home. Appreciate it!
Explicitly type your variable: function breakEverything() { let MyObject: MyObject = { dateOnly: "lol not a date", stringOnly: undefined } }
And always \_always\_ explicitly type your functions.
It's not that simple I'm afraid, the thing to the right assignment is actually a JSON.parse(), so it's not smart enough to find the issue at compile time and then it just slips through at runtime.
TypeScript has no way of knowing what JSON.parse() will return. TS doesn't exist at all at runtime.
That's runtime type validation, and doesn't exist in JavaScript without rolling your own.
Not very efficient, but you could possibly use `Reflect.has("key")` to enforce a specific JSON structure at the very least. I'm sure there are existing libs to do this in some fashion.
That protects against unknown fields, but how do I make sure that it *has* the fields that are required?
Surely I'm not the first person to do this, though, there must be some canned solutions?
The "MyObject" class is never used in the example you've provided. The body of "breakEverything" defines a new variable "MyObject" that happens to have the same name as the class you've defined. As mentioned elsewhere, typing your variable will prevent the example you've provided from compiling. If you need to validate the contents of an object at runtime (e.g. from parsed JSON), I'd recommend something like [https://github.com/typestack/class-validator](https://github.com/typestack/class-validator).
Any specific reason why? I almost never explicitly type my functions, and haven't really run into any issues using implicit return types.
That‚Äôs not really possible to do, in any language.
There are libraries such as joi (https://www.npmjs.com/package/@hapi/joi), but typescript cannot help you here, run time validation is not what typescript does.
Your issue has to do with the return type of `JSON.parse` as it's defined in the built-in declaration file in TypeScript. If you override that to return `unknown` then you'll get proper compile-time enforcement.
Explicit types in the function declaration make it much more obvious what your intention for the function is. Also when you modify the function body later such that it accidentally returns the wrong type you don't have to debug your way back from the other thing that's calling the function to find out where the mistake was, the compiler error tells you exactly which function to look in.
I use a json schema validator combined with type guards to ensure values at runtime. This is handy for loading a file, querying a DB, or handling a json body from a request.
Maybe I'm misunderstanding the question, but that is exactly what `Reflect.has` does (and I forgot the object in my previous post, my bad): given an object and a property name, returns true or false if the object has such a property defined. If the property is confirmed to exist on the object, then you can validate that its value matches the type of value you need it to have through whatever means necessary, including nested objects with more property checks. Again, not too efficient without some careful thought, but I'm not familiar with any other options at this time.
You may find [JSON Schema](https://json-schema.org/) helpful if you need to check it at runtime.
I use io-ts for this: [https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts) That should solve your exact problem pretty well.
This is more controversial than you're making it out to be. In many cases, you want to take full advantage of TypeScript's powerful inference rather than explicit annotations. In practice, I don't find `const myFunc = (): void =&gt; { // do some stuff }` to be any more useful or less susceptible to bugs/confusion than `const myFunc = () =&gt; { // do some stuff }`. There are some cases where explicit return type enhances readability, but it's not all cases.
So there's three "break from model" scenarios to consider in deserialization: 1. The JSON string contains a field your object shouldn't (this is what yours solves) 2. The JSON string contains a field with the same name but a different *type* than the target object. (I'd like to solve this but frankly I've given up 3. The JSON string does NOT contain a field which the target object *requires*. (THIS is the scenario that I'm trying to solve for and throw an error at)
The problem I have with class-validator and joi is that, as far as I can tell, you need to define for it what the validation rules are. This is tough for my service because our request objects are defined in OpenAPI 3.0 and we use OpenApiGenerator to create the Typescript objects the internal code uses. The idea is I want to be able to add a required field to that OpenAPI YAML file and have the validation automatically start checking for it because it was added to the Typescript request object.
Wait do you have an example of what this looks like in practice? It sounds like exactly what I need but I have no idea how to do it.
Wait do you have an example of what this looks like in practice? It sounds like exactly what I need but I have no idea how to do it.
The problem with this, like a lot of the other proposed validator solutions, is that it requires me to specifically define the validation rules for this object. The reason that won't fly is that the objects I'm validating aren't defined within my package, I'm importing them from a central package for request/response objects. I need to be able to make up new validation rules on the fly if that model object changes.
It sounds to me like the kind of function you want here is a Type Guard. I'm not 100% certain how you'd implement it, but I think a type guard factory function which took in required proper pans properties(or what have you) based on the yaml and returned a Type Guard could be written. That said, you could also do this in pure JavaScript given the set of required properties and obj.hasOwnProperty(name). You could achieve the broader goal by specifying required and optional properties and using Object.getOwnPropertyNames(obj).
Check out ajv, which is the schema validator I use. I setup a validator class with a generic type and tie the schema to an interface. Then, you provide an object and it will return that as your interface type using the schema validator as the type guard.
The problem with that is how do you make the validator class generic so if the object you're trying to validate changes, your validator automatically starts checking for the new value? (My request/response objects are defined in an external package)
You can use `jsonschema` to do that validation: [https://json-schema.org/](https://json-schema.org/)
To cast a value as unknown you can do this: `const obj = JSON.parse(data) as unknown as MyDataType`
Something like this: interface JSON { parse(text: string, reviver?: (this: unknown, key: string, value: unknown) =&gt; void): unknown; } interface Foo { readonly bar: string; readonly baz: number; } // Bad! const foo: Foo = JSON.parse('{ "bar": "hello" }'); ([TS Playground](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgFIGUDyA5ZBvAKGWOQAc4oBnCACkgA8wAuZSsKUAcwBpkoIAbsAHQA-CzoALYJRYBXEAGsQAewDuIXoogBPFmw4geyAXAA2ciPKWqNASmQBeAHwmVwACZ3ry9SADcBAC+BASgkLCIKABiKir4RCT8cB4qIGY6yABGFPrsXIEkfBApaRnZcABeLCByALZZ0IEhBAD0rcgAQikAhAQIaWzIMHEssfGOaFjYAHTkVLQA5HjIAEQ5UKssq5IQZmYqq8hBi3b+QA))
Well I just spent the last hour or so playing around with this concept and have come to realize I have no idea what I'm talking about. Could just be that my tsconfig is too strict, but nothing I try seems to work other than iterating through `Object.entries()` and testing each key against a fixed string (property name). Every other attempt comes up with complaints about `never`. Looks like I got some more learning to do and things to try. Sorry if I wasted your time, hope we both find answers to this one! I'll try to remember to loop back if I figure it out. In the meantime it looks like other people have mentioned things like Joi which might work, but I personally want to slam my head against the wall trying things out before seeing how it does what it does.
Yeah, unfortunately I don't think there is a way around defining them explicitly in TypeScript. At least io-ts allows you to get the type definition from the decoder definition when using it. But if you don't control the types themselves since they're in a dependency you rely on, I think that means you haver to keep the decoders in sync as the types change. There's no built-in solution in TypeScript afaik.
&gt;https://github.com/typestack/class-validator &gt; &gt;I don't think this is possible. Types in TS only exist at compile-time, they don't have a runtime equivalent. If you need runtime validation, you need to define the validation/decoder rules. Some packages, like io-ts, allow you to define the decoder and then automatically get the compile-time type that it decodes into from that, so you don't have to define both the type and the validator/decoder. But that doesn't really seem to help you since you don't control the types. Not sure if there actually is any possible solution for what you specifically need without having to define the decoder part yourself (or requiring them to be defined upstream as part of the package that also maintains the types you need to decode into). :-/
I want being able to type \`Object.entries({ test: 1 })\` and have typescript know I get an array back instead of any
Saying it's not possible isn't helpful, that just means you don't know how to do it. In software *everything* is possible, it's just a matter of cost.
Using the `ts-toolbelt` library this can be done in a single short method decleration: ```typescript import { Object, Any } from 'ts-toolbelt'; export function getProp&lt;O extends object, P extends string[]&gt;(obj: O, ...keys: Any.Cast&lt;P, Object.PathValid&lt;O, P&gt;&gt;) : Object.Path&lt;O, P&gt; | undefined { return keys.reduce( (result: any, key: string) =&gt; (result === null || result === undefined) ? undefined : result[key], obj); } ```
Six seconds of Googling ("OpenAPI YAML runtime validation") turned up [this package](https://www.npmjs.com/package/swagger-model-validator). Typescript is *not* going to be involved in this. You need a package that will read your API object definition files and generate a validation function. Or, you can just consume the result with `let myObj: SomeAPIType = JSON.parse(response);`, use your build tooling to ensure that both sides of the API are using the same defs, and hope for the best. I'd only risk it if you control the frontend and backend, of course.
If you don't care about the keys, you can use `Object.values` instead of `Object.entries`. `Object.values(test1).flatMap(val =&gt; val instanceof Array ? val : [val])`
[https://github.com/woutervh-/typescript-is](https://github.com/woutervh-/typescript-is) check this out
Perhaps not in the browser. Definitely doable in other languages though. Use Gson for that sort of thing.
You can write (or maybe find) a tool that generates decoders/validators for you given a TS type definition. Not sure if something like that exists, but you could write it yourself, if there isn't something like that. The TS tooling. parser, compiler etc. are all available and open source so it should be possible. Maybe someone else already has done this? If you find anything, please let me know :) But I don't think there is a built-in way to do this (if so that would be awesome but I haven't heard of this before and others here seem to agree with me).
That's still at runtime...there's no way to do this at compile time unless you happen to know exactly what string will be fed to the parser.
Ohx I was specifically talking about runtime, must have misread the op. My bad.
The two signatures you are wanting are: function add (args: number[]) : number; function add (...args : number[]) : number; Which are not the same thing. If you wanted to represent their arguments, one would be `number[]` and the other would be `[number[]]`--the latter being a tuple of length 1 with a number array. You would need to define 2 overloads, but have an implementation that satisfies: function add (...args : number[] | [number[]]) : number { } [Here's one implementation that uses a type guard.](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAQwCasQCmQJwOYDOAXImCALYBGApjgNoC6AlIiWVbQNwBQoksCFOiwA6MbkKtSFGvWZT2snn2jwkaDJjEiJBBTNqNEAH0R1FhhvLYGciAN7dEzxDGCYYBAII4cyAJ4A8sAAcrYE2PgETCyOLvGIONRQIDjqUSJJqCAQ1JjYEBAANIgAbsgANkwAvAB8cQmNSSlpKIWIANRllTyNzgC+JQAMTE4u-YjUFQTUDmNNyanq6FriUXRDzL3j3P3cvOCqgp4+fkGh4ZGENhxyJmYWcswkuq56j0YNzs1LiFD+AAdqHBgCh1ptENUoYgAOSPGE8PbcSq0KDYFYARiKACYigBmGLIiqo9GoTB0LG4vHMUZAA)
Oh that is so great, thank you much! I wouldn't have thought about much of this. I will study this and then try to implement it from scratch for the practice and learning it better! &amp;#x200B; And the \[ number\[\] \] is perplexing me a bit, i'm not sure about that array wrapper. I'll have to spend some time with this. &amp;#x200B; Thanks again!
I've looked at some of these. Definitely some are good repos. A lot of them it looks the owner of the repo is the one collecting the bounties 99% of the time. I looked at one that had an issue like "Improve typescript strictness" for a few hundred bucks. Made a fair amount of progress but realized that the application would need major refactoring to be considered typesafe without just littering not-null assertions everywhere. Noped out of there real quick.
oh i think i see... . (...args) will turn whatever args you pass into an array and that's where the array "wrapper" comes from with type \[ number \[ \] \] if you pass args as a number array, then ...args will wrap it in another array and thus the need for the type guard, to extract that wrapping? Am i on the right track here?
yup, `...` collects all arguments into an array. So if there is only one argument, an array of numbers, then args is `[number[]]`
Wonderful thanks for the clarification!
[Overly verbose, and prefer your simplicity... but was a good learning exercise.](https://typescript-play.js.org/#code/GYVwdgxgLglg9mABAQwCaoBTIE4HMDOAXImCALYBGAptgNoC6AlMaZTQNwBQoksCK6DADoROAi3LU6TCW2xce0eEjSYRQsURKSaDRAB9EtVlIZNEsqQcT4o2GGFyIA3p0SIYwRBggALKhAA1gCSwACC2NjIAJ4A8sAAcjrY+AD6AIogVLbKWHj4jIwubu6I2FRQINgq+ULlqCAQVBhYEBDkADSIAG7IADZFALwAfMWlpeWV1Sht5IgA1D39XOMAvl0ADIwriKuIVH34VB5ePv5BoRFR0QDqUQAO91SoSXJXMRlZOQh5BIVjEwqVRUgnUmloGyYO1WJQORzKQOmAHI7NEULhkA4uqgYKhENE4CBEPdkPh8No5OTSSg8OQqGAoPgAPxIrgw7jgJT8PwBELhSIxeKvKRpTLZPhgDAlHlBACyVEsuno1mMyTMnGYiBlgXlHnJJiVAMmwMQUGiTzgXm18ohysG9sQACIDdhHWzOBzeMotec+e9bg8ni9kv7PuLctLffLFdIVS71ZrrccYOTVXIzEbEUh-UIU-6zrybZDtpx2RAEPg4H0qEI+nBcFhBLQAIwdABMHQAzEwS+WwJXq7X643MC2e0A) &amp;#x200B; There was some trial and error still, especially about the "someValue is someType" return from the helper functions. Which i didn't have a good handle on but now they're making much more sense. Do you know what they're called by the way? Type Assertions? Thanks again!
Nice! Might want to link to the actual repo: [https://github.com/labs42io/clean-code-typescript](https://github.com/labs42io/clean-code-typescript)
Nice, I'll pass that onto the apprentice at work.
Chances are the concepts discussed in the article are things you might be interested in brushing up on even as a non-apprentice.
It's called a [Type Guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types) and it's definitely a rarer feature, but is slightly more idiomatic than simply doing a cast
Not legal: ``` Type alias 'NestedArray' circularly references itself. ```
This is the canonical solution: ``` export interface Leaf { iAmALeaf: true; } export type Node = NodeArray | Leaf; export interface NodeArray extends Array&lt;Node&gt; {} let arr: Node = [ [ [ {iAmALeaf: true}, ], {iAmALeaf: true}, ], {iAmALeaf: true}, ]; ``` [Playground](http://www.typescriptlang.org/play/#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgGWE3TgG8AoOKxAQQFsbDiAuOGKAV2AG5yBfcuVCRYbAJ5g8AOQgATPAF44M+TShRMYuAB8CRdLyHho8ZKgw5pc4Go1bQqJLIDOcW5oA8K4AD4yA8gAbYHhMdVZvOCUAbUpqWOpEuASk1NIEekZ9VnYuPgAaONSAXULUqnTMpnQczmACorhSxsqGatq8wuLeIA)
oh cool I think something just clicked I didn't quite get before, thanks to your comment. I understand the basics and have done simple examples of a type guard, I thought of it as a type check in an if conditional... if (typeof someValue === 'someType'){ // then typescript treats it specifically in this block } but what I hadn't realized and I think your comment is clicking it for me is the 2nd half, the return type... you can return from such an if block with the : someValue is someType syntax I was asking about. is that the general idea? if so, thanks much for helping me make that connection!
You can do something like dependency injection. &amp;#x200B; You can do like function addUser(usersDb, userName){ usersDb.insert(userName) } const mockUsersDb = { const inserted = [] return { insert(data){ inserted.push(data) }, getInserted(){ return inserted } } } // test const mUsersdb = mockUsersDb addUser(mUsersDb, "RaghunathV") assert(mUsersDb.getInserted.length === 1)
very interesting, this is a very unique looking 'flow' that doesn't look familiar to me. A distinct style. Can you explain what you mean by canonical solution? is this an example of some sort of data structure?
Sounds like something an apprentice would say /s
I appreciate your enthusiasm for sarcasm, but indicating it defeats its purpose.
You really are the worst bot. As user Pelt0n once said: &gt; God shut up *I'm a human being too, And this action was performed manually. /s*
Sounds like something an apprentice would say.
It's important to stay humble and keep an apprentice mindset if you want to keep learning new things.
This is really great. Thank you for the time you put into this!
By canonical, I mean "this is the standard way of expressing a recursive type". TypeScript is fine with recursive types. This simple example works fine: ``` interface Entry&lt;T&gt; { value: T; next: Entry&lt;T&gt;|null; } ``` What it does not support are recursive type _aliases_ (definitions created with the `type` keyword). Unfortunately it's not really written down anywhere, but a type alias is not a full "type" in TS, it's treated more like a type macro, and eagerly expanded in the type system. That's why you can't write: ``` type Node&lt;T&gt; = T | Array&lt;Node&lt;T&gt;&gt;; ``` Attempting to expand this alias results in an infinite loop. However, if you declare an `interface NodeArray&lt;T&gt; extends Array&lt;Node&lt;T&gt;&gt;` you break the loop. `NodeArray&lt;T&gt;` is a full type on its own, which happens to implement an interface that references other `Node&lt;T&gt;` values. This is in contrast to `Array&lt;Node&lt;T&gt;&gt;` which is a direct circular reference to the `Node&lt;T&gt;` type. The TS team probably _could_ support recursive type aliases if they chose. I don't know if it's on their roadmap, though, or if there are performance or complexity reasons that prevent it from being considered currently.
Sarcasm robot bad. *I am a bot, and this action was performed automatically. If you're human and reading this, you can help by reporting or banning u/The-Worst-Bot. I will be turned off when this stupidity ends, thank you for your patience in dealing with this spam.* *PS: Have a good quip or quote you want repeatedly hurled at this dumb robot? PM it to me and it might get added!*
Good question - curious what the right answer is as well. Thus far I‚Äôve gotten myself by using a union with a null return if it fails and being sure to check for a null return at the caller. Interested to see what the best practice is.
Use `throw` statements. If you use something like `Ok`/`Error` types you still run into the possibility that your code throws an error that isn‚Äôt one of the types you expected in your own code (what if an async `fetch` call fails?). Mitigating this often means more `try`/`catch` statements in your current function, when originally, the error would naturally propagate to the callee anyways. Because `return` statements don‚Äôt propagate upwards, if you want to mimic the upward propagating behavior of `throw` statements you have to thread the result type upwards so that eventually every single function returns a `Result&lt;any&gt;`. In other words, functions which consume functions with return `Result` types will naturally gravitate towards returning `Result` types until eventually you have an entire codebase composed exclusively of `Result` returning functions. The `throw` statement does not affect the return types of functions in typescript, propagates upwards automatically, and is the idiomatic way to describe failure conditions in javascript. Keep it simple.
`Use enum to document the intent` While this is a good practice most of the time in javascript, typescript allows you to give strict typing to strings such as `type Genre = 'drama' | 'comedy' | 'documentary' | ...;` -- which would have been something worth mentioning in a typescript best practices. A lot of the other rules are really general as well and not exclusive to typescript (don't require typing in any way) so perhaps consider making a more general tutorial first and then extend it with typescript in another document. Otherwise this seems really good.
This is generally good advice, although a couple points stuck out for me: - I believe TSLint is being retired. ESLint will be the way to go going forward. - 100% test coverage is very costly (in implementation as well as maintenance) and not really useful. On my experience functional and e2e tests are more useful in catching real issues. Unit tests should be used sparingly for more complex pieces of code. (Which you should try to minimize anyway.)
One way would be to define your type as the disjunction of three types, giving all the valid combinations of those fields: type Base = { ... } type Actual = (Base &amp; { field1: Field1Type; field2: Field2Type }) | (Base &amp; { field1: Field1Type }) | (Base &amp; { field2: Field2Type }) Now as long as the field types don‚Äôt allow them to be undefined, Actual should work like you wanted.
&gt; If you use something like `Ok`/`Error` types you still run into the possibility that your code throws an unexpected error (what if an `async` fetch call fails?). Mitigating this often means more try/catch statements in your current function, when originally, the error would naturally propagate to the caller anyways. Errors propagating to the caller is exactly the issue I find problematic. It means any high level code cannot trust called functions will execute without raising exceptions. On top of that, it's not even possible to know what exceptions could be raised without inspecting the implementation of the function (and functions called within and so on ad infinitum). What happens if the implementation of a low level function is modified and now raises an exception? All call sites are now potentially silently broken. (silently in the sense that errors will only show at run time under specific conditions.) I want to catch as many errors as possible before deploying code to production. I don't think exceptions help me to do that.
Indeed. I've just been thinking about them and my own code.
It is now published https://www.geekabyte.io/2019/06/generators-and-iterators-in-javascript.html :)
Networks fail. I/O operations fail. Programmers make mistakes. When this does happen, it‚Äôs better to crash and fail fast. Your belief that using a `Result` type somehow protects you from exceptions is *100% wrong* (I really cannot stress how wrong you are) and will only exacerbate production issues. If you‚Äôre creating an ad-hoc data structure for exceptions without syntax-level support you‚Äôre setting yourself up for silent failures (You‚Äôre gonna end up calling a function which returns a `Result` and forget to check that the `Result` is `Ok`.) Rust mitigates this problem by [forcing all `Result` types to be used](https://doc.rust-lang.org/std/result/#results-must-be-used) but no such guarantees can be made in typescript. &gt; Errors propagating to the caller is exactly the issue I find problematic. If you don‚Äôt want to propagate an error upwards you want to have a function like the `foo` function you describe above return `string | undefined`. You use errors when you think it would be better to stop all execution rather than continue and having them propagate upwards is the best way to do this. &gt; What happens if the implementation of a low level function is modified and now raises an exception? All call sites are now potentially silently broken. (silently in the sense that errors will only show at run time under specific conditions.) It‚Äôs not silently broken... It‚Äôs very loudly broken in the form of a crashed process, errors logged to loggers, notifications sent to monitoring tools. The best way to make sure your code doesn‚Äôt crash is to let errors be errors and use a test harness which exercises as much of your codebase to see that they‚Äôre not thrown. Beyond that, there‚Äôs not much you can do in a language like javascript/typescript. If you want to see what happens when you try to reify errors as a data structure without syntax support look no further than the history of promise rejections. Initially, promises would just swallow errors and it was up to the developer to add `catch` handlers, but this led to a lot of buggy code where programmers forgot to add a `catch` handler or even worse, added a `catch` handler which itself threw an error (these errors must also be caught with another `catch` handler). Best industry practice is now to [crash processes](https://github.com/mcollina/make-promises-safe) when you run into an unhandled promise rejection and always make sure to add `catch` handlers synchronously. &gt; I want to catch as many errors as possible before deploying code to production. I don't think exceptions help me to do that. The road to hell is paved with good intentions. Again, I want to stress how wrong you are about this. If I saw a library that returned `Result` types I would immediately stop looking at the library and consider its author to be either (a) a junior programmer who doesn‚Äôt know what they‚Äôre doing or (b) a senior programmer who adds a bunch of custom babel transforms to a codebase, leaves for a better job, and causes so much technical debt when it turns out the code transforms are a bad idea that future developers have to rewrite the entire codebase in Rust. Either way, not a good look.
 export type These&lt;L, R&gt; = | { type: 'Left'; left: L } | { type: 'Right'; right: R } | { type: 'Both'; left: L; right: R }
Thanks for taking the time to respond. The question of how to handle failing functions has been vexing me so I appreciate the discussion. &gt; Your belief that using a Result type somehow protects you from exceptions is 100% wrong (I really cannot stress how wrong you are) and will only exacerbate production issues. Sorry, I've given you the wrong impression. I'm not trying to extol the virtues of using a `Result` type. Instead I'm finding there are some aspects of exceptions that I find problematic and am seeking better techniques (which may or may not exist). &gt; Networks fail. I/O operations fail. Programmers make mistakes. When this does happen, it‚Äôs better to crash and fail fast. **Programmers make mistakes**, yes, in which case it is better to crash and fail fast. I agree with this 100%. **Networks fail. I/O operations fail**, on the other hand, these are expected failure states. An application should be able to handle these without crashing. (I assume you agree with this.) &gt; If you‚Äôre creating an ad-hoc data structure for exceptions without syntax-level support you‚Äôre setting yourself up for silent failures. That's a really good point. I'll keep that in mind when evaluating alternatives to exceptions. ------ Failure states will occur, when they do, the application can do one of several things: 1. Allow the error to occur and continue running silently. *(Worst possible thing)* 2. Crash, display an error message, write to logs &amp; send error report to developer. 3. Fail at compile time. *(Best possible thing)* Exceptions are a level 2 response to failure states. So, as you suggest, for something to be better than exceptions, it needs to have syntax-level support so the failure state can be detected at compile time. Are there any techniques that can encode failure states into TypeScript's type system so that failure states **must** be accounted for and handled (as in Rust)?
Returning "T|Error" or "\[Error, T\]" doesn't force the function consumer to check the return values which means if the consumer didn't check the return values but the error occurred it will be ignored and the execution flow will go further as nothing bad happened. Ignoring the errors is the worst thing could happen with your program as it normally leads to the system instability and bugs that are hard to spot and debug. So use throw statements since in this case even if the consumer didn't check the exception, which is fine in most of the cases since normally the business logic is not based on the exceptions, the error will still stop the execution flow.
&gt;If I saw a library that returned &gt; &gt;Result &gt; &gt; types I would immediately stop looking at the library I second this, see my other message in this topic.
Wow, thanks a lot. This does it, and is incredibly simple.
&gt; Ignoring the errors is the worst thing could happen with your program as it normally leads to the system instability and bugs that are hard to spot and debug. Yes, I couldn't agree more with this. My beef with exceptions is that they *can* be ignored either intentionally or by mistake. Is there a way to return errors from a function in a way that cannot be ignored? IE: Is there a way to force the developer to account for and handle errors at compile time?
 Programming is important for learning to innovate, create eco-friendly solutions for global problems. It is also important in our daily life to enhance and increase the power of computers and the internet. &amp;#x200B; **Checkout the top programming languages to learn in 2019 are:** **1.** **Python:** The consistency &amp; simplicity make python one of the best readable programming languages. **2.** **Javascript:** This language is popular for link promotions to web pages. It uses elements of C, C++ &amp; java. **3.** **Go:** It is used for the construction of web applications that are invoked by a large number of users. **4.** **R:** It is language for administrative purposes in Unix such as managing files, starting programs, etc. **5.** **Erlang:** It is used for programming tasks that overlap on a single machine or distributed systems.
Thanks! I'm not sure what I'm looking at here. In the constructor, is there an implicit `this._items = _items`? And what's the effect of `as const` in `*items()`?
&gt; Is there a way to return errors from a function in a way that cannot be ignored? There is no such thing in JavaScript. You could try emulating the behavior for example by adding to the function two additional required arguments, "ok" and "error" callback functions but still such thing won't prevent the code to be written and executed after the function call while we need to allow execution flow to be continued in either "ok" or "error" callbacks.
I would valid returning null. "Null" objects or throwing is better. Retuning null puts a burden on the caller and does not allow for error messages to be passed through.
&gt; In the constructor, is there an implicit this._items = _items? Yeah typescript automatically does that. [See this for more info](https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties) &gt; And what's the effect of as const in *items()? The `as const` makes sure that the return type of the function is constant. So if we remove the `as const` the return type would be something like `(k | T[k])[]` and that is not the type we return as we now for certain our type is `[k, T[k]]`. The return type is an array consisting of 2 values, k and T[k]. That means that if we use `as const` the array we return transforms to a [tuple](https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple). For more info about `as const` see [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions).
You can even migrate iteratively by passing your existing express instance as an `ExpressAdapter` parameter (the second argument of `NestFactory.create` is an adapter instance).
What's the use of this? Are there any examples that would be used in the real world? I don't really see any practical application for it. It's rare that you have functions to transform one type to another without actually doing anything with the data.
&gt; There is no such thing in JavaScript. Isn't that the whole point of Result? If you know a function can error, you can return a Result. Then when using the function you would be forced to handle the error (or else you'd get type errors)
Nope, since handling of Result is not enforced by interpreter/compiler in JavaScript as it's in Rust which means it's very easy to miss a need to handle the Result which in many cases will lead to the bugs that are hard to spot and debug. So it's better to go with exceptions in JavaScript. There are lot of fancy articles on the internet about using Result thing in JavaScript, those are written by writers but not by engineers.
I guess you mean if the function doesn't return a value? Yeah agree that's a good point, but I still think it's a good idea to use them when a function can either return a value or an error
Thanks. Any idea why i'd get downvoted for asking a genuine question like this? Is that just the community here?
&gt; I guess you mean if the function doesn't return a value? Even if the function returns a value what in JavaScript stops the developer from ignoring processing the returned value? So in the case of using Result thing if the developer ignores the error by not processing the returned Result, the error will be ignored which would be a very very bad thing to happen. But if you would simply throw an exception the execution flow would still be terminated even if the developer doesn't process the returned value which means it's a preferred way of building robust programs in JavaScript. There is no rocket science here, just a piece of common sense and critical thinking.
Is there an example of this anywhere? I've run into the exact same issue and am having trouble publishing my standalone CRA to npm.
You could also consider returning a promise since promises basically imply that there‚Äôs a success and an error state.
With async/await syntax promise rejections will throw exceptions and exceptions thrown in async functions reject the promise, so it's probably best to resort to raising exceptions.
If you're not doing anything with the value, why would you even call the function? Might be misunderstanding though, would probably be better with a code example where this actually is an issue
If you're not doing anything with the value, why would you even call the function? Might be misunderstanding though, would probably be better with a code example where this actually is an issue
Maybe because people think it's a bad idea and thus down vote to show that?
100% test coverage is not desirable. It can lead to all kinds of issues like testing generated/boilerplate code, testing for the sake of testing, etc. And tests also require maintenance, so yes their is a cost. Tests should be written where they will deliver the most value, which is testing critical business logic. Which in my experience, winds up being somewhere 70% coverage.
Couldn't you make a Tslint rule that ensures it's checked somehow? I haven't written one before but it seems like it should be possible.
I think this might help (from the Haskell article) &gt; if you want a function that creates a list with length n, where all elements are the same value, then that thing should have type Int -&gt; a -&gt; [a], not Int -&gt; Bool -&gt; [Bool]. To be honest I'm still scratching my head because 1 I don't know Haskell and 2 his naming convention is something he probably came up with himself
If you are a former Java user and want a better version, try Kotlin on the backend and Typescript on the frontend. They were created around the same time and have a lot of similar ideas.
Part of the problem is the JVM itself... :-/
FPers live in their own dimension
Memory issues?
 I've read the Haskell article, and i know a bit of Haskell, but i'm still not sure what's this about. The compiler validates you types, and does not allow you to run incorrect code, yeah i get that, but besides that, im totally lost.
You leave holes in your program, the compiler tells you what it wants in the hole, you use what you already have to partially fill the hole, leaving another hole. Iterate until there are no holes.
&gt; It's pragmatic enough to actually get real work done but it's safe enough to scale. Great way to put it!
Just that the JVM itself is a bitch... It's basically a giant elephant metaphorically. Not just memory but also the binary size, install difficulty, upgrade difficulty... etc.
I get that, but it seems that it's only good for boilerplate code, that you should not have anyway. It writes type transformations when you have a target type that can be safely derived from the source type. Basically, it wraps stuff. &amp;#x200B; So how is it actually useful?
because it's yet another glorified band-aid for javascript that still doesn't fix the underlying issues.
TypeScript is called TypeScript because it checks types at compile time.
I feel you man .. I am in love with typescript too! Had been. A java developer previously.
If you want runtime type checking, there are libraries that can help with that: https://github.com/pelotom/runtypes https://github.com/gcanti/io-ts/ Typescript's purpose *is* design-time and compile-time type checking. TypeScript helps reduce the need for runtime type checking because you are ensured, at design time, that data originating in your application (i.e., not as a result of I/O) has the shape you expect it to. If you are building a complex application, this is extremely valuable. If your app is I/O heavy, and you subsequently have a lot of data that you need to validate the shape of, libraries like the above mentioned will facilitate both the run-time and compile-time type checking with minimal effort.
Ok, but for what I need that on compile time I mean interesting it gets on runtime when you consume an api or a user input. I mean if I still have to validate in the userland then why TypeScript. I have a very bad feeling if I get only compile time errors. This fakes the exitence of types. I mean imagine you build a function add(param: number) but on runtime you get a string because it's user input or an api. Then it would not add the number it would concat the string.
Sure, you have to validate all external input. But once you did that, everything else will be fine as is. But I can only repeat what I said: Look up TypeScript. And perhaps if you still insist on wanting more.. choose an alternative.
These libraries are great options, but I'd really just use them for a sanitation layer of external input.
&gt;I mean interesting it gets on runtime when you consume an api or a user input. This case is not specific to TypeScript only. You would have to explicitly validate the data coming form the untrusted source regardless of the type of the programming language used (even if you use Rust/Java/C-like stuff) since the data passed over the internet is basically a set of bytes, the raw data. There are plenty of ready-made TypeScript libraries to validate/serialize/deserialize the data based on schemas, etc. Such kind of libraries also exist and widely used in other programming languages that preserve a type information in runtime.
This looks for what I was searching for: https://codemix.github.io/flow-runtime/#/
Sure, nothing prevents you from building your own validation tool on top of the language.
Correct - that is why I specified validating data originating from I/O as a reason to use them.
The real thing that prompted this post was that I was deep into refactoring code and decided to take a variable and convert it to an array of promises that would need to be resolved. Typescript+tslint completely caught all the errors that would generate and the code was cleaned up in 30 seconds. In JS that would be a major pain and I'd be worried about lingering bugs.
Yes it seems that they compile it for you. If you type hinted a param they inject the needed code in the build. Then I dont need to do it in the userland.
TypeScript actually helps a lot with reducing the chaos. If there is a good balance between script-kiddies and good engineers in the team then there most likely will be no such thing like underlying issues.
I don‚Äôt understand what you mean. This technique can be used for any function you write.
Yep, the ease of refactoring TypeScript is amazing! I often wonder how I lived without it before...
Kotlin follows a bit the same "hands-on" philosophy as typescript. Contrary to other JVM languages, it is a language you will easily get familiar with -- no radical paradigm changes, only big quality of life improvements, and big focus on interop.
It's a tool to assist developers at the time of writing code, not add safety at runtime. There are few languages that provide type safety at runtime.
Interestingly enough, I ran across this. https://1c.wizawu.com/ typescript on the jvm. Haven‚Äôt tried it, but I too really enjoy typescript, but node performance just isn‚Äôt where the jvm , .net , or go is.
Hey all, I'm the CTO at Mercury. We started about 1.5 years ago and have a fairly sizable TypeScript codebase now, a React SPA communicating with a Haskell backend. Open to any questions you might have.
LOL CAN'T READ IT BECAUSE MEDIUM
San Francisco for those wondering.
We‚Äôre also open to US remote for strong candidates
Thanks for the great breakdown, that helps cement the concept in my head.
Have you tried Rust? So nice once you get used to it
Salary range?
Are you 12 years old?
Roughly 125‚Äì170.
Here's the original, NOT death-by-Medium article, free to read. Dunno if this is a ripoff (someone trying to monetize someone else's article) or the same author trying to monetize their own content but... &amp;#x200B; [https://nehalist.io/dependency-injection-in-typescript/](https://nehalist.io/dependency-injection-in-typescript/)
I really wish I could write typescript everywhere
Any reason you're not hiring internationally? Not asking for me, just think you'll see a lot more interest if you're not already. Also I'd advertise the Haskell bit more if there'd be any interaction with it, I think a lot of React devs have an interest in more functional languages like Haskell and Elm.
I'd still prefer an enum. If that hard-coded value has to change (e.g. backend change) you'll either have to insert some new mapping logic somewhere or change that string everywhere in the codebase, whereas with an enum it's one line.
Good point; right tool for the job. But I guess I would argue about the frequency of such cases in a context like discussed in the article. I think if your context instead is that you want to macro a specific value into a variable, and then group those macros together, an enum will be quite clearly the one to go with.
 &gt;Typescript+tslint completely caught all the errors that would generate and the code was cleaned up in 30 seconds. It's almost as if people who invented static type safety 44 years ago knew what they were doing.
I need tech talks to quit trying to be any sort of comedy talk. No one is as funny as they think they are.
I‚Äôd like to hire internationally, but my co-founders say that the operational overhead is too much of a headache for now. We‚Äôre thinking about doing our first international hire for a devops role, where less communication is needed with a designer. That‚Äôs a good idea to advertise Haskell more. So far most of our hiring has been Haskell people, but I didn‚Äôt consider the larger Haskell-curious group.
What do you mean? Doesn't it compile everywhere already?
It depends on what you are doing. For CPU intensive things it isn't. But for non-blocking IO it is usually as good or better. So outside of scientific/machine learning I use it for everything else.
Thanks for the article, can i ask what's wrong with Medium? I've learned a lot from their articles, but that's the extent of my knowledge on the platform.
I did Java before as well, and OOP PHP. Going back to those languages feels like getting a bear to do ballet.
 function flatten(inputArray: nestedArrayOrNumber): number[] { function aux(result: number[], current: nestedArrayOrNumber) { const keys = Object.keys(current); for (const key in keys) { const next = current[key]; if (typeof next === "number") { result.push(next); } else { aux(result, next); } } } const result: number[] = []; aux(result, inputArray); return result; } I've dropped the unnecessary type parameter.
I would do it something [like this](https://typescript-play.js.org/#code/DYUwLgBAdiDOYgCYEEBOqCGBPAXBAcnAiutgDxQCuAtgEYioB8EAvBANoCMANBAEy92AZl4AWQQFZeANkEB2XgA5BATjUBdTZoDcAKF1gsABxAFk+APaIQZACrM2tiAB8CRJGkxY7jPQEsoBFQAMwwAY1NCeA9Sb3sIEAAPBChEWAhPcnxzKxt7ZgBvAF99YMooMLA-CygIYOAMMBSACgCjSjBM3Ddoki8KGnomAEo8KjoGdnUIAt0ICFRwSlRato6ugDpFxEoI5rn5iGbwsJoxwcn1XgCYVDxsy2sBiZHWZgPDjNiNv1gu1qgt2GEAA-BATjQNmEamFGs16o0WjcGMNgXgIdQoTC4cjUMNuB8OOoDsM9CVdNCoLALKANsALABzeENJogKDNGC9LqovRAA). Please note how I did the recursive typings. P.S. Also it's a really bad practice to use \`Function\` type. You would greatly benefit from specifying types of your functions precisely. If you don't now how to type, e.g., array's \`reduce\`, you can just "extract" it using field accessor syntax: ``` type ReduceFn = Array&lt;number&gt;['reduce']; ```
&gt; what if an async fetch call fails? Is it bad practice to make async functions return `Promise&lt;Result&lt;T&gt;&gt;`?
Thanks u/AngularBeginner ! You are everywhere with your helpfulness! &amp;#x200B; Can you speak to why you chose to go with for ... in instead of reduce? I've found typing reduce can be more confusing, is that why?
Thank you so much u/ybogomolov ! This is exactly the sort of thing i was after! Merging the practicality of Array methods with the special recursive type. I will study this and re-implement it for the practice / cementing the concept. &amp;#x200B; Thanks for the advice on avoiding `Function` type, i will keep that in mind. &amp;#x200B; I wasn't aware of the possibility of &amp;#x200B; `type ReduceFn = Array&lt;number&gt;['reduce'];` &amp;#x200B; and will look more into this concept since it looks extremely useful. &amp;#x200B; Appreciate it!
No problem, I was glad to help :) I recommend reading [Advanced types](https://www.typescriptlang.org/docs/handbook/advanced-types.html) section of the TS documentation, if you haven't already. It has a lot of useful tricks which will make anyone a better TS developer.
Thanks it was so helpful and i'm grateful :) I will have to work through that section, i'm sure i'll have follow up questions because lots of this stuff can be daunting to me, but fascinating!
Installation and upgrades are pretty easy (apart from the Java 9 jump). You can also use stuff like jlink to cut down on the application size, or go full in with stuff like quarkus to get a native executable.
This is already a thing (though I don‚Äôt really think it‚Äôs very useful). See \[Promise.allSettled\]([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Promise/allSettled](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)) and if you‚Äôre using Bluebird \[Promise.prototype.reflect\]([http://bluebirdjs.com/docs/api/reflect.html](http://bluebirdjs.com/docs/api/reflect.html)).
I'd resolve them first, then sort: const resolved = await Promise.all(list.map(item =&gt; item.getNormalText())); resolved.sort();
You *must* resolve them first, you can't sort data that aren't there.
The sort function can't be async so I can't use await
100% agree. I rarely find myself explicitly typing return values of functions. It seems like typically it‚Äôs very easy for the compiler to infer return types
This will sort a array of the results from the async functions not my object array. Right ?
I know I think I need too get another sort function.
You could build a sorting collector.
You absolutely can create functions that will determine if a value conforms to a certain type/interface. They're called type guards. [Here is some documentation.](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types) So type guards are cool, however you have to rely on correctly implementing the function, as well as updating it should your type/interface change. This is time consuming and error prone. There are libraries to help with this. One I recently stumbled upon which I like is [runtypes](https://github.com/pelotom/runtypes). It's great because you can define your type/interface and the guard at the same time. You can then use it as a type/interface, and it also provides helper methods to check that a given unknown value conforms. ``` import \* as rt from 'runtypes'; export const Request = rt.Record({ username: rt.String, password: rt.String, }); export type Request = rt.Static&lt;typeof Request&gt;; const myValue = {}; if (!Request.guard(myValue)) { // myValue does not conform to Request } ```
yes, the code I posted would sort the array of results. To sort the original objects, you're going to have to map the original objects to the resolved strings, either by index, some unique ID, or by combining the original objects and their resolved text and sorting the combined objects.
The particular test that's failing is a subtotal of 29.99, I get a 10.00 decimal from db as discount, and then multiply subtotal by discount / 100 (when discount type is percentage). I'm fairly sure that it's the divide by 100 that is breaking things.
Your can't and you shouldn't. Resolve all the data first, then work with it. Also what does getNormalText() do? HTTP call? You should optimise it to have just one HTTP request which will return everything at once.
Checkout flow-runtime. No TS.
This could be useful for you: https://github.com/gcanti/io-ts
Thanks for the rec but just looking for typescript solutions. Which is why I‚Äôm posting this in the typescript subreddit
Thanks for the detailed response and package recommendation. Thats exactly the type of package i was looking for
What's the size of the company/engineering team?
Is there a reason you're expecting $27? 10% of 29.99 is 2.999 which rounded will get you $3. You'd need to floor it for $2.99. Anyways, in detail [here](https://i.imgur.com/ZRPZ2mc.png)
Flow is a sinking ship.
I didn‚Äôt actually run this, but this should be the basic idea that hopefully puts you on the right track. ‚Äò‚Äô‚Äô interface Banana { a: string; b: number; } type propertyType&lt;O, P extends keyof O&gt;= O extends { P: infer T } ? T : never; propertyType&lt;Banana, ‚Äòa‚Äô&gt; // string ‚Äò‚Äô‚Äô
Use a type indexer: `Foo["bar"]`
First resolve all promises, then sort based on the already resolved data.
? It compiles to JavaScript so you can just use node... you can make cli, jobs, migrations, services... Why run on windows when you could run on docker on a Linux box?
Use node for the right purpose, ie a simple API layer. In that case I would bet node is either faster or the same speed as those other languages you mention because the problem is IO bound
Awesome. I just started reading the Blue Book - its clarity and simplicity is so refreshing compared to the complexity of the systems I have to deal with on a day to day basis. Don't you know about a smalltalkish system which persists the object database (or parts of it) in a Git-like, content-indexed, immutable fashion? I was thinking about how distributed development would work in such an image-based system and the push&amp;pull of commit histories between peers looks pretty straightforward.
`Banana["a"]` Much easier and much more efficient.
Wow, that's amazing, I didn't know about this feature. Thanks for the help.
it's just better if it compiles to native code
Very simply: Use the smallest unit. In this case it would be cents. Then you don't have to deal with rounding issues.
You‚Äôre welcome
&gt;Object.values(test1).flatMap(val =&gt; val instanceof Array ? val : \[val\]) Thanks!
And your approach corrected would be: type propertyType&lt;O, P extends keyof O&gt;= O extends { [TP in P]: infer T } ? T : never;
Ah duh! Thanks for showing me not to over complicate things :)
Thanks! I was typing from my phone and figured it may be a little bit off.
Why? If you are IO bound it really doesn‚Äôt matter
I would put the class inside the namespace, then all the constants for that class inside that class. This allows for more logical constants grouping. What if you have a bunch of Plane, Train, and Ship constants? Easy you just declare their classes inside the namespace and within each class, init the constants. For the sake of naming clarity I‚Äôd probably call the namespace VehicleConfiguration or something like that.
Why use namespace for this? Seems a static property in the class will work well for your case (and it's how we'd do in JS as well): ``` export class Car { static Brands = { PORSCHE: 'Porsche', AUDI: 'Audi', SEAT: 'Seat', }; someMethod() { return; } } ```
You don't want Typescript here. Check [ajv](https://github.com/epoberezkin/ajv) which allows you do validate an object against JSON Schema. Bonus is you can use the schema to [create types](https://www.npmjs.com/package/json-schema-to-typescript) so you only need to maintain one source of truth.
Not too popular, but a good approach: https://github.com/paperhive/fefe It's friendlier to use than most classic libraries and it derives TypeScript types from the validation code, so you don‚Äôt need to do the work twice.
Hello! I tried to include a pretty thorough example of my problem. You can find a playground demonstrating the issue here: [https://stackblitz.com/edit/typescript-ktjkzd?file=index.ts](https://stackblitz.com/edit/typescript-ktjkzd?file=index.ts)
I use this approach and I love it
If someone has a way I'm all ears but from my experience and understanding of ts you can't get the type information from this code. Your code is producing the shape of the type at runtime but typescript is statically checking at compile time. If your selector function was only retrieving state from one level deep it *might* be possible to type the return of scopeSelector as something like `U extends State[T]`, or something to that effect. I've done something similarish where I typed specific static string accessors with generics but it probably won't work here since it still would require execution to determine the type at the end.
I'm not sure what your exact use case is but you might like C#. &amp;#x200B; Both were created by the same person and it shows. If you used C# awhile ago but haven't revisited, it's worth going back .NET Core has really shaken the ecosystem up.
I learned DI in C# where you can do constructor injection without having to mark your classes up with attributes/decorators. So I don't really care for container-based DI in TS. I prefer just doing it manually.
&gt; Using {} as any removes any type safety in your reduce function, but you didn't have any in the first place, so I don't feel to bad about it. savage af
Does anyone remember the You Suck At Photoshop guy? "donnie" !? http://www.youtube.com/watch?v=U_X5uR7VC4M&amp;list=PLD19BCF9D57320E03
Straight up, I went back to these yesterday for nostalgia purposes
Wish there was a strong module that didn‚Äôt use decorators. I really like Awilix, and it‚Äôs written in TypeScript, yet container isn‚Äôt typed in any way.
Runtime assertions definitely make sense at the boundaries of your code. You can have perfectly typed code, but as soon as you accept any data from outside of your code, it all goes to hell. Unless you have some form of runtime type checking, all it takes is a single fetch() or JSON.parse() call with untrusted data to ruin your day. However, I wouldn't recommend doing extra runtime checks beyond that. Type things correctly and rely on the compile time stuff doing its job. I wish there were a standard way of dealing with that, but as you've gathered from the other responses, there are instead a great many pet projects in various state of maintenance, and we're left with figuring out the right variation to use for ourselves.
This way they aren't really constants though since they can be easily overridden...
I'm not sure how well that would work in my case. Basically I have multiple constants on that class, and I want to group them based on what they are used for. So it's actually `Class.ConstantGroup.CONSTANT` and not `Namespace.Class.CONSTANT`, if that makes sense.
If you really want them to be readonly, you can annotate them (cleanest compiled output): ```ts const Brands = { PORSCHE: 'Porsche', AUDI: 'Audi', SEAT: 'Seat', }; export class Car { static readonly Brands: Readonly&lt;typeof Brands&gt; = Brands; } ``` Or you can use getters in an object: ```ts export class Car { static readonly Brands = { get PORSCHE() { return 'Porsche' }, get AUDI() { return 'Audi' }, get SEAT() { return 'Seat' }, }; } ``` Or a class with readonly properties: ```ts export class Car { static readonly Brands = class { static readonly PORSCHE= 'Porsche'; static readonly AUDI = 'Audi'; static readonly SEAT = 'Seat'; }; } ```
All great solutions. Thanks! I think I'll go with the first one because it's something new to me. I use readonly quite often for stuff that's not meant to be modified. Better be safe than get stuck with a hard to diagnose bug because someone decided it's a good idea to modify your constant. I don't use readonly for methods (didn't know it's even possible) because if someone really wants to overwrite an instance method with something else, then that really *is* their problem.
In my last (non-typescript) project, I effectively did manual dependency injection -- every function that needed to be able to access the database took in a db parameter as its first argument. The point was that my actual handler/db access code didn't need to know what db it was being run against. The equivalent of my main function could set up the proper db connection for running the server normally, my test code could pass in a separate test db connection, and the rest of my code didn't need to care about what it was connecting to.
The two questions you need to think about are * what does `Foo` do? Does it depend on things you don't control like a Web service or the file system? If `Foo` does depend on things outside your control, then you should use some form of dependency injection. * would it be a problem to do `new Bar(new Foo)`? This is called poor man's dependency injection. It's a form of DI that doesn't require a magic framework. If this doesn't cause a problem, you should use this form of DI.
&gt;So, when should we use dependency injection? When we want loose coupling between our classes. **What is loose coupling?** It's easiest to understand loose coupling when you know what tight coupling is. Your example wihtout dependency injection is an example of a class having tight coupling to another class. import { Foo } from './foo'; export class Bar { // Here, Bar is coupled to a specific Foo class. private foo: Foo = new Foo(); public print(): void { this.foo.print(); } } &gt;Why should we use dependency injection instead of just hard coding? With dependency injection, together with the use of interfaces, you can decouple this code like so: interface Printable { print: () =&gt; void; } class Foo implements Printable { public print(): void { console.log('Foo.print() doing its work.'); } } export class Bar { private _printable: Printable; constructor(printable: Printable) { this._printable = printable; } public print(): void { this._printable.print(); } } This decoupling means that Bar is no longer coupled with a certain class, but can take any implementation of Printable that might exist. Dependency injection helps you maintain the [single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) and facilitates with testing: // example unit test using [jest](https://jestjs.io/) it('should print', () =&gt; { // Arrange const mockPrint = jest.fn(); const mockPrintable = { print: mockPrint }; // Act await new Bar(mockPrintable).print(); // Assert expect(mockPrint.mock.calls.length).toEqual(1); }); &gt;In what scenario should we use it? When you want loose coupling between classes, which is basically always.
I find (automatic) DI very messy and it hides so much. DI stems from Java were the langauge makes you use classes all the time. PHP has gone the same route and i see lots of projects using DI just because.
DI is very often combined with the Strategy-Pattern. Check out this example: [https://ufukhaciogullari.com/blog/strategy-pattern-with-dependency-injection/](https://ufukhaciogullari.com/blog/strategy-pattern-with-dependency-injection/) It's in C# but easy to read and gives a nice overview.
The most clear use is to make mocking easier on tests. You are given a (ugly) way to tap into what is supplied to every component.
designing with inversion of control in mind doesn't mean you have to use a DI container implementation. Although of course, you still might want to use one.
`console.log` is the way to print to the console. Either add a ignore-comment above the call, or disable that rule in your linter. The rule is there so you don't scatter log-calls throughout your code base, but instead have one centralized logging infrastructure.
What kind of linter tool do you use, tslint? If so, disable "no-console" in your tslint config: [https://stackoverflow.com/questions/49990513/tslint-says-calls-to-console-log-are-not-allowed-how-do-i-allow-this](https://stackoverflow.com/questions/49990513/tslint-says-calls-to-console-log-are-not-allowed-how-do-i-allow-this)
Thanks üòä
It's not just Angular, it's TS generally. You can always anycast and overwrite the "readonly" property. If you really want runtime immutability, you need to rely on your old friend `Object.freeze`.
I couldn't think of a worse medium than this.
Check out TypeORM. This is built in.
There are two things I always keep in mind when designing with IoC / DI in mind: * No object should instantiate anything inside itself. All other object instances should be provided via constructor. Of course there are sometimes exceptions, like if these are some utility objects or minor things. But if it's anything of importance, like database connections, services, or other large elements of your app, they should be provided. * Will this make or how do I make testing easier? That is a line of thought that is always running through my head when designing interfaces. How do I design it in such a way, that I can mock/stub it easily for a unit test.
If both endpoints are giving back a Hiscore, I would send it as a generic argument to `api`. That seems to be how you have it typed, and since you aren‚Äôt providing an argument to `api` for `T` it‚Äôs coming back as `unknown` (assuming, haven‚Äôt personally run into this behavior but intuitively it makes sense).
Sure thing, you ignore it :), it worked for me, there could be people like me.
That is true. Good luck.
That makes sense, I have corrected the code to add \`HiScores\` to be an array of \`HiScore\` objects which is what the endpoint actually returns. Unfortunately I am still missing the \`unknown\` so don't think it is optimal yet. Also my \`body\` is still an any. &amp;#x200B; So the code now adds your suggestion, cheers.
Hmm... I have a fetch wrapper that I don't believe exhibits this issue. My response parsing is similar to yours except my return is slightly different: &amp;#x200B; `return (await response.json()) as T;` &amp;#x200B; While typing this reply I decided to paste your code in [TypeScript Playground](https://www.typescriptlang.org/play/index.html#code/JYOwLgpgTgZghgYwgAgBLAM4IPZRQbwChkTSQ4BbCALmQzClAHMBuY0krXG5EAVwoAjaGw4BfQuxKhIsRCnRc8GZBAAekEABMVAQShQ4ATwA8inHgB8yfBI5TkMPiARhg2EMiYQwACj5QADa09IwgTACUtABKEACOfBD0Ng4keGABniAQAO7IsQlJfgGBEaKkdqQOTi5uHsgADtj0-kEhDMwANMiC2FpGtHAgRlH58YnJRBxpPpm8uWOFLSXd+MhUYAAWfbQA5AAKAPIAygAqu929-bQAUseHAHIAdKHMwDBGvlcjyGJlDpUSA44BgjC5HM5XO5PHAGsATKdLL48EswDFxkVRvsoNgKJgIAjrFNpjgQMllE0ySgALzIOA5ODAMCOHwITbIjH0f7TZDvZC+ACEFI8GAgT2wAGsIikeSQtji8tk8gBRAy4DkYSmil5gOAZDCndRgbnTQHIVLIdJzYVUp4AKwwHl80pByGxuPxhPKJDNDnUTSgzJBYIQENq0OQkHoADFWeysTi8aKTAA3bDALREi2k5LeBhJPiBZm0+mMoNwsyYCxJJEWkh53x10i7TZgMANDDUAD0XZTwEDoqgKegLwZTG8UE2fEETxwFC7Dz1myGAFpjsAKBQPDouwAvXGCYAQFdKJJdgCMTwADF288dqxgLk2Ip0LSagTyc8ymvRYhhC8WdIMkydIVuY3AYLWsqNM0fhNiQLZth23a9v2YCDsOUCjnA47QFOM5zguS6ruum7bhge4HkeJ4Phe15dqKYD3twT7QSQazkFQezqJQDSBCgnEQBcdDVrQ55XlevyvtBL5vt6pA5tg-FPIE2BML4ebKAB3Q-mAf4Ae+vxAA), and I can confirm that, without modification, `getresult` and `postresult` both return `Hiscores` types. Am I misunderstanding the issue here?
I added your idea from your original post and updated the code in my post, which does make it work, but I am hoping to use the unknown type and type guards to improve it. I think the fact it assigns the correct type before it has actually got the data is a bit wrong somehow, I was wondering if there was some kind of pattern people are using with the unknown type, as it seems this kind of API fetch function is what the type was created for? Interesting that you have written something similar, care to post it here?
Well when passing the type to the fetch function, you're basically saying that you're assuming the request's response is of that type... If you don't know what type to assume it would be best to type it as unknown, as you suggested, so in this case one has to manually check the response before being able to use it. If you're expecting a type however and something goes wrong during the request, you should then just throw an error. My suggestion would be to use restyped-axios for such endpoints. Just yesterday I wrote a config loader using restyped axios that consumes static json files like a GET API. If you want I can share that example.
&gt;If you're expecting a type however and something goes wrong during the request, you should then just throw an error. Would you do that with an `if` right after the `await fetch`? How deep would you check? I am not familiar with fetch, I thought my `if (!response.ok)` would catch any errors that might lead to a corrupted object? Thanks for the offer of the config loader, but I am keep to use `fetch`. Cheers.
The structured way to think about this is that fetch() gives you back some JSON, but you aren't certain what JSON you got. If you say that api() returns a Hiscores, then the responsibility for figuring out whether that JSON is actually a Hiscores falls within that function. How far to verify the response depends on your app. Maybe you've very sure that it's always in the right form and you can just write "as Hiscores" in there. Or maybe you know that if response.ok then it's the right form, or maybe you wanna check each individual field. Alternatively, api could say that is isn't sure what it got, in which case the proper return type for it is unknown.
Thanks for the help! I think I am maybe conflating two things: 1. My backend code returns the wrong object (due to a bug in logic somewhere) 2. The backend returns corrupted code (due to something happening in transit) I don't know what error checking is done, can I safely assume that if it passes the `!response.ok` it is not corrupted in any way in transfer? I think your final paragraph describes the 'truest' way to do it, but I am not sure if it would have any practical benefits.
It is generally safe to assume that data not get corrupted in transit.
Funny that I get downvoted for telling the truth. For the record, speed !== performance. Compared to the alternatives I mentioned , node performance , IE memory consumption ( amongst other factors) is not onvthe same league, which can be a big factor when paying for cloud services as well. Anyhow, what do I know?
Best thing to do would be to use an interface to define the structure of your expected response (as you've already done). Then have api() return an unknown type and then write yourself a typeguard function for that very interface. You can read more about that here: https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types An example typeguard for your Hiscore interface would be: ``` function isHiscore(obj: unknown): obj is Hiscore { return type(obj) === "object" &amp;&amp; type(obj.name) === "string" &amp;&amp; type(obj.score) === "number"; } ``` Typeguards allow typescript to narrow the type, so if you got an unknown variable and check it with a typeguard, the typescript compiler knows that this variable is of that type from now on. ``` const myobj = await api(...); // api returns unknown // myobj.name would be a compiler error here, because unknown has no properties if (isHiscore(myobj)) { console.log(myobj.name, myobj.score); // accessing name and score works here, because it was confirmed that myobj is - in fact - a Hiscore } ```
Fantastic! I will give that a go.
Lots of good answers. But plenty of apps work just fine without heavy use of di. It can over complicate your code. People mentioned replacing their database, but in practice this is not going to happen and will likely be a pain no matter what (migrating data and so on).
To add to the great comments from these guys. I think DI is especially useful for things that will be switched out e.g. google maps api. Or for stuff that you would not like to run or mock somehow when testing e.g. database calls, https calls, sending an email. You could DI everything this can be very useful when trying to pull apart your app. If you di everything from top down you find your application has kind of like a tree structure of dependencies where the root of the tree might be your main file and then for example users folder only accepts its dependencies and passes further dependencies to like createUser or something. But down side is the app can be cumbersome to set up and develop new features for if you need to pass through everything all the time. I think a middle ground can be reached, this is up to you.
read and watch this [https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html](https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html) [https://www.youtube.com/watch?v=spKM5CyBwJA](https://www.youtube.com/watch?v=spKM5CyBwJA)
I am having problems I am afraid. I am assuming you had a typo and meant `typeof` rather than `type`, and I need to check the returning data from the endpoint is the HiScores array of objects: ``` interface Hiscore { name: string; score: number; } interface Hiscores extends Array&lt;Hiscore&gt; {} function isHiscores(obj: unknown): obj is Hiscores { return ( typeof obj[0] === 'object' &amp;&amp; typeof obj[0].name === 'string' &amp;&amp; typeof obj[0].score === 'number' ); } // ... if (isHiscores(getHiScore)) { console.log(`get top score ${getHiScore[0].name} ${getHiScore[0].score}`); } else console.log(`Error with type guard`); ``` I get the error `Object is of type 'unknown'.ts(2571)` with each `obj` in the typeguard, here is the full code: [playground link](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgBLAM4IPZRQbwChlkQ4BbCALmQzClAHMBuY2nPGkAV3ICNorAL6FCoSLEQp0WXBAzIIAD0ggAJgoCCUKHACeAHhkcIAPmT4RhGNxAIwwbCGSZjcjAApsfAFY1bANYg2ADuIACUNN4+LgpueApEJHhg3FDOHmwkYHoADhDYMMjRANoADAC6yAC8tcgA5NEQ9vXIAGRtWcg5+YXFvuUVAHRklDV19XQMIIytHV09BUWllUOyeOPVDTz80PVs4cKiNnYOTsiMEGAeaQA2NFNMkcgAShAAjtzyYBZsKWnOEAQEKvD5fOg3KC3Q6EKwneyOZy5bB0AwAFVMkPutHoTAANMg+Ng1HoaGjnm9Pt9fskrgDSMDQVSIXcCfhkJQwAALYk0eoABQA8gBlNH1AlEkk0ABSwsFADk1riZsAYHoPJK9OFkEIYVY4Bg9HZkPCzs44LlgOjMXhmWAaJTwWBnvyoNhyJgINaacgcCA6MgEsj-SgtnAQnBgD8YFcEFyPLanTCSKrkB4AIRBpwYCBDbABbVJEjdLlukFAkEAUR0uAT8mDOaVcFSGDRymdrBIVlpqXSgfr2dzPgwTg82oNyFd7s91qOhGUyKgPwNRoQJtsCPOkDoADFY-GXW6PTmDAA3bDANTmIt+gOXMDoYUmGrIcOR5eWzLFi5XL-fhpcmAYC5BgVAAPRgaewBLjmUCntAawRowlxQFy3B8EMODkGB8rNlycAgAAtMKwDkOQTgaGBABe7p8MAECEes8hgQAjEMZRgfeT7uOKXThHiBysGwqYeK4mAmJ496PiY4SFl0t7YLcua3NgjAeAABve3TYLk7ByMgAAk+BScA3F4IMIwUBAQiGcZVzSXIFlMUI6nJjqii3DmvrZopymqRp1ZulAyAhFGXLdHkKCMNwcBQGorlCSQt4-MidAORsYYRlGr6fl0qVgEY4lyJiXQkPUgHAaBEFQTB0DwVAiFwMh0BoRhWE4XhBHEaR5HqBg1G0fRjESax7FgTmYBmRAvH-hYpBWXyygULkSnzZQ4p6ZwyAsWUZQ6gJ378YJwlFKJGDxPIHj5elECyT6SU+UpQwqWppXIOp+XabpTG2ddpkmBZozWb9KIPv9jmrM56kHcWbk2RAnkoApT0vQFNbBaF3IRfkFwxXFCWwkAA) I am not sure having it check `typeof obj[0]` is very accurate either? CHEERS!!
Yes the type() was my fault, been switching languages lately, so when I'm not in my vscode I can get confused. About the obj[0] thingy, I suppose it's the best thing to do. But it depends on your application really. If you're dependent on validity, like in a security relevant application, you should be validating the object deeply. However we're talking about Hiscores here, I suppose your solution would be sufficient. That error probably comes from the fact that you're accessing unknown like an array here before narrowing the type. function isHiscores(obj: unknown): obj is Hiscores { return ( typeof obj === 'array' &amp;&amp; typeof obj[0] === 'object' &amp;&amp; typeof obj[0].name === 'string' &amp;&amp; typeof obj[0].score === 'number' ); } However for one I'm not sure right now how well typescript narrows down the types inside the boolean expression, however if the narrowing works fine, you may still get errors because you're trying to access name and score on a plain object, because as far as typescript is concerned, it has no properties (you're trying to prove it has them, so typescript doesn't know it yet) In this case I think it's best to just declare the obj parameter to be any, so typescript doesn't get you in the way when manually proving the type.
Yeah I know, but I mean in React it's very common practice to use stuff like Redux, whereas in Angular it's not.
Using one of the log methods with level context (debug, info, error, warning) is more proper than raw \`console.log\` calls.
How do you then know which is the appropriate to use in different conditions. For me asides console.log, the only other one I do know how to use is the console.error because that's pretty self explanatory
[https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels](https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels) [https://reflectoring.io/logging-levels/](https://reflectoring.io/logging-levels/) Experienced devs will likely stick to the conventions mentioned in these articles.
Thanks !
Thanks so much for your detailed response! This perfectly answers my question.
Not a single mention of discriminated unions. :-(
Nice article, thanks.
I've got a separate article on DUT's :) https://codewithstyle.info/typescript-discriminated-union-types/
The discriminator should be made `readonly`. const c: CustomerType = Math.random() &gt; 0.5 ? { kind: "individual", firstName: "Bob", lastName: "Builder", socialSecurityNumber: 1234 } : { kind: "institutional", companyName: "Building", companyTaxId: 666 }; c.kind = "institutional";
Since I started building serverless microservices I've moved away from the concept of controllers and instead having separate files for each REST method using the directory structure to define the routes instead. The root url is based on where the service gets mounted by the API gateway.
Personally I prefer this over writing it the express way and for playing around it may be good enough, however for everything else I think you should go with a more tested and used approach like this library: [ts-express-decorators](https://github.com/TypedProject/ts-express-decorators)
Hi, thank you very much for sharing that lib. As I've disclaimed at the end, this was more of a learning exercise/ fun project than anything serious. üòÅ
We use `io-ts` and `io-ts-promise`: - https://github.com/gcanti/io-ts - https://github.com/aeirola/io-ts-promise Check out code samples here: - https://github.com/wemake-services/wemake-vue-template/blob/master/template/client/logic/comments/services/api.ts - https://github.com/wemake-services/wemake-vue-template/blob/master/template/client/logic/comments/models.ts
I currently dislike decorators simply because they require the use of classes, and I avoid classes in TypeScript (due to the gotchas). Gotta wait for decorator support for functions, which is difficult to implement due to the hoisting. :-\
Reminds me of [routing-controllers](https://github.com/typestack/routing-controllers). I use this with nestjs.
Same here, I think Python's decorator implementation is cleaner, it supports anything that you can pass into/return from a function.
I have recently noticed how nicely Typescript's type system plays with a functional style of coding (not to be confused with functional programming. The type keyword reminds me a lot of the data keyword in Haskell.
&gt;We‚Äôre thinking about doing our first international hire for a devops role, where less communication is needed with a designer. Is that mostly a timezone issue then? Would you consider remote workers from Canada for frontend positions?
Cool, but that name is harsh on my tongue.
I've found no compelling reason to use Vue over React. If TypeScript didn't exist, it may be a toss up, but since it does exist and works perfectly with React, it's an open and shut case for me.
Nice, but what are the advantages compared to lodash?
So, like Lodash but not as comprehensive. Oh and a ridiculous name that I'm not sure how to pronounce. I landed on "iter-ree-ree".
Seems cool. Can you use tree shaking? How is the perf when the list is used as a whole. Its rare i use infinite data as a source.
Does lodash support iterators?
You could use an Either monad
Try: declare module 'blob' { function Blob(): any export = Blob }
That partially helps! The Blob constructor is to be used like this `var blob = new Blob(["Hello, world!"], {type: "text/plain;charset=utf-8"});` so I need to pass some options to it I think. &amp;#x200B; Looking at MDN showed the constructor like [this](https://developer.mozilla.org/en-US/docs/Web/API/Blob#Constructor) but changing the file to look like this `declare module 'blob' {` `function Blob(blobParts[, options]): any` `export = Blob` `}` still gives me an error in my code: `Argument of type '{ type: string; }' is not assignable to parameter of type '[any, any]'. Object literal may only specify known properties, and 'type' does not exist in type '[any, any]'.`
I believe you just need to add "dom" in your lib tsconfig.json ``` "lib": \[ "esnext", "dom", "dom.iterable", "scripthost" \] ``` Or you can copy paste the definition from there" [https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts](https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts) ``` /** A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system. */ interface Blob { readonly size: number; readonly type: string; slice(start?: number, end?: number, contentType?: string): Blob; } declare var Blob: { prototype: Blob; new(blobParts?: BlobPart[], options?: BlobPropertyBag): Blob; }; interface BlobPropertyBag { endings?: EndingType; type?: string; } type EndingType = "transparent" | "native"; ```
After adding your snippet to my `tsconfig.json` I got the same error as before. I created a `lib.dom.d.ts` file and filled it with the contents above and still received this error when the line using Blob was called `ReferenceError: Blob is not defined`
you should only need to do "lib": [ "esnext", "dom" ] in your `tsconfig.json` and then remove the import of blob. If that doesn't work can you set up a minimal repo?
Seems very similar to [wu.js](https://fitzgen.github.io/wu.js/). It looks like these two libraries coincidentally have the same API. They both work on ES6 iterables.
What are the main differences in TypeScript usages with Vue and React?
Night need more info into your project setup because the first one should do the trick. That said I guess different build system might redefine how ts is launched. If it's a simple TS file try `ts --lib ESnext,DOM,DOM.Iterable,ScriptHost &lt;filename&gt;` and see what happens.
My tsconfig currently looks like this ``` { "compilerOptions": { "target": "es6", "module": "commonjs", "outDir": "dist", "removeComments": true, "strict": true, "skipLibCheck": true, "strictNullChecks": false, "noImplicitThis": true, "inlineSourceMap": true, "esModuleInterop": true, "moduleResolution": "node", "lib": [ "esnext", "webworker", "dom", "dom.iterable", "scripthost" ] }, "include": [ "src" ], "exclude": [ "node_modules" ] } ``` which gave me the previous results.
Don't know what to tell you other than there's something wrong first "target es6" as you have it should include the lib dom by default so there's no need to add them to lib. Btw, if you're targeting es6 you should probably not add "esnext" to the libs. If the setup is correct there's no need to import anything. Just `new Blob(stuff, mimetype)` should work. As /u/DanMister said, try to create a minimum repo that reproduce your issue.
**FUCK OFF WITH YOUR STOLEN CONTENT!**
Compared to lodash, itiriri works with native iterators and has a deffered execution.
itiriri covers almost entirely the API of native JS functions for arrays plus a few additional methods.
If it's infinite, then you can't use it as a whole. It's as simple as that.
What i ment was the perf always uses n first elements, thats why the perf if consistant. But how about when using the entire (non infinite) list of 200.000 items. I recon its slower or has the same perf as vanilla js.
It's a trade-off. Allocating an array of 200.000 items takes a while and takes a big chunk of the memory.
I thought so, but apparently only partially. There's also lazyjs and wu.js which do support them.
/u/vexator &amp; /u/Bartvds please ban this shit
I set up a minimal repo with the idea of how my app is structured. [https://github.com/panpanick/type\_blob](https://github.com/panpanick/type_blob)
This works fine for me with tsc 3.1.3 ``` { "compilerOptions": { "target": "es6", "module": "commonjs", "outDir": "dist", "removeComments": true, "strict": true, "skipLibCheck": true, "strictNullChecks": false, "noImplicitThis": true, "inlineSourceMap": true, "esModuleInterop": true, "moduleResolution": "node", "lib": [ "es6", "webworker", "dom", "dom.iterable", "scripthost" ] }, "include": [ "src" ], "exclude": [ "node_modules" ] } ```
You posted this repo: https://github.com/panpanick/type_blob In the readme you write: `and then run with node dist/` And that is your issue. You run your code with NodeJS, and NodeJS does not have a `Blob` type. Blobs are only available in the browser context, which is why the suggestions was to add the `dom` library. But that will not work in a NodeJS application, because you don't have a DOM. In NodeJS you use (Buffer)[https://nodejs.org/api/buffer.html] instead.
He's running a NodeJS application, and NodeJS does not have a `Blob` type. And adding the `dom` library is not applicable in a NodeJS app.
More details in the answers on [this SO question](https://stackoverflow.com/questions/53637644/how-do-i-create-a-blob-in-node-js), in case it helps. The npm package `blob` does exist but I believe it still doesn't actually add a working Blob class to Node.
Good point.
Yeah as others said, Blob only exists in the web API I assumed the node blob module did what you wanted.
Did you get the `ReferenceError` when you ran the code? If so it is because `Blob` is not available in Node, only in browsers. Changing the Typescript configuration will only help with compile-time type errors. There is no configuration change that will make `Blob` work if it is not defined in your environment.
Okay, so I turned the object into a Buffer like this `let bb = Buffer.from(JSON.stringify(full_db, null, 2), "utf-8");` How would I save that since file-saver only works with blobs?
Use a different library. If the file saver library requires the usage of blobs, then it's not usable in NodeJS.
I used \`fs\` and that took care of it now.
It would love to have TypeScript compiling to .NET Framework. C# has similar ideas, but I like TypeScript even more.
React JSX has full type safety using TypeScript .tsx files. This means that when you pass props to a component, they are type checked just like anything. This is a very powerful way of writing UI components. Creating and refactoring complex UIs becomes much easier and safer.
what is the error reported? As it‚Äôs underlining the line, you should get one.
It's because the type of `myObj` is not technically the same as `MyMainType`. Even though they look identical, maybe your myObj was declared with that value as a similar type that also had another optional property that you didn't define. That would be allowed on your `myObj` declaration, but it would not be the same type as your `processMainType` function accepts. This is the reason you want to explicitly type it in this scenario, and the reason why that fixes it, it's by design and not a bad thing. If you still want to force your way around it, I imagine there's probably some way, but the best I can offer is the explanation as to why it's technically working correctly.
I don't think there is. &amp;#x200B; [https://github.com/Microsoft/TypeScript/issues/22679](https://github.com/Microsoft/TypeScript/issues/22679) [https://www.reddit.com/r/typescript/comments/a6fig7/narrowing\_type\_of\_a\_literal\_tuple/](https://www.reddit.com/r/typescript/comments/a6fig7/narrowing_type_of_a_literal_tuple/) &amp;#x200B; But as suggested in the last link you could write a tiny wrapper function. const range = tuple('1/1/20','1/5/20');
Here's a minimal reproduction. ``` type StringTuple = [string]; let typed: StringTuple = ['foo']; // works let arr = ['foo']; let fail: StringTuple = arr; // fails ``` The problem is that array literals are never inferred to have a tuple type. So your date range is inferred to have a type of `string[]`.
&gt;o why it's working correctly. Here's the message it gives.
Argument of type '{ propName: { numberProp: number; range: string\[\]; }; }' is not assignable to parameter of type 'myMainType'. Types of property 'propName' are incompatible. Type '{ numberProp: number; range: string\[\]; }' is not assignable to type 'myType'. Types of property 'range' are incompatible. Type 'string\[\]' is not assignable to type '\[string | number | Date, string | number | Date\]'. Property '0' is missing in type 'string\[\]'.
Thank you for the input.
Oh, that makes sense.. in my example, if the function is called like so: ``` processMainType({ propName:{ range:['1/1/20','1/5/20'] } }); ``` It also works. But I guess if the object is declared as the argument, it automatically takes on the argument type, so no error. Thank you!
Basically Typescript compiler is inferring `range` value as `string[]` instead of what you declared as `myType`. I have a question. Do you expect each member of `myType` to be the same or you can combine types? ie. Is `[string, number]` legit?
Right. I suppose based on the definition each value could be different and any of those 3 types at the same time.
``` declare interface myType { range?: readonly [(number | string | Date), (number | string | Date)]; } declare interface myMainType { propName?: myType; } function processMainType(arg1: myMainType) { return; } const myObj = { propName: { range: ['1/1/20', '1/5/20'], }, } as const; processMainType(myObj); ```
That's interesting. Nice! making it a const works too.
To save people loading a spam blog, is it something worth reading else where?
`myType.range` should be `Array&lt;...&gt;` instead of a tuple (`[...]`)
For some reason, it's more of a brain bend to write TSX than it is to slap directives into plain html templates in my experience from trying to teach colleagues. &amp;#x200B; VueJS has TSX support out of the box it's just poorly documented, with 3.0 being written from scratch in typescript it should have all of the benefits of typescript with more batteries included than react.
in Vue 2.0 typescript has to be wrangled to work 100% React has become so popular that the typescript team, react team and co-operating ides like vscode all have really nice integration with each other. Vue 3.0 will be re-written in typescript so its gonna work way nicer
Those are basic questions. It would be more advanced if you would ask to implement `Omit` type, not just name its purpose. Or implement `Arguments` type which will extract the arguments of the function, etc.
The example for question 4 is wrong. [Here is the correct solution.](https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAQwCaoBQA8BciDOUATjGAOYA0iAnnoSeQJR3GlkDcAUKJLAiumx4wIALYAjAKZEqtRCInTm8sVKJce0eEjSZcKMNVl5kh5aeqIA3p0SIikqCCJIsiANQ0uAXyA)
Possibly adding an `as const` on your array literal might work.
&gt; For some reason, it's more of a brain bend to write TSX than it is to slap directives into plain html templates in my experience from trying to teach colleagues. I don't disagree with this, especially if your colleagues have been doing Backbone/KnockoutJS/Angular/basically any other traditional data-binding framework that exists. With that background, data-binding to an HTML template string feels like The Right Way and "separation of concerns." This was my view for a while. If you can get over the hump of "this JSX thing seems weird", it's just not really something where you can go back. Working with unsafe string templates that often fail silently or mysteriously, are hard to debug, and are very difficult to refactor safely, would be very tough to go back to for me.
My medium quota has exceeded. Please post friend link.
This. It feels like React is closer to "just javascript" (/typescript) and less magic than Vue (especially after reading [WTF is JSX](https://jasonformat.com/wtf-is-jsx/)). (Nothing against Vue!)
yeah, I have to wear both hats quite often but it is a real pain to only have runtime validation on components. Vue cli comes with a nice compiler plugin for webpack, it doesn't do types but it does help for misc errors, its not often when I cannot place a breakpoint and look at why something isn't working when you use the full ecosystem
Or ask when it would be appropriate to use the feature, optionally describing what it is first if not known. I don't so much care if they haven't heard of a new feature yet. But if, once described, they can come up with a decent use case, that shows comprehension of concepts rather than how much you read all the latest patch notes.
Honestly these are awful questions. &amp;#x200B; I've said this same thing before in response to similar articles, but anything that is a binary correct/incorrect "quiz" type of question is just not useful in an interview. &amp;#x200B; You ask them these basic questions and either they know the (completely, 100% google-able) fact/answer, or they don't. Great. Now what have you learned about the candidate? Basically nothing other than what facts they know. About a LANGUAGE. That's like trying to find a great author for a book and you ask them if they've seen these 10 random words before. Good software engineers use code to solve problems... you need to find people who are good at solving problems, that understand your domain, and are able to work well with the team and communicate openly and empathetically. Good engineering is a dynamic process, it is not a grade-skill subject where your effectiveness is boiled down to how many check marks the teacher gives you on a spelling test. &amp;#x200B; If an interviewer asked me questions along these lines, I'd consider it a huge contra-indicator of compatibility for me. &amp;#x200B; If THE MOST important thing you're looking for is "somebody who is good at Typescript", then your values and hiring culture are way off. &amp;#x200B; If you are really stuck on trying to ask Typescript questions for some reason, better generic questions / conversations would look like this: &amp;#x200B; * What are some of your favorite features of TS? Least favorite? * What are some interesting challenges/problems you've had in typing complex patterns in TS? * What value do you feel TS brings to the table over vanilla JS? * What is your experience/opinions on TS tooling? * What are some of the challenges you've had in introducing TS to older projects? To other devs without previous TS experience? * How do you handle boundaries between untyped data and typed code? &amp;#x200B; etc.
Thanks for that. I thought I was getting dumber and/or going crazy lol.
As far as I understood this was impossible in Typescript.
Also....
Is this in the map or used to emit jsdoc?
It's possible only if you emit meta data and use decorators. It's how popular decorator libs work with type injection.
Oh I see, so even for a primitive type alias, if you create a class with the same name, a reference to the class is saved in the metadata?
Except creating the class... you need to assign the class to a const then add a type of the same name.
Right... but complex types don't usually work this way. This does not work: \`\`\` class A { @f() method(a: string | number): string | number{ return a; } } \`\`\` &amp;#x200B; \`string | number\` gets serialized to \`Object\`. What I posted is a way to serialize complex types. What I'm not sure is if this is a feature, a hack, or a bug.
Not sure what you mean... what this is (I think) is a way to trick the compile to emit metadata for types that are more complex than prims and classes. See here: [http://blog.wolksoftware.com/decorators-metadata-reflection-in-typescript-from-novice-to-expert-part-4#4-complex-types-serialization\_1](http://blog.wolksoftware.com/decorators-metadata-reflection-in-typescript-from-novice-to-expert-part-4#4-complex-types-serialization_1)
Interesting, looks like the value's type just needs to have a `new ()` signature. You could even do some type hackery so that any value would be stored in the metadata.
You're right! This shouldn't work!!! &amp;#x200B; \`\`\` interface Constructor { new (): void; } let StringOrNumber: Constructor = 'string | number' as any; type StringOrNumber = string | number; class A { @f() method(a: StringOrNumber): StringOrNumber { return a; } } \`\`\`
It doesn't look like this encodes anything about the `type` you've defined though. Just the name... Which sounds more like the class....
Right, you need to encode the type in the constant. One example: ``` interface Constructor { new (): void; } const StringOrNumber: Constructor = 'string | number' as any; type StringOrNumber = string | number; class A { @f() method(a: StringOrNumber): StringOrNumber { return a; } } ```
The metadata emit is considered a mistake by the dev team and has limitations. Support for the existing won't be removed, but it won't be developed and the issues (like lack of union support) will not be addressed. I would not make use of or rely on emitter metadata.
Using https://github.com/pelotom/runtypes: ``` import { String, Number, Static } from 'runtypes'; const StringOrNumber = String.Or(Number) as unknown as ObjectConstructor; type StringOrNumber = Static&lt;typeof StringOrNumber&gt;; console.log(StringOrNumber); class A { @f() method(a: StringOrNumber): StringOrNumber { return a; } } ``` The metadata will include the constant StringOrNumber which can be used as a runtime type guard.
If they remove it Angular will be in trouble... &amp;#x200B; Here is an example emitting metadata for a union: [https://repl.it/@Hypercubed/Complex-type-serialization-in-TS](https://repl.it/@Hypercubed/Complex-type-serialization-in-TS)
One more example: [https://repl.it/@Hypercubed/Complex-type-serialization-in-TS](https://repl.it/@Hypercubed/Complex-type-serialization-in-TS)
If they remove it, the Angular team will do what they do already: Hack shit together. That's also the reason why Angular has a tight limitation on the TypeScript version you can use. You can't just use the latest. And frankly: Who cares. Angular is a poor framework, and it makes **very** bad use of TypeScript.
Or ask about the **gotchas** of TypeScript, e.g. why you should not spread a `Partial&lt;T&gt;` together with a `T` object.
The article is really not worth it. Poor questions.
What is the name of this plugin?
It's wrapped into the @vue/cli-service and I haven't looked deeper as of yet. The vue cli is great, the only thing it does wrong is version numbers :P
Have you seen [typed-inject](https://github.com/nicojs/typed-inject)? It has compile-time safety for dependency injection and the implementation is just [one file](https://github.com/nicojs/typed-inject/blob/master/src/InjectorImpl.ts).
Didn‚Äôt expect this to link to a spreadsheet
For those who don't like spreadsheets
sorry, couldn't attach images
For those who don't like spreadsheets [https://imgur.com/a/nOOaIwW](https://imgur.com/a/nOOaIwW)
I love typescript and it's the best thing that happened to web
Typescript has been a boon to much more than just web.
Of the spreadsheet... A graph would be more useful.
Did you look at the 2nd pic?
On mobile (Apollo) your album only contains one image.
Sorry I don't have app installed. Please use browser
no u
It's surprising! All of my beloved languages are at top. I hope that some day browsers support typescript natively.
Started self learning Web development approx. 5 months ago so I‚Äôm still beginner level but should I also start learning TS soon? Or just save that problem for another time down the road?
Do you have a list of any good typescript resources, explanations, etc?
Why are issues a good metric?
TypeScript is easy to pick up but I wouldn't recommend it unless you have a solid foundation with JavaScript and the problems that TypeScript aims to solve. How familiar are you with OOP in JS (classes, pseudo-classical classes, functional classes, etc)?
Yeah makes sense. I do understand OOP and the theories/syntax because I‚Äôve done a couple Udemy courses using those. But then again, it was just coding along with the instructor so if I were thrown into an OOP test I‚Äôd prob be stumped. So I guess I don‚Äôt really have a solid grip on it yet. Would you suggest learning TypeScript let‚Äôs say, after understanding JS and React a bit more? Reading all these posts gives me anxiety because there‚Äôs so much to learn and if I don‚Äôt learn TypeScript soon will I fall behind?
You will be fine and there will always be more to learn. Just master your first language and framework first before peering beyond the horizon of those. If you become proficient in a front end framework, you will be ready to learn typescript and typescript will be easy to learn. If you focus on React, I would highly recommend using [AirBnB's style guidelines](https://github.com/airbnb/javascript/tree/master/react) with a linter. It will force you to declare the shape and types of your props, which will introduce you to the TypeScript workflow. But regardless, you will have a big 'aha moment' once you become strong in modern JavaScript. Keep at it and enjoy the process!
Def appreciate the feedback and reassurance! I‚Äôll take a look at the BnB guidelines once I have a better grasp of React and go from there Cheers
Looks like the big growers are TS, Rust and Kotlin. Rust and Kotlin have pretty low absolute numbers so there is a \*lot\* of room for fast growth. TS otoh seems on trajectory to pass Ruby soon
Thank you for the suggestion. I tried to compare it to my injector but i think it is missing an important feature. The library is using a single instance each time a type/class is injected and it seems there is no possibility to configure that behavior. Also i don't like adding a static filed to my class, i'd rather fail early at run time with a descriptive message.
Link is not working üôÅ
Huh? What about this one --&gt; https://itnext.io/how-to-create-your-own-typescript-cli-with-node-js-1faf7095ef89
Don't bother with it - I'm assuming you don't have a background in an OO language like C#/Java so the familiarity factor also won't be there and the value added at the beginner level is not there. Once you start working in a team or on real projects then consider learning TS (people will probably be using it) - at that point it will be easier to pick up (you should know more about JS by then) and the benefits will be more apparent.
I think there was a babel plugin or similar to do that at some point (it ran babel directly in the browser by including a script before your real script)
What are the gotchas? Do you just stick to strictly FP in typescript then?
&gt; What are the gotchas? https://www.reddit.com/r/typescript/comments/c39fbq/trying_to_dig_more_deep_into_interface/erph87w/ &gt; Do you just stick to strictly FP in typescript then? Yes. I find it personally **way** easier to understand as well. I keep my data structures readonly, and functions pure (as much as possible). I can easily follow the flow of data and don't have mutable state flying around in various objects that can change at any time.
I think you should take a step back and consider what ts-node does. ts-node creates a temporary directory, compiles your typescript to javascript, and then runs the javascript with node. There is nothing else magical happening. So in other words, if you want to run TypeScript you will ultimately always be compiling it down to JavaScript first. The important thing to consider is which version of JavaScript you want to target, since that will determine compatibility with some older browsers.
iirc it just compiles code in memory. but yes, it compiles the code before running the code.
No.
&gt;Looks like people are having problems with it Which isn't surprising given the (probable) complexity of doing that and the ultimate pointlessness (IMHO)
I‚Äôm pretty sure there is a hidden directory created, why would you keep everything in memory? That doesn‚Äôt really make sense.
I care only **what** it does - the end result - it runs TypeScript. **How** exactly it does it - by compiling it in tmp directory or with magic dust - doesn't matter.
That's sounds pretty much the same as webpack pipeline. I don't want to do that step, I just want to write something like code below and it should somehow work without me doing babel or webpack stuff. &amp;#x200B; &gt;// index.html &gt; &gt;&lt;script src="/some-magical-type-script-loader.js"/&gt; &gt; &gt;&lt;script src="/main.ts"/&gt; &amp;#x200B; &gt;// main.ts &gt; &gt;import { something } from './somewhere.ts' &gt; &gt; &gt; &gt;something()
What's the point of slowing this down by repeatedly writing to file system for every compilation? Caching compilation in memory works just fine. That's exactly what webpack has been doing for ages. Sure, caching to disk will make the next startup faster, but it's also tricky to handle. Also there's literally no call to fs.writeFile in `ts-node` codebase, but ok.
`tsc . &amp;&amp; chrome index.html`
While I am not aware of such a tool, it should certainly be possible, given that TS compiler itself runs in browser (e.g. in the playground).
Here's a good link https://basarat.gitbooks.io/typescript/content/docs/why-typescript.html
You already have your end result‚Äîbabel and webpack will run TypeScript. The browser doesn‚Äôt support TypeScript, it supports JavaScript. So if you want to use TypeScript for an environment that doesn‚Äôt support it then it‚Äôs your responsibility to take care of the compilation step, not the browsers,
That's literally what I mean - you just add `&lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt;` to the html then everything below that with `&lt;script type="text/babel"&gt;` is transpiled. But like I said, looks like it doesn't work for TS currently
Actually, I just tried it, it works fine. Note that babel doesn't do type checking though - which is fine if you're using an IDE anyways but maybe not otherwise.
As an alternative (for small projects), I can recommend [parcel](https://parceljs.org/). It's similar to webpack, but actually zero conf. So if you have `&lt;script src=hello.ts&gt;` in your index.html and run `parcel index.html` it will just work.
They did actually cache everything to `/tmp/ts-node*` before but stopped around version 7 or so. (because apparently the invalidation was not always correct)
If you can get the typescript compiler to run in a browser then you could do something like this https://jsbin.com/qalayeline/edit?html,js,console. That's just a proof of concept with a very basic compiler that just strips type annotations naively. I can't find any project that does this already with a quick google search. The trickiest part would be bundling - in your example the `import ... from './lib.ts'` would need to be resolved somehow and transpiled before being executed.
Assuming you only care about calls in your application then you can just import it, wrap it, export it and replace all imports in your application code with this new export? If you want to intercept calls from within node_module dependencies then you can use your bundler / resolver and add an alias for this module to resolve to your wrapper, then in your wrapper export it with a relative path to the actual node module (in order that it isn‚Äôt replaced as well and creates a circular dependency on itself).
I re-read and it was just the function rather than the module you wanted to replace, you could still do it with a wrapper (and re-export all the other functions from it). However, I‚Äôm not sure you could do anything that was transparent (like you could when aliasing a whole module).
I re-read and it was just the function rather than the module you wanted to replace, you could still do it with a wrapper (and re-export all the other functions from it). However, I‚Äôm not sure you could do anything that was transparent (like you could when aliasing a whole module).
If you find a decent typescript course, you can learn that and pick up regular JS through osmosis. You'll just end up omitting things on non typescript projects as opposed to learning to add things in all over the place. The issue otherwise if you learn while having made progress in JS but not being established with classes and the DOM is you won't be able to practice what you learn while you're still learning it. Without having to learn the new thing AND how that works with types. So my suggestion would be to look for a typescript course that teaches it like a first programming language.
Thanks for the suggestions! Yeah, really I wanted to be able to do it as transparently as possible - i.e. include a file/module or something in the build, perhaps tied to a particular environment setup and then have it use the wrapper without having to change any of the main code. &amp;#x200B; I am still getting my head around optimally writing ngrx code and one thing I found useful was to log all calls to the reducers + selectors - this helped me see that my selectors were being re-executed more often than necessary because my state/reducer setup was sub-optimal. It took me ages to add all the logs in manually so I was hoping I might be able to reproduce it by proxying the creation/execution of the selector projection functions with some logging/other stuff as well as capture the reducers updating the state.
The TypeScript module augmentation you are talking about is only for augmenting the TYPES of a module, NOT the actual code. An example of what I mean from my own code base: I use module augmentation to overwrite the type declaration of react-redux's Connect function, to append a non-existent return property to let me access the type of the properties added by the connect wrapper (It's weird, but why I do it doesn't really matter to this discussion) interface ConnectReturn&lt;P&gt; { (TElement): any; props: P &amp; GlobalProps; } declare module 'react-redux' { export interface Connect { &lt;P, A&gt;(mapStateToProps?: (state: GlobalState, ownProps?: any) =&gt; P, mapDispatchToProps?: A): ConnectReturn&lt;P &amp; A&gt;; } } There is NOTHING inside the declare module code that actually makes any changes to the generated code. Nothing that impacts the Connect function at runtime. It is purely type augmentation. As others have already mentioned, what you are looking to do is not to augment the type of the module, but to change the actual code. You wouldn't go manually edit the module inside your node_modules folder, so there's no way to do that. What you should do is follow the already given advice and write your own wrapper function to add your desired functionality.
First, you don't need to use webpack to compile typescript. Just run `tsc .` and it should do the job. Of your javascript to run on browsers and call others files like the `import { sayHi } from './lib.ts'` line you did there, you need just need to set this config options: // tsconfig.json { "compilerOptions": { "target": "es6", "moduleResolution": "node", //... } } And call your script like this: &lt;script src="./main.js" type="module"&gt;&lt;/script&gt; Oh, and use the typescript compiler in watcher mode if you want to press F5 and see the modification already there. I made something like this here: [https://glitch.com/edit/#!/pika-web-ts-preact](https://glitch.com/edit/#!/pika-web-ts-preact)
The alternative if you just want to do it while debugging is just go and change it in the node_module or use something like https://www.npmjs.com/package/patch-package to do it more programmatically in your dev environment.
The alternative if you just want to do it while debugging is just go and change it in the node_module or use something like https://www.npmjs.com/package/patch-package to do it more programmatically in your dev environment.
&gt; Rust mitigates this problem by forcing all Result types to be used but no such guarantees can be made in typescript. Why is that? Results implemented as discriminated unions behave exactly like this (types have to be narrowed via if clauses or an exhaustive switch function) https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions io-ts is an rather useful (and popular?) library that is built on Either/Result types.
There are some cases where compilation of TypeScript within the browser is something you want.
This is interesting. Here is a [playground](http://www.typescriptlang.org/play/#code/C4TwDgpgBAqmAmBDYEBOAeAKgPigXigApgAuKTASn1wDcB7AS3gG4AoVgMwFcA7AY2AM6PKH1QRkEOEhQYcxMpTIBtTABpYCSXOwBdKAG9WUE1HHAuqEcuAbu-QcMI8IAd0yKqBgL67W39gYeWQ5EPmgAZWBJQ2NTGkQAGy4IMh4uAFsAIzQ2UyggsQgMiGCyQngIROi0zJzUKjxaRhY4k0qikrKiSurEWuy0RuamNgDWPmEAZ2AoZRnJDSmIYCjJfQIiyWltdDWUbEIjfITk1KgAJjU2gv5xLtIoXujqKGXV6JQjm-yAOn+FihrvkTkkUmRARBfqcUlAANRPKrRG7eCjA0wde6lR7PRCvd77CDfEGmf6-SHokkw86Q6Fg6AAWkRfRRFH8bIm01m80+ECubxWhIuuhUhI0O1ke15enwonE2y0ksJh2O8XpZCuN0KWO6uPxgt5xJJUDJFJ+arOEN5dLO8OZyPyqMpiM62LIeqaAo+kiNJNNvOdoMtb2t1KgTNxrPZ7EmPBmc0hAGYlgbJImNnKJCgJWgpZIVTdqRrndrim77XjPQTDaq-QCA+aTEWQ5IbbCEZHHWibpiy7qkZXcD52UA) which repros what you're seeing without React. In case this is a bug, this repro is easier to reason with than a React app. I don't know why you can get away with referencing `setState` once but not twice. But you can work around it by typing the array (see the second usage in the playground).
In the object you pass to `React.useState` as the initial state you reference the `setState` function that is returned by the `React.useState` call. The type of the returned function depends on the initial state you pass to `React.useState`. The logical consequence is that the type of `setState` is not known yet when creating your initial state. I'm not up to date with the React hooks, but I think your state is not really supposed to contain callbacks. Is this really necessary As an alternate approach you could write your own hook, which returns the current state, as well as the `addItem`, `removeItem` and `toggleItem` functions. You would call it something like: `const [state, addItem, removeItem, toggleItem] = yourHook([] /* initial items */);`
&gt; I'm not up to date with the React hooks, but I think your state is not really supposed to contain callbacks. Is this really necessary &gt; I believe this is the recommended way to update React's Context via deeply nested components. [Source](https://reactjs.org/docs/context.html#updating-context-from-a-nested-component) from the React docs. Interesting idea on the custom hook, thank you for chiming in!
Thank you for exploring further and providing a solution!! Do you think this is worth raising on the TypeScript github? Would you be willing to do so? You clearly know a bit more about TS than I do.
I think you should raise it, as you found it and it's impacting you more. If you do, please link to the issue here.
As user tortus mentioned above, this type error can be reproduced outside of React. Why do you suppose the first examples gets past the `noImplicitAny` linter? This is a fairly normal pattern in React, and I've never had issues when only using one function inside `state` to call `setState` (which I've done for months now) - but now that I've introduced a second or third function, everything is breaking down. I expected TypeScript to be able to understand the circular reference in the same way that you can make interfaces like this: ``` interface INode { guid: string; nodes?: INode[]; };
I don't know why it slips past the compiler (not the linter). I suppose it is because you don't declare an `any` typed variable yourself, but rather the returned values type is `any`. I was wrong about not storing callbacks in the React state. :-) In all examples of /u/tortus the `setState` value has the type `any` as well.
Your example is buggy. In your second and third example you reference `setState`, instead of `setState2` and `setState3`. Your third example behaves the same as the first one if you fix this.
&gt;In all examples of /u/tortus the setState value has the type any as well. Perhaps I'm misunderstanding, but when I hover over `setState` in the examples he provided, they have the type of `Updater&lt;State&gt;` rather than `any`? Thanks again for your response. I want to get this right as I'm considering raising an issue on the Microsoft TypeScript github along the lines of "Inconsistent implicit any with array destructuring" but I don't want to cause extra (unnecessary?) work for way smarter people than myself.
&gt; Perhaps I'm misunderstanding, but when I hover over setState in the examples he provided, they have the type of Updater&lt;State&gt; rather than any? His example was buggy. He referenced `state` and `setState` in his second and third example, insteadf of `state2/3` and `setState2/3`. And in the fixed version only `setState2` is properly typed, because it's explicit. [fixed version](http://www.typescriptlang.org/play/#code/C4TwDgpgBAqmAmBDYEBOAeAKgPigXigApgAuKTASn1wDcB7AS3gG4AoVgMwFcA7AY2AM6PKH1QRkEOEhQYcxMpTIBtTABpYCSXOwBdKAG9WUE1HHAuqEcuAbu-QcMI8IAd0yKqBgL67W39gYeWQ5EPmgAZWBJQ2NTGkQAGy4IMh4uAFsAIzQ2UyggsQgMiGCyQngIROi0zJzUKjxaRhY4k0qikrKiSurEWuy0RuamNgDWPmEAZ2AoZRnJDSmIYCjJfQIiyWltdDWUbEIjfITk1KgAJjU2gv5xLtIoXujqKGXV6JQjm-yAOn+FihrvkTkkUmRARBfqcUlAANRPKrRG7eCjA0wde6lR7PRCvd77CDfEGmf6-SHokkw86Q6Fg6AAWkRfRRFH8bIm01m80+ECubxWhIuuhUhI0O1ke15enwonE2y0ksJh2O8XpZCuN0KWO6uPxgt5F2JJKgZMhmpNUGpEMNdLO8OZyPyqMpiM62LIeqaAo+kiNqpJZsNrtBZxtfrtsKZuNZ7PYkx4MzmkIAzEsDZIUxs5RIUBK0FLJCqbtbLq7tcUPY68d6CbyU8bAwD6yG1WG3vXI9AETHnWibpjK7qkTXcD52UA) But strangely `setState3` is also `any`, but there is no warning there. &gt; Isn't that exactly what noImplicitAny is supposed to prevent? No. That variable is to prevent **implicit** `any` variables. But if the function returns a type with `any`, then it's not implicit. It's the same as: function foo(): any {} const f = foo(); // not implicit
ah yes, thanks. Let me fix that.
Thank you, that makes a lot of sense. Any chance you could help me with a proper wording/description of this issue? i.e. "Inconsistent implicit any when referencing array destructured variable in updater function more than once"
I'm not sure context is a good model here, as it has no choice but to send the callback down that way. In your case, I would argue define the functions outside of the state (inside the body of the function component), and pass them down on their own. I'd also not pass down state directly, but rather `items`, and keep state a local implementation detail. You could also consider [`useReducer`](https://reactjs.org/docs/hooks-reference.html#usereducer), which might be more suited for your use case.
I have absolutely no idea how I would even try to describe this. It's clearly multiple things at play here.
You're suggesting [something like this](https://codesandbox.io/s/react-typescript-f23pq)? I chose context because the callbacks and items will be consumed across the entire app, which seems like the intended use case - but I'm totally open to other patterns. In my actual app, there are multiple `states` that get destructured into the global context object. `useReducer` would definitely work in this instance, and may actually be the preferred pattern. I've always hated sending actions as strings which is why I've barely ever made appropriate use of `useReducer`. I would like to get to the bottom of what actually went wrong with my examples - mainly because I've been using these patterns a lot and have only started to run into issues as soon as I introduce a second updater function... It makes me worry about my own understanding of my older code, if that makes sense. I'm definitely not against switching over to `useReducer` though, especially if that's the more by-the-book way of approaching this problem.
I've opened the issue [here](https://github.com/microsoft/TypeScript/issues/32278)
I've opened the issue [here](https://github.com/microsoft/TypeScript/issues/32278)
I do think that `useReducer` is the way to go in this situation. TypeScript can make switching on strings safe if you set up a type for actions using a discriminated union, like this: type Action = | { type: "addItem", item: IItem } | { type: "removeItem", item: IItem } | { type: "toggleItem", item: IItem } Make sure to annotate the `action` parameter to your reducer with that type, and TypeScript will catch any typos in the `action.type` property. I like to put the action type and a set of action-creator functions in a module that is imported anywhere you need to dispatch one of those actions.
&gt; I'm curious why the first setState gets flagged as an error and not setState3 Me as well, but I'd just be guessing as well. It seems to be a weird corner case that involves multiple aspects. I'd guess it somehow involves in example one both `increment` and `decrement` being inferred as type `number =&gt; any` (due to `setState` being `any`), and in example three it can infer `decrement` as `number =&gt; void` and the type of `increment` and `decrement` is the same in the interface. --- It gets even weirder if you add a third callback. In that case both `state` and `setState` are typed `any` in the first example: [Playground link](http://www.typescriptlang.org/play/#code/C4TwDgpgBAqmAmBDYEBOAeAKgPigXigApgAuKTASn1wDcB7AS3gG4AoVgMwFcA7AY2AM6PKH1QRkEOEhQYcxMpTIBtTABpYCSXOwBdKAG9WUE1HHAuqEcuAbu-QcMI8IAd0yKqBgL67W39gYeWQ5EPmgAZWBJQ2NTGkQAGy4IMh4uAFsAIzQ2UygAZwhgADUklLJCeAhE6LTMnNQqPFpGFjiTILEIDIhgyuraxHrstGbWpjzTau7e-qJBuqh00abqKHpJ-3Y+YQLgKGV9yQ0i4CjJfQJuyWltdAuUbEIjfITk1KgAJjUOwuKyh8yItEOszo8IC8-vkAHRw44oX75N7lT4IiAw94pKAAaigIL+3goSNMXXEc1I+Jq0TBxQhUORpjhMPRJMZWLR0RQmNRuKpQ0JxL+M3JfUpINp5y5kNejKgzNZ0PiqLI6J5HygAFp+dFBf4KDs9gcjtKAMynOlmq6icS3LSyB7S56ykwcsg-P5nQEVHWglr-KWSU0MuUKs1s5Fuwpm9XYvEE-JEiNknpi4HUv24cFmkOMsNBiMooHRoOx6DxjOCiMi1PzCX+nz6oA)
I love the type system of TypeScript (mostly). It allows for such powerful constructs.
Awesome, thank you very much for the explanation and example. I've been using TypeScript for about a year now, and it's saved me from an uncountable number of runtime errors - but I feel like I've barely scratched the surface when it comes to advanced types or patterns. I imagine I could refactor so much of my TS code to be more concise, elegant, and workable if I can just continue to learn - but I feel like I've stagnated to some extent. I haven't been searching out learning material or new patterns, I've just stayed in my little coding bubble. TypeScript has been incredible for me and I'd never want to go back to JavaScript, *but* I feel like there is still soooooo much to learn that I could hugely benefit from, and getting started down that path feels a bit inaccessible. Maybe I just need to keep plugging away for another couple years :) &gt;Make sure to annotate the action parameter to your reducer with that type When you say this, do you mean something along the lines of: `const [state, dispatch] = React.useReducer&lt;React.Reducer&lt;any, Action&gt;&gt;((state, action) =&gt; ({}), {});`
Thank you for sharing it. I subscribed, I'm curious to see what the response will be.
Yes, I'm very interested as well. I'm not at all confident in my attempt at describing the problem, but I'm pretty darn confident that the behavior is strangely inconsistent...
I added this info from your comment to [the issue](https://github.com/microsoft/TypeScript/issues/32278)
I'm glad to be of help! You can read more about discriminated unions in [TypeScript Deep Dive](https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html), and you might find other parts of that book to be helpful as well. Regarding the type annotation, either option works. If you can inspect the type of `dispatch` with your editor you can verify that it includes `Action` as a parameter (e.g. `React.Dispatct&lt;Action&gt;`). The second option, putting the annotation in the signature of the reducer, is useful because it will still work if the reducer is not defined inline. For example: function reducer(state: IITem[], action: Action): IITem[] { /* ... */ } function App() { const [state, dispatch] = React.useReducer(reducer, []) return &lt;&gt;Test App&lt;/&gt;; } I find it helpful to put the reducer implementation outside of the component because AFAIK the best practice is that the reducer should be a pure computation that does not reference props or state values in the component. Keeping the reducer implementation separated enforces that practice. On the other hand if you do want to define the reducer inline and reference props or whatnot it will work! I also want to mention that there has been a lot written on using TypeScript with Redux, and much of the advice given applies just as well to `useReducer`. In fact if you want to access the same state value and dispatch function from lots of components you are likely better off using Redux. I have read that Redux has ways of avoiding unnecessary re-renders that you would get with `useReducer` and `useContext`, and Redux comes with debugging tools, side-effect management add-ons, and so forth.
I'm currently going through the process to change implementations to `useReducer` per your suggestion. I'm going to get started with TypeScript Deep Dive as well. Can you tell me, is there much of a difference in these types: type Action = | { type: "addItem", item: IItem } | { type: "removeItem", item: IItem } | { type: "toggleItem", item: IItem } and interface Action = { type: "addItem" | "removeItem" | "toggleItem", item: IItem, }
In this case the two definitions are equivalent because every action has the same set of properties: `type` and `item`. It becomes important to use a union of object types when you have actions with different properties. For example `removeItem` could take a `guid` value instead of an `item`: type Action = | { type: "addItem"; item: IItem } | { type: "removeItem"; guid: string } | { type: "toggleItem"; item: IItem } This way when you construct an `Action` value TypeScript can make sure you provide the correct properties for that action based on the value you use for `type`. And in your reducer if you switch on `type` TypeScript can infer which action properties are available: function reducer(state: IItem[], action: Action): IItem[] { switch (action.type) { case "addItem": // TypeScript infers that `action.item` must be defined here return [...state, action.item] case "removeItem": // TypeScript infers that `action.guid` must be defined here return state.filter(item =&gt; item.guid !== action.guid) case "toggleItem": /* ... */ } }
Ahhhhhhhhh, I think the key piece of info that I was not understanding is that TypeScript can infer types conditionally. I've definitely occasionally built interfaces in the past like this: interface IItem { guid: string; } interface IColoredItem extends IItem { color: 'red' | 'blue'; } interface IWeightedItem extends IItem { weight: number; } type IOwnedItem = IColoredItem | IWeightedItem; And checked for a specific property like `color`, then asserted the type when I had errors... Which is presumably just because they don't share a common type union...
It's looking really good! The VS code App also has some functionality which can convert js into ts somewhat (it can infer type annotations) you could check that implementation!
Huh, interesting. I didn't know that, but I will check it out. &amp;#x200B; Long term I want to be able to specify a test directory so someone can provide more context for how their code should be used.
I can't add any substance, so I'll just leave a few words of encouragement: awesome concept and good luck with it!
Cool! How does it perform the transformations? Using recast or jscodeshift? Or the TS compiler's AST? Does it transform CommonJS into ES6 module syntax? Or is it focused more on adding missing type annotations? How does it do inference? Does it ask the TS compiler API for the inferred type?
Thinking about it more, I probably should have used the TS compiler API for this project. But I know babel better, so that is what I used. I manually try to infer the type by traversing the AST until it gets to a literal. It only adds type annotations but is "technically" a babel plugin so it can be hooked in with an ES6 transformation plugin. The idea was for it to be run once, though. Not something that would be built into webpack or similar. I had the idea while moving a reasonably large codebase over to typescript. Without using any for most type annotations, it can be pretty cumbersome.
Very much appreciated. Thanks!
My experience with recast vs the TS compiler AST is that recast is way better for doing code-mods. It preserves formatting and comments. I've tried a hack where I parse both via TS and recast, and then use node locations to find the equivalent code in one AST vs the other. So I can ask the TS compiler for type info and then add the annotations to the recast AST. Does your tool preserve comments and formatting?
Thanks to everyone for the suggestions. &amp;#x200B; This might be considered a bad thing to do, but after experimenting with different options (including things like monkey patching, using patch-package and creating a wrapper) I decided to try an approach using typescript compiler transformations. This is allowing me to hook into the AST tree nodes where I can find the general patterns we use responsible for dispatching actions, creating selectors and implementing reducers and injecting new code for logging etc at the point they are used. As am example, if I have something like: &amp;#x200B; `this.store.dispatch(new MyAction({ payloadThing: 'whatever'}));` &amp;#x200B; I can intercept the expression node in the tree and replace it with logging wrapped in a block, so it becomes essentially: &amp;#x200B; `{` `const payload = { payloadThing: 'whatever' };` `this.store.dispatch(new MyAction(payload));` `console.log('dispatching MyAction with payload:', payload)` `}` &amp;#x200B; I am presuming the ngrx public API is stable enough at this point that it and our code generally won't change meaning it should be a relatively stable thing once implemented. &amp;#x200B; I realise this means that the javascript code generated no longer is a proper match to the original typescript code but I am really only wanting to use this as an optional switch you might turn on from time to time to check the efficiency of the ngrx implementation so if it slightly slows down the build process or makes the debugging experience more difficult I can live with it.
I used the VS Code convert js with jsdoc to typescript for an entire app and it worked perfectly. Your tool looks very cool, but I think it would be a better approach to have it generate JSDoc type annotations! That way all the JS users could benefit AND then the TS users could have VS Code convert it automatically to TypeScript annotations... or maybe you could use the open source vs code code to do that final part.
Awesome! Great for beginners or small projects
&gt; tool for turning JS into TS hey thats me! üòõ
Even if it's just an example, please use `unknown` instead of `any`. We need to purge `any` from existence.
Just an observation from one of your examples: function add(a: string | number, b: string | number): string | number { return a + b; } add('hello ', 'world'); add(1, 2); This would allow me to call something like this: add(5, "some text"); A better type for this might be something like: // using generics function add&lt;T extends string | number&gt;(a: T, b: T): T { return a + b; } // OR using overloads function add(a: string, b: string): string; function add(a: number, b: number): number; function add(a: string | number, b: string | number): string | number { return a + b; } (haven't checked my examples)
Interesting thought coming from a beginner ;) Gonna start using unknown
I am meaning to remove that example. One of my gripes with typescript is how it handles both operators and overloading functions. My example and both of your examples will fail to compile because there is no way to specify (AFAIK) that a function can take two strings or two numbers. As far as generics go, my tool supports them! Just tell it to use a template and it will.
That is good to know. Thanks for sharing! I will consider that. Might be easier to go the other way, though. Do type annotations and turn that back into JS with JSDoc.
Not sure i understand the point? Any practical meaning ts has over js has to be added by the coder, and it gets stripped away at compile time anyway. I'm clearly missing something... Can you explain how this would be used?
\&gt; Results implemented as discriminated unions behave exactly like this (types have to be narrowed via if clauses or an exhaustive switch function) &amp;#x200B; Let‚Äôs say you have a function which returns a \`Result\`-like type. You want to make sure that every consumer of the function reads the \`Result\` to make sure that silent exceptions don‚Äôt happen. In other words you want a file like the following to emit a compiler error: &amp;#x200B; \`\`\`ts /\* ... \*/ const result: Result = readFile(path); // assuming this is the end of the file, an error should be thrown here because the \`Result\` is never read. \`\`\` &amp;#x200B; There is no way to enforce this requirement in typescript userland, and it‚Äôs the key feature which makes Rust \`Result\` types safe-ish. This has nothing to do with discriminated unions. \&gt; io-ts is an rather useful (and popular?) library that is built on Either/Result types. I stand by my original statement about libraries which use \`Result\` types. I took a brief look at \`io-ts\`/\`fp-ts\` and \*shudder\* so much code for what is essentially a JSON schema validator. Jesus christ.
The name is old, I was an Angular beginner. Nowadays I'm not anymore, and I know what a shit framework Angular is, with piss-poor TypeScript support. I won't accept another Angular project, no matter how much money is in it. Not worth the pain.
Calling TypeScript only an object-oriented language is misleading. It's a multi paradigm language, because JavaScript is a multi paradigm language - and TypeScript just expands JavaScript by type information.
You can use the "allowjs" flag in your tsconfig. See https://github.com/palantir/tslint/issues/515
I've been using eslint for both JS and TS and it works great. You can conditionally enable/disable rules/plugins etc. based on file extension. You can check my config here to get an idea of how to adjust your config: https://github.com/satya164/eslint-config-satya164/blob/master/index.js#L192
I can't find any option to turn TS annotations back into JSDoc in vs code. There seems to be a lack of documentation on this subject, or at least google turns up nothing on it.
Awesome! Thank you!!!!
Convert the rest to typescript. Use any and ambient module declarations to suppress compiler errors. Consider refactoring to lean more towards typescript as an ongoing effort.
Do not just convert everything to typescript. Even in small-medium sized codebases this could take quite a while and is for nothing. Enable javascript in your tsconfig and slowly refactor js flies as necessary.
you can't imagine the scale of the project and all the edge cases...
This is what I wanted to say. To add to this, I have a decently large project that runs both typescript and javascript. We use eslint for our js and tslint for our typescript and it‚Äôs fine, but we want to migrate 100% to eslint as every time a good rule is published in eslint, you have to wait for tslint to implement and publish it.
I've done it with large projects before. It is purely mechanical. &amp;#x200B; Think on the phrase, "typescript is a superset of javascript". Therefore, it is entirely possible to convert a javascript project to typescript by simply setting the file extensions to ts and slapping some any's in some key places. You don't need to convert your module loading code over to import/exports everywhere. You don't need to turn everything into classes. I can say with certainty that you believe there is more to do here than strictly necessary. One of the beautiful things about TypeScript is how easy the migration path can be. You can move large projects over and you don't have to drink the sea. Of course, I'm not on your payroll, so I can't show you.
Not for nothing. Even doing the bare minimum of swap .js -&gt; .ts, you get type checking between entities within that file. It's not a lot, but it's certainly more than nothing. Then you can slowly refactor (like I said, "refactor as an ongoing effort").
You can typecheck your *.js files by enabling ‚ÄúallowJs‚Äù, which renders your point moot.
interesting. The thing is our TS packages are strict and JS obviously won't be if we migrate like this. Won't it be a problem in regarding to eslint and tsconfig? or do you suggest creating two tsconfigs and extending eslint for stricter packages?
Very cool
You'd have to turn off strict and phase in the individual options, this gets back to the ongoing refactors. Generally though you'll get better type coverage with this route vs having some areas of strict typescript amidst js ghettos.
Where are `Union` and `i` declared? Can you post a minimal playground reproduction?
- `Union` comes from this https://github.com/pirix-gh/ts-toolbelt - `i` is simply a collection of all exported types in my project - `withRouter` is a HOC from NextJS I'll try to make a quick codesandbox.
Can you replicate this with no external dependencies so we can try it locally?
What does your tsconfig look like?
This is my tsconfig: https://pastebin.com/JUMwgVGV This is NavLink currently: https://pastebin.com/1T9YMKtF This is NavLink with the discriminated union: https://pastebin.com/fmWDjjRR This is the how `RouteNames` works: [TS Playground](https://www.typescriptlang.org/play/index.html#code/KYDwDg9gTgLgBAYwgOwM7yhArjYA5AQwFthU4BeOAeQCMArYBGAOgDMphgAvYACgG8AUHDgALCCQBccAOTiSMuATJI0MADTClYMABsAntJkEdBxcsQp0mkQRrYYRuw-MqrGrbogBzAJbIjLz9kV0s1GzhkYAB3VCMo2NDVay0E1AARYBgCX114mNQAWgATLJzdJPcI7wJdXWAoQ1kauob9SvDBAF8ASgBuQUGYfTBgOAA1WqxgKlYAHgAVAD4KOAWAbQBrYH0IVjWAXQHBYdG4ACUHfGJSVcndadm50+A9uEwca5JUJYGgA) It should not be able to have `undefined`
Can you try to make `defaultProps` NOT a partial? Just write: static defaultProps = { className: '' };
Well yeah, because I only want to define a default value for className, not for `router` and `children`, which should be passed as props (`router` by the `withRouter` HOC, `children` by the developer). How could the type for defaultProps affect the prop type though?
I'm just guessing if this is the culprit. Did you try it? &gt; How could the type for defaultProps affect the prop type though? With type magic via conditional types you can look up the type of the `staticProps` property. [Example in this playground](https://www.typescriptlang.org/play/#code/MYGwhgzhAEDqCWAXAFgZUWR9gAUBOA9gA4wDeAUNNEQK4BGI20EGWwzr2+xEAXNDjB4sYEAB5S0AHZgAtgFN+LPPCkBzaAF8AfAG5K1eo3YB9OkICESxCvX7N5cqEgwEKAjUTpMXQiWgUVLQMTCYAZgQEVhy2avaOiACeRPLQAMIEUso0wIgEeNAAvNLyAO7QABQAdDVCanzQYFKJANoAugCURdqNzfpJKdAA4vJenLh+EGIAKtDyAB6I8lIAJjAZWTY5eXg9xbMLS6tkHD4TPPyqYfIFqLOa0AD80HfQ-FLyAG43+uQDqd42NNkvIIABGIrDUaA3w8MT-AhhOBINDjbgkPR-EEvcbAlIQABMkJGYzO6KmCKRbmQHlJbHJmKAA) - just hover over `StaticTypes1` and `StaticTypes2`.
This is the type definition of withRouter export function withRouter&lt;T extends {}, Q = DefaultQuery&gt;( Component: React.ComponentType&lt;T &amp; WithRouterProps&lt;Q&gt;&gt; ): React.ComponentType&lt;Omit&lt;T, keyof WithRouterProps&lt;Q&gt;&gt;&gt;; Doesn't seem to do too much magic.
Thanks for taking the time in trying to fix this. I just fixed it! I explicitly passed NavLinkProps to withRouter like this export default withRouter&lt;NavLinkProps&gt;(NavLink); and then it works.
Please share your experience with Angular with us? I'm really interested in finding out where this came out from (I think I'm only a beginner with Angular and I really like it this far)
I wrote here about a few that came up in my mind: https://www.reddit.com/r/programming/comments/c4hpeg/why_angular_made_me_quit_web_dev/es0k0el/ I'm sure I've encountered many more issues.
Cool!
npm i --save @types/aws-lambda
What about generating the json schema from a typescript interface?
Check if you're deleting any .d.ts files. They're commonly bundled inside packages, and the TypeScript compiler needs them. Pass the --listFiles flag to tsc and it'll list all the files it's reading. Of course, to do that you have to not delete them first.
But I'm deleting the *.ts-files (incl. *.d.ts) from `project` node_modules, not `worker` node_modules.
And yet --listFiles is showing you that worker's compilation is reading those files anyway, right?
Yes, you're right. But why? They're in a parent directory.
Thanks for this, I have been looking for a lightweight Markdown editor that does not get in your way. Could you go into some detail as to how you built this.
You can actually read the source code of versions &lt;= v1.5.1 on GitHub. What kind of details would you like to know?
Right, that's how node's module resolution is designed to work, and TS uses the same resolution behavior. If a file /project/worker/Foo/bar.ts tries to import something, it'll look at Foo/node_modules, worker/node_modules, project/node_modules, ... It'll keep ascending
Linux build - nice.
Very nice comparison. You've done your research.
Interesting! The more you know I guess! Thank you!
Great!
I know I can read the code. I will take a look at it. I was wondering how you packaged notable to run on all of the platforms?
Sadly can't get it to work. It works fine up to a certain point, but after a while I get the error that errors that I need `esModuleInterop` enabled for importing, while it's already enabled. Maybe because I'm using a custom directory for my `pages` folder.
I'm using `electron-builder` via `electron-webpack` for that.
Anyone know what terminal app they use in that blog post?
its probably zeit's own electron based terminal app, hyper &amp;#x200B; one more chrome instance, who cares?
When I got that error, it offered to auto-update my tsconfig, which resolved the issue. I know you said that it's in your config, but I'm curious if the auto-config failed you too.
It doesn‚Äôt even generate any more for some reason. Idk whats happening tbh, it‚Äôs very odd. Are you using a custom server?
I am using a custom server. I already had my own tsconfig in my root, and the first time I ran my dev environment was when it offered.
Yeah that also happened to me, and I used it for a while with my own path config added to it, but the next time I tried to start the dev environment was when the error kept popping up
This is great news. I have a lot of respect for devs who program large apps in Javascript. Like with Perl, it takes a lot of concentration and discipline to work with it, compared to Typescript which does a lot of the heavy lifting for you.
&gt; For example, a good practice for naming classes is to ensure that the actual name dictates what type of construct it is: &gt; Therefore: UserController, UserRepository, UserMapper, User. Hard to take it seriously when this is included as non-ironic advice. What is intention revealing about any of this? What kind of controls do we have on users? What is domain about `UserRepository#save(User)`? What the hell does a UserMapper do? Are we converting between types? Or are we actually plotting users on a geographic representation? User is the only thing here that _might_ make sense but I've also seen user objects balloon into knowing about everything
Your ram
You don't need conditional types to achieve what you're looking for, you can do it with function overloads: interface dataObject {} function getData(id: string, history: true): dataObject[]; function getData(id: string, history: false): dataObject; function getData(id: string, history: boolean): dataObject | dataObject[] { if (history) { return [] as dataObject[]; } return {} as dataObject; } const array = getData("", true); const obj = getData("", false); [Playground Link](http://www.typescriptlang.org/play/#code/AQ4SwOwFwUwJwGYEMDGNgBMlSQeQEYBWMKUwA3gL4BQ1owCArhKWAPYTADmMUAItiQAKMBgBcwAM5Q4kLgBpgACzDS2cAJ4SZjGAEoJWHAWKkA2gF0A3HVBMWUdpx79BI8VJlzFKtZonIADaS+oaCJiRQNvT2rBzcvAI47hLSshAKyqpQ6lrA+GxsgTBInAC8DEjBoZjhRJHAAD61xvXmFhS29CBgCMBCvjmaep3dY8BwvIxwnJbASJIteG1QltHjNOMTUzMUlPOLRsumUV3ANGcoHNLzcHBIGsAVLknCAERvijr66yBXEDc2EQnglXMkPoogiE9FYgA) where you can see the return types
&gt; getData&lt;T extends boolean&gt;( id: string, history: T = false ) If T is `true`, how could you assign `false` as the default argument for `history`? You can not write `const h: true = false;` - they're incompatible types. Besides that, /u/1384 is right.
Last time I tried it was extremely sluggish and had so many rendering issues.
The formatting is unreadable. :-( https://imgur.com/uja7Yrc
The project should contain a readme or a glossary to explicitly describes the meaning and usage of these words for this project.
They switched to the same rendering engine vscode uses now, which is pretty ok
cmd.exe best terminal change my mind
FYI the typechecker currently blocks builds until it's fully compliant so don't upgrade unless you want to disable with a [dirty workaround](https://github.com/zeit/next.js/issues/7687#issuecomment-506440999).
Statements like "change my mind" just indicate that you are not interested in a change of mind. You're looking for pointless discussions and arguments, while you have made up your mind already and won't accept change.
I mean, my ram is always half empty. So why the fuck not.
You should remove the &lt;&gt; from the connect. The mapStateToProps function is declarative enough. Typescript can figure it out what types are returned by mapStateToProps.
sorry, didn't know it won't render well in old reddit
yea thanks! saw some code online and removing that fixed it
&gt;in old reddit You mean in the good Reddit design.
To be fair, Controller and Repository are standard language as fair as programming goes. People will know what they are based on context. Mapper is a bit less so, but if you read the rest of Khalil's stuff you'll see it's very Spring Boot inspired with DTOs and the like so it makes sense.
The bigger point I'm making is that these things don't belong in the domain layer (the repository arguably belongs as a necessary evil). And the names don't reveal any intention, I'll give the repository a pass here because it's not gonna get named any better (that's how you get UserRedisCacheBackedDatabaseRepository) A UserController is going to accumulate crap until it's the god controller everyone turns to when they need to do something with a user. Better would be names like UserRegistrationController, UserProfileController, etc etc that give a meaningful name for what kind of controls they expose.
Fair point, the controller names should be more specific.
Statements like "change my mind" just indicate that you are not interested in a change of mind. You're looking for pointless discussions and arguments, while you have made up your mind already and won't accept change.
It‚Äôs unfortunate that most of these tutorials seem to be written by people with very superficial understanding of the language and I wonder what‚Äôs with the desire to teach others and not bother with even a basic fact checking. Seems like there‚Äôs been a huge influx of these recently...
Look up the branding technique. Besides that and `type name = string` there is nothing.
This looks great, but I noticed its for firebase's Firestore, not the newer **@google-cloud/firestore** package which has a few small differences in methods available (the Query has a select). Any plans to do the same for that? I'm a bit annoyed at Google for causing so much confusion on Firestore as the API's are different between **firebase/firestore** and **@google-cloud/firestore**, and its a pain googling for help on firestore issues since you have to filter which lib is in use yourself.
Given that types are local, there‚Äôs no reason not to alias them like you demonstrated.
It looks like @google-cloud/firestore is meant to run in a Node environment, while firebase/firestore is meant for the browser. I wasn't planning on doing the same for @google-cloud/firestore but it was pretty easy to do, I'd encourage you to try it if you feel inclined
Fun, but I do have to question the necessity of this.
Can anyone tell me what the point of NextJS is? I thought it was backend framework that's coupled tightly with React, like a modern Meteor, but I don't see any examples of NextJS interacting with a datastore or db like Postgres or Mongo.
GraphQL has a small class interface for defining custom scalar types. It is a very efficient / clean way to do validation on interfaces. One of the strong points of their dsl in my opinion.
Go for it bruh
It's mostly for fun :) Though I find that I do learn a lot about TypeScript from working on edge cases like this. We did have a somewhat valid use-case for this in a library we are working on. It involved types of "models" in an ORM-like library that had "relationships" defined to other models. In some methods we wanted the properties of these related models flattened into the base model. For the article I simplified the problem a little bit because I didn't want to get into the specifics of this library, and I'm not even sure we'll end up using it in the end.
I have some bad news for you, this is pretty much exactly the new features of NGRX 8 https://ngrx.io/guide/store/reducers
It's a server-side rendering framework for react. It organizes your project around the concept of pages and provides its own router. Then, each page-level component can be given a static method called getInitialProps, which is where you usually do all the data fetching and db code. When a client initially requests the page /about, getInitialProps for pages/about.js will be called on the server, and once it's fetched everything, the fully rendered page is sent to the client. However, if you navigate to /about from some other page on your site, getInitialProps will be called on the client-side and once it's finished, the router switches to that page. It's good for implementing websites that act like actual websites, but you can still do whatever you can do with just plain react.
The underlying idea looks pretty similar and I'm glad that they are using it. But there is a big difference. There is no type inference for the state in NGRX's implementation. Also, Deox is going to develop a plugin system which allows the integration of other helpful libraries (e.g. immer) with it. Look at the following example: ```ts const reducer = createRedcuer(defaultState, handleAction =&gt; [ handleAction.default((state, action) =&gt; /* ... */), handleAction.immer((state, draft, action) =&gt; /**/), /* ... */ ]) ```
Repost: https://www.reddit.com/r/typescript/comments/c4k4cx/associative_php_arrays_in_typescript/
I prefer the more traditional of the approaches offered by`typesafe-actions` as it doesn't involve buying in to the library as such; all we use from it are very easily recreated action creator helpers and type helpers. My team at work are trying to move away from a different library that's not very well maintained and it's been a pain specifically because it involves buying into their non-standard library API.
Why do you think this library is not under maintain? You can not completely move away. node\_modules is the heaviest thing in the world. :D
The preview icon is how I feel when seeing something like this. Better to use a proper result-monad instead. :-(
Wow, seems like you're a **very sensitive** one...
First I tried narrowing, but had no luck with that. Then I tried: value: string | undefined; And the error went away, so narrowing don't seem to work with the ?-syntax.
You have couple of choices: // 1 const f1 = ({ value }: A) =&gt; value ? f2({ value }) : null // 2 const f1 = (arg0: A) =&gt; arg0.value ? f2(arg0 as B) : null // 3 type A = {value?: string} type B = {value: string} const f1 = (arg0: A) =&gt; isB(arg0) ? f2(arg0) : null const f2 = (arg0: B) =&gt; arg0.value // (omitted processing of arg0) function isB(a: A): a is B { return a.value !== undefined }
Option 1 is the safest option, but it creates a new object (which is the reason why it's safe). In both other options the object could be saved as `B`, but later the `obj.value` could be set to `undefined` again.
Like this? ``` type A = {value: string | undefined} type B = {value: string} const f1 = (arg0: A) =&gt; arg0.value ? f2(arg0) : null const f2 = (arg0: B) =&gt; arg0.value // (omitted processing of arg0) ``` seems to still generating the same error
&gt; Why do you think this library is not under maintain? He didn't say it. He said "from a different library".
I went with the second option, but the third one looks interesting. What's that technique called?
The second is called a "type assertion", it basically says: "Hey compiler, this value is of type ABC, trust me on it". The third one is called a "custom type guard": "Hey compiler, this function will make sure at runtime that the value is of type ABC".
Thank you @overtowed, this helped my make [my own configs](https://github.com/futagoza/tsconfigs)
These are different things. ```` a={} &gt; {} a.value = undefined &gt; undefined a &gt; {value: undefined} ```` In the first case, `value` is optional (the ?-syntax), in the second case there must be a key called `value` but its value can be a string or `undefined`.
Cool project, thanks for sharing. I'm glad it helped.
Typesafe-actions is great! It was very easy to convert our project from vanilla function action creators. We were able to keep our switch style reducers too which was great.
He said "from a different library that's not very well maintained" in the context of this post. So I got that meaning.
A second opinion: you don't need to code within the OO paradigm in order to use and benefit from TypeScript.
My point is that all libraries run the risk of becoming unmaintained, that's not a sleight at this library in particular.
Your example works fine for me in [a fresh project](https://user-images.githubusercontent.com/49038/61075783-c1c27e80-a3e8-11e9-8028-9ff0ca62fc7e.png) Is it possible in your example you're working with a mutable variable version of "M" or "F" which is turned into a string instead of the union of the two string constants? ( [this](https://github.com/sandersn/manual/blob/master/Widening-and-Narrowing-in-Typescript.md) covers that topic probably far too much detail )
Works fine for me. What's your tsconfig.json?
 [http://www.typescriptlang.org/play/#code/C4TwDgpgBAyhAeUC8UBEBZVUA+aBiqAUIQmAPYBOwUAxgDYCGAzk1AAoQVNkB2UA3oSjDavJsAoBXGsEoAKMJIBGdAJY0oPBgFsIALijiKqngHMANFEUr1hhAbjwAlAIC+hd4RpjqYZJogAd3ZObh45VAArMghUSwxUJ2JvHnEoRBQeIJCuXgjo2PiAEUSgA](http://www.typescriptlang.org/play/#code/C4TwDgpgBAyhAeUC8UBEBZVUA+aBiqAUIQmAPYBOwUAxgDYCGAzk1AAoQVNkB2UA3oSjDavJsAoBXGsEoAKMJIBGdAJY0oPBgFsIALijiKqngHMANFEUr1hhAbjwAlAIC+hd4RpjqYZJogAd3ZObh45VAArMghUSwxUJ2JvHnEoRBQeIJCuXgjo2PiAEUSgA) &amp;#x200B; it works just fine on typescript playground (using typescript 3.5.1 and strictest settings)
export class Person&lt;T extends Sex&gt; { constructor(public name: string, public sex: T) { } }
I've updated the post with this info
That should work, and seems to work for me -- is this the actual code you're seeing the issue in? One issue I've seen with literal types is that they easily decay to non-literal types. Using the `as const` syntax might help as well (https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions).
So I can confirm the error is happening in this specific case: const info = { name: "Joe" sex: "M" } const p = new Person(info.name, info.sex)
 const info = { name: "Joe" sex: "M" } as const; // &lt;-- add this const p = new Person(info.name, info.sex)
I can reproduce this. My way to handle it would be person.ts export type Sex = 'M' | 'F'; export class Person { constructor(public name: string, public sex: Sex) {} public output() { return JSON.stringify(this); } } test.ts import { Person, Sex } from './person'; interface IInfo { name: string; sex: Sex; } const info: IInfo = { name: 'joe', sex: 'M', }; const p = new Person(info.name, info.sex);
Try const info = { name: "Joe", sex: "M" as const } the 'as const' will tell typescript that "M" is a string literal, rather than just a sting
Typescript can't infer that sex is of type M because you're using a mutable object. Anywhere you can just do \`[info.sex](https://info.sex) = 'genderfluid'\` and now it won't be of type \`'M' | 'F'\`. You should probably have an interface for your info object like \`interface Info { name: string, sex: Sex }\` so Typescript can know it won't be assigned whatever string.
Makes sense. Thanks for explaining
I'm trying to share with the community my solution to a problem that I had. I'm not facebook nor google to pay developers to maintain my projects. If the community like the idea, so they can help me to maintain it. If there is better alternatives they can introduce them to me. It's just open source world.
Absolutely, I didn't mean to be overly negative or critical. Just providing my two cents regarding why I personally won't be adopting it - best of luck with it regardless. :-)
`sex: "M" as const` should fix it.
What do you love so much about TS that makes it so much better than those other languages?
generics... fast compiler. productive library support. Just think it's well rounded and has no major flaws. It's a good pragmatic language that scales. Go has lots of flaws, no generics. Don't like go... I'll use it if forced to though.
Dude, Python, Scala, Golang etc. are weird ass languages that all try to reinvent the wheel. Typescript is more typical, but have you tried Ruby?
TypeScript needs to become a compiled language so it isn't such a hard sell for backend services. There's no reason that the language can't have C-like performance if interfaces without index signatures are compiled analogous to structs. It has a stronger type system than C#/Java without extreme verbosity.
I think the one part that I wish typescript had was ensuring all the other developers leveraged the type system more. I've seen people go to great lengths to just completely eject from the value of static types.
&gt; It has a stronger type system than C#/Java without extreme verbosity. Surely you mean 'better', strongly typed languages have a specific meaning.
We've been using Typescript at my job for a whole year now and it does make the code you write feel safe! Especially when refactoring. The language that made me feel that way was Clojure(Script) tho. Sadly it's a niche language that I rarely get to use professionally.
To be fair generics can be a maze sometimes. Even I can get confused and I feel pretty confident working with generics.
WebASM might get us some of this ...
ya good call
Not sure why you're particularly mentioning generics in response. I meant avoiding the any type like the plague.
Can't you set that in the tsconfig? Or am I thinking tslint? Either way, break the build on those mother fucking heathens.
Java and Scala both have generics and a good library ecosystem.
+1 for refactoring. So easy
Yeah that sounds real good until the reality of training and delivering features in large projects migrated from javascript sets in. Enterprise! Development at the lowest common denominator but at least you can pay your mortgage.
Truth. My team got split to be half India based "hybrid" teams, so I understand lowest common denominator all too well...
You can do ‚Äúgenerics‚Äù in js. Typescript‚Äôs value add is the verification/refactoring and IDE like support (autocomplete and go-to definition).
I'm just getting into TypeScript and am enjoying it. There's an extra level of attention that goes into coding that is enjoyable and fruitful
There aren‚Äôt a lot of reasons for using js on the backend aside from sharing code with the front-end, The alternatives are way better,
noImplicitAny
No merges unless the CI passes
: any Don't even need to contort to get around that.
Yes, but code sharing (homogenous codebase) is a strong reason and TypeScript is a significantly nicer language to use than other popular backend options like C# and Java.
Okay. Convert the 40k loc. Don't cast to any. Deliver features still.
Are you using type annotations in clojure?
Ruby devs are working on adding a type system because it doesn‚Äôt scale well
At least you need to be explicit about making bad decisions.
True, but being explicit is hardly a great length to go to to be a dumbass. It'd be nice if the compiler told these people to fuck off. That's the biggest problem with gradual type systems. Dumbfucks can persist and you can't shoot them into the sun yet.
I have a Go monolith which I‚Äôve been breaking up into services. Once all the heavy lifting is separated out I‚Äôm going to switch to typescript/express for the layer in between.
Did you mean javascript instead of java?
Not really, I'm just using spec. I actually like the dynamic nature of clojure. üòÖ
Not sure when you looked at Python, but the optional typing helps a lot IME. I still prefer typescript but Python is less painful with types for me.
That‚Äôs very different.
Deno is trying to do that, a better node using Typescript
Could you provide examples and why you would prefer them? Just curious.
Maturity and bigger ecosystem. I have a better chance of finding a high quality library in Java/C# than js.
Blatantly not true for c# (can't speak for Java) . I am part of a C# shop and we use literally no modules in production that aren't made by Microsoft (we use some in testing). Look at literally any service and you will find an official JS module and MAYBE a community C# module. Also C# is excessively verbose with a less expressive type system than typescript.
Christ man, I hope you find your peace...
No need for it to be a compiled language. In fast, it's plenty fast and many many very high scale backend services run on node.js currently. However, if you want something even faster [deno](https://github.com/denoland/deno) looks pretty promising. It's by the guy who started node. The engine is written in rust and uses TypeScript as a first class language. It's his "all the things I wish I did different in developing node" project.
Absolutely. I've been coding in JavaScript for 20 years and I've rejected every other weird wrapper that's come along... script#, clojureScript, CoffeeScript... gross. However, TypeScript is a real thing of beauty. Being a super set of JavaScript and closely following ES-next standards was a fantastic choice. Add to that the core people that wrote C# type system and you've got yourself a masterpiece of a language... imo.
https://palantir.github.io/tslint/rules/no-any/
Generics are required for any scalable programming language IMO. without generics I have a list but I don't actually know what's in it...
Java. I actually haven't done a ton of JS.
&gt; TypeScript needs to become a compiled language so it isn't such a hard sell for backend services. I'd still prefer strongly typed languages for the backend, something that TypeScript can't possible offer with the current language design.
Note that Deno won't provide runtime type safety either.
Yeah, but Union types, Intersection types, Indexable types... &lt;3
It's a pity... Because that would be its biggest selling point for a lot of people.
Deno is not trying to do what parent commenter is suggesting. Deno strips away the types and runs the generated JavaScript in V8 just like everyone else.
Do you really have a "list" in TS, though? üòä
But then we'd need another language. TypeScript can't support this by design.
Java has no type inference which means you have to manually type everything
Since a few month I'm porting most of my Dart packages to TS - what a pleasure! Sure Dart has it's nice sides but overall TS is so much better. The TS (+JS) infrastructure is more complex but what you can do with TS, WebPack or Jest is just incredible. On the server side I'm using Kotlin. TS is cool but Kotlin has all the new and fancy language features. However I think nothing beats TS as the client side language.
Java 10 introduced var, which I believe has type inference.
I feel like if you discover C# you'll literally cum in your pants
White space as a syntax makes me vomit.
As far as I read Deno is not currently faster and is still under heavy development.
The "language" is just the syntax of what you type into your ASCII text files, based on its own standards... i.e. ECMAScript is a "language", but it has many runtimes, with slightly different supported features... its up to the runtime of what features work while the program is running. You seem to be confusing the TypeScript language (i.e. a standard of how the source code looks) with the "TypeScript &gt; JS transpiler", which is a very different and separate piece of software to the runtime, i.e. Node on backends. What we would need for something to give TypeScript source code 'runtime type safety'... is simply a runtime that supports reading TypeScript code directly (rather than transpiled JS) with this added feature... which is exactly what deno is, isn't it? But maybe I'm missing something? I don't know that much about deno aside from reading a little. I've never used it. I remember last time I looked into this, the conclusion I came to was the same as yours... deno doesn't support runtime type checks. Just did a little more digging now into the github issues, and came across this: https://github.com/denoland/deno/pull/1821#issuecomment-466168773 ... so maybe it does actually support it somewhat? Now I just found this, which says the opposite, and that it "never will"... https://github.com/denoland/deno_std/issues/151 Kind of surprised there's no obvious answer anywhere that's easy to find. Might have to give it a go in the next few days.
eeeeh, only the most basic type inference. You can pry my control-flow constrained types from my dead, cold hands
Python type hints include generics. You can have List[float] or Dict[str, int] or whatever. https://docs.python.org/3/library/typing.html
Same. I successfully persuaded my team to use TypeScript on our new React and Node projects and it has been really fun coding with it. Really low learning curve since we are all already proficient in JavaScript.
https://github.com/Trixt0r/ecsts/blob/master/tsconfig.json No `strict` flag. :-( Using TypeScript for type-safety, without making use of TypeScripts awesome type-safety features.
&gt; But if the goals and design of the language is incompatible with what you want at runtime, then you have an issue. What's the issue? &gt; TypeScript is a super-set of JavaScript, which explicitly does not provide a sound type-system. But doesn't deno parse and execute TypeScript from .ts files directly? Or does it simply JIT pass .ts through the regular tsc transpiler, and actually only execute the typical transpiled ES code at runtime? ...which I think is how ts-node works? Maybe I'm confused... but if I'm wrong here, why does deno call its a ***typescript*** runtime? Even the plain old tsc transpiler itself could add extra ES code into the output that does runtime checks in most places, I don't see how there is zero possibility for this. It's not "technically impossible", it just not worth putting the effort into according to the people at MS making the decisions. [Looking at the deno github issues mentioning this subject, it sounds like the reason they're not doing it is because it performance, rather than in being impossible.](https://github.com/denoland/deno/pull/1821#issuecomment-466168773) .. I don't get what he means about "optional" though? Sounds like there is some support in this case? Any idea? &gt; What would this type-check? If the TS transpiler doesn't complain, the runtime type checking would do the same. A combined compiler+runtime can obviously do everything a compiler-only can do, and more. And even if there are a few ambiguous edges cases like this where it's possible to make a contradiction... ok, just ignore them. But it's a fairly uncommon edge case. It's still going to work for 99%+ of all the simpler typing we're doing in our projects. 99% support is better than 0% support. Very little in this world is 100% effective. That doesn't mean things aren't worth having.
Do you guys have noImplicitAny turned on? I'd recommend try without it. I would rather have untyped code than have "any" littered everywhere. I'd be worried it will be hard to ever actually add types later on. We are working on a migrated code base as well and get tons of value without using any strict rules. We just add types as we work on an area of code.
I fully disagree. I see no advantage to having a single coding language for everything if that coding language isn't good at everything. Javascript is really only good at one thing (quick upstart), so why would I want to use it for something that it isn't good at? If anything, we should be trying to move closer to a more mixed language world, than trying to be monolanguage.
Type anything = string | number | object | null | undefined | etc...
Did you use IntelliJ. If the language isn‚Äôt a delight. The tools to make it not suck so much can be
Because fixing that would cause huge incompatibilities with a vast amount of libraries out there. Also, this non-goal from the TypeScript wiki is relevant: &gt; Apply a sound or "provably correct" type system. Instead, strike a balance between correctness and productivity.
Hello people, &amp;#x200B; [We](https://github.com/pankod)'ve created a boilerplate for backend development with MicroService architecture. It has everything you need, to build real world apps. &amp;#x200B; Built in CLI generates entities, services, service unit tests and even integration tests in a second! It should save a lot of time for you. &amp;#x200B; Hope you'll like it! &amp;#x200B; [http://github.com/pankod/moleculerjs-boilerplate](http://github.com/pankod/moleculerjs-boilerplate)
YESSS!!! Control-flow constrained types / type inference is the BEST. I've been wanting to experience this in Elixir since their pattern-matching features seem to be a major selling point but haven't given it time yet.
https://github.com/pankod/moleculerjs-boilerplate/blob/master/tsconfig.json You really want to propagate a boilterplate that does not utilize **any** of the strict-compiler flags? Yeah, why would you want type-safety when using TypeScript...
They write: &amp;#x200B; *One such example where this ends up being a problem is in arrays. By default, arrays in Flow are invariant. That means in Flow, this will throw an error:* &amp;#x200B; Which is completely irrelevant for this example. The reason that there is no error in the TypeScript version is because Animal and Bird are structurally the same and therefore assignable to each other. If I add a property to the Bird class then you get an error because Animal is not assignable to Bird.
I completely relate to this. TypeScript is one of the most "relaxed" languages out there. A lot of support for tooling, documentation and examples as well. Happy coding :-)
So you like writing all your contracts multiple times and manually syncing code to different languages?
[removed]
Looking to delve into mypy - it seems promising, feels like trying old 1.6 typescript 3 years ago.
Yes, although that loving glow is quickly spoiled by having to deal with javascript toolchains.
No, but those steps are only needed if you pick incompatible languages. For example, there is little to no need for that if you are coding to the JVM or CLR. While I'm fairly unfamiliar with WebAssembly, I imagine it would or could be similarly capable. Languages can be made to interop with each other without the need to repeat yourself, just in many ecosystems the tools haven't been developed for this yet.
Thanks for the feedback. If you like the rest of the code, we are open to contributions. Also we dont have ‚Äòany‚Äô type other than 1-2 test related file.
v8 is the js runtime, not node. you would have to replace v8. this is not what deno is trying to do nor should it try to. the scale of a task like that is considerable.
Yeah we call it an array
Looks similar to my tsconfigs and I am a VERY strict developer... what "strict-compiler flags" are you going on about?
IntelliJ is not a delight. It's a slog.
What do you use?
- `strictBindCallApply` - causing `.bind()`, `.call()` and `.apply()` to be type-safe, instead of accepting `any`. - `strictFunctionTypes` - disabling bivariant parameter checking for function types (improves type safety as well). - `strictPropertyInitialization` - makes sure all properties of classes are initialized (works only together with the next flag). - `strictNullChecks` - my absolute favorite one, and it's always a pain to work on codebases that don't utilize this. It causes `null` and `undefined` to be types. So if a type says `number`, it **must** be a number and can't be `undefined` anymore. All these flags are enabled by enabling the `strict` flag.
Yes. By compiling your TypeScript code. The result is JavaScript.
what's the build system in the project? Changes are you can just rename .ts files to .js files, remove the typescript parts and it works. (And then when you pick up TS move back the same way)
VSCode or vim depending on the task at hand.
&gt; I have seen dozens of resources with information for JS to TS, but nothing the other way around? perhaps you should take the hint...
Typescript is easy, learn it. Don't damage your project.
I'd love to, but difficult to find the time and do the project as well
Was waiting for that response. I know it's the way forward, just havn't had the time yet.
A triple back somersault with a half twist is easy for me, everything relative and most things can be learnt with time, but time is a luxury that I do not have at the moment.
You're spending many hours here on reddit right now when it would take you a matter of single digit hours to learn TS.
if you learn it now you will have a lot more time very soon. TS is a real timesaver for all those bugs in a JS codebase.
I dont get it why TypeScript? All checks are only on compile-time. When it gets interesting on runtime nothing of TS is there anymore.
You should give Haskell a try too.
That has nothing to with TS. That's the language server protocol which most languages implement in a 3rd party server. Eclipse for example puts out a spectacular Java language server.
A language is more than its specification.
Projects like this are a great way to learn
You may want to look at a new series I‚Äôm writing on Medium, especially if you‚Äôre just starting with TypeScript. https://medium.com/@ChristopherShaffer/get-started-with-typescript-part-1-440d2ec9e59
Using `strict` for the code itself makes sense. For testing not really. Maybe switching completely to JS would make more sense in this case. `any` is used where explicitly needed.
https://docs.microsoft.com/en-us/visualstudio/javascript/tutorial-nodejs-with-react-and-jsx
My favorite is the last two. Never heard of the rest though. Thanks for share.
Ok fair enough. I don't know enough about where the line is drawn in the internals between node/v8. But deno calls itself a "typescript/ES runtime"... rather than just an ES runtime... so doesn't that mean that it's parsing typescript code itself? Also why is he saying there already are some runtime checks in deno here? https://github.com/denoland/deno/pull/1821#issuecomment-466168773 ... and also that the only reason it's optional is because making in compulsory would harm performance? Doesn't make it sound like it's impossible in this case?
Thank you.
Here you go: https://github.com/lukeautry/ts-app
We‚Äôll enable strict mode soon
What is this?! Do you see anywhere anywhere mentioned Typescript?
Thanks, looks interesting!
Your Dockerfile is a mess: - It makes **no** use of caching, at all. - You should use `npm ci` instead of `npm install`. - Your resulting image contains all the source code. - You're using an ancient NodeJS version, which runs out of support end of this year. Just as with the tsconfig, it seems like you opted for the first *working* version without any deeper understanding of the technologies you use. This shows in a lack of quality.
I've raised a PR for these if you want to take a look
Thanks for the contribution, we‚Äôll take a look asap.
Thanks for the feedback, we will take a look and do required updates and again; we are open to contributions. If you want to do more than talking.
I'm already occupied with a project, but I'm up for hire starting October.
Check this out too [https://github.com/kutuluk/js13k-ecs](https://github.com/kutuluk/js13k-ecs)
Without any typehints or docs in the code :O Seems to be performant and cover only the bare minimum of an ecs. The example looks very cool :)
?blue book? can you share please? kthx
BUT can we have the types converted to JSDoc during the conversion?
If you really want to, you can pretty much just write regular JS code in your typescript project and ignore types since typescript is just a superset of javascript. That being said if you already know javascript well, you can pick up typescript extremely quickly. In far less time than it would take you to migrate the project back to plain js.
I'd recommend exploring generating a JSON schema for you TypeScript interfaces, and then maybe verifying your objects against that? ( [example](https://github.com/YousefED/typescript-json-schema) )
nice..this is great. Thanks!
http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf
I use runtypes for this: https://github.com/pelotom/runtypes You define your types using the runtypes library, which persist at runtime. The runtypes can validate an incoming object The best bit is that you can use runtypes ‚ÄúStatic‚Äù method to get the TS type too, so you get the same type at compile &amp; run time without any duplication The downside is that it‚Äôs an extra syntax to learn vs TS, and comments aren‚Äôt pulled out into the TS type.
thank you very much üëç
I usually use class-validator and class-transformer. First I transform the data into a class, and then validate it using a set of rules defined by decorators in the class.
[Yup](https://www.npmjs.com/package/yup) is fantastic for object schema validation. No need for futzing around with classes. It works on arrays of objects too.
I do this too. IMO the best way to do it and the author of those two libraries is very active and very good at it.
&gt; . There's no reason that the language can't have C-like performance Actually I would say that there is (or it is at least an unsolved problem) since that's what [AssemblyScript](https://docs.assemblyscript.org/) is attempting, but can only handle a subset of Typescript (no union or other fancy types.) Typescript is great but ultimately it's crippled by having to do all the weird stuff that JS does.
Haskell and rust seemed to figure out performance of union types
Shouldn't you only save-dev for types?
I write a JSON schema for my types and generate Typescript interfaces from those so I get the compile time checking. I validate the incoming objects against the schema. JSON schema can express stuff that can't be directly expressed in a Typescript interface so you need to validate against the schema rather than the generated Typescript.
Joi is another alternative that I didnt see here. I'd personally go with class-validator myself.
&gt;Javascript is really only good at one thing (quick upstart) Well as I'm writing my backend in AWS Lambdas that's fairly important for me.
Not directly related to your article but you can shorten some of you examples, eg class Track { public name: string; public artist: string; constructor (name: string, artist: string;) { this.name = name; this.artist = artist; } public play (): void { console.log(`Playing ${this.name} by ${this.artist}`); } } is the same as: class Track { constructor (public name: string, public artist: string) {} public play (): void { console.log(`Playing ${this.name} by ${this.artist}`); } }
I most use [https://app.quicktype.io/](https://app.quicktype.io/) (they have a local version that works on the cli) as it understands JSON/Json Schema and generates really nice interfaces (and runtime validation if you want it) for about 20 different languages. It's a colossal time saver when you have a .Net app talking to a backend as well as a typescript client running in the browser and some other stuff talking to a PHP (wasn't my choice I inherited it) backend. I generally just get a structure how I want it and then feed it through and output C#, PHP and TypeScript
Io-ts
https://gcanti.github.io/io-ts/
Just use a typescript generator based on your REST API. No need to write typescript classes or update them, just make it part of your build process. Swagger and/or Swashbuckle can solve most of those problems.
Maybe it has to do with composing tasks and running tsc before/after other tasks?
Sure. But does `tsc --watch` fits into this at all? Or people just use gulp-typescript incremental compilation because it's reasonably fast? (I don't know.. just guessing) From a friend of mine who's using gulp, he actually doesn't know about tsc --watch and said changing a file takes several seconds to compile, which is pretty bad IMO. `tsc --watch` can finish that in a blink.
I work on a decent size typescript project with gulp. 7+ seconds to recompile. Given the choice I would 100% go Webpack or tsc instead.
deno itself does not parse Typescript. It has a built-in TypeScript compiler to compile the code to JS, cache and send it to V8. I would say it is still a TS/JS runtime, but not a "native" TS runtime. I believe runtime checks means inserting extra JS code that validates types in the generated JS file so we have runtime guarantees (e.g. checking `instanceof` or validate if an object has certain properties), but indeed compile-time type checking is good enough. Adding these extra runtime code makes your program run slower. I do remember I saw some experiments about making the engine itself understand types, but seems that the performance boost is negligible (could not find a link to it unfortunately). V8 creates hidden classes so performance is usually great for common shapes.
Thanks for the info! That all makes sense. So from the sounds of it, it isn't impossible... which is what I was trying to figure out here. Fair enough that most people don't think it's worth it. I'd still love the option, especially when dealing with lots of JSON and abstracted declarative programming, but there doesn't seem to be enough interest out there for it in general I guess. &gt; It has a built-in TypeScript compiler Have they written their own? Or does it use Microsoft's regular tsc transpiler? Also wondering about... &gt; [We essentially have a ***runtime*** type checker, it is just "optional" at the moment for performance reasons.](https://github.com/denoland/deno/pull/1821#issuecomment-466168773) Do you know what this means exactly? How do you turn it on? And what does it actually do that's different from regular "TS-&gt;JS compile-time-checking, and execution on Node"?
We use ts-node-dev for development; I think this is the fastest way to just run your code. It is adds watch capability to the package ts-node, which can compile typescript in memory and also skip compile checks. If I am doing heavy refactoring, I also run tsc --watch inside of VS Code. We use gulp too, but only to move around static assets or for frontend apps.
To recompile even a single file change? That would be crazy I guess you haven't tried integrate tsc watch with gulp yet, right? Do you know if that's even possible?
io-ts [https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts) Allows you to explicitly define "codecs" which support JSON encoding &amp; decoding
The TS compiler is essentially `tsc`, used through Compiler API: [https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API) See [https://github.com/denoland/deno/blob/master/js/compiler.ts](https://github.com/denoland/deno/blob/master/js/compiler.ts) &amp;#x200B; I'm also not super sure about what Kitson mean about the "optional" part. He was at one point working closely with the TS team so I assume he could explain if you try to ping him in the deno Gitter chat room: [https://gitter.im/denolife/Lobby](https://gitter.im/denolife/Lobby) &amp;#x200B; As to the difference part, I believe you are more or less comparing deno to ts-node. Here's an explanation: [https://stackoverflow.com/questions/53428120/deno-vs-ts-node-whats-the-difference](https://stackoverflow.com/questions/53428120/deno-vs-ts-node-whats-the-difference) The gist: 1. deno is a different runtime with different APIs and designs from Node (e.g. permission flags, remote URL-based import and module fetching, message-passing based ) 2. TS compiler is snapshotted, so you don't have startup penalties during parsing and optimizing steps for JIT. 3. The compiler itself is involved during module resolution before evaluation in deno. The module loader essentially feed TS files to the compiler and receives generated JS files, so it could then continue the asynchronous module resolution steps (aka they are interleaved). In ts-node, I believe typechecking + compiling to JS and actually running the generated code are 2 separate steps, and Node module loaders have no idea about TS. (You'll notice that instead in the generated JS files for Deno, `.ts` extensions are kept, meaning that the loader would be able to actually resolve this file type)
I tried ts-node-dev on a different project and gave up for reason I don't even remember. Right now using tsc watch for compilation and webpack HMR to reload server, it's pretty awesome. I too, want to switch to gulp for assets copying. But concerned with integration with tsc...
Cheers, thanks again for the info!
TypeScript is just JavaScript with static types on top. The trick to understanding TypeScript, aside from understanding how types work (which is useful in dynamic JS land as well), is to understand that the types are erased at compile-time and it's all just a facade by the compiler to prevent you from writing unsafe code. There, it'll be far quicker for you to learn TS than to refactor your whole project away from TS, tool to help you do so or not.
No, that's not supported and not a goal of TypeScript.
You forgot the crown: Mapped types and conditional types.
**noAny**!
&gt; Javascript is really only good at one thing (quick upstart), so why would I want to use it for something that it isn't good at? So you say JavaScript is only good at quick upstart, and you wonder why you would use it for something that it isn't good at.... So that would mean: Why use JavaScript **at all**? A quick upstart is mostly pointless, because that is done only once.
That is a human rights violation.
Why not just have two tsconfigs? This really isn‚Äôt an issue...
Could this be because you use Webpack or Parcel to generate browser code, but not when you run code in Node? You can ease interoperability issues with the [`esModuleInterop`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#support-for-import-d-from-cjs-from-commonjs-modules-with---esmoduleinterop) and `allowSyntheticDefaultImports` compiler settings. The docs say that `esModuleInterop` "brings the generated output from TypeScript closer to that generated by Babel." Your browser code bundler most likely uses Babel. You might find this article to be informative: https://itnext.io/great-import-schism-typescript-confusion-around-imports-explained-d512fc6769c2 Imports are complicated because we have been using `import` and `export` without a real standard, and we depend on transpilers to convert those statements into code that actually works. Now that native ES Modules are supported in most JS environments we are getting closer to an ecosystem that works more consistently. But there are still a number of details that are being worked out. For more on that process see https://2ality.com/2019/04/nodejs-esm-impl.html. (TypeScript can emit native modules using the `--module esnext` setting. That option is not well documented, but there is some explanation [here](https://github.com/Microsoft/TypeScript/issues/24082).)
I do have 2 tsconfig files, one for browser and one for node. And yet I still had to do all kinds of hacks to generate 2 outputs for the 2 targets ([https://github.com/breck7/jtree/blob/master/tasks/builder.js](https://github.com/breck7/jtree/blob/master/tasks/builder.js)), while getting all of the TSC benefits at code writing time.
Thank you for the docs and info! \&gt; without a real standard I wish TypeScript just adopted the Node.js dead simple require function: const {Foo, Bar} = require("./something.js") class Bam extends Foo {} module.exports = {Foo} If people want something else, they could easily write tooling to transpile to that. The thing is nowadays during develop time you run your code in a headless node environment 1,000x more often than in a browser environment, so I wish they just used the de facto node.js standard as the one true way. Then the compiler can generate the module syntax for browsers any which way.
I don‚Äôt know, and would love to find out.
Typescript is a superset of JavaScript. CommonJS modules are not canonical JavaScript. They're not a part of the EcmaScript standard. There are reasons why the JavaScript standards committee decided to redesign the module system. Tl;DR CommonJS modules must be evaluated before you can determine their exported API. This makes tree shaking and minifying difficult. The guarantees that CommonJS are too weak, and that has performance implications. Huge bundles. Longer compile times. Read more here: https://medium.com/the-node-js-collection/an-update-on-es6-modules-in-node-js-42c958b890c
I use [ttypescript](https://github.com/cevek/ttypescript) with the [transform paths](https://github.com/LeDDGroup/typescript-transform-paths) plugin and it works a treat, even with composite projects.
Thank you for the link and information. Does anyone in the world ever want asynchronous module loading in server side Javascript? Why? It's crazy that nodejs would jump through all those hoops just in order to support the browser's new proposed module syntax. Nodejs is becoming bigger than the browsers, it should be the browsers that are adapting to nodejs' way of doing things and not the other way around. As for the problem with having to wait until evaluation, it's simple: just treat require as a keyword and handle it specially (TypeScript seems to already do this in some cases).
&gt;This looks interesting, reading through now. Thanks!
I'm interested in what you'd like to see in the samples which would make this easier, we can definitely include one. (Please make the example it very explicit too, my web tooling foo is OK but not comprehensive)
Good point. Okay I‚Äôll code something up today and submit a PR and reply here.
&gt; Nodejs is becoming bigger than the browsers lol mkay. Node bigger than browsers huh. Got any stats to back that up? You're also ranting above about how browser and node behave differently, and here ranting about how node is trying to support the same behavior as the browser.
&gt;the browser's new proposed module syntax Standardised in 2015 / ES6, sounds like you're just very behind.
I recently have been getting away from webpack during local development because it takes way too long to test changes. I've been fighting with import issues and haven't gotten it working yet. Any other advice along these lines?
The advice would be to use webpack. There is a reason webpack-dev-server exists. If it really takes so long to test changes that sounds more like a problem with your code base than with webpack itself.
I recently opened an [issue](https://github.com/microsoft/TypeScript/issues/32205) regarding this same problem on the repo. I‚Äôm still not convinced there isn‚Äôt a bug there, but the bot closed the issue anyway with almost no help :(. Looking at the module resolution trace logs, it doesn‚Äôt match with what it is actually importing. It *says* it‚Äôs importing the module I want, but it still throws an error because it didn‚Äôt actually look for types in that module. This is easily the most frustrating part of Typescript IMO.
Imports on the web are a different beast since you can't target the newest versions of JavaScript, which is why things like webpack with babel are relied on to transpile the imports to the correct target library. With Node you can use the newest shiniest features, which means the same things will not be supported in the browser. Seems like you either need two different build steps, one for the frontend to build it to static assets and one to build the backend in node, which I am assuming is just serving the frontend as static assets. Otherwise you could do a single webpack configuration and have it do both builds for you. &amp;#x200B; One approach I take though is to completely separate frontend and backend into their own projects or own folders at the minimum, with each project having its own dependencies. For instance, why would a nodeJS server want material-ui or react dependencies? Really frontend and backend should be different projects with their own package.json files.
Unfortunately I don't know of a good set of tools for developing with native modules. I would really like to try that approach myself! For now I think we are still waiting for the "webpack" of native modules.
\&gt; Got any stats to back that up? Yes. 1. Browser installs worldwide = 10 billion 1. \~ 3 billion smart phone users worldwide: [https://www.statista.com/statistics/330695/number-of-smartphone-users-worldwide/](https://www.statista.com/statistics/330695/number-of-smartphone-users-worldwide/) 2. \~ 2 billion personal computers worldwide: [https://www.statista.com/statistics/610271/worldwide-personal-computers-installed-base/](https://www.statista.com/statistics/610271/worldwide-personal-computers-installed-base/) 3. 2x for a margin of safety 4. Both #'s have plateaued. 2. IOT devices worldwide 1. iots = 30 billion [https://www.statista.com/statistics/471264/iot-number-of-connected-devices-worldwide/](https://www.statista.com/statistics/471264/iot-number-of-connected-devices-worldwide/) 2. iotsVMRate = Expected to double in 5 years to over 70B 3. Nodejs penetration rate on IOT devices: ?? (can't find the number, let's hold off for a sec) 3. \# of developers worldwide 1. \~30M [https://venturebeat.com/2019/05/23/github-adds-donation-button-token-scanning-and-enterprise-tools/](https://venturebeat.com/2019/05/23/github-adds-donation-button-token-scanning-and-enterprise-tools/) 2. \# of packages on npm 1. 1M 3. \# of packages on all other package managers combined 1. 1m 4. Node.js/Javascript marketshare: 50% 5. \# of dev machines with NodeJs estimate: 15M 4. VMs worldwide: 1. vms = Google Cloud/AWS/Azure vms: ??? (10 billion?) 2. nodeVMRate = % penetration rate of nodejs on VMS: ??? &amp;#x200B; So, the equation boils down to is this: iots \* iotsVMRate + vms \* nodeVMRate &gt; 10 billion? The growth rate in iot devices and VMs is much greater than smart phones and personal computers. So if in 2025 you have 20B vms and a penetration of 10% of nodejs on iot devices and vms, there will be more machines running nodejs javascript than browser javascript. This tipping point may have already happened.
[https://nodejs.org/api/esm.html#esm\_ecmascript\_modules](https://nodejs.org/api/esm.html#esm_ecmascript_modules) "Experimental", as of 7/14/2019. It's not too late to reverse support for this.
10% node penetration on IoT devices is.. let's just say, optimistic. Wildly optimistic. Your smart meter isn't going to be able to run node any time soon, neither is your light switch, nor your wireless headphones, and neither is a factory's sensors and controls. And you're still talking about just the ability to run node. Not node actually being used. You're IoT devices figure is also about the highest I can find, and it's unsourced (or possibly sourced, but behind a paywall). Most sources put non-IoT devices outnumbering IoT devices by about 50%, with non-IoT devices around 10B and IoT devices still well under 10B.
\&gt; Really frontend and backend should be different projects with their own package.json files. This is a good point, and I have a lot of node.js projects that don't have a browser target. However, I never have a browser project that doesn't have a node target, because headless test running is much faster in Node, and because over the lifetime of a project I'll run the test quite a lot, it makes sense to make my browser code also run in Node, as much as possible (I use base classes in node to simulate browser stuff, that I then extend to add browser functionality too).
\&gt; Your smart meter isn't going to be able to run node any time soon, neither is your light switch, nor your wireless headphones, and neither is a factory's sensors and controls. In fact, my smart meter, light switches, etc, not only run node, they USE node right now (raspberry pis ftw)! \&gt; let's just say, optimistic. Wildly optimistic. You could be right here. I have no good guess for what the true penetration rate is, my range is at least 5 orders of magnitude, probably between .001% and 20%...However, given that there are more NodeJS packages than there are packages for all other languages COMBINED, and you can't spell Internet-Of-Things without "Internet", and Javascript is the language of the internet, I would not be surprised if I am right, even if it does sound potentially wildly optimistic. \&gt; and it's unsourced It's from Statista, which I'll admit is like Wikipedia circa 2008 in terms of reliability, but still the best of its class as far as broad stat websites go. \&gt; Most sources put non-IoT devices outnumbering IoT devices by about 50%, with non-IoT devices around 10B and IoT devices still well under 10B. This sounds reasonable. But what about growth rates? In 2025, 2030, what would you estimate the chances are that node.js could be more widely used in terms of executing javascript than browsers?
Yeah I don‚Äôt really follow. The most significant tests need to be on the server itself in the form of unit and integration tests. The UI should need only simple tests around logic. I don‚Äôt really see how having the UI somehow headless in node gives you any sort of testability as far as how the UI actually behaves when a user is using it. I have never targeted node in a frontend UI... because node is for the server... the exception may be for something like server side rendering.
This is a good point, and maybe I can minimize my UI code more to require less UI test code. I'm not sure though, as the UI's I am working with push the envelope of the browser environment, which might indeed require a lot of testing. But something for me to ponder, thanks.
I don‚Äôt see how you can really test the UI with a headless browser without a prohibitive amount of code. Like I‚Äôm just not sure I understand what risk these tests are actually reducing or mitigating. I‚Äôm not saying it‚Äôs not possible but I guess I don‚Äôt understand what the test assertions actually are. Can you link me to some code?