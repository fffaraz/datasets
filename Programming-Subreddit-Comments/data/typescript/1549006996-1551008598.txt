I wish there was way to configure typescript use `Readonly` for every new literals by default. So that if i need mutable data i would specify it like `const foo: Mutable&lt;{prop: "val"}&gt;`
little self promotion but this is a good example of conditional + mapped + recursive types: https://github.com/HohensteinGroup/ChangeChecker/blob/master/src/DiffTypes.ts They transform a given type to diff 
thanks!
Just curious, why do you use Babel with TS?
Browser compatibility
Or just link to the original article, instead of this garbage website: https://blogs.msdn.microsoft.com/typescript/2019/01/31/announcing-typescript-3-3/
You can use Babel plugins without running two compilers. For example Emotion and styled-components have really good plugins for DX improvements. &amp;#x200B; Also if you already known how to setup Babel adding TS to it is trivial.
Here's the PR with examples [https://github.com/Microsoft/TypeScript/pull/29510](https://github.com/Microsoft/TypeScript/pull/29510) &amp;#x200B; It should be out with TS 3.4 at the end of march.
I think many of the more advanced features in TypeScript are really aimed for library authors. For example complex conditional types are rarely very readable I would not want to see them in project code but they can be used to the implement really nice APIs in libraries.
I've had to occasionally use more advanced types for actual application code, but it is true that most of my usage of advanced type features is definitely when writing library style code.
I just found that it's nicer in dev to have the faster builds for hot reloading and because TS errors surface in VSCode. Also use tsc in staging/production builds that happen less frequently. Ideally I'd like to use `tsc` everywhere, but the speed difference was quite significant, which is why I'm wondering about the difference on this release.
Your function expects a boolean return value, and you're returning a string. Change the return type to string. 
You don't need type definitions to use JS functions, but they'll be (gasp) _untyped_! There are tsconfig.json options to disallow impilicit any which would force you define types for functions within your project. Type definition files add types to functions ad-hoc for javascript modules/libraries, but TS won't complain (by default) if you use untyped JS functions. At some point you'll come across '@types' packages, which is another instance of this.
The TypeScript lead developer has set up a sample project, it's fairly a good starting point. [https://github.com/RyanCavanaugh/project-references-demo](https://github.com/RyanCavanaugh/project-references-demo)
You donâ€™t have to.... but I think itâ€™s a good idea to use them or @types whenever possible. Ts is a typed language so I always try to keep everything typed if I can.
Doesn't TypeScript compile to ES5 though?
Here's [the entire source of `redux-thunk`](https://github.com/reduxjs/redux-thunk/blob/4bfa41ceb4281131ccbe9eeda87c07aeaf63b014/src/index.js): return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); }; } const thunk = createThunkMiddleware(); thunk.withExtraArgument = createThunkMiddleware; export default thunk; Normally, the thunk middleware just passes `dispatch` and `getState` as arguments to the thunk function. However, you can create a custom instance of the middleware that passes whatever other argument you want as the third parameter. This is usfeul for dependency injection, like passing in a real API request module in prod, and a mock API request module in test.
Unfortunately I have to downvote this because the article is no more useful than the official blog post (https://blogs.msdn.microsoft.com/typescript/2019/01/31/announcing-typescript-3-3/) which was also posted to this subreddit (https://www.reddit.com/r/typescript/comments/altvv0/announcing_typescript_33/): this article is more vague and has ads.
I don't have a full-on boilerplate handy, but I've had some decent success using react, redux, redux-thunk and a new-ish library called immer-reducer. Heres some code I just whipped up. import { createActionCreators, createReducerFunction, ImmerReducer, } from 'immer-reducer'; import { applyMiddleware, combineReducers, createStore, Dispatch } from 'redux'; import thunk from 'redux-thunk'; // the reducer class FooReducer extends ImmerReducer&lt;{ foo: string }&gt; { updateFoo(value: string) { this.draftState.foo = value; } } // actions const FooActions = createActionCreators(FooReducer); // create the root reducer const rootReducer = combineReducers&lt;{ fooStore: { foo: string }; }&gt;({ fooStore: createReducerFunction(FooReducer, { foo: 'initialFoo' }), }); // create the store const store = createStore(rootReducer, applyMiddleware(thunk)); const updateFoo = (newFoo: string) =&gt; (dispatch: Dispatch) =&gt; { dispatch(FooActions.updateFoo(newFoo)); }; // create a thunk action creator const updateFooAsync = (newFoo: string) =&gt; async (dispatch: Dispatch) =&gt; { dispatch(FooActions.updateFoo(newFoo)); }; async function main() { console.log(store.getState().fooStore.foo); // 'initialFoo' updateFoo('Bar')(store.dispatch); console.log(store.getState().fooStore.foo); // 'Bar' await updateFooAsync('Baz')(store.dispatch); console.log(store.getState().fooStore.foo); // 'Baz' } main(); 
This always works &amp;#x200B; const foo = Object.freeze({ foo: 'bar' }); &amp;#x200B;
Hopefully this will fix it? [https://github.com/Microsoft/TypeScript/pull/26797](https://github.com/Microsoft/TypeScript/pull/26797) &amp;#x200B;
Redux-starter-kit has all of these things. It's a very simple library.
Great to see someone else suggesting it! I'd appreciate any feedback on how well it's working for you, and what else might be useful to include. 
Thanks, I didn't know about this project.
That's a nice alternative. However, I think the problem of having people use `Record` first instead of anything else (and not considering the type safety issues that come with it) will remain.
does your tsconfig.json have strict: true? 
Here's what I tend to use [https://github.com/epeli/typescript-redux-todoapp](https://github.com/epeli/typescript-redux-todoapp) 
Please give this a read. https://medium.com/@ankeet.maini/type-redux-with-typescript-without-writing-any-types-5f96cbfef806 There's a GitHub project link in the post with the sample app.
This post eventually brought me to the Advanced Types page, https://www.typescriptlang.org/docs/handbook/advanced-types.html Typescript really is a programming language nerd's programming language! :) I don't use a quarter of these advanced type constructions, but I appreciate that they exist. 
This looks awesome. Now I have something to play with during the weekend :)
Pretty sure it is set to "false". I'll experiment with that when I'm back at work on Monday.
 As a TypeScript beginner, I've had trouble creating a String Literal Type to restrict a variable to DOM type string such as "div", "p", "a", etc. After some struggle, I found out that it wasn't possible in v 3.3 (but will be possible in 3.4). I found out a workaround using "keyof" operator. Instead of using an array of strings, I used an object with DOM types as keys. TypeScript has been both fun and troublesome. This was a fun/challenging learning process.
Decent article, and I appreciate the advert being at the end, not the beginning. Though, I wish people would move a way from the term "runtime types" and call these things what they really are: *manifest contracts.* &amp;#x200B; Some feedback on the article. I may have introduced \`Either&lt;T&gt;\` as \`Error&lt;T&gt;\` instead, then show that it generalises to \`Either&lt;L,R&gt;\`. This is a minor thing, overall it was very readable. The best part of the article IMO is that it includes a practical, and fully presented example (reducers). 
Not sure if I got it correctly, but isn't `type TDOM = "div" | "p" | "a"` exactly what you needed?
That's exactly the result I wanted. But from an array (which wasn't possible). I have an array [100 elements](https://github.com/dance2die/dangerous/blob/master/src/domElements.ts) (so about 100+). And they are used for other purposes as well. Didn't want to have multiple places to maintain the type.
I guess it should be possible with `type T = typeof array[number]`, but it may not be that straightforward, need to check.
I've tried it but the type is infered as string. [https://codesandbox.io/s/qrrq24k7q](https://codesandbox.io/s/qrrq24k7q)
checkout [https://github.com/kimamula/ts-transformer-keys](https://github.com/kimamula/ts-transformer-keys)
https://github.com/sandervspl/ts-react-redux-boilerplate Does not have immer but has everything else
May I ask how this library differs from `keyof` operator? And is it a norm in TypeScript ecosystem to use 3rd party library like this to create types if TypeScript doesn't support certain features?
keyof exists purely in the type system, so there's no actual array of string values at runtime. The transformer generates an array literal of string literals. Depending on the situation, a good alternative is to write the array literal (or object literal or some sort of other runtime value) and let the type system's inference derive the necessary types from there. But it depends on the situation.
You can do it from an array variable using a function helper and generic inference. function literals&lt;T extends string&gt;(array: ReadonlyArray&lt;T&gt;) {return array} type TDOM = (typeof TDOM)[number]; const TDOM = literals(['div', 'p', 'a']); [Playground link](https://typescript-play.js.org/#code/GYVwdgxgLglg9mABAGxlApgJwIbIM4A8AKougB4ZgAmeieUmMYA5gHwAU2mOAngFyIASumxUEyHgEFu2HsVYBKRAG9M6KCExIuvAL4AofVB4AHdIiIARAPIBZRAF5E7Y2bjALN2woDaYEAC2AEZYALoA3PoQCPSedo4oaFi4eOw++gDkqBg4yACMGQA0mdnJyABMRSVJuQDMVVk1uAAsDaW5AKxtTcgAbN05uADsA2UAHKO5AJyTuHkADLP5BcWNg-mVq+1z9Vs9ea1763ldR2V5-We5eSNXcxN3+TOP5YsvK9Xr5ZufZeW7v1y5UOgNw5VOoIql0h5VuMIeMOekNqb2RHzWZVqPwxdQBONwtRB+OQtQhxNq0PJcPJCPJSOJzVRDPR22QzWxrOaeM5RM5ZM5lM51M5tM59NZHSZEpZPQ6HNl3NlvNl-Nlgtlwtlotl4p6vSlepl6168uNiuNyuNquN6uNmuN2uNuvWQwNLqNZSGps95s9ls91s9ts99s9js9zvGbvGHtyY29cd9cf9ccDceDcdDcfDccj02j01juCmCeLSeLKeLaeLGeLWeLOeLebm8wLLaL+Xmpc75c7lc71c7tc79c7jc7zeWbeWHbyeW7c97c-7c8Hc+Hc9Hc-Hc8n8+n89n3yW86XwJP4IvG9hF535T3KJPtVnWKfS8JT7XFKfW9qO9qe6MiezSzuywFLs0K7NGuzQbs0W7NDuzR7pKJ4dLOcpoUuHQrh0a4dBuHRbh0O4dHu+onr0s4mpRS69CuvRrr0G69FuvQ7r0e6uieQyzl6PFLkMK5DGuQwbkMW5DDuQx7mMB5jLO8YnmMS5jCuYxrmMG5jFuYw7mMe5TAeUyziWJ5TEuUwrlMa5TBuUxblMO5TJOryokAA) More generally, this is a useful trick to keep in your back pocket: often you can use generics to trigger type narrowing. TypeScript tries to grab a more specific type for `T` because you asked for it. It can be used to pluck literals out of an object literal's properties, too. The function will compile down to `function(a) {return a}` which, if it's in a hot code path, should be inlined by the VM, so performance should not be an issue.
&gt;keyof exists purely in the type system, so there's no actual array of string values at runtime Thank you u/cspotcode for the clarification. After reading your comment and tried on TypeScript playground to see type DOMTypes = 'a' | 'div' | 'p'; let dom: DOMTypes = 'p'; turn into var dom = 'p'; without any string literal information. &gt;Depending on the situation, a good alternative is to write the array literal For my situation, I was importing an array from another file, thus passing literal values wasn't an option. (And also tried it [other comment](https://www.reddit.com/r/typescript/comments/amh8cu/dynamically_build_typescript_string_literal_type/efly6eq/), as well)
I think my other reply explains how to achieve what you want with an array literal. But let me know if you have any questions; I'm happy to help.
I'd have to go deeper with TypeScript type system ðŸ˜… Thank you ðŸ¤œ
Once const contexts make it into a release from master you can write: `const doms = ['a', 'div', 'p'] as const;` and get the type: `readonly ['a', 'div', 'p']` inferred automatically.
This is the function I usually use for these things const mkTupleFn = &lt;T = any&gt;() =&gt; &lt;Xs extends T[]&gt;(...xs: Xs) =&gt; xs // infers arguments as their widened types const tuple = mkTupleFn() // does not widen arguments, but only accepts strings, numbers, booleans const litTuple = mkTupleFn&lt;string | number | boolean&gt;() With partial type argument inference we could simplify by not having the intermediate function, but then you'd have to specify at every call-site. With typescript 3.4 this should become unnecessary because you can use the `as const` syntax to prevent widening
You need strict: true and some other flags if you want to see all issues. You should read this entire table https://www.typescriptlang.org/docs/handbook/compiler-options.html
You can specify the base dir for output in tsconfig.json. You could have your source ts files in a src folder and make a dist folder for the js files. The dist folder would be the same directory structure as the src folder but it would be js instead of ts and those are the files that would actually run.
Don't check JS files into Git
[removed]
Adding to this: create a tsconfig and set the rootDir and outDir options. Add the outDir to your gitignore. If you want to publish your code as a library: publish the `dist` *and* `src` directories. Enable the options for sourcemap, declaration, and declarationMap. When all of this is done, `tsc` is all you need to rebuild the project.
why publish src? it just adds extra download weight.
When debugging, someone might want step into your code. The sourcemaps refer to the source, so that debugging shows the source .ts instead of the transpiled .js. If you bake the sources into the sourcemaps then it'll take more space due to JSON encoding.
TIL. thanks!
It's cool for sure! From a research perspective, even though the type constructions aren't "innovative", I do find typescript interesting; especially the engineering trade-offs involved in bolting types onto a highly dynamic language (and ecosystem!) that has evolved with zero regard for them.
If you use TS with Create React App by using `create-react-app MyProject --typescript` it compiles with Babel. That's how I use TS most of the time.
I've never made an NPM module, but wondering... if you're doing that, I'm guessing that you generally would commit the JS files to git so that they're distributed with the package, and usable by plain JS devs?
Generally open source projects will also use a continuous integration platform, like Travis or CircleCI. Whenever a Git commit happens, the CI server will run a build routine to handle first compiling TS files and then publishing a package to NPM. So you still wouldn't commit JS files to Git. Instead you configure the TypeScript compiler to output declaration files along with JS files. NPM modules can specify a `types` property in package.json which points to an entry .d.ts file. The package published to NPM would contain .js files and .d.ts files.
This is a great post thanks. 
It means redux dispatch() can be called with either a standard action as the parameter, or a thunk. redux-thunk handles this in the store middleware that you apply when setting up your store.
You'll want to use a ThunkDispatch type during mapDispatchToProps. ''' const mapDispatchToProps = (dispatch: ThunkDispatch&lt;AppStateType, void, AllPossibleActionTypes&gt;) =&gt; ... '''
isNullOrUndefined() | !isNullOrUndefined
`var == null`
 // A typed unary function type Fn&lt;T, U&gt; = (a: T) =&gt; U; // Enforced synchronous unary function type SyncFn&lt;T, U&gt; = (a: T) =&gt; U extends Promise&lt;_&gt; ? never : U; // Enforced asynchronous unary function type AsyncFn&lt;T, U&gt; = (a: T) =&gt; Promise&lt;U&gt;; // Unwrapped Promise type Resolved&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;
i dont get SyncFn... how is it sync if youre using a promise? also Unwrapped Promise looks interesting but again have to think about where iâ€™d use it. thanks for sharing!
If there's any chance it's a Promise, `tsc` will throw an error from the `never` type.
`type Omit = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;` I wish they'd just add it to the standard lib since it's so common even if it's simple to make.
Unwrap type from a promise &amp;#x200B; \` type PromiseType&lt;T&gt; = T extends Promise&lt;infer V&gt; ? V : T;\` &amp;#x200B; Same fro array &amp;#x200B; \` type ArrayType&lt;T&gt; = T extends Array&lt;infer V&gt; ? V : T;\`
Iâ€™m still learning Typescript. What does this do and why would I want to use it?
yep, use it in almost every project. &amp;#x200B; I use this quite a lot. `type maybe&lt;T&gt; = T | null` &amp;#x200B;
\`type Dictionary&lt;T&gt; = { \[key: string\]: T }\` \`type MapFunc&lt;In, Out&gt; = (in: In) =&gt; Out\` &amp;#x200B;
For example if you use a libary which exposes an async function (eg. promise returning function) you can use the `PromiseType` with the buildin `ReturnType` to get it's return type: ``` const value: PromiseType&lt;ReturnType&lt;typeof someAsyncFunction&gt;&gt;; ``` 
 // simpler function types type Fn&lt;As extends any[], R&gt; = (...args: As) =&gt; R // unary Refinement function type Refinement&lt;A, B extends A&gt; = (x: A) =&gt; x is B // unary predicate function type Predicate&lt;A&gt; = Fn&lt;[A], boolean&gt;
I need to get better at writing custom types. It's one of my bigger productivity bottlenecks. I can write basic interfaces and such but that's about it. Can anyone recommend some resources so I can get better at this?
Excuse my ignorance, when is this useful?
What does the rest of your tooling and dependencies look like? The advice I would give is tooling specific. 
It's useful for when you want to omit a set of properties from a type. Sometimes, you want everything in an object except for a very select few properties, that's a job for Omit. For example you could do `type SettingsPageProps = Omit&lt;ServerConfig, immutableSetting1' | 'invisibleSetting2'&gt;` . It's especially useful when you don't control the data model of the server but need to create types based off said data model.
If you haven't already set up a test runner I would too. Give users an example for how to set up Global config stuff for setup and teardown. That was the biggest learning curve for me and TS. Outside of that anything else would be specific to whatever other tooling you want to use
Thanks for the explanation!
Should it be null or undefined though? Null is weird because typeof null is 'object'. On the other hand null is useful for databases/JSON. In practice I tend to write `let t: T | undefined` most of the time.
Read the advanced types documentation. My browser auto completes to that URL pretty quickly these days, its where all of the non-obvious type tricks are, and I've found quite a lot of uses for them. Be prepared for slow builds, especially if you're in a corporate environment with backup and antivirus services, seems to hit typescript projects particularly hard.
I set up prettier with arrowParens: "always" because it makes it easier to add typings to arguments. 
Typescript noon. What does this mean?
&gt;this &gt;[th is] &gt;1. &gt;*(used to indicate a person, thing, idea, state, event, time, remark, etc., as present, near, just mentioned or pointed out, supposed to be understood, or by way of emphasis): e.g **This is my coat.**
You don't need to type every single thing. My WebStorm IDE usually infers most things and complains when it can't, which is when you need top add the types. Don't be afraid to use a strict config (e.g. no implicit any).
It'll omit properties from an object. I've since edited my original comment to add more detail since I've gotten this question a few times. Hope this helps.
Decide on a good tslint and get everyone onboard from the start. I like to start from a popular standard one like Angular or the AirBNB one. Also having any's in the new TS versions is a no-no.
Pay attention to generic classes, functions, etc. If you don't specify a type, sometimes TS will infer the type to be `{}`. Other times, the underlying generic code might have a default value that you weren't expecting. If you get a weird type error, check to see if you're working with generics in some fashion.
Enable strict null checking, if that's your thing.
Isnâ€™t what you just said rather conflicting? &gt; donâ€™t always define your types &gt; no implicit any
No it's not conflicting. There's many cases where you don't need to declare the type (and it doesn't "become" any). &amp;#x200B; Not using implicit any is great for creating higher quality software, since whenever something "becomes" any you really need declarations. &amp;#x200B; Be lazy when you can. The code will become cleaner :-)
Ah I gotchu. Like using var in C# when possible to do so 
Would work as well I guess. With strict mode Typescript forces me to check if the object is null this way which is nice.
About slow builds: With Babel &amp; webpack use https://www.npmjs.com/package/fork-ts-checker-webpack-plugin to speed up builds coupled with ts isolated modules flag. Also, ts is continuously rolling great monorepo support so op can consider it starting bare anyway. 
So, he was wrong about one thing, WebStorm isn't the one doing the inferring, it's `tsc` doing the inferring. It's got a fairly powerful inference engine. So you can (and should), write things like `const arr = [1, 2, 3]`, and it'll get the type of `number[]`. The `no-implicit-any` flag is more for functions: function changeNumber(x) { return 2 * x; } For instance, this would have `x` typed as `any` since the compiler has no idea what you're trying to give it. One last thing about the intersection between these, is that the inference engine also handles inline functions pretty well: const arr = [1, 2, 3]; arr.map(x =&gt; 2 * x); This works since `tsc` knows it's running the function across an array of numbers, and the only type it'll get as `x` is a number. No typing necessary!
&gt; Also having any's in the new TS versions is a no-no. If you're starting greenfield, definitely, _definitely_ add [this to your ts-lint](https://palantir.github.io/tslint/rules/no-any/) in addition to `no-implicit-any`.
great answer, very kind of you
A better name would probably be \`Nullable&lt;T&gt;\` since TypeScript already has a \`NonNullable&lt;T&gt;\`.
\`\`\` type Exact&lt; A extends object, B extends A \&gt; = A &amp; Record&lt;Exclude&lt;keyof B, keyof A&gt;, never&gt; \`\`\` I use this all the time. 
I tend to avoid using "as Interface" after object notation. It can mask lo tea of issues like missing required properties. If you're using vscode then the prettify extension is good but can cause issues with tslint till it's configured correctly.
when is MapFunc useful?
I tried to make my tslint.json as "helpful" as possible: https://pastebin.com/2U5cNiuW
We're coming off a react-native project where the Flow typechecking stage in the Jenkins build takes 5 minutes. I'm not super worried about it.
We're building a React project and so far what we know is we're going with a reasonably popular React stack: styled-components, React, webpack, jest, storybook. People on the team are pretty close to 50/50 WebStorm vs. VSCode. 
About tooling: If you have a project (for example web server) that you both want to test and to run at the same time, it's a complete waste of time to compile the same code more than once, use a watcher (`tsc -w`) in one terminal tab and run the tests/server as JS in separate tabs - without any compiling or ts-node.
Unfortunately that doesn't help me much, we're embedding react typescript apps inside of Java springboot backends, and I pretty much have to deal with a clean install every single time. At least it doesn't delete node modules every build. I am used to seeing several minute build times when packaging up the whole thing, but hot reloading during development only takes a couple seconds.
Same for me.
I just find myself creating functions that transform values a ton. I like seeing a common name in the default to just know that hey, this thing is just another transformer. I think itâ€™s about being easier to scan quickly just like dictionary is for me.
Turn the strictness to max. Try Prettier. I use it on file save in vscode. Just type in unreadable, but correct code, and have it automagically formatted. Never waste time on formatting again. 
tried the ts docs for advanced types?
I'd much prefer a helper function as he suggested over your suggestion. Yours adds some cognitive load. I have to notice that it's a weak comparison `==` and not the `===` and remember that it checks for `null` and `undefined`.
Sometimes you fight the compiler because you don't know how to express your code with types yet, sometimes you fight the compiler because you're exploiting the dynamic nature of javascript to a dangerous/confusing extent (at least in my opinion). I started giving in to things that are easier to express to the type system so it can watch my back, and I think it's been really rewarding. &amp;#x200B; On a more specific note, I suggest always typing your function input and output--except for maybe closures or non-exported functions. Most people would probably agree on typing input parameters, but likely disagree on output since typescript is very good at inferring the output type. I find it benefits the whole team from a documentation point of view, as well as catches some incorrect assumptions you may have about what the function returns. I do make an exception when the inference is a more narrow/exact type than is reasonable for me to write out manually (like when large union types are involved).
When you run into generics, you don't have to use single-letter generic names. Using more descriptive naming can be really nice to add context to what purpose the generic serves.
I'm using the == null check all the time. Does not feel like cognitive load to me. What I'm interested in is if there is some value, which the null check explicitly does. I don't really care much for the distinction between null and undefined, can't really think of a case where I would want different behavior in both cases (there might be some, but this should be incredibly rare). I'm also never using === anywhere - the compiler already warns me if I compare unequal types. I feel like the need for === everywhere is an artifact of Javascript which can be safely dropped. 
What are the API differences? In other words, what happens when I use a type assertion to use node's EventEmitter but with these type declarations?
The closure compiler solutions are the only ones I'm aware of. This seems like something a custom TS transformer could accomplish as well. It could emit non-private properties in quotes, so that uglify can mangle them. Or it could handle the renaming itself.
whats a good practical usecase for NonNullable?
Going against the grain here to say don't be afraid to use a few any types, matched with some TODO comments in your code, while you're adopting it. The pain usually doesn't come from your business logic with primitives - it usually arises from integrating high level third party libraries with advanced types. Don't let it get in the way of your team to the point where people start resenting it and looking for ways to avoid the type system. Tooling, definitions, and community support is getting better throughout the ecosystem daily. Stick with it and when you go back to a plain JS project in a few months I promise you'll tear your hair out and come running back to the sanity that type safety provides in no time.
When to use interfaces vs types. 
Always use interfaces. Read up on SOLID.
Run in strict mode. Keeps you green to all new TS features. Use VS Code. Best TS IDE out there. &amp;#x200B; Use TSLint. Pick from a popular config or use the tslint extended one. What I'd recommend doing though is creating your own module that exports your own config that extends from whatever you choose. It allows you to fine tune it and your team will get the benefits. &amp;#x200B; Interfaces are your friend. Use the *any* type sparingly.
string union types! if you have something that should only be a certain set of strings, say Content-Type should only be 'json' or 'blob' you can make a type `export type RestContentType = 'json' | 'blob'` now there's no way the compiler will let you put say 'xml' in there.
TypeScript will give you just as much type checking as you want or need. You can turn on or off various levels of implicit \`any\` typing, to make it easy to migrate and decide as a team exactly what settings you need. &amp;#x200B; &amp;#x200B;
And to add more arguments when needed. And is more consistent since it's aways there.
Any case where an input type might be nullable, but an output is not. For example, function filterNonNull&lt;T&gt;(xs: Array&lt;T&gt;): Array&lt;NonNullable&lt;T&gt;&gt;
Thanks for this! It was a good read :)
Be careful when editing files and cleaning up directories. If you accidentally make your changes to the JS file instead of the TS file, the compiler will overwrite you changes. A mistake that I just made recently despite having used TypeScript for years: I had created several simple JS files for a demo site in a folder for support files. But I also had cleanup rule that ran as a pre-build task. When I restarted the TypeScript watcher, it cleared out all of my JS files as well. Fortunately Webstorm's Local History saved me because I had a presentation in 15 minutes. 
\+1 VS Code. We used to be a mix of Atom, Sublime, and IntelliJ but most people now just us VS code since moving to Typescript. Also, when using TS Lint + VS Code, set lint errors to show as "warning" - that way they get highlighted separate from type errors. In fact, we started committing our .vscode files and sharing launch configs. Another thing... VS code does a good job reading types for the open file, but if you are refactoring and want to see how changes affect other files, you'll want to run \`tsc\` from inside VS Code as a "Build command."
if a function returns `Promise&lt;string&gt;` and you want access to the type `string` from the promise. (obviously more useful if it's something more interesting than just `string`
Alright thanks for that
Ahh yep, think I initially made the mistake of using this to type the dispatch in the return function in my action. Thanks
Ts lint. Make the rules strict. You can always loosen them later, but it's a lot of refactoring to make them more strict. Specifically, be sure to turn on "no implicit any". Without it you can accidentally do all sorts of stupid things and totally bypass type safety without even realizing it.
Although it seems like a huge job at the start; getting to run your compiler with `strict: true` as soon as possible pays off. Either turn it on and go through one file and turn it off again, or bite the bullet and get most small things fixed instantly; you'll get the hang of what the compiler wants and expects real fast. A strict codebase really is worth it.
No unused vars is annoying while developing, fine for the final build though
No unused vars is amazing while developing. Fight me. 
Well done for turning on strict mode from the get-go, you'll appreciate that in the long-term. The only other thing I'd say is be aware of TypeScript's footguns. For example, even in strict mode, the following TypeError is possible: const arr = ['abc']; // inferred by compiler as string[] arr[1].trim(); This is possible because the compiler treats array access - tuples not included - as safe by default, presumably to make the language more approachable. So, although accessing an array of variable length should really return type `T | undefined`, it returns `T`. There's a tracking issue for this on GitHub. Oh, and there's a ton of cool stuff on TypeScript's GitHub, and the devs are fairly active in the community. If there's something you want to see in the language, chances are there's an issue for it.
I prefer `null` because it carries some intent with it, sort of like the looser equivalent of `None` in the `Option`/`Maybe` ADT. You can always directly check `if (val === null)`, and TypeScript will correctly narrow with that.
If it's not, make it your thing.
`tslint-config-prettier` makes that concern a non-issue.
It's very hard to transition a code base with `noImplicitAny` which has JS in it. We turned it on after the last JS file was converted and cleaned up the missing spots. Unless you know something I don't.
Just set it emit with errors.
We don't have JS test coverage, just integration tests in chrome headless. I feel like types give all the fine grained coverage we need.
A few random things off the to of my head in no particular order * Try to avoid any as much as you can, even if you're translating a javascript project. This is because it can kind of 'infect' your code-base. In a deep hierarchy of abstractions and components, one any in the chain loses all your type safety and can easily mask errors. I like this instead: https://hackernoon.com/typescript-tip-dont-use-naked-any-create-an-any-interface-instead-730bdd2fc224 * Use all the strictness flags, and be explicit about your types. Set up the linter accordingly. * Get familiar with the advanced type level concepts like conditional and mapped types. These can very often elegantly help you maintain invariants in your code. 
Your example code does not compile. state =&gt; ({ data: state.data }), // property data does not exist on type {}
Nah, you just set main to `lib/index.js` and ignore `lib`. Then you set to build on `postinstall` and `prepublish`. Add `src` to your `.npmignore` and output source maps.
I don't think that's it. Even after returning a JSX element (instead of null) and (b) specifying the state as \`ApplicationState&lt;T&gt;\` it reports the same issue. function MyComponent&lt;T, K extends keyof T&gt;( opts: InputProps&lt;T, K&gt; ): JSX.Element { return &lt;div /&gt;; } // Redux container function InputsOf&lt;T&gt;() { return { Input: connect( // state to props (state: ApplicationState&lt;T&gt;) =&gt; ({ data: state.data }), // don't care... () =&gt; {} )(MyComponent) }; }
&gt;I don't think that's it. Didn't think it would be. But when wanting to take a look at the issue it's annoying if the provided example code does not even compile.
I appreciate the time.
Yea that is a good tip, setting the lint errors to warning. I found it so annoying that they default to error, but I get it. I haven't been able to coax my team to check in the .vscode folder yet, even though we all use vscode. What has helped me immensely though was the addition of the launch config in the user settings that applies to all projects. So I just have my launch configs set in there. Eases the burden of having to create the same launch tasks for each project. Now I wish they would do the same thing for tasks. I copy paste the same tsc watch task to each project.
I agree, it is difficult. That could be one of the last things turned on, but I think that setting exposes places in a js code base that are in need of an explicit interface.
Yeah.. actually the launch configs is why people started committing their vscode files! It's pretty hard to get it just right if you want breakpoints in the editor, and we use ts-node as well
I don't have any advice as to the actual implementation, but take a look at Google App Scripts. 
&gt; What are the API differences? In other words, what happens when I use a type assertion to use node's EventEmitter but with these type declarations? IIRC OP added a minor feature, but I can't recall what it was. You can find out the difference by comparing his functions to Node's `events`. &gt; EDIT: and what if I wrote a minimal wrapper around node's EventEmitter to transform its API to be compatible with ee-ts? What would need to happen in that wrapper? That would reduce the bundle size. I would recommend against it. Just use NodeJS's event emitter. Don't overcomplicate things by copying standard libraries with minor changes. Future you and/or your colleagues will be thankful because they don't have to figure out whats different and why.
Why does the component that calls useFetch not handle the loading state? Thatâ€™s what I would have expected
That's not something you'd ever want to do. What you need is a HOC that owns the values and names.
Looks a lot like [stix](https://stixjs.io/). You know, the one where you started emailing the people that starred the repository to spam your framework.
Hey, but that's not how Suspense is supposed to work :) Any component (no matter how far down in the tree) can be suspend whole subtree (here's done by using the hook) up to first Suspense instance. This article mentioned it. The whole point is gracefully handling nested, async code splitting and API calls. You can think about it as loading state context. If you want to collocate it, just wrap your component in in some hoc with suspense or ask the author for no-suspense node :)
Super short answer: - Use TSC for type checking - Use Babel for compilation This explains why: https://iamturns.com/typescript-babel/ This explains how: https://github.com/Microsoft/TypeScript-Babel-Starter
&gt; I'm using the == null check all the time. Does not feel like cognitive load to me. Consider other readers of your code. They have no idea whether you are intentionally checking both null and undefined, or whether you accidentally left off an `=` sign.
you dont use any typescript loader since babel is doing it
Thanks. The tl;dr of why that I got out of it was that it's faster and simpler because you stop typescript from compiling on save (or at all) and only use it by manually running an npm command to check types. That sounds like more of a hassle to me than compile on save, honestly. But speeding up compile time could be worth it I suppose. 
&gt; you stop typescript from compiling on save (or at all) Exactly. It's worth noting that Babel can still compile on save if you want, as well as tsc type checking on save
So if understand well: With the babel typescript loader the typescript source is just compiled to js but no type checking (so if we took just this step in isolation typescript would be useless) And beside this we also run a typescript process WITH type checking but WITHOUT compilation to js. Can also put this in a watcher
Correct
I don't understand the benefit of this: ``` This is the second advantage of Babel stripping out TypeScript code during compilation. You write code, you save, and it compiles (very quickly) without checking for type safety. Keep experimenting with your solution until youâ€™re ready to check the code for errors. This workflow keeps you in the zone as youâ€™re coding. ``` I _like_ that when I save, my webpack dashboard will complain about broken types. Without this, aren't I just hiding problems that will need to be addressed?
&gt; knowing that ts already knows about es6 features? You may want to use newer features like [optional chaining](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties), [the pipeline operator](https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator) or [do expressions](https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions)
&gt;I like that when I save, my webpack dashboard will complain about broken types. Without this, aren't I just hiding problems that will need to be addressed? Nope, `tsc` can (and should) still check types in a watcher. You're just handing the actual compilation off to Babel.
I think you misunderstand; I wasn't asking for a bunch of obvious principles to be reiterated. I was asking for more specific information.
I can't wait for the pipeline operator to be released so I can disable it forever.
For me, it was the path of least resistance. React Native uses babel already, so hooking into that pipeline made sense.
Curious as I've barely started using it myself, what is it that you don't like about it? Or is it a personal dislike for functional programming?
If you target ES6, then you don't really need babel, however if you target ES5, then you might need some polyfills. When you are working with TypeScript, it assumes that certain functions exist. e.g. tsconfig.json { "compilerOptions": { "target": "ES5", "lib": ["DOM", "ES2017"] } } We are telling TypeScript that we want our code transpiled to be ES5. And by using lib DOM and ES2017, we promise TypeScript that we are developing for a browser and function like `Array.from` are available. The easiest thing to do is to use a library like `@babel/polyfill` or create your own custom polyfills.js and finding the polyfills that you need, e.g., [Array.from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) Personally i prefer to manually add them to avoid having another node_module. The polyfills you most frequently would use would be `Array.prototype.map, Array.prototype.find, Array.prototype.some`, `Array.prototype.find, Array.prototype.reduce`, `Array.prototype.includes, Array.from`, `Object.entries` and `Object.values`. Then you would slowly add the extra polyfills as you go.
In that scenario, is tsc launched independently of my webpack dev server? Assuming yes?
Yep! You can open it in another terminal tab or something. I suppose you could also make a new script `webpack-dev-server &amp;&amp; tsc` that does it all at once. It's been a while for me though so idk if that would work.
For TypeScript consider using the TSLint. There are ready to use TSLint configurations that you may consider: TSLint Config Standard - standard style rules TSLint Config Airbnb - Airbnb style guide TSLint Clean Code - TSLint rules inspired be the Clean Code: A Handbook of Agile Software Craftsmanship TSLint react - lint rules related to React &amp; JSX TSLint + Prettier - lint rules for Prettier code formatter ESLint rules for TSLint - ESLint rules for TypeScript Immutable - rules to disable mutation in TypeScript &amp;#x200B; Additionally you can check: [https://github.com/labs42io/clean-code-typescript](https://github.com/labs42io/clean-code-typescript) 
Not sure why you say you'd never want to do this. Could you explain why? Also, what is a HOC?
If you want to change the callsite semantics of a function, the function should declare that it's infix or whatever. Allowing anyone to arbitrarily call any expression in a different style than it was declared is a recipe for horribly unreadable code. The JS community as a unit is terrible about desiring features, using features, and structuring code in a way that promotes write-ability at the cost of read-ability. This is the latest in a long list of bad ideas that make JS (already the language with arguably the highest cognitive overhead to reading) even harder to read, like the bind operator. The proposal lists this as an example for increased readability: let newScore = person.score |&gt; double |&gt; (_ =&gt; add(7, _)) |&gt; (_ =&gt; boundScore(0, 100, _)); // instead of: newScore = boundScore(0, 100, add(7, double(person.score))) When the actual correct code for this scenario, whether the operator exists or not, is: let curvedScore = add(7, double(person.score)) let finalScore = boundScore(0, 100, rawScore) Any code where you'd *want* to use this operator should be hedged with **human readable variable names that explain what each step in your process is doing**. Even in this hilariously contrived, trivial example, my code is objectively superior because it tells you *what the math is achieving* and it's impossible to encode that information into the source using the pipeline operator. I can think of literally no reason to ever use the operator except when you absolutely don't care whether anyone (especially yourself) is capable of maintaining your code in a year. 
Hey guys, I'm the creator of [Testy.Ts](https://testy.github.io/)! I'd be happy to have your feedback if any of you tried it. 
Make sure to add external libraries' @types packages that you use to your package.json dev dependencies. Examples: @types/lodash @types/react @types/react-dom See below for more info: https://microsoft.github.io/TypeSearch/
God bless. I almost puked when I saw this objectively bad proposal. The amount of bad practices that js devs are doing right now is already scary in terms of overall industry competence but this is really the tip of the iceberg. 
Nice!
Brutal. 
When I worked in C many years ago it was not uncommon to see functions approaching the compiler imposed line limit. Then you would see them replaced with func() which in turn called func1() and func2(). Those developers hated me. 
Very helpful. Thanks!
Code can be written well or poorly in either style because it's not the methodology that creates good, sustainable code. For example, no more information is inherently communicated if we break out into intermediate variables but use poor names: const x = person.score; const doubled = double(x); const added = add(7, doubled); const newScore = boundScore(0, 100, added); And the same information as you expressed can be trivially communicated if we use better operations with a more legible API: const reportCardScore = person.score |&gt; (unadjustedScore =&gt; adjustScoreWithCurve({ curve: 7, double: true, score: unadjustedScore }) |&gt; (scoreWithClassCurve =&gt; boundScore(0, 100, scoreWithClassCurve) ) The pipeline operator comes from more functional languages like elixir, clojure, and F#. You've said you don't like those sorts of things, which is fine, everyone has their preferences, but your preferences do not mean you are writing "objectively better" code, and using these features does not mean you are writing things with a "code smell".
Every argument against the pipeline operator I've ever seen boiled down to either "it's bad if you write code wrong" or "functional programming is unfamiliar".
If you seriously think introducing three new temporary variables is "objectively superior" to a clean, simple and very readable functional pipe, I think you have taken imperative too far, and you should be careful not to trip and be swallowed by the nineties. Writing with such contempt and certainty about a paradigm you obviously just dislike, while displaying no convincing skill in any direction, really makes you come off as crude and arrogant.
I was curious why this was even necessary since if you follow good JS practices you'll end up writing good TS too, so I intentionally tried to find areas where the guides differ past just the TS version adding type annotations, and, well ... this line from the JS version about sums up my findings: &gt;It's very difficult to get readable class inheritance, construction, and method definitions for classical ES5 classes. If you need inheritance (and be aware that you might not), then prefer ES2015/ES6 classes. **However, prefer small functions over classes until you find yourself needing larger and more complex objects.** The "clean code" TS version both doesn't have this line, and seems to intentionally ignore it so that it can use classes *everywhere*: class Car { make: string; model: string; color: string; name(): string{ return `${this.make} ${this.model} (${this.color})`; } } vs clean code js: const Car = { make: 'Honda', model: 'Accord', color: 'Blue' }; function paintCar(car) { car.color = 'Red'; } Which is kind of a pet peeve of mine. Writing typescript doesn't mean writing everything against *classes*, it means writing everything against *types*, and classes aren't as necessary if you aren't setting up inheritance chains or have large objects (as the clean JS correctly states). This sort of thinking continues later on when the author creates an abstract class (with no implementation): abstract class Adapter { abstract async request&lt;T&gt;(url: string): Promise&lt;T&gt;; } Instead of just an interface: interface Adapter { request&lt;T&gt;(url: string): Promise&lt;T&gt;; } I don't have too much of a bone to pick with the rest, but this general mentality of marrying everything to classes and classical hierarchies bothers me.
With webpack you'd probably use https://www.npmjs.com/package/fork-ts-checker-webpack-plugin So everything is handled by webpack, and you don't need to manually run tsc
Several issues worth pointing out: &gt; https://github.com/labs42io/clean-code-typescript#use-default-arguments-instead-of-short-circuiting-or-conditionals These two code snippets **do different things**! The first section will also use `10` when `count` equals `0`, because `0` evaluates falsy. This does not happen in the "good" part. Make sure the examples actually do the same. &gt; https://github.com/labs42io/clean-code-typescript#remove-duplicate-code &gt; Do your absolute best to avoid duplicate code. When the code deals with different domains, then duplicate code is acceptable. I've seen way too often developers forcefully remove duplicate code, which later results in flag over flag to handle special cases later on. If the code touches different domains, then duplicate code can be acceptable. &gt; https://github.com/labs42io/clean-code-typescript#set-default-objects-with-objectassign-or-destructuring Again these code snippets to different things. Additionally, you end up with nasty gotcha. If the `config` has a property **explicitly** set to `undefined`, then the default value will be overwritten with `undefined`. For exampe `createMenu({ body: undefined })` or `createMenu({ body: getBody() })`. &gt; https://github.com/labs42io/clean-code-typescript#avoid-conditionals With the strong type system in TypeScript and the exhaustive checks I think the first case is absolutely acceptable, if the airplane is a plain object and not a class. I'd not transform an object into a class to have this logic in a virtual method. &gt; https://github.com/labs42io/clean-code-typescript#use-method-chaining If you return `this`, then actually make the return type `this` and not `Query`. Otherwise inheriting from `Query` will result in a broken API. Also, with a pattern like this, you should better call it `QueryBuilder`. It makes more clear that the API is used to construct something, and then have a final method `build()` (or `construct()`) to create an actual `Query`. The class as it is does not represent a "query". &gt; https://github.com/labs42io/clean-code-typescript#prefer-promises-vs-callbacks The good example violates the SRP from before. `downloadPage` is downloading the page, saving it to a file, **and** returning the response? Why so much? &gt; https://github.com/labs42io/clean-code-typescript#always-use-error-for-throwing-or-rejecting I'd go further: Avoid throwing `Error` and write functional code instead. Either have a result or an error object **returned**. The issue with throwing `Error` is that it's hidden in the API, it's not clear to the caller that something can be thrown, and what can be thrown. &gt; https://github.com/labs42io/clean-code-typescript#dont-prefix-interfaces-with-i Debatable. IMO I prefer prefixing it with `I` for simple types that make clear I don't have any logic and/or prototypal inheritance. For simple objects. &gt; https://github.com/labs42io/clean-code-typescript#use-2-spaces-no-tabs This is a dumb advice for a "clean code" article. Doesn't matter if 2 spaces, 4 spaces, or tabs. Just be consistent. &gt; https://github.com/labs42io/clean-code-typescript#type-vs-interface What's the reasoning behind this? It's arbitrary and doesn't make much sense. Why not make `EmailConfig` in the "good" example an interface as well? The type itself should not be aware if it's used somewhere else in a union/intersection. 
Highly appreciate your comment. I'm one of the contributors to this docs. Firstly, I perfectly agree with you that using classes should not be a preferance over functions and general functional programming. However, the sample you mentioned is from SOLID section which makes it relevant for classes. The abstract class sample can be improved (check), and having there some code inside the abstract class would explain it better (contribution highly appreciated). Secondly, it is mentioned that there classes should be preferred for encapsulating behavior, and there is also explanation when to favor interfaces over types. In my opinion be it TypeScript/JavaScript using functions and the style of functional programming is still very powerful (pure functions mentioned there). But, the well studied concepts and practices from OOP (explained in the original Clean Code book) helps you to apply the well studied patterns and principles.
&gt;it's very apparent when someone makes a class or interface with a single function member or uses a static class to replace a module that they're stuck in a particular way of thinking. I feel your pain. Tell them modules are singletons, in the most entreprise way, that will do the trick.
In your latter example, you've encoded precisely the same amount of information as the procedural example I gave, but with significantly more line noise and an added performance cost. All you've done is replaced this pattern: const a = A() const b = B(a) const c = c(b) With this pattern, which is almost character-for-character the same weight except that it injects a bunch of parens: const c = A() |&gt; ((a) =&gt; B(a)) |&gt; ((b) =&gt; C(b)) Whereas the operator would allow you to do this: const c = A() |&gt; B |&gt; C And the original version would look like: const x = person.score |&gt; double |&gt; add.bind(null, 7) |&gt; boundScore.bind(null, 0, 100) And then you've lost all the "I actually care that other people read my code" metadata the original example has. And if you're not going to use this ultra-terse format to chain together method calls and using the arrow-function variant is actually *more* noisy than the procedural version, what is the benefit? Again, it's solving a problem that well written code doesn't have.
Thank you a lot for all the points. We'll make sure to take a note and adjust it. For the most of it I agree, it's still work in progress, samples have to be improved.
&gt;[...] the sample you mentioned is from SOLID section which makes it relevant for classes. The abstract class sample can be improved (check), and having there some code inside the abstract class would explain it better (contribution highly appreciated). So, if you're implying you need an abstract class for SOLID, I assume you're referring to open/closed, but relying on inheritance and base classes is only one way to do open/closed (called implementation open/closed). A more modern (and imo useful) understanding of open/closed is so-called "polymorphic" open/closed, where the thing that is both open to extend and closed to modify is an *interface*: the implementation code can do whatever it wants to enable whatever custom behavior so long as it doesn't need the interface to change with it. This also combines well with other concepts like compose over inherit; if there *was* some logic in the abstract/base class that we wanted in all of our implementations, we could simply compose it in instead of inheriting from it.
I agree, and it is mentioned and well known that composition should be preffered over inheritance. There are situations however when inheritance just works better. But care should be taken not to grow a monster, and usually inheritance should not go deeper than one level. You might prefer inheritance to reduce duplication, especially when it's on the level of internals and when implementatio is highly cohesive.
Figured as much. Thank you!
I'm so glad! Enjoy!
&gt; If you seriously think introducing three new temporary variables is "objectively superior" to a clean, simple and very readable functional pipe It encodes more information that the pipe does. It encodes the *reasoning behind the logic* whereas the pipe only encodes the logic. The former is INFINITELY more important.
Don't use HOC's as they add mental complexity to a problem already solved via basic javascript but its unclear from your article what the complete problem is, if you want to type your State to model having dynamic keys try looking for typescripts index signatures on interfaces documentation.
I read all the responses and nobody told you the most important hint... they're telling you how to write in TS, whereas you have a code base to convert. You will passionately love the switch --allowJS
i did a thing with a coworker &amp;#x200B; [https://github.com/christophwolff/nuxt-typescript-template](https://github.com/christophwolff/nuxt-typescript-template)
Thanks for feedback ðŸ™Œ, adjustments has been published ðŸš€: [https://github.com/labs42io/clean-code-typescript/commit/4c6d10ce640bc874eaf3af0675941c173520b7df](https://github.com/labs42io/clean-code-typescript/commit/4c6d10ce640bc874eaf3af0675941c173520b7df) 
&gt; https://github.com/labs42io/clean-code-typescript/commit/4c6d10ce640bc874eaf3af0675941c173520b7df#diff-04c6e90faac2675aa89e2176d2eec7d8R230 Utilizing TypeScripts strict null checks the value should never be `undefined`. &gt; https://github.com/labs42io/clean-code-typescript/commit/4c6d10ce640bc874eaf3af0675941c173520b7df#diff-04c6e90faac2675aa89e2176d2eec7d8R2116 Using two types, `Result&lt;R&gt;` and `Failure&lt;E&gt;` and then make `Failable&lt;R, E&gt;` just a union of those two types will be a lot more readable.
If you are working with large amounts of existing JS which perhaps you need to share with other legacy JS implementations, or for which going through and typing is not an option, or for which maybe you'd just like to port at your own pace over an extended period of time w/o losing that functionality, get familiar with "declare" and how it can make your life so very much easier. You can thank me later.
I recommend checking this guide and the related typesafe actions package if you want safe Redux and TypeScript https://github.com/piotrwitek/react-redux-typescript-guide I used to do it all by hand with massive manually written unions and action payload interfaces, but following the guide got rid of thousands of lines of type definitions.
Just finished converting our redux to typescript. If only I had this article a week ago :â€™(
I was forced to do some work on a legacy angularjs app. It was a pain, until I remembered `@ts-check` and `/// &lt;reference types="angular" /&gt;`. VS Code will automatically run the typescript compiler against your files, and you can `npm install -D @types/package` if VS Code can't download type definitions from your package.json in the background (it's a bit buggy it seems). Combining that with decent jsdoc blocks and it's a breath of fresh air. Pretty much everything was strongly typed.
I did but in the end had to use ramdas lens. The reason was typescript wouldn't let me spread a path array as arguments, since it couldn't figure out how many arguments that would be and what they were. Maybe it's possible and I just overlooked something? Btw I also watched your talk and it was very informative.
&gt;And I think it's gonna be a long long time - Rocker Man by Elton John. X-spreadsheet is a very very complex app. Its using canvas and WebGL with hardware acceleration. In order to make such an app, you have to spend a lot of time learning and perfecting. Before diving into WebGL you might wanna look at SVGs. Svgs are amazing and a lot simpler than coding webgl shaders. Three.js is a great framework for webgl. And for SVGs greenstock is the standard. You also have to invest a bit of money. [Frontendmaster](https://frontendmasters.com/) is a great resource. It's just $39 per month and the courses are great a lot better than on Udemy. If are really serious about this then check frontendmaster. Surf codepen for good projects. As of just simple ui ( not 3d shit flying all over the place ) learn a framework ( Vue or react ) as complex websites like big e-commerce sites use reusable components for there sites. Learn how to manage complex states and the changes. Reactive coding with rxjs . Adding small UI animations and micro-interactions will improve ux. For good reading vist [Smashing Magazine](https://www.smashingmagazine.com/) . [This](https://tympanus.net/codrops/) website has great examples. Go through the codes and using them in your web apps and websites. Good Luck.
Unfortunately, this doesn't answer my question. I know about front end masters, and have used react with existing react or bootstrap components. Thanks for those resources but again as mentioned in the question that building really complex project (not just UI with existing components) is what I am looking for.
If you want complex then you will get complex. Learn WebGL. That's all.
This looks cool! A dumb question, but does it retrieve errors after the query is executed or is it checking for correct syntax as you write?
It's checking after execution. Under the hood, it runs `EXPLAIN your-query` for the mysql errors and returns them to you. The errors that don't come back from the server (i.e. the ones built-in to sql-lint) aren't executing any code, they're essentially just checking strings. Hope that helps!
I use typesafe actions. Itâ€™s the best out there
Useful! Does it exist a good MySQL formatter, btw? The ones I've tried so far hasn't done a particularly good job.
There isn't a formatter but I did consider bundling it into this. I wouldn't know where to begin though! 
The obvious alternative to \`Maybe&lt;T&gt;\` is \`T | undefined\` or maybe just \`T?\`. My first instinct is that \`T?\` would produce more readable code. So maybe a part in the readme contrasting the two.
Your implementation isn't actually a monad because you can't express \`Monad&lt;null&gt;\`.
&gt;const isUserAuthenticated = getUserById(2) &gt; &gt;.flatMap(getUserToken) &gt; &gt;.map&lt;boolean&gt;({expire} =&gt; expire &gt; new Date()) &gt; &gt;.do(x =&gt; console.log) &gt; &gt;.getOrElse(false); &amp;#x200B; How could you chain function calls if your return type is undefined ? you have to test in every function if your value is not null. 
&gt;Monad&lt;null&gt; you can just do : `Maybe.fromValue(null)`
Nice... We have very similar implementation at work. 
&gt;null why want you do that ? 
It might be a valid value representing nothing.
I don't consider chained function calls to be an intrinsic virtue. It's only good if it's more convenient or more readable. I would probably write this code something like this. const getUserById = (id: number) =&gt; id &lt; 1 ? undefined : user; const getUserToken = ({email}) =&gt; email &amp;&amp; appuser; const token = getUserToken(getUserById(2)); const isUserAuthenticated = token &amp;&amp; token.expire &gt; new Date(); if (token) console.log(token.expire); If I'm not mistaken it has the same behavior. Personally, I find it easier to read, and would probably track it better under a debugger. To sell this package to me, you'd have to show some advantage of the chained formulation.
There is a difference between knowing something is null, and failing because you can't access a resource. That is one valid use case. &amp;#x200B; But that is besides the point. The concept of a monad is that you never need to ask the client why they want a given `T`\---things should work regardless.
I've been using [`purify-ts`](https://github.com/gigobyte/purify/), it's very nice for introducing ADTs to the codebase. It makes me want a sort of pseudo-standard library alongside it though. For example, I don't want `JSON.parse` to potentially throw, it sucks implementing a try/catch block around it, I'd rather it give me back a fantasy land-compatible Result/Either.
&gt;flatMap Thank you for ur answer, I understand your point of view. i don't use maybe everywhere in my app but only when it's necessary \- when i have to chain more than 2 calls, Maybe can avoid testing (null or undefined values) everytime you call a function. \- I also use Maybe when code should never fail (for loggers for example) &amp;#x200B; I agree with you, for most cases, T | undefined is enough or maybe (**?.**) operator in future ts versions.
Maybe is like a promise of a value. u use it without looking inside the box (whatever the value is) until the moment you want to evaluate it. it voids testing the (undefined or null) everywhere you the value is used.
What is the result of `Maybe.some(null).flatMap(x =&gt; Maybe.some(typeof x))`? What is the result of `(x =&gt; Maybe.some(typeof x))(null)`?
it's little bit verbose in my opinion
maybe.some(null) throws an Error. some is a safe value that is not undefined or null. Maybe.some(2) -&gt; {value: 2} Maybe.none() -&gt; {value: null} Maybe.some(null) -&gt; throws an arror. use Maybe.fromValue(unsafeValue); Maybe.fromValue(null) -&gt; {value: null} &amp;#x200B; `// return an instance of Maybe wrapping the provided value, otherwise return an instance of empty Maybe` `fromValue&lt;T&gt;(value: T) = isNullOrUndefined(value) ? Maybe.none&lt;T&gt;() : Maybe.some(value);` &amp;#x200B; &amp;#x200B; x =&gt; Maybe.some(typeof x))(null) -&gt; {value: x}() &amp;#x200B;
thanks. it's very similar but in maybe-monade u can use all these functions: `- fromValue, some, none` `- flatMap` `- map` `- orElse` `- getOrElse` `- do` `- isEmpty` `- exists` `- get` &amp;#x200B; For Maybe Callback u have: `- fromFunction` `- apply` `- applySafe` &amp;#x200B;
thanks. it's very similar but in maybe-monade u can use all these functions: `- fromValue, some, none` `- flatMap` `- map` `- orElse` `- getOrElse` `- do` `- isEmpty` `- exists` `- get` &amp;#x200B; For Maybe Callback u have: `- fromFunction` `- apply` `- applySafe`
Mixing null and maybe is just asking for trouble. If you want differentiate between I have a value, I couldn't find a value and I just couldn't do that you want something other than maybe or either as your primary abstraction. In Haskell you'd do like data Tristate e a = Found a | NotFound | Error e And then create a maybe like monad on top of it. instance Monad (Tristate e) where Found a &gt;&gt;= f = f a NotFound &gt;&gt;= _ = NotFound Error e &gt;&gt;= _ = Error e
Maybe&lt;T | undefined&gt; is perfectly reasonable and doesnâ€™t couple the monad implementation to something being found or not.
Maybe you should have used maybe-monad that already exists and seems to do what you wanted anyway... https://www.npmjs.com/package/maybe-monad 
Itâ€™s something along the lines of @ts-ignore 
You can suppress type checking for specific lines by adding `// @ts-ignore` before it. If you want to ignore all errors and return error code 0, take a look here: https://github.com/Microsoft/TypeScript/issues/13280
Property X does not exist on Y errors are a sign that you have bugs in your code or you have not properly typed the inputs or outputs of some pieces of code. You say â€œappease the compilerâ€, itâ€™s not their to bully you. Itâ€™s telling you where it sees problems, which can be potential bugs or worse. I would highly recommend not disabling typescript errors. Reconsider your build? If the issue were that you canâ€™t go and change it all now but that you have to keep building, Iâ€™d be able to understand that.
Why use TypeScript if you don't want the compile-time checking?
I do want compile time checking. Typescript just isn't smart enough to figure out what is present at runtime. FB's Javascript API is only loaded at runtime and not at compile time and Typescript does not know that, and therefore complains that the FB variable does not exist. So I want to disable compile time checking for libraries that Typescript can't seem to figure out while keeping compile time checking for the rest of my code.
No, these errors are not generated from my code, but rather the libraries or frameworks that I'm using. Typescript does not seem to be smart enough to figure out where it's coming from and I do not want to waste my time fixing things caused by poor integration of 3rd party libraries. 1) Facebook's Javascript API is only loaded and injected directly at runtime. Facebook complains that it cannot find these functions because they literally do not exist at compile time. https://developers.facebook.com/docs/javascript/quickstart 2) Typescript cannot seem to figure out what this.$refs is referring to. &gt;&lt;input ref="input0"/&gt; &gt;this.$refs.input0.blur() I cannot be bothered to declare in every file that input0 is a HTMLInputElement just because Typescript cannot figure it out. Again this is a limitation of Typescript + Vue, it is not a problem with the code, and I do not want to be bothered by it. 3) Typescript has no idea how Quasar integrates with Vue. It has no idea what 'this.$q' is referring to because Quasar injects its functions in at a lower level than Typescript is aware of. This is poor integration of Quasar and Typescript. I do not want to fix Quasar's problems, I just want to turn off compilation checks for 'this.$q' https://quasar-framework.org/components/loading.html 
Is there a global @ts-ignore? It looks terrible throwing @ts-ignore all over my code base.
That's by design, though. VS Code is very much opt-in. If you are constantly working in new environments, I can see how configuring it to your liking would become a pain, but if you develop professionally (or even as a hobby), I don't understand that argument against extensions. Build it how you want it.
you need to npm install FB SDK types, https://www.npmjs.com/package/@types/facebook-js-sdk This will tell TS, those properties exists, don't worry about it.
It can find the properties on the FB attribute, but it cannot find what 'FB' is referring to. FB also isn't the only problem I have.
you can add the typings via definitelyTyped: https://www.npmjs.com/package/@types/facebook-js-sdk That way Typescript will assume it's on the page. 
Well the first scenario you describe is different and I agree you do not want to be dealing with external libraries not providing proper type information. This does however seem you are compiling external libraries with your code, which isn't supposed to happen if you have set up your `tsconfig.json` properly. Can you post that just to make sure we're talking about the same? In regards of the other 2 situations, these some more VueJS related than TypeScript; yes the compiler will always complain about variables being used that are not necessarily "statically" declared and it needs help understanding when it's alright. This is important, because when indeed you do change something in either the code or the HTML, like a variable name; the compiler can then check if that variable name is used anywhere else that could possibly ruin your day. Again, it's not trying to be a pest or bully you, it's trying to be helpful in a very autistic manner ;-).
Based on his other comments, this is the solution. If the compiler is complaining about unknown properties that are added by a third party library, it's always that you're missing static type definitions or the existing definitions are incomplete. It also sounds like adding "strict": true to the tsconfig could help catch some other bugs
I donâ€™t understand the meaning of every operator: JustAllowNull NullToMaybe OrElseAllowNull MapAllowNull ... If we use Monads we dont have to worry about null, therefore these operators are confusing me a lot 
Please listen to what /u/williams-j is saying. Your handling of null or undefined values makes this not a monad, and will cause more problems that it solves. I wouldn't touch this library. It gives me all of the power of monad, and then restricts me unnecessarily.
You can ignore the allowNull methods if you don't want to use them. Sometimes null is an allowed value so these functions cater for that situation.
&gt; maybe.some(null) throws an Error. some is a safe value that is not undefined or null. And if `null` **is** the value I want? It's not "none".
&gt; it's very similar but in maybe-monade u can use all these functions: purify-ts provides these methods as well.
 { "compilerOptions": { "target": "es5", "module": "esnext", "strict": true, "jsx": "preserve", "importHelpers": true, "moduleResolution": "node", "experimentalDecorators": true, "esModuleInterop": true, "allowSyntheticDefaultImports": true, "sourceMap": true, "baseUrl": ".", "types": [ "webpack-env" ], "paths": { "@/*": [ "src/*" ] }, "lib": [ "esnext", "dom", "dom.iterable", "scripthost" ], "noImplicitAny": false, "strictNullChecks": false }, "include": [ "src/**/*.ts", "src/**/*.tsx", "src/**/*.vue", "tests/**/*.ts", "tests/**/*.tsx" ], "exclude": [ "node_modules" ] } 
This is important, because when indeed you do change something in either the code or the HTML, like a variable name; the compiler can then check if that variable name is used anywhere else that could possibly ruin your day. Not a concern for me. $refs are only referenced in the same file itself. For the 2 VueJS errors, I'm simply waiting for Vue 3.0 to come out with official Typescript support. For now the effort required to write extra boilerplate code to please the compiler far outweighs the effort required to maintain it. 
Vue does not have official support for Typescript. That's all. I cannot add type definitions for every single this.$refs because $refs can contain any HTML or Vue element. With Quasar, I can add the typed definition but the thing is Typescript has no idea where this.$q is coming from. It cannot find any element called '$q' on 'this'. How does adding TS definitions help me? &gt;It also sounds like adding "strict": true to the tsconfig could help catch some other bugs I do have it at strict and I have no intention of turning of Typescript. I appreciate the places where Typescript catches actual potential bugs. I'm just annoyed because 3rd party libraries have poor support for TS and it's causing me to fail my build and I just want to turn off Typescript for those libraries specifically.
You mean void? 
 Try importing the FB library similar to how I need to do with Jquery: import * as $ from 'jquery'; You'll need some type definitions too: https://www.npmjs.com/package/@types/facebook-js-sdk 
"Typescript just isn't smart enough to figure out what is present at runtime." lol
You can just declare the global and it'll work.
Vue doesn't need support for typescript. You just need the typings for Vue.
No I mean the typescript type `nul` or `undefined`.
Loopback is from IBM and it uses koa
In my experience, the actual values of the enum members don't matter all that much. If you're developing more low-level applications and you want to represent specific hex values (for example) while keeping type-safety and readability, then you will probably want to modify the member values ([example](https://github.com/michaelgira23/swarms/blob/master/src/constants.ts#L130) from a friend's project), but I've found that the most common use case is just to have a limited set of named values (`enum DataSharing { SEND_ALL, SEND_ANONYMOUS, SEND_NONE }`, for instance). You can also use string literal types for this purpose, it all really depends on preference.
this example is confusing. enum Direction { UP, DOWN, LEFT, RIGHT } without specifying a value, the transpiler will write this UP = 0 DOWN =1 LEFT = 2 RIGHT = 3 if you choose to specify a value, then do it with all values, instead of just one. sometimes you want to display the enum, this is when it makes sense to assign values UP = 'up' DOWN = 'down' LEFT = 'left' RIGHT = 'right' then `console.log(Direction.UP)`will print "up" rather than 0 enums are just to make sure you don't fuck up. e.g. "left" === "lft" accidental spelling mistake. Direction.LEFT === Direction.LEFT not possible to make mistake
The whole point of using maybe is to deal with null (and undefined, but I'm just going to use null) in a type safe manner, having a Maybe&lt;T | null &gt; means: 1. The maybe could be null (given this is an issue regardless) 2. The maybe could be Nothing 3. The maybe could be a Just&lt;T&gt;(value) 4. The maybe could be a Just&lt;T&gt;(null) So now it's just null checks all the way down and completely negates the purpose of using Maybe in the first place. So Maybe&lt;T | null&gt; isn't the abstraction you want. Null checking the result of retrieving from Just isn't something you would ever do because Just means "I got the value for you". If you care about delineating between error kinds, you use Either&lt;Error, T&gt; or develop your own abstraction that models failures how you want. 
Vue has official typescript support; it has official typing included; furthermore vue-cli 3 supports the creation of typescript based projects, both class based and single component based. for the $ref problem you can do: (this.$refs.input0 as any).focus(); for the quasar vue issue, as /u/alirobe says you need typings that enrich the vue component and makes typescript aware of hte existance of that $q property you can either find an already existing one or write your own definitions. Writing your own without real typings should not be hard, something like: in your src folder, create a file named quasar-vue.d.ts &gt;declare module 'vue/types/vue' { &gt; &gt; interface Vue { &gt; &gt;$q: any &gt; &gt; } &gt; &gt;} &amp;#x200B; The above is writtend straight in this comment and I have not tested it; furthermore I never used quasar but it should work.
Hey, tnolli, just a quick heads-up: **existance** is actually spelled **existence**. You can remember it by **ends with -ence**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
&gt; The maybe could be null (given this is an issue regardless) No, we should be assuming strict null checks here (as implied by `T | null`). Here is an example. You're trying to resolve names across a wire. Either you get back the resolved name, something telling you that the name does not exist, or the connection fails. Using the tristate solution is bad here because you have now coupled the possibility of unresolved names to all request types across the wire. There may be other data requests that can fail, but always return a resolution. I want to be able to compose those freely. Putting the unresolved name result in the error branch of `Either` is also wrong, because this thing is not semantically an error. It's a correct piece of information that is compactly represented using a unit type. Another example is a bidirectional type checker, where the result of checking is Maybe (). You want to model success of failure, but in your success case there is really no more information to add, so a unit type is correct here. 
Remove the optional (the question mark after products in the interface). That is what is determining that the value could be undefined. That might clash with requirements, so in that case you need to assert that state.products is not undefined and handle that case so that the compiler can narrow the type.
TBH I don't think enums would have been added today but they are an older feature when alignment with JS was a lower priority. I would usually use literal types eg: `1 | 2 | 3` or `'A' | 'B' | 'C'` Enums give you two-way mapping from name to value and back. Some Typescript libraries (eg TypeORM) require their use.
The ELI5? Which is more readable? ``` changeDirection(1); ``` vs ``` changeDirection(Direction.UP); ```
this is what I am waiting for.
&gt; In my experience, the actual values of the enum members don't matter all that much. They're utterly invaluable if you're doing anything to/from JSON.
The libraries use them because Enums are stellar for [de]serialization.
Very happy to try this out!
I would argue it's more idiomatic to write `changeDirection({ direction: 'up' })` . Then type direction argument as `'up' | 'left' | 'down'` etc.
`Uncaught TypeError: Cannot read property xxx of undefined`...
Was this from a recent talk?
Yes, I wasn't there but here is some more info https://twitter.com/swyx/status/1093670844495089664
There is no context to that argument. It seems to be only a commercial argument. Was that bugs in production ? What was the context of the project in question? Did they have a test suite? Was the test suite relevant? What is the health level of the project? What is the mindset of the dev team?... You can't give one argument of a talk without giving any context to that argument. That's what leads our industry to opinion based decisions instead of fact based decisions.
What are the devs' favorite colors? Do they prefer coke or Pepsi? I don't think those questions of yours have all that much relevance. I figure that via analysis they could determine that 38% of their bugs essentially amounted to type errors.
Do your own research.
That number is okay if they only counted bugs in realeases. Recently, I've made a small one day project in JavaScript instead of TypeScript. This was a little odd to me, because I've been using TypeScript for 3 years now. And the thing is, all of my errors could have been prevented by using TypeScript. All of them would have failed during compile time. VSCode didn't help me a lot, I really missed the real intellisense.
Why do you treat them as mutually exclusive? You can use the entire JavaScript ecosystem with typescript. There are like 10 of this kind of post every day. No one is interested in wasting their time trying to help you get over your indecisiveness. If you're interested in typescript, all you have to do is install it and try it out, and then you can decide for yourself.
I've been coding in typescript for almost a year now and had coded in vanilla nodejs for two years prior. I think that being good in JavaScript translates over to typescript. But I don't expect someone who's good in typescript to be able to write JavaScript. My work uses typescript but given the choice I would write most of our simple project in JavaScript every time. 
I learn to program with things like C and Visual Basic and then I had to use PHP and Javascript, suffering without type checks for years. Typescript/php7 are a blessing.
Well they did mention bugs. It was not just defects in the code but actual bugs. Therefore someone encountered them. While it is interesting whether that was in production, QA or development it is still a bug that was caught at compile time/when writing the code. I think we can agree that this is objectively better than a bug at runtime or when interacting with your dev build. May be interesting to know how many of those bugs we fixed and the regression test added is now obsolete due to static analysis.
We have mostly integration tests for react/redux components in jest, some unit tests, for more complex functions and a rough end to end test in cypress that covers the main flows. The main problem with only having e2e tests is that they take too long - you need to build docker image, run it with docker compose and then run cypress, which take couple of minutes. In the other hand our full jest suite takes ~30 seconds so you get feedback on each change 
PHP 7? Haven't used PHP in years, did they added types?
Using Any everywhere you can have typescript catch no error... I already saw that. Typescript is not magic. It's efficiency depends on the serious of the dev team. Today I work on projects without typescript and does not have any errors that typescript could have caught because I use tests.... So yeah my questions are important. What is working on some context does not work in others. And people are always the problem in projects not framework or languages but only experience can teach that.
TypeScript + Go = Love
Being good at javascript only helps you avoid the kind of errors that dynamic typing introduces \*if\* you're the only person on the team, or if everyone on the team uses doc comments. As soon as you have multiple people working on a project and that project is more than a few months old, your productivity tanks while you work through type errors and trying to discover what is actually passed to and returned by functions. 
What I am saying, is that learning javascript teaches you the underlying principles of the language you are using. Learning typescript teaches you the principles of other languages. Its java/c# on top javascript. All the typescript devs I have met are shit at javascript. 
&gt; Was that bugs in production ? This question is meaningless. A bug is a bug.
What I've seen is that more devs have a hard time going from JavaScript to typescript than the other way around. Unless they already had experience with java , c#, or other statically typed languages with interfaces. Don't get me completely wrong though. A dev without much experience writing in other statically typed languages may be able to transition over to typescript in a few days. But it's going to take them a long time to learn how to use the type system effectively. For an engineer whose moving from typescript to JavaScript, there's nothing new to learn. Nothing. It's just having to live with more chaotic, undocumented codebases.
I would say theres a lot new to learn. Not because it wasn't there in typescript. But I find that idiomatic typescript is very much OOP centered. A lot of it is class based with dependency injection and the like. I think you learn how to work with promises fine in typescript, but when it comes to closures, and understanding that there are really no such things as classes in javascript in the OO sense. They get stuck.
Type annotations, IIRC, like TypeScript
Oh that's nice, I'll take a look. Thanks 
Typescript has nothing to do with OOP. Thatâ€™s how you choose to write typescript. 
It doesn't have to be. But it seems to be the idiomatic style. And it makes sense why that would be the case with classes being a very convenient way to type things. 
Go is still a thing?
You can use a library like [io-ts](https://github.com/gcanti/io-ts) which adds runtime validation. But don't look at the source of that library, it's scary.
Accessing an array index out of bounds? Accessing an unknown property name on a string-indexed type? Naively object-spreading a `Partial&lt;T&gt;` for fallback settings? Still plenty of cases where you can shoot yourself in the food and get that error at runtime.
First and most important: Enable the strict mode. It's **insanely useful**, and I would never want to work on a project without the strict flags enabled anymore. https://github.com/matvp91/indigo-player/blob/master/tsconfig.json#L7
Eric Elliot would disagree and say that the "Typescript Tax" is not worthwhile, LOL
Typescript tax. Lol. Yeah, I would rather pay the â€œtaxâ€ and be able to sleep at night, thank you!
What? Lol
What what 
We write our Typescript just like JavaScript. It just works more often than not the first time we run it!
How can a Typescript developer not know JS if typescript is just JS?
Good on you then. 
Every dynamic language has these people who resist the static typing that inevitably some people try to bring to the language. They say â€œwell Iâ€™m super expert in this and I donâ€™t need types, and if I have a team of super experts, we all wonâ€™t need typesâ€. Well not every team is made up of super experts. Types let the experts insert checks to prevent common errors. I sleep better at night knowing that the compiler is there checking stuff for me. 
I wish typescript would support runtime validations against an interface so we don't have to use io-ts.
I like TS but I'm calling it BS. 
!
Hahaha, I haven't heard it called a tax before. But isn't a tax something where everybody pays a little bit? Then we add up all of those little bits and it ends up being a huge amount that is used to benefit society as a whole? I like the analogy and view it as a compliment. This is a good use of my taxes!
Saying you don't need types because you're an expert is the same as saying you don't need tests because you don't write buggy code.
The types are very primitive compared to almost anything else though.
Still, they prevent a lot of bugs in combination with a good IDE and static analysis tools. 
Having written JavaScript on a regular basis for the last 7 years, and the last 3 years beeing mostly TypeScript its really amazing how much less bugs there is. No need for tests that TS can catch, and the DevXP is sublime!
there is n such thing as typescript tax, wtf
I'm not sure the statistic of 38% is truly accurate. Sometimes errors can genuinely just be chalked up to human error. 
You came to the wrong sub to ask questions! The disagree==downvote people want an echo chamber.
Use https://github.com/YousefED/typescript-json-schema to generate a JSON schema file from your typescript interface, then pass that to https://github.com/epoberezkin/ajv to validate incoming data against the schema. Works really well even with quite complicated types. 
Use https://github.com/YousefED/typescript-json-schema to generate a JSON schema file from your typescript interface, then pass that to https://github.com/epoberezkin/ajv to validate incoming data against the schema. Works really well even with quite complicated types. 
Yeah, our test suite is slow, but it happens in CI. I just manually run the failing tests locally if I need to debug.
You mean you never mistype a variable name?
I'm sad that everyone upvote that post because it suits their feelings... Everyone in here should watch that video and asking themselves if they really are scientific people : https://youtu.be/C13JC\_YP2Q8 
My point was not really to understand that are production bug vs dev bug. But I find like 90% of the bugs that go to dev environment during development.... Having worked with Typescript for like a year and back to Javascript since, there is 0 differences. Problem is not framework or languages it is PEOPLE ! 
Your comment is also meaningless. You did not get my point. Next time try to read through the whole comment before responding :)
It can happen, but I never ever committed a mistyped variable. So I don't understand your question. When developing, I always have my full test suite run after each edit in my code. If the test suite fails, the code cannot be committed. The whole test suite on a medium project never takes more than a second to run. That is really safer than everything that typescript can give me as "security" because if I want to bypass typescript, I can always put \`any\`. My test suite never lie. 
Eric Elliot is an idiot. 
Why?
Visual Basic is great for comparing static and dynamic typing. By setting it to OPTION STRICT OFF, you can pretend that it is a dynamically typed language and see how much faster, or slower, you are when you aren't worrying about types. *** Personally I find myself to be a lot slower when I'm not using types. The extra couple of seconds to record what type I'm using is more than paid for by time saved trying to remember what type I'm using.
&gt; You may be a "super expert", but I've spent the last three weeks adding comments to all your variables so the rest of us know what fucking type they are Seriously, my first "real job" was just that. I even bough a macro keyboard so I could program the buttons with "&lt;end&gt;&lt;space&gt; //string" and "&lt;end&gt;&lt;space&gt; //integer". 
Percentage is too low. Doesn't account for bugs found during manual testing because code check-in.
Not really. Bugs caught in production are believed to be more expensive than bugs caught in QA. So knowing the difference is interesting.
 I don't necessarily see that as a bad thing. TypeScript eliminates, or at least hides, many of the poor coding practices that JavaScript devs often use. So saying "typescript devs I have met are shit at javascript" is akin to saying "typescript devs I have met are bad at understating shit javascript". Show them good JavaScript, the kind of code that one finds in ""javascript the good parts" or TypeScript's output, and they should be fine. 
Because TypeScript actively discourages, or even prevents, the use of really shitty JavaScript coding styles. The type of code that any good JS programmer will look at and say "WTF are you doing?", but has to put up with anyways because it is so common. Essentially TS programmers are learning ""javascript the good parts" and skipping the rest of the language. 
Hundred percent disagree. JavaScript has weird bits in its design. No doubt. But JavaScript allows you to write code with an amazing amount of expressivity. There is a lot really bad JavaScript devs out there due to its ease of access, the majority of its devs tend to be beginners. But learning JavaScript well is a gift that typescript simply gets in the way of. 
&gt; But JavaScript allows you to write code with an amazing amount of expressivity. Just because you *can* write it a given way doesn't necessarily mean that you *should* write it that way. The best programmers are the ones whose code both runs efficiently and is easy to understand. And while the latter is somewhat subjective, books like "javascript the good parts" were created out of consensus about what good JavaScript looks like.
For sure. There are bad practices within javascript. It's not a candy land. I just firmly believe that while typescript decreases JavaScript weaknesses it also does the same for its strengths. Which is something no one in the typescript community wants to own up to. 
My favorite is the impossible to type event emitter. That can call N functions based on a strong key with the arts passed
Or that â€œmy tests cover everything â€œ. Yeah, right. 
This! Mistyped variable names. Vanilla JS is about as hit or miss as plugging in a USB cable. 50% of the time you plug it in the wrong way, and 50% of the time when you turn it around it still doesnâ€™t go in. 
ys but they have objective data based on their post mortems of production bugs. cant record every bug found in testing.
Can you show a 'good' piece of Javascript code that cannot also be expressed in Typescript?
Your argument would be more compelling with code
Maybe add a test to have an example for beginners and add some comments (or a readme) to explain the dependencies, maybe how you've built the project so users can opt out the features they don't need/like.
&gt; Problem is not framework or languages it is PEOPLE ! You can't fix people. But you can give them tools to avoid their own mistakes.
&gt; My test suite never lie. Sure buddy. I don't need tests. My code never lies.
&gt;I tried the regular way You mean via `process.env`, what doesn't work? are you sure you're passing the env vars when running your node app (e.g. `MY_ENVVAR=some_string npm start`?
In \`node\`, I think you have access to \`process.env\`, you could Google for that to see if any helpful resources pop up.
I admit that it is hard to pick the right words but you all always use cognitive bias (that one is called the strawman technique) Maybe what I wanted to say is "my test suite is not easily bypassable" Yeah that community is really toxic, you can't have a fair discussion. And when you ask for facts you get downvoted, youpee :( Well your not going to heard about me anytime soon with that behaviour. Stay with your philosophy and your beliefs, I don't want to live in beliefs, I want to live on things that I know
What exactly isn't working ? The way I was shown to do it was having a separate file to assign types to the ENV variables and then including/importing/requiring that file with the *.env file. 
I really don't know what's happening. I did this a hundred times before and it's nerve broke but for this app it's not working. I got a way around https://www.npmjs.com/package/env-var this package is great. And it's also comes with if perks.
A few suggestions: - You should allow folks to consume your lib as a node module instead of requiring usage of a CDN - Since youâ€™re issuing React under the hood it probably makes sense to expose a component so that folks donâ€™t have to wire up the lifecycle methods themselves
Something hard to express in typescript but is second nature in JS, how about a good old curry function? ``` function curry(fn) { const arity = fn.length; return function curried(...args) { if (args.length &lt; arity) { return curried.bind(null, ...args); } return fn.call(null, ...args); }; ``` I once needed currying for a small caching package I maintain, and we were using it at work. I wrote the package in javascript, but because my work uses typescript I had to write a declaration file, and it is not simple to type such a basic idea as basic currying. 
Check out https://www.npmjs.com/package/dotenv. Makes managing them pretty easy, there are also packages that add on to it for some additional functionality.
Since you're using TypeORM, you can just use the support that TypeORM already has. &amp;#x200B; [http://typeorm.io/#/using-ormconfig/using-environment-variables](http://typeorm.io/#/using-ormconfig/using-environment-variables) &amp;#x200B; You shouldn't need to do anything but set TYPEORM\_HOST, TYPEORM\_USERNAME, etc.
And you could write { direction: 'pizza' } which from the type system point of view, it is correct, but makes no sense. With enums, this is not possible, it enforces you to choose a valid direction.
You can restrict the string values with literal types: `type Direction = 'up' | 'down' | 'left' | 'right'` . Perhaps even better would be simply `changeDirection('up')` because then we don't have redundant information about "direction".
How would you set it for client side TS? Does TS have some sort of static interpolation we can use?
Typescript tax, and unit test tax, go towards health care. Who doesn't like health care?
To be fair, Eric Elliot is a bit of a blowhard and writes in a way that indicates that his opinion is the only valid one. &amp;#x200B;
[https://quicktype.io/](https://quicktype.io/)
ðŸ¤”
I just shipped a feature today you may be interested in: https://github.com/knpwrs/redux-ts-utils#createasyncactionst-a-extends-any-type-string-startpayloadcreator-successpayloadcreator-failpayloadcreator It's basically just a convenience function to allow you to create three action creators all at once: start, success, and failure.
Why do you need currying in javascript? You can express the same concept with an anonymous function.
You never need currying, currying is a technique that can sometimes make your code nicer, or just works well with the problem at hand. In my case it was what I wanted. It's easy to do in JavaScript. Not easy to type in typescript. I was asked to provide an example so I did. 
https://medium.com/@donnut/typescript-and-currying-161da78ae3f7 
Yeah I ended up doing something similar. But that's my whole point. You lose expressivity. 
&gt; You lose expressivity. No you don't. Currying is just take a function and wrapping it in another function with one less parameter. You can easily express that without a magical curry function.
My God. How hard is it to admit typescript is by nature less flexible and expressive then JavaScript? All typed languages are. That's is not what this function does. The function I posted allows you to generically partially apply parameters. You could have a function of 4 arguments create the curried version, and then you could apply the parameters how ever you like. 1 argument at a time, or 2 by 2, or 1 then 3 or 1 then 2 then 1 etc... You can love your static types all so much, but you can't pretend typescript can express everything JavaScript can. Unless you use "any" which in the end is basically using JavaScript. 
My god, how hard is it to admit that currying is a stupid trick that is no more interesting than an anonymous function?
Currying is not a stupid trick, it's one of the corner stones of functional programming. I'm not a major fan of functional programming, but I wouldn't be so dismissive. Anonymous functions are completely unrelated to currying. And currying is one example that meets the criteria of a code example I was asked to provide to back up my point. It's a great one because it's simple in JavaScript but not possible to type in typescript correctly. (You can do the thing in the medium article above which is what I did too when writing my declaration file but it's limited) My point is not even contentious. It's fairly obvious. 
Currying just a special case of partial function application performed repeatedly. Aside from replacing a series of commas with parens, and dramatically increasing your function call overhead, there's nothing special about it. I've yet to even see an example of it that wasn't just academic wankery. But I suppose that doing things as inefficiently as possible is "fundamental" according to many FP fanboys. 
Sure. Whatever. I am not even an FP fanboy by any means. I don't agree with anything you just said, but I don't care enough to argue those points. Your views on currying or functional programming ideas are not relavant to what we are talking about. My point is simply that typescript cannot express everything javascript can. I was asked to provide an example and I did. But I would suggest you open your mind to different ideas.
I care
&gt; Tax Sorry if I sound noob but what exactly is the typescript tax?
I'd address this concern by keeping the `Event` members private / protected, while exposing the same members publically as `EventSubscriptions`.
Its an article this man wrote
Hbjh
I know this isnâ€™t super helpful but the best thing Iâ€™ve found so far is just reading through the docs.
Let me do a shameless plug here, I have produced an advanced course on the subject. https://www.pluralsight.com/courses/typescript-compiler
Best way is to read the github issues and associated pull requests for the specific language features 
This post illustrate being explicit about specifying a return type for React hooks + TypeScript.I've had a problem when letting TypeScript infer a return type of an array.Specifying a return type generated a correct definition file. This post is also about a **question** I have: *Why didn't TypeScript infer the return type of my own hook method correctly?* Does anyone have any idea?
&gt; Why didn't TypeScript infer the return type of my own hook method correctly? Because tuples are not implicitly inferred like that. Just create a smaller test case: function foo() { return [1, 2]; } const b = foo(); `b` will be of type `number[]`, not `[number, number]`.
Thank you for the explanation u/AngularBeginner ðŸ‘Š I now understand the `why` behind it ðŸŽŠ ðŸ™‚
There are libraries like [typescript-is](https://github.com/woutervh-/typescript-is) available that do enable runtime type validation, but since `tsc` itself doesn't allow for custom transformers, you have to use an alternate compiler wrapper like [ttypescript](https://github.com/cevek/ttypescript). 
An alternative to an explicit return type annotation would be to use a **type assertion**: return [item, setItem] as [string, (item: string) =&gt; void]; But personally I prefer to just be explicit with my types. Type inference can just lead to nasty issues that don't get recognized fast enough.
I will consider it as a possible work-around but will take your advice on using explicit return types ðŸ˜‰ 
[https://play.google.com/store/apps/details?id=ric.Jsho&amp;hl=en\_GB](https://play.google.com/store/apps/details?id=ric.Jsho&amp;hl=en_GB) This one is pretty good &amp;#x200B;
I've used this in a few projects, hope it helps: https://github.com/hapijs/joi
So you wouldn't recommend a TypeScript specific library? The `io-ts` library looks like a TypeScript version of `joi`.
I agree. I have the advanced types page bookmarked at work. That, and coming up with uses for those type features.
If you can wait a couple of months, Oriellyâ€™s Programming TypeScript is about to come out https://www.amazon.com/gp/product/1492037656/.
I've recently stumbled upon https://medium.com/@robertmassaioli/safe-cast-for-typescript-ddc5eaac0fea Didn't get around to trying it yet, but looks just like what you want!
Thanks! Bit worried about this part though especially for cloud functions: &gt; The first time that you call the safe-cast library and we introspect the types you want to validate performance will take a small 1â€“2s hit.
You might want to take a look at [typescript-is](https://github.com/woutervh-/typescript-is).
Thanks! Looks like this one requires you to adapt it into your build system.
nice, i'll have to check it out. Thanks!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/h_n] [38% of bugs at Airbnb could have been prevented by using types](https://www.reddit.com/r/h_n/comments/apap01/38_of_bugs_at_airbnb_could_have_been_prevented_by/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Interesting stuff. IMO, the real power of pattern matching comes when you don't have to write custom matcher functions. e.g. when it's a language level construct like in Rust/Scala/Haskell/etc. But, interesting nonetheless! (and I learned that you can put the `default` case at the top of a `switch` statement. I always assumed it had to go to the bottom)
I got the argument typing wasn't needed because untyped code forced you to unit test, therefore, catching the errors there. Pretty funny. 
A *good* (i.e. not JavaScript), strong dynamic type system plus good tests does in my experience. I think a lot of people don't realize that typescript's main benefit wasn't imposing a static type system but slightly unfucking JavaScript's type system.
I rarely want the hassles of types when I'm writing short scripts. Anything beyond that and I most definitely do.
Python strikes a good balance in that type annotations can be used for static analysis of bugs, while not enforcing the type annotations at runtime. This way I can have my cake and eat it too.
The anti-TS mindset is not too dissimilar to saying you don't need seatbelts because you never crash. It's obviously nonsense. I find that the types themselves make for great documentation and get devs up to speed much more quickly than otherwise. It's phenomenal.
Except for the cryptic errors. When it works it's beautiful, but when it doesn't good luck debugging your types. Specially if generics are involved. I wish they focused more on improving this area.
Sounds familiar!
Yes?
So in your example, you mistype a variable name, and it so happens to be the name of another variable, and that variable has a different type? Because otherwise I don't see how this is a TS thing.
Not sure name calling really helps the discussion much. I went and looked up this article (https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b) and it seems well written and fair to me. Eric Elliot seems to have a ton of programming experience and has first hand, extensive use of TypeScript. So just because you disagree, you just call the author an â€œidiotâ€ and move on? That seems very unprofessional. Also kind of surprised how many upvotes you got. I guess this is a subreddit that is more concerned with being an echo chamber of positive reinforcement of a shared ideology rather than learning and growing as a programmer by confronting and debating ideas which you might not agree with at first? Well, itâ€™s a free world :) Or maybe itâ€™s just youthful inexperience and exuberance that is at work here. When I was a younger programmer, Iâ€™m sure I had concrete ideas as to what was the right way to program and what was â€œstupidâ€. Over the years of learning different languages and working in different companies Iâ€™ve come to learn that company environment/culture and make up/experience of the team members is the #1 factor that determines what language or framework is most successful at a given company. Language features and benefits come in as a far distant second. Anyways, maybe I shouldnâ€™t have written this mini rant. I probably should have just downvoted the comment and moved on.
I also use joi and then just cast it as the type I am intending. The reason I have never used a typescript specific library is because it is very intrusive. Once you start using one their types and abstractions will be everywhere throughout your codebase. What I like about Joi is that you could just switch it out with some other json-schema like validation library. The downside is that you need to make sure that your types and your validations stay in sync. Its a hassle but I have found it to be the lesser of two evils.
That article is pretty objectively terrible. He's one of those guys who sells himself as a "programming guru" without ever saying anything of substance. He'd fit perfectly in an episode of Silicon Valley.
I obviously don't agree with calling him an idiot, but tbh, it's a very low quality article, his graph of conclusions are arbitrary and absurd, and the statistical malpractice on display is almost physically painful. His claim that "there's little evidence that type safety reduces bugs" links to a Medium article.... Written by him... Referencing a studies of bug density that simply look at Github repos, their languages, and the number of issues labeled "bug". If you can't see a million sources of skew polluting this data, I don't know what to tell you.... An easy one off the top of my head (that comports with my experiences at FAANG and beyond) is that the choice of language for a project isn't independent of how complex the project is, or how much attention it gets, and both of these have obvious correlations with the metrics for bug density in the study that have nothing to do with the language's contribution to bug density. Im far from a static-typing fanatic: my last job involved building a tech org from scratch, and I picked python for our backend and would do it again (despite personally hating every minute of it) for a variety of reasons: the low quality of the engineers in our pipeline, the ease with which we could go into tech debt for quick feature changes, etc etc. Elliot touches on these points, but he doesn't even attempt to mount a serious defense of the skew between the large positive scores he places on them and the low weight he places on static typing benefits. Again, I wouldn't go as far as "idiot" but it makes me pretty skeptical of his engineering ability and that of those he's worked with. (FWIW, if my last company had been built with a couple of friends at roughly my engineering ability, I absolutely would've gone with a statically-typed language, from personal experience with the level of productivity and stability it engenders). 
Try webstorm, it shows you typescript errors in the program before compiling 
The tax is predictable; the bugs, not. My vote is predictability.
Nope. You type, say, `heigth` instead of `height` and the compiler catches it during compilation, instead of having to wait for a runtime error or test failure.
That whole article has a lot of substance, you don't think it does?
Youâ€™re not using eslint? Thatâ€™s the issue
I think it's intentionally written to feel like it's substantive but it is absolutely not. He's comparing the ROI TypeScript to using TDD and code reviews which is completely bizarre -- TypeScript make those things easier, it doesn't act as a replacement for it. Furthmore, he has random gems like this: &gt; Missing Features â€” HOFs, Composition, Generics with Higher Kinded Types, Etc. Which is just plain wrong. So wrong I don't even know what issue he could have run into that would give him that idea. There was an HN thread that had some pretty good responses in the comments: https://news.ycombinator.com/item?id=18977700
Have you actually read this thread? Lol.
AJV treats us well: https://www.npmjs.com/package/ajv
Unless you're [SQLite](https://www.sqlite.org/testing.html)
Which does have bugs as evident in its fixes that come with each released version.
The key word being "seems". If you dig a little deeper than the surface â€” as others have pointed out already â€” it's mostly charlatanry.
It was a joke about the 100% branch coverage that the project has.
&gt; The anti-TS mindset is not too dissimilar to saying you don't need seatbelts because you never crash. That's a horrible analogy. Wrong at best and messed up at worst. People who don't want compile time typing like TS just don't want the BS. I personally don't use it much because I don't really run into issues with types as I name my variables in such a way that they indicate what type they use. Sure there's the occasional mistake but it's not worth the overhead. The rest of what you said is definitely not untrue though.
Io-ts is the best Iâ€™ve found. It is what you want. Youâ€™ll get used to it. 
He isn't comparing TDD with TS, he is saying that if you use TDD (et al.) you catch the bugs TS is supposed to prevent. So if you are to use all of them combined the added value of TS (in regards to catching type bugs) is not very big. There might be errors in that piece, but that doesn't mean there isn't anything of substance imo.
You can't know what properties are available on an object unless you know the type of the object. Eslint doesn't do this analysis. E.g. function distance(p) { return Math.sqrt(p.x*p.x + p.y*p.y); } var point = {width: 1, height: 2}; console.log(distance(point)); In this case, eslint knows that `p` is defined inside `distance` and that `point` is defined in the call `distance(point)`, but it doesn't know that `point` and `p` need to be the same type and they aren't. Similarly, eslint doesn't know why this code is wrong: function distance(p) { return Math.sqrt(p.width*p.width + p.height*p.height); } var point = {width: 1, hieght: 2}; console.log(distance(point));
&gt; He isn't comparing TDD with TS, he is saying that if you use TDD (et al.) you catch the bugs TS is supposed to prevent But that's completely the wrong thing to measure. You should be measuring a codebase with tests and code reviews writting in TypeScript versus one without. Comparing TDD to Reviews + TDD is so apples to oranges it doesn't even make sense. It's just a nonsensical way of assigning a negligible ROI to TypeScript's main benefit of type safety. And that's exactly the problem with this piece: he's cherry-picking his data (e.g. by using his own specious articles as sources) and using lots of hand-waving to make it seem less obviously biased.
I once had a bug in a javascript "getter" in our code base. Yup your tests better cover meaningful roundtrip if you use getters/setters (we did, it's complex, dont ask). &amp;#x200B; This was where dynamic types lost me. &amp;#x200B; As for this idea that "just test it" -&gt; well tests aren't free. Tests cost. They cost a lot, and reduce the agility of your code base. Do types cost as much? Hard to say, we have no objective measures of these things, so we just end up in pissing contests.
Sure whether types are worth the benefits or not are very much up for debate. Is OO better than functional programming? It's different people having different opinions. Imo you can build great software with tests and typescript. And great software without either. That article is a combination of facts, anecdotes and his personal opinion. I'd argue it's a lot of substance, even if you don't agree with his opinion.
&gt; Comparing TDD directly to Reviews + TDD is so apples to oranges it doesn't even make sense. This is the exact comparison a lot of tech teams I have been involved in have made: - They already used TDD in the rest of tech stack (such as java backends) - They were wondering whether to going vanilla or TS (or flow) Are apples and oranges that bad to compare if that's all you have at home and you are hungry?
That's literally the whole reason. With currying you can skip part of this overhead because you can apply an arbitrary number of arguments or pass all of them instead of always needing to return a function for every argument. Also there's fundamental difference between passing an argument and *always* return a functions or a value when the arguments are all satisfied versus *always* passing in a tuple (or triple, etc.) to return a value. 
And a good article would explain that TypeScript is beneficial with or without TDD (or even better -- explain how writing a good test suite is easier with TypeScript). A bad article would say that TDD ensures typesafety ergo TypeScript's impact is almost zero.
Npm install config â€”save
You mean that would be an article that you agree with. Do you think all articles you don't agree with are bad? I think it's a great article and I think TDD is terrible. Different things work for different people. 
Sounds more like having your cake and then putting it back in the fridge. 
&gt; Do you think all articles you don't agree with are bad? Nope, just this one. I'd be really curious to hear what insight you gained from reading it.
Please, provide some examples for proof or take that back. I use Typenscript on a daily basis and I can't confirm that.
He talks about his perspective on TS in small and big projects, I have no experience with TS in big projects so I learned that some people actually dislike it for big projects (which I have never heard before). Whenever I talk to big proponents of TS they always explain me that the benefits of TS are small in small projects, but once the project scales up the fact that TS provides a lot of advantages. Here is an article being very concise in why he disagrees. Very insightful imo (even though not everyone agrees). FYI: the biggest JS codebase I maintain is a few years older than TS (or when it became popular) and is still written in vanilla JS: github.com/askmike/gekko
I've found this to be a great resource [https://github.com/basarat/typescript-book](https://github.com/basarat/typescript-book)
I've found this to be a great resource: [https://github.com/basarat/typescript-book](https://github.com/basarat/typescript-book)
actually, given that most people will never in their lifetime be in a car accident where seatbelt will make a difference, they could save a siginificant amount of aggregate time by not buckling up. 
a tax is when a group of kids mows your lawn, says you owe them $200 and if you won't pay they will drag you to their house and throw you in the dungeon and if you complain, people will laugh at you and call you an anarchist.
Lol yeah I thought that when I read it. Did you do c# ? I think I was told that there. 
OT: seatbelts. I say "they are there to reduce the trauma of the person who has to pick up your body parts"
IMO types are like free tests.
Rather than focus on themselves, I ask people to consider the trauma of the people attending the 3,500 fatal road accidents every day, 100 alone in the US, 231 in Europe.
Eric Elliott might not be an idiot, but he is pretty much known for shady PR practices. He has once famously claimed that [a university degree might be a huge waste of time](https://medium.com/javascript-scene/want-to-code-a-university-degree-might-be-a-huge-waste-of-time-81e1817a2ef0) (which *is* partially true, with a lot of caveats though), and the conclusion? Find a good mentor (again, this is actually a good advice), and here's a HUGE link to a "mentoring" program---his own, of course. I won't buy anything from such a person.
I used runtypes in a couple of projects. https://github.com/pelotom/runtypes You can define a type once and somehow it generates the typescript definitions for you. This way you don't end up with 2 definitions of a type
there are 300 millions people in the US. any small risk will seem large when multiplied by this number. 
50k LoC for a few months is a medium to small project. Large starts at 10x that. He used TS for too short a time to even see its benefits on a medium project.
For those of us that have worked with good statically typed languages, this is no surprise. However I've got to ask developers loving TypeScript â€” are you prepared to accept that: 1. TypeScript's bivariant generics make the type system unsound and that's a problem with real consequences, no matter how many special use-cases are patched 2. The language, like many other mainstream languages, is missing higher-kinded types and this makes the type system much less expressive than it could be Paul Graham is famous for his [beating the averages](http://www.paulgraham.com/avg.html) article, in which he says: &gt; As long as our hypothetical Blub programmer is looking down the power continuum, he knows he's looking down. Languages less powerful than Blub are obviously less powerful, because they're missing some feature he's used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn't realize he's looking up. What he sees are merely weird languages. He probably considers them about equivalent in power to Blub, but with all this other hairy stuff thrown in as well. Blub is good enough for him, because he thinks in Blub. So if you discovered TypeScript and like it, consider looking at other, more powerful languages too, or at least convince Microsoft to fix its unsoundness.
a significant amount of aggregate trauma
[Lots and lots of testing isn't always a good sign.](https://news.ycombinator.com/item?id=18442941)
Why is Hungarian notation any easier than just putting the type? What BS are you talking about?
Oh my god that gave me aids
I don't speak for others by I personally can't stand thought leaders and Elliot styles himself as one. The main reason programming continues to be a backwater hackfest is because we chase celebrities, trends, and garbage arguments about type safety when we could be quietly solving problems and sharing the aspects of our work that seem general enough to help others do the same.
Hmm, I get the sense that states should be a little bit more legitimate than those kids. (Whether they *are* more legitimate is a separate question.)
A tax is when everybody democratically elects representatives that organize how to get things done that most people agree need doing, but won't take care of themselves (due to tragedy of the commons, market failure, human nature, etc...). People who disagree with how much needs to be done democratically (rather than individually) then sometimes make silly analogies how "taxes are like theft", even though one of the things that the democratic representatives budget for is a police force and a court system that enforce the abstract notion of "private property" in reality. In other words, without a state and taxes, everybody would laugh in your face at the notion that this was "your lawn".
&gt;A tax is when everybody democratically elects representatives that organize how to get things done that most people agree need doing, but won't take care of themselves (due to tragedy of the commons, market failure, human nature, etc...). so everybody agreed to elect people to bomb iraq because iraq needed to be bomb but won't bomb itself? 
and equally proportionately significant amount of aggregate time spent putting on seatbelt
I wouldn't use LoC as a measure of project size (especially in frontend with half the codebase being template stuff). I'd look at how many people contribute, how many people own how many different parts of the code, etc. I know tiny projects with a 100k+ LoC, especially if you start pushing templates and xml based assets into git.
&gt; I personally don't use it much because I don't really run into issues with types as I name my variables in such a way that they indicate what type they use. So you have developed a personal, ad-hoc type system with a pretty inaccurate and buggy compiler (your brain). How is this better in any way? 
What's your argument? That democratically elected governments make mistakes and therefore are illegitimate? Non sequitur. For the record, yes, Iraq would not have bombed itself. Yes the people who decided to bomb Iraq were elected by a majority (=/= everybody obviously). And yes, in this they represented the opinion of the majority of the population of the USA at least: https://en.wikipedia.org/wiki/Public_opinion_in_the_United_States_on_the_invasion_of_Iraq#Invasion_of_Iraq Incidentally, the war was also illegal, so in the complex system of checks and balances that we have put into place to prevent the abuse of the delegated power, the institutional means are there to stop decisions such as this one. None of this has anything to do with the legitimacy of taxes.
Hah. No coz I am experienced and build complex systems for a living. I have to context switch constantly which includes programming languages, databases, dealing with people etc etc. Sure if I had all the spare time in the world writing code in typescript or even brainfuck would be great but I am not a production line programmer. I can hire a few of them for the dollars I'm paid.
*Hey just noticed..* It's your **2nd Cakeday** tiko844! ^(hug)
My counter argument to the "we are experts" phrase, be it about typing or anything else: Everyone has a bad day. You had an argument with your wife, or your child was sick, or you are just under-slept because you binge-watched some show on Netflix. People, even the most professional experts, are still people. Every little bit of machine assistance that you can get, helps.
elm is the next big thing !!!!
What is TypeScript anyway? Does it have a good theory behind the types it is annotating? I'm asking these rhetorical questions because I see people complaining about the soundness of TS type system. Static types grounded in type theory are clearly an evolution and without any real discomfort, as in most cases it can be inferred by the compiler. It is possible to completely avoid javascript , I do my fronted programming in GHCJS, Reflex-dom 
Huge Percentage numbers. For business expansion model, Airbnb maintaining their website asap. 
&gt; equally proportionately what does this mean ?
So this is the reasoning behind all the crapy spaghetti code that was written.
Damn bro chill.
But `'1' + 1`? Correct, that's `'11'`.
Until you get an impossible error at runtime where the types are nothing like the ones the code says are there.
Static types can serve as documentation, but thatâ€™s just a side effect. A statically types compiler is essentially a theorem prover, type theory being equivalent with math logic. A compiler can prove things about your code that your brain isnâ€™t able to at scale. Using big variable names is a really poor substitute ðŸ˜‰
10 years from now youâ€™ll be embarrassed when looking back at this comment ðŸ˜‰
Jeezus this forum is like the NRA. "People kill ppl not guns". Peace out. I'll let you hang around in your echo chamber.
&gt; Every dynamic language has these people who resist the static typing that inevitably some people try to bring to the language. Some resist because having strict typing in a language that wasn't designed to be strict can add more bugs than they remove. Static typing is useful when you do static analysis and are able to spot the type mismatch before the code is executed. If you're only finding out mismatches during code execution and mismatches result in a fatal error, all of a sudden having something typed hint as boolean but has previously been accepting boolean, integers, and nulls is adding a fatal bug. 
I'm on my phone so excuse the syntax but just change it to flatten&lt;T&gt; = (arr: T[]) : T[] =&gt; {} and it should be fine, although I can't remember the type definitions for Array functions off the top of my head.. And definitely learn more about generics, they are fantastic! 
You definitely should use generics. This is as far as I got export const flatten = &lt;T&gt;(arr: Array&lt;Array&lt;T&gt;&gt; | Array&lt;T&gt;): Array&lt;T&gt; =&gt; ( which should be correct typing. However, there is an issue in invoking arr.reduce which might be related to that at that point Typescript is not sure whether arr is Array or an Array of arrays. I've found related github issue here [https://github.com/Microsoft/TypeScript/issues/10620](https://github.com/Microsoft/TypeScript/issues/10620)
you could type it like this if you want to require that the input array is an array of only arrays flatten&lt;T&gt; = (array: T[][]): T[] =&gt; ...;
Fantastic, I think I might have it then. export const flatten = &lt;T&gt;(arr: T[]): T[] =&gt; ( arr.reduce( (acc: T[], val: T) =&gt; ( Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val) ), [], ) ); I'm not seeing any errors, so I think that's it. Thanks a lot!
If you want this function to be recursive to an arbitrary depth, I don't think you can achieve that without `any` - at this point, it doubles up for `unknown | unknown[] | unknown[][] | unknown[][][] | ...`. Since TypeScript can't know what all the possible types are going to be, it cannot type check that without evaluating the code. The one thing you _can_ do is limiting the type checking hole to this function, by forcing the caller to cast the output. As long as they do that correctly, and your function works correctly, that should give some reasonable assurances. You can do so by changing the return type to `unknown[]`.
That doesn't type it correctly, as `T` will shape itself to the types of the elements of your input error. For example, if you call `flatten(["a", ["b", "c"]])`, it will be `string | Array&lt;string&gt;`, meaning it will return an element of type `Array&lt;string | Array&lt;string&gt;&gt;`, even though it's actually an `Array&lt;string&gt;`. Thus, TypeScript would throw an error if you'd try to do `flatten(["a", ["b", "c"]]).map(e =&gt; e.toUpperCase())`, which should be correct.
&gt; which might be related to that at that point Typescript is not sure whether arr is Array or an Array of arrays. ...or an array of arrays of arrays, or an array of arrays of arrays of arrays, etc. See https://www.reddit.com/r/typescript/comments/apfkxh/how_should_i_correctly_type_an_array_flatten/eg7x52k/
That will only flatten arrays in which every element is an array in which every element has the same type.
I don't think it's just a matter of fixing the unsoundness. Typescript code will generally interface a lot with untyped code from the wider JS ecosystem. The soundness compromises (AIUI) are generally related to enabling that typed/untyped interop. So it's not just a language issue, it's an ecosystem issue. Getting folks to adopt types is a significant lift as it is (e.g. the comments here); creating a sound type system that couldn't interop with the existing JS ecosystem would probably have been a non-starter adoption-wise.
Both '1' + 1 and 1 + '1' are '11'.
Both '1' + 1 and 1 + '1' are '11'. 
That's exactly what the CTO of a company I was interviewing at told me.
It mostly misses "array of type x".
The cringe is real
Yeah, but considering that T can actually represent array of something or array of array of something etc. the main issue is really only in Array of T or Array of Array of T, that's something that OP is solving in runtime using isArray().
/r/iamsosmart
Hahaha Iâ€™m a global travel expert
Working with Angular and RxJS, this can be pretty maddening. TS compiler wants me to specify `(x: Sometype) =&gt; {}`, but expresses it with a weird, cryptic, and dense stack of type errors. 
So, like TypeScript. 
Just realized today (by reading a tweet) that: `let a = "1"` `a -= -1` gives you 2. You're welcome. 
Yeah, but that's not the same as writing hieght, though. Arguably it's a whole 'nother class of errors. 
Actually TS has a quite solid typesystem that enables very complex types. I have not used PHP in a while, but ill guess its a continuation on what was there before, meaning its still a nominal system. FWIW javascript benefits hugely from a structural typesystem becuase of its nature, and this was IMHO the key why TS did succeed as it has.
&gt; T can actually represent array of something or array of array of something etc. Sure, as a union type - but that means the return type will _also_ be a union type including all those arrays, even though it represents a value that only includes atomic elements.
Yeah there is no "string deconcatenation", "-" means numerical operations. One minus minus one is two. 
No worries, sorry for my sketchy syntax!
There is no perfect way to type this currently, predominantly because recursive types are not allowed. If we could use recursive types, then the solution would be simple: type Flattened&lt;T&gt; = T extends Array&lt;infer U&gt; ? Flattened&lt;U&gt; : T; export const flatten = &lt;T&gt;(arr: T[]): Flattened&lt;T&gt;[] =&gt; ( // tslint:disable-line no-any arr.reduce( (acc, val) =&gt; ( Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val) ), [], ) ); In general, when a typing would be easily achieved via recursive types, overloads are the (somewhat nasty) solution. Although they obviously will not be able to type the entire domain of the function, we can write overloads for a reasonable sub-domain. For example, in this case we may want to type an array argument of depth up to 3. This can be done with generics: function flatten&lt;T&gt;(arr: T[][][]): T[] function flatten&lt;T&gt;(arr: T[][]): T[] function flatten&lt;T&gt;(arr: T[]): T[] function flatten&lt;T&gt;(arr: T[]): T[] { return arr.reduce( (acc, val) =&gt; ( Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val) ), [], ); } const depth1 = flatten([1, 2]); // number[] const depth2 = flatten([[1], [2]]); // number[] const depth3 = flatten([[[1]], [[2]]]); // number[] A slightly subtle point is that the overloaded function definitions are matched from top-to-bottom, so we need to have the deepest definition first. All of the uses of the function would match the final (bottom) overload, however, T would end up being an array-type itself. Hopefully it's clear how this approach could be extended to allow deeper array forms to be used. This is a relatively frequently used approach - see for example the [type definitions for Ramda's compose](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/ramda/index.d.ts#L662)
I couldn't disagree more. Virtually every TypeScript error I have seen was very clearly explaining the problem and how it should be resolved.. (source: been working with TS for 6 years..)
Eric Elliot is a goddamn moron
Knowing the difference may be interesting but is irrelevant to the conclusion that 38% of bugs were preventable with typescript.
Just noting... &gt; elected by a majority I was going to say, elected by a plurality, but actually even in 2000 the Democratic candidate got the plurality of the vote and lost - 47.9% beat 48.4%
&gt; What BS are you talking about? learning how a type system works.
 if (avoiding_if_statements) { boilerPlate += 10; maintenanceFootprint += 10; programmer = foolish; }
I thought about that, but the war was authorized by a vast majority in congress, too.
The percent is the postmortem analysis, which means bugs that hit production 
It's actually a lot better than it used to be.
Come on, you know what he meant, fixing the typo won't fixed the whole thing.
I think there's a productivity goldilocks in language features/complexity. Too little and the programmer is slowed down by lack of tooling. Too much and they spend more time finding the perfect abstraction than solving the actual problem.
In the future TS version it'll be possible to use so-called const contexts for this exact purpose: https://github.com/Microsoft/TypeScript/pull/29510
Seeing how messed up the syntax that people are suggesting, and it's *still* either incomplete or wrong and ultimately confusing, I'll just go with **any**.
&gt; Also kind of surprised how many upvotes you got. I guess this is a subreddit that is more concerned with being an echo chamber you must be new here they will just vote the direction of the existing votes quite frequently i leave the same comment in two places, and one will end up +50, the other -50
I lost my temper, sure. The article is still absurd, and he's still an idiot. The premise of the article basically boils down to "TypeScript won't catch *literally every error in existence* therefore it's completely worthless". Nobody ever claimed TypeScript will catch all errors and it's absurd to think that's what it sets out to do. That premise alone is ridiculous. Anyway, he's an idiot because he's a big name in the cryptocurrency space. Which you would only get involved with if you have a complete failure to understand both computer science and economics. That alone is enough for me to dismiss his opinion on anything. 
&gt; Actually TS has a quite solid typesystem that enables very complex types not really
That is so weird because tuples are not constant. They're mutable.
i recommend this library. [https://github.com/corgidisco/safen](https://github.com/corgidisco/safen) const validator = safen.sfl&lt;Person&gt;`{ name: string, id: number, friends: number[] }` validator.validate(...) // return true false validator.assert(...) // error occured
I found one just now: src/app/view/invoice/invoices/invoices.container.ts(74,13): error TS2345: Argument of type 'UnaryFunction&lt;Observable&lt;any[]&gt;, Observable&lt;any[]&gt;&gt;' is not assignable to parameter of type 'UnaryFunction&lt;Observable&lt;Invoice&gt;, Observable&lt;any[]&gt;&gt;'. Types of parameters 'source' and 'source' are incompatible. Type 'Observable&lt;Invoice&gt;' is not assignable to type 'Observable&lt;any[]&gt;'. Type 'Invoice' is not assignable to type 'any[]'. Property 'includes' is missing in type 'Invoice'. I believe it wants me to turn `reduce((acc, cur) =&gt; [...acc, cur], [])` into `reduce((acc: T[], cur: T) =&gt; [...acc, cur], [])`
Ah, good point
&gt; are you prepared to accept that: &gt; &gt; TypeScript's bivariant generics make the type system unsound Given the alternative? Yes. . &gt; The language, like many other mainstream languages, is missing higher-kinded types The reason this is true in almost all mainstream languages is that these really just aren't very important. . &gt; Paul Graham is famous for his beating the averages article It's weird because the language he's recommending also doesn't have a sound type system . &gt; consider looking at other, more powerful languages too I can't name any whose end results both run in the browser and don't require users to start learning a new language from scratch while also throwing away basically all existing tooling and libraries And frankly type system soundness just doesn't seem worth that to me
Related: using the addition symbol "+" for string concatenation was a mistake to begin with. Addition is commutative, string concatenation isn't. 
It is amazing (and dismaying) that something like this would need to be "discovered". The susceptibility of engineers to fads and peer pressure is no different that the rest of the talking monkey population, despite their claims to logical thinking.
 readability = Number.MIN_VALUE; 
TypeScript is the BestScript indeed ðŸ˜‰
I think your title is misleading. I kept reading your article and thinking "but where was the need for an if statement to begin with?". It wasn't until the very end where you show the use case you are avoiding with your command dispatcher pattern. You aren't saying no to ifs; you are saying no to if/then/elseif/then/elseif/then/etc constructs when building a message dispatcher and you did this by using a dictionary that maps a command name to a function. I think your solution is good for that use case.
Check out quicktype.io
The title is misleading, itâ€™s not about not using ifs, itâ€™s about making your app easily extendable (open/close principle and command pattern in this case)
Eric Idiott.
Oh so a property name not a variable name. Yup makes sense
&gt;having strict typing in a language that wasn't designed to be strict can add more bugs than they remove I'm gonna have to disagree unless you can quantify an example of this. If you turn off type checking you're back at JS levels of no type enforcement. Typescript is a superset of JS, it doesn't change how JS operates.
If you are counting XML and templates as LoC, your tools are misconfigured.
What tools do you use for counting LoC? 
Not really? Please show an example were it falls short.
 var point = {width: 1, --------&gt;&gt;&gt;&gt; hieght &lt;&lt;&lt;&lt;&lt;------- : 2}; 
If you really want to define your types just once (and not repeat the same definition for type-level and value-level code), io-ts is pretty good. I've used it in a large project and it definitely reduces the amount of code you need to write.
My take on this^^ I often use recursive function, but type inference in those is tricky, so I just assert return type with correct mapped type. Here's it's very base case but you can conditionally traverse &amp; transform basically any tree. ```ts type NonArray&lt;T&gt; = T extends any[] ? never : T export const flatten = &lt;T&gt;(arr: T[]): Array&lt;NonArray&lt;T&gt;&gt; =&gt; { const init: T[] = [] const result = arr.reduce((acc, val) =&gt; { if (Array.isArray(val)) { return [...acc, ...flatten(val)] } else { return [...acc, val] } }, init) return result as Array&lt;NonArray&lt;T&gt;&gt; } // (number | (number | number[])[])[] const fixture = [1, 2, [2, 3, [2, 34], 23]] // number[] const test = flatten(fixture) ```
In the second example, the error is literally writing "hieght" though. The specific rule eslint is using is [no-undef](https://eslint.org/docs/rules/no-undef). You can see that it only catches very specific instances of typos. I.e. any errors it reports are really accesses to global variables that it doesn't know about. A typechecker will catch typos in any identifier name, not just identifiers that look like global variables.
IMO best answer for now. Although a little too explicit, it should get the job done.
no higher order or higher kinded types, the type system isn't sound and could have been, can't make policies, mixins are unnecessarily difficult and can't be functional, type widening is extremely problematic (it's like 1997 c++ down there,) it's really pretty bad at inference, there are limitations to its runtime effectiveness because it still has to produce JS at the end, `do` still isn't practical, haskell's idea of functors still isn't possible, monads still aren't practical, enums are extremely weak, et cetera ad nauseum Look, I'm not dragging TypeScript. I use it, and I love it. But use Eiffel, OCaml, Haskell, or F# and get back to me, because that's all available in stuff like Reason and Fey and Elm
The languages you use affect the way you think and the solutions you reach for. Basically all typed languages use an entirely separate and much less powerful language to describe the types. So you learn to write your executable language in a way that is constrained by what you can easily express in your type language. Since very few type languages in use today are very good at describing code at a high level of abstraction, you end up with a giant blind spot for high level abstraction.
I've never heard of the guy but I believe you based on the fact that he was casually referenced here and people recognized him. I still remember the jarring feeling I got when articles started showing up with regularity on HN's frontpage that were obviously-wrong, low-quality Medium crap from someone trying to "build their brand" by blogging. I guess it's just a part of growing up, both professionally and in the wider world: you realize that you don't actually need to be that smart or know what you're talking about to have a platform, whether you call yourself a journalist or a blogger. &gt; The main reason programming continues to be a backwater hackfest is because we chase celebrities, trends, and garbage arguments about type safety when we could be quietly solving problems and sharing the aspects of our work that seem general enough to help others do the same. FWIW, the engineering labor market seems to be quietly bi- or multi-modal, and there's a part of it in which all the faddishness and backwater nonsense doesn't really exist at all. (My last job hunt was made much easier because I started leaning into the fact that the first thing employers try to do is place you into one of the modes, and from there the conversations are generally quite productive). The closest the environments I'm familiar with come to "thought leaders" are people with direct subject-matter expertise like Dijkstra and Rob Pike or Geoff Hinton, and that still only buys them your ear, not your agreement, as they're criticized all the time. 
What about just implement type guards on your own? 
A discussion on command patterns in Typescript is useful. The "no more ifs" needs to be a bit more detailed, mainly because there is a lot of verbiage to avoid what would be an if statement.
pardon the noob question but cant you use a recursive interface instead of type?
Type '(state: State&lt;ListModel&lt;ListType&gt;&gt;, payload: ListType) =&gt; ListType\[\]' is not assignable to type 'Action&lt;ListModel&lt;ListType&gt;, ListType&gt;'. Type 'ListType\[\]' is not assignable to type 'void | State&lt;ListModel&lt;ListType&gt;&gt;'. Property 'list' is missing in type 'ListType\[\]' but required in type 'State&lt;ListModel&lt;ListType&gt;&gt;'.ts(2322) * test.tsx(21, 3): The expected type comes from property 'remove' which is declared here on type 'ListModel&lt;ListType&gt;' (property) ListModel&lt;ListType&gt;.remove: Action&lt;ListModel&lt;ListType&gt;, ListType&gt;
This is just a small example. I get these once I start doing composition and it's not at all obvious at a first or even second glance what the error is. It's all the same color/font and horribly formatted. If you've used ReasonML before you would know how much better the errors are. As long as you use libs with strong TS support and remain in the consumer side of things it's awesome. The moment you start doing complex object composition via generic functions it gets messy really quickly. &amp;#x200B; Btw I'm not hating on TS, I like it overall. I just wish they got to a point where you wouldn't have to spend so much time wondering wtf is wrong with your custom types.
https://github.com/Aaronepower/tokei
SQLite is actually used in airplanes (Airbus A350 XWB), and the code is BEAUTIFUL. It reads like poetry. It is one of my favorite OSS. &amp;#x200B; [https://github.com/mackyle/sqlite](https://github.com/mackyle/sqlite)
Don't think of it as flattening a type, think of it as un-nesting a type: interface Nested&lt;T&gt; extends Array&lt;T | Nested&lt;T&gt;&gt; {} type Flattened&lt;T extends Nested&lt;unknown&gt;&gt; = Array&lt;Exclude&lt;T, Array&lt;unknown&gt;&gt;&gt;; function flatten&lt;T&gt;(arr: Nested&lt;T&gt;): Array&lt;Exclude&lt;T, Array&lt;unknown&gt;&gt;&gt; { return arr.reduce( (acc: T[], val: T | Nested&lt;T&gt;) =&gt; Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), [] as T[] ) as any; } const a: number[] = flatten([1, 2, 3, [3, 4, 5], [5, [5]]]); &amp;#x200B;
People who don't like static types often end up implementing a type system using automated tests anyway. I sometimes feel TDD advocates love dynamic languages because there's so many extra tests you could write. Disclaimer - I like TDD, but don't like writing tests to cover what the language should do for you.
It's an option but it's ugly and cumbersome for anything with lots of fields.
&gt; JavaScript has a type system, but itâ€™s dynamic. This is one of the key advantages of using the language, providing an incredible productivity gain. Stopped reading.
Could you tell me why? Iâ€™d love to read a constructive feedback from your side and we can maybe both learn a thing or 2 ðŸ™‚
Dynamic typing doesn't produce a productivity gain, it's much better if your IDE can catch bugs versus only catching them at runtime.
I wonder how reason handles calling javascript functions from reason code. I think it's discouraged in purescript because the type system might break, is it similar story with reason?
Given this subreddit, I'd say a lot of us find having types more productive than not.
You can think that, itâ€™s ok. You can even generalize it to all cases and never write JavaScript. I just donâ€™t think you should stop reading there. This article is not AT ALL making a case against static typing. Itâ€™s actually the opposite. Iâ€™m comparing two statically typed languages and show concrete examples of how cool they are. So to stop reading because you disagree about a sentence, is in my opinion not fair toward the article. 
Love the first comment: &gt;Iâ€™ll always choose simple, explicit and straight forward if statement over overly complicated, overengineeredâ€¦ what actually is that thing?
I wrote something that deals with that in Node: https://medium.com/me/stats/post/7b1189b94637 https://medium.com/me/stats/post/7b1189b94637
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/graphql] [TypeScript type intersection &amp; GraphQL](https://www.reddit.com/r/graphql/comments/apmawd/typescript_type_intersection_graphql/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
 function logCallStack() { const stack = (new Error().stack).split("\n"); stack.forEach((v, i, a) =&gt; a[i] = v.trim().split(" ")[1]); console.log(`${stack[2]} called from ${stack[3]}`); } &amp;#x200B;
You know it might be true what you are saying. Maybe writing your own type checker using unit tests is simply more satisfying. 
I've started migrating parts of my Vue app over to Typescript and have always been a fan of static typing for various reasons, but car analogies are invariably bullshit.
You commented on your own post...
Why would people would want to maintain large systems without static typing is weird to me, after all, we have some studies now : http://ttendency.cs.ucl.ac.uk/projects/type_study/documents/type_study.pdf but we like what we like, I donâ€™t want to fight anymore lol But then why would people would like to maintain large systems with Javascript makes me laugh a lot, then I pay respect for all of developers who can do that, I canâ€™t ... Why would people compares TS which include type inference, sum types ... as well as the ability of typing your codebase in an iterative manner makes me speechless, after all TS has a much better type system than C# or Java, you need that if you are pretentious enough to add type to JS ... which is all that TS does ... itâ€™s a superset so writing JS is an option ... As for those who talk about drawbacks without taking into account benefits or those who think that you can get more value with no efforts. I salute you. Really, youâ€™re in a place I canâ€™t reach. 
it would be even cooler if the whole GQL query got generated from those type definitions. Actually here are 3 different highly experimental libs for doing just that: [https://github.com/capaj/graphtype](https://github.com/capaj/graphtype) [https://github.com/helios1138/graphql-typed-client/](https://github.com/helios1138/graphql-typed-client/) [https://github.com/acro5piano/typed-graphqlify](https://github.com/acro5piano/typed-graphqlify) Of course it's not using the typescript interfaces directly, because those don't exist at runtime, but it's pretty close.
Put a console.error at the beginning of the method. It will print a stack trace, just like if you threw an error (without a catch). Unlike throwing an error, however, console.error will not stop execution nor need to be caught.
Webstorm has this built-in. https://www.jetbrains.com/help/webstorm/viewing-structure-and-hierarchy-of-the-source-code.html
It's not discouraged in Reason + Bucklescript because it's a rather pragmatic solution for the real world. I like thinking of TS as amazing JS interrop with 50% safety, and Elm/Purescript as bad JS interrop with 100% safety, and reason has good interrop with 80% safety. It's a nice balance, IMO, if you want to experience of "if it compiles you won't have bugs" like Elm/Purescript, but also still want to use the NPM ecosystem with a little cost to write a wrapper.
JavaScript is _designed_ to be productive, specifically for new JS developers. Things like ASI, mutation, dynamic types, type coercion, being multi-paradigm (functional, prototypical, imperative, declarative, object-oriented, etc), are all design decisions to increase productivity to those not familiar to the language. I'll concede, though, that not everyone is more productive in JS compared to TS, which the sentence in question seems to imply. Personally I find ReasonML/Ocaml more productive than JS and TS.
I'm not sure why you say higher-kinded types are unimportant. If you've done any work in TypeScript at all, you know that you run into HKTs constantly and there's never a good way to handle them. I love TypeScript and I couldn't care less that it's not sound, but the lack of HKTs does hold the language back. In fact, at one point, I maintained a HKT library on npm, but it kept breaking with every new version of TypeScript because it was using some really complex logic.
Iâ€™m not really sure what this reply is in response to, besides you not liking typed languages. You can easily not write classes in typescript, I do it most days.
Interestingly Paul Graham used a dynamically typed language and highly dynamic runtime programming techniques to build ViaWeb.
I would recommend [graphql-code-generator](https://github.com/dotansimha/graphql-code-generator). I use it with the `typescript-react-apollo` plugin, which will also support React hooks [soon](https://github.com/dotansimha/graphql-code-generator/pull/1295).
Agreed, I'd rather have a less "sound" type system if it makes for a smoother development experience. Perfectly happy with the decisions the team has made so far.
You're asking for a recursive type definition, as flatten needs to not only flatten the arrays of *, but also arrays of arrays of * and also arrays of arrays of arrays of *, etc. The type definition must infer the resulting T. It isn't equal to the elements of the first array (remember that those elements _could_ contain an array, whereas the resulting element type will _never_ contain an array). Recursive type definitions are not really supported by Typescript yet. See https://github.com/Microsoft/TypeScript/issues/6230 There are workarounds for some cases, but I cannot think of one for your case. Restricting the use of flatten to T[][] is possible and other comments have shown type definitions for this already. Just know that these are not the full type definition for the recursive flatten that you've shown in your example.
Put a breakpoint inside the `updateUserAccountDetails` function and when the execution stops you can inspect the call stack.
[json-type-decoder](https://github.com/mojotech/json-type-validation) is an Elm-inspired solution, rock solid with very nice error messages, and works great with existing types. Easy to add custom decoders too.
These left me very underwhelmed, looks like a lot of extra work for not much benefit. I actually like this guy's approach better, simple and effective
Why not run `npm run build` in the app that uses CRA? (That said, as long as you don't use any special Babel or Webpack features - which I presume is the case, otherwise `tsc` wouldn't have worked before - I think you might still be able to use `tsc --noEmit=false`?)
I'm not sure about create-react-app-ts, but create-react-app officially supports Typescript now! You can start a TypeScript project with `create-react-app --typescript`.
Run build minifies the js, this makes it unsusable as a library for our use. Yeah we tried something, since create-react-app forces noEmit=true whenever you npm run build(which we use for standalone running) we made a new tsconfig, that inherit from the main one, add noEmit=false and run that one with a flag when we need to publish. What kind of Babel/Webpack features might become a problem, do you think?
If you read the post, that's what we are using ^^ But thanks!
The problem, of course is that I'm not certain what kind of problems might arise from using tsc when publishing, and Babel when running standalone. Do you have any idea?
&gt; this makes it unsusable as a library for our use. Can you explain why it is unusable?
&gt; What kind of Babel/Webpack features might become a problem, do you think? For example, if you call `require('someStylesheet.css')`. Webpack will know it has to call the CSS loader and inject the required stylesheet in the generated HTML, but TypeScript has no idea. Likewise, you might be using Babel plugins to run experimental Javascript features that TypeScript does not yet support.
As long as you limit yourself to regular TypeScript and standardised Javascript features, I wouldn't expect too much. Their transpilation implementations might differ slightly, but those should largely affect edge cases. Then again, of course I don't know your use case quite well, so there might be things I'm missing. For more background on why CRA runs both Babel and TypeScript, see [this post](https://vincenttunru.com/why-combine-babel-and-typescript/).
Ah yes, I guess I misread the post. It sounds like you have a bunch of components you want to publish to NPM - unfortunately I'm not sure how to do that; I am curious though!
You can still have a recursive type definition using lookup types, but this is [not recommended](https://github.com/Microsoft/TypeScript/issues/24016#issuecomment-428745727): type Flattened&lt;T extends Array&lt;any&gt;&gt; = { flatten: Flattened&lt;T[number]&gt;, exit: T[] }[T extends Array&lt;any&gt; ? 'flatten' : 'exit'] &amp;#x200B;
&gt; JavaScript is designed to be productive, specifically for new JS developers. JavaScript wasn't designed, it evolved from a 10-day project in May-1995 by one developer and nobody expected JavaScript to be used in the way it is today. It's an absolute mess of a language and a platform.
We ended up doing what u/vinnl said. We made an additional tsconfig file that is run with a -p (specified tsconfig) flag to "tsc". This compiles the code from TS to js using the original Typescript compiler. Then we publish that build folder. The new tsconfig included a few configs needed to make the compilation work properly (like "jsx":"react" and of course noEmit=false). As for running standalone we used npm run build(this runst create-react-app build, and thus the Babel transpiler). Hopefully having two different transpilers won't create too much issues. 
&gt; Avoid null and undefined &gt; I started this article with a Tony Hoareâ€™s quote not just for the sake of appearing literate. This is kind of misleading IMO, and part of the quote that has been removed is actually important. &gt; My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. The issue is not really the existence of null or undefined, rather, that they satisfy any type and are impossible to track. With `strictNullChecks` this is not the case. *Always* using `Option` over `T | undefined` can introduce unnecessary complexity and overhead.
Import moduleName from "modulePath" moduleName(args)
https://itnext.io/avoiding-any-in-typescript-advanced-types-and-their-usage-691b02ac345a
Could be cool, but I canâ€™t tell because thereâ€™s no indication of the behavior or API of the wrappers. What do they do?
&gt;Always using Option over T | undefined can introduce unnecessary complexity and overhead. Well, what you have to keep in mind is functional languages do not do this merely to ensure `null` is not a subtype of `T`. `Option` (and friends) are container types and allow us to use quite a lot of useful, predictable functions on them (like `map`). You basically never have to check for `undefined` again, and can instead just use these functions to express your intent: const nullableVar: int | undefined; const optionVar: Option&lt;int&gt;; // we have to do this every time or risk run-time errors const modifiedNullable = (nullableVar === undefined) ? nullableVar + 2 : undefined; // the checking and floating of the error state is automatically done for us const modifiedOption = optionVar.map(x =&gt; x + 2); Moreover, if you decide to update your code to express why something failed, your code is the same: // potentially fail with a string error message const eitherVar: Result&lt;int, string&gt;; // but our consumer didn't have to change const modifiedOption = eitherVar.map(x =&gt; x + 2); We can argue until the cows come home if this makes the complexity of container types worth it, but I can't agree with the notion that it is *unnecessary* complexity and overhead. There is a reason functional languages by and large did not take the approach typescript did, even when they are in a similar situation (such as F#), and there is nothing wrong from learning from FP to solve the same problem typescript tried to with `strictNullChecks`.
Also, instead of simply using `Option` or `| undefined` (which is not super expressive), you can express your domain with a data structure. For example, consider a simple type: interface Result&lt;A, B&gt; { success: boolean; result?: A; error?: B; } Something can meet this interface while being in an invalid shape, such as `result` being `undefined` while `success` is `true`. Instead, we can ask the compiler to ensure when someone claims to be a `Result`, it is in one of the two valid states: interface Ok&lt;A&gt; { success: true; result: A; } interface Err&lt;B&gt; { success: false; result: B; } type Result&lt;A, B&gt; = | Ok&lt;A&gt; | Result&lt;B&gt;; Now, this is definitely more to write, but it more clearly shows the shape of our domain. It is not possible for a `Result` to be in an error state and have a result value, or for it to be in an error state and not have an error value. And the typescript compiler is even smart enough to narrow the type based on our checking: let x: Result&lt;number, string&gt;; x.result; // type error if (x.success) { doSomething(x.result); // good to go } This allows you to leverage the compiler to ensure your code has less mistakes, which is a very common tactic in FP: making incorrect code *unable to even be compiled*, let alone ran.
That should work, just drop the {} from rules
Try this: ``` export interface Query { condition: string; rules: Query[] } ``` This will allow you to pass an empty array to `rules` without any issues. [Here's a pretty decent interface definition from Prisma](https://github.com/prisma/prisma/blob/master/cli/packages/prisma-datamodel/src/datamodel/model.ts) that implements something like what you're trying to do.
This seems to be working! Thanks! 
Just tried that and so far so good :) Thanks!
Ah, yes, this would be a very helpful technique. It would depend on me being able to run the code that would generate the error, which I think is often true in cases like this. I think I'd get a lot of references to npm package internals - I recall seeing a lot of bluebird entries in stack errors - but maybe there are techniques for omitting those from the displayed stack.
What, you're saying I need to actually getting around to figure out how to use `node-inspector`?! What are you, my mom?
Whoa. I use Webstorm! As far as I can tell, this tool won't automatically find a call chain between two given functions (if such exists); it's more like a much easier-to-use alternative to manually grepping between functions. I'll definitely use this. Thanks!
I tried that. Not working for express-mysql-session. Kindly check the documentation. The module sport is a class thus requires new.
Interesting post, here are my thoughts: I think a good method for vanilla JavaScript error handling is to use error handling middleware. See this article: [https://thecodebarbarian.com/80-20-guide-to-express-error-handling](https://thecodebarbarian.com/80-20-guide-to-express-error-handling) That way you can have a single "generic" try/catch block for all of your controllers. If you throw from a controller it is caught by the Express error handler and dealt with accordingly. I use TypeScript for my Express servers (highly recommended). I create my own HttpError classes which have an httpErrorCode. \`\`\` export class HttpError extends Error { httpCode: number; constructor(httpCode: number, message?: string); } \`\`\` then in my controllers I can throw appropriate errors: \`\`\` if (await this.userRepository.count({userName: registerDto.userName}) !== 0) { throw new BadRequestError("A user by that name already exists."); } \`\`\` RE: the article by Yuriy Bogomolov. I've seen similar posts through the years extolling the virtues of never using null, instead use monads (Optional/Maybe) etc. At various times I've even tried them out in my own code. Personally I'm not a fan. I find that it actually reduces readability and adds more "noise" to my code. I'm sure there are benefits to use them in certain circumstances but my subjective opinion is that I disagree with a lot of the article ... and you know what? That's perfectly fine. It's OK to disagree with these types of articles even if they're from widely respected programmers. Try out the pattern if you like but most importantly make your own decision as to whether this pattern is suitable for your codebase. Too many programmers follow best practice as dogma.
You make good points, but they aren't really addressing what I've actually said. &amp;#x200B; The fundamental problem with null references is that they aren't tracked as types. Whether they are tracked as true unions, or algebraic data-types, is an orthogonal point. To talk about the null references and not even mention \`strictNullChecks\` is not a fair representation of typescript. &amp;#x200B; I also specifically said: \&gt; Always using Option over T | undefined **can** introduce unnecessary complexity and overhead. &amp;#x200B; They **can** be unnecessary, not **always**. Sometimes something will be undefined and you can check and return a sensible default value; wrapping that up in an option is completely unnecessary. Similarly, if I'm designing an API endpoint I might not want to ship my own option type, and just returning \`T | undefined\` lets the client handle it in their own way. &amp;#x200B;
By writing `{} | Query` you're telling the compiler "this can either be an empty object, or a query". Then you try to access the property `condition`, just as it if were a query. But what if it isn't? You said before it can be either of those two, and the first type does not have a `condition` property. So the compiler is smart and warns you.
I absolutely dislike throwing for the sole reason that it can't be expressed in the type system. Looking at an API it's not clear **if** it can throw, and **what** it can throw. Instead I prefer the functional approach by having something akin to a `Either&lt;TResult, TError&gt;`, so either a result or an error object. That usually comes along with a lot of comfort functions, e.g. calling another method if you got a result, otherwise just return the error again. Such a type will be clear in the API.
You're extending `Error` wrong: https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work
Thanks :) To be honest, my example was just pseudo code, written in haste. I'll update my post though. 
&gt;As far as I can tell, this tool won't automatically find a call chain between two given functions True. However, it should be able to trace back the stack, and you can then find your calling function in the tree. 
Right, which is why I spent the time I did explaining why always using them would not be 'completely unnecessary', by showing their value. There is a reason why someone would make this decision, and it is no less valid in TS than it would be in haskell just because of the existence of `strictNullChecks`, and it is no more "completely necessary" in TS than it would be in F#. Even in domain boundaries such as an API, which is where I would agree the most with you, returning `T | undefined` forces the client to handle a possible `undefined`. It is the same problem as if you returned `Option&lt;T&gt;` and forced them to unwrap it, only in reverse. We have to express this concept of it might being not there *some*how, and your client is inconvenienced if they use the opposite approach. That being said, &gt;To talk about the null references and not even mention `strictNullChecks` is not a fair representation of typescript. I agree. The article should have brought it up and at least gave a passing mention as to why they did not find it sufficient, which would dovetail nicely into an explanation of the benefits of using `Option` everywhere.
When deciding to implement something as a thrown error, or an error datatype, I usually consider two things: 1. What is the distance between the creation of the error, and its handling. 2. Is the error a domain specific state, or a genuine exception. For example: entering a wrong password is a state, having the user interrupt an evaluating process is probably an exception. If the distance is far, and it's a genuine piece of exceptional behaviour, I throw an error; otherwise, I use a result type. I also think it is good to never throw errors across API boundaries. IMO, everything at the public boundary should be passed as data, not control flow. 
&gt; the benefits of using Option everywhere. Is this something you'd advocate? I first encountered it in Java, and liked it. I'm considering using in TS as well, although `strictNullChecks` eases the cognitive load and I never get around to do it. I found that the library `purify-ts` has nice `Maybe` and `Result` types with a small footprint, but I'm still on the fence about going full Optional.
That's a way of doing, but in your example, this would be valid: ``` const a: Result&lt;string, string&gt; = { success: true, result: "", error: "" } ``` That breaks the pattern of making invalid states unrepresentable. I'd much rather have something like this: ``` type Success&lt;T&gt; = { kind: "success"; result: T; } type Err&lt;T&gt; = { kind: "error"; error: T; } type Result&lt;TSuccess, TErr&gt; = Success&lt;TSuccess&gt; | Err&lt;TErr&gt;; ``` This way, you'd never have your Result object in an invalid state.
Well, the main reason I did it without (nominal) tagging is I like typescript's structural typing philosophy. I don't care what *other* things the object can do, so long it can be a valid representation of the state I want. And in: { success: true, result: "", error: "" } This is still capable of acting like: { success: true, result: "" } Thus not an invalid state for `Ok&lt;string&gt;`. The main thing I want to prevent is: { success: true, error: "whoops" } Which it does. 
I like that `Ok` &amp; `Err` separation. I'm curious what you think about cases with multiple data points. Let's say I do an API query to an API I have no control over, where I request two fields for an entity. I ask for `phone` and `address` for a person, any of which may be missing. I'd end up with an object that looks something like this: { phone: string | null address: string | null } How would I deal with this using the functional approach? Should each field of the resulting object be an `Ok` or `Err` type? e.g. { phone: Result&lt;...&gt; address: Result&lt;...&gt; } Or something else?
&gt;const a: Result&lt;string, string&gt; = { success: true, result: "", error: "" } &amp;#x200B; This does get flagged as an error because of excess property checking. Your definitions are essentially equivalent.
I understand when you say you can dismiss the other properties, but in your example, this is code that would compile and crash at runtime. &amp;#x200B; \`\`\` interface Result&lt;A, B&gt; { success: boolean; result?: A; error?: B; } function exec(a: Result&lt;string, string&gt;) { if (a.success) { console.log(a.result.toLowerCase()); } } const someResult: Result&lt;string, string&gt; = { success: true } exec(someResult); \`\`\` &amp;#x200B;
Have you installed the types for that project? `@types/express-mysql-session` 
I don't have a strong preference. `strictNullChecks` is more "javascript"-y. `Option` is more compose-able and I tend to find the related functions very expressive. Personally, I often find when I would want to return `Nothing` or `undefined`, I could return a reason *why* there was `Nothing`, such as `NoProfileWithThatId`. This tends to nudge me towards `Result` or `Either` types instead of `Option` or `T | undefined`. And then I can just map off of that and I get all of my errors propagated, which is pretty snazzy. I do always have the compiler flag on, though, along with `noImplicitAny`. 
I may have spoken too soon. Now I have this: query: Query = { condition: 'and', rules: [ { field: 'author', operator: '=', value: ''}, { field: 'fileType', operator: '=', value: ''}, ] }; /** Type '{ field: string; operator: string; value: string; }' is not assignable to type 'Query'. Object literal may only specify known properties, and 'field' does not exist in type 'Query'.ts(2322) (property) field: string */ &amp;#x200B;
Right, which is why I moved to a sum type. :) The first example was meant to illustrate the problem that you notice. `{ success: true }` is valid for the non-sum but is not a valid state for `Ok&lt;A&gt;`, thus cannot be implicitly converted to `Result&lt;A, {}&gt;`.
Read the error message, it is **very** clear. Check the array you try to assign to `rules`. According to the earlier type definition it is an array of `Query`. But `Query` has no `field`, `operator` or `value` property. It only has a `condition` and `rules` property.
So, there's this thing called the [domain boundary](https://fsharpforfunandprofit.com/posts/serializating-your-domain-model/). When you leave the pretty space of your app and talk to things like APIs which you do not control, you obviously do not have control over their responses. This means you usually can't express them in 'pretty' functional types, and you have to rely on probably `null`-able DTOs. But whence you're inside your domain, you can shape it however you want to. You would typically use a sum type when the differences between those states are meaningful; when it makes sense for a part of your app to say "I want a model with a phone but no address". Since I don't think that makes sense here (it will probably just be given a default value), I would probably model this in my domain with `Option`. import { fromNullable, Option } from 'some option implementation'; export interface PersonDto { phone: string | null; address: string | null; } export interface Person { phone: Option&lt;string&gt;; address: Option&lt;string&gt;; } export const fromDto({ phone, address }: PersonDto) =&gt; ({ phone: fromNullable(phone), address: fromNullable(address), });
I am sorry if I am confused. I originally had rules set to accept either an object or another Query bc the rules array can contain objects (basically JSON data, as you see in my reply) AND/OR more Queries. I believe I showed this structure in my original post. So now that it is set to just Query[], it won't accept the objects. But if I use my original definition of ({} | Query)[] it fails elsewhere in the code. I am trying to set the correct type so I don't have to use 'any'.
&gt; But if I use my original definition of ({} | Query)[] it fails elsewhere in the code. You should understand **why** it fails. And if it either can be "any object" or a "query", then the question will be: How can you distinguish these two? Can the object look like a query, but just be an object? If you can define how you identify a query, then you can write a custom type-guard function and use that.
Why a new blog post on an old version of typescript? 3.3 has been out for a while.
The added mapped type modifiers are just as functional now as they were when TypeScript 2.8 was released. No symptoms of decay, I promise :)
I adopted `purify-ts` in a side project and love it, though I'd urge caution in using such a new project so detached from the mainstream ecosystem for any major projects anytime soon. In practice it's like having `Option` and `Result` everywhere in Rust, with the only difference being that the fringes of your code return `null` or `undefined` and have to be handled with the likes of `Maybe.fromNullable`.
Any reason you know of as to why the readonly keyword is on the left, but the question mark is placed on the right side? Seems inconsistent, but I suspect there's a reason for it. 
I suspect there may be some assuming that the reader has a background or at least some knowledge of functional programming concepts. fp-ts should have a lot more information about it, if you're interested. For example, here's their docs explaining an Either. https://github.com/gcanti/fp-ts/blob/master/docs/Either.md
This feature would have really helped for my other problem ðŸ˜… I was told that that feature would be available in v3.4. ðŸ‘ [https://www.reddit.com/r/typescript/comments/amh8cu/dynamically\_build\_typescript\_string\_literal\_type/efmahpw/](https://www.reddit.com/r/typescript/comments/amh8cu/dynamically_build_typescript_string_literal_type/efmahpw/)
I always use `noImplicitAny` as well. In fact, I've found out that I only need to specify the types highlighted as a result of that flag in order for TS to know pretty much everything that's going on. Care to give an example that would highlight the composability of Option?
The thing about container types is that they have an operation similar to `map`, but knows how to flatten the structure if you return a container type. For example, we might do something like: someOption.map(x =&gt; x &gt; 20 ? Some(x) : None()) ... but then we have `Option&lt;Option&lt;number&gt;&gt;`. Which is not cool, since it's awkward to get at the actual value. There's something on arrays called `flatMap` which knows how to unnest when you return arrays, and there's something similar for container types, called variously `chain` (in javascript) and `bind` (everywhere else). It works similarly to `map`, except ... someOption.chain(x =&gt; x &gt; 20 ? Some(x) : None()) ... now we just have `Option&lt;number&gt;`. This ability to flatten the container turns out to be really powerful. You know `Promise#all`? Why not have an `Option#all`? You give it a big ol' list of `Options` and it gives you either `None` if there were failures or an array of the `Some`. That implementation isn't that hard (though a bit dense) whence we have `chain`: const all = &lt;T&gt;(xs: Option&lt;T&gt;[]) =&gt; xs.reduce( (acc: Option&lt;T&gt;[], next: Option&lt;T&gt;) =&gt; acc.chain((ys: T[]) =&gt; next.map((x: T) =&gt; [...ys, x]), Some([]) ); We reduce `xs`. Our reducer immediately chains on our accumulator, so if there was a `None` at any point we just return that. Assuming we have `Some` results, we map over the `next` value we're reducing on (so if that is `None` we just return that), and simply concat. Let's say we had an array of validation results. Either `Some(value)` or `Nothing` if validation failed. If we use `all`, we then trivially have the ability to find if the form is valid: if we get `Nothing` back then it's invalid, and if we get `Some` back it's valid: let validations: Option&lt;any&gt;[]; const valid = all(validations).some; ... but let's make this a bit more interesting. What if our validations returned an error message too? If we have the `Result` type, they can do just that - like `ok(value)` or `err("must be greater than 20")`. The really cool thing about this is that since they're both container types, we can trivially use the same technique we just did for `Option` for our new `Result`, only we've suddenly gained error messages too. In fact, if you look at that `all` function from earlier, the only thing about it that would change for a `Result` implementation is the type annotations (most of which I don't think are necessary anyway). In fact, that `all` function could be how `Promise#all` is implemented (if you alias `then`). That's what happens when we have these container types and the common functions on them. *Any* container type can implement `all` whence it has `chain` and `map`. Anyway, imagine now we have a bunch of validations of `Result`: let validations: Result&lt;any, string&gt;[]; const result = all(validations); if (result.success) { clearValidationMessage(result.result); } else { setValidationMessage(result.error); } And I just think that's kind of neat. Given `chain` and `map` and `reduce`, we can combine arbitrarily many container types.
Cool, it actually gives you an error and you can continue the pattern for e.g. ListWithAtLeast3Items: type NonEmptyList&lt;T&gt; = T[] &amp; { 0: T }; const x: NonEmptyList&lt;number&gt; = []; // Error
I wonder how many more they'll find if they used Purescript
We use Purescript at work. I don't remember the last time anyone on the team needed to fix a bug in the Purescript code. I had to fix around 4-5 bugs in the JS code in the past week alone. The Purescript code is really well designed with proper usage of types everywhere possible. Refactoring is done in Purescript fearlessly, if it compiles it'll run correctly or there's a bug in the JS or backend code that sends wrong data to it. I really wonder how the ecosystem of frontend would be if Purescript became a widely adopted language
The longer I work with dynamic type language, the more I need static type. Totally agree with this text, as I experience myself how less bug I created after switching to Typescript.
Readability
always a good read from marius
I had no idea this existed.
Applicable to Go vs Python debate point 
Are you telling us that you \_never\_ think of the type of your variables ? Never do you tell yourself that â€œthe first parameter of this function is a stringâ€, or that â€œI must check this return value before using it, because the contract says it could be undefinedâ€ ? &amp;#x200B; I call bullshit.
Thank you Marius! Your blog is one of the best TS resources on the web. Question: how do you know so much about the intricacies of TS? I've read through the documentation many times but would never have realised some of the things you write about, especially your posts about mapped and conditional types. 
Yes I did
its an extremely good series, Marius. please dont listen to them and keep it up!
Not for code quality and ease of maintenance, however it is a good sign for low bug frequency.
I think escape hatches are great to have, but they shouldnâ€™t be the default. If you use an escape hatch, you should know that youâ€™re doing it. Disclaimer though, I havenâ€™t worked too much with real world typescript applications, so I donâ€™t know how often the need for bivariance pops up in practice and how much friction it would cause if you would need to be explicit about it.
Why does anyone upvote this comment lol. Features of 2.8 don't become useless in 3.3
Thank you, Iâ€™m glad youâ€™re enjoying the series! :) I typically go to GitHub and look through the pull requests of the feature I write about. The summary in those pull requests is usually quite detailed.
Thank you for all that work you do! I recommend just to say Typescript 2.8+ to avoid such confusion- or, even simpler, not to mention version in the title at all.
&gt; There is a reason why someone would make this decision, and it is no less valid in TS than it would be in haskell just because of the existence of strictNullChecks Not just because of strictNullChecks; there are other reasons why some ideas are less effective in TS than in Haskell. - Parametric polymorphism in TS has some wonky edge cases that make it easier to incorrectly implement the definitions of monads. - No unification-based type inference. - No do-notation. (async/await does not count). You end up having to create closures all the time which can get quite noisy. There is also the converse view that everyone seems to overlook. Why do FP languages not take the approach TS does? Well *some* languages do, anyway. Typed Racket has occurrence typing which is similar. Another benefit of TypeScript's approach is that unions commute, monads and algebraic data-types do not.
Put it in a *.d.ts file somewhere the tscompiler will find it
It was supposed to be a joke. I love typescript.
To clarify, I definitely don't think he should stop.
Semantics of features can change though, people also like to get an idea of whether they are reading a new article or not.
If it's a standalone module you can create your own `types/` or `@types/` folder, and then the name of the "external" library, for example: src / &lt;your project&gt; types / mymodule / index.d.ts tsconfig.json You can modify the `"typeRoots"` property in the tsconfig.json to delcare the path you want, in my example, I would set it as: `"typeRoots": ["./types", "./node_modules/@types"]`.
Something that isn't being brought up for some reason is that when you throw in a promise, you are basically already using a result type, because a Promise will automatically convert that to a reject. `Promise&lt;a&gt;` is basically the same thing as `Result&lt;a, any = Error&gt;` only it is async. You're still encapsulating everything in a container type. Compare: const validateUserNotBanned = user =&gt; user.holds &gt;= 0 ? ok(user) : err("user is banned"); const validateUserNotBannedAsync = user =&gt; user.holds &gt;= 0 ? Promise.resolve(user) : Promise.reject("user is banned"); Looks pretty similar, huh? In fact, if all you're worried about is dogmatically throwing, you can just straight-up replace the throw with `Promise.reject`. export async function loadUser1(username: string): Promise&lt;User&gt; { const user: User | undefined = await User.findOne({ where: { username } }); if (!user) return Promise.reject('UserNotFound'); if (user.disabled) return Promise.reject('UserDisabled'); return user; } But you don't have to stop there! export function loadUser1(username: string): Promise&lt;User&gt; { return User.findOne({ where: { username } }) .then(user =&gt; user ? user : Promise.reject('UserNotFound')) .then(user =&gt; !user.disabled ? user : Promise.reject('UserDisabled')) } Maybe checking if the user is disabled is something you would do in a variety of places. We can make the code even more clean and testable: export const ensureUserExistsAsync = user =&gt; user ? user : Promise.reject(user); export const ensureUserNotDisabledAsync = user =&gt; user.disabled ? Promise.reject(user) : user; export const loadUserAsync(username: string) =&gt; User.findOne({ where: { username } }} .then(ensureUserExistsAsync) .then(ensureUserNotDisabledAsync); Notice this looks suspiciously similar to a `Result` flow: export const ensureUserExists = user =&gt; user ? ok(user) : err('UserNotFound'); export const ensureUserNotDisabled = user =&gt; user.disabled ? err('UserIsDisabled') : ok(user); export const loadUser(username: string) =&gt; User.findOne({ where: { username } }} .chain(ensureUserExists) .chain(ensureUserNotDisabled); ;)
&gt;At **various** times I've even **tried them out** in my own code. Personally I'm not a fan. I find that it actually reduces readability and adds more "noise" to my code. [emphasis not in source] There's a saying in the functional programming community: whence you understand functional programming, you automatically lose the ability to explain it. Case in point: you read Yuriy's article and who knows how many others without understanding that *Promises* are, in fact, exactly the sort of type like `Optional` and `Maybe` that they extol you should use. You've been getting all the benefits of the big scary M word without even realizing it! J'accuse! The `async`/`await` stuff just obfuscates it. Whether for the better or worse, well, that's opinion. You can even express something similar with generators for any other sort of container type (which is how `async`/`await` works itself afaik). 
Thanks for your post. It was interesting. If you think I'm not seeing something or you vehemently disagree with my opinion please post more information. If I'm missing something or not understanding something then I'd definitely like to fix that gap in my knowledge. I think promises are ugly too. I much prefer async/await + throw to promise/promise.reject. I also like that throw stops execution immediately. The only benefit I can see from using \` Either&lt;TResult, TError&gt; \` (as described in another post on this page) is that you can then see if the api method throws an error. Useful but still not worth the added boilerplate in my opinion.
Nope, those compilers can catch misspelled variable names too. Compilers can catch all kinds of things: wrong number of arguments, attempts to inherit from final classes, attempts to access private methods, uses of undeclared variables, invalid casts... You should try one. Compilers are REALLY helpful when refactoring code.
It's not a type thing, it's a compiler thing. Catching misspelled variable names (and other classes of errors) has been a compiler thing for decades. It's a great tool for that job. ESLint misses A LOT of stuff that compilers are easily able to catch.
Promises *are* `async`/`await`, was my point. Try typing (async () =&gt; 2)(); into your console. You'll see it's the same as Promise.resolve(2); The syntax doesn't change the types or what is happening under the hood, it's just syntax. Moreover, when you return a `Promise&lt;string&gt;`, it is the same as an async version of `Either&lt;string, any&gt;`. They obey all the same rules that makes them "special" in fp. If you intentionally wanted to avoid these container types for their "boilerplate" you'd have to go back to accepting callbacks. That's the main thing it seemed like you were not understanding. You're *already* using it, just the syntax you're using to consume it is different. And syntax is syntax is syntax. We all have preferences there.
Yes, I already understood that promises use the same functional style container types. I find the syntax of them is ugly. async/await hides the details to give you a more... procedural "style". The functional style in these instances (try/catch/throw vs Either type + async/await vs promise/promise.reject) seem to add unnecessary boilerplate. I think this is just a matter of taste.
You don't need types to catch your misspelled variable names, any javascript linter / compiler can do it.
\&gt; Yes, I already understood that promises use the same functional style container types. This is kind of a red herring because promises differ from these containers. `Option&lt;Option&lt;string&gt;&gt;` is a thing; `Promise&lt;Promise&lt;string&gt;&gt;` is not a thing. In some cases the boilerplate isn't unnecessary and it really does give you extra functionality. I agree that there is no one perfect solution, and it really comes down to experience to pick the right tool for the job.
These are all trash libraries tbh - just use [https://github.com/dotansimha/graphql-code-generator](https://github.com/dotansimha/graphql-code-generator)
It was easier than I thought.. What I ended up doing was to create some d.ts file as advised and inside I put: ``` declare module '@foo/bar' { export interface ButtonProps { htmlType?: string, type?: string, icon?: string, iconPosition?: string, text: string, onClick?: () =&gt; void, disabled?: boolean, 'data-cy'?: string } declare const Button: React.ComponentType&lt;ButtonProps&gt; export default Button } ```
I'm very much against throwing exceptions, especially in a library meant to be consumed by others, for the reason that you cannot tell what will and what won't throw an exception. I'm writing an api client in typescript for my company's API where all the calls are 'functional' in that they require you pass in a valid token, and return an \`ApiResult&lt;T&gt;\` type, which has a field \`ok: boolean\`, if it's true it'll have the data inlined, if it's false it'll have an error type. Check it out and let me know if it helps you at all: [Cycle API](https://github.com/cycleplatform/api-client-nodejs/blob/master/src/common/api/request.ts)
There aren't any types in /dist because there isn't any Typescript in /dist. Don't forget the code that runs from /dist is plain old JS. The types are just for the compiler/editor.
You're right, but I'm exporting the type files on build and writing them to index.d.ts in the /dist file
What do you think of this idea? Create a `./src/node\_modules/` directory with shims that redirect to the appropriate, peer `./src` directories? // ./src/node_modules/foo.d.ts export * from '../../../foo/src'; // ./src/node_modules/bar.d.ts export * from '../../../bar/src'; During development, when your `./foo/src/index.ts` tries to import 'bar', it'll resolve to `./foo/src/node_modules/bar.d.ts`, which redirects to `./bar/src/index.ts` via the `export *` syntax. However, when building and publishing to npm, your `./src/node_modules` directory will *not* be compiled to `./dist`. So it will respect the package.json `"types"` field. You can create this fake `node_modules` directory once -- with a shell script if you want -- and symlink it into each `./src` directory. Let me know if you end up using this, and if it works for you! I think I might do the same in my personal monorepo.
I'm guessing you're using tsnode currently? You could just leave it pointed at dist, and at dev time use nodemon to re-run tsc to re-create the dist folder contents when you change files. 
I second this, actually understand why things go wrong rather than getting things to work. Thats not how you learn, you learn by understanding your mistakes
Are you using a bundler? 
No, and I'm trying to avoid that if it can be avoided. I'm not concerned with compatibility with older browsers.
You provide Observable&lt;Invoice&gt; where you want Observable&lt;any\[\]&gt;. Its simple, clear and not cryptic at all?
What is wrong with the error message? &amp;#x200B; It breaks down to Type 'ListType\[\]' is not assignable to type 'void | State&lt;ListModel&lt;ListType&gt;&gt;'.
Well, that could be true, if it were not for the facts that: * I'm not providing `Observable&lt;Invoice&gt;` * I don't want `Observable&lt;any[]&gt;` Claiming that the error message above is "simple, clear, and not cryptic at all", and that the hinted types are correct is a bold statement. Out of five lines of error message, one is vaguely relevant: Type 'Observable&lt;Invoice&gt;' is not assignable to type 'Observable&lt;any[]&gt;'. But the way it's stated makes very little sense to me - Imo it claims that I'm assigning `Invoice` to `any[]`, when `Invoice` is the input and `any[]` is what gets returned back into the pipe. &amp;#x200B; What it actually wants me to do is exactly what I wrote - typehint the input variables so that they specify that one is an array of the other. `any[]` obviously works, but if we're typing things to `any` we might as well not bother. I'm 75% convinced that you're just trolling at this point. 
 import moduleFactory from "modulePath"; const moduleName = moduleFactory(argument);
in your .ts file export type CdnLibrary = any; or you need types for the CdnLibrary 
Bundlers don't necessarily solve the problem of browser compatibility. Bundlers like webpack allow you to not concern yourself with filesize and instead organize your code in logical ways. AFAIK no browser properly supports this out of the box. There's zero config options out there if you don't want to fuss with config files. Really given your requirements I'd be less inclined to recommend babel, as that is a tool specifically designed for providing browser compatibility. Though even in the case of babel there's still features of es7 and typescript that are not usable on any platform without it. 
If OP is only supporting evergreen browsers, they all support ES6 modules natively, and it's possible to use modules without a bundle. Libraries might pose an issue though. 
It's hard to help without seeing your project. Is the types package installed and referenced in package.json?
I know I can type it manually like \`const \[firstClass, secondClass\]: \[ClassA, ClassB\] = createInstances(\[ClassA, ClassB\]) \` but I want to know if I can do it dynamically 
Have you looked in to type parameters?
Generics can be inferred from parameters. createaInstances&lt;T1, T2&gt;(classes: [typeof T1, typeof T2]): [T1, T2] I think that should work, I'm on mobile so I couldn't test.
The issue is that `[ClassA, ClassB]` is not identified as a tuple `[ClassA, ClassB]`, but instead as an array of either class: `(ClassA | ClassB)[]`. With TypeScript **3.4** (March 2019) you can solve this easily by using the new [const contexts](https://github.com/Microsoft/TypeScript/pull/29510). Then you can write `createInstances([ClassA, ClassB] as const)` to help the compiler infer it correctly as a tuple. Alternatively you can help the compiler with a **type assertion** using the type assertion operator `as`, for example `createInstances([ClassA, ClassB] as [typeof ClassA, typeof ClassB])`. But this of course is very verbose and annoying to write the class names twice. If modifying `createInstances` is an option, then you have two options. The first would be to make use of rest-parameters, then you can pass the classes as arguments instead of an array/tuple: type Constructor = new (...args: any[]) =&gt; any; type InstanceTypes&lt;T extends Constructor[]&gt; = { [P in keyof T]: T[P] extends Constructor ? InstanceType&lt;T[P]&gt; : never }; const createInstances = &lt;T extends Constructor[]&gt;(...ctors: T): InstanceTypes&lt;T&gt; =&gt; undefined as any; const [firstClass, secondClass] = createInstances(ClassA, ClassB); Alternatively you can also make use of function overloading and provide overloads for the different tuple types, for example: type Constructor = new (...args: any[]) =&gt; any; function createInstances&lt;T1 extends Constructor&gt;(ctors: [T1]): [InstanceType&lt;T1&gt;]; function createInstances&lt;T1 extends Constructor, T2 extends Constructor&gt;(ctors: [T1, T2]): [InstanceType&lt;T1&gt;, InstanceType&lt;T2&gt;]; function createInstances&lt;T1 extends Constructor, T2 extends Constructor, T3 extends Constructor&gt;(ctors: [T1, T2, T3]): [InstanceType&lt;T1&gt;, InstanceType&lt;T2&gt;, InstanceType&lt;T3&gt;]; function createInstances&lt;T extends Constructor[]&gt;(ctors: T): any { // Implementation be here }
Never write the extension in the import. You probably need a declaration file for the imported js module.
typeof is not gonna work. type Newable&lt;T&gt; = new() =&gt; T; function createInstance&lt;T1, T2&gt;(a: Newable&lt;T1&gt;, b: Newable&lt;T2&gt;): [T1, T2] { return [new a(), new b()]; } &amp;#x200B;
 type Newable&lt;T&gt; = new() =&gt; T; function createInstance&lt;T1, T2&gt;(a: Newable&lt;T1&gt;, b: Newable&lt;T2&gt;): [T1, T2] { return [new a(), new b()]; } &amp;#x200B;
The two issues with your code are that you're not using `new` and your import is incorrect. Since express-mysql-session uses a CommonJS style module to export a class, you need to use `import mySqlSession = require("express-mysql-session"); ` `let seesion = new mySqlSession(...)` If you want to use ES6 import syntax then you'll need to set `--esModuleInterop` (and depending on what you have for `--module` you might also need to set `--allowSyntheticDefaultImports`). See [this](https://stackoverflow.com/questions/48785451/is-there-a-way-to-use-esmoduleinterop-in-tsconfig-as-opposed-to-it-being-a-fla) for more details.
I think, and I'm not sure, that apart from the class Foo, Bar could be defined inside of a namespace also called Foo.
They have a class Foo and a class Foo.Bar so I would have to export a class Foo and a namespace Foo... hm.
Yes, that is the way to do it.
This has some serious code smell to me
Thanks man! You first option worked like a charm! It would be better to use an array instead of using rest, but until 3.4 is out I'm using it. Thanks again!
Yes, but I want it to be dynamic
The problem is that I don't know how many arguments the function will be called with, that's why I was looking for something dynamic
They might be using [class expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class).
I love \[this approach\]([https://www.typescriptlang.org/docs/handbook/declaration-merging.html](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)), it should be used more
type Newable&lt;T&gt; = new(...args: any[]) =&gt; T ?
Static fields?
What do you mean? With type parameters, they will adjust to whatever you pass to them.
https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces-with-classes-functions-and-enums
It's pretty normal for js libraries to have a top level export that is both a function and a namespace. JS turns code smells upside down to make new art forms. I'm just continually impressed that it's possible to express every possible insane JS construct in a type safe way.
Thank you
After using dynamic languages for a long time, I've found that mismatched types are almost never the problem. The problem has almost always been null objects. As @pydry has already implied, don't depend on JavaScript doing the right thing. 
Think about this question Are you developing for the TypeScript compiler or for/with other developers? If you use Interfaces, you tell the other developers that it is a certain structure, new B() works, but it isn't very intuitive.
Not it's not necessary. Interfaces can't be substituted with basic types, since those are part of it. You can define structure and then use it as consumer (or your co workers will). You will know what kind of structure should be passed. It's not very strong as type guard indeed, since it's just a duck typing.
What do you mean by "use regular types"? Do you have a code example? \`interface Foo {a: string}\` is pretty much the same as \`type Foo = {a: string}\`.
Here's how you do it in TypeScript. // If Foo is a class, declare it like this export class Foo {} // If Foo is a function, declare it like this export function Foo() {} // Either way, you can merge in a namespace of additional stuff like this: export namespace Foo { export class Bar {} } // Here is an example of a namespace that is not a class nor a function. Same idea: export namespace Stuff { export const whatever = 'hello world'; export class YaddaYadda {} } This all compiled down to what you'd expect. It does `Foo.Bar = class `... to hook everything up.
Sorry, I wasn't sure what to call it, but basically any type other than an interface. So instead of depending on an interface like interface IA { doSomething: (str: String) =&gt; number } let myVar: IA; You would just depend on the type i.e. class A { doSomething(str: String): number { ... } } let myVar: A; In TypeScript you're not actually depending on type A, you're depending on the structure of type A. So you're basically depending on an inferred interface. So rather than an explicitly declaring the interface yourself, you just infer it. 
With an interface you can define a specific minimum shape. If you only use your class A but is has some more attributes it may not be interchangeable with class B that doesn't. If your var is type IA and both A and B would implement IA then it doesn't matter what else they got. If you use this IA type in functions etc also makes it clear for readers you only can depend on what is defined in IA.
I can understand that for in some particular cases but a lot of the time you're not actually using the interface to communicate anything, you're just using it to inverse the dependency. What I'm saying is that TypeScript basically accomplished the dependency inversion principle for you (not entirely - but in a pragmatic way maybe it's good enough). This is because in TypeScript you're not actually depending on class A, you're depending on the structure of type A. So you're basically depending on an inferred interface. So rather than explicitly declaring the interface yourself, you can just infer it.
While this usage works, consider the developer load if we relied on row polymorphism over explicitly implementing interfaces. A developer would have to reference back to a common interface while developing, instead of calling `class Bar implements IFoo` and having the compiler tell them if their implementation is complete/correct. Also, A doesn't say much about how it should be used. You've used it like an abstract class in B, but maybe that interferes with other, unseen methods. This becomes increasingly complex as classes grow. Somewhat unrelated, but we often use interfaces as lightweight "structs." We don't define "full" classes, but define our models as interfaces. TypeScript allows your example because it eases conversion from JavaScript. I suspect there's a compiler option that might disallow this.
The \`class\` example is a weird one, because it's not inference. TypeScript explicitly declares an interface automatically. This becomes clearer when you realize you can extend that interface with additional stuff. (only for rare circumstances, but it illustrates my point) class A { hello: string; } interface A { world: string; } let myVar: A = {hello: 'foo', world: 'bar'}; "Inference" typically refers to the compiler automatically figuring out the type of a value expression. With classes, the "expression" describes the class itself whereas the interface you get describes \*instances\* of the class. You can use interfaces in situations where you don't need a class. For example, many functions accept an option-bag. You describe the option-bag using an \`interface\`. interface Options { recursive?: boolean; cwd: string; glob?: string; searchString: string; } function someGrepLibrary(opts: Options) {//... &amp;#x200B;
In that particular case where you want to actually declare an interface, I would completely agree with you. However, a lot of the time you're just trying to inverse a dependency and in that particular case, the inferred interface may be good enough.
That's the basis of TS since JS won't allow for inferences. The interfaces are gone at runtime but if TSC doesn't generate the code due to an error, transitively all classes implement A. This is how it works in any typed language, machine code doesn't have interfaces, but the higher level languages gate the incorrect code.
The compiler will infer the interface of a class and it will not give an error if the object assigned to the variable matches the inferred interface. (Note: I'm not sure if inferred is the correct term to use here -&gt; perhaps it's more accurate to say that the compiler automatically generates the interface) i.e. class A { doSomething () {} } let myVar: A; // The compiler will be okay as long myVar is assigned to something that matches the // interface { doSomething: () =&gt; void } // it does not matter myVar is not assigned to something that "is a" A // (it does not matter myVar is not assigned to something that extends A) // i.e. class B { doSomething () {} } myVar = new B(); // this is perfectly fine even though B "is not a" A // this is not the case in most statically typed languages (i.e. Java or C#) &amp;#x200B;
Based on the original post, the answer is no, they're not necessary, but they sure are useful for expressing your intent. Based on your edit, the answer is no, they're not necessary, but can still be useful to express your intent. Typescript's typing model is structural and progressive, whereas DI done in different languages may legitimately *need* an interface for testability due to nominal typing. Not that dependency inversion is even a thing you need to worry much about with ES6 modules, since they give you all the benefits.
I write typescript similarly to how I write F Go (Golang). In my case, interfaces are very useful
What you're describing is the fact that typescript has duck typing (looks like a duck, sounds like a duck so it's probably a duck). Personally I do whatever feels right. So if I'm making a litter with a normal oo mindset sure I'll make ILoggable and extend it. But if I'm in angular injecting services I just use the base class not an interface e.g. constructor (private ds: DataService). Although my work normally used classes for models instead of interfaces and just declare Types for simple things.
Thanks for letting me know the name. Now I can do some reading on the topic :)
Personally I try to follow conventions without "reinventing the wheel" so I use ESlint only with [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) and [Prettier](https://prettier.io).
Thanks. I'm just learning TypeScript for the first time (with a fair bit of JavaScript experience already), and have Prettier set up with ESLint and TSLint in VS Code. Still trying to get the hang of all of the different style conventions and best practices.
&gt; a lot of the time you're not actually using the interface to communicate anything That's code smell
It's a code smell to depend on an abstraction (interface) over a concretion (class)?
No, it's code smell to not use interfaces to communicate anything
So it's a code smell to create an interface so you do not directly depend on a class? The interface isn't communicating anything outside of what the class already tells you.
Yes semi-colons. Makes quickly scanning code easier.
Always.
Yes
Yes.
If you don't like semicolons then I think it's okay to not use semicolons *if you're using prettier*. There some edge cases when not using semicolons, but prettier is good at making you look silly when hitting those edge cases. At least that's been my experience.
People on a team should be using a code formatter so that by the time you commit it doesn't matter.
It's code smell to have code that isn't being used to communicate something
You don't want that habit when you migrate yourself to C# (which you will eventually)
i lean toward no semicolons but as long as ive got prettier i really dont care. really surprised to see the overwhelming yeses in this sub tho, i thought opinion was more balanced
This is more of a JavaScript question than a TypeScript question Semicolons are optional because JavaScript assumes the developer is an idiot and tries to fix the code for them. When JavaScript checks the code, it tries to add a ";" to some staments to determine if the code is correct. So yeah semicolons are better to use since it won't force JavaScript to work overtime.
Agree on one as a team, configure `tslint --autofix` w/your CI and be done with it. Human shouldn't waste time on something that can be done better by computers. 
Ugh, THANK YOU. I was about to post a gripe I had with tslint and then learned about a new option. My issue is that "semicolon": "always" requires them for interfaces you declare, but not when they're inline. example: ``` interface Fruit { color: string, // lint error type: string } // no lint error function eatOne (fruit: { color: string, type: string }) {} ``` Then I found "ignore-interfaces" and now it doesn't complain. I'm going to share with my team :)
TS is ugly like JS, so yes.
No, not part of the style guide at my work. I'm personally not a big fan of them in general, just extra noise for me.
C# is a perfectly fine language, but no, I have no plans to ever use it for anything.
I actually really like this philosophy. Maybe I should keep them on. I wish someone would invent a better version of CoffeeScript, with all of the best parts of TypeScript.
tsc inserts them anyway
Happy cake day buddy!
You can compile tons of languages into JS including clojure, scala, haskell, elm, ocaml, reason, kotlin, F# etc. Maybe one of these will float your boat? The only challenge is interop with JS libs - which is one reason TS is amazing because it's just a superset of JS so it's dead simple.
Yeah, after one year coding with Lisp, TS feels ugly and verbose AF.
When I find a style guide worth keeping that banishes semicolons, Iâ€™ll do so 
yea
I bounce between Swift and TS all day so Iâ€™ve started to not use them. Certainly have missed them.
Yeah, I use em.
Depends on the linting library in use ;-)
The Typescript to Javascript compiler takes out the unnecessary semicolons anyway so you won't save any space by missing them out of the Typescript.
I'm not a seasoned Typescript dev, but I used an interface to define what I was expecting from an external config file and it cut down a lot of errors... const config = require(file.json) as IConfig Real nice.
I wrote tsc-to to do this. "to" stands for "transpile-only." It's bare-bones; doesn't accept any CLI flags. But if you `cd` to the same directory as your tsconfig and run it, it'll compile your code without any typechecking. https://npm.im/tsc-to If you try it, please let me know if it works for you!
I don't use them as long as I have prettier set up, which I always do. If you were to run into any of the edge cases when semicolons are needed, it will add it for you. And really you probably never ever will intentionally write code that needs semicolons so it's actually safer to know that if you have any semicolons generated for you, your code is probably wrong.
Interfaces are perfectly regular types. All else being equal, I'd prefer interfaces to classes, since interfaces compile out to nothing. There's often no need for classes. interface Foo { something: number; other: string; } let f: Foo { something: 2, other: "ok" }; A class is more complex than an interface. I'd ask "are classes necessary in typescript?" I consider interfaces to be more straight-forward than classes, although I use them both.
Readability is an art and a science. Semicolons are a declaration of intent. They give code verticality more clarity.
they are injected before minification so no overtime.
Easier to not use them.
If you can edit upstream internal code, go to upstream codebase and add `types` field to `package.json` ([Ref](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html))
Instead of having an Event class, you can have a factory that creates 2 functions w/same closure (2 classes would also work), and just attach those functions however you want to your downstream classes. 
Absolute Nay!. But TypeScript is from Microsoft and these C#/.NET people will crave their semicolons. 
I use semicolon while writing typescript just because I am huge Java and C++ fan boy.
In which case you can replace "JavaScript" with "TypeScript" in the above post.
This is starting to sound like one of those expanding brain memes: - following the style guide - using semicolons for increased readability - using semicolons to optimise runtime performance - using semicolons to optimise compiler performance 
ASI is part of JavaScript and can't be disabled, so developers should understand it regardless of their preference to add or omit redundant semicolons. When writing plain JavaScript with no linter or compiler, I think adding semicolons is potentially far more confusing to new developers, because it's easy to mistake the syntax for something like C and pretend ASI doesn't exist, until it bites you in the ass and adds semicolons where you intentionally omitted them. Relying on the ASI by not adding semicolons manually may also create some initial confusion about whitespace sensitivity, but I think it forces developers to learn the semantics much faster, while avoiding a little bit of extra noise in the code. But when you've got (strict) TS compiler and linter working with you, it really just boils down to what your team considers more readable and enforcing consistency is the key. If you are accidentally returning undefined by line break following "return" or starting a line with "(" without a semicolon, you'll know immediately anyway.
Never semicolons. Unnecessary visual noise. Code should be concise and focus on what's important. Semicolons add nothing. I've configured prettier to strip them from my codebase. So if I see a semicolon somewhere, I know I fucked up (like when I have a line break between a 'return' and the value). 
This, but...use f\*\*\*\*\*\* semicolons too guys
Now I'm curious about your code. Possible to share?
The problem is that ASI isn't a static feature. It changes over time as the JS grammar is expanded with new features, and new cases where a semicolon is required emerge over time. In other words, you semi-less code may break in a future version of JS. 
Not using semicolons can lead to unexpected behaviour and bugs. It takes literally one key press to prevent this or you can just use a formatter like prettier. 
You already said that. I asked you about a concrete example.
Never after a code block, always after single line/expressions statements is my credo.
I did already say that but you didn't seem to be understanding
I tried upvoting this more than once. 
I was giving you an example of when I thought that would be wrong and I was asking if you agreed. Hoping that you would elaborate on your opinion. 
In your first example: it would technically be possible to detect the out of bounds issue before runtime, since your array isn't passed anywhere before the out of bounds access (so there is no chance it was modified elsewhere). This type of thing though is usually more in the realm of a static analyzer. The TypeScript compiler does have some static analyzer-y behavior (like it will use type checks in an "if" statement to suppress compiler warnings inside the if block), but generally speaking it doesn't do a lot of static analysis. &amp;#x200B; Your second example is similar. To raise an issue before runtime would require a static analyzer which understands how the semantics of "pick" work, traces through the code, and sees that you passed in "name" only but were later accessing "age". That's generally beyond the scope of what a compiler would do. &amp;#x200B; I've never used it before, but it looks like there is a static analyzer for TypeScript called SonarTS ([https://github.com/SonarSource/SonarTS](https://github.com/SonarSource/SonarTS)). Maybe see if that is able to catch some of these issues?
Array out-of-bounds checks: the type declarations could theoretically say that all array \[\] access is \`T | undefined\`. Here's why the team has decided not to do that: [https://www.reddit.com/r/typescript/comments/ajhrzi/shouldnt\_myarrayi\_return\_t\_undefined/eevzd7j/](https://www.reddit.com/r/typescript/comments/ajhrzi/shouldnt_myarrayi_return_t_undefined/eevzd7j/) In the \`keysOfPerson\` examples, you're putting an explicit type annotation on your \`const\` which means inference will be ignored, and the variable will have the type you've declared. This means when you call \`pick()\` the compiler is basing its \`subperson\` inference on the less-specific \`KeyOfPerson\` / \`KeysOfPerson\` types. type KeyOfPerson = keyof Person; const keysOfPerson: KeyOfPerson[] = ['name']; // any inference of ['name'] is being erased by the explicit type annotation type KeysOfPerson = [ keyof Person ]; const keysOfPerson: KeysOfPerson = [ 'name' ]; // any inference of ['name'] is being erased by the explicit type annotation const subperson = pick(person, ...keysOfPerson); subperson.age; Inference is the way to handle this: const keysOfPerson: KeysOfPerson = [ 'name' ] as const; Unfortunately, we have to wait for TS 3.4 to get \`as const\`: [https://github.com/Microsoft/TypeScript/pull/29510](https://github.com/Microsoft/TypeScript/pull/29510) Until then, we can do one of the following: const keysOfPerson = ['name' as 'name']; // manually narrow inference from string to literal // Use generics on an identity function to trigger narrower inference function literals&lt;T extends string&gt;(arr: ReadonlyArray&lt;T&gt;): ReadonlyArray&lt;T&gt;; const keysOfPerson = literals([ 'name']);
In theory an array with its length statically typed is great, but there are a few practical issues. Consider Array.push(). This mutates the array by adding an element. Further, it doesn't even give an array as the return type - the input array only appears in one position in the signature. So how would the compiler even track this? You need a way more complex type system that tracks side effects of function in addition to arguments + return types. Let's say you add this. Now consider a function that asks for a number from the user, promptNumber(). What if I create an array with size equal to promptNumber()? Well, the length of this array can be anything, so all the work we did is to statically get the length is foiled by this runtime operation. And that's really the problem - anything non-pure will make this feature almost useless. You might think that this is an edge case and that most functions are/can be made to be pure. And indeed many library functions can be made to be pure and work with a new array type. But every useful program interacts with IO and often it's at the very beginning, so the entire program after that will lose the length checking. As mentioned in another comment here, a lot of the examples you give can be solved with const contexts - since you create the array. If you just do simple array operations then the tuple will be preserved. But to do anything complex you'll need libraries to start working with you and that will probably just not happen anytime soon.
Thanks for the tips! I installed typescript@next to try out the `const` feature and it seems to work great! Indeed, I remember reading the reason for why Array's were not length checked which makes sense to me but I thought that it would be nice if there was the possibility to give hints to the compiler that an object can't be mutated (like `const` does now or like `Object.freeze`). I think in your example you meant to remove the `KeysOfPerson` type annotation in front. I'm surprised that using constant string literals is easier for the compiler and thus safer than an explicit list keys of that type!
&gt; I think in your example you meant to remove the `KeysOfPerson` type annotation in front. Oops, you're correct. I'll fix it.
Always use semicolons;
We rely on Automatic Semicolon Insertion to do its job for us. Team made up of mixed people with feelings about that choice, but we got used to it. We also use tabs instead of spaces for indentation, but nobody complains. These and semicolons will get lost/recovered during transpilation anyway.
I found this while looking for a way to throttle an async/await call. I didn't like the available libraries so I just modified an example. Here's what I got, in case anyone else is interested. function throttle&lt;T extends (...args: any[]) =&gt; any&gt;(time: number, func: T): (...funcArgs: Parameters&lt;T&gt;) =&gt; Promise&lt;ReturnType&lt;T&gt;&gt; { let timeout: Timeout; return (...args: Parameters&lt;T&gt;): Promise&lt;ReturnType&lt;T&gt;&gt; =&gt; new Promise((resolve) =&gt; { clearTimeout(timeout); timeout = setTimeout(() =&gt; { resolve(func(...args)); }, time) }); } How to use: Assume `doStuff` is your function which you call as such: const result = await doStuff(your, params, here); Now you can do this: const doStuffThrottled = throttle(400, doStuff); // and elsewhere in code const result = await doStuffThrottled(your, params, here); That's it. Useful in case you're working on a search box and you don't want a call to go out on every key. Now it waits 400ms before sending the call with the last value.
What you implemented is more commonly called debouncing, not throttling since if you keep making calls it will never execute the function until 400ms has passed since the last call. 
This site steals content and rehosts it, basically. At least they credit, but still scummy af.
Prettier is even better for this.
No semis for me if I get to choose. But also I don't care particularly.
I just released [ts-auto-guard](https://github.com/usabilityhub/ts-auto-guard) which may satisfy your needs. Let me know if it helps or why not. I'd love some feedback.
`interface` is TypeScript is for data! If the object is data (e.g. created by `JSON.parse`, coming from a database, etc.) then you declare its type with an `interface`. That way no unnecessary code is generated (every `class` statement will result in a class being generated, even if it has no methods and the constructor is never called).
`use throw` is only cleaner because you've made a mistake: you aren't checking to see if the error originated from your branches or from the underlying database lookup. Integrity errors that should report as `500` will now look like authentication failures. With those checks it isn't really going to be cleaner that the second version, except it's also going to have an unnecessary `try catch`, making it appear like there's actual error handling going on there when there isn't, just normal control flow. The second version is perfectly testable as is. I have no idea why you've broken it down further.
1. Declare your other type (`{ field, operator, value }`) as an `interface`. 2. Use the `in` operator to determine which type the rule is. interface Clause { field: string; operator: string; value: string; } export interface Query { condition: string; clauses: (Clause | Query)[]; } let query: Query; for (let r of query.clauses) { if ('condition' in r) { console.log(r.condition); } else { console.log(r.value); } } 
Could you provide some relevant examples where you've used this in a real world use case? The debouncing idea is a nice one, just wondering if you've used it for anything else as I'm struggling to come up with ideas
Thanks, will edit the comment to reflect that.
The original example in the OP lists measuring execution time. Another example I can think of is logging. Another use I'd apply it to (someone please correct me if this is an anti-pattern) is having custom error handlers. e.g. if the *wrapped* function throws an Error, have the *wrapping* function do a side-effect based on the Error (show a notification on screen, redirect the user to a `/login` page etc.), without having to implement this functionality in either the original function or the one that calls it.
this is a reimplementation of https://www.reddit.com/r/typescript/comments/6b38ij/barrelsby_automatic_barrels_indexts_files_for/ - but it generates barrel files at each directory level instead of a single file for the entire directory tree. also has comments and watch mode.
Oh, that's neat. Making `index` files are quite tedious. What happens if an `index` file already exists, since it seems to update as you change files? Does it only touch files that have that pragma at the top?
Yes, especially if you hook it up to a commit hook or a build process.
The thing about semi-colons is, well, it's [super easy to have an opinion on it](https://en.wikipedia.org/wiki/Law_of_triviality). People who might not participate otherwise can sure have an opinion on something that's easy to have an opinion about, unfortunately.
Might as well ask if we use tabs or spaces next, or how we space our parens. It doesn't matter. Just be consistent, use an auto-formatter, and stop worrying about it.
Nice work, but does anyone find the barreling pattern itself to be kind of useless? It feels like an arbitrary grouping of files. If my codebase is in TypeScript, I'll just import the thing I want, not a bucket of modules that happens to contain the thing I want.
I didnâ€™t know these things had a name
right now i make it throw so basically i force you to not have any manually maintained index files anywhere in the tracked directory or else barrel bot doesnt work. im considering a few ways to handle this. one is have a â€œignoreâ€ pragma at the top for manually created index files. another is modifying the script so it keeps any custom code you may have below a â€œbarrel blockâ€. but that to me seems more complex than just having a blanket â€œno manual index files for youâ€ rule throughout the project. idk. is that too strict a rule you think?
I find it more useful for letting the consumer not need to know about implementation details. For example, if I have a component, I could have a whole heck of a lot of files depending on what library I'm using and how I'm organizing things: components/ input/ input.component.ts input.spec.ts input.readme.md input.styles.less input.constants.json input.view.html However, I can put an index file: components/ input/ index.ts And now I can completely not care about how complicated or simple the implementation is. I just import `components/input` and I'm good to go.
Well, a very obvious place that would be a problem for me is if I had say a components folder: components/ input/ header/ ... index.ts The index file probably looks something like: export { default as Input } from './input'; export { default as Header } from './header'; Which doesn't look like the auto-gen code barrelbot gens out. There isn't really a good answer for this, I don't think. A per-file pragma is probably not something you want to liter your codebase with and I'd be even more iffy about some sort of configuration file. Maybe all or nothing is the only way, but maybe it could just ignore a file if it seems it has been modified outside of barrelbot, assuming that's being manually maintained for now. Maybe it would be best just to use it to gen out the index files once to get the boilerplate out of the way and not bother with the watch mode at all. Idk. ðŸ¤·â€â™€ï¸
See golang. folders should be auto exported under a module/namespace
i mean i think i want the watch mode. otherwise u can just use barrelsby. the ignoring and export namespacing are good ideas. i got this feedback from a couple people on twitter too. iâ€™ll play around with the idea, cheers
this reminds me i should ignore anything with two dots for tests and stories and such
Wow, I was JUST wishing for something like this.
Nice! Are there any options to re-export as a namespace instead: import * as foo from './foo'; export {foo};
yea i can work that in. seems a popular request.
But you should/could not be importing from any but the first file there anyway, right?
I've been using barrelsby in the past but found myself fighting against the tool more often than being helped by it. It would be nice if there was a way to differentiate between internal exports (e.g. only used within the same subdirectory) and global exports (should be usable anywhere in the application). Just indiscriminately re-exporting everything wasn't really that useful. It also pollutes the repository, increasing the number of files and making it just a bit more difficult to find the location of a particular piece of code. YMMV, of course, but this was not for me. 
With a module loader any one of those could be imported. But the point more is that I'd rather import `components/input` instead of `components/input/name.of.the.component.implementation.ts`.
just made it https://github.com/sw-yx/barrelbot#option---namespace-none-all-defaultonly
hows this look for the default exports? https://github.com/sw-yx/barrelbot#option---namespace-none-all-defaultonly
hmm. use some kind of naming convention? can you flesh out the internal vs global idea a bit more? i can build it
dont let your dreams be dreams
they do and theyre awesome
Hi I'm quite new to typescript, and I am quite confused about the '--isolatedModules' flag. Is that recommended for performance? And if so, wouldn't barrel files break transpiling when isolatedModules flag is set?
ive never even heard of isolated modules before today! lol. well lets brainstorm how this might work. maybe its not suitable with isolatedmodules.
I think it speeds up jest tests but other than that Iâ€™m not sure what is the benefit of the flag. I just see my colleague use it in the tsconfig. Maybe thereâ€™s no need to be compatible with that flag.
Iâ€˜m wandering how to get the exact \`38%\`. How to analyze itï¼Ÿ
do you really write input.component.ts? why not input.tsx? unless youre using angular i guess?
alright ill ignore it for now but thanks for bringing it up
I was thinking about something like Go's [internal packages](https://golang.org/doc/go1.4#internalpackages). Lets say I'm building a download manager. I'm starting with a file `downloadManager.ts` which exports a `downloadFile` function. Later, when my code growth, I want to split up the code into more files, so without barrelbot, I would normally create this folder structure: ``` downloadManager | index.ts // mostly the same as the previous downloadManager.ts | queue.ts // contains some code extracted from downloadManager.ts ``` All I needed to do was to create a folder, move the old file there and rename it to index.ts, then imports in the rest of my code won't change. Maybe I was using some internal function `enqueueFileDownload`, which have previously been non-exported functions within the `downloadManager.ts`. Since I am extracting them into their own file, they must now be exported. But this means that they can now be imported everywhere in my application, which I don't like. Obviously, this cannot be fully prevented by this tool, but it can be made more obvious by using the 'internal' name: ``` downloadManager | index.ts // created by barrelbot | downloadManager.ts // previous file | internal | | index.ts // created by barrelbot | | queue.ts ``` Now in downloadManager.ts I have `import { enqueueFileDownload } from './internal'`, which looks ok. If I would find myself importing the function anywhere else in the application, I could see immediately that it is internal to the downloadManager. Of course, the downloadManager/index.ts must not re-export anything from internal/index.ts. 
Conditional types are awesome!
You can try out my tool [ts-auto-guard](https://github.com/usabilityhub/ts-auto-guard). It generates type guards from your interface definitions and can log when fields fail. I found a surprising number of type mismatches when I started using it on an existing project.
I added `Symbol.iterator` on `IntanceTypes` so array destructing could work. type InstanceTypes&lt;T extends Constructor[]&gt; = { [P in keyof T]: T[P] extends Constructor ? InstanceType&lt;T[P]&gt; : never } &amp; { [Symbol.iterator]: any; // destructing works now. }; &amp;#x200B;
Is this an actual software product that benefits a client, or just more â€œadvanced way to use a crayonâ€ noise on the internet?
Unemployed developers really scrape the barrel for things to blog about.
The client wants rapid application prototyping, the client gets rapid application prototyping. Especially if the developer isn't neck-deep in boilerplate and can quickly iterate on designs. This helps a lot.
I have no idea what Deno is, and it doesnâ€™t help that the Readme just links to a website that requires you to click more links to get any idea of what this project even is.
TypeScript runtime. Think ts-node but without the transpile step.
That would indeed be a good addition to the README. For others running into this problem, here's the link to its introduction: https://deno.land/manual.html#introduction It's basically [Node's original creator fixing what he sees as Node's fundamental problems](https://tinyclouds.org/jsconf2018.pdf). (Including TypeScript support.)
My code twin! Doesn't it shit you that you can't access modules from the debugger and that calls from the debugger use "this" differently than the code inside modules?
Yep, flip one or the other, couldn't give less of a shit. Each to their own, as long as it's auto-formattable.
If you don't know already, it's not something you will care about yet (for a year or so?)
Wow you're totally right, that is the absolute worst readme I've ever seen. Can't we all just agree that source code and docs should be self contained and in the same repo for open source projects?
haha yeah but i guess ryan dahl gets a little bit of a pass...
Deno is node with modern tools with less regrets. 
Actually deno transpiles typescript to JavaScript before running it, so its basically ts-node
Not really :-) https://jaxenter.com/ryan-dahl-fixing-node-deno-146190.html
This is a 0.3 release- usually docs come later ;-)
That article states that deno is written in Go, which itâ€™s actually written in Rust. Deno also still uses the v8 engine which doesnâ€™t understand typescript so there has to be a transpile step some where. Also hereâ€™s the code that is used to compile your typescript into JavaScript:[denoland/deno/is/compiler.te](https://github.com/denoland/deno/blob/master/js/compiler.ts) 
I was referring to the ts-node part- thatâ€™s an oversimplification and gives the wrong impression... it goes much further than ts-node by dropping some of the bad stuff :-)
&gt; That article states that deno is written in Go, which itâ€™s actually written in Rust. To be fair, it was [initially written in Go](https://github.com/denoland/deno/blob/900dd6fa42cf841e82c564ac684f254b548d7e9e/Roadmap.md#milestone-1-rust-rewrite--v8-snapshot), but they rewrote it in Rust for GC reasons: &gt; Go is a garbage collected language and we are worried that combining it with V8's GC will lead to difficult contention problems down the road.
I just wish he would also realise that ES imports are as bad as require(). Devs need a proper packaging/class-path system, like in Java.
Even though their approach to dependencies is a bit shabby
On the surface, I like what youâ€™re trying to do. But a couple of things caught my eye. A compromise: allow networking isnâ€™t required to download remote imports. This seems like a pretty big gap. I think you should stick to your guns there and without the network flag, through an error on remote url imports. Now, an additional flag to allow network imports might be a good compromise, or more fine grained control of allowed sources, or some sort of signing support. Without that, your security model is pretty much out the window. I realize you want to avoid the NPM coupling, but defining the expected secure dependency model is key. An opinion: fail as soon as a promise is unhandled. If that means that ignoring a returned promise will immediately throw an exception. I disagree. Fire and forget is a reasonable pattern, and widely used. This is more of a linter/style choice. What are you personally using as a tool chain? Import intelligence is pretty central to my development experience these days. If my IDE is resolving my dependencies differently than deno is, then Iâ€™m probably not going to pick it up. This doesnâ€™t mean you need to fix this or provide IDE plugins, but it would be nice to know how youâ€™re working around it, and to have the expectation set, and maybe have it called out to the community as a â€œwantedâ€ item. Since dependency resolution, file system/network access, and deployment seem to be areas you are focusing/touching on, have you considered supporting an archive/bundle format? Steeling from the java world here. Itâ€™s one of those features I think is pretty key for portability. This also ties into Javaâ€™s file system abstraction, which I think is design pattern worth exploring here. What if, instead if failing (which I assume is what currently happens) when file/network access is blocked, you simply provide in memory default implementations which donâ€™t actually access the disk/network. And then exposing these abstractions as extension points will hugely expand the power for community extensions to your security and dependency models.
My IDE / TSLint setup highlights when they're missing, so I add them.
Came here to write exactly this. If your call results in an `Either` (or an object with fields `errors` and `data), you never have to even think about doing something special to deal with errors. Overnight, the experience of working with the API will change.
Yep. It comes from Golang. But Golang solved its package management problem with modules. I am sure something will come to solve this. Currently they do something similar. Lets see what comes.
I don't use them, I use prettier in a husky hook, along with prettier on save to enforce the lack of them
I like where the TS ecosystem is heading. Perhaps soon we will have a merge of TS with JS itself like mentioned in the article. It's embarrassing how a widely-used language like JS has no support for static typing in 2019.
1. It is under discussion (potentially we will add a flag to disallow remote dependency fetching). The basic idea is that in production, after the initial dependency pull (using \`--prefetch\` flag that pulls deps and compiles the code without running), the deps folder should be carried around (using \`DENO\_DIR\` to tell Deno about its location) and every subsequent run should use this disallow remote fetching flag. Also the current security model is indeed pretty coarse-grained, and pending revision given well-formed proposals. 2. Currently, the unhandled promise rejection would only cause the program to exit when control is returned to the event loop. There is not a lot of discussion about this yet, so feel free to submit an issue on your idea! 3. [https://github.com/kitsonk/deno\_ls\_plugin](https://github.com/kitsonk/deno_ls_plugin) helps a little bit (also \`deno --types &gt; deno.d.ts\` and put it in \`typings/\` folder provides Deno API types. The problem that needs to be taken care of is remote imports, and we need to explicitly tell in the config file about the cached deps location. Full IDE support is indeed wanted but is yet to be done. 4. [https://github.com/denoland/deno\_std/issues/116](https://github.com/denoland/deno_std/issues/116) for bundling. In-memory defaults sound interesting, though we might need to clarify some details of its implementation. I'm forwarding this idea to Ryan. Feel free to join [https://gitter.im/denolife/Lobby](https://gitter.im/denolife/Lobby) (official gitter chatroom) to voice your ideas!
Sorry about not providing enough info in the post. As to README, Ryan recently moved everything to the website... which might not be the best idea...
For extensive documentation, an external site is fine (see react/webpack/Typescript/etc.). But the README should, at a bare minimum, have an elevator pitch of what the project is even about.
Ryan wants the simplest and most web-compatible solutions at this moment. Since we have seen stuff like [https://github.com/WICG/import-maps](https://github.com/WICG/import-maps) , more import mechanisms might be added in the future.
C# programmers kind of chuckle at Jsript.
Amazing, but how that has anything to do with typescript?
nothing at all
it's even better if we have native compiler and native browser support so we can leave javascript completely 
Typescript programmers chuckle at c# developers ðŸ˜‚
How so? They're very different languages but I always miss the expressiveness and flexibility of TypeScript when I work in C#.
Piss off Chris
So, I use Typescript and it's certainly better than plain Javascript, but damn, do people actually really love it? People used to give C++ shit for template hell, but honestly, it's nothing compared to what I've experienced with Typescript. Integrate a new library with less than perfect typings? Either toss any's around like there's no tomorrow or spend an hour trying to figure out the right incantation of type annotations to make the incomprehensible errors go away.
Do you know which sub you posted this to?
Why?
Flexibility to create super buggy software. I hate inferred typing.
Because it is a lot better to structure your code in package than in files. Packages can be abstracted to files, archives, dependency managers or whatever.
Why are you here?
I think that won't happen, probably in the future we'll see TS being compiled into webassembly. 
Don't use inferred typing then. It's a choice.
What the fuck? C# has the "object" datatype, which is just as sinful as "any" in Typescript. This is a really strange high horse you've chosen. 
I think you'd see more balance among JS users. TypeScript seems to have more people coming from C# and typed languages that require semis. Also all the official docs use semis, whereas JS has no single official documentation site.
Publish it to DefinitelyTyped if it's an npm lib.
You don't need `expectNever`. TS will already enforce this when strict null checks are enabled.
Writing type definitions myself is just as easy as reading the library's documentation and taking notes. Yes, I love typescript. Was never a fan of javascript before, nor were I any good at it. But using TS has improved my JS skills, and forced me to learn about the whole post-es5 javascript developing ecosystem (npm and node, bundlers and transpilers, etc) which I knew barely anything about earlier.
that's even better
See this talk where the creator of Node ends up introducing Deno: [10 Things I Regret About Node.js - Ryan Dahl - JSConf EU 2018](https://www.youtube.com/watch?v=M3BM9TB-8yA)
Stop spamming that bullshit of the degenerate Kelsey.
Yes. To **all** of them. Kelsey is frequently spamming various sub-reddits with his coinshit.
Thanks I just got around to trying this and I believe it will work. Thanks again! 
&gt; less regrets. So far. 
I use TypeScript every day, and quite like it. But, do we not all sort of know it's time is limited? Even if JavaScript is never strongly typed, it will get classes, modules, arrow functions, etc. I would gladly give up typing for no transpilation. It is a stop-gap technology. The point being, why would you start a whole new ecosystem based on TS, as if JS was the problem, just as JS is becoming as good as TS?
I use Material-UI, which utilizes JSS (CSS-in-JS). It was a little wonky to get it working with Typescript initially, but not so bad now that I'm used to it. Details below. &amp;#x200B; // First do your imports - no mistake, you need a lowercase and uppercase withStyles import { withStyles, WithStyles, createStyles, Theme } from '@material-ui/core'; &amp;#x200B; // Next define your styles const styles = (theme: Theme) =&gt; createStyles({ someStyle: { backgroundColor: '#f00' } }); &amp;#x200B; // You need to pass the classes object in with your props (will use a blank interface for this example interface IProps extends WithStyles&lt;typeof styles&gt; {} &amp;#x200B; // When exporting your component, you must still wrap with withStyles export default withStyles(styles)(YourComponent); &amp;#x200B; With all that done, you can use props.classes like material-ui describes in the docs. For the example above, props.classes.someStyle would be the only available class.
Thanks for this. I was a little lost on use cases for conditional type, and why people put never in some of the conditionals. This example cleared up my confusion. Great article. 
Dojo provides typesafe css modules using CSS Modules. Tutorial link: [https://dojo.io/tutorials/003\_creating\_widgets/](https://dojo.io/tutorials/003_creating_widgets/) 
How do [dynamic values](https://cssinjs.org/react-jss?v=v10.0.0-alpha.10#dynamic-values) fit into this? My biggest issue with styled-components in TS is doing things like this: ```ts const Box = styled('button')&lt;{color: string}&gt;` background-color: ${props =&gt; props.color}; `; ``` This example doesn't work because styled-components doesn't infer the type of the `props` in the interpolated function, so I get TS errors about `props` being of type `any`. The only solutions I've found involve declaring custom prop interfaces like this (which isn't ideal): ```ts interface BoxProps { color: string } const Box = styled('button')&lt;BoxProps&gt;` background-color: ${(props: BoxProps) =&gt; props.color}; `; ``` This mostly works, but if I tried accessing some valid `button` props ( `hidden`, `disabled`, etc.) it would fail to compile.
I may be misunderstanding, but when I need dynamic values, I just apply them inline in the style property of any JSX element. If I have a class I want to apply dynamically, you can do that via the classNames prop and a logic check on which class to apply!
Those solutions do work, but JSS and styled-components both support adding inline functions to your styles: ```js const styles = { myButton: { padding: props =&gt; props.spacing }, myLabel: props =&gt; ({ display: 'block', color: props.labelColor, fontWeight: props.fontWeight, fontStyle: props.fontStyle }) } ``` I use this feature heavily because I find it much more straightforward than trying to map my component state to a bunch of classnames. Inline styles work most of the time, but they also cause your styles to be split between the style definition and the markup. Inline styles also don't support pseudo-classes or the `&amp;` operator, so dynamic styles in `:hover`, `:before`, `:after`, etc. become difficult.
This is how you pass props to a styled component, it's pretty straightforward: interface TopbarContainerProps { display: string; } styled.div&lt;Props&gt;` color: black; display: ${props =&gt; props.display}; ` as of "styled-components": "^4.1.3" this is working. 
Not according to what I'm seeing. VS Code is telling me `Parameter 'props' implicitly has an 'any' type.ts(7006)` with this code: ```ts const Root = styled.div&lt;{background: string}&gt;` background-color: ${props =&gt; props.background}; `; ``` With `"styled-components": "^4.1.3"` and `"@types/styled-components": "^4.1.10"`.
I have strict and noImplicitAny set to true and it works for me.
This boils down to a discussion in some degree similar to "If we already have C++ and it is getting better, why developing Rust?" argument. I guess people all have their own opinions of how things should be improved. Also, technologies migrate in the direction that we can hardly tell, just like hardly ever imagined how the toy-ish JS language would become a beast it is today before AJAX. I don't think there is necessarily a right/wrong direction here. It is more like preferred/not preferred by developers and in the end only time can tell. On the other hand, Deno also supports JS (no strong typing and without transpilation, as you preferred), and you can understand that the TS part is more or less on top of the JS (which means ease of use in pure JS is a must and a project goal)
That requires TypeScript 2.9 or later AFAIK. Which version are you using?
That must be it, i'm using "typescript": "3.3.3".
I still don't get it :(
Any chance I could see your tsconfig?
I'm using `"typescript": "^3.3.3"`
Feel free to reach out to me via email or comments if you have some specific questions - I'd gladly help.
FYI, here's the talk Abstract In 2014, I made a strong argument that TypeScript was destined to be irrelevant and that my company should not use it in any of our projects. Fast forward to 2018 and we use TypeScript for, like, everything we build at Progress, and I am no longer a source of trustworthy information. In this talk weâ€™ll discuss why I was wrong. Specifically, weâ€™ll talk a look at why TypeScript succeeded where other compile-to-JavaScript languages like CoffeeScript and Dart have languished, and what that means for future of the technology. Come to learn the basics of TypeScript, and whether TypeScript is a good fit for your next project.
I had a similar attitude about typescript until I used it. I thought flow was better, and was extremely wrong. 
That's interesting to learn! I've never used functions in my styles, but I may give it a shot to see how it works. Unfortunately, that also means that I cannot shed any additional insight for you. 
 { "compilerOptions": { "target": "esnext", "module": "esnext", "jsx": "preserve", "lib": ["dom", "es2017"], "moduleResolution": "node", "allowJs": true, "noEmit": true, "allowSyntheticDefaultImports": true, "skipLibCheck": true, "noUnusedLocals": true, "noUnusedParameters": true, "removeComments": true, "preserveConstEnums": true, "sourceMap": true, "noImplicitAny": true, "strict": true } } 
 { "compilerOptions": { "target": "esnext", "module": "esnext", "jsx": "preserve", "lib": ["dom", "es2017"], "moduleResolution": "node", "allowJs": true, "noEmit": true, "allowSyntheticDefaultImports": true, "skipLibCheck": true, "noUnusedLocals": true, "noUnusedParameters": true, "removeComments": true, "preserveConstEnums": true, "sourceMap": true, "noImplicitAny": true, "strict": true } }
Because Microsoft backing.
It has been a long learning curve for me but I think very worth it. I used to do C# years ago, then switched to JS for web and ObjectiveC to Swift for IOS apps. I then wrote a couple of apps in JS/Cordova before a few year break. Coming back now to Typescript took a bit of getting used to, but Iâ€™m loving the fact that I catch a lot of things at coding type thanks to real-time compiling and Linting. It is a different world than the JS of old, and I think worth the effort to learn. C-&gt;C++-&gt;C#-&gt;JS-&gt;ObjC-&gt;Swift-&gt;Typescript. 
Dart had Google backing. Typescript is just a really good product. 
Thanks! Turns out the problem I was having was caused by not having this line: ``` "moduleResolution": "node", ```
"preventable" eh. I bet most were preventable without TS, too.
I realize you expressed a distaste for jsdoc comments, but this was the closest I could come up with for what you were looking for: In add.d.ts I switched it from a global declaration to an export: export function add(x: number, y: number): number; And then in add.js I did this: // @ts-check /** @type {import("./add").add} */ function add(x, y) { return x + y; } Which seems to have the effect you're looking for, VS Code knows x and y are supposed to be numbers within the function itself, and if I try to call add later on in the file it shows me it's expecting numbers and gives me an error if I provide anything non-numeric.
If you don't mind me asking, why are you trying to avoid the compile step?
Disclaimer: author I went in and really hoped Babel would fit all of our needs (and maybe even be a little faster?) I already knew about the const enums, but I was a little sad to lear about the decorators not being properly available.
&gt; We can use JSDoc annotations [...] but they make the code somewhat ugly What?! Ugly? Having comments explaining what the function is supposed to do, what the code is supposed to take, and what one is expected to get back, that is a thing of beauty. And being able to hover over a method to read without having to F12 to the code, that is grand. Being able to use a tool to export all those jsdoc comments into a single library documentation web-page makes it damn easy for others to start using your library. And jsdoc comments makes it really easy for typescript users to write definition files for a js-only library. Whenever I see some properly jsdoc'ed code (or xml-doc'ed code in C#), I want to hug that developer. Have you tried changing your jsdoc syntax color? Maybe thats the issue? I have noticed some syntax color theme often turn comments into gray, cursive, barely readable blocks. I usually keep them easily readable and green-colored. But thats just my opinion.
np, i'm glad it worked out.
&gt; and I am no longer a source of trustworthy information I hope that's tongue-in-cheek
As someone who has never used Flow, I've always wondered what the major differences are. What does TypeScript do that makes it better than Flow?
Dropbox replaced their client side code with Coffeescript in 2012, and Dart came out in 2011. I don't think it was a foreign concept in 2014 to most front end devs.
I'm just going to pat myself on the back for rewriting a bunch of Coffeescript into Typescript in late 2013. I had recently inherited a Coffeescript codebase and besides the ?. operator that is super useful for JSON-like data, it was terrible experience where my coworker and I got bit multiple times by the fact that Coffeescript did not support the ternary operator, and would emit some complete garbage, resulting in very confusing bugs. We did look at Dart at the time, but for our purposes needed to be closer to the JavaScript VM than (transpiled) Dart. I will admit that despite thinking it was the right approach, I have been quite surprised by the popularity of Typescript.
It responds with errors in less than 30 seconds, for one 
I was a fanboy of Typescript from Day 1. The reason was that I was, in a previous life, a Flash/Actionscript developer. Actionscript was essentially ECMAscript 4, an abandoned spec... which bears a striking resemblance to the nascent Typescript language. Of course, now Typescript has advanced WAY beyond what Actionscript ever was. But for me, it was a return to sanity after being cast into the dynamically typed, hack filled world of legacy Javascript.
I guess if you really need/want your enums to have string values. &amp;#x200B; Why not &amp;#x200B; enum Colors { red, blue, yellow }
OP is talking about putting all the type information into the comments instead of using TypeScript's native syntax. \`/\*\* Description \*/ let foo: string;\` is less ugly than \`/\*\* @type {string} Description \*/let foo;\` See the difference? I don't think anyone is saying to abolish JSDoc.
You cannot do what you're proposing. When *other* files try to import stuff from add.js, the editor will use add.d.ts to give them type information. But from *within* add.js, the editor will not look at add.d.ts. Have you looked at ts-node?
I got on the bandwagon by looking at what Angular was all about, trying to pick up TypeScript as a result, then realising I loved TypeScript but hated Angular. It's now unthinkable to write JavaScript in any other way.
How about this trick? It eliminates the need for Proxies and lets you enumerate the enumerated keys at runtime. function Enum&lt;T extends keyof any&gt;(...ids: Array&lt;T&gt;): { [id in T]: id } { return Object.assign({}, ...ids.map(id =&gt; ({[id]: id}))); } const Colors = Enum("red", "blue", "yellow"); &amp;#x200B;
&gt; my coworker and I got bit multiple times by the fact that Coffeescript did not support the ternary operator Mmmm? variable = if something then value else something_else compiles to var variable; variable = something ? value : something_else; Most statements are valid expressions in coffeescript. I never really got all the hate for it, but it makes more sense when I see comments like this where people just inherit a probably ancient code base written in it. I remain, though, it was pretty nice to have all the ES6 syntax sugar stuff back in '09 and '10.
They are mostly compatible.
Both of those works, but as a typescript and c# dev i rarely type or document single variables. Let the compiler infer those (and a good variable name is good enough for the human reader). The important parts to type (and describe) is methods and functions, both input and output. OP is suggesting to use js, but put type declarations in a separate file. Because he wants the good parts of ts without having to run a compiler, but dont want to use jsdoc. He didnt specify what part of jsdoc he thought was ugly. Was hoping he'd say more about to why he dislikes it so much that he'd rather maintain an entire separate file just for type declarations. ðŸ¤” But having a separate declaration file for complicated types (or interfaces) that takes multiple lines to describe I can understand, so his way might have some use. ðŸ‘
I also want the \`enum { red = "red", blue = "blue", yellow = "yellow" }\` part, but it's kinda repetitive
Yeah, that's even better, thanks for the code. Nice trick there with Object.assign and .map
I can add my two cents. I used to convert a \~30k codebase from flow to TS, with around \~3k lines of changes. So mostly compatible. \- Flow has too many magic going on, all these \`$Class, $Keys\` and so on \- Flow's eco-system is much weaker compared to TS, a lot of libraries has .d.ts but not flow type annotation \- Flow doesn't support two things I asked for (one year ago): specifying generic type argument on callsite (already implemented), and abstract member initialization check \- Flow is implemented in Ocaml, unlike TS, which is bootstrapped using TS itself. Not necessarily a drawback, but shows TS has one more solid usecase - the compiler itself \- TS has more advanced type system (especially after 2.8 with conditional type). One evidence is that TS supports React type definition as a library, while flow has logic inside the compiler to special case React (which results in, when a new version of React releases, we'll have to wait the flow compiler to catch up). To be fair, one thing flow supports is generic variance, while in TS, everything is bivariance unless in some specific cases. Not a super big issue The main issue is rooted on the maintainer of these two projects: FB is a very impact driven company, developing/improving flow makes no impact. So it's very hard for Flow to really improve. MS apparently doesn't care about that and TS has basically one of the best dev team in the world, hence the difference should not be a surprise.
The extra complexity this introduces is not worth the characters that it saves. If you're using an advanced IDE like VS Code or Webstorm, you can just use the multiple cursor feature to type both sides of the enum simultaneously. Or even better, make a Live Template to save keystrokes and apply the correct capitalization. As an aside, a useful feature of enums that I discovered recently is `const enums`. With these, instead of outputting an enum object, the compiler inlines the enum value wherever it is used. 
As soon as he said Dart was obviously unsuccessful, I was done listening. I'm sorry, I like Typescript, but Don't is a great language and it isn't done.
It's the other way around. If you try to write the ternary operator, the compiler won't complain, but it will generate some nonsense.
idk I hate dart or its just because flutter
Disagree. But it was a good article. Called out the important points and got things right. Just I just came to different conclusions.
This will error on `ReadonlyArray` as input I believe.
Compiler differences aside, I think this choice ultimately comes down to your build setup. If your using webpack, nextjs, rollup, or something else! I agree that build tooling for the JS ecosystem leaves a lot to the imagination right now.
"If you need some of the custom transformations that only Babel provides, the best build pipeline is still to pass the TypeScript files to the TypeScript compiler and then to Babel afterwards." This the reason I use Babel with TS. Otherwise you need increase the complexity and compile times a lot. The tradeoffs are well worth it. Also babel-preset-env is cool. 
I am using babel and Inversify I'm just not using decorators instead going for composition little bit overhead in writing but when they finally decide how should decorators work I won't have to rewrite everything... In general, articles hits all those issues that I had with choosing between them but you can have your own conclusion when fighting with those issues.
Yes, this is what I meant from ugly part of JSDoc. Should've mentioned. Not abolishing comments or JSDoc anyway.
- It saves time. We can have a faster feedback in browser or while running tests. Otherwise, there is always a delay due to build. Less time in configuration too (although it's a one time work). Also the CPU cycles, which we don't generally care about. - Keeping two versions of files - src and build - with only difference being type annotations removed. This is more important when we're adding a compile step just for type checking. Why we would like to add a compile step if we can do the above without it?
The thing I appreciate the most about Babel+TypeScript is the ability to compile in Babel VERY quickly without waiting for the type compilation of the whole project everytime. &amp;#x200B; It allows me to iterate minor changes really quickly and when I do check logic, I use a dedicated "Build" hotkey and wait for a longer time.
Good summary of the limitations. While I think making TypeScript easier to adopt is great, I'm not convinced a gimped compiler in Babel was the right approach, because it's going to be the option many client-side projects default to. After years of doing Webpack configurations, I welcomed things like create-react-app with open arms, because it just works out of the box without ejecting for vast majority of the applications I developed, while providing good developer experience and documentation. When me and my team decided to switch to TypeScript, I saw [wmonk/create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript) as a pretty natural fit, being a fork of CRA, just putting TypeScript compiler in front and using TSLint instead of ESLint. When the Babel TS support landed and CRA started using it for TypeScript support, the forked project was (understandably) deprecated, with a guide for migrating back to the original project. While the migration wasn't *that* big of a deal, it did leave a bit of a sour taste in my mouth. The drawbacks aren't great enough for me to eject and customize the build process for multiple projects, but I feel like Babel TypeScript was a shortcut that compromised some of the language just for easier fit into existing tools. In all likelihood TSLint is also at some point being deprecated in favor of ESLint to bring the TS/JS ecosystems closer together, but I really hope we don't see the same trend of compromising features just so it fits better in the current implementation of JS-oriented tools.
Google is making dart relevant again for flutter development
But it gives you the flexibility to have the runtime representation and your name in code to be separate. An edge case, but still worth mentioning.
You'd need to expand on it a bit to get the actual type, e.g.: type Enum&lt;T&gt; = { [P in keyof T]: P }[keyof T]; type Color = Enum&lt;typeof Colors&gt;; function doColorfulStuff(color: Color) { } 
Also mentioning here. To get a type representing your colors you can use a mapped type: type Enum&lt;T&gt; = { [P in keyof T]: P }[keyof T]; type Color = Enum&lt;typeof Colors&gt; function doColorfulStuff(color: Color) { }
I believe an article by the TSLint team was posted this week that actually stated they would be working with ESLint to build feature parity, then provide an upgrade path and deprecate TSLint. I'm on mobile but I'll update when I find the article.
What is your db engine?
How is running `tsc` complicating a build? 
That's good news
PostgreSQL
That's because `?` is a different operator. As you noted earlier, it's quite useful and checks for something not being `null`/`undefined`. That doesn't mean the language doesn't support the ternary though. It just has different syntax.
Why does this read like a parody?
This site is designed awfully. Where is the article? Itâ€™s just a bunch of links and a single sentence that matches the title of the OP. 
&gt; How do you efficiently add types to constructors and prototypes like this: You don't. It's not really supported due to the complexity. &gt; Decorators still don't have a stable spec, and my impression is the current spec is going to be scrapped yet again. It's unlikely to change a lot at least. I doubt it will be just scrapped. &gt; Current experimental support for decorators in TypeScript is pretty bad. How so? Can you provide an example? Only thing I can think of is that decorators can not augment type information of classes. Otherwise they work without an issue, support is good and a lot of frameworks built upon them.
You could write and interface for the Person type, then you can use that to apply to the `this` argument of your functions etc. `prototype.myFn(this: Person, arg: String)`. 
How about this? target: "es5" so the class declaration compiles down to what you want. You have to declare `this: Foo` on all methods, but since they're declared as an object literal, you can build it however you want. type Methods = typeof Methods; interface Foo extends Methods {} class Foo { constructor() { this.field = 'hello world'; } field!: string; } const Methods = { methodOne(this: Foo) { return this.field; } } Object.assign(Foo.prototype, Methods); const foo = new Foo(); foo.methodOne(); [https://typescript-play.js.org/?target=1#code/C4TwDgpgBAshwAsD2ATAzlAvFUkkDNZ5l0BuAKAEsA7YCAJ3wEMBjaAMSSSggA87q6IolQYA3gF9yLADZM0GTtzHkoaqCyTU0wegFcWwJPQAUASigr11nAkpoAdPkoQZKLFADkCVzO4B3YzdPCmspa2dXFABCAC4oHXoaAHMKKU1tYGESDGwrdQBbYlQAeWoIE0R7eKULfJsoeng9empbeycXN1D1KSkSgCMAKwhDB3k0SmTqEyUHMHokI1wIABps0TMKaS0dKHwuD3L-KCVzCgOkByKRFDKKraA](https://typescript-play.js.org/?target=1#code/C4TwDgpgBAshwAsD2ATAzlAvFUkkDNZ5l0BuAKAEsA7YCAJ3wEMBjaAMSSSggA87q6IolQYA3gF9yLADZM0GTtzHkoaqCyTU0wegFcWwJPQAUASigr11nAkpoAdPkoQZKLFADkCVzO4B3YzdPCmspa2dXFABCAC4oHXoaAHMKKU1tYGESDGwrdQBbYlQAeWoIE0R7eKULfJsoeng9empbeycXN1D1KSkSgCMAKwhDB3k0SmTqEyUHMHokI1wIABps0TMKaS0dKHwuD3L-KCVzCgOkByKRFDKKraA)
&gt;It's unlikely to change a lot at least. I doubt it will be just scrapped. Decorator use is already very widespread, even outside of TypeScript. I think it's likely to change quite a lot. The main issue I saw expressed were that the current spec made decorators too complex. The complexity allows for a lot of great features, but for average users it is daunting. Use is widespread, but also fragmented. TypeScript uses the is decorator spec. Babel has plugins for both, but the recent spec seems to have more popularity. Now there will likely be a third incompatible spec that will need to gain adoption. I don't think decorators will go away, because they are necessary for class syntax to be effective, but the state is really not good IMO. &gt;How so? Can you provide an example? Only thing I can think of is that decorators can not augment type information of classes. Otherwise they work without an issue, support is good and a lot of frameworks built upon them. Not having augmented types is the issue, but a very large one. Not only does the resulting type not change, but also the type accepted by decorators is inflexible.
Not easily. const Person = (function () { interface Person { name: string; greet(person: Person): string; } interface PersonCtor { new(name: string): Person; } function Person(this: Person, name: string) { this.name = name; } const proto = Person.prototype; proto.greet = function (this: Person, person: Person) { return `Hello ${person.name}, my name is ${this.name}`; } return Person as any as PersonCtor; })(); var test = new Person(); // type error, needs 1 arg, got 0 test.greet(); // type error, needs 1 arg, got 0 If you need to set up prototype chains, `class` syntax is your best bet in Typescript. Of course, you don't *need* to set up a prototype here, you can just simply do this: interface Person { name: string; } const greet = (self: Person, them: Person) =&gt; `Hello ${person.name}, my name is ${this.name}`; greet({ name: 'foo' }, { name: 'bar' }); `class` isn't inherently evil or bad. Just don't overdo it.
&gt; While the class syntax has (or had) potential to be good, it doesn't currently have near the same amount of flexibility of using prototypes directly What is the flexibility you are after? Can you provide an example? I just find that using the class syntax covers pretty much everything I've been using the prototype based syntax for.
Curious, what are the issues youâ€™re facing with typeorm? 
&gt; I loved TypeScript but hated Angular. Because Angular is pretty awful and makes very bad use of TypeScript.
This is for me so old-school... This ugly es5 Syntax held me back from learning JavaScript. If you transpile TS (or ES6 class style) down to ES5 you have this syntax anyway. 
Wouldn't this also work? return ({...ids.map(id =&gt; ({[id]: id}))}) (Skipping `Object.assign`)
I just use: type Colors = "red" | "blue" | "yellow"; My WebStorm IDE seems to know how to deal with this.
&gt; It saves time. We can have a faster feedback in browser or while running tests. Otherwise, there is always a delay due to build How are you compiling now? Manually every X seconds? My frontend setup compiles `.ts/x` to `.js/x` in place, every time the TypeScript code changes, new JS code is produced. Then the `.js/x` change is picked up by the hot reloader watcher and propagated to the browser (or Node is restarted with `nodemon`). I haven't observed any significant delay since switching to TypeScript. &gt;Why we would like to add a compile step if we can do the above without it? Because you're not actually writing TypeScript in an efficient way, you're writing JavaScript and the TypeScript definitions in parallel and have to maintain multiple files for the same piece of code? Seems to me a lot more time is being wasted switching files than having your computer do something that takes milliseconds.
I never use `index.ts` files, could you please explain a use case for this?
make imports easier: https://github.com/basarat/typescript-book/blob/master/docs/tips/barrel.md and avoid circular deps: https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de
Thanks, also found this: https://medium.com/@adrianfaciu/barrel-files-to-use-or-not-to-use-75521cd18e65
It's also opinionated for a reason, so other people can understand your code. Would be interested to hear what you are trying to do!
THE BEACONS ARE LIT! GONDOR CALLS FOR AID!