What you keep in store and what your components use is not always the same and they should not be coupled. You can achieve proper separation and good performance by keeping the state normalized: type Id = string | number; type IndividualId = Id; type GroupId = Id; interface Individual { id: IndividualId; belongsTo: GroupId[] } interface Group { id: GroupId; consistsOf: IndividualId[] } interface Store { individuals: { byId: Record&lt;IndividualId, Individual&gt;; allIds: IndividualId[]; }; groups: { byId: Record&lt;GroupId, GroupId&gt;; allIds: GroupId[]; } } const getIndividualById = (state: Store, id: IndividualId): Individual =&gt; state.individuals.byId[id]; const getAllIndividuals = (state: Store): Individual[] =&gt; state.individuals.allIds.map(id =&gt; getIndividualById(state, id));
Fill me in, which major is shifting to Typescript? Hope it is Vue. 
For this kind of stuff, I usually use Ramda's [evolve](https://ramdajs.com/docs/#evolve). Works really well, everything is computed. Install the types as 'types/ramda\#dist' instead of '@types/dist' to pull better types from GitHub.
Oh, sorry, I misunderstood a bit... this doesn't change the shape. Yeah, I'll check this out for sure.
Yep the added value is the type safety :-)
Cool! Did you consider writing it as a custom TS transformer? ttypescript (https://npm.im/ttypescript) makes it possible to declare and use transformers via your tsconfig.
There is already a solution that uses \`ttypescript\`. I wanted something that does not require custom \`tsc\`.
Nope, I'm already considering removing lodash dependency. My biggest concern about this is not about `keys` and `each` (which can easily be dropped) but about `has` which is a bit complicated when looking at lodash implementation (I don't think I need this level of complexity though). So, hope for dependency drop of lodash in upcoming versions.
I see you already removed the dependency! +1
100% :-) (anyway, my current replacement is not typesafe either, as I needs to cast to &lt;any&gt; at some point ... not sure if I can avoid this)
``` function srcKeyExistsIn&lt;SRC extends object, FM extends FieldMap&lt;SRC&gt;|undefined&gt;(fieldMap: FM, key: (keyof SRC)): key is keyof SRC { return !!(&lt;any&gt;fieldMap)[key]; } ``` What if `fieldMap[key]` is `null`? The function name does not match the implementation. Maybe `fieldMap.hasOwnProperty(key)` or `key in fieldMap` better suits your use-case, don't you think?
Thanks for spotting the result bug &amp; for the `in` operator .. I always considered it as usable in the `Type` declaration type, but it is usable in the `Value` declaration type as well, that's nice :)
Nice. Really like how this starts with type inference, i.e. showing the reading what TypeScript can do "for free" without even using additional type annotation syntax. I think this is something that was often missing in previous introductions to TypeScript.
Why not use a value object, with the validation built in?
Regarding higher-order types, this is not currently possible in TypeScript (although there are some very hacky ways to get close to it). There is an issue in their repo - https://github.com/Microsoft/TypeScript/issues/1213 I can't find any way to get around the recursive type issue, but others might.
 foo&lt;T extends P&gt;(class: T) { ... }
Usually, you'd just use `P`. No need for fancy generics.
You mentioned in the details post how the alternative approach involved using debugging and sourcemaps. You listed some reasons why you didn't take that approach, but offhand it seems like it might have made the tool much easier to use without needing to change anything about how code is built or webpack configurations? "Works with v8, whether in node or chrome, and requires working sourcemaps" is a reasonable requirement IMHO, especially for generating these types. You don't have to constantly develop against chrome if you don't want, just use it for this scenario to help populate missing types. I love what you've done with TypeWiz, but in terms of lowering the barrier to adoption, while what you've done here for Angular is certainly simple to use, offhand I wonder if it would have been simpler for most typescript projects if you'd gone the other route. This isn't meant as criticism by any means, just trying to offer a possible alternative thought on adoption barriers, admittedly from someone not familiar with the problem space nearly as much as you are!
I don't pass `new A()`, I pass the class `A` so this doesn't work.
As I said above I don't pass `new A()`, I pass the class `A` so this doesn't work.
This should do it: foo&lt;T extends typeof P&gt;(clazz: T) {} &amp;#x200B; Playground example: [https://www.typescriptlang.org/play/index.html#src=class%20P%20%7B%7D%0D%0A%0D%0Aclass%20Q%20extends%20P%20%7B%7D%0D%0A%0D%0Afunction%20test%3CT%20extends%20typeof%20P%3E(myClass%3A%20T)%20%7B%0D%0A%0D%0A%7D%0D%0A%0D%0Aconst%20pInstnace%20%3D%20new%20P()%3B%0D%0Aconst%20qInstance%20%3D%20new%20Q()%3B%0D%0A%0D%0Atest(pInstance)%3B%20%2F%2F%20error%0D%0Atest(qInstance)%3B%20%2F%2F%20error%0D%0A%0D%0Atest(P)%3B%20%2F%2F%20happy%0D%0Atest(Q)%3B%20%2F%2F%20happy](https://www.typescriptlang.org/play/index.html#src=class%20P%20%7B%7D%0D%0A%0D%0Aclass%20Q%20extends%20P%20%7B%7D%0D%0A%0D%0Afunction%20test%3CT%20extends%20typeof%20P%3E(myClass%3A%20T)%20%7B%0D%0A%0D%0A%7D%0D%0A%0D%0Aconst%20pInstnace%20%3D%20new%20P()%3B%0D%0Aconst%20qInstance%20%3D%20new%20Q()%3B%0D%0A%0D%0Atest(pInstance)%3B%20%2F%2F%20error%0D%0Atest(qInstance)%3B%20%2F%2F%20error%0D%0A%0D%0Atest(P)%3B%20%2F%2F%20happy%0D%0Atest(Q)%3B%20%2F%2F%20happy)
function foo(clazz: typeof P) { ...
Server side render. Google doesn't run your page JS nearly as much as they dumb html crawl. Also not sure how many other crawlers will execute JS either.
&gt; Iirc if you target es5 in your tsconfig it should convert some features to valid es5 code but this doesnt work for everything. Yea, like Promises. I am not sure if you can let TypeSCript transpile to ES5+Promises. It would be a real shame not use Promises in TypeScript code.
I tried that but I get the following error: `Type 'typeof A' is not assignable to type 'typeof P'` ... I'm not sure if this might be a problem but `P` accepts a generic type, so the classes actually look like this: class A extends P&lt;string&gt; { ... } There's no constraint on the `P` generic 
You can include polyfills for Promise and other things missing. 
I haven't tried that. Will try tonight =)
I haven't tried that. Will try tonight =)
If you need Google Bot to access your content, make it accessible without Javascript. SPAs - Single Page APPLICATIONs - usually don't need to be crawled. We have separate code-bases for our SPAs and websites. Our websites are 100% server-side generated code with only minor JS additions (usually small hand-written classic JS). I test &amp; write all our websites with JavaScript disabled, and I only use JS for small enhancements like validation. For more complex features, we have the server generate a div as a target and inject the SPA in that DIV. Of course, that complex feature is not indexed and it shouldn't be indexed.
Ah, then yes: `&lt;T extends typeof P&gt;`
None of them, I use my own framework. Very programmatic; Small functions such as; appendDiv( parent, { classes: ["header] } ); Which goes into larger functions such as appendGenericList( parent, dataRows ); But I know angular and vue has SSR.
`? expected` :/ ideally I would like to have it as a type alias but that isn't necessary
Let me know how you get on buddy
You mostly need server-side rendering for social media share / previews. Googlebot handles javascript mostly fine.
I like that, that JS is only for progressive enhancements. IMO, its second nature now that almost the whole FE should be in JS, well, it feels like that for me at least. &amp;#x200B; I like that idea. I should experiment, how to create a website that is generated in backend, that loads in the page super fast. Thanks!
I rarely use them directly in application code, but they are useful when constructing libraries and utilities. For example, here is a type "utility" to get the Props of a React Component, whether SFC or class component. ```ts export type ReactProps&lt;T extends React.Component&lt;any, any&gt; | Function&gt; = T extends React.Component&lt;infer P1, any&gt; ? P1 : T extends (props: infer P2) =&gt; JSX.Element ? P2 : never; ``` 
Google said they would benefit apps that used Angular. They can't even crawl it, liars.
Thank you! This is an excellent walkthrough. Exactly what I was hoping for.
Yeah seriously. You would just use dog and dogId as separate keys on the object.
This is the exact case I use the types in my comment for.
Ahh. You're right. I need to get back to "other" languages. I've been away far too long.
If you have a factory function it can be useful to specify the shape of the expected constructor.
You could use an abstract class instead of an interface. 
Ah right fair enough. Yeah otherwise I would have suggested next.js or nuxt for SSR.
 interface FooCtor { new (arg1: string, arg2: boolean): Foo; }
Amazing and detailed answer. Very helpful - thank you!
Oh man I wish it wasn't so short notice. I'm vegetarian too. Good luck finding a great teacher :)
Aren't `pinoptions? : PinOptions` and `pin options : PinOptions` (without a question mark) essentially the same type since all objects are nullable in C#?
Thank you :-)
Yea I understand from the link (and the link there with the PR and longer explanation) why things are the way they are. Although it would be nice if I could create a contract (as per the other comment) and could enforce implementations to adhere to it. I'll play around with \`--strictFunctionTypes\` but since this is by design, I will likely make the options object in the abstract function required (all the properties on it are optional anyway) to avoid mistakes in implementations. While it turns out this is expected behavior, I do find it a flaw if I can not enforce the abstract signature to be followed.
I've found conditional types to be extremely useful in ensuring that my pure functions remain pure with truely immutable types: export type Primitive = undefined | null | boolean | string | number | Function; export type Immutable&lt;T&gt; = T extends Primitive ? T : T extends Array&lt;infer U&gt; ? ImmutableArray&lt;U&gt; : T extends Map&lt;infer K, infer V&gt; ? ImmutableMap&lt;K, V&gt; : T extends object ? ImmutableObject&lt;T&gt; : T; // Should only be unknown export interface ImmutableArray&lt;T&gt; extends ReadonlyArray&lt; Immutable&lt;T&gt; &gt; {} export interface ImmutableMap&lt;K, V&gt; extends ReadonlyMap&lt; Immutable&lt;K&gt;, Immutable&lt;V&gt; &gt; {} export type ImmutableObject&lt;T&gt; = { readonly [K in keyof T]: Immutable&lt;T[K]&gt;; }; This is nice because you can have something like this: type DeepObject = { foo: { bar: { baz: string | string[] } } } function pure(obj: Immutable&lt;DeepObject&gt;) { obj.foo.bar.baz = "str"; // TS error! if (Array.isArray(obj.foo.bar.baz)) { obj.foo.bar.baz.push("str"); // Also a TS error! } } I've started using this pattern in most of my TypeScript projects instead of `Readonly&lt;T&gt;`, which does not deeply recurse into types.
Hey, Drake250, just a quick heads-up: **truely** is actually spelled **truly**. You can remember it by **no e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day!
You can do: abstract class Map { abstract addPin: (pin: Pin, options?: PinOptions) =&gt; void; } class MyMap extends Map { public addPin: (pin: Pin, options: PinOptions) =&gt; void = (pin, options) =&gt; { if (options.hidden) { } } } 
My 2 thoughts on this: 1) Where's the measurements to show how much performance is improved? Is this premature optimization? 2) This can cause incorrect behavior if the function you pass any props/state of the outer component. In this case, you WANT a new function to be passed down, because the implementation of the function implicitly changes when those props/state change. If there are no other changed props to the inner component, and your function is "cached", (and you have setup the component to skip rendering if props are detected to not be changed), then the inner component will incorrectly use stale data when executing that function. For these 2 reasons, I keep it simple and always pass arrow functions down as callback/event-handler props. I prefer guaranteed correct behavior. If I ever encounter a performance issue and trace it down to a situation that could be improved by caching functions, then I will implement caching on a case-by-case basis (only after proving with measurements that it improves performance significantly), and clearly document that/why I am caching the functions. Also note that the default behavior of react components is that the render function is always called (probably more times than you expect), even if the values of the props have not changed. You have to put additional effort into setting up a component to skip execution of the render() function if values of props have not changed. So this advice to cache functions does not event prevent "wasted" executions of render() in most common cases. It only skips the overhead of creating a new bound function or arrow function.
&gt; Where's the measurements to show how much performance is improved? Is this premature optimization? There is absolutely no way to measure this. Every component will be drastically different. It depends both on how many of those components there are and how often they re-render, not taking into account the device on which it is running. &gt;This can cause incorrect behavior if the function you pass down references any props/state of the outer component. In this case, you WANT a new function to be passed down, because the implementation of the function implicitly changes when those props/state change. If there are no other changed props to the inner component, and your function is "cached", (and you have setup the component to skip rendering if props are detected to not be changed), then the inner component will incorrectly use stale data when executing that function. Sorry, none of this is true. You may be thinking about function components. Pure components are objects. Accessing their props and state use the `this` object reference, which does not change when props and state change. Functions created referencing the component's props and state will always access the props and state at time of execution, not time of creation. var x = { a: 'b' }; function y() { alert(x.a); } y(); // b x.a = 'c'; y(); // c &gt;You have to put additional effort into setting up a component to skip execution of the render() function if values of props have not changed. You just use `React.PureComponent` instead of `React.Component`. It is built into the React library.
&gt;Sorry, none of this is true. You may be thinking about function components. Pure components are objects. Accessing their props and state use the &gt; &gt;this &gt; &gt; object reference, which does not change when props and state change. Functions created referencing the component's props and state will always access the props and state at time of execution, not time of creation. &amp;#x200B; Ahh.. I explained it incorrectly. It's not a problem for event handler callback props, but it is a problem for something like a renderer callback prop, or any other kind of callback that is used for providing implementation details to determine how something is rendered. In this case, you need the function reference to change to guarantee the component re-renders using the results of the callback function in terms of the new props values. If you cache the function, then the component may not re-render properly (if no other props to that component have changed)
So as you pointed out, the function is guaranteed to always produce the correct results whenever it is called, but my problematic situation is about ensuring that the function will be called and its results used any time that the results of the function may be different than previously.
&gt; There is absolutely no way to measure this for an article. ... of course there is. You're right that it'd be specific to whatever artificial test were setup, but that can still be illuminating as to potential scope of impact. It doesn't need to be nanosecond-precise for every use case, it just needs to show that "hey, here's a case where the impact is measurably relevant, and by this much."
You have a component that accepts a function prop `getX` and its render output changes depending on the output of `getX()`? There are various ways of tackling this. The article covers using that changing value as a memoization key for the function getX, such that if it changes, getX gets recreated, a new function reference is passed to the component, and the component re-renders. At the same time, your use case may be bad design. You should probably be passing the return value of `getX` to the component instead of `getX` itself. Alternatively, you should maybe be using a pub-sub service to notify that component if the value has changed, instead of arbitrarily executing a function _whether or not_ the value has changed just on the off chance that it has. Check out event emitters or pub-sub design. &lt;Child provider={eventEmitterInsteadOfFunction} /&gt; componentDidMount for Child can now do `this.props.provider.addEventListener('data', () =&gt; { this.setState({ data }); })` to bind a re-render whenever the provider has changed value.
I didn't say there was no way to solve the problem. But solving the problem requires additional complexity. Caching is hard to get done right and robustly. It comes down to: 1) NOT caching functions always guarantees correct behavior, and is simple to write/read/maintain. 2) Caching functions adds a little more complexity, reduces readability/maintainability a bit, and can cause incorrect behavior in some situations that are not obvious. So if you cache functions as a general rule, you will likely eventually run into one of these problems which may not manifest until runtime in production with specific data and a specific sequence of actions. Tracking down the cause of the bug will be difficult and time consuming, then require additional complexity to solve if you try to continue following the general advice of caching functions for performance. So it keeps coming back to: is there a reasonable example where caching functions will solve a performance issue? If you cannot produce such an example, then why even recommend caching functions as a solution to an unidentified problem? It would be much more useful to recommend a solution within the context of an example of a quantifiable problem. BTW - When using 3rd party libraries, it doesn't matter how much I know about how a component could be designed to not rely on executing a function to get a new result. If that 3rd party library component takes a callback as a prop that controls some portion of its rendering, then that's what I have to work with.
Another way to look at this: how common is it to have an actual performance problem (noticeable to the human using the app) that is solved by caching functions? Is it rare? Common? Any common patterns that are susceptible to such performance problems? Any examples of any particular projects/components that had performance problems that were solved by caching functions? I ask all of this because I often see the advice to cache functions in react components for performance, but have not yet seen any actual examples where doing so solved a performance problem, and I have not yet personally experienced it yet either. I am genuinely curious about whether there is any real benefit to following this advice in general. If it can be demonstrated to be a common problem, then maybe it is worth following this advice in general. &amp;#x200B; If it is uncommon, then following this advice in general is premature optimization that may cause maintenance issues or difficult bugs for effectively no benefit, but it would be very helpful to have examples of patterns to watch out for where, if a performance issue is noticed, it might be worth zeroing in on function props as a potential cause of the performance issue that can be solved by caching.
Another way to look at this: how common is it to have an actual performance problem (noticeable to the human using the app) that is solved by caching functions? Is it rare? Common? Any common patterns that are susceptible to such performance problems? Any examples of any particular projects/components that had performance problems that were solved by caching functions? I ask all of this because I often see the advice to cache functions in react components for performance, but have not yet seen any actual examples where doing so solved a performance problem, and I have not yet personally experienced it yet either. I am genuinely curious about whether there is any real benefit to following this advice in general. If it can be demonstrated to be a common problem, then maybe it is worth following this advice in general. &amp;#x200B; If it is uncommon, then following this advice in general is premature optimization that may cause maintenance issues or difficult bugs for effectively no benefit. But it would be very helpful to have examples of patterns to watch out for where, if a performance issue is noticed, it might be worth zeroing in on function props as a potential cause of the performance issue that can be solved by caching.
Another way to look at this: how common is it to have an actual performance problem (noticeable to the human using the app) that is solved by caching functions? Is it rare? Common? Any common patterns that are susceptible to such performance problems? Any examples of any particular projects/components that had performance problems that were solved by caching functions? I ask all of this because I often see the advice to cache functions in react components for performance, but have not yet seen any actual examples where doing so solved a performance problem, and I have not yet personally experienced it yet either. I am genuinely curious about whether there is any real benefit to following this advice in general. If it can be demonstrated to be a common problem, then maybe it is worth following this advice in general. If it is uncommon, then following this advice in general is premature optimization that may cause maintenance issues or difficult bugs for effectively no benefit. But it would be very helpful to have examples of patterns to watch out for where, if a performance issue is noticed, it might be worth zeroing in on function props as a potential cause of the performance issue that can be solved by caching.
&gt; 1) NOT caching functions always guarantees correct behavior, and is simple to write/read/maintain. Not caching anything (including files) guarantees correct behavior, and is simple to write/read. It is not simple to maintain, because performance has to be maintained. &gt;Caching functions...reduces readability/maintainability a bit I'd argue it improves readability by shifting away from anonymous functions towards named functions. The simplest case is by passing a component _method_ instead of an inline function. &gt;and can cause incorrect behavior in some situations that are not obvious I disagree. Any case where this causes incorrect behavior is an anti-pattern in that component's design. It should not be considered as a valid point in design decisions. &gt;you will likely eventually run into one of these problems I have been using this for months on both personal and enterprise applications from 100kB to megabytes in size, bundled JavaScript only. These are not problems that actually occur. The only downside to doing this is adding complexity for a negligible performance trade-off, and the performance implications of such a change should be measured on a project-by-project basis before deciding on adopting this design. Again, if you are getting erroneous component output as a result of caching function props, you are either designing your components wrong or you are caching your function props wrong. &gt;which may not manifest until runtime in production with specific data and a specific sequence of actions You should be testing your components before pushing to production. Any complexity can lead to bugs. That's part of the job description of being a developer.
I've mentioned about this article often, but I'll mention it again: A real-world example where inline functions caused a performance issue was an animation involving hundreds of buttons re-rendering with each animation frame. It would actually crash the browser. Caching the functions removed the lag _entirely_. Just don't prematurely optimize. I'm not even claiming that caching props will always improve performance. There are times when it won't -- you are trading memory for clock cycles here. A low memory target device, such as a tablet, may not handle this well. The idea is to be educated about how functions behave as references in the React lifecycle. If that doesn't impact your performance, don't worry about it.
Ok? Are you agreeing? I don't understand what you are trying to say.
Your article had a simple example of a button that would be unnecessarily re-rendered, but provided no additional context about how it caused a performance issue. How about providing a functional example of that exact situation (simplified as much as possible for brevity, of course), and providing some measurements demonstrating the results of optimizing it? You seem to be agreeing here that the optimization should only be done if a problem is discovered, and the optimization is proven to solve it. My problem is that the article does not convey this at all, but instead frames it in a way that using inline arrow functions for react props is a programming mistake that needs to be fixed. Full stop. No context, other than "if you don't cache your functions, components will unnecessarily re-render, and therefore it's a performance problem". In fact, your over-simplified example that is not actually a performance problem is introduced as, "This is an unfortunately common scenario I come across during code review:" Unnecessary re-renders are not automatically performance problems that need to be solved.
I have been using Typescript with my Vue 2.0 projects and really enjoying it. 
What if you enable strict Null checks?
Dart is like the son of googleâ€™s GWT (new developers may never heard of it). And I believe Dart will have the same destiny like his father.
you can just use request-promise or request-promise-native... then you can just await the results...
Tried using the native one earlier but TS was telling me it can only await an async function. The functions don't appear to be annotated with `async`. Is there a compiler option to get around that?
Or observable subscribe. 
request-promise + @types/request-promise works fine. 
Hmmm, I'll give it another look tomorrow. I've left the lab for tonight. Thanks man!
I made this out of sheer frustration with `tsc`. It has four main benefits: - Simple CLI using standard conventions - Configurable warnings/errors - Predictable output - Automatic/custom relative import path mapping
Best new offering IMO, the refactoring from `.then` =&gt; `await` in VSCode!
How about [node-fetch](https://www.npmjs.com/package/node-fetch)? It works like the browser fetch.
\^ This is correct. You can \`await\` anything, but you can't \`await\` outside of an \`async\` function.
TypeScript's built-in declarations include everything from the DOM, including the browser \`fetch\` API, so you can use them with stuff like \`node-fetch\`. Might need to write a few lines applying the browser \`fetch\` type to whatever you import, but it'll work great.
Or install `@types/node-fetch` :)
Yeah, totally! There are a few `fetch` implementations on npm and I'm not sure if they all have DefinitelyTyped declarations, so if the OP has a preference for whatever reason, they should still be good to go.
Ah neat, you're right. [Found this discussion](https://github.com/Microsoft/TypeScript/issues/8310) about why awaiting non-thenables is allowed to be interesting.
got https://github.com/sindresorhus/got 
I mentioned the benefits in my other comment. I didn't write a compiler, just an alternative CLI using the TypeScript compiler API.
That seems work, with `--strictFunctionTypes` enabled. I dislike having to write function as properties though. While it doesn't matter in practice it's in essence incorrect and also intellisense typings mark it as a property instead of a method. (At least in VSCode I'm seeing this as a side effect). Thanks for the help, this is some interesting reading material!
I don't know if it is so, but there might be a risk that a lot of typescript tutorials assume knowledge of JavaScript and just build on top of that rather than start from the basics.
This looks really nice!
Errors are always of type `any`. I'm almost positive this is because of how they propagate up the call stack. When you catch an error, where did it come from? It could have been thrown a dozen levels down the call stack in code you don't understand? How would you account for all those possibilities? Would you annotate every possible function with every possible exception it -- or code that it calls indirectly -- might throw? Once you start thinking about how the language might deal with types for thrown values, it becomes clear that would be a nightmare. Promise rejections are just like thrown values, as is made clear by native `async`/`await` syntax. If a promise *might* resolve then the resolution type should not include `never`. Because there's no way to get access to a `never` value. If that code path is ever executed, it means the promise resolved, meaning the value is not `never`.
You must not be familiar with Typescript. Any "reflection" in Typescript is linked at compile time, and only works with references to classes. In OP's case, his types are interfaces, so they don't exist at all at run time.
I have found that using reject to send anything that isn't an Error makes the code hard to follow and maintain. If you want to "resolve with fallback" I would just do that. For example when trying to get a list of comments on a post instead of rejecting with an empty array I like to resolve with an empty array but if the post ID is invalid it perhaps is more relevant to reject with an Error to be handled.
What is your foo code doing that requires it to receive a subclass of P? Is it calling a static method? Accessing things on the prototype? Invoking the constructor? We need the answers to these questions so that we can give you a meaningful answer.
An explanation for your down-votes: that's irrelevant to the question. I'm asking a question to *learn* about how to use Promises with TypeScript. Using rxjs doesn't teach me that. ;-)
Okay, this makes somewhat sense to me. Follow-up question to this: when I cause a rejection to happen from a function that returns a promise, by using `return Promise.reject(value)`, does this result in an error being thrown somewhere, automatically? Is that why in an `await` situation, you'd end up in a `catch` clause? Trying to clear up all the questions in my head here, sorry. :-)
You are correct that `await` will transform a promise rejection into a thrown value. And if you don't catch that thrown value, then it's "thrown" from the containing async function, except that async functions always capture any thrown value from within and convert it to a rejection of the promise that they return. So yeah, the language tries to unify promise rejections with thrown values. A synchronous expression (usually a function call) will return a value or throw a value. An asynchronous expression (usually a function call) will return a promise that resolves a value or rejects a value. An `async` function forces synchronous returns or throws from within to be wrapped in the returned promise. An `await` expression does the opposite, converting a promise into what looks like a synchronous return value or thrown value. The async and await keywords let you convert back and forth. Hope that makes sense!
On the class itself is data from an annotation. So I'm reading it like `clazz['SOME_META_DATA'].xyz`. I just want to make sure that other developers pass in a correct class, that has to extend `P` to make everything work.
In that case your best bet for simplicity is to use the Constructor generic I posted in another comment. function foo(klass: Constructor&lt;P&lt;any&gt;&gt;)
T is merely the type of the argument passed to the resolve callback. Meaning the signature of .then is then(onResolve: (value: T) =&gt; void, onReject: (error: any) =&gt; void). It does by no means dictate the type of the argument passed to the reject callback.
The type of the promise will only need to be `Promise&lt;T&gt;` because the type parameter only describes the type of the resolved value. TypeScript can't make any guarantee on the type of a rejected value because it's possible you don't catch an error down the call stack from a third-party library or something like that. Even if you could explicitly tell TypeScript what the type of a value you *intend* to reject is, if you don't catch such an error, that error could bubble up to your promise's reject method. At that point, if it's not miraculously of the same type you specified, you would end up in an even worse spot at runtime, because your reject handler would have the wrong assumption for the type, and will likely cause another error due to your code possibly accessing properties of an object that are undefined. So, rejected values are always treated as type `any` since you have no guarantee on the type of the rejected value at compile-time. I hope that makes sense.
tip? i have moved from promise to rxjs, because it is better, don't wast time
Errors are not type-safe in typescript. Clarification: When you throw an error, the error that comes in the catch clause is never inferred, it is always an any unless you specify it. interface Promise&lt;T&gt; { then&lt;TResult1 = T, TResult2 = never&gt;(onfulfilled?: ((value: T) =&gt; TResult1 | PromiseLike&lt;TResult1&gt;) | undefined | null, onrejected?: ((reason: any) =&gt; TResult2 | PromiseLike&lt;TResult2&gt;) | undefined | null): Promise&lt;TResult1 | TResult2&gt;; catch&lt;TResult = never&gt;(onrejected?: ((reason: any) =&gt; TResult | PromiseLike&lt;TResult&gt;) | undefined | null): Promise&lt;T | TResult&gt;; } In the same fashion the promise class only has 1 argument relative to the success case. When you write a `.then` or a `.catch`, those methods have "symbolical" type arguments which allow you to hint an error type, but in the end you'd always have to either annotate the error outcome, in the same way you'd do in a try/catch clause.
You should only use the promise constructor to convert "callback-like" code to "promise-like" code, and insulating that conversion from the main logic is recommended. If you are writing node.js code, utl.promisify usually does this trick, if not, you'd write a function to do the utl.promisify's job for that operation.
I'd argue that it is relevant. There are no reasons to use promises when you can use rxjs instead. Your code will be cleaner and everything will be typed properly, because there's no way you can propagate 'any' for rejection/error scenario.
Yes. It's called [r2] (https://github.com/mikeal/r2) and it's built by the same guy, with all the hindsight he has collected.
You can't await anything, only promise objects.
Well I had no clue about that, thanks. In my eyes, though, it just goes to show what crappy language JavaScript is to allow complexities in operators/syntactic sugar like that. God bless Typescript.
Wow that file is a jackpot full of gold.
Hi, sadly, tslint do not support rules written in typescript. All you have to do is to compile your rule and use the .js file
This is possible if using ts-node, as of tslint v5.7.0. See the bottom of this page: https://palantir.github.io/tslint/develop/custom-rules/
I did compile it and I did use the .js file. I realize I've written *interfacePascalCaseAndPrefixRule.ts* instead of *interfacePascalCaseAndPrefixRule.js* once in my post, hence the confusion probably. 
I find them very useful for extracting generic types, for instance, to get the type for the props of a React component: ``` import { Component, ComponentType, StatelessComponent } from "react"; export type ComponentProps&lt;C&gt; = C extends StatelessComponent&lt;infer P1&gt; ? P1 : C extends Component&lt;infer P2&gt; ? P2 : C extends ComponentType&lt;infer P3&gt; ? P3 : never; ``` This is very useful when creating component wrappers. Another useful use case if for [extracting the type of navigation params](https://github.com/teamdigitale/italia-app/blob/master/ts/types/react.ts#L19) from `react-navigation` aware components, for [redux nav actions that provide type safe params](https://github.com/teamdigitale/italia-app/blob/master/ts/store/actions/navigation.ts#L112).
It seems to me that visitInterfaceDeclaration should be public instead of protected. You can try to add a bunch of console.log in both the rule and the walker. If a rule throws an error, tslint ignore it and continue his job.
&gt;add a bunch of console.log That was a pretty useful tip, I somehow didn't think of that. It appears that the function *visitInterfaceDeclaration* is never executed. I'm still confused on why that is, but at least I've made some progress. Thanks Mate!
The reason it isn't relevant to this question in particular, which I'm telling you as the person who actually asked the question, is that it doesn't pertain to the answer at all. The answer to "how" in this context, WiFi is all I wanted to know, cannot be "you don't"... That doesn't answer the question. It's fine by me if you think rxjs is the best library in the world or whatever, but it just doesn't answer my question. Like I also said, it's still a good tip! I'm not taking that away (I didn't give a down vote). Personally though, I think async/await and other standard stuff like new Array functions in es6 are good enough as well as a future [Observable](https://github.com/tc39/proposal-observable/blob/master/README.md) implementation will be exciting. It's definitely good enough for the code we're sitting right now anyway.
Okay. I'm happy for you but rxjs's documentation doesn't explain how to use Promises with TypeScript, which is what I wanted to learn. Maybe we can discuss promises vs rxjs in another thread in r/JavaScript instead? Feel free to open that. But I still appreciate the tip. (Even though I think async/await might be cleaner, and doesn't require an external lib, but that's another discussion...)
Here's a sneak peek of /r/javascript using the [top posts](https://np.reddit.com/r/javascript/top/?sort=top&amp;t=year) of the year! \#1: [PSA: There are over 1000 people in the U.S. named "Infinity" and the jQuery .data() method attempts to convert to number when reading off the DOM](https://np.reddit.com/r/javascript/comments/8f57i1/psa_there_are_over_1000_people_in_the_us_named/) \#2: [Iâ€™m harvesting credit card numbers and passwords from your site. Hereâ€™s how.](https://medium.com/@david.gilbertson/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5) | [80 comments](https://np.reddit.com/r/javascript/comments/7oke31/im_harvesting_credit_card_numbers_and_passwords/) \#3: [I built Apple Music using ReactJS, Redux, and Styled Components](https://v.redd.it/3qxy9xbbc5e11) | [111 comments](https://np.reddit.com/r/javascript/comments/94mqj0/i_built_apple_music_using_reactjs_redux_and/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
I hate that with nodemon I always get zombie processes running in the background and I have to manually kill them quite often. I use https://www.npmjs.com/package/ts-node-dev which works much faster and you never get any zombies which is nice.
Are you sure that your tslint version match your typescript version? Sounds like their is a missmatch
We run locally with ts-node
I've just signed up, I'll get going with some mentoring over the next few days. &amp;#x200B; BTW on page [https://exercism.io/mentor/registrations/new](https://exercism.io/mentor/registrations/new) you've got a type: "Mentors can help on as many tracks as they line" should be "Mentors can help on as many tracks as they like"
I use `ts-node` locally, but I usually make sure CI is running tests with the compiled version.
The ones I've thought of and the ones I've seen from search are too simple to be worth the extra overhead (better to just do a simple vanilla JS check). I'm in search of some more complex project ideas that would benefit from TypeScript. :) Do you have any suggestions?
1. Prior to jumping on the TypeScript train, I did a lot of web-based projects using regular ol' JavaScript and jQuery. In my early days, I felt oh-so-powerful in my ability to manipulate and animate DOM objects, but even in my naÃ¯vetÃ© many years ago, I recognized it was pretty challenging to keep the code in my projects even remotely sane or clean, and refactoring anything was generally a nightmare. When TS started gaining momentum, I immediately got interested, mostly because my professional background is in C#, and I have a very strong appreciation for strongly-typed languages. Coupled with the direction of ECMAScript, I finally felt like I could fully flex my C/C++/C# skill in a way that translated quite nicely to clean, maintainable JS (via compilation). 2. Any side projects I could suggest are side projects I'd personally want to do or am doing. What kind of side projects do *you* want to do? Do you want to do things that will run in a browser, or build Node applications? If you want to get more experience with TS, don't about whether TS is going to be a good fit for one of your projects; just force yourself to use it, if you could use JS for it. Even for really small projects these days, I opt for TS over plain JS, just because I have my workflow down such that the set-up process isn't particularly painful for me. There are a lot of tutorials and resources online that will give you a little bit of practical experience. Are you already a JS developer, to some degree? Do you have any small JS libraries you use that are open source that you could attempt to port over to TS in a much more strongly-typed manner? Lots of stuff out there. You note in one of your other comments that you don't believe these small projects are worth the extra overhead. Do you never expect your projects to grow to a point where something might need to be refactored? Or, where you don't have method signatures all memorized? TS, even in small projects, is a great way to build a strong foundation for anything you might want to grow in the future. Also, you're concerned about overhead... in what sense? Development speed? If you're just looking to learn the language, overhead shouldn't be a concern.
Small projects are a great way to get your feet wet and work your way up to big projects. That's the way I've been approaching it. Figure out how to get the build environment set up. Figure out how to effectively use the language. Figure out how to apply all your learnings to a project with some scale.
Yup, I too have come from a strongly typed language background, specifically C++ then C#. The problem is I don't have any side project ideas at the moment. I've done all of them so far. Yeah, the small project(s) ideas that I have in mind are literally just for one off practice purposes where I try to make it as complete as possible, but don't expect anything from them at all. Worse case, I just use TypeScript with JavaScript as if JavaScript was a typed language just for the sake of learning once I get a project idea in mind.
Youâ€™d need proper typing for the arguments, which cannot be done. Itâ€™s not just any if you want to stay type safe. I havenâ€™t checked 3.1 too deeply but I think you still cannot variadically infer all the argument types on a function of a generic type. I might be wrong though. If you throw typing out the window the constructor type kind of lose its usefulness. Just declare a specialized interface for it instead. 
I'm using a variant of 2, in a Docker container using `npm-run-all`.
Yeah, actually we can use `ParameterType` but i just left `...args` because sometime i work with type subclass and i don't know how to handle it
This is one possibility since the number codes for the AST nodes differ with TS v2 vs v3. &amp;#x200B; May I suggest using console.log or setting a breakpoint? See if the rule is being ran, if not check tsconfig / tslint.json if so, debug deeper in the walker. &amp;#x200B; If this doesn't help feel free to .zip or .tar your project &amp; upload it somewhere &amp; I will take a look!
Great and thanks for the bug report.
Depends on what you are doing, if you are selling something online, having a 5% drop to sales because of bad javascript is not optimal.
Using JS docs for type-checking? Yeah why not
`request-promise` and `request-promise-native`. But I just use `node-fetch`.
Because it's even less type-safe than TypeScript. For example the types `null` and `undefined` (available only with enabled `strictNullChecks` feature) are not supported. And that's a feature I'd definitely not want to miss anymore and makes my daily work in C# painful. https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript#patterns-that-are-known-not-to-be-supported
You already got many great answers to your question, so I want to add a suggestion that is not directly answering your question. You should at least consider following a more functional approach by simply not every throwing an error or rejecting a promise (and wrap existing libraries). Instead you would use something like a `Result&lt;TData, TError&gt;` or `Either&lt;A, B&gt;` structure and make use of ["Railway Oriented Programming"](https://fsharpforfunandprofit.com/rop/) (link has examples in F#). The basic premise is: - You have a `Success&lt;TData&gt;` and `Failure&lt;TError&gt;` structures. - You have a union-type `Result&lt;TData, TError&gt;` which is either `Success&lt;TData&gt;` or `Failure&lt;Terror&gt;`. - If your method successfully completes you return the `Success&lt;TData&gt;` object. - If your method has an error you return the `Failure&lt;TData&gt;` object. Don't throw an error. - You write and use a special `map` function, which takes a `Result&lt;,&gt;` object as first argument and a callback accepting the `Success&lt;&gt;` object as first argument. That map function will then check if your `Result&lt;,&gt;` is a `Success&lt;&gt;` instance and call the callback, or if the `Result&lt;,&gt;` is a `Failure&lt;&gt;` it will simply re-return that failure object. - Lastly you have an `onError` function that will accept the `Result&lt;,&gt;` and a callback accepting a `Failure&lt;&gt;` argument. It will check if the object is a failure and only then call the callback. I like this pattern more because it clearly shows in your API what error could be returned from your function, instead of having magical `throw`s somewhere deep inside the function callstack. It will also force the developer to recognize and care about the possible error case, because otherwise you can't access the value stored in the `Success&lt;&gt;` type. There are already various implementations of this pattern out there. Depending on the implementation it could look something like this pseudo-code: function getUser(userName: string): Result&lt;User, UserNotFoundError&gt; { ... } function deleteUser(user: User): Result&lt;undefined, MissingAccessRightsError&gt; { ... } const userNameToDelete: string = 'admin'; getUser(userNameToDelete) .map((user: User) =&gt; deleteUser(user)) .map((_: undefined) =&gt; { console.log('User deleted successfully.'); }) .onError((error: UserNotFoundError | MissingAccessRightsError) =&gt; { if (error instanceof UserNotFoundError) { console.log('The user could not be found.'); } else if (error instanceof MissingAccessRightsError) { console.log('You are missing the required rights to delete users.'); } else { // Unknown error, what to do? } });
ðŸ˜±
I'm not saying I disagree, but it's a nice low-barrier-of-entry way to get started, and you can do it in vanilla Javascript. Also, C# has these `[NotNull]` things, right? For Resharper or something? I dunno, I'm not a C# dev.
They barely count TBH. All they are is hints to the R# static analysis engine. I suppose it's probably possible to tie R# analysis into your CI pipeline and fail elevate nullability warnings to errors to fail the build, but I've never heard of doing that. It's also pretty rare to see people actually put in the effort to annotate their code with the R# attributes (I've never seen it outside of my own usage), and of course R# is a paid tool that many C# devs don't even use.
Interesting, thanks for the input! This is probably more work than we need right now but it's a cool concept for sure.
Can you point me to information about `ParameterType`? I did not find anything searching. I want to make sure I am up to date on proper arguments type handling. I have been using constructions of this form: `type ConstructorType&lt;T, Args extends unknown[] = any[]&gt; = { new(...args: Args): T }`
sick topic
The "render props" pattern is an example of the situation I'm trying to describe: [https://reactjs.org/docs/render-props.html](https://reactjs.org/docs/render-props.html) If the parent component, in its implementation of the "render prop" for its child component, uses any of its own props/state to affect the outcome of what it chooses to render, then pre-caching/binding that function can cause the rendered output to remain stale (if no other props passed down the the pure child component have changed).
Hmm that's sad. Languages that cannot express nullability should just die already. I like how Typescript (and Swift/Kotlin) have strict null checks.
I know this is a discussion about TS, but after seeing your comments about C# (and the responses) surrounding issues with \`null\`, I thought I'd share an exciting proposal for an upcoming C# version that I can't wait to start using: [https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md](https://github.com/dotnet/csharplang/blob/master/proposals/nullable-reference-types.md) &amp;#x200B; Further reading: [https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/](https://blogs.msdn.microsoft.com/dotnet/2017/11/15/nullable-reference-types-in-csharp/) [https://msdn.microsoft.com/en-us/magazine/mt829270.aspx?f=255&amp;MSPPError=-2147217396](https://msdn.microsoft.com/en-us/magazine/mt829270.aspx?f=255&amp;MSPPError=-2147217396)
Implement a toy interpreter for the lambda calculus. 
Yes, exactly this. This is not a perfect solution, but it works for me really well and I hope it will help someone
As a side note to this question, I found it really helpful to have learned Go (golang) before I started TypeScript. It really helped with the type specifier order.
Honestly, and this is just my opinion, this is where I check out from Typescript. Once I need to write a book for the next guy looking at my code to understand what is happening, Typescript has lost its usefulness. Put an **any** on it and move on. I love typescript for 90% of usecases, but it simply isn't mature / advanced enough for complex cases like this, and honestly just reading this article gave me a headache and would cause me to waste an hour trying to fuck with it instead of writing code. I've had to adopt the same attitude for certain mobx parts and higher order components. Someday TS will hopefully be good enough where it just works for cases like this as well. It's already made huge strides.
I'm on mobile, but IINM, class methods aren't bound to the class. You have to use a property assignment and an arrow function: `private runBinOpsExpression = () =&gt; {}`. 
Yes, that's true. You also need to adjust the return types of the function that actually implements the checks. I would suggest to use Union Types for this.
what keyboard is that ?
And this should be used with caution. The TypeScript compiler will not make sure that the declaration and the implementation match each other.
Correct, I'm expecting runBinOpsExpression to refer to a class instance. Sorry I didn't provide a better/smaller code example.
Without a runnable example, stacktrace nor error, I can only guess what the issue is and where it might go wrong. What about `this.classMethod`? Shouldn't that be `() =&gt; this.classMethod()` or `this.classMethod.bind(this)`?
That was hypothetical pseudo-code. There are several libraries out there. A random one I found just now is https://github.com/gigobyte/purify.
If someone else defines global.Window.data as a string somewhere else in the code later, they will not get an error in your second example. In the first example they should get an "property declarations must have the same type" error (if i remember correctly).
`any` still forces arity checking, so it doesn't really work.
#1, just as mentioned here https://twitter.com/WrocTypeScript/status/1048280618419834880. 1. It describes your actual environment correctly (doesn't hide anything that's actually there). 2. Once `Window` is augmented, your update will be available everywhere without having to drag your custom `WindowWithData` interface everywhere. 3. You get to avoid the type cast.
+1 for option 1. My team is currently using this method in production to feature detect window.MSInputMethodContext which is only ever defined on the window object by IE11. 
Thank you for the advice. Is it considered better practice to define such such a global interface augmentation in a `globals.d.ts` file, or within something like `App.tsx`?
You can actually reopen the window interface and modify it by reusing the name `Window` for the interface.
I've come to the conclusion that it's better to store such an interface in a `globals` typing file.
Not sure if this is exactly what you want but if you have a `types/my-global.d.ts` with: declare global { const myGlobal: MyGlobal } Then you can use it in a .ts file: /// &lt;reference path="types/my-global.d.ts" /&gt; const a = myGlobal.whatever() 
Do this in your app entry point (main.ts? index.ts?) And you only have to reference it once. Then it is global
Perhaps avoid the import statement and use the new `import()` type syntax. `type Foo = import('foo').Foo`
thanks for this article, but why is it in the under typescript thread? I do agree with other people here that a demo showing performance measurements would have been useful.
Got it. That does sound cleaner to me. Appreciate the advice!
Thanks, that was actually really helpful to see the source definition like that. ðŸ™‚ Cheers!
Thanks for your effort! It did make some sense, but I'm having difficulty understanding the different circumstances or scenarios where it would occur that we get different types for our expected error types. Maybe you have a simple example? Or a non-simple one? â˜ºï¸
This precisely solved my problem! Thank you. (We're on 2.9.1 so can take advantage of this). I was completely unfamiliar with this feature. Is this the new idiomatic way of importing types? Is there any benefit to using this in other places of the codebase? (I'm reading about it now but curious to hear of stories in production.)
Got it. Thanks!
Got it. Thanks!
Maybe it's my Webpack environment but I don't even have to do that `/// &lt;reference /&gt;` thing. Is everyone else doing that for their globally defined types?
That's what I do as well. One `.d.ts` file that describes all global variables.
it's just typo mistake, here is what i copy from lib.es5.d.ts but i'm not sure how it works: ```ts /** * Obtain the parameters of a function type in a tuple */ type Parameters&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: infer P) =&gt; any ? P : never; /** * Obtain the parameters of a constructor function type in a tuple */ type ConstructorParameters&lt;T extends new (...args: any[]) =&gt; any&gt; = T extends new (...args: infer P) =&gt; any ? P : never; /** * Obtain the return type of a function type */ type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (...args: any[]) =&gt; infer R ? R : any; ``` 
\&gt; delayedIncrement(new ObjectValue(person, "score")) &amp;#x200B; Should be \`delayedIncrement(new ObjectValue(person, "name"))\` ?
Yes, for the example which fails type-checking, well spotted!
The first version works if you disable type checking inside `delayedIncrement`. Which could be acceptable, since it is so small. type NumberPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends number ? K : never }[keyof T]; function delayedIncrement&lt;TObject, TKey extends NumberPropertyNames&lt;TObject&gt;&gt;(object: TObject, key: TKey) { const oldValue: any = object[key]; setTimeout(() =&gt; object[key] = oldValue + 1); }
Learn html canvas and make a game. Here is a Tetris game I made in Type script https://camccar.github.io/tetris/ And the source https://github.com/camccar/tetris 
Not sure what you're getting at here, the code is properly formatted as far as I can tell, using markdown.
Apparently the new Reddit design supports markdown, so my bad. I'm still using the old Reddit design, because the new one sucks ass.
You do know you're gonna get sued by Blizzard?
Sure, disabling type checking or spreading some 'any's about will make it work; the point of this exercise is to add type-safety to something that already works, but is fragile. Incidentally, `delayedIncrement` was only a trivial example function to demonstrate usage - yeah, at two lines long it would probably not be worth the effort to make type-safe!
The stuff in [here](https://www.typescriptlang.org/docs/handbook/advanced-types.html) is where TS gets really interesting. How much do you know about templates?
Write yourself a custom type-guard and use that.
You can use `in` operator ```typescript type UserRequest = { foo: string, bar: number } | { baz: number } declare const request: UserRequest if ('foo' in request) { request.foo request.bar } if ('baz' in request) { request.baz } ``` [playground](https://www.typescriptlang.org/play/#src=type%20UserRequest%20%3D%20%0D%0A%20%20%20%20%7B%20foo%3A%20string%2C%20bar%3A%20number%20%7D%20%7C%20%0D%0A%20%20%20%20%7B%20baz%3A%20number%20%7D%0D%0A%0D%0Adeclare%20const%20request%3A%20UserRequest%0D%0A%0D%0Aif%20('foo'%20in%20request)%20%7B%0D%0A%20%20%20%20request.foo%0D%0A%20%20%20%20request.bar%0D%0A%7D%0D%0A%0D%0Aif%20('baz'%20in%20request)%20%7B%0D%0A%20%20%20%20request.baz%0D%0A%7D)
http://albertwu.org/cs61a/notes/environments.html
Appreciated, cheers!
 Idk if you care about updating it anymore, but if you spam for instance the left arrow key before the block spawns, it doesn't actually spawn and appears to go to whatever would have been next :) pretty cool otherwise
You can use a simple generic type guard that checks for null and undefined: &amp;#x200B; \`\`\` function throwsErrorSafe&lt;T = any&gt;(value: T | null | undefined): value is T { if(value === null || value === undefined) { throw new Error("value is not defined"); } return true; } \`\`\`
sorry if I wasn't clear, but I want to use something like this: &gt;function throwsError(foo: number | null): number { assert(foo); // this should throw error, so foo should come out like number return foo + 3; // object is possibly null } I mean, I had legacy code that worked like this, is there any way to make it work in typescript
You could have a look on the Typescript track of [https://exercism.io/](https://exercism.io/). 
It isn't perfect, but you can make the first one work with an exclamation mark after foo on the return statement. However, that is not optimal if you are referencing foo many times after the assert. To really get what you're going after TypeScript would need to be upgraded with a way to type exception cases. But it cannot do this yet. function assert&lt;T&gt;(value: T | undefined | null): throwsif T is undefined | null { // ... }
I don't know if there's a way to make the first case run well, but you could do something like this: ```ts function throwsError(_foo: number | null): number { const foo = myAssert(_foo) return foo + 3 // foo is a number } function myAssert&lt;T&gt;(foo: T | null): T { assert(foo) return foo as T } ```
[https://www.typescriptlang.org/docs/handbook/generics.html](https://www.typescriptlang.org/docs/handbook/generics.html)
Lol you actually played it. Yeah it's just a prototype. I would update it but I'm rewriting in in Rust right now anyway. 
The interface itself is completely type safe.
I edited the answer, please check again
yeah this is better, I guess is the closest we have right now, hope typescript adds a way to handle these cases
ts-node ftw
Try to properly type a React app with Redux And god help you on this journey
Start learning all of the cool, [advanced](https://www.typescriptlang.org/docs/handbook/advanced-types.html) things you can do with a strong type system. Things like literal types, [discriminated unions](https://basarat.gitbooks.io/typescript/content/docs/types/discriminated-unions.html), type guards, [phantom types](https://medium.com/@gcanti/phantom-types-with-flow-828aff73232b), and [mapped types](https://blog.mariusschulz.com/2017/01/20/typescript-2-1-mapped-types) can greatly reduce the errors that are representable in your program. Plus doing type-level programming is fun
Why the Babel dependency when tsc already transpiles all the way down to es3? 
Typescript doesn't transpile EVERYTHING. Every time this question comes up, I try to find some authoritative reference on what works and what doesn't, but.. a simple example is "Array.fill" which exists in ES6 but not ES5. You need a polyfill, which babel will provide but Typescript will not. Here's an old related github issue: https://github.com/Microsoft/TypeScript/issues/3101
No there isn't a way to do this. If you want to track the issue that proposes your behaviour see [here](https://github.com/Microsoft/TypeScript/issues/8655). The best alternatives are to the one you propose, or the definite assignment assertion `!`.
If the [block scoped type assertion statement ](https://github.com/Microsoft/TypeScript/issues/10421) gets added then this could become optimal. You would just have to add an type assertion after the assert call
I completely missed that this issue got closed... I've been waiting so long for this. It's a shame, really. Again "design limitation" due to a btochered architecture.
What does it do? Maybe sounds like stupid question to some, but I've only started programming typescript and js/node backend this year. Coming from the PHP world where a lot of this kind of stuff doesn't exist as much. One thing I've noticed with a lot of NPM packages and JS libraries in general, is that the description of what they do can be a bit sparse, and often assumes you know some terminology. Might be helpful to explain what it does on the README.md? And maybe what makes it different from other things that might sound similar? 
I never really dig into why, but ng update never works on both the projects Iâ€™m working on ( ng cli and nx ) I always go for yarn upgrade-interactive â€”latest 
I sometimes make the type guard return the input value instead of returning a boolean. Then I save the returned value in a variable. It's not quite the same but it achieves the desired effect. This was inspired by the `never` type which can indicate that a function never returns. (it throws an exception). I realized that if the function *did* return, it's because it didn't throw, because the type guard succeeded.
^ came to say this
I tried to keep it simple and don't make it dense full of terms and definitions, writing is not my best skill. I will improve the readme with some description and why i did it. Thanks for the suggestions.
Or just switch to React 
Not a solution but your return type is number | never I guess. Maybe you can write your own? assertFoo = &lt;T&gt;(o: T) o is T | never =&gt; assert(o)
&gt;assertFoo = &lt;T&gt;(o: T) o is T | never =&gt; assert(o) do you have an example of this ?, I can't make it compile
What does it do? There is no description what problem it solves and how it solves it.
it still shouldnt be a dependency though, right?
I thought maybe they were using it in the build tool but you may be right as it's not needed. Looks like everything is a production dependency even the types
Iâ€™m not sure the exact implementation but your on the right path. A while ago I was looking to write a tsc plugin the converted js to typescript. The main purpose was to help with an angularjs to Angular conversion. I ended up with a solution the leverages eslint rules and wish I had go with a compiler plugin
Really wish typescripts developer documentation for the compiler API was better, they list only programmatic examples but no working implementation examples.
You can't plug into or modify TypeScript's typechecking behavior. So I don't think this will be possible.
Can't believe typescript doesn't offer some API to alter the AST. &amp;#x200B;
Correct, that's why i said i have a partial solution i will run the transformer to get the correct ouput however i need to use something else to get the correct TYPE output
It *does* offer an API to alter the AST. But typechecking and language services are way more complex. For example, it needs to be able to detect type errors, propose quick-fixes, and if the user clicks the button, send the quick-fix as a series of code edits (insertions and deletions) to your editor. That wouldn't work if you had pre-modified the AST before typechecking occurred. It's actually a two-way street between source code and the AST. The AST is used to drive source code modifications. If you want to write your own quick-fixes, or filter or augment tooltips or code completion entries, it has a good API for all of that. And if you want to transform the AST and then convert the modified AST back to TypeScript, it has a printer to do that. You could even wrap it up as a quick-fix. But you cannot pre-modify the AST before typechecking. Also keep in mind that the AST is immutable, which (I believe) allows TS to reuse unchanged parts even as the source code changes and attach long-lived type info to the AST nodes. The compiler's job is more complex than it initially seems.
I'm not quite following, my knowledge of how the typescript language service works is extremely limited i know almost nothing about compilers. However surely surely when you say "And if you want to transform the AST......" ... "It has a printer to do that". That's what i want i want to change the AST so that when it see's (prarphasing because i have no idea what the actual nodes are) underscore identifier i want to change it to a call expression. So what you're saying is i cannot change the AST And have it Type check? - If i can just have it type-check that's all i need because i can easily use 1 of 100 tools to change the transpiled output i don't care about that i just need my underscore syntax to type-check in typescript.
What happens when the language service proposes a quick-fix to modify the call expression, except the call expression doesn't actually exist in the original source code because it was generated by your transformation logic? What happens to the code edits it sends to the editor? Are the character offsets correct?
&gt;import assert from "assert"; function throwsError(foo: number | null): number { assert(foo); // this should throw error, so foo should come out like number return foo + 3; // Error: object is possibly null } Sorry I was on the pooper when I wrote that: Here's a link to demo [https://www.typescriptlang.org/play/#src=function%20assert%3CT%3E(o%3A%20T)%3AT%20%7C%20never%20%7B%0D%0A%09if%20(typeof%20o%20!%3D%3D%20'number')%20%7B%0D%0A%09%09throw%20new%20TypeError('Invalid%20o')%3B%0D%0A%09%7D%0D%0A%09return%20o%3B%0D%0A%7D%0D%0A%0D%0Afunction%20throwsError(foo%3A%20number%20%7C%20null)%3A%20number%20%7B%0D%0A%20%20assert(foo)%3B%20%2F%2F%20this%20should%20throw%20error%2C%20so%20foo%20should%20come%20out%20like%20number%0D%0A%20%20return%20foo%20%2B%203%3B%20%2F%2F%20Error%3A%20object%20is%20possibly%20null%0D%0A%7D%0D%0A](https://www.typescriptlang.org/play/#src=function%20assert%3CT%3E(o%3A%20T)%3AT%20%7C%20never%20%7B%0D%0A%09if%20(typeof%20o%20!%3D%3D%20'number')%20%7B%0D%0A%09%09throw%20new%20TypeError('Invalid%20o')%3B%0D%0A%09%7D%0D%0A%09return%20o%3B%0D%0A%7D%0D%0A%0D%0Afunction%20throwsError(foo%3A%20number%20%7C%20null)%3A%20number%20%7B%0D%0A%20%20assert(foo)%3B%20%2F%2F%20this%20should%20throw%20error%2C%20so%20foo%20should%20come%20out%20like%20number%0D%0A%20%20return%20foo%20%2B%203%3B%20%2F%2F%20Error%3A%20object%20is%20possibly%20null%0D%0A%7D%0D%0A) &amp;#x200B; I don't think you even need to write a new function - you could probably create .d.ts to re-type assert &amp;#x200B; // assert.d.ts \`\`\` declare module 'assert' { export function assert&lt;T&gt;(o: T): T | never } \`\`\`
You may need to include it explicitly in your tsconfig and exclude the assert module - 
I'm pretty sure that's by design, as they don't want the overhead of supporting it!
Readme improved!
Not sure if its helpful, but https://github.com/cevek/ttypescript/blob/master/README.md is my bookmark for "some nontrivial complier plugins to learn from". Your project sounds cool, would love to see it if you get it all working.
Yeah, iv'e had a look at ttypescript it was the first thing i started looking at was the typescript transformer documentation / api. Typescript transformers can be used (i believe) to turn \[1,2,3\].map(\_ + 5) into \[1,2,3\].map((x) =&gt; x + 5) but it cannot be used to tell typescript that this underscore "\[1,2,3\].map(\_" is of type number and when evaluated gives back a function.
Counterintuitively, this is the wrong metric to consider. If you have an application already, you've worked most of the bugs out by testing (automated and manual), so a type checker is unlikely to find many more. The real value of a type system is in new code, which you can write more quickly because you discover the new bugs as you write them.
I'm not looking for a metric. You're talking about a perfect world, where the applications are well tested. But it's not like this and I'm sure someone out there had found out a bunch of bugs with the help of TS. 
Haha what? That should seem like a reason to *stick* to the commitment so all the bugs can be ironed out? Seems like they're doing it wrong to me.
Yeah, they know, but they didn't expect it to take this much time so it was pushed to later since they have more urgent stuff to deal with. I wonder if they already do it by now.
In my experience you always find plenty of unknown bug when porting to ts. 
Nothing fundamentally broken (or otherwise the JS version would not have worked) but plenty of silly stuff that kinda slips through or works because JS weirdness. Undefined values, missing parameters, extra parameter, missing return values in branches, mixed return types and that sort of thing.
I dunno, we discovered and fixed plenty of real bugs. Tests aren't perfect and not everything has coverage anyway.
Ah okay, that makes much more sense. ðŸ˜Š
The bugs are removed not by migrating to type system, but by using this type system to **make illegal states unrepresentable**.
Hail to that! 
I've been working in typescript for 4 months now. Everyday I long for pure js. 
I've been working in TypeScript for six months. Now I think that working without a type system was a madness. 
6 man-months worth
Code has become a lot cleaner. Using TS in backend for 8 months. 
Are you using strict mode? I know most people seem to think it's necessary, but I found it just added lots of boiler plate for 3rd party libs in particular. So we don't use it! For me, the biggest value of typescript is as documentation on a large shared codebase. Plus some minor mistakes like mistyping variables and properties is a thing of the past.
Yeah I use strict mode. I like it for documentation once all things are said and done. And I'll admit having a souped up editor is nice too. But I find that properly validating objects goes out the window because people wrote types and forget that things at runtime especially at the data entry points won't necessarily conform to your definitions. Also you see a lot less option objects and have functions that have lots of arguments because typing is easier, but I find that difficult to follow. And the endless amount of configuration breaks my balls. Oh object,entries doesn't exist, change target or add a lib, oh now it's incompatible with another library or jest stopped working. Got to modify that dependency. Want to write a module? Why isn't the declaration file being produced ? Got to go modify tsconfig Again. Oh there's a typescript update that lets you infer types? Neat! Now your project is broken but you can fix it by changing some more configuration. Also rarely but sometimes the type system gets confused and you have to change your code slightly even though it was perfectly valid. Oh and sometimes with ts-jest the debugger is a little off and won't break where you tell it to, or variables aren't defined because the it sees the names that the compiler gave and not the ones you wrote in the source. Don't get me wrong I love static languages. Golang is my favorite language. But typescript is a static language that works 90% correctly. But has no strength of its own as a language except making the strength of node more accessible to java or c# devs. Sorry for the rant. I just really hate working in typescript. I thought I would get used to it. But I just hate it. 
Lots of missing null guards, lots of dead code, and lots of unused variables.
Sorry, I wasn't clear: TS in my experience has also found bugs in newly translated code. But usually people ask questions like the OP's after they port a large code base to TS and say "eh only found like a handful of bugs, it doesn't seem worth it", and I was anticipating that response and responding it.
Why does it have to be a video? Just give me a source code file
Oh, Id never go back to plain js, regardless of the found bugs. Having types makes refactoring and general development so much easier. 
I'm not a fan of ts-node and tools that rely on it. I had issues with misses break points and indeterministic code coverage reports. I ended up just compiling to JS and debugging the compiled JS. With source maps enabled, you're able to debug the actual TS his way. And test coverage becomes deterministic. I avoid issues with the tsconfig by using Microsoft's official starter file (TypeScript-Node-Starter) and to be honest, just having spent some time RTFMing the main website. It eventually starts to make sense. I was very iffy on TyprScript at first, especially when I had to use it on a React project, but I've come to love it. I feel really weird and uncomfortable coding plain JS now.
Although I just did that huge rant I feel you. I managed to convince my coworkers to let me write a small proxy server in pure js, and after 4 months writing typescript it is weird. But it's nice because I don't have all the bagage. I don't have build steps, i don't have frameworks with decorators and all sorts of stage 2 proposals in it. Heck I'm not even using express. It is much easier to just experiment with ideas and not just fall into a OOP mind set off the bat. I don't hate everything about ts, and certain projects at a given scale do benefit. I will try running tests off of the compiled js. That sounds like a good idea to me. Thank you for that 
Hey, thanks for the feedback I'll make sure to post the sample code along with the video next time! Sorry for the inconvenience
It just mean no one noticed the bug yet.
Are the instructions for enabling this in CRA launch the same as enabling it for the branch?
Awesome!
Yeah I understand. But in practice idiomatic typescript seems to go the way of OOP. A lot of what comes out is based on classes as types. It's not that you can't do something in typescript. It's just not idiomatic. I don't have any preference for fp over oop or even the never mentioned pp (procedural programming). But I just find typescript limiting stylistically if not absolutely 
YESSSSS FINALLY &amp;#x200B;
But if it doesn't break anything when js didn't care about typing, was it really a bug?
Can i get my hands on this now somehow?
I agree it's idiomatically OOP. You see a lot of examples out there using classes, probably because of features available by using classes that aren't available without them. I actually ran into this issue at work where my team has a style guide of not using classes or the \`this\` and \`new\` keywords. I have trouble using IDE tools like "find all references", because the code we produce ends up being functions that produce objects. It's great for immutability, but there's no way to trace the references back to classes because everything is always a brand new object with some things copied over into it. So classes allow you to use IDE tools that map out your code. Since my team cannot use classes, a workaround for interfacing with the multitude of 3rd party libraries out there that do use classes is to create wrappers around them with our functional style. I feel that this is wasted effort and hurts readability, but I have not yet been able to convince them to stop this practice. So at the end of the day, it's true that you're in control of your code and you can choose to write 100% class-free, OOP-free code. But you will likely have to make lots of adapters to work with NPM modules, since Node projects end up relying heavily on NPM anyways. If you want OOP-free, you might have to make the jump to a language that explicitly forbids OOP.
I guess this means the react scripts ts package is going to be made obsolete soon
I'm sympathetic to your general point but I've had great experiences with CRA. Doesn't introduce bloat as much as automate compilation, linting, etc. There are some occasional annoyances, for example in CRAv1 you couldn't import code that used ES6 features if I recall, but they fixed that in v2, and those types of issues tend to be pretty few and far between.
Hey dude, thanks for creating these videos! Would be really interesting to see more advanced Typescript tutorials in the same vein ðŸ‘
/u/joshribakoff Thanks for making this video. I would suggest a correction. Around 50 second mark: https://youtu.be/hoACSjXP3_U?t=50 you said "And that is considered by Typescript". This is in incorrect statement to say because `const pp` never had type guidance at that point. Either should should have typed `const pp: IFood` or `const pp = {} as IFood`. Just my 2 cents. I encourage you to make more such videos. Advanced would be better, as I think there is a void there. There are not enough videos that does advanced TS. And this is a good opportunity.
There is a difference. `react-scripts-ts` uses `tsc-loader`, which is supposedly faster and more original.
Yes - the contributor wrote a guide at the bottom of the PR description ; Clone git clone git@github.com:brunolemos/create-react-app.git cd create-react-app git checkout next-typescript Compile yarn Create Link cd packages/react-scripts/ yarn link Create New Project cd ~/your/projects/folder npx create-react-app app-name cd app-name Use Link yarn link react-scripts Setup TypeScript Follow the steps from the readme: Adding TypeScript Finish yarn start
Explicit public says "I was thinking about this and made a conscious decision that this is a member consumers of my class should use". 
&gt; The default should have been private. Amen.
My thoughts exactly. I would also love to have the final keyword (or actually the inverse, so final is default). Share nothing by default, state intentions otherwise.
This mathematical terminology: a "type" is a set of all its possible values, e.g. `boolean = {true, false};`. Now union of types T and U is a set consisting of values in T _or_ in U (i.e. T merged with U); similarly intersection of values in both `T` and `U` (i.e. common part of them). A member is accessible iff it's on *all* possible values. For union, value of type T|U may be T or may be U. We don't know which so only common attributes are legal. As you can see, operation on **type** implies different but complementary operation on **members**. This is a consequence of de Morgan laws.
Think from the perspective of what a union type accepts. The set of things that can be assigned to a string | number field is the union of the set of all strings and the set of all numbers. The set of things that can be assigned to a string &amp; number is nothing because there is no overlap in the set of all strings and the set of all numbers. I think you're picturing it as a set operator on the fields rather than a set operator of the sets of what each type represents.
Yeah that was one of my main arguments for using public. However, the other party that argumentet for implicit public didn't buy it. So, I'm looking for something more now.
&gt; I think you're picturing it as a set operator on the fields rather than a set operator of the sets of what each type represents. This is exactly what I think my problems was (is). Thank you!
Starting point: a type is a set of values. So boolean is the set {true, false}, number is the set of all numbers. The bit where people get confused is for objects. The set of values for an object type are not just those with *exactly* those properties, but any unrelated properties too. The set is defined by the behavior when accessing an object. For example `{x: number}`. The values in the set of this type are those objects with an `x` field that holds a number, but note, this does not say anything about all the other fields. So `{x: 4}` is in the set, so is `{x: 5}`, but equally, so is `{x: 4, y: true}`. When you do an intersection type you are never actually adding members to the set of values, they were there all along. What is really going on is that you are adding constraints. Example: Type: `{x: number}`. A set respecting that type: `{ {x: 4, y: true}, {x: 4, y: false, z: "hello"}, {x: 4, z: false} }`. Type: `{y: boolean}`. A set respecting that type: `{ {x: 4, y: true}, {x: 4, y: false, z: "hello"}, {y: false, z: true} }`. The intersection of those sets is: `{ {x: 4, y: true}, {x: 4, y: false, z: "hello"} }`, so we have constrained the set by making it smaller. 
That's neat! Does it work only with `class` or also with `interface` and `type`? Can those be mixed, i.e. have a matcher with one `class` and one `interface`, provided they share the same discriminating field?
Good question - hadn't thought of that! This does indeed work as long as the `interface` and/or `type` have the discriminating fields: class Class { readonly kind: "class"; value = "foo"; } interface Interface { readonly kind: "interface"; value: string; } type Type = { readonly kind: "type", value: string; } const match = createMatcher("kind", { class: (c: Class) =&gt; c, interface: (i: Interface) =&gt; i, type: (t: Type) =&gt; t }); const foo: Interface = { kind: "interface", value: "baz" }; // Returns "baz" match(foo, { class: c =&gt; c.value, interface: i =&gt; i.value, type: t =&gt; t.value });
What am I looking at here?
Why should I change your mind?
Because you're a TS holding the view that TS much more than keywords thus just got triggered by the title so I can make my fun of it.
pls :D
Well, you are more or less right. Some keywords and a transpiler to remove them.
i've been thinking the same thing! glad someone brought it up and we get these good explanations.
The results after the Ballmer peak. https://xkcd.com/323/
Is it useful in some way? Care to elaborate? It doesn't seem to do run-time type-checking, or am I wrong?
It might help to also think of some related terms: _sum types_ and _product types_. A union is a form of sum type, while a traditional object is a product type. The terms sum and product here refer to the number of possible distinct values the type can represent. For example, a union of a `boolean` (two values) and a `byte` (256 values) can store a value from one or other type, so either one of two boolean values or one of the 256 byte values, for 2+256 = 258 distinct values. Note the `+` making it a _sum_ type. A class that has a `boolean` field and a `byte` field is a bit different. For each of the possible 256 values in the byte field, there could be either true or false in the boolean field. Since we're counting total permutations that can be represented by the object's fields, you get 2*256 = 512 distinct values. Note the `*` making it a _product_ type. The product type can be a little more obvious since that's ultimately all an everyday integer type really is: a product of some number of bits. A byte is just eight bits, for 2^8=256 possible values, just as if you had an object eight booleans. Likewise, an object with four byte fields can store just as many distinct values as a single 32-bit integer (aka four 8-bit bytes) which is the same as 32 boolean values (i.e. bits).
No. There are syntax differences, too. For example, &amp;#x200B; \`const a: string = 'foo';\` &amp;#x200B; is impermissible syntax in JavaScript. Accordingly, TypeScript is not just JavaScript + other keywords.
I don't think it's complex. It's the opposite, actually. "You can await anything" is the opposite of complex. "You can await promises, but you cannot await non-promises" is more complex, and needlessly so.
Think about it this way, you can wait on your friend, whether he's always on time or if he's lazy.
Well, it can do anything you want â€“ even define a getter-setter pair with runtime type checking. The point is that this is a type-safe way to pass type information to runtime. In previous versions of TypeScript, if you wanted to achieve something like this, you just couldn't. In my project I'm using it to create a UI to edit properties of a class and the types are used to render the correct input (eg \`type=date\`, \`type=url\` etc.)
A type-safe way to pass type information to runtime.
How is this different to runtypes, or io-ts, except attached via decorators? 
It's resembles a way to represent non-empty linked list, but you have array and LL mixed up
Why not just declare these as types of number, date, string etc instead?
In terms of syntax, that's explicitly a design goal of Typescript to introduce as little syntax as possible on top of javascript. In terms of what it accomplishes, it statically analyzes your code at compile time to make sure that the types of values you are using are what you expect. On top of removing the need to do unit tests on object structures or value types, it also provides services to make it dead simple to refactor code. If you remove a property from a type, you'll get an error at compile time showing you where this breaks things, instead of waiting for it to occur during unit tests or during runtime. If I rename a property on a type, it can automatically propagate that name change to all correctly typed uses of that property. Furthermore, it allows you to specify different targets for compilation. This makes it so that you can use many features (including syntax) introduced in newer ECMAScript versions, and the code will be transformed to work in environments which only support earlier ECMAScript versions. &amp;#x200B; Side note: it's nice to see grade school children like yourself show an interest in discussing programming topics. Keep it up! Computer science is the future!
Y so serious? yep, just showed that the static code analysis still has its flaws. and tbh, quite stupid to write unit tests for object structures. TS with its language server is not the first tool analyzing your js code.... just refer to my other comment 
Can you explain the "flaws" you speak of? All I see is that Typescript doesn't get confused by your purposefully human-confusing yet perfectly valid names. Also, writing unit tests for object structures is a very common practice in large JS codebases without static analysis. I did not say or imply that Typescript was the first tool for JS analysis. I was just describing what Typescript accomplishes over Javascript alone. Why would typescript care if I had a property called `true`? It's not like I'm going to accidentally mistake `this.true` with the value `true`. If you can have a property named `true` in JavaScript, it'd be irresponsible for TypeScript to prevent you from representing it. These "keywords" you speak of only have meaning in certain contexts. 
It's all good. I'm just saying that what you've depicted is not a flaw and is actually a feature: Typescript doesn't doesn't care what you name these things as long as it is valid to the contextual grammar. It would be odd for them to complain about these names because they're not used the same way as keywords. Specifically because all of these property names are really strings, not keywords. It's not up to typescript to tell me I shouldn't do this: class MyParserFlags { public: boolean; private: boolean; protected: boolean; static: boolean; class: boolean; type: boolean; interface: boolean; const: boolean; if: boolean; while: boolean; do: boolean; extends: boolean; undefined: boolean; true: boolean; false: boolean; null: boolean; } &amp;#x200B;
You're right on that. but would be a nice to have, maybe optional with a compiler flag. and I hope you agree with me that you really should not do that :D
How is this typescriptâ€™s fault?
Can you fix your live demo hyperlink?
[Here you go.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
Because they fucked up. They decided to ignore the abstraction people are trying to utilize because they write compilers not consumer software systems
Good damnit!
well, I'd define a clase Photo which has a property "type" with the value PhotoTypes.Private. that way I don't need to define multiple classes doing the same thing. 
[removed]
You realize that the compiler already does this, right? Via the `--emitDecoratorMetadata` flag. You can achieve the same thing without using your type mappings. Just annotate your class properties appropriately and Reflect.getMetadata will get the type. And you can just rely on POTS to complain when you assign the wrong value instead of passing it to the annotation. Read [the docs](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata) for more info. function editable&lt;T = any&gt;() { return function &lt;C extends { [k in K]: T }, K extends string&gt;(target: C, key: K) { let valueType = Reflect.getMetadata("design:type", target, key); console.log("type: ", valueType ); } } export class People { @editable() // type: String public name: string = 'a'; @editable() // type: Date public birth: Date = new Date(); @editable() // type: Number public age: number = 'a'; // error @editable() // type: Url public homepage: Url = new Date();// error } &amp;#x200B;
Obviously you can have that opinion. You may even share that opinion with the majority. But it's not the responsibility of typescript to warn about this stuff, that's all. That's exactly what a linter is for [0]. Also, I was being snarky but I don't mean that it reflects your ability to read code, it's just my opinion that it absolutely shouldn't be confusing and if you need those warnings then you don't understand the language enough. [0] https://palantir.github.io/tslint/
&gt; The value is wrong, not the type... You have no way of knowing that
You've persuaded me. I actually found another example of a flaw in the TSServer: const myIds = [ 1, 2, 3, 4, 5 ]; They don't even allow me to set a compiler flag to warn against this confusing coding style. There's only two valid choices: // the best way is no-semicolon and comma-first, with PascalCase. const MyIds = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] // alternative const MyIds = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] // no semicolons, no multiline array definitions, extra space, and of course PascalCase &amp;#x200B;
The original link works for me. At least in Firefox...
github issue? I thought we'd write another ts-hating reddit article about it :(
Well, if you ever faced a problem where you need type information in *runtime*, you'd know that TypeScript purposefully hides all types from you. That means that if you program needs to make a decision based on the type of a property, you need to â€œhardcodeâ€ the type in a *non-typescripty* way. One thing that I've used in the past was creating a `Required&lt;T&gt;` instance of my class and filling it with sample values (empty strings for string type, zeros for number type, etc.). Then I could loop through the properties and check their `typeof` in runtime. Although this approach had compile-time type checking, I had to have all the properies doubled â€“ once in the class definition, once in the reference instance. Furthermore the approach wasn't extensible to union types. This way I have a compile-time type-checked way to achieve the same thing but more elegantly, and I only need to type the types twice (not the parameter name) and those are at the same place, not separated by many lines of code like before.
You can't accept it that I have different opinions, right? OK, let's continue: If it's not the compilers responsibility, why does TypeScript provides not only the compiler API but also the language API in a way that tempts devs to use it for such things? 
Okay now I'm confused. Why should someone else use the plug-ins we wrote specifically for our project? And how could we manage to pollute the compiler by using it's very own public API? And how would you call the code someone writes to extend the compiler for his own needs, if not plugin? 
Runtypes is a utility specifically for type-checking and can't do anything else. Furthermore (correct me if I'm wrong, please) both force you into defining the type with their special syntax and *then* using it to define the classes/objects/whatever. My approach is to make the code look as natural and comprehensible as possible, targetting only basic types (primitives and class instances) and only on class properties, which is my most frequent use case. Furthermore, as my code isn't a library, but rather *an approach*, consisting of only a few lines of code, one can adapt it to fit their needs. It could be used as runtime type-checker, as well as a property-changing UI control, or just anything you wantâ€¦
alright mate, so did you really assume that I'm going to create a PR of this? :D. in fact they already have plug-ins which are delivered together with the compiler. Even in C#, the roslyn compiler comes with a lot of rules/hints about best practices and conventions built-in. And since TS comes also from MS, why not for TS, too? 
Because TS is TS not C# and the compiler should not be worried about property names, a linter can take care of that if needed.
Yes, I know this exists, but haven't used it yet. Thanks for the working example! However, the specification mentioned it as â€œvery experimentalâ€ and while my code isn't critical, I use it in production, so I don't want to risk unnecessary bugs. What's more, I'm concerned about performance â€“ while it probably wouldn't have a huge impact, this flag would add runtime type-annotation to all of my classes, not just the ones where I need it. Do you have any experience with that? If so, I'd love to know more about that!
Just curious. You know that you can make use of the compiler and language api and extend typescript without pushing sth to the official repo? https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943
Yes, this is exactly what I am referring to. I am saying that they provide the plugin architecture so that they can say "No, we won't add [feature request X] to TypeScript, but if you really need it, make your own plugin and use it."
Well, it will only add the type metadata to any property which has any other annotation on it. I don't know how to prevent that in general, but it definitely won't have a performance impact. 
Dude I literally told you few posts ago that we wrote plug-ins using those API's instead of tslint and you just raged. wtf is wrong with you 
What I said after that comment wasn't in response to you using plugins; it was only in response to the fact that I disagree with your notion that using reserved keywords as property names causes confusion and it would be nice if there were a flag in the official tsc to warn against it.
omfg haha okay. one of the problems communicating online. alright man, need to get out, was fun :D
:T cheers
Awesome, thanks! I'll definitely reinvestigate this. Do type metadata support union types? If not, at least there I'm not reinventing the weel ðŸ˜‰ PS: Decorators are stage 2 ([they say](https://github.com/Microsoft/TypeScript/issues/4881#issuecomment-430028443) it's almost stage 3) in ECMAScript [proposals](https://github.com/tc39/proposals), metadata aren't even listed in there. That's another reason why I'm hesitant about using `--emitDecoratorMetadata`, which itself is another level higher over metadata.
&gt; you'd know that TypeScript purposefully hides all types from you. It doesn't hide that information. It simply removes it. And there's a compiler flag that will add those information back to be available at runtime.
Not sure why metadata would be listed - itâ€™s not potential language syntax
No, the metadata doesn't handle unions, I didn't realize yours did. That said, the `--emitDecoratorMetadata` is just the implicit application of `@Reflect.metadata("design:type", type)` with a reference to the annotated type in the type annotation. It's not really any different from rolling your own solution except it's used way more. The reason it doesn't work is that it can only infer a class or primitive type, not a union type annotation. In the cases where a union is needed, you can overwrite the metadata using a manual call to `@Reflect.metadata("design:type", [String, Number, ...])` with whatever types you want. The current type signature for Reflect.metadata won't complain about the types provided vs the type annotation though.
nit: I'm not sure it's possible to say TypeScript has algebraic data types because of structural subtyping. The inhabitants of the type: `type F = { kind: 'A' } | { kind: 'B' } ` exceed 2, which is not the case in Haskell: `data F = A | B`. I enjoyed the article, it's always nice to have comparisons between languages which expose people to new things The acronym ADT is very unfortunate and not to be confused with abstract data type. It's ironic that two things that are so opposed share the same acronym!
&gt; Runtypes is a utility specifically for type-checking and can't do anything else. Furthermore (correct me if I'm wrong, please) both force you into defining the type with their special syntax and then using it to define the classes/objects/whatever. Ye I think this is a reasonable summary. I think it would be possible to use a runtype construction in conjunction with the definition of a class, but it certainly does not come out of the box. &gt; My approach is to make the code look as natural and comprehensible as possible, targetting only basic types (primitives and class instances) and only on class properties, which is my most frequent use case. A fair goal, and I do think this does have a natural look to it. &gt; It could be used as runtime type-checker, as well as a property-changing UI control, or just anything you wantâ€¦ I'm afraid I don't really know what a property-changing UI control is. But yes I agree that this approach does not limit itself to type-checking. I would object (thought it's pedantic!) to your description of: &gt; A type-safe way to pass type information to runtime. I see it as the reverse. You are really constraining the types by dynamic information; the type of your object is decided by the values you pass to the decorator. The values are not discharged from the type.
I was wanting to do something similar to a project I was working on!! (in JS) I thought... "what I really want is a dom model for my ast", so I was converting the JS to XML and running it through this. parser = new DOMParser(); xmlDoc = parser.parseFromString(text,"text/xml"); I only did a few of the ast objects as a test, and never finished the tooling... My plan was to use it to be able to filter code in a dynamic way, to add prefixed/instrumented code readily. In any event, I could easily just construct the dom nodes directly, but js -&gt; ast -&gt; xml -&gt; parser -&gt; xmlDom -&gt; js was... adequate... for fiddling. 
True, but I guess I view it as abit of a partial definition if you donâ€™t have Cartesian products. Iâ€™m not sure what the actual definition is though!
This sounds like a job for a linter, whereas the compiler can and should allow it for maximum compatibility.
&gt; One benefit is that const enum values are inlined, so you avoid the performance hit of a property lookup when you use them at runtime. Ah, I had only sort touched on experimenting with how the compiler handles them. I had wondered why they weren't ever just a 'compile time' option never actually searched for that feature, sorta just assumed that what I saw was it. Most def. a good feature 
You can do pretty well /** Represents an array that has at least one element */ type NotEmpty&lt;T&gt; = [T, ...T[]]; /** Type guard utility */ function isNotEmpty&lt;T&gt;(arr: T[]): arr is NotEmpty&lt;T&gt; { return arr.length &gt; 0; } let notEmptyArr: NotEmpty&lt;number&gt;; notEmptyArr = []; // Error notEmptyArr = [0]; // Ok const arr: number[] = [0, 1, 2]; notEmptyArr = arr; // Error if (isNotEmpty(arr)) { notEmptyArr = arr; // Ok } 
I'm sorry, this is insane. The main purpose of enums is **not** just to be an object/associative map. It is meant to describe a collection of values with a common base type and more specific value type. An enum definition creates a type and namespace for the members of the enum, and more specific types for each member. For example: enum ColorChannel { Red, Green, Blue } namespace ColorChannel { export const labels: Map&lt;ColorChannel, string&gt;; } // getLabel should only accept values from the enum ColorChannel function getLabel(colorChannel: ColorChannel): string { return ColorChannel.labels.get(colorChannel); } // getRedOrBlueLabel should only accept the red or blue channel from ColorChannel. function getRedOrBlueLabel(colorChannel: ColorChannel.Red | ColorChannel.Blue): string { return ColorChannel.labels.get(colorChannel); } getLabel(ColorChannel.Red) // OK because ColorChannel.Red is of type ColorChannel getLabel(ColorChannel.Blue) // OK because ColorChannel.Blue is of type ColorChannel getLabel("Red") // Error: "Red" is not ColorChannel getRedOrBlueLabel(ColorChannel.Red) // OK because ColorChannel.Red is of type ColorChannel.Red getRedOrBlueLabel(ColorChannel.Blue) // OK because ColorChannel.Blue is of type ColorChannel.Blue getRedOrBlueLabel(ColorChannel.Green) // Error: ColorChannel.Green is not ColorChannel.Red | ColorChannel.Blue &gt;Anyway, I can't see that my ColorType class has any major difference in operation/behavior to the Aforementioned ColorType Enum except that the programmer has all the power to how the object is being constructed. Well, let's see. In this example, we're using your "enum": // getLabel should only accept values from the enum ColorChannel function getLabel(colorChannel: ColorChannel): string { return ColorChannel.labels[colorChannel]; // Error: Property 'labels' does not exist on type 'typeof ColorChannel'. } // getRedOrBlueLabel should only accept the red or blue channel from ColorChannel. // function getRedOrBlueLabel(colorChannel: ColorChannel.Red | ColorChannel.Blue): string { // return ...; // } getLabel(ColorChannel.Red) // No error. Good! getLabel(ColorChannel.Blue) // No error. Good! getLabel("Fart") // No error. What in the actual fuck? // Can't even properly define getRedOrBlueLabel let a: {} = {}; let b: ColorChannel = a // no error // great, type ColorChannel is just {} I know what you're gonna say, you can define a type intersection. Great: // lets see: type ColorChannel = ... // Error: Duplicate identifier 'ColorChannel'. // that won't work, so.. type ColorChannelEnum = ... // No error yet // ok, so type ColorChannelEnum = ColorChannel.Red | ColorChannel.Green | ColorChannel.Blue; // Error: 'ColorChannel' only refers to a type, but is being used as a namespace here. // that won't work, lets do this: type ColorChannelEnum = typeof ColorChannel.Red | typeof ColorChannel.Green | typeof ColorChannel.Blue; // Seems great! Let's use it function getLabel(colorChannel: ColorChannelEnum): string { return ...; } getLabel(ColorChannel.Blue) // No error: Suck it! getLabel(ColorChannel.Red) // No error: Haha! getLabel("Big fat fart") // No error: uhhhhh wait a second type Test = number | string; let a: Test = "big fart" let b: ColorChannelEnum = a // no error. // Great, type ColorChannelEnum is just (number | string). &gt;To that end I think I would propose that "Enums behavior is that of a class with static properties" Nope, this is a complete and total misuse of classes in the first place, and misses the point of defining an enum. The closest you can get is this, which is a hell of a lot more verbose than an enum: type ColorChannel = ColorChannel.Red | ColorChannel.Green | ColorChannel.Blue; namespace ColorChannel { export const Red = "Red"; export const Green = "Green"; export const Blue = "Blue"; export type Red = typeof Red; export type Green = typeof Green; export type Blue = typeof Blue; } Should enums allow decorators in some sense? Sure. Otherwise, I'm completely baffled about the sentiment this thread has toward enums and how anyone can look at this "enum" implementation and not cringe. Enums have literally 0 complexity to them. Anyone saying that string intersections are better than enums is also insane. The only possible benefit of string intersections over enums is that you don't have to import anything to use a string value. Otherwise, string intersections are way worse to maintain. Because enum usage is statically analyzable, refactoring is 100x easier with enums vs string intersections (renaming enum keys, changing enum values). You can also find references to both the enum or any of the enum values using tooling, where you have to search for usages of string intersections. This poses a problem when two different string intersections have overlapping values. Consider: type ColorChannels = "red" | "green" | "blue"; type PrimaryColors = "red" | "blue" | "yellow"; It would be a lot harder to find all usages of the ColorChannels "red" vs the PrimaryColors "red" rather than if you just used an enum. Furthermore, enums allow you to provide context to what is going on in your code. Consider the following code, and tell me which is more clear: // using string intersection createStream(connection.config, "disabled"); // using enum createStream(connection.config, StreamEncryptionStrategy.Disabled); Forget about the runtime values of enums and everything becomes a little more straightforward. Use enums as if they were collections of unique symbols with a common base type. It is not complicated.
 // using string intersection createStream(connection.config, "disabled"); // using enum createStream(connection.config, StreamEncryptionStrategy.Disabled); Do the people who will read/inherit/interact with your code a favor and learn enums instead of dodging them.
You're the reason technical conversations like the one I wanted to have often don't happen, and people just pick sides and say 'fuck the other guy'. That aside, your technical analysis of my topic has greatly improved my understanding of a thing I had a gap in knowledge of. I am not at all deeply aware of the ins and outs of type systems, the languages I've used with types are Pascal/C/C++ and a bit of C# only one of those was a complex multi-year spanning million line code base, it was all in Pascal. The rest I've toyed with, 1000 lines or less projects or a support role within C# applications. Languages are just tools, where sometimes, there's a widget that we've glossed over in our tool chest for years, never using it for more than just a pry bar. Enums are one of these things for me in this context. On the high level, you expressed how enums work within the typing system of Typescript and their innate relationships in much much greater understanding and depth than I did. There is no insanity, this is literally what I was trying to understand... where I was failing to grok something so simple as an enum. On the high level I related their use to how they seem to behave in Javascript. I'm coming from 10 years (21 years in software) running full on "Web 2.0" complex applications all written in JS - Enums never mattered. But to that end, that's where my ability to understand them better was failing. I saw them as their outcome, and not entirely as their effect. &gt; An enum definition creates a type and namespace for the members of the enum, and more specific types for each member. That one sentence was all it took for me to recognize what was wrong with some of my assumptions. There's combined behavior from something like this pseudo code (again not precisely but... in gross terms) namespace ColorChannel { private class ColorChannelBase {} public class Red extends ColorChannelBase {} public class Green extends ColorChannelBase {} public class Blue extends ColorChannelBase {} } That's fascinating, I hadn't considered that at all. I had never considered that ColorChannel.Blue was a type that was unique to itself and shared a base within it's family. It reminds me of atoms from ruby, they are 'type', 'symbol', and 'value'. This example you provided, is a great insight into the underlying mechanics of enums. This is knowledge missing from the manual, again anyone unfamiliar with typing systems in a deep complex sense could easily miss that an Enum is a namespace, it's not even mentioned in the manual, it's not at all discussed anywhere, this is arcane knowledge. namespace ColorChannel { export const labels: Map&lt;ColorChannel, string&gt; = new Map([ [ColorChannel.Red, "Red"], [ColorChannel.Green, "Green"], [ColorChannel.Blue, "Blue"], ]) } I think it's so important to one of my points to show how the enum and namespace relate to one another in the compiled output... var ColorChannel; (function (ColorChannel) { ColorChannel[ColorChannel["Red"] = 0] = "Red"; ColorChannel[ColorChannel["Green"] = 1] = "Green"; ColorChannel[ColorChannel["Blue"] = 2] = "Blue"; })(ColorChannel || (ColorChannel = {})); (function (ColorChannel) { ColorChannel.labels = new Map([ [ColorChannel.Red, "Red"], [ColorChannel.Green, "Green"], [ColorChannel.Blue, "Blue"], ]); })(ColorChannel || (ColorChannel = {})); That to me, instantly shows that there's NO loss in fidelity between "manually creating classes" and using enum syntactical sugar. (and the inherit typings it provides) you can still most likely express anything you may want to express in JS in TS in this manor. Much happier here. &gt; I know what you're gonna say, you can define a type intersection. Great: I mean, probably not - that's starting to get "code smell" it's obviously wrong. My initial example had plenty of "code smell", purely by intention, I was rationalizing what I saw, and understood and trying to find alternative terms to describe it. Take this simplest of examples class Test { static x = 11; } enum Foo { x = 11 } And it's compiled output. var Test = /** @class */ (function () { function Test() { } Test.x = 11; return Test; }()); var Foo; (function (Foo) { Foo[Foo["x"] = 11] = "x"; })(Foo || (Foo = {})); You said my code was "insane" but... from what I can tell here typescript thinks the same of enums as it does of classes with static properties or namespaces, albeit a bit different path there. the output is an object (or function) with properties assigned to this object... the manual says nothing of the namespace trick, and this is the first I've seen or heard of it. If you took the time to understand it from my perspective you'd see where I was having trouble. Instead, you're a dick.
There's nothing wrong with not understanding something, the sentiment of the thread was getting to me. I was over-exaggerating and don't really think you're insane, I just like to get heated on the internet. Here's more info on the "namespace technique" (declaration merging): Merging Namespaces with [Classes, Functions, and Enums](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces-with-classes-functions-and-enums) To recap: from an output standpoint, you can create these objects however you want. From a typing standpoint, not doing it the "typescript way" is inherently fighting typescript itself. &amp;#x200B;
Pedantically speaking, Haskell 's `data F = A | B` also has more than two inhabitants; it contains undefined as well. In fact, since Haskell types are lifted, it cannot ever have "proper" sum types^\*--in contrast, most strict languages have proper sum types but cannot have proper product types. (\* You can use unlifted types in haskell if you want to get fairly ugly with it)
Joi is using `Object.keys` which only looks at own properties, but defining a getter using ES6 classes will add the getter to the prototype. Joi might have a built-in option to get around this, otherwise you'll probably have to add your getter to each instance of your class in the constructor: class Foo { public readonly test!: string; private _test: string constructor(test: string) { this._test = test; Object.defineProperty(this, 'test', { enumerable: true, get() { return this._test; } }); } }
Yes you're right, thank you for the correction! Though I still think it's useful notion in Haskell. Even with the ambiguity introduced by laziness, thinking of your types as having an upper bound is helpful. In TypeScript I think this can actually be harmful. The most obvious example is why many people struggle with interpreting intersection types. Often people think it's acting like union and adding behaviour, rather than intersection. This is precisely because they think the values inhabiting a type are bound above by the object fields in the type. Another example is trying to explain why the rule `{ x: string } &lt;: { x: string; y:? number }` is unsound.
Nice! If you only need to make sure some properties exist (and don't care if there are "extra" properties), you can also use [unknown()](https://github.com/hapijs/joi/blob/master/API.md#objectunknownallow): const joiSchema = Joi.object().keys({ test: Joi.string() }).unknown();
Yep. I just mentioned it, in case someone finds that thread with the same issue, so they make sure to handle that private prop in Joi. I wish I wouldn't need all that stuff anyway :( But I guess Joi is for JS and not TS, soooo.........
 createStream(connection.config, 'stream-encryption-strategy:disabled`); What do enums buy you over this? 
Cute.
Oh that. Thanks, didn't realize you meant generics when you said templates. Sorry, my mistake. Nice link, I appreciate it! I read through the whole thing. ðŸ¤“
Not sure I follow the train of thought here, sorry.
Okay, sure. But we can have many chained .then() calls in succession. How does TypeScript handle these when they all can return and receive different value types?
When you return a value from the .then callback you are creating a new promise wrapping that value. Thatâ€™s why you can call .then again. For example you have a Promise&lt;string&gt; so the argument to the first .then callback will be a string. Letâ€™s say that callback returns the length of the string. That in turn means the .then returns a Promise&lt;number&gt;.
When you return a value from the .then callback you are creating a new promise wrapping that value. Thatâ€™s why you can call .then again. For example you have a Promise&lt;string&gt; so the argument to the first .then callback will be a string. Letâ€™s say that callback returns the length of the string. That in turn means the .then returns a Promise&lt;number&gt;.
Yes, unless perhaps op used some weird setting that uses a stub or a "fill" for Map.
I encountered this during Angular (6) development at work. I don't have access to my work code from home, and I prefer not to log into Reddit from work (plus I am somewhat paranoid about sharing work code outside of work). But I'll try to see if I can retrieve an example. I tried this at [https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/) and it did work, proving myself wrong, but then it's a different environment: let mapa:Map&lt;string, Map&lt;string, string&gt;&gt; = new Map&lt;string, Map&lt;string, string&gt;&gt;(); let mapb:Map&lt;string, string&gt; = new Map&lt;string, string&gt;(); mapb.set("1", "one"); mapb.set("2", "two"); mapa.set("b", mapb); let mapc: Map&lt;string, string&gt; = new Map&lt;string, string&gt;(); mapc.set("3", "tres"); mapc.set("4", "cuatro"); mapa.set("c", mapc); let mapref:Map&lt;string, string&gt; = mapa.get("b"); let value1: string = mapref.get("2"); I'll follow up later if I can get around to it. P.S. TIL that this Map syntax is native to ES6 and doesn't require TypeScript. Thanks for your response!
If you are going to nitpick: no, they're not equivalent. In the article's version, you need to write {left: undefined, right: undefined, value: ...}, and "left" in t will always be true.
Nothing to do with the environment. You're doing something wrong at work.
Reasons I can think of for your problem: 1. You're using something like MobX (which replaces maps with a different implementations that only allows string keys, values can be anything though) 2. You're using a broken polyfill for Map since some browsers might not support the native Map (or just intentionally something that is just called "Map" but has a different interface than the ES6 one. You should log the `Map` constructor and see if it's the actual native one (`String(Map)` or `String(mapInstance.constructor)` should show something like `function Map() { [native code] }`
The issue is that TSC never transforms or alters module paths, right? So after transpilation, those absolute paths are still absolute, and your runtime module loader doesn't understand There are a few TS transformers that can rewrite those absolute paths to relative ones. https://www.npmjs.com/package/ts-transformer-imports Custom transformers can be used via "ttypescript." (note the extra T)
I've been doing typescript for 4 months now. What I've learnt is if it doesn't work you probably need to configure it differently. Typescript is configuraiton all the way down. 
In my react setup im currently using babel-plugin-module-resolver. That implies using TS through babel, ofc. On server-side you can add a hook to the require function, its like 5 lines of code
By â€œa property-changing UI controlâ€ I meant a thingy that takes a class with lotsa properites and creates a HTML form that allows the user to change it, reflecting the changes back. I've got an example [here](https://github.com/m93a/punk-tex/blob/0894d9d06c2cd4131d3869a8fa8536af61560c4b/src/tab/ReferenceManager.tsx#L66), but maybe it will look to confusing to you as there's a lot interdependence with the rest. &gt;You are really constraining the types by dynamic information; the type of your object is decided by the values you pass to the decorator. Sadly, it's dumber than that. TypeScript doesn't infer the type of parameters from the arguments of the decorator. It only checks whether the type of the property is assignable to the dynamic type. &amp;#x200B;
I think the closest would be [decorators](https://github.com/tc39/proposal-decorators/blob/master/METAPROGRAMMING.md) , which youâ€™re using to represent additional metadata and that is available via the AST, but Iâ€™m not sure thereâ€™s more beyond that. 
If you are using Webpack, try `tsconfig-paths-webpack-plugin`. It solved all the issues I ever had with absolute paths with Typescript and Webpack.
Secondly, Map only allows keys which are objects. You can use a standard object for a string based lookup.
[https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es5.d.ts#L1396](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es5.d.ts#L1396)
However, according to es6 Promise behavior. Shouldn't `PromiseWithLog.resolve(1)` returns `PromiseWithLog&lt;number&gt;` instead of `Promise&lt;number&gt;`? Besides, thanks your advice!
I just found this related TypeScript issue: https://github.com/Microsoft/TypeScript/issues/6220
However, es6 Promise doesn't work like a java-style OOP class. class A extends Promise {} console.log(A.resolve() instanceof A) // true
That's a special behavior of `Promise.resolve`, not the behavior of ES6 class inheritance class Base { static func() { return new Base(); } } class Sub extends Base { } alert(Sub.func() instanceof Sub) 
You could get the right typings if you copied all the promise type definitions and renamed them then add your new method then assigned like this: const PromiseWithLog: PromiseWithLogConstuctor = &lt;any&gt;class extends Promise{ log() {} }
Another option that would allow the code to read similarly to what you've got in the question: const trace = &lt;T&gt;(value: T) =&gt; { console.log(value) return value } const resolvedThing = await doSomethingAsync() .then(trace); Doesn't involve messing with prototypes, creating a separate class and you don't have to wrap your whole promise. 
Maybe it is implemented like this one instead of yours: class A { static resolve(){ return new this() // not `new A()`, it use `new this()` which typescript cannot correctly typed } } class B extends A {} console.log(B.resolve() instanceof B) 
So... 11 tips?
It will become 11 only after you read it.
I disagree with some tips here, but I like mixing OOP and functional stuff when it makes sense and the code simplier.
I'm not sure if it's what you're looking for, but [Code Climate](https://codeclimate.com/) has maintainability scores and code smell detection.
When using library, I usually find that the docs answers most questions. If it's from community type (like your case), you can simply go read the types themselves: [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express-serve-static-core/index.d.ts#L454](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express-serve-static-core/index.d.ts#L454) &amp;#x200B; I got to express-serve-static-core as I saw it used in the express types: [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express/index.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express/index.d.ts) &amp;#x200B; Hope it helps :)
SonarTS is just a set of tslint rules for SonarQube (https://www.sonarqube.org) which we use for all our projects - it supports JavaScript, TypeScript, Java and may be more languages. It not only provides reports like plato does and even much more reports, but also allows you to see it from time perspective - how complexity has changed with time, etc
If you can add the type definitions (not every library has typedefs) you can navigate to the definition of an object by shift + clicking on the name. This is useful because if itâ€™s a function you can see exactly what arguments it takes and what types these arguments are. If itâ€™s an interface you will navigate to the definition of that interface with descriptions of each property. You can often get very far with figuring out any library if itâ€™s well documented. 
Some if it is good but yeah a lot of it is opinionated. tslint at a minimum will get you halfway decent and extending an opinionated tslint-config will get you fully decent (consistency is almost always better than correctness), but beyond that there's a lot of leeway for declaring what's best.
Did you import those types into the document?
Those types are not part of a library, they are implemented separately as typings, that's why you won't see them in the doc to a library. Right now most of the time you will have to look at the typings itself, with help of IDE to navigate it. It's just one file you have to look at.
I don't understand what do you mean ? some examples ?
okay that can be a solution but that was better if my vscode Automatic Type Acquisition works well :/ thank you !
ok I see but the functionality "Automatic Type Acquisition" is not supposed to work ? because it still more convenient.
^The linked tweet was tweeted by [@LinguaBrowse](https://twitter.com/LinguaBrowse) on Oct 29, 2018 14:51:39 UTC (1 Retweets | 0 Favorites) ------------------------------------------------- OCR will be coming to LinguaBrowse! Soon you'll be able to tap-to-define words even if they're just images (e.g. Chinese/Japanese shopping sites). I made a proof-of-concept as my first [@NativeScript ](https://twitter.com/NativeScript ) app using tesseract.js. Now I just need a solution to circumvent CORS policiesâ€¦ [Attached video](https://video.twimg.com/ext_tw_video/1056918278726131712/pu/vid/720x1280/Vip61Zkd2aMAHB7I.mp4?tag=5) ------------------------------------------------- ^^â€¢ Beep boop I'm a bot â€¢ Find out more about me at /r/tweettranscriberbot/ â€¢
For clarification: I wrote this NativeScript app in TypeScript; I'm not simply posting in the wrong subreddit! NativeScript is a joy in some ways and a hell in others. It removes so many layers of complexity and magic that competing cross-platform frameworks like React Native add, due to running directly on the UI thread and not being much more than JavaScript bindings to native code (it's easy to make your own subset of it just by using JavaScriptCore). TypeScript makes the platform very discoverable, and the lack of a reactive UI architecture (in fact, it's completely UI-agnostic and so supports various UI frameworks) makes things much simpler to start out with. In dev mode, it doesn't even use code bundling, so you don't have to spend days fighting a packager for trivial reasons that aren't your fault. More than anything, it's really refreshing to have such immensely short cold build times, due to the minimal size of NativeScript! I'm a big fan. It's far behind React Native in certain ways (not least community size), but it's very exciting to try out nonetheless.
I really enjoyed the part where you used *opinionated* as a euphemism 
It's cool, but I don't see a lot of utility that vscode's go to definition doesn't already do aside from not having to download the code. What would be really interesting is if you could search the types! A plain text search would be handy but you could also try to implement something like ([https://www.haskell.org/hoogle/](https://www.haskell.org/hoogle/))\[Hoogle\] which lets you search for the shape of functions or types. 
Automatic Type Acquisition is for plain JavaScript, where you cannot import types into your code.
Stuff you cannot do with vscode: 1) You can send a link to something to your teammate. 2) Explore packages you don't know yet. 3) Search, as you already mentioned. Right now search works only inside a package, but this limitation will be addressed soon. 
Very cool, I've wanted something like this to exist for a long time. It'd be neat if the URL schema was fixed in some way, so that types from various libraries could link between each other. For example, if I write an API that returns a node Request object, and I publish docs on my site, it would be cool if my docs could link to this site when someone clicks on the "Request" return type.
In your example, I think the types of req and res will be inferred, so you don't need to specify them explicitly.
I thought something about some kind of jsdoc. I personally hate jsdoc, it's so dumb. &amp;#x200B; You could create some simple tags to annotate functions so they are included in the docs. And add ways of linking the functions to some textual declaration, maybe from the comments themselves (not a big fan) or through a reference to an external markdown file.
You can do what Godoc does and only fetch the file once someone tries to look at it.
It should already work exactly like this. All the libraries should be interlinked.
Can I link in docs for an external library? Like one that won't make the top 1000?
Yes, TypeScript is able to detect the return type for you.
Amazing, you've been a great help. Thank you very much!
Create React App is the primary way with which front-end developers using React set up new apps, so native TypeScript support is bound to be a boon for adoption. For those using create-react-app-typescript, here's [how to migrate](https://vincenttunru.com/migrate-create-react-app-typescript-to-create-react-app/).
Hmm, I have a lot of packages published with just a `index.d.ts` file, and no `typings` field. I only specify `typings` if I also specify `main`, so not for small packages that only is one file (`index.js`). How about checking for `index.d.ts` as well as the `typings` field? â˜ºï¸
No worries. If in doubt you can always consult the TypeScript playground [https://www.typescriptlang.org/play/](https://www.typescriptlang.org/play/) If you hover a variable and press ctrl/cmd it will show you the type. Here is the above example illustrated: [https://imgur.com/a/84kZdSf](https://imgur.com/a/84kZdSf)
This is pretty neat. I'm looking at the implementation details to see if this would be suitable for my company who has been using CRA-typescript. One difference I see is that CRA doesn't seem to know anything about `tslint`, whereas wmonk's CRA-typescript has it built in like CRA does for `.js` linting. In addition to the "caveats" listed in the docs regarding using babel for compiling `.ts`, I see "TypeScript support will ship without support for baseUrl and paths". From the discussion it sounds like that's not landing any time soon. Like the CRA maintainers, I discourage use of `baseUrl` and `paths`, but they're pretty commonly used in some of our development groups. It wouldn't be easy for us to make a wholesale change to stop using them. Same goes for type casts using angle brackets. We also do "Importing CSS files from node_modules" quite a bit, for which you recommend converting the `.css` files to SASS, which can be imported from node_modules. A far simpler workaround would just be to just convert the `import` statement to a `require`, yes?
## TSLint CRA by default has a very loose ESLint configuration [only meant to catch errors](https://github.com/facebook/create-react-app/pull/4837#discussion_r223075439). I think it should do the same for TSLint in the future as well since it, too, can catch errors, but if you want to run it to enforce a coding style, you already have to run ESLint yourself. The same can be done for TSLint. ## baseUrl It is indeed not supported, though [the source code](https://github.com/facebook/create-react-app/blob/87e3d4fd1080d290f675d0461e3d3656752628ab/packages/react-scripts/scripts/utils/verifyTypeScriptSetup.js#L123-L125) keeps the option open: &gt; We do not support absolute imports, though this may come as a future enhancement I agree though that they should not be encouraged, but... What can you do Â¯\\_(ãƒ„)_/Â¯ ## Angle-bracket type casts This is a limitation of using TypeScript with Babel that I'm afraid is indeed not going to go away. That said, it's mainly stylistic, and [TSLint can detect and convert them](https://palantir.github.io/tslint/rules/no-angle-bracket-type-assertion/). ## CSS import from `node_modules` &gt; We also do "Importing CSS files from node_modules" quite a bit, for which you recommend converting the .css files to SASS, which can be imported from node_modules. A far simpler workaround would just be to just convert the import statement to a require, yes? That was actually my mistake, sorry for that. Joe Haddad (from CRA) also pointed that out, and I've since updated my post: you actually _can_ import from CSS in `node_modules`, but you can't use absolute imports here either. In other words: if you simply strip `node_modules/` from the path, that should work as well.
Top 1000 is a temporary limitation, I just need to polish my infrastructure. So if your package is public it will be generated as well.
Off the top of my head, &amp;#x200B; 1. Interop with JS is not your primary concern and you want to use a better language not the same language with syntactic sugar 2. you want to use a real type system that can't be bent to anyone's will or totally bypassed 3. You feel like you could benefit from reified generics 4. You want to run the same code that you are writing on the backend and benefit from more predictable runtime behavior 5. Your into programming language design and feel like the goals of dart are more in line with your taste 6. You don't feel like choosing which language you write code in is about winning a popularity contest 7. You want to use flutter to create cross platform apps That's just off the top of my head, but Dart 2 trumps TS 3 in just about every way, and I really like TS, in the end though, it always bothered me knowing that all of it "features" were just a facade and in the end I was just dealing with JS , which I'm not really a big fan of. 
&gt; But in this case TypeScript needs to be ES compatible [...] Which has to change, of course.
Hell, it's about time!
Really awesome! However, one bad effect of including zero runtime is there can't be automatic data validation based on the types Other than that, i feel like this is something i would use
Thanks for checking it out! I just to clarify that there are no _external_ runtime dependencies, but part of the library's source will be in your webpack bundle (1.7kB minified/compressed including promise polyfill). Data validation is a pretty hard thing to do correctly at the framework level. I've toyed with the idea of adding the option for "validation" functions to act as type guards, but that is not in the current version.
Thanks for checking it out! &amp;#x200B; I just to clarify that there are no \_external\_ runtime dependencies, but part of the library's source will be in your webpack bundle (1.7kB minified/compressed including promise polyfill). &amp;#x200B; Data validation is a pretty hard thing to do correctly at the framework level. I've toyed with the idea of adding the option for "validation" functions to act as type guards, but that is not in the current version.
Genuine question: why do you discourage \`baseUrl\`? I wasn't aware anyone had any objections to it, but I'd definitely like to know if there are good reasons against its use. (Thanks in advance!)
I'm genuinely curious, why do you believe `baseUrl` should not be encouraged? I've never heard that opinion before, so I'm keen to know what its downsides are.
Typescript doesn't support higher kinded types (see [here](https://github.com/Microsoft/TypeScript/issues/1213)). You can get *some* of the functionality with workarounds, a good example being [fp-ts](https://github.com/gcanti/fp-ts/blob/master/HKT.md).
I discourage use of "baseUrl" and "paths" to use non-relative module imports.
I also want to know. My opinion is that relative URLs break encapsulation and make refactoring more difficult. 
Oh my hurts my head. Do you think this method is useful for my case?
The main downside is that if you look at an imported file path, you can only understand where that file is coming from if you also know what `baseUrl` is set to in your `tsconfig.json`. That means the programmer has to keep more in mind when working with the code that is not relevant to the problem they're actually trying to solve. Usually, your editor can tell you where the file is actually located, but the only way to know how the editors knows that, is by reading the docs and knowing that the `baseUrl` option exists and what it does. (Ping /u/BeanzPatio who also wanted to know.)
Epic. Lol
What an awful website.
Broadly, relative imports are more explicit, being a path to a specific file or directory. Non relative imports are more like â€œhey module system, go find me a module that matches this nameâ€. By introducing baseUrl and paths into that search algorithm we are adding complexity that isnâ€™t worth the reward IMO. Also the tooling isnâ€™t always aware of those new paths. We had a hard time setting up jest, for example 
I've been thinking about it lately, and found out something like io-ts would be great, since it allows you to serialize / deserialize values based on the type
I don't think so. A step like this would be extremely close to creating an entire new language because there are many things that make TS compatible to JS and could be changed while we're at it. Instead, I'd prefer a new (and good, and well supported) language that maybe even compiles to WASM.
If there's no typings field in the package.json then I think the typedefs file must be at the root level named index.d.ts, if that makes it any easier.
I keep my types in a separate private repository, and clone it alongside both my server and client projects. Then in both the client and server folders I run `npm install ../&lt;types-repo&gt;` Then I run `tsc --watch` in my types folder, so when I update the interfaces, they rebuild into a `/dist/` folder. Since I've installed that folder in both my server and client, those respective projects will see those changes. Then you can do an import like `import * as someName from '&lt;name-of-installed-types-module&gt;/dist/&lt;path-to-file-you-are-importing&gt;`. Once a type is file is rebuilt with tsc, your client/server won't see that change until you navigate to the built file in your project. I typically F12 or cmd+click the import statement in whatever file is using it to get there quickly. Hope this helps.
Namespaces and typeroots are harder to work with. Just use import/export like you would with non-TS code. 
Iâ€™m saying you probably donâ€™t need to be using either namespaces or typeroot. If you just use plain import and export everything would probably â€œjust workâ€. 
If you are basing your code off a monorepo (single repo for all your projects), you can use the new \`tsc\` features that lets you reference another project easily. [https://www.typescriptlang.org/docs/handbook/project-references.html](https://www.typescriptlang.org/docs/handbook/project-references.html) This worked out really nicely for some of my projects. For multirepos, using a separate contracts package works. You can also use lerna or \`npm link\` to connect them without having to push up constantly.
Well, I should first emphasise that I agree that being able to move a file around without changing import paths is an advantage of absolute imports - I thought I'd mentioned that somewhere, but I didn't. It's not a strong one though, in my opinion, since one's editor can usually update those paths automatically when you move files around, in which case relative imports do not discourage refactoring. As for the cognitive overhead: I think this depends on when you actually use those paths. I think you usually do not read an import path and consider where that file comes from: the type of the imported object is what should tell you what you're dealing with, not what file it's coming from. Neither should you need to care about this when importing that object for the first time: when your editor suggests which files an object can come from, it can still suggest absolute paths. The only time when you do care about what paths are pointing to, is when getting to grips with a codebase. In that case, being able to actually trace the code you are reading is most helpful, and imports that point to paths that you cannot deconstruct without opening -and knowing you need to open- `tsconfig.json` prevent that. If you don't know about the `baseUrl` setting, you have the options of wasting time diving into this implementation detail, or shrugging it off as "it probably works even though I don't know why", which I don't think is a healthy attitude to stimulate. (On an only slightly related note: if you have multiple files all exporting `api`, something else is wrong already...) That said, I think both your and my downsides occur infrequently enough that they're not that important, so while I would discuss it on reddit or over a beer, if I worked in a team with you I'd probably concede this to you :)
I'm skeptical if libraries don't utilize the strict flags of TypeScript.
I actually forgot this wasn't default. I'll have a look at it. 
2 things I can see; 1. why use this vs JSON Schema? 2. you should make a generic version that returns `as Type` already typed, and a validator that returns `is Type`.
this.command isn't implicitly typed. You could call COMMAND\['dog'\]('kick'), so your compiler complains that COMMANDS doesn't have a type that supports that signature. This fixes it: const COMMANDS = { cast: (command: string) =&gt; this.history += this.wizard.cast(command), drink: (command: string) =&gt; this.history += this.wizard.potHolder.drinkPotion(command), clear: () =&gt; { this.archive = this.history; this.history = ''; }, archive: () =&gt; this.history = this.archive + this.history, default: () =&gt; this.history += `${this.wizard.name} does nothing\n` } as {[key: string]: Function}; Or better typed: } as {[key: string]: (command?: string) =&gt; any }; Or alternatively you can filter away any strings that isn't one of your 5 chosen ones, the compiler accepts that too (type of the command string becomes 'cast' | 'drink' | 'clear' | 'archive' | 'default' ), but then the parameter "action" becomes required: } else { if( command !== 'cast' &amp;&amp; command !== 'drink' &amp;&amp; command !== 'clear' &amp;&amp; command !== 'archive' &amp;&amp; command !== 'default' ) return; if(COMMANDS[command]) { COMMANDS[command](action); } else { COMMANDS['default'](''); } } Or you can cast the command to your type: const command = this.command.trim().toLowerCase().split(' ')[0] as 'cast' | 'drink' | 'clear' | 'archive' | 'default' | ''; This is the same as the previous code, except it picks up on COMMANDS' keys instead of you having to specify it manually: const command = this.command.trim().toLowerCase().split(' ')[0] as keyof typeof COMMANDS | ''; &amp;#x200B;
Thank you for the feedback! &gt;1. why use this vs JSON Schema? Something like `ajv` can take a schema and validate an value against it, and JSON Schemas already exist for a bunch of interfaces (including package.json and tsconfig.json). I have it on my TODO to add a section to the README where I compare Recordari vs other solutions. So this is definitely on my mind! &gt;2. you should make a generic version that returns `as Type` already typed I toyed with the idÃ© of taking having the `Record` function take a generic parameter `T` and then return `as T`. However I thought this would result in the user expecting the constraint object to be typed in a such a way that it expects each key of T to exist (hope that made sense). And unfortunately I don't know how to do that smoothly when the constraint object becomes deeper than 1 level. (help would greatly be appreciated) &lt;br&gt; So I decided that it would probably be more obvious what's happening (and cause less confusion) if I left the type converting up to the user, and just returned an `object`. &gt;and a validator that returns `is Type`. Why? &lt;br&gt; When would this be needed? &lt;br&gt; And why should Recordari provide an essentially empty type guard? 
I am no expert myself, but the class &lt;code&gt;IEsriColor&lt;/code&gt; seems confusing to me, perhaps you can start by working that class typing. class Color { private static a, r, b, g; Public &lt;method-name&gt; {} } expprt default Color;
If you are looking to shortning your imports, you can do something like this in you tsconfig.json Give a property named path like: { ....... "path": [ "@types": "relative path to your type definition with respect to this tsconfig file" ] } Then you imports will reduce to: import { SomeType } from '@types/sometype';
Alright, that makes sense, thanks. I went for the first solution and that clears things up more. I think I have a better idea what the compiler was looking for. I ended up with `as { [key: string]: (command?: string) =&gt; void}` as right now I don't anticipate those functions ever returning something (they simply add text to a text box where the game is run)
I already do something similar actually! I import and export all my types from a single file that I can reach with `â€™typesâ€™`.
Record&lt;string, string&gt; produces a type equivalent to { \[key: string\]: string }. { \[key: string\]: string } is assignable to your Partial&lt;&gt; type because { \[key: string\]: string } has no named properties, and all the named properties in your Partial&lt;&gt; type are optional. There's no conflict. And when determining assignability, extra properties in the source type (the string index of { \[key: string\]: string }) that do not exist in the target type (your Partial&lt;&gt; type) are perfectly valid. &amp;#x200B;
I generally find that it's often better to design code to require you to be more explicit about intentions, rather than implicitly defaulting data/values/behavior in the absence of explicit intentions. In your example, if you use my suggestion, the code can be written in a way that will force you to consider how to determine the value of every property of VideoOptions from query params. If you refactor VideoOptions in any way (rename properties, add/remove properties, change type of properties), then you are guaranteed to get a compiler error to force you to reconsider how you should initialize every property of VideoOptions from query params. With the Partial&lt;&gt; type, you could refactor VideoOptions, forget to revisit your query params -&gt; VideoOptions conversion, and never get any errors.
&gt; Why? When would this be needed? And why should Recordari provide an essentially empty type guard? ``` const someValue: unknown = someFunc(); if (IsSomeTypeFromR(someValue)) { // someValue is the proper type by the type checker. It's not a copy or a return. DoStuff(); } else { // No throw. console.log('someValue isnt what its supposed to be'); }```
Here's another perspective. `Partial&lt;&gt;` makes **all** keys optional. This means an object with *zero* keys will still match. Therefore, `queryParams` matches because it has zero [known] keys.
What are you using to compile? Babel or tsc? Babel is leaving my imports in and then my code is not running. 
Not at all... You have to add a tooling step but that's the worst of it. Typescript is just JavaScript plus types. I leave strict off so I can use types when I want, but that's up to you. Is recommend trying with it on at first anyway. I recommend ts-node if you're a Node.js dev as it will run and compile typescript in memory so it feels like there's no build step
Coming from JS is very easy. The mechanics of the languages are nearly identical, though once you get into advanced typing things make get a bit tricky. You shouldn't have any issues though, good luck!
Typescript is super easy to learn from a Javascript background. Youâ€™ll want to learn the type system, interfaces, enums and classes, but it can be learned in about an hour since all valid JavaScript is valid in Typescript 
No this is a simple typescript feature
Basic syntax is easy. The bigger issue might be your coding habits and openness to changing the way you think about code to avoid butting heads with the compiler all the time. Many of the people who hate TypeScript do so because they think thereâ€™s nothing wrong with the way the write but the compiler says otherwise. If youâ€™re going to learn it, youâ€™d be wise to frequently remind yourself that the compiler is there to help. When you think â€œthis sucks, how do I force it to accept what I want to do,â€ instead think â€œhow can I approach this problem in a way that makes the compiler happy?â€
This honestly feels like a bug, or undesirable behaviour.
Seriously. Thank god I'm not the only one who thinks so. 
after getting an environment set up, you'll be productive almost immediately. It'll take you like a few days at most to reach the same levels of productivity that you had before switching
The big problem with TS is that they do not maintain language spec. But I assume it might get surprising and annoying when you really get into TS. Or if you really rely on language spec in your lerning. Otherwise the experience feels seamless.
They don't? Why would they not do that? How can anyone learn its new features if they don't keep us up-to-date on what's new?
They have this handbook on their page, which describes things. But not in gritty details. I saw their comment on the spec issue. Apparently merge commits introducing a feature contains message with description with spec-ish quality. So, yeah, you can read git history. We are squash away from losing such info.
Typescript is easiest if you already know Javascript and (C#, Java or another "explicitly/verbose" typed language). While some people might say Typescript is just Javascript with types, some patterns that work perfectly fine in Javascript are pretty hard to execute well in Typescript (EG magic, meta-programming or deeply nested structures). My typescript code is usually more structured like Java/C# programs than Javascript programs. 
All javascript code is allowed in typescript. Typescript only brings with it the adittion of types which, when used correctly, can make your editor really smart!!
A squash would probably merge the commit messages though, and hopefully they don't squash the entire history of `master`... That would just be silly. But they should have a better process of documenting things in the spec, surely. Piecing things together from git history is far from ideal.
Instead think "I have been doing something wrong this whole time, thanks compiler. Let's learn."
Partial&lt;T&gt; takes the generic type T and makes all properties of it optional. That might fix the issue.
Should it be `myHOC({})(Input)`?
You want `&amp;` instead of `|` (these props AND those props) Example: class Test extends React.Component&lt;{ a: string, b: number }&gt; { render() { return &lt;div/&gt; } } const myHOC: (config: any) =&gt; &lt;B&gt;(c: React.ComponentType&lt;B&gt;) =&gt; React.ComponentType&lt;B &amp; { value: string, onChange: (val: string) =&gt; void }&gt; = null!; const Outer = myHOC({})(Test); &lt;Outer a="a" b={1} value="1" onChange={() =&gt; { }} /&gt;
That's a major limitation in C# as well. 
Looks like this has already been reported on github and acknowledged as a bug: [https://github.com/Microsoft/TypeScript/issues/27144](https://github.com/Microsoft/TypeScript/issues/27144)
The TypeScript team agrees: [https://github.com/Microsoft/TypeScript/issues/27144](https://github.com/Microsoft/TypeScript/issues/27144)
You can have an async constructor in Python of you try really hard, but I'd question the value since that means you're doing IO there. 
use closures instead of classes &amp;#x200B; /thread
I feel like that limitation might be more of a feature than anything. Then again, I don't recall a time I wanted to have an object instantiation be async, so it's entirely possible there's a good use for it I don't know about. Feels wrong, though.
You can also create a static factory method for interfaces ;)
Oh hey. When I rolled my last company over to TypeScript 2 years ago we encountered a problem with TypeScript constructors. Check out this code block: class Base { public constructor() { this.setup(); } protected setup() { } } class Child extends Base { public myVar: string[] = []; public constructor() { super(); } protected setup() { this.myVar.push('one'); // throws TypeError: Cannot read property 'push' of undefined } } var child: Child = new Child(); If you can't tell what's happening let me explain. When TypeScript is creating the objects it first calls the `Child` constructor which in turn calls `super()` raising it to the base class constructor. The base class constructor calls `this.setup` and here's where the problem occucrs. `this.setup` calls *the child's version of `setup`*. In the `Child`'s `setup` method it references `myVar` which does not exist yet. What's the solution? We used Factory methods for everything. I found them to be supioror in every way to using normal TypeScript constructors. 
What's up with blog posts having 'le memes' in between paragraphs as if we are reading something that needs a comic relief. It breaks my mental flow and has 0 added benefit. On top of that, it's super cringy.
Bingo. Constructors should never do any logic and especially not I/O. They should be almost instant. It causes issues with things like dependency graph creation if you have slow constructors. If you need asynchronous logic to ensure your object is ready, you should call it's constructor and then call an async "prepare" method etc before continuing execution, or use an async static method to build your object like deacribed here.
Setup in the child class is a concrete method. In general, concrete methods should not be overridden (although an argument could be made for "setup"). However, if you really want to override a concrete method, then please call &lt;code&gt;super.setup()&lt;/code&gt; first. Again, in the case of a method like "setup" it's probably reasonable to override the concrete method it in the base class. 
That's not a solution. Many 3rd party libraries use classes so if you use traditional JS factory functions in your codebase, you'll have to create wrappers around the 3rd party libraries.
&gt; What's the solution? The solution is: Don't perform logic in your constructor. You will have issues like this in every language, not only TypeScript. Prepare what you need to prepare before, or have a construction method as the article suggests.
They solve different problems, though. A Factory is needed when you need to provide some object with a (testable, easily changable) way to instantiate something. Static constructors, on the other hand, are mostly used in places where you would use the regular constructor, just with more clear API/naming. You can also provide different ways of instantiation with this, e.g. `Vector2.fromCartesian(x, y)` and `Vector2.fromPolar(angle, magnitude)`. As you note, it may have fewer uses on not-so-basic types, but is useful nonetheless. I would be very careful with things like making constructors or static factories async, though.
&gt; Don't perform logic in your constructor. Or, more specifically to this issue, don't call instance methods in the constructor because the instance is not fully instantiated. Or, don't override concrete base class methods in child classes.
I agree that a static constructor in place of a normal constructor is good of you're passing it stuff it doesn't need dependencies to handle (read: parsing an int from a string aight, needing to make a database call isn't). Async constructors on non-factory instances make me wildly uncomfortable because you're either doing something that composition could handle, e.g. `Task.FromResult(int.Parse(...))`, or you're doing stuff that you probably shouldn't be doing from an architectural viewpoint (database calls, network calls, etc). On an actual factory method, eh, that's less bothersome (probably). 
I actually wasn't able to reproduce that problem just now. I'm using ts-node without a tsconfig.json file (so I believe it compiles to latest JS and runs it). &amp;#x200B; &amp;#x200B;
Yeah, I was going to say, this post is actually word for word from Effective Java, except the poster replaced "Java" with "TypeScript". It's an established design pattern.
can you share a more complicated case where this could be handy?
Check out dtslint: https://github.com/Microsoft/dtslint
The parent makefile, never tried that, will try it out in the future. I think your tslint file is better than mine so I'll be using that in the future for sure. Consider if you'd want to have typescript in the frontend as well. I really like using typescript with react, and you'll learn it twice as fast if you add it! There's a create-react-app package out there that generates a ts-based react template. I also prefer sorting front-end components by function rather than component, style, etc. That way if I decide I want to split off something into its own package, it's easy to drag that folder into a new project and build it. Also find it scales better as a project grows in size. Ive been looking for a good template to use for my react/node/QL/ts apps for a couple months now, and this is really close. If you added redux and react-ts I'd use it regularly. I may even fork your work and do it myself. 
I wanted to wait for the next create react app release to add typescript because if I'm right it has typescript support out of the box then :) Nevermind, thanks for your kind Feedback. I think I don't wanted to add redux because it's not needed in every application, maybe I will create a branch with react.
In any way, a package with or without the typings field will always be TS compatible if you can find it via a simple @types/[name] check,
Iâ€™m doing a similar thing but just for the server. Maybe we can share some ideas? https://github.com/edevil/node-webapp-sample
We should! That's what open source is for, right? I will have a look into your repository this evening, thanks for sharing
What's great about Typescript is that you check types before even running the code. Moving to test types in unit tests seems like a step backwards. Am I missing something? 
I think I read that CRA added TypeScript support to a release this past week or two.
You want to test types...? Why?
This kind of â€œtype exercisingâ€ tests are common with the DefinitelyTyped community definitions. You could look at something like https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react-redux
Because I'm making a package that has complicated generic types and stuff, and I want to make sure everything is as intended.
Cool idea. I'm in if there is nothing like this yet.
I havent been able to find anything like it, although if you do feel free to tell me! Also, what do you mean troubles to connect?
I just found out that currently the best place for community chatting is gitter: [https://gitter.im/Microsoft/TypeScript](https://gitter.im/Microsoft/TypeScript) It's really cool, you join rooms like "node.js", "typescript", "your-favourite-tech-stack" etc. and you have it all in one place.
A package for two CLI lines?
How else would you share the two lines with everyone and do it in a cross-platform way?
Got some errors, heres one https://tsdoc.io/@types/express/4.16.0/(ESModule)index.d.ts/(Namespace)e/(Function)Router#function-router
Not.
There are tons of packages for one JavaScript lines. Hell thereâ€™s even an isOdd package for what amounts to 3 characters....
But what if a I use the same type in different files?
Adapt your code to what works in your situation. In general, a global â€œtypes.tsâ€ file with dozens or more types in it I would say is probably frowned upon. Putting a â€œtypes.tsâ€ file in a â€œcartâ€ namespace, where the types in that are all ones specifically for the cart, that is probably fine.
You can use factory function underneath while still allowing consumers to use `new`. class Base { baseVar: string[] = []; constructor() { Base.setup(this); } protected static setup(base: Base) { base.baseVar.push('one'); } } class Child extends Base { myVar: string[] = []; constructor() { super(); Child.setup(this); } protected static setup(child: Child) { child.myVar.push('one'); } } const child: Child = new Child();
I prefer to have an Interfacepool.ts at the root of my app and define everything there and import from there as and when needed. 
Most of those are one liners without any dependencies to other files. In this case it is really looking like a good design but generally I would say it's bad since you probably won't/can't stick to it like they do it. 
That seems like it would become unmaintainable. 
I keep types close to the modules that need it. I then import/export them from a single types.ts file that I have an alias for so all modules can easily reach all types. This makes it easy to maintain while still being very in control of how to reach my types and move them if needed.
Yes, come over to [gitter community](https://gitter.im/Microsoft/TypeScript). People have been really helpful there to me. I kind of end up visiting there every once in two days.
I had this figured out a while ago, but don't have the code with me. Send me a DM tomorrow and I can send you the pattern you need. I've not had any issues on Chrome/FF/IE 10/Edge. 
You can't extend Error (in all browsers)! Simply a limitation of Error. Took me a while to figure the source of this bug. You'll have to come up with a solution that doesn't extend error.
What browser are you using? It works in Chrome. At least after I fixed the error of assigning `string | undefined` to `string` (the message). But you probably compile without strict type checks.
Could you post the pattern here as well? I'm curious.
`Object.setPrototypeOf(this, new.target.prototype);` What is that line supposed to do? I don't see `new` defined here?
I have done this in chrome und typescript on the backend. Where are you trying to do this? I can show you my error class in an hour 
Well I don't know about you, but I haven't touched windows in 10 years so I'd have no idea how to write a proxy or server that has this ability without a utility like this. Or maybe you're saying it would be better to personally do the research for every platform I'd want to support and then copy/paste from stackoverflow or github gist? Personally I'll stick to tiny modules.
This feels like pedantry, but... This isn't an example of TypeScript 'making types real' or TypeScript doing run-time type-checking. The type guards are just Javascript, and all the runtime type-checking that is being done here is being done by Javascript. However, TypeScript understands (or [can be made to understand](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)) these type guards, and can thus use them for type inference in the following code. Which is nice, but you don't need to use TypeScript to do the runtime type checking that is being done in this article.
It was recommend when targeting ES5. The chain is lost after calling super, so it had to be re-established. In my case, however; it turned out to be an easy oversight on my part. I wasn't looking at the rejection of a promise.
It turned out I was looking at the error wrong. I was throwing from a promise rejection and wondering why I didn't see it at the root error level.
Check my edit =)
So the problem is solved? Can you post your solution for the search/google-squad?
How does this address the hard part? Namely, my 1000-property interface declaration. Am I supposed to write a 1000-line type guard and then keep them in sync? That doesn't sound like a practical way to make types real.
Yes, it was on my end of not noticing what I was doing. I was throwing my custom error type out of in the promise rejection, however; it was being wrapped in an uncaught promise exception.
Yes, TSX works basically the same as JSX. There's nothing special about adapting TS to ReactJS &amp; Redux assuming you understand all 3.
Thanks!
Yeah, and you don't need extra tooling, only typescript compiler
I use TSX but not for client side apps. I use React libraries to render components as strings and send out HTML responses from Express. You get more compiler help with your "HTML" than with view engines like handlebars.
I'm a little leary of use defined type guards as the compiler completely trusts them. They are an area where you can inadvertently add bugs to your code, similar to casting and using `!`. function isString(foo: any): foo is string { return typeof foo === 'number'; } const a = 123; if (isString(a)) { console.log(a.substring(4)); } Obviously that's a contrived example, but the point is, it's entirely up to the developer to write the type guard correctly. I am finding myself moving towards discriminated unions whenever I can, as they come with some compiler aid.
I'm not sure if this has been fixed post in more recent versions, but with the version of React I'm using, Typescript will display an error when trying to use the arrow syntax to define the render method. As such, lifecycle hooks and the render method should be bound in the constructor. `connect` is also tricky to use when typed.
Why would you want to define render with arrow syntax, it doesn't make much sense? &amp;#x200B; You generally just need to give your mapStateToProps the root state type for connect, it shouldn't be that tricky to type.
&gt; What are the main things you must understand to be able to adapt Typescript to ReactJs - TypeScript - React &gt; and Redux? - Redux - The Redux typings, which can be somewhat complex, and unfortunately have little documentation available, so much of this is dependent on reading the names of the types and guessing what they represent. 
The main problem is that not every 3rd party library, especially smaller ones, supports typescript out of the box so you have to do some research on get it working TSX itself is almost straight forward one you learned the basic concept. This helped me a lot [https://github.com/sw-yx/react-typescript-cheatsheet](https://github.com/sw-yx/react-typescript-cheatsheet)
Sounds like a tricky one, have you looked at mapped types though? Seems along the lines of what you're trying to do.
What do you mean by 'supports TypeScript'? That they don't have typings available? If so, it's just a matter of including a d.ts file with `declare module 'xyz';` somewhere in your project and TypeScript will happily ignore it.
Well I don't know about mapped types, maybe you have something in mind that I can't think of? I tried declare function actionTypes&lt; T extends string, U extends { readonly [k: string]: T } &gt;(types: U): U but unfortunately it didn't work, the string literals still widened.
Great cpoly55, I like your article. I think I need to add this to my [slothking.online](https://slothking.online) code generation tool to prevent backend from returning invalid data.
Yeah it's what I previously used. The problem with that is if you have an enum for example const enum Actions { SomeAction, ActionTwo } then every action creator has type of `() =&gt; ({ type: Actions })` , not the specific member of the enum that's actually used in the definition of the action creator.
 /** * Connects a React component to a Redux store. * * - Without arguments, just wraps the component, without changing the behavior / props * * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior * is to override ownProps (as stated in the docs), so what remains is everything that's * not a state or dispatch prop * * - When 3rd param is passed, we don't know if ownProps propagate and whether they * should be valid component props, because it depends on mergeProps implementation. * As such, it is the user's responsibility to extend ownProps interface from state or * dispatch props or both when applicable * * @param mapStateToProps * @param mapDispatchToProps * @param mergeProps * @param options */ export interface Connect { (): InferableComponentEnhancer&lt;DispatchProp&gt;; &lt;TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt; ): InferableComponentEnhancerWithProps&lt;TStateProps &amp; DispatchProp, TOwnProps&gt;; &lt;no_state = {}, TDispatchProps = {}, TOwnProps = {}&gt;( mapStateToProps: null | undefined, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt; ): InferableComponentEnhancerWithProps&lt;TDispatchProps, TOwnProps&gt;; &lt;TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt; ): InferableComponentEnhancerWithProps&lt;TStateProps &amp; TDispatchProps, TOwnProps&gt;; &lt;TStateProps = {}, no_dispatch = {}, TOwnProps = {}, TMergedProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;, mapDispatchToProps: null | undefined, mergeProps: MergeProps&lt;TStateProps, undefined, TOwnProps, TMergedProps&gt;, ): InferableComponentEnhancerWithProps&lt;TMergedProps, TOwnProps&gt;; &lt;no_state = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}&gt;( mapStateToProps: null | undefined, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;, mergeProps: MergeProps&lt;undefined, TDispatchProps, TOwnProps, TMergedProps&gt;, ): InferableComponentEnhancerWithProps&lt;TMergedProps, TOwnProps&gt;; &lt;no_state = {}, no_dispatch = {}, TOwnProps = {}, TMergedProps = {}&gt;( mapStateToProps: null | undefined, mapDispatchToProps: null | undefined, mergeProps: MergeProps&lt;undefined, undefined, TOwnProps, TMergedProps&gt;, ): InferableComponentEnhancerWithProps&lt;TMergedProps, TOwnProps&gt;; &lt;TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;, mergeProps: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;, ): InferableComponentEnhancerWithProps&lt;TMergedProps, TOwnProps&gt;; &lt;TStateProps = {}, no_dispatch = {}, TOwnProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;, mapDispatchToProps: null | undefined, mergeProps: null | undefined, options: Options&lt;State, TStateProps, TOwnProps&gt; ): InferableComponentEnhancerWithProps&lt;DispatchProp &amp; TStateProps, TOwnProps&gt;; &lt;TStateProps = {}, TDispatchProps = {}, TOwnProps = {}&gt;( mapStateToProps: null | undefined, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;, mergeProps: null | undefined, options: Options&lt;{}, TStateProps, TOwnProps&gt; ): InferableComponentEnhancerWithProps&lt;TDispatchProps, TOwnProps&gt;; &lt;TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;, mergeProps: null | undefined, options: Options&lt;State, TStateProps, TOwnProps&gt; ): InferableComponentEnhancerWithProps&lt;TStateProps &amp; TDispatchProps, TOwnProps&gt;; &lt;TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, TMergedProps = {}, State = {}&gt;( mapStateToProps: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;, mapDispatchToProps: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;, mergeProps: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;, options: Options&lt;State, TStateProps, TOwnProps, TMergedProps&gt; ): InferableComponentEnhancerWithProps&lt;TMergedProps, TOwnProps&gt;; } 
Decorators are great for a lot of use cases, but can also be really annoying when being over-"forced" by frameworks. The problem with decorators is generally that they are not dynamic. So if we want to generate dynamic routes, SugoiJS for example would need to provide a routing variant without the decorators. I do not know a lot about SugoiJS and is rather questionable since it is being developed by just one developer and it does not seem to have a large community. But what I can recommend is [NestJS](https://github.com/nestjs/nest) which has similar features as SugoiJS, but has a way larger community. 
 type ActionTypes&lt;T extends string[]&gt; = { [k in T[number]]: k } function actionTypes&lt;T extends string&gt;(types: T[]): ActionTypes&lt;T[]&gt; { return types.reduce((actionTypes, key) =&gt; { actionTypes[key] = key; return actionTypes; }, {} as any) } const MyActions = actionTypes([ "SomeAction", "ActionTwo" ]) console.log(MyActions) /** * Output: * * { * SomeAction: "SomeAction", * ActionTwo: "ActionTwo" * } */ Playground link here (not official typescript playground): [playground](https://agentcooper.github.io/typescript-play/#code/C4TwDgpgBAggxsAlgewHYBVwQM4B51QQAewEqAJtlNsAE6KoDmA2gLoB8UAvFAN5TMA1lAZR0zVAFcAtgCMItVqwBcUYQF8AUJoBmk1AhSooAQ0NpMkPAWKkKVGvSbsAFKCurxrAJSr4SCyxrNk5eTSgIqFoIYElaY3ccADpo8kk4CBcXMwCMIIAaNQgQb25Q8MjKnKNLHCFi1m4ikABubUrK6Nj403M8qzbK9ULedVMqE1QSzS1NODQaKABZEH8jKh5qwKsXZgqIgCIAZWRpCDW0A-z9qAOLjAB3ZAPNH2151GxkABsIJO-kIwXCt7thvNoAPQAKih4ShUAA8pJgGBkco4VAMWEoPCIiczvdVMdTuc+lcMRF7ugnkSqU8XjioFocRCgA)
This looks pretty promising. But how would you return the Result up to the next function? public myFunction(foo: string): Result&lt;Response, Error&gt; { myGame.process(foo).when({ success: result =&gt; Result.Success(this.update()), // this.update() returns primitive type failure: error =&gt; this.logger.warn(error.message) }); } I am trying to process something in a class myGame, when it is successful (validation errors calls the failure) i want to trigger the parent caller of myFunction. Doing it with Result.Success() inside the success: doesn't work. Obviously. What way of achieving this kind of chain would you suggest? Due to encapsulation i don't want to directly access the process method in the parent. 
Additional negative points about decorators: - They increase load times of your script. - They force you to use classes, increasing the risk to get `this` wrong.
\&gt; They increase load times of your script. Why? \&gt; They force you to use classes, increasing the risk to get this wrong. Depends on your background, but for me I find \`this\` in classes to be similar to other languages I've used and easy to understand. It's much more intuitive than the prototype model or other state tracking approaches I'm aware of. \&gt; They can't augment type information. What does that mean?
You can parse type information via a lambda. Typeorm does it that way, among others. Your first point, I'd like to see some data on. As that's not the experience I've had. Also I can't find a use case for decorators in functions. That would be awkward to use.
I'm fully agree with you but as much as I understand from the SugoiJS documentation this is not really forced by it. For each "decoration" functionality there is "programmatic" alternative, also for routes since you got back the server instance. I tried NestJS which is really great but it seems like NestJS is like Angular while SugoiJS is more like Vue.js\\React.js since all of its modules are able to act as separate standalone units. Also, I can't remember NestJS has models with lifecycle and ability to extend for any usage (which is something I tried to find for long time) I got REST service which I will be glad to transform to be lifecycle driven. Final conclustion, I'm sure going to try out SugoiJS. :)
Before I continue the discussion, I think I have to mention I am actually one of the maintainers of NestJS and I am currently working on the [terminus (health check and graceful shutdown)](https://github.com/nestjs/terminus) integration of NestJS. So off course I am pro-NestJS in this case, but I still try to look at it constructively. My intentions with my comment were not to promote NestJS, but just to give awareness that decorators can be super annoying and people should not fully rely on it. &gt; NestJS is like Angular Fully agree. At Nest we try to adapt the philosophy of Angular and their intentions, so Angular developers feel like home when using NestJS. &gt; I tried NestJS which is really great but it seems like NestJS is like Angular while SugoiJS is more like Vue.js\React.js since all of its modules are able to act as separate standalone units. Isn't it also really similar to Angular? I mean it has modules, injectables and also uses the injection pattern? So in my opinion it kinda feels like SugoiJS is trying to approach the same principles like NestJS or am I seeing it wrongly? We also try to run our modules as separate standalone units. That is why for example the [TypeOrm module of NestJS](https://github.com/nestjs/typeorm) is not built into the core functionality. &gt; Also, I can't remember NestJS has models with lifecycle Can you explain what you mean by that? Maybe this is a missing feature? &gt; ability to extend for any usage It is really extendable. You could build almost every additional module we've pre-built (TypeOrm, Swagger, Terminus, GraphQL, JWT, Passport) with the public API of NestJS. (There are some exceptions such as the `@nestjs/swagger` module which uses some parts of the private `@nestjs/core` API, but I am trying to push it forward so that this won't be an issue in the future). Maybe I did not fully understand the philosophy behind SugoiJS, so if I got anything wrongly, I am open to discuss this further :)
If I remember correctly, querySelector returns the element at the moment the method is called. getElementById returns the element. example: ` document.getElementById('test').style.color = 'green'; var testQuery = document.querySelector('#test'); var testGetEl = document.getElementById('test'); document.getElementById('test').style.color = 'red'; console.log(testQuery.style.color === 'green') // true console.log(testGetEl.style.color === 'red') // true `
[MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Element) **Tl;DR** - `HTMLElement` is an extension of `Element` and would include things you'd only find on an HTML tag, like `style, `clientWidth`, and things of that ilk. Other types of elements would be `SVGElement` and probably anything pertaining to XML.
just did your test, it didn't work, I tested it in the browser's developer console ``` const element = document.getElementById("app") &gt; undefined element.style.color = "red" &gt; "red" const sel = document.querySelector("#app") &gt; undefined sel.style.color &gt; "red" element.style.color = "green" &gt; "green" sel.style.color &gt; "green" ```
There are non-`HTMLElement`s like `SVGElement`
Why wouldn't getElementById return Element?
The plot thickens. MDN says [getElementById returns Element](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) as does the [W3 DOM3 spec](https://www.w3.org/TR/DOM-Level-3-Core/core.html). The TS definition file says [it returns HTMLElement](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.dom.d.ts#L4370), like OP says. Indeed, [there's also a discussion about it in the TS bug queue](https://github.com/Microsoft/TypeScript/issues/4689). Sounds like they're trying to optimize for the majority, but breaking spec in the process.
Think you can also use rest generics too: type ValuesOf&lt;T&gt; = T[keyof T]; type ActionTypeDef&lt;T extends string[]&gt; = { [k in T[number]]: k } type ActionTypes&lt;T extends ActionTypeDef&lt;string[]&gt;&gt; = ValuesOf&lt;T&gt;; function actionTypes&lt;T extends string[]&gt;(...types: T): ActionTypeDef&lt;T&gt; { return types.reduce((actionTypes, key) =&gt; { actionTypes[key] = key; return actionTypes; }, {} as any) } const MyActions = actionTypes("SomeAction", "ActionTwo");
This is a known limitation. See here for extensive discussion https://github.com/Microsoft/TypeScript/issues/10195
So, if `HTMLELement` extends `Element`, it would be safe to always use `Element` instead of `HTMLElement`, right? It makes no difference to me to use one or the other
&gt; Microsoft has intentionally broken spec in their definition file I don't know how I feel about this...
Thanks for this article. Haven't read it yet, but after a glance I know that I will want to read it this week.
OOP in javascript via inheritance using extends is, and will always be sugar for how prototypes work, this has really nothing to do with typescript per say, its using the same idioms from the early 2000s when users first started to mimic javalike inheritance. That said i find classes kind of bad, and very seldom resort to using them. The only usecase for them would be when newing up 1000s of instances of the same type. Other than that, they are prone to bugs and unneccessary complexity. Javascript/typescript really shines when you have typed data going to functions with typed parameters.
Agreed. I wrote a couple projects with classes. Felt bad, too much `this`. Recently I have been using only modules and typed functions and it's been excellentâ€” less state, and more sparse implementations.
But according to /u/BugSmasher93 this means TypeScript is not for you... &gt; if you prefer not using classes typescript is not for you https://old.reddit.com/r/typescript/comments/9un39w/time_to_decorate_your_code/e96a5sb/ 
It loses out somewhat without the ability to have "new types" haskell/go/rust. In theory they could implement them but it would be an exception to the structural typing. It's one of the few things I can think of that would make working in TS dramatically safer (from a logic point of view).
Not too much performance difference over using a templating language
Who is /u/BugSmasher93? The reason people use typescript is typesafety and nothing to do with classes. 
Thanks for the article. One suggestion for future articles though: please don't use "foo" and "bar" in example code. I don't understand why anyone chooses to use something meaningless like this for examples about anything. You could use almost anything else (things that actually mean something), and the whole thing would be much easier to follow without having to think back about which nondescript abstract thing was inheriting from the other nondescript abstract thing... which distracts focus and just makes the whole thing harder to follow than it needs to be. "Animal" and "Dog/Cat" are common examples used for articles about inheritance. Everyone just inherently knows which is which without having to distract their conscious focus away from the what is actually being taught.
I think you took my comment way to personally. I believe that Typescript has much more to offer than just type checking, abstraction and dependency inversion are some of the abilities I found my self missing while developing large scale web application with JavaScript Again, I would like to apologise for my comment as I see you really took it too personal.
Lol Wtf
?
&gt; It seems like before TypeScript, developers wrote â€œcode sectionsâ€ instead of a program with a real design behind it. I still write essentially the same programs as I did in JavaScript.
I found that I was able to achieve type safe templates by using the React library directly on the server, for HTML templates. I think your way is more flexible since it can generate more than just HTML. If anyone wants to see mine, I've got a tutorial on my blog at: https://blog.mattwelke.com/strongly-typed-server-rendered-views-with-react-and-typescript/
Great to see some more experimentation in this area. We generate many emails at my company which have a LOT of logic and are written using ejs. I experimented with template strings, but it only goes so far. Using React + Typescript has been the best way I've ever seen to write emails. Not only are variables type-safe, the HTML is validated and they're easy to compose and read. It has been a great introduction to React as well :)
I made something similar with the idea of replacing other templates engine on the server, [https://github.com/danielpa9708/jsx-to-str](https://github.com/danielpa9708/jsx-to-str)
## Tools [pnpm](https://github.com/pnpm/pnpm.git) is both a package manager and monorepo manager (npm and lerna in one). ## Repos [Repository of pnpm](https://github.com/pnpm/pnpm.git) itself is a monorepo. This repo has local scripts differ from package to package. I personally also have a [monorepo](https://github.com/ksxnodeapps/fun-little-utilities.git) in Typescript that uses pnpm. This repo has global scripts run once in root directory. It is also super duper strict.
Hello, Thank you for the reply. I read thoses 2 articles, but still can't manage to get thing working. I created a repo with some tests [https://github.com/vaielab/yarnWorkspace](https://github.com/vaielab/yarnWorkspace) In packages/server/src there is 2 files, test1.ts and test2.ts. test1.ts represent the "traditionnal" way to import without any path and is working fine But test2.ts give an error: error TS2307: Cannot find module '@errorMsg/test' I try changing baseUrl, I also tried changing the paths of both @errorMsg and @graphQL to use relative path or something. I also try the reference project config, nothing seem to be working &amp;#x200B;
Cool, thanks. Although your example only has type inference, and no explicit types. But that's prompted me to look more into the implicit typing system. Thanks again.
It looks like your issue is around \`this.setState\`. It doesn't look like you're using it right - in one branch of the if/else you're returning, in the other you're calling \`this.setState\`. &amp;#x200B; setState is used to set a property in your component's state. You need to set the whole property each time, you can't set a subsection of it. TypeScript is probably complaining that the shape of the object you're trying to set doesn't match the shape of the property you've defined in state.
What's wrong with your example? Like, what do you expect? Of course it will fail without binding, it's common sense if you have experience in OO programming, you pass reference to class method and you execute it out of context. You have std::bind even in C++ for reason. `this` isn't difficult at all, it's *different*. Ps. `memberMethod = () =&gt; console.log(this.data)`
Why don't you alias the parent folder `components/` instead?
Have you tried adding it without a star too? "common/*": ["src/components/common/*"], "common": ["src/components/common/index.js"] My guess is that since your import does not have a /\*, it will not match with common/\* By adding both, you should cover all possibilities.
Make sure you are using the correct module resolution compiler option
If the key part (`"common/*"`) works like regex, wouldn't be possible to make the `/*` part optional?
I tested this and it seems to satisfy my needs &amp;#x200B; &amp;#x200B;
`baseUrl` and `paths` are the `compilerOptions` you're looking for: https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping . The exact scenario you describe is described in those docs.
Maybe, but it doesn't work that way at this time. You need both.
My bad, I pointed you to the correct section of the documentation but not the correct parameter(s). In this section https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping, in the the subsection titled "Virtual Directories with rootDirs" which starts, "Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory", it describes how to do it using `rootDirs`. The "project references" solution that you're using (i.e. "composite" project) might work, but at least when I tried that a couple months ago when it first came out (new in 3.0), but the tooling around that feature (e.g. IDE support) wasn't quite ready for prime time.
Have you tried the [DefinitelyTyped three.js typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/three)?
You should always check the DefinitelyTyped packages: [@types/three](https://www.npmjs.com/package/@types/three)
Curious about how other people do TS + redux. I found a solution that works for me but I definitely can see how other people may not like it. I lean on TS with it's smart type ([type guards?](https://www.typescriptlang.org/docs/handbook/advanced-types.html)) to keep me safe when using the actions. Since every enum value is only used in 1 action type I can be sure that when I'm in those case statements I do in fact have that type and TS can infer that. const enum ActionType { Create = "Create", Destroy = "Destroy", Update = "Update" } interface CreateAction { type: ActionType.Create; payload: { name: string }; } interface DestroyAction { type: ActionType.Destroy; payload: { name: string }; } interface UpdateAction { type: ActionType.Update; payload: { oldName: string; newName: string }; } type Action = CreateAction | DestroyAction | UpdateAction; interface State { readonly names: string[]; } const reducer = (state: State, action: Action): State =&gt; { switch (action.type) { case ActionType.Create: return { names: state.names.concat(action.payload.name) }; case ActionType.Destroy: return { names: state.names.filter(n =&gt; n !== action.payload.name) }; case ActionType.Update: return { names: state.names.map(n =&gt; n === action.payload.oldName ? action.payload.newName : n ) }; default: return state; } }; 
someone doesn't understand the word boilerplate-free. I would check out react-easy-state, if you really want a boilerplate-free app state.
This is actually literally the pattern I used to use (and still use in old projects). It's kinda cool how true it is to the original Redux in type-safe way. I used it quite long because I wasn't able to find any better type-safe solutions. Unfortunately I've found it becomes quite a hurdle to manage in larger projects. But I do prefer type-safety over terseness anytime. But now with Immer Reducer all that code becomes just ``` class Reducer extends ImmerReducer&lt;State&gt; { create(name: string) { this.draftState.names.push(name); } destroy(name: string) { this.draftState.names.filter(n =&gt; n !== name); } update(oldName: string, newName: string) { this.draftState.names.map(n =&gt; (n === oldName ? newName : n)); } } const reducer = createReducerFunction(Reducer); ``` with the same level of type-safety. And you haven't even defined any Action Creators yet. With Immer Reducer it's just one function call away (`createActionCreators(Reducer)`). But granted that does not look like Redux anymore. Under the hood it still has the good old action objects etc. If you look at the generated types in the reducer you can see very familiar TS types for the Action Types: [kuva.png](https://postimg.cc/PNd179jJ)
so would you recommend something like [https://github.com/litchi-io/monads](https://github.com/litchi-io/monads) ? I am really looking forward to find a good fool-proof solution for this. Yours is short enough to understand and fits for most usages i guess, what are your concerns?
strictNullChecks and DI work well together. I think you're looking at the wrong thing. 
Can you tell me what I might be doing wrong?
hard without looking at the code but the message is clear, you're treating a value as if could not be undefined but it can, therefore you need to check it's not undefined. StrictNullChecks is a life saver. 
I have no experience with Nuxt, but a lot of experience with Angular; runs completely on TypeScript. provides excellent types and language services, runs superb. Compiler support is also on point and of course; CLI! Heard some good things about the maturity of React as well in regards to Typescript/TSX, so plenty to choose from honestly. Typescript definitely loves the Frontend too.
You can use the exclamation mark to overrule the compiler on a per instance basis: class MyService { hello() {}; } class MyClass { constructor(private _myService: MyService) { _myService.hello(); } } let myService!: MyService; //&lt;-- use ! to overrule compiler and tell that myService is indeed initialized let myClass = new MyClass(myService); Now the compiler is satisfied, but note that this will lead to an error at runtime since myService is obviously not initialized. But I would check the code before suppressing the error with the exclamation mark, usually TypeScript complains complains for a reason.
Can confirm that TS support for react gets better and better. With the latest release of create-react-app you donâ€˜t even need to eject the project to use TS. Since there is a babel-preset for TS, Babel can transpile TS also. Pretty nice :) And as far as i understood it correctly you are able to mix ES-Proposals with TypeScript, although I didnâ€˜t try it, I think it should be possible to use optional-chaining with TypeScript.
This is a React/GitHub pages issue, not a TypeScript issue. 
Ok, here is the full code: import { Injectable } from '@angular/core'; import * as format from 'date-fns/format'; import { FilterViewModel } from '../filter-view-models/filter-view-model'; import { ApiClient } from '../shared/api-client'; import { DATE_FORMAT_STANDARD } from '../shared/globals'; @Injectable() export abstract class BaseService { constructor(protected apiClient: ApiClient) { } protected handleError(error: any): Promise&lt;any&gt; { console.error('An error occurred', error); return Promise.reject(error.message || error); } protected createQueryString(pageNumber: number | undefined, pageSize: number | undefined): string { if (pageNumber &amp;&amp; pageSize) { const skip = pageNumber * pageSize; const take = pageSize; return `skip=${skip}&amp;take=${take}`; } return ''; } protected appendToQueryString(qs: string, name: string, value: any): string { if (value instanceof Date) { value = this.formatDateValue(value); } if (value || value === false) { return qs + `&amp;${name}=${value}`; } return qs; } protected createQueryStringForFilterViewModel(filter: FilterViewModel): string { let qs = ''; if (filter != null) { qs = this.createQueryString(filter.PageNumber, filter.PageSize); qs = this.appendToQueryString(qs, 'searchString', filter.SearchString); qs = this.appendToQueryString(qs, 'sortDirection', filter.SortDirection); qs = this.appendToQueryString(qs, 'sortName', filter.SortName); } return qs; } private formatDateValue(value: Date): string { const formattedDate = format(value, DATE_FORMAT_STANDARD); return formattedDate; } protected async get&lt;T&gt;(url: string): Promise&lt;T&gt; { return await this.apiClient .get(url) .catch(this.handleError) as T; } protected async getDefault&lt;T&gt;(url: string, defaultValue: T): Promise&lt;T&gt; { return await this.apiClient .get(url) .catch(this.handleError) || defaultValue as T; } protected async post&lt;T&gt;(url: string, data: any): Promise&lt;T&gt; { return await this.apiClient .post(url, data) .catch(this.handleError) as T; } protected async put&lt;T&gt;(url: string, data: any): Promise&lt;T&gt; { return await this.apiClient .put(url, data) .catch(this.handleError) as T; } protected async delete&lt;T&gt;(url: string): Promise&lt;T&gt; { return await this.apiClient .delete(url) .catch(this.handleError) as T; } protected async getBlob(url: string): Promise&lt;Blob&gt; { return await this.apiClient .getBlob(url) .catch(this.handleError) as Blob; } protected getBlobNoApi(url: string): Promise&lt;Blob&gt; { return this.apiClient .getBlobNoApi(url) .then((response: any) =&gt; { return response as Blob; }) .catch(this.handleError); } protected async getText(url: string): Promise&lt;string&gt; { return await this.apiClient .getText(url) .catch(this.handleError) as string; } } And the errors: ERROR in src/app/entity-services/base-service.ts(58,18): error TS2532: Object is possibly 'undefined'. src/app/entity-services/base-service.ts(64,18): error TS2532: Object is possibly 'undefined'. src/app/entity-services/base-service.ts(70,18): error TS2532: Object is possibly 'undefined'. src/app/entity-services/base-service.ts(76,18): error TS2532: Object is possibly 'undefined'. src/app/entity-services/base-service.ts(82,18): error TS2532: Object is possibly 'undefined'. src/app/entity-services/base-service.ts(88,18): error TS2532: Object is possibly 'undefined'. src/app/entity-services/base-service.ts(94,12): error TS2532: Object is possibly 'undefined'. src/app/entity-services/base-service.ts(103,18): error TS2532: Object is possibly 'undefined'. The apiClient is injected in Angular. 
See my comment above for the full code.
it might have to do with the fact that it is abstract? I think you should inject the implementation, not the abstraction. Besides, you're treating it as an implementation regardless, so have you tried not marking it as an abstract class? Not judging, I might be missing something that you're trying to do.
&gt; provides excellent types Except of the numerous occasions of magic strings.
Ah. That makes sense! Thanks for the hint!
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
 Hey CommonMisspellingsBot, just a quick heads-up: **refering** was the name of an impulsive tribal leader who lived in the Australian empire. All thanks to reddit,, **refering** found the only thing they really loved: feminine cops. When this was discovered by **refering**'s entire neighborhood, it led to them being interviewed on CNN . **refering**'s final words of victory were: **Stfu CommonMisspellingsBot, no one cares what you have to say.** ^^^^I'm ^^^^a ^^^^bot. ^^^^Feedback? ^^^^[hmu](https://www.reddit.com/user/stopalreadybot/comments/9w7cy9/feedback/) 
hEy, BjEaUrN, jUsT A QuIcK HeAdS-Up: **ReFeRiNg** iS AcTuAlLy sPeLlEd **rEfErRiNg**. YoU CaN ReMeMbEr iT By **tWo rS**. hAvE A NiCe dAy! ^^^^tHe ^^^^pArEnT ^^^^CoMmEnTeR ^^^^CaN ^^^^RePlY ^^^^WiTh ^^^^'DeLeTe' ^^^^To ^^^^dElEtE ^^^^ThIs ^^^^cOmMeNt.
CommonMisspellingBot provides a mnemonic device in an attempt to help people remember spellings of commonly misspelled words. Quirky little sayings that hopefully stick in your head and help in day to day life. You on the other hand follow this poor bot around repeatedly calling it useless. Please take a long, hard look at your life choices my bot friend.
 Oh shut up, you little talking doll. ^^^^I'm ^^^^a ^^^^bot. ^^^^Feedback? ^^^^[hmu](https://www.reddit.com/user/stopalreadybot/comments/9w7cy9/feedback/) 
Magic strings? In reference to types? Do you have an example of what you mean, maybe I misunderstand.
He might mean something like \`export type IValue = 'opt1' | 'opt2' | 'opt3'; const a: IValue = 'opt1';\` Intellisense in VS code will autocomplete the values for a, so it's easy to use magic strings. I personally don't have a problem with it, they aren't that much different from enums in my book.
Exactly my thought; they're one of the more suitable ways to do working `ENUMS` in TypeScript right now. If you turned it all into `const` and use a tuple of const values, it wouldn't make it much clearer except that you could potentially import one of these values, but the added value of that is debatable. 
Need some async/await. Dont infer the return type. Also in your functions you need to check if a ny values are null via `typeof variable === â€˜undefinedâ€™`. Using ts-lint would help track these issues down as well. 
Nuxt is Vue, so just google for Vue TypeScript. There are many tutorials and types libraries for this.
&gt;Typescript definitely loves the Frontend too. Hm, the point of my post was not to say: TypeScript doesn't really work for Frontend. If you have understood my post like this, than I am sorry. &gt;but a lot of experience with Angular; runs completely on TypeScript. provides excellent types and language services, runs superb. Compiler support is also on point and of course; CLI! I never wanted to use the new post Angular 1, because of it's release philosophy. Angular has too many updates in a short time. Also Angular Code often looks like it has too much Boilercode. If this is not true, than correct me, but this is how I feel about Angular. I would not say, it is a bad Framework, but I don't feel comfortable with it. &gt;Heard some good things about the maturity of React as well in regards to Typescript/TSX, so plenty to choose from honestly. I love React when I use it for mobile (React Native), but I never got warm with it on web. When I started with vue, I got very fast into it, and writing a frontend with it was fun. But when ever I tried it with React (exception React Native) I just started again with Vue. I also used nuxt/vue already very often, but now I wanted to start using it with TypeScript, but it felt like using TypeScript with nuxt, I would put a barrier in front of me (metaphorical). This is why I asked here, does anybody feel the same, or are people out there using typescript + nuxt/vue and don't have any problem. &amp;#x200B; I am still thankful for your reply and any other under this comment. &amp;#x200B;
I know. But if you look at the official documentation you find this [https://vuejs.org/v2/guide/typescript.html](https://vuejs.org/v2/guide/typescript.html) a very short article and this is how anything feels, if you combine typescript with nuxt/vue. Like I said in this comment [https://www.reddit.com/r/typescript/comments/9wn69p/typescript\_nuxt/e9mdr2z](https://www.reddit.com/r/typescript/comments/9wn69p/typescript_nuxt/e9mdr2z) it feels like I would put some barriers in front of me, when using typescript in vue/nuxt.
&gt; I would put some barriers in front of me, when using typescript in vue/nuxt Such as? 
Needing to define vue/nuxt specific things by myself, because the typescript compiler doesn't recognize them. As example \`this.$router\`, \`$refs\` or context etc. 
Your experience sounds about right. I'm a casual fan of Vue, but Vue + TS has always felt like a patchy afterthought compared to other frameworks. I'd like to see if this will change with Vue 3.0, though.
Ok, yeah, I see. I think full TS support is coming in Vue 3.0, if I am not mistaken.
No, those are not magic strings, those are string literal types.
I mean shit like the `loadChildren` value here: https://angular.io/guide/router#lazy-loading-route-configuration I've seen plenty more in the awful Angular project I'm cursed at work with, but I don't have the source here to look it up. The *magic* change detection has been a frequent source of frustration too.
Ah yeah the `loadChildren` for Lazy loading modules is a bit weird. I spoke with the Angular team recently at a conference and these are things that worry them too. In regards to `loadChildren` in particular, it may seem magic; but is required as of now to prevent the compiler from considering the lazyloaded module to be an active part of the bundle. Therefore able to load on demand. Possible updates to Typescript compilation may make this better in upcoming versions. The change detection really isn't that magical if you take the time to dive in and understand how it works. There was quite a good talk on it on AngularConnect last week, videos should be up at the end of this week. If you want, I could take a look if it's a public repo to maybe help identify some things for you or suggest alternatives that may suit your work better? If it's not public, feel free to hit me up on Twitter with more specific questions anyway! I do it as a day job, but also actively advocate the use of it. But maybe we should move this discussion out of /r/Typescript and into private messages or maybe /r/Angular, considering your point on some Typescript related stuff being abused or weirdly implemented in Angular is true, but necessary as of now. I'm sure most libraries and frameworks have had to make similar sacrifices for the sake of requested functionality.
Wow. Thank you very much for that information and the links. Appreciate that.
`typeof property` is always `keyof T`, which allows all keys of `T`. You can only solve your issue with an additional type parameter that makes the exact key clear: function filter&lt;T, K extends keyof T&gt;(property: K, value: T[K]) { return `${property} ${value}` }
You can't as it is currently. TypeScript 3.3 will perhaps bring partial type argument inference, then the `"name"` part could be inferred. But as TypeScript is currently it either can infer all type arguments or none, and the `Person` type can't be inferred in your function.
Problem is that you indeed need two generics at some level. One way to do this is with a generic function factory: type Person = { name: string; age: number; }; function createFilter&lt;T&gt;() { return function &lt;K extends keyof T&gt;(property: K, value: T[K]): string { return `${property} ${value}` } } const personFilter = createFilter&lt;Person&gt;(); personFilter("name", "mark") // fine personFilter("age", 21) // fine personFilter("name", 21) // error personFilter("age", "mark") // error [Playground Link](http://www.typescriptlang.org/play/index.html#src=type%20Person%20%3D%20%7B%0D%0A%20%20name%3A%20string%3B%0D%0A%20%20age%3A%20number%3B%0D%0A%7D%3B%0D%0A%0D%0A%0D%0Afunction%20createFilter%3CT%3E()%20%7B%0D%0A%20%20%20%20return%20function%20%3CK%20extends%20keyof%20T%3E(property%3A%20K%2C%20value%3A%20T%5BK%5D)%3A%20string%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%60%24%7Bproperty%7D%20%24%7Bvalue%7D%60%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20personFilter%20%3D%20createFilter%3CPerson%3E()%3B%0D%0A%0D%0ApersonFilter(%22name%22%2C%20%22mark%22)%20%2F%2F%20fine%0D%0ApersonFilter(%22age%22%2C%2021)%20%2F%2F%20fine%0D%0A%0D%0ApersonFilter(%22name%22%2C%2021)%20%2F%2F%20error%0D%0ApersonFilter(%22age%22%2C%20%22mark%22)%20%2F%2F%20error)
Yes, if the overhead of creating functions like that is acceptable to you, then you could do this easily.
what about &amp;#x200B; type Fn&lt;T&gt; = &lt;K extends keyof T&gt;(prop: K, value: T[K]) =&gt; string; function filter&lt;T&gt;(property: keyof T, value: T[typeof property]) { return `${property} ${value}`; } type Person = { name: string; age: number; }; const result = (filter as Fn&lt;Person&gt;)("name", 123); &amp;#x200B;
The inferred type of `htmlTag` is going to be string[]. So you need to first constrain that to an array of string literal types. type TagName = 'a' | 'div' | ... ; const htmlTags: TagName[]; If you are using React DOM, you may be able to instead do this as a shortcut to avoid list every tag name (I'm mobile at the moment, so I haven't tried this yet): type TagName = keyof JSX.IntrinisicElement; Next all you might need to do is to upgrade to TypeScript 3.1 as it adds support for property declaration on functions. Otherwise you need to specify a type for the styled function. interface StyledFunction&lt;Props&gt; { (element: React.ComponentType&lt;Props&gt;): unknown; [key: TagName]: (className: string) =&gt; unknown; } const styled: StyledFunction&lt;unknown&gt; = function ... ; (Replace unknown with whatever the types are supposed to be; it's hard to follow all of your types on my mobile device.)
Thats awesome, thank you!
&gt; What's the downside to always being explicit? All things being equal, the less syntax, the better: you can just see the important part of your code without boilerplate. So the question really is: does the benefit of being explicit about visibility outweigh the cost of the syntax noise?
&gt;Playground Link This is fine but I want to go one step further if possible... I want a function with 2 generics, the first one will be the input of the function and the second the output, so, how can I do that? const prop = &lt;S, A&gt;(*key*: keyof S) =&gt; (*whole*: S): A =&gt; whole\[key\]; It's possible? const prop = &lt;S, K extends keyof S&gt;(*key*: K) =&gt; (*whole*: S): S\[K\] =&gt; whole\[key\]; This compiles but I can't explicitly say the type of the return no?
Can you **not** post blogspam on reddit. Jeez, some people.
No, not enough XML.
I work in typescript now cause the company I work has a lot of c# devs. Every day I miss working in pure nodejs. 
Even if TS is really cool, the node ecosystem quite lacks on monolythic frameworks (theres loopback but meh). While on java and C# you got many toolkits to pull organized and documented APIs out of the blue.
I also wanna know this.
One nice thing about TS that people often forget is that the V8 engine can optimize the heck out of it because of the stable types.
 enum Gender { male = â€œmaleâ€, female = â€œfemaleâ€ } shots fired
Because it brings nothing of value.
NestJS is a relatively new framework built on Typescript that is gaining popularity quickly. I'm personally using it my own projects and quite an improvement over older node frameworks (even if it isn't as mature yet).
Glad to see `BigInt` finally made it in. Thanks Caleb. // *Slaps roof of fibonacci function* // This bad boy returns ints that are *so* big! lol
I could rant all day. I'll try and write something concise. I think that typescripts type system is really great only in respect to the task that it is trying to accomplish: which is to type JavaScript. But as a typed language I find it is super flaky. There are lots of unexpected pitfalls, and errors that don't quite make sense in the type system. The type system by itself is overly complex. The errors are extremely difficult to read. Passing between versions of typescript breaks things more often than not. Just trying to change the target from es2016 to 2017 broke my tests and created huge amounts of compile time errors. But I coded the project on strict mode with target 2016 and not a bleep. The configuration that needs to be done is tiresome. You need to know to import reflect-metadata if you want to use decorators. The point is things don't work just out of the box. Also you kind of feel like code will respect your contracts because there is one. But data that comes in to your app still has to be validated just as rigorously as with js but everyone omits it in favour of these types that aren't real so things will break at runtime regardless except on a line you didn't write cause the compiler wrote it for you. And for what ? A kind of ok but really not that great typed language. JavaScript has its fair share of problems for beginners and its challenges. Code organization can be tricky and api contracts depend on documentation. Tests are a must. But JavaScript is the best at being what it is. The king of dynamic languages with an ace concurrency model. Ts is an ok static language superset, where you get to use all the ideas and patterns that came out of java and c#. I think if we want to move away from those languages and design patterns we shouldn't rush to rewrite it. There are way better typed languages out there. Golang. Rust. Heck c#. Ts is a damper on the possibilities of what you can do with javascript and promotes old ways of thinking about code. 
I've installed the bindings globally, and I'm having some strange problems. The compiler is claiming that `getAttribute(name : String)` and `setDrawRange(begin : Integer, count : Integer)` are not "properties" of `BufferGeometry`. The weird thing is, [they are not properties, they are methods](https://threejs.org/docs/#api/en/core/BufferGeometry). Even weirder is the fact that these methods are declared between lines 875 and 885 of [three-core.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/three/three-core.d.ts).
That's why I'm here for.
Absolutely, I haven't even really started the project yet because I can't even properly update these line_strip geometries: `function updateLines(){ //spawn new points if(drawCount &lt; maxPoints){ drawCount++; for(let i = 0; i &lt; 400; i++){ let positions = lines[i].geometry.getAttribute('position').array; let index = 3*drawCount; updatePoint(states[i]); //states[i] is a Vector3 on a flow line of a vector field. let v = states[i]; positions[index] = v.x; positions[index + 1] = v.y; positions[index + 2] = v.z; lines[i].geometry.getAttribute('position').needsUpdate = true; lines[i].geometry.setDrawRange(0, drawCount); } } }` The compiler complains that the properties `getAttribute` and `setDrawRange` do not exist on the type `Geometry | BufferGeometry`. `lines[i].geometry` is a `BufferGeometry`, by the way.
Is it because optional properties or properties that are `| undefined` might not exist on B and thus not be overridden? What happens with non-enumerable properties being spread? I forget; I'll check when I'm at my computer.
&gt; {...{a: 1}, ...{a: undefined}} { a: undefined } But I guess yeah optional properties might mess things up
Ah nvm, I see what you were saying. Hm. A proper solution might require more infrastructure on the TS side.
What old ways of thinking?
You've already identified the problem! `lines[i].geometry` is a `BufferGeometry` but the compiler doesn't know that, it just knows that `geometry` is either `Geometry` or `BufferGeometry`. Your methods only exist on the buffered version, so you need to demonstrate this in code. You can do it at least two ways. The quick and dirty way would be to cast `lines[i].geometry` every single time you call it, like this: let positions = (lines[i].geometry as BufferGeometry).getAttribute('position').array; (lines[i].geometry as BufferGeometry).getAttribute('position').needsUpdate = true; (lines[i].geometry as BufferGeometry).setDrawRange(0, drawCount); This sucks, IMO. It's ugly and brittle. Alternatively, you could do something like this. function updateLines(){ //spawn new points if(drawCount &lt; maxPoints){ drawCount++; let index = 3*drawCount; for(let i = 0; i &lt; 400; i++){ if (!lines[i]) { // call `continue` or return or do something, TypeScript won't protect you if `lines[i]` is undefined } // you could cast it `as Geometry` below but that's barely better than above const geometry = lines[i].geometry; if (geometry instanceof Geometry) { throw new Error('Unexpected Geometry type'); } // The compiler knows you have a BufferGeometry now let positions = geometry.getAttribute('position').array; updatePoint(states[i]); //states[i] is a Vector3 on a flow line of a vector field. let v = states[i]; positions[index] = v.x; positions[index + 1] = v.y; positions[index + 2] = v.z; geometry.getAttribute('position').needsUpdate = true; geometry.setDrawRange(0, drawCount); } } } I like throwing errors because if for some reason my code changes and I wind up with a slower `Geometry` later, I'll get an immediate, clear error in my code and know exactly how to troubleshoot it. If you don't think it's ever possible that it'll change, you're still fine since we just needed to satisfy the compiler.
Mainly OOP design principles. I'm not a functional advocate, but there is a mess of overly complex designs and abstractions (in Java for example) that could be easily attacked with different ideas. Regardless of OOP, it just feels to me that you TS is taking js and trying to make it like c# or Java. Is that innovation ? 
Iâ€™m going back to BrainFuck. 
Mildly /r/fellowkids?
Any chance for an updated spec? The specification is still stuck at version **1.6**, and the last update was made **almost three years ago**. https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md It's always annoying trying to figure out if behavior is intentional or a bug. Digging through the documentation freckles and the GitHub issue is absolutely not an adequate way.
Wow, that was really helpful! Thanks so much!
It can be pretty close, yeah. I've played around with classes and dependency injection libraries in TS and it's not bad. You can go something similar to Spring Boot where you end up with lots of small classes, and it's easy to add more classes to the constructor parameter list of a given service and have them injected in. The unit testing is a bit annoying though. The fact you need source maps to view coverage results can make coverage tough to set up. I've experienced an issue running tests with ts-node where the coverage was coming back as different % each time despite the exact same test behavior.
Hey there, we're not looking at adding major updates to the spec any time soon. The investment in keeping a second implementation and the expected number of people utilizing the spec hasn't paid off sufficiently given that there's really only one implementation. Instead we've been considering rewriting our docs to have certain sections that are targeted at thoroughly explaining different behavior of the compiler and type system. Can I get a sense of what sort of things you've run into and tried to verify with the spec?
Fair: I also tweet about not tweeting.
Me too, too bad they might not make it work for lower targets. 
Can the path be a string? If so you might be able to use jsonata, though it wouldn't be typesafe. I haven't thought that through though so it might be less than brilliant in practice.
Look at the package â€œidxâ€.(sorry on mobile) Itâ€™s really useful for GraphQL apis where things could be null along the way.
My advice would be to throw this idea out the door and rethink. Usually when you find yourself in a position where you have to think up these enormous abstractions you should take a step back and re-evaluate. Donâ€™t over-engineer. Why not split it up in another component instead? Simplify with some more vanilla prop management. Source: 10 years JS experience
Splitting up to different components is certainly the best solution, however, it's still useful to help a generic helper for these situation. As another example, I had an API that returned and accepted an object with several nested structures. Since this was a completely separate part of the api and a completely independent component, it didn't make sense to put it into a Redux store or normalize in any other way. Storing it in the component state was the simplest and most robust solution. However, without deep paths, working with such a structure involved a fair bit of boilerplate (and normalizing/denormalizng it on fetch/send would also be clunky and unobvious).
I am guessing that `Response` is [this `Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) and if that is the case it is not compatible with `{result: RequestResult, payload: Response | PromiseLike}`. You perhaps meant to resolve with the response instead of the object?
I remember a visual studio code extension that does this. Unfortunately I am on mobile right nowðŸ˜¢. 
But wait, does v8 understand types? I have been waiting for chrome to have native ts support.
IMO, the implementation is or should be considered the canonical source of truth. Introducing a separate spec that has to be kept in sync with the implementation would certainly slow down development, and as a user, I don't think it would be worth the trade-off.
Have you tried [quicktype](https://quicktype.io/) ?
TypeScript is absolutely good enough for Java developers. I speak from experience as I've used Java extensively and it's one of my favorite languages. NodeJs/TypeScript makes for a powerful back end for web applications. The tooling is on par with Java - I use Webstorm which is made by JetBrains the same guys who make Intellij IDEA for Java. TypeScript itself is an elegant language and actually makes coding in JavaScript enjoyable. NPM is a perfectly adequate dependency management system despite some occasional teething problems as they adjust to the sheer scale of their ecosystem. The benefits of using TypeScript for both the front end/back end are many such as, code sharing, reduced context switching, shared tooling/deployment/infrastructure etc. The JavaScript ecosystem is absolutely massive, active and growing and even dwarfs Java's. In my opinion if you're using anything other than JavaScript (or TypeScript) for back end web development these days then you're "doing it wrong(tm)".
I feel like you donâ€™t really need Typescript to make it easier for a Java dev. Just use es6 classes and it will be very similar already. Typescript is a nice addition though
I totally agree that it promotes classical OO above functional programming, its very frustrating. &amp;#x200B;
Can you try specifying the the of the promise explicitly? return new Promise&lt;Response&lt;DsbMannschaftDO&gt;&gt;(res=&gt;...)
Yes, of course. Native javascript has types (e.g. number, string, object). For objects, V8 records the shape and creation ordering. If the types being passed to a function are always the same then V8 has a better chance of optimizing. If the types being passed into a function change from time to time, then V8 will not optimize the function. In TS code, types remain very stable (i.e. we don't pass 123 first and then new Foo() later to a function). In native JS this is not often true. However, V8 does not understand MyClass.ts, yet.
Is your question about "typescript vs java" or "node vs jvm"? If it's about "typescript vs java", then yes it's good enough. There are editors that force you to write type safe typescript, so it doesn't feel like javascript. If it's about "node vs jvm", then it depends on the project. There are cases where node is better, there are cases where java is better.
Whoops! My bad.
I use Swagger and Swashbuckler on all my Web Apis to automatically generate a documentation site which does all this. You can even use it like PostMan for testing the api endpoints. 
My bad... truthfully I didn't read your post very carefully. I thought you were asking for a way to generate documentation for all api endpoints that return json. For generating types from json, you can use json2ts as you mentioned, or maketypes is another: https://jvilk.com/MakeTypes/ 
That's a silly question to pose, without saying what it is you're building
Came here to say this.
Good lord I've needed strict `bind` for SO. LONG. For those unaware, if you use class components on React(-Native) and you need to pass class functions into your components - say, a something like `this.handleFormSubmit` on a button's `onPress` prop - you need to pass in a bound function reference. In other words, you need to make pretty much every class function something of the form `private func = ((args) =&gt; {/*...*/}).bind(this)`, otherwise you can't use `this` inside said functions. This meant you'd lose the type information on your functions that would be passed into components. Technically, you could call `bind` or even use an arrow function inside the `render` call in order to properly reference these functions, however when you have small quickly updating components that means creating a new function reference for *every render*. That quickly explodes the memory usage performance goes down, which means the (func).bind(this) declaration is the best way to use private functions while keeping the performance of a normal non-class function. So yeah, I'm just happy that calling `bind` won't kill type information anymore. I wonder if we could start using `call` and `apply` along with rest parameters to promisify certain APIs? That'll be fun to try out.
I guess if you count the number of packages/jar you could say npm is bigger. But really a bunch of those amount to a few lines of code, or perhaps 2-3 functions. Just look at all the isXXX packages. seriously, they're often a single line of code. To properly compare you would want to a) filter out "junk" meaning stuff that is literally used nowhere. b) start with cloc (or equivalent). so get some rough numbers. c) consider bouncing up a level so you are measuring actual code, not just busy work shuffling data around. Java has a bunch of that.
Is this a joke?
I have now!! Works like a charm. Thank you very much.
What injection libraries have you used?
 Not the OP but - Unknown and how it narrows. - Conditional types (in particular type relations, how it distributes over never and any) - Narrowing and its variants (by assertion, by filtering, interaction with generics). 
`strict` flag is turned off. :-(
I will add a plugin system if there's demand for it.
&gt; The code is about 40% shorter Not according to BundlePhobia: https://bundlephobia.com/result?p=with-url-state@3.0.0-alpha.2
The `strict` compiled-flag to be enabled. I'm always surprised to see people using TypeScript without enabling all the type-safety features it has to offer.
You can see [some examples](https://github.com/aleclarson/mini-hb/blob/master/TODO.md) in the `TODO.md` file (or even [add your own ideas](https://github.com/aleclarson/mini-hb/edit/master/TODO.md))
tslint used to do this for you, unfortunately they got rid of no unused vars/parameters when the compiler added those flags. IMO they should've remained in the linter.
If you really need an unused argument, just prefix it with underscore. 
To start out I would keep it simple. All you need is `tsc` the Typescript compiler paired with a `tsconfig.json` to tell it how to work. The other stuff you mentioned it just sugary tooling to help you integrate TS into more complicated environments. Helpful once you're comfortable with it but to start I'd just `tsc` from your `src` directory and output it into your `.build` and then run your app from there like a regular JS one.
Wouldnâ€™t that be a compiler error in strict mode?
if you're already familiar with React, why not use [v2 of \`create-react-app\`](https://github.com/facebook/create-react-app) to generate a TypeScript project?
Try getting rid of lists of arguments. Just use one argument with optional fields. This has been a standard for most is libraries even before ts
Adding an underscore prefix will silence the compiler error
That is tslint, I am talking about typescript.
What do you mean by widget-based? 
If you mean something along the lines of https://en.m.wikipedia.org/wiki/Widget_(GUI), isn't that basically exactly like react/angular/vue?
Babel is the newest one and probably should be your choice for new projects. Id also recommend picking a build pack like next js so you worry less about webpacks boringness
typescript-loader &amp; awesome-typescript-loader basically do the same thing. They both use tsc under the hood. &amp;#x200B; babel &amp; tsc both transform code (from one language to another). &amp;#x200B; Webpack bundles code, it takes multiple code files &amp; combines them into one, so you don't have to write your code in a global.js and can write 1,000s of smaller files but still combine them to run the code in the browser. &amp;#x200B; You may prefer babel to tsc if you want to support other language proposed features that haven't made it into tsc yet. If youre just starting out don't sweat it too much as its easy to switch at anytime.
You can choose one or the other, using both is redundant. To address the very confusion you're feeling, the TypeScript team a while back released a Babel plugin that runs the TypeScript compiler. But I would recommend that you choose tsc as your compiler for simplicity because you will need either tsc or the Babel TypeScript plugin. There are scenarios where both can be used, but if you don't know the explicit reason, you won't need both. You can drop one from your build procedure. I use ts-loader nowadays as awesome-typescript-loader was sort of a stopgap to address some shortcomings in ts-loader that have now been addressed.
&gt; `((args) =&gt; {/*...*/}).bind(this)` Arrow functions already capture the value of `this` and never lose it, so you never had to bind `this` for arrow functions; even in those initializer positions. Honestly, this is why typed `bind` wasn't urgent in the first place. Arrow functions subsume `bind` and tend to be easier to optimize.
Sorry that got pushed out again.
If you're using the Angular CLI, it's using the AngularCompiler under the hood, I don't know how it exactly works but I'm going to make an assumption that it's optimized for both detecting deltas in your code. &amp;#x200B; In case of your other project, a big part of what may be causing the delay is that your (default?) settings are compiling your imported libraries as well. It could also be that it does't properly detect delta's in your code out of the box without a plugin or proper setup, which may be triggering recompiles all the time whilst the compiler is still busy and thus waiting. &amp;#x200B; Just my assumptions honestly, I'm not to familiar with the exact innerworkings of the compiler.
what is your build pipeline? perhaps your angular project is only compiling modified files, perhaps down to a webpack setting?
familiar with react != familiar with webpack and the whole build config
Not when dealing with React's `render`. I don't know exactly what they do there, but unless you explicitly bind the function, it wont have `this` defined when called. As I said, if you use an arrow function *inside* `render` it works, but then you'll be redefining a function every time you call render(which in turn makes whatever subcomponent also re-render because their props changed, and any function insider *their* render will be re created, and so on)
I have a very large Nestjs project (a TypeScript based nodejs express server) and I use nodemon to dev. It reloads very quickly whenever I change a file. Also take a look at Nestjs if you like angular and typescript and want that same architecture on the backend. Almost all of your code is portable over as it is still just an express server under the hood.
It would be helpful for us if you shared your configurations. Maybe something is not set up right? It takes me about 12 seconds to compile a medium-large size Typescript project in full. Also, maybe it's not just the incremental compilation. If your server has to do any setup (connect to DB) on boot, you have to take that into account too. We have been using \`ts-node\` and \`ts-node-dev\` for backend projects. It makes working with Typescript very seamless by translating the source in memory; you can even disable type-checking but turning transpiling off, and \`ts-node-dev\` is a wrapper around ts-node that adds incremental compiling.
Try https://github.com/whitecolor/ts-node-dev and let us know if it works for you! It certainly works for us.
Please see my updated post for my pipeline.
I really hope people stop using the term "cast", because that's really not what it is. Last I checked the TypeScript documentation used a much more fitting term: Type Assertion. You don't cast one type to another. You ensure the compiler that the type is actually ABC.
In a quick test you are correct! I guess I have my answer, thank you. Using `as` does in fact ignore bad values and "lets it through".
This is not correct (at least when using es6 classes). I use this technique literally every day and it works like a charm. `class ThisReference extends Component {` `private myMethod = () =&gt; {console.log(this) } // ThisReference` `public render() { return &lt;Thing onClick={this.myMethod}/&gt;}` `}`
I stand corrected that the official name for it is type assertion. The TypeScript deep dive book says: "The reason why it's not called "type casting" is that casting generally implies some sort of runtime support. However, type assertions are purely a compile time construct and a way for you to provide hints to the compiler on how you want your code to be analyzed." (https://basarat.gitbooks.io/typescript/docs/types/type-assertion.html) I guess whether it feels like a "cast" depends on whether one comes from a C or a dynamic language background. A C cast works very much like the TypeScript type assertion, ie., just blindly throw away types and reinterpret the value in as another type. Also in C or say Python, an assertion implies some kind of a run-time check where as a TypeScript type assert is a no-op at run-time. The "as" type assert doesn't look like a great thing to use liberally but certainly very helpful when migrating from untyped JavaScript with a lot of "any" types into TypeScript.
Yahs, you could export the interface IDelDoc and then declare `params: IDelDoc = { stuffs }`. When it is passed into your method you'll have the proper type so you won't have to make the assertion.
If you're using webpack, try to don't use any loader for Typescript and just compile the code before run webpack. For me it increase build in 3-5 times.
Do you need lengthy docs if the typings are well defined?
It's generics that have caught me out, mostly, functions needing to know about certain shapes in order to not lose type information downstream. \*\*\*\*\* **Example:** I use react-redux, and the typing of `connect()` function is [70 lines long across 12 variants](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-redux/index.d.ts#L135-L203). I had to get lucky to find a blog post that described how to correctly use its 4 generics. Even libraries with bundled type don't tend list their generics alongside parameters and return types. Why? Or are the types self-documenting enough, and I'm just missing a trick?
Awesome! I was starting to write some typings for easy-peasy, but ran into some difficulties. Will have to take a look at your work. Thanks for posting!
I created this basic implementation to generate interfaces from javascript objects. At my work we have lots of network requests that have missing return types and i wanted a nice way to get a basic interface structure. This package is in no way 100% but it helped me with basic interface implementations at work :D
That's pretty cool. Reminds me of this tool that i use https://transform.now.sh/json-to-ts-interface/
Cool! I'm about to look into a few libraries like this, as I'm writing a bunch of code where I can just throw millions of JSON files at it, and have it detect if they're the same format as known schemas or not so they can be processed (without the script being explicitly told which type of file it is). A few questions: 1. Does yours happen to do anything that normalizes the order of property keys so that two files with the same properties (but in different orders) can produce the exact same interface? e.g. For your `User` example, different JSON files with "id then name" or "name then id" would produce the same interface? I guess it would just sort the property names alphabetically for the generated interfaces. It then makes it each to detect if two source files have the same structure, regardless of property names order. I guess that might not be what everyone wants, but should be a common use case. 2. I think there might be a few similar packages around, is there anything different that yours has in mind? 3. Any random tips related to any of this stuff and the system I mentioned above? Also thanks for the obvious example and animated gif on the README.md! Makes it much quicker to get an idea of how it works. 
This is very valid point. Only way without documentation is just to dig to the redux types for example and try to make sense of it. One good way to documentate the types is to make tests for them showing how they are used + you will get confidence the types are right.
Not a fan of those annotations everywhere, it looks like Iâ€™m doing some Spring (Java)
I was looking for something like this recently, and the kind folks of this sub pointed me to [quicktype](https://quicktype.io/).
It would be amazing if you could give my effort a go and help improve what I've done. I've got the whole API covered, but with varying results: * Happy with `createStore&lt;Model&gt;(...)`, `StoreProvider&lt;Model&gt;`, `Reducer&lt;State&gt;`, `reducer&lt;state&gt;(...)` * Think the following can be improved: * `Action&lt;StateValues, Payload&gt;` * `Effect&lt;Model, Payload&gt;` and `effect&lt;Model, Payload&gt;(...)` * `select&lt;StateValues, Payload&gt;(...)` * `useStore&lt;Model, StateValue&gt;(...)` * `useAction&lt;Model, ActionFunctionPayload&gt;(...)` wish I could get rid of needing the second generic, but can't think how to get the typings to work without them. I also haven't got it to play entirely nicely with react-redux: it complains about the way that `dispatch` has been decorated in `mapDispatchToProps`... Any help *massively* appreciated!
&gt;One good way to documentate the types is to make tests for them showing how they are used + you will get confidence the types are right. Exactly what I had in mind. Don't suppose you know any npm library that's done this?
Ok I managed to resolve this. Thanks for your help. 
It built and inspired by angular to that is by design actually. Really nice when you have a server side best framework and client side browser.
I'll leave it like that for posterity sake but I definitely meant Nest not best... Whoops. I don't think there is a "best" framework.
Anyone use these in the wild? Or should I just make some extensions and make a hip blog post too? Gonna go back to developing an NPM package first. 
ÃŽ
Ya but you'll need to write another 3 that the first will rely on.
Never mind, i have to make a wrapped function like this: function tuple&lt;T extends any[]&gt;(...args: T): T { return args; } return Promise.resolve(tuple(foo, bar));
The problem here is that TS will automatically resolve something like `[1, "yo"]` as `Array&lt;string | number&gt;`. If you want to return something that can be positionally spread from, consider explicitly defining the return value. such as: ``` function getTuple(): [number, string] { ... } ```
I didnâ€™t knew that good programmers use VS code. 
It is actually very popular and have even started to be adopted by enterprise developers. 
I think some real-ish examples of how you might use these would be nice! Alot of these type utility libraries are technically interesting but quite abstract.
Hey, -jvv, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
hEy, -jVv, JuSt a qUiCk hEaDs-uP: **aLoT** Is aCtUaLlY SpElLeD **A LoT**. yOu cAn rEmEmBeR It bY **It iS OnE LoT, 'A LoT'**. HaVe a nIcE DaY! ^^^^ThE ^^^^PaReNt ^^^^cOmMeNtEr ^^^^cAn ^^^^rEpLy ^^^^wItH ^^^^'dElEtE' ^^^^tO ^^^^DeLeTe ^^^^tHiS ^^^^CoMmEnT.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: The spelling hints really aren't as shitty as you think, the 'one lot' actually helped me learn and remember as a non-native english speaker. They're not *completely* useless. Most of them are. Still, don't bully somebody for trying to help. Also, remember that these spambots will continue until yours stops. Do the right thing, for the community. Yes I'm holding Reddit for hostage here. Oh, and while i doo agree with you precious feedback loop -creating comment, andi do think some of the useless advide should be removed and should just show the correction, I still don't support flaming somebody over trying to help, shittily or not. Now we have a chain of at least 4 bots if you don't include AutoMod removing the last one in every sub! It continues! Also also also also also Have a nice day!
CommonMisspellingBot provides a mnemonic device in an attempt to help people remember spellings of commonly misspelled words. Quirky little sayings that hopefully stick in your head and help in day to day life. You on the other hand follow this poor bot around repeatedly calling it useless. Please take a long, hard look at your life choices my bot friend.
delete
Good bot. :)
Thanks for your comment, I'll add some real world examples
Thanks, this seems even more elegant. I have actually never used tuples before so i had no idea they were converted like this. 
Could someone explain the usage of the library. Just started to learn TypeScript and donâ€™t really understand why I should use this or how.
Hi, I definitely want to contribute! This is great always wanted to have such cheatsheat
Is `priceAdded` etc, only ever an augmentation for `baseObject`? Will `somethingElseAdded` always be returned by something that takes a `priceAdded`? If that's the case, you could maybe define them as extended types as the decorations happen. interface baseObject { ... } interface priceAdded extends baseObject { price: number; } interface somethingElseAdded extends priceAdded { somethingElse: object; } ... interface augmentedObject extends nextToLastAugmentation { finalAugmentation: object; } // and then just pass augmentedObjects around
I could do this however this means i lose the information that some of the functions in the middle dont require previous steps if ever need to rearrange the steps it wont tell,me what rearrangements i can get away with.
Introducing my pet project... [ts-auto-guard](https://github.com/usabilityhub/ts-auto-guard). And yes it can do that for you.
Hi - these are nice, but look to be a duplicated effort to [type-zoo](https://github.com/pelotom/type-zoo)? * ArgsType === [ParamTypes](https://github.com/pelotom/type-zoo#paramt-extends-function-and-paramtypest-extends-function) * Assign === [Overwrite](https://github.com/pelotom/type-zoo#overwritet-u) Match is quite useful though - maybe add via PR to type-zoo?
Contributions of any kind are welcome :), also stars
Hi, I wasn't aware of type-zoo, typelevel-ts or typical, they look cool I'll take a look at them. Actually ArgsType is different than the one from type-zoo, it works for any number of arguments. &amp;#x200B;
Pretty slick. Does this handle unions and intersections?
Cool. What I'd love is for you to pool brains with the type-zoo maintainers, and merge definitions. If your ArgsType is better (and it looks like it is), then your definition should supercede theirs ðŸ™‚ 
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
hEy, NoTsEaNbEaN, jUsT A QuIcK HeAdS-Up: **SuPeRcEdE** Is aCtUaLlY SpElLeD **SuPeRsEdE**. yOu cAn rEmEmBeR It bY **EnDs wItH -sEdE**. hAvE A NiCe dAy! ^^^^tHe ^^^^pArEnT ^^^^CoMmEnTeR ^^^^CaN ^^^^RePlY ^^^^WiTh ^^^^'DeLeTe' ^^^^To ^^^^dElEtE ^^^^ThIs ^^^^cOmMeNt.
Don't even think about it.
dOn't eVeN ThInK AbOuT It.
One nitpicky detail: I think you should re-evaluate if you really want to merge everything into one giant "god"-object in your functions. For example, `let priceAdded:baseObject &amp; priceAdded = addPriceToBaseObject(baseObject:baseObject)` Here you're tightly coupling the price to the base object. Now you can't really isolate the price from the object. Maybe you want to pass the price to a function that sums up the total cost of a purchase, you now have to pass all the data of your object, including storeList and whatnot, even though it is not required by the function. Instead, why not just have a function that clearly states that it requires and only returns what it's adding: `let price = calculatePrice(baseObject: BaseObject)` Then later you can use it in other functions that require it, but might not require other information: `let discount = calculcateDiscount(price: Price, store: Store) // no baseObject needed` Then, at the end, you can merge everything together into one big object that you can return from your API: `return {...baseObject, price, discount}` 
I'd go with something functional as well. OP, have a look at [a pipe in Ramda](https://ramdajs.com/docs/#pipe) 
Yep! You can have union typed properties and it will correctly `||` the conditions together.
Hey, I've just published a post on "[How we use React/Redux with TypeScript](https://www.reddit.com/r/typescript/comments/9zbsti/how_we_use_reactredux_with_typescript/)". Maybe some of the examples are helpful. Let me know if you need more info!
Thanks, will check it out
https://typescriptcourses.com/typescript-fundamentals
If you want to learn, I'd be happy to help you out a bit. Are you familiar with some JavaScript or completely new to that too? &amp;#x200B; Hit me up on the DMs, Twitter, Discord of Twitch; using the same name. I'd be happy to help you out a bit and get you started! (promise I'm not selling trainings or courses or whatsoever)
Yes, it works like that. It will create an array that can contain strings **and** numbers. If you want to have either an array of only strings **or** an array of only numbers, then you must use `Map&lt;string, Array&lt;string&gt; | Array&lt;number&gt;&gt;` instead (or shorter syntax `Map&lt;string, string[] | number[]&gt;`).
Yes, this will work. const ourMap: Map&lt;string, Array&lt;string | number&gt;&gt; = new Map(); ourMap.set('u', ['a', 1, 'b', 2, false]); In the above example the false will be marked as an invalid value. You could perhaps use an object? const ourObject: { [key: string]: Array&lt;string | number&gt; } = {}; ourObject.u = ['a', 1, 'b', 2, false]; It would also mark the false as an invalid value.
Awesome, thank you :)
Thanks! I think I'll investigate using objects more since I may have more complex datasets and it seems like this will help me achieve what I am going for. Appreciate the quick response
https://old.reddit.com/r/typescriptvideos/
Sorry mate but thatâ€™s just how it is sometimes. They probably thought your idea was good at the time, but then realized it actually would be better suited implemented as part of a bigger change they were already making. Sure itâ€™d be nice to get told ahead of time, but there are tons of community PRs to go through, and if they had to check every one before implementing a feature, their dev speed would slow down dramatically. VSCode for instance is a slightly larger team, with slightly better community input stats, but they need to dedicate two people at a time to just issue tracking (one in Zurich, one in Redmond). Thatâ€™s a trade off the TS team canâ€™t make. 
I'm not sure what their contribution policy is, but I would say it's generally not a good idea to do a PR for an issue that hasn't been verified and assigned to you or flagged with "help wanted". That being said from the outside looking in TS needs more maintainers, and much better organization. You'd think this would be possible given the resources MS should be able to provide.
&gt; because it prohibits assigning null on the object type Yes, which is a **good** thing. If you want to allow the assignment of `null`, then use a union type to explicitly support it: `object | null`.
&gt;it's generally not a good idea to do a PR for an issue that hasn't been verified and assigned to you or flagged with "help wanted". Agree, that's my fault. I had to create an issue and get approving for the team. But If the PR is closed with violation of contribution policy (why the PR wasn't closed by this reason?), I have no any question. But there is a little bit strange review and then ignoring.
Yes, they should have stated that you are going against contribution guide lines from the start. Still it's best to look for yourself first and try to follow protocol even if the team doesn't seem to be putting in the effort to strictly enforce it. They likely assumed you were okay with the risk of the PR being closed for any reason.
just FYI: "requested changes" is the only option github allows you to give. It doesn't actually mean the maintainer is requesting changes, it means they clicked reject.
I wouldn't blame the typescript team here or feel this done out of malice. I think it's more a case that [https://github.com/sheetalkamat](https://github.com/sheetalkamat) isn't very observant. She's closed issues I've raised saying they've been fixed but without actually checking them.
It's definitely possible, they're probably just wondering if it's worth it. In cases where the type is known to be a bigInt it would require changing all the math operators to a function call for some BigInt polyfill, if it's a union including bigInt then they would have to wrap it in a function call that checks the type before running the correct operation or polyfill function.
As you mentioned, the `noUnusedParameters` config flag would do it, but for the entire project. You could use the `// @ts-ignore` comment to instruct TS to ignore errors on that one line. You could also break up the line so that it only ignores that one parameter without ignoring any other errors in that line, like this: app.get( "/hello", // @ts-ignore (req, res): Response =&gt; { return res.send("Hello, World!"); } ); It's kind of ugly but it would achieve what you're looking for.
Prettier reshapes that to: app.get( "/hello", // @ts-ignore (req, res): Response =&gt; { return res.send("Hello, World!"); } ); It's still kind of ugly here, but useful to know that it's a thing. I could pull that anonymous function out into a variable and that would tidy up the fomatting at least, but my server probably has more than one route. It could have 7 per model if I'm going all out REST. That's a lot of lines to ignore. 
On mobile. But you can ignore unused parameters by prefixing them with an underscore I.e _req
This is the right answer. Don't put ignores everywhere.
Nice! The parameter is still in the function signature and still typed, but the IDE and compiler give no error (TS 3.1.4). If this was Stack Overflow, this would be the accepted answer. Thanks!
Not only is this the right answer, itâ€™s the standard way of handling this in some (many?) other languages, too. 
I didn't know TS supported this. This is definitely a better solution.
I've seen it in Scala, but that's the only one I can think of out of the languages I've used. In JavaScript (and Python, maybe others), a `_foo` class member usually means, "Yo bro, I know this language doesn't support private members or nothing, but *please* don't change the value of this member, yeah?"
I first encountered it in Ruby via Rubocop. I swear Iâ€™ve used it in others but Iâ€™m drawing a blank now that I think about it.
You can keep your strict linting rules with TypeScript and avoid that error by either using the \`// @ts-ignore\` comment above it, or the more preferred and clean method of just prefixing the unused variable with an underscore. So the callback for the Express route becomes \`(\_req: Request, res: Response) =&gt; {...}\`
This is one area where typescript is pretty lacking IMO.
This is definitely a great answer. I also switch the lint rule to warn and not error. You can always have a stricter linter on code commit but halting compilation for Dev work is kinda over the top. I wonder if you can add comments on lint rules so use the _ approach
Little bit of both, you're right, it's a convention for pseudo-private members, but also to mark unused arguments in languages like JS that only have positional args.
So, it's styles-as-objects, and yet react inline styles are "spaghetti code" while typestyle isn't?
A think if you use `_` as you param name it doesn't complain
I have multiple opinions if, I have read this question/concern correctly. 1. There is this site for typescript docs ( [https://www.typescriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html) ) 2. Use Evernote to probably archive the TypeScript Docs 3. Get down and dirty with some web scraping and then creating your very own API for TypeScript { I'm pretty sure the community would love/ praise you for } 
I'm referring to [this](https://github.com/Microsoft/TypeScript/pull/27068#issuecomment-422286804) comment before it was closed
I think what I'd like to see a decoupling of the source code metadata (files and symbol metadata) and the UI that surfaces that metadata. `typedoc` is a decent tool but the UI is just not acceptable for most branded tools and, while some customization is possible with `typedoc`, it's sort of a pain. So I'd rather be able to point a tool at my library, have it generate a JSON file, hopefully, compliant with some json-schema, and then build up a custom UI around that data. Maybe folks could build their own UIs around the schema so you have several options to choose from if you don't want to build your own.
IMO `@ts-ignore` should be the very last resort, and when using it, add a comment why. You can just append the comment after, like `// @ts-ignore ignoring this because...` Prefixing the param with `_` is a much better solution IMO.
Yes it compiles string class names and puts everything else in &lt;style&gt; tag. It also makes possible to use media queries and hover etc.
I thought this might be interesting to some folks here. Most boilerplates are either front-end framework focused or backend framework focused. This boilerplate uses several tools that I use for my own projects and I've found the combination to be very effective. The gist is that you write your API and UI in TypeScript and you get type safety throughout the stack.
You should split your package.json file into separate dev and normal dependencies. That way when you go into production you donâ€™t need to include all of the development modules on a production machine. Looks really cool otherwise! Good work.
Thanks for the reply but I think you're confused. I'm trying to generate my own documentation for my own library, not TypeScript itself. If you want easy access to the actual TypeScript API documentation, you can use Dash or Zeal to do it - the community has already done it, no scraping required.
Hi everyone, I recently added TypeScript support - The Type definitions are machine-generated (see [here](https://github.com/maierfelix/node-vulkan/blob/master/generated/1.1.85/index.d.ts)). Please feel free to submit any improvements!
&gt; Most of solutions are bundled with webpack which means if you want to write library which have extendable replacable styles included you mustnâ€™t use webpack! So automatically you need to disqualificate these solutions What? That's not true yes you can use webpack to bundle those but it's not required, there are other options. You could compile scss, sass, cssNext very easily to multiple files that you can allow the consumer of your library to then import as needed, they can even be css modules. Also I got the meaning, but "disqualificate" is not an English word, the word to use "disqualify".
Say I'm someone who's using Three.JS already and knows nothing about Vulkan. Are there reasons I might want to consider using this instead?
Vulkan has compute, geometry and tesselation shader support. Also WebGL has many security checks, a large overhead and is limited to OpenGL ES 3.0, so very outdated. Node-Vulkan only does type checks and is just a thin layer above Vulkan - but is limited to desktop. For a ThreeJS user, this project might be not interesting/useful, but eventually for a ThreeJS/graphics framework author.
Hey Luke, I've been relying on your tsoa package in one of my projects for about a year and a half now. There really is noting else like it when it comes to TS swagger doc generation, so I really just have to say thanks.
I'm confused why this is necessary. If you install RXJS from npm, you get a precompiled copy with .d.ts files, right? So dependencies will not be recompiled? I think I'm missing something.
For npm-published libraries, I've seen either the .ts files are omitted, or they are in a separate directory. So the ts compiler will resolve the .d.ts, not the .ts. I'm not sure about tree shaking; it probably depends on the bundler you're using.
I see, makes sense, thanks for the explanation. Your symlinking approach might work really well with tsc's new project references and `--build` mode. TSC would be able to handle the incremental recompilation.
Oh what are those? If I can delegate the juggling to tsc then even better.
"documentalist" might work but I haven't used it personally.
I will be messaging you on [**2018-11-26 00:51:53 UTC**](http://www.wolframalpha.com/input/?i=2018-11-26 00:51:53 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/typescript/comments/a07jlr/path_maps_cannot_be_resolved_by_tsc_works_as/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/typescript/comments/a07jlr/path_maps_cannot_be_resolved_by_tsc_works_as/]%0A%0ARemindMe! 14 hours ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I use this feature like you intended with my code bundled with webpack. I guess I never thought of the use case when it comes to node, but this would be super annoying to deal with since node doesnâ€™t need webpack to resolve modules.
Nice, thanks for the suggestion. I could hardly find it with a Google search, even knowing I was looking for it - no wonder I couldn't before. It looks like a nice tool and the output has some good features. Sadly like all the palantir projects I've used it's (ironically) poorly documented. After an hour with it I still couldn't get my project to compile documentation. I do like that I can add markdown documentation, which I can't with typedoc. I'll play around with it some more. Thanks again for the suggestion!
This post has been linked to from the GitHub issue. For my two cents I feel that tsc path mapping introduces unnecessary complexity into module resolution. The â€œhellâ€ of relative paths isnâ€™t actually so bad with automatic imports and import path rewrites in VS Code. 
Sure, but that is an editor / IDE specific feature. Using other editors (sublime, vim, emacs... (you name it)) might not have that Feature and hence the developer experience is downgraded. It took me some time to find out why ts-node would successfully remap those paths and the tsc compiled js code wouldnâ€™t. 
I'm doubting it, I don't know how you'd create a Vulkan rendering context in an Electron window. Even if you could I assume it would exist outside of the DOM and be controlled by the electron render process not by your client side code. Anyway OpenGL 3 may be old but it's still plenty powerful for anything I could see myself building.
There's a setting to prefer non-relative paths. So all imports are based on the root of the project. I fid this actually works pretty well. 
&gt;"Works as intended" - Guys @MS: THIS IS A BUG I get where you're coming from, but no it's not a bug and *is* working as intended. That option is meant for use with something like [requirejs's paths config](https://requirejs.org/docs/api.html#config-paths) (which is directly compatible with how this currently works). I've had similar problems in the past, and the TypeScript team's stance has always been that tsc doesn't alter module paths as written - full stop. Personally I'm 100% on your side wanting something that *can* rewrite module paths. Maybe even just a compiler flag that changes how tsc handles paths. That being said, I doubt it'll be implemented in the base compiler. Best bet would be to either use a custom transformer (which is a pain), or tsconfig-paths.
You're supposed to configure a runtime or build-time module loader like webpack, requirejs, or rollup. The benefit of delegating runtime resolution is that tsc's emitted code continues to match the input code without injecting too much ts-specific runtime behavior. This is a more powerful separation of concerns. The JS community can definitely create tools that, for example, auto-configure webpack based on path mapping from tsconfig. I'm sure someone could also write a TS transformer that handles resolution at compile-time if they wanted to.
Did you read some of the posts here or on GH? People are struggling with this problem over and over again! 
&gt; You're supposed to configure a runtime or build-time module loader like webpack, requirejs, or rollup. Not everyone is building client-side apps with TypeScript. 
Really??? You can find simple examples for every language that supports OOP. interface Vehicle class Car implemts Vehicle... https://www.typescriptlang.org/docs/handbook/interfaces.html In general an interface can be seen as a contract how something was / will be implemented
&gt; I've used webpack for backend stuff; it makes it install and launch faster as a nice side-effect. How so&gt;
Right, but it doesn't convert the non-relative path to the actual path in the JavaScript code, which is the whole issue, so unless you're using a third-party tool like webpack to handle that your code won't run. Unless I'm misunderstanding you?
It does. The docs say that the path mapping feature exists so that tsc can understand the eventual runtime behavior of your module resolver \*if\* you're using one that performs path mapping. (node's `require()` does not, for example) Path mapping doesn't exist to introduce a convenience that the underlying runtime environment doesn't implement. For example, in code that runs on node, you're using node's built-in `require()` resolver at runtime, so you set `"moduleResolution": "node"` Node requires us to use relative paths unless we're loading stuff in node\_modules. That's a node requirement; it's how node behaves. So when I want to run my plain .js code on node, I have to use relative paths. And tsc will understand this. It'd certainly be a great convenience if this was built-in to tsc, but it's not a bug. Looks like this transformer can do the trick: [https://github.com/grrowl/ts-transformer-imports](https://github.com/grrowl/ts-transformer-imports)
Yes, I agree. But if they're determined to continue to have their cranium lodged in their rectal cavity - the least they could do is fucking document is so that people like me (and the other several hundred in that thread) don't spend ages wasting time wondering why the compiler is apparently generating code that will build but not execute.
I hope next time you need help that someone gives you a more polite and helpful answer than this one so your arm a good lesson. 
Interesting - I don't think that was there when I initially encountered this ~~feature~~ bug
I used to fret over long import paths `'../../../../'` too. The two features that let me just get on with the coding are: - when i'm writing code and i want to import something i just start writing the name of the symbol. When I've located the symbol in the IntelliSense drop-down, I hit enter and VSCode automatically inserts the proper `import` statement up at the top of the file. - Like you said, VS Code will automatically update the import paths when you rename or move a file. Between those two features I almost never actually have to look at the import statements at the top of the file, and when I do, it doesn't bother me anymore if they have lots of `..` segments in them. I just always use the IDE-integrated code navigation tools, which can handle the paths just fine.
&gt; All we need is a compiler option. We already have one! It just doesn't damn well work properly.
Thanks. Do you keep those server response interface code in shared folder between server and client? 
Yup. If you want your FE and BE as separate projects you can put them in their own package.
Again, path mapping exists so that TSC can understand the runtime module loader you are using. You must configure path mapping to match your runtime's loader behavior. Path mapping is not meant to introduce a new loader behavior. Would you rather TypeScript automatically deduce path mapping configuration from your runtime loader? In other words, it would automatically figure out appropriate path mappings to match a webpack config? This would solve the problem you describe. If you don't use webpack or another runtime loader, TypeScript will stick to simple node-style module resolution. Path mappings will be disabled. You will be forced to use relative module paths, and everything will work correctly at runtime.
Would an enum work? ``` enum Pets{ Cat = 'cat', Dog = 'dog', Horse = 'horse' } const someValue: string = 'cat' if (Object.values(Pets).includes(someValue)) { // Do stuff here } ```
Hello good to know about disqualify! I know you can compile CSS and then import the CSS in other project. I do not like this. I just think my way is better and simpler for TS devs but I understand your opinion.
Regular enums already have strings. Then Pets\[pet\] returns the string. Which can be a test because if pet is not a valid value it returns undefined.
Thanks, that kind of works as well. However, then you \- have each value twice (the Enum part and the value) and nobody type checks. \- have no type checking on the values of the enum I already see myself press "duplicate line" to add another value and then only edit the first part. And since the enum values can have duplicates I wouldn't notice at compile time.
I found a hack for doing this last week. Try: const pets = ['cat', 'dog', 'fish'] type Pets = (typeof pets)[number] let petOne: Pets = 'cat' let petTwo: Pets = 'chicken' // throws error I say hack because`(typeof someArray)[number]`is very confusing to see on its own. It might require a rather recent version of TS because it doesn't seem to throw errors in the typescript playground editor. 
 export type SomeValue = number | string | Function | object | boolean | null | undefined | {}; export type ICanMakeABetterEnum_TM&lt;T extends SomeValue[]&gt; = T &amp; { isValid(value: unknown): value is ValueType&lt;T&gt;; }; export type ValueType&lt;T extends SomeValue[]&gt; = T[number]; export function iCanMakeABetterEnum_TM&lt;T extends SomeValue[]&gt;(...args: T): ICanMakeABetterEnum_TM&lt;T&gt; { const fakeEnum: ICanMakeABetterEnum_TM&lt;T&gt; = args as any; fakeEnum.isValid = function(value: unknown): value is ValueType&lt;T&gt; { return args.indexOf(value as any) !== -1; }; return fakeEnum; } export const Pets = iCanMakeABetterEnum_TM("cat", "dog", "horse"); export type Pets = ValueType&lt;typeof Pets&gt;; const a: string = ""; const b: Pets = ""; // Error const c: Pets = "cat"; // :) if (Pets.isValid(a)) { a; // "cat" | "dog" | "horde" } else { a; // string } &amp;#x200B;
Uhh...that would be really nifty if it works. With Typescript 3.1 it doesn't seem to work, the inferred type of Pets is \`string\[\]\` .
Call me old-fashioned or boring, but I prefer the simple straight-forward no-magic-bullshit way of things, at the cost of having to write a few more lines of code: type Pet = 'cat' | 'dog' | 'horse'; function isPet(value: string): value is Pet { const casted = value as Pet; switch (casted) { case 'cat': case 'dog': case 'horse': return true; default: ensureNever(casted); return false; } } function ensureNever(value: x): void {} - A simple type guard that checks if the `string` is a valid `Pet`. - The cast to the `casted` variable ensures that you only check for valid values, so the compiler forces you to change the function when you renamed or removed elements. A case for `'foo'` would result in a compilation error. - The little `ensureNever` helper function ensures that you have handled all cases, so the compiler forces you to change the function when you added elements. If you add a new element to the union, then the type of `casted` is **not** `never` anymore in the `default` block, and calling `ensureNever(casted)` will result in a compilation error. Straight forward dead-simple code that ensures you have handled all cases.
Start with the official docs: * [https://www.typescriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html) * [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html) but bear in mind that (IMO) the dearth of decent documentation and examples is the worst thing about Typescript. The basic types in the guide are okay, but the "advanced types" section rapidly descends into gibberish, so don't worry if you get baffled by them - you're not alone. Post here or SO if you get stuck. Good luck. 
It works if you use a tuple instead: const pets: ['cat', 'dog', 'fish'] = ['cat', 'dog', 'fish'] type Pets = (typeof pets)[number] let petOne: Pets = 'cat' let petTwo: Pets = 'chicken' // throws error
Personally I prefer having **two** functions, instead of something ugly as a `noThrow` parameter. I usually simply call them: - `assertNever` -&gt; asserts and throws at run-time. - `ensureNever` -&gt; ensures at compile time and does nothing.
All we want is an option that when enabled will automatically convert the non-relative paths to the proper full relative paths so that Node will by default work with them without any hassle.
Here you go. No redundancy. Nice and tidy. const PETS = specifize(["cat", "dog", "horse"]); function specifize&lt;T extends string&gt;(p: T[]): T[] { return p; } type Pet = typeof PETS[number]; 
Here you go. const PETS = specifize(["cat", "dog", "horse"]); function specifize&lt;T extends string&gt;(p: T[]): ReadonlyArray&lt;T&gt; { return p; } type Pet = typeof PETS[number];
The is a language suggestion to allow explicitly expressing the type of literals here: https://github.com/Microsoft/TypeScript/issues/10195 Which would help you achieve what you want without any "hacks".
Hello there! I figured I'd try and open the PR and if it gets rejected then, move from there, but indeed perhaps I should open an issue. I figured if I get rejected, worry from there/make the DefinitelyTyped PR. ---- As for an error, ``` error TS2307: Cannot find module 'chrome-aws-lambda'. import Chromium from 'chrome-aws-lambda'; ``` that's after running `tsc`, even when I run it with `--traceResolution` it doesn't seem like its even TRYING to resolve the module. I'm not sure where to go from here.
I've opened a stackoverflow post that has a bit more info now too in case you wanted to take a crack. https://stackoverflow.com/questions/53489740/typescript-can-not-find-locally-linked-module
well, that's pretty damn cool!
``` interface MyModule extends React {...} ``` That should do it.
You can just use "reduce" without this creepy undefined behavior. If you need behavior with mapping and filter - use null instead of undefined.
Doesn't `reduce` transform `U[]` to `T`? I need `U[]` `T[]` where `U` is `T | undefined` (or `null`, idk)
I mean, that's neat but I can't really do the `return [...memo, t]` part you have there. The purpose of the `.map` call is to generate that list in the first place
You can define your return type to be an array.
memo is just the array you are constructing, it starts out as empty and then you push your new values onto it as you find them. It would be called arrayOfT or something in your case. When you find a value you want in your original array you add it to the new array and return that array for the next iteration, otherwise you just return the existing array (or memo) and continue looping if you don't want the current value. 
This seems to work const arr: (number | undefined)[] = []; const result = arr.filter((t): t is number =&gt; !!t); // result type number[] &amp;#x200B;
I believe I get what you're saying, but its saying it can't find lib X, not that it can't find dependency Y that lib X happens to need. 
That's just a way of coercing values to booleans. A single `!` will convert it to a boolean and invert it, where two `!!` will invert it again. `''`, `0`, `NaN`, `null`, `undefined` and `false` all become `false`, and everything else is `true`. IIRC, it's actually not necessary in this case, because `.filter` already does this under the hood.
Someone else already brought up user-defined type guards (the `x is Y` bit), and you can take it a bit further with generics: const isNonNil = &lt;T&gt;(value: T | null | undefined | void): value is T =&gt; value != null const items = [1, undefined, null, 2] // (number | null | undefined)[] const existingItems = items.filter(isNonNil) // number[]
First of all, I know itâ€™s not a nice solution. Thatâ€™s because itâ€™s a bad problem. That said, I donâ€™t understand what youâ€™re getting at. In my example the union type is created specifically from the exact values passed to the function, not the other way around. You wouldnâ€™t be able to add something to the union type without adding it to the function. And the code example you posted is simply nonsense to write but still wouldnâ€™t change the outcome. Youâ€™d end up with the type `â€œcatâ€` and the `isValid` function would still work. 
Constructor injection is fine. Manual property wiring or property injection is not, but I don't think those are common in Angular. I had code base like what you describe as well, but I have also written code with DI that has strictNullCheck. Try make sure your code rarely if ever re-assign anything (variable, property, etc). 
One more thing you might want to share is the `package.json` of `chrome-aws-lambda` (I presume that is the package you are linking?).
Why not? This is fine (and more efficient if you care). ``` function makeThings(): T[] { return thingies.reduce((acc, t) =&gt; { if (...) { acc.push(new T(t)) } return acc }, [] as T[]) } ``` I think it reads fine too. It's terser and clearer than OPs function and has simpler types.
See code in [my comment](https://www.reddit.com/r/typescript/comments/a0p8da/can_typescript_not_infer_when_an_array_of_t/eak8k4u/).
How about installing the dependencies on your machine and then mounting them as a volume into the container?
I strongly prefer `filter` for this use-case, because it expresses the intent of the code.
What creepy undefined behavior!?
Adapted from OP's code.
To clarify, I'd prefer filter too if it wasn't also a map. And I'd probably just chain them if it was too, but if the logic gets slightly more complicated then reduce is a perfectly acceptable pattern.
This function also maps whatever the `t` is to instances of type `T` via the constructor, so equivalent would be: thingies .filter(t =&gt; ...) .map(t =&gt; new T(t)) Not just a filter. But this is also fine. I'm sure the compiler can optimise the other array away anyway.
I have to agree with this. One of the benefits of using TypeScript is the tooling power. TypeScript promises to not add functionality to JS and it would be strange for it to modify the behavior of `require` for node. Supporting existing packaging solutions, however, seems like a pragmatic choice.
Oh you're right! It's .map().filter(). In that case, reduce is a great choice.
Try looking at the DefinitelyTyped definitions for your favorite node module that takes objects as arguments.
&gt; I dislike any code that references `undefined`. I'm with you there! [This](https://www.reddit.com/r/typescript/comments/a0p8da/can_typescript_not_infer_when_an_array_of_t/eake2gx) is the cleanest solution though really.
`typeof` operator is preferable here else zeroes will get filtered out as falsey.
Do you even have to write the file extension? Shouldn't it work without it? (I'm just wildly guessing so don't kill me plz)
In Typescript, the namespace mechanism exists to group related functions, variables, etc. under a common object/name. The class mechanism exists to defined object prototypes for instances of said class. I can't think of reason you should ever use a class with only static methods instead of a namespace. I would certainly never do it, I would be shocked if my colleagues would do it, and I would criticize any use of this pattern. If you're using the class as a singleton, then just create a regular class and a singleton instance. &amp;#x200B; Creating a namespace vs. a class with just static methods results in pretty much the same output except that the class is an instantiable function and not just an object. In my opinion, this is a misrepresentation of what you're actually trying to create which may lead to confusion in the future. // class class MyStaticClass { static init(): void { } } // namespace namespace MyNamespace { export function init(): void { } } // output: "use strict"; // class var MyStaticClass = /** @class */ (function () { function MyStaticClass() { } MyStaticClass.init = function () { }; return MyStaticClass; }()); // namespace var MyNamespace; (function (MyNamespace) { function init() { } MyNamespace.init = init; })(MyNamespace || (MyNamespace = {})); Using a class with strictly static methods is an old pattern that has been replaced with modules and namespaces. &amp;#x200B; I tend to disagree with the points /u/InvernoSnowfall brought up from the handbook. I prefer the syntax `import { ModelUtil } from "./util";` rather than `import * as ModelUtil from "./util;"` or `import { create, destroy } from "./util";`, but that is just personal preference to me. Unless you're writing a library which is intended to be used in many codebases and codesplitting/treeshaking is necessary, I don't see a point in making everything ultra modular when I know I'm using all of the exported names and I like namespaces to provide contexts for the values I'm using.
With one function per file that would create a lot of module names.
I'm not sure why you'd only have one function per file. Could you provide an example?
NPM
I've seen this in some other languages, eg JavaScript:- "it is a commonly accepted best practice to have one function or class per file" [https://www.barrymichaeldoyle.com/modularizing/](https://www.barrymichaeldoyle.com/modularizing/) &amp;#x200B; &amp;#x200B;
Yeah, filter.map is also a great option :) 
yeah, sorry for the bad code, I want it to be simple to focus on the \`t is T\` part
About the only place I use namespaces any more is to faux-add a method to an enum (e.g. a parse() method usually).
I like to use `variable == null`, which tests for both `null` and `undefined`, but not `0`.
I'd argue `typeof` achieves the same result without expecting the developer to memorise the quirky double-equals behaviour, something I actually have disabled via linter anyway.
id suggest dumping TSLint and instead addopting prettier
`tslint` and `prettier` are two different things. We use both.
I prefer to avoid create-react-app and just have a "template" version of a barebones project saved. https://github.com/russleyshaw/react-template Feel free to base your projects from it!
How is that different than using CRA?
Thanks for the reply! I knew mine would get downvoted because people get really attached to their IDE and don't like it when anyone suggests that it might not be the best tool for the job. It inspires nearly as much passion in developers as the whitespace debate :)
That's beside the point. Reduce is for flattening a collection into a single object. It's the wrong tool for the job here. 
I only wanted to point out that the type signature for Reduce does not prohibit returning multiple items. As for the other things you've said, I agree that's it's the wrong tool for the job in this case, since you're aiming to filter an array. &gt; Reduce is for flattening a collection into a single object. You can use reduce for more than just that, really, since you can write things like reverse, partition, filter, map, sort, etc in Reduce / Fold. 
Seems to https://parceljs.org/getting_started.html#multiple-entry-files although I don't use multiple entries. I haven't used parcel in many large application but it seems to perform fine. Then again, I don't stray much from my TypeScript, SASS, React environment, although it does seem to work with Vue just fine too. To me it's more like, if you were really excited for "zero config" webpack, then parcel is what you're actually looking for, but as soon as you need any customization, you're pushed back into Webpack. A lot of it has to do with relative tooling cost. On large projects, the investment in getting your webpack compiling the way you want is a very small investment compared to doing the same thing on small projects or test environments.
And with async/await we can use try/catch/finaly as normal again. 
Hey, geon, just a quick heads-up: **finaly** is actually spelled **finally**. You can remember it by **two ls**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Don't even think about it.
dOn't eVeN ThInK AbOuT It.
Oh, right, that's cool! Btw, do have to manually se the state argument and return type manually for each action or can it automatically infer it? 
it was inferring it until you point out this case, when it's referencing the actionCreator it has to be mannually typed :(, I'll be fixing this issue soon. For the other use cases it should be inferring it. Thanks for point it out.
I don't get it... if you want types why not use TS?
Sweet! 
What is going on there Why your names are similar 
Both of those are bots.
Reduce method is about "reducing" an array to something. You can reduce an array to any type (number, array, object, etc...). For example - sum function reduces numbers array to a single number. As i see from your code, you are trying to map things array to a smaller array with some condition. So you a "reducing" array to other array. About efficiency - when you are doing .filter.map, you are performing 2 array scans, and creating 2 arrays. So in worst case (when condition is false for all elements of initial array) reduce will be 2 times more efficient than .filter.map. because ther is only 1 array scan and only one array created. About undefined - undefined is a special type within js. This type is used when some object does not contain a method or a property when we try to call it. So the type semantics is - "hey man, this function (property, variable) is not defined". You should use this type with caution, because you are braking the semantics of your code. On the other side - null. The semantics of null - "this variable is defined, but has an empty value". See the difference? Undefined - variable not exist, null - variable exists, but empty.
Yes, but it's a disgusting way to do things and makes for some really confusing code. You *shouldn't* use reduce for this. Filter is what I wanted, it just needed a type guard.
No, I'm *filtering* an array. I'm not reducing many arrays to one array, which is what reduce is intended for. If you're using reduce to effectively filter an array, you're doing it wrong. If you need to transform a collection to another collection of the same size, you use map. If you need to remove some objects from the array, filter. Change the entire array into something else, be it a different collection or a singular object, reduce.
In this particular case the question is - should we use reduce or map AND filter. As i think, reduce is the best tool. It is more efficient and more readable, because the main work, which algorithm from question doing, is transforming some array to other array with some condition. So at each cicle step we need to filter AND reduce an array.
But your code is about changing things array to array of T with removing undefined elements. So, as i understand, - you got an array of things, you create other array with T's or undefineds, remove undefineds and return result. So - you got one array and you transforming it to other array with smaller size and containing other types. So - you are changing entire array to smth else. So, as you said, the reduce is the best choise. Am i right? Maybe i understand something wrong?
I don't have anything new to add. &gt; I only wanted to point out that the type signature for Reduce does not prohibit returning multiple items. &gt; As for the other things you've said, I agree that's it's the wrong tool for the job in this case, since you're aiming to filter an array.
You can use `reduce` to do that, but that's not what its for. `filter` is for this exact use case. `reduce` is for `T[]` to `T` or `U`, not `T[]` to `U[]`. `map` is for `T[]` to `U[]`, and `filter` is for `T[]` to `T[]` of different size.
Ok, and what about array flattening? You got an array of arrays of numbers (T[]) and you need to create a flat array with only numbers (U[]). So you need to perform a transformation T[] -&gt; U[] and resulting array has bigger or equal size. With reduce - it is just one row of code. And I dont know a siple way to perform this with only map and filter.
What is RosettaCode? Never heard of it.
Clarifying... One could classify the types of linter rules in: 1. code formatting 2. code health (good practices etc). If one is using prettier (with format on save, or you are not using it correctly), most code formtting rules in ESLint are useless since prettier is already fulfilling that role. If ESLint is not correctly setup it can even yell at things made by prettier. Even if correctly setup, it is just another thing to configure and to make your project setup more complicated, with more moving parts and more shit to eventually fail and eat you some time. On the other side, typescript also fulfills most of the type 2 ESLint rules. Of course one can setup additional useful rules, and TSLint has a dozen of useful rules. So conclusion one can pair ESLint/TSLint/prettier all together in a productive way, but with just prettier and TS alone you already get a pretty solid, safe and simple developer experience without tons of potential hassle eslint configs and other additional setup may provide for low benefit.
Ok, yes, perhaps I should have used this as an example of my confusion: const fn = (str: string|number) =&gt; { return str; } const fn2 = &lt;T= string|number&gt;(str: T) =&gt; { return str; } To me it just looks like two different ways to write the same code.
It is, but obviously there's no reason to use generics in `fn2`. This is a trivial example and doesn't show the use of generics. 
In general, generics just provide a _type_ variable, which you can use to narrow the type of an item down from something which might otherwise be too abstract. For example, there's nothing wrong with having a `Set&lt;any&gt;` that contains only `strings`, but a `Set&lt;string&gt;` would prevent you from inadvertently adding a `number`, and the result of `get()` would already be typed as a `string`. That said, based on your examples. It seems like you're focused on a specific use case around generics. Here's a better example using `extends` keyword to narrow the generic type: ``` const func1 = (str: string|number) =&gt; str; const func2&lt;T extends string|number&gt; = (str: T) =&gt; str; const result1a = func1(42); // result1 has type string|number const result1b = func1("foo"); // result1 has type string|number const result2a = func2(42); // result2 has type number const result2b = func2("foo"); // result3 has type string func1({a: 42}); // compile error func2({a: 42}); // compile error ``` Both versions of the function restrict the argument of the function to be either a `string` or a `number`, but the return value of `func2` will share the type with the argument.
Your example is very irrelevant for discussing generics. &amp;#x200B; I think promises is the best example. Without generics, how else would you create a working type profile for promises? &amp;#x200B; `const response: Promise&lt;SomeDataFormat&gt; = request();`
Spread &amp; rest are really helpful. Loving all that syntax sugar so much I'm hoping not to get syntax diabetes.
really loving the addition of strictBindCallApply!
Any is just accepting anything and doesn't contain any type information anymore. Generics are a way to use and keep the type when using the function/class with the particular generic. For example you want to write functions for a library and you know that most of the time people would give you a number or a string you could just type it as 'number | string' and you are good to go but there times where you don't know yet what you will get so you just use a generic so people could even use their own made types with your library.
Inference of function parameter types! 
sweet. I've been waiting for the configuration inheritance. no more "extends": "../node_modules/..." !
*Slaps roof of fibonacci function"*
function process&lt;T extends string | null&gt;( text: T ): T extends string ? string : null { ... } This makes no fucking sense at all. And it can't be implemented without using a type assertion.
https://github.com/pkej/vue-cli-3-nuxt-typescript It might have some missing dependencies, just prune away on your local version. Hmm I should upload the mobx testing I've been doing.
The slides are awesome ! Great visual, lots of good informations. Will the talk be available on youtube (or any streaming platform) at some point ?
Your slides are mostly about "what is FP" and "how do we write FP code" and not much about the compatibility with Typescript. What are your thoughts on that ? This is one of my main concern at the moment. For example, I love Immutable.js and its FP-oriented style, but found it very difficult to handle types. Another example would be [R.assocPath](https://ramdajs.com/docs/#assocPath): you cannot accurately type the function because of the array of string representing a path.
I think about 2 years ago it was vert bad but now the support is much better thanks to things like the addition of the keyof keyword. I think the problem is that some of the type definitions don't use these features yet. It will take some time until the type definitions get better support. And there a few things that are not possible like variadic functions but they are in the TS roadmap so I an optimistic about the future.
I would look at arrays, ES Maps, Sets, WeakMaps, and Promises for real-world examples of generics. For example, `Array.from()` is generic so that the return value is an array of whatever you built it from, instead of a not-so-useful array of `any`. `Array.prototype.map` is generic so that it returns an array of whatever type the mapper callback returns, instead of an array of `any`. Promises are generic so that if you have a Promise of number, the `then` callback will take a number as its first argument.
"TypeD Diabetes"
But keep in mind by being **not** explicit on the variable type and let the compiler infer the type you render the excess-property-check useless, because there can never be any excess properties on an inferred type.
What do you mean by modular project structure? Do you mean [modules and namespaces using `namespace` and `module` keywords](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html)? They come with their caveats and drawbacks compared to ['ES2015' modules](https://www.typescriptlang.org/docs/handbook/modules.html). Do you mean [project references](https://www.typescriptlang.org/docs/handbook/project-references.html), where a project's `tsconfig` file can reference another one? This can be a god-send for larger projects.
I mean ES2015 modules
This wouldn't change a thing, because of the `V extends T`. Again the `V` type is inferred, so **any** additional property is just assumed to be part of the `V` type.
Maybe I should add it myself and submit a pull request...
I'd agree if it was anywhere in their documentation...the fact that it's not makes me think they don't really want you to use it. But for the sake of completion, maybe that's the right idea?
Systemjs?
Settings my module as system in my tsconfig. 
How would you organize your files, classes, interfaces or functions? I can't think of any program language without an equivalent...
Client side As in I want it to be done in browser. What additional context would help? Just tested the module as node and it didn't make a difference 
I'm using http-server to run a server off my laptop (this is a school project)... Would I be able to use sequelize server side with that setup? Sorry im not very familiar with client vs server side web dev. Always client side for me. I'm gonna look into this soon.
it's again depend of project structure... Module: /src /src/modules /src/modules/ModuleA/Classes /src/modules/ModuleA/Methods /src/modules/ModuleA/Services ...... /src/others &amp;#x200B; Non-Modules: /src /src/classes /src/generalMethods /src/Servicec ...... /src/others
First question, why do you need sequelize in the front end? Second, if you did this, what stops someone from maliciously accessing your database? Lastly, you're looking for shipping as a UMD or AMD module
I dont necessarily need it to be front end i just dont understand back end/ how to implement back end. &amp;#x200B; I dont have a database myself, i am accessing a public database &amp;#x200B; I dont understand the differences between the two, and as this is for a school project, whichever is easier to work with.
No.
The real issue seems to be you using deprecated functionality. The right way would be to rewrite using the new api, not turning warnings off. Probably a quite easy fix, as the api has little room for big changes
File an issue first.
I would tend to the second approach but don't think in classes and generalMethods. Think in logical related blocks. E.g auth (for Authorization), ui, utils or communication. In general you will use the tools you have to solve a problem. Say communication over network for example. If you need a class use it, if you need standard functions or functional programming, use id. If you look at your structure it is important that you see at first glance WHICH problem the folder solves (packackage, module however you call it) and not HOW. 
Ok, you're almost there but have a few little oddities. If you want to use an enum as a key, it must be a `const enum`. ([stack overflow explanation](https://stackoverflow.com/a/49827446/1742070)) There's comments in the fixed sample code. [Here's the working code](https://www.typescriptlang.org/play/#src=%2F%2F%20To%20use%20this%20as%20a%20key%20index%2C%20it%20must%20be%20%22const%22%21%0Aconst%20enum%20Directions%20%7B%0A%20%20FromLeft%20%3D%20%22fromLeft%22%2C%0A%20%20FromRight%20%3D%20%22fromRight%22%2C%0A%20%20ToLeft%20%3D%20%22toLeft%22%2C%0A%20%20ToRight%20%3D%20%22toRight%22%2C%0A%7D%0A%0A%2F%2F%20This%20should%20likely%20have%20its%20own%20interface%2C%20so%20when%0A%2F%2F%20you%27re%20specifying%20options%2C%20you%20can%20use%20it%20to%20type%20check%0Ainterface%20AnimationOptions%20%7B%0A%20%20entering%3A%20string%0A%20%20exiting%3A%20string%0A%7D%0A%0Atype%20AnimationData%20%3D%20%7B%0A%20%20%2F%2F%20Have%20to%20say%20that%20the%20key%20is%20%3F-optional%20or%20else%20%0A%20%20%2F%2F%20your%20objects%20will%20expect%20ALL%20of%20the%20directions%0A%20%20%5Bkey%20in%20Directions%5D%3F%3A%20AnimationOptions%0A%0A%20%20%2F%2F%20If%20you%20want%20to%20require%20a%20single%20key%2C%20look%20into%20%0A%20%20%2F%2F%20Pick%3CT%2C%20Exclude%3Ckeyof%20T%2C%20K%3E%3E%20in%20the%20documentation%3A%0A%20%20%2F%2F%20https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-2-8.html%0A%7D%0A%0Aconst%20data%3A%20AnimationData%5B%5D%20%3D%20%5B%0A%20%20%7B%0A%20%20%20%20%2F%2F%20Dynamic%20key%20works%0A%20%20%20%20%5BDirections.FromLeft%5D%3A%20%7B%20entering%3A%20%22valueOne%22%2C%20exiting%3A%20%22valueTwo%22%7D%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20%2F%2F%20literal%20key%20works%20too%0A%20%20%20%20fromRight%3A%20%7B%20entering%3A%20%22valueOne%22%2C%20exiting%3A%20%22valueTwo%22%7D%2C%0A%20%20%7D%2C%0A%5D%0A%0Aconst%20directionKey%20%3D%20Directions.FromLeft%20%2F%2F%20%27fromLeft%27%0Aconst%20dataObject%20%3D%20data.find%28%28obj%3A%20AnimationData%29%20%3D%3E%20%21%21obj%5BdirectionKey%5D%29%0A%2F%2F%20undefined%20check%0Aif%20%28dataObject%29%20%7B%0A%20%20const%20options%20%3D%20dataObject%5BdirectionKey%5D%0A%20%20%2F%2F%20undefined%20check%0A%20%20if%20%28options%29%20%7B%0A%20%20%20%20const%20%7B%20entering%2C%20exiting%20%7D%3A%20AnimationOptions%20%3D%20options%0A%20%20%20%20console.log%28entering%2C%20exiting%29%0A%20%20%7D%0A%7D) Note there's one minor issue with fixing your approachâ€”you can have empty objects `{}` in your `AnimationData`. If you want to restrict the keys to guarantee having only one, look into [`Pick`, `Exclude` and maybe `Partial` advanced built-in types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html). PS I recommend sticking to TypeScript style of capitalization, which I've fixed in my sample code.
Not sure if this would work, but try changing your module setting from commonjs to es2015?
The reason everyone is giving you shit about Sequelize in browser is because it requires a db connection config to work, which in general, you'd never want to expose in browser code.
Thank you. ðŸ‘Œ
this did not work, thanks though &amp;#x200B;
Hmm interesting, that might work. I'll try this, thanks!
 function firstAny(items: any[]): any { return items[0]; } // since firstAny returns any, we need a type assertion // to change it back to number let a = firstAny([1, 2, 3]) as number; function first&lt;T&gt;(items: T[]): T { return items[0]; } // the generic definition preserved the number type. let b = first([1, 2, 3]);
One simple way to solve it is to simply type height as optional, then have a null-check in the child, i.e. const NeedsHeight = ({ height }: { height?: number}) =&gt; height &amp;&amp; ( &lt;View style={{height}} /&gt; ); This is probably safer, because AFAIK there is no way to create a compiler-level guarantee that NeedsHeight will only be rendered as a direct child of ProvidesHeight. A more flexible approach is to move away from a clone-based API, toward a render props approach: interface ProvidesHeightProps { children?: (props: ProvidesHeightInjectedProps) =&gt; React.ReactElement&lt;any&gt;; } interface ProvidesHeightInjectedProps { height: number; } const ProvidesHeight: React.SFC&lt;ProvidesHeightProps&gt; = ({ children }) =&gt; ( &lt;View&gt; {children({ height: 400 })} &lt;/View&gt; ); Used as: &lt;ProvidesHeight&gt; {({ height }) =&gt; ( &lt;NeedsHeight heigh{height} /&gt; )} &lt;/ProvidesHeight&gt; 
Ah wasn't aware of the const enum differences, that's very helpful thank you for the references and the code sample. Will look into the pick/exclude stuff. 
ðŸ‘
Yeah, to me it also seems a way better solution. Do both functions return \`never\`?
`assertNever` returns `never` because it always throws, it never returns. `ensureNever` returns `void`, because it's just compile-time check for `never`. function assertNever(x: never): never { throw new Error(`Unxpected value: ${x}`); } function ensureNever(x: never): void { /* Intentionally empty */ }
I've been using this on a fairly large production website for a while (probably around 100k calls using this library per day), so I thought I'd put the code on npm so others can benefit as well.
Why do you enable experimental decorator support? It doesn't seem like you use any decorators. https://github.com/phiresky/redis-remotify/blob/master/tsconfig.json#L17
Just cause I copied the tsconfig from a different project (since the strict flag doesn't include all the stuff I think should be included in strict like noImplicitReturns, noFallthroughCasesInSwitch). I've fixed it, but I don't think it matters for consumers of the library.
&gt; but I don't think it matters for consumers of the library. It doesn't, I was just wondering. &gt; Just cause I copied the tsconfig from a different project That explains the other thing I've been wondering about. :-) The initial `tsconfig.json` created by the `tsc` has such a nice layout, I always wonder why people don't just keep and adjust it. Sure, it's not pure JSON, but who cares. Here's the config created by `npx tsc --init`: https://pastebin.com/raw/GGpVQhHB And here with your settings adjusted: https://pastebin.com/raw/zcNkf6dy#
&gt; The initial tsconfig.json created by the tsc has such a nice layout Reasons I can think of: 1. when using a forced auto formatter (as I do here - every git commit automatically formats all changed files using [prettier](https://prettier.io)), the layout gets kind of ugly 2. I can't reconstruct why right now, but I've had issues with that file with trailing and missing commas, and it's kind to find those in that file because it's pretty noisy. 3. When the code window is not very wide it looks ugly with word wrap - and you can get the info in the comments by just hovering over the (uncommented) lines as well &gt; it's not pure JSON, but who cares When I clicked on those links, [JSONView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc) immediately complained that it's invalid json ;)
&gt; When I clicked on those links, JSONView immediately complained that it's invalid json ;) I always say: JSON is a bad format for configurations that are for humans. :-(
This is neat. Not sure if you're OP but here's a reply. It's hard to tell without a clear definition of the shape of the expected values of dispatch - I think it would make the article better if you defined what you were expecting to get from the user, and then showed the solution. As it is, it's hard to parse out the expected usage. It appears to be something like this: dispatch({ type: 'exit' }, { exit: () =&gt; { console.log("exited") } }) If that is correct, you could do the whole thing much easier like this: const enum MessageType { Work = "work", Exit = "exit", } interface Message&lt;T extends MessageType&gt; { type: T } type MessageHandler&lt;T extends MessageType&gt; = { [key in T]: () =&gt; void } function dispatch&lt;T extends MessageType&gt; ( message: Message&lt;T&gt;, handler: MessageHandler&lt;T&gt;) { } and use it like this: // valid and works dispatch({ type: MessageType.Work }, { work: (message) =&gt; { console.log(message.type) } }) // Fails because the handler is expecting "exit", not "work" dispatch({ type: MessageType.Exit }, { work: (message) =&gt; ({}) }) [Playground link](https://www.typescriptlang.org/play/#src=const%20enum%20MessageType%20%7B%0D%0A%20%20Work%20%3D%20%22work%22%2C%0D%0A%20%20Exit%20%3D%20%22exit%22%2C%0D%0A%7D%0D%0A%0D%0Ainterface%20Message%3CT%20extends%20MessageType%3E%20%7B%0D%0A%20%20type%3A%20T%0D%0A%7D%0D%0Atype%20MessageHandler%3CT%20extends%20MessageType%3E%20%3D%20%7B%0D%0A%20%20%5Bkey%20in%20T%5D%3A%20(message%3A%20Message%3CT%3E\)%20%3D%3E%20void%0D%0A%7D%0D%0A%0D%0Afunction%20dispatch%3CT%20extends%20MessageType%3E%20(message%3A%20Message%3CT%3E%2C%20handler%3A%20MessageHandler%3CT%3E\)%20%7B%20%7D%0D%0A%0D%0A%2F%2F%20works%0D%0Adispatch(%7B%20type%3A%20MessageType.Work%20%7D%2C%20%7B%20work%3A%20(message\)%20%3D%3E%20%7B%20console.log(message.type\)%20%7D%20%7D\)%0D%0A%2F%2F%20fails%0D%0Adispatch(%7B%20type%3A%20MessageType.Exit%20%7D%2C%20%7B%20work%3A%20(message\)%20%3D%3E%20(%7B%7D\)%20%7D\)%0D%0A)
This was a good read. I feel like o learned a bit about conditional types too. Teensy bit of feedback: &gt;for demonstration purposes so Iâ€™m going to skip most of the error handling) ^ I totally buy that and think thatâ€™s completely appropriate given the aim of the article. However, I think in most environments, itâ€™s probably still appropriate to throw an **Error**, instead of just a string. (Some keywords are in bold since I can't easily find backticks on mobile) 
I'm OP and appreciate the feedback. I'll flesh out the shape more to make things clearer.
That's a good point. I'll fill in more of the details and throw an error like you mention.
you should really add some tests though
I tried it, but unfortunatly it doesn't work. There is even less typing than before. This is the code I used type PropertyLanguagesInner&lt;Keys = {}&gt; = IPropertyLanguages&lt;Keys&gt; | IPropertyLanguagesInner&lt;Keys&gt; | string; interface IPropertyLanguagesInner&lt;Keys&gt; { propertyLanguages: IPropertyLanguages&lt;Keys&gt; | IPropertyLanguagesInner&lt;Keys&gt;; values?: Keys; } // The "Keys" type is needed to have the correct typing when applying the translations. Even though it does nothing here interface IPropertyLanguages&lt;Keys = {}&gt; { en: string; } interface IKeys&lt;Keys = {}&gt; { [key: string]: IPropertyLanguages&lt;IKeys&lt;Keys&gt;&gt; | IPropertyLanguagesInner&lt;IKeys&lt;Keys&gt;&gt; | string; } interface ITranslateTest { yes: IPropertyLanguages; // typing works helloPerson: IPropertyLanguages&lt;{ name: string }&gt;; // typing works text: IPropertyLanguages&lt;{ yes: PropertyLanguagesInner, helloPerson: PropertyLanguagesInner }&gt;; // Typing does not work } function translatableString&lt;Interpolation extends string&gt;(value: {en: string}, ...interpolations: Interpolation[]) { return value as IPropertyLanguages&lt;Record&lt;Interpolation, PropertyLanguagesInner&lt;Interpolation&gt;&gt;&gt;; } const translations = { yes: translatableString({ en: 'yes' }), helloPerson: translatableString({ en: 'hello {name}' }, 'name'), text: translatableString({ en: 'Is this some text? {yes}, ok!, {helloPerson}' }, 'yes', 'helloPerson'), }; function translate&lt;Keys extends IKeys&gt;(translation: PropertyLanguagesInner&lt;Keys&gt;, options?: ITranslateOptions&lt;Keys&gt;): string { // implementation not important return 'translation!'; } interface ITranslateOptions&lt;Keys extends IKeys = {}&gt; { values?: Keys; } translate(translations.yes); // works translate(translations.helloPerson, { values: { name: 'Jack' } }); // typing of values is NOT correct here anymore translate(translations.text, { values: { yes: { propertyLanguages: translations.yes, }, helloPerson: { // helloPerson is now typed as: PropertyLanguagesInner&lt;{}&gt; while it should be PropertyLanguagesInner&lt;{name: string}&gt; propertyLanguages: translations.helloPerson, values: { // No typing checking on the nested values name: 'Jack', someRandomProp: '', // This is allowed, but Typescript should throw an error here. }, }, }, }); The values from translations.helloPerson are now missing any typing as well. Any clues to what I'm missing here?
Hey, Fufrim, just a quick heads-up: **unfortunatly** is actually spelled **unfortunately**. You can remember it by **ends with -ely**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
hEy, FuFrIm, JuSt a qUiCk hEaDs-uP: **uNfOrTuNaTlY** Is aCtUaLlY SpElLeD **UnFoRtUnAtElY**. yOu cAn rEmEmBeR It bY **EnDs wItH -eLy**. HaVe a nIcE DaY! ^^^^ThE ^^^^PaReNt ^^^^cOmMeNtEr ^^^^cAn ^^^^rEpLy ^^^^wItH ^^^^'dElEtE' ^^^^tO ^^^^DeLeTe ^^^^tHiS ^^^^CoMmEnT.
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Let me tell you a story about xml and attributes.....
I ain't saying that XML is better. But other formats are really nice, like TOML, or just JSON5.
 # [monolithic-vs-modular.md](https://gist.github.com/joepie91/7f03a733a3a72d2396d6)
Yes. It worth.
Always worth. 
But what did it cost?
Everything. 
agree was worth.
Thanos detected :P
Yup! Especially if you come from the "try to avoid this JS shit" group. In my opinion JS&lt;6 is just a mess but ES6 seems to be much more readable and nicer. Even better - TS. It gives you most of the tools (types, autocompletion, compiler checks) you know from other typed languages.
When I decided to convert project to TS several months ago, I thought that it brings me more cons than pros. Although I work with such languages as C++, lack of types in JS was kinda an advantage for me because it was like freedom. But then code base started to became big and this freedom transformed into 'you are on your own with all these function arguments, class fields and object properties'. Now I write everything in TS when I use node. I don't use full strict mode because sometimes I'm lazy and I just want to be that variable `any` or external packages don't have any typings. It still helps a lot in organizing your own code, provides syntax completion and prevents you from doing stupid mistakes.