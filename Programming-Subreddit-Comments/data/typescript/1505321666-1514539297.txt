There are infinitely many ways to implement "a normal, mutable list", of which the misnamed `List` is only one possible implementation (the details of which you still haven't specified...). Does it map the set operations to HTTP requests against a third-party RESTful API? If so, then a more appropriate name might be `SomeThirdPartyApiList`. Does it map them to a CSV file stored locally on disk? If so, then a more appropriate name might be `CsvFileList`. Or is it a less contrived, in-memory list backed by an array? If so, then `ArrayList` might be warranted. And so on, and so forth. You can extrapolate the same logic to the other concrete class names. The interface itself, `IReadOnlyList`, is misnamed as I previously mentioned because interfaces don't define what implementations *don't do*. It makes no sense to have an interface named `IReadOnlyList`, as there is nothing preventing you from creating a writable list that implements `IReadOnlyList`.
&gt; It makes no sense to have an interface named IReadOnlyList, as there is nothing preventing you from creating a writable list that implements IReadOnlyList. That's the point. IReadOnlyList only provides the read operations on a list. It's pair is IList, which provides both the read and write operations. Mutable lists implement both interfaces. Read-only and immutable lists only implement the first.
&gt; Or is it a less contrived, in-memory list backed by an array? Maybe, but that's an implementation detail that is subject to change so long as the black-box behavior doesn't.
The concept of "read-only" is different than that of "readable". The former implies that it can't be written to. The latter only implies that it provides read operations. `IReadOnlyList` should be named `ReadableList`, and `IList` should be named `List`. Implementations that are mutable should implement `List`, where implementations that are immutable should implement `ReadableList` instead.
&gt; The former implies that it can't be written to. Correct, it means that the data structure cannot be written to using that abstract or public interface. It can only be read using that interface, hence the name "read only". &gt; IReadOnlyList should be named ReadableList All lists are readable, making the adjective redundant. 
That's not an implementation detail; it's the entire implementation strategy. That much is not "subject to change" for any reasonable software.
You're not into the whole encapsulation thing, are you?
&gt; Correct, it means that the data structure cannot be written to using that abstract or public interface. It can only be read using that interface, hence the name "read only". That's not what "read only" means in the computing world and I'm pretty sure you know that. This point is hammered home by virtually every interface that encompasses only read operations across the entire programming ecosystem using the "readable" terminology and not "read only". &gt; All lists are readable, making the adjective redundant. And all lists are clearly not writable, yet all `IList` implementations must be.
That's not what encapsulation is.
I don't know where your definitions come from, but mine are well grounded: https://blogs.msdn.microsoft.com/andrewarnottms/2011/08/21/read-only-frozen-and-immutable-collections/
Your definitions are well-grounded in [a source that can't even agree with itself](https://i.imgur.com/AWCTd7b.png), and freely admits its own inability to name things: &gt; De facto standard #2: **ReadOnly**Collection&lt;T&gt; &gt; Somewhat **misleadingly named**, this collection is **neither immutable** nor a general collection. It is merely a wrapper around a **mutable** list.
I'm slightly annoyed there's a version upgrade for features that I already have in my editor... rendering the features useless. I understand it's a tool package but you've got to acknowledge this obvious pitfall.
Couldnt agree more, Redux just doesnt play nice with Typescript, MobX is the way to go
I think the phrase "doesn't work well with typescript" should be more like "doesn't work well with static typing". There's nothing inherently wrong with typescript here. 
I've considered doing a YouTube tutorial for mobx. Do you have anything in particular that you wanted to learn about it? Or something that was confusing or especially difficult?
I think you can specify readonly in an interface.
Not really looking for anything specific. I was planning on just trawling through github this weekend looking for projects that use it and just learn by example. I've read an overview of it, so I know the premise (still don't know if I buy it, but it's interesting)
You can make it work - I'm doing it - but it is a pain. It is very cumbersome. And at the end of the day, you feel like you have been satisfying TS instead of writing meaningful code. 
Depending on how you structure your redux you can get nice solutions. I use the ducks module pattern and wrote a library for personal use that makes it very simple to get strongly typed actions and reducers. https://github.com/codecorsair/redux-typed-modules
to answer your Qs directly the typescript compiler by default does 1 file in one file out. you can configure it to transpile ts files into a js file right next to them. it might have a mode for bundling but I use Webpack for that. if you only want typing, you can introduce type comments via jsdoc strings. tsc will then just do type checking on those files. could be useful for you you need one tsconfig.json per project. well, you dont actually need a tsconfig file at all but the default compiler options are probably too strict for most conversion projects. it should be at the root of all your ts files, in the same folder you'd run tsc. typescript's overheads are build time and setup time. the aim is for no runtime overhead because it's just js in the end. 
on node, sure. in browser, not really for general purpose.
Interesting stuff. I wonder why TS compiler doesn't do it by default?
Would be nice to see a benchmark on this for property access times. With this pattern, each access to one of the properties is going to have to traverse the prototype chain to find the value. I would assume this is the reason TypeScript doesn't do this by default; it's a trade-off between creation speed and memory usage vs property access speed.
Also, the first assignment to that property on an instance would change the `hasOwnProperty` state from false to true. It would change the shape of the instance by adding a property. I'm not sure if that has performance implications 
Off the top of my head, here's something that would break. class Thing { private created = new Date(); }
Yeah, it wouldn't break if it would behave like this from a day one ;) But probably it's part of the spec of es6 spec (static class field?) 
Uhh probably it's not es6 feature... nvm
This is all well and good until you try to initialize something to an object and now all instances variables across instances refer to the same object. Whoops! It is kinda curious why TS wouldn't do this for primitive types, however, as that seems perfectly acceptable. Probably just because the code is more readable!
I got something like I believe you described working by moving the ts files into different folders with their own tsconfig.json files, and then killing the tsconfig.json file from the root of the scripts folder. Not sure if that is the recommended way. But it is working for me generating different js files based on the ts's in each folder. Doing that I did have to manually add references to the type definitions each folder needed, not ideal. But works for now.
Exactly. You end up with many "hidden classes" depending on which properties are set on the instance (with `this.x = x`) and which properties are still inherited from the prototype. Worse, you get different hidden classes [depending on the order you add instance properties](http://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html). For example: `x.a = 1; x.b = 2` transitions `x` to a different hidden class than `x.b = 2; x.a = 1`. The problem with many hidden classes is that functions working with these instances become [polymorphic or even megamorphic](http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html). If a function is called on objects with different shapes, then V8 needs to keep track of many specialized functions for each shape in its "inline cache". If you have too many different shapes, this cache becomes too big and V8 just gives up on this optimization. In conclusion: your constructor should initialize all properties on the instance (so that instances do not change shape when you use them later on) and in the same order (so that you always end up with the same hidden class).
Makes sense. So by using TypeScript's property initializer syntax, and letting TypeScript move all those initializations into the constructor automatically, you're getting more efficient code in addition to the benefits of documentation and static typing. Sweet!
I went through a similar phase. But after seeing the benefits of composition over inheritance, ended up back at simple functions that operate on 'dumb' (pure-data) json-serializable objects. With generics, union types, and interfaces offered by ts, you're in a pretty good position with only those, and can safely ditch classes, 'this', 'prototype', 'bind' etc.
It breaks `hasOwnProperty()` which is used for a lot low-level API implementations in libraries. For example, even the `__extends` code generated by `extends` in TypeScript uses it. 
from the article &gt; When using the Static Init Pattern, it is important to remember that property values initialised on the prototype are shared across all instances of the object. This is fine when the value is a simple type or constant value, but can cause issues if it is an instance of an object or an array as this effectively becomes a static reference across all objects without being explicitly stated as such. Recommended primitive values would be numbers, null, strings and booleans.
Union types have nothing to do with mathematical union. They harken back to early programming languages that had a facility to store objects of two distinct types in the same memory location. Typescript unions are like tagged unions, in that the union itself knows which of it's types it currently holds. Intersection types are... unfortunately named. The closest thing to them are mixin types, in which a class is augmented by inheriting from multiple other classes.
Intersection types are "AND". "Dog &amp; Loggable" That means the type that you are creating includes the intersection of all of its members. It is both a dog and loggable. It can't be a dog but not loggable. It also can't be a loggable thing that is not a dog. Union types are "OR". "Dog | Loggable" means the type that you are creating is the union "bag" of the types that make it. It can be a Dog, but doesn't have to be loggable. It can be loggable, but doesn't have to be a dog.
&gt; That means the type that you are creating includes the intersection of all of its members But an intersection of two sets only contains the elements that are present in both sets. So if a `Dog` can `bark()`, but a `Loggable` can't, then `bark()` won't be in the intersection of the sets of members from `Dog` and `Loggable`. That's where I'm getting hung up. However, your bit about &gt; It can be a Dog, but doesn't have to be Loggable. &gt; It can be Loggable, but doesn't have to be a Dog. makes a bit more sense in terms of mathematical Unions. However, I think /u/the_hoser is probably correct, because a TypeScript Union Type of primitives behaves like a traditional Union in C, since it's one referenced location that is guaranteed to be one of the specified types. I hadn't even considered that these were related to those Union types. The difference though is that in C, it can *only* be one of the specified types, whereas in TypeScript, since it's a structural type system, it can in fact be both types under the hood (or even something else entirely, as long as the structures are compatible).
I totally forgot about C unions. Yes, this makes more sense now, thank you! It was driving me nuts.
I looks to me like the JS script world is slowly going through the cycle of UI developments that transpired in the desktop world and step by step it seems to be pointing back towards the same patterns that worked there.
I disagree with /u/the_hoser. I believe TypeScript union types refer to the mathematical concept. You are mixing it up. "Dog &amp; Loggable" means you are creating a new type, a type whose compatible instances are "Loggable dogs". The fact that you are mixing a Dog with a Loggable in an intersection **does not impose constraints on Loggable**. Loggable does not have to bark() for the purpose of the intersection type. The **constraint applies to the member of the new type that you are creating**, which is for them to be both Dogs and also Loggables. So as long as what you provide to the function as that type can BOTH bark(), AND log() you are satisfying the type constraints. The barking will come from the dog part, and the logging will come from the loggable part. They don't need to include each other in themselves. Therefore, it is an intersection (like their intersection in a venn diagram). Union is similar, and consistent with the mathematical description. "Dog | Loggable" means "Either a dog, or a loggable is fine, doesn't have to be both". Therefore there is no "AND" involved, and hence no "intersection". You are saying "all Dogs are acceptable, and all Loggables are also acceptable, give me any one of them". Therefore your type is referring to the union set of Dogs and Loggables. 
If you think of it that way, then I suppose you're right. A union could represent an instance that implements *any* of the provided interfaces, thus creating a union of those possible instances. An intersection would represent any instance that implements *all* of the provided interfaces. Thinking of it in terms of types being structural constraints and not concrete data structures helps.
The important point is about **the subject** of the type constraint. A union type imposes constraints on the members of the new type that is being created, it does not affect the members that make such a union. And same for the intersection type. OP is getting confused because he thought "intersection of dog and loggable" somehow obligates the loggable to be a dog. The obligation is on something new that you are declaring/creating. In case of union Dog | Loggable, a dog satisfied the constraint because it is a member of that set. So does a loggable. It does not have to be both a dog and a loggable. In case of intersection Dog &amp; Loggable. A lone dog would not satisfy the constraint. Nor would a lone loggable. They would have to join together to form a loggable dog (their intersection) to satisfy or be a member of that set. "Dog &amp; Loggable" does not obligate the dog to be loggable, and does not obligate loggable to be a dog.
Well, no, that's not what was confusing me. Never have I thought that Union and/or Intersection Types impose constraints on the parent Types. I guess the perspective is what is confusing me. Let me break it down a bit to try and explain my thought process: If I have two sets: S = { 1, 2, 3 } T = { 3, 4, 5 } Then the Union and Intersection of those two sets are as follows: Union: S ∪ T = { 1, 2, 3, 4, 5 } Intersection: S ∩ T = { 3 } In Set Theory, if you think of Unions and Intersections in terms of Venn Diagrams, the Union is the entire diagram, whereas the intersection is just the parts where the circles intersect (hence the name). Since `3` is the only number that appears in both `S` and `T`, it makes up the intersection in the Venn Diagram, and therefore the Intersection of the two sets. I double checked to make sure I didn't have a backwards understanding of this. Wikipedia backs me up: https://en.wikipedia.org/wiki/Union_(set_theory) https://en.wikipedia.org/wiki/Intersection_(set_theory) So, if we think of Types as a set of members and I have: Dog = { bark(), toString() } Loggable = { log(), toString() } Then the union and intersection would be as follows: Union: Dog ∪ Loggable (aka Dog | Loggable in TypeScript) = { bark(), log(), toString() } Intersection: Dog ∩ Loggable (aka Dog &amp; Loggable in TypeScript) = { toString() } But that is obviously incorrect in TypeScript, though thinking of Types in this way yields this result. The way I see the AND and OR is: * What members are in either `Dog` OR `Loggable`? (This is a union, and will contain all members from both Types, based on my deduction, which we agree is inaccurate somewhere) * What members are in both `Dog` AND `Loggable`? (This is an intersection, and will contain only members that both Types have in common, based on my deduction, which we agree is inaccurate somewhere) But I think I get it now, I was thinking of the Union and Intersection Types as new types whose members are formed from the mathematical set operation that defines them, when really, the new types don't care about that at all, they themselves are sets, and only need the constraint to be satisfied by any type that will be used in their place. Is that right?
Thanks to Typescript team for the String Enums. I've been hacking my own for years by casting the string initializer to &lt;any&gt; and it always worked but seemed a bit shady.
You are digging one level too deep into the details of Dog and Loggable. Dog | Loggable = I accept anything that is either a Dog, or a Loggable The fact that Dog barks, and Loggable logs is of no concern here. So { bark() } is good enough, and { log() } is good enough too. That means what you accept is within the set of the union of Dog and Loggable. You are digging into their guts, and taking the union of their methods saying "there's this new object whose methods is the union of the methods of Dog and Loggable and the new type must conform to that". That's not what the type is declaring. And making this assumption that the new object must now satisfy that set of merged methods (bark, log, toString). What it IS saying is "I accept items from a set defined by the union of the set of all things that are dogs, and all things that are loggables". Dog &amp; Loggable = I accept anything as long as it is both a Dog, and a loggable So { log() } is not good enough, and { bark() } is not good enough either. In order for something to be both a dog, and a loggable, you want { bark(), log() }. Which means what you accept is the intersection of Dog and Loggable. i.e.: At the intersection of BEING both a Dog and a Loggable which is { bark(), log() }. NOT "an object that matches the intersection of the methods of Dog and Loggable". You are conflating this with "an object whose shape is the intersection of the methods of Dog and Loggable, which is only toString()". 
Okay, this is what I was looking for. I assumed I was thinking about it the wrong way and that's definitely the case. This definitely helps, although I still have to think about it for it to make sense. But thank you for your help with understanding the names, because I was so confused.
You're welcome. Basically you have to remember that it is about type theory, about things being things and belonging to categories. So the union and intersection operations are **not applied to the structure/methods of the types** that you are composing. They are being applied to the concept of belonging or being of that type. So the union of Dog | Loggable is not all of their methods combined. It's the concept of anything that is either one of them. Their intersection is not the methods that they have in common with each other. Their intersection is **things** that are ALL of them. Once the union/intersect is applied to the concept of BEING. That THEN dictates what the shape/methods can be (constraint satisfaction). So for something to be either a dog or a loggable, it just has to be one of them ({ bark()}, { log()}). And for something to be both a dog and a loggable, it has to look like { bark(), log() }. Notice that union/intersect is not applied to the structure or the individual methods. It is applied to the category of things. Then the "set of acceptable things" dictates "the set of possible shapes".
Also it occurred to me another way to make it simple to think about it. Consider that union/intersection can be applied to primitive types as well. So "string | number | null" means "either a string or a number or null". It doesn't mean some weird new object that shares all the methods of those things. Thinking in terms of "richer" types like Dog and Loggable may mislead you into quickly jumping at their methods where as the primitives draw your attention to the type because they don't have bells and whistles.
JSON.stringify is probably a big one that would break due to this.
[removed]
I don't like using Sinoin with TypeScript. I miss the ability to mock interfaces directly. I can recommend TypeMoq to anyone who have the same problem. Together with Inversify I can completely avoid that irritating "class rewrite and revert" method of Sinoin.
TIL Dojo is still being developed 
See [discriminated unions](https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html).
I was finally able to test it on Node 7.8, and it does indeed work as expected. Does anyone know what I can do to it to make it work with Node 8+?
This will change the world as we know it. 
I'm late to the party. Are you closing your db connection? If not, node will think there is more to do and wait until you close it manually.
That was it. :) ty
I personally found it tough to get at first, but that was because I was already in the Node world and had to go through several learning curves. First, it was how to do async things with callbacks, so I had to learn what callbacks were and get used to the idea of passing around functions as arguments. Then, it was promises which promised (har har) to simplify things. I liked the way the code looked with promises, but it was yet another different way of doing it that I had to get used to. Then, it was generators, which were the first attempt at making async code look synchronous (even though generators weren't really intended for this, and using them to achieve this was kinda hacky). Then, finally, we got async/await and I had to get used to going back to writing my code without nesting, but also remembering that these things return promises. I've done a bit of .NET (mostly with school work) and I've never used async/await there, so I'm unfamiliar with it right now.
No "options" parameter allowed. The lib.es6.d.ts entry for **HTMLVideoElement** says the signature should be one of these two: addEventListener&lt;K extends keyof HTMLVideoElementEventMap&gt;(type: K, listener: (this: HTMLVideoElement, ev: HTMLVideoElementEventMap[K]) =&gt; any, useCapture?: boolean): void; addEventListener(type: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void; The "duration" property exist on the **MediaSource** type, an extension of **EventTarget**. So i guess you could cast your EventTarget to a MediaSource and get the duration like this: video.addEventListener('loadedmetadata', event =&gt; { console.log((event.target as MediaSource).duration); }, true); I don't know if this is the correct way to do it.
Thanks! I didn't know about "as". I will read more on casting. Odd about the options since it's on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener). I'll try to use casting to get around this bit too. Thanks a lot!
You probably want to set something like this as part of your config: { "compilerOptions": { "target": "es6" } } Also, does it have to be global? Can you just put `tsconfig.json` in the root of your application?
Edit: simply adding the .json worked like a charm - thanks :) Yeah, right. But all I have is the following: https://i.gyazo.com/83c8a7d75709a9bd38f562329eb35915.png That´s why I was asking where I would find the corresponding config.json to edit. 
Fair enough -- I think if it's not specified, the [target](https://www.typescriptlang.org/docs/handbook/compiler-options.html) option defaults to ES3.
I made this because I was bothered by TS's weak support for sum types: https://github.com/garrettm/tsum It's on npm under `tsum`, let me know if you have feedback or questions.
Pass it to tsc directly. $ tsc --target=es6 HelloWorld.ts
FWIW: $ tsc --help Version 2.5.2 Syntax: tsc [options] [file ...] Examples: tsc hello.ts tsc --outFile file.js file.ts tsc @args.txt Options: -h, --help Print this message. --all Show all compiler options. -v, --version Print the compiler's version. --init Initializes a TypeScript project and creates a tsconfig.json file. -p FILE OR DIRECTORY, --project FILE OR DIRECTORY Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'. --pretty Stylize errors and messages using color and context (experimental). -w, --watch Watch input files. -t VERSION, --target VERSION Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'. -m KIND, --module KIND Specify module code generation: 'none', commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. --lib Specify library files to be included in the compilation: 'es5' 'es6' 'es2015' 'es7' 'es2016' 'es2017' 'esnext' 'dom' 'dom.iterable' 'webworker' 'scripthost' 'es2015.core' 'es2015.collection' 'es2015.generator' 'es2015.iterable' 'es2015.promise' 'es2015.proxy' 'es2015.reflect' 'es2015.symbol' 'es2015.symbol.wellknown' 'es2016.array.include' 'es2017.object' 'es2017.sharedmemory' 'es2017.string' 'es2017.intl' 'esnext.asynciterable' --allowJs Allow javascript files to be compiled. --jsx KIND Specify JSX code generation: 'preserve', 'react-native', or 'react'. -d, --declaration Generates corresponding '.d.ts' file. --sourceMap Generates corresponding '.map' file. --outFile FILE Concatenate and emit output to single file. --outDir DIRECTORY Redirect output structure to the directory. --removeComments Do not emit comments to output. --noEmit Do not emit outputs. --strict Enable all strict type-checking options. --noImplicitAny Raise error on expressions and declarations with an implied 'any' type. --strictNullChecks Enable strict null checks. --noImplicitThis Raise error on 'this' expressions with an implied 'any' type. --alwaysStrict Parse in strict mode and emit "use strict" for each source file. --noUnusedLocals Report errors on unused locals. --noUnusedParameters Report errors on unused parameters. --noImplicitReturns Report error when not all code paths in function return a value. --noFallthroughCasesInSwitch Report errors for fallthrough cases in switch statement. --types Type declaration files to be included in compilation. @&lt;file&gt; Insert command line options and files from a file. 
The `event.target.duration` error is an old issue with the Typescript definitions. The problem is that `Event.target` returns type `EventTarget`, which doesn't have any properties. See [here](https://github.com/Microsoft/TypeScript/issues/4163) and [here](https://github.com/Microsoft/TypeScript/issues/299). The workaround given by /u/empty_other should work. For some other ideas, see [here](https://github.com/Microsoft/TypeScript/issues/4163#issuecomment-321942932) and [here](https://github.com/Microsoft/TypeScript/issues/299#issuecomment-168538829). The `addEventListener` error is also an old issue (see [here](https://github.com/Microsoft/TypeScript/issues/9548)), due to the fact that although `EventTarget` has the correct signature (`addEventListener(type: string, listener?: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void`), all the derived types, including `HTMLVideoElement`, overload it and don't give the possibility of an `options` object. For a workaround, see [here](https://github.com/Microsoft/TypeScript/issues/9548#issuecomment-256793821). Or cast the `Element` to `EventTarget` (in your example: `(video as EventTarget).addEventListener('loadedmetadata', handler, options);`).
Interesting, thanks for your perspective.. personally I find it has incredibly simplified the way I can reason about and write asynchronous code.. being able to spin up a bunch of tasks by just calling the method and popping the result in a list and wait for the lost to complete is so damn easy now! There's still some gotchas in the .Net land, mainly to do with exceptions, but it's a huge leap forward!
Just include example code that should work and make sure there are no type checking errors.
Thanks. That was helpful. I did find a couple of places where the definition wasn't doing what I was expecting it to.
Sounds like something too complicated for [`mapped types`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html), at least in their current implementation and limitations. Maybe a library like [`AutoMapperTS`](https://github.com/loedeman/Automapper) could help you get rid of the mapping code at the very least.
Thanks for that. I have been quite busy so didn't have a chance to try this right away. But I recently did this and it looks like it's working. I distinctly remember that multiple `tsconfig.json` files was not an option previously, so I wonder whether they have fixed this in one of the dozen or so VS2017 updates that has come down? An interesting observation is that this method seems to compile the `.js` file in the wrong order. i.e. I have listed the files as, say, `a.ts`, `b.ts`, `c.ts`, and I can see the `.js` file is compiled in the order, say, `a.ts`, `c.ts`, `b.ts`. But when I run `tsc` from the command line, the order is correct as per the `tsconfig.json` file. I don't believe this happened before, when I just had the one config in the root of the project. Hopefully it won't become an issue. I know the order is sometimes quite important. At the very least, this seems to be a more workable solution for now, than what I had previously.
Sure you should. Why wouldn't you?
I think you forgot the link
Hah, what a fumble! https://medium.com/@AndersCan/say-no-to-undefined-with-typescript-4b8b14cb9324
My mistake, forgot the link. https://medium.com/@AndersCan/say-no-to-undefined-with-typescript-4b8b14cb9324
If you are not using TypeScript you shouldn't use it anyway.
This is where you use strict null checks and make the `getFirst` return type `number | undefined`.
Strict null checks handles this without the runtime overhead.
I knew I should have written about strict. I find that you still need a lot of the if else boilerplate with it. Don't you? I guess this comes down to personal taste so I do not think there is any right or wrong answer. I'll update the article with strict when I get home.
Typescript code guidelines explicitly say to use undefined and not use null
Do you mean these guidelines? - meant only as a standard for contributors to the project &gt; - https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines
Last I heard, they generally support stuff that's at ~~stage 2~~ or later. EDIT: They wait for stage 3; see replies.
How about this: Write your classes and interfaces using the desired TypeScript names, and use a decorator to expose those names to the runtime. This will populate the type-system with the right names and code completion. Then use some runtime logic to generate a mapping from the TypeScript names to API names, based on the list it gets from the decorators. It can do this by automatically converting the `camelCase` name into `snake_case`. There are microlibraries to do this. export class ApiModel { @Field firstName: string; @Field lastName: string; // ... } EDIT: Also! You can `import` that file at compile-time (perhaps using [ts-node](npm.im/ts-node)) and generate a .ts file with the corresponding API interface. import {ApiModel} from './api-model'; fs.writeFileSync('./api-json-interface.ts', ` import {ApiModel} from './api-model'; export interface ApiJsonData { ${ ApiModel.__fields.map(v =&gt; { return ` ${ v.snakeCaseName }: ApiModel['${ camelCaseName }']; `; }).join('') } } `);
Sure, just saying. The guys who write the language recommend the opposite.
I absolutely love real `Option` types, but they are a complete kludge if you don't have a nominal type system (whereas javascript is structural) with some nice pattern matching support. Since javascript mostly sucks, I've resorted to the `number | undefined` option with `strictNullChecks` option. It get's the same effective result, but the enforced checking becomes more manageable. Just a simple `if(x &amp;&amp; x.y &amp;&amp; x.y.z) then { doSomething(x.y.z);}`
Okay, now that I've posted it, I've modified my search terms and found a solution so I'll just post that. https://blog.mariusschulz.com/2016/12/16/typescript-2-1-external-helpers-library Doing this reduced my index.js from 340k to 240k. Way bigger difference than I was expecting! 
There is a thing called "tslib" and an option called "--importHelpers" that you may want to look into. https://github.com/Microsoft/tslib https://www.typescriptlang.org/docs/handbook/compiler-options.html
I thought it was Stage 3. They currently support Stage 2 decorators, but they specifically put that behind a compiler flag because it was stage 2, and could change; but Google needed it for Angular or they were going to fork the language. 
I agree. The problem with the `Option` type is also that that it introduces runtime overhead, and may itself be `undefined` (without strict null checks). But like you say, with strict null checks, the control flow based analysis is what makes `number | undefined` really shine.
You're right, I did some googling and found this post from a TS dev that says they wait for stage 3. https://github.com/Microsoft/TypeScript/issues/2103#issuecomment-182195915
what happens if you run it through the closure compiler?
The TypeScript project also has zero dependencies (not counting dev) So it makes sense they would not want anything that is not 100% necessary for the project.
Fair enough. The title was slightly click-baity, but I'm trying to say you *should* not use `undefined` Not that you *can't* use it.
I've updated the article with a new section regarding this topic. I hope you can take a look and give me some feedback if you have any. Thanks.
I've updated the article with a new section regarding this topic. I hope you can take a look at it and give some feedback if you have any. Thanks. Edit: Forgot to mention that I will have to run a jsPerf test for both you and myself. I am very curious to see if the runtime overhead really is a show stopper.
My only grief with `strictNullChecks` is that you still have to deal with the `if else` logic making it more imperative than declarative.
Thank you both for taking the time to respond. I really appreciate it. It looks like this proposal has been advanced to Stage 1. I’m looking forward to watching it progress.
"I don't need to read this, I already know function overloading in TS. But I'm bored anyhow. Let's see..." "Oh! You don't have to specify the parameter types in the implementation?!! Neat!" Thanks, guy!
&gt; I find that you still need a lot of the if else boilerplate with it. Don't you? Your examples don't do the best job showing how to avoid that if/else boilerplate though. You've only change the if/else from if(valueFromFirst) { /* can use valueFromFirst */ } to if(opt1.isSome()) { /* operate on opt1.get() now */ } It actually seems like you've introduced even more boilerplate because not only do you have to call `isSome()` to figure out the type, you also have to call `get()` to even begin to work on the value. Focus more on your `map` and `flatMap` library functions in your examples. That way you can demonstrate the value of not having if/else there; the moment you're doing `if(opt.isSome())`, you're not showing what Option can bring to the table. I modified your Option from [`typed-option`](https://github.com/AndersCan/typed-option) library in [this gist](https://gist.github.com/sasmithjr/16f9849473ae8843950c1c239483a57f). Your functions no longer use `if(this.isSome())` and instead use a `match` function. It allows you to perform operations when the object is either `None` or `Some` without having to use if/else if you prefer. You can make `match` public if you'd like, and then people more broadly can avoid if/else with your library if they'd like. Edit: Personally, I don't believe if/else is boilerplate. 
I've never been able to get a working build pipeline with typescript and closure. Do you have any examples? 
Please explain why. Newbie in react and vue here
Mind posting your type definitions for this?
When you post a link to something, it would be nice if that link had a description of what it is. I have been to two pages on the site and the only things I know are that you moved to typescript and don't want you users to require a loader. I still don't know what Intern is, and I lost all interest when it wasn't readily available.
Are you running webpack? I think the webpack bundling process is where you match file extensions to different processing tools. You can check the configs on my minimal project template here: https://github.com/KyleGalvin/frontendBoilerplate 
Boilerplate is created with this command: create-react-app my-second-app --scripts-version=react-scripts-ts react-scripts-ts does the builds. I haven't configured Webpack myself. And I don't know what that Sublime Text's Show error list actually does. Does it call TSLint? 
I think you can create a tslint file in the directory root and should be able to ignore the node_modules folder. You could Google tslint config to get a boilerplate or install it locally with npm install -D tslint, then call node ./node_modules/.bin/tslint --init to get it to generate one for you. Saying that I didn't have any issues running create-react-app with vscode and didn't need to change any configs...
it appears somewhat complicated. https://github.com/angular/tsickle
I've heard that inside google there is an effort to parse typescript directly in the closure compiler...which would be amazing. It's sad that the best quality javascript optimizer doesn't work with the best quality type system for javascript. 
Offhand my guess would be that sublime isn't parsing the jsx as jsx but instead as actual typescript code. Look for a plug in that will parse jsx inside tsx files. Also, there's an unofficial create react app w/ typescript cli which is based off the official one. You should probably try it instead for the build.
Test
Test
You are right. I'm promising a lot, but only giving a very basic introduction to Options that doesn't deliver. Thanks for the input, I'll improve on this in the future. I must say your gist is absolutely amazing! I've been wondering how you could make something that looks like pattern matching in TS. I'll have to take a closer look and ~~maybe~~ implement it. Thanks!
I've never understood this. I find it quite beneficial to differentiate between `undefined` and 'defined as `null`'. It's also more convenient on the fingers to write methods that return `something | null` than `something | undefined`. I realise that having both `undefined` _and_ `null` could get confusing, but I've never seen an instance of that occurring. I should note I'm using `strictNullChecks`, `noImplicitReturns` and `noImplicitAny`, which might help.
Basically, yes to all of your questions, besides overkill. Gradually introducing types to JS generally leads to using them more and more. I've built and shipped a large, non trivial, production JS app (webrtc, video chat, screen share, etc) that was built with TS from the start. I believe it was critical to the success of the app. Currently, I use flow which might be better for your setup. You can literally just drop it in to any JS file and start using it. If you don't like it, remove the types. Let me know if you want me to dive in deeper to any specific. Cheers!
you can use `ts-loader` to have webpack handle typescript files.
Why are you using TypeScript if you don't want types? Also even though the TypeScript compiler complains about type mismatches, if you are using default options, as long as your code is valid JavaScript, it would still generate the correct JS file. So you can treat those as warnings. 
Yeah, that was my question exactly. If I don't care about types, and just want interface functionality mostly, should I be using it. I'm guessing you think I shouldn't.
This is good, thanks. Flow looks cool. Is it very will adopted? 
I might do that.
I think so in the react world but not to the level of TS. Facebook made/maintains it. It's very close to TS so if you can't Google something for flow exactly then you can the same thing for TS.
You can keep the files as JavaScript files while still get the benefit of typescript compiler. Though I never tried to set a project up like that, so I do not know how well it works. * If you are using VSCode, it would load some of the correct external types and warn even when editing JS files without additional setup. For a full-fledged set up, [this page](https://code.visualstudio.com/docs/languages/jsconfig) tells you how to properly set it up. * You theoretically can set the same thing up with TSC, and use it as a linter, but I never tried. 
It’s amazing how much sanity typescript brings to JS
I can't answer all of this, but I'll try. This is what you can do with the config: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html I think you can ignore untyped js files these days, it may fall back to 'any' typing. Don't have any probs with it. I only use ts for interfaces, union types, and typed (maybe generic) functions. You can do everything with those alone, even in large production systems. I haven't used classes or inheritance in js for a long time, anyway. Also, I don't see how using a subset of the functionality offered could be overkill. Typescript is adding a layer of information. Of detail. But not of complexity. It makes it easier for other developers (or you in 1 year's time) to approach the code, because it provides more information of the intent of the code, and valid ways to use that code. You might fall down the rabbit hole, but if I were you, I wouldn't use all its features. Have a read about 'gradual typing.' p.s. If you use ts with webpack, use 'awesome-typescript-loader' 
I use Vue instead of react, and I found this: https://alligator.io/vuejs/components-flow/ I love the idea of having something I can pull in per file. Seems like, especially if it's a small project and only want to use an interface or two, it would help me avoid killing a gnat with a sledgehammer.
Why would you care about interfaces if you don't care about types? What IDE do you use? Turn off all checks. Slowly start explicitly using types instead of the inferred. Then slowly turn on checks. You'll not want to go back. 
Phpstorm, which is pretty much webstorm with php support. Polymorphism. I like being able to have a contract that objects adhere to. As a very simple example, say I have a factory that expects objects passed into it to have a make() method. Coming from PHP, we have interfaces for that, but it is not a strictly typed language. Eg, I don't care as much about primitives, though I can sprinkle in type checks for them when I feel like it's important. I realize this brakes all the mantras of TS. That's why I'm making sure it's a good fit before I put dev time after it.
So for starters, great choice on IDE. * Create a tsconfig.json and install typescript through NPM. * Turn off all checking inside of tsconfig.json, enable JS checking. * Typescript [JavaScript checking](https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files). * I would actually take it further, renaming your JS to TS. Or just make a copy and see how it goes. * PHP Storm and WebStorm will both suggest allowing the IDE to compile to JS from TS. You don't need to do this, just check the typescript errors it shows you. * I'm not sure how either IDE does with typescript checking JS. So you may not get expected results from a straight JS file. * VueJS is awesome, but there's some current difficulties with typescript. Next release is improving that a lot which will make your life a lot easier. * As you go, start enabling typescript checks. You'll actually start liking it more and more, along with finding bugs in your code. 
Thanks for this! Very helpful!
I don't like default formatter for TypeDoc, it feels and looks like ugly verbose JavaDoc. Would be nice to make formatter that output nice and simple docs.
Don't know, maybe it's a personal preference. But I find https://dojo.io/api/interfaces/v2.0.0-beta3.1/globals.html docs hard to use. This one http://backbonejs.org looks much better, very easy to find what you want.
What is the point of using interfaces if you're not typing your code?
Same here, I much prefer a basic tree navigation.
Polymorphism. I like being able to have a contract that objects adhere to. As a very simple example, say I have a factory that expects objects passed into it to have a make() method. Coming from PHP, we have interfaces for that, but it is not a strictly typed language. Eg, I don't care as much about primitives, though I can sprinkle in type checks for them when I feel like it's important. I realize this brakes all the mantras of TS. That's why I'm making sure it's a good fit before I put dev time after it.
&gt; I realize this brakes all the mantras of TS. What mantras?
The main point missing in my opinion is in which case this pattern is good, and where is it's limit. I feel like this pattern is good when you want to add new behaviors to the datastructure. You only have to define the functions for your behavior. When you want to add new elements in the datastructure, it is less useful because you have to modify every functions to handle the new type of gift. In that case, OO implementation should be better. So everything relies on your need. Btw, as mentioned in the end of the article, Typescript (and javascript though) is not the best language for that. I'm not really fan of putting an attribute in the object to describe the type (but you have no choice because typescript types are only at compile time... :()
I'm just saying, TypeScript (per the name) is all about type saftey. I was assuming the community wouldn't approve cherry-picking features.
I mean if you want to add new elements to the data structure you still don't need OO, you could also use typeclasses and perhaps existentials, for one example. 
Without getting into a discussion about flow vs typescript I'll just point out that typescript now supports using js files as well.
I'm a beginner so I warned ya. Yes I usually have a type definition for a model which is part of a generic that exactly mirrors the API response. If any of your front end uses attributes of that model you will definitely get errors in all dependent code when refactoring. I don't know if jetbrains is aware of typescript refactorings. 
This has nothing to do with typescript. 
The way we solved this problem where I work is by generating typescript interfaces based on the backend code (in our case c#). So when the c# type changes a new typescript interface is generated which will throw an error if your implementation no longer matches. Not sure if there are existing interface generators for Kotlin you'd have to have a Google
I have no problem writing the interfaces by my own (actually I made a generator by myself). If I create the Interface, simply building the project will let me know of the errors or I will have to run the code to know it's wrong? (By unit test for example)
Can you elaborate more how I will get those errors? Let's say I change a variable name, Will I get those errors when I compile the typescript and there is an object using a property that no longer exists on it's class?
That sounds amazing! I never tried a single line of TypeScript but in my next project I will definitely use it. Do you know where I can find a guide for this configuration?
Yep, building the project will break because your type will no longer be implementing the interface correctly.
That is awesome. Thanks for your help
I'm not sure if one of IDEs can automatically change all of the references for you, but the compiler makes it trivial to find every usage of that variable (or a key in an object or a method or... etc,...) and fix it quickly. Compiler-Driven Development is great.
When you attempt to use a property on a class that has been removed or renamed, the typescript compiler will show the file and line number. 
That is just perfect, thanks for helping :)
Thank you very much
Well, the compiler pointing where is the error is enought, but if undertood it right, /u/8468 pointed that JetBrains IDEs have this functionality, and that is even greater! &gt; I've just tried refactor and yes it works as you would expect in intellij, rename refactor finds all usages of property you want to rename
Speaking of unit tests, I find over half the unit tests that are typically written for plain old Javascript code are completely unnecessary when you use Typescript because the compiler will catch so much for you. 
Visual Studio Code has top notch Typescript support and absolutely supports variable and function renaming across your codebase. Refactoring is one of the biggest benefits of Typescript to me. I have made huge internal api reactors easily in a Typescript codebase that I would have been terrified to make in Javascript, even with tons of tests. One of my favorite things is completely changing a function signature, breaking the entire app, and then fixing compiler errors one by one (a simple click in a list in VS Code to go to each error). Once the compiler is happy, 99% of the time you're good to go. 
Probably won't help OP, but for generating TS from swagger or C# or even an assembly, I really like NSwag. https://github.com/RSuter/NSwag Making it part of your build is great, but lots of other ways to use it too.
Yes, refactor-&gt;rename is supported by the language service and IDEs that use it like VS code. WRT server-to-client, I'd generally say yes the server to generate swagger, then use the swagger to generate the typescript. https://swagger.io/swagger-codegen/
That would work yeah, but that's kinda hacky Imagine you want to add a flower gift. You need to apply all methods defined on the gift. Then you'll have to modify every functions that can be split to different files. You'll have to add new tests for each functions and if you don't know the codebase well you can miss some functions that were important. With OO you would only have to add a new class flower that extends/implements gift and you would not have to change anything outside that new class to make your code work. Then, the downside would be if you want to add a new behavior to the gift class, that would impact every child class. I only tried to understand the different use cases in order to know how to efficiently apply this pattern. I'll keep it in my toolbox :) (Thinking out loud can help people reading comments too :))
I feel like you don't understand typeclasses and existentials because none of what you just said is true. `Gift` would be a typeclass and you could also (if needed) have a `GiftX` existential. Just like in OOP you would only have to have `Flower` implement `Gift` and you would be good to go. 
Exclude node_modules in tsconfig.json
&gt; node_modules I've done this, and it doesn't seem to have any effect. "exclude": [ "**/*.spec.ts", "node_modules" ], My `tsconfig.json` is in the root of my project folder.
What errors are you getting?
A mountain of issues related to levelup/leveldown/memdown. node_modules/@types/levelup/index.d.ts(76,20): error TS2694: Namespace '"node_modules/leveldown/leveldown"' has no exported member 'Constructor'. node_modules/leveldown/leveldown.d.ts(66,3): error TS7010: 'seek', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(2,3): error TS7010: 'open', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(3,3): error TS7010: 'open', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(5,3): error TS7010: 'close', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(7,3): error TS7010: 'get', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(7,26): error TS7006: Parameter 'err' implicitly has an 'any' type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(8,3): error TS7010: 'get', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(8,39): error TS7006: Parameter 'err' implicitly has an 'any' type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(10,3): error TS7010: 'put', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(11,3): error TS7010: 'put', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(13,3): error TS7010: 'del', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(14,3): error TS7010: 'del', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(17,3): error TS7010: 'batch', which lacks return-type annotation, implicitly has an 'any' return type. node_modules/leveldown/node_modules/abstract-leveldown/index.d.ts(18,3): error TS7010: 'batch', which lacks return-type annotation, implicitly has an 'any' return type. etc. I've reported issues and they explained they are in the process of releasing ver 2 in the next week or so. In the meantime (and even in the future for other modules), I wanted to suppress errors coming from `node_modules` where I have no controls over these issues. I assume there has to be a way, otherwise it would be pretty ridiculous to be blasted with errors on every build that you can't help.
You can try adding skipLibCheck: true to compiler options until their new version is out
It looks like you probably have implictAny set to false in your tsconfig but that library is implicitly returning any from inside it. You can try setting implicit any to true in your tsconfig and see if that fixes the error. 
This does indeed remove all the errors, but I shouldn't have to change the ruleset of _my_ project and make it _less_ strict in order to hide errors returned from a node_module. Why would the ruleset from my project even be applied to all node_modules? That makes no sense.
What the parent said was true in parts. If you extend the sum type Gift with a new case then you will need to extend the signature of cataGift and anything that calls it. Implementing a type class approach in TypeScript is most likely going to involve extending some interface, which I think is what the parent means in OOP. I think the criticism that what is presented in the post being not extensible is perfectly reasonable. You probably both have a similar solution in mind, but one is viewing through the lens of OOP, and the other type classes / ad-hoc polymorphism.
I agree with you in theory. I'm not sure how to make it work like that in practice though. But at least now you know for sure what the issue is and you can try to get the maintainers to fix their definition files.
I'm going to be perfectly honest and admit I did not realize I was in /r/typescript. I thought I was in /r/haskell, so that's why I was saying you don't need OOP, because in Haskell you would use typeclasses / existentials instead. In typescript you probably should just use OOP, since you've already paid all the costs for it, (from type inference to runtime overhead to coupling and lack of extensibility), so may as well get the benefits.
Here's a quick fix for your specific situation. Add the following to your tsconfig.json's compilerOptions: "paths": { "leveldown": ["node_modules/@types/leveldown"] } and npm install @types/leveldown leveldown should not be distributing type declarations incompatible with `noImplicitAny`. It's a big no-no and is not allowed for anything on DefinitelyTyped. Fortunately, I think you can use the typings from DefinitelyTyped instead. The `path` mapping makes sure the compiler uses `node_modules/@types/leveldown` instead of `node_modules/leveldown`.
`"exclude"` only prevents items from being included by `"include"`; it doesn't prevent them from being included via `import` statements or `&lt;reference&gt;`s. If you import `levelup`, and `levelup` imports `leveldown`, then excluding `leveldown` or `node_modules` won't have an effect.
Okay sorry I thought your were talking about something else :/ I'm too newbie in FP. Do you have some links that explain correctly those notions? The ones I read were not 100% crystal clear 
I just posted on here about a pattern matching library I made to try to improve polymorphism without OO in Typescript. You might find it useful: https://www.reddit.com/r/typescript/comments/73d6mn/tsum_typed_pattern_matching_over_sum_types/
It's largely on me for thinking this was /r/haskell. My bad. In typescript you probably should just go ahead and use OOP whenever you want to be adding new values to a type but not new behavior, using interfaces and such. It's not reasonable for me to expect a typescript dev to understand existentials or typeclasses. But in case you are curious, I can explain the concepts. Typeclasses are essentially interfaces similar to in OOP, they just are defined in a much more powerful and extensible way. In OOP if you create a new cool interface you can't retroactively make existing objects / types implement it. You have to declare and implement all the interfaces you want when you declare the class. In Haskell you don't define any interfaces or behavior when intially defining a data type: data Color = Red | Green | Blue Likewise when you declare a typeclass you don't initially declare which data types use it: class Eq a where (==) :: a -&gt; a -&gt; Bool Then after you have defined both of them you can separately define the implementation of `Eq` for `Color`: instance Color Eq where Red == Red = True Green == Green = True Blue == Blue = True _ == _ = False Also another thing you will note is `==` requires that both arguments have the same type at compile time, in say Java `.equals` does not do such a thing and `myDict.equals(myList)` will compile fine and return false. But basically if you hear "typeclass" you can kind of just think "interface but cooler". Ok so now I'm going to explain how you can just use typeclasses to have a non-OOP approach to adding new types easily when you don't need to easily add new behavior. Let's say you want to build a whole bunch of functions and behavior and systems on top of numbers, but you want to easily add new number types without reimplemting all this stuff. Here is how you can do it: class Number a where (+) :: a -&gt; a -&gt; a (-) :: a -&gt; a -&gt; a (*) :: a -&gt; a -&gt; a one :: a zero :: a So we now have a `Number` interface that declares all things number-like, note that you don't have to actually use `one` and `zero`, you can make number literals work, it's just easier this way to explain. Also I would personally break it up into more fine grained pieces (e.g. so you can have just `+` but not `-` for some types), but that's not important right now. Now lets say you want a sum function: sum :: Number a =&gt; [a] -&gt; a sum [] = zero sum (x : xs) = x + sum xs Note that you can freely create a new number type and as long as you implement `Number` then `sum` will work just fine. You can actually use typeclasses to get really far into this whole "freely add new types" thing, farther than you typically go with OOP. Like for example lets say you want to be able to sum dictionaries and sets: class Foldable t where foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b Now you instead declare `sum` as follows: sum :: (Foldable t, Number a) =&gt; t a -&gt; a sum = foldr (+) 0 And now if you create a new number type and a new list type, totally independently, and just implement `Number` and `Foldable` respectively, `sum` magically works (and is type safe and fast and so on) for any combination of old and new numbers and containers. Existentials basically allow you to intentionally forget type information so that you can combine things of different underlying types. It's not hard to come up with toy examples that seem to need it, but I'll note it is very rarely needed in practice for real world Haskell programming. Lets say we have a `Gift` typeclass that defined various behavior such as `purchase` or `display` and so on, now lets say you need to store a bunch of gifts in a list that might all be different independent types. Well a list is a homogenous structure so you can't do that. So you must intentionally forget type information, this is done implicitly in OOP languages (e.g. `List&lt;Gift&gt; foo = [new Flower()]` forgets that you actually have a `Flower` and not a `Painting`. Hence why often you see things like casting from `Gift` to `Flower` which is very much not type safe, but due to Haskell's parametric polymorphism and typeclasses and other aspects of its type system you just instead choose to not forget type information unless you really really have to. Haskell decided to add a whole bunch of cool new features such as bidirectional type inference, parametric polymorphism and typeclasses, that don't play nicely with implicitly forgetting type information, so you explicitly wrap the `Flower` in a `GiftX` existential that intentionally forget that it is a `Flower` and remembers only that it is a `Gift`. Now you can have `[GiftX myFlower, GiftX myCar] :: [GiftX]` to have a list of gifts, but note this rarely comes up. Almost all of the time you are doing things like `purchase myFlower` and `purchase myCar` which does not need any of this `GiftX` stuff and it all just works fine. Hope that makes sense.
**Here's a sneak peek of /r/haskell using the [top posts](https://np.reddit.com/r/haskell/top/?sort=top&amp;t=year) of the year!** \#1: ["Category Theory for Programmers" has been finished!](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) | [38 comments](https://np.reddit.com/r/haskell/comments/6x7ms0/category_theory_for_programmers_has_been_finished/) \#2: [Typing the technical interview](https://aphyr.com/posts/342-typing-the-technical-interview) | [62 comments](https://np.reddit.com/r/haskell/comments/64lg42/typing_the_technical_interview/) \#3: [Lecture notes on Category Theory concepts and Haskell](https://np.reddit.com/r/haskell/comments/6oagzk/lecture_notes_on_category_theory_concepts_and/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Why is this downvoted? ES2015 spec clearly says that for explicit stuff `null` should be used. https://stackoverflow.com/questions/37980559/is-it-better-to-return-undefined-or-null-from-a-javascript-function/37980662#37980662
I get: error TS5060: Option 'paths' cannot be used without specifying '--baseUrl' option. When I enable `paths` and try a bunch of values such as ` ` `.` `./` all my errors come back. I can confirm that the `index.d.ts` file exists in `node_modules\@types\leveldown`. I went ahead and added `@types/levelup` as well and included it in my `paths` and went from ~21 errors to ~12 errors.
Including @types/levelup in "paths" is unnecessary because there is no alternative; levelup's npm package doesn't include typings so @types/levelup will be used. An explicit path is only necessary for leveldown because they include typings in their npm package, which by default take precedence over anything in @types/. I assumed you already had @types/levelup in your dependencies, is that correct? Keep the dependency, just get rid of the extra "paths" entry. I totally forgot you need baseUrl. It should be `"baseUrl": "."`. That way the path mappings will be relative to the root directory of your project.
That's what is going on when you define a type deriving equal and show in Haskell ? Or something different ? 
I'm interested - currently doing it with attributes using this https://github.com/reinforced/Reinforced.Typings Customizing every model using attributes is useful to us and we'd have to work on your "camel case" example - since it would convert "ID" to "iD"
Maybe I'm missing it, but it's really unclear how this brings TypeScript to anything. It seems like it's just a higher level wrapper around Express and you happen to declare some types.
Yes, and you define these types by using TypeScript. It's true that Nest.js does not forces one to use TypeScript, but using it is advised as the framework itself was written in TypeScript and considering that TypeScript provides so many nice features (like type checking).
But I don't want to compile my server side. 
The benefit over reinforced is: - Your code doesn't need to compile for this to work. Reinforced is based on the compiled assemblies, my script just looks at the cs files. Your Typescript can be available as soon as you save your cs file this way. - My script can do attribute-only mapping too. If you would like, I can elaborate how by improving the documentation? I am curious. How does reinforced handle camel casing? Does it do it better? 
I'd recommend anyone to have a go with ts-node alone before also bringing this framework in, if they haven't already. The phrase "brings TypeScript to Node.js and Express" to me sounded just like what ts-node does alone. This framework is something extra on top of that, bringing a decorator API and stuff.
This is cool. I'm glad to see more TypeScript support for the backend. Haven't looked at Nest.js much but I really like [routing-controllers](https://github.com/pleerock/routing-controllers).
Typescript itself doesnt force you to use typescript.. it's a superset thats purely opt-in... plain javascript in typescript is completely legal... 
Yeah pretty much. `data Foo = ... deriving Eq` creates `instance Eq Foo` for you. 
Okay I did not have that in mind when I wrote my answer :) Thanks for your time :)
I've been using [NSwag](https://github.com/RSuter/NSwag) for generating typescript models from C# code that does web api 2. This looks really interesting, though, but I'm trying to figure out if it's beneficial for my specific use case.
Great project! I love generating models one off from c# to typescript so this is perfect. It would be interesting to create a vscode plugin that uses this straight up. 
Using this together with ts-node (so you don't have to transpire anything server side) has been a joy
You also can use the vs code extension Typescript hero. A must.
Thanks for that. Camel-casing is a configuration option in Reinforced. I just set it on. It does do it better ```ID -&gt; id``` You'd probably want configuration options like these in Fluffy Spoon... rather than have to custom-write them, in some future release...? PS Maybe you need a "short name" for this product - I'm not sure what to call it. 
It utilizes TS decorator metadata to handle some processing for you. This does not work in javascript, you have to specify some things manually. 
On the contrary, it was designed to allow you to use as little or as much of the typings as you want.
Here's a little bit more information on the technical side: Auction status such as time left, bids, price are retrieved from ebay using simple rest request that returns json data based on auction ids appended the the request url. Json data if tabulated into rows using a template literal string one per row. TypeScript events are hooked up to monitor key presses like F3 for search, F2 for preferences, Escape key to clear search or close dialogs. I created a flexible Dialog class that handles the preferences menu, the image previews, and the profit calculator with one class. Can be reused with any other dialog types I dream up. I created a custom tooltip class from scratch. Its style can be altered through alternate css. Search filtering is easily implemented as follows: let filter = ""; input.addEventListener("input", ev =&gt; { let s = input.value; s = s.trim().toUpperCase(); if (s == filter) return; filter = s; if (s.isEmpty()) getAll("#rows .row").forEach(row =&gt; row.removeClass("filtered")); else getAll("#rows .row").forEach(row =&gt; { let found = row.innerText.toUpperCase().indexOf(s) &gt; -1; if (found) row.removeClass("filtered"); else row.addClass("filtered"); }); });
Fucking finally 
A deep dive into your application is a bit too hefty of a time investment for me, but one point of feedback that I can give after a cursory glance is that I think at this point, you could learn greatly from using a framework in terms of application design. Case in point: the code snippet above. It's a lot of work to manually keep the view in sync with your actual data. For example, what if some action by the user would lead to one of the rows having to be removed? You'd have to listen to such an event, and then in the event listener, check whether that row is actually being displayed at the moment or has been removed by your search filter (and if there's a bug that leads to rows being hidden for other reasons, finding that bug will be hellish), and if not, remove it. That sort of design is bound to lead to bugs not too far down the road. Consider if instead, you'd have used a library like React. You could have simply written a `map` function that would operate on your listing data to indicate which would have to be filtered, and pass the result to the function rendering the view: const filteredProducts = products.map(product =&gt; ( ...product, { filtered: product.name.indexOf(filter) &gt; -1; } } )); Now, if `products` were to change, React could automatically generate a new `filteredProducts` and then update the listing based on that, and the entirety of your code snippet would be unnecessary, and there would be less room for bugs. It's a bit hard for me to explain it in this short form - I believe the best way of learning is by doing it. So my advice would be: try doing the same thing using e.g. React, and try paying attention to what patterns you end up using and what advantages (and disadvantages) they bring you. Especially with you now having done a "manual" version, I think that could be very enlightening. More than anything we could say here :)
Fix errors and do a PR? if you have time that is
Thanks for the feedback. Regarding your point about the user removing a row through some action, that's not possible. For the user it is a read only, uneditable view simply designed to allow them to see the status of the items, my estimation of their resale value, and a comparison of the actual price people finally pay. As far as updating the view, I don't expect people to be just sitting there watching the page waiting for it to change. Like a normal ebay view, the page does not change. If the user wants to see the updated page after X amount of time, they can press refresh. Alternately if I wanted to update the page live, based on actual auction bids, it would be trivial for me to add that rather than bringing in a framework like react. Anyhow, I appreciated your feedback. Thank you.
&gt; Regarding your point about the user removing a row through some action, that's not possible. But that's just specific to the example I happened to choose :) The overall point is that it is a very common occurrence that data changes, and that it can save you a lot of potential bugs if you don't manually have to update that data in your view. Good luck with your project :)
You can make a wrapper around an instance of Map which gives you the typings you want: type Guard&lt;T&gt; = (x: any) =&gt; x is T; const registry = (() =&gt; { const store = new Map(); return { set: &lt;T&gt;(a: T, guard: Guard&lt;T&gt;) =&gt; { store.set(a, guard); }, get: &lt;T&gt;(a: T): Guard&lt;typeof a&gt; =&gt; { return store.get(a); } }; })(); class ExampleA { public exampleA = true; static guard = (x: any): x is typeof ExampleA =&gt; { return "exampleA" in x; }; } class ExampleB { public exampleB = true; static guard = (x: any): x is typeof ExampleB =&gt; { return "exampleB" in x; }; } registry.set(ExampleA, ExampleA.guard); registry.set(ExampleB, ExampleB.guard); const guardA = registry.get(ExampleA); // typed as Guard&lt;typeof ExampleA&gt; const guardB = registry.get(ExampleB); // typed as Guard&lt;typeof ExampleB&gt; console.log(guardA(new ExampleA())); // true console.log(guardA(new ExampleB())); // false console.log(guardB(new ExampleA())); // false console.log(guardB(new ExampleB())); // true 
Ah, thanks. Although I think it should be set: &lt;T&gt;(a: typeof T, guard: Guard&lt;T&gt;) =&gt; { store.set(a, guard); }, get: &lt;T&gt;(a: typeof T): Guard&lt;T&gt; =&gt; { return store.get(a); } and static guard = (x: any): x is ExampleA =&gt; { return "exampleA" in x; }; shouldn't it?
&gt; Yeah, your version produces guards for things like (ExampleA &amp; typeof ExampleA) | (ExampleB &amp; typeof ExampleA), which are completely useless for what I'm describing. My version, meanwhile, doesn't compile. I'm not sure what you mean by this
Your version's type guards return the right _results_, but if you use them as _type guards_ the type that TypeScript infers is ` (ExampleA &amp; typeof ExampleA) | (ExampleB &amp; typeof ExampleA)`.
Here's a quick [live demo](https://flems.io/#0=N4IgZglgNgpgziAXAbVAOwIYFsZJAOgAsAXLKEAGhAGMB7NYmBvEAXwvW10QOISroMmxPAHpRAAgDq0KBMK0oAEwkAlGEqURiEsACd6xAA4YA5jF0wNEpRmIYAOmlg6wVpYgkY0ATwkAfCQBXNCUYSDQNJydxCQAJRSU4YLgYPQkINCMg12hGdMYAD2InF108tIkAXgkAclrotEE4XKh8gGFaLCN6YWqJYGjiADcIGAB3AAoASgGhh2I9GGIgvTQJLEna-Eg2tNqKeZLSLbgTNAO6gDEKvU9a6cO0BZeT2szs4gOj18Hn49eC2IPiMMHuRS+T0BAJGGCgQTB5T2eihMNesQAqkZbIwkfkJMM4QivMkgqkCiD4D8YfQPjlPFh8ONtIQAILERZbQnwmCXbnEqoAPjm-2hr12+Jq-Jg1NerGmsuIrGpCtFxFVC2VaC1TmaOigEBanW6vQY-T+C1GEwkMxFryWKzWGy2+ANLW+aoWm1qhAAjJdalcDAwTOYJAAFWgtOAPVHoyQAZQU4wkUFoGC0aFMwQY0Ak4wshAwwws2hgWGSxFoNkNRigGB81LcUU9xwA-M6y1gADKG4jGnqRBgUAZduCeZtKfA4jD4aiEaBKJbajVo4gMrZGAPd9OZ0z4A8PI6rrU6pr0FoZRg9vsD006GoWkZjFOTYB2Rbj0fXuCseV244HVWdYxx2W5JmpLtqmFABCCVKn8QIu2nOxZ2IbRYHwKsdwLPR2gwVIZnwTIwkKAB5MBJngvQsNoHC0nwwjplmQUagABmPfAsAwIwINbKChU7a87yHYgR2ALt5WPIZT0aPUr3LES+kfIYrVfd8OT0L8JOvP9ZifBYgKdb1iOvD1oW9QgACZLmQmcsIwmBVwWE8nDPeSeKMJSzRU-41NtAzFmWYDnW2TzzJhTZqO89U42OTY3X7LpB2EZz1RktzGliABZWgQj4CRiEICxspZPQ8zoE1RKcRksDyhhJiUWhqCCHAGHwAAjWglB8EdPJijU0FiBMmBUWgwDACQlgARwRS8qymjQtFcWh0n0QwJFDUsf1TPsavwGa5uILYSGMcdxHGS6DqW7Q5y6UR8AAKzgegHiw4q0EmJY4CCNpoIAyd+m+36ShXSgaGS6A0jwPg2A4EBMBwPA5zgfgIaEZgeDYABdKgDTQABrBAUE4JGeCwMroHB1ZyB4U6jHO0QQiMAn90q0QKaK8qoAAAV9fB+YAFg5ymoCetHgVBPBnpx1ggA) using a micro-framework Mithril.js (which is similar to React.) It lets you filter a list of reddit posts by typing in the filter box. It's a very basic example, but hopefully demonstrates how you can apply filtering without patching the DOM manually.
TypeORM is what I’ve been waiting for in order to move from Rails to Node. Been watching it for a while now, eager to see if this release adds the features I’ve been waiting for. Thank you for your fantastic work!
This the ORM that node.js needs and community deserve. 
No. Sorry. Use ASP.NET Core and EF Core.
Please don't. JavaScript is the shit sandwich that Typescript makes barely tolerable and you want to infect your server with it? .NET Core is about the sanest choice right now. NodeJS is a cruel joke compared to RoR. I doubt any engineer who knows any other language would willingly use JS on the back end. I have 15+ years of JS and there's no way I'm putting it on the server.
This seems extreme to me. TypeScript in conjunction with modern JS features make the language quite pleasurable to work with, IMO. V8 keeps getting faster, while Ruby’s 3x3 project shows promise but... will it really happen? JS’s ecosystem is strong, finding engineers is easy, npm is now a modern package manager, and using Promises via async/await is powerful as hell. I’ve worked with Ruby for years (mostly backend, also helped maintain a somewhat popular ORM for quite a while) but would use TypeScript for a new project over Ruby in a heartbeat right now.
Pleasurable? Is this a valid heuristic for selecting a language? Please look at .NET Core ecosystem. It absolutely demolishes the performance of NodeJS and RoR...and modern c# is as close to a perfect language as I've used. Go is one of the only others I would say is close but the tooling and industry support just isn't there.
Thanks for this link.
“Pleasurable” in the sense that I feel like I’m able to move quickly without the language getting in my way, yes, I think that’s worthwhile. Tools that help more than they hurt. It’s more than I can say for vanilla JS or Ruby, more often than not. .NET Core has been very high up on my list of frameworks to investigate. It seemed to change quickly throughout its releases, so can you recommend any modern Getting Started resources? I build JSON APIs, work with Postgres, nothing crazy.
I'm currently fully behind an all MS stack, VSTS, Azure, Visual Studio. Honestly it's the best I've seen. Definitely more cohesive than the AWS and docker world. I find it much more productive and pleasant. I would start here: https://docs.microsoft.com/en-us/aspnet/core/tutorials/ Good next step, EF: https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/intro
And you're right, I'm probably lax on tact. But I've been doing this for a long time and the fads get old. I'm also at least 3 sheets in, so, I apologise if I seem curt.
We have use TypeORM 0.0.11 in production for more than 3 month. It's my first node.js project, the experience was great.
someone from Java world can hate your decisions on your stack just like what you did on JavaScript/TypeScript
What are your complains about JavaScript now. Typescript/ES201x has made using JavaScript really enjoyable for me. async/await is just magical. I haven't used RoR personally but node is like 10x faster than that which is just great for dynamically typed language.
I like Java but since Sun sold out to Oracle it just hasn't kept up with C# in terms of more advanced language features that make the language more functional and expressive. Putting TS/JS in the same realm as Java/C#/C++/Swift etc is a major stretch.
* Easy sockets * Client/server share codebase * Server side rendering * Electron * All the niche libraries npm has that other platforms don't
C# is missing *a lot* of TS features I wouldn't want to go without.
okay, so you put Swift into Java/C#/C++ realm....
Did it work?
The reason (from the TypeScript side) that this happens is that `exclude` doesn't prevent files that are referenced from being included in the compilation. Specifically, see this paragraph from the [TypeScript documentation on tsconfig.json](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html): &gt;Any files that are referenced by files included via the "files" or "include" properties are also included. Similarly, if a file B.ts is referenced by another file A.ts, then B.ts cannot be excluded unless the referencing file A.ts is also specified in the "exclude" list. Since you are importing `sp-pnp-js` in your main file, the definitions for that (and any of the dependencies that it recursively references) are included in the compilation and can't be excluded.
I feel like for the prices you charge employers to give out these tests you should either be doing this yourself or paying somone more than a $30 giftcard. Not super reassuring that a company that compiles these tests needs to outsource them like this. No wonder every test like this I've ever had to take has been complete garbage.
There's also just `tsc --init`. Doesn't do as much though.
I have been working lately on a little bit similar tool https://www.npmjs.com/package/tadd it tries to solve the problem of quickly installing new packages with typings for TS. 
Very cool, I like it! Thanks ;) .
&gt;The main thing is that a Promise is evaluated when it is created while a Future is evaluated when you explicitly call fork. Perhaps in some Future implementations, but in Scala this is not true. Futures are also evaluated at creation time. The Task type carries the behavior of futures describes in this article.
Unfortunately that's how Array#sort works, it casts each element to string before comparisons, but preserves items in the output. You can fix the behavior by passing a custom comparison function like `(a, b) =&gt; a &lt; b`. You can probably turn this into an error by overriding the standard library declaration of the sort method, but this isn't trivial.
Always remember that TypeScript is really just annotations for JavaScript. Anything weird that it does is probably because of that compatibility. Check out Array.sort on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort You'll see that string sorting is the default method, so you'll need to provide a custom function to do this. (An example is provided) There are many JS libraries that clean up array operations like this. Underscore and Lodash are a couple options. Hope that helps, and good luck! TypeScript is a really amazing language.
 const arr = [ { id: 1, name: 'Dave' }, { id: 2, name: 'Bob' } ]; arr.sort((a, b) =&gt; a.name.localeCompare(b.name)); console.log(arr);
The comparator function is supposed to return &lt; 0, 0, or &gt; 0. You can just subtract one number from the other.
Your first example isn't just off because of types; it produces results in the opposite order. :) Sorting with `a &lt; b` sorts opposite the expected order as `true` is interpreted as `+1`, the semantic response for `b` coming before `a`. The latter example will return `-1` when `a &lt; b` and `+1` only when `b &lt; a`. https://jsbin.com/lunewubodi/edit?js,console
Right, it's not C++.
You are absolutely right :) But my goal was to show how to win types problem which, i think, was the main reason of this question. 
That's simply not true. I've been using TS for nearly three years. It compiles to JS. Not being able to see any code etc. about how you're encountering this error its hard to speculate what might fix it for you. 
can't post the code sorry. and even if i did it's a giant project and it would take you a while to digest. if you want something else to read [here's a FB engineer explaining why Typescript doesn't actually offer any benefit to developers](https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887). You can get the exact same behavior without a rigid and unforgiving type system.
It seems like you're more interested in being angry and argumentative then you are in solving your problem. Did you do anything to try to solve it? I typed in &gt;Cannot find name "string" into google, and the [first result](https://stackoverflow.com/questions/33332394/angular-2-typescript-cant-find-names) might be a good place to start. Seems like this is a known issue with Angular, not TypeScript. 
if you read my post you'd see i google'd and stackoverflow'd the hell out of this, it seems like you're more interested in painting me as the problem instead of the many well documented gripes against typescript. typescript is supposed to help you with informative error messages right? it can't find a basic primitive..., i make the same exact declarations in multiple places without any problems. but the helpful error messages...
Read the link I sent you.
your link is purple... i dont know why you think im lying when i said i googled and stackoverflowed this for a few hours.
You have the patience of a saint. :)
* doesnt read my post * suggests link i already viewed * suggests the same link again * gets pat on the back this sub is hilarious
I'm going to ignore the paragraphs of unconstructive complaining. Did you, by chance accidentally do something [like this](https://stackoverflow.com/questions/41992050/typescript-cannot-find-name-error)? ie: function foo (bar=string) {} As opposed to function foo (bar:string) {} 
i didnt do anything but inherit a codebase and be asked to glue a buggy Angular4/Webpack/TS front-end onto a RESTful API. to faciliate a backend switch cause these peeps decided to use graphQL because 'hey its another buzzword i can put on my resume' meanwhile nothing works, they can't even get e2e tests working, and the consultant they hired to help them is gone, and me the new guy whose worked with a variety of different frameworks, custom in house ones, and popular ones, gets shifted onto this project and asked to save it. its a basic calendar app for fucks sake, why are they using a 1nm thick carbon nanotube to cut a stick of butter... the node_modules folder has 5000 folders and 30,000 files. this is not the future of web development. this is lazy stupid programmers thinking 'oh why would i code this basic functionality when i can import a library that does it'
Sounds like you need a drink.
Are you always this coarse of a person. no one is making you write your code in TS vs JS. If you love JS run with freakin' js. TS is just a superset of the language and provide a bit more syntactic sugar around the language to make it more type safe and OO-esque. You clearly have all the answers. So do what you want to do dude. on a side note, this issue feels like a PEBCAK error. Might want to look into that to see if it helps. 
i have a job. there is definitely someone making me write TS. im just desperately looking for something to tell myself that all this grief is worthwhile. that TS adds some value in some way. and with such a cryptic error message about such a basic primitive, im convinced there isn't.
why dont you take look who didnt read a post, and started making personal attacks before you label me as coarse. thank you for another issue to google.
Mate, the variety of solutions is due to either people like you giving 0 information or to people have some actual serious issues that need expert debugging. The fact that you don't want to add a code snippet indicates that you have no clue what you're doing, if you want this issue resolved and a decent discussion I suggest you first post the line(s) that actually give the errors.
I get your frustration, and the thing to remember is that no compiler, well nothing really, is idiot proof. And by that I mean we all make mistakes, and have all seen bizarre error messages from every compiler as they try to figure out what the heck we are trying to do (including whatever random code we include). Plus the nature of how web development has evolved and is constantly changing/diverging doesn't help at all. And the tooling does suck, no argument. A shitton of work has gone into it, but it is trying to re-invent everything from scratch. And the fan-boys with their favorites (and their naivete) who turn everything into a popularity contest. But it is what it is, you still have 6 more stages of grief to go through though :)
Sounds like you've given up on solving the problem and just want to run your code, given that you're not sharing any code by which we might help you debug the problem. It sounds like a fairly serious problem though (as someone mentioned, probably `=string` rather than `:string` was written as a typing for a variable/field/parameter somewhere. Do a find for "=string" throughout your codebase (excluding the node modules initially) and see if you track anything down. If you just want to build and try out your code, however, TypeScript can still compile the Javascript even if the TypeScript compiler throws an error; just configure with the 'noEmitOnError' flag in your `tsconfig` or the command line. Furthermore, from TypeScript 2.6, you can add `// @ts-ignore` comments to conceal errors. To any other TS devs reading this: obviously I don't condone this practice.
I assure you that's not the case. I've started at ~30 or so build errors and am down to 10. I'll probably work a bit this weekend and when I get everything isolated and identified I'll probably post the offending code.
The fact I don't want to post a code snippet indicates I put in a 60hr week on that shit and wanted my Friday night and Saturday day off before I spend the rest of my weekend cleaning up and stitching together two codebases I get minimal background information and support on. Businesses impose impossible expectations on workers all the time. The implications it's a pebcak error is more indicative of this subs defensiveness and unwillingness to discuss TS weaknesses.
Using React here. I've found that React meshes with Typescript incredibly well, and highly recommend it to anyone interested. 
I've found mobx, react, recompose, and material-ui (the beta for the new version) to be a fun combo typescript wise.
I don't see the problem here? You've declared an array of numbers and then created an array of actual numbers. Where are strings coming into play?
I was told you lose typing with props and state params? is this true?
I'm not sure what you mean. I have typings everywhere.
Angular all day long. It was built for TypeScript so you can’t go wrong. 
I don't buy into angular after the 1 -&gt; 2 drama sadly.
You don't lose typings on state because state is self defined by the component. It is completely up to you to define the type of state. For props you don't lose type information because the react components have a generic type where the generic is the shape of the props themselves so you don't lose type information there either. The sticking point is that often react components are propagating props through themselves without type information. Often the spread operator is used to just continue passing props down through a tree of components. The best way I, personally, have found to handle that is to pass unknown parameters through props and catch them on the other side. So you might have a parent component that passes props something like { foo: string, bar: number } The first child component only cares about foo so the natural reaction is to just create an interface like { foo: string } But that loses any other fields in props. A child of that component expecting bar won't see it through the type system. So I end up also declaring the generic parameter { [name:string]: any } Then you can pass it down where the parent has the original interface with both foo and bar defined and then the first child component has: { foo: string, [name:string]: any } And the second child component has props of an interface with { bar: number } And you can freely pass down the props that way and not lose typing information.
IIRC the react component typings have type parameters that let you specify types for props and state
Have you tried the 2 -&gt; 4 drama?
I'm using it with self-rolled libraries (virtual dom and FRP) for solo projects, but since those are too obscure for commercial work with others, I'm using it with React there.
I've been having trouble with material-ui beta on older browser (I target portable computers running Chrome 33 in a closed warehouse), but I use exactly this stack with the _old_ material-ui and it works brilliantly!
You don't need to declare a var name for the latter generic object? 
Hah. I just feel like they're too prone to deprecate and react kinda has them beat (if I were to go with a popular framework/lib)
correct. kinda painful to have to do both however.
My team doesn't use external libs, but our code doesn't have any sort of UI, and we have unusual browser support requirements.
So you're using it for node?
Assigning `survey1[category]` and `survey2[category]` to local variables, and calling the type guard on those, seems to work: const categoryScores: number[] = Object.keys(survey1).map(category =&gt; { const survey1Category = survey1[category]; const survey2Category = survey2[category]; if (isProficienciesArray(survey1Category) &amp;&amp; isProficienciesArray(survey2Category)) { return proficienciesScore(survey1Category, survey2Category) * categoryHighestScores[category]; } return percentageMatch(survey1Category as string[], survey2Category as string[]) * categoryHighestScores[category]; }); I'm not sure why, maybe TS's type guards have some sort of scoping restriction?
&gt; browser support No, it's essentially a passive captcha used to detect fraud. 
Not near a machine to test this with, but maybe it'll work with dynamic imports? 
In the second case you would have to assign null to for every instance of a user, so user:User = { email: 'example@example.com' } would work for the first interface, but not for the second. For the second interface you'd have to do user:User = { email: 'example@example.com', dob: null } I'm not sure of any functional reason to choose one style over another so I think it's a matter of preference.
No, that's the whole point. Using [name:string]: type signifies that you don't know what the field name will be. The value inside the []'s is limited to only a few types, I think just string and number offhand, but that type exists to let you pass around and fill out unknown stuff.
Why would it be painful? They are two different things, so of course you have to specify both.
The difference basically boils down to the difference between `undefined` and `null` (in javascript in general). You can Google that, but basically it's "there's no value" vs. "there is a value, and it's none", respectively.
I didn't realize you could have a parameter that was unnamed mixed with named parameters.
because the react PropTypes feels hacky. It'd be great to have it all in one. TypeScript safety is superior.
Ohh I must have been confusing it with something else when I was testing. That is definitely a different way of using the types. Thanks!
Their two different things. Two different variables. One gets passed down as component.props and the other is literally component.state. How else could they possibly do it? And what does dev mode safety have to do with anything here? This is really confusing.
They kept angularjs around for 5 years. And they wrote a new framework to address the parts that were badly designed in angularjs because they were fundamental to angularjs's design and couldn't really be just changed through an update. You can say it was a marketing failure to reuse the angular name but the new angular framework is fine. There's nothing wrong with it or any indication that it will be replaced.
An optional property can be omitted from an object literal or assigned the value `undefined`. An `| undefined` property can be assigned undefined but cannot be omitted from an object literal. `| null` is the same but with `null` instead of `undefined`. In other words, optional props are not identical to unions, because only the optional marker allows the property to be omitted from object literals.
https://github.com/TypeStrong/ts-node
The [Monaco](https://github.com/Microsoft/monaco-editor) editor is the same one used in the TypeScript playground site and shares a lot of code with VS Code. It has very good support for TypeScript built-in. Performance is basically what you see on the TypeScript playground page, it takes a while to load initially, but then it works pretty fast once it's ready. TypeScript itself can be used in browser fairly easily, see https://github.com/Microsoft/TypeScript/wiki/Using-the-Language-Service-API and https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API I once tried to create a better "fiddle" site for TypeScript (where you could also edit tsconfig.json, choose TS version and other things), and while I never finished it, you can have a look at the [code](https://github.com/peterholak/ts-play). The "interesting" parts are the call to [`getEmitOutput`](https://github.com/peterholak/ts-play/blob/master/frontend/src/App.tsx#L106) and actually running the code [inside an iframe](https://github.com/peterholak/ts-play/blob/master/frontend/src/Output.tsx#L40).
Thank you! :)
Thank you! :)
Are the users going to get the TypeScript code and be able to input TypeScript? Feels like your application would be easier without a full-fledged TypeScript implementation. Since you have a limited set of interactive programmable elements that doesn't have the requirements of real world programming language (backward compatibility, forward compatibility, general purpose API), it might be better to just write an interpreter yourself. With typescript, you might need to define your own API, how it behaves with different versions of your code/module, etc. 
The old `module` has been renamed `namespace`. ``` A note about terminology: It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with ECMAScript 2015’s terminology, (namely that module X { is equivalent to the now-preferred namespace X {). ``` https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html This system is still supported, but designed for client-side code without module system or bundler. Most bigger JS apps now is either Node.js or uses a bundler -- webpack, babel, browserify, requirejs, maybe also ES6 async loader in the near future. The new module system can compile down to support those: * Webpack/Browserify/Babel - ES6, CommonJS * RequireJS - AMD I would follow ES6 module system if your bundler is compatible enough. ``` import * as jquery from 'jquery'; import MyClass from './MyClass'; import namedExport1, namedExport2 from './MyUtil'; export default MyClass; export { namedExport1, namedExport2 }; ``` 
Thanks for the comment. This suggests that I was reading the documentation correctly, and that `namespace`/`module` doesn't have much of a place in TypeScript post-1.5. Your first quote from the docs is what I think was throwing me. They call that out at the beginning of the page, and then don't really talk too much about actually implementing that in the remainder. I'll take your advice and look at ES6 modules for my next step. I think that'll help me understand better how TypeScript implements it.
Just be warned that Node.js is actually CommonJS-based, but you can use ES6-like syntax to import most Node.js/NPM modules. My ES6 syntax above for 'jquery' should work for most, but there are some that doesn't work. There are quite a bit of quirks in implementations in this area (CommonJS vs ES6 module system) across the board in JavaScript transpilers, not just TypeScript. 
&gt; and that namespace/module doesn't have much of a place in TypeScript post-1.5 Shouldn't that be in a "project without a bundler? We use namespace in ts 2.5.2 and won't be changing anything about it until we integrate WebPack (we have nothing of the sort at the moment) 
That is true. It is a blast to work with and applications scale very well. People seem to dislike Angular, because of its name but it really is a good Framework.
So, that section should not be deprecated in the documentation? As I asked the same question 6 month ago, I think it's really confusing for new joiners
Very rarely would you want to use it. IMO, you should only use it for legacy application that pre-dates all the module/bundlers, and you don't plan to refactor. If you are new, I would recommend setting up tslint with `tslint:recommended` preset (&amp; minor modifications like your preferred quote/indent character). `namespace` is banned in that preset. 
Exact, last time I was asking because tslint told me to not use it.... The techlead overrided the rule x) That's why I was asking if it should not be marked in official documentation as deprecated. The techlead would not have overrided it if it was flagged as deprecated in the documentation, I assume. Anyway, I find the current state confusing
Great question. I've seen articles that suggest bundlers aren't needed with TypeScript anymore since TS supports it out of the box/better (?) now (either 1.5+ or 2.0+). For my purposes I'm at the point where I want to do more than just bundle and strip comments, which is what lead me to browserify/tsify so that I can uglify via gulp. Which raises the question of whether you should use namespace/module if the natural step is moving to a non-TS bundler. Even the handbook covers these, suggesting they're expecting people to just put the effort in to use one immediately.
I just migrated a 30KLOC codebase from 2 -&gt; 4. Didn't have to touch code at all, just bump version numbers in `package.json`. I submitted like 5 pull requests and they were all handled within a week. The actual upgrade to ng4 was easy, and all the pain-points were with npm not typescript or angular. I wish there was a simple way of telling npm that a given dependency works fine with a newer version (e.g. ng4) without having to just fork the repo and bump the version.
This is cool. Writing `linalg.matmul(A, B)` makes me want operator overloading.
I suppose you could manually concat all declaration files into single file, if they are not in hierarchical structure. I'm doing something similar when I'm adding extraLibs to Monaco editor in my project.
See you there!
Would like to attend if I wasn’t traveling. Hope to attend in the future.
If you use --outFile on the TypeScript compiler it will combine them for you. Why do you want them combined though?
You don't need to combine them to use them with `types`. Assuming you're using imports and exports, your `.d.ts` files should reference each other in the same way. package.json `types` points to the main declaration file, which in turn references the others. If I have misunderstood your setup, can you post a minimal code sample?
&gt; I’m currently trying to achieve 100% code coverage Why? What does it buy you? I’m not convinced 100% of code needs to be covered thru unit testing. Unit testing is a valuable tool, but don’t overuse it. And sorry - to answer your question - no I don’t know of a way to achieve that kind of coverage :P
Which browsers (and versions) are you running your coverage tests in? Those are there for browsers that don't support `Object.setProtoypeOf` or don't add the non-standard `__proto__`. My guess is you'd have to fire up old versions of IE (pre 11) or old versions of Firefox and Chrome (from a few years ago) to get those lines to execute. If you're really motivated to keep 100% coverage, you could look at using the `importHelpers` switch to pull in the standard library code from the `"tslib"` npm module. Personally? I'd let it be. With the amount of generated code and dependencies like polyfills that make up modern web development, you're fighting a losing battle. Focus on getting 100% coverage of _your_ code, and let language and library maintainers worry about covering their code.
Don't aim for 100%, you are kidding yourself and wasting energy. You will be spending all your time working towards this arbitrary sheet of green ticks and forgetting to think rationally and methodically about what and why you are testing.
By applying the source maps to the coverage report using istanbul-remap, you can get more readable output (TS instead of compiled JS) and those lines aren't in the report anymore. That makes it totally feasible to achieve 100% line coverage for most files.
This looks normal to me. Some projects write the interface in one place and then implement it in a concrete class. Consumers must import the interface but don't need to import the class because the DI system is responsible for giving them an instance that matches the interface they expect. What DI benefits do you think your missing out on? It's possible your project is simple enough that it doesn't need all the benefits of DI.
Use "importHelpers" to load those helper functions from the external "tslib" module. Then they don't exist in your code and won't be flagged by your coverage tool.
You can just use require. Every single startupFile implements the same interface, so declare that the return value of your require call is a value matching that interface. Something like this: const startupChecker: IStartupFileFn = require('./' + startupFile); startupChecker(callback);
This is perfectly fine, and Typescript suppresses Interface from the output. If this is just a code style issue, you can create a d.ts file where you declare global types. Something like global-types.d.ts import __MyInterface from "path/to/module"; // or import {MyInterface as __MyInterface} from "path/to/module"; declare global MyInterface:typeof __MyInterface;
The choices to use libraries, frameworks, TypeScript, and classes are all orthogonal concerns. It doesn't make a ton of sense to treat them as either-or choices. For example, why do classes or a typesystem make a virtual DOM any less useful? I'm no more inclined to write my own in TS than I was in JS. If anything, TypeScript's tooling makes it *easier* and *more desirable* to use external libraries and frameworks because the APIs are easier to consume. That's the whole point of TS.
That's not right. He's talking about console.log, not Array.sort. Array.sort doesn't do any sort of conversion.
I disagree. The abstractions TS provides that JS iris just now introducing blows it out of the water and opens you up to easier control imo
I'm certainly getting the benefits of DI, but what I'm trying to do is decouple my files, and DI goes a long way to making that happen, but then I have to put to the files for their types anyway. That's basically what I'm getting at, and trying to 'fix'. It'll be a larger application and DI will be needed, and the parts may be reused so I'm trying to make it more modular by removing direct references to other files. 
Dependency injection gives you the ability to mock dependencies but your code is still coupled. Dependency injection is not enough. To decoupled you need something else: Dependency Inversion. “depend upon abstractions (Interfaces), not concretions (Classes)” You can achieve this as follows: ``` import { DataQueryFactory } from 'interfaces'; import { TYPES } from 'types'; export default class App { @Inject(TYPES.DataQueryFactory) queryFactory: DataQueryFactory; } ``` The `TYPES` are just symbols: ``` const TYPES = { DataQueryFactory: Symbol("DataQueryFactory") } ``` Or as follows: ``` import { DataQueryFactory } from 'interfaces'; import { InjectDataQueryFactory } from 'decorators'; export default class App { @InjectDataQueryFactory queryFactory: DataQueryFactory; } ``` The `InjectDataQueryFactory` is just: ``` const InjectDataQueryFactory = Inject(TYPES.DataQueryFactory); ``` 
We define it like this: IDBAdapter.ts that exports an interface and the type. This decouples the interface/type away from our concrete types. Another approach is to just have the types defined together in a map
Something to note for the manager types that might listen, you can get (and I don't have the articles but there are many examples) quick wins just by enabling typescript and using vs code. Ie, by letting it infer types and getting a very small amount of typed code can still help highlight issues in your existing code base.
Yes, I thought some live coding examples would be nice.
That similar to the Inversify examples but I haven’t fully implemented them. Coming from a C# background I identify with interfaces over implementation, but I’ve never really understood the best architecture around it. Ideally the interfaces would be portable with the code, but if they sit with the code then you have to path to the implementation anyway. Alternatively, as mentioned, I can make an interfaces file that I ports all the interfaces I need and exports them from a single place. That seems like a lot of extra work, but just like my service container for Inversify, maybe that’s the necessary step I’m missing. In C# we could namespace it and access it through Services.DataQueryFactory, for example. I don’t see a great way to do that in TypeScript, but I’m still relatively new to it. 
Welcome to enterprise software. :(
&gt; Focus on getting 100% coverage of your code, and let language and library maintainers worry about covering their code. This is a very good point.
Hey, here's one of many open source TypeScript projects where I work that has 100% code coverage using source maps. https://github.com/LearningLocker/xapi-state We do intentionally and unintentionally ignore some files. Intentionally because we don't want to use them in our tests (because they expect to be executed in a production context). Unintentionally because of dead code that is no longer imported. Probably best to start at the ".travis.yml" and "package.json" files. I hope that example is useful to you. All the best :)
what do they normally use on the back end?
If you are in the world of finance I would absolutely stress that a strongly typed system removes an entire category of human error from being possible. By having the transpiler check your types, you know that type errors will not be firing at runtime. This leads to more robust code and saves on development time
&gt; I can make a single interfaces file that imports and exports all the interfaces I need. That seems like a lot of extra work, but just like having the service container for Inversify, maybe that’s the necessary step I’m missing. That is what I personally do but I can understand if some people don't like it... If you do create a single file you can use the d.ts extension. Then you can import it using the types option in tsconfig.json and then you don't need import statements to import interfaces. You can access them via a global. Because these global is only to access interfaces it is not available at runtime. So it is not really a global variable (which I would try to avoid).
Upcoming Babel 7 will have support for stripping TypeScript types without the tsc compiler, but there are few limitations and one is that the namespaces are not supported. So that might be something to consider when deciding whether to use namespaces. More info here https://news.ycombinator.com/item?id=15236089
`[number, number, number, number]` or `Array&lt;number&gt;` there are no fixed-length arrays (except for [tuple types](https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple)) and array elements don't have names
 let area: [number, number, number, number] = [0, 0, 0, 0]; should work.
Arrays are indexed by number, starting from 0, always. You might want objects: let area: {x1: number, x2: number, x3: number, x4: number}; area = {x1: 1, x2: 2, x3: 3, x4: 4}; area.x1 You could also use tuple types let area: [number, number, number, number]; area = [1, 2, 3, 4]; area[2]; // 3 area[5]; // compiler error You could also combine the tuple type with destructuring assignment: let [x1, x2, x3, x4] = area;
type Area = { x1: number, y1: number, x2: number, y2: number, }; area: Area; 
Demonstrate `keyof`. IMO it's a totally killer feature, especially if people are familiar with C# or Java.
Great idea, it's a lifesaver.
Is there a way to specify how many numbers are in the array? Eg, something like Array&lt;number&gt;[4]... I also tried enums, I could do: enum Area { x1, y1, x2, y2 } a[Area.x1] = 1; a[Area.y2] = 3; but it turns out that enums are compiled into an Object anyway: var Area; (function (Area) { Area[Area["x1"] = 0] = "x1"; Area[Area["y1"] = 1] = "y1"; Area[Area["x2 
I'm not aware of any way to label the elements in an array. You could use the enum (why is there a problem, that it produces code?). But I'd say, you better use an object like other poeple already suggested. This would be the cleaner approach than using an array and labeling it by enums. Concerning the number of epements in an array, I'm also not aware of a way to specify them other than what I already suggested above (`[number, number, …]`).
The reason why is because I'm trying to pack arrays for WebGL and yet somehow extend Typescript safety into them.
So you'd want typesafety in form of a fixed length array?
This is how I did a rect class in my typescript webgl project https://github.com/emilekberg/onodrim/blob/master/src/math/rect.ts
Yeah, sure, in the same way Typescript now has type safety over a scripting language, and how C achieved type safety over an array 30 years ago.
Make your presentation simple. Show them what they want to see. Don't show shiny (but really great) features they won't understand from the first look on it. If they are bears show them similarities with languages they use, remember most of time bears don't like new things, they want to see things they are adapted to. If there is a choice in your company between js vs ts then show benifits of ts over js. If there is a choice to choose node+ts over other server side languages them show them perspective of node and javascript ecosystem and show how typescript brings even more things to that perspective.
My own, which extends from "tslint:all" "tslint-react" "tslint-eslint-rules" "tslint-config-prettier" Then I loosen up some rules since "tslint-all" is mad strict. Also, I remove "tslint-react" from extends if I'm not using react, obviously.
In the [related article](https://blog.mariusschulz.com/2017/01/06/typescript-2-1-keyof-and-lookup-types), in `K extends keyof T`, why is the "extends" there? Wouldn't that mean K can be any key of T, or something else entirely since "extends" implies a superset? Why not just `K keyof T`?
``` class Area { constructor( public x1: number, public y1: number, public x2: number, public y2: number ) {} get asArray() { return [this.x1, this.y1, this.x2, this.y2]; } static fromArray([x1, y1, x2, y2]: [number, number, number, number]) { return new Area(x1, y1, x2, y2); } } ``` 
React's PropTypes feature is redundant in TypeScript. It's a kind of weak type checking mechanism that you just don't need if you have a proper one available such as TS.
What the other poster said. And regarding the dev benefits.. catching more bugs at compilation time makes the developing progress more rapid
Promises are effectively monadic. `then` is the `bind` operation. And `async`/`await` is like the `do` notation (per Haskell). A future can be modelled simply as an `async` function: call it to launch, as many times as you like.
I extend "tslint-config-airbnb" "tslint-eslint-rules" Then added a few small changes on top that suit the style we use here.
Oh I see your talking about the prop types thing in react. I thought you meant the fact that react has 2 generics in its type definition: class Component&lt;P,S&gt; { props: P; state: S; } But yeah the prop types thing where you specify the types in a data structure in the constructor are unnecessary with typescript. Just don't use them. I don't bother.
&gt; "tslint-config-airbnb" Already uses "tslint-eslint-rules". I think that is redundant.
I think that "tslint-eslint-rules" is redundant.
When is it better to use Pick vs. Partial?
`Pick` when you have an object that is a specific subset of another interface, it says, “this object contains only this/these key(s) of T.” It’s particularly useful with React and `setState`. `Partial` is less specific, it makes the statement, “this object may or may not contain any or all keys of T.”
To add onto this, `Partial` allows some likely unintended behavior, e.g. interface Person { name: string; } function updatePerson(orig: Person, partial: Partial&lt;Person&gt;) { return { ...orig, ...partial, }; } const person: Person = { name: "Bob" }; // compiles, but newPerson.name === undefined const newPerson: Person = updatePerson(person, { name: undefined }); It's almost always better to use `Pick` if you can IMO, but the typings are more restrictive due to needing to specify the keys you're picking. In some circumstances the keys can be inferred (as is the case with `setState` typings in react), but it isn't always possible to get this inference to work out.
I use the default settings installed by [react-scripts-ts](https://github.com/wmonk/create-react-app-typescript), but with some extra checks enabled, e.g. trailing whitespace.
React + MobX is bae
&gt; Compiler-Driven Development is great. Ok, I'm stealing that phrase. That's exactly what I do!
There is also https://github.com/google/ts-style although it contains more than just tslint; it also includes the code formatter and default tsconfig. (Disclaimer: I work on this)
I had a similar problem and I decided to just use fs-extra which has typings.
So the latest typings for node have readfile and readfilesync bindings which appears to suggest readfile returns the promise. https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node It looks like the signature might be the following: export function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise&lt;Buffer&gt;;
This is where I don't understand. The promisified function's signature is defined but seems like IntelliSense is ignoring it. (I am using WebStorm, if that helps.)
I can't offer much more insight from my vantage point. Do you have @types/node installed? Which version of the node api are you running? Do the two match? Can you hack/edit the installed types file in your node_modules direct in a way that makes an observable change to your intellisense? Can you do the same with a working typings file? Maybe answering these questions can give more insight as to where the problem lies
I have @types/node @8.0.47 (newest) installed, along with node@8.8.0 (newest). I think this problem is related to my IDE as the typings are properly shown in VS Code (using util.promisify, bluebird.promisify shows the same problem). For now, I think I am going to reside to fs-extra.
If there was activity on [this Typescript issue](https://github.com/Microsoft/TypeScript/issues/2983#issuecomment-312810059), then we could use async / await for all monads. However, it's gotten kind of stuck on the proposal to improve the assignability check in the necessary way.
&gt; Promise happens to be a monad because it has the .then method. This is false. Promises aren't a monad, they don't even define well typed `unit`. &gt; The resolve function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this constructor. This clearly violates the parametricity of `unit` suggested by its type `forall a. a -&gt; m a`. Not all inputs are treated equally. 
I thinks that's a little pedantic distinction. You can easily define a function promiseUnit with type T =&gt; Promise&lt;T&gt; by doing (t: T) =&gt; Promise.resolve(t). Yes, as you said Promise.resolve can take a function that returns another Promise but there is a way to make a well typed unit for promise it's just not Promise.resolve. Similarly, the .then method on a promise is not exactly a bind either. It can function as map as well but you can still define a properly typed flatMap/bind on a promise using .then. Just because the properly typed functions don't exist in the standard library doesn't mean it's not a monad. The only requirement for a type to be considered a monad is the capability to put a value into the type (pure) and the ability to flatten one level of nesting. The way these capabilities are implemented is irrelevant.
Yes, I've seen the issue as well. Even my first thought was to use generators but unfortunately, currently, the value generated by yield is inferred as any. Until then, I think by solution is sort of acceptable (at least to me).
This is an awesome idea! I struggled with generators myself, and with defining flatMap1, flatMap2, flatMap3, etc. (which hardly seems elegant). This idea is the most usable, in my opinion.
Is there a way to make it prettier by allowing .assign({ x: positive(23), y: positive(23) }) which results in a scope { x: 23, y: 23 } That way, you could lose the "ugly" quotes around your values as well.
There might be a way do that but then you'd be relying on the runtime to enumerate the object keys in order in which they appear in the source. (I'm assuming you want x to be bound first and then y). Even though most runtimes (I've checked in chrome and node) enumerate the keys in order right to left, top to bottom, I don't think it's a good idea to rely on such unspecified behaviour of the runtime. Even transpilers may change the order of keys. JavaScript standard says clearly that the order of enumeration of object keys is up to the runtime so technically, there might be a few runtimes that might enumerate y before x. From the point of view of the assign method, there's really no way of knowing whether to do positive(23).then(x =&gt; positive(23).then(y =&gt; ...) Or positive(23).then(y =&gt; positive(23).then(x =&gt; ...) Moreover, typescript won't be able to infer different types of the scope in the same object. y might need the value of x so I'm pretty sure that won't work. 
In this case you will be using the Applicative properties and not the Monad properties, zo order shouldn’t matter, right? It is not like you want to sequence them bevause x and t are clearly independent.
Yes in this case it's fine but not for monads in general.
If you're only interested in applicative properties, this function signature might be useful to you function $&lt;A&gt;(aMObj: MaybeValues&lt;A&gt;): Maybe&lt;A&gt; This will allow you to do something like $({ x: getMaybeNumber(), y: getMaybeString() }).match({ // here o will have inferred type {x: number, y: string} Just: o =&gt; o, Nothing: () =&gt; ... }) Though I haven't thought about how you'd implement this function by using `ap` and `map`. Seems doable. Might give it a shot later.
In my experience, source mapping seems to butcher Branches number, which is more important than Statements, Functions, and Lines number. There were files with branches I never tested that got 100% Branches coverage. It might be a limitation of the version I was using. 
You could fold over the key-value pairs, starting with {} and adding a key-value pair each time, using `flatMap`. Maybe I'll give it a try myself. I'll let you know.
I'll have a look next week, but I haven't noticed such discrepancies. I do like to use the coverage reports to find uncovered lines/branches and consider how important/complex they when reviewing changes. At least everything that was reported as uncovered was actually uncovered with recent Typescript, Node, Jasmine, Angular CLI versions.
Just looked on their GitHub, it is a reported bug: https://github.com/istanbuljs/nyc/issues/618
Good job! I am also under the impression that we need to rethink parts of JS ecosystem when working with Typescript.
Pretty cool. Rx observables can do everything redux does and more. app state is a stream from a fold over an initial state + input actions stream, by a reducer function. 
If you are using Webpack with `ts-loader`, `outDir` in `tsconfig.json` is ignored. You could theoretically remove it, but I wouldn't. Other editors/IDEs might not recognize Webpack, thus would dump compiled JS files into your source directory if you don't have this config. (I assume Visual Studio handles it correctly) Also most online examples has `webpack` output and `outDir` point to the same directory (i.e. `dist`), you can change that. 
Are you using latest WebStorm and TypeScript plugin? I had to debug a WebStorm issue on a coworker's setup last year, and it turned out it had an old version TypeScript and there was no updated to the plugin as the version of WebStorm was not the latest. 
`keyof` and `extends` are both operators. `keyof` is a unary operator (think `negative sign`). `keyof T` represents a union type of all the string keys of T. `extends` is a binary operator (think `multiply`). `K extends X` defines K is a subtype of X. In other words, K is a narrower definition than X. If you put them together, `K extends keyof T` means K can be a type that "K is a type whose definition is based on the union type of all the string keys of T, and it can be narrower than that". In case of that article `keyof T` is `"id" | "text" | "due"`, so `K` can be `"id" | "text" | "due"`, `"id" | "text"`, `"id" | "due"`, etc. 
Code. Show us code.
This seems pretty rad, anybody tried it out?
Sorry! Here is the question reformatted from stackoverflow: This is a common problem I'm facing when working with angular2+. I have a property in my service that only gets a value assigned to it once an observable that's defined in the constructor is resolved (for example an `http` call below). I can either assign the observable to the property itself, and subscribe to the property in other components(1), or I can assign a value to the property in the `.subscribe` call (2). (1) @Injectable() export class UserService { public property; constructor(private http: Http) { this.property = this.http.get(url).map((res) =&gt; res.json()); } } (2) @Injectable() export class UserService { public property; constructor(private http: Http) { this.http.get(url).subscribe( (value) =&gt; this.property = value.json() ) } } The problem is that in case (2), I can't figure out how to handle the property in other components that consume the service, since given the async nature of observables it always resolves to `undefined`. I'm not concerned about handling it in the template but rather in the TS code. I can't always use case (1) because sometimes I need the response to be assigned to multiple values. 
There's a couple ways to handle this scenario. For (1) you can use `this.property` in the template like `{{ property | async }}`. The `async` pipe handles the subscribe/unsubscribe for you. If you want to access a specific attribute from the response then you'll want to do `{{ (property | async)?.someAttribute }}`. For (2) you could always do `{{ property || 'some default value' }}` or if you're accessing an attribute on the response, `{{ property.someProperty }}`.
I get handling it in templating with the safe navigation operator or async flag, my main concern is how to handle those values in other components. Say for example I need to know the default currency for a specific user. My user service queries the api and gets the response, in the .subscribe of the `http` call it assigns the value to, for example `this.currency`. My currency service that handles changing the currency has a BehaviorSubject with the default currency. Instead of calling private currency = new BehaviorSubject&lt;string&gt;('EUR '); how do I make use of the other services property, when it's received asynchronously and therefore not automatically available? 
Yeah I realized the bundled version of TS is 2.4. But I chose to use the project version which I used npm to install. However thanks for pointing that out.
I'm not sure if I understand the full context but one way to handle it would be to `.share()` the http observable. This code is untested but I think it will do what you want: ``` @Injectable() export class CurrencyProvider { user$ = null; readonly defaultCurrency = "EUR"; constructor(http: Http) { this.user$ = http .get("/users/1") .map(res =&gt; res.json()) .share(); } get currency(): Observable&lt;string&gt; { return this.$user.map(user =&gt; user.currency || this.defaultCurrency); } } ``` You could then access the currency property on the service which will eventually resolve to the currency value from the user request. With `.share` you can access the currency property multiple times but the user http request will only be made once for the instance of the service.
I did visit this problem not long ago when messing with TypeScript and Node to make a GraphQL API. I started using webpack, but came to the conclusion that it is better suited for frontend, client-side JavaScript projects rather than server-side. In the end, I got what I needed using regular package.json scripts. Here is a repo containing this work: https://github.com/bttf/nodeapi-graphql-typescript Hope it helps!
Could you provide a code sample of what you're doing in the other components ? &gt; In templates you can use the async flag or safe navigation, is there a similar solution in typescript? You can use the old `property &amp;&amp; property.myAttribute` to access something only once it's defined... I would avoid keeping information in many places like you seem to be doing (i.e you receive it in one place and set it in other components). It creates hidden dependencies between components (B.a is set by component A, but you need to look at A code to see it) and it may create multiple sources or truth (like, some component starts using B.a instead of getting info from A) which may be hard to manage in the long run. 
I wish I read your comment a few hours ago. I just recently figured out the `&amp;&amp;` trick, and I'm starting to realize the problem with not having a single "store of truth" but not too sure what I can do about it. I know redux is meant to organize state but I don't have time now to research and implement it - if I'm even right in thinking that it would help. I'm still not sure what the best practices are in typescript when it comes to state management or what the workflow should be when working with observables. When I work with http, should I be assigning the resulting observable to a property and have components subscribe to the property? That makes sense, but what about when I need to update the value? That doesn't work, so I have to assign the result instead of a primitive type property that gets targeted instead. That's two replications already. Then when I inject the service, I'm screwed because I can't just reference this.serviceName.property every time since that seems like terrible practice, I have to assign the injected service variable to a local variable but then updates to the service property don't translate to the now local one. I don't know of a better workflow, but I feel like there must be one and that there's something obvious that I'm missing when working with observables. 
`.share` seems brilliant, thanks for introducing me to it. I still have a problem though with pushing new values to the observable. I'm trying my best to have a single "source of truth" for my data and observables being streams you can subscribe to seem perfect for that, but if I assign the resulting observable from the http request to a property I'm not able to update that value. For example if I'm making a cart service and I want there to be a single property that components could subscribe to and is always up to date, what I would want to do is 1. Assign the http observable to a property 2. Call updateProperty() in the service that updates the property (thereby transferring the changes to its subscribers) and sends a post/put request to the server That doesn't seem possible though, is there something I'm misunderstanding? 
Redux is exactly what I was going to suggest, but you're right: the learning curve is a bit steeper than one might hope (at least it was for me). I still stand by that suggestion, though. I think it's probably the most elegant solution to your problem.
I would suggest that you look to typescript as JavaScript with types. It's there to help making sure variables have the types you want them to have. Almost nothing more. Redux is a nice idea... but I won't suggest someone to take the learning curves of typescript, rx and redux at the same time. It's not worth it. For the architecture problem, I think you need to get the change in world view when you use rx. You're not reading variables from other components anymore (which is similar to polling other components) but you should be subscribing to updates from other components, and then reacting to them. For each component, you should think about which events it should publish/subscribe to. 
Just straight using the TSC compiler. I don't see the need for Babel at all, tsc handles every import/export format available.
Quick suggestion, if you install a package via npm, in an npm script it will append the node modules bin folder so you don't have to put the full path! Just something I noticed reading your example. 
As op mentioned js in their repo, make sure you use your .ignore files (npm and git) properly. For npm publishing, you can ignore the sources if wanted and only ship js which counters the gitignore! 
[ts-node](https://github.com/TypeStrong/ts-node)
So building on the same currency example you could store the value in your service but always return it as an Observable. Also in the `set currency` method you could still send the update to the backend while setting it locally.: .... private currency: string; get currency(): Observable&lt;string&gt; { return this.currency ? this.$user.map(user =&gt; { this.currency = user.currency || this.defaultCurrency }) : Observable.of(this.currency); } set currency(value) { this.currency = currency; } .... 
Though in the example I just posted the currency observable reference will change every time the `get` is called so setting it will not emit a new value in that observable but will return a new observable each time its called. You could probably create a currency `Rx.Subject` and always return that in the `get` instead of a new observable each time and in the set you do something like `currencySubject$.next(this.currency)` or use `BehaviorSubject` like you were before.
I just released it, and am using it to build a project for a rad [data science nonprofit in SF](https://github.com/bayesimpact/tds-frontend). If you'd like to try it out, feedback is welcome!
Okay, the unary part makes sense but why *narrower*? When I extend a class I get all the types defined in the base class, plus an extra ones I define. So shouldn't `K extends keyof T` have *all* of `"id" | "text" | "due"`?
When you extend a class, you are making a narrower (more specific) definition of the underlining concept. For example, `class Orange extends Fruit {}`. `Orange` would always qualify as `Fruit`, but not the other way around. So `K` would qualify for `keyof T`, not the other way around. All possible values of K could be: * `"id" | "text" | "due"` * `"id" | "text"` * `"id" | "due"` * `"text" | "due"` * `"id"` * `"text"` * `"due"` However, `"id" | "text" | "due" | "added"` would not satisfy, because `"added"` is not a valid `keyof T`. Think of union types as "Sets". 
Hrm... but if `Fruit` had a property called `id`, then `Orange` would necessarily have that property too.
[removed]
Those are totally different things. Here's an analogy that might help: * Union type: "I want to have *oranges*, *apples*, or *bananas* for dessert". * Class: "I want to have *fruits* for dessert". When using classes, you are defining/declaring properties and functionalities of the class. When you are using union type, you are providing a list of different possible values. The possible values can be instances, classes, or interfaces. 
How did you get definitions for "chrome" and such?
Not sure why but maybe this works: type ILogStore = { [logType in LogType]: string[]; } 
Chrome type definitions are found in the "@types/chrome" package. The only additional thing you have to do is add ``` "types": [ "chrome" ] ``` in your tsconfig
Thanks!
What you need is the Behaviour Subject * [BehaviourSubject and how to use it](https://blog.angular-university.io/how-to-build-angular2-apps-using-rxjs-observable-data-services-pitfalls-to-avoid/) * ["Real App"](https://github.com/gothinkster/angular-realworld-example-app/blob/master/src/app/shared/services/user.service.ts) * [plnkr](https://embed.plnkr.co/plunk/ErTmmf) 
You can also use built-in Record type: type ILogStore = Record&lt;LogType, string[]&gt;;
That does work! Thanks! Any idea why a type would work here and why an interface would not? Also, it is interesting that an inline type within an interface works. I would have thought it would behave like an interface since it is defined within one.
That is true. I am still curious why it works as a type but not as an interface though.
thanks a bunch
Doing React.Component&lt;any, any&gt; is a terrible waste. If you provide it with interfaces Props and State, you will get type-checking, IDE hints and a form of documentation, actually. But to answer your question: sure, you can even make TypeScript compile your code despite of errors it gives. Just as you, we tried to start with a mild configuration (and gradually work our way into more strict one), but it quickly turned out there is no point of taking such approach. We made it as strict as it can possibly be and loved how much it pays off. I was a sceptic, too, and now I recommend it to anyone I can. It's worth a try.
Me too, if you ever find out why, please share your answer. 🙏
I think I understand now. Thank you for explaining. What I still find kind of strange though is if we have type TodoKeys = "id" | "text" | "due" Then... Well I'm trying to figure out what it means to "extend" a union type. I guess if each of the sub-types is a simple string, then "extending" it basically means it has to be one of those strings, because there isn't much you can add to a string. But if we had: type Foo = {a: string} | {b: number}; Then `{b: 9, c: "cat"}` *would* be an extension of `Foo` because it matches one of the union types, right? 
I personally don't mind typescript, I try to use it as much as possible and not use any, but there's a lot of people on my team that don't want it, and we need to draw a compromise somewhere. People don't want to make an interface for every component props and state they make, especially on HOCs, and I understand their pain. I tried turning off noemiterror true/false and it still doesn't compile on type errors. 
Correct. Also note that * `boolean` = `true | false`. * Enums are basically union of its elements. 
I believe in A you want to define the callback function like this: callback: (this: extends A, But that only raises the question why would you ever need to pass a reference of an instance to itself?
I think you need to hard cast the `callback` in B constructor to `(this: A, value: number) =&gt; void` before calling `super`, since there is no guarantee the passed in callback is valid for A. IANA compiler expert, but I believe the feature you want is called [Class invariant](https://en.wikipedia.org/wiki/Class_invariant), which allows &gt; a descendant class to change the state of instances in a way that made them invalid from the viewpoint of the parent class
**Class invariant** In computer programming, specifically object-oriented programming, a class invariant (or type invariant) is an invariant used to constrain objects of a class. Methods of the class should preserve the invariant. The class invariant constrains the state stored in the object. Class invariants are established during construction and constantly maintained between calls to public methods. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/typescript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Is... is that valid syntax? I get what your code means but I don't know if that is valid TypeScript syntax to have "extends" before the type. And to answer your question, it's passing itself to a function callback, not itself.
Casting kills all type safety. There must be a way to define the types to allow for this without casting.
You can refactor the class to use composition instead of inheritance, which is suggested in the Wikipedia article. 
This version seems to completely break TSServer and the IDE integration. After I updated, YouCompleteMe syntax checking / GetType / etc. all return "Response Timeout". Reverting back to version 2.5.3 fixes these issues.
Well still why pass itself to a callback? Just use bind if the callback function isn't a member that you can define as an arrow function.
I think I didn't read your original post carefully enough ;-) And you are right, typings HOC is painful when you do it for the first time, but when you create a boilerplate for it it becomes much easier. Check this guy's gists for cool examples: https://gist.github.com/mikebridge What are you using for building your project? If you're using Webpack, you can go with awesome-typescript-loader which separates type-checking and compiling (transpileOnly: true).
The compiler itself wont take files that doesn't have the extensions .ts, .js, .tsx, .jsx. And neither would it know how to parse markdown. But you could create a nodejs script that reads your .md file, returns only the lines that are scripts, and passes the text to the [typescript-compiler](https://www.npmjs.com/package/typescript-compiler) module. Then it should be possible add your script to your vscode build task.
&gt; But you could create a nodejs script that reads your .md file, returns only the lines that are scripts, and passes the text to the typescript-compiler module. Then it should be possible add your script to your vscode build task. This would actually be a cool little tool.
You're right, I ended up using a BehaviourSubject, thanks for the help and taking time to post, those resources really helped me understand behavioursubject's. 
This is exactly what I was looking for, I can't thank you enough for the help. I knew that specifying the getter and setter was an option but for whatever reason never seriously considered it, and I had no idea that about `Observable.of()`, thanks so much for the help!
I was in the process of reading up on redux before your post, thanks for the heads up. The little I heard about it made it just seem like an object that stored state and I didn't realize how complex that concept could get, so thanks for saving me a day of studying. I'll definitely pick it up later on, just maybe when my typescript/angular knowledge is more concrete. Thanks again for the help!
You can compile the Readme using a template language that allows including other text files. That way the examples are in .ts and can be type-checked.
Why is the typescript sdk not integrated in the vs 2017 installer? If its because of 'out-of-band' updates, why do older versions show up and not the newer?
Put the TS isn a separate file and use markdown-magic. https://github.com/DavidWells/markdown-magic/blob/master/README.md#-code
I'd say the suggestion by /u/der_flatulator below (using [Markdown Magic](https://github.com/DavidWells/markdown-magic#-code)) is better, since it'll be more error prone to extract code from a Markdown file than to inject it into one.
Fix is on the way https://github.com/Valloric/ycmd/pull/869
I agree. Thanks for the heads up.
Looks like something that could be useful to me.
I wouldn't say sanctuary and ramda promote global functions. They promote keeping data and function separate, so functions can be composed more easily and more generically, but there's not really anything global about it.
[author of prelude.ts here] I probably didn't express myself correctly. How about standalone functions vs methods and a fluent API? But yes you got it right, the dichotomy is separating data &amp; functions or having "classes" mixing both. The former is definitely more FP. The difference is between =&gt; R.filter(R.where(...)) // ramda list.filter(..).sortBy(...) // prelude I agree separating data &amp; functions is good of course. But then, to me, so that the code flows properly, I need a composition operator and currying. Ramda does have automatic currying and proper parameter order. For the operator, I mean for instance |&gt; or "." that some languages have, or $ in haskell. So that's ok with me: list |&gt; R.filter (x =&gt; x.age&gt;=5) |&gt; R.sortBy (x =&gt; x.name) but that's less OK: R.sortBy(x=&gt;x.name, R.filter(x =&gt; x.age=&gt;5, list)) although i didn't actually try ramda but this is probably also valid ramda and that's better: R.sortBy(x=&gt;x.name, R.filter(x =&gt; x.age=&gt;5))(list) since I don't have a composition operator in JS, I do: list .filter(x=&gt;x.age&gt;=5) .sortBy(x=&gt;x.name) I think both approaches have their merit. On the one side there are ramdajs and lodash, on the other there are immutablejs, monetjs, preludets. I picked what I thought was more familiar to most programmers and the syntax that to me bit fits more the limits that the JS language has compared to first-class FP languages. I also followed the lead of the java [vavr library](https://github.com/vavr-io/vavr) which did wonders to our java at work.
That's fair. I just see the word `global` and it always rubs me the wrong way. I quite enjoy ramda, though. It doesn't have the pipe operator (but [may in the future](https://github.com/tc39/proposal-pipeline-operator)), but you can always use `R.pipe`, too. It's a bit more wordy than having a real operator (and I'd prefer a composition operator, to be honest), but it works.
If you want to use TypeScript, probably avoiding Vue is a good thing. Its a great framework but unfortunately they complicated things a lot to make it harder than it should and thats the reason it does not work correctly with TypeScript. Eg. defining components as large literals with "methods", "computed", etc. or automatically injecting vuex stores inside $store var or vuex calling using raw string variables and then using dynamic lookup. Vue components inside .vue files also arent working good in IDEs and its impossible to use awesome-typescript-loader in webpack with .vue files, so you have to stick with worser ts-loader. React went other way and they decided to use just standard javascript features like pure classes with methods/getters or pure functions or redux being in fact just really simple javascript pure functions, nothing fancy. And because of that, React works really great with TypeScript especially with TSX support. Working with Vue in comparison seems lacking "soundness" of code.. You never know if a thing you are working on is statically typed or not. On React however, everything from top to bottom is statically typechecked and everything just feel right, like it should. Thats sad though, because I am Vue fanboy. :(
I have written a number of midsized apps with NG4 and ng-bootstrap. Really love it. Would be nice to have typechecking on templates like react + ts + jsx has, but having a full framework ready to go with NG is great.
I have had a very pleasant experience combining Typescript, React, and MobX. Typescript, you know the benefits of. React components are usually very easy to reason about, and don't require the additional tooling Angular wants- just use a .tsx extension and a typings file and you're good to go. MobX gives you the live-updating Angular offers, but with a more robust approach that intercepts property setters instead of running change-detection and easy caching of computed values. (It doesn't bridge with Promises *quite* as cleanly as RxJS, but it's only been a minor nuisance for me compared to everything else mostly Just Working.)
I'm the author, so take this with a grain of salt. I would use feather-ts.com. it's small, fast, easy to debug and written in typescript. plus it comes with a lot of stuff out of the box. but of course I got no community yet, so maybe it's too risky to try it out from a business point of view. however I use it in my own projects and (naturally) love it. At work I use react/redux and hate how bloated, slow and cumbersome it is, especially passing down all the property clutter. 
Riot.js is amazing! And works fine with typescript. Robust, simplistic and lightweight.
I personally have done a few with React + Redux. I actually find that TypeScript, used properly, cuts down on a lot of the code repetition that you generally find in Redux code.
Aurelia in a heartbeat. It works beautifully with Typescript and gets out of your way. The only thing I don't like is that the tooling isn't powerful enough yet to help out with HTML template binding. That should come with time though.
They can do it with `.js` files, so I assume they could do it with `.tsx` files? You might need to use `--allowJs`, though.
This is exactly what I was looking for for a new project. Perfect timing. Thanks! 
The only real thing you'd have to do would be to rename the file from .jsx to .tsx. Typescript will then flag it for compiling.
It's the same as classes in JavaScript. Perhaps you should go through a tutorial on modern JavaScript first?
You can either just rename the file to .tsx or set `allowJs` to `true` in your `compilerOptions`.
While it’s basically the same idea as classes in JavaScript as of 2015, there are some differences. In TS classes are about defining a function for creating objects while simultaneously declaring the data type of those objects. So when we talk about `class C`, we’re talking about two things: * the function `C` which must be called with the `new` prefix to create an object, and * the type `C` which is the “shape” of the objects that will be created. So the major difference with classes in plain JS is that in TS you have to declare the types of the properties. In JS you can write a constructor: class C { constructor() { this.blah = "whatever"; } } In TS this is wrong because you didn’t say that `C` has a property `blah`. So TS introduced a neat way of declaring properties: class C { blah = "whatever"; } This wasn’t allowed in true JS 2015, but has been working it’s way through standardisation. Anyway, with the second version, TS can safely deduce that an object created with `new C()` will have a property `blah` that is a string.
&gt; doesn’t cover what classes are. This is probably by design, as the concept of classes are very core to programming in general and not typescript specific. Perhaps take a step back and familiarize yourself with how type systems work in object oriented programming and then come back to learning TS. This article/lesson is Java specific, but it should help here also: https://docs.oracle.com/javase/tutorial/java/concepts/class.html
Before understanding what a TypeScript class is, make sure you understand [prototypical inheritance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain), [constructor functions](https://css-tricks.com/understanding-javascript-constructors/), and [typescript interfaces](http://www.typescriptlang.org/docs/handbook/interfaces.html). Once you know those things, go through the Constructor Function section of the [TS Handbook](http://www.typescriptlang.org/docs/handbook/classes.html) which explains exactly what's happening. It's different from Java, Ruby, and other class based languages, so try to look at it with an open mind. To summarize, when you write a class in TypeScript you're creating two things: (1) the type of the objects that are *instances* of that class, and (2) the *constructor function* that generates new objects of that class.
`allowJs`. It's in compiler options.
If you enjoyed our article, follow https://medium.com/gitconnected for more Typescript and React 
Conceptually, classes are about encapsulating mutable state. So rather than directly setting properties of an object, you might instead call methods that update those properties (and any other internal bits that need to be updated as well as a result of that change.) Or rather than reading a property directly, you might use a `get` method that computes the value from some other internal properties. One thing to keep in mind is that you don't often need to use classes in Javascript or Typescript (unless you're using a library that requires them.) There are other, easier ways to encapsulate state (closures) and there are often more elegant ways to manage state than class-style encapsulation. 
While I’d agree in plain JS classes have little to recommend them, in TS it’s different. Suppose I’m writing a simulation/animation with objects moving around. Each sprite has position and velocity, and can be moved somehow: function makeSprite(position, velocity) { function move() { ... } return { position, velocity, move } } In plain JS this pattern only has one problem relative to classes: the methods are duplicated on all sprites. Whereas classes keep their methods on the prototype. But this is only a problem with a large number of objects and methods. In TS, there’s another problem: what is the type returned by `makeSprite`? The compiler figures it out, but does not give it a name. We can hack it by making a dummy instance to get the type from: const dummy = makeSprite(...); type Sprite = typeof dummy; But then we have to come up with dummy arguments. Like I say, a hack. Or we can write a separate `Sprite` interface declaration by hand. A shame when the compiler could do this for us. The answer is to use a class: class Sprite { constructor( public position: Vector, public velocity: Vector ) { } move() { ... // `this.position` etc. } } In one declaration we have the type `Sprite` and the function `new Sprite` to create instances of it. Whenever we add a method now, we don’t need to add it in two places.
I'd agree that a Sprite is actually one of the better candidates for a class because of the prototype optimizations (library code may have more uses for classes.) But I'm finding in most apps I'll have only a handful of instances that need encapsulated state. For things that require hundreds or more instances I think POJOs or arrays are better suited. So needing class optimization is really a non-issue. Like vectors for example - I'm constantly running into interop problems with using different Vector class types between graphics and physics libraries. Had they been simple POJOs this wouldn't be a problem. And IMO they should not be classes because they need no encapsulated state. Regarding the types for closures, I generally do: interface Foo {...} createFoo(): Foo {...} Working with callbacks within a closure is a lot nicer. And they minify a lot better too.
So, what does this get us over using tsc directly?
Completely agree about prototype optimisation being irrelevant to most apps. Re callbacks, `this` is a pain generally. One mitigation is to write class methods as properties initialised by lambda, or use a decorator to implement this-binding.
Haven't read the article, but I do use Webpack with TS. My reasons for this are mainly that it allows hot reloading and using CSS modules.
You just write your code in your editor of choice and it gets autocompiled and the page is reloaded automatically.
After using grunt, gulp, and ultimately resorting to NPM for building my projects I spent a bit of time creating the task runner I've wanted. It has the same idea of a task name with a command as an npm script, but you can build out task dependencies, check inputs for skipping up to date tasks, easily parallelize execution, and is 100% Typescript friendly. Any feedback would be welcome!
Dependencies may bundle their types in their own npm module or have them separate, in `@types`. If you find that any given import lacks typings, you'd better check to see whether DefinitelyTyped provides any. I usually install DefinitelyTyped typings blindly and see if they exist, for any given dependency that I import; tends to save a lot of time and headaches.
Minimal should not need webpack plugins
Hot reloading and CSS modules are pretty sweet.
Ah ok. I was wondering if some npm modules came with their own types. 
Yeah, it's very confusing. The clue is that DefinitelyTyped tell you not to contribute if you have the option of bundling the types into the given module.
Yep, at that point however why not just use a closure? :)
I use 'yarn info @types/...' to see if the package exists or check the repo. Npm I think is the same command
Cool! Did you ever explore NPS? I recently wrote about it here: https://mikecann.co.uk/tooling/node-package-scripts/
I hadn’t seen that, it’s definitely an improvement over npm scripts. The big things I wanted were a real task dependency graph and easier parallelization (was using npm-rub-all before). This casker was born and even includes up to date checking. 
I haven't tested this myself yet, but you could also try [tadd](https://www.npmjs.com/package/tadd)
No need to be minimalist about this. The "maximalist" version is super easy to use and everything just works. https://github.com/wmonk/create-react-app-typescript I used this to start my latest project and it is *awesome*. Webpack, TS, TSLint, unit testing (`npm test`), dev server (`npm start`), source maps, minifying to a production build (`npm build`), everything ready to go, and all the details are tucked away in `node_modules` where they can be bug-fixed for me.
Some do, some don't. If they are written in TypeScript the types are usually included in the module and you don't need to use @types/*.
Nice, I wish it allowed using string enums for the index part of objects {[index:MyEnum]:string}
Additionally, you can accept and assign instance variables if you give them an access modifier. For example these two code blocks are essentially the same in TypeScript: ``` class MyCoolClass { constructor(foo: string) { this.foo = foo } } ``` ``` class MyCoolClass { constructor(public foo: string) { } } ``` In both cases, you can do this: ``` const myObject = new MyClass("bar") console.log(myObject.foo) // will be "bar" ```
I don't understand, is this not already checked by the normal type checker?
Yes, you just need to enable noImplicitAny to catch this! Try setting the option in [this playground](http://www.typescriptlang.org/play/#src=const%20a%20%3D%20%5B1%5D%0D%0Aa%5B%22foo%22%5D%20%3D%203%0D%0A%0D%0Aconsole.log(JSON.stringify(a\)\))
[removed]
Hmm that's weird, I asked on StackOverflow if there's a way to disallow setting array properties, and I didn't get any answers in 3 months, so I figured it isn't possible. [Link](https://stackoverflow.com/questions/45500142/disallowing-setting-array-properties-with-tslint) I don't currently have the possibility to configure `noImplicitAny: true` though, so I guess that makes my rule not completely obsolete haha.
You should add noImplicitAny to your answer on stackoverflow for anyone else finding it. But yeah, it's a pretty invasive setting, probably noone answered because most people have set it to true already I think 
I think you mean JavaScript not Java. All JavaScript is valid typescript. Generally speaking I'd learn the subset (JavaScript) before moving on. There's far more on JavaScript than typsescript. Once comftorable and proficient with JavaScript then I'd move on to typsescript. Which is a superset of JavaScript.
Here are prerequisites (in order): Java, Haskell, and Cantonese.
You'll definitely want to learn the fundamentals of JS, mostly because you'll understand why TS is an improvement on vanilla JS. Plus, you'll need to understand the JS ecosystem to be effective with TS.
[code academy](https://www.codecademy.com) is good for beginners, do the JavaScript tutorials. Then you can google “learn TypeScript” and go from there. 
Definitely learning JavaScript first is a very important step. Even a basic understanding is a good start. If possible, it's best to use never resources teaching ES6. JavaScript underwent a major revision recently, and learning some of the new syntax will be helpful for writing modern TypeScript. If you find a tutorial that mentions Babel, that's usually good. Just note that in the future, you'll be using the TypeScript computer instead of Babel to validate and transform your code that uses newer features into JavaScript files that can be better understood by older browsers/Node versions. Good luck! It's a great dev environment.
I'd use a good IDE that gives you real-time feedback on what's wrong with your code. It's way easier to correct stuff than waiting for a compiler to spit out a bunch of gibberish. Webstorm or Visual Studio are both excellent.
Many people really don't like webpack configuration. Hence, "minimalistic", "simple" and "easy" are good buzzwords, if you want to advertise your starter kit. And I can understand that. I feel like I wasted years of my life configuring tools (from Grunt to Gulp &amp; webpack... and back again). Recently I discovered Encore, and I love it. It's basically just a Webpack wrapper, but it makes everything so damn easy. Here's the link, if anyone's interested: https://symfony.com/doc/current/frontend.html
Personally I skipped grunt/gulp as they seemed obviously without any purpose. The tool I linked to, you literally run the one-liner command to create your app and it’s all taken care of. You needn’t even be aware of webpack.
You might be able to identify the problem by working in a new folder, running `npm init -y` and `tsc --init`and then installing only some of the types and running `tsc` to see what combinations cause problems.
[mp4 link](https://g.redditmedia.com/r1DGJKh-094qjxdFrOqadOBu9KsYiCfO3KO2-xSfqkA.gif?fm=mp4&amp;mp4-fragmented=false&amp;s=e4b9e9306ff8a1a86b6cfc742595ead2) --- This mp4 version is 75.33% smaller than the gif (892.84 KB vs 3.53 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
Thanks, looks like a good starting point to learn how to create typescript libraries and how to configure webpack :) However while it's easy to find, some links about the utility would be welcome. * NPM: https://www.npmjs.com/package/create-ts-lib * Github: https://github.com/emyann/typescript-webpack-starter
Any reason you're using webpack to run your unit tests?
&gt;Should I migrate the build system to Webpack? What can I really gain with the change for such a small project? Probably not. If you don't have a specific need for webpack, don't use it. &gt; I found myself sometimes fighting with the type system and Typescript limitations, am I doing some obvious/newbie mistakes? Almost certainly. The type system is your friend. Hard to say what's going on without any specific issue you ran into though. &gt; Should I stick with the Typescript compiler or change to Babel? I had to replace property accessors with function getters, can Babel support property accesors and still build for ES3? See my first answer. Also, why support ES3?
&gt; Almost certainly. The type system is your friend. Hard to say what's going on without any specific issue you ran into though. I've run into [this issue](https://github.com/Microsoft/TypeScript-wiki/blob/77a2a18a6e7bf8599bbe693243b1b9eb3044bfda/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work) when trying to subclass the native type `Uint8Array` to make it immutable (among other things). Now I'm using the interface [`ByteArray`](https://github.com/Terseus/tsipaddr/blob/master/src/arrays.ts#L7) but still it feels limited, e.g. I can't create `ByteArray` instances, I have to use its backing type [`Uint8Array`](https://github.com/Terseus/tsipaddr/blob/master/src/arrays.ts#L62) for that, therefore I cannot fully generalize the `ByteArray` type. OTOH, is there any way to use `this.constructor` in an abstract class without using [the "as any" trick](https://github.com/Terseus/tsipaddr/blob/master/src/address.ts#L107)? Feels like cheating the type system. &gt; See my first answer. Also, why support ES3? Just to have more compatibility, still not everyone/everything supports ES5/ES6.
Thanks you!! 🙏🏽
Re: subclassing native things. That's a pretty common anti-pattern in a lot of typed languages. Native data types have access to more language internal fiddly bits and subclassing them often messed with these internal interactions in subtle ways. Seems TS is no different here. Perhaps consider composition over inheritance, something like (I don't know if this compiles, but it might be a good place to start): class ByteArray&lt;T&gt; { constructor() { this._underlying = new UInt8Array&lt;T&gt;(); } get readonly [i: int]: T { return this._underlying[i] } } &gt; OTOH, is there any way to use this.constructor in an abstract class An abstract method that instantiates an instance is sort of weird. The whole point of abstract methods is that they operate at a class level, not an instance level. Why does `add` need to be abstract? (i.e. `new Address().add(foo)` instead)
All the popular testing frameworks have TS type definitions so you can write your tests in TS with any of them.
You can....but you need `ts-node` in order to execute/interpret the TypeScript on the fly.
Not necessarily; `ts-node` can be used on runners that don’t have their own hook for transpiling on the fly. But many do. Jest is an example, there is even a `ts-jest` that takes care of the details.
Anyone using a TypeScript library is probably safely assumed to know how to do their own transpilation.
[removed]
&gt;Not necessarily; ts-node can be used on runners that don’t have their own hook for transpiling on the fly. Yeah - so I use mine with mocha to run my mocha tests. &gt;But many do. Jest is an example, there is even a ts-jest that takes care of the details. This I did not know...that's very cool.
I were trying to avoid composition in this case to not having to add lots of boilerplate code to create the methods in `ByteArray` that already exists in the underlying type `Uint8Array`, but maybe you're right and it's the best option; indeed with it I'm not going to have those problems anymore. &gt; An abstract method that instantiates an instance is sort of weird. Maybe I should create an abstract method to be used as a constructor that child classes must implement with its concrete type. Thank you a lot, that's why I love to show the code to others :) specially when it's in a language I'm not familar with.
The error seems clear to me and it would help if you removed the first two declarations because the error only applies to the last one. The error is saying that your declaration can only export names, so you need to do something like: declare module "*.styl" { class styl { [index: string]: string } const obj: styl; export default obj; }
It takes quite a lot of gymnastics to get typescript/strong-typing support for a VueJS project, so I thought I would share a repo I made with the minimum to get going. If you use this, with VSCode and the Vetur extension [1] you get typing-support everywhere including your .VUE files. Enjoy [1] https://github.com/vuejs/vetur
I just gave this a watch-through. It's well put together, and touches on some helpful subtleties of the type system. The part on transformation types, in particular, was new to me, and very helpful. Thanks for publishing this. I've already shared it with a few friends.
Glad you enjoyed it, and thanks for sharing!
Thanks for your effort! I'm excited to check this out.
Usually it means that dependencies went out of sync and some of them require an update. If it's 3rd party code and it works, but TypeScript doesn't let you compile your project, you can suppress the error by setting `"skipLibCheck": true` in your `tsconfig.json`.
Not a lot of people know this but if you have ts-node as a dev dependency, you can actually use typescript for your webpack configs. Webpack will use ts-node if the config file ends in .ts.
Well that's kinda cool.
Unfortunately what you're asking for is not possible in Javascript/Typescript. The method signature `[index: number]: T` cannot be implemented, it just serves as a type hint for Typescript, therefore you cannot implement an array that backs its data onto another array member of itself, like you can do e.g. in Python with `__getitem__`.
Finally! I've been searching for something like this (with vue 2.5). Will give it a try 
Yes I️ added a follow up edit about that right after I️ posted. 
Just a simple utility to organise reducers as classes. FIts well with ngrx. React users would hate it.
I'm probably missing something, but there's not a single type declaration in the example. So where is the type safety happening?
Very cool! Been wanting to tinker with building something just like this for a bit. One bit of code review: This line https://github.com/Gbuomprisco/typed-reducer/blob/master/index.ts#L17 assumes that every non-constructor method is an Action, which isn't necessarily true and would consequently throw on error later on if a method was not decorated with @Action (because the metadata wouldn't have a type). Perhaps a more robust approach would be to mark the method's metadata with something like `action = true` and then the filter would be something like `method.action === true`.
Hi! Thanks for the review, I'll add that soon! :)
Np, hope you don't mind the unsolicited review. If I weren't so lazy I'd just code it up and open a PR. Maybe tomorrow if you don't get to it :)
&gt; app state is a stream from a fold over an initial state + input actions stream, by a reducer function. I like the way you described this, kind of made a lightbulb go off in my head. Thanks! Would you say [rgrx/store](https://github.com/ngrx/store) is best illustration of that?
Why? What's the benefit and what problem are you solving by using classes over just basic functions like it's done in basic redux? I take the encouragement of using pure functions as a good thing, it's simpler to maintain and test. With classes, you can quickly introduce some internal, instance-specific state which is difficult to reproduce and you lose the main benefit of what redux was trying to solve. And if you avoid that, what you're left with is a glorified object-to-action map. This can be achieved with a simple object literal. In our project, we're using [Enhanced object literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015), where you can define the object key with a variable. The variables are action names, which are exported in action file and used as `type` value. All that there's left is a few lines of boilerplate to get the correct reducer function based on action: const reducers = { [ACTION_TYPE]: (state, action) =&gt; { return [ ...state, nextAction: action.payload, ]; } } // the "boilerplate" export default function reducer(state = initialState, action = {}) { const fn = groups[action.type]; return fn ? fn(state, action) : state; } This code is fairly simple, it gets the function based on action type and calls it with the state and action or returns the previous state if the action is not found. I see it as a switch statement, but with a prettier syntax, although your opinion might differ. 
Hi! Thanks for the feedback! I like your approach and I find indeed quite simple. What I proposed here is not a better way, it's just another way of doing it. I also think that a method can be a pure function, and a function may be not pure (ex. it uses global state), so as long as the developer is knowledgeable about how that works, there is no risk of having state issues. The main aim of this is to strong type actions and payloads for our reducers. In this way I do not have to specify the correct type and just need to be careful to dispatch the correct action. No union types, no casting :) Can you paste an example with strongly-typed actions/payloads? It would be interesting to see your approach to that!
I haven't used TypeScript for a long time so I don't have an example for this. But I don't see how this might be different if it's a function or a class method. 
Static types are inferred from the "runtime types" you define for validation. In the example, here is the Body runtime type: https://github.com/OliverJAsh/express-fp/blob/0d7b13e2ace63f5c0a2bdcb658182df953a7aebd/src/example.ts#L16 After validating the request body against this runtime type, we get back an Either. When mapping over the either, the mapped value will have the correct static type: `{ name: string }`. We don't have to repeat the type interface. This magic is done via io-ts: https://github.com/gcanti/io-ts.
Is there a way to combine all the parameters in a query into a single validation? It would be nice to be able to specify the query type as an interface like ```Body```.
Good question! You can collect the query parameters, chain the Options to create a object, and then validate that using io-ts. I created an example for you here: https://github.com/OliverJAsh/express-fp/blob/89bb6747833d5eba4264847a0571b367afd32e00/src/example.ts#L21 This might be something we can make easier in the future. At the moment I'm pretty much copying the Play framework in Scala does. Open to any ideas. :-)
Nice! That's a good idea! Thanks for the tip, I will setup that for sure!
The thing that introduced me to TS five years ago was Anders’ original announcement video: https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript It’s still an excellent intro, demo and justification for why it exists. At that stage there were no generics in the language, but that was addressed soon after, so ignore anything in the video about that. Also amusing at this distance to look back at the comment-gore underneath... So many dumb people.
I've been surprised by how many of your day to day packages you'd use in your Webpack config have type definitions available.
Unfortunately, whenever you want to have more features than just javascript bundling, like unit tests(13 packages) or css bundling, your number of packages could drastically grow :/ https://i.redd.it/tfugj4n3l6ez.png Definitely, I plan to add some options to the CLI in order to provide multiple use cases that cover a broad set of configurations from minimal to all-features
Sounds like you'd want to write a generator of some sort...unless webpack can do that by default
Start with a hello world using a simple transpiler setup. Then build from there. Are you using node? If so, you can built a little TypeScript program and execute on node (treat it like a console app in C#). Demo some TypeScript features like classes, type safety, etc. If not using node, you can demo it via a browser. Just create minimal amount of HTML to display the TypeScript output (like a console app). If the JS devs are front-end devs using front-end frameworks, split the sessions in 2, and demo angular (or any other front-end framework) with TypeScript. Angular is a nice choice since the angular tutorials are in TypeScript. 
It may sounds like that but I don't want to end up with a yeoman-ish CLI :) Just want to keep it as simple as `create-react-app`is actually, by externalizing those configurations/templates into tiny scripts, and address one purpose: Accelerate your Typescript module building flow. 
&gt; I don't want to end up with a yeoman-ish CLI Not familiar with yoman - why would that be a bad thing?
In addition to what /u/PassItOnBro wrote - you could use the [TypeScript Playground](https://www.typescriptlang.org/play/index.html) to demo some stuff, especially to the JS crowd - to show them that the additional TS code doesn't always result in runtime code, which means no performance hit etc., but at the same time - show them how the compiler protects you from mistakes. Something like `strictNullChecks` should make this point obvious, since it has no runtime implications, but catches ***a lot*** of compile-time errors.
I think the Elm language is the best example of that. That's where it first clicked for me. But you can also do it in plain js or ts with a virtual dom library and an frp library, e.g: https://github.com/twfarland/sprezzatura-acto-mario/blob/master/src/app.ts
Is there a specific reason why you want people to *have* to supply the type parameter? If ```Foo``` is as generic as its type says, then I don't see a problem with the third line. Are there some extra requirements you have? Maybe this would help give a better solution. I'm afraid I don't know how to answer your problem in a satisfactory way. I think it could probably done using a type level dictionary with a ```never``` option for the case when a type parameter is omitted. Another solution would be to make the user have to supply a witness value; TypeScript might be able to do type inference, but it can't do value inference. ``` interface Data { prop1: string; } // Value witness const Data: Data = undefined as any; declare function Foo&lt;Shape, T extends Shape&gt;(_: Shape, data: T): void Foo(Data, { prop1: "str" }); // fine Foo(Data, { someProp: 1 }); // error, someProp does not match Shape Foo({ someProp: 1 }); // Missing first argument. ``` 
It seems pretty obvious that one version is defining zip as a property and the other is defining it as a function. You'd need to change how it's defined in one of those two so the type isn't incompatible.
Thanks! This was more-or-less what I meant. I'm afraid I'm not familiar with the Play framework. I was just wondering in the case where you write: const maybeQueryParams = req.query .get('age') .chain(age =&gt; req.query.get('gender').map(gender =&gt; ({ age, gender }))); This seems like the 'default' behavior someone would want; just try get all the properties out and if any fail, return None/Nothing. Is there a way to offer that function without the user having to write the query? So if your parameters are some interface type ```T```, then a request comes in as a sort-of mapped type with every property optional: ```Mapped_Option&lt;T&gt;```. Then have a function that goes from ```Mapped_Option&lt;T&gt; =&gt; Option&lt;T&gt;```. 
Why not use an editor like Visual Studio Code. It's all in there and you don't have to configure anything.
`req.query` has type `Map&lt;string, string | string[]&gt;`. We can write a function that allows us to collect keys from this map onto an object: const collectQueryParams = &lt;Key extends string&gt;(keys: Key[], query: SafeRequest['query']) =&gt; keys.reduce&lt;Partial&lt;Record&lt;Key, string | string[] | undefined&gt;&gt;&gt;( (acc, key) =&gt; ({ ...acc, [key]: query.get(key).getOrElseValue(undefined), }), {}, ); We can pass the resulting object through to io-ts, which returns an `Either`, containing either validation errors or the validated object. If we dont' care about the error details, we can convert this to an Option with `Either.toOption()`. Example: https://github.com/OliverJAsh/express-fp/blob/f125bca4af80e36a574dcc3217bfb1ae42c579ef/src/example.ts#L34 Is this closer to what you're asking for? It's hard to know what the default behaviour should be—I think that will become clear with time, as more people try to use it. My goal at the moment is to provide a flexible enough API to make all use cases possible.
For C# developers familiar with dependency injection with Ninject, https://github.com/inversify/InversifyJS will be very familiar and many of the elements in the API https://github.com/inversify/inversify-express-utils will be familiar for ASP.net developers.
Functions are just properties declared on the object. ?? Anyhow apparently there is a difference between, aggregate: { (func: (x: TSource, y: TSource) =&gt; TSource): TSource, &lt;TAccumulate&gt;(seed: TAccumulate, func: (x: TAccumulate, y: TSource) =&gt; TAccumulate): TAccumulate, &lt;TAccumulate, TResult&gt;( seed: TAccumulate, func: (x: TAccumulate, y: TSource) =&gt; TAccumulate, resultSelector: (x: TAccumulate) =&gt; TResult): TResult, } and aggregate(func: (x: TSource, y: TSource) =&gt; TSource): TSource, aggregate&lt;TAccumulate&gt;(seed: TAccumulate, func: (x: TAccumulate, y: TSource) =&gt; TAccumulate): TAccumulate, aggregate&lt;TAccumulate, TResult&gt;( seed: TAccumulate, func: (x: TAccumulate, y: TSource) =&gt; TAccumulate, resultSelector: (x: TAccumulate) =&gt; TResult): TResult, to the compiler. I think this does the trick. 
Properties are class variables. Methods are class functions.
Have you ever found a good solution for this? Would be interesting to me as well.
It's not a great solution, but I wrote this script which was good enough: https://gist.github.com/tscholl2/ca88a1e7ea4d067d7c684c55b019b2c7
It's kind of nice, especially syntax, but it's a performance hit, and standard switch on tagged union types is good enough.
It's not really meant to be used when classic switch can be used. Lately I needed a deep matching on several cases (e.g. pairs - combinations of two things like [Enum1, Enum2]) and classic switch can't handle that. I know it can be done by e.g. Ramda, but the syntax is a bit less concise and I am afraid there will be issues with typings (Ramda typings has a lot of "any"). My library aims to be typed as much as possible with clear API and TypeScript-first (typings are packed with the source code, so they will always match currently used version of the library).
Interesting - what's your use case? I've never encountered the need for deep matching in a case/switch statement in the wild (not just in JS, but also in FP languages).
I especially like its use as an expression. 
do you use internet explorer as your daily browser?
Jesus the amount of nonsens over a fucking icon is un-be-liev-able
How do I get the orange icon back?
RIP orange icon.
Have an internet tantrum
I really couldn't care less what colour the icon is as long as it's consistent. After getting used to the orange icon, it took me way too long yesterday to locate my windows in the taskbar as I wasn't expecting it to be blue again...
Go here and click fork... :) https://github.com/Microsoft/vscode Disclaimer: Am MS employee, not on this team or anything related.
Impressive
Then why even mention you're an MS employee? Lol. 
So when is Closure going to accept typescript or ts sourcemaps as input? JSDoc is terrible. 
With [tsickle](https://github.com/angular/tsickle), you can (kinda) have the best of both worlds. It converts TS to Closure-acceptable JS, so it can then be minified properly by Closure.
first people complaining about orange icon. Then people complaining about the come back of blue icon. Then people complaining about people complaining about the icon :D
i haven't used it but maybe [tslint](https://github.com/palantir/tslint) has something for this?
hmm, so eslint has `no-implicit-coercion`, but it seems an equivalent does not exist for tslint.
The npm package [tslint-eslint-rules] (https://www.npmjs.com/package/tslint-eslint-rules) includes this rule and I *think* will do roughly what you're looking for. 
hey I really like the 'match' idea :-) stole it for my library: https://github.com/emmanueltouzery/prelude.ts http://emmanueltouzery.github.io/prelude.ts/apidoc/classes/option.html#match http://emmanueltouzery.github.io/prelude.ts/apidoc/classes/either.html#match -- Nice about the do notation but it may be a little too much for me for now.
i don't think you can do it for NaN. there would need to be a number type that doesn't include NaN
I looked at that but I think the red x means they didn’t implement this particular rule 
[removed]
This is how I'd approach it: https://jsfiddle.net/pagalvin/vk2c07c0/6/ And if that doesn't work for you, I pasted in the code. It's verbose, but that's my personal style. It could be optimized a bit no doubt. const someData = [ { userId: 1, userEmail: 'user1@email.com', postId: 1, postBody: `User 1's first post`, }, { userId: 1, userEmail: 'user1@email.com', postId: 2, postBody: 'User 1\'s second post', }, { userId: 2, userEmail: 'user2@email.com', postId: 3, postBody: 'User 2\'s first post', }, ]; interface userPost { userId: number; userEmail: string; postId: number; postBody: string; } interface post { postId: number; postBody: string; } interface postsByUser { userId: number, userEmail: string; posts: post[]; } interface allPostsByUser { data: postsByUser[]; } const result = someData.reduce((transformedResult: allPostsByUser, currentUserPost: userPost) =&gt; { const userRecordDoesExist = (forUserId: number): boolean =&gt; { return transformedResult.data ? transformedResult.data.filter( (aUserRecord) =&gt; { return aUserRecord.userId === forUserId;}).length &gt; 0: false }; if (! userRecordDoesExist(currentUserPost.userId)) { transformedResult.data = transformedResult.data.concat(&lt;postsByUser&gt; { userId: currentUserPost.userId, userEmail: currentUserPost.userEmail, posts: [] }) } const mappedResult = transformedResult.data.map( (aUserPost) =&gt; { if (aUserPost.userId === currentUserPost.userId) { return &lt;postsByUser&gt;{ userId: currentUserPost.userId, userEmail: currentUserPost.userEmail, posts: aUserPost.posts.concat(&lt;post&gt;{postId: currentUserPost.postId, postBody: currentUserPost.postBody}) } } else { return aUserPost; } }) return {data: mappedResult}; }, &lt;allPostsByUser&gt;{data: []}); console.log(result); 
I think I misread your question. I think the code I pasted could be generalized for what you want, but it's not on target. Sorry!
You are correct. I use this package in many repos, however the `no-implicit-coercion` rule is not yet implemented. Though like yourself I wish it was, as you identified a nice potential error the compiler or linter could catch.
[TSLint has one](https://palantir.github.io/tslint/rules/strict-boolean-expressions/), but it's limited to boolean expressions.
You should be excluding your `node_modules` folder entirely. If you are, that's likely why it's emitting `can not find module`.
You probably want something like this (using `lodash`): _(values) .groupBy(x =&gt; x.userId) .reduce((arr, group, key) =&gt; { arr.push({ userId: key, userEmail: _.first(group).userEmail, posts: group.map(g =&gt; { return { postId: g.postId, postBody: g.postBody } }) }) return arr }, []) If you want to make it dynamic for multiple data sources, wrap around the pieces that need to change (mappers for children / parent, group key selector, etc).
this seems to work: const map = &lt;T&gt; (arr: T[]) =&gt; &lt;U&gt; (fn: (value: T) =&gt; U) =&gt; arr.reduce((total, curr) =&gt; { total.push(fn(curr)); return total; }, &lt;U[]&gt; []); const mapped = map(["1", "2", "3"])(Number); console.log(mapped); generic arrow functions need parens around the argument list i fixed your use of `Array.prototype.push` since it returns the item pushed, not the array the cast in reduce also seems to be needed
This looks like what I need. :) Thank you. Sounds like the only work left is to make those wrappers so that I can specify keys on arbitrary arrays.
Brilliant! Thanks
No problem. I received a number of useful responses so I'm going to take another stab at a generalized function soon.
What do you use for CSS usually?
I stole it from a Java tutorial on Optionals ;) Also, I can't see a straightforward way to package the "do" notation in a library without higher kinded types. It may be possible using some weird type trickery (wrapping all monads in a HKT&lt;M, V, T&gt; type or something) but it's not elegant.
I normally put the generic argument to reduce at the start i.e. arr.reduce&lt;U[]&gt;((total, curr) =&gt; { total.push(fn(curr)); return total; }, []); As I think it's more readable; but to each their own..
thanks, i might just use that in the future
No readme?
https://github.com/Microsoft/TypeScript/issues/13267
&gt; We waited and waited. And the issues never came. The combination of unit tests, manual testing, and a new, very robust type system bought us a TypeScript migration with zero customer-facing issues. ... And they all lived happily ever after.
https://github.com/k1r0s/preact-stylesheet-decorator
todo haha
I truly couldn't agree more. I will never write anything of substance in vanilla javascript again.
I went back to using JavaScript (React) after using Typescript (Angular). I actually really miss the typing!
[removed]
TS works great with React, even compiles JSX itself
This is how I feel after using Rust.
Company I work for used Angular (2+) to build an application and along with it came Typescript, personally I find it awful to code anything without type safety after that; I used to use Dart and Typescript for me is incredibly similar. I really like it, there are a couple of things missing which to make an example of one would be getting the return type of a function (Incredibly difficult to code though and is currently undergoing code review in TS). Unfortunately I was moved on to another project and right now we are using Preact, whilst it is possible to use Typescript and Preact together is a massive pain in the arse. The definitions are wrong and a lot of the libraries are not maintained making it impossible to work effectively with it. I managed to get everyone to agree to use typescript with it but only a day later switch back because how terrible the work flow was. I'd love to continue using it but right now its not possiblke.
Isn't Preact just a drop in replacement for React? How come the types are so different. 
Kinda, its a watered down version of React (with a compatibility layer to make it 99% feature parity). Realistically it shouldnt be different and Im fairly certain they copied the typings. I think they are just out of date. It currently is so broken it fails to compile if you dont have a 'ref', 'context' and 'props' property on the component (which it really shouldnt require.) plus it requires that any JSX component that you provide have some form of HTML attribute on it otherwise it will complain that it doesnt have anything in common with the interface it provides.
Had to switch back briefly for a project, and at the time, My cofounders were not ready to hire TypeScript developers (difficulty finding candidates and salary considerations in the future). So I was forced to work with plain JavaScript and Meteor. It’s all over now though. I retired from the project. Now they’re back to PHP and I’m building my own [CMS](https://dev.to/voodooattack/cloudpresspart-1-how-to-reinvent-a-better-wheel-bo2) in TypeScript. Everyone is happy.
It is frankly impossible to understand why you aren't using TypeScript with React! It's the perfect combination.
[removed]
Your cofounders' attitude was a little strange - TS's whole deal is that it is an extension to JS that you can introduce gradually, so a team can learn it as they go. I've introduced it recently to my team and even the most skeptical person has to admit it's very cool when he wants to use a new library and gets autocompletion that teaches him how to use it correctly.
I tend to prototype things in JavaScript, then re-write them in TypeScript for production. Still do some small stuff with vanilla JS.
That’s true, but you have to know that one of them is not technically inclined and the other’s background is PHP development. They argued that they couldn’t fathom bringing in JavaScript developers just to train them in TypeScript (in addition to the typical orientation required for a huge codebase). I don’t fault them for their logic. I just wish I didn’t listen at the time. The project would have been usable by now in the time it took me to rewrite it again from scratch in Meteor/Vulcan.js. Had the project been completed in TypeScript, we would have had all the time in the world to train our own people.
I've had no issues with Preact and Typescript, using the current version of both.
Weird, Typescript 2.6? Everything works out of the box? Can you give an example of a component that works? Right now for me, no matter what it is creating hundreds of errors so if you can point me in the right direction that'd be great...
Not just the writing.. the maintenance cost of dynamically typed codebases is much greater because of lower velocity due to fragile refactoring and runtime bugs. Too bad there haven't been any definitive studies on this but I'd be gobsmacked if it wasn't true.
Or the cost of writing and maintaining excessive brittle unit tests to cover the fact that there is no typing. I feel like 90% of unit tests I've seen in most Javascript code bases are testing things that would just be caught automatically by the compiler if using Typescript. 
My current project at work is on TypeScript 2.4, I tried upgrading to 2.6 and have lots of errors to fix. So I just setup a new project, using similar webpack config (cut some plugins) with latest TypeScript &amp; Preact and had no issues. I haven't had the chance to try upgrading the work project yet. Maybe something to look into over the holiday weekend.
It looks like if I disable `strictFunctionTypes` a lot of the errors go away and left with 2. Which were not related to Preact at all but the way types are inferred on object literals.
The only places I use JS now are around build tools (webpack, gulp etc) and quick little prototype scripts. TypeScript ftw everywhere else.
I prefer Javascript, only real bonus that typescript has for me is that VSCode actually picks up types with it. (It sucks as finding out what the types of something are in Vanilla JS)
As Java developer nothing more natural than TS. It's not only about VSCode autocompletion or refactoring, there's much more to it. Take a look at my blog post about typescript and some stuff around it http://paulosuzart.github.io/blog/2017/10/04/type-safety-orm-and-dependency-injection-node/
Absolutely. I haven't converted our e2e tests into typescript yet and it's such a slog having to console log things just to see their APIs. Yeah yeah I know. Docs. But sometimes things don't work as advertised but you still need to deal with it.
I'm a freelancer, so I don't always get a choice :(
I fault them for their logic -- any JavaScript developer that can't figure out how to work in Typescript on the fly is a shit JavaScript developer. The ROI on switching to TS really is phenomenal -- it saves so much goddamn time, and it really is almost nothing to switch.
Yeah like others here I'll chime in and say react and typescript are awesome together! Although I still haven't got generic components to my satisfaction.. 
Exactly this. We have been rewriting mission-critical parts of our codebase into TypeScript and man, I can't count the amount of tests we could just throw away because they didn'tvaooky any longer
If you're feeling this way, you might also like [Elm](http://elm-lang.org/). It has a different syntax but even more type safety and the different syntax makes a lot of sense with the types.
[removed]
I heard this point of view couple of times and frankly it makes me baffled. When I prototype, I usually start with TypeScript. So I define interfaces and types first and then I extensively use tagged union type s, inheritance (if I need it) and so on. And rename! After all, it works and I use it a lot on prototype phase.
I would say it takes time to learn static typing for the first time. It would take longer to do so in addition to a new language paradigm like object orientation. If you are hiring people who know neither it would be reasonable to pick only one to use. Personally, I would bite the bullet and hire more experienced candidates.
I am so glad to see posts like this one. I have used C# extensively throughout my career and when I moved into web development TS was still in beta. I remember how the veteran JS guys could not relate to my confusion and frustration with JS and the poor tooling around it. So it's really good to see JS guys actually starting to "see the light" on the benefits of types.
That's one thing I still find a little frustrating. Many build tools back in the day added native coffeescript support so you could write your build scripts/tools/etc with CoffeeScript instead of vanilla js. I had really hoped the same would have happened with typescript by now, where we could avoid vanilla js even in such cases by now.
Here's a nice paper that actually quantifies the benefits of a typed system:http://ttendency.cs.ucl.ac.uk/projects/type_study/documents/type_study.pdf
On the opposite end of the spectrum... ES6 is standardized in Node, but have you ever looked at any of the source code behind any random npm module? It’s god awful. No one even uses classes, which is the most basic concept you could possibly incorporate. JS devs don’t even know how to use the tools they already have available. JavaScript is the new PHP. Anyone can write it and it shows. I would say the cofounder’s attitude is completely understandable, in its flawed inverse way. My current company has the same problem. No babel, no flow, no typescript because no one understands it. They don’t even know enough to realize that 99% of it is ES6 native, they think using a class or a static method is “non-native”.
couldnt agree more. I just started working with TypeScripts a few weeks ago. The initial coding might take a few extra lines but the final code has a much lower probability of bugs. 
Babel is getting TS support soon so it may happen.
I certainly wouldn’t judge ES6 JS code on whether it uses classes. They are pretty pointless in most cases. In TS they have a purpose: combining declaration of data type and implementation.
I disagree. They do the same in ES6. You’re not exporting some anonymous object, you’re exporting a specific class. Webstorm even recognizes that and lets you navigate directly to a member. Using TS would certainly be better, but there are native language constructs available to make your code better now and no one uses them. 
Some tools, like Webpack, allow the configuration to be defined in TypeScript (amongst others). This is achieved by leveraging node-interpret[0]. See the docs[1] for more detail. [0]: https://www.npmjs.com/package/interpret [1]: https://webpack.js.org/configuration/configuration-languages/
wait, so google is writing their own TS compiler instead of contributing to microsoft's open source repo?
A lot of what I code hits weird edge cases by design, and needs to support ancient browsers. It's easier for me to debug that with vanilla JavaScript.
This seems pretty interesting but I find some of categorization hard to follow. On the one hand the author writes: &gt;You can think of the TypeScript compiler as a linter for the language spec. yet they also write: &gt; Our compiler flagged this as a type-check error: when describing a perfectly type safe expression. I definitely see the value in adding rules to reject what someone might call 'code smells', but the distinction between linter/compiler feels slightly forced. Maybe I'm missing something and just need to see some more example rules and it will become obvious to me.
We need rust for the browser
No, this new tool uses the compiler's plugin API to operate. It works with the existing compiler. It's similar to ErrorProne for Java; an optional set of extra checks that runs along with the compiler.
The TS compiler has arguably already crossed the line into checks that don't just concern type safety before, such as the `noUnusedLocals` and `noImplicitReturns` flags. I think this goes beyond "code smells". The idea of these checks is that they're *never* correct code; there's *no* situation in which you want to call .trim() but then not use the result. At the very least, you could remove that line, since it's not doing anything. But probably you meant to do something different. This is different from a "lint" check like enforcing that you use braces on if () statements -- in that case, the code is valid, could very well be what you intended, but just isn't stylistically up to snuff. http://errorprone.info/docs/criteria has the documentation for what qualifies for one of these types of checks -- note "The bug pattern should have no false positives.", for instance. ErrorProne also has a lot more examples, if you wanted to look over that. [This blog post by the same author talks a lot more about lint checks vs compiler checks.](https://medium.com/@Jakeherringbone/why-linting-makes-me-yawn-cadbd9a51ca9)
Just one [example](https://medium.com/@ianjsikes/get-started-with-rust-webassembly-and-webpack-58d28e219635).
How are edge cases easier to deal with in vanilla? You can target es5 or even es4 with tsc.
I've used Gulpfile.ts for awhile, so I know at least that one works.
I have the same feeling. But I only use Javascript Again when typing tiny libraries. I think Typescript gains when building large software in medium/large teams.
Is someone is interested in Preact-Typescript combination: https://github.com/k1r0s/bleeding-frontend-starter
There are many examples. If you have problems just ask! https://gist.github.com/k1r0s/6167eab946514d6aab4b9ce6943bb443
For those who are interested in plain Javascript OOP take a look over this: https://github.com/k1r0s/kaop/blob/override/test/main.spec.js
Thanks! The post at the bottom was helpful for giving me some context.
It's not that edge cases are easier to deal with, more that I can choose to expose them. I do a lot that touches on undefined behaviour.
I do the same as the parent, lemme explain more. When I'm testing code out, I just wanna write "x" for a variable. Then if I get into another bit of code and need to use "x" again, I'll rename the old variable. So it's a process of keeping my core thinking to the 7 items I can hold in short term memory, with refactoring to push older items out of my mental space. It has the benefit where "x" acquires a name through being used, rather than the temporary placeholder it might have started as. In the same way, I don't start variables off with types, I start with "x", refactor to say "pipeline", then when it interacts with other code, it'll get a type in the interface. The overall outcome is the same as writing in Typescript, it just has more of an incubation period deep within the functions before surfacing to an API.
Now It has
Now it has
Not sure to understand the question. TypeScript is basically JavaScript + types, so... you can do everything that you can already with JavaScript but with a compiler checking types and other things for you, if that's the answer you're looking for.
Are.... Are you asking us to write your article for you?
You can write code in it.
Maybe make sure you're well informed on the subject before you take the job.
https://medium.com/@basarat/typescript-won-a4e0dfde4b08
Typescript is great for cutting through baked-on grease. Just spray a little on and wait a few minutes. Scrub and your grill is good as new!
That's what a good reporter does. The bad ones just make up shit.
Typescript compiles to JavaScript which is a Turing-complete language so literally anything given an infinite amount of time and memory
So you're asking us to do your research for you? 
Just what the internet needs, more filler content created by the ill informed!
As a freelance copywriter, the most common is the company ask for a text about some subject, giving me just one briefing. With this briefing i need to find the informations to create the text. I'm a IT student, but i never had contact with TypeScript before, and even with my researches, i couldn't find the answers. But that post helped me.
thank you all for the answers, i'll use some to write about the language. Thank you very much for your help!
Get a different job that doesn't involve spewing out a high volume of poor quality spam-ticles for click revenue.
I can hardly wait for that quality text. Just make sure you get that word count, that's the most important thing.
Make sure to leave a draft of your article here for us to review. 
No - a good reporter does their own damn job without expecting someone else to do it for them :p
This is the answer. It's also good for curing hemorrhoids.
Be sure to also include `lorem ipsum`. That should make things better.
[removed]
So go learn JavaScript/Typescript and stop expecting other people to do your job for you.
you can use a namespace: interface Matrix { width: number; height: number; items: any[]; } namespace Matrix { export function create (width: number, height: number): Matrix { const items = Array(width * height); return {width, height, items}; } } export default Matrix; . import Matrix from "./Matrix"; const m: Matrix = Matrix.create(1, 2);
Is there a good rule for deciding whether a given instance of `Matrix` refers to the interface or the namespace?
i don't think there'll be issues because the namespace exists only as a value (doesn't affect the interface or create a type) while the interface exists only as a type (doesn't affect the namespace) const ns = &lt;typeof Matrix&gt; Matrix; // this is the namespace, you can use typeof if you want to refer to the type ns.create; ns.items; // error const m = &lt;Matrix&gt; &lt;any&gt; null; // an instance m.create; // error m.items;
Hang on, so which one is `export default Matrix` actually exporting? 
both the type and the value types and values are in a different "scope" so they can use the same name
So you'd be able to do the same thing with a named export (e.g. `export namespace Matrix` and `export interface Matrix`? 
yes, and `export {Matrix};` would also work
In this example, since Matrix objects aren't just data packages but have a defined way of being created, would it not make more sense to make them a class? export default class Matrix { // properties, either public or private (what you had in your interface) // constructor (what you had in the createMatrix function } 
Perfect answer. Would upvote more but I only have one. Incidentally classes do a similar trick, being both a value (function) and type (of object returned by function) with the same name, hence exportable as a unit.
Free functions have the nice property that you can pass them around easily as values. Suppose the matrix package included the standard `transpose` operation. If it was a free function I could transpose a whole list of matrices like this: ``` const transposed = manyMatrices.map(Matrix.transpose); ``` Methods on classes clash with this usage, making me write: ``` const transposed = manyMatrices.map(m =&gt; m.transpose()); ``` A minor thing in this simple example, but gets ridiculous if you have to constantly wrap method calls in little lambdas.
When possible, I prefer to keep the functions separate to make it easier to move the data structures around the app. I find that passing from server to client, from client to webworker, storing in DB is much more straightforward when you're not thinking about serialising and deserialising classes all the time. Also influenced by the fact that my home programming language is Clojure and I've gotten used to a Clojureish way of working in JavaScript too.
As one of the comments above said, wrap your function in a module or namespace and you should no longer have this issue.
That's been very helpful. Had no idea that types and values had separate scopes (even though types obviously can't make it to runtime). Always learning—thanks!
Another thing you could use is to name your interface/type as t. It's a convention in OCaml. Then it would be Matrix.t as the type and Matrix.create(10, 10).
You can't inherit from enums in TypeScript, but could using unions help? enum State { State1, State2 } enum AnotherState { State1, State2, State3, State4 } const x: State | AnotherState = State.State1; const y: State | AnotherState = AnotherState.State3;
Ugh, now that matrix object is not compatible with matrix objects from other libs. It's brutal working with vector and matrix types from three.js, cannon.js, fulltilt.js etc. in the same app. If only they had used pojos things would be a lot easier.
It's a nice pattern. A couple of questions about this... I don't suppose there's a way to make the factory function called `Matrix()`. i.e., there's no way to make the namespace a function? Does putting all the functions in the namespace inhibit tree shaking?
&gt; I'm a IT student Bullshit.
 const enemy = this.getStrongestEnemy(); if (I.am(enemy).and().not().null()) { // Do something with enemy } What was wrong with `if (enemy !== null)` ??? I admit, at first I thought this was hilarious, but now I realize that this is just sad. Either I've failed to understand this simple code, or... I don't mean to pick on your specifically because I see this kinda thing so often... but why??? 
Hey, no I agree you're right. I'd use your example 100% of the time. I really should have put some context along with my post explaining it was something I created for fun. Just to be clear, this is not production level code and I'd never code like this in a production environment. This was merely me playing around with fluent interfaces in TS. 
https://gist.github.com/mpj/17d8d73275bca303e8d2 
That’s clever. Thanks for the trick!
No problem :)
Where do you set up cookie parsing and express-session?
Wow. What a stupid mistake of mine. When I first started doing this, I thought I would add the things one bye one, to understand it.. And in the process I forgot about it, more or less. Thank you.
I hope you are a better copywriter than “**an** IT student.”
So far, there is no way to merge enums and I don't know any language that does support it. Frankly, I don't think it's right thing to do The closest thing that I use is string literals and union types. In your case that would be type State = | "State1" | "State2"; type DerivedState = State | "State3" | "State4"
Did you delete the submission or something? It sounds like /u/Beege1 is OP but it says "by [deleted]" above. Also the link 404's, did you delete the repository?
Neh, there is no reason to go back.
Work on Angular projects for the frontend, and NestJS+TypeOrm on backends, problem solved. We are implementing this workflow right now and it's going great, people are changing their minds about how they do JS development, without type safety, it's all just hell.
You could always unit test it? Ch click definitelytyped for instance
Well it's for my package and possibly to publish to dt. Mainly asking to make sure I don't do something dumb and break anyone's build that's using it or anything.
Strongly recommend that instead of making `options` type of `any`, come up with an interface that lets end-users know what properties on the options are actually available to them.
Right on, better something along these lines? https://github.com/nol13/fuzzball.js/blob/typed-options/fuzzball.d.ts I actually had the options typed out at first then was thinking maybe better to be lenient, trying to run through any possible reason someone might want to add random properties to the options. The more I think about it don't think there are any good reason to though. (One of the functions can accept a custom scorer function, which will get the options passed to it) Also there are a couple functions that technically could take any, but if you don't pass valid strings will just return 0 or ''. Ok to type these as only accepting strings? or string | any? 
Yeah, that looks better. Basically, I want to be able to know that I can pass things like `wildcards` just by using the autocomplete. Any time you can leave `any` off, it saves me a potential future headache. I'd rather have an editor yell at me _now_ while I'm writing the code, instead of having an end-user yell at me _later_ when something I deployed didn't work because I passed the wrong type. Bonus points if you include jsdoc-ish documentation on each of the values as well, since most editors will allow you to view that documentation as a preview. Like this (at least, this works in vscode): export interface FuzzballBaseOptions { /** * wildcards documentation here */ wildcards?: string; } Or [here's an example](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/dc0c4811d4afcf4c34de4143112b999a7199249e/types/react/index.d.ts#L358-L362) from `@types`. Basically anything to save people from having to hop to and from a browser to look things up.
You should add `length` to your Results interface, since it is actually an Array. I would just use `Array&lt;ExtractResult&gt;`, but I guess the reason is you want a named return type. Also the `ExtractResults` and `DedupeResults` are polymorphic return type -- array containing varying different types. You are basically forcing the downstream consumer to add a `if` statements checking which type the method is returning. Consider make it mono-morphic or split it into different functions. 
Maybe you could tell us what variable it is that you think wasn't declared instead of just dumping 50 lines of code in the post and making us figure it out.
Thank you, out of all proposed alternatives, this makes the most sense (to me.)
Can you export the generated html somewhere else? Our documentation is hosted in a CDN. Is nest what I should be using with TypeScript vs plain express?
Guess I can overload/merge the interface for the extract function to specify one return type if passed an array, and one if passed an object if that would suffice. Not totally opposed to splitting the function if best though. Dedupe could be harder since the shape depends on if the "keepmap" option is true. Will mess around with it tonight. Does a named return type vs. Array&lt;ExtractResult&gt; have any material benefits? Appreciate the feedback.
There's probably a .d.ts file that defines it as a window object somewhere. 
Visual Studio CodeMap feature: https://msdn.microsoft.com/en-us/library/jj739835.aspx
For angular specifically check out [compodoc](https://github.com/compodoc/compodoc). 
this seems to be for Angular 2+? 
Yes. You said angular. If you meant angularjs you should say that.
[removed]
The convention is to prefer `Array&lt;Result&gt;` over `Results`. In your case, you are doing `Array&lt;Tuple&lt;Blah, Blah&gt;&gt;` but currently Tuples cannot be typed as interface, it can only be typed as `type`, which is only a "shorthand". I would've done `Array&lt;{ field1: any, field2: string, field3: number }&gt;`, that type inside of the array can be extracted into interface and named. I came from a more OOP background, where there is no benefit of using Tuples, `class` in Java/C# under the hood are flattened datatype anyway. Given Node.js 6's "object destructuring", there is not much benefit of tuple in Node.js either. You can do `const { x, y } = { x: 1, y: 2 };` just as well as `const [x, y] = [1, 2];`. However if your audience are Python users, then it might be worthwhile in keeping tuples. 
i'd recomment using nest, it's a very nice framework, but you must be fluent in Angular's Hierarchical Dependency Injection, otherwise you'll have difficiulties understanding what the hell is going on, Nets's components are equivalent to Angular's Services: https://angular.io/guide/dependency-injection Modules are pretty much the same as Angular: https://angular.io/guide/ngmodule
Pretty fun thread, I like it.
i said angular 1.6
Thought you were referring to the ts version. Sorry.
It's in the main Github project... https://github.com/fastify/fastify/blob/master/fastify.d.ts
That's pretty awesome. Didn't know it existed. Is it available in the community version? 
don't think so, i think it's Enterprise and above.
jesus, OP cant handle any feedback
Honestly, fuck Angular for making this an issue in the first place. 
Also pm'd me after I tagged him haha
Breaking circular dependencies usually involves contrived separation of concerns or rigorous use of interfaces (eg: one file of all interfaces and no relations between classes), this isn't so bad but it is burdensome. There are no hard and fast rules so feel free to lump a bunch into one file, and also the circular dependency rule comes from NodeJS rather than TypeScript specifically.
Cool, so updated my current working branch to use Arrays of tuples as return types, and overloaded all the different signature to get rid of the polymorphic return types. https://github.com/nol13/fuzzball.js/blob/typed-options/fuzzball.d.ts And ya, this started out as a pretty direct port from python, with the tuples along with it, then used more JavaScript idioms as I went off-course. Hence the mixed camel and snake casing, which I now regret. Maybe could add an option to return objects instead of tuples though.
Comments added and parameter descriptions showing up when I hover in vscode! Did have a some jsdoc in there, but not in quite the right format to auto-generate the type definitions from I don't think. Seemed like less of a hassle to just write them from scratch.
Afaik not but you can do minimal transpiling with tsc (target: es2016 or something) and then use babel to produce production bundle with preset-env.
it was the **adb** variable. It was actually emphasized on my post.
yes there is one actually. What does it do? 
Research "typescript definition files". In this scenario, it is a way to define variables in third party libraries without importing them and instead relying on them being on the window.
Pretty sure you can do this using webpack with a typescript transpiler loader. 
Hi everyone - if you want to know about the role (it's for a client), feel free to DM me or drop an email at bogdan@functionalworks.com. The product you'd be working on is a new property management platform - backend is in Scala.
Version-specific browsers -- not really. These are the targets: * "ES3" (default) * "ES5" * "ES6"/"ES2015" * "ES2016" * "ES2017" * "ESNext"
Wouldn't it make more sense to post either the actual job description here rather than get people to message you directly?
&gt; I'd rather use functions and interfaces than classes with static members. Any reason in particular? export class Matrix { width: number; height: number; items: any[]; static create(width: number, height: number): Matrix { let items = Array.from({ length: width * height }); return { width, height, items }; } } and then use it like this: import { Matrix } from './Matrix'; //... const m: Matrix = Matrix.create(2, 3);
If you're not targeting IE, but only Edge instead, then ES6 is fully supported across the board.
Not for a recruiter. They want to "find" the candidate and claim the equivalent of 15-20% of the first year salary, so they aim to stop any candidates going direct to the employer.
Correct, this is what we’re doing in our application 
There is really no problem having one class per file; it makes you separate the concerns of modules, and if you're coming up with circular dependencies it's a sign that the modules are doing too much work and they both depend on a common third module. Having 2 classes that heavily depend on each other is accepted in a lot of projects, as long as only one of the classes is intended to be used outside of that file. It really comes down to defining good components and following Single Responsibility Principle.
You don't output them all to the same directory. You create some sort of top level barrel that imports and reexports all of them and point declaration dir at that.
thanks a lot. I get it now.
As far as Webpack goes, it's as easy as changing your configuration file extension from .js to .ts. You can then use "import" instead of require and take advantage of type checking for your config (webpack.Configuration from @types/webpack). I've actually been supprised by the number of plugins that have type definitions available. To make webpack pick up the config, you need to install ts-node as a dev dependency. The real show stopper is the lack of support from other tools that might read your config like styleguidist. 
Yeah, I thought of it, but the spec itself is pretty vague: • We're looking for individuals with a strong engineering background plus a passion for UI development/front-end to join us and help anchor the team. • Architect well-designed, well-implemented, and well-tested front-end software that drives complex web interactions (TypeScript, JavaScript, SPA) • Work within and contribute to a cross-functional product team and manage individual commitments to a high standard My general aim is to have a quick talk with people interested in the role, give insight into the company and their interviewing stages and then see if it makes sense to move forward.
I do agree that most of the recruiting industry is pretty crap, but the way I/we work is a more consultative basis and giving guidance through the various interviewing stages. Fundamentally, if a candidate wants to go direct to the employer - they can do so (as in the first talk with a candidate I tell them the company name and how the they work).
Which module system you using? Specify by the "module" option in `tsconfig`. You can have circular references with ES6 module semantic. CommonJS (and maybe also AMD/UMD) might not support it fully, because it allows post-binding/runtime modification of imports, but bundlers usually provide a hack to allow for circular references in the naive case. 
it's your face... on my reddit... 
There is a GitHub issue relating to this that has been open for quite a while: https://github.com/Microsoft/TypeScript/issues/8372 
Hey buddy! Fun seeing you here.
i start using typescript 4 years ago, i introduce it to my college and they all refuse it and were against it. now they all love it and use it all the time thanks for Angular (Angular 2)
IMO, this is very bad advice. Using `!` to tell the compiler, "nah, we're good" comes back to bite you more often than not. Using `as` to make your DefaultProps behave like your ComponentProps is very brittle. Instead of that, define an interface for the props that will be provided when your component is instantiated, define another for the default props, provide the combination of the two to the Component generic, and then export the class with _only_ your ComponentProps. Your component's public face will behave exact as you want and the `DefaultProps` are a safe, private detail. This is the same process you'd take if you wanted to ignore the common Redux container/component advice and instantiate a Redux-aware component elsewhere without burdening the caller with its props. interface ComponentProps { age?: number; name: string; } interface DefaultProps { age: number } interface LocalState { # your state } class MyComponent extends Component&lt;ComponentProps &amp; DefaultProps, LocalState&gt; { static DefaultProps: DefaultProps = { age: 33 } constructor(initialProps: ComponnetProps &amp; DefaultProps) { super(initialProps); this.state = { # your state here } } } export default MyComponent as React.ComponentClass&lt;ComponentProps&gt;;
how does it compare to prettier ?
I am working with angular 4 (ng serve, ng build etc). Do you know how I can use a naive workaround? I dont even need multiple modules to make circular references to each other. I just want to spread out one module to multiple files for ease of organization. If tsc would just concatenate the files before compiling I would not mind at all.
This is Google's configuration of tslint and clang-format. If you want the same code formatting capabilities, but you want to configured it yourself, it looks like you should use clang-format.
The article doesn't suggest blanket use of `!` all through your code -- only points out it can be used when you KNOW React is going to provide the value. Using `as` is no less brittle than having two interfaces as you've done because there is nothing in the type system ensuring the critical overlap between DefaultProps and ComponentProps. But, more importantly, the article also made the point that it's a non-issue if you use use destructuring with default assignment.
Angular 4 uses ES6 module system and webpack, which should work with circular imports/exports. Where are you getting the error? Are you getting circular reference problems during static function calls or object construction during application start up? 
Maybe if you did something like static defaultProps: DefaultProps = { age: 33 } as ComponentProps and then I think the type system would ensure that the members of ComponentProps are assignable to DefaultProps 
My error was in my model files, ie they are not even components or anything. They are just files that have the game logic in them without any angular code or angular imports. I started getting errors not during compilation, but in the browser. The error was that the functions inside the object were missing, like static functions or constructors. I assumed it was due to circular dependency. 
It might still circular dependency, just not module imports/exports. It probably is with the initialization of your code or construction of your objects. Try move code out of the constructor, and have a separate method say called `initialize` to do the initialization. Last time I did much OOP, in application-level singletons, constructor is used to initialize the singleton w/o dependencies, and then another function is used and called to do initialization after application is wired. 
clang-format is the formatting tool here. I've tried both prettier and clang-format, and they're quite similar. Both are quite configurable, so you could probably achieve nearly the same results with either. In my tests, clang-format was faster, but not by much.
The use of `!` is all well and good at the time the user followed this example, but it isnt safe if it needs to be refactored. If it’s ever removed from the default props, the compiler won’t be there to catch it. This is what always gets me, sooner or later. We all use `!` with good intentions and sound logic, it just doesn’t last.
I think you could get away with saying that it’s a `Pick&lt;ComponentProps, ‘age’&gt;`. 
Wouldn't it make sense to pass in the current value and return the result? You could do it as an optional parameter that defaults to 0.
This didn't work for me. I get: `Error TS2665: Invalid module name in augmentation. Module 'whatever' resolves to an untyped module at "path/to/node_modules/whatever/lib.index.js', which cannot be augmented.` Using Typescript 2.6.1
Try setting "types" to an empty array in your tsconfig. Also make sure you're .d.ts is being looked at *before* anything that might possibly be triggering ts to look at node_modules/whatever. That's the goal: get TS to look at your .d.ts and never even notice that `node_modules/whatever` exists.
Alternatively, you can use an non-optional "accumulator" argument and reduce/fold over the Linked List. They are semantically the same, but would classify as slightly different programming style. 
This library is part of the [Zafiro](https://github.com/ZafiroJS/zafiro) ecosystem but it is standalone and can be used on its own.
I was _just_ wondering if I should write validation decorators for my app. Now I don't have to. Thanks for sharing!
This validates the object in runtimes right? This is great, it is always better to crash than continue with an error. However I really want typescript to see the needs of this and put the validation to compile time. Either implement refinement type or at least compile time code injection.
The check is at runtime, the main use case is to validate HTTP response body containing JSON
[removed]
Be careful too cause .push returns the length of he newly created array, not the array itself. Makes no sense to me. This is why i choose concat instead. 
I'd also like to make a shout out to class-validator which does the same thing but is written by the same guy who created TypeORM (that Zafiro uses). https://github.com/typestack/class-validator
One class per file is great for tooling also. Makes things easier to find.
In the example, you limit password length and chars. 😕
I actually started to, then just went back to standard joi followed by just telling my app that the data matched the interface I claimed it was. What I really want is a library that takes JSON, and parses it directly into specific classes, throwing if the structure doesn't match. And without needing to `JSON.parse` into an intermediate object (or array or whatever) first. Something like [Json.NET](https://www.newtonsoft.com/json) in C#
True :( I actually copied the example from Joi https://www.npmjs.com/package/joi
string is an object type. so it should be error.
The errors are src/test.ts|29 col 13 error| 2345[QF available]: Argument of type '"red"' is not assignable to parameter of type 'Color'. src/test.ts|30 col 13 error| 2345[QF available]: Argument of type '"purple"' is not assignable to parameter of type 'Color'. In the first example I'm assigning a number to an Enum with number values, second example I'm assigning a string to an Enum of string values.
You don't need to use var when declaring class properties. They'll exist as properties on an object and by default can be assigned and reassigned to. By default properties are public, so the first one is public and the second one is private.
&gt;You don't need to use var when declaring class properties. Not only don't need to but it's a syntax error to do so. Member fields are just keys in the object hash.
&gt;You don't need to use var when declaring class properties. Not only don't need to but it's a syntax error to do so. Member fields are just keys in the object hash.
you should check out /u/klaxxxon's method of namespacing using strings. I think 'app/color/red' is better than 'red' by itself for indicating that the red color is part of an enum in your app vs any old red or another's app/library's red.
You mean like type alignment to figure out which of several ordered optional values you have passed? No, it doesn't.
I meant keyword args, :(
U can use optional params class Car { constructor(param1, param2, param3?) { } } new Car("Seat", "Ibiza") // this is correct
But any of them can be null
BTW you can use Builder pattern in TypeScript (JavaScript as well) Here is an example in Java (just googling "builder pattern") http://javarevisited.blogspot.com.es/2012/06/builder-design-pattern-in-java-example.html
Oh, well your function can take an object, which is similar to kwargs.
[removed]
Another alternative: class Car { constructor(args : {param1, param2, param3?}) { } } new Car({param1:"Seat", param: "Ibiza"}) // this is correct 
 class Foo { bar: string; otherProp:number; constructor(params:Partial&lt;Foo&gt;) { Object.assign(this, params); } method() { return 'result'; } } const foo1 = new Foo({bar: 'value'}); const foo2 = new Foo({otherProp: 3}); const foo3 = new Foo({method: ()=&gt;'override'});
`Partial` is just a special generic in TS?
it's basically the same type as Foo, but each property is marked as optional see mapped types here: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html
Not special, but it is defined in lib.d.ts [here](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts#L1329).
Depending on how much duplication and boilerplate you can stomach, you could do something like this: (you can certainly make it shorter depending on your code style) enum Color { red = 1, blue = 2, green = 3, } namespace Color { export type Map = { red: 1, blue: 2, green: 3 } export type Value = Map[keyof Map]; } function logColor(c: Color.Value) { console.log(c); } logColor(0); http://www.typescriptlang.org/play/index.html#src=const%20enum%20Color%20%7B%0D%0A%20%20%20%20red%20%3D%201%2C%0D%0A%20%20%20%20blue%20%3D%202%2C%0D%0A%20%20%20%20green%20%3D%203%2C%0D%0A%7D%0D%0Anamespace%20Color%20%7B%0D%0A%20%20%20%20export%20type%20Map%20%3D%20%7B%0D%0A%20%20%20%20%20%20%20%20red%3A%201%2C%0D%0A%20%20%20%20%20%20%20%20blue%3A%202%2C%0D%0A%20%20%20%20%20%20%20%20green%3A%203%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20export%20type%20Value%20%3D%20Map%5Bkeyof%20Map%5D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20logColor(c%3A%20Color.Value)%20%7B%0D%0A%20%20%20%20console.log(c)%3B%0D%0A%7D%0D%0A%0D%0AlogColor(0)%3B
yes
I would add that it is not specific to typescript but it is javascript related. You have a way to avoid this with factory functions ;)
I might be mistaken here but inside a class method you could start with 
I might be mistaken but inside a class method you could add const { number } = this; and reference is by calling number instead of this.number.
should be { value }, number is the type
Whoops, you are correct. Thank you.
You could set this to a variable I suppose, so it’s myClass.value 
You could set this to a variable I suppose, so it’s myClass.value 
I'll never get the purpose of these "Cloud" IDEs. Just have it on your machine maybe ? Use source control to store your files maybe ? Have full control over your Dev environment maybe? Ugh.
I understand your concern, and believe me I felt the same when Eclipse Che was announced and such. I know there's a huge use case at my company for IDEs like this, where a lot of people work remotely (they don't have a choice for several reasons: i.e can't keep any code locally on their machine, security etc.) There's also some advantages to working with this for code collaboration (workspace sharing when debugging is an example that comes to mind). However what's nice about this project is that you can also use the electron desktop app, which is very similar to VS code (also an electron app), but also more configurable via user extensions.
Why not: type Color = 'red' | 'green' | 'blue'
I didn't know that was possible, I'm just getting started. Now I don't know the use for enums either. 
Do you develop your IDE using your IDE now?
TypeScript can do what JavaScript can.
Not yet, although that is something we'd very much like to do in the near future! We're getting closer to that goal every release though, the project is growing steadily and once debug (quite a big feature) gets in, I think we'll be able to do so. There's also the fact that the platform (core) is evolving really fast with new features every week, so unlike Eclipse where you can use an old version from 6 or 12 months ago to develop new Eclipse versions, Theia needs to be updated regularly to keep up with the features. Once it gets more stable and debug gets in (something planned for early 2018) I feel like this is going to be a reality :)
Can you imagine what it will do you to your pitch to say, hey "We develop all 500,000 lines of code for our IDE using our IDE"? Makes me wonder how quickly the TypeScript team started coding TypeScript in TypeScript.
This looks like a similar topic: https://github.com/Microsoft/TypeScript/issues/17690
I don't see how it works in that partial code you pasted that seems to be just mostly comments, but it is valid syntax as object destructuring: const obj = { a: 'foo', b: 42 }; const { a, b } = obj; console.log(a); // prints "foo" https://www.typescriptlang.org/docs/handbook/variable-declarations.html
Can you check if this works? Assumes pc is of global scope, and the created object does not have initialize and update by default. class MyScript { constructor() { Object.assign(this, pc.createScript('scriptName'); } initialize() { // Stuff that happens when script is initialized } update() { // Stuff that happens every tick } } 
you can do: class MyScript extends pc.createScript('scriptName') { }
You can prepend `export` to any `const`/`let`/`var`/`function` declaration. It would simply export whatever variable/function associated with that declaration. 
Nice find. Looks like an intentional inconsistency in the language, and the only way they can fix it is with allowing both let c: Color = Color.Red let c: Color = "RED" But what really bothers me is that you can assign any number value to a number Enum. Until they change that, Enum just looks like unnecessary bloat to the language. Looks like spacejack2114 had the right idea with type Color = 'red' | 'green' | 'blue' 
I wouldn't call it bloat - but losing some type checks because at least 1 of the values in an enum is a number is a bummer.
Enums let you refer to those strings by an identifier (`Color.red` instead of `'red'`, then use F2 rename refactoring to rename all at once. This saves a ton of time in large codebases where `red` might be referenced a hundred times.
It’s destructuring and renaming. The key to the left of the colon is the name being destructured from the result of getSelector. The right side is what that variable is being renamed to. 
Yup, that's just a JavaScript thing. If you only need to *read* values, you could copy them to local variables at the top of your method, using a destructuring statement: const {foo, bar} = this; Or if you felt like `this` was too verbose, you could `const T = this;` But really, this is just the way JavaScript works. JavaScript is so dynamic that, unlike C# or C++, it's not possible to unambiguously determine whether or not you're referring to an object property or a lexically scoped variable without requiring the explicit `this.` property lookup.
Would you prefer your solution to just namespacing the value like somebody else suggested, like 'app/window/red'
I've never used that namespacing idea so I can't speak from experience. Can you use the rename refactoring in that case, or would you need to find-and-replace?
Ah true. Looks like it was edited to put in proper line breaks after I commented.
Brilliant, it never occured to me to extend it this way. Only problem is that I'm getting a "Type 'ScriptType' is not a constructor function type" error.
No, it doesn't, unfortunatly. Thanks for trying though;
Is `pc.createScript` defined in TypeScript or JavaScript? If it is in JavaScript, you can write a `.d.ts` file for it, in which you declare the external interface of the class. It could be based on what you know from runtime or what you use. If it is in TypeScript, there is probably some upstream type error. You can probably just annotate `createScript` to return a class/interface you declared somewhere.
It is defined in JavaScript but I'm using an JSdoc autogenerated typings file. This is what it generate for createScript: function createScript(name: String, app?: pc.Application): ScriptType; How should I modify it?
What is `ScriptType` in the file? It should be one of the following: * a`class` * a void function * an interface with `new` entry 
 This is what it look like in the typings file: declare class ScriptType { constructor(); attributes: pc.ScriptAttributes; } By the way, thanks for taking the time. I really appreciate it.
Change `createScript` to return `typeof ScriptType` instead of `ScriptType`. Since it doesn't actually return an instance of `ScriptType`, it returns the "class" definition of `ScriptType`. This is a very odd API. No problem. 
Well it took care of the TypeScript error but unfortunately the code doesn't work with the engine. Like your said, it is an odd API and I'm having a hard time understanding the inner workings of it all. If ever you want to take a look for yourself, here is a [link](https://github.com/playcanvas/engine/blob/master/src/script/script.js) to the relevant part of the source code.
Looking at the [documentation](https://developer.playcanvas.com/en/user-manual/scripting/creating-new/), it looks like the object returned is expected to be treated like a "partial class" or "config object" to be modified or configured, rather than a "abstract class" to be extended. Definitely not a common idiom in JS land. The best syntax I can think of is probably: const MyScript = pc.createScript('scriptName'); Object.assign(MyScript.prototype, { initialize() { } }); 
Well thanks for looking into it. Atleast I feel better about having such a hard time with it.
Damn, didn't know TS now supports plugins. Anyone know if there are (being worked on) plugins for that mentioned runtime typechecks (e.g. for every function/method call it would check types when running a debug build) or pipe (aka |&gt; operator, reversed function application)?
Then try to find out why it's a boolean[] instead of a string[].
 ['F', 'E', 'D', 'c', 'b', 'a'] .sort((left, right) =&gt; { const [a, b] = [left, right].map(phrase =&gt; phrase.toLowerCase()); if (a &gt; b) { return 1; } if (a &lt; b) { return -1; } return 0; });
I had to go with list.sort(function (a:any, b:any) { return a.toLowerCase().localeCompare(b.toLowerCase()); }); I don't know why the TS compiler demands a boolean for a and b but casting them to any worked
It’s likely because the array you’re sorting isn’t picking up string typing properly. Hard to tell just from these snippets though.
Well, it's happening at compile time, so it shouldn't matter what is in the arrays. I logged typeof a, typeof b at runtime and it comes out as all Strings. I've been working in TS for about a year, and I love it, but every once in a while, it throws me a curve ball. Enough that I even yearn for javascript's loose typing, but those feelings usually pass quickly. 
It matters because of what TS can/can't figure out is in the arrays during static analysis for compilation. It may actually have strings in there, but further up there is likely a point where the arrays are being worked on in a way which isn't enforcing the string type.
It matters because of what TS can/can't figure out is in the arrays during static analysis for compilation. It may actually have strings in there, but further up there is likely a point where the arrays are being worked on in a way which isn't enforcing the string type.
&gt; No proof-of-work or proof-of-stake: a block can be added to the blockchain without competition Can't really call that a Blockchain then
WTF https://github.com/Microsoft/TypeScript/issues/14529#issuecomment-287517438 minestarks (MSFT): &gt; Our long term plan is in fact to base the language service version off of what's specified in the .csproj file to match the build. So right now, by design, the build and the Compile on save via the language service uses completely different TS versions and this is apparently completely OK. :tableflip:
I'm sharing this because I'd like it to be critiqued before I package it. I wrote it this morning, so please, shred it.
The readme is ... too short. 
Haha that is a very fair point. I'll update it when I can but for now I guess you could say the magic happens in NepModule, and you can see players.handler for an example usage and server.ts to see how it hooks up to express and pg
I will have a look. 
Are you aware of nestjs &amp; zafirojs?
I am not! I assumed there would be libraries that did this but my googling didn't find those two. This was as much about me learning typescript decorators (and soon npm packaging) as it is about being a production library that people would use in the real world. I'll definitely look in to those two, thanks for the tip!
+1, don't get me wrong. Maybe your framework tackles problem from a little bit different perspective but make sure that you know advantages and disadvantages of competitors :) 
Do you know about generics and union types? If you "go to declaration" in your IDE it'll show you where those types are declared.
There is a little problem with that, your values are not variables. Which means, whenevezr you change one, you have to change it everywhere in your code. I personnally use an enum(string typed as shown by OP's awesome post) when I don't care what the value is and just want to typecheck. But when I use the value I use namespaces : export namespace Color{ export namespace values{ export const RED = 'red'; export const BLU = 'blue'; export const GREEN = 'green'; } export type type = 'red' | 'blue' | 'green'; } That way when you want the type you give the type Color.type, and when using the values : Color.values.RED.
&gt; equivalent [...] in Java If you want to learn typescript, forget it looks like Java and try to understand what's happening JS side. Typescript playground is an awesome tool for that. Nothing in typescript is like Java, it looks like it and can work like it so it's easier for javaers, but if you code it only like you code Java, your code will be bad. On that note about your issue, there is no real access modifier in javascript. When TS parses your code and sees you are calling a private var, it throws an error. But in JS (at runtime) you can access that var.
tl;dw?
Definitely webpack (although I have heard good things about rollup too). [the guide here should get you up and running. ](https://webpack.js.org/guides/typescript/) 
I was exactly the same a year ago. Although typescript looked good compared to classic javascript, the build process and integration into the page felt wrong. Using [webpack](https://webpack.js.org/guides/typescript/) now it still feels wrong somehow (especially when i look into the webpack config file) but it actually works pretty well.
It's can't be fully OOP since it still uses prototype-based inheritance (since it's a superset of javascript).
This webpack config should be enough to compile your typescript app into a single bundle.js const path = require("path") const SRC = path.resolve("./src") const DIST = path.resolve("./dist") module.exports = { entry: path.join(SRC,"index.tsx"), output: { filename: "bundle.js", path: DIST }, // Enable sourcemaps for debugging webpack's output. devtool: "source-map", resolve: { // Add '.ts' and '.tsx' as resolvable extensions. extensions: [".ts", ".tsx", ".js", ".json"], }, module: { rules: [ // All files with a '.ts' or '.tsx' extension will be handled by 'awesome-typescript-loader'. { test: /\.tsx?$/, exclude : /(node_modules)/, loader: "awesome-typescript-loader" }, // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'. { enforce: "pre", test: /\.js$/, loader: "source-map-loader" } ] }, };
I love you. I'm gonna try this out tonight. Thank you.
It's full fledged oo language and it's also a sugar on top js. Did you think that js is not oo?
This is wrong in many aspects. Having prototypical inheritance does not contradict for the goal of being fully object-oriented. I'm not claiming typescript being or not "full-fledged OOP", I'm just saying your reasoning has some flaws.
Fair enough. However, I still don't think it's fully OO, for other reasons. Just like JS, it borrows some concepts from OO, and some from FP, making for some mixin between the two.
At least modules have (mostly) settled. UMD was such a PITA.
You should try Fusebox. I think it is much better then webpack. Easier to configure, faster, with built in typescript support. http://fuse-box.org
IMO Browserify is way easier to get started with. It does most things you need from webpack with a fraction of the configuration. Just point it at your app entry point. Eg: npm install browserify tsify browserify src/main.ts -p [ tsify ] -o public/js/app.js 
Can a transform be made to generate typings for CSS files?
Nice, I was actually looking for something like this. Thoughts on TS/Vue so far?
I like Vue very much, even more than React, also note that Vue itself uses Flow instead of TS. However, as I mentioned, the migration only took me a day, thanks to Vue offers a very well-written guide on TS support and writing the webpack config didn't take longer that I expected. Also, Vue offers their own type definitions on all their libraries so adding types should not be that hard, I didn't take the time to actually look them up though, but I will, if this part is also finished, the project would be an excellent example on how to develop Vue along with TS and shows how powerful it can be and how easy the migration is. All in all, I had a blast.
Very helpful thank you.
Js is fundamentally an object based language. The functional aspects are just an extension of making a function one of the object types. It didn't borrow concepts, it *is* an object oriented language from top to bottom. Every feature it has is also present in other languages that I assume you would call oop.
I just had a look at that project. Wow. If that's a minimal project, I am staying far away. I can see it being warranted for sizeable projects, but for mine, nope nope nope. I appreciate the help though.
Well there's a few things that you'll find you probably want. Compiling typescript, including source maps, bundling modules, compiling dev builds vs building minfied bundles, rebuilding on save, hot-reloading on save, adding some type of CSS preprocessor. Compared to the equivalent webpack config, this is pretty minimal and transparent. You might also look at [parcel](https://parceljs.org/) which presumably does a lot of the same stuff automagically without a lot of configuration.
I've just begun looking into that. https://github.com/kevguy/vue-hackernews-2.0-typescript/commit/1086d68550c8f990dd51d7d8f355093bdbe09db5
Awesome! Give us an update when you get it ready.
Nope, it is in fact a feature of TypeScript itself! The npm package _typescript_ ships the compiler and the language service, which powers the entire TypeScript tooling experience (autocompletion, refactorings, code navigation, …) in many editors.
This general question keeps getting asked on this sub. :) The feature is indeed part of Typescript itself. TS is the poster child for Microsoft's Language Server Protocol. This means that the IDE doesn't actually have to implement any language-specific features and leaves all that work to an outside program with which it communicates via a structured language-and-editor-agnostic mechanism. Typescript is one of the languages that ships LSP support right in the core compiler project; other languages instead have third-party servers that can be used. The benefit of the setup is that now any IDE can get all these language-specific features for any language; you could write a brand new from-scratch IDE today and get excellent language support for Typescript, C++, Rust, C#, Python, etc. without having to write much or any language-specific support. Likewise, you could write a whole new language that works out of the box with all these IDE features in VSCode, Atom, Vim, Emacs, VS, etc. without having to write any IDE-specific support. It's similar to syntax highlighting via a something like TextMate grammars; if your IDE uses such files, you don't have to go rewrite all the syntax highlighting support for every language in your IDE when the .tm files already exist and are widely used, and if your language provides a good default .tm file then you can get syntax highlighting out of the box on a wide range of IDEs, including ones you've never seen or heard of.
What is "pure oop"?
Have a look: https://github.com/kevguy/vue-hackernews-2.0-typescript/tree/master/src/store
All of the advice you have is more complicated than it needs to be. I am simply compiling Typescript to JS, and you can use the built-in ES6 modules in the browser for everything else. Example: &gt; index.html &lt;script type="module" src="viewer.js"&gt;&lt;/script&gt; &gt; viewer.ts import { sayHello } from './wtf.js'; sayHello(); &gt; wtf.ts export function sayHello() { console.log("hello world, sure whatever"); } Use typescript to compile the two ts files, which become js files.
I tried this out. weirdly (to me) the JS output has the line "import ..." and the browser says NO. I tested with Chrome 62 which is supposed to support modules. So right now it's complaining that it does not recognize the "import" token. I'd love your advice on this. My tsconfig is as you said.
HN discussion: https://news.ycombinator.com/item?id=15934289
Very cool. I've been wanting to write a library for this exact thing for quite a while now...but other things kept popping up. Kudos!
Thanks! I'm really surprised someone didn't get to it before me.
Can this be used with Angular 5?
I thought so too when they released automatic imports. I logged an issue in the vscode repo because it didn't prefer import default, and it also forced semicolons which we don't use in our code base. The vscode team pretty quickly closed and moved the issue over to the typescript repo where they discussed config options to put into the language. Pretty interesting way to do it. Makes it so easy to get your language supported in all IDEs
Is it working now?
I'm going to retry tonight. I will keep you posted I promise. Thanks
i got the modules to load fine. but this line barfed `var car = new Car();` it says Car is undefined. although I can see it loaded in the debugger.
Never going back to angular. Sad my company went down that route.
Best use of typescript I think there is right now. They predicted the rise of rxjs and support is baked in. I think there’s a lot to like, but I can see it being frustrating depending on how your org manages it. I’m only using it with small teams. Everything else is still react
&gt; 9,615 developers reported they had used Angular 1 and would not use it again Not use Angular 1 again, or not use Angular again? Does this mean they wouldn't use it in a new project, or they would avoid working on projects that are currently using it? I doubt anyone would start a project using angular 1 given it has been superseded.
I've been trying to become less dependent on Angular, but the more progress I make on this goal the less benefit I see in it. it took a bit, but I finally learned webpack enough to get it to also move the non-ts/js files from src to dist. the Angular command line tool took care of that webpack configuration for me without any downsides. I really like the Angular paradigm (presentation and container components, services, dependency injection) and have found myself re-inventing the Angular wheels in my (supposed to be) plain typescript project...
TypeScript is such a blessing for frontend code. The fact that microsoft (can you imagine?) dogfoods it via vscode is also a very good sign! TypeScript has made me enjoy frontend dev in a totally new way! Long live TS!
Never mind about Car, just get my examples working. Then you'll have something that works as a starting point. Make those three files, do it, and then that's where it starts.
There's nothing wrong with Angular. I think it's pretty great, though I prefer React. If you're looking to extricate yourself from a framework, React is much lighter weight and requires less buy-in (and thus commitment). But if you're happy with Angular, stay with Angular :)
CycleJS is written in Typescript. It's less of a functional utils framework and more of an application/state-management library.
I'll be using React+Redux for the view/state layer since they are incredibly popular and also quite functional by themselves.
You'll have to show me the code so I can see how you're loading Car.
Maybe not exactly what you're looking for, but some things I've come across: https://github.com/funkia/hareactive https://github.com/kube/monolite https://github.com/garrettm/tsum 
https://github.com/types/npm-ramda/
https://github.com/gcanti/fp-ts is a nice little lib.
I was reading about Parcel recently, but the missing (or rather not advertised) TypeScript support has discouraged me from even trying it. Thanks for the info :).
I can't believe this, I am in tears, I lost 6 hours of my life trying to configure webpack, typescript, hrm, react and avoid full reload of the app and its state, parcel did all this for me in just a minute. thank you op
Create-react-app?
is it me or parcel swallows all transpiling error?
not, they appears in the browser console
I'm wondering if instead for now the answer is to create a higher level mixin creator that will take in a number of different mixins and return the result from all of them. This might fix the issue since each new mixin wouldn't be masking the total signature created. Might be worth a shot trying anyway.
This isn't really a Typescript specific question. It's just JavaScript. One thing to consider is that you will need different varience calculation functions for dates than for numbers unless you first convert the dates to timestamps. Also due to the size of timestamp numbers you must take care when calculating varience not to accidentally cause a wraparound error or lose precision when adding values for calculating the mean. This may require the use of a big int type library for JavaScript/Typescript.
TL;DR: yes
As mentioned, not really Typescript specific. But this library should get you going: https://www.npmjs.com/package/descriptive-statistics
What you are trying to do is "outlier removal". Since your data is 3-dimensional as supposed to the normal 1-dimensional vector, you should read up on that topic first. There are special Machine Learning algorithm (clustering) for 3D data. Also this is normally done in Python/R. Both of those can do a basic version of outlier removal in one line of code. 
Do you have the option of writing your code in typescript? Typescript will generate the .d.ts files for you and all the namespacing will work exactly as your code is written. 
That’s good to know, but at the moment full TypeScript is not an option. I’m trying to make a case for it though and wanted to demonstrate some clear wins to my company.
That's how I would approach it - put complex/reusable types in external d.ts files. Can you use `/// &lt;reference path="...d.ts"/&gt;` to just include types in the files that need them?
Good idea, I’ll try that out.
I tried this once before and got it working... I think I needed a jsconfig or tsconfig file with a `files` property so the compiler wouldn't automatically grab all the .d.ts files it finds in your directory tree.
No, not that I can tell, if you want to be able to use modules you have to have some form of module loader. If you want tsc to perform the concatination and output into one file you will need require.js or system.js. It's not a big deal though to include either one of these though. 
Thanks, do you have a preference of either "require.js" or "system.js"? Most TS samples I'm finding are using "require.js".
Honestly it doesn't matter too much, probably just go with whatever is smallest especially if you're just wanting to use `tsc` on its own without an actual build process. I personally use webpack to bundle everything together and commonjs (but that isn't what you want to go for and isnt supported when using a single outFile in tsc).
You could use es6 modules. One caveat is that you have to include a '.js' file extension on all of your imports, since TS won't add it for you (see [here](https://github.com/Microsoft/TypeScript/issues/13422) and [here](https://github.com/Microsoft/TypeScript/issues/16577) for a bit more info). So for example &gt; tsconfig.json { "compilerOptions": { "target": "es2015", "module": "es2015", "outDir": "./dist" }, "include": [ "./src/**/*.ts" ] } &gt; index.html &lt;html&gt; &lt;head&gt; &lt;title&gt;Module test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="dist/index.js" type="module"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &gt; src/index.ts import { hello } from './hello.js'; hello(); &gt; src/hello.ts export function hello() { alert('Hello, world!'); }
Chrome, Firefox, Edge and Safari all have native support for modules. You can use `import/export` in your code and load your main module in your page with `&lt;script type=module&gt;`. [This blog post](https://jakearchibald.com/2017/es-modules-in-browsers/) has more details.
I think adding proper jsdoc is good practice in all cases. With a good editor such as vscode you'll get all the same type hints as you would with typescript. It's a little awkward when defining complex objects because you end up with dangling comment blocks, and I'm not sure how reusable it is, but it works. You can also check out google closure compiler, which uses the same jsdoc as typescript. It does compile time type checking and minification and can perform optimizations based on the type information declared in the jsdoc. I've never written a .d.ts file by hand, but the process sounds very tedious and redundant to me and you have to remember to keep it in sync with your code. Jsdoc lives in your code so it's much easier to remember to add/update it. If you really can't use typescript directly, I would add jsdoc before manually writing a .d.ts file. 
But why would you ever write typescript in notepad when you get some much functionality like auto complete, refactoring, quick fixes etc from ide integrations. That's like insisting on crawling everywhere when you could walk.
&gt; Chrome, Firefox, Edge and Safari all have native support for modules [caniuse says](https://caniuse.com/#feat=es6-module) they're not supported by default in firefox
why walk when you can ride
Thats pretty cool didn't realise the es6 modules had landed in browsers. To note though this is pretty shitty if you're not using http2 and have a ton of modules, right?
The problem with sticking to JSDoc only is that there are many types that are only peripheral to several modules but they are relevant in those modules and should be defined in some shared area, not in some module where it’s not obvious that that is the correct place to find them. So I was looking at `.d.ts` files as a reference point for those types, and figured if I’m using them anyway, might as well make full use of them.
You're right, it's still behind a flag. Thanks!
Trying a slightly different tack: I'm writing a library and trying to provide a typing using the 'module function' template: https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html // index.d.ts declare function add(a: number, b: number): number; export = add; // index.js module.exports = function(a, b) { return a + b; } But, VSCode is not picking up the typing for my module (I'm getting errors saying the parameters `a` and `b` are inferred to have type `any`). This is with full and strict checking turned on in the project: { "compilerOptions": { "checkJs": true, "strict": true, "noImplicitReturns": true, "noUnusedLocals": true, "noUnusedParameters": true }, "exclude": [ "nodes_modules", "**/node_modules/*" ] } Any ideas as to how to make VSCode pick up my typings?
Use nothing but namespaces and avoid all import and export statements. Use your tsconfig's "files" array to control the order of concatenation and the "out file" option to merge all files into one. The TypeScript compiler itself is written totally with namespaces and without ES6 imports or exports.
Reinventing Swagger/OpenAPI
This is the easiest way to go when turning old existing ES5 javascript code to typescript. Doesn't have to use the "files" array either, there are two other options: * Typescript compiler reads the files in alphabetical order and then travels down into subfolders. And the compiler warns if code is being used before its declared. So you can keep order that way. * If that somehow proves difficult, you can also add a [reference path](http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html) to the top of your typescript file to make sure the compiler places that file earlier in the load order. And as you mention: if typescript find the keyword "import" somewhere, or the keyword "export" without a "namespace" section around it, it turns the typescript file into a js module and will require a module loader. And while mixing modules and non-module javascript within the same project isn't impossible, I would not recommend it.
OK, for future reference, found https://github.com/Microsoft/TypeScript/issues/14342 which says that a VSCode can't actually typecheck a module using its type definitions file. Which sounds a little crazy, but OK.
Stupid question 
Stuestion. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'Stupid question'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
Link is suspended.
Holy fuck, I've never realized that this is possible. That's a huge hidden bug. I'll probably write a ts-linter rule that enforces non-undefined types to be assigned to the partial properties to prevent this.
A good lint rule would be good to prevent mistakes. It's too bad cause a proper `partial` keyword was nearly implemented (https://github.com/Microsoft/TypeScript/issues/11233) but it was decided that the mapped type alias `Partial&lt;T&gt;` was sufficient. Hopefully you can just use `Pick` and get actual compiler warnings against this error, though.
Something must be wrong with my desktop. Whatever I do, there is no error in my console and the HMR also seems to be broken. It works fine on my laptop and its a bliss!
Can you provide an example using Pick?
Sure, take a look at `setState` typings for react: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts#L286. If you're unfamiliar with `setState`, it basically is very similar to the `updatePerson` example I have above (used to update part or all of the state of a react component). It comes in two flavors (passing a part of the state to `setState` or passing a callback that takes in the previous state), but the crux is that the function shape looks roughly like `setState&lt;K extends keyof S&gt;(state: Pick&lt;S, K&gt;): void` (ignore the `| S` in the actual typings, that is just for intellisense, but adds no additional type safety). The tricky thing about Pick is that you must specify the keys its picking. You can often infer the keys if used in a function, as we do here, so you can consume them nicely (e.g. `setState({ foo: "bar", baz: "bar" })`, `K` is inferred to be `"foo" | "baz"`). But this isn't so easy if you're just trying to e.g. create an object that is a subset of another: interface Foo { bar: string; baz: string; bloop: string; } // annoying to have to specify all keys here const partOfFoo: Pick&lt;Foo, "bar" | "baz"&gt; = { bar: "hi", baz: "hi", }; I recommend playing around with `Pick` and `Partial` on the playground to learn their intricacies: https://www.typescriptlang.org/play/index.html
You just need to specify the second generic parameter explicitly. const WithGet = Gettable&lt;IUser, typeof Endpoint&gt;(Endpoint); const WithGetCreate = Createable&lt;IUser, typeof WithGet&gt;(WithGet); If you specify *any* generics, then the omitted ones will use their default values instead of using an inferred value. This means, in your case, `U` was being set to `typeof Endpoint` instead of being inferred as `typeof WithGet`. You can sidestep this limitation by splitting up the `T` and `U` generics onto separate functions. That way you explicitly specify `T` and let inference figure out `U`. function Createable&lt;T&gt;() { return function&lt;U extends Constructor&lt;Endpoint&gt; = typeof Endpoint&gt;(Base: U) { return class extends Base { ...and then invoke it with an extra set of parentheses: const WithGetCreate = Createable&lt;IUser&gt;()(WithGet);
These are often called "ambient" because they're available in the execution environment without being imported from any sort of module. Great examples of "ambient" things are TypeScript's own declarations for the `window` object, `WeakMap`, `Promise`, etc. You can check TypeScript's built-in .d.ts files to see how these are written.
Thank you for this explanation. I wasn't aware that `setState` is already using `Pick`. The only thing to dislike about this is the second generic argument, but that's unfortunately unavoidable... So verbose! I'll probably write the linter rule anyway, as I consider this a dangerous pitfall.
Don't know about Vue, but for React everything (100%) is typed and well recognized including JSX.
I've used both react and vue with TS. Vue is finicky at best. React would be the way to go. 
Typescript support was dramatically enhanced Vue 2.5 onwards. There are official types available for vue, vuex, vue-router etc. Been using Vue with TS in production at a medium sized company and it has been phenomenal. I highly recommend using [vue-class-component](https://github.com/vuejs/vue-class-component) ([vue-property-decorator](https://github.com/kaorun343/vue-property-decorator) if you wanna go the extra mile) with typescript. 
Do you know if you can typed Vue.js templates? (v-if and friends + {{}} expressions)
That depends on the editor / IDE you use. I use Webstorm as my IDE, which has full support for code assist inside vue templates (v-if, v-for), interpolation inside {{ }} etc.
vue-class-component and vue-property-decorator are great, but you still don't get static analysis of templates. vue-tsx-support takes this a step further with TSX support, but it is still not perfect as you have to provide an interface for props which is disconnected from the actual code wtihin the component. React is the way to go. Preact's performance advantage is minimal, if it even exists at all, and their TypeScript definitions are often wrong or misleading. The best way to use Preact is still via preact-compat and using the React type definitions.
Had a few apps where I just used interfaces for models returned from REST APIs. Switched to using classes and it's been amazing - love having getters and whatnot to nicely wrap up model-specific behaviors.
OK, for now, settled on this strategy: define all types in an ambient `types.d.ts` file that should be available throughout the codebase, and use JSDoc annotations on JS module contents.
It is really a division of style of programming. If you are doing stuff closer to OOP-style (e.g. persistent object each with special logic, lots of application-level singletons), class is the way to go. If you are doing stuff closer to FP-style (e.g. transformation pipelines, functional composition), interface at key locations in code is the way to go. 
Totally agree
This
You can also wrap up that functionality in classes with only static methods that take and return interface parameters (without binding them forever to specific instances)
Crap. I should have linked directly to the README. I’ll delete and repost...
I never use classes these days. Just unions, generic interfaces, and functions. It's very flexible and you don't end up with unwieldy hierarchies. You can also sort of emulate type classes. So yeah FP style I guess.
This is how we do everything in JS. A big factor in this is our using redux, but just generally you sidestep a lot of baggage and inflexibility that comes with classes and (god forbid) inheritance. I don't think we have a single non-component class defined in our codebase. You just don't need them. Ever.
Be careful with `Partial&lt;T&gt;` and prefer `Pick&lt;T&gt;` over it if you're using `strict` or `strictNullChecks`. Even when your local property does not accept `undefined` you can end up with `undefined` values using `Partial&lt;T&gt;` like this.
While I like Vue framework more than React, when it comes to TS integration, Vue is far far behind React. In Vue you have some things strongly typed, but a lot of things typed as `any` - this is because Vue uses various "hacks" to work like calling vuex methods by string, using their own object literal structure instead of classes etc. React uses standard ES6 things like classes or reducer functions which are easy to provide type for; also, React uses JSX files which are natively supported by TypeScript in form of TSX files, with stronly typed component properties, etc. React is strongly typed completely, that is stores, component code and component "templates" (render functions) - everything is typechecked. In Vue, you are working with partial typechecking instead.
Can you provide a short summary how you do it? I've seen approaches where `data: any` is taken in the constructor, and the classes properties are initialized that way.
I put a static parse method on the class that takes in a Partial&lt;MyClass&gt; obj. I then have a method that copies all the properties from that partial to the instance. If I have properties that are also classes, I parse them there as well. So for example: card.service.ts: this.http.get("card/1").toPromise().then(r =&gt; r.json()).then(Card.parse); this.http.get("card").toPromise().then(r =&gt; r.json()).then((r: Partial&lt;Card&gt;[]) =&gt; Card.parse(r)); Card.model.ts: class Card { public title: string: public date: Date; Public author: Author: Public tags: Tag[]; public static parse(data: Partial&lt;Card&gt;) { let obj = new Card(); copyProps(data, obj); obj.author = data.author ? Author.parse(data.author) : null; obj.tags = data.tags ? obj.tags.map(Tag.parse) : []; }
This is seriously great! Many thanks! Makes much more sense now. Any chance you would have advice on turning this into a reusable factory? Ideally I'd like to do something like this, but I'm tripping up on the typing: class User extends Mix&lt;IUser&gt;(Endpoint, [Gettable, Createable]) {
Not talking about IDE support but TypeScript. Are templates typed? (can they be? JSX being just JavaScript so it is typed with TypeScript)
Both prototype-based inheritance and class-based inheritance are OOP. In one case, you inherit from a definition (class), the other you inherit from an instance of object (prototype). JavaScript is not unique on this, there is a whole list you can see [here](https://en.wikipedia.org/wiki/Prototype-based_programming). 
**Prototype-based programming** Prototype-based programming is a style of object-oriented programming in which behaviour reuse (known as inheritance) is performed via a process of reusing existing objects via delegation that serve as prototypes. This model can also be known as prototypal, prototype-oriented, classless, or instance-based programming. Delegation is the language feature that supports prototype-based programming. Prototype object oriented programming uses generalized objects, which can then be cloned and extended. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/typescript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
The only major difference between what people refer to as OOP language and non-OOP language is syntactic sugar. In fact, any language that supports objects can do OOP. You can write [OOP code in C](https://www.cs.rit.edu/~ats/books/ooc.pdf)! It involves naming your functions consistently, and using "self" as first argument of those functions. In fact, it supports inheritance as well. Since ES6, there is the OOP syntactic sugar, so yes. 
If you mean type check, then no. Vue template by default isn't type checked. But you can use JSX or TSX with Vue. They have first class support for it.
Nothing in your `constants` folder is a constant. I don't really have any other feedback b/c I'm not entirely sure what you're asking, but I just noticed that.
Looks like there are 8 instances of something being typed as `any` in `src/` - that's a bunch of nails sticking out that could be hammered down. I also saw a lot of e.g. `typeof CounterListStore` which is something I haven't come across, is it a way to get around ImmutableJS annoyances? I can see some things in the usage of reselect that can be improved e.g. [selectCounterFromRoot](https://github.com/cantux/typescript-react-redux-reselect-immutablejs/blob/fe02d2ac11c01cc99f9c25c2899c975e3de9da97/src/selectors/counterList.ts#L27). First, the output of `createSelector` is already a function of `state` and `props` so you don't need to have the outer function. This would probably remove other weirdness from e.g. [selectCounter](https://github.com/cantux/typescript-react-redux-reselect-immutablejs/blob/fe02d2ac11c01cc99f9c25c2899c975e3de9da97/src/selectors/counter.ts#L7). Something like [selectCounterListFromRoot](https://github.com/cantux/typescript-react-redux-reselect-immutablejs/blob/fe02d2ac11c01cc99f9c25c2899c975e3de9da97/src/selectors/counterList.ts#L8) is exactly equal to `getCounterListFromStore` so no need to wrap it up in a selector. Unless `state.get('counterList')` is somehow slow you don't need to memoize it.
I add "readonly" to all of my interface properties. Then, TypeScript treats those types are immutable. This means I don't need ImmutableJs or classes. Reselect is still a good option. Selectors are an abstraction layer that decouples the state implementation and the react components. The memoization from Reselect can reduce the number of unnecessary react renders. 
Thought this was the name of a library. Had me scared for a few seconds.
I should name it models. Any feedback is appreciated. Thanks.
&gt; Looks like there are 8 instances of something being typed as any in src/ - that's a bunch of nails sticking out that could be hammered down. 3 of them is under the Redirector component which needs to be generic. Removed them. 2 of them was nearing getState property of mapDispatchtoProps. Removed them. Rest is under selectors. I don't want my selectors to depend on components so I don't import component prop types. &gt; I also saw a lot of e.g. typeof CounterListStore which is something I haven't come across, is it a way to get around ImmutableJS annoyances? Yeah basically. I think I figured this out back when I first fiddled with typescript. &gt; I can see some things in the usage of reselect that can be improved e.g. selectCounterFromRoot. First, the output of createSelector is already a function of state and props so you don't need to have the outer function. This would probably remove other weirdness from e.g. selectCounter. Thank you very much!! 
Personally I wouldn't write any definitions for packages that don't have them. I'd either find a different package or just use a declare var Foo: any if I *had* to use an untyped package. 
Just a heads up. Make sure you are no longer using typings and using the @types packages from npm. I find most packages have types either included or can be found in npm
Yup, I found that pretty early (and it was very confusing when I was reading about it as I did not understand when the transition from typings to @types happened). I have found lots of the libraries in @types as you mentioned before, but there has been three or four recently (as I go deeper into the rabbit hole) in which I've found myself wondering how to create the type definition and how to get it to work as expected.