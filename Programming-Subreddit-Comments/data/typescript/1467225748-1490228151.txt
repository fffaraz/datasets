Awesome. One suggestion though, those bash scripts could probably be converted to javascript/typescript and use shelljs for file system commands etc. This would make the whole thing work on Windows as well as Mac/Linux.
i dont think packages have to be named same thing so i dont see how it would be possible. its not that bad for now.
Gets better in Typescript 2.0 (available as @next) - npm install lodash @types/lodash --save
This one is very smalll and compact. It only focusing on getting things done quickly. It only compile TypeScript, show test results and do a bundle. And throws if there are errors in your code. The other one is huge comparing to this, and too many dependencies etc.
Yeah. It's a bit too much for me though. Don't understand half of the things. Gotta get the hang of it. :)
I can only speculate, but: I think that's because instead of just coming up with radically new ideas, the TypeScript developers are trying to follow what the ECMAScript development group might use in the future. Remember they're trying to be "tomorrow's JavaScript, today". The idea is convergence. And as far as ECMAScript goes, `someVar:Type` is what they used in ECMAScript 262/ES4 (which ActionScript adopted), so it might be what they use next (maybe in [ES8](https://esdiscuss.org/topic/es8-proposal-optional-static-typing)). (Ironically, ES4 was abandoned because many people, including Microsoft developers, were against it).
Thank you, but please try avoid shell scripts in builds systems, since there are a lot of developpers using windows.
Perfect! Thanks heaps :)
Atm. I'm working on a Window computer. With Github shell you get sh and can use shell scripts. But I normaly try to avoid it. Something I did in a rush for a private project. After I'm done with this project, I will probably remove the shell script.
As far as I know, npm will always use cmd as a shell on Windows, even when invoked from bash. Do you have a workaround ?
Also, I feel it cuts down the ambiguity with optional types. This way the variable is always the variable, rather than possibly the variable itself but could be the type too. 
That should be inferred from the type of `foo.bar`, I think.
I've used types for three.js, socket.io, howler.js, lodash and mithril (which just got a big overhaul recently.) I've found a few things needing fixing here and there and submitted back to DefinitelyTyped. Overall things have worked pretty well. EDIT: If you're looking for something (roughly) between Angular and jquery, take a look at mithril!
It is, as far as I know - good luck getting it to play nice with TSLint though.
 let foo: { bar: any } = { bar: 5 }; let {bar: baz} = &lt;{ bar: number }&gt;foo; baz // is a number Yea, that's not really much of an improvement. On the left-hand side, the ":" is used for renaming. "bar: baz" is like "bar *as* baz". It's an ES6 feature.
 const foo = {a:'foo', b:9, c:true}; type C = {a:string, b:number}; // Use type prop names const {a,b}:C = foo; // OR, rename your vars const {a:newA,b:newB}:C = foo console.log(newA); // logs 'foo' console.log(newB); // logs 9
I can't speak for other editors but in VSCode I do get an auto complete for `{ someVar }` but no suggestions on `someVar.`. That I get only when I specifically assign it a type, as in my traditional ES5 example. 
Anders Hejlsberg, creator of TypeScript, was chief architect behind Delphi, and the developer of Turbo Pascal. in Pascal you define a type as type X = &lt;type&gt;; My guess is that derives from that. Typescript bought the beauty of Object Pascal to Javascript...finally. 
Is it ready for use in production? 
This boilerplate are now compatible with Windows. Build tasks runs in parallel, and VSCode are supported. Still small and fast! 
I don't see it as beautiful, but I can clearly see your love for it. :)
Seems like a really niche subreddit, why not post the same content to /r/gamedev ?
Same discussion [here](https://www.reddit.com/r/gamedev/comments/4qqmpy/new_typescript_gamedev_subreddit/d4vcud4)
Yes, but I'm getting just half way there. See my reply to the other comment: http://reddit.com/r/typescript/comments/4qmf37/typing_a_destructured_assignment/d4usr1d. 
http://i.imgur.com/z90Ia7H.png
no nulls has been a dream. I've caught so many could-be issues.
It's kind of sad because i rooted strongly for ts over dart
It's getting better with typescript 2 having first class support for npm installed typings. Angular2 has started to use it already, but the recommendation is to not make the full switch just yet. It will solve all the versioning bs that we have to deal with now as it will just be straight forward npm versioning See https://www.npmjs.com/~types for currently available npm types and https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/ for the announcement article
I'm not sure I follow.. if you hate typings/definitelytyped, just don't use them? It's not even part of the typescript language... just a convenience. There's still a ton of value in typescript even if you're just statically typing own code. I also don't understand how using Dart will suddenly fix the 3rd party type definition issue? Does Dart have better 3rd party type definitions than Typescript?
[removed]
Don't recall saying i hated dt. Typings are a part of the language. They have not been a convenience. I clearly don't doubt the value of ts, I've been rooting for it. As far as dart goes, I'll leave that one for you ðŸ˜š
Typings (the project) definitely broke my build a few times for what seemed like trivial reasons, mostly just moving the files around. That said, this is what you should expect from a 0.x project. Now that it's in 1.x, I expect things to calm down a little.
Would like to hear some more specific use cases where you are having problems. I've been using TypeScript since 0.8 when it was much more buggy and I personally find having types the best thing about it. Makes building large code base so much more productive. And the best part of it is if some third party library does not work well with TypeScript or some type definitions are out of date you don't have to use them. It's not like you have to forcefully have your code base 100% covered with types. And if your build gets broken due to some incompatibilities you can always cast your broken method call to "any" type and have the compiler ignore that part.
Simplest example here is the following with standard JS (ES3/5): var $this = this; var anonymousFunction = function () { $this.callSomethingInOuterScope(); } In TS you can do it automatically without having to assign outer scope "this" to a variable in order to access the outer scope inside the function scope: let anonymousFunction () =&gt; this.callSomethingInOuterScope(); If you check the compiled TS then it does the same thing automatically for you, that is binding outer scope to a variable that is used instead of pure "this" keyword inside a function. And in case you need "this" keyword to be bound to function scope in TS you can use the old JS syntax. 
Thanks a a lot!
I do the opposite: the first thing I do when starting a Typescript project is enabling all the stricter flags (`--noImplicitAny`, `--noImplicitReturns` and the new `--strictNullChecks` and `--noImplicitThis` of the nightlies). Sure, it's going to be harder to make your code compile, but you're also going to limit a lot the time you're going to waste debugging, while making your code as clear as possible for anyone that would read it. `--noImplicitAny` is extremely powerful, since it forces you to type everything that can't be inferred, and you can't imagine how much things could go wrong with something you thought was typed but wasn't. And you will feel bad about annoting `any` instead. The same can be said with `--strictNullChecks`, and that one is even worse because it will force you to write additional code as a safe guard. I'd say the "lesser" options are here to make easy the adoption, for beginners as well as for migrations of existing projects. But if you use Typescript in a somewhat controlled environment with some experience, you should go the strict route.
Why would to you need to do more class stuff with typescript? Interfaces are structural (as opposed to nominal) and they can describe any JavaScript object you can imagine. Adding types absolutely doesn't mean you have to change the way you code (it probably will discourage you from doing too much dynamic stuff though). 
I'll give it some more thought. There's so much happening in my life, and so much missing, that I'm not even sure it's wise for me to be doing this for now. Like i said, maybe I'm just a bit frustrated with the community. I'm trying to get my shit together. I don't think i should be the one trying to speak up. I apologize if my words stirred up too much commotion. 
no
https://github.com/Microsoft/TypeScript/issues/5039#baseUrl
Open a cmd prompt and tsc -v. Make sure the paths are correct.
The compiler is built in. I've still got an old 1.4 compiler on the command line, but vscode has its own version somehow.
Thanks. It doesn't clarify one thing: why the vscode compiler doesn't include these things by default. I did set target to various values, including es6, and it just didn't work. I have included lib.es6.d.ts, and there are no duplicates, but it works, so thanks!
To be accurate, there is no such thing as the "VSCode compiler": it's the Typescript service that does all the magic (the `tsserver.js` file in the `typescript/lib` folder is the thing VSCode will get in the folder set by `typescript.tsdk`). But it would surprise me that Typescript won't know how to include the library by default with the correct target. Maybe it's because 1.4 is a rather old version that came around before ES2015 properly got standardised. In any case you should try to update to the most recent version (if you can), I don't think there's any breaking change since then (at worst you'll need to put an additional compiler flag). 
&gt; typescript.tsdk I've now installed typescript 1.8 globally, set the target to es2015, and pointed typescript.tsdk to the directory where npm installed the library, and I may be damned, but vscode still gives an error on "Map", whereas running "tsc -t es2015" on the same file doesn't. Should I report a bug to the vscode team?
Are you building with VSCode or are you using gulp? (I'm guessing just using VSCode)
This looks really cool. I'm curious as to why `validate` returns a promise.
Ah, makes sense.
Haven't tried building yet. I've resolved the errors with (yes) emacs and a Makefile; building with vscode is up next.
I just realized (again I don't use vs code for javascript development as web storm really is the premiere tool) you should have a tasks.json file. Set the command to point to your compiler. You shouldn't even need to muck with the settings files. I actually knew this from a while back when vs code first came out but this article reminded me: https://code.visualstudio.com/Docs/languages/typescript I had similar issues because the visual studio updates were not updating the path for tsc.exe that gets installed with it and the command line was using THAT. Let me know how it works for you.
Here is the solution I just got working (my sample project is callled 'VSCodeExample'. Create \ modify the task in the tasks.json to look like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "0.1.0", "command": "node", "isShellCommand": true, "args": ["..\\VSCodeExample\\node_modules\\typescript\\bin\\tsc", "-p", "."], "showOutput": "silent", "problemMatcher": "$tsc" } And voila everything works as expected. Sorry about the formatting.
The next step was i was going to just send you my sample project that works.
The sheer number of changes in this release is mind boggling. So many big features were implemented this month, it's kinda crazy.
If you use VS Code and do not see "2.0.0-dev..." in the lower right corner, you've to set the "typescript.tsdk" property to the right directory. https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions /u/GoSubRoutine's example works fine for me in the playground and VS Code.
wow!... i didn't know about the multiple terminal windows. 
Perhaps you should take a look at our documentation on using TypeScript with Gulp and Browserify: https://www.typescriptlang.org/docs/handbook/gulp.html If you want to use ts-loader, we have a guide on React &amp; Webpack at https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html, where it's easy enough to drop React if you're not using it.
I've got some success with rollupjs and the rollup-stream module that can be used with gulp. But so far I've not managed to get proper incremental builds going so it can be slow...
Been using hotkeys on everything that has them since 1990. Ppl who do stuff with mouse are so much slower. Aside that, I find working with tabs more intuitive. Plus the patch fixed one big issue (for me) that when you close a file, it did not switch to the file opened or swtiched to before that, so you would just stare at a blank screen.
Of course it's bloody generators, one of the main things I'm looking forward to. I'm pretty sure these are dependent on something scheduled for TS2.1 too (the emitter), so I wouldn't be surprised if these were delayed. Hopefully not...
Also really cool that they released the monaco editor on npm.
Really looking forward to refactoring our codebase to use async-await from callbacks.
I'm so hot for this.
I've not tried it, but I'm assuming you could still use them targeting ES6 then use Babel after, right? Many of us have been doing that to get async/await, and I'd imagine it works for generators too.
I've been working on a node v6 app in typescript which means I can target es6 and use async await. I was pretty on the fence about async await at first, i thought promises were good enough, but I'm so glad I learned to use async await. I had to do some recursive async stuff and the promise solution is ugly but the async await solution is straight forward as can be.
[Here's a tip from @piotrwitek on GitHub](https://github.com/Microsoft/TypeScript/issues/1564#issuecomment-220025449) if you use Babel only for `async`/`await`: TypeScript will complain about using `async`/`await` when targeting ES5, but it will still output valid code (although it uses generators)! That means that you can have TypeScript emit "ES5 with generators", and then have babel or regenerator transform *just* the generators to produce ES5 output. Babel won't see any classes, `let`, `const` or other ES6 constructs, since TypeScript already generated human-readable ES5 for those. It's a bit of a hack, for example [it only works](http://www.typescriptlang.org/play/index.html#src=async%20function%20foo(%29%20%7B%0A%09await%20Promise.resolve(%22foo%22%29%3B%0A%7D) with `async`/`await`. Regular generators in your TypeScript code [don't seem to work](http://www.typescriptlang.org/play/index.html#src=function*%20foo(%29%20%7B%0A%09yield%20%22bar%22%3B%0A%7D), TypeScript always outputs `function` rather than `function*` for ES5...
babel-plugin-typecheck inject runtime type checks, which in my opinion are really helpful. As you said contract support is not added yet. If there is really no plugin system I move more effort in it and create custom hooks.
typescriptlang.org has a bunch of really good articles on setting up your favorite build/bundler tool and typescript.
I refactored our codebase to be typescript 2.0 compatible last month (using the dev build) and holy crap strictNullCheck is a goddamn life saver. I've caught so many potential issues and bugs. Yeah, it's a bit more work but the code you write is 1000x better
thats great info, i'm curious to know what difficulties did you find, is the compiler stable / buggy or its better to wait for final ? Do you think its mostly production ready for those not using generators ? There aren't many Typescript 2 testimonials out there, thanks for sharing any info on how it went and if you advise start using it now.
The standard seems to be like: import Foo { fooFunc1, fooFunc2, fooObj } from "./foo" Foo is the default export and everything inside the {} are additional exports
Hello /r/typescript, over the past year i have fallen in love with two things, typescript and vuejs. However, due to vue's component declaration system, there was no way to write vue components while still keeping all the features that make typescript awesome (intellisense, compile-time type checking, etc...). There were a few basic workarounds to make class style components possible, however they didn't embrace the features that make typescript awesome, and more importantly, forced you to cast as &lt;any&gt; constantly. This is why i built vue-typescript, it lets you to write components as perfectly standard typescript classes which allows your IDE to provide accurate intellisense and the typescript compiler to do it's job like you would expect it to. So if you want something lighter and easier to set up than angular 2 while arguably providing very similar functionality, but don't feel like giving up typescript, give this a try. The project is still fairly young, and i plan on adding multiple additional features, namely intefaces for Vue directives as well as filters. All criticism and comments are welcome, and if you would be interested in contributing, i'm open to that as well.
Thanks! Yeah, it was pretty cool to see it in action (and work properly) this morning! I'll have to check out Telegram - I've never heard of it. I've been wanting to use Twilio for a while; just haven't had a reasonable use case until now!
Thank you for this, this is awesome
postponing async/await and generators support for ES5/ES3 until 2.1 release. darns.
Do I understand it correctly, that with --strictNullChecks on everything is non-nullable by default? Because that will make migrating large, older codebases rather painful.
There was talk of using a question mark to indicate that a type is nullable. For example, `var foo: number?;` can store a number or `null` or `undefined`. Is that still possible? EDIT: Answered my own question. No, the question mark isn't valid syntax. I imagine I'll be using a shorthand like the following: type none = null | undefined; var foo: number|none; foo = null; foo = 123;
We considered a question mark, but there's no way to satisfy people using *only* `null`, *only* `undefined`, or both, without confusing the other groups. We felt it was better to be explicit than to ship something that's not obviously appropriate.
&gt;a bit of work If only. We've got nearly 1M SLOC of TypeScript across thousands of files :(
Makes sense. If there's one thing I *don't* like about the JS ecosystem, it's APIs that try to cram in too much syntax sugar and magic, and end up being ambiguous, and full of corner cases. In that spirit, I agree it is better to be a bit more verbose and a lot more explicit and predictable.
I haven't used TS 2.0 yet. I'm wondering if there are any issues using strictNullChecks with older definitions having no distinction between nullables and non-nullables. In any case it will take some work to update existing definitions and I would imagine some types may be a bit tricky to decide on.
That works when a var exists but you want one of those values. For actual members of an interface (e.g. a class property), you could do foo?:number; For optional members.
I want to say that sounds totally bad ass and lots of fun (not kidding). 
That's pretty solid. I hate that default exports can just be named whatever. 
Does that mean that, when accessed, it might be `undefined` or `number` but never `null`? But it can only be assigned a `number`?
I just tested this, and optional interface properties are indeed of type `whatever | undefined` for reading *and* writing. Here's an example: http://imgur.com/W2Z0INl `baz` is of type `Bar | undefined`. The compiler errors are: index.ts(11,1): error TS2532: Object is possibly 'undefined'. index.ts(14,1): error TS2322: Type 'null' is not assignable to type 'Bar | undefined'. Notice that you can assign `undefined` but not `null` to an optional property. EDIT: fixed capitalization and added clarification
There's at least one d3 v4 type definition in progress https://github.com/tomwanzek/d3-v4-definitelytyped No idea about jquery... but why would I need it if I have d3? ;)
I've been discussing this for quite a while with some people at work and we came up to a decision to use `Import {Foo} from â€˜./Fooâ€™` at all times and actually try to never use more than one import from a file. We came up with this by eliminating possible variations and to find the best solution to work with our tools. WebStorm/IDEA autocompletes the named exports `{Foo} from â€˜/Fooâ€™`. It cannot autocomplete default exports since you have to name them within your import statements and we consider this a huge disadvantage because you will have to write import statement itself instead of auto generating it. It may be not the case with other editors if they don't have such powerful static analysis and autocomplete but we donâ€™t consider them. Furthermore you can, obviously, have only one default export, so if you wish to export more than one entity from a file you will have one default and one/multiple named exports - this is a diversity we donâ€™t want so we stick with named exports, that way if you want to export multiple entities they will be imported the same way by the client. &gt; The third style is alright, but if I have a file for Object tools for example, with a function called 'merge' inside, it may get confusing what the merge function was referring to without diving into the definition. I think this is not the Typescript way. Typescripts makes Javasacript highly Object Oriented so it would be considerable to `{import {ObjectUtils} from â€˜./ObjectUtilsâ€™}` and use `ObjectUtils.merge` as a static method of a class or a method of an object (the implementation does not matter here). 
Also having this problem, help will be greatly appreciated !
Thanks. I'm not sure what they mean about "dynamic API calls." However, I'm fairly certain "TypeScript for the logic" just means that you should write in TypeScript instead of JavaScript. Maybe "dynamic API calls" means your app should talk to some other webservice over http? Or that your frontend should make http requests to your backend?
You definitely can. Just grab the typescript definitions for jquery. If you are using visual studio, just go to your NuGet package manager, alternatively use the bower manager.
I think "dynamic API calls" are just dynamic http requests to an API, like accessing a user profile with "http://yourapidomain.com/user/42" where 42 is the dynamic part and is controlled by the logic, which you have to write in typescript. Maybe they want you also to write the part where you make post and put requests to the API to create or edit data.
Yes, you can use any JavaScript library with TypeScript. TypeScript is basically the newest JavaScript features plus compile-time type-checking and IDE intellisense. You can use the "typings" command-line tool to install type declarations, which are .d.ts files that tell TypeScript all about the API of a JavaScript library. This allows TypeScript to confirm that you are using jQuery correctly and to show errors when you make a mistake. The biggest collection of type declarations live at DefinitelyTyped, and the "typings" tool can install from there. npm install -g typings typings init typings install --source dt --global --save jquery https://www.npmjs.com/package/typings Even when a type declaration doesn't exist for a given library, it's simple to tell TypeScript "I don't care." This means TypeScript won't do any typechecking on that library, but it also can't help catch your mistakes.
something like (function (root, factory) { 'use strict'; // commonjs else if (typeof exports === 'object' &amp;&amp; typeof exports.nodeName !== 'string') { factory(exports); } // browser globals else { factory(root); } }(this, function (exports) { // ...code exports.mylib = {} }
Yeah, I'll likely end up doing that. But for simplicity and time's sake I just used npm scripts.
I've been working with TypeScript for close to a year and I still don't get how to manage typings. I fumble my way through it until it works and come back to the docs every few weeks to see if I can truly understand it, but with not much luck. I don't know if that's a red flag for me or for typings. Anyway... You need to do a few things. Somewhere you need to include a reference to these typings, like at the top of your app's entry point (e.g. main.ts): /// &lt;reference path="./typings/index.d.ts" /&gt; You'll still get errors because the Request module references some types that come from Node.js so you need to install typings for that too: typings install --save --global dt~node Hope this helps.
Do you have a tsconfig.json? If not, check this out: https://www.typescriptlang.org/docs/handbook/tsconfig-json.html It's possible the compiler isn't seeing your typings folder. You can fix this by having a tsconfig.json that is configured to include the typings folder as a src location. Take a look at the link I posted above for some examples. 
I would also like to have some info on this, specifically on what is the correct way to add my own type definitions to a project that does not have any. 
I think the best way for this would be to use the `typeRoots` option and point it to a local `./types folder`, in addition to `node_modules/@types`. For some reason the typeRoots option does not seem to work though, so I have a postinstall script that links types from my `./types` folder to `node_modules/@types`. See these links for more information: &lt;https://github.com/Microsoft/TypeScript/issues/9184&gt; &lt;https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/&gt; 
You need to add the top level typings file to your tsconfig.json. [Example](https://github.com/lukeautry/tsoa-example/blob/master/tsconfig.json) You can also reference it via a triple slash reference as another posted pointed out, but I think the tsconfig.json approach is much cleaner. There may also come a time when you need to create some custom typings - for instance, if a library doesn't have any type definitions. Normally, what I'll do in that situation is create an ambient.d.ts file, create/reference custom type definitions, triple slash reference typings/index.d.ts, and then add ambient.d.ts to "files" in tsconfig.json.
use Typescript 2.0 by `npm install -g typescript@next` then `npm install @types/request` on .ts(x) file `import * as request from 'request'` You will have all the type completion, otherwise, one important thing about typescript is, to learn to write the module declaration on your own.
I agree completely.
It's worth mentioning be that typescript supports non nullable types now
I don't think the article is very fair in saying that ImmutableJS is written in TypeScript. It's not. It just has typings written, similar to nearly everything in DefinitelyTyped/the typings repository. I am becoming much more of a fan of TypeScript now that there's a wildcard module definition, which makes interop with webpack *so* much easier. `--strictNullChecks` is awesome as well.
You can use `import * as foo from './foo'` to access CommonJS modules - `foo` will be what was assigned to `module.exports`. I prefer to avoid `import foo = require(...)` because you end up with lots of different types of imports.
Okay, this seems to work just fine. thank you! Could you please explain how it works? it looks a bit complicated, like a hack of sorts in a way... It looks a bit like hashmap declaration looked for me from start, i.e. the dictionary: {[id:string]:number}; but please help me understand why this does what i want :)
I've thought of something similar. Maybe i'll play around with this idea a bit later and see if it fits my needs :) thanks for your replies!
I, for one, welcome our new TypeScript overlords. 
Decorators are executed only once when the class is first created. An instance of the class isn't created. I suggest that your decorators somehow attach metadata to the class, it's methods, or the class's prototype object. When you later construct an instance of that class, you somehow look at that metadata and register Action listeners appropriately. Perhaps you call a helper function from within Store's constructor? I'm not familiar with reflux terminology so this generic answer is the best I can do.
Looks like your rant is targeted at javascript ecosystem, not the typescript language. Well, web development is all over the place, that's true. TypeScript doesn't solve that, but it's not made to solve ecosystem's problems, rather it's made to solve some of JavaScript's problems, which it does solve nicely.
True I guess. Every step to implement a solution to one problem brings a bunch of new steps to do it "right" and it's gotten into a real mess.
try webpack.
Two things. First, every piece of new technology feels weird at first, if you're used to what it's trying to do. To the point where it's easier to get defensive and say "wait a minute, this sucks". Personally this is how I felt with a lot of new tech over the years. I remember being very against specific techologies. I hated the mouse. I've ranted against XML, then against JSON, them against React. I said editing documents online was a joke and would never be a thing. And yet here we are. Experience has taught me than in the vast majority of cases, once one learns to use that technology well, this feeling becomes a thing of the past. More often, that new technology becomes something you cannot live without, and you wonder how you ever managed to work without it. Second. Yes, there's a steep curve when implementing TypeScript in a project because it requires building steps. Webpack? Grunt? Browserify? Etc But you know what? Modern JavaScript itself needs that. That's the way web development is moving towards. It's inevitable. And once you have a build flow, adding typescript to the mix is trivial. Finally, my advice with TypeScript (and any other piece of technology really) is to keep it an open mind. Give it some time. Give it a fair chance because it's more likely you lack the perspective to judge it well. We're always biased by what we know, and we have expectations that might be tainted by what we assume are universal values. Worst case, you'll learn a lot. Best case, you'll adopt something that'll make you a better developer.
The only reason to use a mouse really is for the Web, since there is slim to none sites that is possible to navigate without it. 
I got exposed to Webpack recently, it does seem quite nice for building your app. But I ran into trouble when I wanted to add unit tests into the mix. When you're only using a few classes (for the test) do you have to include requireJS or systemJS instead of Webpack?
Well, totally I hear ya. I think your pain is mostly about the vast amount of tooling required. This is a byproduct of the large-scale shift toward coding to *future* language standards rather than being constrained to the lowest standard that legacy browsers can interpret. As painful as it is, it really opens up a lot of opportunities as well. The good(?) news is that, omit the type annotations and you're pretty much writing ES6, which is definitely here to stay. So its not like a wasted effort. To get the tooling set up for you, I would suggest starting with a good quickstart like the Angular folks provide. Or this one seemed well organized: https://github.com/antonybudianto/angular2-starter
I think this sort of highlights the reason why PHP is so popular. Just FTP a file and you are off. More "convoluted" systems require things like source control, build server, deployment configuration scripts. Then you get something like modern JS/TS you need some package management. You don't want to have 100 individual files, so you need some bundling. Oh but that library uses ES6 so you need some transpiling too. You need the "convoluted" steps to get the good benefits. But they actually don't matter to a lot of jobs. Making a website for an advertising campaign that's just one single page app? Why bother with a build server or unit tests? I mean it's just a lousy few days work.
I've tried them all (I think), and didn't think it was that pleasant to use. 
I think some people here are hitting it spot on; TypeScript solves JavaScript problems, not web development problems. Coming from C#, TypeScript lets me do JavaScript without the uncertainties I'm not used to.. To me, the flexibility in JavaScript is an absolute nightmare. I don't want to have that kind of flexibility when developing some large web application, and TypeScript takes those fears away. Hell I even enabled enforced type-casting in the TypeScript compiler (meaning every variable I declare anywhere _must_ have an explicit type) and it made my brain get to grips with this definition of web development even faster. Also yes, TypeScript lacks in some areas due to how new it is, but hey 2.0 Beta is here. Have a look at those changes.. :-)
&gt; Do people actually hate learning and writing JS so much they would rather jump through flaming hoops on one leg to get it to work in a browser? No. I don't think any part of that question has anything to do with why anyone uses TypeScript, for one very simple reason: TS includes practically all of JS, including almost all the new features added in the last few years, and aims to add all of them eventually. If someone suffered from a hatred of JS, then TS would be just about the worst choice they could make, because it contains not only all of JS, exactly as usual, but also in addition a static type system that has been carefully designed to support common patterns in JS usage, i.e. a totally JS-centric static type system, quite different from the type systems in most other mainstream languages (in many ways much more powerful). As someone who found JS surprisingly great when I first tried it seriously, and then built pretty substantial apps with it over the years, I never hated JS, but I did often think to myself, when I was writing comments that described what "shape" of object my functions accepted, "One day if I have time I should write some kind of tool that validates my code based on the info in these comments". And then a couple of years later, TS was announced and I never had to write that tool! Instead of type-laden comments, I just write type annotations. With only a few trivial exceptions, TS's ONLY differentiator from JS is its static type system. That is the *only* thing it adds. It happens to be phenomenally wonderful thing! But that's it. Nothing else you are finding confusing about it is unique to TS. I haven't used Angular since I took a look at Angular 1 and then backed out of the room quietly and left them to it... I know Angular 2 is a complete rewrite but on that basis I half suspect Angular 3 to be another complete rewrite. It's good that they're using TS, but it's quite possible that the complexity of Angular is the source of your angst. In which case you may find it easier to learn TS if you take some old familiar JS project of your own and try converting it to use TS.
Webpack is even more overly complicated. A lot of weird (to me) illogical configuration going on.
&gt; Also yes, TypeScript lacks in some areas due to how new it is, I'm nitpicking here, but do you really consider a web development tool released 4 years ago to be new?
&gt; Do people actually hate learning and writing JS so much they would rather jump through flaming hoops on one leg to get it to work in a browser? This makes no sense. No one uses typescript to avoid learning javascript. Typescript *adds* stuff to javascript. To learn typescript, you first have to learn javascript, and then learn some more stuff.
Valid javascript is valid typescript. Typescript gives you a lot more on top of it. The initial setup is a little more work but in the end I find the initial troubles outweigh the other troubles down the line. I prefer web storm as my ide which has excellent typescript support like placing your breakpoints in typescript files. I'll recommend sticking with it as you will most likely find it to be an indispensable tool for catching problems early on.
Is it really a web development tool? It's a type system, a typechecker, a transpiler, a language service that handles refactoring and IntelliSense. It's language stuff, not web stuff. All the mile-a-minute, wild-west churn in the web dev landscape isn't a good thing, and thoughtfully-designed tools like TypeScript are a breath of fresh air. Given that TypeScript is such a big undertaking, it can still be "new" 4 years in.
Tools are designed serve human, not the other way around. It is part of the job of a software engineer to choose the right tool. You need to ask yourself some questions before adopting any tool. Here are some that might be relevant to this discussion: * How big is your code base? * Is it just one file? (e.g. gulpfile) * How often do you start from scratch? * Do you work with others? * Do they have the same programming style? * Can you actually communicate with them? * Do you diagram out stuff before coding? * How much do you rely on manual testing? * How much do you rely on automated testing? * Do you write type guards (`if (typeof x == 'number')`)? * Do you use a relational database? or noSQL? * How do you refactor code? 
If you're coming from writing ES3/ES5 JavaScript to TypeScript, then yes, there is a learning curve and the syntax is going to seem weird. A few things to keep in mind: - Most of the weird syntax is actually just ES6. Arrow functions, classes, const, let...all ES6 - Almost everything that TypeScript adds on top of that is for the purpose of static typing If you have a js/php background, then you probably haven't yet experienced the beauty of static typing, but for me personally, I find it so valuable that it's non-negotiable for projects of any complexity. Also, I think it's unfortunate that a lot of folks are being exposed to TypeScript through Angular2. Angular2 is, uh...well, it's very complex and has a very steep learning curve. Most of that has nothing to do with TypeScript itself, but rather with the set of abstractions the Angular team chose to stick with.
Hello, I'm the creator of [vue-typescript](https://github.com/itsFrank/vue-typescript) what I did, is that I transpiled everything into es5 in the 'lib' directory with type des and sourcemaps, pointed main in package.json to the transpiled index.js, if it's typescript, make sure to point 'typings' in package.json to index.d.ts. I however left all my ts in 'src' and made sure to include typings.json and leave all of my npm build scripts in package.json in case my users want to make some modifications to the source. All they need to do is run `npm install` (with typings install as the post install script) make their changes, and then `npm run build` You can check the repo for a real example [This](https://medium.com/@mweststrate/how-to-create-strongly-typed-npm-modules-1e1bda23a7f4#.h2x37wk30) is a good article on the subject 
Additionally, if users want to debug with sourcemaps, their debugger will need access to the `.ts` source code. If `--inlineSources`is true, it's embedded in the sourcemaps, otherwise you'll need to distribute the `.ts` files.
I found it. It's called `jsnext:main`.
I haven't looked at it recently, but there's an example producer and consumer at https://github.com/basarat/ts-npm-module and https://github.com/basarat/ts-npm-module-consume
We have recently upgraded our Dev Environments from VS 2013 to 2015. However we haven't yet updated TS to 1.8 (We are near a release and want to keep things stable) I have to rebuild my local dev environment ... and went straight for VS 2015 However Typrescript 1.4 is not included in VS 2015 install To I downloaded Typescript for 2013 and have had this issue since. I have even gone to the trouble of intstalling VS 2013 
Still not enough info. Is it dying on some particular line of code or is there more to the error? BTW, these two statements are at odds with each other: &gt; We have recently upgraded our Dev Environments &gt; We are near a release and want to keep things stable
Thanks for the reply pe8ter! I know about Dev environments ... Long story! :) Have check the following ... The project file is defo looking for 1.4 &lt;TypeScriptToolsVersion&gt;1.4&lt;/TypeScriptToolsVersion&gt; &lt;TypeScriptGeneratesDeclarations&gt;False&lt;/TypeScriptGeneratesDeclarations&gt; Build (or even Clean) is giving the following error: C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v14.0\TypeScript\Microsoft.TypeScript.targets(103,5): error MSB6006: "tsc.exe" exited with code 1. I have 3 sdks installed for Tysescript: 1.0 1.4 1.8 (Getting the same error in VS 2013 btw)
I sure did .. again and again ... unfortunately that error message is very generic
I think you are right wkoorts on the nit-picking, I just want to add that support for TypeScript virtually skyrocketed the past year since the announcement was made that Angular 2 was going to be made in TypeScript. For me, that makes it difficult to blame the lack of maturity when the project was probably quite low-budgeted until the Angular 2 bomb dropped.
That filepath is a local one and just looks locally to my script launch point. I could get around it I suppose by putting local installations in every project, but I was trying to get it to use the global ones. In the learning phase I'm going to be making a ton of little test projects so that would get very confusing. IDE is Sublime Text 3. 
&gt; ///&lt;reference path="../typings/restify.d.ts"/&gt; I haven't had to add reference paths to my .ts files in a LONG time. Just make sure they're in your compilation path in tsconfig.json and you should be good.
&gt;My ideal scenario would be for an end user to do something like `npm install --save my-library` and never have to worry about typings or module resolution. You can look at this [small library](https://github.com/localvoid/perf-monitor) as an example. It builds umd module, so it can be used with cjs bundlers, or from [npmcdn](https://npmcdn.com/), es6 module for rollup, typings for typescript.
Right, so when using Typings you can't pretend it's a node thing, you have to install and specify local file paths? In which case the best solution to my making fiddles would be to create the structure and zip it so I can clone it easily. Any advice on setting up a project structure for Tpyescript? Never done anything properly that didn't involve an IDE doing it for me, so steep learning curves all around.
I've uploaded the project to Github. Link in the updated description.
&gt; Due to the asynch nature, there is no "this" so functions cant be called as class members but have to be called as static functions. Correct, the `this` context will be lost if you try to pass a class method as a callback directly: this.addAsync(123, 456, this.handleAddResult); This is because the code *calling* your function determines the `this` context of your function. That doesn't mean that you can only use static functions as callbacks though! You simply need to ensure that your callback gets executed with the correct `this` context. The classic solution would be storing the correct `this` in a local variable and using that in your callback: var self = this; // store the current this context this.addAsync(123, 456, function (result) { self.handleAddResult(result); // use self variable instead of this }); Alternatively, use the function's `bind` method to create a new function with a given `this` context. This is roughly equivalent to the former solution, just using a handy helper method rather than using boilerplate code. this.addAsync(123, 456, this.handleAddResult.bind(this)); ES6 adds an additional possible solution with arrow functions. Inside an arrow function, the `this` context is determined *lexically* (by the code surrounding the function) rather than *dynamically* (by the code calling the function). When transpiling to ES5, TypeScript generates code equivalent to the classic solution. this.addAsync(123, 456, (result) =&gt; this.handleAddResult(result)); [More about this on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Lexical_this)
Also, just to be totally clear: You can't `npm install -g nodeLibrary` and then `require('nodeLibrary');` Node doesn't work that way. Always expect to install things locally: npm modules and typings. It avoids version conflicts and is just generally easier to deal with, knowing everything's local. For ideas, you can check out [my Typescript project template](https://github.com/cspotcode/ts-project-template). (disclaimer: self-promotion) It compiles ".ts" files from "src/" and puts them in "bin/". It has a "tsconfig.json" telling `typings` what typings to install. I always commit my typings to git but you don't have to. If you're making lots of small projects to learn the language, I recommend doing them all in the same project, so to speak. Just create many subdirectories within "src." That way you're not constantly copying tsconfig.json and package.json files. You can put a README.md file in each subdirectory explaining the purpose of each mini-project and push the whole thing to Github.
General tip: TS is just JS with static typing. The behaviour you're seeing is identical to what you'd get in JS. Even classes are basically identical to the old pattern of methods in prototypes. And a lot of experts avoid classes/this anyway. TS is still hugely advantageous if you take that approach. Summary: TS doesn't change how the code runs at all. It just gives you more ways to let your dev tools know what you're intending to do, so the tools becoming more intelligent assistants.
Yes, it's strongly typed, but it can still crash at run time if you request a component type that doesn't exist. That's the opposite of what you want from a strongly typed solution. A better way might be to implement a bunch of small component interfaces.
Maybe you dont need a class, maybe you just need functions. 
+1 A couple other notes: - Don't use `.bind`, you [lose type safety](https://github.com/Microsoft/TypeScript/issues/212) - Your handler function can just be a lambda instance variable on the class, allowing you to pass in the method directly and get the right `this` context, e.g. class Foo { public mainFunc(): void { this.doAsync(123, 456, this.callbackHandler); } private callbackHandler = () =&gt; { ... }; } The above also prevents the creation of many lambdas you get with the `this.doAsync(123, 456, () =&gt; this.callbackHandler())` method.
It all depends on what you want to do with the data. If you can use the returning (interfaced) objects just the way they are, then there is no need to do the extra creation of new objects. But i usually run into the wish to create functions on that object to do whatever with the data (which would otherwise be static util functions somewhere that i feed the raw objects). Creating an object with helper functions on the instance can make your code a lot cleaner. Tldr: i always stick with the raw objects from the backend (with an interface) until i want to add functionality onto them.
So if I can't use the javascript global restify, how does it access the javascript global node package? This is where I'm confused. Maybe I have a bad model of how things work? So far as I get it, *.d.ts files are the interface (C# style) for typescript to communicate to *.js ones. They don't contain any code, just make sure that the typescript communicates properly once compiled to javascript. Restify.d.ts contains declare module "restify" { import http = require('http'); import bunyan = require('bunyan'); import url = require('url'); which means that not only is the restify.d.ts required, you also need the .d.ts for the dependencies (aka node.d.ts). Where the actual javascript would therefore be irrelevant so long as the compiler can find it, which given it can find node means it's looking globally?
Instead of creating a new function each time at call time you can do the binding at compile time and create a method that is already bound to 'this' class Foo { startAddAsnc():void { this.addAsync(123,456,this.addAsync) } addAsync = (arg1:number,arg2:number) =&gt; { this.stillWorks() } } edit: oops, i see /u/ltray already pointed this out
Figured it out!! My problems, in order were: Microsoft's Sublime3 Plugin incorrectly tells you it can't find the package you've included. I'll look at whether my plugin is up to date, but for now I'm compiling from the command line using tsc. Tried it on a whim just to make sure and whaddya know... Not using the dev build of typescript. That hint was amazing and is just so much simpler. Though that may be because I'm no longer trusting the Sublime3 build error log. Still have a few things to figure out in my mind about project structure. Can you have a src directory for your code, a build directory for the compiled js, plus a lib directory to contain the node_modules + any typings that are still needed? What would be the config to set up and build something like that? Thanks for the great explanations and patience!
If Sublime keeps giving you trouble, you can check out [Visual Studio Code](https://code.visualstudio.com). (VSCode for short) It's a great IDE with great TypeScript integration. Yes, you can have a "src" directory for code and a "build" directory for compiled js. I personally configure typings to be installed into "src/typings". "node_modules" should always be installed by `npm` into "&lt;your project's root directory&gt;/node_modules". Your "package.json" stores a list of all dependencies so that anyone can install them with "npm install". Your "typings.json" stores a list of all typings so that anyone can install them with "typings install". "package.json" and "typings.json" should be in git/VCS; the "node_modules" directory should not. npm install --save restify # this will install restify into node_modules *and* add it to dependencies in your package.json typings install --save --global restify # this will install typings for restify *and* add it to dependencies in your typings.json [My TypeScript project template](https://github.com/cspotcode/ts-project-template) is a good example of everything I just talked about. It holds source code in "src", compiles js into "bin", and has a "package.json" and a "typings.json" EDIT added link to VSCode
Tweaking your type declaration seems to fix the problem: type Type&lt;I extends Interface&gt; = (arg: I) =&gt; boolean; When I make that change, the compiler shows an error on the last line. Playground link: https://www.typescriptlang.org/play/index.html#src=interface%20Interface%20%7B%0D%0A%20%20%20%20prop%3A%20string%2C%0D%0A%20%20%20%20prop2%3A%20number%0D%0A%7D%0D%0A%0D%0Atype%20Type%3CI%20extends%20Interface%3E%20%3D%20(arg%3A%20I)%20%3D%3E%20boolean%3B%0D%0A%0D%0Afunction%20f1(arg%3A%20boolean)%3A%20boolean%20%7B%0D%0A%20%20%20%20return%20arg%3B%0D%0A%7D%0D%0A%0D%0Aconst%20f2%3A%20Type%20%3D%20f1%3B) I'm only guessing, but with your code unmodified, maybe tsc is thinking that I is `any` since it never gets specified anywhere. `any` is an `Interface` and it's also a `boolean`.
Just for completeness: one small problem with this solution is that if a subclass wants to override the `callbackHandler`, it cannot call the `super` handler. This is because now `callbackHandler` is a *property* (holding a function) rather than a *method*. If your subclasses must be able to override the handler and still call the `super` implementation, you need an additional indirection: class Foo { public mainFunc(): void { this.doAsync(123, 456, this.callbackHandler); } private callbackHandler = () =&gt; this.handleCallback(); protected handleCallback() { // override me! } } You probably rarely need to do this, but I thought I'd post it just in case. :P
When you're running in node, you don't need to compile everything into a single file. Each file is a module, and modules can load each other using "require()" Google for "node CommonJS", which is the name of the module-loading standard that node uses. TypeScript lets you write ES6 modules but can compile them into the equivalent CommonJS-style code so that it'll run in node.
See the [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/type-compatibility.html), *Function Parameter Bivariance*: &gt; When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. So the question then becomes, which way is there type compatibility? If you try to assign a `boolean` to a variable of type `Interface`, it's not allowed, and nor is the reverse. But here you've said it can be any type that *extends* `Interface`. If it is possible for a type to be compatible both with `boolean` and with your `Interface`, then we have compatibility in one direction and hence under TS's bivariance rules we pretend we have compatibility in both directions. And there is such a type: `boolean &amp; Interface` (the intersection of the two types). How you'd implement such a type is beyond me! But TypeScript doesn't block out such unlikely combinations. You can tighten this up by changing `Type` to be simply: type Type = (arg: Interface) =&gt; boolean; Now an error appears at the `f2`assignment, because it is impossible for a `boolean` to be assigned to an `Interface` *or vice versa*.
The reason for the error on the last line is just that you've changed the signature of `Type` so it requires a type parameter, and the code doesn't supply one. `I` is not quite `any`, because it is constrained by `extends Interface`, but that isn't much of a constraint (see my answer).
Got it working. The nuances of it going from *.ts to *.js plus the nuances in typescript are going to keep my on my toes for a while! At least now I won't be forced to squash all my code into one disgusting file!
I assumed the OP wanted `Type` to be a generic so that they could constrain `I` elsewhere. interface FooValidator {isValid: Type&lt;Foo&gt;;}
You don't need any extra tools if you use TypeScript 2.0, you can get your typedefinition files straight from npm. 
 import {MyCustomClass} from "./path.js" This is what you are looking for. If your module only contains this one class then you can also use the default export like this export default class MyCustomClass { ... } You can even leave out the class name MyCustom class in this case, though I prefer to still name the class. Using the default import you can import it like this: import MyCustomClass from "./path.js"
Thanks, I think I get it now. I guess that if I require Type to be: type Type = &lt;I extends Interface&gt;(arg: I) =&gt; boolean; then I just need to be aware that the type-checking isn't quite as strict as I was expecting (or rather, it just works in a slightly different way than I was expecting).
Tried this, I get: error TS2305: Module '"*/RestReplyObject"' has no exported member 'RestReplyObject'. The code: class RestReplyObject{ ... } export {RestReplyObject as default}; And importing as import RestReplyObject from "./RestReplyObject"; Which interestingly is interpreted the same with or without the .js extension, and leaving it off actually stops Sublime thinking it's an error.
Havent ever seen this syntax, but if you write it like mentioned above it should work. So your module should look like this: export default class RestReplyObject { ... }
2.0 is in beta, I've tried it out and I'd say your fine to use it. Is your code hitting deployment soon or will you have some time before release? If so, I'd move to 2.0. npm -i typescript@beta will give you 2.0.0 :)
A module can "re-export" things that it imports from another module. (aka another file) There is no automatic namespace merging like in C#, but re-exporting allows you to explicitly take exports from many modules and merge them into one. // foo-library/index.ts export {Socket} from './socket'; export {Listener} from './listener'; // when someone consumes foo-library import {Socket, Listener as L} from 'foo-library'; 
Right so you can bundle them up as you go. Any problem with re declaring them? Say you have three classes than implement one, then a class to control those 3. If you 'forward' that shared class three times, will you run into problems? My gut feeling is no, because TS would simply have 3 different objects of them? Man this is going to be fun when it comes to passing pool connections out to classes and then returning them nicely. Why is it such a pain to do things properly? xD
Unfortunately that's a delicate question. You can think that ES6 modules are somewhat like c# dlls. In TS, using the namespace keyword, you can achieve something like c# namespaces. Although when referencing a namespace from a different one, you must always fully qualify them or create an alias, which is done (unfortunately) using the import keyword, NOT to be confused with import from. I don't think that the info on typescriptlang.com is outdated. It is strongly recommended not to mix modules and namespaces. Pick the one you prefer and stick to it. ES6 module pattern is probably preferred because it is becoming standard. We started with ts1.0 and our code still uses what is now called a namespace. 
I think that's pretty much the answer, pick a method and use that one. Modules do seem to be the more standard and, given that it compiles to js which doesn't care about the content of objects, you can simply design your flow around a good structure and it should work. I've now landed in the situation of not having a 2.1 compatible pg pool typedef file, so time to get researching that. Or write without a pool for now, not like I'm going to be producing production-level code for a while.
&gt; Say you have three classes than implement one, then a class to control those 3. What do you mean? Can you rephrase this sentence? &gt; If you 'forward' that shared class three times, will you run into problems? My gut feeling is no, because TS would simply have 3 different objects of them? Actually, nope, there is only one class / object / whatever, and it is accessible in multiple places. Here's an example: // foo.ts export class Foo { static name: string; } // bar.ts export {Foo as ReExportedFoo} from "./foo"; // index.ts import {Foo} from "./foo"; import {ReExportedFoo} from "./bar"; Foo.name = "I am Foo"; assert(ReExportedFoo.name === "I am Foo"); // yup! assert(Foo === ReExportedFoo); // yes again! assert(Foo.name === ReExportedFoo.name); // of course! &gt; Why is it such a pain to do things properly? xD Haha, I know the feeling, but I respectfully propose that it's not so painful; you're just learning a new language that does things differently than C#. :)
Classes A, M, N, O, and Z. M, N, and O all implement class A. Z then implements M, N and O. In C# (and PHP from what I remember), if you were running imports/includes you'd have to take care to declare once. Declaring the import multiple times would cause issues. However from what I'm (very vaguely) learning about JS, it really doesn't care *what* the class is, it's just code. The OOP-ish structure for typescript is for human readability and use more than actual compilation. Thus importing the class wouldn't cause a problem so long as multiples of that class do not exist within the same scope with the same variable name. But even then it'd probably just overwrite the variable a few times and there wouldn't be an issue? Honestly, I was happiest when I was manipulating bytes and reading in hex with C. No-one cared what was what or whether it was the same. If you wanted it to be exactly the same you could pass by reference, else you'd memcpy it. One thing I will say for C# is that the documentation was an almost perfect example of how to do it properly (at least until you got to the stupid stuff). That said, typescript seems to be evolving so fast that documentation can't keep up, and Google is having even more trouble. But isn't learning a new language always a pain? :p
I think you may be trying to hard to make a new language work exactly like the last one you've become familiar with. Read source code of real projects, follow tutorials etc. Pick up the language's own style and approach.
This part: let kernel = new Kernel(); kernel.bind&lt;UserStore&gt;(UserStore).to(UserStore); let pInject = makePropertyInjectDecorator(kernel); export { kernel, pInject }; Can be replaced with: export const pInject = new UserStore(); And then this part: @pInject(UserStore) private userStore: UserStore; can be replaced with: private userStore = pInject; It has several advantages: * It's strongly typed. Whereas in the article's code, `@pInject(UserStore)` can specify a different class to the field being injected into with no checking possible by the TS compiler. * Doesn't require a library. * It's shorter and simpler and completely obvious what's happening. This is despite it being exactly equivalent: a singleton instance of some class is bound to a name, and then that name is used elsewhere to assign the instance to a field.
If you need to ask this, you probably want to study more JavaScript before using TypeScript...
&gt; I don't think you can import a javascript file into a typescript file You can now with --allowJS set to true. Tried it today and it worked surprisingly well!
Well, this is good news, will be giving this a go soon, thank you
Redux only has one store. It's an immutable object containing the entire app state. &gt; And you can change them because JavaScript is dynamic in a static programming language it would not be possible to unit test your code. i.e. You accept this solves a problem in other languages but not JS? (Edit: to clarify, TS has all the underlying dynamic nature of JS, so objects are never of specific concrete types, which is why structural typing is so important in TS). And even besides all this, I can still provide the same capability in less code and more strongly typed, using existing language features. A set of services: const pInject = { X: new XMock(), Y: new YMock(), }; And in a component: private x: pInject.X; In both our approaches, a singleton name is queried for various named properties it owns. So mocking just requires setting up that singleton differently. In my approach they are actual named properties as understood by the compiler with strong types. In your approach type checking is bypassed, so why even use TS? 
Does this mean that each time you do a version bump, you'll have to find the new version you're planning to use and then download that particular version through DT?
Yes. It's not big improvement over just putting .d.ts files in version control Otoh, if the API didn't change, you can keep on using old .d.ts files
Currently, typings does a similar version control as npm does through package.json, so you can have version preferences there. In practice, I've been keeping both up-to-date with latest and haven't had any trouble. This is probably different if you're using an early library that is going through many breaking changes, but that hasn't been my case using major things like React, react-router, etc. In the (very near) future you'll be able to [drop typings and use npm](https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/), however. It sounds like version control will be a bit more automated.
SoundScript experiment was terminated by Google. Project of significant size can probably find a volunteer to maintain the typedefs, so I'm not terribly worried about the situation
This is an issue I've run into as well, and I haven't found any great way of dealing with it. The problem is essentially that decorators run immediately when the file is parsed rather than after all files are parsed, so references refer to something that doesn't exist.
Some of the labels are great - By Design, Canonical, Working as Intended, Awaiting More Feedback
I think my question *was* indeed confused, but you still answered it capably, thank you!
What have you tried? What's your build process?
this looks great for saving objects into session or local storage and being able to pull them back out into classes. Thanks!
Looks neat. Decorators are still experimental in TypeScript though right?
Just use `corejs` or `babel-polyfill`. Shell: `npm install babel-polyfill --save-dev` Code, once: `import 'babel-polyfill';`
It all works fine - extra backend transpilation makes no difference to your editing experience. What setup have you tried?
A d.ts file is, to me, really just used to compile typescript. It should mirror the documentation but it shouldn't BE the documentation.
That code is using ["rest properties"](https://github.com/sebmarkbage/ecmascript-rest-spread) which are an ES proposal, not an official part of ECMAScript yet, and not supported by TypeScript. I tweaked the code to work in TypeScript, using LoDash's [omit](https://lodash.com/docs#omit) and [clone](https://lodash.com/docs#clone) functions to replicate rest properties functionality. You don't need to us LoDash; you could write a simple function to do the same thing. import {omit, clone} from 'lodash'; function restProps(obj, ...omitProps) {return omit(clone(obj), omitProps);} const DateCell = (allProps) =&gt; { const {rowIndex, data, col} = allProps; const props = restProps(allProps, "rowIndex", "data", "col"); return &lt;Cell {...props}&gt; {data.getObjectAt(rowIndex)[col].toLocaleString()} &lt;/Cell&gt;; }; EDIT fixed a bug
Yeah, it would be very similar to this. Rust is the only language I know of with a first class implementation of this, although I'm not sure it plugs into compile errors as part of the compilation process. The rust compiler (as long as it is not cross compiling) can compile and execute compiled code in the same process. With JS, the execution environment would be the most difficult part about this. Depending on your target, typescript functions/classes/whatever may or may not pass a test, and that could vary all the way from Node/Browser down to individual versions of node and individual browsers. This is the majority of the reason why test runners like Selenium and Karma exist. But lets say we have: @test((assert,foo) =&gt; { assert(foo() === true); }) function foo() { return false; } What I can imagine happening is the compiler would pass the unit test + implementation to a test runner like karma with its browser plugins configured, execute the test on every plugin, and return a `Success | Error(Array&lt;Message&gt;)`, from which the compiler would generate a compile time error message. The test code would never emit to a file, but be passed directly to the test runner. Thinking about it a little more, I can imagine this being a huge undertaking which would involve some sort of compiler plugin (if that capability even exists) as well as creating a plugin for the test runner as well as test libraries which plug in to the compiler plugin as well as the test runner plugin. So maybe not so feasible. 
Does it really need to be inside the compiler? I don't think that buys us much benefit; we can just run the compiler and then immediately run the tests, right? tsc -p . run-inline-tests The result is the same, right? We get rapid feedback that the code fails the tests?
I guess it doesn't necessarily need to be in the compiler. You wouldn't be able to generate compile time errors and use options like `noEmit` to not emit code on a failed test, but that's a tradeoff that could be made. The real question is if you can create a decorator that can be elided from production code, or possibly output to a different file that inserts directly into a test runner. 
If you want to, sure.
I think outputting to a different file is asking for trouble, since the test code will almost certainly access lexically scoped imports and variables. There might be a way to get UglifyJS's dead code elimination to remove tests from the output. It has a `--pure-funcs` option for naming "pure" functions (aka functions with zero side-effects) that will be removed as long as their return value isn't used. If all the test functions are specified as "pure" then Uglify can remove them. However, if we're using decorators, then the value of the decorator is *always* being used (it gets passed into `__decorate`) so it won't be removed. // If we tell UglifyJS that `test` is pure, it will be elided. test(() =&gt; { assert((new Foo()).myMethod() === true); }); class Foo { // ... but this won't be elided because the return value is used @test(/*...*/) myMethod() {/*...*/} } Additionally, I don't think `--pure-funcs` supports marking imports as pure; it assumes they are global functions.
http://www.TypeScriptLang.org/docs/handbook/classes.html
We shouldn't use GOTOs just because it's sometimes easier and because we can.
Without digging too far into the code... In `IPipeline&lt;T&gt;`, the `process` method takes an argument. In your `Pipeline&lt;T&gt;` class it doesn't. All classes are automatically interfaces, so you may not even need the `IPipeline&lt;T&gt;` interface, although I can see why you might want to keep it. In IPipelineStep&lt;T&gt;, the process method is shadowing the generic type T. In other words, the T on line 31 is not the same as the T on line 32. That might be a problem. Classes `Pipelinestep` and `Pipelinestep2` don't need to be generic. In other words, they don't need `&lt;T extends number&gt;` or `&lt;T extends string&gt;`. That's not causing your problem, but it's worth point out, because I think it will improve your understanding of generics. `Pipelinestep` looks like it always operates on strings. There's no benefit to saying it operates on "something more specific than a string." Therefore it doesn't need to be a generic. (It *does* implement a generic, but it itself is not a generic) Hope this helps!
You can use strings for generics. (in case someone else sees this and gets confused) Your original code had other problems that were preventing it from working as you expected.
Yeah I never used generics before, figured this would be a good case to finally use them. Would you be so kind and show me how I can use the above example with string,... aka without wrapping it with IPipelineObject&lt;A&gt;? thx
Sure, the problem is on lines 31 and 32 of [your original code](http://pastebin.com/KMBSLRUC). interface IPipelineStep&lt;T&gt; { process&lt;T&gt;(arg: T): T; } The compiler is seeing two different types T. I can rename one of them to explain the problem more clearly: interface IPipelineStep&lt;T&gt; { process&lt;ArgType&gt;(arg: ArgType): ArgType; } The `process` function says that whatever type it gets as its first argument, that is the type it returns. However, that type doesn't have any relation to `T`. If `T` is `string`, `ArgType` can be `boolean` or `Promise` or `RegExp`. This solves the problem: interface IPipelineStep&lt;T&gt; { process(arg: T): T; // Get rid of the &lt;T&gt; } [Here's your code in the TypeScript Playground](http://www.typescriptlang.org/play/index.html#src=class%20Pipeline%3CT%3E%20%7B%0A%20%20%20%20data%3A%20T%3B%0A%20%20%20%20_steps%20%3D%20new%20Map%3Cstring%2C%20IPipelineStep%3CT%3E%3E(%29%3B%0A%0A%20%20%20%20constructor(data%3A%20T%29%20%7B%0A%20%20%20%20%20%20%20%20this.data%20%3D%20data%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20add(key%3A%20string%2C%20step%3A%20IPipelineStep%3CT%3E%29%20%7B%0A%20%20%20%20%20%20%20%20this._steps.set(key%2C%20step%29%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20process(%29%3A%20T%20%7B%0A%20%20%20%20%20%20%20%20this._steps.forEach((step%2C%20k%29%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20this.data%20%3D%20step.process(this.data%29%3B%0A%20%20%20%20%20%20%20%20%7D%29%3B%0A%20%20%20%20%20%20%20%20return%20this.data%3B%0A%20%20%20%20%7D%0A%7D%0A%0Ainterface%20IPipelineStep%3CT%3E%20%7B%0A%20%20%20%20process(arg%3A%20T%29%3A%20T%3B%0A%7D%0A%20%0Aclass%20Pipelinestep%20implements%20IPipelineStep%3Cstring%3E%20%7B%0A%20%20%20%20configure(%29%20%7B%7D%0A%20%20%20%20process(arg%3A%20string%29%3A%20string%20%7B%0A%20%20%20%20%20%20%20%20return%20arg%20%2B%20%22test%22%3B%0A%20%20%20%20%7D%0A%7D%0A%20%0Aclass%20Pipelinestep2%20implements%20IPipelineStep%3Cnumber%3E%20%7B%0A%20%20%20%20configure(%29%20%7B%7D%0A%20%20%20%20process(arg%3A%20number%29%3A%20number%20%7B%0A%20%20%20%20%20%20%20%20return%2043%3B%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20pipe%20%3D%20new%20Pipeline%3Cstring%3E(%22hello%20world%22%29%3B%0A%0Alet%20step%20%3D%20new%20Pipelinestep(%29%3B%0Alet%20step2%20%3D%20new%20Pipelinestep2(%29%3B%0A%0Apipe.add('test'%2C%20step%29%3B%0Apipe.add('test2'%2C%20step2%29%3B). It's showing the expected compiler error on the last line.
You can tell vscode to use another version of the typescript server for these checks in the config. I do this in this file to use a local installation of 2.0 https://github.com/doskallemaskin/onodrim/blob/master/.vscode/settings.json
Thanks!
I see. If the interface says it returns void and the implementation returns a number, it's fine. However, if it returns a string according to the interface, it actually must return a string. The implementation also can't accept a parameter with a different type. The behavior is plausible, but I'm not really sure if I like it. I guess it helps when dealing with JS code.
The behaviour is sound - the types are compatible. It is different from C#, which is more fussy and requires the coder to "help" by providing patching code to explain how two things are compatible, just because this will catch more accidental errors by forcing you to be explicit. There is one case where C# take the TS approach. If you have a delegate requiring a string argument: Action&lt;string&gt; a; You can assign it like this: a = delegate { Console.WriteLine("Whatever"); } That is, a no-args with delegate keyword is fine. But not if you use lambda syntax! TS will error if you add an extra method to your object literal, even though the type will still be compatible. It only does this in that exact case: an object literal in a position with a known type, because it's a common source of errors. This is an example of how a type checker has to be a commonsense compromise rather than merely "correct".
Combine this with an optional and disable-able contracts (pre- and post-conditions) checking system and we've got something good going on here. function foo(a: string): number { requires(a.length &gt; 0); ensures(return.value &gt;= 0); test(this("foo") === 17); test(this("") throws PreConditionError); test(this("\n") === 2); return /*... implementation ...*/; } Once you get to mocks and bigger tests, you probably need something a little more involved, but it can work. Allow tests to be defined at class/interface/file scope and allow hooks for code to run before/after any/each test in scope, etc. Can do the same thing for contracts: checks that after any method or public property change, a particular class/interface-scope post-condition holds. You could definitely build most of this with decorators, though eliding the code at build time would take some extra work (e.g. switching out the definitions of the decorators to no-ops and then letting post-build tools elide the unused test functions). I'd argue that it should be build into the language, though, as that has various other advantages; with the right contracts syntax, for example, the compiler can warn you if you violate them (e.g., if you call the `foo` above with a literal `""`). It'll also be in a far better spot to provide diagnostics on malformed conditions or tests. I'm unsure if the TS Compiler API can be used to write plugins like this yet or not (e.g., can you modify the AST or add support for new keywords or statements?)
Itâ€™s been years since I browse on the web about how to get typing jobs where I can just stay at home while earning some income. Whenever I browse I am always directed to some kind of trading sites and anything not related to any typing activity. And just yesterday upon browsing, typing jobs online, I was so lucky to find TypeAtHome.com as top of the list. 
I'm sure the point wasn't to write a fully fledge one but a simple version. Still I'm not sure where to start. Would it be to create a Tokenizer, Parser, then I could parse the AST to do type checking and semantic checking?
Sounds interesting, but I wonder why they don't make more TS-centric tutorials. There's already a million JS engines out there, and one of the advantages of working with a TS library is getting all the strict-ness that comes with it (types, etc).
Without a second thought I immediately clicked the link and register as one of the home typist at TypeAtHome.com. You will be trained so anyone will be ready to start the main assignments and get paid later. And I would suggest you try this great opportunity to work at your own pace with different positions to choose from. Register now!
How to import RxJS libs to app.ts for example?
Copy/pasting my answer from SO: You may need to target ES6 in your `tsconfig.json` file. tsconfig.json "compilerOptions": { "target": "ES6" } Or, you may need to install a polyfill that handles Promises (and more) and has typings for Typescript, like core-js. npm install typings core-js typings install â€“global â€“save dt~core-js 
It works. Thanks so much.
Aaaand its pretty valid point..... sometimes. Unfortunately for now, TypeScript does not evaluate imported .ts file if it COULD have some side effects. If you write file B.ts and write console.log( 'hello!' ) there and then create file A.ts with: import 'B.ts', resulting javascript wont shot you "hello!". This is not always good and can lead to some unexpected errors :(
Thank you, I didnt know about it!
Unfortunately `typings` changes how it works quite regularly. So I just grab the necessary files from `DefinitelyTyped` (hopefully this will get much better in TS 2.0). You can just just put the `.d.ts` files anywhere in your project directory (the directory containing `tsconfig.json`). In this case, you need these three others: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/webrtc/MediaStream.d.ts https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/filesystem/filesystem.d.ts https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/filewriter/filewriter.d.ts
I just started a new project with TypeScript 2.0 beta. In TS2, they've settled on npm install @types/package which is a nice and easy way to go. My experience with TS has been less than flawless, but I don't want to go back to not using it either :)
2.0 looks way easier! I just tried: npm install @types/express --save And by just following the dependencies it automatically got me all the required definitions: â””â”€â”¬ @types/express@4.0.30 â”œâ”€â”¬ @types/express-serve-static-core@4.0.31 â”‚ â””â”€â”€ @types/node@6.0.33 â””â”€â”¬ @types/serve-static@1.7.28 â””â”€â”€ @types/mime@0.0.28 So basically OP's problem is solved in 2.0.
One idea might be to take advantage of TS's support for JSX in the view rendering. You just need to supply an implementation of `React.createElement`.
Yeah, interesting idea! I'll look Into that :)
I don't know about canonical, but I have a working example with some of my libraries. Look at mfgames-contracts, mfgames-writing-liquid, and mfgames-writing-clean for a three package chain. That is how I got it working. 
This is nice, but it has nothing to do with TypeScript, has it? **Edit** Try /r/rwebdesign or similar subs.
I implemented rudimentary support for JSX. It works really good. Thanks for the suggestion! :)
You can use the regular DOM APIs and you can also use jQuery. Get the d.ts file for jQuery to get auto-complete and type-checking. http://microsoft.github.io/TypeSearch/ + jquery = https://www.npmjs.com/package/@types/jquery
TypeScript must be compiled to JavaScript, and using JavaScript, you can manipulate any browser API's as you normally would.
https://developer.Mozilla.org/en-US/docs/Web/JavaScript https://developer.Mozilla.org/en-US/docs/Web/API https://developer.Mozilla.org/en-US/docs/Web/Events 
Why don't you want to do an import? Node will only load it once.
Digging deeper it seems like it may be handled okay? https://github.com/DefinitelyTyped/DefinitelyTyped/commit/568ec4378d010bb901a61bd9686be49077e54d5f Looks like a script or find and replace was run to automatically update packages to the prior tagged release. I still don't know why the new version isn't a tag. It seems confusing. Also that commit didn't fix everything because `karma` actually depends on v3 of bluebird. You won't get compile errors but now if someone goes to hack on the Karma types, it looks like it has a dependency on bluebird 2 unless you check npm. I'm not trying to shit on anyone's work, genuinely trying to understand how bad these problems plague you guys.
I've had to pull specific GitHub URLs with Typings before because it will pull the wrong version from DefinitelyTyped. lodash is a good example - it pulls v3 by default when v4 is what I always want. Typings is too confusing for humans, IMO. Global modules? Ambient? Local? Environment? I have to provide these flags, but it already knows what it wants and complains if you do it wrong. Why not just fix it for me?
I use `typings` to install definition files. It's much more like npm, and references the commit hash in the `typings.json` in case I want to make any changes to the definitions in a my own fork.
I'm having trouble getting this working with Typescript 2.0's @types/react definitions. Doesn't seem to override properly and styleName remains invalid. Anybody have any luck?
Second this... DefinitelyTyped is old hat. Try typings it's much better. Still, not all things have good typings support or update them in the same cadence (often someone else makes the d.ts). I think it'll get better the more popular TypeScript gets, but for now it's the cost of using it. Sometimes you'll have to find specific d.ts versions or even manually modify them to make them work.
Personally, I'd prefer something closer to what's in Haskell or some MLs, except tweaked to accommodate the fact that automatic currying is not present in Javascript. Something like: `type CompareFunction = (number, number) =&gt; boolean` We're close, except that today you *have* to assign names to the parameters even in the type declaration, which is odd.
Honestly, all of this is made much simpler with TypeScript 2.0, which can already be used today. This is how types are managed in a TS 2.0 project: https://github.com/lukeautry/tsoa/blob/master/package.json#L31 It really is that easy. 
Turns out Typings is old hat too https://www.reddit.com/r/typescript/comments/4y7x2o/how_do_typescript_users_and_the_community_deal/d6mnw5w
I really only use the type keyword for naming stringly typed things. type Options = 'yes' | 'no';
I figured it out. `S` extends `CatState`, meaning it might be something more specific than `CatState`. Therefore a `CatState` is not necessarily an `S`, and the assignment raises a type error. Adding a type assertion eliminates the error.
It is referenced/used :/
You can also write it this way: type CompareFunction = { (a: number, b: number): boolean }; 
Very interesting, have you seen the [Ubiquits framework](http://ubiquits.com) - it has many of the same goals, built on the strong dependency injection pattern of Angular 2
I have seen it and I think it's pretty neat. I think tsoa is a lighter weight option that doesn't tie itself to any particular front-end framework, or even a front-end framework at all; it could easily be used as a microservice framework.
Yep agreed, it's always great to have different-weight options for different project scales. One minor clarification - while Ubiquits is built on Angular 2, it is just the core dependency injector that is used, so it isn't technically tied to a front-end framework as the DI is platform agnostic (and a separate npm package). Nice work with TSOA, I'm hoping the Node.js community gets on board with typescript to the degree that the Angular community has
Handy; I've seen overloads in .d.ts files, but it didn't occur to me to use them above the function definition
I would only do this in type definitions of external code. For first-party code, it is better to just do: * `reverseString` * `reverseArray` Overload would fail when the argument is `any` type (e.g. result of JSON.stringify). So for first-party code, why go through of overloading/ambiguity when you don't have to. 
You're right. I over-simplified my example. In my project I'm assigning an object literal to `state`, and in that case, typing it as `CatState` is necessary to avoid a type error. let state: S = {declawed: true}; // type error: object literal is not assignable to S
You misunderstood my comment. const input = someFuncReturnAny(); // stuff is (any) const result1 = reverse(input); // result1 =&gt; (string | T[]) const result2 = reverseString(input); // result2 =&gt; (string) const result3 = reverseArray(input); // result3 =&gt; (T[]) My point was why dealing with ambiguity (union type) when you don't have to. 
Oh, got it. In that case, I agree!
Not generally - only in the specific cases that default parameters can solve. There are a lot of ways a function can be overloaded.
Oh my god, that's the longest text on function overloading I've seen in 15 years!
This ain't high-quality product, and I initially wrote it for fun. But it still kinda works, and I might improve it to high-quality product(maybe).
I've actually been working on something really similar to this recently for some internal projects at the company I'm at right now that we've been trying to opensource. Curious if there was any particular reason you didn't use [swagger-tools](https://www.npmjs.com/package/swagger-tools)?
Last I checked, this starter implemented testing with webpack, karma and remap-istanbul: https://github.com/AngularClass/angular2-webpack-starter. It adds a bit of clutter, but you should be able to extract the information you need.
+1 to the other reply, and to underline it, you're much more likely to be successful using webpack (which angular-cli is moving to) and its ecosystem than browserify and its. Not that you can't get it working with browserify, but it'll be harder to find examples, existing integrations, etc., at least in my experience. Also, Angular2 is on RC5 as of a few days ago.
Webpack marks dependencies found without usage and doesnt export them. These code segments become unused variables, which are cleanud up by UglifyJS and it eliminates dead code.
Your post would be better if it was a link post with that resource as the link, just FYI. [This GitHub ticket](https://github.com/Microsoft/TypeScript/issues/3956) has some useful information.
Perhaps this is because TypeScript and Babel are by no means intended to serve the same purpose.
Is this testing TypeScript's transpiler, arguably the least important part of TypeScript? You can let TypeScript emit ES6 and then transpile that using whatever other tool you want (Babel, Traceur, whatever) That page says TypeScript doesn't support generators. In fact, it *does*. It just doesn't transpile them down to ES5. ...and they're adding that ability in a future version. See [the TypeScript roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)
&gt; Except Typescript is being marketed as a superset of es6. It is. It just doesn't compile everything to ES3/5 nor does it polyfill all the things. I compile to ES6 and polyfill nothing. Things are straightforward if you only care about the latest versions of Firefox and Chrome.
The problem is you are implicitly adding type with function that does something unrelated to types. You should type `input` in the first point. If you still want to add type with an array-reverse function, then you can just cast your input which at least makes it clear that there is a deliberate and unsafe cast: const result1 = reverse(&lt;string/T[]&gt;input); // result is typed 
You shouldn't mix concerns when you don't have to. String and Array are totally distinct concepts, just so happen that in the JS implementation, they both come with a method with the same English name. Note that `str.reverse()` creates new string, while `arr.reverse()` reverses array in place. If the intention is to call the "reverse" on arbitrary object, the function should be function reverse&lt;T extends { reverse: () =&gt; T }&gt;(obj: T): T { ... }
I would do it differently. `hidden` is not a property of the `Car`, it's just the UI state. I think it's common (in 2016) to use some sort of a local store on the client to keep your data. For example, if you're using React, think MobX or Redux. I would leave the `Car` intact, as in your very first listing, and then have a CarStore that might look like this: class CarStore { cars: Car[]; hiddenCarIds: Set&lt;number&gt;; constructor() {} hideCar = (id: number) =&gt; { this.hiddenCarIds.add(id); } showCar = (id: number) =&gt; { this.hiddenCarIds.delete(id); } get shownCars() { return this.cars.filter(car =&gt; !hiddenCarIds.has(car.id)); } } Edit: Updated shownCars to be a getter.
If you work better with classes I totally recommend MobX. It lets you write your stores exactly as in my example above. 
You're missing the point, which is: do not add types with a type-unrelated function call.
It's not a fancy term, it just means that in the example, `reverse` has nothing to do with types. It should reverse something. In the example it can reverse a string or an array, and you can write two different implementation, or one with generics. Neither solution is better or safer than the other, typewise. Now, in your example you assume that you have some JSON blob that is `any`, and that there `reverseArray` and `reverseString` would be better to have. I say No: what if you don't happen to need to reverseArray/String? Then you would have to cast explicitly. This should make it obvious that you should either 1) always be explicit about the casts you're making, instead of the cast being a "side effect" of something unrelated to adding types, or b) just type your input (the JSON blob) and avoid `any`. Generally speaking, I would also say that having types in function names is code smell - type annotations are for that. 
Maybe it's just my after-workday-tired me, but I'd welcome a lot simpler examples. Something more seizable. Like filter apples from a list of fruits or whatever. I watched a few vids on FP, but it still just don't click. Perhaps because people go about advanced stuff from the get-go. Nevertheless, +1 to you, sir.
Thanks for the feedback. I've been under the impression that what I wrote about is almost too simple to "real" FP programmers that it's hardly worth writing about. It's easy to get this impression that "everyone is doing FP" and that you're way behind. I'll gladly write up more examples. Thx, again.
I agree with most of what you say. I have different position on function naming. For any project that I would waste time typing up generics and complex interfaces, i consider the project to be intended for long-term maintenance. As such, maintainability would trump most other non-critical concerns. For best maintainability, function names should describe the context it should be used and be obvious enough that it prevents common misuses. It should definitely try to alleviate Principle of Least Astonishment. In that regard, `reverseArray` and `reverseString` is actually not explicit enough in naming. So `reverseArray` should probably be `reverseArrayInPlace` to be explicit about its behavior. And `reverseString` should be `reverseStringByCharacter` as supposed to `reverseStringByWord`. As for whether they redundantly include the type's name, that's entirely secondary. 
https://developer.mozilla.org/en/docs/Web/API/SharedWorker That would be probably the cleanest way to handle it. SharedWorkers aren't supported by Edge and Safari yet, however. http://caniuse.com/sharedworkers
Not sure that this is a "multithreaded" issue so much as it is a "race condition". Can anyone else confirm? I'm only picky about this because I don't know how two tabs could cause multithreading to occur. So I just want to get my understanding correct :)
That's hilarious. Long weekend coming up and I was planning on cooking and getting pre-nervous about how to handle the avocados :)
I'd say start with just tsc, see https://medium.com/@5fcb0d5f9b46/417d2ef0e773 
The store is really just an immutable data structure. I think a neat way to do it is to make the reducer be a method on that structure: interface PersonAction { type: "setFirstName" | "setLastName", payload: string; } class Person { constructor( public firstName: string, public lastName: string ) {} Person setFirstName(name: string) { return new Person(name, this.lastName); } Person setLastName(name: string) { return new Person(this.firstName, name); } reduce(action: PersonAction) { return (this as any)[action.type](action.payload); } } If your app is large enough to warrant it, you can split it up into sections, referred to by a "root" object, which delegates to the `reduce` methods of other objects further down the tree. Also the `reduce` method shown above, which just delegates dynamically by interpreting the action type string as a method name, is ugly boilerplate. It would be better to hide it in a framework that automatically ensures all these things are type safe. [I've been experimenting with a library that does this](https://github.com/danielearwicker/doop/blob/master/spec/DoopReduxSpec.ts), using decorators, but I have only played with it so far and haven't written up the Redux aspects of it yet.
I use Typescript 2.0 and am very familiar with the union types. It's awesome. I'm not quite sure how to approach separating for reducers. Could you give a bit of an example? I'd really appreciate it. 
Nobody uses hungarian notation anymore, for good.
I recently ported the [npm typings](https://github.com/types/npm-bluebird) of Bluebird 3.0 over to [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/10561). The previous typings for 2.0 where actually global ones which extended the `Promise` interface as you want it. Unlike those "my" typings do not extend any global types though, which caused some nuisance (idk if this is the right word), with people like you asking for the same. [Here](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/10801#issuecomment-242998842)'s what I think about this though and the dangers resulting from this. You can also find some partial solutions for this in the issue. As such you could try to take [these typings](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/bluebird/bluebird.d.ts) and rewrite them to be like [those](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/bluebird/bluebird-2.0.d.ts). I think many people would be quite happy if you or someone else would create such (opt-in) typings.
Thanks, I was not aware of that option. However that's going to depend on the bundler generating a default for you, right? In which case it means your TS code changes depending on the bundler you use. Do you know which syntax is correct?
Don't do it. Redux is a shit sandwich for any sort of complex data model. Use [mobx](https://github.com/mobxjs/mobx) instead. Not only is it implemented in Typescript (which makes typescript support a guaranteed thing), but its a much better system for modeling massively complex UI state than a global-event-broker/state-machine tightly coupled to thousands of "pure" renderers. Hell, vanilla react classes are a better model than that. 
They fixed my biggest issue with the flow control!! function invoke(fn: Function): void { fn(); } function foo(value: number | string): void { if (typeof value === "string") { // `value` is type `string` invoke(_ =&gt; { /* type error if `value` used as `string` */ }); } } 
While I wholeheartedly agree with you, I wouldn't be so blunt to try and convince someone. Redux is a nice concept but in practice it requires a lot of boilerplate code (actions, reducers, selectors...), and even more so in typescript. Also, you're pretty much out of luck trying to properly typecheck your components with react-redux without adding more boilerplate on your components (I tried really hard and I only got something that worked for functions). MobX on the other hand requires none (save a few parameter-less decorators) and is totally unopinionated about how you should organize your code. It's really great and the react integration is simply wonderful (your components can react automatically to any mobx state change without being forced to inject anything in your component's props or state). You could literally remake redux and react-redux with mobx and I believe it would still be better.
[removed]
After diving into it, I kinda walked out with the same opinion Â¯\\_(ãƒ„)_/Â¯ I'm trying mobx with multiple data stores. Would you mind sharing some of your implementations? 
Thanks so much! I'll dive into this over the weekend. 
All my mobx code is holed up in private repos at the moment, but there are a lot of examples out there that are really good: http://mobxjs.github.io/mobx/faq/blogs.html http://mobxjs.github.io/mobx/faq/boilerplates.html I should add that using mobx in no way binds you into a single paradigm of state management. I've seen projects where they use: * a global state object (barf!!) * Component-local state (@observables within the same component that renders them) * Semi-local state, where each component has a companion state object that gets injected into the component as a prop * Dependency injected state (using &lt;Provider&gt; and @inject) * a mix of all of the above I'm personal to semi-local state. It allows you to separate your state relative to a component which is a huge reduction in the cognitive burden of managing your UI state when compared to a global state model. Furthermore, you can easily serialize/restore a snapshot of the state, and you can test the state independently of the component. I usually wrap them up with a wrapper component that becomes my only export (as long as I don't need to use any complex nesting of components that affect that state). A quick example (I haven't tested it, but it should work): class UserFormState { @observable name = ""; @observable email = ""; } // renders and reacts to changes in forms @observer class UserFormComponent extends React.Component&lt;UserFormState,{}&gt; { changeName = (e: React.FormEvent) =&gt; {this.props.name = (e.target as any).value as string;} changeEmail = (e: React.FormEvent) =&gt; {this.props.email = (e.target as any).value as string;} render() { return &lt;form&gt; &lt;input type="text" value={this.props.name} onChange={() =&gt; this.changeName}/&gt; &lt;input type="email" value={this.props.email} onChange={() =&gt; this.changeEmail}/&gt; &lt;/form&gt;; } } Now you can wrap them with: // WRAPPER TYPE #1 // creates a new UserFormState instance every time this component is rendered @observer export default class UserFormEphemeral extends React.Component&lt;{},{}&gt; { formState = new UserFormState; render() { return &lt;UserFormComponent {...this.formState}/&gt;; } } or with: // WRAPPER TYPE #2 // creates a static (singleton) UserFormState associated with the component, // if your app moves to a different route, and then returns, it will display the same values @observer export default class UserFormStatic extends React.Component&lt;{},{}&gt; { static formState = new UserFormState; render() { return &lt;UserFormComponent {...UserFormStatic.formState}/&gt;; } } or with // WRAPPER TYPE #3 // works similarly to UserFormStatic, excepts serializes/restores state using localStorage instead of storing in memory // user can close webpage and return on a different day and will restore the state to the same values // use sessionState if you only want session-level persistence @observer export default class UserFormRestorable extends React.Component&lt;{},{}&gt; { formState = new UserFormState; componentWillMount(){ this.formState.name = localStorage.getItem("UserForm:name") || ""; this.formState.email = localStorage.getItem("UserForm:email") || ""; } componentWillUnmount(){ localStorage.setItem("UserForm:name",this.formState.name); localStorage.setItem("UserForm:email",this.formState.email); } render() { return &lt;UserFormComponent {...this.formState}/&gt;; } }
I'll post an update later. Basically, I made the Services class static and ditched Handlebars, so I can call the filter method in Services from the tags.
Can I ask why you want to do this? Is it an alias? Shorthand?
This is a deep and interesting question (to me anyway) and I've been meaning to write a blog post about it for a while, so now I've done it as a response to your question: http://danielearwicker.github.io/TypeScript_and_runtime_typing.html Short answer: yes, you can do this.
That's almost it, except the `Listener` doesn't want to be passed a constructor for an event. It just wants an event. [Full answer here](http://danielearwicker.github.io/TypeScript_and_runtime_typing.html).
Thank you for really great explanation. I knew about TypeScript being only compile time thing and I've had underlying JS nature in mind when I tried to develop this module. I actually planned to point Map keys for a constructor functions of object and on triggering event, I'd just search for event.constructor in map and call their listeners. I actually did this yesterday but it was not type safe because I've used Function instead of my "class extends Event" and any type for listeners. Today I've modified code and it works correctly on runtime. Unfortunately, I still do not know how to remove any from map key template parameter while still having listen method 100% fully checked (with listener&lt;T&gt; second parameter). Here is code (copy-pased from 3 different modules): http://pastebin.com/cRvm9QEL
Don't know if I've understood your remove problem, but a common-ish pattern for tearing down a listener is to have the `listen` function return something that can be later used to "unlisten". e.g. const unlisten = hasEvents.listen(FoodEvent, myFoodHandler); Then later: unlisten(); BTW, note how in your use of `inversify` you have to repeat yourself so much: @inject(TYPES.Weapon) katana: Weapon, Every time you have to give the type name (e.g. `Weapon`) twice. It's exactly the problem I talk about in that post. Unfortunately there are some Java/C#-like runtime environment assumptions baked in here, and that approach just doesn't quite work in TypeScript.
Ah, I totally misunderstood your question! :) Problem is you had `eventClass: T` where `T extends Event`, but it's not an event, it's the type of the event (represented by a constructor), so: listen&lt;T extends Event&gt;(eventClass: Constructor&lt;T&gt;, action: Listener&lt;T&gt; ) { let listeners = this.handlers.get(eventClass); if (!listeners) { listeners = []; this.handlers.set(eventClass, listeners); } listeners.push(action); } trigger( data: Event ) { let listeners = this.handlers.get(data.constructor as Constructor&lt;Event&gt;); if (listeners) { listeners.forEach(l =&gt; l(data)); } } Note that in `trigger` we have to use a type assertion: `data.constructor as Constructor&lt;Event&gt;` because `data.constructor` is only known to be of type `Function`. But this is fine because the purpose of your `EventHandler` class is to provide a type-safe facade. You only allow compatible handlers to be registered, so you effectively check at runtime whether the type assertion was correct. Re: inversify, I think that project's documentation gives a very bad impression! Due to the readme example using interfaces instead of classes (I've seen a few posts about it here that were similarly problematic). As you're using classes, you don't have the same issues - classes in TS are effectively interfaces with a built-in object to represent them at runtime (the constructor function). In fact you can eliminate your one bit of repetition where you say `Init` three times: let init: Init = kernel.get&lt;Init&gt;(Init); init.initialize(); can become (thanks to type inference): kernel.get(Init).initialize();
Problem is, as soon as you use interfaces, there is no runtime type, it becomes necessary to use symbols or strings and nothing automatically checks that you're using the right combination, so all type-safety is lost - may as well use `any` everywhere. However, we can use abstract classes, e.g. abstract class Lightswitch { abstract switchOn(): void; abstract switchOff(): void; abstract get isOn(): boolean; } class MyLightswitch extends Lightswitch { private on: boolean; switchOn() { this.on = true; } switchOff(){ this.on = false; } get isOn() { return this.on; } } At runtime this will be true, thanks to how `instanceof` works with inheritance: new MyLightswitch() instanceof Lightswitch So we retain runtime type identity for `Lightswitch` but it is completely abstract allowing us to implement it however. Only downside is we can only extend one such class (single inheritance). You can change `extends` to `implements` but then there will be no runtime type relationship.
Correct, interfaces do not exist at runtime. The metadata available on attributed class members of interface type is just `Object` (there is talk of improving this, but it doesn't seem to be on the roadmap).
If I just insert the actor object inside the console.log paranthesis, like this: console.log(actor); I get [this](http://imgur.com/a/tlhla) in the browser. So I'm sure that I get the object. 
One other question, how do you feel (in a large app anyway) about using an event system such as Actions to modify state across components, vs modifying the store directly? I'm trying to think of potential future cases, but I like the idea of the "actions" being right on the data stores themselves. For example, right now I have multiple loading icons that are nested (only showing the loading icon for the route im rendering). I have the loading icon share a data store, that needs to react to a route being updated. My current mobx solution uses a store for the router, and when a route starts to change it updates a bool on that store. Once it's done, it updates it again (finished?). The loader icon store listens for a change in that variable, and if it's *not* finished it shows the loading icon at the appropriate spot, until it changes again and then re-renders. Is this a decent long term approach to these kind of problems with mobx, or would it be more efficient to implement the 'action' portion of flux in conjunction? I know I will be implementing websockets soon, and they work well with the actions model. However, with directly modifying data stores, I can 1) limit my dependencies and 2) follow code flow directly rather than trying to chase even paths, which I quite like. Would love to hear your opinion, thanks!
why are you linking self.typescript, and then commenting a url.... wat, i cant.... 
Well, I think a lot of that comes down to personal preference + judicious application of basic engineering principles. My own personal preference is to couple actions with state. The reasoning is that all interactive UI's are state machines (note I'm not saying that they are *like* state machines...they literally *are* state machines). And a state machine is mathematically described as follows: State^0 + Action =&gt; Side-Effect(s) + State^1. In other words, your state and your actions define your side effects and your new state. If you think about your example, you are literally describing a state machine. That is basically the principle behind OO programming. Now, forget about inheritance and patterns and all the cruft that is associated with OO today. Basic OO programming in the way Simula and Smalltalk were designed is basically state machine programming... a perfect fit for programming state machines, right? To be sure, I'm a fan of functional programming in most areas, but OO and its ability to couple (encapsulated) state and actions is an almost perfect fit for programming UIs. 
To clarify, in lieu of an event system, your preference is to call functions (@action)s that are a part of the same object as the state itself directly? 
Yes, exactly 
You've been a huge help. Thanks so much!
How is this support different than the one already available for months?
Current async/await emits es6 async and await statements. This actually transforms the source code into es5 and es3 compliant alternatives.
An iterative approach is easier to read IMO. const enum Comparison { GT, LT, EQ } type CompareFunc&lt;T&gt; = (a: T, b: T) =&gt; Comparison; function binarySearch&lt;T&gt;(array: T[], item: T, compare: CompareFunc&lt;T&gt;): number { let [left, right] = [0, array.length - 1]; while (left &lt;= right) { let middle = Math.floor((left + right) / 2); switch (compare(array[middle], item)) { case Comparison.LT: left = middle + 1; break; case Comparison.GT: right = middle - 1; break; default: return middle; } } return -1; } 
Correct, because es6 (es2015) didn't have async/await but did have generators. In standardisation async/await is still at stage 2 so I think goes in es2017 at the earliest.
This is awesome and implies 2.1 with down level async and generators very soon after 2.0. And this is on top of non-nullable types in 2.0... TS is the most fantastic essential one-stop-shop enhancement for JS devs ever.
Yeah, the proj file had a [TypeScriptToolsVersion](http://stackoverflow.com/a/39147318/215534) property in it. That would do it.
Hell. It's about time. ðŸŽ‰ https://www.youtube.com/watch?v=_J6-3l3hCm0
This is glorious news for El Dorado!
Check the handbook for [import = require()](https://www.typescriptlang.org/docs/handbook/modules.html) import foo from 'foo'; // import 'default' export import {foo} from 'foo' // import `export foo` import foo = require('foo'); // import an es5 module This syntax is _not_ allowed in combination with `{"module": "ES6"}` compiler optoin
Not sure I agree with any of the comments here.... `allowSyntheticDefaultImports` does not modify code generation, it only modifies type detection. This makes it useful when you compile TypeScript to ES6 and then pipe that ES6 through Babel (surprisingly common), because Babel will take the following: import foo from 'some-module' and turn it into function requireDefaultInterop(module) { return module._esModule ? module.default : module } var foo = requireDefaultInterop(require('some-module')) or something equivalent. However, if you *don't* do this, TypeScript does not attempt do this, even with `allowSyntheticDefaultImports`. In other words, TypeScript will convert the above code sample to var foo_1 = require('some-module') var foo = foo_1.default which is probably not what you meant. --- I wouldn't use `import foo = require()` because it is confusing to have two entirely different syntaxes. When using CommonJS modules I stick to the solution you've given and use `import * as foo` as well - to me, this makes sense anyway as you are importing the entire CommonJS object (that is what CommonJS does anyway). I wouldn't necessarily say that Babel has it "wrong", it's just that Babel adds this interop wrapper to make the gradual adoption of ES6 easier - and note that the interop wrapper is a plugin that comes as part of a preset and isn't even required to use the ES6 import syntax. If you're going to use TypeScript, though, I would stick with `import *` so that you aren't relying on Babel's magic. So the tl;dr for me would be to use `import * as foo`. 
I've not used rollup, but I know it does some limited treeshaking, in which case `import *` would make you lose the benefits of that. I'm not sure of a right answer here.
If I rebuild the solution, they are generated one way. If I then save a ts file to trigger the the compile on save, they are generated the other way. I tried adding the tools version, but still got the same results. 
Async/await is stage 4 right now, so it's going to be in ES2017. See there: https://github.com/tc39/proposals/blob/master/finished-proposals.md
I'm pretty sure you can't. (You won't get any issues of the sort with minifying by the way)
Thanks! That may in fact be too verbose, but it's helpful to think about decorators this way for me. I appreciate it.
It's working at TS Playground. Just make sure file _"Vector2D.ts"_ is loaded before _"TestVector2D.ts"_: http://www.TypeScriptLang.org/play/#src=class%20Vector2D%20%7B%0D%0A%20%20%20%20x%3A%20number%3B%0D%0A%20%20%20%20y%3A%20number%3B%0D%0A%0D%0A%20%20%20%20constructor(x%3A%20number%2C%20y%3A%20number)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.x%20%3D%20x%3B%0D%0A%20%20%20%20%20%20%20%20this.y%20%3D%20y%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20Add(vec%3A%20Vector2D)%20%3A%20Vector2D%0D%0A%20%20%20%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20new%20Vector2D(this.x%20%2B%20vec.x%2C%20this.y%20%2B%20vec.y)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20Sub(vec%3A%20Vector2D)%20%3A%20Vector2D%0D%0A%20%20%20%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20new%20Vector2D(this.x%20-%20vec.x%2C%20this.y%20-%20vec.y)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20Cross(vec%3A%20Vector2D)%20%3A%20void%20%7B%0D%0A%20%20%20%20%20%20%20%20%2F%2F%20return%20this.x%20*%20vec.y%20-%20(this.y%20*%20vec.x)%3B%0D%0A%20%20%20%20%20%20%20%20throw%20Error(%22Not%20implemented...%22)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20Dot(vec%3A%20Vector2D)%20%3A%20number%20%7B%20%20%20%20%20%20%20%0D%0A%20%20%20%20%20%20%20%20return%20(this.x%20*%20vec.x)%20%2B%20(this.y%20%2B%20vec.y)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20Angle(vec%3A%20Vector2D)%20%3A%20number%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20Math.acos(this.Dot(vec))%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20TestVector2D%20%7B%0D%0A%20%20%20%20DoShizzle()%20%3A%20void%20%7B%0D%0A%20%20%20%20console.log(%22start%22)%3B%0D%0A%0D%0A%20%20%20%20var%20vec%20%3D%20new%20Vector2D(5%2C%200)%3B%0D%0A%20%20%20%20var%20vec2%20%3D%20new%20Vector2D(0%2C%205)%3B%0D%0A%20%20%20%20var%20angle%20%3D%20vec.Angle(vec2)%3B%0D%0A%20%20%20%20alert(%22Angle%20is%20%3A%20%22%20%2B%20angle)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Avar%20tv%20%3D%20new%20TestVector2D()%3B%0D%0Atv.DoShizzle()%3B
The issue is ... I want to have a single .js file.
Ok, thanks. this seems to work. I also changed to module system es2015 so maybe that helped, too.
I use the same stack in order to test frontend in plain node. It's really not that difficult to get up and running.
Wait! What!?!?! I've been looking for an answer to the Karma soup-sandwich situation for a while. Do you have any references for more information on this solution?
I would also highly recommend https://wallabyjs.com/ it costs a bit of money, but worth every penny
UPDATE: now with mocha unit-testing
Maybe make this a pull request so TypeLite can add this support? Adding a platform to TypeLite seems to make more sense than trying to maintain a fork of sorts, IMHO.
What differs this from Q's implementation of Deferred? And just using the type definition for Q.
Alternatively, file as an issue to at least identify the problem and have it confirmed as a bug instead of potentially being By Design for some reason. :)
I update the typing if they don't fit. The people who made them might be smarter, but the lib might have changed after they wrote it. You can even up date them your self in the repo. People who make the typing are just people.
Currently I open issues on the DT repo - adding the typing to DT myself just takes too long and gets me out of the zone. :P So you have typings for all your third-party libs?
If you find a problem with some typings, open a PR. Keeping them all up to date is hard and help is always appreciated.
Only one of the options you wrote is an actual interface. This does not work: `type Foo = { bar: string };` `interface FooBar extends Foo {}` So yea... the second one.
I have not, what does that entail? 
Ah ok, I didn't know that. I use the `interface` keyword and was wondering if and why people would be using the alternative.
Yeah, I'll start doing that instead of opening issues with my proposed changes.
None of the problems of php are relevant to the essential ideas of the article. It could just as easily have been written about Java or C#.
[removed]
Are you using typescript 1.8 or 2? It affects our answer.
Thanks, I am using 1.8. But I see Angular has gone to 2 so maybe I should move.
*knee slapper
[removed]
How painful is upgrading an existing body of code to typescript 2? I'm guessing the biggest problem would be non nullable types. Does anyone here have experience with this? 
I think you could just switch over and not use the strict null checks to start with.
I have tried using strictNullChecks in the past but was stuck because the type definitions of the libraries I use (Angular2, lodash, localforge, etc) are not strict null safe. I would love to use strictNullChecks on our codebase, but is there some way to tell it to go back to lax null checking for some/all library type definitions? Without this it seems I will have to wait quite a while before I can actually use null checks and will end up having to turn it off whenever I add new libraries that don't support it yet.
a, least things to type.
There's nothing stopping you from changing the definition files manually. I'm not trying to be pedantic - it's actually a super simple process to edit a definition file and toss in a | undefined as you need it :)
Been using strictNullChecks since late May, have to say it's been a godsend. Congrats to the team! Once I have some more free time I'll try and dive in and contribute :)
It would be really cool if there were a transformer that added `| null | undefined` to legacy type declarations. That way you could enable strictNullChecks and use the transformed versions of those declarations. Then, when the community had time to properly update DefinitelyTyped, you could switch to the @types version.
Official for contributing to the typescript compiler yes, but not a standard. 
Excellent news, also worth noting the configuration docs are now relevant. No more old 1.8 documentation frustration. https://www.typescriptlang.org/docs/handbook/compiler-options.html
It sucks but i add them to my source control and fix as needed, which sadly happens a lot.
Wouldn't this be bad practice, though? I install my definition files using typings, and I don't check in the installed folders. Granted, could always submit a pull request with updates to those definition files I suppose. 
So you don't just say _fuck it_ and use `require`?
I tend to do it in the constructor. I think that people will look there for "authoritative" initializations of object properties. At least I do :).
I just use '+' to turn enum values, which were used as object keys, back to numbers. So, in your case, something like: if (+this.state.selectedTimeFrame === TimeFrame.Quarterly) {
it's a good talk, but does it belong in /r/typescript ?
it's typescript's syntax too. 
Did you add the module to your package.json?
Do you want to reformat your source code? If so, there are tools that do that and you don't have to deal directly with AST, just some configuration. I've forgotten the name of the project, but there's at least one. There are a few other tools that let you rewrite very specific patterns into something different, but I haven't heard any for specifically Typescript. 
He hit the nail on the head with the ending. Some days are great and you feel like you have a solid grasp on the project...then some new way of doing things (looking at you react-router v4) comes out just as you finally got caught up with the now-deprecated-but-was-bleeding-edge-last-week way of doing things.
Does anyone else think that strict null checks are inspired by Swift? 
I'd like to understand the type of tasks you have in mind. Working on [tsoa](https://github.com/lukeautry/tsoa), the code generation works by running files through the compiler and using the compiler API to retrieve metadata through the AST. I wouldn't describe this process as exceedingly difficult, but it is very tedious. Depending on your task, getting the information you want may be easier than you expect. The compiler API isn't so difficult that it requires some kind of wrapper to make it more accessible/user-friendly IMO.
EDIT - let me rephrase that: Suggestion: implement auto-complete and error feedback as you type.
I am aware of Monaco. Glot.io is using Ace. If Monaco is better than Ace is every point. I don't see why we couldn't replace one with another. Monaco seems to lack of language diversity. [Glot.io](https://glot.io/) has a lot of them to support. I open an [issue about the idea](https://github.com/prasmussen/glot-www/issues/24).
Ahhh I thought i read something about that. That is very ideal. Fail so the user tries to maintain type, but still compile, so it is a true (although grouchy) super set. Perfect. Thanks a lot dude and cheers!
Stuff like bit fields. Enums are used often. A lot of useful procedures for querying and modifying the AST are implemented as functions in the giant ts namespace, rather than methods in reasonably sized classes (I use autocomplete often). I've wondered whether the compiler code is actually the raw code that the TS team works with, or if it's generated. Presumably it is written to be fast.
Occurred to me that I'm looking for a thing one might expect to see in a reflection library. This active project looks promising: https://github.com/dsherret/ts-type-info 
More significant changes than reformatting. But if you remember the name, do share!
Yeah, speed is a huge priority for them. I'm pretty sure it's all the raw code that they work with, though. It'd be interesting to use ES6 Proxies to provide a "membrane" wrapper over a real TS AST, with lots of useful methods added. Especially if speed isn't an issue, you could focus on a really friendly API.
Did you ever get this resolved? Having the same issue.
Unfortunately not, my solution instead was to use this: [Typings for CSS Modules](https://github.com/Jimdo/typings-for-css-modules-loader) which allows me to import and use type-safe css classes instead. I've found it to be a better and saner approach. 
I posted this onto /r/javascript as well. I re-posted here since all the examples are in TypeScript.
What's wrong with Promise.all?
Promise.all resolves the promises in parallel. The OP is a way to resolve them in series. Consider the case of looking looking for the first url (or file in a filesystem) that returns a desired value where you want to check each one in series and use its result, if it exists, otherwise go to the next and check for a result. Promise.all is inadequate for this.
Alas, project's owner replied about why it would currently come up short for many complex refactoring tasks: https://github.com/dsherret/ts-type-info/issues/191#issuecomment-249755283
Recursive solution: https://github.com/bcherny/promise-seq
No mention of nw.js? http://nwjs.io
The second form is more elegant to me.
I find async/await to be very useful, so I prefer the first. It's also easier in case you need both `utm` and `user` later on: you just use the variables. With just promises and `then`, you'd need to put variable declarations scoped outside the promise chain and assign them from the `then` handlers... which can get tricky. The second one is just what you'd write when you don't have async/await and only have the standard promise methods. In fact, you can just remove the `async` and `await` in the second example and it still works.
i think you have to do both. in proper cases, creating interface would be great, both for testing and design. for example, you can create a *Storage* interface and *LocalStorage*, *SessionStorage*, *InMemoryStorage* would be possible implementations. You can use *InMemoryStorage* in tests, *LocalStorage* or *SessionStorage* in real world. sometimes however, interface wouldn't be necessary, than you can either use a mocking library or create stub classes.
Can you post an example of something where you hit a problem? TypeScript has structural typing. Any object that has the right "shape" is good enough to serve as a mock. Interfaces describe the "shape" of an object. And also, classes *are* interfaces so it's not necessary to duplicate their members in a separate interface. So for example: class Foo { x: number; y: string; bar() { return `${this.x}, ${this.y}`; } } // accepts something that implements Foo function whatever(foo: Foo) { console.log(foo.bar()); } // the right shape - no mention of Foo though! const mock = { x: 3, y: "Hi", bar() { return "fake"; } } // TS compiler is perfectly happy whatever(mock); But try changing some things in `mock` to see how TS is checking it all.
TypeScript doesn't help with that. All types are "stripped" during compilation when your code is turned into regular JavaScript. All checks you had to do during run time in JS is still needed even if you use TS. What you probably are looking for is a library that validates the data you're fetching from the API, maybe look into JSON Schema or something
That's what I suspected. I'll check JSON schema out. I've also heard of Typeson and going to check that out as well. Thanks for your response!
Since you got async/await, you might as well use it. The code looks simpler.
If the endpoint has swagger, there is a lot of typescript code generation out there
I have something custom written and similar I'm already using but it only splits a string by "." and loops through it but it doesn't work if there's an array in the middle somewhere and I need to get a.b.c[0].item. Would lodash handle a situation like that? I'd definitely switch to it if so edit: I see that it _does_ do what I need, great! I'm going to use it. thanks!
What Typescript would do for you in that case (with strict null checking) is output errors when you *don't* write all that stuff
You've replied to your own post
Key quote: &gt; So overall the conclusion about TypeScript for us is clear: We are now enamored with TypeScript! Whether or not you take the plunge for Angular 2, your JavaScript development will be greatly improved by switching to TypeScript. They started out as Angular users who didn't want to use TypeScript, and ended up as TypeScript users who happen to be using Angular.
It's not backward compatible with python 2, so the libraries/ecosystem is fragmented.
ah. so the aim is pure typescript libs then? 
* [typedi](https://github.com/pleerock/typedi) * [routing controllers](https://github.com/pleerock/routing-controllers) Both by /u/pleerock iirc They are very useful if you're writing an express server in TS. I made one using both these libraries, and they work awesomely well together. With routing controllers, no more stupid `app.method` callbacks.
I believe that is the expected behavior of `noImplicitAny`, from the Typescript docs... When the noImplicitAny flag is false (the default), and if the compiler cannot infer the variable type based on how it's used, the compiler silently defaults the type to any. That's what is meant by implicit any. In the QuickStart exercise, the noImplicitAny flag is initialized to false to make learning TypeScript development easier. When the noImplicitAny flag is true and the TypeScript compiler cannot infer the type, it still generates the JavaScript files, but it also reports an error. Many seasoned developers prefer this stricter setting because type checking catches more unintentional errors at compile time. You can set a variable's type to any even when the noImplicitAny flag is true. In line 6 you have **explicitly* set the type to any, line 3 is set to any by the compiler **implicitly** line 4 errors per the rule, whereas line 7 doesn't error because you have essentially told the compiler to ignore it by setting jim to any.
I see. That makes sense. Is there any way to make a function not accept a parameter of type `any` no matter what?
This is very funny but allow me to be the hipster from the article. When I program systems, mobile, or desktop applications I typically have multiple stages of compiling, linking, bundling, etc. The number of new must-haves and shiny toys is dizzying and silly, of course, but when (if?) the dust settles I don't think it will be all that crazy that compilation, linking, and module juggling will be part of the process. Also yeah four libraries just to fetch data to go in a table is mad silly. I've been tinkering with [my own little fractious contribution to the ecosystem](http://niltag.net/Alm) to see what a good balance of letting good patterns from a little type nerding help me / resisting the urge to reinvent clever things functions can already do. 
[removed]
Not at pc so sorry for short answer. Download the typings for passport and modify to your will. A definitions file is just another ts file but with interfaces, declarations, comments and no zero I code. Think of them as header files from C++. Also consider contributing your d.ts when you're happy with it to the typings project! Using 'any' type is not ideal as you might as well be using JavaScript without intellisense.
No problem, i will give it a try today, at first time it looks kind of a scary :)
Using a bundled definition file and pulling one from @types is essentially the same thing. Using a "pure" Typescript library is still a way better experience.
Here's a good tool to find typings (doesn't mean the library itself is typescript-written though): http://microsoft.github.io/TypeSearch/
Not at all. I maintain `.d.ts` files for my own JavaScript projects that I won't be rewriting into TypeScript. There's no difference in "pure" TypeScript or JavaScript with a `.d.ts` file there, unless you're misunderstanding what TypeScript does in the end.
Unfortunately that tool mostly does the opposite. It'll only ever find polyfills, and never an original library written in TypeScript.
Understandable. That's been a real pain point for me too, and every project in Typings (it's a question asked when opening a PR to the registry) is meant to follow this as a result but understandably people (like me) don't really work on definitions for libraries we never use, so I've never done the work myself on the `lodash` typings. This was definitely a huge issue with DefinitelyTyped, not sure it's been improved much with 2.0 either since the entry files are all hard-coded to `index.d.ts` now but at least you can just make that an export alias manually. However, finding a high-quality library like the ones you mention in pure TypeScript is even harder to do. You'd need to basically replicate something that already exists, and get a bigger user-base for continuous contributions. That's my only point :) Although it's great to say that you only want to use TypeScript libraries, it's very impractical in practice (even with small libraries, I don't want to re-publish a bunch of other peoples work or use someone else's republish). On that mark, I still think having a feature to search directly on NPM with "types included" would be extremely valuable. Hopefully DefinitelyTyped will become better versioned and higher quality over time so we could even omit outdated definitions.
Yes, it's not compatible with Python 2, but for good reasons. A lot of old baggage was removed from the language and standard library. As a result it's a much cleaner and more modern language. If you want to know more: https://docs.python.org/3.0/whatsnew/3.0.html
Agreed, and I had that thought too. We've seen a Cambrian explosion. 
Thank you! Gonna read it right away. I was never able to get into Python, for some reason. Not quite sure why. On the other hand, Lua clicked immediately with me. But now, after being exposed to C# for some time, I feel so much more productive with all the intellisense and static analysis that I can't go back to any dynamically typed language. :) Although Python still intrigues me. Perhaps because I never tamed it.
Nice analogy!
I was in the same-ish boat. I decided to ditch react and just use Typescript &amp; jQuery. Well, and webpack. 
Are you suggesting webpack 2 with atl 2? Yeah the idea to have a single file/bundle as output is what I'd prefer. Thanks!
There's a walkthrough for using TS, React and Webpack on the TS website. Did you hit problems with it? They might not have updated it for 2.0 yet.
Fatigue is usually about making things way harder than they are. If there is a benefit to using a tool, use it. If not or if it causes you trouble, *discard it*. The question is, why ts in the first place? Most react projects use babel, and if needed, flow. Setting up a react project with babel and webpack is a [matter of seconds](https://egghead.io/lessons/react-react-fundamentals-development-environment-setup?course=react-fundamentals). Adding flow for static types is [easy as well](https://egghead.io/lessons/javascript-up-and-running-with-facebook-flow-for-typed-javascript). Yet with ts, you will bump into edge cases and troubles along the way. Even if you make it work, the moment you get into redux it will collapse once again because it just can't transpile as close to the tc9 stages and living drafts as babel can. 
We are using Typescript/Redux/React too, and ran into similar problems. We also use Immutable for our store. I think now everything is typed, but I would also be interested to hear other patterns for mapStateToProps/mapDispatchToProps. I'll outline how we approached each of the issues you raised (I won't call these "solutions" though). **State** We use immutablejs "records". We have a wrapper (which is a bunch of generics mashed together on top of some interfaces). It's not super pretty to look at, and not all functions are typed (for example the "set" function). But since most components usually just read from the store, you can use regular javascript notation like `store.routing.pathname` even though `store` is an immutable. Records are pretty great. **mapStateToProps/mapDispatchToProps:** We only have a dozen or so "smart" components. For those that have a complicated state/props, I usually write 2 interfaces: `componentProps` and `componentActions`. Then there is another `componentStuff = componentProps &amp; {actions: componentActions;}`. The `mapStateToProps` then only needs to return a `componentProps` and `mapDispatchToProps` returns a `componentActions`. It's more boiler plate, which is annoying, but it isn't holding us back or anything. It's just slightly annoying. The worst part IMO is that I end up rewriting the signature of an actionCreator many times, even though it's the same actionCreator. **Actions:** I followed this article: https://spin.atomicobject.com/2016/09/27/typed-redux-reducers-typescript-2-0/ It took me less than an hour to write a file which exports types for all the actions. We also use an `enum` type for our action types. While it's nice, I don't think it's necessary. So we have one file which exports an enum `ActionTypes` and also exports all the different types. Then in our reduces, since we switch by the action type, inside the case the action is known and you have all the typings for it. This is very similar to your solution, but it uses more type literals (you still have to do a big tagged union at the end). Let me know if you have any other questions or suggestions! Or if something doesn't make sense, it's very early.
Support for ES3/5 generators [was dropped recently](https://github.com/Microsoft/TypeScript/issues/3975#issuecomment-250859415)
That's a bit surprising. Personally, I only care about async/await, though. Haven't found a good use for generators yet. It's primary use seems to be simulating async functions anyhow.
**State** This looks interesting! Would you mind going into more detail or providing an example of how you are setting up your state with records and exporting the type like you described? **mapStateToProps/mapDIspatchToProps** Bummer. This is what I was afraid of. I was hoping there were parts of typescript that I wasn't aware of that would make this easier than multiple interfaces. **Actions** Holy-ly-cow. What a great read. You are right, this is very nearly what I showed off here, but I never thought about the whole "OtherAction" scenario. Thank you so much for that link.
Immuto works by building up reducers from individual action handlers, so everything is strongly typed. The type of a reducer is effectively auto-generated so it only accepts a specific set of action types. It ends up being exactly the same as Redux except all the pieces are first-class objects so you can manipulate them and build on them, and compose them. The tagged union approach is fine but ultimately what I want is composition. I'm only part of the way there but the next few commits (when I get around to it) will support things like recursive data structures and self-contained renderable objects. I want Redux to be as easy and second-nature as working with references to mutable data.
Please do, and check out the various write ups I've attempted. I'd like to make them clearer if I can.
A webpack example i'm using in my Angular App. var webpack = require('webpack'); var HtmlWebpackPlugin = require('html-webpack-plugin'); var ExtractTextPlugin = require('extract-text-webpack-plugin'); var helpers = require('./helpers'); module.exports = { entry: { 'polyfills': './src/polyfills.ts', 'vendor': './src/vendor.ts', 'app': './src/main.ts' }, resolve: { extensions: ['', '.js', '.ts'] }, module: { loaders: [ { test: /\.ts$/, loaders: ['awesome-typescript-loader', 'angular2-template-loader'] }, { test: /\.html$/, loader: 'html' }, { test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/, loader: 'file?name=assets/[name].[hash].[ext]' }, { test: /\.css$/, exclude: helpers.root('src', 'app'), loader: ExtractTextPlugin.extract('style', 'css?sourceMap') }, { test: /\.css$/, include: helpers.root('src', 'app'), loader: 'raw' } ] }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: ['app', 'vendor', 'polyfills'] }), new HtmlWebpackPlugin({ template: 'src/index.html' }) ] }; Other file for dev specific. var webpackMerge = require('webpack-merge'); var ExtractTextPlugin = require('extract-text-webpack-plugin'); var commonConfig = require('./webpack.common.js'); var helpers = require('./helpers'); module.exports = webpackMerge(commonConfig, { devtool: 'cheap-module-eval-source-map', output: { path: helpers.root('dist'), publicPath: 'http://localhost:8080/', filename: '[name].js', chunkFilename: '[id].chunk.js' }, plugins: [ new ExtractTextPlugin('[name].css') ], devServer: { historyApiFallback: true, stats: 'minimal' } }); 
 create-react-app your-app cd your-app npm run eject You now have hot module reloading and most of what you wanted. To add typescript, just edit your webpack config and add your preferred typescript loader to `ts` and `tsx` files. Now copy your source code to the `src` folder, update `package.json`, and work up from there.
Post in the [VSCode issue tracker](https://github.com/Microsoft/vscode/issues) - this seems like a bug. How big is your project? It should compile in under a second using `tsc -w`.
This is kind of a sidetrack, but if you don't mind looking, does anything jump out at you in this project that would cause slow compilation? https://github.com/mwcz/phaser-typescript It's very small, but tsc takes 2-4 seconds to run. I thought I might have an overinclusive glob in tsconfig, but nothing stands out to me.
This is very cool however I find translations typically are needed at runtime as well. Regardless annotation processing is an awesome feature to have. They're really making the most of the language.
As easy as following the instructions here: https://github.com/s-panferov/awesome-typescript-loader
Can't really speak to the rational behind this, but the compiler does have a -noEmitOnErrors flag
Hope it helps someone, it's by no means comparable to the big boilerplates with thousands of stars - and it will never be. But those are more always so bloated and it's actually quite the effort to delete all those parts one does not need.
Very nice, loving seeing decorator annotations being used for test cases. Some features that would be great to bring it up to mocha equivalent and beyond; beforeEach/afterEach etc, assertion of expect counts (great for catching async test issues), test skipping/focusing.
Aah sorry! Totally forgot to test it again on a clean repo. Thank you for trying it out, I'll fix it now. Edit: It was the node typings, needed because of the `require` and `process.env`. I migrated this from another project where I used this setup and tried to delete everything I don't need. But totally forgot to delete the typings and install them again ðŸ™ˆ. 
Aren't we using @types now?
This is more of a graphics demo than a game, but [here is an example](https://github.com/spacejack/terra). It relies on three.js. One change I would recommend - use tsify &amp; browserify rather than just tsc to build the compiled js bundle so you can use npm libraries.
Nice example, I would read into tsify and browserify when I have time on my hands. Do you also have know of a 2D game in typescript? 
We had a similar issue combining but from the other side. We have coverage working using typescript, karma and remap-istanbul but found that we couldn't get webpack working because karma-webpack's source maps weren't retained for remap-istanbul to use. I can double check our config at work and let you know the exact scenario if that would be of any use. One possible solution is not to webpack your files (only during the tests) and just use require or something. Not ideal but might be the simplest way to get the coverage working without having to switch out other sections of the pipeline
For my current project I'm using [ava](https://github.com/avajs/ava) with an nyc reporter. It's working like a charm for me.
https://bencoveney.itch.io/quadrilactic Here is one I made. The code is a mess (I was trying to get it finished before losing interest in this project and moving on to the next one!) And it glitches out some time but it might at least demonstrate what you are looking for. https://github.com/bencoveney/Quadrilactic/commit/19f9dbf8ebe4d899ce2584e52b87b219b8d97708 This is the codebase at the time I put it on Itch.io, since then I have done a bit of refactoring to try and pull some engine stuff out of it but all I have managed to do so fat is make more of a mess! ;)
This isn't quite what you asked, but I put together a TypeScript boilerplate project for Phaser games. https://github.com/mwcz/phaser-typescript
Not actually a game itself, but the Excalibur game engine is written in Typescript: http://excaliburjs.com/ Some of the example have Typescript code as well: https://github.com/excaliburjs/ludum-33
Correct. All of the @types packages on npm are auto-generated from the type declarations on DefinitelyTyped. Submitting to DefinitelyTyped is the correct way to add declarations to @types.
Yeah, it's more like nitpicking. Mainly because npm causes more and more frustration. No wonder Facebook released yarn. Maybe some day npm developers will realise that community is getting tired and make a proper update to their creation. I really hope that day will come soon :)
&gt; many of TS features are getting adopted in ECMA specifications in one way or another. OP seems to believe that TS syntax sugar (arrow functions, classes etc) began in TS and were adopted by ES. It's the other way around. TS has mostly tried to implement ES specs, though sometimes it has anticipated incorrectly (namespaces for example).
It's worth nothing that the static typing is actually "optional" typing (use it where it counts!) and very much is inferred, meaning you don't have to declare types everywhere. The structural typing system is also incredible for making interfaces much more dynamic. Like USPS flat rate boxes, if it fits, it ships!
I think I mentioned optionality, but yeah, didn't go into details. Maybe I should update my post later after gathering the feedback. Thanks!
I like typescript, but no one ever seems to acknowledge the biggest problem. 3rd party typings and mis typings. It can bite you when you least expect it and cost you hours to fix, or force you into using an any. 
I hope this problem will go away as soon as @typings section of npm gets better, now we can finaly find the correct version of .d.ts for the libs we're using. It's not going to be 100% of course, but it will get better.
I have the same hopes. It would be really great if it read your package.Json and didn't require typings.json file a well
I thought it already did that?
Yes, I think that is the case. While I have upgraded to TS2, I have not yet stopped using typings because I'm lazy.
First: Super glad to see more small boilerplates popping up. Super glad to see how much fat you were able to trim. Great work. Second: Do you have plans to add something like unit testing? I've seen some success trying Jest on my own, but am interested in seeing what works well for others.
I am interested in what others have to say because I don't think you'll like my solution, and I'm not sure if there's an easier way. If I were you I would setup RequireJS. Then you'll have to update each file with the necessary imports and exports. Also, what you are calling modules are technically called "Namespaces" now, sometimes referred to as "Internal Modules". But the name "module" is reserved for external modules. It's actually all quite confusing to me still. 
Saw you replied and I worked hard on this response before you deleted your reply. So here it is anyways.... You don't need to say module Foo.Bar at the top of your files anymore, no. If you really want to you could change it to: namespace Foo.Bar But that's completely optional. What you're more likely to do is use imports and exports in your file. Those will automatically make TypeScript treat the file as a module. And then when you require the module from somewhere else you are going to use the filename as the module name. So the module name is kind of implied by its filename. For example: File /src/Foo/Bar.ts: namespace Foo { //optional export class Bar { doStuff() { /* do stuff */ } } } File /src/Other/File.ts: import * as Foo from '../Foo/Bar' namespace Other { // optional var fooBar = new Foo.Bar(); fooBar.doStuff(); } You'll notice that the import statement in /src/Other/File.ts didn't have to use the namespace from /src/Foo/Bar.ts at all. So I really don't think there is much to be gained from the namespace usage. You basically want to use folders to organize functionality and use good file names to indicate the contents of the file. I think you'd use namespaces to separate functionality defined in the same file. But you'd be better off just splitting the file. Hope that helps. Edit: The import in my example is kind of dumb. You wouldn't import something from Bar.ts and call it Foo. You'd probably use the destructuring technique to import just what you needed: import { Bar } from '../Foo/Bar' 
I'd suggest using only external modules. You can just export default interface (...) and include file using normal import. For namespaces you can make "export import" statements.
Thanks for this! At the end of the day I do "get" that TypeScript is just a language.. But to go back to a simple example, let's say that my "app" does one thing: on page load it fetches some data from some service and draws it. With "normal" javascript, let's say jQuery, I might do something like this: $(function() { $.get('http://stuff.com/data.json', function(response){ window.myApp.renderState(response); }); }); I might have this before the closing &lt;/body&gt; tag, or something like that. So I'm guessing perhaps this bit of code might still be required. This would "bootstrap" my app in theory (perhaps of course it would even be simpler, like ```window.myApp.boostrap();``` or something). Is it fair to say that in this example though, the "myApp" could be a TypeScript "class", and that might the entry point for TypeScript? Along those lines, let's say I wanted to use jQuery within TypeScript (is that where Typings comes in by the way?), so I could write a simple class for example that fetches data, using jQuery, etc. I guess this is where the disconnect is for me at this point!
&gt; the "myApp" could be a TypeScript "class" Sure. &gt; the entry point for TypeScript? There is no such thing. You might have an entry point for your app, but that is not related to using typescritp vs javascript. &gt; is that where Typings comes in by the way? Yes. Typings define Typescript types for existing Javascript code. The problem with some libraries is that they are written in an untypeable way. jQuery does a lot of different things depending on what you pass it. Sometimes that makes your code unable to take advantage of types. One example is Backbone models. They have the methods `set` and `get`, that takes the name of the property as a string. You can't use the property name string to determine the type of the property in a general way, therefore you lose the typing there. `get` can return *anything* as far as Typescript is concerned. This is called "stringly typed" code. But try it out. Typescript is awesome to work with. 
Just to add re:`typings`, it no longer has any purpose. As of TS 2, just use `npm` instead, e.g. `npm install --save-dev @types/jquery` In your closing body tag, put a script element with `src="bundle.js"` instead of embedded code. In your TS, the jQuery code would look identical to your snippet. But you don't need to add properties to the `window` object (i.e. globals). Hide all your definitions inside modules. The TS docs show how to use webpack to build a single JS bundle from a set of TS modules. I wouldn't recommend shoehorning classes into a project. They have a specific purpose in JavaScript: to represent objects with methods in a way that saves memory. This is only important if you are going to create a lot of instances. In most business apps, you aren't going to. On the downside, classes use `this`, which is error prone in JS, and TS has not (yet) made it entirely safe.
dont use tyescript
QuickTip for the QuickTip: You can just do `npm init -y` to quickly get a package.json.
Why are you trying to equality-compare two variables, the values of which you can statically determine?
Yes, but you're setting the value of the variable to a literal, which means a static analyzer (the TypeScript type checker is a form of static analyzer) can guarantee that the equality check will evaluate to false in this case.
Use `--save-dev` for type modules, as they are only needed to build the module, not needed to consume it.
Thank you! Wish I knew that a long time ago.
You're right!!! I'll annotate that in the video.
Most of the package managers have this `jspm init -p`, `tsc --init`, etc.
Looks like an updated reference syntax as well! ``` ///&lt;reference types="jquery"/&gt; ``` This is also valid. 
you sure? I got `error TS1084: Invalid 'reference' directive syntax.` typescript@2.0.6
I hope so, too much efforts I put into this project. As you can see its already being developed for 12 months
There should be no need for triple-slash references at all. If TS can't resolve it automatically, I would say something is not properly configured.
As a bit of a newb, I found that confusing, as follows: 1) In your second image of a command-prompt, are you typing "type-acquisition npm install....", or just the "npm install...." ? It's not clear, like, why would "type-acquisition" be a different colour? Also, why does your *first* cmd image not have a "-&gt;" showing, buy your second one does? Is that your cmd cursor, or what? 2) You go on to say: &gt;Using npm again, you can now install the @types/lodash package which contains the... But then a couple paragraphs later say: &gt; Finally, they can be quickly installed with a package manager that's set up already anyway So.....installed twice? Do I install something that is installed....yo dawg....I don't follow So yeah, I'm a newb, and yeah I get that these blogs assume I already know what I'm doing :( 3) "Where Do the Type Declaration Files Go?" In your image showing where they go, you haven't shown enough up the tree to determine if that's my project folder, or is that the npm folder, or where the context is for that tree.....where *do* the type declarations go? Just musings from a newb I guess.... *edit: not trying to be cynical or anything - thanks for the post and I appreciate the info! 
1) looks like the first cmd is actually text (most likely the code style for the site in question) and the second is an actual screen shot. type-acquisition is the name of the directory he is currently in. I'm assuming he customized his cmd window to look that way (with the colors and whatnot). 2) Ignore that last sentence, when I read the article it didn't make sense to me either. Maybe he was trying to say now that it is setup it is easier for someone else to use the project and get the types necessary because they will only have to do one call to `npm install`. 3) From what I was looking at he showed enough of the tree. Structure is as follows `type-acquisition -&gt; node_modules -&gt; @types -&gt; lodash -&gt; index.d.ts`. The `type-acquisition` folder is the project directory (node_modules is typically in the root directory of a project).
YES! I just figured this out. For the most part, as long as your types are installed from NPM you don't need to declare types. :) With a few issues. I've noticed some type declarations aren't ready for prime time. Like 'del'. Del is referring to ```Promsie&lt;T&gt;``` but should simply use ```PromiseLike&lt;T&gt;``` to avoid errors.
I was excited that a "set up this environment and have a simple example" was going to be around 3 minutes long. Sad that's not the case. Although not shocked either, in fairness.
That's true if my package is another library *and* types from my dependencies "leak" out into my `index.d.ts`. But if they are internal to my implementation (or my package is a command line tool) then I put them in `devDependencies`.
Hello, sorry for the misunderstanding I tried to mark it as an announcement as much as possible via title, annotations and post, thought it would be cool to announce it before the release. Next time i'll add the word announcement, its the first time I'm announcing a course before its ready. I will publish at least a one hour sample probably more on YouTube, so there will be a lot of the material available for free, I'll try to put around a third of the course for free. 
`npm install @types/d3`
I've created a small project in typescript and d3. https://github.com/rasmusprentow/sf-film-visualization It uses version 3 and not version 4 though. But as mention with the latest you install each module by it self instead. Npm install d3-selection @types/d3-selection 
Here's a fairly simple example with v4 - [Bollinger Bands](https://github.com/paulhoughton/bollingerbands)
Thanks, that's very helpful. Same code doesn't seem to give me a list in Chrome. Do you know how much these same values are used in Chrome / Safari / IE?
Yea, only Firefox has those nonstandard KeyboardEvent.DOM_VK\* constants. That's why you have to put them in a module if you want to use them outside of Firefox extensions. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode There is a lot of overlap, but unfortunately also a lot of differences. Alpha-numeric keys, arrows, pgup/pgdn, space, backspace, return, tab, and simple stuff like that works, though.
&gt; couldn't you make a main entry point Absolutely, and I think you should. There is however nothing magical about it. As you mention, you would have to kickstart the app manually somewhere. Also, this has nothing to do with Typescript speciffically, but is how Javascript works. 
Make sure the correct dts is being referenced. I would try including the reference declaration.
Typescript is the same as JavaScript. You're new to Angular, not TS (:
I mean, mabye its just me but http calls in typescript/angular 2 are not very intuitive, i've made something similar to this in javascript/angular one already 
ok, doing that makes it so that my ngFor populates the list items with [object Object], just woke up so i'll keep working at it 
Whaaaaat?! Why does this work? And what would I use it for?
Have the data, draw, etc methods return the object itself. On my phone, so apologies if the formatting is messed up. public draw() : LineChart { \\ do stuff return this; }
Is this what you mean? var path: SVGPathElement = document.createElement("path"); 
hmm but it doesn't work for me in VS Code drawLine(): SVGPathElement { return document.createElement('path'); } I get [this error](http://screencast.com/t/a68cVmdk3).
You need something like this: drawLine(): SVGPathElement { return document.createElementNS("http://www.w3.org/2000/svg", "path"); } You might define this helper... const createSVGElement: (kind: string) =&gt; SVGElement = document.createElementNS.bind(document, "http://www.w3.org/2000/svg"); Edit: I should mention that the lib.d.ts file [has overloads](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.d.ts#L7027) for various types of svg elements as long as you call `document.createElementNS` - therefore, there's no need to use a type assertion. The compiler knows that `document.createElementNS("http://www.w3.org/2000/svg", "path")` returns `SVGPathElement`.
Or create a method on Person called convertToCitizen() that returns a Citizen object.
What is the difference between a Person and a Citizen? Why do you want to convert an instance to its superclass, that doesnt make sense to me.
Converting a Person into a Citizen doesn't make much sense - what value do you assign to the Citizen's socialNumber (that Person does not have) for example? What problem are you trying to solve?
I will probably do that if there is not better solution, but it's not easily maintainable.
I think others are offering good advice but to answer your question directly, you could use an automatic object mapping function or library. http://stackoverflow.com/questions/18140902/underscore-js-object-object-mapper https://stackoverflow.com/questions/36970419/javascript-object2object-mapper 
You can filter only typescript libraries on github and sort by popularity. Also take a look on my all pure typescript libraries [here](https://github.com/pleerock)
Aaand they pulled it because it overloads npmjs.org. https://code.visualstudio.com/updates#_17-rollback
This technique has been a game changer for me.
This is cool. I got a bit curious so I tried function foo(readonly bar: number) { ... } as well as function foo(const bar: number): void { .... } But none of those worked. Basically, I'm wondering if there is a way to tell people that "my function will not change the variable that is passed to it" in TypeScript.
So, shall we wait till microsoft makes their own rep for @typings, and will use yarn-fork to reduce load?
What is yarn-fork? I only know of yarn, but that still uses the npm repository so it wouldn't change anything I imagine
If I recall correctly, Intellij, which WebStorm is built upon required a lot of memory, maybe your RAM is not sufficient and your OS starts swapping out memory. If you have a lot of RAM you can try to increase the available vm-heap-size (Intellij is JAVA). I also switched from Atom which were too slow and the autocomplete was sluggish. Personally I don't get why you're switching, vscode just seems so much better for me. I've got two projects open in two windows and it uses less than 1GB of RAM.
You're trying to do the opposite of what my team has done. We all used IntelliJ and then Webstorm for a few years until we moved to VSCode this year. Webstorm really is just slow. There are a few things I miss every now and then, but VSCode is just so much faster, and the autocomplete for typescript is just about perfect.
Yes, very slow, even after increasing memory allocation. I just started experimenting with VSCode and I'm blown away by how snappy the TS integration is.
I am not sure what is your endpoint (ie where you want to deploy this code, its node.js or browser or something else), but I'd suggest using modules instead of namespaces. You might have to type more code (import xx from yy) but you gain better project structure and protection this way.
This is actually a lot of the reason I was trying it on my own. I work at what is mostly a mobile-app company. The project I'm on had the web team using VSCode (mostly because of typescript). We ended up needing some extra resources, so we borrowed from the Android team. After watching them mix up hotkeys and hearing constant complains about "Android Studio *this*, and IntelliJ *that*", I thought it might be worth looking into WebStorm to see if we could ease some of the burden if we ended up having to share people again. There are a few other things I liked (at least in theory) about webstorm too. But I'm beginning to think it's not worth it. 
Dude. Ho-ly-cow. It's not even CLOSE. It's CRAZY how fast the TS autocomplete in VSCode is compared to WebStorm/Atom.
This did help. For sure. It's still not great - and I think I may end up going back to VSCode (at least for now), but this is definitely a good tip.
1. As far as I remember, you cannot really protect variable inside namespace, while in module it is you who decide what can be altered from 3rd party modules. 2. When using modules, your internal application modules are in the same technical level as 3rd party modules are. So your program is a composition of modules that refer other modules, either your or 3rd party library. This is simplification for me. 3. It is easy to see requirements for modules to work. For example you can have an URLManager namespace, but you have no slight idea on what it does depend. In modules pattern, you will see few import's on the top and you can move your URLManager to another project or whatever by just making sure that imports will be fullfilled properly. 4. Not sure if namespace pattern can do this as well, but in modules you can only require a certain thing from module instead of whole module. This can be optimized to not include all of the code in resulting bundle. For example, you might have a PriceCalculator.ts that has several really big functions. Now you can share this file in few projects (for example in your ionic frontend and your node.js backend), but frontend only needs one function, so you can just import that one function and your bundler will not include rest of module into resulting .js file reducing its size and increasing performance. It is very hard to judge if a function is used in NAMESPACE, because you could for example do that: namespace XXX { function doSomething(){...} } and then you can write a code like this: let x = 'do'; let y = 'Something'; XXX[x+y](); and this will actually call your function doSomething... So you see it is impossible for bundler to judge if that function will be called because of JS dynamic nature. In the other hand, with module pattern if you "import { doSomething } from './namespace'" then it is IMPOSSIBLE in runtime to execute any other function from './namespace' module so bundler like webpack or browserify can just ignore rest of your module. 5. Name collisions are problem too. Its quite easy when you have small project with few files, but as it continues to grow, you will probably run into name collision someday. 6. One probably most important thing - modules are handled differently than namespaces. Modules are self contained building blocks of program, while project based on namespaces is just a big .js file that is concated from several files. This means that your runtime actually depends on ORDER of these modules are bundled in final .js file. One day you might have ModuleB that calls ModuleA in its initalization part, but some day a programmer decides to refactor and move your ModuleA to different directory / different file name causing TS to compile files in different order, causing application to crash. Thats what I come across, but remember one thing. The worst side of javascript for JS community was always a "lack of module system". There was thousands of name clashes and weird errors in community just because of that. Tools like Browserify or Webpack just add a module system to raw JS files and thousands of people are using them everyday. Even more, the ES spec actually developed proper module system in ES6 specification. (please note that you can easly achieve equivalent of typescript namespaces by making an objects or self-invoking functions - so back in days, JS developers had the same "feature" as you, and still community decided that we need real module system) I strongly believe that all those people, who complained, who developed tools, who pushed ES into direction of having a module system had really good reasons to do it, probably much more than those six I have written here. Discarding all of those people work because you dont want to type few extra chars seems a really bad idea for me, especially because it wont make you develop a project faster actually because 80-90% of programmer time is spent on READING code, not writing it. 
Yeah, it's not a silver bullet. WebStorm is a beast and it's all about how many bells and whistles you want. Kinda like a framework vs a library. At this point I feel like it's mostly Stockholm's syndrome for me.
Sooo you're saying go with namespaces...just kidding I definitely can see the benefits of the module approach. Wasn't aware that namespaces leave everything in the global space. Thanks for the detailed response.
Only the outer `namespace` go to the global space. Everything else stays inside. If you make out good names for those, it's very unlikely to hit any name collision. Personally, I like `namespace` pretty much for small projects. They're easy to compile w/ just _tsc_ and doesn't demand any 3rd-party packing. BtW, `namespace` is pretty old TS feature! ;-) 
like.this.ts
I was under the impression that this naming scheme for specifying the type of the contents (eg. Angular components). If you had a class titled `LikeThis`, would you name it `like.this.ts`?
Thought I was the only one
I find it odd how many developers are using camelCase and PascalCase files. That can be a nightmare when moving between linux and windows systems
Yeah, I'm with you here. `foo-bar.component.ts` would the style I'd go for, the class would be called `FooBarComponent`.
Personally, I use C# naming conventions because I'd really rather be working in C#.
Oh like that, personally my OCD would take the best of me and all use the same style everywhere :D
As long as you stay consistent and don't use `thisFile.ts` and `ThisFile.ts` in the same directory you should be fine though.
Really? Normal renaming in Explorer works for me just fine.
I use this now to force a check on the return type of certain functions, so that you only have access to the value if you do if (!resp.ok) { return; } That way I can avoid exceptions like the plague.
Full example: *image.html* &lt;img/&gt; &lt;script&gt; let image = new Image(); image.onload = () =&gt; { let canvas = document.createElement('canvas'); canvas.width = 200; canvas.height = 200; let ctx = canvas.getContext('2d'); ctx.scale(1, 0.5); ctx.drawImage(image, 0, 0); img = document.querySelector('img').src = canvas.toDataURL(); }; image.src = 'tumblr_nwegbkPlip1s4dpgxo1_1280.png'; &lt;/script&gt; Note: This has to be served via some webserver. Localhost won't work. (Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.)
I thought I'd share a small personal project I completed using Typescript. **Purpose** Create a view showing the listings of my favorite TV channels so that I can look up what's on TV, from the TV, while I'm sitting on the couch. **How it works** I press a button on my TV remote and the TV switches from shows to the TV listings grid in the original topic link above. A Raspberry Pi with the Chromium browser full screen showing the listings page is plugged into an HDMI port on my TV. There is no user interaction other than switching TV inputs. The grid refreshes and scrolls to the bottom automatically after 10 seconds, then repeats again from the top. **The code** The Typescript code associated with this page can be viewed and stepped through, as source maps are attached. Use your browser developer tools to step through the Typescript as it executes. **What happens** * Function "main()" is invoked on window DOMContentLoaded. * JSON data for the current listed are requested through and XMLHttpRequest. * A series of collections are iterated over to build the HTML that is the listings content. * The cell widths are calculated using show start/end times and some extra adornments are added, such as "cont'd", and start/end times in human readable form. * To scroll the grid a css transition is calculated based on the size of the browser window, channels listed, and the cell height of each row. * A dynamic css sheet is requested based on that information. See http://tv.codebot.org/?method=css&amp;height=1337 as an example. * When the hour changes new data listings JSON is requested and the process repeats.
Is the source posted somewhere? Is there a backing server or is it all client side tech?
I need to set a css "transition" to achieve a slow change over time, in this case "transition: top 10s". I cannot set "top" directly, nor can I set "transition", I need to force the element to switch to a new rule, which is what triggers "transition" to fire. The way to force a css rule change this is to add/remove a class or psudeo class (:hover for example) on the element. So in short I to redefine the rule for "#listings.bottom" to reflect the size of the window. To me the easiest way to do this is to change the href on the stylesheet: // let areaOffset = calculateTheNewBottom(); get("#dynamic").setAttribute("href", `./?method=css&amp;height=${areaOffset}`); The other way would be to build a new &lt;style&gt;, delete the old one, fill its innerText, then insert it into the document body, like: // let areaOffset = calculateTheNewBottom(); // let newStyle = buildNewStyle(areaOffset); document.body.removeChild(oldStyle); document.body.appendChild(newStyle);. This seems way more cumbersome to me.
A few months ago I used TypeScript with the non-modular D3 v4 ("default bundle"). I got the type definitions here: https://github.com/tomwanzek/d3-v4-definitelytyped and included the global definitions the old fashioned way: ///&lt;reference path="d3-v4-definitelytyped/src/d3/index.d.ts" /&gt; Since then, the type definition page says it's migrated into @types but I haven't tried the new way. Edit: following the github page's link to https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11367 I see that you can now run `npm install @types/d3 --save` and it will give you d3 v4 typings. I tried it and it worked. 
Thank you! Calling my code inside image.onload did the trick.
Yup. Floats are screwy.
The exact behavior of those math functions is up to the implementation. Only 5 specific input/output values are defined. http://www.ecma-international.org/ecma-262/6.0/index.html#sec-math.sin &gt; Returns an implementation-dependent approximation to the sine of x.
Nope, I'm on Linux but the code should be machine independent. I was digging through the typescript compiler code. It isn't possible. https://raw.githubusercontent.com/Microsoft/TypeScript/master/lib/tsc.js Look for "ts.getDirectoryPath(options.configFilePath)". I need exactly the other branch: "host.getCurrentDirectory();". But if I pass the tsconfig file then there is no way to do that. Or if not there, just making basePath="" for the argument to "function parseJsonConfigFileContent()". I modified tsc.js to do exactly this and it works. The problem is that I won't be controlling tsc.js in production. This restriction doesn't make much sense to me. I wonder if this is a bug, a feature or something that was just not taken into account.
Oh okay, then on Linux just use a symbolic link. ln -s full_path_to_folder full_path_to_link If you want to use relative paths in the ln command, substitute full_path_to_folder with `readlink -m ..\relative_path_to_folder` You should probably make a bash script called foo.sh: #!/bin/bash ln -s `readlink -m foo` `readlink -m foo/generated_files/src` tsc -p foo/generated_files/my-tsconfig.json rm foo/generated_files/src Then mark as executable: chmod +x foo.sh And to run the script: ./foo.sh Be sure to mark your my-tsconfig.json (it should be marked with the .json extension because that's what it is, not .ts or typescript) with: { "compilerOptions": { "outDir": "src", //.. rest of config
2.1 looks awesome! Great job!
Its gotten a lot better recently, definitively worth a shot
It doesn't work for me. Animation bounces back around alternating viewpoints at about 2 fps. Chrome Version 52.0.2743.82 (64-bit).
Thanks for the feedback, I will look into this. Have you tried Firefox or maybe another computer? I have a Macbook Pro (early 2013) and it works fine in Chrome, Firefox and Safari. In any case, I've uploaded a video to the post so that people can see the code in action.
Not possible with the current type system. Using `1 | 2 | 3 | ...` is your best bet, but it's hard to tell without knowing your valid usecase. Typescript is gradually typed so you need to know when to try to get full type safety and when to move on to something more productive. 
just make a class to handle this. class myNumber { private value: number; constructor(private minVal = 1, private maxVal = 100) { if (minVal &gt; maxVal) { throw new RangeError('min value is great than max value'); } } public setValue(value: number) { if (this.isValid(value)) { this.value = value; } else { throw new RangeError(`${value} does not fall between ${this.minVal} and ${this.maxVal}`) } } public getValue(): number { return this.value; } private isValid(value: number): boolean { return (value &lt;= this.maxVal &amp;&amp; value &gt;= this.minVal); } } **edit:** cleaned up code and handled cases a bit better
[`/// &lt;reference path="./index.d.ts" /&gt;`](http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html) there's options for [tsconfig.json](http://www.typescriptlang.org/docs/handbook/tsconfig-json.html) too, look at `files` or `typeRoots`
Yes, my company used to have that problem before we changed to a modular structure for our app. Once we moved to explicit import / export things sped up significantly. Lots of ///reference&lt;&gt; tags at the top of your files seems to bring everything into the global namespace and it kills the speed of lookup. There may be other reasons as well including the third party .d.ts files you are using. Adding typing also seemed to help, when a variable is typed it didn't attempt to. Backtrace the properties to generate and auto complete list.
Love it. Consider adding a string enumeration for the string constants.
The title says compile time, but this is run time.
The data is checked at run time, yes, but it is uncertain at compile time (and hinted to the compiler via ADTs). That's what I was trying to say. Sorry for any ambiguity there.
I know it will stay... I'm asking what people's *style* or *conviction* is about changing it in their existing code, or code they are writing now?
New code gets completely let-ed. Old code doesn't get updated unless it's easy and I have to touch it anyways. Not going to update old code just for the sake of it
const is my default unless I need let. I think Kyle Simpson wrote about this, and it's worth reading if you can find it ( his blog seems to be down at the moment ), but I'm pretty sure he gave a valid case for using var in some rare instances.
IMHO you should be using const by default, then let for the times you intentionally want to have the value change.
I like this. This is more intent descriptive. I've been doing this more. When a var is not going to change, I use const inside a function. 
My linter tells me that I should use 'let' instead of var. Who am I to argue with the linter? For the record, angular-cli configured tslint with "no-var-keyword" set to true.
Exactly what I do. I imagine in the future const will allow for optimizations in the js vm.
I have been using TypeScript for longer than plain JS at this point. I can't remember one instance in the last year where I used var instead of const or let. And I use const in 90% of the cases, maybe even more. I guess that if I thought I needed a var for something, I'd be more inclined to make it a class property, but that's not any kind of hard and and fast rule.
That's my policy. I tag my code with "quality levels", where each level represents best practices from a given time. That way I know at a glance what needs to be done when I do have to touch the code to add a feature. 
`sed s/var/let/g ./**/*.js`. If anything breaks, you should feel bad.
My default is `const` for anything which isn't supposed to be re-assigned! However, both `var` &amp; `function` are forever necessary for the global namespace. B/c neither `let`, `const` nor `class` allow re-declaration. And they'll throw an exception! Also neither of those 3 hoists their variable. 
Two examples from the PR: function pick&lt;T, K extends keyof T&gt;(obj: T, ...keys: K[]): Pick&lt;T, K&gt;; function mapObject&lt;K extends string | number, T, U&gt;(obj: Record&lt;K, T&gt;, f: (x: T) =&gt; U): Record&lt;K, U&gt;; Personally, I've been wanting a nicely typed way to do `mapObject` for a long time. Basically pass in an object with a given set of keys and return a new object with the same keys but different values.
I saw those, but they are still not very clear to me as to how they would be used in practice.
Nice work! Check out https://github.com/Jimdo/typings-for-css-modules-loader if you want typings for the css.
 ``` [ P in K ] : T ``` Each item in `K` becomes a property (`P`) with type `T`. ``` type Foo = { [ P in "x" ]: Date; }; ``` is the same as ``` type Foo = { "x": Date; }; ``` It becomes useful when `K` has more than one value that you can `map` over. ``` type Foo = { [ P in "x" | "y" ]: number; }; ``` becomes ``` type Foo = { x: number; y: number; }; ``` 
I just stick them in with the rest of my sources.
Yes
Thank you VERY MUCH for your input. This is my first truly open-source project that I plan continuously working on. A couple questions/comments: * Please expand upon the readFileSync "killing shit" * I love the idea about splitting the files up to allow for easier PRs. * Currently in the middle of refactoring doSearch actually :) * When reusing the server, it causes an issue that's rather lengthy, it was easier (maybe still not right?) to re-create. * Lawyer action? I am not hosting anything but an innocent multi-search provider ;) Maybe a disclaimer of responsibility? * How might I reduce FOR loops? EDIT: There is a readme. I will add examples though! 
Makes sense. :-P
John, you cannot use 'module' in regular typescript files (ts). 'module' is used in type definitions files (d.ts). To correct your case you can try the following (use namespace): export namespace Shapes { export class Rectangle { private height: number; private width: number; constructor (height: number, width: number) { this.height = height; this.width = width; } } } *p.s. [tslint] The internal 'module' syntax is deprecated, use the 'namespace' keyword instead. (no-internal-module)* 
Yes the problem is relative to "import" no declaration or export. 
I would definitely say yes. Don't do that.
If you get on the slack channel I'm there. In one of my previous comments, I included a link to configuration using webpack/babel. It's very basic.
General practice is simply to NOT use ```var```. Change any ```var``` to ```let```. And if it's like the sample above, use ```const``` for all those require statements because they don't change within the scope it's declared.
Yeah.. Not my project. Just got a wild hair up my [bleep] to refactor to TS. Subscribe to my channel for other insights and in early 2017 I'll be publishing a Udemy course.
It's in RC still, not available in stable quite yet. 
If you have questions about anything there, don't hesitate to comment on the video.
Can you use this with a method in a class? 
Yuppers - you can install from the @rc tag though https://blogs.msdn.microsoft.com/typescript/2016/11/08/typescript-2-1-rc-better-inference-async-functions-and-more/ &gt; npm install -g typescript@rc 
Yep, TypeScript is a transpiler/compiler; Flow is only a type-checker. TypeScript ~= Flow + Babel IDEs support is a lot better for TypeScript. Also why boring with the configuration of two tools instead of one?
Hmm... I read up and a 'lambda expression' does mean an arrow function... But I see your distinction here.
This is a good clarification. It's worth noting that they are semantically different because arrow functions preserve "this", and in doing so create trivial overhead preserving the reference. See the compiled TS for the difference :)
JS' arrow functions come from CoffeeScript's fat arrow function syntax: `() =&gt;` Besides the "fat" 1, CS also got the "thin" 1 which doesn't bind `this`: `() -&gt;`. http://CoffeeScript.org/#fat-arrow 
&gt; JS' arrow functions come from CoffeeScript's fat arrow function syntax C# had them a couple of years earlier than CS.
It's an arrow function. In this case, the body is a block instead of an expression. MDN refers to these kinds as "block body" and "concise body".
it's so nice. I always thought null is not enough and adding undefined is a great thing in js. But it seems things just got better, now i even have never. /s but honestly, why? what does it solve?
I second this 
Excellent Job!
three.js typings work great. you can find them in the typesearch from microsoft.
Whilst it would seldom be used, I can't see the harm in exposing it. The reason is it's going to be hard to be misused. This isn't like a System.Reflection namespace, this is a real type that you could signal your intent in a method with. Plus one of the nice things about TS is the improved opportunity for control flow analysis.
pixi.js is good too for 2d. 
The way I think about it is this: * 'anonymous function' and 'lambda expression' are interchangeable * 'arrow syntax' is one possible syntax for the above concepts (in JS - in C# it's the only syntax) * 'arrow function' is therefore a portmanteau of 'arrow syntax anonymous function' It works in my brain.
Thank you for the share! I've been doing React and had been (very passively) looking for a way to document without it becoming a hassle. I think this will fit the bill nicely!
You don't need 'never' for that.
Because `never` provides a better description for certain real-world use cases. For example: function alwaysThrows() : never { throw new Error(':-('); } This function will not return `null`, nor will it return `undefined`. Before TypeScript 2.0, we would have to give it a `void` return type, but then we'd wrongly assume that it will (eventually) return. With TypeScript 2.0, we can more accurately describe its behavior - and the type checker can use that information to deduce even more information in other parts of our code. In the end, the job of the type checker is to catch stupid mistakes at compile time instead of having them crash your program at run time. With the `never` type and the control-flow based type inference, it can catch *more* kinds of errors. If you don't need it, don't use it (but then why even use TypeScript?). By exposing the `never` concept to the programmer, it can be used to annotate impossible types or impossible control flow paths in your *own* code, and have the compiler check these for you.
Same here :/
proper pattern matching?
Not with TS/JS
This video explains basic of Typescript static typing and type inferences
I think you can also do: if ('myProp' in myObj) { ... }
A union type describes a value that can be one of several types. We use the vertical bar (|) to separate each type, so number | string | boolean is the type of a value that can be a number, a string, or a boolean.
But what if not lodash.
Then of course, use one of the answer offered, which are harder to read and maintain IMO. Lodash is one of the first things I install on every project. It's just a staple library, like moment.js.
Right, that's the other one.
You can define interface to define shape of a variable. Defining interfaces in typescript is easy.
Totally. I think everyone should absolutely know how to do this without a library, no doubt. In my experience, especially when working in a team, it's just much better to lean on tried and trusted libraries like lodash for this stuff. Less brittle code === win.
Sure.
Typescript classes, constructor and initialization. Static methods in classes.
&gt; typeof obj.prop!=="undefined" Just compare directly with `undefined`. The global `undefined`, `NaN`, and `Infinity` values are read-only since ES5.
This is the second one of your videos. Just put together a playlist and post a link to that. Save some time and reduce noise here. 
Ok so you suggest simply: ``` if(obj["x"]===undefined) {} ``` ???
Don't write code where something could be `T | undefined | null`. It's terrible enough if it can be one of those null-ish values. (TypeScript's non-nullable types are super awesome, by the way.)
You are promoting yourself badly 
Yeah I'd have to disagree with ==. Because zero is a valid value but matches null. As well as empty string. Sadly, you have to check both null and undefined individually to be sure.
Yeah, this seems to be the winner because it works with everything. But I still might be more inclined to use ```in```. I was concerned about this because I swear there was a time long ago where asking for obj.x threw an error. Now, not so much. The other side fo this obj.x===undefined problem is that it IS possible to have x exist as a key on an object, but equal undefined. :/ ``` function Obj() { this.a = "goodbye"; this.b = undefined; } p.hasOwnProperty('b'); // == true ``` 
foo.x !== undefined // has an 'x' property which is something else than undefined foo.hasOwnProperty('x') // the object itself has an 'x' property 'x' in foo // the object itself - or another one in the prototype chain - has an 'x' property &gt; I was concerned about this because I swear there was a time long ago where asking for obj.x threw an error. You get an error if you write foo !== undefined and foo wasn't declared. You don't get one if you use typeof. Anyhow, this detail doesn't really matter since all of your let/const variables are in-scope and, if they aren't, you get a squiggly line like you would get in any other language. So, it's a complete non-issue.
Although both `undefined` &amp; `null` are 2 of the "falsy" values in JS, it doesn't mean comparing them w/ `0` or `""` would result `true`! Try it yourself right in your browser's console: console.log(undefined == 0) // false console.log(null == 0) // false console.log(undefined == "") // false console.log(null == "") // false console.log(undefined == null) // true Only `undefined` &amp; `null` comparisons result `true` w/ `==`. And of course, `false` w/ `!=`. :-P 
An enum is a way to organize a collection of related values. Many other programming languages such as Java have an enum data type but JavaScript does not. However TypeScript does. 
The destructuring assignment syntax is a TypeScript expression that makes it possible to extract data from arrays into distinct variables.
Right... I guess I've just gotten over cautious. You have to use ```==``` properly.
There is one thing that flow has going for it which TypeScript doesn't: Because Flow is only a type checker plugin for Babel, you can do a lot more 'bleeding edge' stuff which you can't do with TypeScript (because TypeScript is not pluggable.. yet) 
Right... I honestly thought null==0 // true. :( And it is not. So this is very helpful. Thank you. I can see how I could simplify my code now. 
I just hate to have so many ref. With typings, I can just simply refer to index.d.ts and done with it. 
You dont have to do it at all. TypeScript 2.0+ automatically resolves node_modules/@types/* for you, you dont even have to include it anywhere.
Cool! So just import * as koa from "koa" is enough?
Yes, as long as you install the types and have typescript 2.0. not sure if you need node module resolution on as well?
I think that is true UNLESS you have excluded node_modules in your tsconfig.json
typescript functions
implement update as an Action&lt;int&gt; property in the Thing class
Although it's probably a good idea to have it on given that `classic` is [only present for backwards compatibility][tsconfig]. [tsconfig]: https://www.typescriptlang.org/docs/handbook/module-resolution.html 
Or: - you have specified `typeRoots` in your tsconfig and haven't included `node_modules/@types` - you are trying to use a global ambient type and have either explicitly set the `types` value in tsconfig so that it does not include it. Example, installing `@types/node` but setting `types` to `[]` will stop the node types from appearing.
So I can't override the method as an anonymous class like in Java?
I'm not particularly commited to any runner or framework per-se. My top priority is good coverage docs without hacks.
**ELI5**: Definitions files are like instruction manual to help the typescript compiler understand plain javascript code. They contains the availables functions signatures and variables types of a given javascipt file. **Q**: do I need to learn TypeScript to use definitions in a project ? ~~**A**: Yes, or rather, you need to ***use*** Typescript.~~ **A**: No, VSCode uses the Typescript compiler in the background to provide Intelisense to javascript files. [More information on VSCode site](https://code.visualstudio.com/Docs/languages/javascript) The Intellisense come from the compiler itself so you need to compile Typescript files or use an IDE who uses the compiler in the background to get any Intelisense out of the definitions files. I find that Webstorm gives fast and 'good enough' Intellisense *without using any external compiler or definition files*. Its far inferior than its Java counterpart but its way better than anything I used. [To find available definition use this link](https://microsoft.github.io/TypeSearch/) [For more information on how to install definitions](https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/) Happy coding :) Edit : Typos and changed my answer now that I know more about ATA and how VSCode uses the Typescript compiler and the language service. 
Good article in my opinion
looks very well thought out (disclaimer: haven't used it, only read the tutorial). I'd be unlikely to use it though, because of the verbosity of declaring the schemata. I'm aware that Typescript is tying your hands in a big way here because of how all type information is stripped at runtime, however if there was some way of automating this to be able to declare schemata with native typescripts `type`s and `interface`s, I would be so happy... probably impossible though. :( 
**Update answer based on reply**, In VS Code it will automatically find you types. (However this method is still useful if you want to use an older api. For example I am still using it to use the older d3 v3 api.) You can definitely use @types to give yourself Intellisense without using TypeScript directly. I've noticed that in VS Code the editor provides Intellisense even when I'm in a .js file ~~(if I've installed the @types)~~. If you're using VS Code you're also in luck because it ships with TypeScript. *VS Code will automatically acquire types so below isn't necessary.* To get Intellisense for node I do the following in the command line: This initiates the typescript config file: tsc --init And this provides the Intellisense: npm install @types/node --save-dev Hopefully this helps!
You could probably extend The Window interface, interface MyWindow extends Window And use that one. 
&gt; (...) in VS Code the editor provides Intellisense even when I'm in a .js file (if I've installed the @types) Installing `@types/*` dependencies is [not needed anymore as of 1.7.2](https://code.visualstudio.com/updates#_better-javascript-intellisense). VSC acquires types automatically for JS code.
This ^. Also, don't name your interface "Window" as that is a predefined type. ``` interface WindowInterface extends Window { foo: bar; } ```
Use a global augmentation: declare global { interface Window { ... } }
I tried the following. The error went away, but it can't find window.React (undefined) when I check in the Javascript console. import * as React from "react"; declare global { interface Window { React: any; } } window.React = React;
The suggestion from /u/tenkennosoujiro is the correct answer. Remember that TypeScript's type information is completely removed at runtime and that TypeScript is not generating any magical runtime code. So if `window.React` is `undefined`, then either: a. your import statement is getting `undefined` b. the last line, `window.React = React`, is not executing You can put a breakpoint on that last line and make sure it is actually executing.
The point seems to be towards the end of the section: &gt;Interface types have many similarities to type aliases for object type literals, but since interface types offer more capabilities they are generally preferred to type aliases. For example, the interface type &gt; interface Point { x: number; y: number; } &gt;could be written as the type alias &gt; type Point = { x: number; y: number; }; &gt;However, doing so means the following capabilities are lost: &gt;* An interface can be named in an extends or implements clause, but a type alias for an object type literal cannot. &gt;* An interface can have multiple merged declarations, but a type alias for an object type literal cannot. So it seems like interfaces might be the way to go for everything, until you consider mapped types: type TestKeys = "foo"|"bar"|"baz"; interface ITest { [k in TestKeys]: string; } type Test = {[k in TestKeys]: string}; The interface declaration is invalid here, since they don't support this kind of property declaration (For now?). And then there's type operators: type FirstType = { foo: string, bar?: number }; type SecondType = { baz: boolean }; type MergedType = FirstType &amp; SecondType; type EitherType = FirstType | SecondType; const mergedObject: MergedType = { foo: "I am foo", bar: Math.PI, baz: true}; const eitherObject: EitherType = { foo: "I am still foo" }; const anotherEitherObject: EitherType = { baz: false }; So, from what I can gather: * Use interfaces when enforcing a structure on something which is not a parameter or a property, like a class or another interface, or if you have a specific use for multiple merged declarations (Which you probably don't if your code base is tidy). * Use types in all other cases. They're generally more flexible with their `&amp;` and `|` operators, as well as the recently-added mapped types feature.
This is what worked for me finally. It was not working due to some config issues (which I wasn't able to sort out). I nuked my config and followed the instructions from here: https://medium.com/@fay_jai/getting-started-with-reactjs-typescript-and-webpack-95dcaa0ed33c#.uhentctwb
what about libraries? Also, do you feel yourself more c# guy or php guy? 
I cant even image how much TypeScript helped me with development various projects, mobile applications, frontend, backends. I am in love with TypeScript as it saves hours and days. I am scared to write even hello world application in raw js.
I think it's mostly that way because of the aesthetic similarity of async/await in C# and Typescript. 
A lot of people point to arrow functions as well, but they are ECMA spec, not a C# inheritance.
As a mainly PHP/JavaScript full stack developer with very little C# experience, Typescript has rocked my world. I never want to go back. 
I don't think it has much to do with JS or TS, but programming in general. Why would you silently fail? IMO only in situations where you are expecting a failure and testing for it.
Fail loudly _and as early as possible_. Not doing so is postponing the inevitable (and frequently making it worse).
&gt;Stepping outside an array's bounds returns undefined rather than throwing an exception. Will throw an error in most other languages &gt;Nonsense math like 'foo' * 5 yields NaN rather than giving you a type error. Unless you cast to numbers, neither can you in TS. Will throw a type error on compile &gt;Accessing a nonexistent property is fine. &gt;Trying to add stuff to a frozen object is a no-op. &gt;You could call constructor functions without new. &gt;Implicit globals. &gt;You can't do any of that in Dart. Neither can you in TypeScript.
"I don't think it has much to do with JS [...]"
At my job, we have had pretty good luck. It's an agency, so tech stacks have varied team-to-team, and my current project was the first at our company to use typescript. When we needed help, the JavaScript guys from other teams had no problem picking up on type annotations, and most of the other syntax they were already familiar with because almost everyone at our company was already at least using babel. An added bonus, we also got help from some Android engineers, and they mentioned that Typescript helped them to transition easier from Java. On big libraries I think the benefits greatly outweigh the costs. The tooling seems to make it a lot easier to make yourself at home with a new codebase than it would otherwise be (intellisense and compile time errors really help in unfamiliar territory!)
At my job here in New York, it's taken hold very well with the folks with any kind of Java or C# backend. Those are all my peeps, so I don't know what it's like for pure JS people that haven't done back end development or other non-JS stuff. I think it's pretty easy to sell. Just pull up an editor that does intellisense and show them regular JS with a TS extension working with implicit typing. Then a million more things after that, of course. 
Would you explain why it's hard to migrate? If you allow lenient compilation options, can't you just change the file extensions from js to ts?
nice!
Okay, I have to admit, this is indeed a bit confusing. In a TypeScript interface, `new() : Type` denotes that this type can be constructed by calling it with `new`. For example: interface Foo { new (foo : string) : Foo; } let foo = new Foo("foo"); However, in order for a class to implement `Foo`, it should provide a *constructor* that is compatible with the `new` call signature. For example, this would be a valid implementation: class FooImplementation implements Foo { constructor(foo : string) { console.log(foo); } } In your case, replace this line: new&lt;LogicalEntity&gt;(target: LogicalEntity, handler: ProxyHandler&lt;LogicalEntity&gt;): LogicalEntity { with: constructor(target: LogicalEntity, handler: ProxyHandler&lt;LogicalEntity&gt;): LogicalEntity { **EDIT:** Wait... why are you're trying to implement `ProxyConstructor`? That's just an interface to give the global `Proxy` variable a correct type, it should never be used in your own code. I think you're confusing a lot of things here. Your original code defines `LogicalEntity` as an arrow function, but also uses `LogicalEntity.prototype`. Why is `LogicalEntity` an arrow function? What's on the prototype, are you trying to define a class? But if you're defining a class, then why does the `LogicalEntity` function return a `Proxy` instance? Could you provide some more code to have a better idea what you're *actually* trying to do here? Because it looks like you're making things unnecessarily complicated, and the *real* solution is probably a lot simpler than all... this.
Thanks for the reply. I actually figured this out a bit later after I posted this but didn't get a chance to reply. What I'm ultimately try to accomplish is the have a raw type and a proxy parameterized with the raw type to: - look like the same raw type - be used for type checking in react/tsx files When doing this in JavaScript, I followed examples of building new instances of proxies. So for the purposes of what I'm doing, the arrow versus standard function works the same way from a type checking perspective. interface Example { value: string } function ExampleProxy(raw: Example) { return new Proxy&lt;Example&gt;(raw, handler); } So now when I refer to ExampleProxy instances in my code, it will autocomplete with members of Example. So the first requirement is met. However, in my React/tsx files, these are not recognized as types because there seems to be strict differentiation between Functions and Objects. I am still missing something on this. I was going to experiment today with using the base interface in the tsx files to see if the proxy will be interpreted as the same type.
You should be able to just tell TypeScript that the `ExampleProxy` function will return an `Example`: function ExampleProxy(raw: Example) : Example { return new Proxy&lt;Example&gt;(raw, handler); } Normally, TypeScript should be able to infer this return type from the [Proxy constructor type definition](https://github.com/Microsoft/TypeScript/blob/v2.0.10/lib/lib.es2015.proxy.d.ts#L36), but it doesn't hurt to make it explicit. One possible problem might be your code somewhere calling `x = new ExampleProxy(raw)` instead of just `x = ExampleProxy(raw)`. TypeScript might get confused by the `new` operator and infer the wrong type (not sure though). To avoid confusing yourself, I would rename `ExampleProxy` to `createExampleProxy` so that it is more obvious that it should be used as a function, and not as a class with a constructor.
It *parses* correctly, but doesn't *type-check*. Every syntactically valid piece of JavaScript code is syntactically valid TypeScript. Note that, if every piece of syntactically valid JavaScript were type-correct TypeScript, then TypeScript's raison d'Ãªtre would be gone.
I have a simpler example. `1 == 2` Good luck compiling that as TypeScript. :) Although I agree with the other reply; of course you can't expect arbitrary JS code to type-check correctly in TS.
Damn the type system is now so powerful.
Wow, type mappings are amazing! Now you can pass an immutable version of any type just by using Read-only&lt;T&gt;. Typescript team is killing it. 
[dam son](https://i1.sndcdn.com/avatars-000185441357-os55ce-t500x500.jpg)
The TS team is incredible. I guess they use static typing :-) Now I think it's time for me to make the move ... Can you recommed tutorials on how to use TS with React / Redux?
Newbee question regarding Redux here: So I could use Read-only&lt;T&gt; for my state in my reducers and baaamm - immutabilty guaranteed?
Single-level immutability, yes. AFAICT it wouldn't apply recursively down the properties, but if the properties were all primitives, or you didn't need immutability down past one level, then you're good to go.
``` type Immutable&lt;T&gt; = { readonly [P in keyof T]: Immutable&lt;T[P]&gt;; }; ```
Not sure I understand how that works for primitive values? Immutable&lt;number&gt; doesn't make sense AFAICT?
If I have class P { foo: number; } it seems like Immutable&lt;P&gt; would have { readonly foo: Immutable&lt;number&gt; } right? I don't see how it would 'stop recursing' at the primitive types?
Basarat's online book is probably the best go-to reference+starter, and it covers a bit of React/JSX too: https://basarat.gitbooks.io/typescript/content/docs/getting-started.html For a quicker intro, there's a LOT of react+typescript scaffoldings on GitHub. Just do a Google search for one using your build stack of choice. Here's an opinion: using React with TypeScript is waaaaay easier than using it with JavaScript. Proper types for states/props and autocompletion for everything takes a lot of the friction and stupid mistakes out of development.
&gt; function times (count : number, f? : F0) : (x : F0) =&gt; any[] | any[] { function times (count : number, f? : F0) : **(**(x : F0) =&gt; any[]**)** | any[] {
ah! thank you very much!
https://www.udemy.com/stepping-up-to-typescript-fundamentals In case anyone is interested. :)
Well, using a class would encourage using mutable state which would go against the spirit of the framework. Do you see any benefits of using a class in this case?
looks interesting, any bigger examples?
Kind of hard to help without source, but did you just added types or what did you change more? Put a breakpoint and see why the object that should have a kind Nevers gets set. Feels like you did somrthing bad when converting.
What is the error you are getting? You should have the types for react in your package.json (@types/react). Is the error you receive when you try to use this hello world component in another file?
`return &lt;h1&gt;Hello from {props.compiler} and {this.props.framework}!&lt;/h1&gt;` Why is it using this.props for the framework prop? Also, as /u/cwmacdon said, maybe include the actual error/behavior you're seeing? Hard to know what's going on just based on the current description. :)
The error is as if the TS compiler can't find the module at all if there aren't any type definitions installed for it: TS2307:Cannot find module 'some-package'. The error is being shown in the file I have declared the untyped import itself. Based on the release notes for 2.1.4, as long as you have the module installed in the project, you should be able to just say: import * as Something from 'some-installed-package' without the need to install any type definitions from @types. 
I think your example code in the original post is missing something since there is no reference to react-modal.
That was my mistake in leaving react-modal in my response. I've been working on it and since my post I installed npm module react-modal and imported it in the same way; seeing the same issue. Check out the Bitbucket repo I just posted for this :)
Good job, we really need good instruction videos on TypeScript. I have two suggestions though, I hope you will consider them: - Always specify your types. It makes your code much easier to read. Turning ```noImplicitAny``` on might help with this. - Use ```const``` if you define a variable that's reference will not change. It not only shows your intention better but it will also allow optimizations for the browser once we will be able to compile straight to ES2015 in the future. Using TSLint helps a lot and the default configuration is great 90% of the times.
Thanks for taking the time to take a look. I'll make sure to open an issue for this tonight. 
I don't use gulp, just the typescript compiler. It works well for me. I advise you check out the Angular 2 tutorial. It'll get you setup with the most basic stuff you need.
Typescript as in other object oriented languages allows you to use types in class definitions
any chance you could stop spamming this subreddit with LQ, low effort videos? you've been asked quite a few times [to make a playlist](https://www.reddit.com/r/typescript/comments/5f1usf/typescript_enums/dagtzq4/).
I ran into something like this when upgrading my TS project to 2.x Read the docs here for help: https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html and https://www.typescriptlang.org/docs/handbook/namespaces.html and https://www.typescriptlang.org/docs/handbook/modules.html
So I opened an [issue](https://github.com/Microsoft/TypeScript/issues/12839) for this on the TypeScript repo and it turns out that as /u/HawkEgg pointed out, the compiler will look for an index.js at the root of the npm module by default, and if it doesn't exist then it throws the error messages i'm seeing. This is counterintuitive, but if you want to use untyped imports instead of just typing in import Something from 'some-module' you need to make sure you have the location of some-module's entrypoint (usually defined in the package.json) and type the path to where it is within the module. In my case, I needed to type out import Modal from 'react-modal/lib'.
Wow, yummy! It might be serious competitor for Sequelize, especially that Sequelize is not straightforward in TypeScript (though doable and perfect type safe).
Particularly relevant to the TypeScript sub as [this RC includes the latest TypeScript 2.1 RC and enables the Salsa language service by default](https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes#javascripttypescript). Much better JS/TS experience in Studio now, though Code still has my heart.
Either an IDE-compilation or awesome-typescript-loader for webpack. I prefer second one though build times on larger projects could be issue.
It would certainly be useful. At the moment I use underscores for private properties, then skip them when enumerating and indexOf("_") === 0.
Thanks!
I think this is a good idea. You could event create a decorator to make the code readable and allow the flexibility of using it or not. 
Instead of typings you can just do: npm i --save @types/pkg-name 
tldr; Active record for MVPs and CRUD apps that map cleanly to databases. Data mapper for complex business rules and procedures (or existing legacy systems). Data mapper will give you much more flexibility at the cost of designing up front. Active records will typically let you .save() anywhere in your application where data mappers will require an entity manager. Data mappers typically have better separation of concerns.
I'm not sure what you mean as an action does not interact with state at all. You can have multiple modules's state combined together using combineReducers, and if you wanted to have an action that has handled by two different reducer's modules, then using this you would need to define the action twice. I'm assuming you're asking about something like this. const moduleA = new Module({ initialState: { message: 'Hello World!' } }); const moduleB = new Module({ initialState: { count: 1 } }); const sharedName = 'actionName'; const sharedAction = (data: {message: string, count: number}) =&gt; data; const actionA = moduleA.createAction({ type: sharedName, action: sharedAction, reducer: (s, a) =&gt; { return { message: a.message } } }); const actionB = moduleB.createAction({ type: sharedName, action: sharedAction, reducer: (s, a) =&gt; { return { count: a.count } } }); const reducerA = moduleA.createReducer(); const reducerB = moduleB.createReducer(); const globalReducer = combineReducers({ reducerA, reducerB }); // .. in component later on... this.props.dispatch(actionA({message: 'A Message', count: 2})); // -- or -- this.props.dispatch(actionB({message: 'A Message', count: 2})); // both dispatches will achieve the same result, by calling the reducer in both modules. 
Thanks for your comments. I will consider your suggestions in feature videos.
Hi Thanks for your comment. there is already a playlist. Videos will be added one by one.
Sorry, yeah, I meant a reducer that has access to state in both modules.
I would discourage the use of namespaces in general. ES is very clearly adopting modules and the two are incompatible in TS.
Ah ok. That use case is not supported.
You could use them in different files and use modules to import, or require them, then you will have this dependency. Using a bundle, like browserify, rollup or webpack you can build them into a single file. If you need to have them in the same file for some reason, define all classes first, then create instances.
Yes, the whole thing is Promise-based, so you need to provide a polyfill for older browsers.
Perhaps the bundlers should be able to de-duplicate code? I mean, this article is good advice for the here and now, but in the long-term the bundlers should be better. In a reasonable world they'd act a lot more like a compiler, including inlining of very small function, deduplication of repeated functions, basic dead code elimination, and so on. You might even be able to make a case for more advanced optimizations like constant propagation and constant folding, strength reduction, and all that jazz; the browser's runtimes are nice and efficient, sure, but there are some JS runtimes out there that lack the fancy JITs, and being able to optimize for them could perhaps be mildly useful. Even if the JITs do optimize very well at runtime, pre-optimizing as much as possible would shift the burden to a one-time bundling operation on ready-for-release builds rather than pushing it out to every user's device. Could be nice for user's batteries or general startup speed for many apps.
That is a fair comment but what sparked the removal was the following: &gt;1. I was referring to an `enum` in the `global` space, so why would I need to pass it in? 2. The class didn't have it's own definition of `WORD_GROUP`, ergo a flaw in my logic.
This looks cool. I tried this with webpack/ts-loader, and it seems like there was no change in size. Maybe webpack already takes care of this type of code duplication.
Code samples available at https://github.com/inversify/inversify-express-example
So this is C#...
This looks really good. [tsoa](https://github.com/lukeautry/tsoa) has a very [similar syntax](https://github.com/lukeautry/tsoa#create-controllers) for annotating controller methods and controllers, with the additional bonus of generating a swagger spec and Express routes. I've been wanting to implement inversify on top of it as a way of doing DI on the controllers.
And ASP MVC, it's good to see new stuff adopt previous conventions that worked instead of going all anti-establishment (reference to the recent reactjs tweet)
It's created by same person. It's interesting to also see C# language borrowing from typescript now (eg c#7 tuples)
That looks a lot like [routing-controllers](https://github.com/pleerock/routing-controllers). I've been using it for a few months and it's absolutely brilliant. I guess you've convinced me to try Inversify out now. On a side note, couldn't you just do `export class ModulesController`? Is there a reason to do it at the bottom?
Please do not use async await, if you dont process the results. It will create quite an overhead. Just return the promise directly.
Use it. In half year it will be optimized as fuck anyway.
Using jest
In our node environment we use Mocha and assert from the node std. lib. Works really well. Mocha has a compiler option where you can use ts-node. Debugging works in our JetBrains IDE too. 
Same here. I've been using Mocha. If OP would like an example to look at you can find one of my repos [here](https://github.com/atom-morgan/typescript-api-starter).
Yeah it makes sense what did you write here. I am used to follow the convention of "always await if its promise" when I was using ES6 and Babel only - because this habit made me save a lot of pitfalls in raw ES6, for example this: It should be: let users = await UserRepository.getAllUsers(); But if you write it this way: let users = UserRepository.getAllUsers(); The code is correct too, but you probably expect an array instead of promise there. Hovewer in TypeScript I have another habit, that is always annotate everything :) So the upper example is not the case anymore. let users: User[] = UserRepository.getAllUsers(); This will throw compile error if you dont put await before.
Yes if you use the users variable it is completely fine to await the call. I only dont like awaiting a promise and then returning that result directly in an async method. Because async await adds complexity, Even though the method itself has completely synchronous flow.
[removed]
awesome, thanks for that!
Async await works great with an es6 target. I haven't looked into code coverage yet (previously used instanbul) but could really use it. Coverage is important. 
Yes you are right, but I am not sure if we should profile perfomance in such tiny degrees. I mean http server is not a 3D engine where every CPU tick matter. We write in things like node.js, python or php, because we CAN sacrifice some performance for more readable/maintanable/easy to learn/easy to launch/etc code. Do you really believe that a http server can have hog because of awaiting promise when returning? They are so tiny values it doesnt really matter much, so I prefer to just stick with convention.
lol, yea i guess probably not. i'm new to working on front end stuff, so i really don't know anything about unit testing for javascript/typescript. 
I experimented with backbone-style models with get/set: https://gist.github.com/geon/04944c01b8d0255f3cc83eb16d66b15e Works great.
You could use an interface that has an optional method. I dont know the correct Syntax, but somerhing like this: interface HasMethod { newMethod? : { (): any } } Then you either use class Thing implements HasMethod or you cast the object: (&lt;HasMethod&gt;element).newMethod()
But what if the method name depends on a parameter of the decorator? Like: function decorate(methodName: string) { return function(Class: Function) { Object.defineProperty(Class.prototype, methodName, { value: function () : void { console.log('Foo bar'); } }); } } @decorate('newMethod') class Thing { }
Yeah that can't be done in any way im aware of, I've worked extensively with decorators and they r are treated as runtime code 
Oh :(, thanks anyway!
You should be able to include the tether file above the script tag that has require. Alternatively, I'm using the domready library and tag of [domready!] which makes sure all Dom is loaded before require starts.
Ah okay that works. Thanks man! And happy holidays!!
I left a reply on twitter, but I'm not sure typescript is doing what you're thinking it's doing. The inferred type of z is an array with each element being a union type of A and B. Explanation: https://gist.github.com/dwieeb/dd11fb65472a159a77638ab4dda1062e class A { a: string } class B { b: string } // Tair's example. let z = [new B(), new A()]; // z is inferred as array type of A | B let [a1, b1] = z; // a1 and b1 are of type A | B let x1 = a1.a + b1.b; // won't work (a1 could be of type B, b1 could be of type A) let x2 = a1.b + b1.a; // won't work (a1 could be of type A, b1 could be of type B) // Fixed let y: [B, A] = [new B(), new A()]; // z is explicitly typed as 2-tuple of type [B, A] let [a2, b2] = y; // typescript knows y[0] is of type B, y[1] is of type A let x3 = a2.b + b2.a; // works as expected let x4 = a2.a + b2.b; // won't work (a2 is of type B, b2 is of type A)
It may compile it to `require`, but that `require` may be a function that TS has defined itself (unrelated to the library). Did you encounter errors with the `import *` syntax?
Whew, glad it's working. These all seem like tiny things no one mentions, but everyone must go through. Have a great holiday!
Ok, checked one more time, and it really doesn't work with my code. It only works if I remove the intermediate z.
You do NOT need to use requirejs to use the require function, and I would definitely not recommend that. RequireJS support is mostly in there for legacy support. Stick to commonjs/es6 imports when possible. All you need to do is make TS aware of the typings for require, you can either do that by including the typings for node `@types/node`. Or define require yourself by putting this in a .d.ts file `declare function require(path: string): any` or a generic alternative if you'd like `declare function require&lt;T&gt;(path: string): T` If you are using webpack, you can also chose to include the `webpack-env` typings that also give you a require function along with the webpack specific `require.ensure` and so on.
Correct me if I'm wrong, but it would correctly infer the type as well if you use `const` instead of let.
`const` doesn't seem to change the behavior, but not using the intermediate `z` does, as /u/ts9999 mentioned.
What about using a property/method decorator to "inject" the method you need. That way, the method is declared and you satisfy the interface but the decorator is still responsible for the actual implementation of the method. 
It's almost as if it's trying to be deliberately verbose, between not importing the classes directly, not using the short constructor syntax etc.
&gt; (reference to the recent reactjs tweet) ?? 
finally nodejs webdev that scales
hey /u/lukeautry really love the idea here and started playing with it. But it seems to break down with qualified imports, enums, etc. Do you know if its being used in production anywhere? I'd love to use it but a bit worried about what feels kind of like a great start but a bit incomplete
[removed]
By no means do we have this down yet. We're trying out the this option on our first production TypeScript project. We're treating the interfaces the same way we would with server side Java or C# development where we essentially have one file per interface. If there are child types we may put them in the same file, but not often. For example, we have a region that has locations, and locations have a location type. So I'll have a region.d.ts and a location.d.ts file, where location.d.ts will have the location and location type structures defined, while region will only have region. For folders, right now we have one folder, but I think we'll change that over time to use the same structure we use for namespaces. So, region and location may be in a web.lookups namespace or module, so the folder would be typings/lookups holding both files.
What's DT's policy about using new TypeScript features in its typings files? Is it fine to send a PR that would break the lodash typings for anyone on TypeScript 1.x? FlowTyped is taking an interesting approach to this -- all typings are versioned for both Flow _and_ the library.
Alright, after reading your post closer I can see that you are aware of this already. I would assume it's okay to do PRs to DT that use new TS features. Those still on older versions can just stick to the version they were using. I don't know if that is their policy though, so don't hold me to it. ~~The example above can be made to work with the new `keyof`/lookup types functionality added in TS 2.1 https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#keyof-and-lookup-types~~ ~~The typings will catch up eventually, but they cannot assume that everyone is using the latest TS version.~~ ~~In the interim, you can download and modify the typings manually instead of using them directly from DT.~~
Yes, everything's now versioned through the @types npm org so that should be possible. They need people to turn`strictNullChecks` on for all new submissions, which would make everything &lt;2.0 break by default if the versioning wasn't in place. I would try submitting a PR and see how the discussion goes from there, they are pretty helpful folks.
There's this on the DT README: &gt; I want to use features from TypeScript 2.1. &gt; &gt; Then you will have to add a comment to your definition header: // TypeScript Version: 2.1. If it is merged before January 7, it will be published as a prerelease version, such as 4.3.0-next.0. This is a bit cryptic about what exactly happens on January 7th, but I hope it means free reign to use TS 2.1 features.
Awesome! Thanks!!
That bit us. Kind of dumb instanceof checks don't work. That would be really handy. 
[removed]
Yeah, such a breaking change with a minor update of TypeScript. Sucks that code which used to work suddenly breaks, in particular custom error classes which are really useful with promise chains. Hope the solution/workaround works for you too! 
I think this method is great when using typescript. It could be implemented as a function in the promise chain from the fetch.
Well, why do you want to force such workflow? I don't want to be forced. For example, I prefer to have one error handler to do everything and I want to assign it to all my promises/observables in a streamlined fashion without dealing with ifs/switches. I can of course wrap calls to your library, but this feels redundant.
[removed]
You may need the require syntax for some commonjs only modules.
Yes, it is fine and I did it many times. You can store in Map whatever you want, an object, function, simple value or even a class constructor.
It's possible we've already been talking by email. But, in case we haven't, I would say that it is incomplete, in that it doesn't currently support the full range of typing that TypeScript offers. It supports the basic cases outlined in the docs, but it could do more.
Pay for course to save anyone the link following
&gt; And no need to use babel I'm not sure if that's an advantage. That means I'm using TS's ES6+ transpiler and not Babel. I haven't researched it, but I doubt they support the exact same features, in fact I'm pretty sure Babel has a bunch of experimental plugins for extra language features.
&gt; Typescript can give you all kinds of headaches when using lesser known/outdated libraries This used to be the case but I believe they recently changed it so that typescript will set the type to any when importing unknown modules in the latest release.
Hey, thanks for this post. I'm doing something at work that involves attaching extra data to enums, I completely forgot that they're just normal JS objects under the hood...
Each item must be unique in the collection, so I think Map is better, but I'm not sure.
Each item in a set is by definition unique.
[removed]
[removed]
Typescript will not transpile ES7 down but you will need babel for that.
[removed]
&gt; You might try cross-posting this to /r/vuejs Well, I think this is much more related to typescript than it is to VueJS. I just happen to run into it with VueJS, but I'm guessing this happens to people all the time using all kinds of frameworks. &gt; Have you read through this article and some of the related links, especially the av-ts related? https://herringtondarkholme.github.io/2016/10/03/vue2-ts2/ I have and there's nothing there that solves my problem.
**Here's a sneak peek of /r/vuejs using the [top posts](https://np.reddit.com/r/vuejs/top/?sort=top&amp;t=all) of all time!** \#1: [Vue 2.0 is here!](https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.dhxn80yol) | [4 comments](https://np.reddit.com/r/vuejs/comments/559h6o/vue_20_is_here/) \#2: [Announcing Vue.js 2.0](https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9#.t4ssx4l9s) | [10 comments](https://np.reddit.com/r/vuejs/comments/4gq2r1/announcing_vuejs_20/) \#3: [Vue in 2016 â€“ The Vue Point](https://medium.com/the-vue-point/vue-in-2016-8df71d98bfb3#.rdy198jq3) | [0 comments](https://np.reddit.com/r/vuejs/comments/5krkky/vue_in_2016_the_vue_point/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Marius- you're publishing some great articles. Keep up the good work.
I had a similar reaction when I started working with both Typescript and ES2015 modules. I fought it at first, looked at ways to cut down the number of repetitive imports and felt like I was writing more code than I before to accomplish the same thing. It's part of why I still don't use TS for everything, sometimes linted JS is safe enough for my needs. It's not an answer to your questions, but I think if you just embrace the normal TS way of doing things you'll get used to it quick enough, and hopefully the advantages of Typescript are worth it to you.
I think you meant FrozenPoint here? &gt; The resulting ReadonlyPoint type is identical to the **FrozenType** type that we created manually.
Haha :P The team has been moving fast, so there's a lot of good stuff to write about :)
In that case, I'm afraid there's no shorter solution than what you have already. I don't think TypeScript will ever add a shorthand for this, because it conflicts with [TypeScript's design goals](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals). The `let` inside the `if` condition would be new syntax, which might conflict with a (future) syntax extension of the JavaScript language itself. It would be really bad if code that was written for this new JavaScript version would have a different meaning when interpreted as TypeScript. If you really think this should be part of the JavaScript language, you could always propose it to the ECMAScript working group. For now, I guess you'll have to stick to the two-line solution.
IMO It's not worth it trying to make typescript a fullstack language, and with Web Assembly becoming a thing, I'd rather have C# on the front and back end than having typescript.
What are the advantages of making the language full stack?
No. Let's not do that. Knowing Microsoft it would be a big mess
Having the same language makes it mentally easier and you could share common libraries between the client and the server.
If they build a c# to Web assembly compiler.
We tried the full-stack thing on a large-scale product a few years ago (C# server-side, [Script#](https://github.com/nikhilk/scriptsharp) on the client) but it didn't work very well. The tooling continually got in the way, was missing features and we were constantly putting in workarounds to get C# to behave like JavaScript. This was all before Typescript was developed, so when that came out we migrated all of our Script# stuff to that. Not once did we think of doing it the other way around. Typescript isn't so far away from C# that one would have difficulty learning both. When you have two tools that do specific jobs, experience in development tells me that trying to shoehorn one into doing the other isn't usually a good idea.
Create the needed .d.ts files and use JScript.NET with the transpiled output. Isn't that all?
Your example says "we should compile C# to WASM" but your post title says "JavaScript should compile to the JVM. JavaScript doesn't compile to anything but itself and WASM; why in God's name would a language explicitly designed to be a formal superset of JS take on completely unrelated targets like this.
What. No. C# and TypeScript are two completely different tools made by the same manufacturer so they have familiar and similar features. They're still very different creatures.
It's already running in several backends on the nodejs runtime. Why is it then so hard to imagine it running on .NET 
&gt;Several NodeJS uses V8. Last I checked, there was no other JS engine that could be swapped in for it. Technically, because V8 and .NET are two different creatures. That's like asking why we have gasoline, diesel, and kerosene when they all catch fire for power generation. Semantically, because TypeScript is essentially C# that compiles to JS. Targeting TS to .NET is redundant and provides no advantages to just using C#.
Several backends for different projects running on nodejs was what I meant. A better phrased. Thousands (probably) of companies and open projects rely on typescript as backend running on top of nodejs. They could have been hosted on .NET core if Typescript.NET was a thing.
Yep, agree. Typescript brings the dynamic nature of javascript along with it in a very smart way. There's a lot of extremely experienced language people involved with the project. Finding myself preferring typescript more and more. Miss LINQ and a few other things of course but very happy in TS land. 
Why do you think C# is better than Typescript? My experience is that C# falls behind Typescript with for example worse null handling and worse type inference. F# still blows them both away :), but I think Typescript is more on the right track than C#.
Major changes are the new layout based on goldenlayout, which is much handier to work with and I've updated to the latest TS2.1 compiler. I've set the configuration target to ES5 which now has async/await support so it's way easier to write async code. Other noteworthy things: finally added quick info support, support for console.warn, console.error and console.table and jsdoc comments are displayed in the autocomplete window. Feel free to create an issue if you encounter bugs. Suggestions are welcome too :)
[removed]
[removed]
[removed]
If I understand what you are saying then you just are having the tsconfig.json compile the js files into the /build/ directory and it just maintains the same structure that was in the /client /server folders? I wouldn't mind seeing what your structure looked like if you were to write something up. I would appreciate that very much.
[removed]
The TypeScript type system continues to amaze me. There is some very cool stuff going on in the project. 
I am using ts-node for launching server-side things and webpack+awesome-typescript-loader for building client (browser) bundle. I usually store them in one repository to use common things in both frontend and backend (for example interfaces with data schemes).
&gt; On that aforementioned TIOBE Index, TypeScript has not even cracked the Top 100 list of programming languages yet, but TIOBEâ€™s editors noted the language was rising fast, moving from No. 167 to No. 137 in a single yearâ€™s time. This is a weird anomaly with TIOBE - what the heck is going on there? TS or no TS is probably the first question asked for nontrivial business website projects, right after (or before?) React vs Angular
Mixins (as described/modelled by this feature) are used a lot in the wild. This will make it possible to typecheck them.
Take a look here at the TypeScript Docs for [Modules](https://www.typescriptlang.org/docs/handbook/modules.html) for an explanation.
That's certainly an improvement over the current workaround where you have to add the properties of the mixin(s) yourself: https://www.typescriptlang.org/docs/handbook/mixins.html I wish it would be more like Dart's mixins, though.
You could start by setting allowJs to true, and noImplicitAny to false. You won't get all the benefits of typing, but you can start converting files from js to ts incrementally. I'd also consider adding some automated testing, even if it has crappy coverage and just tests "I have a function here, here and here", it might speed up your feedback cycle.
{} means an empty interface which is something different.
Implement a memoization decorator.
What do you use to install NG2 and so on?
npm install. i use nativescript-angular (and @angular/core and the like) so i am not sure if pure ng2 will be any different
decorators are amazing, they makes your code very declarative, easy and effective. Take a look on [typeorm](https://github.com/typeorm/typeorm) and how it uses decorators. Take a look on any of [my](https://github.com/pleerock) node-related open-source repositories and you'll see many use cases of them.
Does VS have integrated support for using npm?
i believe it does however i have not used it
I installed 2.2 RC, copy-pasted the mixin example from this blog post, and got a type error. Can anyone else confirm? /** Any type that can construct *something*. */ export type Constructable = new (...args: any[]) =&gt; object; export function Timestamped&lt;BC extends Constructable&gt;(Base: BC) { return class extends Base { // index.ts(5,26): error TS2509: Base constructor return type 'object' is not a class or interface type. timestamp = new Date(); }; } 
Definitely give vscode a try. It's so nice! 
https://webtooling.visualstudio.com/package-managers/npm/
One reason to avoid them is that the most current tooling (e.g. web assembly) rely upon them to their thing. I think another is that they are TypeScript-specific. ES6 modules are not so it reduces friction between you and the rest of the world. 
Thanks for your entry So you disabled that tslint rule, or you use a custom set of rules? I started with tslint:recommanded but I'm starting to disable some rules (like ordering imports or members) 
We use namespaces and modules too and basically just have that rule disabled but we're planning of getting rid of it and switch to ES modules soonâ„¢.
I Just use TS add-on for the Atom IDE. Haven't seen any such errors from its lint. 
You know you can compile .NET Core apps to be standalone with no external .NET framework dependencies?
Oops i meant to say isomorphic
You can already run typescript compiled to js on node for isomorphic web apps though. Why would you want to compile it to c#? 
-Enterprise Fud re: nodejs -presumably the CLR is more optimized than V8 strict mode Pretty weak reasons I admit.
Try [seamless-immutable](https://github.com/rtfeldman/seamless-immutable). I found it easier to work with on the last project as it has a more straight forward getter and the same 'set' 'setIn' and 'merge' methods as setters. 
I'm leaning this way too. I've done a fair bit of TS development in VS2015 and it's been... Not painful, but far from frictionless. VS Code offers a smoother TypeScript development experience
That hasnt been my experience at all.
Care to elaborate a bit more? 
I actually prefer vscode when writing typescript. What features (for typescript) make vs "fully built" compared to vscode?
We use that plugin : https://www.npmjs.com/package/tslint It is part of the build process in webpack, if tslint detects errors, webpack won't compile the project. Every people on the project use the same rules regardless of their tools : Intellij, Atom, VS Code etc...
Check out the [typings](https://github.com/typings/typings/blob/master/docs/commands.md) project. I believe its `bundle` option will create a typings file from your source which you can publish with your module. If it doesn't work it should be easy to maintain your own index.d.ts that you publish with your compiled JavaScript at the top level of of your module.
Never tried it, but I would have thought the declaration: true option would be sufficient. https://www.typescriptlang.org/docs/handbook/compiler-options.html
[removed]
That's the correct answer, by setting "declaration" to "true" the compiler will output the definition files next to the javascript files and every import from these files will automatically be typed. Please note that it makes the compilation a bit stricter on which types need to be exported, since you can't export a type that depends on another type which hasnt been made public. Basically you'll have to put a few more export keywords that you'd like.
ES6 modules are the official Javascript standard, and "module" and "namespace" syntaxes aren't. They come from a time where there was no standard and should now be considered as deprecated. Do not use them in a new project.
* Why are you minifying server code? * Why is webpack being used on server code?
Good questions. In my case, I've got an universal React app. It's written in a way that requires the shared code to get processed through webpack with TypeScript and then Babel. (Should be able to get rid of Babel once TypeScript 2.3 is released because it is supposed to support transpiling generators to ES5). So even if the code weren't minified, it would still require a source map lookup. 
In dev you shouldn't minify, so then there is no problem. On the server I wouldn't include sourcemaps just to keep your source a bit more protected. I wrote a C# handler that takes a stacktrace from an error logger and uses mapping files to log the correct stack trace.
thanks luke. the dist folder idea keeps things clean.
thanks!
thanks guys - doing this tonight.
**es7-typescript-starter** ([Repository](https://github.com/bitjson/node-typescript-starter)) ([NPM](https://www.npmjs.com/package/es7-typescript-starter)) **Stars** 0 - **Language** TypeScript - **License** MIT - **Release** 1.1.0 *(9 hours ago)* An es7/typescript starter for building javascript libraries *** ^(BETA | by /u/AtroxDev |) [^(Telegram Bot)](http://t.me/LibrariesBot) ^| [^(Something went wrong)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Something%20went%20wrong) ^| [^(Suggestions/Thoughts)](https://www.reddit.com/message/compose/?to=AtroxDev&amp;subject=[LibrariesBot]%20Suggestions/Thoughts)
Hi all, I just finished up an initial release of this last night, I'd love feedback or ideas for improvement. The overview: * Write **standard, future javascript** â€“ with stable es7 features â€“ today ([stage 3](https://github.com/tc39/proposals) or [finished](https://github.com/tc39/proposals/blob/master/finished-proposals.md) features) * [Optionally use typescript](https://basarat.gitbooks.io/typescript/content/docs/why-typescript.html) to improve tooling, linting, and documentation generation * Export as a [javascript module](http://jsmodules.io/), making your work **fully tree-shakable** for consumers using [es6 imports](https://github.com/rollup/rollup/wiki/pkg.module) (like [Rollup](http://rollupjs.org/) or [Webpack 2](https://webpack.js.org/)) * Export Typescript type declarations to improve your downstream development experience * Backwards compatibility for Node.js-style (CommonJS) imports * Both `strict` and `flexible` Typescript configurations available So we can have nice things: * Generate API documentation (HTML or JSON) [without a mess of JSDoc tags](https://blog.cloudflare.com/generating-documentation-for-typescript-projects/) to maintain * Collocated, atomic, concurrent unit tests with [AVA](https://github.com/avajs/ava) * Source-mapped code coverage reports with [nyc](https://github.com/istanbuljs/nyc) * Configurable code coverage testing (for continuous integration) 
It would be great if you could add screenshots or perhaps a link to an interactive demo to the readme, so we don't have to install it locally in order to get an impression of what it does :)
Thanks! Please add an issue if you find any areas for improvement. I'm not sure if I understand what your project is doing â€“ couldn't really find any descriptions or docs â€“ mind summarizing?
Still a work in progress, getting there. It's a bit of a concept I'm working towards, functionality mostly not important. Just the root directory.
Author here. This sort of type safety is only possible with TS2.1's mapped types. In Scala, you'd have to resort to macros to implement the same thing! 
In discussion means "this is known to be a bug and the typescript team is thinking about how to fix it". At least that's how I understand it. Also note you got a little confused. The response said a new TYPE operator, not a new operator. The effective code would be unchanged, but the type would be inferred more exactly. That is what mhegazy is suggesting. The fact that it worked before was probably a bug... kind of a bummer I know.
&gt; In discussion means "this is known to be a bug and the typescript team is thinking about how to fix it". At least that's how I understand it. Ah, okay. I interpreted it as "intended behaviour, here's a workaround we might try".
I wouldn't do it. Typescript enforces better patterns.
The tag for that would be "By design" :)
thanks for your reply. Unfortunately, my tech lead did not want to hear about that, so he just disabled the tslint rule and we are using namespaces T_T I should learn to say one day... but that's another problem =)
Not sure if this is your article or not, but this should probably be x-posted to /r/javascript as the article is focusing on "converting" javascript devs to typescript devs.
Seems to be possible. export const initialState = { foods: { filter: '', someForm: { name: '', age: 2, }, someFormWithoutAnAge: { name: '', }, } }; type state = typeof initialState; export const myFunc = &lt;K extends keyof state&gt;(state: K, val: keyof state[K]) =&gt; { console.log(state, val); }; myFunc('foods', 'filter'); // compiles myFunc('foodz', 'filter'); // doesn't compile myFunc('foods', 'filterz'); // doesn't compile
Thanks! I just posted it there.
[removed]
I still think TypeScript it soo much of a hassle for a personal project. There is too much initial setup and extra work to get any use out of it. The starter repos/generators usually aren't very scalable and probably not a good idea if you're not sure what's going on there, at which point you are skilled enough to just do it yourself. When working alone, you can do ok without the autocomplete. And it's not like types guarantee the program will work correctly, you should still write tests to achieve that. The only helpful thing is that they save you from some dumb mistakes, which can be achieved with a linter too and the latter doesn't take any setup, given that you already have some sort of global config. TypeScript becomes useful on a team project or when you're working alone on a huge project, which is going to be developed for years to come. I am a big advocate of using it where I work, but I do not support using TypeScript everywhere without a reason. The reason could be as simple as "I really want to use TypeScript", but everyone should decide that for themselves and be aware what they're getting themselves into. Please, don't be the person that preaches it as TypeScript is the only god and vanilla JavaScript is bad, there's plenty of valid use cases for regular JavaScript over using TypeScript.
I disagree that it's not worth it. I find it super easy to just copy the boilerplate from any similar project I've done to get up and running fast. If not using typescript I write almost as much extra detail in function headers describing param types and options interfaces anyway. And it makes it easier to revisit you project later as there are more hints around as to the shape of objects etc.
Er, the example already had this function. I meant that "filter" must refer to a specific looking object inside the state. So only provide a key to a member of the state AND that key points to something that looks/has a specific type. Thanks for the help.
I used to use typescript, but now that babel is the norm, which enables es2015, which enables js to be a good language, I just can't justify using typescript over flow. Flow has better type inferencing, works with babel which devs are already using, and has much better generics. Typescript's bivariant generics are awful and Microsoft justifies it by saying that variance is too difficult for JavaScript developers. I switched to flow, and frankly it's worked out much better. 
I'll agree that TypeScript's type inference is lacking compared to Flowtype, but I've found the stability and ecosystem of TypeScript much more preferable to Flowtype. Flowtype doesn't have nearly as many type definitions (although you could argue it doesn't really need them), it just about works on Windows (and Windows was a second class citizen for a long time), and frankly I like VSCode more than I do Atom (or Nuclide, which also only works on OSX/Linux last I checked). I do most of my coding on OSX/Linux but it's hard for me to justify writing in a technology that locks out a lot of developers. I really do wish TypeScripts type inference was as smart as Flowtype, though. Some of the weird type errors I have had are dumb. For example, given the following: declare function render&lt;P&gt;(element: React.SFC&lt;P&gt;, ....) declare function render&lt;P&gt;(element: React.ComponentClass&lt;P&gt;, ....) you cannot do this in typescript: const el: React.SFC&lt;Props&gt; | React.ComponentClass&lt;Props&gt; = ... render(el) typescript thinks that the above is a type error :x
[removed]
I am talking about personal projects, which are mostly some quick hacks or small tools. I never write any documentation for those, not even comments and I write tests only if I think it's worth the time, e.g. if it's an external resource, it's probably not worth the time mocking it. The idea is to get it done as fast as possible, not to do it perfectly. If you can't live with yourself without writing the function description, then TypeScript makes more sense. And the thing I dislike about copying over the boilerplate is that you still have to do it every time and think about how to set everything up, which derails your train of thought from the idea to project setup. As a programmer, I see a common trend about picking languages, frameworks, libraries, project structure, code style, anything but get the work done. When I want to do something for personal use, I don't care about anything else but the latter. Hence comes the mindset that TypeScript is not superior to plain JavaScript in each and every case. But if the project requires maintanability, i.e. team project or software which will be used by many people, I will care more about other things I mentioned earlier and will advocate the use of TypeScript over JavaScript. 
No, also about working with types. When you sometimes want to have something more dynamic and have to jump through hoops to get it to work without the compiler complaining. As I've said in a response to the other commenter, this can get distracting, which is not ideal when you just want to develop a small tool or a piece of software to help you with something. If it takes me 2h to do the thing and I waste another hour with set up prior to getting any work done, it's doesn't make sense to use it.
I'm not trying to be smug, but [this](https://github.com/Microsoft/TypeScript/issues/1394) was the first Google hit I got. 
Well on one front it was really just your word against mine. You asserted it takes you an hour to set up TypeScript, I said it takes way less. So we weren't getting anywhere and I addressed your other argument: How TypeScript was somehow distracting. You talked about a situation where &gt;when you just want to develop a small tool or a piece of software to help you with something and I said that I'd not use JavaScript (et al) for that in the first place. About your point regarding Elm and TypeScript: I don't really care to argue semantics. Which of those to use, in my mind, is a way less impactful decision than whether to use plain JavaScript or typed JavaScript. Maybe TypeScript will tell you Argument of type '4' is not assignable to parameter of type 'string'. and Elm would say something more akin to [this](http://elm-lang.org/assets/home/errors.png). I don't see that as a huge gain. It's nice, but to me it's absolutely not necessary to understand what's going on. And it's not a reason to decide for one transpiler or the other. When you/your team/your boss decides that you need types, that's when you should use them. When you're staffed with OO people, that's when you should use ES6. When you have a lot of functional affinity, you'd go for Elm. But I think there is always very little reason to use plain JavaScript. Also, TypeScript (and some other transpiler-based JavaScript extensions) will leave JavaScript code untouched. So there's no penalty for getting in the habit of using them.
[removed]
ES6 classes are largely the same, regardless if using TypeScript of JavaScript. And `this` reference is the smallest of all problems, every developer learns this soon after venturing in JavaScript world. But where there is the real annoyance is overloading functions and using extend, that works very differently as someone coming from Java or C# would expect. &gt; JavaScript itself is starting to move away from being all that functional in paradigm It might look like it, but a lot of people, influential to JavaScript development, disagree with adding classes. Just to mention one, Douglas Crockford (author of JavaScript: The Good Parts) was strongly against it. Although this is personal opinion and I might be in minority, but I think just letting OO people do their thing, regardless of the fact that it's not the "norm" nowadays and that it doesn't behave as the traditional OO does, is bad for personal development.
&gt;ES6 classes are largely the same, regardless if using TypeScript of JavaScript. I agree, but I fail to see how this is relevant. &gt;`this` reference is the smallest of all problems I don't think so. I personally don't have as much of a problem with it, but I see a lot of my colleagues who spend their time writing backends in Java who continue to have a very hard time switching contexts between Java and JavaScript. It's no wonder; they're also switching between the functional paradigm with a very specific definition of closures and functional scoping to the object oriented paradigm where neither exists. I have come to believe that the object oriented paradigm comes easier to the majority of people. It's not better that way; there are problems that are better suited to be solved by a functional approach. But for a large ecosystem where tonnes of people need to be able to *just do work*, I think OO is generally better suited. The problem, of course, is that many web technologies *should* be written functionally to achieve maximum architectural cohesion. It's no wonder node was hyped for it's asynchronicity. There is certainly value in pipe- and streamlining web development. I don't have an answer to this, but that's the observations I've made. Extends and overloads are less of a problem imho, because they're not unpredictable. Losing `this` context happens silently and proliferates. Extending is only really difficult because of the scoping issues. Overloading has to be explained once (there is no overloading, use the option pattern instead). It's great that people have different opinions but I'm not so sure that I'd value Crockford's opinion as highly when the community decides something else is more valuable. Apparently he doesn't have as much influence as you purport he does. Again, this is not to say that more functional programming wouldn't be swell. I just think that it's more mass-friendly to limit non-OO paradigms to people who intentionally choose to engage with them. 
The only excuse to let "`this` reference get you" is if you're mostly back-end developer who has to do some occasional front-end work. Anyone who is at least somewhat experienced JavaScript developer should know about this, even if they switch among different languages. If we're talking about what approach is better, then I would always suggest object composition, which has the benefit of getting rid of all the hassle that comes with OO in JavaScript. And if you change the use of `this` with explicit parameters, you also mitigate `this` reference problems. &gt; Apparently he doesn't have as much influence as you purport he does. Not sure what you want to say here or are just trying to twist my words against me for the sake of this argument? He is a well respected and an influential figure, but not a dictator. At TC39 meetings, everything is decided democratically and even though some voiced their concerns against adding classes in JavaScript, majority knew it's better to cater to a wider range of developers. 
I don't understand why we're arguing any more. 
Those with a C# or Java background should smoothly transition into working with TypeScript.
Hello, Really nice work ! I tried to debug the ts files with vscode but did not succeeded, can you point something to do in order to achieve it ? Thx Edit: Found it, I disabled the uglifyer in the webpack.config and it did the trick. Maybe the plugin need an additional setting to target a typescript debugging.
Error: Cannot find module './build/Debug/buffertools.node' on windows of course. this is why we can't have nice things.
Will there be a separate VSCode update to support the new quick fixes? Doesn't look like they're working at the moment.
The next version of VS Code will support it out of the box, but the blog links to instructions on how to install a newer version globally and modify your `typescript.tsdk` setting to reflect that. By default, VS Code should prompt you if its default language service is different from the globally installed one.
I've been following [this issue](https://github.com/Microsoft/TypeScript/issues/4948), which was tagged with the `2.2.1` milestone. How does that work? Did that come along with this release, or was it actually already planned to be a patch release before?
*I posted this solution on SO.* The only way I was able to do this is by: a. constraining the data structure to match the string literals, not the other way around. b. passing the data structure as a function argument. const state = { foods: { filter: '', someForm: { name: 'Some form', age: 2 }, someFormWithoutAnAge: { name: 'other form', priority: 10 } } }; interface HasAge { age: number } // IMPLEMENTATION function getForm&lt;O extends {[P in P1]: {[P in P2]: HasAge}}, P1 extends string, P2 extends string&gt;(o: O, p1: P1, p2: P2) { return (o[p1] as any)[p2] as any; } // USAGE const form1 = getForm(state, 'foods', 'someForm'); // GOOD const form2 = getForm(state, 'foods', 'someFormWithoutAnAge'); // ERROR const form3 = getForm(state, 'foods', 'blah'); // ERROR A much simpler and more flexible solution is to use regular code. `pickAForm` takes a function instead of string literals. const form1 = pickAForm((state) =&gt; state.foods.someForm); // ...or... const form1 = pickAForm(() =&gt; initialState.foods.someForm);
A popular type declaration that uses `Pick&lt;T&gt;` is React's `setState` method: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/89328a754d3b385c504f05c23ce8059809e245e0/react/index.d.ts#L171-L172 `Pick&lt;T&gt;` describes the semantics better than `Partial&lt;T&gt;` in this case.
Wooo! Considering webpack had no problem with this before we switched to TS this is going to reduce the amount of bitching from the devs massively.
This has been possible for a while and it is a big improvement. The trick was always getting your module loader to understand the concept of a root path. Webpack has allowed it for a long time. Webpack 2 supports it. Even older technologies like require.js have support for it. The examples in the article can be made even simpler. For instance, with this: { "compilerOptions": { "module": "commonjs", "moduleResolution": "node", "jsx": "react", "baseUrl": "src", "paths": [ "actions/*": [ "app/actions/*" ], "selectors/*": [ "app/selectors/*" ], "ui/*": [ "app/ui/*" ], "logger": [ "util/logger" ], ] } } "paths" can be removed completely; everything under src can be resolved as expected. The webpack.config.js changes aren't necessarily at all. You can simply have a resolves/modules that looks like this: resolve: { modules: [ path.resolve('./src'), 'node_modules' ], extensions: ['.ts', 'tsx'] },
What do you mean? Object.assign?
why is DoSomethingWithAPoint(myPoint3); this doesn't make sense, DoSomethingWithAPoint demands a **Point**, not an **any** 
It depends on the project structure. If it's the difference between going up 6 vs. down one then I'd just put a '../' in. That hasn't been an issue in my project because the dependencies tend to be either in the same directory (or deeper) or far enough away that it makes sense to go up from the root. YMMV.
[removed]
I got this working no-problem with VS Code but webpack throws exceptions :(
Hey /u/lechatsportif â€“ I'm working on better support for Windows, you can see the issue here: https://github.com/bitjson/typescript-starter/issues/11#issuecomment-281757546
Any object with a property x and y of a number type will satisfy the interface requirements of the Point interface. You can have as many other properties on the object as you want. The requirement given by the interface is only that the object has at least the given properties it defines. 
What!?!?! SO stoked for this. 
Typescript is a strict super set of js In js you can extend any object Logically yes 
This post states the new auto-fixes are "fixes" to 2.2. That doesn't make sense. It also talks about Visual Studio support, which unrelated to TypeScript itself. Was this either a bot post or a shoddy copy&amp;paste job.
Ah, I see what you mean. I'd accepted "Whatâ€™s been fixed?" at face value, but you're right, those are actually the new automatic fixes that are added. Doesn't look automated (I can't find anywhere else that uses the exact same phrasing as this), but definitely looks like they've got the wrong end of the stick there. Edit: I'm actually just going to delete this post. I'd read it as a useful expansion of the roadmap with further introductory details into everything that's going on, but the fact that half of it is so shoddy as to be totally wrong makes it pretty useless.
I hesitate to ask because I don't know anything about anything, but is any of this compatible with SP2010? Corporate bureaucracy prevents upgrades for the foreseeable future and I'm reaching my limits of sanity wrangling InfoPath
No, this is at the moment limited to SP Online and the process to roll out to all tenants is just starting. Next target would be the on premise SP2016. There is no way to fit this into 2010. Infopath is kind of dead anyway, so maybe you can have a look at third party solutions that offer a good upgrade path. 
[removed]
thanks
Did you try assigning to Object.prototype before any class definition?
I did, but it wasn't displayed over intellisense (VS Code)
Hi, author here. You should be able to debug the code because webpack config generates source maps... isn't that working @thamak?
[removed]
I see. Thank you, that answers my question. Now I wonder if I should really fork definitelyTyped just to fix this for me... but the webpack config file is such a maze.
Yes, you can create interfaces that define what those parameters look like.
I'd say at this point, things like this ought to be proposed as a JavaScript feature. TypeScript, thankfully, isn't creating much in the way of custom syntax anymore.
Yes decorators can definitely do this. It sounds like your decorators merely need to attach metadata to your classes, and your form builder will then read that metadata. As for attaching metadata, you can use a WeakMap, Symbols, or just make up a property name like `__my_form_metadata__`. EDIT formatting
You need to use the proper import syntax. import * as sql from 'mssql'; 
Absolutely you can. Pull in [reflect-metadata](https://www.npmjs.com/package/reflect-metadata) and make use of Reflect.defineMetadata()/.getMetadata() to store arbitrary data for arbitrary keys. You could store metadata for each property or even collect them together for the whole class. I had a very similar problem case - I wanted to store metadata for properties of classes, and [this](https://github.com/kukeiko/entity-space/blob/master/src/metadata/entity-decorator.ts) is how i decided to do it.
good stuff from both you and /u/cspotcode , thanks. I've now successfully created my first decorator and am writing / reading out the metadata for the properties,brilliant! Is there a good way of getting all the properties of a class that have a specific decorator? Im used to having all the wonderful helper functions that .Net System.Reflection has
[removed]
Check out https://www.npmjs.com/package/reflect-metadata. When the TypeScript team first announced Decorators support, they used it in conjunction with that library. I think the author of that module, rbuckton, is a member of the TypeScript team. (not 100% sure though)
This is super helpful when refactoring logic in old codebases into independent modules.
This is the closest way I can think of to what you have at the moment. ##### [Playground link][play] const types = ['apple' as 'apple', 'orange' as 'orange', 'pear' as 'pear'] type FruitAlias = typeof types[0] type FruitAliasMap = { [Key in FruitAlias]: string } const aliases: FruitAliasMap = { apple: 'Apple', orange: 'Orange', pear: 'Pear', starfruit: 'Starfruit' // compiler error } You could also try defining FruitAliasMap explicitly, then defining const types: (keyof FruitAliasMap)[] = ['apple', 'orange', 'pear'] but either way you're going to have some repetition. [play]: http://www.typescriptlang.org/play/index.html#src=const%20types%20%3D%20%5B'apple'%20as%20'apple'%2C%20'orange'%20as%20'orange'%2C%20'pear'%20as%20'pear'%5D%3B%0D%0Atype%20FruitAlias%20%3D%20typeof%20types%5B0%5D%3B%0D%0Atype%20FruitAliasMap%20%3D%20%7B%0D%0A%20%20%20%20%5BKey%20in%20FruitAlias%5D%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Aconst%20aliases%3A%20FruitAliasMap%20%3D%20%7B%0D%0A%20%20apple%3A%20'Apple'%2C%0D%0A%20%20orange%3A%20'Orange'%2C%0D%0A%20%20pear%3A%20'Pear'%2C%0D%0A%20%20starfruit%3A%20'Starfruit'%20%2F%2F%20compiler%20error%0D%0A%7D
Interesting, what does the `types[0]` and `as` do?
`value as type` is just another way of writing `&lt;type&gt; value`, so you could have const types = [&lt;'apple'&gt; 'apple', &lt;'orange'&gt; 'orange', &lt;'pear'&gt; 'pear'] instead if that's more familiar to you. The main point is that the variable `types` if of type `('apple' | 'orange' | 'pear')[]`, so you could equally have const types: ('apple' | 'orange' | 'pear')[] = ['apple', 'orange', 'pear'] or const types = ['apple', 'orange', 'pear'] as ('apple' | 'orange' | 'pear')[] or const types = &lt;('apple' | 'orange' | 'pear')[]&gt; ['apple', 'orange', 'pear'] but I feel that at that point you might as well define `type FruitAlias = 'apple' | 'orange' | 'pear'` and go from there. More information on this behaviour [here][as]. Note that by default, string literals are of type `string`, so we need to explicitly cast them to themselves, otherwise `types` will be of type `string[]` instead. ----- `typeof types[0]` abuses the fact that the type `T[]` is has an index signature of `{ [key: number]: T }`. Since the variable `types` is inferred to be of type `('apple' | 'orange' | 'pear')[]`, `typeof types[0]` is `'apple' | 'orange' | 'pear'`. There's nothing special about the number `0` here, we're just using it to extract the type `T` from an instance of type `T[]`, so any number will work. More information on this behaviour [here][keys]. ----- It's a bit convoluted, it's the only way I can think of that doesn't have the list `'apple', 'orange', 'pear'` duplicated in two separate places. [as]: https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#new-tsx-file-extension-and-as-operator [keys]: https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#keyof-and-lookup-types 
 type Fruits = 'apple' | 'apple' | 'orange' | 'orange' | 'pear' | 'pear'; type FruitAliasMap = { [P in Fruits]: string; } const aliases: FruitAliasMap = { apple: 'orange', orange: 'orange', pear: 'Pear', starfruit: 'Starfruit' // compiler error }
Typewriter can be confusing but it can be very powerful. What you want to do is possible but there is a catch Each c# class must be in it's own file and the filename must match the classname exactly. Most people go with this convention by default anyways so it shouldn't be too big of an issue. Below is an example using what you provided as a bsae, I added an enum and a base class as those are pretty common and a good thing to ensure it works as expected. I am also using a custom attribute to determine which models to include as I find it better than matching on wildcards or class name alone. //Person.cs [TsDef] public class Person : BasePerson { public string Name { get; set; } public Address Address { get; set; } public Status Status { get; set; } } //Status.cs [TsDef] public enum Status { Active, Inactive } //BasePerson.cs [TsDef] public class BasePerson { public int Age { get; set; } } //Address.cs [TsDef] public class Address { public string City { get; set; } public string State { get; set; } } //TsDefAttribute.cs public class TsDefAttribute : Attribute { } //Models.tst ${ // Enable extension methods by adding using Typewriter.Extensions.* using Typewriter.Extensions.Types; string ClassName(Class type) { if(type.BaseClass != null) { return $"{type.Name} extends {type.BaseClass.Name}"; } return type.Name; } } $Classes(x =&gt; x.Attributes.Any(a =&gt; a.Name == "TsDef"))[ $Properties(x =&gt; x.Type.IsEnum || !x.Type.IsPrimitive)[ import {$Type[$Name]} from "./$Type[$Name]";] $BaseClass[ import {$Name} from "./$Name";] export class $ClassName {$Properties[ public $name: $Type;] }] $Enums(x =&gt; x.Attributes.Any(a =&gt; a.Name == "TsDef"))[ export enum $Name { $Values[ $Name = $Value][,] }] The tst is kindof hard to read, I tried to format it as best as I could without completely mangling the resulting output. Let me know if you have questions about what I am doing.
This is not an option. The code in question iterates over the array of types so I cannot use a type alias in this way (this was however my original attempt)
I'm not sure if this is exactly what you want, but I found this useful a couple of times so I'll throw it up here for your reference: export function Enum&lt;V extends string&gt;(...values: V[]): { [K in V]: K } { const result: any = {}; values.forEach((value) =&gt; result[value] = value); return result; } export type Enum&lt;T&gt; = T[keyof T]; Then later if you want to use this: export const MY_ENUM = Enum( "VAL1", "VAL2" ); export type MY_ENUM = Enum&lt;typeof MY_ENUM&gt;; I found it useful since I was looking to use a string enum both at runtime and in type checking. Source: Can't find the article, but its the person that did this package https://www.npmjs.com/package/typescript-string-enums
[removed]
Yeah, what you're looking for is no-string-literal in tslint: https://palantir.github.io/tslint/rules/no-string-literal/ There are actually cases where tslint will allow access by index, even with this rule allowed. For instance, if you have a property called "one.two", there's no way to access that with "dot" notation; you have to access it by string literal.
This is nice, but I would prefer a decorator based approach for dependency injection rather than mixins simply because it's *much* easier to use. Some back of the napkin concept stuff.... @inject class MyClass { constructor(@inject('someName') someName: Something) {} } Where `@inject` a string argument and a parameter would register the dependency in some kind of metadata object on the class, and `@inject` with a constructor function would return a new constructor function that links the dependencies based on the metadata. Maybe. I feel like I'm reinventing the wheel a bit because Angular 2 already does this, I think.. At any rate: Mixins should be used to share functionality, not for dependency inversion :x
Look up inversify. It's really well done.
Oh man, I've been searching for a good DI solution for weeks now. Thank you!
I really like typedi found over here https://github.com/pleerock/typedi pleerock has some other good typescript libs also like routing-controllers and also typeORM
But di annotations couple your code to the di module which is the exact opposite of what di is supposed to help with. It's fine when it's part of a framework your using though, like angular2 or spring as your already fully coupled to that. I've been trying to find a good di package that wire things together. For example I have something like a log module and a cache module in separate packages. My cache module needs a log impl but shouldnt be coupled to the logger or the di package, it's just a class that takes some args. Also if my logger impl was part of the project and then I want to move it out to be more reusable, why does it have these annotations on it? Edit for example: ``` class Foo { constructor(private log: Log); } ``` Di wiring: ``` Container.register('log', Log, []); Container.register('foo', Foo, ['log']); ```
Sorry, I'm having issues understanding your comment a bit, could you provide a code sample to show how the mixin approach is any less coupled to a "di module" (assuming "di module" is the source of `@inject` decorators here) than my decorator approach? At some point you are going to need to interface with the dependency injection module, and you need to do that by proving metadata on your components or by registering them in some location. I'm failing to see how the mixin approach by the author avoids this while mine falls into that trap?
&gt; I've just been looking at how I'm going approach it in a large separated project and take issue with the decorator approach I've seen in a large amount of di packages I mean, the decorator approach is exactly how it will work under the hood as well. I'm not sure how you would approach a DI container in JS without deferring to some kind of metadata on a class unless you wanted to rely solely on `Function.name` for classes or have string literals everywhere. You could ignore the `@inject` decorator on the class but you'd need to provide some kind of metadata somewhere...
[removed]
I really like some of the other things pleerock has up but inversify is a lot nicer IMO. 
In addition to this, you could also utilise the new `typeRoots` option in TS 2 to provide your *own* types. Set it to the following in `tsconfig.json`: "typeRoots": [ "node_modules/@types/", "typings/" ] Now you can create your own typing files inside of a `typings/` folder relative to the `tsconfig.json`. 
Sometimes, I'll create a simple interface of just the methods I'm using. Most of the time, I type them as any.
&gt; Do I need something like webpack to use features like async/await. Nope! The question is, do you want TypeScript to emit async/await code or do you want it to transpile it into ES5 or ES3? This is controlled by `"target"` in your tsconfig.json. &gt; Also how do I go about using the es6 module pattern? I was seeing exports/require errors in console. You can always write your TypeScript using ES6 imports &amp; exports. Do you want TypeScript's compiler to emit ES6 import/export syntax, or convert them into node-style `require()` calls? This is controlled by the `"module"` option in your tsconfig.json. If you want help diagnosing some specific errors, you can post a complete example for us to look at. Please include everything: source code, tsconfig.json, and a complete copy-paste of the errors. &gt;Lastly, how do I go about using modules in node_modules? Set `"moduleResulution": "node"` in your tsconfig.json. This will tell TypeScript to use node's logic for finding modules: looking in node_modules, looking at package.json, and loading index.ts. EDIT: formatting
That is the correct behavior. It's a bit confusing at first. Here's the rule of thumb: `var Promise = require('bluebird')` translates to `import * as Promise from 'bluebird';` `var Promise = require('bluebird').default` translates to `import Promise from 'bluebird';` or `import {default as Promise} from 'bluebird';`
Ok well it seems no matter what, a browser cannot detect require/import, so on the client side I'll need to bundle it somehow right?
Valid point. Ok so I've used web pack before with react and I agree it's wonderful.. especially when everything is generated from the basis of one index.js(x) file. However, suppose I did want to have multiple *.html pages, do i want to bundle a separate entry-point for each in this instance?
You can do that if you want. That's a whole other can of worms, and out-of-scope for a TypeScript discussion, but the webpack documentation can help you.
might be that it does not use peer dependency or does not include the latest version of typescript. i do not run this setup so i'm not sure how it works. but you should be able to specify which version of the compiler to use. You should not need to use bluebird as promises should be in typescript as of some version ago, correct me if i'm wrong though. 
You might be interested in this TypeScript boilerplate project: https://github.com/bitjson/typescript-starter
This works well but if I have a collection, say a list of Addresses on the Name class, it populates in the import as Address[]. Anyway to only import just the ts class I need?
I don't want to use a post build event. The reply by /u/originalmoose is close what I need. Not sure if that is what you were looking for as well.
https://www.reddit.com/r/javascript/comments/54528t/advantages_of_typescript_besides_es6_support_and/d80c9hc/ although that's been about half a year. Things might be different now? /u/thejameskyle and /u/DanielRosenwasser are most likely still the best people to chime in on whether anything is different these days on the conversion front in either direction.
Poorly cropped jpeg'fied screenshots of Notepad? Is there a browser extension for filtering out this crap? 
Not sure I follow. How is it unsafe? The API itself is 100% type safe. Internally we cast the "real" connect but wrap it in typesafe functions. Your approach looks interesting, but you came up with an API that looks very different from core Redux. In my example, other than declaring a component inline (if you want, just like a decorator), the API is identical to normal redux. You can even declare them separately, and the compiler will enforce that the props match.
Makes sense to me. If you can figure out a way to do class components, please let me know. I've been struggling with it for a while, and although I've found a solution, it's significantly less than ideal. 
Correct me if I'm wrong, but it looks like: - I can define a non existent key on `mapStateToProps` - I can misspell a key on `mapStateToProps` - I can pass a value of the wrong type on `mapStateToProps` - Why do you need those asserts (`as any`)?
There's no such thing as "non existent" keys in mapStateToProps. That's the point of the whole thing: you can inject *anything* you want from state. The end component will not require you pass those injections when actually using the component. But they will be available to the component (as they come from Redux) inside its definition. So again, no such thing as "wrong" properties in mapStateToProps. You can use anything you want from the state. Then anything you inject will be available in props further down. Now, if you inject say "foo" into props, but in the component definition misspell it as "props.fooo", you *do* get an error. Hope that helps.
I will change it soon!
Essentially in TypeScript there's no way to get the type of a generalized expression. Stuff like `typeof a.b.c`, or `typeof a[0].b` or whatever else will all fail. In my case, I had a function returning a Redux store. The Redux store is a very large and complex object that I didn't want to explicitly type, because that would violate DRY as well as be a giant pain. But I still wanted the type of the Redux store so that when I passed it into different functions, I could ensure statically that I was passing in the right thing. There is currently no built-in way to grab the return value of that function. But you can use this hack to do so. --- Hopefully that illuminations my motivations a bit more! I find this hack to be particularly useful to take advantage of TypeScript's type inference so that you don't have to write out complex types and maintain them by hand. 
I usually just use function getReturnType&lt;R&gt; (f: (...args: any[]) =&gt; R): R { return null! } In this code snippet: function inferredTypeF() { return 3 } const rt = getReturnType(inferredTypeF) type InferredTypeOfF = typeof rt InferredTypeOfF will be of type number Credits go to artem@so who answered my question on the subject: http://stackoverflow.com/questions/41251531/export-return-type-of-function-in-typescript
Actually, that makes a lot more sense now. Thank you for taking the time to explain. I might even use this..
If I'm not mistaken ... TypeScript is just TypeScript. There's not an "es5 vs es6" way of coding in TypeScript. Through the tsconfig, you can specify a *target ecmascript version* for the compiler to *transpile* your code to. If that's what you're asking ... I generally see tsconfigs targeting es5 to target more browsers (e.g., IE9, etc. ) As far as coding in webstorm ... I actually use VS Code for TypeScript/Angular 2 development, mainly because it jives very nicely with the language (no surprise there). I would try googling to see what settings/configurations other devs use for TypeScript development in webstorm. You might need to install some sort of addon for syntax highlighting and intellisense.
It's true that TypeScript has a large base of people using it with Angular, but it's no necessity. I use it to make JavaScript apps that have no association with Angular (or any other library!) whatsoever, because: 1. I work with byte-code, XmlHttpRequest and JSON a lot, so it's invaluable for providing **type-checking**, as this lets you know whether you're dealing with something that's been processed into a string or an object yet, or something that needs further processing. 2. I work on large projects. They could be written in pure JavaScript (this was how I started out), but I was finding that my code was just becoming too big to follow properly and that I was missing a lot of **object-oriented** programming features like classes and interfaces. 3. I was pretty new to JavaScript to begin with, so TypeScript's **code completion** has proved really helpful. As for ES6 and Babel - I don't use Babel at all, just TypeScript's built-in transpiler; and I transpile down to ES3 wherever possible because I'm supporting TVs where I can't anticipate how old the built-in technology will be. It handles most use cases, up to a point (lambda functions seem to be fine, but certain other newer features like Promises, Set, and Map are left to the user to shim in manually). I also use WebStorm as my IDE - mainly because I liked the way it can figure out where to import your various classes from and do so with a single keystroke, which Sublime Text and VS Code didn't visibly seem to do (correct me if I'm wrong). It also has lovely integration for the Karma test runner, for when you come to writing tests. I don't recall having to do any environment setup whatsoever, although admittedly I run the compiling steps in watch mode in an external terminal rather than WebStorm's built-in one. If you want to use the built-in one, you might need to tell the WebStorm terminal where to find *tsc*, the TypeScript compiler, but I don't remember how. As long as your *tsconfig.json* file is in a sensible place (the root of the project folder), it finds it automatically and it may prompt you about what to do with it.
Interesting! Thanks for the great tip! I have not used `Pick` much yet, but this looks great.
If you use tslint there's a setting that checks for this.
Also, you don't need the &lt;HTMLElement&gt; type assertion because addEventListener is on the EventTarget interface, which is [implemented by Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) (which is the return value of querySelector).
I think their issue is that a lot of existing typings like lodash don't use a safe dictionary type so they want something that forces indexers to always include undefined.
What about type MaybeUser = (User | undefined); type SparseUserDict = Dictionary&lt;MaybeUser&gt;;
I actually do not understand what is wrong. I can't find the prototype for `vsOutput.appendLine`, but if `vsOutput.appendLine` only accepts one argument, then values.map(vsOutput.appendLine) is the same as values.map(value =&gt; vsOutput.appendLine(value)); The fact that `map` passes 3 values shouldn't be a problem (`map` passes current, index, and the whole array) BTW this doesn't really have anything to do with TypeScript, because you could rewrite my snippets in JS as values.map(vsOutput.appendLine); or values.map(function (value) { return vsOutput.appendLine(value); } 
&gt; I can't find the prototype for vsOutput.appendLine, but if vsOutput.appendLine only accepts one argument Basically [this here](https://code.visualstudio.com/docs/extensionAPI/vscode-api#_a-nameoutputchannelaspan-classcodeitem-id940outputchannelspan) but yeah "just a single string arg and returns void"..
I think the issue might be that in your second form, appendLine winds up being called with its "this" value set to undefined. To test if this is the case, try the following: function printLines(values: string[]) { values.map(vsOutput.appendLine.bind(vsOutput)); } The result of the .bind call will be a function with "this" bound correctly. Personally, I wind up prefering the first form simply to avoid having to repeat the object name in the call. Edit: There's more info here - https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/this - but in short, "this" in Javascript takes a little getting used to compared to other languages.
Is this the only change in 2.2?
No, it's one of many changes. :) Here's the full list: https://github.com/microsoft/typescript/wiki/roadmap#22-february-2017
It's an object index signature - see: https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html Edit: this specific syntax is for declaring an object instance which has an object signature with string keys. The definition for an instance is slightly different to an interface. Example: const obj: { [key: string]: any } = {}; obj['SomeValue'] = true; obj[1] = 'test'; // fails, because the key is defined as a string
That was sloppily written.
My bad, I wrote that on my phone and didn't check it, but yeah, you're right. A bit unrelated, but there's a cool new feature with TS 2.2 where you can access string index properties using . notation, e.g. obj.SomeValue = false; https://blog.mariusschulz.com/2017/03/03/typescript-2-2-dotted-properties-and-string-index-signatures
It's a cool feature, indeed. That's why I wrote that blog post. ;)
This has to be one of my favorite interactions on Reddit in some time. 
Once you declare a string index signature, you're free to access arbitrarily named properties of that type via bracket notation (`obj["prop"]`). If that's allowed, though, why should dot notation (`obj.prop`) be forbidden? It's the same property in both cases. In the past, TypeScript didn't allow dot notation in these cases. As a result, you often saw many compile-time errors when migrating a JavaScript project. TypeScript 2.2 loosened that restriction.
Check out /u/Kamek_pf's answer.
Thanks, so are these all manually created? there is no tool to do it for you?
Thanks, it is there. looks quite small though, kinda confused how the .d.td files work but will read your links, hopefully it clears it up for me :)
The TypeScript team explained it in this blog post, under the heading "Easier Imports:" https://blogs.msdn.microsoft.com/typescript/2016/12/07/announcing-typescript-2-1/
From the readme: &gt; For our Example React Native App we've stuck with React Native default of using JavaScript instead of TypeScript but still enjoys the same simplified programming model and concrete Types that servicestack-client enables. In other words, the title is a bit misleading. TypeScript use is possible with React Native, but this project sidesteps it.
These are manually created, or at least tweaked. If it was easily automated there wouldn't be a need for them to exist at all, the compiler would create them. The exception is when the library itself is in TypeScript, in which case it exports its own definitions so it can be reused later.
The intelli-sense tooling/language services still benefits from using a TypeScript library and TypeScript generated server DTOs during development which is where the benefits from using TypeScript are (as TypeScript source code is never used at runtime). It's easy enough to use TypeScript for the original source files (and use their compiled .js outputs) but I wanted an example that shows the servicestack-client and generated TypeScript definitions we're both usable from a pure JavaScript project and that it provides benefits over using a naked JavaScript library (i.e. without Type Definitions) whilst retaining the same syntax to send Typed API Requests (enabling great code-reuse).
You don't stop, /u/mythz! Nice work!
[It is possible.](https://codewich.com/#v1,,,bVJda8IwFPW5vyL4FJmmFSYMv2AT5x7mBjrYc0zvbKRNupvIrGP_fUlaFcdKH27vOfecew9NQeQcgQitjCVvT6v5fEi4qkZRVLeMAAVkQhR81TBb.w7tjBqC4AUgv2K8os30FnmZSTELMO31u6R.fZUwXydJclZBUCkg4JXOO2wWz6sG8Y4nFjNg1_IIdJAkXTIIOqkW.wKUZRudVoyXpePOMpmn9DyV6mKegyddtt9v3HURcc_Fdwkmo5fPB31YgC7AYkWbMzrdP_QXjQXPl9wCSp7Tjjdw0qzURlqpFTu6y3qDURTyZDxNqccd7WOvhGc0EdAO.Q7rnLdu.mGw28Tt5jwnWKC2PFgcyM3ERZv0_wOraxDhcw_G3itZBPwRnW6TlBP_OWXtU2.1xkagLN3PgGLSzqwtzTCO.Y4f2FbrbQ68lIYJXYRenMuNiW2GADsT491tXbNCKrYz7ek4rtWm0S8) I definitely want to improve it though. I just want to give a bit of thought to how it should work with, for instance, different versions of the library.
script tags are fine, every package is available at unpkg.com, plunker has a way to include scripts but I just go the unpkg route anyway so seems not a priority.
The ts editor is really nice. How are you providing all the highlighting and live type help?
It's using [Monaco](https://github.com/Microsoft/monaco-editor), the editor used in VS Code and the TypeScript Playground. It's actually quite effortless to integrate with TypeScript. I was impressed.
I want to support @types declarations as well as projects like Angular 2 which are natively in TS (and so expect TS imports). But yeah, for most projects it'll just be a matter of dropping in the &lt;script&gt; tag.
[It's also the 3rd most loved Programming language](https://stackoverflow.com/insights/survey/2017#most-loved-dreaded-and-wanted)
Even more impressive when I'd hypothesize the two languages above it are mostly used by programmers in their hobby-time, which would probably lead to them loving those languages more. Smalltalk definitely fits into this category, and despite all the hubbub around Rust I don't believe it's found a large amount of use in the workplace either. Rust is really crushing it, though, so I'm forced to admit that's probably not the only explanation. My guess is that Rust to C++ is a similar thing to TS to JavaScript, in that they replace a previously very painful language, and that Rust's improvements over C++ might even be greater than that of TS over JS. (Though it's hard to imagine what that would even be like!)
Ah, I see it now - [it wasn't even in the survey](https://stackoverflow.com/insights/survey/2016#most-popular-technologies-other) back then. It was the most popular write-in in the "wanted" section back then though.
SQL is a programming language(S?L)? and 2.9% of the respondents prefer VB6?
Technically SQL is actually more of a programming language than Typescript, seeing as Javascript is actually a scripting language.
But there's a c interpreter and V8 compiles all JS to machine code
Actor model is something that came later. The story of how the terms script and program came to be used with computers predates it and is about where those terms originate: the theater. In a theater production the actors on stage get the script and the audience is handed a program as they walk in.