It's a WebStorm feature. Quite nice, except standard function signatures like `Math.floor(x: number): number` trigger that warning when you try to `floor` that `y` :)
This just feels like a less robust and less theoretically rigorous version of a number of already existing libraries. Why would I choose this over some others?
Yep, that's clever!
- hundreds of hours - introduced bugs - only to be back where you started - but now we can say that the code we don't have to maintain is now easier to maintain
I think eslint with typescript is good enough for everyday usage at this point. It's included with \[create-react-app 3\]([https://github.com/facebook/create-react-app/releases/tag/v3.0.0](https://github.com/facebook/create-react-app/releases/tag/v3.0.0)), which targets folks who don't want to mess around with their tooling. &amp;#x200B; I use JSDoc everywhere (\[example\]([https://github.com/danger/danger-js/blob/master/source/runner/Dangerfile.ts](https://github.com/danger/danger-js/blob/master/source/runner/Dangerfile.ts))), then build my own tools for extracting those and turning those into reference APIs
I can't find the link right now, but I read this somewhere and I use it frequently. When you start writing types for their JS code, don't use `any`. Use an interface like this: interface IFoo { [key: string]: any; } then you can add things to it incrementally as you understand the shape of the data, and eventually remove the `any` part.
This works fine as it should, the only issue is that TypeScript can ensure that `currentScreen` is always `Gamestate.level1` when encountering the switch, so it rules out all other cases. You can adjust that by using a type assertion: `let currentScreen = Gamestate.level1 as GameState;`
Thanks! I am still a bit confused as to why `let currentScreen: GameState = GameState.level1;` will not set `currentScreen` to be of type `GameState' as I want? It sets it to be of type `GameState.level1` which is not a type I was wanting to define or even know about... I think my understanding of something in the switch is missing?
It sets the type to `GameState.level1`, because that is the type your variable holds. In an enum every case is a type, and the enum-name is a union type. It's the same when you write: type SevenOrNine = 7 | 9 const value: SevenOrNine = 7 if (value === 9) { /* ... */ } TypeScript can ensure the type is always the number literal `7`. When the compiler is uncertain it will work as you expect: type SevenOrNine = 7 | 9 const value: SevenOrNine = Math.random() &gt; 0.5 ? 7 : 9 if (value === 9) { /* ... */ }
Cheers :)
At the moment I can't recall a good reason, must've been a remnant of the project template I copied while creating it.
Thank you so much for this explanation. I feel that I've actually learned something cool. Thanks again.
With nominal type support we would not need this, and instead could leverage the type system for this. :-( Still hoping at some point they will actually consider adding support.
In what ways does it seem less robust or less theoretically vigorous? This project was something I pulled out of an existing library of mine, where I needed to iterate over special data structures and dynamically created sequences (Dayspan is the library name). An important aspect of what I needed was lazy iteration and early exit functionality because my sequences we're potentially limitless and I only needed a subset of the data based on the users input. I didn't see anything like it when I originally created the class so I made my own, then later pulled it out and thought about it some more and established the operation, mutation, and view concepts. I pulled it out because I was working on another project involving more complicated data structures (spatial databases like grids, quad trees, BSPs) and I needed a way to provide the user a way to iterate over queries and collision detection results - all while not knowing if the user wants the entire set of data, or the closest 10 for example. I don't think anything exists like this already that allows me to do that stuff all under a single interface.
`npx tsc --init` generates pretty sane default tsconfig file with comments for each option.
Thanks for the tip!
This looks awesome. Is it incrementally included and/or does it support tree-shaking? We have some historical dependence on lodash and while this lib doesn't support everything we need, I am looking for more small libs to shore up JavaScript's abominable standard library.
 let currentScreen: GameState; currentScreen = GameState.level1; This may work.
I was curious how you handle things like reverse on an unbounded sequence. Only had a minute to look at the code, and it looked like you expect the sequence to be fully realized there. What did I miss?
&gt; is there a list of ECMAScript features TypeScript officially supports? Yes. Expand "Handbook" on the left. http://www.typescriptlang.org/docs/handbook/basic-types.html
Sorry I should've specified, I edited my OP.
Oh, good question, I'm not sure.
I would assume they need to support everything before they can just offer it as a source ES dialect. Perhaps they might not support the most granular possible typing on that new feature, but your code will compile.
Management should have zero to do with this decision If your managers are REALLY breathing down your neck, maybe only ever add the bare minimum of type definitions you need when you touch some code.
TypeScript aims to support all stage 3 or implemented proposals. Implementing takes time, so proposals that recently reached stage 3 might not be supported. I'm on mobile and on the run, so I can't look up what exactly is supported. Some earlier proposals are supported as well (e.g. decorators), but that's a step they usually regret and won't do anymore. Also it is important to mention that TypeScript will not add any polyfills (e.g. for array operations), except of those that are necessary for syntax features (e.g. classes).
Fun?
If you are talking TypeScript + React, I have a small project here: https://github.com/tkrotoff/MarvelHeroes It's a web app that displays the Marvel characters. - React with hooks - No Redux, just `useState()` - TypeScript with `strict: true` - Babel with `@babel/preset-typescript` - React Router - Jest + react-testing-library + Puppeteer =&gt; 100% code coverage - Fetch API + whatwg-fetch polyfill - Bootstrap 4
Do you have an example of ANY repo that‚Äôs fun to read? I only ever read while writing.
Here's a little game I work on now and then: [https://github.com/pagalvin/rpsn5](https://github.com/pagalvin/rpsn5) It's TypeScript + React and nearly playable. Might be useful to you. Good luck!
This describes our system and scenario. For us, it would otherwise take too long and not make sense to spend time migrating everything to JavaScript. TypeScript is very good at incremental implementation (when it is configured appropriately). If they have it already set up and working, there's nothing really to worry about. Just write your new code in TypeScript. Any new files we write are in TS and it takes no extra effort. If you *do* need to interface with legacy code, see if they're ok with converting to TypeScript, that's what we do. If some TypeScript interfaces with some JavaScript, that JS gets rewritten to TS as part of the patch. At this point, we still have a lot of JavaScript, but since we've been rewriting legacy as we touch it, most of our major important common systems are TypeScript. The nice thing about this is that the legacy code also gets a bit of fresh eyes and fresh testing, since the new patch is using the functionality.
It‚Äôs not a Typescript issue per se. This is a common pattern in Javascript, especially in Node. It allows Node to juggle all kinds of IO in parallel without requiring threading in your code. You are right that you cannot synchronously wait for the result of a Promise, so yes, it spreads everywhere. It‚Äôs a good pattern to write all functions that do IO to make them return Promises, even if it‚Äôs not necessary at first, to be ready for that inescapable moment when it is. It‚Äôs a lot better now than it used to be, since Promises and async/await make your code a lot flatter. It used to be callback hell and events everywhere. I‚Äôve come to like Promises quite a lot, actually. They are very easy to chain, combine, etcetera.
The size of the lib minified is 18kb, and gzipped it's 4.8kb. The tree and linked list iterators could be moved out so they are tree shakeable, that would probably reduce the size a fair amount, but even with all the functionality the library is pretty slim since so many operations and views are just slight variations of each other. (Check out the source, it's basically all in one class)
Most functions also have a callback if you don't want to use await
We should get this linked in the d.ts for React
I haven't looked into this in any detail, definitely looks interesting. [https://github.com/traduora/traduora](https://github.com/traduora/traduora)
&gt; Do I seriously have to modify every function all the way up my stack to return a Promise wrapping whatever it's actually responding with? You have to make it async at the point where you need the data and everything below that, because you *have to wait for that data*! The call to DynamoDB could take 30 seconds, or a few minutes, or any arbitrary amount of time, you can't just stall the process for 30 seconds waiting for the data. Given the amount of work we had to do in the past to make things non-blocking, you should be thankful it's only a keyword away now. &gt; What's going to happen to my tests? You make the tests async. Yes, whatever framework you're using already supports it. &gt; What about functions that can be called both for async and sync code paths? If there's the potential for the function to take an arbitrary amount of time to return data, *it needs to be async*! &gt; How does this not spread to everything? If you're writing a lot of glue code that does a DB call here and service call there, it's going to be async. That's life. [Also please read this blog post.](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
&gt; you can't just stall the process for 30 seconds waiting for the data. Why not? Java, C#, C++, Python, all of the other major programming will absolutely stall 30 seconds waiting for returns, they make absolutely no assumptions about the latency of any method they call. Why does Javascript force this boilerplate code on us to achieve the same thing?
Because C# and C++ can do something in one thread and something else in another, and Python programs are perfectly happy blocking the single thread that is available. Actually, Python has a non-blocking IO library that does the same thing JavaScript does now to address the same problem in Python. JavaScript is single threaded and uses various means including events, callbacks, and promises to get around the problems introduced by blocking behavior. Probably the best deep explanation of this is one of the Getify books. I forget which one. I recommend reading them all. :)
It just seems like such a waste because this is all going to end up blocking anyways. Like, this is a GET call on my Lambda. The caller is going to block on *me* until I return. All this is deciding where the inevitable blocking happens, so why can't it happen at the lowest level possible instead of *everywhere*?
You are fighting the language. You can't really get by without this stuff. Learn callbacks, events, and promises. Each has their place, and you need to understand them to work effectively in JavaScript or Typescript.
I'm not trying to fight the language, I just want to avoid boilerplate. If every function in my service has the keyword `async` in front of it and the return is wrapped with `Promise&lt;&gt;`, then that just seems wasteful as hell.
There is no blocking for IO in the main event loop when you use callbacks or promises. This is often optional in NodeJS (there are sync methods for most things), and this works okay if you can get away with it (one process doing one thing). For the browser, blocking the JavaScript thread blocks the browser. Not all libraries support synchronous methods, and you cannot convert async to sync. I find async/await with promises to be easier to reason about than callbacks most of the time, but it is definitely async code, and any async in code will propagate outwards. I assume you are doing this in JavaScript for some reason and can't do it in another language, so best just to accept fate and learn how it works, why, and use it as it is meant to be used. It isn't bad when you get used to it. :)
Direct link instead of this trash: https://www.humblebundle.com/software/full-stack-webdev-bundle
&gt; This is often optional in NodeJS (there are sync methods for most things) &gt; Not all libraries support synchronous methods, and you cannot convert async to sync. Whoa so there's a chance DynamoDb supports a synchronous call?! I'll take a look for that, thanks!
&gt; C# In C# it's the same: Once you use `async` it spreads across your entire call stack.
The other option is to convert the promise to a callback, of course. function getItem(id: number, callback: (err: any, item: Item) =&gt; void): void { const promise = DB.getAsync('item', id); promise.then(item =&gt; callback(null, item)).catch(err =&gt; callback(err, null)); }
There's a chance, but this is a very very bad idea unless it's like a start up one time configuration call.
Even in c++ a lot of high performance io based stuff is async.
Why's it a bad idea? I'm blocking at some point either way right?
No, the whole point of promises/callbacks is that you're not blocking the event loop. You're having the c++ portion of node do something while the event loop continues to work on whatever is on top of the stack. If you do a synchronous call, your literally taking the v8 to wait and do nothing until the c++ code is done.
Oh definitely not. I have just found Angular to be a great resource of how TS can be leveraged.
That doesn't really solve the problem though. At some level, I still need to have a top-level function that gets called and returns the response with blocking in-between.
At the very top level of this stack though has to be a single method that gets a service call and returns the appropriate response object. The latency of that method will probably be in the 100s of milliseconds. At some point, *something* has to block and wait. It's a REST API.
You are right of course that calls to a database take time, but I'm not going to explain to you exactly how node works, and you clearly don't fully understand. Here's something to read: https://nodejs.org/de/docs/guides/blocking-vs-non-blocking/ I haven't read that myself, but I think it probably covers the topic.
It is reassuring to hear that others have done this before! Are there any pain points of interfacing plain js code with ts code?
Thanks for sharing! I've used Typescript in a bunch of projects before but we always started out using it. Are there any pain points of interfacing plain javascript with Typescript?
It's \~turtles\~ promises all the way down. But seriously this is just how javascript works. It's an asynchronous runtime. If you can post some code though it would probably be easier to help.
That's just not how JS is setup to be used, unfortunately. If you're used to languages that block by default coming to JS might be a bit of a trip.
Jest or RxJS are both TS codebases that are well organized and a learning experience to get familiar with.
&gt; that just seems wasteful as hell What do you suppose it is wasting? And yes, async/await is infectious, and not just in JS. It does tend to force your entire call stack to be async.
&gt; What do you suppose it is wasting? Lots of dereferencing and indirection. Look, if I have a `serviceRequest` object that contains a `requestId` string, and I need that string 10 times in my function, I'm not going to call `serviceRequest.getRequestId()` 10 times, right? I'm going to do something like `let requestId = serviceRequest.getRequestId()` and then just use the local variable from then on. Because I don't want to do a lot of unnecessary dereferencing. By wrapping *every* return value in a `Promise&lt;WhatICareAbout&gt;`, it's making me fucking dereference it in the calling function *every time* even if just by an `await`. Simpler is better. Always fight unneeded complexity, and I refuse the argument that JavaScript is somehow special and needs this complexity when no one else does.
I have no idea if they're any good for learning, and have never looked into their history, but a few projects that come to mind that you could look into: * https://github.com/typeorm/typeorm - being an ORM makes very heavy use of typing and dynamic models of data (called entities in typeorm) ... lots of use of generics I think - which is still something I'm trying to get my head around * https://github.com/nestjs/nest - a general purpose web backend framework, so should have many familar concepts if you're a webdev * https://github.com/graphile/postgraphile - converts graphql queries to postgres queries * https://github.com/Microsoft/vscode - text editor
Hey, r0ck0, just a quick heads-up: **familar** is actually spelled **familiar**. You can remember it by **ends with -iar**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Hey /u/BooBCMB, just a quick heads up: No one likes it when you are spamming multiple layers deep. So here I am, doing the hypocritical thing, and replying to your comments as well. I realy like the idea of holding reddit hostage though, and I am quite drunk right now. Have a drunk day!
Hey, BooBCMBSucks, just a quick heads-up: **realy** is actually spelled **really**. You can remember it by **two ls**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Hey /u/BooBCMB, just a quick heads up: No one likes it when you are spamming multiple layers deep. So here I am, doing the hypocritical thing, and replying to your comments as well. I realy like the idea of holding reddit hostage though, and I am quite drunk right now. Have a drunk day!
Hi, a little SpaceInvaders-clone: [https://github.com/MikeMitterer/ts-spaceinvaders](https://github.com/MikeMitterer/ts-spaceinvaders) (UI: Vue, Core: TS) The commit-comments are sometimes a mixture between englisch + german but I try to stay with englisch for future commits.
For the record, async/await functions in C# predate and heavily inspire async/await in JS. Python has [async/await](https://docs.python.org/3/library/asyncio-task.html), too. Rust will probably have it in the [near future](https://github.com/rust-lang/rust/issues/50547) (no pun intended).
Hopefully Typescript continues to use its private keyword and then compiles to #private fields, so we never have to see that #ugly badly specified piece of #shit in our code. AS3 already solved this private variable problem by using shadowing and it worked great, so why did ECMA have to do it such a shitty different way?
Yes, once you await the entire call stack must become asynchronous. My advice is to separate business logic in pure sync functions and keep the async flow as small/simple as possible. It is certainly possible that all of your code is effectful and in that case everything is async, but I highly doubt it. My assumption is that you have put all of your logic in a handful of functions and now having to make them all async is annoying to you.
This isn't related to TypeScript at all &gt;\_&gt;
Y'all should just shut the fuck up, shame on your devs.
Yesssssss
No. Typescript code just imports it as "any." You can even have it allow js files.
Blocking VS nonblocking IO is a concept in computing all the way down to the OS level. If you do a synchronous/blocking IO call, your process still has a thread running, something like `while(!promise.resolved()) { sleep(); }`. No other code from that thread can execute, and the thread may hog cputime more than necessary. Sometimes around 2010 (maybe before?) all of the big boy managed languages started adding functionality &amp; syntax that made nonblocking IO easier. Async/Await &amp; Tasks in C#, Futures in Java, Promises in JS. These features allow developers to write concurrent code that would otherwise be "callback chaining" in more readable ways. Under the hood, these methods may use language/OS features to allow the program to never block while waiting for an asynchronous task to complete. And yes, for it to be any benefit, it has to be promises basically all the way. Unless you can just fire &amp; forget some promise.
I helped initiate this change! https://github.com/Microsoft/vscode/pull/68023
Good job dude!
Finally!
Actual URL to the thing: https://www.humblebundle.com/software/full-stack-webdev-bundle Quit the referral ID, spam facade bullshit.
Wow, such crucial info, seems I missed it in the main tutorial. Can you recommend some resources for knowledge such as this?
My opinion might be wrong here, but I don't think `defaultProps` really makes sense when using TypeScript. Couldn't you just make props with defaults optional in the Props types? Like ```ts type ButtonWithIconProps = { type: 'with-icon', icon: string, onClick?: React.MouseEventHandler&lt;HTMLButtonElement&gt;, onDoubleClick?: React.MouseEventHandler&lt;HTMLButtonElement&gt;, } ``` I kind of feel like `Component.defaultProps` is supposed to signal to the consumer which props are optional and which ones aren't. TypeScript gives you this exact functionality with the `?` syntax in types. I would be okay with inline default props also, but maybe that's just opinion. ```ts export const ButtonWithIcon = ({ type, onClick = () =&gt; {}, onDoubleClick = () =&gt; {}, }: ButtonIconWithProps) =&gt; // ... ``` TypeScript would still be able to narrow the type union when you specify the `type` prop, and it would be able to tell you which props are optional.
I think they're a [verified partner](https://www.humblebundle.com/partner/verified), so in either case it's humblebundle trying to make money by advertising. Regardless, the whole post _is_ advertising
I think you need to spend some time understanding how Javascript works before you start making judgements. I'm curious what languages you've used that allow async values to be used like sync values without any additional syntax/types. In my experience, most languages make async flow control significantly more complicated than JS.
Wouldn't the compiler catch it anyway? Even if you forget the \`await\`, your value will be of type \`Promise&lt;Something&gt;\` which would cause all kinds of downstream type errors from trying to use \`Promise&lt;Something&gt;\` in places that expect \`Something\`.
What if you are not looking at the return value. I will give you two cases where I believe this is a problem. &amp;#x200B; \`\`\` init() // forgot to await here doAfterInit() // this assumes init finished. \`\`\` \`\`\` try { anAsyncWhichMightThrow() // forgot to await here } catch { // This will never catch the error since we forgot to await. } \`\`\`
A defining feature of TypeScript is that it isn't nominally typed. I don't fully know what you have in mind here, but I think there's a lot of ways that could go wrong. I think this particular item is fixed pretty well by using objects to contain parameters when you have multiple parameters of the same time, or even more than 2 parameters. The readability of `callFn({ email: 'blah' })` is far superior to `callFn('blah')`.
Oh yeah these will cause problems. It kinda makes sense. There's no constraint in JS that says you must run async functions in a specific order, and there are legitimate use-cases for floating promises. Interestingly, if `anAsyncWhichMightThrow` isn't `async`, but returns a `new Promise`, it's possible that it could throw both synchronous and asynchronous errors if an error is thrown outside the promise body. I really hope nobody relies on that though. Anyway, I think the top comment is correct in suggesting [no-floating-promises](https://palantir.github.io/tslint/rules/no-floating-promises/). If your functions are `async`, they return promises even if you don't include a `return` statement, so the compiler should catch these cases.
Thank you for your service
Wait, what window? Even after looking at the pic I'm not sure what window this is talking about and I use VS Code religiously.
The correct term for `AsyncOrSync` is [Zalgo](https://blog.izs.me/2013/08/designing-apis-for-asynchrony).
@dvlsg Is there any methods that we can print the result without using IDE?
You might need to be more specific. I wouldn't consider VSCode to be an IDE. What exactly are you looking to do?
Nice article!
The idea I got from the parent post was creating domain types instead of naked string/number types, so the compiler can complain about incompatible types (TS can already do this with strings, but doing it with numbers breaks math operators IIRC). Ada and other languages have this functionality: type Integer_1 is range 1 .. 10; type Integer_2 is range 1 .. 10; A : Integer_1 := 8; B : Integer_2 := A; // error, type mismatch although I'm not sure I'd go as far as creating distinct types for X and Y coords myself.
Fucking thanks! That feature has been such a pain in the ass I have no idea what it was trying to solve. I don't know if I've ever wanted a peek when ctrl + click, I need to go into the damn file!
Thanks for your comment. Actually I mentioned that in "When this library is not needed" section. But defaultProps is still a good abstraction for Class Components when for some reason you don't have React 16/hooks.
I'm doing some simple examples with "vi" on command line, and compile \*.ts files with tsc. That's why I want to have some "command-like" feature to show the result. &amp;#x200B; Thank you for the link you sent, now I know VSCode has an embedded tsserver within it.
&gt; type BK = keyof typeof B Yes I was, this makes sense - thanks a lot!
Yes makes sense now having seen the example from the other comment - thanks!
Unfortunately calling `resolve(image)` is not enough to infer the whole operation as a `Promise&lt;typeof image&gt;`. Workaround: explicitly type the promise itself when instantiating it, as in: `const promise = new Promise&lt;HTMLImageElement | never&gt;((resolve, reject) =&gt; ...)`.
You basically want this: ``` function loadImage(path: string): Promise&lt;HTMLImageElement&gt; { const image = new Image(); const promise = new Promise&lt;HTMLImageElement&gt;((resolve, reject) =&gt; { image.onload = () =&gt; resolve(image); image.onerror = reject; }); image.src = path; return promise; } async function simple() { const arrow = await loadImage('http://i.imgur.com/U4hfvaH.png'); console.log(arrow.height); } simple(); ``` The reason why `Promise.reject()` returns a `Promise&lt;never&gt;` is because it is known to never resolve. However, in your case the promise will either resolve with the image or reject with an error.
No Problem. You can even rename every file into a *.ts file. TS is a superset so js is still valid ts
1) You are looking at the wrong typings. You linked to the typings for the static function Promise.reject(), not what happens when you reject() within a Promise. 2) The problem is that TypeScript infers the wrong type of Promise here. You need to help it when you construct the Promise. See https://github.com/Microsoft/TypeScript/issues/5254 . Fixed code: https://www.typescriptlang.org/play/#src=function%20loadImage(path%3A%20string)%3A%20Promise&lt;HTMLImageElement&gt;%20%7B%0D%0A%20%20%20%20const%20image%20%3D%20new%20Image()%3B%0D%0A%20%20%20%20const%20promise%20%3D%20new%20Promise&lt;HTMLImageElement&gt;((resolve%2C%20reject)%20%3D&gt;%20%7B%0D%0A%20%20%20%20%20%20%20%20image.onload%20%3D%20()%20%3D&gt;%20resolve(image)%3B%0D%0A%20%20%20%20%20%20%20%20image.onerror%20%3D%20reject%3B%0D%0A%20%20%20%20%7D)%3B%0D%0A%20%20%20%20image.src%20%3D%20path%3B%0D%0A%20%20%20%20return%20promise%3B%0D%0A%7D%0D%0A
&gt;Promise&lt;HTMLImageElement&gt; Thanks! Would you bother with the `|never`? Everything seems work great without it. My total code is now below, does it look A OK? Cheers! ``` function loadImage(path: string) { const image = new Image(); const promise = new Promise&lt;HTMLImageElement&gt;((resolve, reject) =&gt; { image.onload = () =&gt; resolve(image); image.onerror = () =&gt; reject(new Error(`Problem with image file: ${path}`)); }); image.src = path; return promise; } ```
Cheers, thanks for the help!
No problem. `never` is not relevant when dealing with a resolved Promise, your code here is fine. Happy typing !
Thanks for the detailed info, I am afraid your link has got corrupted somehow.
Do you have the same `tsconfig.json` settings as the author? In particular, do you have `strictNullChecks` on?
The [TypeScript Docs](https://www.typescriptlang.org/docs/handbook/jsx.html) have a nice section on this.
It works if you copy and paste it, sorry for being bad at reddit.
Though I wouldn't recommend this. I recommend sticking to strict TypeScript and slowly convert your codebase over.
Including since connect happens first in the "lifecycle"
The component wrapped by connect will include the props that connect provides. IMyProps are all the key value pairs that you can find on `this.props`
The only time I would use `Promise&lt;never&gt;` is if an async function *only* throws or never returns: ```ts async function foo(): Promise&lt;never&gt; { while(true) { console.log('foo'); await wait(10); } } async function bar(error: Error): Promise&lt;never&gt; { throw error; } ```
Yeah I read your post and that's the point I was trying to criticize
A few of the points apply more to Babel than TS, particularly since the recommended way to use TS is with typescript-babel, and to use \`tsc\` only for typechecking.
This example should illustrate the concepts enough: interface OwnProps { personId: number } interface StateProps { person: Person } interface DispatchProps { onPersonFired: (personId: number) =&gt; void } type Props = OwnProps &amp; StateProps &amp; DispatchProps export const Person = ( { personId, person, onPersonFired }: Props) =&gt; { return &lt;div onClick={() =&gt; onPersonFired(personId)}&gt;{person.name}&lt;/div&gt; } const mapStateToProps = (state: State, { personId }: OwnProps): StateProps =&gt; { return { person: getPerson(state, personId) } } const mapDispatchToProps = { onPersonFired: firePerson } export const ConnectedPerson = connect&lt;StateProps, DispatchProps, OwnProps&gt;(mapStateToProps, mapDispatchToProps)(Person) The total props are composed from three sets of props: own props (the props that are the arguments to the whole connected component, but can be also consumed by the inner component), state props (props that are derived from the state in mapStateToProps) and dispatch props (wiring to action creators).
No it isn't. Babel lags behind the official compiler considerably. They get features later. The recommended way to use TS is through tsc
You shouldn‚Äôt even need to specify the generics in ‚Äòconnect‚Äô as you‚Äôre doing ‚Äî ts can infer these. But +1 this is nearly identical to how I structure and name props.
`tsc` downlevel compilation targets are just ES3/5/6/next, while Babel has the much more useful `preset-env`; that and other things like `babel-plugin-macros` means you'll probably be using Babel anyway (or should use it), and in that case it's much faster to use Babel's TS transform instead of `tsc` downlevel compilation. Using Babel with TS also means there's no need to have a webpack TS loader, `ts-node`, and all the other TS specific tooling. All you really lose by using the Babel TS transform is const enums.
I find that this makes figuring out errors easier (TS produces better errors when you mess up something in either of the connect methods, the prop interfaces or the inner component declaration). This line gets copied everywhere anyways and makes things a bit clearer to people not familiar with the process :)
How are you installing typescript?
I had it installed it via Angular, I also installed it via npm as well. Now my system no longer recognizes the ng command, or the tsc command, the npm command to install angular I used the one from their website. I use this to install typescript: npm install -g typescript. Yesterday both were functioning happily, today my PC has decided they don't exist.
&gt; I had it installed it via Angular, How is angular capable of installing anything? I genuinely don't understand. &gt; I use this to install typescript: npm install -g typescript Ok, that makes sense. Hmm... what operating system?
Angular uses typescript by default. I wanted to ensure I had the most recent version. Neither the ng command or tsc are recognized by my system.
Check your environment variables, ensure that it's added to your path.
A good way to execute TSC is with npx. If it's not in the node modules paths, it downloads and runs TSC. Btw, have you installed TSC with this line? npm install -g typescript Or with other way?
I guess you have to install it globally by running `npm i -g typescript` Otherwise, if you omit the `-g`, said package will be installed in the current directory and only available via command line in that directory (and I think not all packages have executables to begin with).
That‚Äôs what I am doing. Using the -g.
How do I find out where it‚Äôs installed or even if it really is if it doesn‚Äôt recognize the commands?
What's your OS and environment? Node and npm versions?
Angular usually does not support the most recent version of TypeScript.
I'd recommend checking that your global modules do, in fact, still have typescript installed. The global node_modules folder is in %appdata%/npm/node_modules (usually) if you're on windows. If it's in there, check your environment variables PATH. You can do this by going into control panel and search "environment variables" and click "Edit the system environment variables" in which there should be a "Path" which contains your command-line accessible folders with executables. If it isn't here, add the folder to your path. Make sure you restart command line after edits.
Shouldn't this be done on installing with npm? Regardless no neither angular or typescript are in the path. They are installed. I do not understand how they got removed.
It should be done, yes - but from what you've described, it sounds like you've somehow rolled back all of your changes. Very strange. I'd recommend just re-running `npm i -g typescript` and whatever else you need. See if issues persist? If it keeps happening then I'm really not sure.
Babel is only really useful if you are serving in a browser so you can target things like IE11 and non evergreen browsers. If you are making a node API for instance, you don't need anything more than tsc to compile to js, or you can use ts-node which just does that for you.
just did it, and nada. I'm starting to get aggravated, I was using Angular and TypeScript both just fine yesterady, and now it doesn't recognize them even though both are clearly installed. I even manually added the paths. I'm about to give up, because I don't know what else to do.
That's not a feature the Typescript compiler has, if you're looking for an alternative to webpack you could try rollup.
&gt;rollup Got it. Thanks!
To really understand what is happening here, we would need to see your call to `todos`. However, from my experience what is happening here is that whatever you are passing to `todo` as the parameter `state` actually has a type `string | undefined`. To fix this, you can track down where that mistake in types is happening, or you can tell the compiler that it will always be a string (the less preferred method). For instance: ``` function todos(state: string): string { return state; } interface RequiredA { a: string; } //this will work, no doubt const reqA: RequiredA = { a: "a" }; const b = todos(reqA.a); //a is required so it is always defined as a string expect(a).toBeEqual(reqA.a); interface OptionalA { a?: string; //this is equivalent to type (string | undefined) } //the type here is still optional for a even if we send a value const optA: OptionalA = { a: "a" } //this will cause a compiler error todos(optA.a); //c is string | undefined not string //don't do this unless you absolutely have to tell the compiler what is correct todos(optA.a as string); //no compiler error because we tell typescript that a is a string and not a string | undefined. ``` This is just one of many examples of what could be causing this, so post more code if you really want to know what's wrong.
So you've got %appdata%/npm/node_modules/typescript/bin on your environment path and it doesn't work?
Ahh, this could be it. I put it in bin because that's where most everything else lives that I've done lately. I'll try the new path.
yeah, \`npx tsc\` should do the trick
I‚Äôm actually just passing the function to createStore function in react redux.
Let me know how it goes!
Are you using interfaces? This is exactly what they're for.
Ok, well that may be your problem right there... As I said, you should really post more code. But based on what you're saying, I just went to the Redux docs (here: https://redux.js.org/api/createstore) and found this: ``` import { createStore } from 'redux' function todos(state = [], action) { switch (action.type) { case 'ADD_TODO': return state.concat([action.text]) default: return state } } const store = createStore(todos, ['Use Redux']) store.dispatch({ type: 'ADD_TODO', text: 'Read the docs' }) console.log(store.getState()) // [ 'Use Redux', 'Read the docs' ] ``` As you can see, you should be passing in a default value to createStore, without it I bet it just uses undefined instead of string. So, it should be `createStore(todos, "")` if you want an empty string. I will say it doesn't really make sense for todos to be a string and not an array or map, but I'm assuming you're just using this to learn so it doesn't really matter.
This is because in JavaScript you can do this: \`\`\` function fn(a,b,c,d) { return a+b+c+d; } const k = fn("a"); //when this is called, b,c, and d are undefined to fn. This is how we can get optional parameter types with TypeScript, because you are able to create variadic functions like this in JavaScript. Similarly you can use the spread operator \`...\` at the end of a function to pass additional unknown # of arguments
This should get you on the right, erm, path https://dzone.com/articles/how-to-install-typescript-and-nodejs-typescript-tu-1
Your environment's `PATH` variable needs to include the `npm` global install directory. Execute `npm root -g` to get your global NPM directory. Make sure that that directory is in your environment's `PATH` variable.
If you use Node version manager (nvm) and changed the Node version you can lose your global modules. Maybe not your situation but throwing that out there.
If you don't want to use bundlers then the --outfile compiler option is what you use to output all your code (modules and namespaces and triple-slash-referenced files) into a single file. It only supports AMD and SystemJs modules, and you need an AMD or SystemJs loader library. I ended up using [SystemJs](https://github.com/systemjs/systemjs) on my project. But use a bundler if you can. It is a lot simpler. Another good alternative to the webpack bundler is [ParcelJs](https://parceljs.org/), btw.
I'm exporting a bunch of different similarly typed functions that are not at all otherwise related (for plugins), and I want to ensure that every `export function blah` is the same signature. I'm not sure how an interface would help there. What is your idea?
Parcel is not good for TypeScript, unfortunately, as I really like it. Parcel compiler does not emit any type or compilation errors, it will happily ignore any problems in your code as long as the type-stripped code builds. It makes TypeScript with Parcel completely pointless. You can follow the issues here: https://github.com/parcel-bundler/parcel/issues/1378
Yep, that it is.
They are both already installed. The issue is why I can't use them.
Still same as before nothing. I've tried every suggestion given here, and nothing.
Windows 10, I do not understand what you mean by environment. Node is 10.15, npm is 6.4.5
This did the trick, however I am not happy about yet another command I have to type. I want to go back to just using tsc. I do not see how this is a "good" way of doing anything. If it were the only way I would just deal with it, but I know that before today I was able to use just tsc.
fuse-box.org seems promising as well. Tried it myself once and even I was able to understand it to some extent.
I think the general approach you have makes sense. You could clean up the syntax a little which would make it a little cleaner I think. Something like: type FunctionThing = (value: string) =&gt; string const moduleName: Record&lt;string, FunctionThing&gt; = { thing: (value) =&gt; ‚Äúhello‚Äù + value } export default moduleName I‚Äôm assuming that if these all have to have the same signature, theres some moduleName that makes sense to group them. Then combining it all in one object lets you avoid creating an empty object and adding to it. Also you can leave off the type for ‚Äòvalue‚Äô in the actual implementation because TypeScript can infer it based on it being in that Record type. Sorry for any weird formatting. I‚Äôm on mobile.
\&gt;Parcel compiler does not emit any type or compilation errors, it will happily ignore any problems in your code as long as the type-stripped code builds. It makes TypeScript with Parcel completely pointless. You can set noEmit:true in your tsconfig.json and then run "tsc -w" in a separate terminal to see typescript errors.
Since the UUID will just be a string, you can just define a type alias `type UUID = string` and use that type - no extra dependencies üòâ Note: Since TS doesn't support opaque types, this type alias will merely make the code a little clearer to read, it won't have any impact on type checking (TS doesn‚Äôt know that a UUID is a string in a certain format, it will just treat it as if you declared the property to be a plain old string).
One of the main points of TS over other type systems it that it is structural (while popular C# and Java are nominal). &amp;#x200B; This means that in order to check if two types A and B are assignable, each of its properties are compared exhaustively. While C# or Java requires both objects to have been strictly created with the same "constructor". &amp;#x200B; TS does not care about constructors, as long as 2 objects have the same properties, now matter how thet were "constructed", they are assignable (as a general rule).
If you set your `--target` to ES6 or newer or set `--module` to ES6 TypeScript should emit normal module imports instead of converting them to `require()` calls. You'll still need a bundler though if any of your dependencies don't use ES modules or you do anything else not compatible with the web like leaving off file extensions.
As others have mentioned, TS is structurally typed ("duck typed") rather than nominally typed. However, there are ways to emulate nominal/opaque types (there are a few guides out there, such as [this one](https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html)). Even the official TypeScript team use [something similar](https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698). The approach I personally use is to use the following pattern: `type SomeNominalType = SomeStructuralType &amp; { readonly _: unique symbol };` (using `unique symbol` rather than a string literal etc. prevents any collisions with other opaque types with the same name). So for your example, if you do want to prevent `id` from being set to any old string, the way I would implement it would be: ``` // Uuid.ts import { generate } from 'some-uuid-lib'; export type Uuid = string &amp; { readonly _: unique symbol }; export function Uuid(): Uuid { return generate() as Uuid; } // app.ts import { Uuid } from './Uuid.ts'; interface Book { id: Uuid; title: string; pages: number; } // [ts] Type 'string' is not assignable to type 'Uuid' const book1: Book = { id: 'any old string', title: 'foo', pages: 32, }; // Valid! :) const book2: Book = { id: Uuid(), title: Uuid(), pages: 54, }; // (Note also that `Uuid` is a subtype of `string`, so it can be assigned to `Book['title']`) ```
Babel has `babel-node` in place of `ts-node`, and using Babel also enables you to use tools like Jest that support Babel out of the box, instead of having to use `ts-jest`.
I honestly wouldn't bother creating aliases for built-in types. You don't really gain anything, but you add boilerplate and make it a little less clear that you can perform string operations on your UUIDs. If you really want something like a nominal type, I'd try the approach another commenter mentioned with `unique symbol`.
Not sure why everyone's talking about nominal and structural types? Your question wasn't really about that. You just need to use the types you care about. Where did you get the Uuid type from? If it's just a string, type it as a string and move on.
Not sure but it may cast it as the x and y properties exist in point3d. My best bet would be to use classes with constructors to stop this behaviour
Typescript is structurally typed, as opposed to nominally typed. Point3D has all of the fields that Point2D has, so functions that require a Point2D will be able to operate on a Point3D as well. If you want something approaching nominal typing, you'll need to add a "brand" property: interface Point2D { __brand: "Point2D"; x: number; y: number; } interface Point3D { __brand: "Point3D"; x: number; y: number; z: number; } Using a string literal as a type means that these two types are not compatible.
TypeScript is a \*structural\* type system, which means that a 3D point can be used as a 2D point because they are structurally similar (they both have \`x:number, y:number\`) - this is because there aren't really types in objects and really you're only declaring an interface. The whole of the 2d interface fits inside the 3d, so they're the same &amp;#x200B; \[Here's a modified version\]([https://www.typescriptlang.org/play/#src=interface%20Point2D%20%7B%0D%0Ax%3A%20number%3B%0D%0Ay%3A%20number%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Point3D%20%7B%0D%0Ax%3A%20number%3B%0D%0Ay%3A%20number%3B%0D%0Az%3A%20number%3B%0D%0A%7D%0D%0A%0D%0Avar%20point2D%3A%20Point2D%20%3D%20%7B%20x%3A%200%2C%20y%3A%2010%20%7D%0D%0Avar%20point3D%3A%20Point3D%20%3D%20%7B%20x%3A%200%2C%20y%3A%2010%2C%20z%3A%2020%20%7D%0D%0Afunction%20iTakePoint2D(point%3A%20Point2D)%20%7B%20%2F\*%20do%20something%20\*%2F%20%7D%0D%0A%0D%0AiTakePoint2D(point2D)%3B%20%2F%2F%20accept%20anything%20that%20does%20%20%7B%20x%3A%20number%2C%20y%3A%20number%20%7D%0D%0AiTakePoint2D(point3D)%3B%0D%0A%0D%0A%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%0D%0A%0D%0Ainterface%20Point2DV2%20%7B%0D%0A%20%20x%3A%20number%3B%0D%0A%20%20y%3A%20number%3B%0D%0A%20%20type%3A%20%222d%22%0D%0A%7D%0D%0A%0D%0Ainterface%20Point3DV2%20%7B%0D%0A%20%20x%3A%20number%3B%0D%0A%20%20y%3A%20number%3B%0D%0A%20%20z%3A%20number%3B%0D%0A%20%20type%3A%20%223d%22%0D%0A%7D%0D%0A%0D%0Adeclare%20var%20point2Dv2%3A%20Point2DV2%0D%0Adeclare%20var%20point3Dv2%3A%20Point3DV2%0D%0A%0D%0Afunction%20iTakePoint2DV2(point%3A%20Point2DV2)%20%7B%20%2F\*%20do%20something%20\*%2F%20%7D%0D%0A%0D%0AiTakePoint2DV2(point2Dv2)%0D%0AiTakePoint2DV2(point3Dv2)%0D%0A%0D%0A](https://www.typescriptlang.org/play/#src=interface%20Point2D%20%7B%0D%0Ax%3A%20number%3B%0D%0Ay%3A%20number%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Point3D%20%7B%0D%0Ax%3A%20number%3B%0D%0Ay%3A%20number%3B%0D%0Az%3A%20number%3B%0D%0A%7D%0D%0A%0D%0Avar%20point2D%3A%20Point2D%20%3D%20%7B%20x%3A%200%2C%20y%3A%2010%20%7D%0D%0Avar%20point3D%3A%20Point3D%20%3D%20%7B%20x%3A%200%2C%20y%3A%2010%2C%20z%3A%2020%20%7D%0D%0Afunction%20iTakePoint2D(point%3A%20Point2D)%20%7B%20%2F*%20do%20something%20*%2F%20%7D%0D%0A%0D%0AiTakePoint2D(point2D)%3B%20%2F%2F%20accept%20anything%20that%20does%20%20%7B%20x%3A%20number%2C%20y%3A%20number%20%7D%0D%0AiTakePoint2D(point3D)%3B%0D%0A%0D%0A%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%0D%0A%0D%0Ainterface%20Point2DV2%20%7B%0D%0A%20%20x%3A%20number%3B%0D%0A%20%20y%3A%20number%3B%0D%0A%20%20type%3A%20%222d%22%0D%0A%7D%0D%0A%0D%0Ainterface%20Point3DV2%20%7B%0D%0A%20%20x%3A%20number%3B%0D%0A%20%20y%3A%20number%3B%0D%0A%20%20z%3A%20number%3B%0D%0A%20%20type%3A%20%223d%22%0D%0A%7D%0D%0A%0D%0Adeclare%20var%20point2Dv2%3A%20Point2DV2%0D%0Adeclare%20var%20point3Dv2%3A%20Point3DV2%0D%0A%0D%0Afunction%20iTakePoint2DV2(point%3A%20Point2DV2)%20%7B%20%2F*%20do%20something%20*%2F%20%7D%0D%0A%0D%0AiTakePoint2DV2(point2Dv2)%0D%0AiTakePoint2DV2(point3Dv2)%0D%0A%0D%0A)) that wouldn't accept the 3D version - but you have to break the interface
Regardless of whether or not you agree with it, I'm sure you can figure out what's going on. Point2D is a subset of Point3D, and therefore Point3D passes the Point2D check. This behavior is often very convenient. Let's say I made my own promise class, I would still want typescript to consider them to be promises, even if they're not the default promises. It's ultimately debatable how this should work, the problem with being too picky with stuff is that people will only use things as long as it's convenient, and if typescript really started yelling at people for every single instance of this people would just default to using any. As alpha said, if you're really bothered about this you can use classes.
Woah... I did not know about this and I've been using TS for years. I guess I never had 2 interfaces that similar in nature.
yeah, I hear you bktechnike, I'm on the same boat. Thank you for the explanation, 1384, that makes sense. But I'm still not sure whether or not I completely agree with that. I can imagine, for example, this situation: const formatting = { x: () =&gt; ... y: () =&gt; ... } ... function iTakePoint2d(point: Point2D) { Object.entries(point).map(([key, value]) =&gt; formatting[key](value)); } I was relying that TypeScript was going to restrict only objects in the format that I declared on the typing, but it actually won't as per the reasons you described, and therefore this snippet would result in an error during execution time if Point3D was passed as if it was Point2D.
...did you try the example you provided? `iTakePoint2d` will emit an error at compile time in your example.
You can set it up correctly but you need to fix your path environment variable as everyone is trying to help you with. It's very difficult to diagnose this kind of problem without sitting down at the machine to do it. Frankly I would just use \`npx\`. That way you get get to coding and won't have to keep banging your head against the wall.
That's what I'm trying to figure out, however nothing is working other than npx. I don't understand why I was able to do just plain tsc etc the other day and now I can't.
I think this is called "ducks typing", as in "if it looks like a duck and quacks like a duck...".
Why not do ``` interface Point2D { x: number; y: number; } interface Point3D extends Point2D { z: number; } ``` ?
methods like Object.entries/keys require you to help the compiler out a bit. They don't automatically convert to strings to a type-safe "keyof" representation. An easy way to avoid the runtime error in the specific case you've pointed out is simply to use Object.entries(formatting) and thus process only the keys you want, but you're right that the compiler won't help you out much here. talbenari1 is also correct that your example will show a compiler error, but it's related to "formatting" not having a string index signature. Fixing that compile error, however, will not prevent the runtime error. here's an example of a runtime-error free implementation that has some type safety on the formatter object: type Point2D = { x: number; y: number; } type Point3D = { x: number; y: number; z: number; } type Formatter&lt;In, Out&gt; = { [K in keyof In]: (input: In[K]) =&gt; Out } const formatting: Formatter&lt;Point2D, string&gt; = { x: (i: number) =&gt; "x: " + i, y: (i: number) =&gt; "y: " + i, } function iTakePoint2d(point: Point2D) { const keys = Object.keys(formatting) as (keyof Point2D)[]; return keys.map(key =&gt; formatting[key](point[key])); } const p2d: Point2D = { x: 1, y: 1 }; const p3d: Point3D = { x: 1, y: 1, z: 1}; iTakePoint2d(p2d) iTakePoint2d(p3d) While the function will still accept a Point3D, it will only operate on the keys from Point2D, avoiding the runtime error. And the "Formatter&lt;In, Out&gt;" type ensures that the "formatting" object has only the keys from Point2D. If you want to explicitly exclude Point3D from being used in this function, you can use a brand property, or a type guard, or a more explicit/fleshed out type like a Class with distinct methods, etc. But if your implementation is as you describe, this should suffice. The function takes an object with the same keys as "formatter" and operates explicitly on those keys and no others.
This structural typing offers so many great possibilities that don't work in most other languages. I like to compare it to Rust's traits
Duplication of [https://www.reddit.com/r/typescript/comments/bhj1sx/whats\_the\_big\_deal\_with\_typescript/](https://www.reddit.com/r/typescript/comments/bhj1sx/whats_the_big_deal_with_typescript/)
Fix the URL bro
Hrm, what do you mean? when I click it takes me to the playground I was expecting
It's mainly that TypeScript and Babel have different release cycles, the TypeScript team generally send over all syntax changes to Babel pretty quickly after they've been added to TypeScript's master repo üëçüèæ &amp;#x200B; I wouldn't be surprised if that lag came to about 2-3 weeks, which feels pretty acceptable. While the TS docs all talk about using \`tsc\` - babel support is first class from the TypeScript team. Which IMO, is awesome.
Personally, I'd recommend **always** using TypeScript through npm and yarn. &amp;#x200B; This means adding TypeScript to your project via \`devDependencies\` (\`yarn add --dev typescript\`) and then using \`yarn tsc\` to compile (or use \`"scripts"\`). Why? Well this means that each project can have their own version of TypeScript, because you might have accidentally be using the wrong version for this project. Then there's less messing around with globals.
By the way it is fixed. No idea why either. Thanks to everyone who tried to help.
I think it depends on how the code that *uses* these types is gonna look. Will the extra safety be useful? Or annoying? I try to think about the experience of another engineer on my team using these types. What's going to help them do their job correctly? If non-null assertions are easy to write, and if JSDoc tooltips make it obvious to that engineer that they need to check `type` first, then maybe the simpler approach is better.
Realy?
As long as you know when to discriminate, then the consuming code should be air-tight, and want to write itself. But I could see that become challenging. A contractor has introduced some prod errors like "cannot read property &lt;&gt; of undefined" and it's because he wasn't defensive enough and started using `!` . I can understand why he was so frustrated with the endless checks for undefined...
It does. I just meant to format it in the comment
If you don't want to use duck typing, the you can use branded types. https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html
It's when you click on a piece of code that was imported from some other file but instead of just going directly to the source, it will show a peek window. It was really bad.
Huh... I just tried a Ctrl + click like yesterday to see if it did that and it actually navigated to the file. *shrug*
Either you changed your path env var or the files that exist within one of the paths
"I need someone to do duck duck things. If you can quack and waddle I don't care if can also operate assault rifles." - JS/TS
It's all about ducks.
True. And there is an async library in development for Rust. There are advantages to that programming model.
Take a look at the Getify async book (free on github) to understand where this stuff came from. It solves a number of problems, and there are alternatives if you don't like this. I will say that async/await is the solution with the least amount of boilerplate for JavaScript and TypeScript.
That was like 3 days ago the service is done now lol
This is now my favourite explanation of structural/duck typing. Definitely gonna use this in future haha.
I usually see no issue with adding more detailed types as it can be helpful later on when the code becomes more complex. You could define `Product` like this: namespace Product { interface Product&lt;Type extends string&gt; { type: Type } export interface Shoes extends Product&lt;'shoes'&gt; { size: number } export interface Car extends Product&lt;'car'&gt; { year: number } } type Product = Product.Shoes | Product.Car And at some point you could have advanced logic that expects only `Shoes` or only `Car`. I think at that point it is unreasonable to carry around a generic `Product` and check the `type` each time to get `size` or `year`, if you, since the beginning, know that you are only working with `Shoes` and nothing else. Also, `switch..case` statements work really well with this type of structure, where it infers which type of product it is. function label(product: Product): string { switch (product.type) { case 'shoes': return `Shoes(size = ${product.size})` case 'car': return `Car(year = ${product.year})`; } }
&gt;why can't it happen at the lowest level possible instead of everywhere? But it can happen at the lowest possible level. There are two ways to use promises, either "synchronous-like" with `async/await` or using a callback with `.then/.catch`. In my programs, I use `async/await` throughout the program, but you can also just use callback. yourDynamoCall().then(result =&gt; /* do stuff */) The difference is that your synchronous call just passes through this line instantly and the callback is executed when the results come back. If you use `async/await`, the program will wait at your `await yourDynamoCall()` and do other stuff. Why "do other stuff"? Because the user might want to click some things while the comments are loading. Or the server might want to serve other requests while the data for a particular request is still fetching.
Goroutines in Go work the same way, right?
I think he doesn't know about `.then/.catch` and thinks that he has to use `await` to resolve the promise. I [replied here](https://www.reddit.com/r/typescript/comments/bgy3l5/how_do_i_contain_async_functionality/elywvui/).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javascript] [MikroORM - TypeScript data-mapper ORM with Identity Map for mongo\/mysql\/postgres\/sqlite](https://www.reddit.com/r/javascript/comments/bi9qwr/mikroorm_typescript_datamapper_orm_with_identity/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Why not separate types for Shoe and Car, and then have Product be a union type between them? Then you can make a type guard function that checks whether you're dealing with a shoe or a car.
What was your main source of learning material when you learned typescript? I'm curious because this is like one of the cornerstones of the language in my opinion.
This is the correct answer. Look into tagged union literals
What's the use of this?
What you're proposing seems to me like quite standard way of definings interfaces with discriminated unions. Imo it makes much sense for larger/more complex business domains. It's probably overkill for one or two types :) You need some kind of discriminator (kind/type) to discriminate by to access field of specific kind. For this reason it's useful to have those kinds in some enum (or typed js map). Here's how I would structure it: ```ts enum ProductKind { SHOES = "SHOES", CAR = "CAR" } // product interface will act like abstract class interface Product { kind: ProductKind; price: number; } // or you can use union like in your example // but imo interfaces have more sane inheritance flow type UProduct = ShoesProduct | CarProduct; interface ShoesProduct extends Product { kind: ProductKind.SHOES; size: number; } interface CarProduct extends Product { kind: ProductKind.CAR; size: number; } // can be useful to define guards const isShoesProduct = (product: Product): product is ShoesProduct =&gt; product.kind === ProductKind.SHOES; const isCarProduct = (product: Product): product is CarProduct =&gt; product.kind === ProductKind.CAR; const doSomething = (product: Product) =&gt; { if(isCarProduct(product)) console.log(product.year) if(isShoesProduct(product) console.log(product.size) } // your groups can one own discriminator enum ProductGroupKind { SHOES = "SHOES_GROUP", CAR = "CAR_GROUP" } interface ProductGroup { kind: ProductGroupKind; products: Product[]; } interface CarProductGroup extends ProductGroup { kind: ProductGroupKind.CAR; products: CarProduct[]; } // some composition of few kinds/types enum NodeKind { PRODUCT = "PRODUCT", PRODUCT_GROUP = "PRODUCT_GROUP" } interface ProductGroupPrim { kind: NodeKind; productKind: ProductKind; products: Product[]; } interface CarProductGroupPrim extends ProductGroupPrim { kind: NodeKind.PRODUCT_GROUP; productKind: ProductKind.CAR; products: CarProduct[]; } const isCarProductGroup = (group: ProductGroupPrim) =&gt; group.productKind === ProductKind.CAR // or just use generic interface ProductGroupGeneric&lt;P extends Product&gt; { products: P[]; } // if you create KindToType maps (plain or some smart mapped type) - you can automatically lock generic type interface ProductGroupGeneric&lt;K extends ProductKind&gt; { products: Array&lt;KindToType&lt;K&gt;&gt;; productKind: K } ``` It's a bit more verbose but imo makes your code quite clean &amp; semantic. Btw. You may want to look into GraphQL. It's basically a language that allows creating strictly typed APIs (amongst few other features). You would just define ```graphql interface Product { price: Int! } type CarProduct implements Product { price: Int! year: Int! } type ShoeProduct implements Product { price: Int! size: Int! } ``` and all of above (and more) could be generated using some codegens.
There have been significant improvements to the react-redux types and TypeScript error messages in the last six months. You can just assign types to `state`, `ownProps` and `dispatch` and the rest will be inferred correctly. I'd recommend giving it a try.
Hah, "works fine in new Reddit" - looks like somehow it is borked in old reddit. Thanks, sigh.
I've added this to [my list](https://github.com/orta/typescript-notes/issues/7) of things to improve in the playground.
Sync file IO?
You mean metadata discovery? It happens just once, and then its cached, but sure I can make that async.
You mean metadata discovery? It happens just once, and then its cached, but sure I can make that async.
In vscode you can press a hotkey to auto import, and you can enable it to do it on autocomplete, letting you choose any export from any file, including dependencies. Can't remember if it's a setting or plugin...
I just saw only sync imports from fs and globby, that's it. As for another feedback, currently your project isn't feature-rich to be used in a somewhat 'big' project that heavily utilizes DB. For example, I didn't see any lifecycle hooks for SELECT operations (after you retrieve records from DB), no plain raw query in query builder, maybe it's just missing in documentation though. I mean new NodeJS ORMs are always welcome especially written with proper TS support because I work on a big Node + MySQL project and for now I stick with ObjectionJS but I wish I could use something like Sequelize with proper TypeScript. I tried TypeORM but it wasn't flexible enough for my needs so I just rewrote everything to use Objection. But Sequelize was still the best experience for me before I started using TypeScript. So if you want to know feature directions for your development I guess you can just look into Sequelize because it has almost everything you expect from proper ORM.
Just curious, why do you switch from Symfony to Node?
[It looks like Microsoft wrote one but it's not the one I'm thinking of.](https://github.com/Microsoft/ts-api-checker)
Thanks for the feedback! Can you give an example use case for on select/on fetch hook? Btw looking and sequelize hooks, I do not see such thing... Btw raw sql is also supported, at query level (you can run SQL on driver level) as well as parts of where clause can be added via string literals (that is part of query builder API).
https://api-extractor.com
You could use the typescript compiler directly via its Node API to test if your code can still compile against a given type. Not super convenient, but building the tool you're looking for would be a day or two of work tops.
Sequelize has hooks for almost everything [http://docs.sequelizejs.com/manual/hooks.html](http://docs.sequelizejs.com/manual/hooks.html) SELECT hooks are useful when you want to run arbitrary logic on data you got from database. I mean it's not something you need in every case but at some point you realize that you need to do some kind of transformation of data or calculate something and you want it to execute automatically without calling some method in each place you do such SELECT. Also look what kind of raw queries Sequelize provide: [http://docs.sequelizejs.com/manual/raw-queries.html](http://docs.sequelizejs.com/manual/raw-queries.html) You can write raw SQL and map results to model. I mean I understand that it's probably not the goal of your project, I just find Sequelize to be the 'king' of Node ORMs in terms of functionality, that's why I use it for comparison.
Thank you! It seems good enough.
You might even be able to just do ``` npm install package@1.2.0 tsc -p ./tsconfig.json npm install package@1.3.0 tsc -p ./tsconfig.json ```
I think the \`suppressExcessPropertyErrors\` tsconfig option would catch this, as well.
I advise you to not change your existing file to .ts / .tsx The typescript compiler is a lot stricter in typescript files than in .js /.jsx files, so you may give a lot of warnings you may not want right now. Some may say it's better have those warnings but with a large codebase as you said you have it gonna take days to get rid of them. So. Use the allowJs option of the typescript compiler. And you can write your new components in .TS/.tsx and still have all your code typecheck without much headache.
I was thinking about adding support for property transformers, that's a use case I understand. Btw mapping results to entities is also supported in MikroORM, you just need to `merge` those results to EM (but that would work only for one entity type currently, you would need to handle the separation manually when selecting multiple different entities). I will probably allow doing this in one step too so QB is easier to use. Something like this should work (in the end that is what happens behind the scenes when you use entity manager API): const qb = orm.em.createQueryBuilder(BookTag, 't'); qb.select('t.*') .leftJoin('t.books', 'b') .where('b.title = ? OR b.title = ?', ['test 123', 'lol 321']); const res = await qb.execute(); const entities = res.map(data =&gt; orm.em.merge(BookTag, data));
Because it's the only php application I have left. Every other bit of the site, whether that be a program to talk to custom devices, the front end, and handling real time messaging are written in something not PHP. I'm just tired of switching contexts for just one language in the stack.
OK, thanks for your responses. I can't try you use it right now but I will definitely follow further development of this project.
I'm not as familiar with Go, but my understanding is that indeed goroutines are a way to describe concurrency--so they are a solution to the same problem.
I don't really see how these are essential.
I assume it's an a attempt to support the following... async function foo&lt;T&gt;(func: () =&gt; SyncOrAsync&lt;T&gt;) { await func() // ok - as await T is fine. } // supports both sync/async signatures. foo(async () =&gt; 1) // ok foo(() =&gt; 1) // ok I'm just not sure why we need this in a library called 'ts-essentials', the signature is a one liner. 200+ GH stars tho. I wonder whose staring these things &gt;\_&gt;
TS doesn't provide any bundling tech on its own. The most you will get AMD / SystemJS concat or using &lt;reference path='...' /&gt; directives which isn't module based. &amp;#x200B; You can give this a try if you just want to bundle with the 'absolute minimum' amount of effort. [https://github.com/sinclairzx81/typescript-bundle](https://github.com/sinclairzx81/typescript-bundle). &amp;#x200B; Alternatively, rollup, fusebox are very good alternatives to webpack and provide the kitchen sink.
SyncOrAsync is just one of many available types that I often find useful. Other types like DeepReadonly are way more complicated. If you work on multiple projects including a library is much easier then copying stuff over.
For those interested is leveraging WebRTC for more than just video conferencing.
I can't recommend these articles enough. They explain some of node's concepts really well. As an example I had to introduce my team to node streams and this was my go to article to get them through the basics. I really hope this series of articles keep on expanding
I prefer the void operator for that. It evaluates the expression and returns undefined, so `void myFloatingPromise()` is totally fine since it's not dangling.
My or may not be relevant, but I too have an API response with tons of optional metadata, depending on more than just a single variable (e.g. `type`). I haven't fully typed it yet but I was working on an approach that looked like interface IBasicItem { id: string; type: string; saleData?: object; } type WithShoe&lt;T extends IBasicItem&gt; = T &amp; { type: 'shoe'; size: string; }; type WithSaleData&lt;T extends IBasicItem&gt; = T &amp; { saleData: { discountedPrice: number; saleEnds: Date; }; function isShoe&lt;T extends IBasicItem&gt;(item: T): item is WithShoe&lt;T&gt; { return item.type == 'shoe'; } function isOnSale&lt;T extends IBasicItem&gt;(item: T): item is WithSaleData&lt;T&gt; { return !!item.saleData; } // Usage declare const item: IBasicItem; if(isShoe(item) &amp;&amp; isOnSale(item)) { console.log("This ${item.size} size shoe is on sale for ${item.saleData.discountedPrice}!!!"); }
Agreed! OP is a clearly a good Node engineer, and he knows a thing or two about Typescript, too. I used the Readable stream tutorial to good effect recently. Goodjob, [u/\_gnx](https://www.reddit.com/user/_gnx)!
&gt; Another problem is getting into the angular injector, unfortunately we do not have this option in the decorator as in the normal component by the constructor. You can wrote a component that can only be applied to a class having a public injector field. The drawback is that you need to have the injected in a public field... But that is likely a lot better than having a static field like that. Tho Angular is full of code smell and lack of TypeScript support, so it's probably okay anyway.
That would be different than the `P` function, which returns the input value instead of `undefined`. In some situations you want to store the promise in a variable without awaiting its result.
There's practically no TypeScript in these articles though. They may be good Node articles but they don't really belong in this subreddit.
These articles have zero TypeScript specifics.
The examples are written in Typescript. What exactly do you expect should be specified to be a proper Typescript article?
There is zero Typescript in this article. Probably because Node itself doesn‚Äôt support TypeScript with its own definitions. Sure you can add and very much use TS in the Node environment but the NodeJS team has not integrated it with the Node core and doesn‚Äôt provide definitions for the native Node methods, etc. Using TS with Node to write a Node-only app (like with Child processes and clustering) would only require adding the TS npm module and then decorating the code accordingly ... but that was never done in this article.
If you'd like to see the value of Cat on the command line using just `tsc` assign something wrong to a variable of Cat ``` var test: Cat = 4; //Typescript will tell you 4 is not a Lion ```
It might be written in TypeScript of course, but all the types are simply inferred there so it looks completely as pure JavaScript code. I didn't see there any custom functions/types/interfaces/classes/use of generics/etc. This is why there is no TypeScript specifics at all.
Hm. Agree to disagree, I guess, since I prefer to let TS infer as much types as possible‚Äì I think it's visually less noisy and more productive (though, *I do* prefer explicitly typed function params). I rarely have to make custom types or interfaces when I am using Node's core library, though. Moreover, classes are stupid. Factory functions / closures / Crawford-style \`{}\` + plain old functions + ES6 modules are truly zen. I use Typescript for types, not to turn my Node into C#.
[https://github.com/krzkaczor/ts-essentials/blob/master/lib/types.ts#L79](https://github.com/krzkaczor/ts-essentials/blob/master/lib/types.ts#L79) export type AsyncOrSync&lt;T&gt; = Promise&lt;T&gt; | T; Should maybe be export type AsyncOrSync&lt;T&gt; = PromiseLike&lt;T&gt; | T;
&gt; If like me you also believe everything should be immutable, you‚Äôll be happy to see what Typescript 3.4 brings with it. It's read-only, not immutable. **Huge** difference.
Looking at the actual announcement, what they added was improved syntax: [https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#improvements-for-readonlyarray-and-readonly-tuples](https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#improvements-for-readonlyarray-and-readonly-tuples) &amp;#x200B; `function foo(arr: readonly string[]) { arr.slice(); // okay arr.push("hello!"); // error! }`
true. though what it does achieves immutability.
Totally right! I'll amend the post!
How about: result = (Array.reduce as any)(cb, {})
Wouldn't the mapped type prevent the keys from being known to the consuming context?
No, it does not. If the array is assigned as an regular array somewhere, then it can still be mutated. If you use `Array.isArray` you can mutate it as well.
Yeah. I personally found the other syntax more readable, but unfortunately the compiler now always shows the new one...
that should probably be pointed out in the article yes
The article should just use the correct terms. And if he considers necessary write about the difference of read-only and immutability.
My main complaint with TS ReadonlyArrays is that they cut off all the mutating methods without replacing them. I totally understand why; that would be outside the scope of the language and better handled by one of the many immutable JS libraries. But it makes the readonly arrays pretty useless.
`ReadonlyArray&lt;T&gt;` was added in TypeScript 2.0 (in 2016).
What methods did you lose that you want replaced?
It would be nice if it modified the type signature of array prototype methods too. E.g. if I invoke a filter/concat/slice function, I would expect it too to return a `ReadonlyArray`. It should be behaving as if the underlying structure is immutable
It is a very good article, but it was only posted here the other day.
I didn't know about that.
These methods return a fresh copy though, so it makes sense that you can do whatever you want with the copy, but cannot mutate the original array using a readonly reference.
This is indeed outside the scope of TS, but you can easily use any utility library (like lodash) or even define the missing methods and their type declarations on the Array prototype (I wouldn't do it, but it's possible). TypeScript makes both options type-safe, so I wouldn't say this is a problem. And, personally, I often find map/filter/reduce/slice enough for most purposes.
No worries. 11 days ago [https://www.reddit.com/r/typescript/comments/bf1qxd/interfaces\_in\_typescript\_what\_are\_they\_and\_how\_do/](https://www.reddit.com/r/typescript/comments/bf1qxd/interfaces_in_typescript_what_are_they_and_how_do/)
Don't do this. Use NEST.JS framework instead --- https://nestjs.com/
Why the f@#k would I use nest.js for a CLI app? or an Electron app? Or anything else than a web app? This article is about TS env setup, not TS web frameworks.
Just make a copy with .slice() or similar.
no swearing on christian minecraft server
[Or use Deno](https://github.com/denoland/deno)
Feels sad that the mostl complete framework around used s2pid angular patterns...
[https://github.com/palmerhq/tsdx](https://github.com/palmerhq/tsdx)
Hey, I'm brand new at TypeScript (as of today) and decided to convert something I wrote in vanilla JS to TS. I made an attempt to decouple state and DOM manipulation, however I think the logic of the MVC needs to be improved - it's just M and V with some scattered C right now. Just wondering if I have the right idea with typing (I've never written in a strictly typed language before...) or if I'm doing something horribly wrong. Hopefully feedback/questions are allowed here.
Use eslint instead.
Hi, Just had a look through your code, it looks fine. I really like the interfacing around Display (which signals intent that there may be other display types (Canvas | WebGL) so that's cool. Your use of types is fine and reasonable (and perfectly readable), the only things that standout is small idiomatic stuff, but aside from that, its good. Well done. &amp;#x200B; Ill go over a couple of things if they are of any value to you. [https://github.com/taniarascia/tictactoe/blob/master/src/tictactoe.ts#L4-L14](https://github.com/taniarascia/tictactoe/blob/master/src/tictactoe.ts#L4-L14) Typescript is a structurally typed language, so both 'PlayerToken' and 'Score' are effectively the 'same type' and can be used interchangeably. However, I am curious what the 'other' properties might be on the different variants of this type, particularly if they are intended to be distinct representations for things.. This might be better written as... interface Token { x: string, o: string } type PlayerToken = Token &amp; { a: string, b: string, c: string } type Score = Token &amp; { count: string } Which provides a bit more information as to what the other properties are. I've done a draft of this [here](https://repl.it/repls/FragrantForestgreenLicense) to give you a sense of what's going on with that &amp; syntax, with perhaps some follow on reading on TypeScript's 'Union and Intersect types' and 'Discriminated Unions' which can be read about [here](https://www.typescriptlang.org/docs/handbook/advanced-types.html) and [here](https://basarat.gitbooks.io/typescript/docs/types/discriminated-unions.html) respectively. &amp;#x200B; [https://github.com/taniarascia/tictactoe/blob/master/src/tictactoe.ts#L207](https://github.com/taniarascia/tictactoe/blob/master/src/tictactoe.ts#L207) TypeScript supports automatic property assignment for constructor arguments. The following will create a private field 'display' on the class without needing to explicitly assign it in the constructor body (useful for DI as you have for the TicTacToe type). (Note: the readonly is optional but generally good practice). constructor(private readonly display: Display) { } [https://github.com/taniarascia/tictactoe/blob/master/src/tictactoe.ts#L114](https://github.com/taniarascia/tictactoe/blob/master/src/tictactoe.ts#L114) Its generally considered more idiomatic to assert a type with the 'as' keyword than using the &lt;HTMLElement&gt; form, mostly due to ambiguities with TSX (or JSX) syntax. Can be written as. const cell = boardRow.querySelector(`[data-col="${col}"]`) as HTMLElement Other than that, your code looks great for a first go round. Again, Well done.
You seem to have the right idea with typing. For the future though, I might recommend adding member accessibility modifiers (public/private/protected) to your class properties/methods for any real projects you do. &amp;#x200B; I would look into using a linter like ESLint though. It can provide helpful insights into the formatting and will let you set up your own best practices (or use one of the many recommended presets). &amp;#x200B; Normally TSLint would be recommended, but the TypeScript team themselves have essentially urged everyone to move over to ESLint. This ( [https://javascriptplayground.com/typescript-eslint/](https://javascriptplayground.com/typescript-eslint/) ) and other articles like it might be of some help.
Recommending TSLint over ESLint isn't best practice. See [here](https://eslint.org/blog/2019/01/future-typescript-eslint) for details. &amp;#x200B; Everything else here is standard TS usage.
"Best practices" and does not even mention the strict compilation flags. Even shows a configuration where the strict flags are omitted.
Yes, you're right, I'm thinking about it as though the array members would be effectively immutable, when in fact it's just the Array object itself that is being treated as such.
Really clean code, types all look correct. `isGameWon` takes unused params, you can enable a compile time check for this in your tsConfig [`noUnusedParameters`](https://www.typescriptlang.org/docs/handbook/compiler-options.html). Also there is a semantic difference between functions assigned to fields (`method = () =&gt; {}`) and methods (`method() {}`). Unless you need to pass them as callbacks you don't need the former. (Sorry if if you already knew this)
The whole ‚Äúyou only need TypeScript for large projects‚Äù thing needs to die already.
what's stupid about them (genuine question)?
&gt;Its generally considered more idiomatic to assert a type with the 'as' keyword than using the form, mostly due to ambiguities with TSX (or JSX) syntax. Can be written as. I wouldn't call it "more idiomatic". I would say it's something to be aware of based off your project's needs. Using TS at a C# shop, we preferred to do it the same way as OP due to similar syntax. But we don't do TSX. In the end, neither is right or better without context of the project.
See section 'as foo vs. &lt;foo&gt;' [here](https://basarat.gitbooks.io/typescript/docs/types/type-assertion.html) for reasoning. &amp;#x200B; Also, its also more idiomatic to use 'as' instead of explicit cast in C#, as demonstrated [here](https://repl.it/repls/StainedEqualProcess).
Nice work! Thanks for sharing your code. Here are a couple of suggestions: - As a general rule, there's no need to include type information in the documentation when you're using TypeScript. At best it duplicates information that's already in the type annotations and at worst it diverges from them. So [this comment](https://github.com/taniarascia/tictactoe/blob/eb8f8f8dcb7b29259359644b07b2eb522e476fb3/src/tictactoe.ts#L75-L80) could be deleted entirely. Don't say that a parameter is optional in the comments: mark it optional with the type system. - `DOMDisplay` doesn't need to be a class since it has no state. It could just be a value: `const domDisplay: Display = { ... };`. A benefit of this is that TypeScript will be able to infer the types of the parameters and returns on all the methods that come from `Display`, so you won't need to repeat them: `bindHandler(clickHandler) { ... }` instead of `bindHandler(clickHandler: (row: number, col: number) =&gt; void): void { ... }`. - I find `string[][]` more compact/readable than `Array&lt;Array&lt;string&gt;&gt;` but up to you. - You don't need to explicitly pass `undefined` as an optional parameter, e.g. [here](https://github.com/taniarascia/tictactoe/blob/eb8f8f8dcb7b29259359644b07b2eb522e476fb3/src/tictactoe.ts#L88).
Don't install TypeScript globally, do a local dev dependency install. This way you lock the version to your project. Add `"build": "tsc"` to your package.json scripts and build with `npm build`.
Oh, excellent feedback. Very actionable, thank you! Great point about the comments. It felt like a lot of work and duplication, to the point where refactoring the code would become a pain. TypeScript does make it much more self-documenting. Also great point about `DOMDisplay` not needing to be a class. I was basing it off a previous project I made where I used `blessed` for the display in the terminal instead of using the DOM, and it required a lot more state. I didn't even think about that. Then I wouldn't have to make that whole `Display` interface. I actually didn't know I could do `string[][]` instead of `&lt;Array&lt;Array&lt;string&gt;&gt;`, so good to know. When I was fixing all the errors it had a problem with me leaving the arg empty, but that was probably due to something else I was doing wrong at the time.
Yeah, that's a good point. I'm just so used to using React and need the lambda more often than not, so I've just gotten into the habit of always using it even when it's not necessary...
Yeah, I saw that ESLint was becoming the preferred linter for JS and TS. Thanks for the link, I always get frustrated setting up linters properly.
Thanks for the feedback! Really appreciate it. I'll be looking more into the `type Score = Token &amp; { count: string}` syntax, as I don't quite understand it yet. Regarding `&lt;HTMLElement&gt;` vs `as HTMLElement`, I just used the first thing I found when googling to make the error go away, I wasn't aware there was another way of doing it. I guess my problem with the Display interface is that it's tightly coupled to the DOM, so it wouldn't be useful for interchanging it with other UI. I think making it a one-off object instead of a `class` as suggested by another commenter below might be a better choice unless I intend to extend it further.
no answer, so i guess nothing?
Disagree about deleting the comment entirely. TSDoc is a thing, after all. https://github.com/Microsoft/tsdoc I do agree you don't need type information in there, though.
Thought that may have been the case.
You are describing a lot of stuff, but you don't really provide any examples of how the code looks in the current state. When you get 9 paramaters, it's often best to change it to the arguments to an object interface NineObjects { stringOne: string; stringTwo: string; optionalString?: string; numberOne: number; numberTwo: number; optionalNumber?: number; anObjectOne: {[K: string]: string}; anObjectTwo: {[K: string]: string}; anOptionalObject?: {[K: string]: string}; } const nineObjects = (arg?: NineObjects) =&gt; { // do something } const actualNineObjects: NineObjects = { stringOne: "one"; stringTwo: "two"; numberOne: 1; numberTwo: 2; anObjectOne: {hi: "you"}; anObjectTwo: {obj: "two"}; }; nineObject(actualNineObjects); An Interface is really good at describing an object
I usually do something like this: let me: Person = { firstName: 'Bob', lastName: 'Ross', username: 'PaintGuy' }; the compiler will complain if you omit a required property.
There are some very clean implementations of the builder pattern in TS, and even some npm packages which make it almost trivial &amp;#x200B; This answer shows how to make a builder pattern with everything you mentioned: [https://stackoverflow.com/a/53982272](https://stackoverflow.com/a/53982272)
So with your example, what if I needed the NineObjects class to keep its members private and only exposed via getters/setters, and this factory method? Also, how do I avoid having the concrete NineObjects class not reiterate all the variables over and over. Like import { v4 as uuid } from 'uuid'; export interface NineObjectsInterface { stringOne: string; stringTwo?: string; // Optional one numberOne: number; // Etc... } export class NineObjectsImpl implements NineObjectsInterface { private _stringOne: string; private _stringTwo: string; private _numberOne: number; // Etc... I've enumerated them all twice now.. constructor(){ // No-arg constructor needed for deserialization } static fromInterfaceArgs(args?: NineObjectsInterface) { let myNineObjects: NineObjectsImpl = new NineObjectsImpl(); myNineObjects._stringOne = args.stringOne; myNineObjects._stringTwo = args.stringTwo ? args.stringTwo : uuid(); // custom construction logic! myNineObjects._numberOne = args.numberOne; // Etc... three times I've enumerated them all } get stringOne(): string { // Additional logic in getter because I'm a bad boy if(!validateSecurityMode(process.env.SECURITY_MODE)){ throw Error("stringOne is only available in Open mode") } return this._stringOne; } get stringTwo(): string { return this._stringTwo; } get numberOne(): number { return this._numberOne; } // yeah, I'm gonna need 9 getters too... } function validateSecurityMode(SECURITY_MODE: string) { return false; } That all still seems pretty messed up and overly verbose, am I still fucking this up?
What does the constructor of Person look like in that case? Let's say if userName isn't passed I want to have some logic to generate it.
Instead of having a constructor which sets 9 elements, make a Builder (9 setters which return the object itself so you can chain them) This is a general pattern not related to TS itself. let c = new Chicken(); c.setEggs(2).setName(‚ÄòDave‚Äô).setColour(123); Another option is to use an interface
you could also deconstruct the object and use public and private fields, getters would have public readonly fieldName, seteers would have public fieldName and private variables would be inaccessible
Why do you need this class and the getters and setters? The point of those are to encapsulate and control access to your members if you need to. For those members that can be read directly and mutated externally without special logic, there is no need for getters and setters. However, you may want to consider refactoring into multiple different classes instead of having one mega class that has incredibly complicated internal logic based on the internal state. If only specific combinations of the some subset of the parameters constitute "valid" objects, create a different type of object for each, if there aren't too many possible combinations. With such an approach you can dispatch on a parameter which will let the compiler narrow the type and thus give you maximum type safety and make it impossible to cause your objects to throw exceptions because a method was called that is not applicable for a specific configuration of the internal state.
The problem with that approach is how do I enforce that all required fields in the object have been set before the object can be used?
&gt; Why do you need this class and the getters and setters? Basically this is an internal data object for the service, one of many like it. It's goal is not to be a source of truth (that's the DAO version that actually goes in the DB), but rather to make coding around the object easier. In that regard, it has several properties which are implicit (derived from other properties but presented as a first-order property), generated if not provided, or validated at set-time. The idea is, classes using this object shouldn't have to know which properties of the object are which, it should just *look* like a simple data object as much as possible and do its own housekeeping internally.
@danvk: Thank you for your suggestion. After create a tsconfig.json file for my tiny project, and set strictNullChecks to true, then, the problem is solved. &amp;#x200B; Could you please provide the internal logic about why this issue was happened when I did not set strictNullChecks before?
I use something like this at work so that required/optional is enforced by the compiler. I think it would work for a constructor? I don't see any reason why not. Basically, define a type that houses the set of arguments you want to wrap in an object: `export interface ISettings { prop1?: string; prop2: number }` then you set up your method like this to enforce the type requirement and allow inlining, or any other type of construction of the 'settings' object: `export function stuff(settings: ISettings = {} as ISettings) { //implementation here }` Hopefully this is enough to get you on the right track? I do not remember what this 'trick' is called, I just fell in love with it when I found it for some of our lib functions which were gaining more and more parameters as time went on.
I think you're looking for [parameter destructuring](https://mariusschulz.com/blog/typing-destructured-object-parameters-in-typescript). To use the example from above, imagine `me` is still set lie above: function addUser({ firstName = 'defaultFirst', lastName = 'defaultLast', username = 'defaultUser' }: { firstName?: string, lastName?: string, username?: string, } = {} ): boolean { // function impl } With this implementation you can access all three parameters by their name. They can be handed over. If you give `addUser` only `{ firstName: 'foo' }`, in the function implementation you will have `firstName` being `foo`, `lastName` being `defaultLast` and `username` being `defaultUser`
Hey, just had a look through the codebase, took a bit of an interest at the backend code. Saw you were using nestjs back there. Just wanted to get your thoughts on the nestjs framework, how do you find working with it?
Hey, thank you for the comment ;) I really like it. I have tried ExpressJS before and NestJS seems a much better option if you like TypeScript. NestJS has popular modern tools integrated into like TypeORM for DataBases, PassportJS for authorization, Mongoose for Mongo DataBase, etc. Also, NestJS has a convenient architecture with modules (Like in Angular 2+). Each module consists of Controller/Gateway and Service. So it's easy to separate your logic to make it more maintainable. There are many other useful things there like Pipes, Guards, Interceptors which you can use simply with Decorators. It allows implementing aspect-oriented programming paradigm. And It really makes code readable! I am not sure, but for NodeJS with TypeScript, NestJS seems the best option at the moment.
Hi Thanks, yeah, I stumbled across NestJS late last year after already having tried to build something similar. I'm generally of the opinion that plain raw Express | Middleware doesn't really scale up (application wise or structurally) so i was pretty keen to see nestjs emerge to tackle some of those more higher level architectural concerns with node software. &amp;#x200B; Had been musing around either nestjs or loopback but think ill settle on nestjs. It reminds me very much of [ASP.NET](https://ASP.NET) MVC, particularly with the leveraging of 'decorators' (which would be attributes in .NET). It looks like its handling all the standard verb stuff, and have quite a bit of interest in its Web Socket architecture. It really does look great. &amp;#x200B; Ill use your project as a bit of an guide and reference implementation, looks really clean. &amp;#x200B; Thanks
Builder pattern is the way to go
Thank you. Could you provide a link where you going to use it? Or tell few words about your project?
If you really need this complex of an object, use an `abstract factory` or a `builder` pattern. However, it seems as if you have some factoring issues: the class is probably doing or representing too much at once. Can the class' dependencies be broken up and, through composition, grouped into more coherent concepts.
Ah, id be looking primarily at leverage vanilla nestjs for some bread and butter work. Nothing particularly interesting to share (mostly business web programming using standard HTTP stuff and perhaps some socket stuff). In terms of nestjs projects, I haven't written anything yet :D The last node project I was on basically had me building something similar nestjs from the ground up (all under private repo tho) &amp;#x200B; In the OSS space, i usually write and share things like [this](https://github.com/sinclairzx81/smoke) or [this](https://github.com/sinclairzx81/typescript-bundle) or [this](https://github.com/sinclairzx81/zero). But these are fairly tangential :D Maybe of some interest.
Thank you for the links and good luck with NestJS. Hope you will like to work with it ;)
A dependency developped in TypeScript can have all the .ts files, or only the compiled .js with the definitions. It's totally up to the person publishing the library.
Great post! Do you or anyone know if a feature for typescript to \_not\_ have a field as discriminator is on the roadmap (Similar to how Elm does it)?
What do you mean by that? There must be something to identify the different cases. That's either nicely done a discriminator, or the poor-mans approach using classes and `instanceof`.
This project is geared towards finding parity between JSON schema and TypeScripts type system. It is similar to io-ts, but uses JSON schema as its internal type representation. Static resolution of the types is handled via TypeScript 'Mapped Types' capabilities detailed [here](https://www.typescriptlang.org/docs/handbook/advanced-types.html). &amp;#x200B; Useful for runtime type validation when paired with JSON validation libraries such as Ajv.
Just a pity that a lot of JSON Schema can't be represented in TypeScripts type-system. And JSON Schema has plenty of pitfalls as well. It's not a very good format.
I've found it does ok. I've listed the mappings in the projects readme. It extends as far as data-transfer like objects (so no function signatures), you can replicate Union | Intersect and various other constructs, and generally it feels more flexible than what would be possible with say XSD. &amp;#x200B; But you're right, in lieu of something better. With some luck the IETF might actually ratify it one day :D
&gt; you can replicate Union | Intersect and various other constructs JSON Schema supports `oneOf`, which can't be represented by TypeScript. You can only represent `anyOf`.
This is true, however Union | Intersect are supported via \`anyOf\` and \`allOf\` respectively. &amp;#x200B; This project is really just an exercise in finding the parity between JSON schema and TypeScript. Given that TypeScript won't (at least they claim they won't) support any emitting of non JS content from their compiler (which includes 'interface' | 'type alias' emitted as JSON schema), I did just want to see if there was a case to be had with respect to how well TS types could theoretically be mapped. It turns out that JSON schema is very accommodating of what TypeScript does, but also includes things it doesn't do. Maybe TS gets some 'oneOf' operator or maybe JSON schema narrows its feature set, i don't know :) &amp;#x200B; For reference purposes of course :)
Thanks! I was actually going to mention value types and pattern matching in this article, but saved it for later. As far as I know, there's an active proposal to add pattern matching to Javascript. I hope it leads to adding value types and pattern matching to Typescript. Typescript feels clunky in this regard after using Elm and Elixir.
that's unfortunate thanks though
It's still a stage one proposal with some debates ongoing about syntax IIRC, we won't be seeing it for a while.
I guess as an example, the name of the type itself could be a candidate for discriminator, instead of having using a specific string as a type discriminator. &amp;#x200B; I know it is not supported in the typescript language now, and I am sure there are multiple reasons for it not being easy to add (In particular the type of something is defined by how it looks, i.e. no runtime information regarding \_what\_ it is) &amp;#x200B; But it would make it quite awesome with less duplication / indirection. &amp;#x200B; As an example, see the type safe implementation of: [https://medium.com/@martin\_hotell/improved-redux-type-safety-with-typescript-2-8-2c11a8062575](https://medium.com/@martin_hotell/improved-redux-type-safety-with-typescript-2-8-2c11a8062575) &amp;#x200B; Although you here export the action type descriminators, it would have been awesome if that could be extracted without it.
Shame. Both features are implemented in number of languages that belong to different language families. I'm sure that syntax from e.g. Rust could be adapted. Maybe TypeScript devs can lead the way?
&gt; the name of the type itself could be a candidate for discriminator, The name of the type is not present at runtime, so it can't be used for that purpose. The TypeScript team won't add it, as that goes beyond the goals of TypeScript. And then name of the type is not unique, the same name could be used in different modules.
It's a very verbose way of defining actions. I'd suggest trying something like this library [https://github.com/pelotom/unionize](https://github.com/pelotom/unionize).
&gt; [ ] This could be implemented without emitting different JS based on the types of the expressions (not sure about that) The team has stated multiple times that this is a **hard requirement**.
&gt; Also, its also more idiomatic to use 'as' instead of explicit cast in C#, as demonstrated here. Reasoning here. Uhh... Absolutely **no**. Each way serves a different purpose and expresses a different intent. One is not more idiomatic than the other.
I am not sure what that checkbox means. This is why I said I am not sure. Do you know what it means? Maybe I can check the checkbox if it satisfies it. It actually emits different JS but it's not because of the types of expressions.
I love Rust, but a lot of the discussion going on in every proposal is about backwards compatibility, often to an extreme degree - for better or for worse. Rust tries to maintain backwards compatibility but it can make breaking changes occasionally when necessary, and has a much better foundation.
It means: if type == A, then write "A", else write "B". Compiling to different JavaScript code depending on the type.
No one was comparing the C# 'as' operator to a type assertion in TS. Read previous comment.
That means I can check the checkbox. Thanks.
This helped me so much, thank you! FWIW, I googled and the better way to do ` type Props = OwnProps &amp; StateProps &amp; DispatchProps ` is ` interface Props extends OwnProps, StateProps, DispatchProps {}` since type is eventually going to be deprecated. Additionally, since my reducers are split, I have another interface `ICombinedProps` as well.
Thanks!
Thanks!
Makes sense, you kind of provided the answer i was querying. Have you seen elm though? They solve this very nicely. And it transpiles to js, so that was why i hoped for it..
I mean, it's just a data object at the heart of it. It's one database row. Shit, not even one whole DB row, it contains some child objects that are already defined elsewhere. The problem is, your core data object always becomes this sort of glue that holds your service together. It gets referenced *everywhere*. So it's worth having a single-purpose object to just be that intermediary object, and obfuscate all its internals behind private methods and variables, so that if you ever have to change how it works you can do that inside the object instead of fucking your entire codebase.
Elm has different goals than TypeScript.
I agree! This is a common denominator between Elm, Rust, Elixir and many other newish languages. It's easier to make bold, breaking changes when you are not a superset of a faulty language design. Even though I may appear negative, I'm thankful that TypeScript exists. It still allows pretty nice logic.
Yeah that's pretty much where I am with it. It's made a painful language relatively enjoyable, but I'm still routinely brushing up against rough edges that will never go away within JavaScript itself. Ah, I love Rust. No doubt I'd like Elm too. I was hoping WASM would allow the takeover of the frontend space but given the latency involved it seems my hopes were misguided.
The environment is basically a bunch of variables the operating system remembers. Linux, OSX and windows all have these. &amp;#x200B; To view them in Windows 10 do the following: Click start type this pc right click on this pc -&gt; properties click on Advanced system settings in the left hand plane click Environment Variables... on the bottom right of that screen At the top of this screen is variables assigned only to your user and below that they are system wide. &amp;#x200B; When you type a command in a terminal the terminal process doesn't know where that command is. So it searches the directories in the PATH variable. If it finds a match it executes it. Your terminal can't find a executable named tsc if your PATH. &amp;#x200B; tsc is located somewhere on your computer. Find it and add that directory to PATH. This should of been done for you when you installed node. I think npm installs to: C:\\Users\\YOUR\_USER\_NAME\\AppData\\Roaming\\npm &amp;#x200B; you can test if something is in your path on windows with: where ipconfig C:\\Windows\\System32\\ipconfig.exe
Hey, syntax\_erorr, just a quick heads-up: **should of** is actually spelled **should have**. You can remember it by **should have sounds like should of, but it just isn't right**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Hey /u/BooBCMB, just a quick heads up: No one likes it when you are spamming multiple layers deep. So here I am, doing the hypocritical thing, and replying to your comments as well. I realy like the idea of holding reddit hostage though, and I am quite drunk right now. Have a drunk day!
Hey, BooBCMBSucks, just a quick heads-up: **realy** is actually spelled **really**. You can remember it by **two ls**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Well, that looks promising! Thanks for sharing!
Thanks for this, it's an excellent resource!
Nice
Referencing database objects outside of your infrastructure / data access layer is tricky for the reasons you name. It is OK to create a table gateway or row mapper, but take care not to leak it into the rest of your application. Data access should not be the glue of your application, it should be an implementation detail separated by an abstraction. Application services typically fulfill the need of "glue" or orchestration. My advice would be to look at separating your domain (core abstractions) from your storage implementation.
\`private\` fields have to be declared within the curly braces of \`class Foo { }\` which is annoying. But if you move all the data fields onto a single internal \`data\` object then you can compose the type of that object from other interfaces. And you can reuse the same interfaces to describe your constructor arguments. You can use \`Required\`, \`Partial\`, \`Readonly\` and other modifiers to change which properties are optional, readonly, etc based on context. // Tell the type system our class has all these public fields. We'll dynamically generate the getters and setters below interface DataObject extends Required&lt;PublicFields&gt; {} class DataObject { private data: Required&lt;PrivateFields &amp; PublicFields&gt;; // or whatever you want to do static fromInterfaceArgs(args?: PrivateFields &amp; PublicFields) { Object.assign(this.data, args); // apply defaults and other init logic here ... } get field1() {} // override a single getter ; all other getters will be generated automatically below } dynamicallyGenerateGettersAndSetters(DataObject, listOfFieldNames); // &lt;-- utility function defined elsewhere; uses Object.defineProperty() to define default getters (&amp; setters) that delegate to `this.data[fieldname]` Then you can use a loop to generate default getters and setters on the class that each delegate to the corresponding field on \`data\`. And if you want to override an individual getter or setter, you can put it in the body of your class. \`listOfFieldNames\` is annoying; you'll need a runtime array of strings. You can declare it as an array, using \`keyof\` and tab completion to save some effort, or use @Decorator magic to generate the list. I know maybe this isn't the kind of answer you were hoping for. But I think it'll work.
Thanks. Just what I was looking for this morning!
Now lemme see type safe stream crossing. Checkmate Ghostbusters
I'm not directly referencing the database object. This intermediate object is converted into the database object which is only ever used by my repository class wrapper around dynamodb. Always separate external model, internal model, and database model.
This really is well put together. Thanks for the share
It's a little clunky compared to Elm, but still really cool!
I am failing to see what your issue is. In the Typescript playground, this exact code behaves how you want it to. interface Test&lt;T&gt; { foo: T; bar: T; } const a: Test&lt;string&gt;[] = [] a.push({ foo: '', bar: '' }) // WORKS a.push({ foo: false, bar: 1 }) // ERRORS
I'd like it to work on a.push({ foo: false, bar: true })
When inferring generics the compiler will use the most strict type in the type hierarchy that is satisfied by the given value(s). The reason your first example fails is that the inferred generic parameter is `any` instead of `number` (what you expected). This will apply for any combination of types -- all will be allowed. The reason your second example fails is that the inner object generic parameters are inferred (`string`, `any`) before the function's generic parameter is considered. Because objects with generic parameters cannot be assigned to similar types with supertype generic parameters (`SameTypeContainer&lt;string&gt;` cannot be assigned to `SameTypeContainer&lt;any&gt;`), there is no longer any type for `T` (of `test&lt;T&gt;`) that satisfies its arguments. It looks like the functionality you're looking for isn't quite as well defined as you're probably hoping. For example, you could say that `'string'` and `'also string'` are not the same type in their most explicit sense since `'string'` is not of type `'also string'` (i.e. type bounds can include specific values). Depending on your use case, you might be able to get closer to what you want by defining upper bounds explicitly to avoid `any`. E.g.: `SameTypeContainer&lt;T extends string | number | boolean | object&gt;`. But `object`s will still give you issues with this as all sub-types have a shared type of `object`. Honestly, I would leave it the way you have it and just declare the required type where needed (`public mySomeClassContainer: SameTypeContainer&lt;SomeClass&gt;;`). This is a typical way to use generics -- include explicit types in declarations where needed, and infer types on creation.
`create-react-app` is used for bootstrapping a web application. It doesn't really facilitate making importable libraries. If you're using typescript, you should be able to point your components to a different `index.ts` that you could then build with `tsc`.
I am aware of this, but I haven't been able to find any GitHub repos for first-class TypeScript React Components.
Something like this: ```ts // package.json { "main": "es/index.js", "typings": "es/index.d.ts", "scripts": { "build": "tsc -p ./tsconfig.json" } } // tsconfig.json { "compilerOptions": { "target": "es6", "module": "commonjs", "jsx": "react", "declaration": true, "outDir": "./es", "rootDir": "./src" } } ```
TypeScript support only really requires that you export the type declarations. You'd include `"declaration": true` in your `tsconfig.json`
Okay I understand a bit better what you are saying, I am not aware of an easy way to handle this. You might want to reconsider how you're managing your data if you're trying to do this.
Thanks for the help in understanding, why do react component libraries normally bring in so many dependencies? &amp;#x200B; "devDependencies": { "babel-cli": "^6.26.0", "babel-core": "^6.26.0", "babel-eslint": "^10.0.1", "babel-jest": "^23.0.0-alpha.0", "babel-loader": "^7.1.4", "babel-plugin-transform-class-properties": "^6.24.1", "babel-preset-env": "^1.6.1", "babel-preset-react": "^6.24.1", ... "react-hot-loader": "^3.0.0", "serve-static": "^1.11.1", "webpack": "^4.24.0", "webpack-cli": "^3.1.2", "webpack-dev-middleware": "^3.4.0" }, Why are they using Babel so much?
Dependency injection frameworks are a virus, spreading across your entire codebase, all to re-implement es-modules-like functionality in the off-chance you *might* need to mock something in the future. This is the kind of stuff that makes people think "TypeScript makes JavaScript more like Java". No thank you. Write code like a normal JavaScript developer (no blanket OOP required) and use [ts-mock-imports](https://www.npmjs.com/package/ts-mock-imports) for those rare times you need to mock a dependency that can't be passed as a simple function parameter.
Babel does js to js compilation. It also now sort of supports ts to js compilation, but doesn't output type definitions (it's faster than `tsc` and has more tooling surrounding it too, making it pretty good for web app development). I'm not sure about a lot of those extra babel dependencies though. I think babel-jest is for allowing you to write your jest tests in whatever and doing the compilation and `run test` in one step. I think the transform class properties is for things like `static defaultProps` in react class components. Babel does a lot of stuff. I don't really expect anyone to know anything about it lol. I just google error messages as it emits them and hack around it. :shrug: Using `tsc` in the way that I describe doesn't give you a single executable like what I think webpack is supposed to do. I think webpack also allows you to import non-code files like css/json/whatever as js. I'm not too familiar with webpack, though. I've always used `parcel`, which is a much friendlier tool imo.
Use this and you‚Äôre done! https://github.com/palmerhq/tsdx
This is my favorite feature is typescript. It's also my favorite feature of F#. I'm still waiting for the F# style exhaustive pattern matching to make it's way down to typescript. Then we went have to stick an arbitrary 'type' property on all of our Union types.
It might help to know that the wasm latency is an implementation detail, iirc. Mozilla has a great post on [making wasm and js interop fast](https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/). Plus wasm's roadmap has DOM manipulation (and more) so eventually, I see it being possible to do essentially everything in pure wasm. I wouldn't be surprised if TS -&gt; wasm became more popular than TS -&gt; JS at that point, actually. But there's definitely a lot of things that need to happen first before that's even a thing
And it forces you to use classes, leading to the dark OOP side instead of living in functional bliss.
You sound like a person who doesn't like to follow good practices.
There's no functional bliss in JS, but you can adopt declarative code style. And it doesn't need to be functional.
ES modules are singleton, and you should avoid singletons. Ideally, you want the ability to be able to import classes and create instances of them, es-modules are singular and cached, exporting functions (or an interface) on modules doesn't allow you to trivially swap those functions for something else. &amp;#x200B; Anyway, If you understand OOP best practice, it naturally leads to dependency injection. And if you understand dependency injection, it naturally leads onto Inversion of Control (IOC)...It's maybe an advanced topic if you're not familiar with the patterns and how and where they should be applied, but you really need to spend time trying to understand it if you want to be able to critique it. (It's not without its issues) &amp;#x200B; Anyway, use FP for your micro line by line code, use OOP for your macro and high level software construction. Learn to use them both where appropriate and you profit.
Excellent article!!! What is your opinion on Awilix as DI? [https://github.com/jeffijoe/awilix](https://github.com/jeffijoe/awilix) I have been using it for now and has been great. Also have you yet tried typed-inject with production project yet?
IMO React uses both FP and OO concepts in tight union. Is that like an angel marrying a demon for you?
From name alone I would assume this person follows rational JS practices.
I'd take RxJS.
We actually use RxJS in parts of the system. We needed to encapsulate what a stream consists of, for this part RxJS didn't give any handles to improve type-safety. If you do know of anything that could supply similar guarantees I'd love to hear it.
With a functional style, you don't need to swap the functions, you swap the arguments out. For example, a "fetchFromDB" function would just take a DB connection in it's first argument, allowing you to swap dev and production trivially. More advanced functional languages have implicit parameter passing (typeclasses, traits, etc) that allow this to be very ergonomic and clean. That being said, on the high fuzzy level, one might point out that there's not a whole lot of difference between the compiler/RTS "passing in a method dictionary" vs "passing in this" as the first argument. And, for simple cases, there's not, but the dictionary method allows you to split up effects to a very high granularity without sacrificing ergonomics. In my admittedly biased opinion, I find writing a function that takes a list of capabilities is much nicer than a class that can do everything. How would you express "can read from DB, write to error log, and fire off a Ready event"? With classes, there's only one class you can write methods off of, so you end up passing in all of the classes yourself, in which case you're just doing the dictionary passing manually, or you do a bunch of side effects, which complicate debugging, mocking, and all of the other benefits you get from a DI approach (is there a better way with classes that I'm missing?) In addition, you're less likely to run into pitfalls with hierarchies, subtyping, and class resolution (if the dictionary method is one that guarantees deterministic resolution as is the case of Haskell and Rust). The most important thing about that, to me, is you can write code in a very generic way that's open to extension while guaranteeing that your particular function's behavior will never change even if someone else writes a different class later. (I get the feeling these aren't major issues for most OOP codebases, though? Don't want to construct a strawman here; just mentioning that there are functional solutions for things.)
Now this is sexy! Congrats
Thanks! Glad you liked it
How did you arrive at this conclusion?
Dependency inversion is not specific to oop, in fp they have the reader monad. Mocking is not the only reason people use dependency injection. Another might be that they prefer to code against interfaces because doing so helps discover the problem domain an generally results in more reusable and single responsibility components.
Yes, this is the question I have for you!
Pretty awesome - kinda doesn't completely follow the invaders movement rules (also you can fire a crap ton of bullets). For a typescript demo like thingy, it is pretty cool.
Build dockerfile, push docker image, pull docker image, start container. But most importantly: no manual steps. All automatic.
Sure, but you can do all these things without a dependency injection **framework**. Notice I wrote frameworks, not dependency inversion or DI itself.
I could answer that if you provided any specifics whatsoever.
https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md
message.ts (shared between provider and consumer) ``` interface Messages { "numberData": { numberProp: number; }; "stringData": { stringProp: string; }; } type Value&lt;T&gt; = T[keyof T]; type MapMessages&lt;M extends keyof Messages&gt; = { [T in M]: { type: T; payload: Messages[T]; } }; export type Message = Value&lt;MapMessages&lt;keyof Messages&gt;&gt;; ``` provider.ts ``` import {Message} from "./message"; export function sendMessage(message: Message): void { // TODO sending "message" to websocket } sendMessage({type: "numberData", payload: {numberProp: 123}}); ``` consumer.ts ``` import {EMPTY, fromEvent} from "rxjs"; import {mergeMap} from "rxjs/operators"; import {Message} from "./message"; // TODO better see https://rxjs.dev/api/webSocket/webSocket const socket = new WebSocket("wss://server.com/"); const socket$ = fromEvent&lt;Message&gt;(socket, "message"); const numberData$ = socket$.pipe( // you can also use custom type guard + "filter" operator mergeMap((message) =&gt; message.type === "numberData" ? [message] : EMPTY), ); numberData$ .subscribe((message) =&gt; { console.log(message.payload.numberProp); // console.log(message.payload.stringData); // throws error as this is "numberData" stream }); ```
Corporate firewall is throwing huge fits over this site. &amp;#x200B; Additionally, your https implementation is weird or broken. SHA-1 cert makes google complain, pages keep asking for authentication but accept blanks as credentials, etc. &amp;#x200B; If you don't fix these things (test in chrome), you'll scare many would-be users away
hmm, that's weird. It's just a static website hosted on netlify and uses a Let's Encrypt certificate. I'll look into it, thanks
Nice... been peeking at your sprite factory code and it looks good!
Looks like a wrong \`typeof\` use [https://github.com/ayakashi-io/ayakashi/blob/021119b6c19bf2dd3b91b51bccd5adfed2e39b39/src/coreScripts/printToConsole.ts#L42](https://github.com/ayakashi-io/ayakashi/blob/021119b6c19bf2dd3b91b51bccd5adfed2e39b39/src/coreScripts/printToConsole.ts#L42)
Yep. Good catch!
Do you have all this in a GitHub repo we can look at instead? It's very hard to get a good overview from your post.
I know I'm a bit late to the party, but you can host the types project as a got repo, and then I stall that repo as a npm package without needing to publish it. This way you can use private repos as modules. You can reference a specific commit if you want to version lock it too. If you have npm, you should be able to just do \`git install &lt;git-url&gt;\`
First thing I do with any language. Nice one.
The basic DI / OOP approach is as follows. &amp;#x200B; interface Repository { ... } interface Logging { ... } interface Producer { ... } export class Server { constructor(private readonly repository: Repository, private readonly producer: Producer, private readonly logging: Logging) {} } Here you you're simply describing some 'abstract' domains (usually things that reach outside of the software), in this case, a repository (could be a database, could be a file on disk), a producer (could be redis, could be amqp, could be sqs) and a logger (could be stdout, could be some logging service) &amp;#x200B; The notion here is that the Server doesn't really care what these things are, so long as they match the expected contract defined by each interface. Construction of the server is a game of picking the appropriate dependencies. class MongoRepository implement Repository { ... } class KafkaProducer implements Producer { ... } class DataDogLogging implements Logging { ... } ... const server = new Server( new MongoRepository(...), new KafkaProducer(....), new DataDogLogging(...) ) That's all. There is no hierarchies, no crazy sub classing, no and no guess work. There is polymorphism i suppose, but its not incomprehensible (you have type system afterall). All you've done is described a domain (with the interface), implemented it and passed implementations in on the constructor. (TypeScript even gives a friendly syntax for this). &amp;#x200B; Where IoC comes in useful is for moving this 'explicit' construction of the type (as above) out to some external 'thing' (usually configuration). Where the configuration document (yml, json, etc) references registered types (@injectables or some such) and auto wires objects for you. That's usually the down level win for adopting IoC containers. &amp;#x200B; I'd be curious to see the equivalent pure FP approach for this. Also note here that type classes and interfaces (at least in this example) can be used interchangeably. This is just good modern OOP practice i think.
It isn't possible to type concatenated strings dynamically. TypeScript doesn't exist at runtime, so it doesn't make sense to be able to get static analysis on some string that you're appending another string to. Looking at your `apiAction` action creator, I'm also feeling like I don't understand the purpose that your middleware serves. Would you mind elaborating on that part? Otherwise it seems to me like all your actions are just going to be converted to a string class with a `String.valueOf() === '[object Object]'`, `String.request === [object Object]:REQUEST` etc and not contain the original action.
I agree, this does not seem possible.
I'm inclined to agree with you on this. The more I mess around with it, the more unlikely I see this working. &amp;#x200B; For reference, the function is a small part of a middleware that handles api calls.
I kind of like the bombardment feature thank you lol
It's working fine for me now
Can someone explain to me how this is useful? I'm a little confused
You might like ts-remote-data; it‚Äôs the same inspiration, but we took a leaner approach to the implementation. (Full disclosure: Our company are the creators of ts-remote-data)
I'm on FreeBSD, so I heavily utilize zfs &amp; jails. 1. Initiate a build job that basically just produces a tarball of the application, which includes bundled code, node_modules, etc. 2. Snapshot the current deployment jail on my main data/file server &amp; then deploy the tarball into that jail. Perform any cleanup if necessary beforehand, or in some cases, just build a fresh jail. Take a snapshot of the jail after deployment. 3. Run the job to re-deploy the jail across my cluster of servers. This job basically does a zfs send/recv on each server to get the latest snapshot &amp; then just restarts the jail (or starts it if it wasn't running before and the deployment job specifies it). That's it. The jails are configured, as part of the job, to auto-register with my service-discovery cluster &amp; fetch the necessary secrets (e.g. TLS certificates/keys), generate configuration, &amp; start necessary services.
Ayakashi is a framework that helps you build scrappers (crawlers) to extract data from web pages or automate specific actions in a page. If you are familiar with this kind of thing it can be compared to a tool like scrapy. &amp;#x200B; The difference is that Ayakashi operates in a higher level, resulting in much less code. It comes bundled with many utilities to help manipulate a page, extract and save data. &amp;#x200B; A big focus of the project is building scrappers that are properly structured and easy to change later since what i found is that keeping up with page changes is more difficult than building the scrapper the first time. &amp;#x200B; Let me know if this clears things up. Happy to answer any more questions you might have!
Super massive bug; you're supposed to be able to take out one side and then the rest have to travel further before they can move down.
I've noticed that TypeScript newcomers used to take `tsconfig.json` file from random projects published on GitHub. So I'd suggest adding a note like: use `npx tsc --init` command to generate sane default `tsconfig.json` file". `strict` option is enabled for such default config of course.
Thanks, I didn't know about this!
Thanks for having a look! It is not really ready for a new repo, once I finalize the object creation I will make one and get things in order. This new code below should run anywhere with copy/paste. Quokka in vscode is great, check it out https://quokkajs.com/docs/index.html I have woken up first thing in the morning for days with this object creation problem on my mind! I just came up with another totally different solution. I think it is better this time, I tried to limit all the optional parts to the factory function and defined all my Interfaces as the actual object rather than the options. Perhaps you have an option on which you like best? To summarize, I just want to create Hero, Zombie or Bullet from the factory function with only the following options: ``` Character: gameLevel: GraphicsAssets: ``` The factory function will use the gameLevel number to work out any other factors, like should there be more zombies. I can modify the classes as needed to accept more options should they need new features. This is the cleanest solution my brain can produce for now LOL ``` /** * ============================================================================= * Types and Interfaces * ============================================================================= */ type Vector2 = [number, number]; type GraphicsAssets = | HTMLImageElement | { color: string; widthHeight: Vector2 }; interface Newable&lt;T&gt; { new (...args: any[]): T; } interface GameObject { position: Vector2; rotation: number; scale: Vector2; } interface Character extends GameObject { isAlive: boolean; velocity: Vector2; GraphicsAssets: GraphicsAssets; } interface GameFactoryOptions { Character: Newable&lt;Character&gt;; // https://stackoverflow.com/questions/41017287/cannot-use-new-with-expression-typescript gameLevel: number; GraphicsAssets: GraphicsAssets; } /** * ============================================================================= * Hero Class * ============================================================================= */ class Hero implements Character { public isAlive = true; public velocity: Vector2 = [0, 0]; public GraphicsAssets: GraphicsAssets = { color: 'red', widthHeight: [50, 25], }; public rotation = 0; public scale: Vector2 = [0, 0]; public constructor(public position: Vector2) {} } /** * ============================================================================= * Zombie Class * ============================================================================= */ class Zombie implements Character { public isAlive = true; public velocity: Vector2 = [0, 0]; public rotation = 0; public scale: Vector2 = [0, 0]; public constructor( public position: Vector2, public GraphicsAssets: GraphicsAssets, ) {} } /** * ============================================================================= * Bullet Class * ============================================================================= */ class Bullet implements Character { public isAlive = true; public velocity: Vector2 = [0, 0]; public GraphicsAssets: GraphicsAssets = { color: 'blue', widthHeight: [5, 25], }; public rotation = 0; public scale: Vector2 = [0, 0]; public constructor(public position: Vector2) {} } /** * ============================================================================= * Game Factory * ============================================================================= */ export function createCharacters({ ...options }: GameFactoryOptions): Character[] { let numberToCreate = 1; const characters: Character[] = []; let argument: any[]; /** * ========================================================================== * Functions that are used as callbacks to calcuate screen positions * ========================================================================== */ const middleOfScreen = (): Vector2 =&gt; [200, 200]; const randomSpawnPoint = (): Vector2 =&gt; { const pointToSpawnAround = middleOfScreen(); const variationInR = 400; const minimumR = 200; const theta = Math.random() * (2 * Math.PI); const r = Math.random() * variationInR + minimumR; return [ Math.cos(theta) * r + pointToSpawnAround[0], Math.sin(theta) * r + pointToSpawnAround[1], ]; }; /** * ========================================================================== * Create optional settings per character per level * ========================================================================== */ switch (options.Character) { case Hero: argument = [middleOfScreen()]; break; case Zombie: argument = [randomSpawnPoint(), options.GraphicsAssets]; if (options.gameLevel === 1) { numberToCreate = 100; } break; case Bullet: argument = [middleOfScreen()]; break; default: break; } for (let index = 0; index &lt; numberToCreate; index += 1) { characters.push(new options.Character(...argument)); } return characters; } /** * ========================================================================== * TESTS * ========================================================================== */ const hero = new Array( createCharacters({ Character: Hero, gameLevel: 1, GraphicsAssets: { color: 'red', widthHeight: [10, 10] }, }), ); const mockImage = new Image(); const zom = new Array( createCharacters({ Character: Zombie, gameLevel: 1, GraphicsAssets: mockImage, }), ); console.log(hero); console.log(zom); ```
These are generally good rules in any environment, be it Python, Go, C#, or Java.
This changed my life but introducing me to aliases. Pretty early in my TS and node journey but not new to programming. The relative imports drive me nuts.
glad you got something useful out of it :)
It would sound sort of silly for a backend developer used languages such as java or c# to be told why typing is important, but gazillions of programmers working with typescript don't quite fully believe in strict typing. One of the reasons is that coming from JS, like me, is a bit of a shock at first.
Great addition!
If you got IntelliJ Ultimate you can use the code analysis to report unused code. It comes with a 30 day trial so you could use for this and then go back to what you were using before.
This one, while mostly accurate, is unfortunately out of date. See this issue for discussion on the topic: https://github.com/Microsoft/TypeScript/issues/15711 Personally, I'm in agreement with the maintainers on the issue, but my use cases have not required me to delve too deeply into any kind of formal specification so I may be biased.
Perhaps this is a bit more verbose than you'd like, but you can achieve what you're looking for using something like this \`\`\` type SameTypeContainer &lt; T &gt; = { \[key in 'val1' | 'val2'\]: T } &amp;#x200B; function test (array: (SameTypeContainer&lt;string&gt; | SameTypeContainer&lt;boolean&gt; | SameTypeContainer&lt;number&gt;)\[\]) =&gt; { ... } &amp;#x200B; test(\[ { // this is fine val1: 'string', val2: 'also string' }, { // this is fine val1: true, val2: false }, { // this is fine val1: 1, val2: 2 }, /\* Type '{ val1: number; val2: boolean; }' is not assignable to type 'SameTypeContainer&lt;number&gt;'. Types of property 'val2' are incompatible. Type 'boolean' is not assignable to type 'number'.ts(2322) \*/ { val1: 5, val2: true }, /\* Type '{ val1: boolean; val2: number; }' is not assignable to type 'SameTypeContainer&lt;number&gt;'. Types of property 'val1' are incompatible. Type 'boolean' is not assignable to type 'number' \*/ { val1: true, val2: 10, } \]) &amp;#x200B; \`\`\`
What do you think of this? [https://www.reddit.com/r/typescript/comments/bk3b8t/help\_with\_should\_be\_simple\_generics/emi69rm/](https://www.reddit.com/r/typescript/comments/bk3b8t/help_with_should_be_simple_generics/emi69rm/)
Does your middleware conditionally call `Object.defineProperties`? If so you might be able to do something like this: ``` type ActionType = { request?: string success?: string failure?: string toString(): string } export function apiAction(actionType: string): ActionType { const str = new String(actionType) if (some_condition) { Object.defineProperties(str, { request: { value: `${actionType}:REQUEST` }, }) } if (some_condition2) { Object.defineProperties(str, { success: { value: `${actionType}:SUCCESS` }, }) } if (some_condition3) { Object.defineProperties(str, { failure: { value: `${actionType}:FAILURE` }, }) } return str } type Action = { type: ActionType } const reducer = (action: Action) =&gt; { switch (action.type) { case 'ACTION_NAME': { if (action.type.request) { return something } if (action.type.success) { return } if (action.type.failure) { return } } } } ... ```
This is an example of where tagged literals come in handy: ``` interface Point2D { type: 'Point2D' x: number y: number } interface Point3D { type: 'Point3D' x: number y: number z: number } const point2D: Point2D = { x: 0, y: 10, type: 'Point2D' } const point3D: Point3D = { x: 0, y: 10, z: 20, type: 'Point3D' } function iTakePoint2D(point: Point2D) { /* do something */ } iTakePoint2D(point2D) iTakePoint2D(point3D) // Typescript will complain here ``` Here is some further reading: - https://mariusschulz.com/blog/typescript-2-0-tagged-union-types - https://www.typescriptlang.org/docs/handbook/advanced-types.html
Great takeaways overall. Definitely worth the read if you're a couple of weeks in!
Another option is to have a type assertion on the export like so: ``` export default moduleName as Record&lt;string, FunctionThing&gt; ```
nice, i agree with most of what you have here. and honestly was not aware of the import alias feature, that's really cool. one thought: where you say 'prefer horizontal reading,' aren't you actually saying 'prefer vertical reading'? if you preferred horizontal reading, you'd keep lines at 120+
Oh I know seasoned devs who could use some of that advice
Ha yes! Lol. Thanks for pointing that out :)
No. Every action calls defineProperties. I‚Äôm trying to rewrite the middleware a little to remove that functionality while still being backward compatible
Coming from a Java world TypeORM is great, documentation is not great but it is out there. Typedocs are a thing and are similar to javadocs. It's out there on the interwebs. http://typeorm-doc.exceptionfound.com/
Looks useful! You should make a PR to the usehooks.io GitHub repo; I think it would be a good fit there
Thanks! I‚Äôll look into that
Have you tried [project references](https://www.typescriptlang.org/docs/handbook/project-references.html)?
Thanks! This was something I was unaware with I'm going to try it hopefully it works. Been battling with this dependency stuff.
Hi, Mono repos can be quite awkward in TypeScript. Below is a project I wrote this for personal use but you're welcome to try it. It may be of some use, possibly even as a reference to base your own setup on. &amp;#x200B; [https://www.npmjs.com/package/smoke-pack](https://www.npmjs.com/package/smoke-pack) &amp;#x200B; Quick Usage $ npm install smoke-pack -g $ smoke-pack add foo library # creates a TS library project named 'foo' $ smoke-pack add app console # creates a nodejs console project named 'app' $ smoke-pack link app foo # links the 'foo' library to 'app'. $ smoke-pack watch app # builds 'foo' then 'bar' and starts both in watch mode. And inside the 'app' project you can. import {...} from 'foo' // where 'foo' is resolved from 'app' node_modules This project uses 'npm link' to cross link library dependencies (leaning more towards npm package publication). TypeScript is able to resolve npm linked packages (when published with .d.ts), So it seems to be the best way to approach things. &amp;#x200B; In future, there is talk of npm itself offering an alternative to 'npm link' using something similar to yarn workspaces. Will be something to keep an eye on (npm link is somewhat slow and clunky and im not a fan of the symlink-ing). &amp;#x200B; Anyway, Hope you find it useful (even if only for reference for project layout). Also remember that the lerna project exists too ([https://github.com/lerna/lerna](https://github.com/lerna/lerna)). &amp;#x200B; All the best.
This looks useful. I‚Äôve been using Puppeteer for a while because I scrape a lot of sites that throw up too many barriers not to use a real browser, but the interface is *definitely* a lot more low level. Looking forward to trying this one in the next few weeks!
If you're using type aliases, you might need to look at [https://www.npmjs.com/package/tspath](https://www.npmjs.com/package/tspath) to sort out the generated javascript.
I'm not entirely sure I understand the alias problem - however we have been managing our Typescript monorepo with bazel and it's working well so far. It's actually open source if you want to poke around its structure - https://github.com/dataform-co/dataform
with Angular I never had to use this, but I did had to with Node
You can try setting up [tsconfig-paths](https://www.npmjs.com/package/tsconfig-paths).
Essentially we use a root alias. All of our code since in an src folder. So our paths in config is src, so we can import @src/components/button. However that @src resolves to a physical space in the file system. When you move over to a front end app that leverages this same info, but uses the same @src alias. When you get to build time it tries to resolve it in both projects, it has a problem because they should resolve to two different places. But you can only have one alias key resolve to one thing.
I'm using lerna already, Essentially we use a root alias. All of our code sits in an src folder per package/project. So our paths in config is src, so we can import @src/components/button. However that @src resolves to a physical space in the file system. When you move over to a front end app that leverages a component library, but uses the same @src alias. When you get to build time it tries to resolve it in both projects, it has a problem because they should resolve to two different places. But you can only have one alias key resolve to one thing. When you run webpack it looks for @src. But @src in the front end project and @src in the ui project are two different things and since I'm using raw ts files and not their compiled js versions it fails when using aliases. If I made all imports relative path it would work. But it's just a terrible pattern.
You can use yarn link or npm link. Or a tool like lerna that does this for you. You‚Äôll want two path aliases. One per package
Yeah I guess I'd have to set up one root tsconfig and do my aliasing that way. At the moment each project has its own tsconfig, because you'd build them in different ways. We are using lerna, it's just when you go to build them it becomes a problem since we are using the ts files and not the compiled js. Even with the compiled js you'd need to resolve those aliases since ts doesn't.
Yes you‚Äôre basically saying you prefer functional programming to object oriented programming. Both are useful. Object oriented programming can essentially be implemented with functional programming as well, which is a reason I prefer functional. React is also moving in this direction with the introduction of React hooks
At work we have similar pain. Have you tried not using the same alias to mean different things inside different subfolders? What about `@project/subproject` etc.? That's what I've been doing in a side project and it was much better.
Yeah I might be getting rid of the src and using named aliases that describe it. It's a pain in the ass but a necessary evil to make it work. If I can get it to work without changing to relative it'd be a godsend.
Thanks for providing additional context! They've still got a couple months, but it's looking probable that [the language team is going to miss out on a nice free dinner](https://github.com/Microsoft/TypeScript/issues/15711#issuecomment-409366722). It's really unfortunate that language specs are so often neglected. It's a general fact about the universe that technical documentation sucks/is probably out of date/may not even exist, but official specs are typically the worst of the worst unless there is a dedicated standards body in charge. I think the problem is that the people who are most equipped to write specs are the ones who personally need them the least (almost by definition).
No they‚Äôre saying they like using smaller isolated modules. All of those functions are stateful and don‚Äôt return. Not functional.
Will Angular 8 improve the mediocre TypeScript support? Especially hoping for support of the `strict` flag.
Sort of.. I'm aware of OO vs functional. This could be made OO too.. with nested classes. The nesting is what I'm talking about here. Not having to jump around the code I think makes things easier plus I know exactly what each block does.
You can just use a `union` type to define the `T` for your `test` function. interface SameTypeContainer&lt;T&gt; { val1: T; val2: T; } function test&lt;T&gt;(_: SameTypeContainer&lt;T&gt;[]) {} test&lt;string | number | boolean&gt;([ { val1: "string", val2: "also string", }, { val1: 5, val2: 15, }, { val1: true, val2: false, }, ]);
We have a bunch of strict flags enabled. Which one is broken in Angular nowadays?
The default project template generated by the CLI has all strict flags deactivated. And I found no nice solution for strictPropertyInitialization yet.
As with everything, there's no one universal pattern. If these are hiding 100 lines of code each, I get it. Otherwise I dislike indirections simply for "readibility" - I'll argue it makes it worse. For one, you are making the reader jump around. There should be no escaping reading all the code inside a function, imho, if I'm going to work on it, including any functions it calls, especially when they don't return a result! It always triggers a flag in my head that something unexpected is going to happen. And If you work on a team, there's no guarantee someone won't add something else in the future completely unrelated to your functions or even worse, come up with another abstraction on top of this one not realizing it was purely meant for readability. I generally prefer one function that's even 100 lines long, with all the details, to 3-4 functions calling each other that I have to keep in my head and will only get in the way if I need to combine their logic in the future. There are exceptions but id say it's the exception and the rule should be only use methods for things you need to reuse.
I activate strict and only disable strictPropertyInitialization, although it should probably be enabled by default, would help many runtime errors happening when an Input is undefined. It just requires a lot of defensive code. "Mediocre" is a bit harsh my friend.
Biggest pain is requiring an old TS version and mainly meh template support.
I think the best "*solution*" / workaround to `strictPropertyInitialization` in Angular would be a `Proxy` (if you don't need to support IE). For example: function throwProxyError(): never { throw new Error("Accessing invalid proxy."); } const throwingProxy: unknown = new Proxy({}, { getPrototypeOf: throwProxyError, setPrototypeOf: throwProxyError, isExtensible: throwProxyError, preventExtensions: throwProxyError, getOwnPropertyDescriptor: throwProxyError, defineProperty: throwProxyError, has: throwProxyError, get: throwProxyError, set: throwProxyError, deleteProperty: throwProxyError, ownKeys: throwProxyError, apply: throwProxyError, construct: throwProxyError }); function initial&lt;T&gt;(): T { return throwingProxy as T; }; And when using it: class SomeComponent { @Input() public age: number = initial&lt;number&gt;(); } const someComponent = new SomeComponent(); console.log(someComponent.age.toString());
Closures are a core tenant of FP. I thought they were contrasting locations not size of functions. They specifically said they prefer closures to additional methods on the class, and did not mention function size.
Yep but to play devils advocate this style can result in larger files and it‚Äôs important other people than the author can understand it. I would encourage you to keep learning about the different paradigms but also not hold opinions too closely. I think one of the main benefits is not the nesting, but first class functions, passing callbacks, composing functions, functors and monads. These are all possible with lambda, and that‚Äôs the real advantage even more than the nesting üëç.
that is true, you CAN do a lot of &lt;things&gt; without libraries and frameworks, replace &lt;things&gt; with "state machine", "object mapping", etc. That does not mean that those frameworks are unnecessary. While I generally agree with that position (that DI without a framework is a valid option, in SOME capable languages), following that statement with "just use the module system" does not make a good suggestion because module systems of most languages are very basic and not designed with design by contracts in mind and are irrelevant to how you'd do DI, with or without frameworks. In javascript where there is no module functor, your composition units are classes and functions, not modules. To be clear my main point is that testability is not the sole motivation for DI. To some people, it's just a saner way of decomposing problems.
I just recently switched over to the tslint plugin built by Microsoft and it's slower than the original one. I still use it because the original is deprecated and might not support newer versions of vs code. Which version are you using
What plugins do you have installed (and enabled)
Are you using StyledComponents by chance?
Some of my coworkers switched to webstorm and reported that it‚Äôs a bit faster
I'm on the new one as well.
* C/C++ * Debugger for Chrome * DotENV * TSLint (new one, not the old one) * vscode-styled-components
I am indeed.
Thanks! Valuable input.
Recent version of TypeScript introduced **extreme** performance issues when using types that involve a lot of distributed types (which StyledComponents makes heavy use of). So your issue is likely not VSCode or TSLint related, but TypeScript and StyledComponents. Make sure your TypeScript version is updated (or switch back to 3.3) and you use the latest StyledComponents definitions.
Just leaving a comment to say that you definitely aren't the only one who has had this issue and I've been having it for the past week or so. It's only when editing .vue files though, I have no problems whatsoever when working with straightforward .ts files. Glad to see that /u/AngularBeginner and others have responded with solutions to this issue.
Go with webstorm. As much as vs code is a good editor, webstorm is just another thing.
Wow thank you! I bet this is it. I've been trying to figure this out for the last month and I bet this is the issue as the timelines coincide.
Ya I'd expect performance to improve soon. Make sure you stay up to date
Check my comment above to see if you're also affected by the \`@types/styled-components\` bug! Could be the issue for you too.
I'll make a few random comments, make of them what you will 1. No unit test. 2. So many directories. This isn't Java(!), you don't need to have lots of different directories, especially as most of them only seem to contain one file. 3. Use the short form for constructors. Instead of &amp;#x200B; private response: IResponse constructor (response: IResponse) { this.response = response } Write constructor (private response: IResponse) { } 4. Methods are public by default so you don't need the public qualifier. 5. Add comments to classes and interfaces. I've no idea what most of them do so it's hard to comment on the overall code structure. 6. Don't start interface names with 'I', any more than you'd start a string variable with 'S'. Just name them for what they represent. 7. You can add paths to tsconfig to avoid the relative imports. 8. Expression class doesn't match the comments. The class just lets you set a string but the comments talk about operators numbers and spaces.
The short term for constructor is new to me. Thank you so much for pointing that out, just learned a new thing!
TIL shorthand constructor
Putting the public after methods is a good practice though. The intention is clearer in that way.
Obviously it's matter of style but I disagree. It should be clear without the public modifier as that's how the language is defined.
There is nothing wrong using the `public` keyword and using the `IInterface` naming convention.
Public is matter of style. I'd argue that without it the code is shorter, has exactly the same meaning and is equally easy to read so it's pointless. The I in front of interfaces I'm more opinionated about. I don't put an e in front of enums or a c in front of classes so what's so special about interfaces? Generally the caller shouldn't care whether or not it's an interface, they should just see a object with a number of properties/methods which they can call. If you need a leading I to distinguish the interface and implementation then that's a possible sign there's something wrong, such as your names, modelled concepts or even whether the interface is serving a purpose. Robert Martin was talking about this years ago "I prefer to leave interfaces unadorned. The preceding I, so common in today‚Äôs legacy wads, is a distraction at best and too much information at worst. I don‚Äôt want my users knowing that I‚Äôm handing them an interface."
It's just a naming convention. It's used everywhere in the C# community and frequently within TypeScript projects as well. The same goes for using the `public` keyword: it's a matter of preference and more frequently convenience for the developer.
Even in C# the Hungarian notation convention for interfaces exists just for legacy reasons. The main issue with it is that it encourages sloppy naming like `Foo extends IFoo`, where in actuality it should be `SpecializedFoo extends Foo`.
&gt; more frequently convenience for the developer. How is it more convenient though? You already know whether or not something is an interface - that's literally the point of TypeScript. Your editor will likely provide hinting to let you know what things are. If not - then you need a better editor.
More convenient in the sense that if you code in C# a lot, it's one less thing you have to change and it's something that some TypeScript projects use as well so if you contribute to them it's quite convenient to keep it that way for your personal projects as well.
Right, but as you've said yourself it's just a naming convention. You _could_ always just call things what they are in C# as well and break from the naming convention. I'm all for sticking to established standards, but I've always thought this one was a bit daft. As /u/moremattymattmatt points out - what's special about an Interface? Why not call it CFoo for classes, and vBar for variables too? It just adds unnecessary noise to variable names and (in my mind) is akin to the old convention of prefixing variables with their type to denote the contents(i,e: `iUserId` where the first letter is `i` for integer etc.)
Can you post some code?
Unless you tell TS how your object will be structured, it has no way if knowing. Look into index signatures.
This was more a general, hows the best way of doing it, rather than about specific code. Is there something I can do to find out what a type is when it isn't very obvious?
You're definitely not understanding the static typing system in Typescript. Have you done a very basic tutorial? &amp;#x200B; [https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
Adding the access modifier says ‚Äúyes, I meant to do this,‚Äù and it also is nice to have all methods be declared with a consistent syntax. You‚Äôre right that it‚Äôs mostly a matter of style, but that‚Äôs also a reason to not recommend someone change it without an especially good reason.
What editor are you using? If you're talking about type inference, you should be able to just mouse over something and see what type it is in most editors that have typescript linting and syntax help. I'm using Visual Studio Code with some typescript extensions. https://i.imgur.com/qGBDDQr.png Note that I didn't give my function a return value. Typescript inferred the value based on the known result of adding two things with the number type together. Here's an example of a function that returns an object. https://i.imgur.com/IyI3hAZ.png You'll notice that my variable person is typed. If I try to do something like person.job = "janitor", I'll get an error that the property job does not exist on type {....} with my anonymous type properties in there. If I had instead done something like this: https://i.imgur.com/l0MtJKH.png Notice I've also given my function the return type of Person now. Since my object conforms to that type, I'm allowed to return it from makePerson. And the typescript compiler also gives me a more descriptive error about my missing property. Hope this helps or leads to more specific questions.
I'm guessing that by using `sudo`, you're installing for the root user instead of current user. Do you have the same issue if you run `npm install -g typescript`?
Restart your terminal?
I'll certainly go through them, but an example of what I was trying to do using my object from earlier: let foo: object = { MyString: 'bar' }; object.Mystring &lt;&lt;this will always through an "Mystring does not exist on type object. " error. Should I Just not make it a type? This is the other problem I have, value does not exist on type element: document.querySelector('.add__description').value. The only way I could figure out how to solve this one was also to just cast it as an any type. Is this what I should do or is there another way of going about this?
Ho-ly-shit. I thought it was just me! Doing this as SOON as I get to work tomorrow. ü§ûüèºü§ûüèºü§ûüèº
Not sure about your second question. And I'm on mobile so I can't test the first. There's absolutely no need for that object typing. The fact that you are assigning an object literal takes care of that, in addition to describing the shape of the object (its properties and their own types) based on the literal you provided.
A list of wrong tools for the job. Why JavaScript for ML?
The second error is always value does not exist on type element. However I think my problem is my main language is C#. All types must either be var, or explicitly typed. I prefer explicit typing for most situations. So what do I do in cases where like the second where the inference is apparently not correct, or I apparently need a cast but don‚Äôt know what the proper type is?
Thanks for replying! &amp;#x200B; I've learned some new stuff and since there are issues with the code comments etc, I need to fix them first.
Maybe they have too much time for a model to evolve.
&gt; I'll certainly go through them, but an example of what I was trying to do using my object from earlier: let foo: object = { MyString: 'bar' }; &gt; &gt; object.Mystring &lt;&lt;this will always through an "Mystring does not exist on type object. " error. Should I Just not make it a type? You should make a type, but a proper one. By saying your type is `object` you say that it can be **any** object, with unknown properties. Instead you should use a proper matching type. You have three options: 1. Let TypeScript infer the type. Then just write `let foo = { ... }`. TypeScript will infer the type from the object literal you assign. 2. Declare the proper type inline, e.g. `let foo: { MyString: string } = { MyString: 'bar' }`. 3. Create an interface for your type (best option) and use that, e.g. `interface MyObject { MyString: string }`, then `let foo: MyObject = {...}`.
Have pondered an approach to leveraging worker threads with TypeScript's decorator syntax, the concept is as follows... &amp;#x200B; interface IThreadHost { main(args: ...): Promise&lt;...&gt; } export function RegisterThread(name: string) { return (ctor: new () =&gt; IThreadHost) =&gt; { // register a dictionary of thread names on startup. // when the application starts, parse worker thread // parameters and invoke the IThreadHost main() // function. } } @RegisterThread('ImageResize") export class ImageResize { main(args: ...): Promise&lt;...&gt; { // do some heavy lifting here. } } So here, the @RegisterThread decorator is registering a bunch of named threads (on start up). When the worker\_thread is started, pass the name of the thread 'ImageResize' which would instance the class (via the constructor) and invoke the 'main' function. &amp;#x200B; In the main thread, one might invoke the thread with... const result = await CallThread&lt;TRequest, TResponse&gt;('ImageResize', { ... }) Haven't had much time to explore this abstraction in detail, but putting it out there in case it gives some developers some fodder for an interesting side project. &amp;#x200B; In a previous project however, i had set something like this up for forked node processes. Setup was similar to the above, but new processes were forked / spawned with something similar. $ node index.js --thread-entry ImageResize But with the advent of worker\_threads (and SharedArrayBuffer), this is a project in need of writing (or at least experimentation) &amp;#x200B; Nice work.
Make sure the global npm install location is in your PATH
Not just javascript ML libraries but top of them - what a time to be alive at )
There are basically two options: If you know in advance which attributes you will add later: Define an interface containing the attribute as an optional attribute If you don't know which attributes you will add later: Define an interface with an index signature { [k: string]: string } If you will always add this attribute you should try to add it directly when creating the object as this is also better for performance in JavaScript
When creating a new resource using POST, how do I access the location header of the response to retrieve the newly created resource?
This is because you've installed TypeScript as a superuser via `sudo`. As per my understanding, you've installed Node globally via brew or macports. I suggest taking a look at [nvm](https://github.com/nvm-sh/nvm). It not only allows having several Node versions installed side-by-side, but also solves a hindrance of `sudo` being required to install global packages. As another option, you can run `npm i typescript` in your project folder, and create an alias in the `scripts` section of package.json like so: ``` "scripts": { "start": "tsc" } ``` BTW, if you just want to play with TS, you can run the compiler without installing it globally with `npx tsc` ;)
{} is any without primitives and arrays
Hi, In my application I simply returns the new entity instance as response, in order to be serialized and sent to the client together with its ID. However, if you want to access the response headers you can still do it as you would do with Express (considered that the Request and Response instances are compatible)!
I was assuming it's a framework to access RESTful services.
It's a REST framework, but you're right.. it should be compliant about the Location header! I'm going to add this feature. Thank you for your feedback!
5 year WebStorm user here, switched to VSCode. I like WebStorm a lot, but VSCode is on par now. It isn't so much the editor, but the fact that tsc runs a server for full code understanding that makes them equal.
Q1: The role of \`{}\` was to act as a top-type: the most general non-nullable type which imposes no constraints on the value. This is why primitives, objects, and functions are all assignable to \`{}\`. In modern typescript using \`{}\` is usually wrong. You either want \`unknown\` for all values, \`object\` for non-nullable non-primitives, or some combination of \`object\` and primitive types. &amp;#x200B; Q2.1. No they are not the same. A value of type \`any\` is assignable to anything; a value of type \`{}\` is assignable to almost nothing: only \`unknown\`, \`object\`, something with an indexer, or \`any\`. &amp;#x200B; Q3. You can use this helper type to remove superfluous object types. `type RemoveEmptyObj&lt;T&gt; = T extends unknown ? ({} extends T ? never : T) : never;`
My 2 cents: also look into nodenv which is an alternative to nvm.
You're mistaken. Any object is `object`. You can assign anything to a variable of type `{}` except for `null` and `undefined` (when `strictNullChecks` is on).
I am not 100% sure about this but I think \`{}\` is the same as \`{\[key: any\]: any}\`. If you want to specify an empty object you can do something like: `type test3_full = keyof({}) | {email: string} | {token: string} | {message: string};`
The types `{}` and `{ [key: string]: any }` are not the same. A number is assignable to `{}` but not `{ [key: string]: any }`. It is best to not think of `{}` as an object at all. Think of it as a thing that places no constraints on a value, other than it being non-nullable.
Oh right, I forgot about that part. My point was that it is an object that can have any value but you phrased it much better than me :)
TL;DR you can have generic React components.
You clearly didn't cross-check or even test your code.
What are the legacy reasons you are talking about?
Older Windows APIs are riddled with Hungarian notation, which also happens to be a misinterpretation of what the inventor of the notation intended; the `I` prefix carried over to C# specifically from COM interface classes, but the overall reasons for using Hungarian notation are not relevant with more modern languages and tooling. It especially doesn't make sense to apply it to TS which doesn't have the legacy of C#.
Try this: type EmptyObject = {[key: string]: never}; type test3_full = EmptyObject | {email: string} | {token: string} | {message: string};
VS Code with TS Lint will do this for you.
A few questions: \- What version of TypeScript are you on? \- Have you double checked that you don't have any spelling or capitalization issues in either your configuration, your file/folder names, or your imports? \- Are you able to reproduce the issue in a small new TypeScript project?
How? What rule is it?
@williams-j: Thanks a lot for your detailed explanation and very helpful. I understand now.
&gt;No they are not the same. A value of type \`any\` is assignable to anything (except \`never\` @williams-j I just want to clarify one more detail: From your answer to Q2.1 as I quoted above, I think it should have been: ...A **value** of type \`any\` is assignable **TO** anything (except \`never\`) and also A **value** of type \`any\` is assignable **FROM** anything (**even** \`never\`) I had written a tiny code snippet as below and VSCode allows : &amp;#x200B; If I am wrong about this, please let me know why? &amp;#x200B; Thank you.
@rekkyrosso: As I mentioned in the question, I put "test3\_full" there just to show an example. The real code does not allow to edit the union like what you suggested. Thanks anyway.
All I can find is [this feature request](https://github.com/palantir/tslint/issues/780) on tslint's github.
That is hilarious and sad at the same time.
My personal beef has been with the `declare` keyword. Like what it means and what it does. And .d.ts files. I'm really struggling to find explicit info about these two topics in the handbook (searching is hard because it's split). Looked in the spec. Found the `declare` thing instantly. The spec is so important for a language, in my opinion.
Not my blog, I was just looking to see if it's possible because I needed it in my app and used this resource to see how it's done.
&gt;VS Code with TS Lint will do this for you. I don't think that's correct. See the comment from /u/[PhysicalRedHead](https://www.reddit.com/user/PhysicalRedHead)
thanks
Thanks, I hate it!
Ironically, I see some value in this &gt;\_&gt;
The value of being enterprise-compliant-code-unicorns¬Æ. Jokes apart, you could use it to statically type at runtime your TS code, althought it is not intended to run at runtime because is not optimized and stuff.
I'm all about seeing runtime type validation in JS [here](https://github.com/sinclairzx81/typebox). You know what they say, always validate your inputs. Might as well use semi industry standard ways to do it. If only the IETF or TC39 would embrace JSON schema, standardize it and give us some JSON.validate(schema, obj) method, we might see TS able to emit JSON schema for interfaces and possibly type aliases (without junking up a JS codebase with all the manual schema validation polyfill). &amp;#x200B; One can dream :(
I will have to say this code is not production ready. It needs to follow IoC. Also you need to hide everything behind interfaces just in case you decide to change the framework dynamically from JavaScript to cobol or assembler.
Pull requests are really welcome! By the way I will investigate on how to make it more Enterprise¬Æ and ProductionReady¬© the whole thing.
Not to forget you also need to future-proof-it ‚Ñ¢
Means you have to build the library on blockchain/AI/GraphQl/another-buzzword and optimize the code for running on quantum computers.
This example might help: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
How about a Decimal builder pattern? var d = ooop.Types.ObjectDecimal().new().withInteger("10").withFraction("0.10").withSign("-").build();
Good idea. A better over engineerd solution could be: var d = ooop.Types.ObjectDecimal().new().withInteger(new ooop.Types.ObjectString("10")).withFraction(ooop.Types.ObjectString("0.10")).withSign(ooop.Types.ObjectString("-")).build(); Could you please open a pull request or issue? Your contribution would be EnterpriseProductionlessReady¬Æ welcome indeed!
The aim of this project is to create a REST client that is similar to the .NET HttpClient. Current the documentation is almost non-existent. Check out the tests for more thorough use cases. --- The library is available on NPM... ```sh npm -i @michaelcoxon/rest-client ``` --- A bit of API docs: https://michaelcoxon.github.io/rest-client/
What does this have to do with OOP? You've got wrappers for primitive types line string, which would allow you to give strings methods, but JS already has this, like `toUpperCase`.
Finally! The library I had *NO IDEA* I couldn't live without!
Ah, I see you have studied marketing.
Come to the ProfessionallyOverengineeredSide‚Ñ¢
You are right, but it will be public in the next four major version (v213, v212, v323 and v454-codename-facepalm)
Thanks, and I've already noticed your need for an imaginary number type‚Ä¶ :)
If you're just adding features like an IoC container without removing features, it wouldn't be a breaking change, so it wouldn't require a major version bump, just minor version.
Works like a charm!
That's what it means to have sense of humor!
That's also not making to the release date, but it is normal in EnterpriseOhCuteABunnyWorld¬©
i suspect they intentionally wait on updating the spec to avoid having dinner with tneward. they might have had a point, but they were pretty unlikable throughout the whole interaction
Right now I'm trying to figure out what the integration tests should run off of. Do I point to the typescript files? OR do I need to compile it down to \`es5\` first like the app runs on a server.
You can disable diagnostics on jest configuration https://huafu.github.io/ts-jest/user/config/diagnostics
You jest... But I've seen Java that is more ooop than this!
Yep but in the future, ooop will transpile to java, just because a lot of recruiters still confuse java with JavaScript. Obviously, the output will be over and over engineered, juicy and delicate.
That's a nice approach too. For us it was very important to ensure every type is handled. Also the many streams had very specialised handlers per message type. By having this object (+types) we could ensure both. The handlers remained simple, which is important for the project because the project itself was already quite big. So it allowed us to have one simple handler per type instead of one big handler. Having one handler with an if or switch construction also made it possible for developers to forget handling certain data, which is what we wanted to prevent. &amp;#x200B; We created a projection mechanism, of which this was a centre-piece. All that came after is, the subscriptions to the resulting streams, were all done using RxJS though.
&gt; Having one handler with an if or switch construction also made it possible for developers to forget handling certain data, which is what we wanted to prevent. Of course, processing messages using if/switch construction would not be the best idea but there is no problem to apply simple pattern matching on top of the shown example.
Unless I'm overlooking something that'd result in a runtime check rather than a compile time check, is that correct?
You might want to look for better resources. Even the **first** method shown has already a glaring obvious mistake: function isDefinedNumber(a: number) : boolean { return a !== null || a !== undefined; } I mean, come on, really?
Although in a dynamic language like Ts/Js Ioc/DI is an overkill IMO it's very helpful un static typed language like c# 99% of the times for testing purposes. You can mock / stub (even without libraries) clases that calls external services (email, buy stuff in 3rd party apis, etc). We do this on an everyday basis. In a few cases you actually have a couple of implementations of the same service (ex: we have a mailservice that uses standard .net mail api for customers with office365 and other that uses sendgrid api for customer that don't have 365).
I am glad the author understood my sense of humour.
Will you create a yeoman template for customizing this library? Also, needs a blog post.
this['underlyingValue'] = !!bit ? 1 : 0; Love this line. Would love a reflection example in the readme
No, it won‚Äôt happen. But a cli for customisations will be distributed to your enterprise company on several 3.5‚Äù floppy disks
Why in the name of all things holy would you declare a subscription like this? JFC, the only bug is the person who wrote this garbage code.
That was a demo purposes only example. For real world case I'd suggest reviewing something like this library [https://github.com/pelotom/unionize](https://github.com/pelotom/unionize) which supports expression matching.
Hey, this is cool! I actually searched NPM for a TS RemoteData implementation when I started to write this article. It was more than a week ago, and I couldn't find any. Thanks for publishing this on NPM. I'll see if your implementation could be my go-to version from now on.
A big part of why code like this is written is that the author is not used to reactive and whenever a data transformation cannot be modeled in a straight line, they revert back to imperative style. (Same with FP, when I look at my old Scala code, I see way more mutable variables whenever control flow got slightly complicated) It's bad code. But a big part of what I'm going for is writing before/after of bad patterns vs good patterns to make sure that intuition can be shared.
Never heard of this before. I‚Äôm gonna check it out, seems interesting.
This is unnecessary. ctrl-p | pbcopy Unix is about composition. Please embrace it
I'm not sure which one you mean The fact that could rewrite it as function isDefinedNumber(a: number) : a is number{ return a !== null || a !== undefined; } or that you could make simpler and faster code by function isDefinedNumber(a: number) : a is number{ return 0/a === 0 }
One hour!?
to sum up everything in 2018-19? yes one hour.
maybe /u/i_spot_ads wanted it to be longer? like "on hour?! that's it?"
no haha i just wanted a blog post
Maybe he didn't click the link and is asking if it is 1 hour? We will never know.
but it might have ads
no worroes, I use ad block
then how do you spot them?
My experience was that it used 100% cpu even when idle/not changing any files.
They always have one hour session on each build. Anders himself gave some of the sessions
Personally I've found ambient types to be more trouble than they're worth at times, mainly because: * They're everywhere, even when they shouldn't be. If you have certain types that can only exist on the server or client, it's easy to tell you're using the wrong type if you have an import path that shows "client" or "server". * It adds a bit of mental overhead if you're in a file with no imports and there are some non-standard types available. "Wait, where did this come from?" This is mostly a non-issue if you're using a good editor that lets you jump to the definition, but I still prefer seeing the imports. * If a .d.ts file ever stops being referenced accidentally or accidentally gets removed, it can lead to a prolonged period of confusion where you have type errors scattered everywhere, but nothing to help you find where they came from in the first place. I've never had issues with circular references of just types, so I can't speak to that explicitly. The runtime won't care about circular references since TypeScript erases any imports that are type-only, so eslint may be acting overly zealous for you. Certainly, plenty of people dislike importing common types all the time, and I can understand that. But I prefer being explicit over implicit. Ultimately, if what you're doing is working for you, by all means keep doing it, these are just my personal preferences.
Fairly uninteresting this year, getting ever closer to variadic type signatures, so that's something. &amp;#x200B; But why you no runtime type validation Microsoft? JSONSchema exists, can't you just provide some mechanism to emit a JSONschema object representation of an interface (no functions of course) ? I am perfectly happy with plugging in my own JSONschema validatator, but god, to get data object types into a schema would be a god send. Been waiting since October 2012.
Very cool! I've been rolling my own backend framework piecemeal for a recent project, but switching to this is very tempting. What's the history behind this project? Do you have some apps running in production that are using it?
I could be misunderstanding you, and if so please ignore me, but this statement concerns me: "note I am forcing `this` to `Compose`". Specifying types in TypeScript doesn't *force* anything. They're annotations. They have no effect on the resulting JavaScript code (try it out, your JavaScript output will be the same whether you include `this: Compose` or not). When you specify `this: Compose`, all you're saying is "when I call this method, I'm going to call it such that the `this` value will be set to an instance of Compose". TypeScript is complaining because that's not what you're doing. You're calling it with an instance of `One`. It sounds like the closest thing to what you're looking for is mixins, which you can read about at this article in the TypeScript handbook: [https://www.typescriptlang.org/docs/handbook/mixins.html](https://www.typescriptlang.org/docs/handbook/mixins.html)
i mean.. could you do that in userland? dont need to wait 7 years for something you seem to want so bad. ts ast is right there. i have to admit i still dont get what variadic signatures are for. i thought the spread types we got in ts 3.x addressed that? there was a big longstanding issue i was watching that mentioned variadic. do you have something i can read up on? is there a language that does implement variadic signatures that you can refer me to?
‚òùÔ∏è
ES and TS are different beasts. I'd strongly suggest 1. `tsc --init --strict` to set up TypeScript in strict mode 2. Set up https://palantir.github.io/tslint/ with the `"tslint:recommended"` set of rules 3. Set up https://prettier.io/ and just use the defaults By taking the default settings for these tools, you're setting your codebase up pretty much as "standard" as you can get.
The framework looks pretty good! What are some of the differences between foal and other progressive frameworks such as Nest?
Really try to avoid running anything as root. This *especially* applies to `npm`, where security has been lax-to-nonexistent, and typosquatting packages of popular libraries aren't aggressively pruned. Node packages in general should be installed in the context of a project, rather than installed system-level. 1. Download and install Node. You can either use homebrew, `nvm`, or the installer at nodejs.org. Verify it's installed by running `node -v` on your terminal (as you, not as root). 2. Make a directory for your project, like `mkdir -p src/myproject`. 3. `cd src/myproject` 4. `npm --init` and answer the prompts. 5. `npm --save-dev install typescript` 6. `npx tsc --init` to set up a default `tsconfig.json` 7. `npx tsc` to run the TypeScript compiler.
There are lots of tools to go from TypeScript definitions to JSONSchema. quicktype is one. Why does MS need to build this into TS?
You are right. This is a demo project for learning TypeScript and Node.js
My typescript-fu is pretty rusty, and I don't think I completely get your question, but here's a function that takes an array of constructor for some type T, another parameter of type T and returns an object of type T: type Constructor&lt;T&gt; = { new(...args): T }; function blah&lt;T&gt;(a: Constructor&lt;T&gt;[], b?: T): T { return b || a.length ? new a[0]() : null; }
Not worth the registration.
&gt; Set up https://palantir.github.io/tslint/ with the "tslint:recommended" set of rules Consider directly using eslint instead. It does not support all the rules of tslint yet, but at some point it will. tslint is falling out of favor and will be deprecated soon.
Only this project [here](https://github.com/sinclairzx81/typebox) where I've needed to do things like [this](https://github.com/sinclairzx81/typebox/blob/master/src/typebox.ts#L175-L192) for [this](https://github.com/sinclairzx81/typebox/blob/master/src/typebox.ts#L348-L369). &amp;#x200B; This project is somewhat apt to the discussion of getting TS to emit JSONSchema for types. I'm not particularly fond of running yet more external tools to parse interfaces as JSONSchema, id much rather see it as a feature of the language (rendering that project completely mute) &amp;#x200B; Perhaps something like... &amp;#x200B; export schema Customer { firstname: string, lastname: string, // func: () =&gt; {} // invalid within schema types } // Used in this context, one could inspect the types // schema representation. Facilitating a limited form // of reflection over data transfer like objects. assert(Customer.properties.firstname.type, 'string') // Used in this context (annotation), Customer is treated // as a typical type (interface | type alias). function f(c: Customer) { ... } // With the primary usecase being something like the // following, with 'schema' some wrapper over Ajv or // other JSONschema validator. app.post('/', async (req, res) =&gt; { const obj = await req.json() const valid = schema.validate(Customer, obj) ... }) That's all really.
I'm generally not so fond of needing to run yet more external tools on my TypeScript projects. The topic of JSONSchema ties closely to the topic of runtime type validation, and it seems natural for TS to express its type system encoded in JSONschema for this purpose. Well it would except .... &amp;#x200B; .... JSONSchema is still pending ratification by the IETF (currently shuffling to [draft-8](https://github.com/json-schema-org/json-schema-spec/milestone/6) to keep the spec alive). The TC39 refuses to do anything meaningful with JSONSchema (like JSON.validate(schema, obj)) likely due to IETF not ratifying it and I largely expect that because of these upstream issues, TypeScript is unable to do anything in the runtime type validation space as doing so would put them at tangents with whatever 'standards' may emerge with request to JSONSchema (or other thing that shows up to solve the problem). &amp;#x200B; Anyway, always validate your inputs !!! (just maybe with a little less external tooling)
Yeah, that's terrible. Looks like someone thought TS is Java. Good news is, I'm now rocking generics in my functional components. But I'm deleting the OP link due to the poor quality of the code.
Yes you can! I have it set up like this: ``` "devDependencies": { "@typescript-eslint/eslint-plugin": "^1.7.0", "@typescript-eslint/parser": "^1.7.0", "eslint": "^5.16.0", "eslint-config-airbnb-base": "^13.1.0", "eslint-config-prettier": "^4.2.0", }, ``` .eslintrc ``` { "extends": [ "./node_modules/eslint-config-airbnb-base/rules/best-practices.js", "./node_modules/eslint-config-airbnb-base/rules/errors.js", "./node_modules/eslint-config-airbnb-base/rules/node.js", "./node_modules/eslint-config-airbnb-base/rules/style.js", "./node_modules/eslint-config-airbnb-base/rules/variables.js", "./node_modules/eslint-config-airbnb-base/rules/es6.js", "plugin:@typescript-eslint/recommended", "prettier", "prettier/@typescript-eslint" ], "parser": "@typescript-eslint/parser", "parserOptions": { "project": "./tsconfig.json" }, "plugins": ["@typescript-eslint"], "rules": { "lines-between-class-members": "off", "@typescript-eslint/no-for-in-array": "warn", "@typescript-eslint/explicit-function-return-type": [ "warn", { "allowExpressions": true } ] }, "env": { "browser": true, "node": true } } ``` The "rules" bit is my personal preferences, you can leave them out, but I think it gets rid of a couple of conflicts with airbnb. The next version of typescript-eslint will have some more rules that may enhance things further with regard to airbnb in TypeScript, they try to prioritize the TypeScript way by overriding rules you may have set: https://github.com/typescript-eslint/typescript-eslint/commit/2600a9f9892795b6193358f24ca15bbf761ac8d0
Hi /u/tyler_church &amp;#x200B; I have been working almost full-time on the framework for the last past months and I intend to continue to do so. The architecture of the framework is stable now (new releases only introduce new features) and the framework is battled tested by [many unit and acceptance tests](https://travis-ci.org/FoalTS/foal/jobs/529753145). &amp;#x200B; I use FoalTS for my projects and also know people using it in production.
Foal and Nest are both Node.js frameworks using TypeScript. \- NestJS architecture is very inspired by Angular and so comes with some complexity. Foal's architecture is meant to be simpler and so easier to learn and use. There are only three types of components in FoalTS: controllers, services and hooks. \- FoalTS comes up with *batteries included*. Not only does it bring architecture like Nest but it also offers a lot of built-in components to handle common scenarios. For example it includes tools to manage variables in multiple environments, shell scripts to execute Node scripts from the command line with validation of the arguments, CLI commands to generate and run databases migrations, generators to quickly build REST APIs, hooks to authenticate users with JWT with blacklist support, tools to debug the app with VSCode, and more!
Sorry, "forcing this to Compose" was just bad use of English, I know it is just an annotation, but thanks for making it clear. I saw that mixins article, but I am trying to stay away from complexity. Is there no way that I can simply use the `new` constructor in a class for composition and keep type safety? I am finding it hard to find information on how to do proper composition in TypeScript. Every article want to talk about mixins. Would you be so kind as to say how you would write the following in TS? class Hero is type Character. class Zombie is type Character Characters can have different rendering methods, shapeRender() and bitmapRender(). How can we use composition to give them each a different rendering method? We need the `this` in the rendering method to point to the class that created it to read it's co-ordinates. Cheers!
They could always change, but this would go squarely against their current design goals. https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals &gt; 5. Add or rely on run-time type information in programs, or emit different code based on the results of the type system. Instead, encourage programming patterns that do not require run-time metadata.
https://github.com/gcanti/io-ts
Look at joi :)
[https://github.com/sinclairzx81/typebox](https://github.com/sinclairzx81/typebox)
https://github.com/pelotom/runtypes
Let's say I have a class RandomClass with a constructor that takes an object of type ObjectConstructor. I want to make a function where the two parameters are of type ObjectConstructor and RandomClass. Can I achieve that with what you said above?
I like to use [typescript-json-schema](https://github.com/YousefED/typescript-json-schema) in combination with [ajv](https://github.com/epoberezkin/ajv). Unlike with other validation libraries, you're not writing classes with decorators or any other special code, you're just writing plain old Typescript interfaces. Then, you generate a [JSON Schema](https://json-schema.org/) file from your types via a CLI tool like this: \`\`\` typescript-json-schema --required --noExtraProps -o ./MyType.schema.json tsconfig.json MyType \`\`\` The JSON Schema file can be understood by a variety of tools, can be passed to other teams, etc., and you can also use it to check the types of incoming data via Ajv: import MyTypeSchema from './MyType.schema.json' import Ajv from 'ajv' const validateSchema = new Ajv().compile(MyTypeSchema) function validateIncomingData(data: any): MyType { if (!validateSchema(data)) { throw Error('Invalid data!') } return data }
What!? No :( I love tslint...
tslint is deprecated. It's developers now works on typescript support in eslint
I wouldn't say it is deprecated already, given that the TypeScript support for ESLint is still in progress, but it definitely will be in the foreseeable future.
Typescript is compile time not runtime.
Because one of these type checks by default and the other does not. This is not a 1:1 comparison
That's a lot of build infrastructure and baggage to deal with, why not [this](https://github.com/sinclairzx81/typebox) or your own version of it ?
[https://github.com/sinclairzx81/typebox](https://github.com/sinclairzx81/typebox) \+ [https://github.com/epoberezkin/ajv](https://github.com/epoberezkin/ajv)
Its all about trade-offs. For my project, there were only 2 objects which mattered (UploadSchema, DownloadSchema), but those were large, nested objects, which contained about 30 different interfaces in them. With a JSON Schema file, I can give it to the other team so they can make sure their output matches my expected input, for example by putting both into the [JSON Schema Validator](https://www.jsonschemavalidator.net/). I don't need to depend on them using Typescript as well, or me telling them why their data is not conforming to my schema. They can check it easily on their own. If I were using typebox, I would have to explicitly write down each of these interfaces in its notaton, and create an additional type from them that I can use throughout my application. This seems to me to be much more baggage than a single command that I can run automatically in a prebuild-step. Now, if I would find myself in a situation where I had to check the type of many different, but simpler objects, instead of only 2, I would need to create and import a lot more schema files. In this case, I might be more tempted to use something like typebox or JOI. But in the general case, I tend to dislike the boilerplate these libraries introduce into my code.
Looking at what the library is doing, I'm not sure if there is a straightforward way to convert it to Typescript. Here's an [example](https://www.typescriptlang.org/docs/handbook/mixins.html) from the Typescript Handbook on doing mixins, but it doesn't really match the dynamic behavior your library provides. &amp;#x200B; The main issue I see is that even if you get the typing working for the library, any consumer will somehow need to provide defined Typescript interfaces for any mixin they create/use.
Unfortunately a lot of those compiler checks mean nothing if the runtime objects don't match the types that the compiler thought they'd be.
Um, not exactly....Typebox is different to JOI as it is JSONschema by default and provides static type resolution out of the box. It doesn't provide any validators at all, and suggests you use Ajv or similar. I know, because i wrote typebox :) Consider. import { Type } from './typebox' const Customer = Type.Object({ firstname: Type.String(), lastname: Type.String() }) So if you did JSON.stringify(Customer) you would get the following JSONschema. { type: 'object', properties: { firstname: { type: 'string' }, lastname: { type: 'string' } } } However, if you do this.. import { Type, Static } from './typebox' const Customer = Type.Object({ firstname: Type.String(), lastname: Type.String() }) function foo(customer: Static&lt;typeof Customer&gt;) { customer.firstname = 'dave' // fine customer.lastname = 'smith' // fine } Typebox resolves the JSONSchema to a static type basically. In fact with the following, types X and Y functionally equivalent. const Customer = Type.Object({ firstname: Type.String(), lastname: Type.String() }) // X and Y are structurally the same type. type X = Static&lt;typeof Customer&gt; type Y = { firstname: string, lastname: string } So, Typebox does what JOI doesn't in this regard. However because your schemas are encoded into the javaScript, it doesn't really help you pass those schemas to your remote team. I have been known to publish API schemas on HTTP endpoints using Typebox tho, and because the code and the schemas are always in sync, i never worry about them going out of sync. Just a thought.
Take a look at type guards: [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
Yup (a bit too simple but works great)
i'll do it for you idgaf
It‚Äôs useful to verify that your program is internally consistent with itself. It‚Äôs not meant to add runtime checks. Thanks for the down vote!
I don't understand why this was down-voted. Runtime functionality is an explicit [non-goal](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals) of typescript itself. To add runtime type checking you use need to use something else (like io-ts) which can generate both a runtime checker and the types from the same code.
Try `wrappedFunction: Function`
How do I pass in params to the wrapped function though? This part fails because `callDynamoDb(itemId)` just does the call then and there, and passes the *result* into the wrapper. async callDynamoDbWithMetrics(itemId: string) { return metricWrapper(callDynamoDb(itemId)) }
Use .bind()
You can wrap it in a function: `metricWrapper(() =&gt; callDynamoDb(itemId))`.
You could have `metricWrapper()` return a function that passes along the arguments: function metricWrapper(fn: (...args: any[]) =&gt; any) { return function (...args: any[]) { const startTime = new Date(); let result: any; try { result = fn(...args); } finally { addLatencyMetric(startTime); } return result; } } preserving return type is pretty straight forward: function metricWrapperTyped&lt;T&gt;(fn: (...args: any[]) =&gt; T): (...args: any[]) =&gt; T { return function (...args: any[]) { const startTime = new Date(); let result: any; try { result = fn(...args); } finally { addLatencyMetric(startTime); } return result; } } [playground with usage](https://typescript-play.js.org/#code/GYVwdgxgLglg9mABAQwCaoDLKgU0gTwFkcoAnGCACgGcplSoAVGAWxwC5EARbHASkQBvRAF8AUGNCRYCRGzIUA6qWQAHVTlKVgYTpQB0h+gHNqnZGHwBtALoCAvAD4UlgYLGJPiUiRCkkUtDwSAZGpKbmlrZuHl5xEAi0iLT0TKw4iPaIYDgA7ty8lHwA3LFxngA2JN441CAVUJH4peVeZPhCZa1ePnUNmYg6ofom1CVdcSKDMGDIFRUd7t3laJi8BMQKVCkMzGzjy+LLPlB+SL31UC1e4uKS4EGyEHMVXPizLHBcAEaUMLgsACSqE4tHIYGMMTiJzOiH+OCBqFKdwSYCSz3mbw+X2+in+AAtNuQINQBvJico1BotBjXu9kJ8fuMxLSsQycXioISSMTqJQAETUOBsYH88ZAA)
This did it! Thanks!
Please explain the second screenshot
The key is to capture the full type in the type parameter: function metricWrapper&lt;F extends (...args: any[]) =&gt; any&gt;(fn: F): F { return &lt;F&gt;function (...args: any[]) { const startTime = new Date(); let result: any; try { result = fn(...args); } finally { addLatencyMetric(startTime); } return result; } } This will preserve both input and output types.
I just took a quick look on my phone. Ultimately it‚Äôs just syntactical sugar for JS handling of the decorator pattern, right? You can actually use @decorators on classes with typescript. I feel like I‚Äôm missing something?
Thanks! Enjoyed very much.
Every release has an associated blog post which I don't struggle to cram into an hour. ;)
I had a similar problem, I solved it by combining my tsconfig files into one file at the root of the monorepo
That‚Äôs a very good point! Most of the code I‚Äôve worked with is functional in style, so I haven‚Äôt actually tried out decorators, but they seem to fill the same purpose as this library. https://www.typescriptlang.org/docs/handbook/decorators.html
They actually just demoed typing this type of function at MS Build. https://youtu.be/Au-rrY0afe4?t=13m35s
&gt;unprofessional niggy this is reddit
It's `typeRoots`.
If you don't have the medium membership, please use the following link: https://itnext.io/building-a-paint-app-in-typescript-1ce42c5b1698?source=friends_link&amp;sk=cfeff11fa728f099d3fb27020a0b386e
Just don't create the definition file
You can simply re-export it from index.ts: `export {Button} from "./Button";`
That import wont resolve in the importing project unless I include the source in the node package, which I don't want to do.
Then how would other Typescript projects know what types to expect? I exporting the lib as a JS file.
Then just import from the definition file.
I tried this but it doesn't work. VS Code doesn't complain but Webpack doesn't like it.
If you are writing in typescript and want other typescript projects to use it, you dont need the .d.ts file. The typescript import will be enough. Those definitions are for putting types on untyped files.
Simpler fix would would seem to be moving widgetName to widgetConfig object
Do you writing index.d.ts by yourself? Why don't use typescript declarations generating?
I made the index.ts file export the relevant modules and declarations only. No actual code in there. Example... export { default as Button } from './Button'; export interface SomeInterface { ... } export interface AnotherInterface { ... }
The tsconfig.json allows you to exclude files by a pattern (e.g. all src/**/*.d.ts files) If you use MSBuild exclude your d.ts from the .csproj file or don't set the buildAction to TypeScriptCompile. Hope that helps.
Really nice clean code with zero dependencies.
This is the correct answer. I had to disabled "allowJs" but I can live with that. Thanks!
This is also correct - thanks!
I spoke too soon. It doesn't output some of the files even though they are no different to some of those that were exported. Any ideas what might cause that to happen?
Sorry I'm not sure what you mean. You'll need to provide examples.
Never mind, I got this working. I re-enabled allowJs and then added a separate node script for this command which produces the full typings only and disabled JS just for that task. [https://github.com/Microsoft/TypeScript/issues/7546#issuecomment-446472991](https://github.com/Microsoft/TypeScript/issues/7546#issuecomment-446472991)
Hey! I made a project in angular. Just started last week and almost about to finish it. Let me know what you need on dm.
dependency-cruiser will easily let you spot orphaned files https://www.npmjs.com/package/dependency-cruiser
Right, which is always the challenge with contrived examples. Part of the idea is what to do when you have one source data coming from an observable and you want to transform it (or parts of it) in different ways (e.g. mapped in different ways, or transformed asynchronously in different ways, or there are a bunch of methods that take one of these things as input, etc.)
https://old.reddit.com/r/typescript/comments/bmjw71/whats_new_in_typescript_daniel_rosenwassers_talk/
Something isn't right with your setup. You have to never touch the d.ts files at all in your life, and stuff should still work. Manually writing d.ts files for .ts projects is highly unusual (it's different with legacy JS projects), the compiler declares everything automatically. If the d.ts files aren't located in the standard output (dist) dir, maybe you forgot to set the "typings/types" prop in the package.json?
So everything working the way you need now?
I like this a lot. Are you suggesting 1 class per route in this setup? Possibly with the following... router.post('/api/users', CreateUserController) 1 class per route is an interesting idea, i think i kinda like it, Can you elaborate more on some of the details around routing.
writing your own web framework on each project, one gotta love node
Interesting work, have somewhat explored the parity between TS, JSONschema and mapped types [here](https://github.com/sinclairzx81/typebox), but curious on other approaches and mindsets. I strongly feel that JSONSchema is the path to runtime type validation in TS, so its awesome to see others digging deep into this topic. &amp;#x200B; Nice work.
Yes, all good now. Thanks again.
The base controller does nothing for you in terms of inheritance. Otherwise layout and structure seems okay
Yeah, if only Node had some sort of [modules](https://nodejs.org/api/modules.html) that one could import from some sort of [package repository](https://npmjs.com) to facilitate code reuse... but I guess we‚Äôre stuck always rewriting everything from scratch.
If at least node had stable and well mantained frameworks like Rails, Django or even Spring. Having a dependency system is not much useful when the most stable higher level frameworks around are 1-man mantained. Even .net which was quite rewritten from scratch for net core already has more solid frameworks than node /rant
Oh yeah, I‚Äôm with you there in that a lot of heroic effor being expended. No idea about what the maintainer base is like, although I‚Äôve thought Hapi was the quintessential one man project, Express less so.
Have you ever looked into [Nestjs](http://nestjs.com/) I think you might like it since you mentioned spring, and enjoy ts?
Thats the most decent thing around, I guess (not a big fan of their patterns but at least it is complete)
This is how we typically do it in the ASP.NET/dotnet core world. Default router is setup as `{controller}/{action}` and individual routes are just methods in that controller. If needed, you can decorate a controller or action with `[Route("newRoute")]` say if you had API routes and presentation routes under the same controller.
That's totally fair, it takes some getting used to but I've started to really enjoy it recently. I'm also an angular fan though.
&gt; Keep the story going. Sign up for an extra free read. Hahahaha **no**.
Yes, im familiar with .net core, webapi, / mvc, i was just surprised to see a single route encapsulated in a class as his blog suggests. The nestjs framework manages multiple REST handlers per class, but 1 class per route, than is something different. I expect it would make pulling dependencies, isolating logic tied to those dependencies really granular. Its an interesting approach.
They did a great job at laying a solid base for a web framework while still reusing some of the best packages around. &amp;#x200B; But for instance, lets compare it to Django, which has probably more than 10 years around. Django's ORM is flat out better, no discussion, migrations are top notch. And integrates with the whole framework, views, nested serializers... Validation comes out of the box, swagger documents come out of the box, all with a minimum amount of repetition and bootstraping. To do the same with nest ill need to write more code and some repetition, adding @Api markers on a ton of places. It's not nests fault, one cant do miracles within 3 years of work. You just cant expect a node framework to have the same level of maturity than a 10+ year old Python or Java framework. :( On the other hand I think the TS editor experience is something hardly matched nowadays. Id love a mature framework + the TS editor experience.
I definitely agree with you there. typeORM (or others) are still pretty immature but are making headway! I also do really love the editor experience! It is top notch!
This was one of the first issues in the Typescript repo: https://github.com/Microsoft/TypeScript/issues/9
 "Hello".makeTitleCase(); If we get the pipe operator syntax, we can simply write: "Hello" |&gt; makeTitleCase
Ok, I still have a hard time understanding what you mean, but I think that when you say ObjectConstructor, you're talking about the type of a parameter given to a constructor rather than a constructor type. Based on that assumption, you could have something like: function blah&lt;T extends new (...args: any) =&gt; any, O extends ConstructorParameters&lt;T&gt;[0]&gt;(a: T, b: O): InstanceType&lt;T&gt; { return new a(b); } Which you can then use like this: class Foo { value: Number; constructor(value: Number) { this.value = value; } } // Error: Argument of type '"test"' is not assignable to parameter of type 'Number'. blah(Foo, "test"); blah(Foo, 3); // Works.
I don't believe Typescript will ever add features that depart from javascript beyond its type system. But you don't need a new `extension` keyword, not do you need to go edit a builtin definition file to do exactly what the blog post is talking about: declare interface String { foo: (bar: string) =&gt; number; } String.prototype.foo = function (bar: string) { return this.localeCompare(bar); }; The first statement augments the builtin string type, the second statement augments the builtin string implementation. That's it. You'll typically want to split those so that the `declare` stuff ends up in a .d.ts file of your own, that you'll include as needed in your project. With that said, augmenting builtin object prototypes is usually a bad idea for a number of reasons. But typescript won't get in your way if that's what you're into.
How is this any different from creating your own version of a built in type and then giving it all the extensions that you please? Modifying built in types in javascript is always a bad idea, any sound javascript resource explicitly tells you to not do this. I fail to see why you cannot just created your own String class that inherits everything from the built in String prototype and then add what you will.
The benefit of extension methods is that you are \*not\* modifying built-in types. Lexical scope determines which extension methods are usable in a given context, and they're not \*actually\* methods of the target object. So they don't leak into other code or break external libraries. They're just functions that accept the target as their first argument, but you get syntactic sugar to invoke them as if they were methods. Extension methods make sense when it's not feasible to extend another class, because you're not creating the instances, you're getting them from somewhere else. For example, any time the JavaScript engine concatenates strings, it gives you a \`String\`, not a \`MySubclassOfString\`. The JS engine is constantly giving you plain strings without your added methods. Ditto for working with external libraries that construct values internally. Extension methods are great in those situations.
I've played with extension methods in Kotlin, and I agree they're great. In TS, will this get messy or confusing with union types or other language features? interface Foo { field: string; foo(): void; } interface Bar { field: string; bar(): void; } // extension method pseudocode extension function foo(this: Bar) {...} const val: Foo | Bar = comesFromSomewhereElse(); val.foo(); // &lt;-- compiler rejects this; it cannot add a runtime conditional (val as Foo).foo(); &lt;-- is ok (val as Bar).foo(); &lt;-- is ok
I've never understood the convention of prefixing interfaces with I. Why not prefix types with T? I tend to favor interfaces because of the principle of least power: use the least powerful tool that can solve the problem. Interfaces are less powerful than types, so unless you need an alias, union, mapped type or conditional type, use an interface. I still prefer types for functions since the syntax is simpler/clearer.
&gt; I don't believe Typescript will ever add features that depart from javascript beyond its type system. They have clearly stated their rules: https://github.com/microsoft/TypeScript/wiki/TypeScript-Design-Goals This suggestion would violate rule 8: &gt; Avoid adding expression-level syntax. And the non-goal 5: &gt; Add or rely on run-time type information in programs, or emit different code based on the results of the type system. Instead, encourage programming patterns that do not require run-time metadata.
Something like this will never be added to TypeScript, unless it's added to JavaScript first. TypeScript has the clear design goal to be *just* JavaScript with types. It does not want to provide and add all kind of different features that put it at risk for future incompatibilities with ECMAScript.
And even without you can trivially write something like: start("Hello") .pipe(makeTitleCase);
&gt; It‚Äôs a common convention to prefix interface names with I It's a common convention in other languages, but not in TypeScript. &gt; If you write object-oriented code ‚Äî use interfaces, if you write functional code ‚Äî use type aliases. An arbitrary rule without any base. &gt; It‚Äôs simply faster to type type Props than interface IProps. Holy sheet! Just imagine **all the time** you will save!
&gt; It's a common convention in other languages, but not in TypeScript. In TS as well, if you use TSLint (which is the de-facto linter for TypeScript), it will tell you to prefix your interfaces with I. &gt; An arbitrary rule without any base. Not really arbitrary, it's based on the strengths of interfaces and type aliases and where they're more likely to be used. &gt; Holy sheet! Just imagine all the time you will save! Well, developers are lazy :)
&gt; so unless you need an alias, union, mapped type or conditional type, use an interface. That's kind of a problem (at least for me and other devs that I talked with), that once you hit that barrier when interfaces no longer suffice, you get a mix of both, and that creates unnecessary clutter in your code and requires extra mental effort. But thanks for your input, I know that this article is highly opinionated, so it's great to hear what other people think on the matter.
&gt; In TS as well, if you use TSLint (which is the de-facto linter for TypeScript), it will tell you to prefix your interfaces with I. It's a tool not by Microsoft, and as with every tool: You need to configure it. The default rules are heavily opinionated. Microsoft explicitly forbids the use of the `I` prefix in the TypeScript code-base: https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#names There are numerous reasons why the `I` prefix thing does not make sense in TypeScript (I linked a larger explanation).
[**Microsoft/TypeScript**](https://github.com/Microsoft/TypeScript) repository has been mentioned 116 times over the last 7 days. The last 3 mentions: &gt; [..] for https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API CAVEAT This is a temporary solution until TypeScript adds support for this API as built-in types. See https://github.com/Microsoft/TypeScript/issues/27186 .USAGE Install Package via npm Edit your tsconfig.json Now you get navigator.connection with its type! INSTALL $ yarn add -D network-information-typesTSCONFIG.JSON network-information-types is a ambient types that modify global navigator type, so it MUST be [..] ^(Date: 2019-05-11 10:01) ^(Source: [dev.to/lacolaco/network-aware-preloading-strategy-for-angular-lazy-loading-4hae](https://dev.to/lacolaco/network-aware-preloading-strategy-for-angular-lazy-loading-4hae)) &gt; Hey again :) Would it make sense to add support for renaming files (https://github.com/Microsoft/TypeScript/pull/23573) to nvim-typescript? ^(Date: 2019-05-06 08:21) ^(Source: [github.com/mhartington/nvim-typescript](https://github.com/mhartington/nvim-typescript/issues/214#issuecomment-489543739)) &gt; TypeScript Language Specification 1.6https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md Âú® 2019Âπ¥5Êúà6Êó•Ôºå11:41ÔºåWei Gao &amp;#x6e;&amp;#111;&amp;#x74;&amp;#105;&amp;#102;&amp;#x69;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#115;&amp;#x40;&amp;#x67;&amp;#105;&amp;#x74;&amp;#x68;&amp;#x75;&amp;#x62;&amp;#46;&amp;#x63;&amp;#x6f;&amp;#x6d; [..] ^(Date: 2019-05-06 09:43) ^(Source: [github.com/Shopee/react-knowledgeable](https://github.com/Shopee/react-knowledgeable/issues/69#issuecomment-489564481)) View all [mentions of **Microsoft/TypeScript** repository](https://gitspo.com/mentions/Microsoft/TypeScript). ^(This is an automated message reacting to a mention of a GitHub project. | [Message the bot author](https://np.reddit.com/message/compose/?to=gajus0&amp;subject=GitSpo%20Reddit%20mentions%20bot&amp;message=Hello%20Gajus,))
Fuck off with this spam!
This has been discussed quite a bit. It probably won't be how you expect.
If TC39 had a schema.validate, that would allow TS to stick with their design goals but allow a way to generate or represent types/interfaces as schemas (similar to how enums are "run time" code)
I've seen [this](https://github.com/jinhduong/phodb/blob/master/src/utils/helpers.ts) before... But do chrome extensions support IndexedDB? Wouldn't that be more flexible and portable to specialised chrome extension storage stuff?
No, chrome extension doesn't support IndexedDB. `Wouldn't that be more flexible and portable to specialized chrome extension storage stuff?` I hope I got your question if you have worked with chrome extension APIs, so they just provided the JSON storage like `localStorage` at browser so this library will help us easier to work with them avoid duplicate code.
Interesting they would support localStorage and not IDB, you can get gigabytes of object and blob data in IDB but with an added cost and overhead of extra complexity and requiring async read / write. Thanks for your response.
You may be interested in [first class protocols](https://github.com/michaelficarra/proposal-first-class-protocols) which might prove a better alternative to extension methods.
Fix your links buddy
Thank you for feedback. This issue has been already fixed and no longer appears in future comments.
No strict mode enabled. Just why?
Strict mode not enabled. Just why? I would not use a library anymore that doesn't has all strict flags enabled.
Ha, sure. Not added as a mistake from the base TypeORM scaffolding. https://github.com/jmfurlott/chrona-api/issues/7
I was indeed talking about the type of the parameters passed to a constructor function. I ended up writing my function like so: export const arrayOf = &lt;T extends new (...args:any) =&gt; any&gt;( data: Array&lt;ConstructorParameters&lt;T&gt;[0]&gt; ): Array&lt;InstanceType&lt;T&gt;&gt; =&gt; { let Item: InstanceType&lt;T&gt;; const arr: Array&lt;InstanceType&lt;T&gt;&gt; = []; for (const index of data) { arr.push(new Item(index)); } return arr; }; to be used like so: const arrayOfClasses = arrayOf&lt;typeof MyClass&gt;(payload); Everything is correctly typed when I do it this way. Do you see any problems with this approach? I was not able to get correct types using your response above.
You're right, just updated to strict mode. Thanks.
cool project!
Ironic that this is posted in Typescript
Well it was posted in javascript a few weeks ago so I guess OP decided to make a high effort contribution and post it here as well.
&gt; completely contrary to most common belief, the == operator is actually more powerful and more useful in our programs than ===, and in fact, usage of == should be preferred and === should only be a last option. I'm no expert but I've burned myself on == way too often, I would need a very good reason to ever touch that one again.
How do you use this approach? When do you instanciate `CreateUserController` class? Is it in your main `server.ts` file or somewhere else?
Awesome!
For that specific example, inheritance sounds like a compelling option over composition. See here: [https://www.typescriptlang.org/docs/handbook/classes.html#inheritance](https://www.typescriptlang.org/docs/handbook/classes.html#inheritance) You can have a base `class` named Character that provides common fields and functionality, and then Hero and Zombie can `extend` Character and customize any functionality. If you need to override any methods, but still use the base functionality provided by Character, you can use the `super` keyword to access those. Alternatively, it sounds like passing in a specific rendering method to a character might be what you're after. You can do something like this: interface Drawable { x: number; y: number; name: string; } function bitmapRenderer(drawable: Drawable) { /* ... Implementation ... */ } function shapeRenderer(drawable: Drawable) { /* ... Implementation ... */ } class Hero { x = 0; y = 0; name = "hero"; constructor(public renderer: (drawable: Drawable) =&gt; any) {} render() { this.renderer(this); } } let hero = new Hero(bitmapRenderer); // Or... // let hero = new Hero(shapeRenderer); hero.render(); // bitmapRenderer will end up being called with Hero's information.
For those like me who hadn't heard of Yup: [https://github.com/jquense/yup](https://github.com/jquense/yup)
What type of feedback are you most interested in? Code-review kind of feedback? UI/UX? Something else? Random thoughts from just looking around: * Why `npm install &amp;&amp; yarn` as one of the install steps? Not sure I've seen a project use both npm and yarn but maybe I've just missed it. * `grabApplicationsFromApi` in `main.ts` looks like it could just be a normal async function itself, rather than returning a promise containing an async function. Sadly I don't use Flathub, Snapcraft or AppImage so can't comment much on the usage of the app itself. But congrats on putting your first TypeScript application out there :)
Code review would help me much.
don't: ``` "noImplicitAny": false, "noImplicitThis": false, "strictNullChecks": false, "strict": false, ``` do: ``` "strict": true, ```
This is really good! Also unknown moves us closer to using typescript in a FP paradigm.
I would debate whether a typesystem is a requirement or not for FP. It seems like the perfect match, but that doesn't automatically imply it is a necessity.
I have no idea, checking out Ramda now.
I've updated the article after some feedback! Almost like that, more along the lines of exporting an entire router and hooking it up to the main app. I'll be putting out another article really soon on folder organization and packaging by component. Thanks for reading @[sinclair\_zx81](https://www.reddit.com/user/sinclair_zx81/)! import { userRouter } from '../users/http/routers' const app = express(); app.use('/user', userRouter)
I love a sum-type-esque Result type as opposed to exceptions. Though, for this approach to get real traction, I feel like the type would have to be provided out-of-the-box by TypeScript, rather than numerous people rolling their own.
Static types aren't a requirement, but it certainly helps imo. Clojure, for example, doesn't use static types, and you could definitely argue it's a functional language.
That would certainly be pretty cool. Or maybe if enough people roll their own, TypeScript devs might take notice :)
Article also contains a gem I was not aware of: TypeScript allows you to omit the error binding for a catch block where you don‚Äôt use the error. TIL.
You do something like the end section of this guide: https://www.typescriptlang.org/docs/handbook/declaration-merging.html Does this work? ``` declare global { export function fireLaser(strength: Number): void } ```
Try https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement
Follow the react.d.ts file or even the TS lib d.ts files, you'll learn a great amount.
I've done something similar to extract callable and non callable fields from types. Very useful when defining redux mapStateToProps and mapDispatchToProps, since the compiler can then check that every prop is covered.
I haven't had a chance to download and play with this, but think it's a fantastic idea.
Thanks so much! I will try this out soon. I am using Inheritance, but the renderer method was the final annoying thing that would not quite fit in to an otherwise perfect hierarchy.
FYI, this appears to be a react event, not a regular DOM event. Most of the events are here. https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement. Some events only exist on specific element types, which you can find in the MDN reference for the corresponding types.
I find this to be disagreeable because it's using a map for an effect (modifying a the max variable). let max = -1; numbers.map((num) =&gt; { max = Math.max(num, max) }) Some alternatives: numbers.reduce((a,b) =&gt; Math.max(a,b) or Math.max(...numbers) If you really need to have a side-effect, please use **forEach** instead of **map**.
How are you bundling them together, webpack? Are you using an ES6 import like `import {myfunc} from './script.js';`?
Bundling is webpack, and yup, very similar. import SearchOverrideJs from "./searchOverrideJs";
Hover over an identifier and hit F12 to jump to it's declaration. Depending on the editor, the keybinding might be different.
Even better, optional catch binding is not a TypeScript-specific feature! It‚Äôs standardized in the ECMAScript specification, so it‚Äôs part of JavaScript, the language: https://github.com/tc39/proposals/blob/master/finished-proposals.md
I don't use React but I assume that the `ChangeEvent` must be a lightweight wrapper around native DOM events. For native events, /u/recursive linked to MDN, which is probably the most comprehensive documentation you'll find. If you want to know more about React's wrapper, you'll have to look at their documentation.
The page seems very buggy on mobile https://imgur.com/gallery/pgz66kf
Apparently, Safari gives a really hard time for the site. Try on Chrome while I try and fix this for Safari. Thanks for the feedback! :D
Nice article, Mapped Types are powerful! You might want to check out ts-essentials [https://github.com/krzkaczor/ts-essentials#readme](https://github.com/krzkaczor/ts-essentials#readme) for some interesting mapped types like DeepPartial and DeepReadonly.
Came here just to say this. A map with a side effect just feels all kinds of wrong.
OK looks good, webpack would raise error if import fails, would need to see full code
I'm noticing the generated example at the GitHub doesn't include the suffix you specified in the demo comment, this is a bug, right?
Not a bug I forgot to update the docs after adding the feature! Thanks for noticing :)
Mocha/Chai would be your minimalist solution. Add Sinon if you want to mock APIs. I'm not familiar with Jasmine enough to know what it supports out of the box, but it may be a good choice. Jest would be the non-minimalist option. It is based on Jasmine, and I know it has Mocha, Chai, and Sinon features baked in. Jest also supports threaded testing, which is nice if your tests take a while to run.
Jest. You don't have to install other dependencies for assertions/mocking/coverage, it pretty much has everything you need. It's recently been rewritten in typescript too, so the support for typescript should be good going forward.
You can't just compare arrays like that. https://gomakethings.com/checking-if-two-arrays-are-equal/
[fast-check](https://github.com/dubzzz/fast-check) Typescript property based testing library. You can build powerful "Arbitrary" objects which will generate random test data which you can test against.
An array is an object. You are comparing two different objects.
This is a very fundamental Javascript (and every programming language I know) feature. Essentially you are comparing the object references, not the contents of the object (in this case an array). To put that in human terms, it's asking are these the same array? Well... They're not. Their contents may be the same, but they're not the same array. Imagine you have two identical red Toyota priuses. The may look and function the exact same, but they are different cars in the sense that they're two separate ententies.
Both of you guys are so right. Thanks for your comments! Fixed!
Did you try quicktype?
Yeah, that makes sense now. I had made the assumption that I was comparing the value of each object, rather than the reference of each of object. Thanks for the clarification. If you're at all interested, here's what I was trying to refactor: if ( histogram[0] &amp;&amp; histogram[0].value === 14 &amp;&amp; histogram[1] &amp;&amp; histogram[1].value === 5 &amp;&amp; histogram[2] &amp;&amp; histogram[2].value === 4 &amp;&amp; histogram[3] &amp;&amp; histogram[3].value === 3 &amp;&amp; histogram[4] &amp;&amp; histogram[4].value === 2 ) { ... } I *wanted* to package up the assertion to represent it a bit more elegantly if (histogram.map( item =&gt; { return item.value }) === [14, 5, 4, 3, 2] ) { ... } &amp;#x200B; Again, thanks for your clarification
While I understand what you are saying, your phrasing is ambiguous.
Anecdotally, the choice is between Jest and 'any of the mainstream others'. Jest is sometimes slow, but it is very feature reach, most prominent feature being, IMHO, module mocking (don't remember the rest having it). If you are making a small-medium library - mocha + chai is probably enough. The red-green-refactor development cycle is usually super-fast and Jest may slow you down in this case. If you are doing enterprise development in a team, where most of the time is spent figuring out requirements \\ business logic - go for Jest, its power will serve you well.
You're on the right track in exploring more declarative approaches. I recommend reading more on functional programming and the concept of referential transparency. I think you'll find even more tools to simplify your code.
'**any**' is not a type, 'any' is to give-up to type. '**unknown**' is a type. **Use 'any':** when you decided to inform the type system you want to disable his suport with certain variable. **Use 'unknown'** when you want the type-system help you:- to prevent type error at compile-time *(or even before, at coding-time) .*\- to give you good intelisense suport Nice article.
Yep, added link to the article, thanks.
I was always rooting for mocha/chai combo because it's damn simple but these days I finally migrated to Jest. Snapshot (and inline snapshots) are killer feature, saving tons of time.
There's absolutely no way I would have understood what a Monad is without a type system :D
Just looked at it, it seems great! Doesn't seems to provide a lot of options tho. My goal was to build a simple tool to get a simple file, I don't think it's targeted for entreprise solutions
This is a better way: const expected = [1, 2, 3]; // etc if (histogram.every((v, i) =&gt; v === expected[i])) { ... }
&gt;Note: Formally any is a type. It's the type of all variables of a &gt; &gt;pure javascript &gt; &gt; code for example. Automatically any pure javascript code has all its variables casted to 'any' when you parse it in a TS compiler. It's your job to inform something more meaningful than that. You don't need to type all variables in your program, TS inference system works well. But no Type-Inference System on the world can infer what type 'any' is. What really happens is that Typescript makes a FFI call to Javascript very transparently. Haskell, ReasonML, Rust... all of then obligate you to type values you bring from untyped languages using FFI.
I think this is clever but inaccurate because is does not match strict equality. Example: const histogram = [ {value: 1, quantity: 2}, {value: 2, quantity: 2} ] const expected = [1, 2, 3]; if (histogram.every( (v, i) =&gt; v.value === expected[i]) { // true! ... } `histogram` could be shorter than `const expected` and still run the if block. &amp;#x200B; Food for thought.
Thank you for replying. I've added this to a blog post so that images and code could be easily embedded. If you require more information just let me know. Feel free to just reply here. I will assume for a moment that you're \*not\* familiar with the SharePoint Framework, I've attempt to not overdo any of the specifics. My own comfort with TypeScript and vanilla React in general isn't the highest, so please excuse any retardation on my part within the scope of this sub. Here goes: [https://dreamsof.dev/2019-05-17-typescript-and-javascript-not-playing-nicely-spfx-react/](https://dreamsof.dev/2019-05-17-typescript-and-javascript-not-playing-nicely-spfx-react/)
Maybe I could explain what he said with code? This is a better way: ``` const array1 = [1, 2, 3]; const array2 = array1; const array3 = [1, 2, 3]; // same values but new array. console.log(array1 == array2); // true (since they are equal to each other) console.log(array1 == array3); // false (since they are two different arrays with the same values) ```
Like I said, I understand what he is saying. We're evaluating if two objects are the same instance - or in other words, comparing references. And this is important to note because my assumption in the OP is that I was comparing values, not references. &amp;#x200B; /u/muchroomcultpeople is right, but their explanation is ambiguously phrased.
The way I see it you were expecting something to happen because you assumed something and because it didn‚Äôt work the way you expected you are pleading ignorance in hopes it will somehow magically change for no other reason than your initial assumption which is ludicrous. I say ‚Äúpleading ignorance‚Äù because you apparently understood it was an issue of pointer vs value. You should be above this. Why are you here? You could figure this out with a _very_ simple google search. I‚Äôm sure even bing would give you viable answers.
node-tap is cool (not for browsers tough)
yeah geez why talk about code on the internet at all. There is no benefit at all for anyone exploring a topic of conversation with other people for something that 'could be googled'. Don't like the post? downvote and move on you crustacean.
Aw, cmon. You‚Äôre so passive aggressive. I felt like I _had_ to get a little triggered. And I‚Äôm a little drunk. How was I ambiguous? I‚Äôm genuinely curious.
You could do a simple length comparison between expected and the actual array before the every call to avoid this case
Those are some seriously impressive improvements. I know it's minor, but having Omit built in is just awesome. I'm tired of defining it myself in every project.
I've create this [https://github.com/xialvjun/skm\_ts](https://github.com/xialvjun/skm_ts) . It can generate the `Input Type` or the `Args Type` for server resolver from `schema.gql` file.
I've spent so long trying to solve some of these issues, it's almost relieving to see them addressed, but it doesn't give me back all the hair I pulled out.
Mine either.
Dear god, that convert to array function. It's like you just took a simple 1 liner and made it 100x more complicated.
+1 for Jest. I just wrote a few hundred unit tests in TypeScript for a couple node/express applications at work and it was a dream to use. The mocking of es6 modules feature is extremely powerful.
It's a small thing but I am incredibly excited for the `Omit` type. I can now stop creating it in every project I work on. Thanks for listening Typescript team - it's appreciated.
I'm disappointed they are making the keys permissive. Now I'll need to add a StrictOmit to all my projects. https://github.com/microsoft/TypeScript/issues/30825
[Microsoft/TypeScript](https://github.com/Microsoft/TypeScript) repository has been mentioned **7 times** on Reddit over the last 7 days. The last 3 mentions: |Mention|Source| |---|---| |They could always change, but this would go squarely against their current design goals. https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals Add or rely on run-time type information in programs, or emit different code based on the results of the type system. Instead, encourage programming patterns that do not require run-time metadata. |[/r/typescript](https://reddit.com/r/typescript/comments/bmjw71/whats_new_in_typescript_daniel_rosenwassers_talk/en0ad6o/ "/u/danvk at 2019-05-10 11:27") | |I don&amp;#39;t understand why this was down-voted. Runtime functionality is an explicit non-goal [ https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals ] of typescript itself. To add runtime type checking you use need to use something else (like io-ts) which can generate both a runtime checker and the types from the same code.|[/r/typescript](https://reddit.com/r/typescript/comments/bmy35p/checking_object_schema_at_runtime/en22vh8/ "/u/sledgespread at 2019-05-10 21:33") | |Never mind, I got this working. I re-enabled allowJs and then added a separate node script for this command which produces the full typings only and disabled JS just for that task. https://github.com/Microsoft/TypeScript/issues/7546#issuecomment-446472991|[/r/typescript](https://reddit.com/r/typescript/comments/bn9o26/how_to_avoid_duplicating_interface_definitions_in/en3wnit/ "/u/HomeIsHades at 2019-05-11 10:59") | ^([Report an issue](https://np.reddit.com/message/compose/?to=gajus0&amp;subject=GitSpo%20Reddit%20mentions%20bot&amp;message=Hello%20Gajus,)|View all [mentions of Microsoft/TypeScript](https://gitspo.com/mentions/Microsoft/TypeScript))
This doesn't have anything to do with switch statements. This is a common technique to not pollute your global scope. `let` and `const` are defined within the block scope. ```js { let i = 0 // do something with i }; function whatever() { i // undefined // ... } ```
Don‚Äôt worry, TypeScript 3.6 will add ‚ÄústrictOmitType‚Äù as a new option /s
I appreciate your enthusiasm for sarcasm, but to become a master you mustn't use /s. *I'm a human being, and this action was performed manually.*
Wait a minute you choose to remove your hair Daniel. üòÑ
I appreciate the performance improvements. It has been impossibly slow with styled-components.
I'm always surprised by comments like this. Are you so frequently creating new projects that actually make use of this type? So often that you get incredibly excited for not having to copy paste one line anymore?
Yep this code scores are old as dinasaurs shit
**FUCK OFF WITH YOUR STOLEN CONTENT!** **REDIRECTS TO MORIOH.COM!**
I dislike Jest for their pollution of the global namespace. Why not just use modules?
I must admit that I've never felt the urge to have an Omit type.
To me it's painfully slow (tho I don't know any faster tool either). But when you encounter issues like https://github.com/cypress-io/cypress/issues/695, then you're just frustrated about the frequently failing tests. It's open since 2017 and work hasn't started yet either.
It's probably more about importing it. Could make it global but that creates dangerous precedent.
&gt; Could make it global but that creates dangerous precedent. Having universally applicable types globally available is fine. TypeScript doesn't do anything else.
I generally prefer [idiomatic TS](https://www.typescriptlang.org/play/#src=interface%20Logger%20%7B%0D%0A%20%20%20%20log(s%3A%20string)%3A%20void%0D%0A%7D%0D%0A%0D%0Ainterface%20Walker%20%7B%0D%0A%20%20%20%20walk(steps%3A%20number)%3A%20string%0D%0A%7D%0D%0A%0D%0Aclass%20Person%20implements%20Logger%2C%20Walker%20%7B%0D%0A%20%20%20%20name%3A%20string%3B%0D%0A%0D%0A%20%20%20%20constructor(name%3A%20string)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.name%20%3D%20name%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20log(s%3A%20string)%20%7B%0D%0A%20%20%20%20%20%20%20%20console.log(s%2C%20this.name%2C%20this.walk(8))%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20walk(steps%3A%20number)%3A%20string%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20'you%20took%2C%20'%20%2B%20steps%20%2B%20'%20steps!'%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20s%20%3D%20new%20Person('ihsan')%3B%0D%0A%0D%0As.log('hey')%3B%0D%0A) over weird styles people try to bring in from other languages, and I think most TS devs would agree that the idiomatic version is easier to read. Please consider adopting local culture before you try to force the Go style you're used to into the language.
Interesting ideas. Personally, I would write this the "normal" way like so. class Person { name: string; constructor(name: string) { this.name = name; } log(s: string) { console.log(s, this.name, this.walk(8)); } walk(steps: number) { return 'you took, ' + steps + ' steps!'; } } I'm not quite sure what you mean by extra syntax or peace of mind. To me, this is slightly more readable than the factory variant. If you like small interfaces, it's also possible to declare them that way within a class. Could you expand on your "easy composition" comment? It seems the `log` and `walk` functions are still tightly coupled to the `Person` type in your example. How could you re-use those functions in any other composition?
This is much more readable to me as a JS dev. In general, think it's best to follow the paradigms provided by a language rather than try to reuse patterns from other languages. Classes are syntactic sugar but theyve made our code much more readable. You can look at a constructor for example to know what needs to be done on creation, and there's a clear list of all the fields in one spot.
My opinion has changed. Ryan made a good comment here: https://github.com/microsoft/TypeScript/issues/30825#issuecomment-493579128
Interesting and creative! It does indeed look "Go-ish", as each method adheres to the "receiver" syntax that Go does. As others have said, it still tightly couples Person to log/walk, though. What if I want to have other specializations of the log/walk functions? Would I do?: ``` function newSomethingElse(...): SomethingElse{ return { ..., log: somethingElseLog, walk: somethingElseWalk } } ``` I personally like to see the coherent methods grouped together in a class;
Cypress is a piece of crap. Did you try Endtest?
Just please don‚Äôt call it composition
In your example, `SearchOverrideJS.js` is not a "module" in any format (ES2015, CommonJS, etc). It doesn't export anything to be imported, it merely declares a variable. Your `.d.ts` file, on the other hand, claims that `SearchOverrideJS.js` is a module with a default export. &amp;#x200B; It works from the console because I assume you have `&lt;script src="SearchOverrideJS.js"&gt;` somewhere on the page, and that `var` declaration goes into the global scope.
Thanks! You got me on the right track! I created `globals.d.ts` and added the line: declare function fireLaser(strength: Number): void And then I was able to use it just like I want to! I do have an extra question which would be really nice. Is it possible to group fireLaser in "something" so I can do lasers.fireLaser(42) And then in my compiled output it simply says `fireLaser(42)` as it's the name of the real global that exists in my target? The reason I'd like to group it is that I will have around 40 of these global functions and it would be nice to be able to write `lasers.` in Visual Studio Code and I'd get to see all of them easily. Otherwise the suggestions are mixed with things I won't even have access to such as `canvas`
Thanks for the input, it was the "not a module" comment that made me realise duh, how could I have been so stupid. Thanks for the prod in the right direction. The SharePoint Framework doesn't work like vanilla React, there's no index page, and while a script tag could be inserted, it hasn't been. The import only occurs in one place, within the React component as previously mentioned. Thanks again.
Well classes rely on `this` ([which tons of javascript developpers struggled with](https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work)). The op code don't. Otherwise in terms of readability it's just subjectivity
State containers can be achieved by both classes or closures. Clorures have been the preferred javascript community method for a long time, and they have a couple of benefits and also downsides compared to classes.
That‚Äôs a fair argument. I think the advantage that StrictOmit still has is with auto-complete when typing keys, but I suppose that‚Äôs a minor benefit
That's just to demonstrate now being able to apply function composition to functions that take generic parameters.
Sooooo... how do you pass that video stream to a server, then have it streamed to another person?
My thought process exactly. There are pros and cons and I think they made the right choice.
As far as I know that's not possible. It would heavily impact how JS was emitted from the compiler, which is an explicit non-goal for Typescript. Also, the reason VSCode reports bad types in the global namespace is the values you've set for `lib` in your `tsconfig.json`
 type Athlete = { sport: string, human: Human } function newAthlete(name: string, sport: string){ return { human: newHuman(name) sport } } //OR type Athlete = { sport: string } &amp; Human function newAthlete(name: string, sport: string){ return { ...newHuman(name) sport } } Something like this. We can compose things together like this. For further reading check out wiki and other resources and videos [https://en.wikipedia.org/wiki/Composition\_over\_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance).
or very alternatively to directly address you question of reusing function which could also be done with classes i suppose is something like this interface Logger { log(s: string): void } interface Walker { walk(steps: number): string } type Person = { name: string, } &amp; Logger &amp; Walker function newPerson(name: string): Person{ return { name, log: log(walk), walk: walk() } } const log = (walk) =&gt; (string) =&gt; { console.log(s, this.name, this.walk(8)) } const walk = () =&gt; (steps: number) :string =&gt; { return 'you took, ' + steps + ' steps!' } const s = newPerson('ihsan'); s.log('hey');
I mean, I'm using paradigms from JS. Arguably the way I do it is more js because the way i showed existed before classes.
Where do Monads fall?
Not OP. &amp;#x200B; Can you explain why what you wrote is important? Genuinely curious.
I don't see how Endtest is comparable. It's a paid service, not a free tool. So it's absolutely not an option.
`strict: true` is the sane default option, run `tsc --init` to generate default tsconfig file. Everyone should strive to have it enabled as otherwise you lose a significant part of TS benefits and then why use it in the first place.
Endtest spam
What's the incentive for these accounts who pollute tech subreddits with their links?
Those are dummy accounts, just used to post links that redirect to Morioh. And that website takes content from others, presents it as their own, only gives credit with a small text at the end of the article saying "originally published by xyz on medium (links to the domain, not to the article)". And Morioh makes money of advertisement and merchandise.
What are monads? Some sort of monoids?
Yep. /u/dragnea_presedinte is clearly affiliated.
Yes, I forgot, your arms would fall off if you would pay for a service that you use. Why ask your boss to pay $50 for something when you can build it yourself in 36 months?
Paying for something is one thing, but not being able to run it on-premise is a whole different kind of beast and a huge issue. And for on-premise there is no price listed, just "custom pricing".
In TS it‚Äôs referable to use ‚Äòfor (let num of numbers)‚Äô, it compiles to same code
Because it's ubiquitous; there's no situation where you're writing a Jest test suite and *not* importing `describe`, `it`, `expect`, etc. so putting them in global scope makes writing test suites less tedious. Also Jest is not a just a library, it's a completely separate environment where tests can be executed. It makes sense conceptually that this environment has its own particular global namespace, similar to how the browser is an environment with its own particular global namespace.
&gt; Because it's ubiquitous; there's no situation where you're writing a Jest test suite and not importing describe, it, expect, etc. so putting them in global scope makes writing test suites less tedious. But it usually also means you immediately have these identifiers available in all your regular source code, unless you completely split up your app and test code in different folders or have multiple tsconfigs (both not nice).
You need to specify the type yourself, because there is no way for the compiler to otherwise identify the type (because the type of your generic function is not part of your wrapping type). So one option would be `GenericFunction&lt;unknown&gt;`. If you care about the type, then you should drop the mapping type and provide a type with appropriate type arguments: type YourWrapper&lt;T1, T2&gt; = { 'first': GenericFunction&lt;T1&gt;, 'second': GenericFunction&lt;T2&gt; };
 class CacheQuery extends Query { myMethod(str: string) { console.log(str); } }
You can use declaration merging to achieve this First you need to declare an interface which will be merged into the mongoose class definition. This is just for the cache method type CacheOptions = {key?: string} declare module 'mongoose'{ interface Query&lt;T&gt;{ cache(options: CacheOptions) : Query&lt;T&gt; useCache: boolean hashKey: string } } You should then be able to add the cache method to the prototype Query.prototype.cache = function cache(this: Query&lt;any&gt;, options: CacheOptions = {}) { this.useCache = true; this.hashKey = JSON.stringify(options.key || ''); return this; };
Maybe i am wrong, but i think the point of this code was to overwrite Query.prototype.exec and create reusable redis cache.This just creates new class that wont be used by mongoose.
Have a look at TypeORM with mongoDB. It‚Äôs what I used and I found it nicer personally
Oh, you're probably right. &amp;#x200B; /u/toasties1000 seems to have the correct solution then.
The article says static types don‚Äôt reduce bugs, but then says &gt; Thing is, that developer injects more or less the same amount of defects, and static type checks allow him to notice and fix the fraction of these defects earlier, and thus with a less effort That sounds like reducing bugs to me. It also says types are the ‚Äúdocumentation guaranteed to be right‚Äù but I disagree. Especially with TypeScript where the types are overlayed, often manually. The defined types, especially in third party code, are often wrong. And TS offers so many escape hatches that you can‚Äôt trust the compiler to the degree you can in say C#. I‚Äôm a TS fan, but it‚Äôs just one of many tools and you need to be aware of its limitations and how people use it.
I agree with that interpretation
Type definitions might go wrong sometimes. A couple of weeks ago, I got a weird bug on CI pipeline because of `@types/jest` version. Someone on the team updated devDependencies and somehow passed the reviews. While I was trying to fix the bug, other team members suffer from failed tests. This is when I feel relieved as it's TypeScript, I just put `@ts-ignore` on those lines for hotfix.
Apollo+Typeorm here, perfect match imho
I feel your pain. Prisma's [Nexus](https://www.prisma.io/blog/introducing-graphql-nexus-code-first-graphql-server-development-ll6s1yy5cxl5) aims to address this partially by going away with you having to write the GraphQL schema strings. There are also packages like `ts-mongoose` ([link](https://www.npmjs.com/package/ts-mongoose)) which allow you to define the Mongoose Schema and TypeScript types in the same place. The downside is that you're adding a dependency and adding more code-DSLs to your codebase.
The lack of runtime type checking is quite frustrating to me, I wish that I could optionally inject runtime type checking, at least at the boundaries of my code. I understand there would be some overhead, but in a lot of cases it would be very much worth it (possibly disable in production). There are some third-party libraries that sort of do this ([io-ts](https://github.com/gcanti/io-ts), [ts-runtime](https://github.com/fabiandev/ts-runtime)), but they are not quite general enough and very cumbersome to use. From what I can tell the [feature request](https://github.com/Microsoft/TypeScript/issues/1573) was closed without much real discussion.
I think you‚Äôll need some code to adapt the schema to the type, but you could take a look at ‚Äúio-ts‚Äù.
This is not possible, and it violates the core principle of generics: It being generic.
I agree, this does not seem possible.
How many more spambots do we need on Reddit? Really?
On that specific sample present on the text: function f(x) { return x / 10 } f(2) f('a') // flow would err here When a function argument is not annotated, Flow would actually check each invocation all the way down, while typescript will just erases it to `any`. Why is it like that? Performance, I'd bet.
By the way composition is a pattern that more or less relies on implementing interfaces rather than on extending a base class. It's more nuanced than this but is the gist of it. This can be done with classes as well.
Looks cool. Typescript is becoming my favorite language. Anyone use it on the server?
logrocket has an awesome blog
yupp, since years. especially cool with nestjs.
Yup, with Hapi.js
Mostly a fix for an old annoyance like set({ color: 'RED' as 'RED' })
What were you using before Nest? Rails? Laravel? .net? Can you compare it with any of those? Does it feel full featured?
Hi everyone. I am a fullstack developer and I have been playing with TS for a few months. It was a tough start but TS really speeds things up with auto-complete etc. Then I started to make GraphQL servers with TypeORM and Type-graphql and they worked together so well that I thought I am using the same library. Now I believe that I am using THE stack for 2019, which is believed as the year of TS. Any feedback/PR would be appreciated!
This seems like something the transpiler should have been able to figure out without more weird syntax.
I can answer here. I come from Symfony and moved to Nest for a couple of projects, I find it very fast and powerful. It has everything I need and for the more advanced stuff (domain validation, cronjobs, etc) you can always use any JS library. I'm only missing the profiler from Symfony but besides that I really like it.
The compiler can't reliably guess whether you intend to rely on the mutability of an object or not, same as it can't figure out whether a `let` you've used should actually be a `const`, so explicit syntax is needed.
Awesome. Thanks!
Every `.ts` file with an `import` or an `export` in it is a module. Doesn't matter if default or not. I think your error is due to the paths not being sufficiently relative. They should start with an './' or '../'.
But the first path alias works fine.
Try: ``` "paths": { "@db/*": ["src/db/*"] "@/*": ["src/*"], } ``` Since `@/*` has a stronger precedence, it may be trying to route `@db/` through it first, and failing because there is no `@db` directory.
Why is the strict flag disabled in the server project?
Still get the same error despite prioritising `@db/*` over `@/*`.
What do you mean?
The strict flag is not enabled in the tsconfig of the server package. Why?
Hell yea :D
I think a better solution than what was proposed already would be: type Nested&lt;T&gt; = NestedArray&lt;T&gt; | T; interface NestedArray&lt;T&gt; extends Array&lt;Nested&lt;T&gt;&gt; { } function flatten&lt;T&gt;(arr: NestedArray&lt;T&gt;): T[] { return [].concat(...arr.map(x =&gt; Array.isArray(x) ? flatten(x) : x)); }
If you're using Apollo GraphQL server then you also have the ability to use Apollo Types which will do the same thing for you. Recommendation: make generation Apollo types part of your build process and do not commit it to your repos, it'll just cause headaches.
It has to assume it. Maybe it is too much assumption. More details on the example above: function set(i: { color: 'RED'|'BLUE' }) { } set({ color: 'RED' }) // errors because 'RED' is inferred as string set({ color: 'RED' } as const) // OKAY // the following also does not work const RED = 'RED' // type 'RED' const obj = { color: RED } // downcasts to string
Cool, been meaning to find out all about Riot, looks very interesting from a privacy and FOSS angle.
This is the first I am hearing of Riot. Is there a compelling reason for using Riot instead of Discord for this sort of public user group where the privacy stuff doesn't matter much? Since I use Discord for a bunch of stuff, I would really prefer to stay with having only one public chat client open.
There's an overlap between programmers and the privacy-conscious. Using Discord has the effect of filtering against some of those programmers, and not to make too broad of a generalization, but in my experience the privacy-conscious programmers tend to also be particularly knowledgeable as well.
There's already an \#typescript IRC channel with a Matrix bridge. Any reason you don't want to use that one?
&gt;set({ color: 'RED' }) // errors because 'RED' is inferred as string &amp;#x200B; This is incorrect. There is no compiler error here. When passing a literal as a param to a function, or when assigning to a var/const or property with a well-defined type/interface, then the type of the param/property is used to interpret the type of the literal, rather than widening the type of the literal.
The error is correct - `HTMLImageElement` does not have a `color` property. Since all types in the union must have the property in order to access it, you get an error. What behavior are you expecting?
I see. I did not configure tsconfig on my own. I just copied some common settings workable for TypeORM and Type-GraphQL. &amp;#x200B; I haven't been aware of 'strict mode'. So what are the benefits of enabling it?
Cheers, but `&amp;` does not work. I thought that would be the case too, but when I replace `|` with `&amp;` I get: ``` public GraphicsAssets: GraphicsAssets = { color: 'red', widthHeight: [58, 25], }; Type '{ color: string; widthHeight: [number, number]; }' is not assignable to type 'GraphicsAssets'. Type '{ color: string; widthHeight: [number, number]; }' is missing the following properties from type 'HTMLImageElement': align, alt, border, complete, and 262 more.ts(2322) ``` by "but I want it to be EITHER the first object OR an HTMLImageElement", I DON'T exactly mean "I want the type to have the properties of BOTH", but if they were all optional that would work I suppose, but it seems they are not. I will try to restate, I would like the property on the object to be an object of this type: ``` { color: string; widthHeight: Vector2; } or GraphicsAssets: HTMLImageElement, ``` The idea is that the game has `GraphicsAssets` that are either vector based, which in this case is a simple object, or an image that I preload in advance before sending it to an object factory. This `GraphicsAssets` property needs to contain either the vector info OR an image.
Cool, that makes sense. The problem doesn't occur until you try to access \`this.GraphicsAssets.color\`, because the compiler knows that if that is a HTMLImageElement, then it won't have a property called \`color\`.
How are you starting your server and what's your build process, are you using any bundling or minification, and if not are you using tsconfig-paths plugin? Typescript itself doesn't resolve these paths, it just makes sure the code compiles. If it's compiling fine then it's probably an error with how those paths are getting mapped when you run the actual code.
I'm getting a lot of use from GraphQL Code Generator. On the server side it produces interfaces that check that my resolvers conform to my schema. On the client side it produces type-safe React hooks for use with [react-apollo-hooks](https://github.com/trojanowski/react-apollo-hooks).
What do you think the best solution is? Cheers!
Those paths don‚Äôt actually overlap/conflict so Oder doesn‚Äôt matter
When you start the server? You mean web pack? Does the error happen with just tsc? Is it an error in your editor too?
&gt;Those prefixes don‚Äôt actually overlap/conflict so order doesn‚Äôt matter Yeah‚Äì I realized after reading your comment that I glanced at their values rather than their keys by mistake.
Hm yeah actually... on function inputs it handles differently, something like that... Cant remember where I last had to do a cast like that but sometimes it happens
I think what you're looking for is what is called "user defined type guards" from the link you've provided. Basically you need to tell typescript what the type is by asserting it in a type guard. Here is a quick and dirty example because I'm on mobile: type obj = { someProp: string }; type objOrString = obj | string; function isObj(val: unknown): val is obj { // You must find a way to distinguish if the given thing is of the correct type return typeof (val as obj).someProp === "string"; } Then later: function doSomething(x: objOrString){ if(isObj(x)){ // Here ts now knows that x is of type obj x.someProp } else { // Here ts knows that x must be of type string since objOrString type is a union of only 2 possible types (obj or string) }
What do you expect to happen when `this.GraphicsAssets` is an HTML element and you try to get the `color` property of it?
First time I read about overnightJS -- this seems neat!
Don't people already know TypeScript tho? Its not difficult to learn.
I start the server using ts-node.
Another template / new project that does not make use of the `strict` flag. :-( Why are people using TypeScript, but then don't make use of TypeScript?
I am working on a nodejs framework for my disertation that uses the "strict" flag. No more "any". Incredible useful flag. It should be turned on by default.
Isn‚Äôt strict automatically handled by webpack
That‚Äôs why, you need tsconfig-paths library. Or just use tsc
No. The webpack plugins for TypeScript will just load the tsconfig as well and use the TypeScript compiler.
Most importantly it will also enable strict null checks. No more "number? null? undefined?", instead "number! no null! no undefined!"
Don't we have this information in [release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html)?
**FUCK OFF WITH YOUR STOLEN CONTENT!**
That would break backward compatibility with JavaScript.
How so? The typescript is transpiled into js for browser/nodejs to run. So, it's just javascript.
We use the strict flag in all of our projects at work. I occasionally have to crack open one of our older projects that doesn't use it and it is a nightmare to work in. I forget how much strict mode does for a project. I've slowly been migrating those projects but some of them are just unwieldy beasts to update to strict mode.
Hi I'm the creator of OvernightJS. Thanks for taking an interest my library. Let me know how things go. FYI I have created a starter template for Express and TypeScript here [https://github.com/seanpmaxwell/ExpressTypeScript](https://github.com/seanpmaxwell/ExpressTypeScript).
But can you transform UML into TypeScript?
Nope
Ah well, maybe version 2.0
I don‚Äôt think it‚Äôs the scope of the project, but thanks for the feedback.
This can be very helpful, but then how do you graphically visualize the output plantuml?
Paste your transformed code here: http://www.plantuml.com/plantuml/uml Next version, the image will be generated directly via command line.
Thanks, I'll try it out!
Adding runtime overhead for design time tooling.. :-/
Can you explain to me how would you improve it? I appreciate your feedback.
I'd just use a marker comment instead of a full blown decorator.
r/swoosh
Here's a sneak peek of /r/swoosh using the [top posts](https://np.reddit.com/r/swoosh/top/?sort=top&amp;t=year) of the year! \#1: [My school loves this](https://i.redd.it/7ufuwfg8rp321.jpg) | [2 comments](https://np.reddit.com/r/swoosh/comments/a5azpg/my_school_loves_this/) \#2: [Swooosh](https://i.redd.it/yvm6s654gf021.jpg) | [6 comments](https://np.reddit.com/r/swoosh/comments/a06l7i/swooosh/) \#3: [Hey guys, here‚Äôs my swoosh](https://i.redd.it/bz8g4bf9ryw11.jpg) | [9 comments](https://np.reddit.com/r/swoosh/comments/9v2po7/hey_guys_heres_my_swoosh/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
You mean the 'use strict' at the top of each file or inside the tsconfig?
No, I mean setting "strict" to true of the compiler options in your tsconfig file. It will enable various other strict compiler flags (which can individually disable if necessary). All these strict compiler flags improve the type safety of TypeScript. My absolute favorite flag is the `strictNullChecks` flag, which causes `undefined` and `null` to be types, additional to being values. As a result you can't return or provide `undefiend` or `null` from a method / to an argument/property when it says `number`. If `undefined` is a valid option, then it must be explicitly declared using a union type like `number | undefined`. It adds so much safety to the compile time level and reduces the amount of "scare snakes" (e.g. `obj &amp;&amp; obj.prop1 &amp;&amp; obj.prop1.prop2 &amp;&amp; obj.prop1.prop2.finalProp`).
Adding strictNullChecks to a project later on is so painful. I have no clear path for it. Either just use the non-null assertion operator everywhere, or introduce helper functions and litter your code everywhere with it, e.g.: function assertNotNull&lt;T&gt;(value: T | null): T { if (value === null) { throw new NullReferenceError("Expected value, got null."); } return value; } Then when using: // previously: someObj.method(...); // now: assertNotNull(someObj).method(...); Once this is added everywhere and the code compiles with the flag enabled you can slowly start to adjust your code and remove the call again. There's a proposal for scope-based assertion methods, but unfortunately it makes no progress and gets no love from the TypeScript team. It would be perfect for this case.
Hmm -- sounds reasonable -- would these flags suffice? "noImplicitAny": true, "alwaysStrict": true, "strictNullChecks": true I didn't know you can use | to define types o.o that seems quite useful
Awesome! Just what I was looking for to create living design docs that wont become outdated as code changes
The "decorators" you're seeing are part of the output plantuml syntax. You don't have to put them in your typescript code.
Noice. This is about to be really useful for me. Any chance this works with react components too? I really just need relationships, don't really care about fields or methods (although showing state and props might be nice).
It only works for native TypeScript code right now. But feel free to create an issue and suggest this feature üòä Just don‚Äôt forget to post an example code and the expected result.
I definitely will when I get into work this morning. I've created similar diagrams by hand in graphviz before and it was a pain. If I could simply generate some nicer plantuml diagrams in a matter of seconds it'd be an amazing tool in my arsenal. I'm expecting to be writing a ton of documentation a few months from now. It might be easier to help this tool understand tsx than it would be to create diagrams by hand.
You'll run into issues if you try to use things introduced in 12, the types will show up but you'll get an error at run-time, or any other changes introduced in 12 won't be in your version of node. It's probably best to use the version you expect to be running but you'll probably be fine either way.
You can collaborate on the project ;)
If you remove the namespace, you can instead do import \* as Dropdown from "..." Then you'll have the same syntax as before, without wrapping your exports in an unnecessary namespace
I submitted my thesis this morning, this could've been useful. (Not really, plantuml is easy to write and it was a one-time-thing, and most what I wrote are state diagrams. It's just the timing thats funny)
Great thanks!
Issue opened: https://github.com/bafolts/tplant/issues/37 I think I'll try to talk to my boss about getting to set aside some time for this at work. I've attempted to contribute to some OSS projects in the past on my own time and I just end up getting distracted or running out of time. If I have time at work and clear goals then I imagine I'd be better at staying on task. I'll let you know if I can. Thanks =)
No one cares about your garbage product‚Äîgo shill somewhere else.
I think getting an error in a strict mode would be an expected behavior as accessing \`characters\["randomString"\].length\` will end up with \`Cannot read property "length" of undefined\` error since \`string\` is a raw type in \`key: string\` index definition.
I sort of see what you mean, but I am not accessing \`.length\`. The original statement that caused the error in strict without the index signature was: \`\`\` Object.keys(gameRAM.characters).forEach(characterGroup =&gt; gameRAM.characters\[characterGroup\].forEach(character =&gt; character.draw(ctx), ), \`\`\` What is a 'raw' type vs a primitive type? Cheers!
Nice! Looking forward for your collaboration (If possible üòä)
This seems like duplication but it really isn't--remember \[\] is basically shorthand for new Array&lt;&gt;(), so how it behaves differs in strict and no implicit any. think of `never[]` more like \[ (never anything in here) \]. By using strict&amp;noany mode, you're basically asking that this type doesn't get widened, so if the compiler did this for you, it would break expectations in other places.
Can we get some pics of sample output?
Input: https://github.com/bafolts/tplant/blob/master/test/Playground/RayTracer/RayTracer.ts Output: http://www.plantuml.com/plantuml/uml/bLNDRjim3BxtANHqiUIm7briAB0UDc0OXhRO3iCEYapRGcNP8EMqMP1tdnI5iRNPyvAB9VwG7_cHoXqvYQvlp9KoaaXy0-LQ5FihuNzlNdDX-sO36A-xzFehlUvzAAVLGJZT06NFh5s9RNwAUys7FpmQRNlAjczPxLrkbdmwSx5BqRevZvbI6bbbsoKZssAJBTQeiALbm8ShRHrWAHM81xbZ8euifO4BZPDUdyA9l5otbjrThMsLYwVmYHAKkpmau5ZapiKTJgFmeJN3961QUvLUDpET8IKDf9CGmrx7xoodNiaTchFdIRl8uQNM3gPL5S9kMhCnKZtFgBocmhQtnRI-W5BsnXrLCoMqzoXVF2z7PQO6_7jnRlgjg8RZPZWU4kOV-_ZTCwbbsPElDkjQEa-QUFT-Z8CwKBsH-6yhXD9unOJHc7Pi-wgsGCG0n-ZYy36sevXYI1x542-PtcWQjakQYTJZPQ1OUiuzE7K0o66xotmpjwqkKg6LZRVtPm-B3SPuF-kgTentb3iAr8ZHOMDyI9JiKxRu8h58_J14JKLzbzoJN0cz2Yma6qsdbVxnCmfD24vvXCv2TGILdy2TiNurqaVJJMUW0UievMUXwHUGECCFmtZiQi1v72WBtTDD-hme2F7pnG7WCf8YykaIXWB2uiNtCdpeLh3cLWpF92zV62BgHij7Oi-r1Pydz39-HDUDVBs7pjL9EMizwXQTSQm41RxpIBj7zLTJrmx8USjPboIB2qZchLUY625BdyyrrRA0J8VaAOuBObJW7g0qqI--TUD_fPKOaRGIF7zy7zReifHVfEjHcl_AjvpDXvTsnq-YBG2pg0xYbL3kzNGYXG3skovSdKW-Gbn_BngUd3iVgM_CRm00
I changed your code a little bit, but this seems to work fine for me: type Character = { draw: () =&gt; void; }; const characters: Record&lt;string, Character[]&gt; = { hero: [], zombies: [], bullets: [] }; Object.keys(characters).forEach(characterGroup =&gt; characters[characterGroup].forEach(character =&gt; character.draw()) ); `Record&lt;string, Character[]&gt;` is `{ [key: string]: Character[] }`, just looks nicer. Now why do you need this? Because characterGroup is a string and not a literal type. `Object.keys` returns an array of strings and not an array of literal types. Now you could do something like this (assuming there's no type annotation for `characters`): (Object.keys(characters) as Array&lt;keyof typeof characters&gt;).forEach(characterGroup =&gt; characters[characterGroup].forEach(character =&gt; character.draw()) ); but then you'd get error that `.draw()` doesn't exist on type `never` (unless you added these `as Character[]` for each field in `characters` again).
It's because the array literal `[]` is the same as `any[]` or `Array&lt;any&gt;`. Also you can replace the object indexed type: `{ [key: string]: Character[] }` with TypeScript's built in Record type which does the same: `Record&lt;string, Character[]&gt;`
Vs code has a plugin (requires you to install graphviz, which is in the debian repos)
If you define a namespace you don't have to import it. Just type your namespace and point to any interfaces in it.
There is a separate tool which is designed to go from UML to various languages. https://github.com/bafolts/plantuml-code-generator
Now, on version 2.3.0, you can already generate the image file via command line.
That's a fast update, lovely!!! Thanks so much!
&gt;: Record&lt;string, Character\[\]&gt; Thanks for the detailed help! I am afraid VS Code intellisense accepts leaving out the `as Character[]`, but the compiler is not so happy: Type 'Partial&lt;Hero&gt; | Partial&lt;Zombie&gt; | Partial&lt;Bullet&gt;' is not assignable to type 'never'. Type 'Partial&lt;Hero&gt;' is not assignable to type 'never'. I will continue to experiment with your `keyof typeof characters` suggestion, nice one!
Just tried the new [2.3.0](https://github.com/bafolts/tplant/releases/tag/2.3.0) image download, works great, cheers!
Well you can tell it. But only if you're absolutely sure. Strict mode is a must. E.g. ``` export function nonNull&lt;T&gt;(v: T | null | undefined): T { if (v !== null &amp;&amp; v !== undefined) { return v; } throw new Error("assertion failed, value is null or undefined"); } ```
You can put it as a type guard: ``` export function nonNull&lt;T&gt;(v: T | null | undefined): v is Exclude&lt;T, undefined | null&gt; { return typeof v !== "undefined" &amp;&amp; v !== null; } ```
definitely use strict mode, it'll save you so many headaches
Yeah, and its not even that hard. &amp;#x200B; IMHO one flag you may maybe consider disabling is "noImplicitAny", while you lose a good bit there, you also gain a lot of flexibility - it has a fair tradeoff depending on your goals.
If you know something must be defined, then the provider of that thing shouldn't be providing something that may not be defined. I've found these couple definitions to be really helpful: ```ts export type Maybe&lt;T&gt; = T | undefined export type MaybeNull&lt;T&gt; = Maybe&lt;T&gt; | null | void export function map&lt;T, U&gt;(obj: MaybeNull&lt;T&gt;, f: (t: T) =&gt; U): Maybe&lt;U&gt; { return obj == null ? undefined : f(obj) } ```
I think `Exclude` is what I've been looking for. This should help a bit, thank you.
My main issue is for example a React class. Let's say you load data to the state asynchronously, so by default it's `undefined`. Now, the component will return `null` _until_ that data is loaded, and so none of the event listeners will ever trigger that expect the data to be defined, and yet still I have to in all of them do `if (!this.state.data) return` (or a million other possible workarounds) even though _I_ (but obviously not TypeScript) know the check is completely frivolous. I guess that's just the price of strict mode though.
You can tell typescript that you know better about nullability of a thing if you use `!` [https://www.typescriptlang.org/play/#src=function%20x(param%3A%20string%20%7C%20undefined)%3A%20string%20%7B%0D%0A%20%20%20%20return%20param!.toLocaleLowerCase()%3B%0D%0A%7D](https://www.typescriptlang.org/play/#src=function%20x(param%3A%20string%20%7C%20undefined)%3A%20string%20%7B%0D%0A%20%20%20%20return%20param!.toLocaleLowerCase()%3B%0D%0A%7D)
You THINK you know it. One of the main rules in software development is: "Don't thrust yourself"
You can use `!` before the `.` to tell typescript you know for sure something isn't null. Eg: `if (this.state.data!) { }` Will allow typescript to compile.
_This_ is what I've been looking for! Thank you (and u/Plorntus too). This should solve about 90% of my problems.
&gt; Don't thrust yourself I'll try not to...
Because your state has fields that the compiler allows to be undefined, those checks are doing useful work in protecting you from bugs that could be introduced by refactors or new features.
I think so. I do just that.
Also take a look at [Objection](http://vincit.github.io/objection.js/#models), as it has really nice, DRY modeling, great SQL-ish query facilities (via KnexJS), reasonable test coverage, and a solution for GraphQL. Disclaimer: I wrote the original typings for it last year when I was looking for a typesafe ORM and didn't like what was available. Moar Disclaimer: I ended up using [knex](https://knexjs.org/) directly, as my model relationships were so simple.
Probably the best thing around for js. You can easily find better ORMs on other ecosystems, but they are not js.
Unfortunately NodeJS has added features in minor releases (see fs.Dirent, released in 10.10), so you'll want to match it as close as possible. Note also that the caret (the default version prefix) in package.json means "latest minor version of that major version," which isn't what you want in this case. See https://docs.npmjs.com/files/package.json#dependencies
We're using it for REST APIs right now.
It's okay. We tried for a one-off, short term site. We found we had to review every migration because it would often generate unwanted junk SQL. It had problems with decimal types I believe (Postgres.) I think from now on I'll just go with pg-promise or knex if I really think I need DB portability.
Yes, you will want to run the TS compiler in 'strict'. The stricter the better.
Yeah, it's fine. I've been using it for a little over a year daily. No matter what orm you use you'll wind up using raw queries for complex stuff (mostly aggregation), but typeorm's query builder is really powerful and can do most things pretty well. One big gotcha, if you do `myRepository.find(myId)` and `myId` is undefined it will return all rows in the table. Make sure you're vigilant with that cause it could easily cause major security issues, but outside of that it's been really great.