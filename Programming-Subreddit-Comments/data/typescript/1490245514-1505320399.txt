JavaScript *was* a scripting language when its only target was the browser. It was literally scripting the way the browser worked. Now it can target browser, every operating system thanks to node, mobile devices thanks to React Native, VR thanks to ReactVR... the days of JS being just a scripting language are long over. 
Is this true? I can't believe I've been coding for x years and never knew this bit of etymology. 
Hence the "most often". :) The line became blurrier as new technologies mixed everything up, but the old names remained.
For me, TS has made front end development much more enjoyable. There's much less mental overhead and less 'stringly' typed woes. The combination of TS and VSCode with @types is gold. I remember writing JS (separately) for IE and Netscape around the turn of the millennium, and though most of my work is app dev these days, I no longer dread JS.
Istanbul is the right solution. Make sure you are using the newer nyc tool found here: https://github.com/istanbuljs/nyc You do not need to use remap-istanbul any more. You can use ts-node to compile the typescript on the fly. For example to run your tests with mocha you run: mocha --compilers ts:ts-node/register tests/**/*.ts To get code coverage you can run: nyc --register ts-node/register mocha tests/unit/**/*.ts 
Thanks, good article :), my concern is I don't want to go with istanbul if it's not going to be supported anymore.
Thanks, we'll take a look :)
I found the solution derp... the interface must extend the interface as well. interface IExperimentOptions extends IFeature { Outcome: Outcome[]; TrialCount: number; }
This is the story I've always been told. I have no citation though, so it could be BS. I *think* back when I first heard it I was told Ada Lovelace picked the terms. But she could be like the Einstein of computer stuff and get all quotes attributed to her.
I don't understand what and why you are doing there.
I'm not asking what function these objects do, I'm asking wtf is going on in your code? Why do you assign argument to instaniated object inside constructor? Do you know what inheritance is?
I'm not asking what function these objects do, I'm asking wtf is going on in your code? Why do you assign argument to instaniated object inside constructor? Do you know what inheritance is?
that function says take the value passed in the constructor which implements IExperiment(thus ensuring the values passed are correct types). set super() (required in inherited/extended class constructors in typescript) and pass those values into my object as long as fields is not null. the objects final form is actually a bit different. export class Experiment extends Feature { public constructor(fields?: IExperiment) { super(fields) if (fields) Object.assign(this, fields); } public Outcome: Outcome[] = []; public TrialCount: number = 0; } export interface IExperiment extends IFeature { Outcome: Outcome[]; TrialCount: number; } if you feel I am doing something off here let me know.
Nice work.
Agreed. The official site alone has such a good documentation I barely felt I had to look elsewhere.
Also I'm learning typescript too!
Random feedback/thoughts while browsing your code. I know TS very well but rxjs not at all, so keep that in mind :) * It doesn't make sense to type a variable as `any | null`. null is a subtype of any, so just use any. * As much as you possibly can, don't use `any` at all. Try very hard to give a type to every variable you have - that's the whole point of TS, after all! * Is there a reason you do Array.apply(null, { length: 5 }) instead of just Array(5)? I have to admit, the syntax was really baffling to me until I realized that you were mocking a JS array with an object. And then when I realized that I was still very confused. :P I dunno if this is rxjs style? * Seeing HTML embedded in strings always makes me sad. I can understand why you were avoiding it, given you're creating your own library, but React and JSX in particular has an AMAZING synthesis with TypeScript. You should try it - if you geek out over static typing like I do you're gonna love it. * I personally find the rxjs style very difficult to read. It might just be me - who knows. Actually I started this thinking I'd have a lot to say, but your code is very clean and sensible for the most part. Nice job! 
Your demos are all so cool! I'd love to see more if you have any. (I'd also be interested in hearing how the flocking behavior works.) It makes me think that codewich would be really cool if it had a list of popular/interesting playgrounds.
I'm currently working on a CLI app with TS too. Far from finished, so don't expect clean code or awesome comments, but here you go: https://github.com/gentics/mesh-cli Cheers!
If you have questions feel free to ask. Especially autocompletion gave me quite a headache.
Well, tbf some of us take time to learn and the documentation isnt clear enough! :) 
Just going to point out that [ts-node](https://www.npmjs.com/package/ts-node) exists and may be of use for something like this.
Just like you'd do a CLI app using Node, only written in TypeScript (of course), and adding `"prepublish": "tsc"`to the `scripts` property in your package.json.
there's always room you just need to have enough users to utilize it I think the 'critical mass' you need for a framework to be worth the effort is a ways off but could be coming with Angular inclusion
[GlimmerJS](https://glimmerjs.com) released today (essentially the view layer of EmberJS) is written in TypeScript.
I've been using it with React. There's been several features in the past few releases that we're obviously heavily influenced by the desire to improve the experience working with React (`Pick&lt;T&gt;` comes to mind instantly, and it makes `setState` something you can type check successfully). `ant-design` (which is a bag of common components and reasonable starting styling for React) is written in Typescript, and that's gaining popularity, so that's another bonus when working in React. I probably wouldn't use React without it anymore, honestly.
expressjs was written back when Typescript didn't even exist! If you're looking for a framework as mature as express, you'll have to wait for a framework written today to mature for as long as expressjs did. 
Casting has never been a problem for me. Can you give an example?
(myRow.querySelector('.my-class') as HTMLInputElement).value = myVal This requires a semi-colon on the prev line or it hard-breaks your code (According to official ES6 docs, semicolons to terminate lines are not required). If you don't typecast, it just raises a TS error since it doesn't think objects returned by querySelector should have the value attribute. Another one: for (let row of tBody.rows) {...} I've found no way to iterate through table rows without Typescript complaining. You get different errors depending on if you don't cast, cast as an array of rows, collection of rows etc. 
For an arbitrary number of rows? How do I do that? TBH I love TypeScript; coming from a Python background with optional type annotations. It's just built-in funcs that return DOM elements that are tripping me up. With your own funcs, you can control the output type, but TS doesn't seem to handle Element-returning builtin funcs elegantly.
According to Mozilla's docs: https://developer.Mozilla.org/en-US/docs/Web/API/Element/querySelector **Element::querySelector()** can return any **_Element_** among the dozen in existence: https://developer.Mozilla.org/en-US/docs/Web/API There's no way for any language, even strongly-typed languages like Java, to guess which 1 would come out of **Element::querySelector()** at compile time! Most of the time, such elements aren't even created inside JavaScript, but inside an HTML file. TypeScript would also need to become an HTML language transpiler in order to be aware of what is created inside ".html" files! 
make a custom component that handles the rows the way you want them, then loop through a collection of rows in the dom. 
Semicolons to terminate lines *are* required in some situations. That's always been the case and is still true in ES6, per the ES spec. You can google for a description of the various situations and how to handle them.
I feel like the releases are fast enough given its up to date re esx specs.
Looks cool!
Might have to do that. React looks great. edit: Trying this approach now!
I use moduleResulution: node and yes, I have installed @types/lodash. The problem I have is reproduced in the github issue I linked in my initial post and the given solution is either a) use an older version of TypeScript or b) set skipLibCheck: true; both of these seem like really shady fixes for loading such a popular library as LoDash.
Typescript does support method overloading! You just write all the type signatures separately, and then handle them in a single function. That's how things like createElement("canvas") can actually return a canvas element, and createElement("div") can return a div, rather than both of them returning a generic typed HTML element. 
What version of TypeScript and @types/lodash are you using? It works with the latest TS and type declaration. npm init npm install --save @types/lodash npm install --save typescript PATH=$PWD/node_modules/.bin:$PATH tsc --init # Add "moduleResolution": "node" to tsconfig.json # Create index.ts, which uses some lodash stuff tsc -p . # No errors; everything works
I edited my original answer with the preferred way to setup Phaser; no dirty workarounds required. Let me know if you run into trouble.
[removed]
You shouldn't assume node use...
More importantly, how did you get that many people in a room at 4:33pm (and presumably earlier)?
My advice would.be don't use an angular seed. Use the cli. Assuming you are talking about angular and not angularjs that is.
This sounds a lot easier than manually searching through the release notes each time. Thanks for taking the time to make this! I'll try it out tomorrow.
This is cool! You can also use VSCode's code completion. Hit Ctrl-Space / Cmd-Space and it'll show a dropdown list of all the rules that aren't already in the file.
Oh wow if I knew that earlier, I might've been too lazy to write this ;-). I guess this is part of the tslint extension? It definitely lacks some functionality (e.g. the list isn't up to date and it doesn't include many custom rules)... will look into it - thx!
VSCode can offer autocompletion and error-checking for any JSON file based on a JSON schema. This means that extensions can provide schemas automatically, you can specify schemas in your project's options, or you can specify them per-file by adding `"$schema": "&lt;url or path to a schema file&gt;"` to your JSON document. In the case of tslint, the extension declares it in its package.json: https://github.com/Microsoft/vscode-tslint/blob/master/tslint/package.json#L127-L132 (official VSCode documentation: https://code.visualstudio.com/docs/languages/json) I guess the tslint project is responsible for keeping that schema updated? If it's out-of-date then your tool appears to be a better option. 
Fascinating - TIL! The tool could be adapted to list all the rules that aren't in that schema and one could update accordingly. Might be another evening project in the nearish future!
Come on, shows that our Grand Architect is a man of the people as well!
Something tells me you are not perfectly happy with the results
I am, After the first few hurdles it's now quite tolerable. Basically, I have a single code base and use webpack to generate both index.android.js and index.ios.js files. I'm really disappointed these have to be in the root of the project. Using native base has helped a lot. Some of their .d.ts are a little strict on some attributes but everything will still compile. Using typescript has saved me plenty of headaches with react native I would have spent hours trying to debug. I can probably create a little boilerplate if enough people are interested
Thank you. Would you mind sharing your tsconfig.json? I'm unable to get imports working in Typescript: I get 'Uncaught ReferenceError: exports is not defined' when importing npm modules.
sounds like you need to install `@types/node` and/or specify node module resolution see if this helps: https://pastebin.com/ZAnWagsX edit: `npm install --save-dev @types/node`
I'm still in the process of converting this boilerplate all the way to typescript but this may inspire you as I don't have any simple examples laying around. https://github.com/StrikeForceZero/react-typescript-boilerplate
You should really look at flow. React native is flow typed and most of its libraries are too. You can also get the better of the two by using VSCode which will provide you with typescript autocompletion for imported modules. Then add the flow extension for flow autocompletion.
It still haven't been able to write anything that interacts with browser APIs in typescript. The compiler always complains that something isn't defined, even with browser types installed.
Curious, what doesn't work for you? TypeScript includes types for ES5 and the DOM by default.
I forgot the exact error message but after adding every type I could think of and defining the remaining ones manually it gave me some error that I couldn't find any reference to on the internet so I eventually gave up. If I try again I'll post any errors here.
99% of the time I can find a module on DefinitelyTyped that works for my needs
Not yet. Not sure if /u/DanielRosenwasser has any updates, but this explained the situation recently: https://blogs.msdn.microsoft.com/typescript/2017/03/27/typescripts-new-release-cadence/ &gt; However, when Visual Studio 2017 RTM released a few weeks back, we were not able to include the latest TS version (v2.2) with it. Instead, Visual Studio 2017 currently comes with built-in support for Typescript v2.1.5. &gt; With the changing cadence of TypeScript releases, we could not fully align the TypeScript v2.2 release with Visual Studio 2017. Given some key changes that have gone into the new setup authoring process for Visual Studio 2017, we need to do additional work to ensure that TypeScript releases can be applied to Visual Studio 2017 at a faster cadence as users might be used to in Visual Studio 2015 and VS Code. &gt; We’ve heard feedback from several users about their need to move to TypeScript v2.2 in Visual Studio 2017 and understand the confusion and pain this has caused. As a team, we’re actively working on the problem and hope to have a fix available soon. We’ll keep the community updated as we make progress. Once implemented, developers will have full flexibility to update as soon as a new version of TypeScript is available. We apologize for the confusion and want to assure you that fixing this issue is a top priority.
Same. The issue seems to be that TS doesn't recognize that element-returning functions can return different types of Elements; it flags properties that aren't part of generic Elements.
If it has more than 1000 stars on Github, almost 100% of the time. Less than that, it's a little flakey.
I totally love it. I gave it a go for a microproject (a prototype if you wish) and I'm really amazed by how it looks. Hoping to see more!
[This by pleerock](https://github.com/pleerock/routing-controllers) is very similar, I've used it and coming from java it feels way better with decorators than writing `app.get(url, (req, res) =&gt; {...})`
Can someone explain to me what I am looking at? :)
You can use object spread instead of `Object.assign`: `{...old, ...updates}`. The type signature of your function is still helpful if you want the `Partial` constraint, though.
Well, that's the point of it, isn't it? Statically, TypeScript can't know which type of element is being returned. *You* might have that knowledge from a side-channel, though, e.g. you know (by looking at your HTML) that `document.getElementById("foo")` always returns a `&lt;table&gt;` tag. In that case, you can use a type assertion to tell the compiler about that: ``` const table = document.getElementById("foo") as HTMLTableElement; ```
Alright, thanks for the information! I'll see what I can do with this since you confirmed my singleton theory. Most of all that doesn't apply to me since my framework isn't inversify related in the slightest but I should be able to work something out with regards to this logger situation.
Of course, `document.getElementById()` could be typed to have a return type of `any`, but then you're losing the advantages of a static type system — you're back to JavaScript mode and everything goes. For completeness' sake, you could either add an `as any` type assertion or encapsulate the call to `document.getElementById()` in a function with a return type of `any`.
I looove inversify. Use paths in your TSconfig to fix up those imports though :)
We use https://github.com/sequelize/sequelize-auto to generate the repositories via introspection of the database. We are working on types support for sequelize-auto at the moment we have to import JS files and manually declare its type definitions. 
I see what you're getting at, but I think that would be a bad idea. The type system would be lying to you in that case: not every HTML element has a `value` property, therefore TypeScript shouldn't suggest that this property always exists.
"Fira Code"
The speaker added a lot of unnecessary pauses in his speech.
This code looks a little bit verbose.
Not once, but twice. And not jokingly I might add. 
Yes please do! I plan to get there eventually. React Native seems prime for a Typescript takeover.
If you drink the jetbrains koolaid (intellij, webstorm) you get all the same benefits and then some
The app is private but there will be some open source example available soon you can keep an eye on https://github.com/inversify/InversifyJS/blob/master/wiki/ecosystem.md if you are interested
I'm just starting out on a React Native, TypeScript project. Is it conventional to not specify the return type for these stateless functional components? Or it's not considered a big deal?
Which function in particular are you referring to @demonizah?
OK I get it. that returns some jsx. See: https://www.typescriptlang.org/docs/handbook/jsx.html By default the result of a JSX expression is typed as any. You can customize the type by specifying the JSX.Element interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box`
Hmm, well the question came to me when I saw that the [React typings](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts#L205) come with a type called `StatelessComponent&lt;P&gt;` or `SFC&lt;P&gt;`, which seems to be needed when specifying something like `defaultProps` for the component. I was trying to incorporate that into a project, but got compiler errors that I couldn't figure. I describe that issue here: https://www.reddit.com/r/reactnative/comments/64cuvg/using_typescript_what_is_supposed_to_be_the/
If I understand it right, you wouldn't want `globalColors.link` to be modified. But with the object literal there is no way you can tell TS (as far as I'm aware) that `globalColors.link` is a constant. You do have two other options though, making a class with `static readonly` attributes, or an `enum` [examples](http://www.typescriptlang.org/play/index.html#src=class%20B%20%7B%0D%0A%20%20%20%20static%20readonly%20link%20%3D%20%22%23302012%22%3B%0D%0A%20%20%20%20static%20readonly%20byLine%20%3D%20%22grey%22%3B%0D%0A%7D%0D%0A%0D%0Aexport%20namespace%20C%20%7B%0D%0A%20%20%20%20export%20const%20link%20%3D%20%22helo%22%3B%0D%0A%20%20%20%20export%20const%20byLine%20%3D%20%22blue%22%3B%0D%0A%7D%0D%0A%0D%0Aenum%20D%20%7B%0D%0A%20%20%20%20link%20%3D%205%2C%0D%0A%20%20%20%20byLine%20%3D%2010%0D%0A%7D%0D%0A%0D%0Aconst%20E%20%3D%20%7B%0D%0A%20%20%20%20link%3A%2010%2C%0D%0A%20%20%20%20byLine%3A%2020%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Not%20authorized%0D%0AB.link%20%3D%20%22%22%3B%0D%0A%2F%2F%20Not%20authorized%20either%0D%0AC.link%20%3D%20%22%22%3B%0D%0A%2F%2F%20Neither%20this%0D%0AD.link%20%3D%2020%3B%0D%0A%0D%0A%2F%2F%20This%20is%20however%20authorized%0D%0AE.link%20%3D%2030%3B) In your case, I think a class with static attributes would be better suited (enums only accept numbers)
Thanks, I didn't think about the immutability, that's an extra advantage of namespace. class with static attributes seems like a heavier namespace, but I guess it achieves the same thing while being more ES-ey. I wonder if there's any benefit to them rather than just a namespace. Especially if your namespace does have some computed values, ie: export namespace GlobalColors { export const link = '#502012'; export const byLine = 'grey'; export const authorLine = darken(link); } 
I was confused by this because I've been using @types/mithril for a while now. To clarify, it appears that the mithril project itself is now hosting the defs which are now being referenced by the @types/mithril project. This is good because the types will now no longer be out of sync with the mithril version you have installed.
The previous types were for Mithril 0.2. Mithril 1.0 is a re-write (but the API should be pretty stable now moving forward.) The types are maintained in the DefinitelyTyped repo.
Ahh dammit, that's right haha. That's supposed to get fixed at some point..
Mapped types Discriminated unions Optional types Union types 
This is my first Typescript project so I'm sure I've made a few howlers. It's a toy project to test out the language and workflow. So far, after a rocky start, I quite like it. Any feedback on how I could do things better is welcome.
I use [jscpd](https://github.com/kucherenko/jscpd) for this, there's a VSCode plugin that works well too.
--strict flag, yay!
Seriously, what the fuck is up with this stupid trend of having pictures not related at all to thing being discussed in the software community (books, articles, etc...)? Please, tell me, what the hell this header image does for the article except waste by bandwidth (2.67 MB to be exact -- which is *way too* big to be on a website. Simply compressing it gets it under 1MB)? 
We went about implementing typescript the same way, it doesn't have to be all or nothing. I'd recommend typescript to any js or .net developer. More and more dev teams are going over to it, it's worth your time to at least look into into and have a play around! Edit: Also yeah, that image size is insane. 
Not sure about the typescript support, but check out jsinspect: https://github.com/danielstjules/jsinspect
I use it and am in the process of writing a very detailed tutorial of one way to write said apps: https://lapanti.github.io/ts-react-boilerplate/ I'm aiming to complete the first version by the end of this weekend, but until then that should get you started :)
Not a feature of typescript itself but it allows IDEs to do autocompletion.
It has types. Types are nice, hence we use it...
Thanks, that book is awesome. There's a PDF version as well. 
Sorry for that. [This](http://blog.mgechev.com/2016/08/14/ahead-of-time-compilation-angular-offline-precompilation/) is what I meant by the use of angular on the server. It is convenient for full stack angular developers the use typescript all across the board due to the lack of context switching. Google wants to move web apps as much as they can onto the server so that they can compete with native app performance and have nearly instant initial page load times.
It's not a new trend, I've been doing it for quite some time and it's definitely superior to ES6 in most use cases.
TypeScript on backend is amazing
See what I did there?
What's the advantage of this compared to extending a class or implementing an interface?
What does this have to do with TypeScript on the server?
Just found this while trying to find a tool I could use to share TS snippets. I am running into an issue where I'm unable to edit my code. No obvious errors in the console. (Mac on Chrome.) Would love to help debug if you have any suggestions. I'd also love to see some sort of 'Run' button so I can trigger when the code should be run. This I'll put in as an issue on GitHub. Otherwise, great start!
What if I go `adjust(33)`? You've defined this function as working for all types `T`, but `p.hello` is only compatible with one type, `string`. 
Ohhhhh ok
The *hello* property of *g* is type string, not type *g*. Since *adjust* has closure over *p* and mutates it, it's not a generic return type, it's just a regular one. The return statement is also of type string -- you must return *p* on a separate line to return the object reference rather than the value of *p.hello*. function adjust(arg: string): g { p.hello = arg; return p; }
Ohhhhh
If you're using middleware to attach custom properties to the request object, you can always just augment the type definition to include your property. If that's what you're getting after.
http://stackoverflow.com/questions/43429574/how-can-i-handle-type-with-middleware-of-express Could you check this question? There are some example code.
Yeah i ended up realizing it after. major boo boo
I double check i get a linting error still, cannot find name 'GraphQLObjectTypeConfig'. However it works so i can live with it.
It's a reference to the graphics on the Typescript homepage: http://imgur.com/a/pX4w4 But yes, this pattern is silly in general
Nice, this looks awesome. Is it safe to say that Swagger/OpenAPI is just not compatible/useful with GraphQL? I would assume not since Swagger describes RESTful APIs. I've done a lot of work making tools to keep APIs and client code sync'd up, and it is possible to do this cleanly, but ultimately there is that difficult challenge of expressing complex queries in an API call. Evidently GraphQL just does it better.
I dont have the answer to your question and just asking. Why avoid classes in the first place? I haven't heard that. 
Classes are meant to pass both behavior and state. If you're only passing behavior, then classes are too blunt a stick. You'd want just plain functions, probably namespaced or modularized, both of which javascript support fine. If you're only passing state, then use some structs or maps, again, great with what we call JSON. There is then a secondary concept to prefer composition over inheritance. Composition gives you code reuse. Inheritance gives you code reuse + hierarchical exension. Once again, this is too blunt a stick, when the majority of problems call for code reuse, but only a minority of problems call for that strict inheritance tree. Now, for a javascript-specific concept, javascript is built on prototypical inheritance, not classical inheritance (as in based on classes). ES6 changes the syntax to make it look like you're using classical inheritance when really you're doing prototypical inheritance under the box. Therefore, there's an argument to be made that you're working against how the language was designed, just to make it easier to use for those of you coming from classical inheritance languages like C++ and Java.
VS Code (default dark)
Classes mostly fit with a programming style that is somewhat getting out of fashion in large parts of the Javascript community, namely that of encapsulating state in classes (e.g. with private members) that expose methods to modify that state. Many people have instead transitioned to a style that favours immutable data passed into functions that return new immutable data, using that as a way to represent changing state. The latter style is suited very well to use with TypeScript, but... The former is too :) tl;dr Depending on your (or your team's) programming style, you should or should not avoid classes, and that's mostly independent of TypeScript.
For what it's worth, VS Code is open source, so you can take a look for yourself on GitHub. There are classes in nearly every file. In fact, they use interfaces heavily in the design as well, which don't even compile to JavaScript (they are strictly a design-time constraint). Using classes in TypeScript gives you the side effect of having very strong type safety during development. Sure, true classes and private members don't exist in JavaScript, but they don't exist in IL or Assembly either. And we use high level languages like C# to provide safety at design and compile time (the runtime can be type aware as well, such is the case in .NET, but I'm referring just to the language in this case).
Classes enforce object shape, which is important for performance. The relevant concepts are [hidden classes and inline caching](https://github.com/v8/v8/wiki/Design%20Elements#fast-property-access). Performance is a major reason why Google's proposed replacement for js, [Dart](https://www.dartlang.org/guides/language/language-tour#classes), as well as [ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), both introduce classes. Ideally interfaces should be used as contracts to be fulfilled by classes that implement them. Edit: Better link for elaboration on hidden classes 
Classes (or objects) have never been bad. Inheritance, on the other hand, is a different story and should be used sparingly in favor of composition. 
Classes and immutability are not mutually exclusive. Value types or scalas case classes are a good example.
It can be nice to use classes just to have read/query/format methods on object prototypes. Mutation methods can clone the object rather than modifying its state. Obviously the same can be accomplished with regular functions, but I don't think immutable classes are that unusual in JavaScript.
PHPStorm (or WebStorm) with TypeScript is amazing. Also, I started reading definition files instead of / in addition to docs. So I'd call that a feature, too.
I think the question is why Typescript even allows this: class Foo { bar: string = 'abc'; Probably as a familiar convenience, but with potentially confusing behaviour.
Well, during the construction of child, the child is actually a fully instantiated, real-life, completely constructed Base before it becomes a Child by the addition of all of the Child related functionality and attribute state. Therefore, the child is not fully a Child until the constructor (which is a plain function) for Child is finished executing. Any code that is executed in the Child constructor needs to be aware of the fact that child is not fully a Child until that constructor is finished.
Here are the typescript files: https://github.com/sysrpl/Codebot.Files I'll add the C# file backend after I remove my salt and private keys, and denote to other people that they need to add their own salt and private keys. For the curious, here is what the file with main() looks like: https://github.com/sysrpl/Codebot.Files/blob/master/app/manager/manager.ts
VS 2017 currently has some shenanigans related to TS compiler versioning and you might be affected. Their new Preview build was made available today or yesterday, it should have fixed it. Other than that, try unquoting names in TypeScriptLib. For example try setting it to es6,dom
TS is "JS (ES2017) with types". Perhaps a better question is why types are a good idea. That is a very good question and there are some very important answers to it. It is worthwhile to dig into those answers.
I meant it more as in you shouldn't use javascript but my wording was awful.
Because it is a horrible language that only won by being first to market, not because anyone actually thought it was a good idea.
I don't get how you expect it to work as such. Setting the value of a member in the property definition is syntactic sugar for setting it in the constructor AFTER any super() call that takes place. That is, super() is run BEFORE you set the value. What's hard to grasp about this? If you need this value to be set in the base, make it a constructor argument of the base class, and pass it to super() in the constructor of the derived class. I fail to think of any language that this behavior is different. 
Then you don't know why use typescript 
Actually it wasn't first to the market. I'm not sure exactly who that honor belongs to but if nothing else coffeescript was around before typescript. One of the defining features of typescript was that it is a super set though. Which meant not having to learn a different language than js but just having to learn how to add a type system to it. This move is what made typescript popular. It's arguable whether it's more popular than flow due to first mover advantage though.
The name calling is my point.
use the allowJs flag and you can pass js through tsc
that's the first thing I tried, it doesn't seem to use the .d.ts files
noEmitHelpers
This is precisely the issue that the `--importHelpers` compiler option solves: https://blog.mariusschulz.com/2016/12/16/typescript-2-1-external-helpers-library
Here's a [barebones example](https://github.com/spacejack/mithril-fractals) that uses tsify (browserify) so you can bundle your app and 3rd party npm libs. It uses watchify to recompile on file changes. [This example](https://github.com/spacejack/mithril-tutorial-ts) does the same and adds sass compilation. Both will output minified bundles when you run `npm run build`. All scripts are in package.json, no gulp needed.
Just published a test version in Chrome Web Store. Join our test group to try the first build: https://github.com/lpimem/hlc#install
the classes in the example are equivalent to this: class Base { constructor() { this.myVar = "Child"; console.log(this.myVar); } } class Child extends Base { constructor () { super(); this.myVar = "Child"; } } so when constructing `Child`, the `Base` constructor initializes the `myVar` field and logs it before `Child` overrides it my personal opinion on class fields: i think how it adds the fields to instances is a mistake and the fields should be added to the prototype instead, just like methods. the constructor should be used for adding stuff to instances
https://github.com/apollographql/apollo-client/issues/713 you need @types in deps for project deps, if you publish the package, things will screw up for other consumer otherwise. The time you put @types in devdeps is ,... it is only devdeps, should have thought about it. just move it yourself, I don't install stuff with flag anyway. 
I'm not sure how rest params (which, btw, are JavaScript and not specific to TypeScript) would even help you here. If you want to take either an object or an array, it doesn't seem that you want to actually make a vargarg function. Where TypeScript can help here is in type-narrowing and checking your argument type for you: function someFunc(a: number|number[]) { if (typeof a === 'number') { return a++; // type-narrowed to number } else { return a.length; // type-narrowed as number[] } } 
There's the func(obj: ??): *obj is type* {} return signature that, when used, will automatically type the object within an if clause, with the else being the other. https://www.typescriptlang.org/docs/handbook/advanced-types.html under "user-defined type guards" I use a generic function to handle most cases of this: coerceTypeFromUnion&lt;TrueType, FalseType&gt;(obj: TrueType | FalseType, coercer: (obj: any) =&gt; boolean): obj is TrueType { return coercer(obj); } Although it sounds like you want a generic function like: function doSomethingWith&lt;T, V&gt;(target: T, value: V, options: optionsType): ? {} Or function doSomethingWith&lt;T extends *whatever*, V too&gt;(target: T, value: V, options: optionsType): ? {}
I don't have a Typescript specific suggestion, but a general one: just take number[] in those cases -- the single number is an edge case with no real distinction​. I actually do that in any language where it wouldn't be PITA for the caller. For example, in C and similar languages, the caller can cast a reference to a variable to look like a single element array. In languages like JavaScript or Typescript, it's trivial to create an literal array at the call site containing a single variable. Languages​ like Java are (for now) exceptions ... there I default to the array (or Collection or List, if more appropriate) version, and provide and overload if the single value case proves common enough.
webstorm
Code is a godsend. 
TS support in all editors is backed by TSServer. So they're mostly the same.
go for vscode
I've done both and VS Code is a definite winner here. Like you I had used Atom for a good while (1 year+) and I tried all their TS plugins and tried to finagle it. In the end, TS just struggled with the compiler features and different interactions with the Atom editor, plus Atom was super slow. I would definitely try out VS Code, it is built for TS, lightning quick, and just has such a better UI/UX overall.
Used both but recently switched to Webstorm and prefer it
My experience of atom is, it's shit. Way slow. i would just use vim and plugins for lightweight non ide. I use webstorm though because it's actually good. I used vscode a while back but vim was better with plugins, things may have changed.
I'm not saying I couldn't afford it, just that the value wasn't there anymore.
? ts-node isn't necessary
Thank you guys. My mistake was trying to perform import/export like with plain es6. After removing exports and imports everything worked like charm.
Recently switched from sublime to vs and love it! Only two things suck ass: Can't rebind mouse events And there is no search &gt; select all feature that inserts multiple cursors through the document. 
Ctrl+Shift+L
&gt; I moved away from Webstorm when they changed their pricing model, I hung in there for a while, then code came along so no reason to hang in any longer, I miss the git integration, was awesome, but the pricing model change was a let down for sure.
I just tried out code after all these positive reviews. I was blown away by how fast it is. Atom seems way slower.
Til. Thanks!
&gt; And there is no search &gt; select all feature that inserts multiple cursors through the document. I am sorry, you said vs, not vs code
TS is a superset of JavaScript, all ES2015 constructs are supported AFAIK and some ES7+ ones (async/await and async generators in 2.3 IIRC) Heck, you should be able to rename an ES6 file's extension from js to ts and the typescript compiler dog work with it fine.
Linter usually catches that for me. https://palantir.github.io/tslint/rules/no-unused-variable/
Oh I guess I need tslint? Right now I have eslint. Can both be used at the same time? 
Add `noUnusedLocals: true` and `noUnusedParameters: true` to your tsconfig.json
That did it, thanks! What other recommendet linting rules are there for typescript? 
Read the "TypeScript Handbook" and Basarat's "TypeScript Deep Dive." The former is from the TypeScript team; the latter is the single best supplement to the official documentation. I seriously can't recommend it enough. It's the best bang for your buck. Short, clear, to the point. (I'd include links but I'm on mobile)
What code do you think you'd be repeating 
Thumbs up on the article. It's something I try to express to a lot of people. :) Instead of "closed loop" I would just say "fully typechecked." I understand the desire for a new term though, because there isn't really anything that fully expresses what you're tying to say. 
For what it's worth, Atom etc are using the same analyzer. It's the same deal with Dart. All of the good plugins are simply using Dart's analyzer for the heavy lifting. Anyhow, VS Code is a complete package which does pretty much everything you need out of the box. The Sass support, for example, is also really great.
typestyle is by far the best way I've found. It's similar to styled-components but strongly typed and a pleasure to use. Works for SSR too. http://typestyle.io/
Not exactly, but you can download addons to tslint to include the eslint rules not already included in tslint. Lookup tslint-eslint-rules on npmjs.com You can't run eslint against ts code as eslint won't be able to parse your typescript.
I just did a talk about exactly this! See the code in the src/ directory- https://github.com/bcherny/Talks/tree/master/Incrementally%20Typing%20Angular. I started with a javascript+Angular app with a handful of bugs, and gradually converted it to a React + TypeScript app where all of those bugs were caught at compile time.
IntelliJ.
Thanks! Rx + TypeScript works great - no complaints.
 import { Router, Request, Response, NextFunction } from 'express'; const router: Router = Router(); router.get('/', (req: Request, res: Response) =&gt; { res.json({msg: 'Genre index route'}); }); router.get('/add', (req: Request, res: Response) =&gt; { res.json({msg: 'Genre add route'}); }); export = router; all the routes and schemas will be the same, excepting only the collection name they have to query.
Look up "route parameters"
This is perfect timing. I was discussing converting a project at work to using typescript just this afternoon. We decided it was too late in the life cycle to switch for the benefits. Today's announcement fits the bill perfectly
If one where to use js with the comment tagging, could one export declarations from that? Say you write a js live and want to export D.ts from that.
The comment look similar to jsdoc to me. Someone could easily then create a d.ts file of any properly documented js library with out having 3rdparty tools for instance
But why create a .d.ts file when you already get that typing from the js?
You can move the `Item` type to a `.d.ts` file or a `.ts` file without any import/export statements. That way, your `Item` type is available within your TypeScript project without you having to import the type explicitly within each file.
With the code I have shown, I can get the `Item` type throughout my app. I wanted to know whether what I have shown above is the correct way or not. I am not aware but does `.d.ts` file contents/types are made available globally? If I export my `Item` interface from a `.ts` file then I would have to import it otherwise, how would it be made available globally, right?
Your code above is not the idiomatic way to define types within your TypeScript applications. It works, but it's neither the briefest nor the recommended approach. If you have a `tsconfig.json` file within your project, which you typically do, the TypeScript compiler will pick up on `.ts` and `.d.ts` files by default in the same directory and directories nested underneath. That way, your types are available throughout the entire project. Once a file turns into a module through an ES2015 import or export (or both), you have to export (and import) your type definitions as well, correct.
https://www.gitbook.com/book/basarat/typescript/details Agreed, this was the single most useful resource for rapidly getting up to speed with typescript. The author is excellent at communicating without been wordy.
I'm pretty sure that for various reasons, probably performance, the compiler assumes that the AST is immutable. The compiler's own transformation-based emitter works by substituting nodes for new, synthetic ones, but with a reference to the original node. You could probably look at the source for the [compiler's own transformers](https://github.com/Microsoft/TypeScript/tree/master/src/compiler/transformers) to see how they mutate the AST. None of these APIs are public yet, but you might be able to use them via something like [byots](https://www.npmjs.com/package/byots) 
Basarat has done some amazing work on bringing first class typescript functionality to the ecosystem. Typestyle is fantastic.
&gt; The rule is roughly that any code expecting a superclass instance should be able to receive a subclass instance and still work correctly. [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle) &gt; *Substitutability is a principle in object-oriented programming stating that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of T (correctness, task performed, etc.).*
Does it even matter if TypeScript is not a standard, at least when WebAssembly becomes widely supported by all browsers?
Thanks, My terminology may be wrong. There's a bunch of ambient JS code which I have typing for. "Module" may have been the wrong word, and I can't be sure it's a "class", but it's certainly an object, and has a matching Typescript interface. I looked into decorators based on your post, and they definitely seem the "cleanest". Unsure if decorators can be applied to external typings, though
Nice! Will this works for just plain objects/interfaces? say the external typing: interface A { echoString(s: string): void; // console.log(s); } I don't "create" object A... I request it or get it passed in. I want the following to transparently happen: function doThing() { const myA: A = SomeAmbientJS.getA(someArg); // normally this next line would output "hello" to the console myA.echoString("hello"); // &gt; "hello" // I'm hoping to make it output something additional, such as: // &gt; "Echo String called with argument hello" // &gt; "hello" } Obviously the actual object is more complicated than this. I want the object to be used as normal in the code, but I want to intercept calls to it, first, and something
Found the answer to the question myself in the docs: &gt; A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a declare class).
Why not inject an override when you receive the built object? export function getWrappedA(obj: A) { return { ...obj, echoString: (arg: string) =&gt; { console.log("hello world"); return obj.echoString(arg); }, }; } ... const myA: A = getWrappedA(SomeAmbientJS.getA(...));
would lernajs help? https://lernajs.io/
Hey there, just wanted to drop by to say that I disagree with most of /u/jonwah 's criticism. I mean, (s)he's right in that you've written this thing in a bit of a unconventional format, and if you'd taken all those suggestions to heart, it would have been a post exactly like every other post about a language feature. But I liked the white with a bit of colour, hey why not! And I liked to follow along in the process of how you learned about this feature. As a newbie to the language, it's nice to learn some of the tricks of learning about APIs. Oh and about the intro, am I the only one who just glazes over when I read those things? I can never make sense of what people are talking about until I can see some actual code anyway. But maybe that's just me. Jonwah has a point about the naming, but whatever, I thought this is a great post, keep it up!
Typescript will merge the declarations 
Why do you want it to fail? Having extra properties doesn't change anything, you still have an object that respects the interface.
Here's an example of the freshness I'm looking for, but at the argument level rather than returns: function test(foo: Car): string; function test(foo: Boat): string; function test(foo: any): string { return '1'; } test({name: 'foo', isForRacing: true, power: 2}); // Goes through. test({name: 'foo', power: 2}); // Rightly fails test({name: 'foo'}); // Goes through 
Thanks for the encouragement!
I'm happy enough (more than happy) with the quality of the JS that typescript outputs, if TypeScript went away tomorrow I'd just generate the output with the version I have and base on that. Since my projects are a mix I already end up piping TS -&gt; ES6 -&gt; Babel anyway and that works fine.
Not working for me either, I'm getting `Uncaught ReferenceError: monaco is not defined` :/
Yeah not working for me -- I actually tried to take to twitter but I'm not getting much traction lol https://twitter.com/SantiCmusic/status/859437925070721024
Can I somehow cast using JSDoc? I use the new --checkJs feature to quickly check my code for errors and I get heaps of `Property 'value' does not exist on type 'HTMLElement'` because I can't figure out to tell it that it is a HTMLInputElement.
As far as I can tell, Vue/Vuex integration with TypeScript is not fully baked yet. There are several ways to use decorators with Vue (e.g. https://github.com/vuejs/vue-class-component). When comparing this to React/TSX, I come out strongly preferring React. With typed props and strict TypeScript settings (strictNullChecks, noImplicitAny, etc), it's really a totally different world than any other (JavaScript-based) UI development.
VSCode's ATA installs types locally on your file system, but if someone else is working on the same project using a different text editor, they will not have the luxury of automatically installed types. ATA is nice for quick prototyping and for JS files, but for any committed code, make sure that the corresponding @types/abc are also listed in your package.json's devDependencies. &gt; Does it use the same global cache VS ATA uses? Yes - All TSC servers controlled by VSCode share the same ATA cache.
I could test it, but I'd also like to know what the typescript team / vscode team recommend as a best practice. They don't seem to comment on it anywhere.
Daniel from the team here! Types are installed into your project's node_modules folder and are resolved the same way as if you installed them yourself. Like the parent comment mentioned, ATA can be great for prototyping but it's not a great idea once you're ready to commit code. You want to have consistent and reproducible builds, across your coworkers's as CI's machines. To do that, you'll need to save your types to your package.json dependencies and/or devDependencies. 
&gt; Daniel from the team here! Types are installed into your project's node_modules folder and are resolved the same way as if you installed them yourself. I assume you are referring to types installed via npm install @types/, not ATA? 
It's working fine for me.
I'm going to comment on the interface. interface IPost { id: Number; name: String; email: String; body: String; } const posts : IPost[] = [ { id: 1, name: "John", email: "test@test.me", body: "blah blah" } ]; 
It's good practice to "implements" interface to class. class Point implements IPoint {}
Actually struggling with this for a couple of days as well, I would really appriciate some help
A huge amount of information to go through, great job and congratulations on reaching the final release milestone!
If you test them in your use case and they work, why would you feel bad about it?
Yeah, basically this. Experimental flags mean they can drop or change the implementation details at any point as far as I know.
That still works. All code is deprecated eventually. I think this is more about using a tool to make your life easier.
Technically, you should be able to put the type definition anywhere in your directory and the TS compiler will find it. Usually, I create a 'custom-typings' directory and store my custom type definitions in there. The way you write the definition will depend on the JS library structure. This page will help you to figure that out - https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html For me, figuring out the library structure is always the hardest part. Once you've done that, it's a case of going through each feature of the library: functions, constants, classes, properties, methods etc. And documenting their type in the file. It's a way to tell intellisense what type each constant and property must be, what type each is properties in every class, what type of parameters each function and method accept, and what type return. Think of it as an instruction booklet like the ones you get with flat-pack furniture from IKEA. The instructions tell you what different components you have and how to fit them together. It's a lot easier for you to find out that screw 'A' goes into the top left hole on board 1 when the instructions tell you so. You know which type of screw is needed for each type of hole, making errors much less likely to happen. The instructions don't tell you how the whole process happens in great detail, just that shelf 'D' fits into slot 5 and the result is TV cabinet type furniture. That's the best analogy I'm going to come up with right now. Whiskey is blocking my explanation abilities. Anyway, hope that helps!
Yes.. you can, and you should!
Does your suggested solution work? It looks like it should work already.
Unfortunately not.
Ok it seems that I needed gulp and some module loader. Is there any alternative to this (it's not exactly a project, but a research)?
If you are attempting to use a module in a script written for the browser then yes, you need Browserify or Webpack or similar tools to pack a module and all its dependencies all together in a single file so that the browser can execute them. To use modules: [have you read the official documentation ?](https://www.typescriptlang.org/docs/handbook/modules.html) Hope this helps Edit: after thinking about it some more it seems that you have made a common mistake mentioned in the documentation, [see here](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#pitfalls-of-namespaces-and-modules) the part about "/// &lt;reference&gt;-ing a module" 
You don't need Gulp.
The problem is that you haven't told RequireJS how to find gl-matrix.js. The program compiled because TypeScript knows how to look in node_modules for libs imported using `import` statements, but TypeScript is only a build time concern. At run time you have to hold RequireJS's hand through loading dependencies. I suggest reading the RequireJS docs, specifically the [paths section](http://www.requirejs.org/docs/api.html#config-paths), but do read more than that. In your document's body you need to further configure RequireJS: &lt;script&gt; require.config({ paths: { 'gl-matrix': 'node_modules/gl-matrix/dist/gl-matrix' } }); &lt;/script&gt;
I am ashamed. I indeed read through the documentation but missed it. Thanks a lot! And maybe some other recommendations how to treat errors such as `Script error` - it's not very informative and hard to say what it means.
So typescript does not bundle files for you akin to node. This is fine in a server side context, but not in a client side one. Typescript has a lot of great resources for this, but basically you want to use webpack or browserify plus @types/jquery and the query npm package to get what you want. 
Yes, you're right, but I'm importing across all my files the `interfaces.ts`file. What I achieve with a *.d.ts file like: ``` declare namespace myModule { interface myInterface{ ... } } ``` Is that I don't have to do the `import {myInterface} from './../interfaces.ts'`. I don't want to import a ts file full of interfaces because my output interfaces.js is empty (thanks to no-ahmpile-to-js because of syntax sugar). But when I use a *.d.ts file, then this is not copied to my outputDir and then my *.d.ts files generated thanks to *tsc* (with compiler option "declaration" to true) are not able to recognize my `src/myModule.d.ts` file. Did I explain myself? Sorry if not, I'm not good explaining my situation because I've been struggling so much, hehehe.
&gt; Have you "installed" your module ? For example: npm install --save jquery. Did it. &gt; Additionally if you want to run your module/script in the browser you will need to pack it with Browserify or Webpack or you will need to add a &lt;script src='...' &gt; in your html page referencing jQuery (although it defeats the purpose of requiring things) Have been doing the second one.
If you are adding jQuery as an included file in your HTML, then you don't want to be importing / requiring it at all. You can simply add the first line you quoted to the top of any file that needs to use jQuery and immediately start using `$` or `jQuery` as a global variable: `/// &lt;reference path="./node_modules/@types/jquery/index.d.ts" /&gt;` Note that the relative path has to be correct, so this will only work in a file that is at the root of the project, if you have your code nested in sub-folders then you'll need to adjust the path to correctly point to the `@types/jquery` folder Edit: Also make sure that the `&lt;script src=".../jquery..."&gt;&lt;/script&gt;` occurs before the include of your application javascript in the HTML. If it is after then jQuery won't be loaded when the browser tries to execute your code.
Ok, I revised the code, I rearranged the jQuery route in the HTML file, erased junk comments in my .ts and added the document.ready in my jQuery event. It works. Thank you very much for your answers and your time guys.
In the video I see a tsconfig under the tests directory. My issue is that webstorm doesn't recognize source file imports that are one directory above.
You need to exclude the folder that you want to have a custom tsconfig in. Then you can deploy a unique tsconfig in that folder. Check out my other video I released the day before where I walk through it: https://redd.it/69x00n 
I think there could be more dependencies for sure
For anyone that finds this, I ended up just marking the props that I inject as optional in the prop definitions. Maybe I'm rationalizing this so I don't feel as bad, but I guess they are *technically* optional to pass in. They just have to get there somehow either passed in or injected. I had to turn off strictNullChecks in the tsconfig otherwise TS would complain that the prop could be undefined. This works, but I'm not quite satisfied with it. It feels hacky. Any suggestions are welcome!
According to Mobx' creator, optional props are they way to go: https://twitter.com/mweststrate/status/809126681646628864
 { callback: (source: string) =&gt; console.log(source) }
[removed]
If I create an object of that class, how do I access properties ? The methods (anyMethodName, anotherMethodName) are not necessary to be declared are they ?
Create a typescript definition file (.d.ts) for your api module in the same directory as your api.js file. Put this in it: declare module './api.js' { const api: any export default api } You can replace `any` with actual typings for your module if you like. I've only ever done this with global modules before (e.g. those from npm), so I'm not 100% sure if this'll work for just one file. If all else fails, you should be able to `declare module '*.js'` with the code above and be able to import any JS code as `any`. Also, try enabling `compilerOptions.allowJs` in your tsconfig.json as well.
Does not work. TS reports: ambient module declaration cannot specify relative module name. allowJs has been set to true. I've been racking my brain on this all evening. Do .d.ts ambient declarations only work with node_modules packages?
As previously stated, I tried declare var require: any and, while typescript no longer complained, api did not end up in the webpack bundle, so it failed at runtime. :-/
Read the first part of the answer and ignore everything else. Edit: `` npm install @types/node --save-dev `` Edit2: And read the "optional" part under Typescript 2.x
Love Anders, but gosh he's given the same shpill almost word for word for the last 5 yrs. I realize it's for the benefit of those who haven't heard it ... but geez switch it up a tiny bit Anders. :)
The first half is an intro, but the second half is about new TS features: null checking, discriminated unions, Vue.js support. TypeScript has had a big year!
I absolutely despise karma. I have a working project if you want to see, just PM me. Howevevdr, I would highly recommend moving to using JSDOM for your testing environment. The Karma feedback loop is just too slow.
The Karma feedback loop with headless chrome is pretty decent now. I'd really value actually using a real browser over a mock one in acceptance testing, for reasons I'm sure you understand - especially when I want to expand to other browser testing, not just chrome. Jsdom would be fine for unit testing, but not for acceptance-level tests IMO
What is at `./src/store/index.ts (17,20)`? Sounds more like it's complaining about the type of the object you're passing into the function. 
Awesome, that works!!! And yet I really don't understand why that did the trick. Since the `state` that's given as the function's parameter is completely independent from the `state` that I defined earlier. At least from a type-checking point of view. Right? I'm guessing it's just really buggy behavior.
Well as you can see line 17 is nothing more than `export default new Vuex.Store({`, so that doesn't give me much information. But the other guy's tip already worked, so yaay.
It's because the type definition of `Vuex.Store` looks like this: class Store&lt;S&gt; { constructor(args: { state: S }) } Where `S` is the type of your state. When you pass what you pass, TypeScript infers it to be: class Store&lt;{ todos: undefined[], newTodo: {} }&gt; {} This is because you provide no hints to what `todos` actually is or what it contains. TypeScript infers any array that it can't determine the type of as `undefined[]`, hence why you see this error.
Thanks for your reply. I understand it about 99%. There's just one thing that I don't understand, which is: why then did the error go away when I changed `uncompletedTodos(state: State): Todo[] {` into `uncompletedTodos(state: any): Todo[] {`? Is it because Vuex also defines the getters object as being an array of functions that take the same type as the state-type defined in the constructor? That would make sense, except then I don't understand why it would still accept the first `completedTodos(state: State): Todo[] {` function as is.
&gt; Is it because Vuex also defines the getters object as being an array of functions that take the same type as the state-type defined in the constructor Yes. &gt; That would make sense, except then I don't understand why it would still accept the first completedTodos(state: State): Todo[] { function as is. Can't answer that. If you look at the playground, having either function causes the error you're seeing 
I second using immutablejs, it's an outstanding feature complete library. Once you get a good grip on its 'API' it's incredibly powerful. I used it primarily for its own data types (list, map, record, etc...) I have an general aversion to class /inheritance structures, from OO languages. Edit: apologies I've just realised this is in the typescript subreddit. I imagine OPs looking for a tidy immutable friendly pattern in typescript, I have no experience with hand rolled immutable classes.
Ever seen [this library](https://github.com/pleerock/routing-controllers/blob/master/README.md)? Used it for a personal thing, I really liked it.
You can use the [compilerOptions.paths](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) object in your tsconfig.json to achieve this. E.g; "compilerOptions": { "path": { "myLib/*": [ "path/to/myLib/*" ] } } You can then do: import * as geometry from "myLib/geometry"; import { something } from "myLib/color"; and so on.. I suggest adding an index.ts to each of your 3 directories and re-exporting everything you need from there. e.g in src/geometry/index.ts; export * from "./shapes"; export { thickLine, thinLine } from "./lines"; 
Right, what I'm asking is how do I make it so that I can import from source subdirectories of my library as such: `import { Something } from 'myLib/subdirectory/.../something'`? I'm editing the first post do give more details.
&gt; If your top-level directory has a 'geometry.ts' or a '/geometry/index.ts' - then it can be consumed by: &gt; import { shape } from "myLib/geometry"; ~~I _do_ have a `geometry/index.ts` and I still cannot import via `import { shape } from 'myLib/geometry'`. And I can confirm that a declaration file and js file do get created for it in `dist/geometry`.~~ Edit: nevermind. I get you. It's not top level, its in 'src'. I guess I'll just build into 'core' so it sounds intentional :p. 
Yep, already using immutable.js for the collections. But your edit hits it right on the button for why I don't want to use immutable.js for the class stuff.
Immutable.js is fine to use with typescript. If anything it gives you 2 layers of type safety instead of just 1.
Then just extensively use jsdoc comments to reiterate what the typescript types already say. 3rd layer achieved.
I suppose the closest thing would be extending record then implement getter and setters utilising immutablejs methods? I was just about to say isn't it a bad thing storing functions (non data) within the redux store but immutablejs already does that. I would love typescript to make immutable data structures a first class part of the lang. But I think the readonly keyword is the closest we'll get until it gets introduced into ecma.
I've never understood this pattern... I don't want you to access or mutate my private variables, so here's some handy methods for accessing and mutating my private variables. Just make it public.
It's much more useful for providing simple computed values as a property. class Person { public firstName: string; public lastName: string; get fullName(): string { return `${this.firstName} ${this.lastName}`; } }
Why not make `fullName` a public method instead of a getter? There's literally no advantage to this. class Person { private first: string; private last: string; fullName(): string { return `${this.first} ${this.last}`; } } Additionally, overloading property getters and setters to do some arbitrary logic is wrought with danger for any devs consuming your code. would you expect `myObj.foo = 13` to do *anything* but set that property to the value 13? Now if you did `myObj.updateFoo(13)` it's at least a giveaway that you're passing data into an arbitrary method.
&gt; Why not make fullName a public method instead of a getter? ## Semantics A properly designed property has a stricter meaning than normal methods. * Calling the setter twice in a row with the same value is a no-op * Calling the getter twice in a row will always return the same value * Calling a setter with a known value will return said value if you immediately call the getter. * The getter has no visible side effects This alone is useful from a documentation standpoint, but it also has some second order implications. ## Debugger Support Since calling a getter is always a safe operation (assuming that its written correctly), the debugger can show you all of the properties in the same way it shows you all of the fields for an object. This is especially important if the property isn't just a thin wrapper around a field. You can also make the properties editable in the debugger because the debugger knows how to pair getters and setters. ## Framework Support It is much easier to create generic libraries that deal with data binding, data transformation, serialization, etc. when you can just ask a class for its list of properties. 
Gross! Why?
&gt; it's not your concern what the implementation of something does I know that's the general line toted, but IMO this is the leakiest of all the abstractions. As soon as said thing does something unexpected you're immediately concerned with the implementation.
&gt; Semantics Every bullet point here is a built-in invariant of using public fields instead of getters/setters. Using getters/setters allows you to break every single one of the rules listed. &gt; Debugger Support &gt; (assuming that its written correctly) I'll keep the footgun in its holster. &gt; Framework Support Fair enough, though should be noted that there are plenty of other ways of achieving those things. 
&gt; would you expect myObj.foo = 13 to do anything but set that property to the value 13? Depends on what else is going on in the class. For example, if the class has a "IsDirty" or "IsChanged" flag, the setter should set the flag to true. If the class has a PropertyChanged event of some sort, that event should be triggered. Property setters are great for making sure all of the bookkeeping is taken care of. 
Have you ever changed a field on an object but forgot to set the "HasChanges" flag? By encapsulating that in the property setter, the consumer of the object doesn't have to worry about such details. 
&gt; Conventions only work with people obey them. Exactly my point. People are fallible, if you can avoid having to trust humans as much as possible and rely on the computers to do the things they're good at, why wouldn't you? This is the same sort of argument people use for not wanting a static type system..."conventions are good enough". A plain public field sticks to a set of invariants that can be relied upon by downstream interactors. A function does not have those and can perform any logic it likes, these are known properties to the interactor. getters/setters is this weird middle ground where the interactor is supposed to trust the property to act like a public field even though it has the ability to do anything a function can do.
Yes, conceded in another leaf that those sorts of things are possible uses here. I've never seen it in the wild though, it's always been some variant on `obj.set('propertyName', val)` vs overriding the actual setter.
Because I want to bundle some functions with my object and, as demonstrated in the SO question, because interfaces + spread operator allows creation of invalid objects.
&gt; I think the readonly keyword is the closest we'll get until it gets introduced into ecma Yeah, and that's Ok. I just wanted to make sure that's really the situation and I wasn't missing some obvious language feature/pattern that people were using (or an upcoming feature, the readonly keyword being a fairly recent addition). It just seemed a bit strange that the language would have the concept of immutable classes with no convenient way to manipulate them. It'd be like immutablejs having immutable collections, but then not having the ability to manipulate them via the setter methods. For the moment, I'm moving forward with pure classes containing "with()" functions, but it's pretty verbose/inconvenient. When I've explored all the problems with it - I'll look into an alternative implementation using immutablejs. 
I think the only way to do this is to rewrite the tests with typescript
Damn, missed this one. Now it's switched to some RPi book.
Missed it i guess :(
That would definitely seem to be the case, I tried multiple configurations of `tsc` with different flags and made some progress, but in the end just got stuck with imports and missing declarations. 
Sorry to hear that. If you are interested in TypeScript content then I'd recommend getting a 30 day free trial of [Mapt](https://mapt.io/free-trial/), our online reader. You can then access every video and ebook - including all TypeScript and JavaScript titles - in our library. Go to [https://mapt.io/free-trial/](https://mapt.io/free-trial/)
Sorry to hear that. If you are interested in TypeScript content then I'd recommend getting a 30 day free trial of [Mapt](https://mapt.io/free-trial/), our online reader. You can then access every video and ebook - including all TypeScript and JavaScript titles - in our library. Go to [https://mapt.io/free-trial/](https://mapt.io/free-trial/)
Aren't unit test sample usage code for a library? 
Check out Apollo. It's written in TypeScript! I use Apollo for my client side GraphQL usage and it works great with TS. For the server I run .NET servers, so haven't tried Apollo's server version, but they do have a graphql-server project on GitHub that is also written in TS. [GitHub](https://github.com/apollographql) [Website](http://dev.apollodata.com/)
Thanks for the suggestions. I'll definitly check it out. Is GraphQl working fine with .NET?
I made this a while ago, it's not production ready, but it might give you some ideas https://github.com/ericwooley/graphql-typeorm-passport-boilerplate
Had the same issue a few days ago and ran into [tsconfig-paths](https://www.npmjs.com/package/tsconfig-paths). Works like a charm!
If anyone is looking into this again, with React Native 0.45 it's going to be much easier. Wrote a blog post about it here; http://blog.novanet.no/easy-typescript-with-react-native/ Example project here: https://github.com/cbrevik/react-native-typescript-starter Basically you won't have to do any magic like replacing the packager or doing stuff manually.
Super weird. Try changing the state undefined to {} (Doesn't match up with the error message but I think I've encountered this before)
Oh man, I've loved that font ever since I saw it on wesbos' twitter :) I meant on the Jumbotron component, though (not on the App one), unless you already did that.
Haha, yeah that font is amazing! The only thing is it's hard to find themes that has support for it. I've only found two themes in VS code that makes the cursive a ligature look nice so far. &amp;nbsp; Yeah, I already did that to both. No changes.
Ah, wait, I think I 'get' it. Try `React.Component&lt;RouteComponentProps&lt;IJumbotronProps&gt;&gt;`. You may need to import `RouteComponentProps` from `react-router`
Yeah, sorry for not being clear. I am assuming the reason it doesn't work is because the `Route` component attribute has a type signature expecting a component that either has `RouteComponentProps&lt;T&gt;` as props or `undefined`, and `IJumbotronProps` fits in neither of those categories
super confusing. Sorry I can't be of more help, it's like 5am here and I'm on my windows (non-dev) machine
It's funny because we did this together. This is my other handle ;) (Still working on jest..)
Note that this doesn't allow you to further extend this, or make a class implement it. The recommended way is `interface`, unless you can't achieve want you want with one.
&gt; Although writing backend in js is not a good idea for me. Why? I agree that writing `app.use('route', (req, res) =&gt; { ... })` is pretty ugly, but with a library like this one (coupled with typescript decorators) you're getting close to what you would have in for example Java
Not this is ugly. Ugly is that even typescript is only safe at compile time. Not at runtime.
I found a nice way to solve this issue as well with making your routes more scalable or maintainable was to make a config.json file in each route folder with a structure that has a name and route and middleware then in your route file just have async function renderHome(ctx) { } Then export them all your handlers at the bottom export renderHome; Then instead of piling up routes in your app.js you can just make an import routes function which loops over your config.json files and matches the exports to the config files and vwala Might have came out like a big spew of words. On mobile, formatting is hard. 
/u/naeramarth7 solution works, but if you are looking for alternative, I am using startup script that uses and configures npm module 'app-module-path' and set it to my ./src folder. https://www.npmjs.com/package/app-module-path
This is awesome.. I was unaware of being able to combine types. Only problem is that adding the `?`, doesn't enforce it being defined. Thanks! Helped me get over a mental barrier. 
Like you said. :)
Why do you want to confuse objects with methods? There is surely a more elegant solution to your problem than this.
You can just use Object.assign() for that: example: const Sum = Object.assign( (x: number) =&gt; { console.log(x); }, { empty: () =&gt; Sum(0) } ); Sum(10); Sum.empty(); 
Only problem with this is that the `const test = function (...){...}` complains that empty is missing as a type. The top solution seems to work by making empty optional. Thanks for the alternative solution though!
A better way is via declaration merging. There's no need for duplicate type information. See my top-level response.
They're used so heavily that this really isn't an option anymore.
This is the least boilerplatey way to do it. Type inference for the win. Bonus feature: use a named function expression instead of an arrow function to get more meaningful stack traces.
I would be glad if i could right such a big framework ^^. But unfortunaly I'm not that guy. I think a library like this is better than dealing with types and objects that are not really made for this. I often have the case were i need an "object" but it's not really a class so it can't be instantiated right (maybe i'll do things wrong:) ). But i like the idea of having everything from a single source.
Guessing you're on mobile. I thought the same. Click the menu icon in the top left to open a table of contents.
Yeah, I didn't see the hamburger, thanks.
looks a lot like https://github.com/pleerock/routing-controllers
Wow this is extremely handy!
The short answer is: TypeScript compiles into JavaScript. VisualStudio has a template that will give you all the files you need. 
[here is](https://www.keithcirkel.co.uk/why-we-should-stop-using-grunt/) about not using Gulp and how to set it up 
Google "typescript nodejs" and click the first link. That walks you through setting up a node project with typescript with only npm scripts.
I have a project that has an src/client and src/server folder with a tsconfig in the root of src, and yes it's shared. I use Visual Studio Code and I have several tasks configured. To run the server I use a node command task and to run the client independently I typically use a command line task and call webpack-hmr. I also have another task which sends an argument to node which instructs my server to also act as the webhost for my ng2 app using the webpack hmr middleware. This is more convenient for simple F5 debugging. No gulp. All VSCode native setup. Do note that sharing a tsconfig has a drawback with angular2 (not sure if 4 has fixed this) which is strict options don't work. If you want to go strict for your server code you will need separate tsconfig files.
Interesting. I think that's kind of the solution I'm looking for. Since I want to stick with the Angular CLI to build the client side, I'm probably going to need a separate tsconfig file. I could probably do a simple NPM script like: ""ng build -watch | tsc -p tsconfig-server.json -watch | nodemon server.js" The server code wouldn't be run thru webpack and would simply be compiled in place. Do you output your server code to a different file/folder or do you simply output js files in your src/server folder and subfolders?
I have posted my solution on SO https://stackoverflow.com/questions/44138024/how-to-use-typescript-with-angular-2-cli-and-express-node-in-the-same-project Basically, I have added a separate tsconfig file to deal with the server code and added an NPM script to compile the server code separately from the client code.
I ended up mocking out the global interface to make it stop complaining. Seems to be working well.
you can do this with a one-line shell script, example on linux let's say you name this file `npi` #!/bin/bash npm install --save $1 &amp;&amp; npm install --save-dev @types/$1 Then you just havev to do `chmod +x npi` and put it somewhere that's in your path. then just type `npi lodash` for example and it should do what you want This doesn't guarantee that there actually is a typing file for the package, but you'll see npm fail
This method is a bit dirty but it works. Open the file nodejs\node_modules\npm\lib\install.js (install dir of node starts with nodejs on my win10 pc / I ran "which npm" to get it) and change the line this.topLevelLifecycles = !args.length to this.topLevelLifecycles = true then in package.json add a postinstall script "postinstall": "node ./postinstall.js", in the file postinstall.js which will be executed after the package install &gt; https://pastebin.com/RtK8p5EH If you encounter a bug in the script or an edge case, you can always do console.log and get the output of each line in order to fix/improve the code 
 type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array
[removed]
Haha, hi there. Funny nick name :P
Ah yes, never let your 12-year old self pick your nickname :D
There are many well known examples of libraries that do this. The obvious one being jQuery. It's a neat way to let a single identifier serve as a function for the most common use case but also carry extra capabilities for the less common use cases.
In TypeScript, you can use `--jsxFactory` to configure an alternate caller instead of `React.createElement`. As an example, see [this blog post of someone using `h` for Preact with TypeScript](https://medium.com/@shakyShane/hello-world-with-preact-jsx-typescript-6d70cf2ebf01).
Use whichever gives you the rules you want to enforce. The compiler flags and tslint are just tools available to you, there is no set of rules you *should* be using. I am not 100% sure but I believe no-unused-parameters used to be a tslint rule before they added it to the typescript compiler so possibly the people behind tslint are working to remove any overlap between the two.
tslint also includes style rules you can set, having nothing to do with the correctness of your typescript code. i recommend it. :)
Is it as ugly as this? I think it looks much better than Go code (which doesn't even include routing here) `func handler(w http.ResponseWriter, r *http.Request)`
Yes, we are using it at system that is processing 500 req/s from all over the world and now we are migrating to Java to be more resource friendly. Also It's not runtime safe like Java and need a LOT of testing / debugging before publishing. 
The compiler..?
Yes that.
And I recommend tslint-loader if you're using webpack :) Edit: Sorry, I was thinking about tslint-loader, not ts-loader
Sorry for the very late response. It was a webpack thing. Now I've migrated it to RollupJS, you may consider giving it another try :) 
When used as a type, `{}` is the empty interface, *not* an empty object. So you might be getting confused between the places where you're creating objects and where you're referring to blank interfaces. A number is assignable to a variable of type `{}` because a number satisfies all the constraints of the interface. (it has no constraints; it's empty). You might be thinking of the `object` type, which is different than `{}`. I can't speak to the 3rd example because I don't know what the RxJS declarations look like.
That is not the reason here. as cspotcode mentioned, when used as a type, {} does not mean 'object', it is an interface with nothing in it.
I don't understand what you are saying, but if you make one .ts file, define a class and and an interface that it can implement, then compile it to .js, that .js file will not contain the interface. The TS compiler ignores Interfaces. Just wanted to state that regardless of my capability to understand your above comment :)
The pattern for typing an object destructure is as follows (sorry if formatting comes out weird, on mobile): function ({ obj1, obj2 }: { obj1: any, obj2: any }) { ... } Now, I can't test how this plays with "rest" object parameters, but this should get you started. 
jaja thanks 
No problem! Please share! I'm open to any feedback, feel free to submit issues or PR
I've only used typescript in the front-end (usual react setup) and I've enjoyed it very much, and I definitely see its advantages. But when I see code littered with decorators I can't help but recall getting lost in Java/Springs annotations and voodoo magic. I would love to see something similar but written in a more functional manner.
Why Java? Why not ASP.NET? Curious. I heard Visual Studio and ASP.NET have magnificent development support, intellisens, refactoring etc. What stack are you using with Java? Framework, ORM, etc
In the end decorators are just functions. Well, these libraries using TS metadata heavily (which is real magic, getting and saving types of arguments, properties etc at runtime (!)), but decorators pretty much are like function decorate(target: Object, property: string, ...etc) {} class A { constructor() { // here decorator(A.prototype, "callForDinner"); } // or here @decorator callForDinner() {} } Of course this example does not provide full usage example for every decorator out there, but I think you got the idea. Btw typeorm also works without decorators and classes. I can suggest you to write several decorators by yourself to see that this just some kind of sugar.
Of course, You should use @adviceMetadata to retrieve metadata of decorated subject. Take a look at this: https://github.com/k1r0s/kaop-ts/#inside-an-advice I released the library 2 days ago )) Docs are still a todo :( 
decorators are a win dude, don't be afraid :D. have you seen MobX?
Funny situation. I wrote my thing for development with preact, "reactors", like actions and stores at the same time and decorators and listeners etc. https://github.com/idchlife/nuclear-reactor And then I discovered MobX. They are not exactly the same, but hell, I was pleased that some people already thought about observing changes of properties to update state. Was thinking that I'm one person doing witchcraft by using decorators and wrapping methods (willMount, willUnmount) in the world of functional madness, lol. (not that I hate functional) MobX is very nice.
I see. Yeah you're right I will definitely have to take a closer look. I suppose I was getting spring flashbacks.
If you're writing a library, you could check out https://github.com/alexjoverm/typescript-library-starter which already includes a stack of libraries :)
Well this topic's comment section starts to look like awesome-typescript list :D
Because Visual Studio is slow as hell crap in comparison to InteliJ Idea, buggy and it lacks many features that Idea has for years. I know there is a Intelij's Rider but it's not feature complete yet in terms of integration with .NET. .NET applications are more expensive to maintain and develop (licenses fees for server, software, etc). You cannot achieve also such level of automation with Windows as base system like with Linux. .NET Core is simply not yet production ready. From the other hand C# is wonderful language but only this is not enough for us. Things like open source, vendor lock also does matter. With Java we are mostly using Play Framework and Hibernate as stack, but it depends of project requirements.
Do you have a link? I can't find it anywhere.
Ohh man you are standing on the edge of a never-ending rabbit hole. OOP is fucking giant, had a class in uni dedicated to only that. IMO if you're not familiar with OOP you should read some theory about it. Because it's not only about code, it's class diagrams, state charts, sequence diagrams, CRC cards, etc. And THEN there's design patterns. Don't have any resources on hand but if what you really really want is code to follow along with I suggest you try to find something that teaches OOP principles with examples written in Java
I would use this stack in a heartbeat if TypeORM was just a little further along. It's missing some features that are non-negotiable for me but they are all in the 1.0 checklist. Routing-controllers is also extremely impressive and does so much of what I've been looking for. I've been keeping an eye on these and can see myself jumping to a TypeScript backend using these libraries sooner than later.
I'm actually wondering how Nest became THAT look a like routing-controllers. Routing-controllers saw the world at 2015 year, and Nest in 2017. Also about Nest, as I believe (saw it somewhere in another thread) it has disadvantage of defining dependencies and "components" with additional decorators, and routing-controllers + typedi etc can give you dependency injection exactly as you will do in languages with annotations and even better. Like you just define properties in class or/and parameters in constructors with types and viola! Anyway, I'm looking into Nest too, because it has it's cool ideas. Will see how it all will work out. Is there plans to make integration for TypeORM? Like @OrmEntityManager injection etc (I know, it can be obtained by wrapper service, but it's very easy to use out of the box with such decorator)
If you replace `this.foo = 1;` w/ `test.foo = 1;`, the datatype inference works: [Test1](http://www.TypescriptLang.org/play/#src=const%20test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%200%2C%0D%0A%0D%0A%20%20%20%20changeFoo\(\)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.foo%20%3D%201%3B%20%2F%2F%20can't%20infer%20via%20this%0D%0A%20%20%20%20%20%20%20%20test.foo%20%3D%201%3B%20%2F%2F%20correct%20infer%20as%20number%0D%0A%20%20%20%20%7D%0D%0A%7D%3B%0D%0A%0D%0Aalert\(test.foo\)%3B%20%2F%2F%200%0D%0Atest.changeFoo\(\)%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%201) const test = { foo: 0, changeFoo() { this.foo = 1; // can't infer via this here test.foo = 1; // correctly infer as number now } }; alert(test.foo); // 0 test.changeFoo(); alert(test.foo); // 1 Typescript isn't very good to infer the datatype of `this` outside a `class` though. Check the same code now turned as a `class`: [Test2](http://www.TypescriptLang.org/play/index.html#src=class%20Test%20%7B%0D%0A%20%20%20%20constructor\(public%20foo%20%3D%200\)%20%7B%7D%0D%0A%0D%0A%20%20%20%20changeFoo\(\)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.foo%20%3D%201%3B%20%2F%2F%20Now%20infer%20w%2F%20this%20works!%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20test%20%3D%20new%20Test%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%200%0D%0A%0D%0Atest.changeFoo\(\)%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%201) class Test { constructor(public foo = 0) {} changeFoo() { this.foo = 1; // Now inference w/ this works! } } const test = new Test; alert(test.foo); // 0 test.changeFoo(); alert(test.foo); // 1 
You're right! Each non-lambda, unbind `function` has its own `this`. Regular objects don't have 1. Rather it uses the most immediate function's `this`. The `this` at `this.foo = 1;` belongs to the global _window_ scope at that moment. As if **changeFoo()** would be directly invoked w/o using the `.` operator inside the object _test_. When it's finally invoked as `test.changeFoo();`, its `this` dynamically becomes the _test_ object. Until it is actually invoked, Typescript infers the `this` at `this.foo = 1;` as belonging to _window_. Or whatever the global scope happens to be. 
Typescript can' t actually guarantee that `this` will be always of the type from `test`. E.g. the following code is totally valid: let changeFoo = test.changeFoo; changeFoo(); Now `this` is set to something different than if you would have called it with `test.changeFoo()`, and `changeFoo` will manipulate something different (which might even not exist). Therfore `any` is the only safe type which can be inferred for this.
&gt; Typescript can' t actually guarantee that `this` will be always of the type from _test_. You are being pedantic! Of course almost nothing can be guaranteed in JS! Here's 1 of my own statements: &gt; When it's finally invoked as `test.changeFoo();`, its `this` dynamically becomes the _test_ object. The keyword here is: **dynamically**! Even a method defined inside a `class` can be hacked in the same vein. If I add these 4 statements in my [Test2](http://www.TypescriptLang.org/play/index.html#src=class%20Test%20%7B%0D%0A%20%20%20%20constructor\(public%20foo%20%3D%200\)%20%7B%7D%0D%0A%0D%0A%20%20%20%20changeFoo\(\)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.foo%20%3D%201%3B%20%2F%2F%20Now%20infer%20w%2F%20this%20works!%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20test%20%3D%20new%20Test%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%200%0D%0A%0D%0Atest.changeFoo\(\)%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%201) `class` example, calling the `function` reference w/o operator `.`, that's not gonna change _test_'s _foo_ property. But instead it's gonna create a global property _foo_: const changeFoo = test.changeFoo; test.foo = -5; // change it to -5. changeFoo(); // It won't change foo back to 1 this time! alert(test.foo); // still -5 Check that out online at this link: [Test3](http://www.TypescriptLang.org/play/#src=class%20Test%20%7B%0D%0A%20%20%20%20constructor\(public%20foo%20%3D%200\)%20%7B%7D%0D%0A%0D%0A%20%20%20%20changeFoo\(\)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.foo%20%3D%201%3B%20%2F%2F%20Now%20infer%20w%2F%20this%20works!%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20test%20%3D%20new%20Test%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%200%0D%0A%0D%0Atest.changeFoo\(\)%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%201%0D%0A%0D%0Aconst%20changeFoo%20%3D%20test.changeFoo%3B%0D%0Atest.foo%20%3D%20-5%3B%20%2F%2F%20change%20it%20to%20-5.%0D%0A%0D%0AchangeFoo\(\)%3B%20%2F%2F%20It%20won't%20change%20foo%20back%20to%201%20this%20time!%0D%0Aalert\(test.foo\)%3B%20%2F%2F%20still%20-5%0D%0A%0D%0Aalert\(foo\)%20%2F%2F%20But%20a%20global%20variable%20foo%20is%20created%20instead!) And if we start the script w/ `"use strict";`, it's gonna throw an exception, b/c global `this` becomes _undefined_ now. :P "use strict"; class Test { constructor(public foo = 0) {} changeFoo() { this.foo = 1; // Now infer w/ this works! } } const test = new Test; alert(test.foo); // 0 test.changeFoo(); alert(test.foo); // 1 const changeFoo = test.changeFoo; test.foo = -5; // change it to -5. changeFoo(); // It won't change foo back to 1 this time! alert(test.foo); // still -5 alert(foo) // But a global variable foo is created instead! 
In situations where Typescript says your `this` type is `any`, you can manually specify the type of `this` like so: changeFoo(this: MyObjectType) { //... Note that in this example the function still has 0 arguments.
However if for some reason `noImplicitThis` can't be used for your old JS code, besides replacing `this.foo` w/ `test.foo` or defining a proper `class` to represent _test_, you can define an `interface` for it: interface Test { foo: number; changeFoo(this: Test): void; } Or even a Type Alias: type Test = { foo: number; changeFoo(this: Test): void; }; And then declare that _test_ is of datatype _**Test**_. Check it out an online example at this link: [Test5](http://www.TypescriptLang.org/play/#src=%22use%20strict%22%3B%0D%0A%0D%0Atype%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20number%3B%0D%0A%20%20%20%20changeFoo\(this%3A%20Test\)%3A%20void%3B%0D%0A%7D%3B%0D%0A%0D%0Aconst%20test%3A%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%200%2C%0D%0A%0D%0A%20%20%20%20changeFoo\(\)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.foo%20%3D%201%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%3B%0D%0A%0D%0Aalert\(test.foo\)%3B%20%2F%2F%200%0D%0Atest.changeFoo\(\)%3B%0D%0Aalert\(test.foo\)%3B%20%2F%2F%201). "use strict"; type Test = { foo: number; changeFoo(this: Test): void; }; const test: Test = { foo: 0, changeFoo() { this.foo = 1; } }; alert(test.foo); // 0 test.changeFoo(); alert(test.foo); // 1 
It's not `noImplicitAny` but `noImplicitThis`. Of course, you can use all the 4 `noImplicits`. :-P 
my library rest.ts implements decorator pattern https://github.com/netdur/Rest.ts angular and rxjs also implements some of those patters
those patterns is fairly common and widely used to write software in other languages, I have only simplified the code for easy understanding, if you are not afraid of c# or java, you will find a lot of apps implementing those patterns.
It's nice to see CQRS moving int node development. This is just an opinion, but I feel like organizing files by feature rather than by type is a better fit for CQRS. For example, in the example app /commands rather than having /handlers/kill-dragon.handler.ts /impl/kill-dragon.command.ts I think something like this is easier to work with: /kill-dragon/handler.ts /kill-dragon/command.ts /kill-dragon/dto.ts Taken a step further I'd often put the command,handler, dto etc in one single file to make kill-dragon.ts . It makes it really easy to understand all the parts that are working together at a glance.
Eric Lippert's opinion on this can be found [here](http://www.informit.com/articles/article.aspx?p=2425867), #5. Personally I also like "type-first" approach better.
Similar to the way C# is considered a superset of Java, TS is a superset of JS. TS's syntax isn't bound to TS's dev team only, but rather also on how JS's team envisions its evolution! 
This may seem argumentative - and it's not meant to be, but wow, this has reinforced my belief that TypeScript is not well thought out... specifically the reasons that Eric Lippert gives in that article are, in my opinion, the wrong conclusions to draw from the evidence. &gt; 5: Type first, ask questions later &gt; As noted in item #6, C# borrows the "type first" pattern from C and many of its other successor languages: int x; double M(string y) { ... } &gt; Compare that to TypeScript: var x : number; function m(y : string) : number &gt; Okay, dim is a little weird in VB, but these and many more languages follow the very sensible pattern of "kind, name, type": What kind of thing is it? (A variable.) What is the variable's name? ("x") What is the type of the variable? (A number.) &gt; By contrast, languages such as C, C#, and Java infer the kind of the thing from context, and consistently put the type before the name, as if the type is the most important thing. Weirdly, this is an argument, in my view, *against* the use of the Kind - Name - Type pattern. For a number of reasons. First, "var x : number" starts with the kind. The kind is not the most important thing, so even if you accept the most important thing goes first, it's still weird to put the most important thing in the middle. After all, you don't say "My Sally Aunt." You say "My Aunt Sally" - usually going from least specific to most specific. &gt; Why is one better than the other? Think about how a lambda looks: x =&gt; f(x) &gt; What is the return type? The type of the thing to the right of the arrow. So, if we wrote this as a normal method, why would we put the return type as far to the left as possible? From both programming and mathematics, we have the convention that the result of the computation is notated to the right, so it's weird that in C-like languages the type is on the left. Again, I'm thinking that this is the wrong way to look at it. Mostly because the *type* of a function assignment is "Function", not whatever value it returns. let foo : int function(int x = 1){ return x; } console.log(typeof foo); //=&gt; "Function" // C'est non un Integer. Compared to: int function foo(int x = 1){ return x; } console.log(typeof foo); //=&gt; "Function" - just like we said it was when we said "function foo" console.log(typeof foo()) //=&gt; "Integer" -- just like we said it would return when we said "int Function" As you read from left to right, you see: "let foo : int" first, so your brain already has processed that foo is a variable of type int. But that's not true. Foo is not a variable of type int. By using "int function foo" - we see that A) It's a function that returns an int. ("int function"), and foo is a function ("function foo") &gt; Another nice property of the "kind, name, type" syntax is that it's easy for the beginner programmer, who can see right there in the source code that "this is a function, this is a variable, this is an event," and so on. I would actually argue against this being easy for the beginner programmer for the reasons above. 
While I agree, I'm going to assume it's because of the goals of JavaScript itself as stated in another comment, but also because it's an opt in language. 
I'd say without hesitation that Typescript is very well designed, it's quite the language geek's kind of language. That being out of the way, first of all Typescript's syntax inherits a lot of "what came before" in the ill-fated ECMA 4, and then Actionscript 3. Same name:type construction. Python 3 also uses this name:type syntax for its optional annotations. So maybe this form is just much easier for the compiler to parse out and/or discard? Not sure since I am not a compiler expert. Second, you DON'T have to write the type declaration. Typescript will be perfectly happy without it (it still knows the type from the assignment), and some linters actually discourage the use of type declarations when the assignment is immediate. IMO your Union is much more verbose and inelegant than A|B which I feel is totally awesome syntax. As you can see all this is quite subjective. I've had a lot of experience with languages that look just like Typescript. So for me there's no mentally jarring aspect, which is perhaps what you're experiencing in spades. This is something that time will heal. PS I learned in a *great* Coursera course (U. Wash. Programming Languages) how saying "strongly typed" is not quite correct in this context. Both Typescript AND JavaScript are strongly typed. But Typescript is (optionally) STATICALLY typed, vs JavaScript's pure dynamic (duck) typing. Both TypeScript and JavaScript will not let you recast a 64 bit number as two 32 bit ints, or 4 text characters. This is as opposed to C which is weakly typed, and will be happy to let you do such things to memory constructs if you force it to, since in the end it's all just 1's and 0's. (not typing to be smart ass, but it might prove useful in an interview question someday so I pass it on)
The types are optional. Type first syntax wouldn't make sense here without a placeholder syntax otherwise it would look odd. You'd need to have something like this: function foo(int x, * y, int z) {} as the following function foo(int x, y, int z) {} would be very jarring to read (for me). Interesting I believe Flow has a placeholder syntax like this.
Hey there! const PrivateRoute = ({ component: Component, ...rest }) The above signature is equivalent to: const PrivateRoute = ({ component, ...rest }: { component: any, ...rest })) =&gt; { const Component = component; } As you can see, `component` is implicitly `any`. The `:` inside of your destructuring assignment in the function arguments is aliasing rather than functioning as a type signature. You could correct it by doing the following: const PrivateRoute = ({ component: Component, ...rest }: typeof rest &amp; { component: YourComponentType }) =&gt; { } Or the following for legibility type PrivateRouteProps&lt;T&gt; = T &amp; { component: TypeOfComponent } const PrivateRoute = ({ component: Component, ...rest }: PrivateRouteProps&lt;typeof rest&gt;) { } This only happens if you have either `--strict` or `--noImplicitAny` enabled
[removed]
Actually there are 5 keywords to declare variables in JS: `var`, `let`, `const`, `function` &amp; `class`. 
In short, TypeScript's design keeps its syntax much closer to JavaScript, it keeps the syntax of type-inferred and explicitly-typed declarations more similar, it avoids ambiguities in the syntax, and it introduces fewer reserved keywords. A lot of your design decisions are introducing new keywords into either the variable identifier or type identifier namespaces, something the TypeScript team tries to avoid whenever possible. Stuff like `public`, `export`, and `import` has already been reserved by the ECMAScript standard. `required` and `Union` have not. Your syntax creates ambiguity in a few situations: ``` // This is a valid JavaScript statement that can call `valueOf()` functions and trigger side-effects. Promise&lt;number&gt; foo; // This is unambiguously a variable declaration. let foo: Promise&lt;number&gt;; ``` In TypeScript, there are frequently situations where values and types must have the same name. For example, in `const P = Promise;`, Promise is a value. In `let string = getCode();` string is a variable. I can't `int int = 123;` in C. &gt; * Variable type declaration and variable initialization are the same, cutting down on the amount of boilerplate. Type inference means the type declaration can often be omitted. Your syntax, omitting the `let`, `var`, or `const` declaration, further separates the syntax from vanilla JS, and a large goal of TS is to stay close to JS. It also makes declarations with and without types look different. In your example, `char a = 'w';`, what's the scoping? `var` or `let`? &gt; * Union is not special syntax, it is a global function that combines two types into one. What's the benefit of your design besides being more verbose? You can easily do `Union&lt;number, string&gt;` in TypeScript. Why do you say it's a global function, when functions are never executed at compile-time? (Yeah I know that some languages execute some of your code at compile-time) This would prevent any types from being called `Union`. * Strictly typed arrays are typed via [init/memberType] [variable name][] rather than [init][variableName] : Array&lt;membertype&gt; TS can do `public foo: number[];` which is pretty darn close. * Variables are either block-scoped with let, or function scoped with var. Are you saying that JS's `const` is not allowed? What about people who need that runtime guarantee, for example, because they're integrating with non-TS code? Again, a big design goal of TS is to stay close to JS. This means allowing all JS features to be used. &gt; * const variables cannot be reassigned, but const is not the assignment but a descriptor. TS strives to stay close to JS. &gt; * Interfaces can either have properties added to them - or not - depending on the needs of the program. Probably a pragmatic decision. Flow does have "strict interfaces", although they probably go by a different name, and Flow still uses a syntax very similar to TS. &gt; * Whenever possible, the variable name is placed immediately to the left of the assignment operator. I think you have a preference for this just because it's what you're used to. I actually like the TS syntax better because the variable names are more likely to occur at similar horizontal positions than when they're following a type. What motivated you to choose the syntax you did for required vs optional properties? It seems awfully verbose to write `required` before most properties, since often it makes sense for all properties to be required. [This StackOverflow question](https://softwareengineering.stackexchange.com/questions/316217/why-does-the-type-go-after-the-variable-name-in-modern-programming-languages) asks why many modern languages use postfix type notation. One of the answers in particular links to explanations from the creators of several languages. EDIT: formatting and grammar
Eager loading of associations is the biggest one for me. I'm using Ruby right now and ActiveRecord has me so completely spoiled where this is concerned.
I use the [Airbnb](https://github.com/progre/tslint-config-airbnb) tslint config as a base and extend that for my a few areas where my preferences differ. The base Airbnb config is pretty solid and is based on the [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript).
Lol, trying to be honest I don't support Democrats..you didn't read the article. I was only a joke. So don't be a pussy
http://img.playground.ru/images/4/4/6666.jpg
I call them Lambdas, just because that's what C# calls them.
I would say "arrow function" because that's what I hear in JS circles, and "arrow functions" specifically have a few behaviors relating to `this` binding and the absence of an `arguments` array. "Lambda" doesn't seem totally foreign but "template" sounds wrong and makes me think of C++ templates, which are more like TypeScript generics. ...but maybe that's just showing my ignorance.
That's very strange, and at first glance confusing. `int` is a type. `let` is not a type. Why are they parallel in that structure? If anything it should be `any`, but even then that feels much less elegant than the way TypeScript does things now.
I think if you at a minimum "declare" the module then you can import it as "any".
This was the first problem I encountered when using Typescript (on day 1 integrating TS into an existing React JS project), so I understand your frustration. You are right, only node_modules become type any if no type definitions are found. With your own JS files, typescript will do its best to infer the type, and may not get it right. In my case, the JS module dynamically added properties to the exported object, and typescript couldn't infer them. My options were to be more explicit in the constructor ... or specify the type another way. Please see this issue: https://github.com/Microsoft/TypeScript/issues/11106 What I ended up doing is writing my own Interface to describe the shape of my object correctly. I then cast away the bad inference (cast it to any), then assigned it to a new constant with the correct typing. It was unfortunate that I had to introduce a new symbol, but this was the cleanest solution I could come up with. Of course, this isn't necessary if TS can infer your JS correctly. import ApiService from './ApiService'; // sadly an incomplete inference const Api: IApiService = ApiService as any; // so cast to any then assign it to a correct explicit type I also could've simply used (ApiService as any).whateverMethod(), which might be easier if you only use it a time or two and don't care about the intellisense.
If you wanna get rid of all formatting configuration, Prettier comes very in handy. Also released recently tslint-config-prettier which makes them play very nicely! https://github.com/alexjoverm/tslint-config-prettier
You'll enjoy TypeScript 2.0+ a lot, then! Non-nullable types in particular were an incredibly valuable addition.
Yes. It does the same thing as `tsc --watch` but integrated inside webpack.
I didn't want to put here the whole post, so I've attached above the link to stackoverflow. Thanks in advance. 
I'm already enjoying it, it's a matter of time for the company to keep up!
Thanks for the explanation. 
That looks very nice! Especially the **Dynamic Import Expressions** caught my eye. Can somebody explain who knows a bit more about TS than I do: Does TS's compiler already transpile to ES5 or is there a need for babel? Since `import()` is so fresh, where could I check, what polyfills will be added? In babel I can add plugins for that, but in TS?
Don't use TS to transpile down to ES5 (instead transpile to latest ES) and transpile to ES5 using Babel configured to preserve imports.
Using Babel just for import stuff seems pretty bad. I'm sure they get a straight webpack solution working now that the feature is in there
Babel's async is faster?
https://github.com/MatAtBread/fast-async
Why would you want a constructor in the first place if all you're doing is namespacing the library function?
I don't know? As I said, I'm pretty new at this. I'm not using a namespace now, which might be why I have to use the different classes separately. If I put everything in the same namespace, and get rid of the constructors, would I then be able to use it just like: FccsLibrary.Common.getCurrentUser( ... without needing to instantiate a new instance?
To illustrate the context here, I'd gotten involved with typing the JS functional programming library Ramda for TypeScript, and had met a lot of challenges along the way, if partly because I've been ambitious about inference -- ideally aiming for type-level inference of the actual outcome values. As a result, I started to explore from the ground up what could and could not be done with the TS operators we [have](http://www.typescriptlang.org/docs/handbook/advanced-types.html) usable on the type level (essentially `&amp;` `|` `keyof` `in` and member access), and got.. further than i expected at least. :) The furthest I got right now has been a PoC for type-level iteration of tuple types, so as to emulate the `reduce` operations used in functions like [this one](http://ramdajs.com/docs/#pathOr) to get to properly typing them. This doesn't mean all problems are solved now, as there is still more we cannot do on the type level: we cannot manipulate tuple types yet (to fully infer the output values of functions returning arrays), nor can we do type-level function application or (ironically) type checks, to name the notable gaps. 
How is this meant to be used? Is it the language service running inside a ServiceWorker? Or it is meant to transpile code on-demand before you run it in your main webpage? The TypeScript playground uses a WebWorker to host the compiler, right? Is this at all similar to that?
I think of it as a forEach loop but for generating properties in the type system. The type of each property can potentially be different depending on the `K` type in each iteration. I know that's not a complete answer, but hopefully it is helpful.
Thanks for answer, but still not clear :( What i would like to know - is it some hack or i can rely on this construction in a future?
Thank you so much. For some reason i miss this part of documentation and focused on "interfaces" part.
It's called arrow function. Anonymous function is something different: `const anonymousFunction = function () {};`
Thank you! Does this work with "noImplicitAny"?
Okay, thank you :) I think I've had some issue few weeks ago where my .d.ts file couldnt be read even when it matched my "include" glob in tsconfig; however I do not remember exacly why it didnt worked. I will try your advice.
Can I possibly get example of usage type operators? Thanks!
I may be misinterpreting your question, so feel free to correct me! Currently two of the more practical ones for end-users are probably `Overwrite` and `Omit`, see [#12215](https://github.com/Microsoft/TypeScript/issues/12215). I've also been using the experience gained to try and find solutions to challenging types and steer the TS roadmap toward filling the gaps (see [here](https://github.com/Microsoft/TypeScript/issues/5453)), but we'll see what comes of that. Aside from just the types to manipulate objects, there's quite a bit of internal machinery (string-based boolean operators, operators on unions, tuple iteration) that may be of interest to more advanced users, which may help to generate more accurate typings (read: value-level type inference) for functions. This would seem of interest particularly for authors of TS definitions for functional programming libraries. Implementations of the types (`export`ed), including test types (no exports) that show usage can be found at the [gist](https://gist.github.com/tycho01/be27a32573339ead953a07010ed3b824). For the most part you can just paste that into the TS Playground; there's like one in there that needs a newer version (a 2.5 nightly). 
Hey there! I don't know if you're still looking for an answer here, but the answer to your question is the Typescript Record type. It takes two generics: (1) the keys you want, (2) the type you want their value to be. Used like this: type MyType = Record&lt;'potato'|'notPotato', string&gt;. 
Thanks for answer. My question was more about why this works type LimitedKeys = { [P in 'KEY_1' | 'KEY_2']: string; }; And this does not? interface ILimistedKeys { [P in 'KEY_1' | 'KEY_2']: string; };
It's a language limitation, unfortunately the "in" keyword only works for types. BTW, the former example is what Record is! 
Very nice. I've been hacking string enums for a while now, with foo = &lt;any&gt;"bar" , but it's great to finally have them officially supported. Most of these are so useful!
Thank you :) appreciate that you find the write up useful. I realized I spent a lot of time in the GitHub Roadmap and figured most people probably don't do this.
Good clear examples well written. Great post, you should consider doing this for each point release as TS has insane dev velocity (a good thing but keeping up with it and everything else makes it easy to miss stuff).
Thank you! Yeah it's definitely something I want to keep doing 🙂
Yeah, the velocity of the TypeScript team is fantastic. If you don't mind shameless self promotion, I've published a bunch of write-ups for the last TypeScript versions in my "TypeScript Evolution" series. Check it out here: https://blog.mariusschulz.com/2017/06/16/typescript-2-3-type-checking-javascript-files-with-checkjs
I solved it thus: https://medium.com/@prashaantt/strongly-typing-injected-react-props-635a6828acaf?source=linkShare-1026136cfd11-1497983863.
Thanks for the link! I've actually used tree shaking (and dead code elimination via the uglify plugin) in webpack before, following something very similar to this link. But this is all done during/after bundling? It's definitely solving a similar problem, but I was hoping for a more static solution. My ideal solution would be a script that I run on my source code and it says "&gt; 'export foo' in ./file.ts is never used". Do you think there is a way to use the tree-shaking feature of webpack (along with source-maps maybe?) to find which source code is never used? That sounds like a lot more work than I would want to put in. A stupid way might be to use regexp to search for all `export const ____ =` and then search for all `import { ____ } from `. But after thinking about it for 2 seconds it seems like there are too many cases for a simple regexp. A better solution would probably be to use the typescript parser and compiler.
Really great articles Marius! 
Probably because it should be similar to Javascript, especially being a superset of it (unlike languages like CoffeeScript or Dart).
Agree. Or, it could go with something similar to python: function createSquare(config: SquareConfig) -&gt; Tuple[string, number] { // content }
Coming from Java, Scala et all I really like inline types. Though it makes sense why Haskell keeps it separate, as it doesn't actually need the annotations to infer types. I wonder if TS could reuse the function overload syntax for annotations (note that today it'll infer the 2nd line as `any -&gt; any`): function createSquare(config: SquareConfig): {color: string; area: number} function createSquare(config) { ... }
The comments on the indexer even says so. "Special keys start with '!'". Looks like "special" here means of a different type than the indexer though. They're just properties like any other, except since they're not valid identifiers, you have to access them using ["!cols"] or whatever.
the exclamation mark here is just convention by the author of the code the exclamation mark is used elsewhere in typescript to denote a field which you know to be non-null/non-undefined but the compiler does not (under the `--strict` or `--strictNullCheck` flag). 
I don't really understand what string enums provide that string literals don't -- can someone enlighten me?
It's "more" type safe - e.g. member renaming works.
I've been working in a project like this recently, check it out, we're using similar tech https://github.com/alexjoverm/typescript-library-starter
That's true -- I suppose it also forces you to declare an explicit dependency in that you have to import the enum. Doesn't really seem like it will improve the type checker much, but certainly nice as a development tool!
Maybe an ability to mix TS &amp; JS modules in projects? Correct me if I'm wrong. TS itself recently added the ability to mix JS modules in.
Hey that's cool. I've used nominal types for Symbols before, but it didn't occur to me to write them as an intersection so that I still get all the `number` methods and compatibility with mathematical operators.
Yeah, TS already has the ability to ingest and transpile a mix of TS and JS. I think the big benefit here is that projects can use Babel as their transpiler when they need certain Babel plugins or custom code emitters. Also, Babylon-based tools such as linters can now ingest TypeScript. EDIT: *can use Babel as their transpiler without first using TS to strip type annotations. A two-step build was already possible since TS can strip annotations without doing downlevel transpilation.
ESLint is my absolute favourite linting tool, and it sucked that nothing like it existed for TypeScript. Now I can use ESLint on TypeScript, using the Babel plugin.
[TSLint?](https://palantir.github.io/tslint/)
Babel plugins to modify code, I guess? I'm not sure. Seems to be a small use-case.
One cool thing is tools like jscodeshift will be available to Typescript users.
It sounds like you are running afoul of [this](https://github.com/Microsoft/TypeScript/issues/16772#issuecomment-311761959). Upgrading to ts-loader@2.2.1 should help.
This article completely missed the fact that flow is a type checker but TypeScript is a type checker and transpiler which means you can get cross browser support for ES7 down graded to ES3. Async await on IE6 if you had too. Further flow is built using OCAML and has poor Windows support. You gotta dog food your language. Thats why TypeScript is written in TypeScript. Anders Hejlsberg states this is important many times. 
Hey all, since a lot of people are asking, this is something experimental at this point, mainly to help existing Babel users pick up TypeScript more easily. Something we hear from a lot of folks with existing stacks is that rewiring a build system can be absolutely daunting. Similar to the `checkJs` feature that helped users incrementally start adding types to their code, we want to make it easier tor people with existing build infrastructure move to TypeScript as well. tsc is still going to continue to be the primary means we recommend, but hopefully for a lot of people this makes TypeScript an easier proposition. :) Plus, this gives more choice to users in the TypeScript community. If you're not a fan of choice, just go with the prescribed option. If you need something from the Babel ecosystem, then you're covered. I think the collaboration is a net win for everyone.
I've responded [here](https://www.reddit.com/r/typescript/comments/6k6dhw/babels_parser_now_supports_typescript/djn0pav/) if you're still curious. TL;DR is it doesn't mean a ton for existing users, but it means you have more options if you'd like.
On compatibility via transpilation: You're correct that this is a plus in general, but Reddit already had transpilation in their pipeline and plugged TS in ahead of it. &gt; At Reddit, we had an existing build process using Babel as a transpilation layer. Since they're gluing onto an existing Babel setup, there's no added advantage here in Reddit's specific case.
That's a good point. Missed that. I'd also be interested to hear why it made their build process way more complicated 
&gt; Flow’s type annotations are automatically removed by Babel This is the real difference. Babel already supports Flow so there's no real pipeline change. TS in theory is also just code transformation, but it's not integrated with Babel so now they have two transpilation steps one after the other, along with the path resolution changes to feed TS output into Babel input and manage any imports from one side to the other. 
Good news is Babel now supports TypeScript so they can make that easier, but I'm not sure of the value of using Babel when you're targeting TypeScript. I'd probably have ejected Babel from the pipeline. 
Partial adoption. They have existing code to support that's tested and integrated using Babel. Also Babel only supports *parsing* TS at this point. Can't actually be used for typechecking or compilation.
Depending on your needs, babel can be pretty handy. They can do target-based polyfilling, for example. I almost always have it in my webpack workflow.
Regarding covariance/contravariance, the example given isn't very realistic. TypeScript checks to see if the object you're pushing into the array has the type's properties rather than the requiring objects be the type; add a single property to the Bird class and the example code will cause a compile error. class Animal {} class Bird extends Animal {public name:string } const foo: Array&lt;Bird&gt; = []; foo.push(new Animal()); //TS2345:Argument of type 'Animal' is not assignable to parameter of type 'Bird'. Property 'name' is missing in type 'Animal'. I can understand why that would be troubling to some people, but I think it's a good compromise for easier development because you can use an object literal or an untyped JSON response rather than casting or creating a new object instance. let bb = new Bird() bb.name = "Big Bird" foo.push(bb) // let's shorten that code: foo.push({name: "Big Bird"})
That helps, it explains a bit. I don't really have a build system yet. 
I'm confused why you even have to do this since TS will typically infer the type of your generics.
If you have some class T that has some property which is later defined it cannot be inferred initially. The authors first example showed this the best! 
[removed]
use .bind to create a new unique function for each event binding. I would also append the btn to the parent before attaching the event
Use `let` instead of `var` to get block scoping.
thanks! works. 
Base Types Extensions like in Kotlin would be an awesome feature :) It allows you to extend base types without extending it, more https://kotlinlang.org/docs/reference/extensions.html
This is pretty neat!
I really like Vue, but this part makes me hesitant &gt; We'll be using a custom repository that uses experimental declarations for Vue. These declarations are currently maintained on a fork of Vue, but may be part of the main repo in the near future.
In one sentence, when is this useful?
Anytime you want to transform an action based on information provided by APIs. (other situations too though) 
You probably do not want to put it in the Global Scope, but rather have it around in all relevant places in your application. export a module, call it Utils or whatever and export this function with it. Everywhere else in your code import the Utils module and call the function within. [Avoid globals.](https://www.w3.org/wiki/JavaScript_best_practices#Avoid_globals)
&gt; Avoid globals. Sorry, I should have stated that the global is strictly for testing / protractor. I figured out the solution by using it as a module in each test, but thanks for the reply.
Sure thing, no Problem
The whole module is a class. declare module 'listr' { class listr { ... } export = listr; } EDIT If you need to import it import listr = require('listr'); 
this produces a red squigly line in visual studio code giving the error `[ts] Exports and export assignments are not permitted in module augmentations.` compiling it with `tsc` gives: src/index.ts (1,24): Module '"/mnt/c/dev/.../src/typings/listr"' resolves to a non-module entity and cannot be imported using this construct. (2497) src/index.ts(1,24): error TS2497: Module '"/mnt/c/dev/.../src/typings/listr"' resolves to a non-module entity and cannot be imported using this construct. src/typings/listr.d.ts(40,3): error TS2666: Exports and export assignments are not permitted in module augmentations. 
&gt; An ES6 module namespace object cannot be invoked as a function or with new. https://stackoverflow.com/questions/39415661/what-does-resolves-to-a-non-module-entity-and-cannot-be-imported-using-this#39415662 You can keep that documentation, but you'll have to use CommonJs; import listr= require('listr'); Or use a workaround in the documentation to use import * as listr. declare module 'listr' { class listr { ... } namespace listr{} export = listr; } This also could work. declare module 'listr' { class listr { ... } const static = listr; export = static; } 
I got it working using `import listr = require('listr');` in `index.ts` and: declare module 'listr' { class listr { ... } } in `typings/listr.d.ts` It works perfectly for the issue I have described, there's still a small hiccup, i omitted the generics from the original question in order to keep it as simple as possible, my definition is actually like this in `typings/listr.d.ts`: declare module 'listr' { class listr&lt;T&gt; { ... } } However the compiler will complain when i instantiate like this `new listr&lt;listr_ctx&gt;([{...`, changing it to `new listr.listr&lt;listr_ctx&gt;([{...` will satisfy the compiler, but stil fail at runtime with: new listr.listr&lt;listr_ctx&gt;([{ ^ TypeError: listr.listr is not a constructor It's not a gamebreaker, but for the purpose of learning how to do this correctly, how would I solve this? ###EDIT For the sake of lookup, `node_modules/listr/index.js` exports as such: class Listr { constructor(tasks, opts) { ... } ... } module.exports = Listr; 
You need to export listr in the module declaration *"export = listr"*. d.ts declare module 'listr' { class listr { ... } export = listr; } yourfile.ts import Listr = require('listr'); let instance = new Listr&lt;Anything&gt;();
[Well the PR](https://github.com/vuejs/vue/pull/5887) has been signed off on but it isn't in yet. If all goes according to plan, it'll be ready for Vue 2.5. You should still give it a shot if you just want to try things out.
`export = listr;` doesn't work: `error TS2666: Exports and export assignments are not permitted in module augmentations.`
**Solved it** The key was to drop `declare module 'listr' {...}`, I could then use `export = listr` together with `import listr = require('listr');` Thanks for the help Gapplay
Get rid of the dual require. Your second require statement is returning a value of type `any`, which is why the compiler doesn't care when you assign it to `argv`. Do this instead: const argv = yargs as yargs_config; Here you're using an explicit type assertion to tell the compiler that you want to treat `yargs` as a more specific type. This isn't yargs-specific; it's a general mechanism for telling the compiler to trust you when you know that a value is, in actuality, of a more specific type.
Can't wait to try this together with react :)
Hi, I'm the author of this new book on TypeScript. If you can spare a moment, I'd obviously love some feedback either here or through the gitbook tools. TIA. 
This works perfectly, thank you cspotcode
This is awesome!I been looking for something like this. Do you think is possible to have a similar closure compiler setup using angular 1.x? Good work by the way.
Oh, it's not my work. I just thought it was cool to share as I want this to improve a lot. I looked through the sample and it seems it should also work for angular 1.x but I have not tested it. The tsconfig specifies where the transpiled javascript files go: https://github.com/angular/closure-demo/blob/master/src/tsconfig.json In the closure.conf it specifies where the transpiled javascript and other library javascript files are found: https://github.com/angular/closure-demo/blob/master/closure.conf I actually use angular 1 as well and have wanted to use closure. I will post when I get a chance to do that (probably not soon enough).
I do like being able to use typescript in one file components. I hope this is in 2.5. Thanks
Are there many other TypeScript learning books? Yours looks good, but could you share a couple more that you were thinking of as you wrote this?
Good luck wasting one year of your life. Are you really good at numerical analisys and like design patterns and such. How's your linear algebra? Do it man!
What a weird comment... People should be encouraged to create open source projects. At the minimum he'll learn a lot and get some feedback, or maybe he makes an amazing game engine we can all enjoy!
Sure! When I first started writing I only knew about the TypeScript Deep Dive book (https://basarat.gitbooks.io/typescript/). Microsoft provides pretty good information on their typescriptlang web site too. Even though that's not a "book" it seems bookish, if you know what I mean. As I continued on the project, I checked on Amazon and found several: https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=typescript. I have no idea as to the quality of any of them. Lastly, two weeks ago, I was approached by PACKT to write a book on SharePoint development. I told them this one was nearly finished, but haven't heard back :). I checked their site and they have at least two. It seems like there are least 8 out there, not including mine. 
Well he isn't wrong, just an asshole. I am working on [something similar](https://github.com/Kloranthy/angular-game-client-demo) and have had to learn a lot of math stuff. I still need to figure out matrices well enough to do the transforms between coordinate systems... and figure out how to get the normals from the frustum planes in a left handed coordinate system... All in all I have enjoyed working with TypeScript/Angular, have definitely learned a lot, and would be down to collaborate if you wanted. You mention ray-casting in the readme, I found three tutorials on ray-casting that were pretty helpful. The [first](http://www.playfuljs.com/a-first-person-engine-in-265-lines/) is a good introduction but uses JavaScript, makes some restricting decisions, and doesn't explain the backing concepts enough. The [second](http://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/) is a little old but offers a lot of explanation. The tutorial is very informative but the [example implementation](http://permadi.com/java/rayc/Rayc.java) is a little confusing as it does some hackish stuff with angles being pixels. The [last](http://lodev.org/cgtutor/raycasting.html) is my favourite as it offers the most technical detail, although it does tell you to learn the math stuff on your own. Mathisfun has been the most helpful to me as it gives thorough and understandable explanations. Wikipedia has been somewhat helpful for learning the names of concepts but is not very good at teaching them. [This site](http://www.lighthouse3d.com/tutorials/maths/plane/) is ok at explaining some of the math stuff, but assumes you are using OpenGL. [This presentation](http://legends2k.github.io/2d-transforms-101/#/) is extremely good, and I need to go through it again when I'm ready to start adding matrix stuff.
Somebody embarks on a journey to learn, and wants to share the fruits of that with the world. Of course they deserve that vitriol.
Seems interesting, I've done and worked a bit on something similar. Maybe I'll pitch in if you like!
Sure, that would be great! I've always wanted to build a simple game engine.
Thanks for the links! This is definitely going to be a free time / on the weekend d project for a long time.
I'm stocked by your developer tools!
If you have any questions as you go feel free to PM me. I've made many types of 2d (and a couple small 3d) engines in the past. I don't have time to contribute actual code, but happy to review/give pointers.
And what does it do? You don't expect me to follow your link with no information, right? :D
I did, I won't in the future.
here's mine: { // Use IntelliSense to learn about possible Node.js debug attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ { "type": "node", "request": "launch", "name": "Launch Program", "program": "${workspaceRoot}/dist/app.js", "sourceMaps": true, "outFiles": [ "${workspaceRoot}/dist/**/*.js" ], "env":{ "NODE_ENV": "development" } }, { "type": "node", "request": "attach", "name": "Attach to Process", "processId": "${command:PickProcess}", "port": 5858, "restart": true } ] }
[The more you know... ](http://gph.is/2p2zNlf)
This is basically what I use for my launch.json. Do you have to manually build first, too?
thanks but can you set breakpoints in ts code? cause I can't get them to trigger :/ { "version": "0.2.0", "configurations": [ { "type": "node", "request": "launch", "console": "internalConsole", "name": "Launch Program", "program": "${workspaceRoot}\\built\\local\\tsc.js", //"outDir": "${workspaceRoot}\\built\\local", "outFiles": [ "${workspaceRoot}\\built\\local\\**\\*.js" ], "args": [ "-v"/*"built\\local\\test.ts"*/ ], "sourceMaps": true, "cwd": "${workspaceRoot}" } ] }
I want to star your hair
/u/wisepresident /u/twomousepads i have the typescript compiler watching for file changes (**tsc -w**), so everything is recompiled automatically whenever i save. if you're not able to add breakpoints to TS code, i'd guess it has to do with your source maps. does your launch.json have that **"sourceMaps": true** line? and are your sourcemaps configured properly in your compiler config (tsconfig.json)? personally, i use inline source maps, which looks like this in the config: /* Source Map Options */ // "sourceRoot": "./src" /* Specify the location where debugger should locate TypeScript files instead of source locations. */ // "mapRoot": "./", /* Specify the location where debugger should locate map files instead of generated locations. */ "inlineSourceMap": true, /* Emit a single file with source maps instead of having a separate file. */ // "inlineSources": true, 
Brilliant, thank you!
Haha, thanks😂
There's no need for the `export module` syntax here. What you want to do is, instead of importing a module and augmenting it, define the module somewhere else, then import and re-export it from another file. In this situation, you'd do something like this. submodule.ts: export function foo() {} export function bar() {} core.ts: import * as subModule from './submodule' export class Test {} export { subModule } main: import * as core from './core' // use core.Test, core.subModule.foo, core.subModule.bar 
Thats it, you are my Hero! Thank you very much! :)
Is there a source code available ?
Plays very well. Would love to see the sources...
I have asked the author, waiting for his response.
So frustrating when people post this without any source code.... It doesn't really help people learn typescript and ends up just being another pacman clone.
The "no implicit any" error means that TSC wants *everything* to be labeled with its type, and it will throw an error for every case that this isn't true. To disable this behavior, you can set the option "noImplicitAny" to false in the compiler options section of your tsconfig file.
Okay. What would be the right type if I don't specify "any"? Is there something more best-practice like?
And that relates to this question... how?
Would you mind putting your code in the OP, or linking to it as plaintext (even if it is just a dummy example)? It will be much easier to help if I can copy and paste examples rather than transcribing from the screenshot. Edit: Just wanted to add that this is generally the etiquette when asking for programming help anywhere online, so it is a good thing to keep in mind any time you are asking for help online.
I wouldn't recommend turning off `noImplicitAny`. This rule doesn't require all variables to be explicitly typed, it just throws an error when tsc cannot infer the type (and so it infers it implicitly to `any`). Most types can be inferred in many cases, e.g. `const foo = 5;` will not throw, as `foo` can be inferred to be the number literal type `5` (a subtype of `number`). If d3 types are correct, you also should rarely need to explicitly type most of your variables. For example, in `let svg: any = d3.select(...)` you should be able to drop the `any` -- tsc knows that `svg` is a `Selection&lt;GElement, OldDatum, HTMLElement, any&gt;` (as per the typings: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts#L102). In your existing code, I believe tsc is yelling at you since some of your callback params are untyped (and tsc has a much harder time inferring callback param types), near the bottom of your code (`.attr("y", function(d, i) {`, `d` and `i` are implicitly `any`). Many IDEs with intellisense will tell you the expected types, but you can always refer to the type definition itself. In this case it looks like your usage of `attr` with a callback expects a `ValueFn&lt;GElement, Datum, string | number | boolean | null&gt;` (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts#L281). Looking at the definition of `ValueFn` (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/d3-selection/index.d.ts#L69), it looks like the first arg is a `Datum` and the 2nd arg a `number`, so I would expect specifying types like so would work: `function(d: d3.Datum, i: number)`. I would usually browse these type definitions in an IDE.
This deserves more upvotes. 
Glad you like it 😀 
Scope is a Facebook Messenger bot that identifies songs from lyrics/titles. Scope returns detailed information about songs it matches including title, artist, album, release date, recording location, BPM, key, samples, featured artists, producers and writers (where available). Scope also returns direct Spotify, Apple Music, Soundcloud, YouTube and Genius links to the song. Scope is powered by Genius and Spotify APIs so matches are slightly biased towards hiphop and rap music (Genius started off as Rap Genius). It's easy to scope a song - just send a message starting with 'scope' followed by the lyric/title you're after (e.g. scope waves). Scope will reply with details of the closest match. If Scope matches the wrong song, simply reply with the word 'wrong' to select from the next best matches. Hit up Scope at https://m.me/scopebot or https://facebook.com/scopebot Vimeo demo at https://vimeo.com/225540115 Technologies Used - Node.js - TypeScript - Terraform - Lex - Lambda - CodeBuild/CodePipeline - Facebook Messenger Platform - Spotify API - Genius API
I know it's not a rule or anything but why post a link to a tweet that has a link the relevant content?
In the hopes that those who find it useful would retweet it so it reaches more people. 😀 
Is it open source?
That's cool but why not use [ts-option](https://www.npmjs.com/package/ts-option)? It has support for pattern matching and a limited for-comprehension.
ts-option's inference is not as good as tsoption, making it far less safe. For example, with ts-option (comments are what is known at *compile time*): let a = option(3) // Option&lt;number&gt; let b = some(3).map(_ =&gt; _ + 1) // Option&lt;number&gt; let c = some(3).map(_ =&gt; null) // Option&lt;any&gt; let d = some(3).isEmpty // boolean And the same code with tsoption: let a = Option(3) // Some&lt;number&gt; let b = Some(3).map(_ =&gt; _ + 1) // Some&lt;number&gt; let c = some(3).map(_ =&gt; null) // None&lt;number&gt; let d = Some(3).isEmpty() // false
You can specify the typing of this as a fake argument parameter ``` class A { method(this: A, other: string, parameters: number) {} } ``` Also, you should be using () =&gt; {} to preserve the value of this. 
The only way around it is to compile to ES 6 which supports arrow functions.
The problem is that `this`'s value is not not accurate during debugging. While I'm coding, the data type of `this` is accurate. But when I debug, and I hover over `this` to get its value, it points to nothing or a wrong `this`. What you mentioned puts the correct datatype of `this` but doesn't help with debugging. In debug mode, `this` doesn't exist, or points to something else so the debug gives me false information.
So the value of `this` is accurate?
Yes, since TS will compile to native arrow functions which have correct `this` in the browser/vm.
Before switching to ES6 (which is a good idea if your production environment supports it), you should learn and understand how 'this' works in JavaScript and how fat arrow syntax solves the problem you are having. It will make debugging in the future a lot more helpful
I find turning off black box debugging in chrome makes debugging easier to understand and easier to modify the code at run time if need be. You'll see that this is complied as _this, which you can reference in the console.
Sometimes I add resolve aliases into webpack for commonly imported things. I'm sorry I don't know any other solutions
I've seen it, and I've gotten used to looking at `_this` instead, but it does feel like that shouldn't be necessary. Effectively, it's a mismatch between the devtools showing the typescript code (thanks to the sourcemap support), and yet ignoring the typescript symbols (and only using javascript symbols during debugging.) There's a chromium issue about that stuff https://bugs.chromium.org/p/chromium/issues/detail?id=327092 which seems to hint that: 1. the sourcemap spec supports symbol mapping and that 2. chromium devtools have implemented something about it, although it's not entirely clear what that's supposed to do and not do. Notably, there's no obvious clue that the typescript compiler outputs symbol maps in its source maps, which would be prerequisite for any of this to get better. Also, it could be confusing. `this` when stepping through code has a definite value, which isn't supposed to change depending on whether you're looking at a javascript file or its typescript-mapped equivalent, which are often just one source tab away from each other. That could stop being true if typescript symbols become accessible. Maybe there's a clever way to make this all work without ambiguity. 
I sorta find myself in the same situation where the types exist for a library but there are absolutely no examples of usage, and usually a generic uses single letters for the types. I've gotten myself into a semi working setup for annotating actions and reducers based on cobbling together other people's blog posts. It doesn't make it easier that there are a lot of ways to organise your redux setup. 
Check out the baseUrl property in tsconfig.json
Hello! There is a way to avoid this and it is quite easy :) Lets assume that you have sources in 'src' folder. First of all you must let TypeScript know that you will be using non-relative path by setting baseUrl in tsconfig.json: { compilerOptions: { "baseUrl": "./src" } } This will tell TypeScript that you will be using base path and you may now use absolute that, for example if you have file in ./src/service/users.ts, then you may import it with: import * as Users from 'service/users'; The second step is to make sure that RUNTIME will understand our paths and this step differs if you are making browser(or electron or cordova) app and node.js backend app. For frontends, using webpack and awesome-typescript-loader: Edit your webpack config, in resolve.modules put this: path.resolve( __dirname , './src' ) , Example: https://github.com/nullptr128/openheroes2/blob/master/webpack/editor.js For backends using node.js, you must create a wrapper script that will use app-module-path module, add src/ folder as root path and them require() your main script (note: require is mandatory over import here): require( 'app-module-path' ).addPath( './src/' ); require( './src/index' ); And now you can use non-relative paths in your TS project.
Or you avoid them altogether and write `var self = this` and use self throughout the closure.
Does nothing more than prevents errors... im looking for a Proper way
This is the thing man whats the point then to have those options if i end up using a third partu solution fixing my imports?
Right now i wrote a prebuild script that transforms my ts absolute paths or whatever o have set up to relative paths.
This is the best answer. In fact, I always compile to ES6/7 for debug builds since the debugging experience is so much nicer without source maps.
Microsoft put out a [TypeScript/React starter](https://github.com/Microsoft/TypeScript-React-Starter); maybe that might work for you, good luck! EDIT: Btw, many suspect Microsoft did this to help promote use of their [Fabric framework](https://dev.office.com/fabric#/components); haven't used it but it seems like a pretty good UI framework to me. At least you know its well supported.
The ecosystem of Typescript commonly separates the Typescript compilation process and actual project build process and requires third party stuff like webpack and webpack plugins, but it is reliable, tried, and tested. Path mapping is a feature that must be configured in both your Typescript configuration so that the Typescript understands what you're referencing, and your build configuration so that things are built and linked correctly. It's unfortunate but it's certainly not a big deal. 
I think you didn't get my question i know very well the tsconfig paths, baseUrl and other parameters it offers. But whatever you think is good for you its good for you but sadly for me it's just an another "hacky" way. Additionally i don't want to use webpack, and there are no other alternatives to make this happen. Can you explain why this can't be done in typescript itself? I can't see any scenario when it would break any project if typescript suddenly would transfrom the absolute paths based on the tsconfig to relative paths.
I was in a similar position few weeks ago. What has helped me a lot are two guides I found. The first one is more basic, while the second one provides real-life examples on how to use TypeScript with Redux, what to put in your tsconfig.json and what are the best practices when using React with TypeScript. 1. https://github.com/Mercateo/react-with-typescript 2. https://github.com/piotrwitek/react-redux-typescript-guide 
Wait, if you're not using webpack or a bundler, why doesn't baseurl work for you? I'm not just suggesting a "hacky" way that works for me, I'm telling you that typescript does not do this out of the box other than allowing path mapping and baseurl configurations. I don't know what to tell you. There's no proper way, and at current it is out of the scope of the problem that the Typescript project is trying to fix. 
&gt; I don't know what to tell you. You don't have to tell me anything. All i want is that whatever i give to typescript it will use the paths config and transforms the path for every import. Wether i use webpack, my own bundler or whatever i want to use. Your webpack solution is worthless once you need to transform your own paths for the definition files. So the fact that typescript does resolve the paths but does not transform them is kinda stupid. I hope you see that :) They could've done it but they didn't WHY?. If they just transpile the paths to relative theres nothing to lose but to save the hassle for all the devs. I am not sure maybe my wording in my question is not clear let me know
Submit a feature request to the typescript project on github. 
Because TypeScript is not an complete environment. Its just a JS transpiler that has no idea about runtime and you must guide it manually.
&gt; My take is that the biggest benefit TS offers over Flow is that it provides d.ts files Flow has these as well. &gt; Also I'm guessing the tooling (ie: intellisense) situation for TS is a lot better than with Flow? This is the main reason we chose TypeScript at work. We all like VSCode and most of us prefer it to Atom, and the integration with VSCode is really fantastic. And as much as I like living on the bleeding edge, the TypeScript compiler feels a lot more "stable" since it's an all-in-one-solution (you won't get plugin nightmares). &gt; And... is there any particular aspect where Flow beats Typescript? Flowtype has much better type inference (which is pretty annoying) and has more types that help it be mathematically sound (which is not a design goal for TypeScript). This is a bit annoying, but as the TypeScript compiler gets more mature it's starting to be able to infer better. I've only come across a few cases where I've been bitten by TypeScript where FlowType would have worked just fine, but they're so rare I can't even remember them 
My understanding is that TypeScript intentionally decided not to be mathematically sound, because to be mathematically sound, it would break some semi-regularly-used patterns within Javascript, which would make representing libraries that relied on those patterns impossible to model with .d.ts definitions. Can you give an example of how Flow has better inference?
These look really helpful, thank you!
&gt; I've only come across a few cases where I've been bitten by TypeScript where FlowType would have worked just fine, but they're so rare I can't even remember them
Yeah, I read that. I assumed you were specifically referring to places where you've "been bitten by TypeScript", and that Flow having "much better inference" doesn't necessarily mean that you will be bitten in TypeScript by the same code. Wanted to be sure. I keep hearing that Flow has better inferencing but I still can't find any real-world examples of this using TS2.0+. 
Does Flow do down-level compilations or do you have to pair with babel or other? TS does it all on one toolchain with minimal fuss. Edit: legitimate question, btw, not trolling :)
 &gt;Flowtype has much better type inference (which is pretty annoying) and has more types that help it be mathematically sound (which is not a design goal for TypeScript). This is a bit annoying, but as the TypeScript compiler gets more mature it's starting to be able to infer better. I've only come across a few cases where I've been bitten by TypeScript where FlowType would have worked just fine, but they're so rare I can't even remember them I've found the bivariant gerics problem can pop up often in a lot of back end code. I really disliked how typescript doesn't include contravariant and covariant generics. The typescript developers reasoning for having bivariant generics is somewhat insulting too. They imply that covariance and contravariance is too complicated for a lot of JavaScript developers. As soon as intellij has better tooling for flow, in switching for that reason. 
Assuming there's a sub for flow, they're likely to know better if you don't get a response here. :)
I am sorry - I didn't know about that. I'm having a hard time formatting this properly, so I will link you to my question on stackoverflow, if that's okay: https://stackoverflow.com/questions/45132254/why-does-d3-not-work-properly-with-typescript
You can let a babel plugin generate .js.flow files for you. Which is the same as a .d.ts file for TypeScript. Here is a [Medium](https://medium.com/@ryyppy/shipping-flowtype-definitions-in-npm-packages-c987917efb65?source=linkShare-8024d0bbfabd-1500274016) post on how to config a setup for this. I dropped TypeScript because when developing react-native apps, you sometimes need platform specific code with a file extension like .ios.js and .android.js. Flow handles things like that really well as you can config it to ignore the .android.js files and use .ios.js files like normal .js files. As flow is no compiler as TypeScript both of those platform specific files are compiled by babel, ignoring the flow config. But if you are not going to write react-native apps, I recommend using TypeScript because the intellisense autocomplete is so much better IMHO...
Wow, I see. That is kind of a lot of insight and it makes sense. Thank you very much for that. Do you mean browsing type definitions with "Peek definition", for example?
My 2 cents: about soundness - I actually have HUGE application I am developing now, with services, patterns, factories, type guards on backend and frontend and... I stumbled into structural typing problem once or twice and it never did bad to my productivity or mood. You know, just plan nicely, keep in mind that this is structural and don't be a drama queen when Dog with name and Car with name are === at compile time. Separate them, lol. I migrated from Flow to TypeScript and now I code not in JS with flow, which have often problems with speed of checking in IDE (also VSCode ftw), I code in TypeScript. I mean like separate language that is like js but better. Of course I know that it's just JS, but my coding experience drastically changed. From coding in god knows what with js (+/- flow) I started coding in something like C# for the web. And you know what? I was never delighted so much developing things for the web before.
It depends on your IDE, but that sounds right. In intellij, for example, I can cmd-hover over items, like so: http://i.imgur.com/CindIoc.png. I can then click through to find the actual props, like: http://i.imgur.com/W09RXo8.png. Ideally, the lib you're using would have good typescript docs so you can avoid doing this and just use the docs: http://blueprintjs.com/docs/#core/components/button.button. Similarly, if your IDE has good intellisense, it should show you inferred types, like: http://i.imgur.com/HNQZZlO.png. I actually haven't found intellij to be great about this, but vscode has very good intellisense. Useful cause again most of the time you shouldn't need to explicitly type your data, as it can be inferred, so this is a nice way to see what e.g. a variable actually resolves to without having to peek the definitions.
Flow is a crutch for JS which adds noise to the code (not much, but still). TS is a language built with types in mind from ground-up, so it feels the same as other typed languages everyone is used to. I don't like crutches.
The ground being JS
https://blogs.msdn.microsoft.com/typescript/2017/06/27/announcing-typescript-2-4/
Unfortunately that's more of just a type inferencing fix. It still doesn't let you specify whether or not a type parameter is covariant, non variant, or contravariant. Unless I'm reading it wrong.
Right, you can't specify however it does check for correct usage.
There's something called (jsdoc)[usejsdoc.org/about-getting-started.html] that you can use. Basically you comment at the top of your function, class or whatever with certain "keywords" starting with the "@" symbol and jsdoc can create an API document out of that (or just enhance parameter hinting in your ide)
There's [typedoc](https://github.com/TypeStrong/typedoc). When I tried using it it didn't support up-to-date tsc/tsconfig options, but it looks like it's been updated since then.
Hi, OP of the first post you mentionned her :-) You can check the following GitHub repos for examples of charts written with TS and d3 v4: https://github.com/Ledragon/MakeOverMonday2017 https://github.com/Ledragon/ldd3 If you want to start from a blank slate, just clone https://github.com/Ledragon/d3-v4-ts-seed This will configure tsc and rollup. Run npm install, and npm start. You should get a nice blue circle in your browser. I am thinking about writing a new series on using Typescript with d3 v4, and was unsure there was demand...
I played a bit with [tsoa](https://github.com/lukeautry/tsoa) the other day and it looks like it fits your need. It adds decorators (that are essentially noop functions to keep the compiled js clean) that are used to generate the swagger.json documentation.
A small library I made to aid when using knex (but it could be used for any database access library) to cast the return object to the actual table schema. If you have any suggestions do let me know. 
Wow, that's kinda pretty cool. Thank you for your answer. I will try doing it that way. Is there a lot of difference between v3 and v4 in TypeScript? As I understood, it's just the syntax?
Same here! I only found tutorial with old things!
It is true, once you learn TypeScript, you won't want to write even a hello world app without static typechecking.
Nice. Now I just need a combination of this with this lib: https://github.com/hediet/ts-typed-sql and I'm happy. I just tried this on a PostgreSQL database, and it only seems to extract the tables in the public schema, is that correct?
In using TypeScript in itself, not that much difference. However, using v4 lead me to learn how to use ES6 modules, and therefore structuring my code better. The modularity of the new version offers greater flexibility and smaller bundles, but this is not specific to TypeScript. The way to retrieve the types using npm and @types is also new, but not specific to d3. So this all made me feel like working with something totally new...
To be honest I only have minimal experience with PostgreSQL. It currently only exports the public schema but I'll read a little more on it and post a fix.
Interesting, I saw that when poking around and passed by it pretty quickly because it looked like it needed a lot of custom code annotation. I'll take another look at it. Thanks for the suggestion!
This did look pretty close to what I was looking for. The controller structure and annotations looks familiar from a Spring standpoint, but I didn't know how native annotations were to TypeScript. Are they built into TypeScript or an add in? I haven't see them elsewhere.
When it comes to typescript, wouldn't webstorm be more relevant? Don't get me wrong, the jetbrains products are awesome but webstorm seems more tailored for typescript than intellij idea.
Free CE vs. paid maybe? Not sure really, just a guess...
You might look into this project by a colleague of mine and see if you can't join forces. https://github.com/SweetIQ/schemats A tricky one is to try and get SQLite support in the future.
They're called Decorators in TypeScript and are arguably much more powerful than Javas (non-compiler plugin) annotations. https://www.typescriptlang.org/docs/handbook/decorators.html
Is this viable for new apps now? 
They are builtin but behind an experimental flag because the proposal is still at stage 0 on ecmascript.
If you are looking for a good typescript ide then perhaps look at visual studio code. I am not the biggest MS fan, but I see their approach to the development of typescript and the visual studio code ide as a huge cultural shift. Imagine 10 years ago MS creating an open, cross platform language, compiling into a competitors language, another competitors runtime engine and officially supporting it on 2 competing operating systems. Without any .NET. then making it free and open source. Heads would have rolled. Yet here we are. And it's my IDE of choice right now.
 let c = some(3).map(_ =&gt; null) // None&lt;number&gt; Is that right, though? Why would a return value of `null` in map return a `None` and not a `Some&lt;null&gt;` or `Some&lt;any&gt;`? I'd expect `map` to return a `None` only if it's called on a `None` in the first place.
IntelliJ Ultimate contains everything WebStorm has, so I would say it's still relevant.
Neat, I knew I couldn’t have been the only person with this idea. I’ll lend a hand and take a look into that SQLite support. 
The title of this is a little more prescriptive than the the actual article. it's more of a question on the merits of passing a single object as parameters to a function vs. multiple parameters.
You are setting the switch to be on temp = temperature.cold, so you'll never be able to compare temperature.cold to temperature.hot. You should probably do something like switch (temperature) { case temperature.cold: console.log("Brrr...."); break; case temperature.hot: console.log("Yikes...") break; } With he switch on the actual enum, and then switch on the case of the enum EDIT: Not sure which version of Typescript you are using, but I just put that into a fiddle, and your code compiled fine, but gave what I probably would have expected that it can only ever hit temperature.cold as the value you are switching on is temperature.cold. It's probably a good thing that the compiler you are using stops it though, as it's not correct. You cannot compare the enum value .cold to .hot (they will get transpiled down into a number value anyway, so switch(0) { case 0; //it's cold case 1; /will never get hit }
Got an answer here. It boils down to the fact that the compiler that I use knows that case temperature.hot can never be hit since temp is hardcoded to be temperature.cold: https://stackoverflow.com/questions/45197320/typescript-switch-statement-throws-not-comparable-to-type-error/45197975#45197975
I've pushed a quick fix for this. 
 let temp: temperature = temperature.cold;
Nice! Doesn't seem to work though, it outputs empty interfaces for all tables not in the public schema for me. Also you definitely need to seperate the schemas (probably best into seperate `namespace schemaname {}`), because I have multiple tables with the same name in different schemas.
I have no real experience with game dev. but i am a JS/TS dev coming from C# too. Seems to me that it's not a TS problem but just a general OOP problem so my answer is dont be afraid to look at how it's done in C#/Java and just port that reasoning to TS :)
I like the behavior in practice, it makes options really nice to use. The downside is because of that behavior, they're not proper functors. I've been testing out the behavior you want in https://github.com/bcherny/tsoption/tree/fantasyland, give it a shot.
There should be a "I have heard of it but have not used it" just because i have heard of it I might not have used it or decided if it works for me or not
This isn't much more than testing how many frameworks and utilities you recognize by name. It's missing important options like "I have no opinion" and it barely touches on any real "state of the language" questions at all (probably hard to make multi-choice anyway). It doesn't even ask whether JS is your primary language, or if/why you even use it (or don't use it).
Gah, I fell into the "it works on my machine" trap. I know what the issue is here, I've made an issue on the Github so others also know. Good idea about namespaces. I want to make the default exported file as basic as possible so I'll probably make it a config option and have it namespace the database/schema name. Would it be beneficial to have a `schemas` config option for specifying which schemas should be exported?
Nice. I reckon linting rules for this would prove popular. A article could do with mentioning default parameters too.
The only place I'm aware of that differs these days is parameters. Take the code function Double(x) { return x*2; } Flow will infer that x must be of type number and therefore let y = Double("2"); Will throw an error. Typescript is perfectly happy with that code. Both ts and flow know that y will be a number since both infer the output of the function. The reason some people don't like that is that typescript is just as happy with let y = Double("abd"); We know that's a runtime error. Flow won't allow strings in either case because it infers that the input has to be a number unless told otherwise. Typescript is permissive and assumes that if the parameter was untyped that the developer is taking on the burden of only sending numbers or values coercible to numbers into the function. And yes this is by design. The typescript team is attempting to be permissive and support existing Javascript styles. The flow team is trying to make a strict type system that won't allow possible run time errors if it can at all help it.
+1. With a single object parameters you can't specify default values. Furthermore, even if you do have a defusing behavior for a lack of one of the options (param.foo = undefined) it's not mentioned or backed by intellisense.
Why would anyone use something other than Visual Studio Code for typescript? 
I suppose you could use object destructing within the function body: private assignIconClickHandlers( params: { itemIDSelector?: string, childrenSelector?: string, onClickFunction?: () =&gt; void } ) { const { itemIDSelector = 'default_itemIDSelector_value', childrenSelector= 'default_childrenSelector_value', onClickFunction= (event) =&gt; console.log(event.target.value), } = params; $(params.itemIDSelector).children(params.childrenSelector).click(params.onClickFunction); } Or do something like this: https://blog.mariusschulz.com/2015/11/13/typing-destructured-object-parameters-in-typescript Both are horrendously verbose, so I probably wont use single param objects at all. edit: code formatting
Webstorm has some advantages, but is not free. See comments about the advantages are here: https://www.reddit.com/r/javascript/comments/6o66pv/webstorm_20172_is_released/ But VS Code is fantastic as well. I came from Webstorm, used VS Code for a year but are now back at Webstorm. Mainly code intelligence is better and it's more "packed with features", which can be an advantage or disadvantage.
Muscle memory, build environments, developing across multiple languages...etc
Very good points. Thanks for the responses. I've been living with it for a while. So far, the convenience of it outweighs the default params problems you guys point out. If that was important for some particular method / function, no need to pass the object.
[This is npm's count for TypeScript](https://www.npmjs.com/package/typescript). 
As for an example use case, I'm using IntelliJ Ultimate. I do both front-end and back-end work at the same time, so not having to switch IDEs/editors to access the front-end part is a huge productivity booster.
Loved this. I posted a few days ago because I was struggling to understand how TypeScript fits into things and this helps clear things up from the other side a bit, what the module makers do.
&gt; 164,465 downloads in the last day &gt; &gt; 1,107,259 downloads in the last week &gt; &gt; 4,994,844 downloads in the last month Not bad. Most probably comes from automated builds but a lot of projects must be using it.
You can just import a script in the html but you will have no typing context for it. You have to know what var or whatever the script is going to expose and then you can access it by adding declare var $LibVar; It will be type any so it will compile no matter what functions or members you access on it. The other way is to include the typings for the library which is usually done with the npm command npm install @types/&lt;package&gt; That will enable you to do a proper import statement and give you typing information on the libraries but the libraries have to support it. The good news is these days a lot of libraries do. Offhand I don't know if systemjs does but honestly I'd be pretty surprised if it doesn't.
This may be a long shot, but try "ES5" instead of "es5"... I had that issue on an IDE (can't remember which) 
Thanks for your reply! Unfortunately, that didn't work. It seems it's not reading my tscfonfig.json file for some reason. I can also force it from terminal with: tsc --target ES5 main.ts , but it's not really ideal either. :/
My guess is that it isn't looking at the correct directory somehow. Does it still happen if you point `tsc` at the tsconfig file directly?
Thanks for the reply! point tsc at the tsconfig how? If I do "tsc tsconfig.json" in the terminal I get an "unsupported extension" error. That does at least show that it should know there's a tsconfig file there. But, is there another way to point it at the file that I don't know about? Thank you!
Check out Nest, I'm a big fan. It sits on top of Express and has a nice DI container. There's an example with TypeORM, too. https://github.com/kamilmysliwiec/nest 
I've done similiar. Migrated an ASP.NET API to ASP.NET Core because I needed / wanted to get rid of the Windows Server. I ran into perfomance issues with ASP.NET Core and decided to give NodeJS a try. I've used Express (Morgan, Bunyan, Helmet). Creating a REST API is straight forward. Datastore is Elasticsearch. But if I had a Postgres DB I'd use https://github.com/brianc/node-postgres (with NodeJS primisify) or https://github.com/vitaly-t/pg-promise. It's all nice and easy. But for complex apps I'd still prefer .NET or Java (Spring - which is incredible huge and mature). Also in my current project I need to read binary data and JavaScript has no long integer!
Sorry for the delay! The `--project` option should let you specify either a folder containing a tsconfig file, or you can pass the path to the tsconfig file directly.
No problem! Thanks for being willing to help out a stranger.
I prefer TypeDI over Inversify and second TypeORM and Nest. 
I built a tool called ts-typie which you just have to run in your project directory. It installs all types automatically and skips types for modules which come bundled with own types. If you like, you can check it out here: https://github.com/T-Specht/ts-typie
 [T-Specht/ts-typie](https://github.com/T-Specht/ts-typie) &gt; *Description*: A small utility for installing TypeScript definition files using npm &gt; *Stars*: 0 &gt; *Forks*: 0 &gt; [Issues](https://github.com/T-Specht/ts-typie/issues) | [Pull Requests](https://github.com/T-Specht/ts-typie/pulls) *** ^(This is Earth radio, and now here's human music ♫) ^[Source](https://github.com/anaskhan96/github-stats-bot) ^| ^[PMme](https://np.reddit.com/message/compose?to=github-stats-bot)
I've applied some more fixes (0.2.0) for various schema related issues. Two new configuration options (`schemaAsNamespace` and `schemas`) have been introduced. Let me know if you find any more issues.
Thanks! I'll add any other issues to github.
Hey thank you, I'll give it a go.
Make sure TypeScript's compiler is looking at your tsconfig.json file. You can use the --project / -p option to specify a project. Either give it a path to the root directory containing the tsconfig or give it a path to the tsconfig itself. For simplicity, you should have a single tsconfig and it should be in the absolute root directory of your project. That way, IDEs won't need any special configuration to find it. How are you invoking compilation? Directly on the command line? Via an editor plugin? If the latter, what's the editor? Both should work but knowing which you are using is important for us to help you debug.
Just published this: https://hstefanski.wordpress.com/2017/07/23/d3-v4-and-typescript-getting-set-up/ Let me know if it helps!
Thanks, maybe with the state of JavaScript 2017 survey there will be more info.
I would be interested to hear about your perf issues with .NET Core since they go on over and over about how fast it is.
There's this famous benchmark at Techempower ... this benchmark measures actually scalability. ASP.NET Core does good to great there, especially in the plaintext benchmark it's great. In the others ASP.NET Core is not that stellar, but good. All those async frameworks handle a lot of request per given ressources better, as they don't block any threads. However for a single request they're always slightly slower as it takes a bit overhead to manage the events and threadpools. I had the following issue: Data flows from Elasticsearch to ASP.NET Core to NGINX. Due to our IT-Sec standards I have to encrypt all traffic. So from the client to NGINX TLS, NGINX to ASP.NET Core TLS and from ASP.NET Core to Elasticsearch TLS. I used everywhere keep-alive connections. In this scenario NodeJS was 4-5 times faster than ASP.NET Core. We're talking about 30 to 300 ms for NodeJS for typical requests depending on size, but I have an API with autocompletion and then it matters (at least I think) if a request takes 80 ms with NodeJS or 250 ms with ASP.NET Core. I couldn't really spend to much time on profiling. I think it's likely an issues with TLS and Kestrel, because I think only few use Kestrel with TLS. So it wasn't brought to attention yet.
Thanks so much for all the details! I love a good case where Node wins.
Will do, thank you so much!
Browsers don't expose that information to clients. You will have to have the server (hopefully it's on the intranet) request Windows integrated authentication (I'm not sure how this works exactly). Then the server can look up the user in Active Directory and send down the necessary information to the client.
Check for Addy Osmani books and scriptures youll get a lot of infos on patterns... He is the one that comes to my mind right now. 
Use the allowJs compiler option, which also requires noImplicitAny to be false (if you had set it to true). https://www.typescriptlang.org/docs/handbook/compiler-options.html
I have done this sometimes, so it shouldn't be a problem. Do you use es6 modules? With node, you can mix and match es6 imports and node-style require. &gt; the JS library is extremely complex and changes often All the more reason to have it typed. 😕
They made a change sometime in ts 2 to no longer throw an error if the module you're importing doesn't have a type definition file associated with it. However, if it's a local module I think you need to turn on the compiler flag to allow Javascript files.
We use tsc, ts-node and mocha for tests with the ts-node as a compiler. Everything is typescript until deployment. I think it's odd typescript doesn't use babel under the hood, tbh. Competition is good?
&gt; I think it's odd typescript doesn't use babel under the hood, tbh. Competition is good? I've thought that too! That would be pretty sweet, IMO. Similar (maybe) in how the ESLint community is looking to add support for being able to use ESLint against TypeScript files (which I would be totally stoked for) I did some looking and it looks like someone else has proposed this as well. I added my 👍 https://github.com/Microsoft/TypeScript/issues/11441
1) Yes, `tsc` right down to ES5. 2) I have no idea why I would want to insert babel into the process. What would babel-preset-env get me? 3) Unit tests are mostly typescript, sometimes plain JS. I use plain old `nodeunit`. &gt; Babel is another tool in the chain, but the advantages of babel-preset-env seem very appealing to me. Can you briefly explain what these advantages are? 
Thank you! 
Hey, I updated the description to provide a brief example of what babel-preset-env does and how it looks to configure it. Hope it helps clear things up a bit! Essentially, tell babel what kind of transpiled ES5 you want, and it handles polyfilling only what's needed for those specific browsers.
I can answer your question now. No, I've never felt the need to have fine grain control over the ES5 output. I just target ES5 for browsers and that is it, and it works. 
Well it turns out for our case, in which we are using webpack to build our application, my colleague indicated that our usage of awesome-typescript-loader has first-class integration with Babel, and will respect any provided .babelrc. So looks a win-win! https://www.npmjs.com/package/awesome-typescript-loader#differences-between-ts-loader &gt; atl has first-class integration with Babel and enables caching possibilities. This can be useful for those who use Typescript with Babel. When useBabel and useCache flags are enabled, typescript's emit will be transpiled with Babel and cached. So next time if source file (+environment) has the same checksum we can totally skip typescript's and babel's transpiling. This significantly reduces build time in this scenario.
Split client and server behavior, and share a common core library between them of the data that gets passed around. Node's `require` loads JavaScript files into memory. TypeScript `require` brings symbols into scope so that when you compile to JS, everything's in the right place. Personally, I'd recommend using TypeScript's own functionality to handle code structure, and use `tsc` to generate single JavaScript artifacts for Node and browsers to run.
Ditch RequireJS and learn Webpack. Use ES modules for both the client/server code. [This is a good guide](https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html) to get you started - just ignore all the React bits (unless you want to use React/DOM for your game's UI).
Cheers. I'll look into webpack and read through the guide you linked.
I keep my client and server code separate and it's been less headaches. If you need a place to start for server apps this is pretty bare bones: https://github.com/locnguyen/typescript-node-starter
I've been writing code for a code agnostic algorithms class in typescript/vscode as a 'why the fuck not' thing. It's a surprisingly easy adjustment. Wonder how that will hold up with external modules and definitelytyped
You should probably add a bit more about namespaces versus modules, as many tutorials (and [Microsofts own documentation](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html)) recommend that you use modules. Which confused me since i didn't know at the time that i needed a third-party loader or a web packer compile step to get typescript modules to run in a browser environment. The "outFile" option can also be used with modules, but the compilation is too slow to be a useful option. Neither does namespaces protect against naming conflicts. If you create a namespace called "jQuery", it will conflict with the jQuery library. So that is one reason modules is recommended. But using namespaces does simplify things: No need for loaders or web packing.
Comment inside JSX are not valid in that format, you should use { /* insert comment */ }. The braces signals the start of a JavaScript expression, which in turn you can just put a comment in there.
correct, but then you get this http://imgur.com/g4pxlqu
Is it valid jsx?
apparently not.. 
You'll need to put the comment somewhere else or may be { /* comment */ ...{} } But that's start getting ugly.
Thank you for this article, I found it very helpful although I've run into something that seems a bit more tricky and I'm wondering if you can help. How do you import an interface from one type definition file into another? I need a components props to be extended from the props of different module. 
So I find myself using this style to write React more and more: const h = React.createElement ... function render() { const className = "foo" const style = {backgroundColor: "red", color: "white"} return h("div", {...this.props}, h(CardText, { flex: true, layout: "column" }, h(SortableTodo, { onChange=this.handleOnChange }) ), //Note that you can still easily include jsx //inside here. It works fine! &lt;br/&gt;, //Adding props can be easier too with the modern JS Syntax h("div", {className, style}, "Hello World!") ) } It makes it considerably easier to toggle lines on and off, add comments, inline-styles are a lot more friendly coherent and syntax is more consistent with the surrounding typescript code.
Observables are implemented as part of the standard library, right? No new language syntax so we can already use them today. For the other stuff, the TypeScript team adds new stuff once it reaches stage 2.
That's a really cool utility function
Don't over engineer it.
Pattern matching would be the most amazing feature. I use Elixir quite a bit, and pattern matching (in my opinion) is the most expressive way to branch.
In scala, pattern matching with partial functions is amazing for concise code. Are the elixir features similar? 
Don't bother with Angular
why?
Sorry I'm not familiar with the concept of partial function matching. :-(
Ah, it's applications of functions that a "partial' because they're missing some core part of the definition and they accept another function that is the meat. It makes for some shockingly elegant code. https://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html
I see where this keeps the syntax more consistent. But JSX actually ~~free~~ grew on me and I now enjoy the literal syntax that mixes in the element tags. ~~Also, createElement is deprecated or removed in react 16 I believe.~~ Edit: Autocorrect, and some misinformation - misread API.
 var it = makeIterator(['yo', 'ya']); console.log(it.next().value); // 'yo' console.log(it.next().value); // 'ya' console.log(it.next().done); // true https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Iterators_and_Generators
Offhand my guess would be that you aren't referencing the module with iterator inside your tsconfig.
No observables are not currently part of the standard lib.
Right right, sorry, what I meant to say is that the proposal, if implemented, would be part of the standard library and wouldn't require new language syntax or features. So it's polyfillable without any sort of transpilation. I'm pretty sure that's the case.
&gt; Also, createElement is deprecated or removed in react 16 I believe I haven't been able to find anything on that from googling. Do you happen to have link or remember where you heard that?
Sorry for the confusion. I misread this a day ago when skimming their api for something &gt; Convenience wrappers around React.createElement() for DOM components are provided by React.DOM. For example, React.DOM.a(...) is a convenience wrapper for React.createElement('a', ...). They are considered legacy, and we encourage you to either use JSX or use React.createElement() directly instead.
Found this comment in `@types/node`: `// Forward-declare needed types from lib.es2015.d.ts (in case users are using `--lib es5`)`
I've used this with great results in Angular 1.5/6 projects before. The controllers will bind the props you pass in to 'this' and setting the 'this' type keeps me from fat fingering things all over the place. Love this feature!
It's not just polyfillable, it already exists. It's called rxjs.
Yes that is also possible and very common usage of elixir. Love it! I believe you are talking about the same thing.
Yeah, I've been using it a fair amount as well. The power of the typing system has really come on since v2 of TS came out.
Sequelize has full type support for typescript and is wonderful to work with for Postgres
Oh absolutely. I've been around since 1.8 was released and haven't looked back. Anything sizeable immediately goes full TS for me.
The type signature is an indexed object, not a string itself. myErrors.errors = {}; myErrors.errors["LOGIN_FAILED"] = "an error occurred"; FWIW. I would not use a string indexed object after typescript 2.3. Instead, you can use a Record type, which takes strings (which represent keys) and a value type (in your case a string) that way you can have truly typesafe objects. Only use a string index if you truly have no idea what the keys can be. (Indexing a user given object) 
What the... typeclass keyword, instance keyword. What is this? Language for aliens? What is this title? What is this conclusion? Who are you? Where did you come from? https://i.ytimg.com/vi/3KtYwWsVKU4/maxresdefault.jpg
😂 The ending examples are in a made up language (aka I just smashed type classes into typescript) 
You may want to work on using some more "direct" language. Try to drop phrases like "Now do this." Keep it more procedural as this is meant to be a tutorial. I'd put WebStorm in the title, not everyone uses or has WebStorm! You use "now" a lot in general. Lastly, pictures can be your friend, too. Instead of saying "File –&gt; New –&gt; Project" use a gif or an image _with_ the text as a description. Keep it up!
 let username = prompt("what's your username?"); :P
http://modauthkerb.sourceforge.net/
Fun read - I like your writing style! You might be interested in https://esdiscuss.org/topic/block-scoped-prototype-extensions. I suggested implicits (Scala's version of TypeClasses) on esdicsuss earlier this month, but it looks like they're hard to implement. The other approach would be as a compile time thing, but [that 's not happening](https://github.com/Microsoft/TypeScript/issues/10844). You could implement them with TS macros, but that's [not prioritized yet](https://github.com/Microsoft/TypeScript/issues/4892) by the TS team - and neither is the [Sweet.js version](https://github.com/sweet-js/sweet-core/issues/482) of that issue. Fortunately the [higher kinded type](https://github.com/Microsoft/TypeScript/issues/1213) proposal is in progress, which will get us one step closer to typeclasses!
Yea, I don't foresee it happening anytime soon in typescript. I have been diving into purescript for learning these concepts and pushing elm otherwise. I am all over the place 🙃
I have no idea what that's supposed to do. The README contains a list of TODOs and mentions that this thing doesn't really work yet, but no work about what this actually *is*.
Thank you, I now added the tl;dr to the readme: lodash for types. Background: I'd been trying to type a library (Ramda -- [repo](http://ramdajs.com/docs/), [typings](https://github.com/types/npm-ramda/)), and found that there would be a lot more return types we *could* be figuring out the types for -- no-one had just quite figured out how to compose the basic type operators to construct larger building blocks yet. That is where this library comes in. This also means it's probably something of interest more so for typings authors than for end-users. 
I use typescript with the usual react eco system. How does this have any impact on a typical typescript user? Does it enable a neat pattern? Not being snarky: I'm not really an academic style programmer, more of a regular implement/fix/optimise-it programmer.
I've been using Ionic 2 for a year now, love it, but this isnt news?
Assuming it is Turing complete (haven't looked too closely) it means sometimes the typechecker will give infinite loop. However, this will only really happen if you are making some crazy types you'll likely never use in practice.
The post is from December, so definitely not news, but I guess OP wanted to make sure everyone knew. :)
Why is it still in alpha?
Ionic 2 isn't in alpha. Pretty sure Ionic 2 already had its RC and was straight up released. MS's build tools for it might be in alpha, but that's irrelevant because that's just the IDE (some) people might choose to use over webstorm.
Lol, ok. Check out http://ionic.io/2 &gt;Be advised: it's alpha software
Its an outdated splash page thats not even on the REAL Ionic domain. They haven't changed it since the day they started hosting Ionic 2, which was NOT a default of their site back then. http://blog.ionic.io/announcing-ionic-2-beta-11/ Ionic 2 is literally already in release. https://github.com/ionic-team/ionic/releases
Well then they have a serious messaging problem. It's the first result in Google for "Ionic 2". I was immediately turned off by it. 
Can't argue with that. But probably also shouldn't argue with someone who's been using a framework for over a year when they tell you it's not in alpha. Ionic 2 (which it looks like they're just trying to rebrand as Ionic and make people forget about V1) is pretty much the best Typescript implementation of Angular Material (which was my fav framework for V1) if you just use the android styles for all devices, but it also tries REALLy hard to make you use cordova to make those fake native apps, but the webapp engine is just dandy by itself.
I'm not arguing. Just pointing out that it's a pretty big flaw to say you're in alpha on top search result. I actually just tweeted that to them. I honestly went with React Native because I was under the impression it was still in alpha. A shame I guess. I've made an Ionic 1 app and was very pleased. I'm curious how the routers behave. One of the pain point for my React Native project was implementing push notifications and linking to some deep nested navigation state. Curious how that would compare to Ionic 2. I'm sure there are some drawbacks on your side as well?
I'm a fan of [glamorous](https://github.com/paypal/glamorous)
Have you tried https://github.com/Jimdo/typings-for-css-modules-loader ? It has worked well for me. I'm keeping an eye on https://github.com/tkh44/emotion, as it cares about performance by extracting static parts to a CSS file so you don't send 1Mb of inline styles each page load.
I use something simular to @Zalastax option. I use this command: https://github.com/Quramy/typed-css-modules (in combination with the modular css module for webpack). It generates a .d.ts file for every css file, that way you can do: import * as component1Styles from 'component1.css' import * as sharedStyles from '_shared.css' I find this very usefull in larger projects because it allows me to split my css in little files.
Please can you post your compiled main.js and your index.html? Can't see why it's not executing from the typescript. However it's worth noting that you aren't assigning to `this.uid` in Rat, this shouldn't stop the log statement from executing but might be worth noting. 
Thanks, added index.html and main.js. Yes you're right - I have not assigned the parameter to the local class variable yet - because the example shown is just a minified example of my use case.
Ok, I think what is happening is you need to configure typescript to concatenate your files into a single file in order to use it in the browser like you are trying to. If you look at the current output files you will see typescript is trying to import the Rat class from `main.ts` with a `require` call, which will work for contexts like Node or Webpack or Browserify but not a naive script tag in an HTML file like you are using. You should configure an `outFile` either in your tsconfig.json or with the command line flag, calling it something like `out.js`. Then replace your two script tags in your index.html with a single one to `out.js`. Then you should be good to go! The various compiler options are documented here: https://www.typescriptlang.org/docs/handbook/compiler-options.html
Thanks a lot! Unfortunately most web tutorials are based on Node environments - getting it to work with pure js not documented as far as I can see. The issue seems to be solved now - after putting all js into one file (I had to use the compiler parameter module with the value amd in order to use the outFile flag). I get another error now though: ReferenceError: define is not defined Should not be a big issue though. As far as I understand it, it is a requriement to use require.js if I want to use external modules in typescript. I assume I will be able to fix that. Thanks!!!
I've been playing with typestyle which has type definitions for CSS
Second on Typestyle, it's great!
Great to hear you're enjoying glamorous with typescript 💖 Highly recommend upgrading to v4. There's now close to 100% coverage on the typings and the typings have been significantly improved especially around glamorous component factory arguments. https://twitter.com/kentcdodds/status/893135704099663872
Good to see people from babel embrazing typescript :)
It also means you can implement arbitrarily complex type checks. What about prime number types? K&lt;K&gt;, K&lt;K&lt;K&gt;&gt;, K&lt;K&lt;K&lt;K&lt;K&gt;&gt;&gt;&gt;, ...
The first question you want to ask yourself is if a type checker is important to you. If not, go with babel. If so, then the question is more about babel es6+flow vs typescript. There are plenty of articles written about typescript vs flow. So I'd start with that. The basic arguments I've heard is that typescript has better tool support than flow but flow allows you to use pure JavaScript instead of Microsoft's superset. So which is more important to you? In practice, IMHO, there's not a whole lot of difference. Both are transpiling code to JavaScript. In theory, browsers will catch up to babel es6 reducing (or eliminating) the amount of transpiling done by babel. Whichever you choose, switching to the other from a skillet pov would not be that tricky. 
It doesn't have to be Typescript _versus_ Babel, it can be Typescript _and_ Babel! You can set up a multiple-step build process that makes use of the `allowjs` flag in Typescript. If you set a target like `esnext`, then you can pipe all your output through Babel, allowing you to take advantage of both Typescript's built-in features _and_ Babel's diverse plugin ecosystem (or maintain some compatibility with your dependencies).
&gt;but flow allows you to use pure JavaScript instead of Microsoft's superset. There's nothing about typescript that forces you to use anything specific to typescript (with the small exception of actually typing things *if* you turn implicit any off). Typescript is completely opt in. Don't trust typescript's version of private members? Never use the keyword private and you won't be any worse off than you would have been with vanilla javascript. Write a line of valid js and it's valid ts too. All of the features of typescript are opt in, not opt out. To some people this might seem like a minor point but I think it's a very important one. Typescript has done an excellent job of making itself completely optional with the fallback being the vanilla js method. Imo this is one of its selling points. 
True. From a purist perspective you're still transpiling from one language to another but presently, the exact same thing can be said for es6+flow. In the future, es6 will be able to be used without transpiling but if we're playing the crystal ball future game, you'd have to consider Web assembly too. IMHO, right now, Typescript is a fantastic option due to the beautiful tooling support and the additional language features are well worth the transpilation. I like to think of the type of transpiling used by typescript and babel+es6 as similar to the way the c# compiler implements some features rather than wholesale transpiling like coffeescript
As someone who didn't know what AOP was, it's definitely not clear enough. If you look at [meld](https://github.com/cujojs/meld), they do a better job at bringing newbies up to speed because: * They spell out AOP (Aspect Oriented Programming) the first time they mention it and provide a link to some more comprehensive description. * They explain what it is in a single sentence. * They provide a **meaningful** introductory example to show how to apply that fancy concept with their framework. In your example, the user won't understand what's going on just by reading the code. They'll have to work out what happened by looking at the output values in the comments and working *backwards*. Not saying you've got to be a genius to figure that out but who knows how much brainpower your average random visitor has left when this is the 100th JS library readme they're seeing today. Hope this helps ;) 
yeah, absolutely agree.. its hard to exmplain AOP in two rows. Now I try to read it and you're right that there is no explanation about "WHAT AOP MEANS" in terms of providing solutions to general software issues or what AOP can provide to software development .. Currently im working in providing examples like this one: https://github.com/k1r0s/angular2-aop-showcase But totally agree about my readme isn't clear enough :( thanks!
I'd suggest trying webpack with awesome-typescript-loader that fixes many issues u would have doing it that way.
Already did so, thanks - slant.co told me webpack is the best js organization tool:-).
Thanks for all the suggestions, I was particularly impressed by typestyle, but why isn't it getting more acknowledgement?
Not really answering your question, but es6 Map might be what you're looking for. It maps keys of (potentially) any value to values, is iterable, and can easily be transformed into an array. An example in typescript would be const map = new Map&lt;string, number&gt;(); map.add('key', 1); const array = [...map]; // =&gt; [['key', 1]]
Interesting! Thanks! This is pretty close, although not quite there I don't think...
it's hard to understand what you're looking for... So you basically want something where you don't know the types and names of the properties that are going into the container but still want autocomplete?
kinda like this: class iterable&lt;T&gt; { constructor(array[{key: string; val: T}]) { array.forEach(item =&gt; { this.array.push(item.val); this.dict[item.key] = item.val; }); } private dict = {} private array = new Array&lt;T&gt;(); get(key:string){ return this.dict[key] } // now extend all Array methods here, and makes sure any manipulation also affects the object } //so later I can say something like var dictionary = new dict&lt;specialClass&gt;([{"1": impl1, "2": impl2}]); dictionary.get("1"); dictionary.map(obj =&gt; obj.member); // these are dumb examples, but I think you get it The point being that you have linear access to members by name (huge performance increase in my case), but also get the benefit of having your object as an array, (so that things like ngIf* can still iterate over it.)
do you need this to be contained within a single object? what is the use case? I can't think of any libs off the top of my head that offer this (though looks like you've already begun thinking about it, probably not too hard to complete your impl!). but, I'm a big fan of selector libs like [reselect](https://github.com/reactjs/reselect) (and [re-reselect](https://github.com/toomuchdesign/re-reselect)). you can create a depth-1 memoized selector to map, say, a `Map&lt;K, V&gt;` to a `V[]` and only incur the cost of array creation on the first call. (sidenote: if you do plan on using es6 `Map`, make sure your key type is `string | number` -- other types, even objects, do work, but make lookups O(n) instead of constant)
Interesting. The use case being that my constantly updating UI is dependent on having an array of objects to ngFor* through, while other code needs access to these objects a lot, so iterating through arrays to find what I need would be extremely slow in comparison to linear access. I want to keep my O(N) low, or my UI will start to get really laggy. 
I think you wanted to reply to /u/ltray But anyways I agree with him. And there's kind of a problem in what you think? &gt; iterating through arrays to find what I need would be extremely slow in comparison to linear access Accessing an array is O(n) time (linear) unless you have an array of arrays. Maps are constant (O(k) where k would be the number of operations required to hash the string, however it does not change with the number of elements stored in your map). Besides, you could always store what you need in a Map for the O(k) lookup time (BTW I do not know nor can I find anything about Map lookup not being constant for objects) access and use another object that you could create / update with `Array.from(someMapObject)` concerning the *ngFor directive.
As much as possible I now favor deriving data in whatever format your components need from source data using selectors. If some parts of your app need constant time access to arbitrary objects I'd store the data as a map in whatever data store you use, and use a selector to derive an array representation of this map. Also, I obviously know nothing about the specifics of your app, but I often find rendering to be the major bottleneck. If rendering a large array of items is causing noticeable freezes, you may want to look into virtual rendering options.
This is what I'm doing now, it just seems messy and not very elligant. 
What about just using a simple Map interface: interface Map&amp;lt;T&gt; { [key: string]: T; } Coupled with using `Object.keys` to do your array iterating? Within the callback method you can dereference your key to get a strongly typed value. Edit: Also I'm confused by your assumption that array access is slower than Object property access. Why would that be the case? Regardless, I think this might be a case of premature optimization. Have you actually written the array approach and measured it being noticeably slow / non-responsive?
Yes. I've done both. It is faster to use an object to store my values. It's hard to explain why I have the requirements I do in text without anyone seeing why. The map might be the golden pony though. 
Anyone know if the large file support was spawned by the discussions comparing support from different editors? 
[quicktype](https://ts.quicktype.io) infers types from JSON sample data, then outputs interfaces and runtime typechecking for TypeScript (and Go, C#, and Elm). Tools like [json2ts](http://json2ts.com) etc. try to do the same thing, but we are taking a more rigorous approach, and so far we handle maps, type unification, naming, reserved words, and code generation a bit better. We're planning better tooling support. This is a new project and we would love your feedback. Is this useful to you? What can we improve? We're also not very experienced with TypeScript so let us know if there's anything we can do to generate more idiomatic code. You can also try our CLI: $ npm install -g quicktype $ quicktype -o LatestBlock.ts https://blockchain.info/latestblock Thank you!
Thank you for your comments.I tried to fix these points.
Check out the github repo, you might find something there.
[Chocolatey installs 64bit version on 64bit machines](https://chocolatey.org/packages/VisualStudioCode)
Standard js, if (!(typeof x === 'string')) { throw new TypeError() ) Typescript will know `x` is a string from that point forward. (Though it probably already does if it's a function argument). For additional points, if the check for `x`'s type is non trivial, you can use a 'type guard' function: interface MyType { v: Thing } function checkMyType(x: any): x is MyType { return (x.v &amp;&amp; x.v instanceof Thing) } ... if (checkMyType(x)) { // Now typescript knows x is MyType in this block }
There was a post in this subreddit not too long ago about a handy utility function `ts-is` that can make writing the type guard a bit simpler: https://www.reddit.com/r/typescript/comments/6ooo8n/tsis_or_my_favorite_utility_func/
Doesnt have to have anything to do with typescript, depends more on your web framework. hapi.js has lout, a great doc generator. And hapi-swagger for swagger docs. Express has something similar. Outside of those I guess typedoc is your best bet.
Yup, the Lex handler is here: https://github.com/jch254/scope-lex-handler. Lack of support for Lex in Terraform meant I had to configure the Lex side of the bot manually via the AWS console. 
Cheers g!
May I ask why you want to use webpack + require.js at once? As far as I understand it you use typescript + webpack and use that script like this &lt;script src="bundle.js&gt;&lt;/script&gt; Or you use typescript and load the produced js (you can make typescript output everything in one file) and load that file using require.js
Thanks for the quick response! That was my understanding originally as well, but I can't for the life of me work out how to reference the module from javascript (new ComplianceEngine(blah) throws a ComplianceEngine is not defined to the console). I can see that the script is being placed onto the page successfully so it must be an issue with how the module is being built, but I can't see where.
Just to add on to this you can also do something like: interface Base { v: Thing; } class MyClass extends Base { } class Handler { private list: Base[]; public GetItem&lt;T extends Base&gt;(type: { new (...args: any[]): T; }): T { return this.list.find((obj) =&gt; { return obj instanceof type; }); } }
Async iteration is already a part of TypeScript: https://github.com/Microsoft/TypeScript/issues/11326
I'm unsure what benefit I'm supposed to get as a developer.
The readme has no information about what this tool actually does. 
Doesn't tslint already help with this? Why do we need another tool?
Is the name a wordplay on 'vial' considering the icon or did you have the words confused ;)
I was wondering that myself
After having read the README, I've got absolutely no idea what this tool is supposed to do. Is it a linter? Does it analyse the AST's complexity? Something else?
I'm picturing something hooked up to a car battery that doles out electric shocks when you make a typo or write an O(n^^3 ) algorithm.
8-spaced tabbing with 6 indents, really?
Typescript supports es2016 module syntax. Just set your target to es2016 in your tsconfig and you shouldn't need to use Babel. Unless you want the Babel polyfills, then you need to target es2016 and compile through Babel after typescript. Typescript doesn't support polyfills, that's not what it is for.
thanks, is there a unit testing framework this would work with? 
You can use [typescript-node](https://www.npmjs.com/package/typescript-node) and tell mocha how to use the typescript directly. There is an example in the link.
Not entirely sure what you're looking for but the angular cli sets up unit testing with karma if you haven't looked at that one yet.
For the typings issue with mocha, I think you forgot to add mocha to the types field in the package.json. It should just work.* * Your mileage may vary. 
I agree with what someone said earlier. Angular-cli has the set up for testing through command line with Karma. That would be the simplest path to go with. 
thanks, the project isn't angular or react based so I'm really looking for a unit test framework that I can use without those I've not heard of karma before though so I'll take a look!
unit tests are just more code, all you do is run it at the appropriate time and see if it passed. If you are in the "js is for the browser camp" then create a unit test page that exercises the code. It will be a better test of the operating environment that way anyway.
This project demonstrates an AWS-powered serverless build, test and deploy pipeline ft. multiple environments. The /src directory contains a React/TypeScript/Webpack-powered web app that is served from S3 with CloudFront as a CDN and Route 53 for DNS. The /infrastructure directory contains all infrastructure and deployment steps defined as code (Terraform and bash scripts). CodeBuild and CodePipeline take care of building, testing and deploying the project. All build logs are stored in CloudWatch. CodePipeline accesses GitHub using an access token. When using CodeBuild to build, test and deploy each project, information about the build environment must be provided. A build environment represents a combination of operating system, programming language runtime, and tools that CodeBuild uses to build, test and deploy - A.K.A. a Docker image. I maintain build environments for the programming languages and tools I use frequently - e.g. docker-node-terraform-aws. The build commands and related settings must also be specified in a buildspec declaration stored at the root level of the project. Because a buildspec declaration must be valid YAML, the spacing in a buildspec declaration is important. If the number of spaces in a buildspec declaration is invalid, builds might fail immediately. A YAML validator can be used to test whether a buildspec declaration is valid YAML. See AWS CodeBuild Concepts and Build Phase Transitions for further information. This project can be updated as needed to build many different types of project. If a project needs to build Docker images/interact with the Docker daemon the Privileged flag under advanced settings of the CodeBuild project in AWS console must be set to true. This can also be set to true using the privileged_mode variable of the build-pipeline module. The buildspec declaration must also start the Docker daemon and wait for it to become interactive. Check out https://github.com/jch254/buildpipeline for more details. 
&gt;Route 53 for DNS Is this integral, or just included for completeness? Is Route 53 required to serve from the CDN for example? I don't have a lot of AWS experience.
What do you mean you can't open the .ts file? It's a text format, so just open it with a text editor. Even if you edit the TypeScript source code, you'll still need to know how to compile the .ts into .js. Is there a package.json in the root of the project with a build command (one with a word like `tsc` or `gulp` or `webpack`) provided in its 'scripts' field?
Through various plugins it can analyze code complexity and also generate data related to linter analysis. It can also make use of existing linters and even complement them. I've updated the README as well to try to better explain the reasoning, features and overall goals of the project. Thanks. :-)
I definitely did not expand on such details in lieu of the marketing pages on vile.io, which was a fail. I've updated the README, which should better convey what the project does standalone.
Too late. I've already tried that as well. It makes doing things a *bit* more difficult, but I'm getting through it. Plus, it does add a certain "je ne sais quoi" to my life. :-D
https://media.tenor.com/images/3db6d2d9f8c5a755c4091e716238ba4c/tenor.gif
The test tube logo came after the name. Mainly I wanted an easy and inexpensive logo to get the project out there, and the play on words was a bonus. Not sure I'm stuck on it though. :-P
Oh well, in the end I was just being dumb. The .ts files are empty, all of then. That's why I though the Notepad++ wasn't the right software for that. The code is in JavaScript, but now comes the challenge of find what I need and do what I want...
I'm really after a test framework and assertions etc. 
I mean it's pretty good to have your brand imaging aligned. I googled "vile" and checked the images, something like a skull &amp; crossbones might be cool for this such as in this image: http://4.bp.blogspot.com/-CICZRuLpMJk/T9SS-9ibgEI/AAAAAAAAArw/DRFbyLvog9A/s1600/vial+vile.jpg Plus, all the language on the site seems to point towards "vile" as in "your code is vile, heathen" and not "pour your code in this vile" so maybe you could even use some deity as your image. Just some thoughts, don't listen to me, I'm just an asshole on the internet.
The unit tests in karma don't really test anything specific to angular. It's just a generic unit test environment. At least it is as far as I can tell.
what is AOP? 😫
Basically, web *browsers **can't work** with typescript* and other supersets files. They work only with javascript (*.js). One of the main **advantages** of js in the web is that **all versions of js are supported in browsers**. That's why nowadays developers transpile their code from latest JS standards to the basic (read lower) version of JS to run their code in old browsers. Same for typescript. During transpiling developers can get source maps which give an ability to open files in web browsers like in text editors (Visual Code, Notepad++). But on production in most cases, this is turned off (because of security demands). And of course, you **can't run typescript specific code in web browser console**. I am not sure whether I explain in an understandable manner why there are some difficulties to work with typescript. You can read in details why developers choose to work with typescript and are advantages to improve your code writing in my article [there](https://binary-studio.com/2017/08/11/typescript-helps-write-better-code/) and also you can ask there and I'll try tp help you
Babel just tranpiles your code from latest JS specifications (ES6, ES2017..) to ES5 to support your project in old browsers. Typescript is a **superset of javascript that adds additional abilities to set and check additional restriction** in JS. Because javascript has dynamic typisation there are often bugs of types mismatching when you try to run number function on strings and so on. You can prevent this just using types (number, string, array). Also, it gives very powerful structures like **interfaces**, **generics** and even much more. Another typescript advantage is that it requires much fewer CPU resources for providing awesome code navigation (IntelliSense) in comparison with usual js plugins in sublime and other editors. This is pretty important when your code is growing and just to get navigation data through code webstorm and other editors need to parse whole project (which is a pretty big amount of work). I have an experience implementing big apps with plain ES5, ES6 and using typescript with both react and angular. Now I don't work with plain JS on big projects (only on small plugins and quick solutions). You can read in details what typescript can offer to you in my [article](https://binary-studio.com/2017/08/11/typescript-helps-write-better-code/)
It is not integral. The web app can be served from S3 at http://buildpipeline-prod.603.nu.s3-website-ap-southeast-2.amazonaws.com. I've not tried CloudFront without Route 53. I always host projects under a single Route 53 hosted zone, it's easy to create DNS records per project. 
TL;DR: no big changes, but expect some in 2.6.
Argh, yeah. It's always had a certain brand dissonance I couldn't deny, so I wasn't surprised at the comments haha. :-P I think a skull/bones or similar style could be a good stop gap if it's going to shoot me in the foot while I'm in my web service's validation phase. But for something more ultimate, I like your deity idea, as it's definitely meant to be within the "your code is vile, heathen" context. I was also considering using some sort of animal as a base, perhaps something that is more infamous but of which can be made to look a bit cute even. For example, I'm definitely a fan of percy.io's logo style. Appreciate the thoughts! :-) 
File 1: Foo.ts `export interface Foo {}` File 2: Bar.ts `import { Foo } from './Foo.ts' interface Bar extends Foo {}`
Async/await is luxurious to use once you get used to it. The one thing that bugged me was that you can't use await from a non-async function and this includes the top level code (that isn't in a function). So to make it work you just take everything that would have been in your index.js/ts and wrap it in a ```async function main() {}``` and right below that function, call it without await... ```main()```. Also, you can't use ```forEach``` inside async functions (or at least it won't do what you think it will) so you use for...of loops instead.
Tbh, observables are suitable for all async operations. Async await is not. This is why I opt for rx over async await as often you want cancellation, composition and increased parallelism. 
Wait what? I don't understand? Can you provide an example of what got are trying to do?
Question, how do I do error handling with await? Like I want to do something different if it goes wrong, like I do with .then and .catch.
You can use an actual `try ... catch` block: async doSomething() { try { await somethingThatMightError(); // do stuff after success } catch(e) { // do stuff after error } } This can get kind of ugly if you want the return value of a function that can error: async getSomething() { let something; try { something = await somethingThatMightError(); } catch(e) { something = 'something else'; } } Sometimes combining async/await with the standard Promise catch can help: async getSomething() { const something = await somethingThatMightError().catch(() =&gt; 'something else'); } 
Here's an excerpt from some code I wrote that uses this: async function main() { try { const client = new Client({ user: 'user', host: 'localhost', database: 'postgres', password: 'password', port: 5432 }); await client.connect(); for (let year = 1970; year &lt;= now.getFullYear(); year++) { for (let month = 1; month &lt;= 12; month++) { for (let day = 1; day &lt;= 28; day++) { await insertTimeRecord(client, { year, month, day }); } } } } catch(e) { console.log(`Error: ${e}`); } } main(); In the code, ```Client``` is a class imported from the ```pg``` library and ```insertTimeRecord``` is an async function that takes a connected Postgres connection and the values for the time record as arguments. When I invoke ```main```, it's a promise, so it begins to run while the code below it runs. But it's just my main function, I have no need for anything else to run anyways, so that side effect is irrelevant. But this allows me to use async/await everywhere in my app. It's all one giant promise. I don't use for..of loops in this code, I actually use traditional for loops, because it made more sense. Disclosure: One bug I did run into was the app hanging. It doesn't exit after ```main``` finishes executing.
Really well written article. JS async/await is easy to pick up coming from .NET/C#, is it more difficult to understand for those who haven't had experience with it before?
Thank you!
I believe it's because forEach runs in its own callback/function, and doesn't respect promises itself. You can await, but it won't block the next item in the loop from running. You could possible find a replacement that checked for a promise return that would only execute the next loop when it was complete.
Actually the solution is to just use for and for...of loops which do block for each iteration if await is used inside them. Edit: I just realized, you're the blog poster, so you definitely already know that. XD By the way, would you happen to know why my code example above hangs when I run it with "node index.js"? It runs fine, completed everything I expect it to, but the node process doesn't exit and I have to use ctrl-c to make it exit.
Putting a call to an "awaited" function in a try catch block can achieve this effect. The code in your catch block is equivalent to the callback specified in a call to the catch function of a promise library.
I honestly think that Angular-university is by far, the best resource for Angular 2+X (also TS, RXJS, NGRX). You'll also get to learn correct software eng principles. Not just how, but when and why to do stuff and when not to. I bought a subc a while ago and it is worth every last penny. Can highly recommend this. 
Very cool! Something to watch out for with this approach is that your sample data may not represent the full range of possibilities, particularly around rare cases. That's why it's always better to get official type definitions when they're available.
C# has the same concern about using async/await in tight loops. The overhead of each await call is punishing.
Some things are just best done with streams, even if they could be a little bit more user friendly.
Hopefully the language of the future is better than the language of the present! Python shows that there's no inherent reason this can't be done well.
There's a valid point here - promises waiting for the next event loop can be irritating for performance (although it is very useful for other reasons). However, the comparison to Python isn't all that helpful, because you're comparing apples to oranges. The way Python's parallelism works means that, by default (i.e. outside libraries such as `asyncio`), if there's only one thread running, it gets full attention from the interpreter. That means it doesn't need to worry about switching contexts, running through the event loop, and other costly things like that. This works just fine, because most of the time there's only one input, and one output, which means the program is always going to need to wait on one source of I/O, which means if the data isn't there, there isn't really much else to do but wait for it to appear. JavaScript, however, has the assumption that there will usually be multiple inputs that cannot block, and so optimises for this case. This means that it forces the programmer to deal with the event loop always. (In Python, any event loops are built in library-land and therefore optional.) This means that any I/O call must *always* deal with the overhead of the event loop. However, it means that there's a lot of things that are provided for free that in Python you'll need to work for. For example, in JS-land, it's fairly easy to read from fifty sources of input at a time and process them all in parallel - in Python this will require explicitly using the `threading` module and building up the threads individually. I do agree that there are some issues with the async iterator proposals that need to either be made more explicit, or ironed out in some way to make them more useful by default. I did a small side-project a while back to try and work out how async iteration worked and what it could be used for, and tbh there were a lot of moments where they just made things harder to parallelise, and harder to process. If I were to find myself in a similar situation in the future, I think I'd just end up sticking to a streaming API like RxJS and losing the slight bit of sugar that iterators give you.
Yeah, fair. Python &amp; JavaScript's threading models are completely different. The thing I find frustrating is that async iterators are _so close_ to making node a good environment for text processing. There just needs to be some way to mix async and sync iteration. Even more baffling is that reading a file line-by-line is [the specific example given in the proposal](https://github.com/tc39/proposal-async-iteration#the-async-iteration-statement-for-await-of), but the proposal doesn't handle it very well!
Yeah, I definitely agree that it's irritating. They feel almost like streams, but then not quite close enough to be entirely interchangeable. They have a nice syntax, but like you say, it isn't particularly efficient. Have you seen Dart's stream/async iteration stuff? I haven't used it much myself, but I was looking through the docs a while back and it has a sort of unified asynchronicity thing going on with futures and streams, where futures can be awaited (like JS promises), and streams can be for-awaited (like JS async iterators). The streams were much more powerful, but all the syntax sugar was designed around them. They were also more configurable than I think the current Observables proposal is, they could be either hot or cold, and things like buffering were very built-in.
- The article states that `let` declarations and classes came from TypeScript, when they actually originate from ES2015 instead. The article should mention the concepts stating that TypeScript borrowed features from ES2015 instead; it didn't invent them. - Even after introducing `let`, the article still uses var for its remaining examples. - No mention of `const`, when `let` and `const` go hand-in-hand and should be mentioned together, discussing the differences between the two. - The article kind of merges the concept of a function and a class method together, and speaks as though the `function` keyword can be left off outside of classes, which is untrue. It should talk about function declarations in isolation, then talk about classes, then class methods. - "It is a lot cleaner to always assign a return type." I don't know what the recommended practice is, but I wouldn't use the word 'cleaner' here. It's probably actually cleaner to leave off the return type. I'd say it helps readability and documentation instead. - Despite the title, the article doesn't really tell you how to get started with TypeScript. It doesn't tell you how you can install it and start making things with it. "A taste of TypeScript" would be more fitting, since all it's doing is showing you what the language is like. That's not a bad thing, but the title should reflect the content a little better.
Thank you! Yes it's always possible to have incomplete data, and even official type definitions can become invalid when schemas change. Our CLI tool allows you to analyze larger sets of sample data, and even includes a simple API crawler that, given an API URL *pattern*, will enumerate API calls and unify their responses into a consistent type.
True, but if you're writing tight loops, do you really want to push the job off to a separate `Task` (or `Promise` in js world) each time?
Here's some real code from C#: using (var reader = (await cmd.ExecuteReaderAsync(cancellationToken).ConfigureAwait(false)).AsObjectConstructor&lt;TObject&gt;(ConstructorSignature)) { while (await reader.ReadAsync()) result.Add(reader.Current); return result.Count; } Depending on the row size, `await reader.ReadAsync()` may wait for data from the database every iteration or every 50 iterations.
Thanks you for the feedback! It helps me very much. I have taken your suggestions and updated the article accordingly: 1. Mentioned ECMA 2015 (ES6) in the chapter about variables, to make clear that this feature comes from the standard. 2. Changed the usage of var to let. Even though it was not wrong, I think it helps to make clear that the code examples are actually Typescript. Good point! 3. Added a chapter about constants 4. "keyword can be left off outside of classes" : remove that statement, added function keyword to all examples. That should make clear the difference between methods and functions, as well. 5. Changed the statement to something more suggestive than fact: "Personally, coming from a C# and Java, I feel like you should explicitly assign the return type to every function. That way, your code is much better to understand and maintainable. But I also know that programmers are lazy sometimes. I catch myself, not assigning a type, as well. However, I think it should be done. Especially when working in a team and/or on a larger project. I made the experience, that linting tools, that mark inconsistent syntax right in the editor help to train good coding practice. " 6. I understand your point here. I actually had a chapter about the installation. Renamed that chapter to "Installing Typescript" to make it more discoverable. Have to think about changing the title or adding a practical example. No idea what that example could be. I hope the article now meets your expectations a bit better. If there is still something off, please let me know. Again, thank you for taking the time to give feedback. Have a nice day!
Hey, you're right!
I'm a bit puzzled. Why do you use async/await in a tight loop if you want it to have full attention while it runs? I mean, isn't one of the point of async/await to yield that attention so other things can happen concurrently? 
The idea is that you don't want to block a thread while waiting on more data from the network. This works great when you have long waits, but not so much when the wait times are short. With the line I highlighted, there is no way to predict if the wait will be ling or short. Hence the problem in choosing the right code.
&gt; "It is a lot cleaner to always assign a return type.".... I'd say it helps readability and documentation instead. In my experience it helps most with type safety. Inferred types are all well and good, but when you want a function to return a string and there is some random return path that returns a Promise&lt;string&gt; it's useful to have that flagged as an error.
Makes sense yeah.
Nice, it looks a lot better. 
Hi /r/typescript! We love to contribute to the Open Source community. In the past, our libraries have been mostly focused around Golang. We recently introduced typescript to our front-end stack, and we will be producing more Typescript libraries in the future! Hopefully some can benefit from the tooling we've created. If you have any questions, comments, or requests - please let me know!
I'd hardly call this natural language: Expect that a fact { Unless 7 is like 6 { Return 1. } And unless 8 is like 4+4 { Return 2. } Else { Return 3. }. } is like 1. 
Hey nice library. Welcome to typescript community ! I have two questions : Why you did not released it to npm? Putting links to github into my package.json worried me. What are benefit of that library over rxjs? Correct me if I'm wrong : you encapsulated observer pattern in your library, that's exactly what does Reactive programming
The API is a lot simpler than rxjs, that could be preferable to a lot of people
Valuable point but rxjs is sort standardised : you'll find same API in other languages
Enlighten me please, how do you build a router for a language?
Here is an example: https://www.npmjs.com/package/toxiproxy-node-client With code hosted here: https://github.com/ihsw/toxiproxy-node-client It is quite clean and I recommend looking at `package.json` and `.travis.yml` for reference. Note that the code is built and outputted into a `./dist` directory as opposed to placing JS files side by side with TS files.
Great questions! - Will be putting this on NPM/yarn in the next coming days, this is more of a pre-release while I finalize the API - The benefit is a very simple, elegant, and tailor-made solution. For me, a big thing with libraries are having options. If this tool is able to help someone out, then it's all worthwhile to me. If someone finds more benefit using rxjs, well that's just dandy as well. I must say, your comment was a great first impression of the /r/typescript community. If this is the standard for how this community communicates, I'm going to be a happy camper!
You pretty much nailed it on the head. The initial reasoning for this was to make a very simple library with few frills. 
Well, the main point is that you can understand it. But you have to do an effort. For example: Expect that a fact { Unless 7 is like 6 return 1. Else if 8 is like 4+4 return 2. And unless 8 is like 4+4 return 2. And in case that 8 is like 4+4 return 2. Otherwise return 3. Ok. } is like 1. You can understand this, you can dechyper this, but you have to do a previous man. 
If you have to work harder to read this than to read TypeScript, don't call it natural.
Valid answers :)
Sorry, naturality and readability are different things, sir.
Not in this case. You first have to shoehorn everything thought into programming concepts and then express it in your restricted language. The fact that it uses expressions that resemble natural language but aren't only hinders that process, especially while reading. This language doesn't come naturally. Facts cannot be like 1.
xD the result of the fact, but I don't want to get verborreic. But... yeah, "para ti la perra gorda" xD (it means: Ok, I'm not going to discuss this ridiculous question, of course naturality and readability are different things, that's why they are different words).
it depends greatly on what your views are doing. Where I'm consulting at the moment C# ASP.NET MVC was used with controllers and Razor views. We turned the controllers into quick API returning JSON instead of rendering the view and move the view into React using TypeScript. One by one, taking one controller and implementing the view into real client-side and making sure that the controller was returning JSON. That took some times, but it could be done side-by-side with the Razor views and some were migrated to React. If you only have some functionalities, one way to slowly introduce TypeScript in your views is simply to create one .ts file per view and you could include a script that load the compiled .js version if it. Again, it depends on your needs
I put my code into `src/lib` and tests into `src/test` and setup my `tsconfig.json` to compile everything from `src` into `dist`. I turn on sourcemap emission and include the `src` directory when uploading to the npm registry. That way users of the library can turn on sourcemaps and get proper stack traces and breakpoints. Also make sure to enable `.d.ts` emission. Do not create a second `package.json`; you only need one. The TypeScript compiler will be a `devDependencies`. All the libraries your code uses at runtime will be regular `dependencies`. I'm not sure if there is community consensus about `@types` dependencies, but I think they should be under `dependencies`, not `devDependencies`.
So you can actually submit TypeScript code to npm, and compile it with the install script?
Any code can be packaged into NPM (like Git, it has a `.npmignore` file denoting what does not get published.) The set up I have is: * Code is pushed to GitHub * Travis runs the build scripts that will compile it into JS in the "dist" directory, in addition to that the TypeScript compiler will generate corresponding `.d.ts` TypeScript definition files * Travis runs unit tests on those built JS files (not the TS files as test runners run on Node, and Node does not interpret TS files) * If the tests pass then the code is published to NPM * Users can then install the package using `npm install`, and this package will contain the JS and definition files (but no actual TypeScript) The code pulled from `npm install` is precompiled by Travis.
Well that's a start, thanks. Right now my main concern is input validation. Working with Razor views gives you a very simple way to display your validation messages, unobtrusive or otherwise. I've dealt with the pain of delivering validation and other messages to the client side from APIs and setting the whole thing up was just too much pain. If I were working on the project alone, I'd be up for it, but converting multiple developers to join in is not realistic. Looking at all the magic frameworks/libs (that I'd be willing to try), they don't really have this problem covered as far a I can tell.
For our project (React &amp; Redux) it looked like this: 1. Replace Babel with TypeScript in our build pipeline. 2. Make the tsconfig **as strict as we could**, but make it validate only .ts(x) files. It's very important to have strict checks enabled. Only then you can fully leverage the power of statically typed codebase. 3. Add interfaces for API responses and Redux store reducers, action creators and selectors. By starting from _the source of truth_, typings could have been distributed down the cascade. What helped us a lot was JSON-to-TypeScript converters we used on the Redux store. 4. Create each new file in TypeScript and make your colleagues add types to everything they touch. A good JSDoc annotation is better than nothing, what matters is agreeing on something and sticking to it. It's nothing revolutionary, but the takeaway is to go all the way in and make the config as strict as you possibly can.
Read about type guards on the same page. Particularly "Discriminated Unions".
I'm having a hard time finding what I'm looking for. Could you provide example syntax, ie replace my Type1 | Type2 example? Here's a full example: Interface Type1 { attr1: number attr2: number attr3: string } Interface Type2 { attr1: number attr2: number } function myFunc(myArg: Type1 | Type2) { return myArg.attr1 + myArg.attr2 } What do I replace Type1 | Type2 with to make this work as expected? Ie accept Type1 and Type2, and any attr either could have, but complain if they get something else?
Really you should read the section on Discriminated Unions and Type Guards on that page more closely. The simplest way to accomplish this is to add a key like "myType" to each of them with different string constant types and then in "myFunc" you say something like "if (myType === "one") {" and inside that if block Typescript will know what type it actually is.
That's kinda janky; would rather not declare if that's the solution, and if needed, mention in the docstring that myArg should be of Type1 or Type2.
Can you explain more what the *problem* is (as opposed to what you think the solution should be) or provide an example that fails? I'm having a hard time understanding what the problem is, especially since, at first glance, even your example code *works as expected*.
Can't you do the following? : interface Type { attr1: number; attr2: number; } interface Type2 extends Type { attr3: any; } interface Type3 extends Type { attr4: any; } function myFunc(myArg: Type) { return myArg.attr1 + myArg.attr2 } You don't even need to create Type2 and Type3 if you don't want/can't. myFunc will work with anything that can be casted to Type. myFunc({attr1: 1, attr2: 2, attr5: "type4"} as Type); myFunc({attr1: 1, attr5: "type4"}); //Error: attr5 does not exist in type 'Type'
Good catch; bad example since it does work without error. However, I get TS2345 if I replace my func with this: function myFunc(myArg: Type1 | Type2) { let x: Type1[] | Type2 = [] x.push(myArg) }
That would work for my example, but wouldn't if Type2 had attrs Type didn't.
It's typesafe, unlike a docstring.
You need something more like: Array&lt;Type1 | Type2&gt;. That type is an array of one or an array of the other, not an array where the elements are either
Type doesn't has the attr3 from Type2.
Do you want to have an array that accepts both Type1 and Type2 or just one them? function myFunc(myArg: Type2 | Type3): (Type2 | Type3)[] { let x: (Type2 | Type3)[] = [] x.push(myArg) return x; } function myFunc2&lt;T extends Type2 | Type3&gt;(myArg: T): T[] { let x: T[] = [] x.push(myArg) return x; } const both = myFunc(type2); const oneOfT3 = myFunc2(type3); const oneOfT2 = myFunc2(type2); both.push(type2, type3); oneOfT3.push(type3); oneOfT3.push(type2); //Error: oneOf only accepts typeof type3 (Type3) oneOfT2.push(type2); oneOfT2.push(type3); //Error: oneOf only accepts typeof type2 (Type2) myFunc returns an array that can be populated with elements of Type2 and Type3. myFunc2 uses Generics to return an array that only receives the same type as the parameter
It looks like you've solved it! (For this example, at least)
Jcaetano's answer shows the alternative syntax for that type: (Type1 | Type2)[]
Love it!
Doesn't this just boil down to Type2 through structural typing?
This works as-is. Literally the only thing you have to change is spell `interface` using lowercase.
I admire basarat's work and dedication. terminal editor for typescript is something
I haven't done this with redux, but you might want to take a look at how the closely related [ngrx](https://github.com/ngrx/platform) handles type safety. There is quite a bit of boilerplate, but I've found it to be maintainable. If your goal is really to eliminate boilerplate, that may currently be possible only at the expense of some type safety. 
I rolled my own solution about a year ago that allowed for strongly typed sync and async actions and reducers. I basically created helper functions to generate the action creators as well as handlers for the actions in the reducer. Recently I looked around to see if anyone has published a library that can replace my solution, and I found these, which look promising: [typescript-fsa](https://github.com/aikoven/typescript-fsa) and [typescript-fsa-reducers](https://github.com/dphilipson/typescript-fsa-reducers) An example they give for async actions: import actionCreatorFactory from 'typescript-fsa'; const actionCreator = actionCreatorFactory(); // specify parameters and result shapes as generic type arguments const doSomething = actionCreator.async&lt;{foo: string}, // parameter type {bar: number}, // success type {code: number} // error type &gt;('DO_SOMETHING'); console.log(doSomething.started({foo: 'lol'})); // {type: 'DO_SOMETHING_STARTED', payload: {foo: 'lol'}} console.log(doSomething.done({ params: {foo: 'lol'}, result: {bar: 42}, }); // {type: 'DO_SOMETHING_DONE', payload: { // params: {foo: 'lol'}, // result: {bar: 42}, // }} console.log(doSomething.failed({ params: {foo: 'lol'}, error: {code: 42}, }); // {type: 'DO_SOMETHING_FAILED', payload: { // params: {foo: 'lol'}, // error: {code: 42}, // }, error: true} 
Thanks for the links, I've just had a read through the source code of `typescript-fsa`. It appears the secret sauce is using type guards to narrow the types instead of discriminated unions. 
They also have alias for common methods for developers with different backgrounds like selectMany / flatMap.
Did you look over google?, it stands for aspect oriented programming
well you asked if your readme is clear enough. apparently not. 
Hm, that seems to shift the boilerplate to a different part of the type system, but it's still there and kinda hard to read. Other than using interfaces rather than concrete types, I mostly gave up trying to reduce boilerplate, at least it's simple and allows more helpful type hints in the editor. One area I reduced it was in forms. I made one reducer/action set for all forms, with a map of form names to their current state.
Agreed, all the libraries trying to reduce boilerplate are full of complexity too which is understandable given there are many corner cases to deal with too. I have decided its just easier to go along with the boilerplate as its a lot clearer without all these type abstractions. Or potentially just not type any of it which is still up for debate. 
I've built a tool that can do a large part of the work converting normal JS files written with Flow types to definition files for Flow and TS. I'm being paid to work on other things right now though so it may be awhile before I come back to it to finish it off
That's great to hear! Thanks, James!
[removed]
Sorry man: if you know a way of stopping gist from doing that, I'd love to know.
Take a look over this: https://egghead.io/lessons/vue-js-use-aop-in-vue-components-with-typescript-and-kaop-ts Using AOP you can import behaviors. For example, using dependency injection you are importing instances.. Its a way to abstract your code. By describing what your app should do without telling explicitly HOW should do. Take a look at the end of the video. You will realize that "aspects" are login that are completely decoupled from business, and you can plug them everywher
Great, but isn't refactoring a feature of the editor, non the language?
Wait, `Foo.bar` is wrong?
Not in Microsoft's mindset. Since Intellisense was introduced with Visual Basic in the 90's, they have considered tooling to be a key part of language design. They need a really good reason to even consider syntax that may interfere with code completion, refactoring tools, etc..
It's implemented as part of the language server mode of the compiler itself. That allows any editor to gain the feature for free so long as they use the required commands via the language server protocol.
It depends on the context. In type position, `Foo.bar` is correct *only if* `Foo` is a namespace and `bar` is a type. In other words namespace Foo { export type bar = number; } var x: Foo.bar; // this is fine. Otherwise it's only correct if * `Foo.bar` is being used as a value, and if `Foo` is a value and `bar` is a property on `Foo`. namespace Foo { export var bar = 100; } var x = Foo.bar; * `Foo.bar` is being used as a namespace and both `Foo` and `bar` are namespaces. This is much more niche.
That is really cool! Thanks!
Which has led to them having some of the best tooling in the business.
My favorite refactoring! There should be a reverse operation for that as well, inline method. Does that exist?
Is inlining a method a commonly used refactor? I would've thought it was pretty rare since generally that would be reducing reusability. 
I personally use inline refactorings quite often in C# and would like to see them be supported in TS. Perhaps it's a matter of style, but I generally associate many small methods/functions with complexity before reusability. It can be taken overboard, and I certainly did that earlier in my career. Regardless, there is a level of granularity that suits each developer/team/code base, and reaching that level can involve both extracting and inlining.
But WHY?! Why would anyone ever try to reference types this way?
Anyone read this? Is it worth it? Sign up to their site is required but it is legitimately free. 
It's good for certain applications. But Visual Studio is sorely lacking behind when compared to Jetbrains's or even VS Code with extensions. 
You know what they say: if something is free, you're the product ;)
Sounds like what you want is to merge a declaration with the `WebSocket` class which is not allowed. Without more context on your use case it's hard to advise much more, but you may need to take a different approach (store them in a dictionary, use a wrapper class, etc).
That's all? Refactoring is a feature of an IDE, not a language :-(.
Try this: // Augment the interface of WebSocket instances interface WebSocket { id: string; } Does that work? I'd normally test but I'm on mobile.
I basically want to treat the wildcard variable (the `WebSocket` in `import * as WebSocket from 'ws'`) as a class and augment it with a property. So far I've used a wrapper interface (`WebSocketEx`), e.g.: import * as WebSocket from 'ws'; interface WebSocketEx extends WebSocket { id: string; } const server = new WebSocket.Server(); // Example 1: casting required server.on('connection', (client: WebSocketEx) =&gt; { client.id = '123'; }); // Example 2: casting required const client = new WebSocket('ws://localhost:3000') as WebSocketEx; client.id = '123'; This is OK, but I would prefer not having to cast the `client` variable in these examples at all. I've tried several things in a `declare global {}` block, but haven't found a solution yet.
This will complain about conflicting declarations: http://i.imgur.com/wjrptJJ.png I also tried moving the interface declaration to a separate `.d.ts` definition file, but the code file wouldn't pick it up: http://i.imgur.com/sNryVXs.png 
Yea, I don't *think* that what you're trying to do is possible, since there are no class extensions in TS.
Class extensions *are* possible, just not for `export =`. Here's a working example: import {MyClass} from './myclass'; declare module './myclass' { interface MyClass { bar: string; } } const i = new MyClass(); i.foo = 'this works'; i.bar = 'this works too'; ...and `myclass.ts`: // Avoiding `export =` export class MyClass { foo: string; } It also works with a default export. But I can't get it to work with `export =`.
Oops, I forgot to use the `declare module` syntax to do module augmention. Still doesn't work with `export =`, though. I posted another comment with an example that would work if the `ws` module was doing named or default exports instead of export assignment.
It's basically the Gang of Four's [Design Patterns](https://en.m.wikipedia.org/wiki/Design_Patterns) in typescript. Even though you have to sign up it doesn't do any verification, so just use fake data. 
Non-Mobile link: https://en.wikipedia.org/wiki/Design_Patterns *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^107361
Indeed. Maybe I could rewrite the original `@types/ws` definition file to use an interface with a `new()` definition instead of the current class definition, something like this: declare module 'ws' { interface IWebSocketStatic { new(url: string, protocols?: string | string[]): IWebSocketInstance; } interface IWebSocketInstance { // original WebSocket class stuff here } export = IWebSocketStatic; } This way it should be augmentable, e.g.: declare module 'ws' { interface IWebSocketInstance { id: string; } }
Yeah, it seems impossible to do when a class is exported with `export =`. I might try to rewrite the original `ws` definition using an interface with `new()` instead of a class.
Not really. This allows every editor that implements the protocol to offer refactoring. This is implemented in the "language server".
&gt; every editor that implements the protocol IDEA had the refactoring options already, it means it doesn't implement that protocol =&gt; it's a useless feature for IDEA users. It is not a *language* feature = it's adds nothing to the language itself.
So you're just annoyed the versioning doesn't separate syntax and semantics from other features?
Again, **refactoring is not a language feature**, it's an editor/IDE feature. It's commendable they are doing some tools for easy integration with editors, but it should not be a part of TypeScript, the language, project. So updates to TypeScript, the language, should cover only language features. And in version 2.5 there are no new features, no changes to syntax/semantics, just some little tweaks like "Optional catch clauses". There is simply nothing release-worthy from a language perspective. I am not annoyed by the fact they are creating the support tools, but by the fact that they seem to not doing anything else than creating the support tools which a lot of developers has no use for.
Why is it an editor feature? It's much easier, more reusable, more localized, and more reliable if the compiler and language server (which is what the tsc code is) can do it for you. Think of it as a release of the compiler and tools, rather than a language definition. You might also be wrong about the the number of developers benefitting: this feature will now be available to all users of Visual Code (and Visual Studio).
I figured out a really quick solution! I've seen this done elsewhere, where type declarations include empty interfaces solely to allow extension. Unfortunately it does require a small modification to @types/ws. Add 2 lines to `@types/ws/index.d.ts`: // Put this line outside of the namespace declaration... declare interface WebSocket extends WebSocket.WebSocketInstanceExtensions {} declare namespace WebSocket { // ... and put this line inside the namespace declaration export interface WebSocketInstanceExtensions {} And in your code, do this: declare module "ws" { interface WebSocketInstanceExtensions { id: string; } } 
There's two different things happening here. B conforms to type Test because they both have a string called test. So B is allowed to be passed in for a parameter of type Test. Completely separately inside a function that is being passed a type specified as Test internally it can treat whatever is passed *as* a Test type since you explicitly said that was what it is receiving. So inside the function you can attempt to set whatever was passed. If you define Test instead as { get test():string; set test(t:string); } instead of what you have then B will no longer be a valid value when a Test type is expected. Typescript by design attempts to be as permissive as possible since at runtime none of it will matter anyway.
No its not common, but I find it I need it when functionality has been obviated, and you are left with silly one line methods only called from one source.
Sometimes TypeScript does things that aren't *technically* correct because if TypeScript really were that strict, it would actually be annoying and inconvenient more often than helpful. I know that's not a satisfying answer, but that's generally how the TypeScript team designs the language. They are also occasionally constrained by backwards compatibility. I don't know 100% if this answer explains the particular situation you're describing, but it's my guess.
Ah yeah, I know what you mean. 
The two reviews sound legit. ahem.
ah, that's a nice hack. Thanks!
Lol. Gotta get those "seed" reviews
While this might seem crude, I've settled on a pattern that is keeping me sane. I have a string enum of action types and an interface for each action. They're all defined in one file, so I have a single source of truth for all actions and interfaces. export interface ComparingResultsData { type: ActionTypes.COMPARING_RESULTS_DATA; activeResultId?: number; series: SimpleExerciseSeries; } The interface name always matches the action type. When I create the action, it's on me to explicitly type it. const returnAction: ComparingResultsData = { type: ActionTypes.COMPARING_RESULTS_DATA, series, activeResultId }; return dispatch(returnAction); In my reducer, I do a normal `switch (action.type)` and then recast my `action` as the appropriate matching type(s) if I am expecting data. case ActionTypes.SAVED_EXERCISE_SERIES: case ActionTypes.COMPARING_RESULTS_DATA: { const typedAction = action as SavedExerciseSeries | ComparingResultsData; return { ...typedAction.series! }; } I wouldn't mind a slightly smarter approach to casting my action in the reducer, but this is easy to interpret, use, and explain to others. It has completely solved the problems I was facing with my actions. My remaining concern at the moment is sprawl -- I'm up to 100 actions and almost as many interfaces (I only define an interface when there's data being passed) and growing -- but I'm not too worried, I can get smarter with naming, and I'll gladly accept a little wordy sprawl in exchange for safety and clarity.
Doesn't this just boil down to JS performance? Seems a little superfluous to have a TypeScript performance book, like a CoffeeScript performance book would be. That said, I do love TypeScript so...
Is there a sample chapter we can read?
Thanks for explaining that, I'm new to TypeScript and found it surprising that that was allowed. But I agree with you that it makes sense.
Your `tsconfig.json` is wrong. { "compilerOptions": { "target": "es6" } } 
Ah yeah, sorry. Oversimplified while trying to show what was going on. I've corrected to what you have and still get the error.
Working fine for me. Just run `tsc` with no parameters.
Interesting. If I run "tsc settings.ts" it fails, but without the file argument it works. Why would that be?
AFAIK, `tsconfig.json` is only used if there are no supplied parameters. You would have to do tsc --target es6 settings.ts Read https://www.typescriptlang.org/docs/handbook/tsconfig-json.html &gt; When input files are specified on the command line, tsconfig.json files are ignored.
Well there you have it. Thanks!
With that invocation, you're not telling tsc to use your tsconfig file. `tsc --project .` is probably what you want.
Just worked this out, thanks for the help! And for anyone else reading, `--project` can be shortened to `-p`
I don't think interfaces are allowed to demand getters or setters. I've been tripped up by that before.
If you look at the chapter list, the chapters like "Optimizing Resource Delivery" are not directly related to TypeScript, but chapters like "Leveraging Advanced Language Constructs" and "Handling Asynchrony" are very much pertinent to TypeScript and discuss simpler, more readable, naturally scalable approaches.
Ha. Yea having nice reviews always seems nice, doesn't it :) However, I've no idea who wrote them!
[removed]
There's some features that the TypeScript compiler doesn't support yet in ES5 that Babel has added in already. Usually it's a matter of boilerplate and stability. Downlevel async generators is one example (though you can do this now with a compiler flag)
I suggest you use what your team is comfortable with, in combination with the right tool. Does your stack require heavy computation or is it mostly I/O? Working with a team I'd chose TS over standard JS, that's for sure. But without knowing "what" you're building I can't give any more recommendations at this point.
Typescript is a great thing. I spent two weeks refactoring one of my projects to be TS that greatly accelerated my project. But that was in the front end. I'm currently working on a TS/Node backend and I find it extremely painful to work with. TS suffers from similar projects that build on top of platforms (e.g. Scala on the JVM) in that it still suffers from the underlying limitations. So it greatly helps in catching things upfront but is still very hard to do refactoring. I also have problems with the tooling because things are compiled down to JS. 
I've used it with ts-node. Had absolutely no problems and would not go back to plain js in Node. It's particularly nice to be able to make an interface for each entity you're sending between backend and frontend, and have it checked on both sides. It's a nice benefit, but by default I use Go on the backend. Ryan Dahl even recommended we use it rather than Node these days.
I work on a large Typescript project for quite some time now and I do recommend it. The backend is a Node API and the frontend is implemented in Angular, both 100% in Typescript. The biggest advantage is the typed nature of the language. The Typescript compiler reports many bugs up front. This lets you develop large projects with an extra layer of fail safe. Another big advantage is that you can use a shared source code pool for frontend and backend. For example API definitions/references (for instance with enums) have to be implemented only once and can be used for sending API data and validating in the frontend from the same source of truth. I did a lot of backend/frontend stuff with PHP and Javascript. Data negotiation and validation has always been a thing that had to be done kinda twice. Whereas in this project all that stuff has been normalized and thus trivialized. The tooling can be a bit tricky at first. But also this trivializes as soon as you realize that the Typescript compiler generates Javascript eventually, so you can code whatever you think suits your project well. Also, the situation of Node library typings became pretty good. You will find current definitions for all major libraries. And if you need a lib without types, writing interfaces for only the calls you need is a quick task. Even using stuff defined as `any`is viable. Imho there is no right or wrong in this. Maybe the most important advantage of Typescript is the fact that the IDE understands your source code way better than it understands Javascript. It happens a lot that project requirements change at a certain point. Those changes have to be worked into your code. And to avoid spaghetti code, refactoring is necessary sometimes. In Typescript you can refactor everythig with ease and you will never have to worry again that you forgot to update any reference that has been changed. With Javascript refactoring always was living on the edge :) For me I can say that I will never work in Javascript again. Finally I can use one language for frontend and backend which feels grown up. The one downside I see is that the Node environment is by far not as diverse as the PHP environment when it comes to libraries or frameworks. For the same task PHP offers a multitude of great libraries that can be trusted. Node sometimes only has one-man shows, which we don't use on principle since a discontinuation of a library would produce an unnecessary overhead. We rather implement it on our own in this case. I know, PHP got bad reputation. But working in web development (frontend + backend) for 10 years now, I have to admit that PHP gets the job done very quick in a proper way. With PHPDoc you even can typehint your whole project, so it's comparable to Typescript in thie regard. 
I'm lone wolfing right now at a small company. I use TypeScript/Node and like it, which is why I'm in this sub. The people with a lot of reasons to not use TypeScript might not be here to see your post. I have a set of libraries that provide access to all the in house and 3rd party APIs my company uses. Those libraries are used by a desktop app on electron, a set of command line utilities for manipulating product and order data, intranet apps that are typescript on the server and the client, a public facing web app that customers interact with and google hangouts chat bot for a couple of customers that want to ask via chat about our inventory levels. We're a small company and we bend over backwards for customers. I also built a text adventure into the bot. As these different projects evolved, they were running off of raspberry pis. Once they launched, they were all moved to a linux VM on a beefier machine. We have some customers as well as a small office overseas and for the sake of latency I shipped an rpi over to the office in Europe and the customers there are running off of that. If the customer base grows we'll set up a real server there eventually. We're a small group trying to do big things and it's nice to have the flexibility this provides while still having some type checking to keep me sane. I came from C# but made the total switch to Linux for all of my machines around the time Windows 10 came out. I started with TypeScript figuring a switch back to C# on .NET core could happen later. And for desktop apps I REALLY miss C#/XAML MVVM. So if and when cross platform XAML with databinding is a thing I'll probably go back at least for desktop apps.
Why is it hard to refactor TS code, and what kind of underlying limitations are there? In my experience, the exact opposite is true. TS allows you to safely refactor code that would otherwise only be refactorable using string search and replace
Typescript has become such a safety blanket for me. If I have to write plain javascript code, I start to feel a little anxious about my inability to add types to things. You get addicted really easily to all the intellisense stuff you get too. mouse over a function name, see exact expected parameters and return types? Why, this almost feels like a real programming environment! With no real runtime penalty, the only potential downside is the compilation step in your build tasks, which isn't particularly slow, but can take a few seconds on a big project. My advice on this is to chunk your project into libraries if it ever becomes close to being an issue. Unless you really enjoy having a giant monolithic codebase, it will make sense. 
Go in the backend is a good choice in terms of performance. But in most business cases, shorter delivery time = more money. So typescript in backend and frontend is better for most companies/freelancers because of faster development. But it rly depends on what are you building
I don't find it any slower to develop in Go. It's a small language. But with ts I like being able to share interfaces with ts across server/client. And the ts type system is more powerful (generics etc). Either can work out well for many cases.
When compared to JS, TS is much better. But when you compare it to strict nominal type systems, it doesn't hold up as well. I certainly won't work on a plain JS project if I had the choice . But I would also most certainly prefer to use something like Java, Scala, Kotlin or C# for a backend over TS/Node unless I'm doing a throw away prototype.
I have used node.js before and now I use typescript for both backend(nodejs) and frontend(browser). The only reason I use typescript is because I can easily refactor code without any fear of changes affecting remaining parts. The compiler easily finds out errors without even running the code and that's a huge plus for me. Heck I don't even compile the code to js I just use ts-node. Apart from this it's incredible flexibility to turn off type checking by explicitly casting variables to any when type declarations are missing for some library. Now a days I also create lot of interfaces for database models to catch errors early. 
I have used go in the backend along with node.js before and I won't do that again. The amount of time that I wasted context switching between languages was huge. Now a days I just stick to one language and nodejs/ts seems to cover the areas that I usually deal with.
Gotcha. I thought you were saying that those things were harder compared to vanilla JS. Thanks for clarifying and have a nice day!
Thanks for this. "The people with a lot of reasons to not use TypeScript might not be here to see your post." I was just thinking about this. Where should I go to get good disconfirming opinions, I wonder?
I'm not really sure. I know I like it because it's been extremely useful for me and I enjoy using it. But I don't have a team to worry about and I'd classify all my projects as small. If I was planning something big or brought in other devs I'd be looking for how it has failed people.
I'd say it depends what platform you're targeting. Been using TS full-time now for last 9 months after switching project where we are only targeting AWS lambda for running code. Was using .NET (F# where I could) for the last 10 years which was great when all infrastructure was Windows boxes. The biggest pain I've experienced is around building a good tool-chain e.g. tsc, WebPack, jest, ts-lint, gulp, etc. which all works at a basic level, but I've still not managed to get debugging of tests to work inside VS code, and stack traces get messed up line numbers even with source-maps enabled. It's not a deal-breaker, but there is a cost to not having those bits working. If I was still running my own servers (on docker) or using Azure Functions for the new project I'd have probably gone with .NET core instead though as I find the tool-chain tends to work better out of the box.
I work primarily in TS+Node these days, and I would never go back to JS+Node if I could help it, but I still don't feel like TS+Node beats C#/.NET Core in any real use case and Elixir/Go are better if you need to deploy highly scalable and fault-tolerant applications and don't mind the additional complexity. Javascript, and other scripting languages, just get really tough to work in as your application gets larger and it gets harder to remember all the little things about how pieces of your app fit together (and god forbid you need to refactor anything). Typescript goes a long way in improving this but just really isn't as thorough or feature-filled as something like c#. Also, the npm ecosystem in general is a house of cards in which everything works about 90% of the time and the 10% of the time it doesn't you're reading through github issues for hours trying to figure out what deep mesh of dependencies and shitty code caused your current problem. On the flip side though you can find npm packages for nearly anything you can think of - they might completely suck, but at least they're building blocks for you to kind of fill in the gaps. We use TS+Node primarily because a decent amount of the devs I work with are really only comfortable with JS and as a small company / startup it's a tough sell to ditch that expertise and existing code and learn and write something new.
I've used it for a short period of time (Frontends React / Angular). Background: I needed to move a ASP.NET API from Windows Server to Linux. First try was ASP.NET Core. I hit some strange performance issues - probably regarding https, which I had to use from Kestrel to NGINX and also to Elasticsearch via HttpClient. A single request took about 4-5 times longer than with Node. Also the documentation was a mess at this time (some month ago). Overloaded and unorganized. Tutorial everywhere you look, but incomplete as a reference. That and the performance issues might have changed. At this time I was frustrated about all this bullshit benchmarks - 100000000000 "hello world" plaintext responses per second but &gt; 60 ms for the simplest real world request. Creating simple API with Node and Typescript is easy and fun. I've used Express and like it. Never use Node wihout Typescript! Still, if your domain is large and you have a lot of business logic it becomes a pain. The truth is that you spend a lot of time for simple refactorings that you have to do all the time. I'd prefer the safety of a statically typed language. Also, VS Code is fine and dandy but IntelliJ is different tools. More to learn, but much more power at your hands. On my current project I use Java (Spring Boot). The learning curve is quite long, but it's the most powerful framework of all. By far and with no doubt. The question is: When do you need all the abstractions and capabilities? My answer: If you're creating an API or App with a lot of domain models and business logic (e.g. complex authorisation) then it's worth learning Spring. Compared to ASP.NET I'd say the ORM (JPA implemented with Hibernate) is a strength, not a weakness (EntityFramework Core). AOP for cross cutting stuff is the proper way. ASP.NET should be fine as well. Despite having enjoyed using Node I actually wouldn't use it again for standard business APIs because I already are comfortable with ASP.NET or Spring Boot. Node is fine in small Apps or Projects where you don't have the time to learn another framework. Finally if you want to check out Spring Boot in your evaluation: Have a look at Spring Data Rest (https://spring.io/guides/gs/accessing-data-rest/). Even if you need much more controll (you probably will) it's impressive and fun. You get a complete backend in a couple of hours. I'm on Pluralsight so getting started with Spring was not a Problem. Spring in Action is a good book. Don't let the configuration stuff discourage you. It's part of the learning curve but then just vanishes.
What about today? What language features can TS not downlevel? Because, as you said, it can do async generators.
If your team is comfortable with JavaScript, Typescript + Node definitely makes a lot of sense, as it's bascially JavaScript that doesn't suck.
No worries about using babel, just setup for tsconfig and go. I also like using classes moreso now, I had instancing issues before with node. Now everything is OOP and works great. Is more readable, and error handles better on the server without writing extra stuff. 
I like typescript and would nearly always choose it over JavaScript. But if your back end app is doing more than auth, data transformation, and data persistence, then I'd choose a statically typed language with multithreading for sure. 
Reminds of a [thread](https://www.reddit.com/r/typescript/comments/6pdcy2/transpiling_typescript_right_to_es5_or_combined/dkpnrch/) I started a little while ago. For me I wanted to take advantage of Babel's [babel-preset-env](https://github.com/babel/babel-preset-env) plugin (essentially [caniuse.com](http://caniuse.com/) as an npm package) as part of my transpilation pipeline. I am doing this by using webpack and awesome-typescript-loader. In this way, I got the best of both words since to my knowledge, TypeScript doesn't offer what preset-env can.
I can't recall anything else in particular feature-wise. If I remember right there are some differences between compilers such as static class properties don't go into `__proto__` in TS but they do in Babel (or something like that). This can cause some interop issues with JS libraries because it differs from ES6 spec. There may have been some differences in handling with async/await also.
First impression: awesome. API and standard lib documentation links unfortunately don't work. Any idea on how it treats/implements arrays and classes?
Nice! Last week I installed VS Code for the first time and started getting into TS/Angular. After using JetBrains products and Sublime Text for a while, I found in Code a very pleasant user experience. My prejudices against Electron and JS desktop applications are gone now.
Since this is about WebAssembly I think it doesn't do high level stuff. All the types and methods are very specific numeric types and raw memory operations. I think the idea is you write your low level stuff in AssemblyScript modules/functions and import and call those from regular script. I don't expect to write big interactive programs directly in AssemblyScript but use it as a speed booster for math and data work.
The readme mentions things like classes and sizeof, and memory management via a malloc which returns a usize and casts and all that, which makes it look like it's technically allowed, but memory management is at C level. So I guess only the syntax and type checking is TypeScript, for the rest it's pointers all the way down.
&gt; My prejudices against Electron and JS desktop applications are gone now. Just install atom and you can bring them back!
Its crazy how quickly MS are developing VS Code. I used Sublime Text too and I feel for what I use it for Code is a lot better. I really liked Sublime Text too. 
MS was founded as a shop building programming languages. It's good to see that they haven't forgotten their roots.
They never did forget. For all their ups and downs they have always been pretty amazing in terms of development tools.
Try out React coupled with MobX. Better than XAML.
Looks good, but what makes it better than something like [lodash](https://lodash.com/) (which also has `@types`)?
Yes, exactly.
I've been using awesome-typescript-loader. Which has been doing the fork checking since day one. But I'm curious about the happy pack and looking into TS loader again after reading this.
+1 for the Knight Rider reference :)
Can't say I've seen that personally. Have you tried strace'ing the high CPU process to see if it's stuck in computation or system calls? That might help at least narrow things down.
actually after posting this I found lots of discussions on the vscode github about cpu problems, apparently that "Code helper" actually hints its "purpose" in the command line (like this, copied from a comment on vscode github): /Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper.app/Contents/MacOS/Code Helper **/Applications/Visual Studio Code.app/Contents/Resources/app/out/bootstrap --type=extensionHost** Next time it happens, I'll be able to see which "Code helper" is the culprit.
The `Either` type (inspired by Scala's), works well for me for mutually esclusive types (e.g., error or result). See [here](https://github.com/teamdigitale/digital-citizenship-functions/blob/master/lib/utils/either.ts) for my version of it. You can use it like this: ``` function(a: Either&lt;Error, Result&gt;): void { } ``` 
That looks great
I prefer to prefix interfaces with `I` because it's still important to differentiate between interfaces and classes. For one thing it's important to know if a thing is going to be a real javascript object (a class) or will be compiled away (an interface). 
If you have a good abstraction (and that's why we are using interfaces, right) you don't really need to differentiate between interfaces and classes
I used to be in the I-prefix camp. Now I think it's an abomination that enables developers to make bad abstractions. When you switch to using non-prefixed interface names, bad abstractions tend to slap you in the face by way of naming conflicts. They force you to reevaluate your architecture and do things correctly, rather than just sweep the problem under IRug. Of course, you can do things correctly and *still* use the I-prefix, in which case I don't really see a problem with it beyond being ugly...
If you use I before your interfaces or impl for your implementations or both (some people are weird ^^) you certainly have naming problems (naming should explicit intentions - not sure if it is english to state it that way) Now I never did that I don't have naming problems in my code ^^
Btw it hit me too when I saw differences between angular guidelines and tslint... but I forgot to ask, so thanks to bring that point :)
Its awesome. Use tools like nest, typeorm, inversify, ts-node, routing-controllers, class-validator, typedi and you and your team will be happy with it.
Care to provide an example?
In typescript that shouldn't be a problem. And the type itself will tell the compiler if it is a function object (class) or ephemeral(interface). And how you use them either as implement or extend really states the usage. Pretty much just repeating what i said in my post. 
&gt; When you switch to using non-prefixed interface names, bad abstractions tend to slap you in the face by way of naming conflicts. Um, have you seen Java? They just slap `Impl` on the back of every class. I'm perfectly happy with `List` being the default implementation of `IList`.
I like using `I` because it is self-documenting. I can tell at a glance that I'm looking at an interface. This is important when consuming someone else's API. When I see `Foo` in Java, the first thing I do is type `new Foo()`. This of course doesn't work if Foo is an interface, so I waste time trying to figure out if I screwed up an imports statement or if I need to start hunting for a concrete implementation. If the function is asking for `IFoo`, well chances are there is a matching `Foo` class that's going to work for me 90% of the time. 
If there is only one possible implementation, an interface is unneeded. If there is more than one, then you have misnamed your class.
While I agree on the first point, as to the second I have counter-examples. Consider the interface `IReadOnlyList`. The three primary implementations are `List`, `ReadOnlyList`, and `ImmutableList`. What is misnamed?
I like Typescript, FP, DI, rxjs, socket support, support for guards/interceptors out of the box. I like pretty much all of the things listed! I'll give it a try during the weekend
An interface defines what an implementation *does*, not what it *doesn't do*. Thus, `IReadOnlyList` is poorly named to start with, and should likely be `ReadableList` or similar. Of course, `List` is blatantly misnamed, as it's demonstrably not the only feasible implementation of a non-readonly/non-immutable list. Look closer at how it's implemented, and consider other possibilities and their names. You'll probably find that something that makes it unique, and that should be reflected in the name.
What? Like naming it `ArrayList` (https://msdn.microsoft.com/en-us/library/system.collections.arraylist(v=vs.110).aspx)?
Lets say you have: `Loader` interface and `FilesystemLoader`, `HttpLoader`, `FtpLoader` implementations. If you have a good abstraction you don't work with any of implementations directly - you always work with `Loader` interface (and its provided implementation, and you don't care about what implementation you use). And everywhere you work with it, you type `Loader` like this `load(loader: Loader)`. If you prefix your things with "I" then you'll type everywhere ILoader: `load(loader: ILoader)`. And what is the point of this I? It just makes your code dirty and less natural, I don't see anything else good or bad it brings.
Yes, that's a pretty reasonably named implementation.
Zero-points for an incomplete answer. You don't get credit for simply restating that it is misnamed, you have to come up with actual replacement names.
Just fucking give up on the Redux shit sandwich already. Mobx is a million times better in every possible dimension. 
You wouldn't happen to have a link to your favorite tutorial would you? I am indeed on the verge of giving up on this shit sandwich. 
Sorry if this part didn't come through in my last reply, but it's clearly not possible to name an implementation properly knowing nothing about its implementation.
* List is a normal, mutable list. * ReadOnlyList is a wrapper for any IReadOnlyList that only exposes the immutable operations (i.e. reading the count and contents) * ImmutableList is an immutable list. Feel free to ask follow-up questions. 