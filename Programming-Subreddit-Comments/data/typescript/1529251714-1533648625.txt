Hmm those are some good points, it really would be nice to write everything in one language , and you are right there are a good amount of outdated or unmaintained libraries in python, especially Flask compared to Django. 
You mentioned you're looking at Angular codebases, but if you'd like to see a real world TypeScript + React + Redux application, [here's \~7000 lines of code of that for an application with \~350 daily users ](https://github.com/Anveio/mturk-engine)that I'm working on. It also has a [guide](https://github.com/Anveio/mturk-engine/blob/master/DEVELOPERS.md) for reading the source code and running the application locally.
It worked out well for me - if you want to learn TS, just go ahead and learn it. It's not some magical beast that you need to approach circuitously. You'll come across plenty of Javascript elements as you learn but there is no need to understand JS in detail before you start. As for Angular - it integrates nicely with TS but I haven't used Vue or React very much so can't compare them. If I was just looking at my CV, I'd probably learn React. In my team the developers don't have a lot of front end experience Angular made more sense.
Node on the back end can be very nice. I'm using it to implement Lambdas in AWS and it works very well.
Here's on, though I'm not sure how approachable it is: https://gitlab.com/Flockademic/Flockademic/ Note that it's actually three separate projects, located in the `/stacks` folder. Two back-ends and a front-end. The nice thing is that they can share some code, but especially [type definitions for the API endpoints](https://gitlab.com/Flockademic/Flockademic/tree/dev/lib/interfaces/endpoints). That means that if I change the API responses (or expected parameters) in the back-end, I know where to make changes in the front-end as well.
TypeScript became really popular at the dawn of es6 (es2015). Using the new features of the language meant that you would only get partial browser support. TypeScript offered a way to write modern es6 but also introduced strict typing. People lost their minds. However JavaScript caught up with things like ‚Äúflow‚Äù, ‚ÄúBabel‚Äù and in the case of react. I honestly switch between TypeScript and JavaScript all the time and barely notice a difference these days. Except in my opinion TypeScript adds a bunch of dependencies to my package.json which kinda sucks. People in programming are always elitist about what they think is best, it‚Äôs because we‚Äôre passionate. But honestly JavaScript+Babel+Flow and TypeScript are the same thing in the end. 
Visual Studio Code
Github client
Take some of your production code and turn it into typescript. 
Being doing front end for a little while now, have used all the major frameworks. They are about the same, despite what people say. React is a little more hands on, Angular has lots of boilerplate, Vue is a less boilerplate-y Angular with some strange-ities. All support typescript, they will all do what you want them to. What's more important is understanding patterns. If you don't like JS much or don't want to set up an environment, go angular. It has ts/scss out of the box with the cli.
Try them all out. What have you got to lose? Then determine for yourself. Everbody will give different opinions. Untill vue 3.0 launches, Angular is a no brainer if you got a brain. We'll see about vue 3, but I doubt they can "beat" angular. Probably will remain what it is now; a simple clear way to develop cute apps.
Hey, Dandamis, just a quick heads-up: **untill** is actually spelled **until**. You can remember it by **one l at the end**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Get the fuck outta my face.
How about the tool you'll probably be using to write it: [https://github.com/Microsoft/vscode](https://github.com/Microsoft/vscode)
&gt;However JavaScript caught up with things like ‚Äúflow‚Äù, ‚ÄúBabel‚Äù and in the case of react. None of those are part of Javascript. \&gt; I honestly switch between TypeScript and JavaScript all the time and barely notice a difference these days. I mean they're not apples and oranges but if you're not noticing a difference between static and dynamic typing then why even use TS? \&gt; Except in my opinion TypeScript adds a bunch of dependencies to my package.json which kinda sucks. Oh, you're not.
I believe that people with these opinions never worked on big code base with a type system and proper tooling. They just don't know what they miss. If you have a big project without typing and it does not have an excellent test coverage, you are just insane. Types and static analysis does not make tests optional, but without them you have to heavily rely on tests to be sure that you are not breaking half your codebase every time you change something.
I don't really let it bother me (other than enjoying discussing it only sometimes, but that doesn't really emotionally affect me). The only moment it is relevant is with direct colleagues, but I'd just categorise that under the general challenge of inter-colleague-interactions, aka social skills.
Uhms, I tend to have these discussions with colleagues and I understand that those are the challenges to overcome but... I find this behaviour almost exclusively in JS whilst I don't see it in c#, f#, swift nor c++ (naming some of the other communities I tend to work with. How do you prevent it from getting to you?
I understand your point and unfortunately, excellent test coverage and good tests tend to not go hand in hand and devs tend to (unknowingly) relax the quality around tests towards the end of the day (the quality of tests variate quite a lot within a single project). This is one of the reasons I love static typing
I always like to point out how the ability to use interfaces is the most useful to us. We have many and deep object structures in domain model objects and passing these around and returning valid objects back is made workable by TypeScript and just poiuntless mud-swimming in raw javascript. We even generate the interfaces from server code - automatically. So we compile our code and then the data sent back to our client app automatically has the right types. All the classes and methods that deal with them all understand what they're getting and returning. The documentation and increased readability value of that is priceless to us.
That somehow newer is always better and thus the creation of gazillion new JS frameworks. Each dying a silent death after a few years. And guess who has to pick up where they left off. Everybody thinks their shit smells the nicest. The community as a whole needs to come together and create a default JS core api. It is insane we need strpad, Date or HTTP community libraries. 
It just happens, I guess? Agree to disagree and all that. Your friend's argument sounds somewhat like the [No true Scotsman](https://en.wikipedia.org/wiki/No_true_Scotsman) fallacy. I _know_ I understand my code with Javascript and that TypeScript helps me with that, so I don't really feel like their description applies to me. (I'm less good at this with colleagues though :P)
**No true Scotsman** No true Scotsman or appeal to purity is an informal fallacy in which one attempts to protect a universal generalization from counterexamples by changing the definition in an ad hoc fashion to exclude the counterexample. Rather than denying the counterexample or rejecting the original claim, this fallacy modifies the subject of the assertion to exclude the specific case or others like it by rhetoric, without reference to any specific objective rule ("no true Scotsman would do such a thing"; i.e., those who perform that action are not part of our group and thus criticism of that action is not criticism of the group). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/typescript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I've tried to raise this exact point so many times, is a fruitless exercise.
Apparently, this topic has offended somebody (is the internet nevertheless... that was to be expected), but I would love to know your point of view random anonymous that downvoted the topic. Would you mind sharing your thoughts? I really want to have a level-headed conversation with the community to see if there is something we can all improve.
What bothers me is that every man and his dog seems to want to publish endless snippets of code to npm. It can make it hard to find the good quality code that is being maintained. 
I don't agree with this. For a long time everybody used jQuery and Moment, but better replacements for these have come along. If we'd stuck those in the core API they'd be permanently stuck in there now given our obsession (that's a different debate) with backwards compatibility.
As always, there's a [relevant XKCD](https://xkcd.com/927/)
Flow and Babel are part of the JS ecosystem, their transpilation and compilation process tools. I always compile JS these days, weather using Node or React. TypeScript offers the TSC cli interface, which acts the same as the Babel Cli interface. Flow is a static typing library and works the same with vs code. But I still stand by my @types import statement. That will always suck.
There are so many issues with no static typing, apart from being more error prone. Static typing gives you fast compiled code for free, whereas with dynamic typing the JIT compiler has to work everything out, which may and will fail in many cases. Static typing also gives allows method overloading which is an amazing feature that javascript misses out on. But knowing with what kind of objects you're dealing with is still one of the best things ever about static typing. Dynamic typing should be optional, not mandatory.
I used to be that guy. I always relied on the name of my variables/arguments to know what data was being passed around, for example. We have a shared library worh models, core logic, and utils used by about 20 apps of variying complexity. Even though the code is clear as day to me (so I assume), no one else can work on the core parts without my help. As a tech lead though my goal now is to make sure other people can be effective without me. Typescript has been a godsend in this sense, and helps me find bugs in my own code all the time. Devs who are used to types have quickly taken advantage it, but we are still working to show the benefits to most of the junior devs. I find that VS Code makes a big difference. Those that use atom or Sublime are not setting their editors up for typescript so they don't see as much benefit. Another huge win with the non js crowd is async/await, we are moving away from callbacks now and it feels similar... Easy for me to follow but not for others. Now I'm growing to enjoy it as well
Could you elaborate how this synchronisation works? Sounds quite interesting and useful!
You assume adopting a library into core would be easy and added as is. The proces of adding a core library should be rigoureus and properly tested like they do in other mature open source organisations as to overcome adding an improper library that is stuck. Sure not everything can be perfect. But no single person or organisation should dictate the standard. The community as a whole. There is no consensus now. 
The community dictated those older standards as well. That's just the way things are; this is a language that cannot afford any breaking changes.
Honestly this might be my favorite part of ts that no one talks about as a major strength. I can use magic ‚Äústrings‚Äù, write tons of documentation, put oddly named keys into variables and use `obj[key]` or I can simply write a ts interface. A ts interface is easy to read/write, describes the intent of the code in a succinct way, makes key name changes a click of a button and is always up to date. When I first started learning ts I started writing libraries in it over js just so I wouldn‚Äôt have to write and maintain tons of jsdoc.
Getting downvotes is not an indication that you have "offended" somebody. 
&gt; I find that VS Code makes a big difference. Those that use atom or Sublime are not setting their editors up for typescript so they don't see as much benefit. Dear god. Coding in TypeScript in a plain text editor would be a horrendous experience, especially if you're a JS dev with no strong typing experience. 
A lot of the js community is very green. The dunning kruger effect is strong.
He's probably using something like OpenAPI (formerly known as Swagger) to have a machine readable presentation of his service API. Based on that it's trivial to automatically generated the client contracts. No need to manually update the client code when the service changes - let the computer do that for you.
Worthless medium articles spammed so that their CVs have a Medium link
Function parameters, preferably return types, everything that is `any` (e.g. `fetch` responses), the rest somewhat according to intuition.
I try to be as explicit as possible, for 2 reasons: 1. It ensures that the actual type matches what I expect it to be. 2. It makes it easy to see with a glance what the type is, without using Intellisense. 
I find that when just reading code on something like Github without being able to jump to the definition, having a `Discombobulate&lt;Gollygoops&gt;` type written down doesn't really help me that much.
1. All function argument should have an explicit type 2. Return types can usually be inferred, but sometimes you want to check that the function actually returns what you're thinking it does, especially during development. Also contextual typing is useful with the return types. 3. Initializers can usually infer the correct type so writing `const x: string = "foo"` doesn't add any clarity - it in fact reduces it. 4. The exception to 3. is when you initialize inherited class properties like React's state - you always want to explicitly repeat the type since the type system will just let you add undeclared properties willy nilly.
True, but you're not losing either. You're just gaining for the situations where you recognize the type. 
Maximum type inference. Less code = less bugs.
With that silly response he just let out that he doesn't know a sh\*t about type checkers. One can have solid arguments againts the use of type checkers, but that absolutely is not one. I'd quote solid arguments ones in the lines of: \- Question that the complexity that it adds still dont outweigh its benefits. (Complexity which is comprised of much more than the types themselves, but also build tools, 3rd party typings, fresh/ustable/unpopular/unmantained tech, etc) \- Question that one still has to write tests in the end, which overlap a bit in purpose with typings; \- Question that types may encourage the use of determinate patterns; (All of those questions can be countered)
Just return the promise and change the return type of the function to `Promise&lt;string&gt;`.
This describes my approach, too. I expand it to include: * A method or function that returns a new object matching a defined interface. interface Person { name: string; age: number; location: string } // needs explicitly type to keep me from screwing up a key or omitting something crucial function newPerson(name: string, age: number, location: string) : Person { return { name, age, location }; } // doesn't necessarily need an explicit type function findPerson(people: Person[]) { return people.filter(person =&gt; person.age &gt; 29); } I'd argue that if that second function was exported or wasn't immediately clear, it'd still benefit from an explicit return type.
I'll take a crack at it. One way to do it is with a callback function: let getCFPrice = (cardName: string, cb: (err: Error | null, result: string) =&gt; void): void =&gt; { let returnStr = ""; const options = { uri: cfSearchPageWithCardName(cardName), transform: (body: any) =&gt; { return cheerio.load(body); }, } rp(options).then(($: any): string =&gt; { let cardPrice: string = $('h3.grid-item-price').html(); console.log(cardPrice + 'test2') cb(null, cardPrice); }).catch((err: any) =&gt; { console.log(err) cb(null, err); }) } Use it like this: getCFPrice('foo', (err, result) =&gt; { if (err) throw err; console.log(result); });
Thank you! &gt;Also, when you're initializing a variable, it's considered best practice to not explicitly declare the type I'm not sure if I under stand. So is something like const url: string = 'home.com' bad practice? I took your suggestion and modified the method to return a promise string. This is my entire index.ts file. Do you think this is good coding practice? import fs from 'fs' import rp from 'request-promise' import cheerio from 'cheerio' console.log('Starting Card Price Script!') let fileText: string = fs.readFileSync('./cardList.txt', 'utf8') let cardList: string[] = fileText.split('\n') let cardParamList: string[] = cardList.map(x =&gt; x.replace(/ /g, '+')) let priceList: string[] = [] let cfSearchPageWithCardName = (cardName: string): string =&gt; { const cfSearchByCardNameURL: string = 'http://store.channelfireball.com/products/search?q=' const url: string = cfSearchByCardNameURL + cardName console.log(url) return url } let getCFPricePromise = (cardName: string): Promise&lt;string&gt; =&gt; { const options = { uri: cfSearchPageWithCardName(cardName), transform: (body: any) =&gt; { return cheerio.load(body); } } return rp(options) } cardParamList.forEach((cardName: string) =&gt; { getCFPricePromise(cardName).then(($: any) =&gt; { const cardPrice: string = $('h3.grid-item-price').first().html() priceList.push(cardPrice) console.log(priceList) }).catch((err: any) =&gt; { console.log(err) return 'error' }) })
&gt; I'm not sure if I under stand. So is something like const url: string = 'home.com' bad practice? That's the gist of it, yeah. I can't find the link now, but the official docs discouraged it. As far as I know it doesn't hurt anything. It just makes it easier to read and is unnecessary.
If you're returning the promise from `rp()`, I think you're not dealing with a `Promise&lt;string&gt;` anymore, but a `Promise&lt;any&gt;`.
\&gt; Despite the fact that JavaScript is an object-oriented language, it does not have any builtin mechanisms for declaring members to be public or private. There is currently a \[class fields proposal\]([https://github.com/tc39/proposal-class-fields](https://github.com/tc39/proposal-class-fields)) which will allow for private class members. It is in stage 3, so it will most likely be added in to the language soon.
\&gt; I feel the proponents of just javascript (and sometimes Flow) I don't see how this extends to Flow, which is extremely similar to TypeScript. 
I got you. I'll review the code later today because for now, this fix works for me. However, I think using **async/await** instead of a promise would be much easier to read.
I sort of disagree. While the template does have all of those things, they‚Äôre already setup out of the box and you don‚Äôt need to touch them at all. Using the template doesn‚Äôt really require knowledge of HMR and webpack, just sets you up in a nicely working environment.
If you can, I think having two separate functions would be a better idea, e.g. `returnObject(): object` and `returnString(): string`, and you can extract shared logic into a function. It's easier to type and much more readable than using a flag argument. In a vacuum, it's unclear what `doThing(true)` means; do the thing true-ly?
When I use TS in small projects I just make type declarations where it matters the most, this is for small projects, personal tools. On big projects tho, I make everything very explicit, to avoid lot of dumb bugs.
Explicit cast? https://tutorialstown.com/typescript-explicit-casting/
'&lt;A| undefined&gt;' cannot be converted to type 'A'
Weird. The whole point of explicit casts is to tell the compiler that you know something it doesn't.
I just restarted VSCode and that seemed to fix the problem :/ return a ? a : create(z); Is now working
I'm using [ReinforcedTypings project](https://github.com/reinforced/Reinforced.Typings) We compile C# code and it immediately and automatically generates interfaces for classes we have adorned with attribute [TsInterface]. You don't have to use attributes, though, there's also a fluent config for determining what to generate.
I agree. Overloaded function seems to be the best option here: function sharedLogic(in: string) { log(\`Doubling ${in}.\`); } function doubleIt(in: string): string { sharedLogic(in.toString()); return \`${in}${in}\`; } function doubleIt(in: number): number { sharedLogic(in.toString()); return in \* 2; } The compiler will know what type to expect returned based on the input, and you won't have to worry about union types like \`string | number\`, checking downstream what type the result is.
Less executable code, yes. Less static type constraint code, the opposite.
 a &amp;&amp; create(z) Is common shorthand for a ? a : create(z)
That's not what I meant. I mean something like this, in OP's case // instead of this function doThing(shouldReturnObject: true): object function doThing(shouldReturnObject: false): string function doThing(shouldReturnObject: boolean): string | object { return shouldReturnObject ? { hello: 'world' } : 'hello world' } const obj = doThing(true) const str = doThing(false) // I'd prefer this function returnObject() { return { hello: 'world' } } function returnString() { return 'hello world' } const obj = returnObject() const str = returnString() There's less noise, and the intent of the code becomes cleaner. And, like I said before, if there's something that `returnObject` and `returnString` do in common, can put the common logic in another function.
One of the major problems is that most people haven't experienced a type system anywhere near as nice as TypeScript. If you're experience with type systems is Java then the stance that type systems are restricting is entirely valid. The best part about TypeScript IMO is it's embrace of the JavaScript development model. Defining classes is not necessary and you really don't need to change how you code to get the immense type benefits. Heck even things like string's as enums works flawlessly in typescript. The early attempts at bringing types to javascript didn't work this way. They acted as Java in javascript and they didn't work very well. There was even libraries that defined types using JSON, and then didn't even give any compile time tools for it. It was a terrible world and anyone who experienced that would (rightly so) be hesitant of anything that claimed they bring type safety to the web. 
Unless I'm missing something, [the example given seems to compile without any errors](https://www.typescriptlang.org/play/index.html#src=abstract%20class%20Test%3CA%3E%20%7B%0D%0A%20%20%20%20abstract%20get\(z\)%3A%20A%20%7C%20undefined%0D%0A%0D%0A%20%20%20%20abstract%20create\(z\)%3A%20A%0D%0A%0D%0A%20%20%20%20getOrCreate\(z\)%3A%20A%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20a%20%3D%20this.get\(z\)%0D%0A%20%20%20%20%20%20%20%20return%20a%20%3F%20a%20%3A%20this.create\(z\)%0D%0A%20%20%20%20%7D%0D%0A%7D) Maybe... upgrade your TS version? Not sure what could be the problem here
You could do "get(z) as A" in getOrCreate function
Sometimes TypeScript Server doesn't know to update that something has changed. There's a command to restart only TypeScript Server when this happens. (It's usually instantaneous for me. I don't use VSCode, though.)
The only thing I don't like about that approach is that it involves changing the name of the function you're calling if you type of its paramter changes, as you work with your code. But I agree, that's more descriptive.
\&gt; This is a very selfish/individualistic view (in my opinion) that I feel strongly across the JS community I wouldn't say it's selfish. I'd say it's an immaturity or ignorance that produces statements like that. To say something as silly as "I don't like compiled languages" just tells me that someone doesn't understand them and isn't willing to learn. If anything that's my gripe about the JS community is that it's full of lots of immature developers. Either young devs who have just learned how to code and JS is all they know. Or worse are the "web devs" who have transitioned from HTML, CSS and a little jQuery to being able to write code on servers or desktops thanks to new platforms like Node or Electron. They were never well trained or disciplined developers but due to a booming eco-system now have access to a broader range of development with the one tool they know and refuse to consider using anything else. There's nothing wrong with dynamically typed languages. There's something wrong with developers who know nothing but.
Flow does not force you to compile your code, is basically annotations for JavaScript. At least that‚Äôs how my friend is using it.
Don't write code like that ...
Interesting idea but I think `a ? a : create(z)` is a clearer 
I discovered the other day that A &amp;&amp; B || C Is (I think?) the same as A ? B : C And it blew my mind. 
&gt; I'm not sure if I understand. So is something like const url: string = 'home.com' is bad practice? It's not bad practice. It's just a style preference. However, having non-explicitly typed variables that are initialized with an object literal **are** bad practice.
"A is the best option." - "I agree with you, B is the best option."
Agree with that. But I had to come up with this solution, because I created typings for an existing JS library. This library is a client for a REST API. The following function I had to use the "function overloading". ```JavaScript ... containers: function (lazy, callback) { ... ``` This function requests all "containers" from the REST API (e.g. GET `/api/container`). If the parameter lazy equals true, this function will only return an array of container UUIDs. If lazy equals false it returns the an array of container objects. I had to Google for a while until I came up with this solution and I think it is pretty neat. So I posted it on Stackoverflow and on here. But you're right, I should make a disclaimer in most cases this is not best practice! 
This. And if JS developers still not believe TS is awesome, show them [this talk](https://www.youtube.com/watch?v=M3BM9TB-8yA) from Ryan Dahl (Node.js inventor), where he says TypeScript is the best thing that happened to the JavaScript community. He is currently creating as a hobby a new node, called deno, which has the TSC built-in. If the Node.js loves TS so much himself, you should really reconsider it in my opinion 
Yes, you are right, although I believe it would be a lot more productive to participate in the conversation as well (not just downvote). That way you might be able to share your point of view.
Haha, that is not exclusive to the js community. I've seen it in several profiles and headhunters tend to follow those patterns (in a way it works... which is utterly depressing).
I said it as selfishness because the js community has been around for quite a few years now. I perfectly understand your comment about immature developers and it is true... if you learn to use a hammer, all of the sudden everything looks like a nail, right? I know that calling them "selfish/individualistic" is wrong because they might be great team players (my friend, for instance, is like that, very team driven and willing to work on the moral part) but is that closed thinking "I know how to do this" without thinking about the future is what bothered me. As you said it, there is nothing wrong with dynamically typed languages, I tend to write my build scripts in ruby and I like it a lot more than f# (for build scripts)... but just for scripts. I feel that writing anything bigger than scripts is reckless and a bad practice for "future me".
&gt; Static typing gives you fast compiled code for free Uhms... for most programming languages that might be true. I am not that sure about typescript that will be just running the same javascript at the end of the day. &gt; Static typing also allows method overloading which is an amazing feature that javascript misses out on Unfortunately, I don't think this is valid in typescript :( &gt; JS could be the best thing ever, if it just had static types. Typescript is okay, but it would need to be supported by browsers and V8. Well... I am looking forward to webassembly. That should make things a lot better.
I would love to agree... but I've seen the similar behaviour in a lot of different communities. Some communities have it a lot less because it tends to scare people away (cough-haskell), but (based on experience) I've seen the same process of valuing your skills a lot higher than the rest of your peers, especially when you are starting in a new area.
Intellisense on Visual Studio is faster when you explicitly define types, i noticed when i was working on converting a project from js to ts.
I usually reply pretty rudely to headhunters. They don't understand what the employer requires, they don't understand what the candidate can do, they just understand 2000‚Ç¨ commission from a successful contract, they don't care about the rest. MOST employers don't hire robots that have exactly 7 years experience in php 4 years in react. They hire human beings who would be a good fit for the team. Headhunters act like algorithms. They lie, overestimate, underestimate, exaggerate to get the candidate hired. It's a good idea, but it doesn't work. And that senior with 20 years in JS that they got a job for in the UK (Example) could find 20 more jobs like that had he applied himself via email and interviewed.
sure bud
Thanks, published v0.0.4 with this change. Usage is `ArgumentTypes&lt;Fn&gt;[1]` and `ConstructorArgumentTypes&lt;Fn&gt;[1]`.
Inferring more means writing more DRY code, where the runtime code ‚Äútypes himself‚Äù without the need of unnecessary extra annotations. Inferring more doesnt mean losing or erasing types, neither using any. Actually, when one uses heavier generics patterns, the types can even get more detailed then if you just had erased them to ducked interfaces.
I must admit I find myself guilty of using async/await in some scenarios. But for 90% of the async data you probably want to use RxJs. Otherwise your code will look like callback hell again when things get a bit more complicated with async data.
Eh? Guilty? Async/await is easily the clearest syntax for async code IMO and I think that's supported by the fact that it's being picked up by other languages. 
;) Thats correct. The project is meant to be fairly minimalistic. It hopes to enable the developer to make most decisions. Where this project expresses some opinion is in its choices of Swagger, pino, dotenv, ... It ultimately provides devs the minimum needed to ensure they've got sane support for api request validation, interactive api documentation, fast logging, and a simple build system that enables [es.next](https://es.next) via babel. 
It is the clearest syntax, where simplicity is allowed. But also adds nothing besides that. It's still just promises. And to properly catch errors you still have to wrap it in a try catch. With ReactiveX you always have the same structure no matter how complex or simple your data flow is. 
Looks interesting. Web3.js (the Ethereum JS client) uses a similar system.
Yes, that's where I got the idea from. I've credited Fabian Vogelsteller in my README. FYI, I'm using the PromiEvent in a layer above Ethers.js to get similar events to web3.js 1.x
Seems like a problem with the available abstractions (that are not built to complement async/await) rather than the technology.
The problem is not type script but the bundle system you use for transpiling the code. Try webpack 4.
not bundling system. I am waiting for VS Code to update type checking. Sometimes it takes forever to get definition of an object.
Ah yes I guess we're on the same page. Typescript is pretty good with inference. I'd only explicitly type what can't be inferred. As long as it has full typing coverage either way.
Something is wrong with your system. I'm using Macbook Pro with i5 and 8GB RAM with absolutely zero issues.
Sometimes extensions can be *very* heavy on your CPU. Try disabling them altogether to see a possible difference.
I have disabled all extension but nothing changes
Seems kind of odd to hate typescript due to an issue you are having with VSCode
How large are the projects? Two minutes sounds really excessive. The projects would need to have several million lines of code, and even then it's questionable. Make sure your VSCode is updated. Also check if perhaps those projects are configured to use the local TypeScript SDK and if that TypeScript version is perhaps slow. You already said you disabled all extensions, so that should be ruled out (especially disable any angular and tslint extension). Do your co-workers have the same issues? Could you try another machine?
So similar to io-ts. That's great, we need more options. I'm working on an alternative version too. :-)
the project is quite small. Less than 100k lines. But we have pretty long types generated by io-ts. If I hover on an object, the popup type window is thousands of lines long.
That's your issue. The magic that io-ts performs for the type inference takes a heavy toll on the compiler. 
I've needed something similar myself, but instead I just composed a simple object: `{promise, stream}`
You have a problem with your local machine. Blaming this on TypeScript is childish.
To Answer your Question: Yes.
I experimented with a few different solutions, and in the end decided on using [https://github.com/ooesili/type-safe-json-decoder](https://github.com/ooesili/type-safe-json-decoder) . It is heavily influenced by Elm's decoders. It takes a little while to learn the pattern, but once you get the hang of it, it makes writing decoders pretty simple &amp; fast. I would recommend it. Only bummer is that it doesn't have a huge amount of npm downloads or github stars.
[io-ts](https://lorefnon.tech/2018/03/25/typescript-and-validations-at-runtime-boundaries/) is one that I‚Äôve seen as well. For JavaScript validation in general I know [joi](https://github.com/hapijs/joi) is popular. It doesn‚Äôt have any typescript type generation, but if you‚Äôve already written out the interfaces you don‚Äôt really need that to be honest. 
Class-validator, class-sanitizer and class-transformer by pleerock are very good tools.
I've been using [normalizr](https://github.com/paularmstrong/normalizr), but the typescript integration isn't great, unfortunately. Mainly, I wanted to say that now [this song](https://www.youtube.com/watch?v=JQNv2sY7Ge0) is stuck in my head.
I cry and pray. I'm serious, TypeScript's type-safety doesn't extend beyond compile-time. Yes you can perform client-side type checking but then you might as well be performing proper schema validation with [yup](https://www.npmjs.com/package/yup) or something equivalent.
So you're looking for dynamic static analysis on an object retrieved via an API? I'm not sure that's possible.
I think they are suggesting emitting meta data during compilation which can then be verified at runtime. That's doable, I recall atscript the now dead Google language based on Typescript did this
io-ts is incredible and adding custom validators is not difficult 
So I have one more question. I think the code is not in sync because now when I run the code, I expect a result like \[ '$5.99' \]\[ '$5.99', '$9.99' \] and I do sometimes but I will also get results like \[ null \]\[ null, '$5.99' \] with the same input. Is there something I'm missing where the console statements are resolving before my promises?
My guess is that `$('h3.grid-item-price').first().html()` is sometimes returning `null`. Try adding `console.log($)` on the line after `getCFPricePromise(cardName).then(($) =&gt; {` and see what it outputs.
You might want to look at https://quicktype.io/, I believe it can generate runtime checks from your interface.
It's one big reason I'd like TypeScript to create a "RealTypeScript" of sorts (via WebAssembly perhaps) that addresses these issues, as well as JavaScript's weirdness.
Whenever this topic comes up I like to read all the options available and then sit and wonder how JS became a mainstay on the server side. Who wouldn't want to build a service architecture and client libraries for it on a dynamically typed language? Everyone loves having to dig into documentation to find out if their request/response object satisfies the API contract.
We use our home grown Maybe monad all the time in our Typescript. Since introducing we've noticed a few things. 1.) Code is more correct and less error prone 2.) It's more efficient as better use of short circuiting 3.) Cyclic complexity is way down 4.) It's help spread functional programming practices through the team 
It would be nice to see some examples (or descriptions of examples) of these things. Reading the examples in the docs of this library isn‚Äôt all that educative, as it‚Äôs quite hard to see how addThreeNumbers 1, 2, 3 gives the benefits that you describe!
Poor naming choice. `Nullable&lt;T&gt;` by your library and an incompatible NonNullable&lt;T&gt;` by the standard library.
So in our case If (foo != null &amp;&amp; foo.bar != null){ If(foo.bar.baz &gt; 20) { return "older" } else if (foo.bar.quax != null &amp;&amp; foo.bar.quax.age &lt; 20) { return "young" } } return "unknown" BECOMES const barMaybe = Maybe.nullToMaybe(foo) .map(f =&gt; f.bar) const older = barMaybe . filter (b =&gt; b.baz &gt; 20) .map(_=&gt; "older"); const younger = barMaybe .map(_=&gt; b.quax); . filter (q =&gt; b baz &lt; 20) .map(_=&gt; "young"); return older.or(younger).defaultTo("unknown); Did this on phone on commute so sure it can be better but it does show the functional style, composition, lazy evaluation etc. It can be much more terse as well. We have operators such as orElse or combine etc etc. If you've done Rx or used libs like underscore you'll understand the benefit of using repeatable operators and queries. 
I recommend you read the Elm docs on maybe monad. 
I'm not sure this is 100% Monad compliant because there is no way to distinguish a value of type `Nullable&lt;undefined&gt;` and a value of type `None`.
Ah, is that similar to Rust's `Option`?
Check out AssemblyScript
Interesting, but I don't see anything there about compile-time type-checking or casting?
If you are an agency, don't bother. If you are building a product, it is essential.
Is this a typo and OP meant Flow instead of ReasonML?
Is this a typo and OP meant Flow instead of ReasonML?
What's your backend and IDE? For example, we use C# and Visual Studio. Typewriter will auto generate TS files based off of a template. There are NPM packages to work with swagger as well, which might cover your case.
I think this is a counter example, correct me if I'm wrong: function f(x: number): number | undefined { return x &gt; 0 ? 1 : undefined; } function g(x: number | undefined): boolean { return typeof x === "number"; } function compose&lt;A, B, C&gt;(f: (x: A) =&gt; B, g: (y: B) =&gt; C): (x: A) =&gt; C { return (x: A) =&gt; g(f(x)); } const l = compose(Nullable.map(f), Nullable.map(g)); const r = Nullable.map(compose(f, g)); const result = l(-1) === r(-1); // should be true according to functor laws
You got it. But without pattern matching e
You got it. But without pattern matching. 
Yeah we use nullable for mapped types
You can strip out null/undefined union cases by either doing an explicit undefined/null check if(key){ spaces.top.left = squareValueMap.get(key); } or by using the non null assertation operator (!) spaces.top.left = squareValueMap.get(key!); 
 spaces.top.left = squareValueMap.get(key) as string; or use an intermediary and a Type Guard const temp = squareValueMap.get('test'); if (temp === undefined) { // return or throw or handle here } else { spaces.top.left = temp; }
I think OP's issue is that the return value of `squareValueMap.get(key)` is possibly undefined, not `key` itself -- so the `!` would go outside the parentheses: ``` spaces.top.left = squareValueMap.get(key)!; ```
Yes, you are correct.
Try to remove the typeRoots completely from your tsconfig, it should automatically detect the types Also can you paste the command you running ?
removing that didn't seem to fix it. npm run build runs the command "vue-cli-service build" (hooray for obfuscation! and yields the error Try \`npm install @types/bootstrap-vue\` if it exists or add a new declaration (.d.ts) file containing \`declare module 'bootstrap-vue';\` that returns a 404. Doing some digging (and this maybe better suited to the Vue subreddit) the index.d.ts uses all the components in a global style...meaning I'd have to import the whole project, and not just the components I wanted to use (adds about 150k to my payload) and maybe that is the answer, I just have to use the global import to use this library and Typescript. For example import bButton from 'bootstrap-vue/es/components/button/button' gives the error it can find the definition. However import BootstrapVue from 'bootstrap-vue' Vue.use(BootstrapVue) works.
Similar things have been done already [acm page](https://dl.acm.org/citation.cfm?id=2676971), [paper](http://www.cs.umd.edu/~aseem/safets-tr.pdf)
Type definitions, *.d.ts, only exist at design time. They are completely removed when the code is transpiled to js. So unless I'm misunderstanding your meaning adding type definitions for the entirety of vue won't change your final bundle at all.
You are absolutely right, I communicated this rather poorly. There is one .d.ts file. If I try and import individual components the compiler throws an error saying it cannot find the type definition. For example I want to use this component [https://github.com/bootstrap-vue/bootstrap-vue/tree/dev/src/components/button](https://github.com/bootstrap-vue/bootstrap-vue/tree/dev/src/components/button) I can do a simple import and only bring that component in. What I cannot figure out is how to do that, and have the typescript compiler recognize the component typing is defined here [https://github.com/bootstrap-vue/bootstrap-vue/blob/dev/src/index.d.ts](https://github.com/bootstrap-vue/bootstrap-vue/blob/dev/src/index.d.ts) Without needing to import the whole library
The following is supposed to work in Typescript and is the syntax to import things dynamically. let foo = import('foo')
Well I dunno. That project has various issues open about typing including. But it looks like they didn't actually write it in ts so I don't really know if they didn't set the typings up properly or what.
Thanks! I was thinking that too
I suppose `import` will work. For some reason I didn't think `import` translated into `require` calls. Your example should be `let foo = await import('foo');` since `import` is asynchronous.
Yeah, sorry for the lack of await. 
The comments on those requests make me laugh though. It takes several comments for him to realize what is actually being asked for
Just spent this evening fixing up the typings for my Redux store only to find this now. I've come to a similar solution, albeit likely with more boilerplate in exchange for less black-box/'magic' functions. I like a lot of the design choices here. Finally, a solid, holistic approach to integrating React-Redux into a TypeScript project. Allow me to give that GitHub repo it's hundredth star! üå†
I got the feeling they were just pushing their vs code plugin really hard. Because it makes sense to download a plugin for every single library you use...
If you were just going to click the first link without looking why not hit "I'm feeling lucky"?
More like "don't click any of the links on the entire first page of results." :D
`DeepReadonly&lt;T&gt;`
The same happened to me. Quite an unfortunate error üòÇ
If you have feedback about my writing style or my content I am all ears. I hoped you liked it.
And keep in mind that the order of Google's search results is adjusted based on your previous searches. ;-) Your first result won't be the same for everyone else.
I'm coming from PHP. Been doing webdev on &amp; off and I never really took the time to learn JS properly, so always hated it. Here's what I did: * Started with just writing some CLI sysadmin type scripts (kind of like my own a very simple config/deployment system like ansible/puppet/chef etc)... so that I could focus on just learning JS itself (latest ES version), without even thinking about browser stuff. There's a book + video series called "javascript for php developers" that really helped me... i.e. it's not super basic "learn to program" stuff... it just focuses on telling you what is different. It might even be useful for you as a Python programmer, and there's probably similar resources along the same lines too coming from Python. I think if I jumped straight into webdev stuff that I would have a number of misconceptions of what is pure JS functionality vs browser stuff, so backend code would be a bit more confusing. * Then I changes my CLI system to use Typescript. Again, I think it was helpful doing this outside the context of webdev. * Now I'm building a site using Vue/Nuxt/Typescript. Vue is easier to get started with than React I think seeing there's more n00b friendly guides etc. The main Vue documentation is really all you need to get started. Nice thing about Nuxt is that I'm doing both some backend + frontend code in the same project. Changing whether some code executes and renders HTML serverside -vs- in the browser is as simple as moving where the `&lt;no-ssr&gt;&lt;/no-ssr&gt;` tags are in the templates. Pretty cool coming from the world where your backend is an entirely different language. Note however that it's recommeded that you do your backend API code in a separate project to the Nuxt project. Although it is possible to do it all in the one project... but I'm probably going to set up a separate project with Koa for all the API calls. 
Not sure what do you mean. AssemblyScript is a subset of TypeScript that compiles directly to WebAssembly, with full compile time AND runtime type checking capabilities (through WASM).
This awkwardness is why I replaced my maps with readonly objects. e.g. from: const cfg = new Map&lt;string, string&gt;(); cfg.set('name', 'Hodor'); to: interface Config { name: string; } const cfg: Readonly&lt;Config&gt; = { name: 'hodor' };
Sorry, I meant runtime type-checking, my mistake. Where does it say that runtime type-checking is supported?
I haven't read the article, but just wanted to get this off my chest: who the hell creates awards for charting libraries? :P
When I say Immutable, I actually mean Immutable.js, so these are different object types.
While I cannot speak for tslint, my personal opinion is that doing too much in a file makes the code harder to read/understand and it's much easier to blur responsibility of one class ends and the other begins. I am primarily a Java programmer where you can only have one public class per file, and when I use other languages like Kotlin that allow more, I still find myself generally limiting each file to one class. 
Under the header "rationale". [https://palantir.github.io/tslint/rules/max-classes-per-file/](https://palantir.github.io/tslint/rules/max-classes-per-file/)
Right. This does not work if you are using any form of inheritance though. I'm working with a set of classes that inherit from each-other (they're basically just nicer interfaces to some JSON messages. I guess I could just leave it, and allow the devs to use the design document to figure out what fields are and aren't used in each different type of configuration message, but I felt it would be prudent to abstract out those structures into something more useful).
Perhaps. I tend to group files by general purpose in relation to the code as a whole, with each class inside clearly handling a specific part of that section, for instance in a UI system, having a class that handles events, one that handles containing widgets and components, then a basic component that can be inherited from for more specialised use
You can't import the parent class? `import Foo from './foo'` `class Bar extends Foo {` `}`
Having a load of fairly closely related classes in separated files seems pointless and messy. Seeing as the base class is literally empty, and just there to provide a common root to trace back to, and that they all serve a similar purpose I see no reason to create that many files for that.
Different use cases often mean different 'best' practices. Java would enforce that rule, but there is a strong enough reason that several newer languages agree with your rationale. Kotlin has the idea of sealed classes that mean all sub classes must appear in THIS file. In this case, I would tend to agree with you. If I have several small classes that all inherit from the same parent ... e.g. \`Node\` \`Leaf\` it would make more sense to have them in the same file, but that would be about the only case where I can see it being a better practice than separating them out.
I guess part of it is also that I come from Python, where grouping classes by purpose, and not simply having 1 file per class is far more common. In Python you'd more likely have a file named [UI.py](https://UI.py), which would contain all the classes directly related to the UI
It's supported by definition - WebAssembly supports it, albeit limitedly. It's going to be expanded in the future, though: - https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md - https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md
In typescript, you'd typically have a folder \`ui\`, and a file for each ui component. It's a convention. Instead of diving into a file of dozens of ui component definitions, you can look at a folder and jump to \`book-view.ts\`. At the end of the day, as long as your code compiles and runs, how you organize your code is up to you. You're free to disable the rule ("max-classes-per-file") in \`tslint.json\` or just on files which you make the exception with \`// *tslint:disable:max-classes-per-file*\`. That said, you should at least come to terms that it's a convention for a reason and it certainly works just fine. It's not messy because everything is neatly labeled and every file has a single responsibility. It's not pointless because it can increase organization, which may outweighs the overhead of adding more files. 
I would probably do it if my classes had much in them, but they're just there to provide a few utilities. Having so many files for maybe 20-40 lines doesn't feel worthwhile, and what I'm writing is pretty small. In Python for specific UI components, you'd likely have a file for each one, but the core of the UI code would be in 1 file
That's fine. I'm sure it makes sense to you to have it organized like that. I personally don't understand the "not worth it" statement because from my perspective there's nothing lost by separating into different files (my opinion, not trying to say you're *wrong*).
All good. I try to work my code in a way that is accessible to other devs when necessary, and I always spend some time pouring over conventions for each language I use to make sure the stuff I write makes sense and complies with community standards. By not worth it, I mean the time it takes to create the files and insert a boilerplate license statement and whatnot. It's part me being lazy, part not being used to structuring code that way
The preview of their v4 on their site looks fantastic. I‚Äôve never used a charting library that I love and really look forward to trying this one. 
Thanks for this post
Thank you for this, there was a lot of great info in this post
The charting library award committee, of course 
I'll join those who is not going to read the article and will try to guess the answer (if it starts with "how" is the sentence a question) instead: they sat in front of computers and wrote some typescript code.
There's a strong confusion about what "java classes" and "javascript classes" mean. A Java class is a state container AND a module path. A javascript class is just a state container (and a hacky shim around proto inheritance to please OOP lang newcomers); Since typescript uses structural typing, in many cases you gain nothing by creating classes for some structures. While in java's nominal typing system a `Foo` object MUST be created from a `Foo` constructor, TS will only check if those objects have the same properties, **no matter how they were created**. 
I think generally I saw codebases where each class was in separate file but those files were in a single folder like you described. Also, the sintax for importing will be almost the same if you create `index.ts` file in that folder.
Pro Tip: You can get rid of the need for all the typecasts in the code by changing the signature of nullableIsNone to be a type guard: function nullableIsNone&lt;T&gt; (nullable: Nullable&lt;T&gt;): nullable is None { ... }
Do you have an example on how to split up a larger project into smaller ts projects? Tha k for the write up.
So I just split up one of our larger projects that had about 700 files into 40 projects this last week, so this is fresh on my mind, but it depends on what the state of the code is. If you live in a mythical world, the dependencies are in a DAG, meaning no circular dependencies. In this case you can just graph the dependency structure and then draw a circle around a group of the files and it is safe to move those. If you have actual code then it is a bit messier. I wrote a script that uses the TS compiler API to create a pretty simple data structure that represents the dependency graph for our code. I then select a group of files (I call this the pivot), and throw those into a new project. Then the remaining files fall into 4 other groups, which I move into 3 other projects. 1) Depended on (transitively) by the pivot group. 2) Depends (transitively) on the pivot group. 3) Depends on the Pivot and the Pivot depends on it (quasi-circular). 4) No dependency relation with the pivot. 1,2 get new projects that depend on the pivot project, then I just leave 4 in the original project, and 3 gets moved in to the pivot project. To me this has been a good balance of having projects divided on logical concerns (choosing the pivot) and also creating small projects that allow for incremental changes to the strict flags and also it helps with our incremental compilation build process that we have. If people are interested I could clean up the script and open source it.
Something like this? type DeepImmutable&lt;T&gt; = { readonly [K in keyof T]: Immutable&lt;T[K]&gt; }; type Immutable&lt;T&gt; = T extends (infer U)[] ? List&lt;DeepImmutable&lt;U&gt;&gt; : DeepImmutable&lt;T&gt;;
Those downvoting please say why so I/it can improve
One doesn't even need to use TypeScript to benefit from it. As more and more library authors convert, and as people use intelligent IDE's like Visual Studio Code, they will get free benefits without doing anything to their project.
We moved to TypeScript - there is a great deal more support than in plain javascript or coffeescript. Not many things can be confidently assumed/refactored using such elastic languages.
Maybe I'm imagining it, but I seem to be noticing a steady decline of Typescript criticism/hostility over on /r/javascript, especially over the past year or so.
I suppose I'm making the potentially unpleasant (or pleasant) statement that one could merely ride on the productivity of others. The bounty of TypeScript is shareable.
The bounty of TypeScript is shareable, and does not demand reciprocation.
Yep you're right. Those against types are bring win over. 
Almost. Type annotations help to document the code a lot more, and using TS syntax lets you dip into the TS ecosystem more easily. JSDoc syntax _works_, but it's verbose and limited.
They're saying there's still _some_ benefit if you're using plain Javascript, _if_ your libraries' authors are using TypeScript.
I am a recent convert to Typescript. The developer experience is amazing. 
Well, one of the big problems I had accepting Typescript is that so many people see it and say: "Yay, now I can bring my established practices from C# and Java to Javascript" which is not always a good thing. But I think that the more people move from JS-&gt;TS instead of from C#-&gt;TS, people are finding ways to get the benifits of typing with the flexibility of Javascript more. 
or someone contributed a type def to your library on DefinitelyTyped. VSCode downloads it automagically from there.
The handling of external packages improved **a lot** too, and that was a major problem.
I strongly dislike your code style, but that's preference. Tho I have a few constructive suggestions: - Don't use `console` in your library. I'd immediately drop any library that dumps output to the console that I can't control. If you want to be able to log some output, let the user pass a `onError` or `onWarning` callback. - Spreading an empty object literal is pointless, don't do that. In `envOverlay.ts` line 87 you have `{ ...{} }`. That makes no sense. - You have a type-bug in your handling regarding the optional settings. In `envOverlay.ts` line 87 you create a new object by spreading your default options and the provided `options` type. In the target type `IEnvOverlaySettings` most properties are non-optional, and in the source type `IEnvOverlayOptions` all properties are optional. The huge issue here is that an optional property **can be set to `undefined` explicitly**, and the spread you use will use that explicit `undefined` value. So if I call `envOverlay('test', { disallow: undefined })` it's perfectly valid code (and is according to the types), but it will produce a bug in your library as the value is `undefined` in your target `settings: IEnvOverlaySettings`. Instead of having two types, one with required and one without optional properties, you should use the standard `Pick&lt;&gt;` type instead. - Instead of accessing the DOM yourself, provide a way to just return the created HTML node. - The signature for the `envOverlay` call is wrong in your readme. It mentions `options?: IEnvOverlayOptions`, but looking at the source I can see that it's **not** an optional argument, but it's a **required** argument with a default value. That's a difference. With `options?: ..` I could pass `undefined`, but with `options: IEnvOverlayOptions = {}` I could not.
It's worth to note first that VScode checks your plain Javascript using the typescript compiler internally.
Thank you for the pointers! Very much appreciated I'll try to reply with my reasoning for your points - please do reply my comments to my comments - I'm not trying to rebuke, but to elaborate on the points for you to counter and elaborate more. I was a little conflicted about wether to use console, but I decided that for the cases where something would be going wrong in a bad way - there I would do it (for instance if there was no "document", which would indicate you trying to run it in an environment that made no sense. I'm not catering for situations where someone is specifically trying to break the pattern - thus if you send "undefined" you are trying to break it intentionally, and I won't write bloated code to counter that. For the code the "settings" are required - as the program is using these values - therefore from the users point of view things are optional - for the code itself inside, they are not. As of spreading on to an empty object - old habit, I do not like to extend on to a object that is hardcoded in - I prefer to safeguard it with an empty object, but that is probably just an old habit I need to get rid off. I will fix the signature for sure - very good point, and the Pick&lt;&gt; also. As of returning the DOM instead of adding it myself right away - could do that as an option probably (easy of use was a major priority here) Thank you VERY much for taking the time to reflect on it and give me these pointers - hugely appreciated. I'll go make a new version and implement some of your suggestions
&gt; I'm not catering for situations where someone is specifically trying to break the pattern - thus if you send "undefined" you are trying to break it intentionally, and I won't write bloated code to counter that. That has nothing to do with trying to break the pattern. Your signature clearly states that the type `undefined` is allowed, so I should be able to set the value to `undefined` without your library failing. Imagine I construct the settings-object like this: `{ property: hereIsAFunctionThatMayReturnUndefinedOrMayNot() }` - and if the function returns `undefined` I want the default behavior of the library to apply. Completely valid according to your types, but currently this would result in an attempt to access `undefined` in your library.
In other words: He finally understood the purpose of static typing.
Fair point
Can you describe what you've done and why it's not acceptable? Your description is pretty vague.
I'm having some trouble understanding what you're asking for. You can specify "module": "es6" to have TypeScript emit regular import statements in your JavaScript. If your deployment paths are different from what you have in source, you may need to use the "paths" compiler option to specify the mappings.
I used to be against TS too when it was released. I felt that it was trying to fragment EcmeScript developer space with branching concepts. But TS pretty much adopted ES2016 and onwards and added types to it. Over the years I too have become a very strong advocate of TS.
When I tried that it wasn't translating my import statements to point at the resulting JS files and would fail at runtime.
I have a src directory with TypeScript files inside of it with a directory structure. I also have a tsconfig. I can run the TypeScript compiler from that folder to build my TypeScript into JS files. If I use an import statement that points to a module path (e.g. import {MyModel} from "./model" ), it works, but then fails at runtime when the resulting code expects to find a JavaScript file. I can find the error I am getting once I get home and can look at the project again. I'm not too interested in finding the answer to my specific problem. I am more interested in finding documentation or recommendations on how to setup TypeScript when the only front end tool you want to use is the TypeScript compiler.
Unfortunately, TypeScript is only one piece of writing a frontend. For example you'll still need HTML and CSS. Similarly ES6 modules aren't a solution to shipping modules: http://engineering.khanacademy.org/posts/js-packaging-http2.htm . There are ways to make things sort of work but you're going to be fighting against the tools if you do it, which is also why you can't find documentation on it. Specifically here, TS allows 'import ... from './foo.js' when you have foo.ts.
One of the biggest ones for me is interfaces.
&gt; For example you'll still need HTML and CSS. Not really...almost the entire UI is going to rendered to a canvas element. &gt; Similarly ES6 modules aren't a solution to shipping modules Reducing latency on downloads of files is not important to me for this project. &gt; TS allows 'import ... from './foo.js' when you have foo.ts. That is what I am using now, and it kind of works. Looking over the documentation, I think what I really want is to use the triple slash references and just use an outFile tsconfig option...and I can avoid using runtime modules entirely.
Yes, you still need to add a module loader if you want to use javascript modules. I prefer SystemJS. Browser-support for module loading is right around the corner (except for IE11). You will need to target "ES5" in your tsconfig because neither browsers nor nodejs fully support ES6 yet. You will also need a Promise polyfill. [I used this one](https://github.com/lahmatiy/es6-promise-polyfill). To load your first module, add this javascript to your `index.html`. Thats the entry point. System.import('Application').then(function(exportedItems) { var myJsApp = new exportedItems.Application(); }); This will attempt to load the file "./Application.js" if it hasn't been loaded yet (a module is only loaded once, then the loader keeps the exported items in memory). The callback will return an object with the exported items from that file, and you can do whatever you would do to start your app. The "triple slash references" when using an outfile works too. But it can cause problems with circular references. And the feature is deprecated.
&gt; Browser-support for module loading is right around the corner (except for IE11). I'm confused, MDN and caniuse.com both imply all modern major browsers support JavaScript import statements today. I don't need to support legacy browsers for this project. &gt; The "triple slash references" when using an outfile works too. But it can cause problems with circular references. And the feature is deprecated. Where are you finding that the feature is deprecated? According to the documentation its only the -out parameter that they deprecated, and that was only because they didn't want people burned when they changed the relative pathing of the feature. Dealing with circular dependencies could be a pain in the ass though...
Have a look at the parcel bundler ([https://parceljs.org/](https://parceljs.org/)) and parcel-plugin-typescript. It's really easy to get started and requires almost no configuration! Run ``` npm install --save-dev parcel-bundler parcel-plugin-typescript typescript ``` Create a `tsconfig.json`: ```json { "compilerOptions": { "module": "commonjs", "esModuleInterop": true, "target": "es5", "lib": [ "es6", "dom" ] }, "include": [ "./src/**/*" ] } ``` Create an `index.html`: ```html &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="./src/index.ts"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ``` Finally, create the `src/index.ts`: ```ts function add (...numbers: number[]) { return numbers.reduce((sum: number, n: number) =&gt; sum + n, 0) } console.log(`2 + 3 = `, add(2, 3)) ``` Run with: `npx parcel index.html` Create a static build with: `npx parcel build --public-url=./ --detailed-report index.html` Hope that will get you started ;)
&gt;I'm confused, MDN and caniuse.com both imply all modern major browsers support JavaScript import statements today. Chrome since September 2017. But i missed that they've finally enabled it for Firefox in May 2018. &gt;Where are you finding that the feature is deprecated? Huh. I might be mistaken. I seem to remember the documentation telling me not to use it. [Here is a working example ](https://github.com/emptyother/tsbrowserproj)of what I explained. This was the way i did it a bit over half a year ago, in a project that i needed to support IE11 too.
&gt; Huh. I might be mistaken. I seem to remember the documentation telling me not to use it. On the page that talks about it, they mention referencing files and mentioning types, and they state not to reference types except when creating type definition files. The documentation tells you not to use one variant of the triple slash references. Maybe that is what you remember? That example is pretty close to what I was looking for originally before I stumbled on the triple slash references. Thanks for sharing! It's frustrating to me that the TypeScript documentation doesn't have some equivalent.
That is interesting...but I don't really need a bundler and part of the reason I want to avoid other tools and WebPack is because of the large number of dependencies, difficulty upgrading, and large cognitive load. In comparison, using the TypeScript compiler is incredibly simple. I just didn't want to jump through hoops to use the import statement. The HMR support does have my interest though...maybe I'll give it a try. How many dependencies does parcel have?
Why not just use Webpack to concatenate all your TS into one JS file for the browser? I know you expressed concern over Webpack changing often, so you want to minimize the number of moving parts you add, but this is a fairly common use case and so there's a stable, established way to do this with Webpack. Basically, you use Webpack to compile your code (not the TypeScript compiler) and in your webpack.config.js file you use a loader to enable the TypeScript compilation, called "ts-loader".
I started by using Java patterns myself, but now I have developed some patterns which feel more at home with TS.
Afaik import should be supported in new version of all good browsers but you can still rely on es5/commonly and just load the transpired is files over http. Should work pretty straight forward and out of the box. 
As you didn't explicitly say this, I wanna ask this just in case. On the documentation you linked it says the import statement can only be used from a script that is declared as module. Are you declaring your entry point in your index.html as such? &gt;The import statement cannot be used in embedded scripts unless such script has a type="module".
Its a bit of an understatement to say it has more moving parts and changes often. An empty webpack install has dependencies on 324 packages and takes 40 seconds for NPM to install on my machine and packages resolved will change throughout the day sometimes. TypeScript is released by Microsoft and is a single package from a single vendor. I don't have to worry about compatibility of my tools when its one library...and upgrading is trivial. I don't need a transpiler, I don't need a CSS or HTML loader, I don't need HMR, and I don't care to break my runtime library into anything other than a big blob of JS with a source map. I don't really get anything out of using Webpack except that its usage in this context is better documented because Webpack is used with most front end frameworks =(
If you don't want to use any module bundler (webpack/parcel/requirejs) you could fall back to "vanilla module-less" files -- TS files without any root `import` or `exports`. You would be the one in control of the files you load by using `&lt;script&gt;` tags. Kick the compiler using `tsc -w`, choose whether you wish him to output the `.js` into the same folder or in a separate folder. I'd list two approaches on listing which types are available for each file: - You can add all your TS files into the `include` section of your `tsconfig.json`, which means all types are global to every file; - Or you can add only "entry points" to your tsconfig, then use `///&lt; reference &gt;` tags; When not using modules, the `namespace` tags are really suited to scope files and quite replace the pattern of wrapping a file in an IIFE. Module-less JS scales bad and you will be afraid of splitting code into small files. You would probably regret not using any module system soon. But could be OK for small front-end napkin code. Curiosity: The TS compiler itself does not use any module system (or better, it uses "vanilla" global modules and namespaces and some custom build tool).
I've used it and have found that it works very well.
Kinda cool proof of concept that shows how powerful the vs code plug in system is, but I'd NEVER want to do this. It's hard enough keeping track of all my open files without having one of the tabs being chat. 
Why would using ///&lt;reference&gt; tags with an entry point in tsconfig scale poorly?
It \*could\* bring issues if you have lots of HTML files with script tags you have to manually manage, or some sort like that. Nothing to do with typescript actually. Its the same as if you were writing JS without any module bundler. You'd ask "do I need a module bundler?", "do the benefits outweigh the cons?"?
[a lot](https://github.com/parcel-bundler/parcel/blob/master/package.json)
Except I can bundle my TypeScript with the TypeScript compiler using outFile, if I don't need any other type of bundling, right?
Yeah, I used to do that long way back on TS 1.5. Didn't work bad for my case, tough I've read a couple of articles advocating not using it.
I preferred Flow a couple years ago, but considering the recent improvements in TypeScript and its rich ecosystem, it became much more appealing to me. The only two things still missing are HKTs and variadic generics. If they get added, the last bits of typing awkwardness will go away.
\&gt; everything inside one tool It might be one tool, but its made up of over three hundred packages and many different package authors. Calling it simple is a stretch. I'm not avoiding WebPack in general, I use it on most of my work projects either directly or hidden behind our front end framework's CLI and I'm not afraid to eject the config when necessary. I just wanted to know how to do 'Vanilla' TypeScript, because there doesn't appear to be good guidance on how to setup a project for that in the docs.
Did you set the baseurl in tsconfig when defining the paths?
Use yarn to improve the installation time of packages. Also, both yarn and npm use lock files now so that you can restore your installed packages to a particular version. There may be a few hundred packages used by Webpack but that's just due to NPM maintaining hierarchical dependencies, so that everything gets exactly what it asks for. Many NPM packages the up causing multiple packages to exist as dependencies of the project. Unfortunately the best the TypeScript compiler can do alone is concatenate your compiled JavaScript. The browser won't be able to use it because it won't have a module system. That's what lead me to learn how to add Webpack into the mix. It's really not that bad once you get more familiar with it. I'd recommend giving it a shot. I'd suggest you check out a new Webpack alternative called Parcel, which aims to need no configuration, but you seem to appreciate standards. Webpack should be around for a while and using it to prepare a JavaScript bundle for a browser should continue to be a popular use case.
True, but not more than a webpack setup with typescript loader, etc., I'd say. And installation time is still ok.
There is an easier way when dealing with CoomonJS modules (= node modules): ```ts import foo = require('./foo') ``` No `await` necessary, since node's `require()` is synchronous.
I'd say just make a compromise for the team and use whatever the group wants. It _is_ for work. It's cool. Good job getting them to adopt ts!
I am totally with you! I don't come from an C#/Java background but I also hate those nested '.then' and '.catch' syntaxes. It also can lead to a 'Callback hell'! For me it's like this: If I don't need to catch the specific error I am just surrounding my async tasks with a try/catch and break the operation on catch. If I need a specific error then I am trying to resolve my promise with my own 'Error Object' rather than rejecting it. Then I would get the Custom Error Object as return and immediately after that I will check if my return is an instance of my Error Object and will goon with that information. If it is mandatory for me to get an rejected promise... Well than I use the .then .catch syntax... Hope my experience helps you!
Additionally to what the others said, I'd suggest to actually adopt a proper functional style: Don't use errors at all. Instead use a result object, which either is a success or a failure - but not throwing errors.
Sure this simple case looks less verbose. In real backend apps you typically do many async calls in tandem. Even if you don't today, you might want to add in the future. I'd say show your team more complex examples and demonstrate how much simpler async flow is. For frontend code I'd say it's allright because you split by components anyway and usually a component only does one our two async code so it's not a big deal.
Your link points to the Reddit post itself.
How did that happen? ... üôà But thx! Added the right link in the description.
I have no idea. I always thought the `8ttw4b` is a hash of some sort, so I wonder how you knew the hash before posting... Anyway, perhaps you should additionally also add a link to GitHub directly.
I get the same version of my dependencies, but I get different versions of the transitive dependencies depending on when I install. Is there a simple argument I can pass to npm install to tell it not to update the transitive dependencies and just use what is in my lock file? I think maybe they have an argument designed for use on a build server that does that? &gt; There may be a few hundred packages used by Webpack but that's just due to NPM maintaining hierarchical dependencies That number I got was just by counting the top level folders in node_modules, which are unique package names. I wasn't counting packages inside of packages. &gt; Unfortunately the best the TypeScript compiler can do alone is concatenate your compiled JavaScript. The browser won't be able to use it because it won't have a module system. I am under the impression through documentation and articles that if I use triple slash references between my files, that the concatenated output will be properly ordered assuming I don't have any circular references. &gt; It's really not that bad once you get more familiar with it. I'd recommend giving it a shot. I have. I use it for other projects, and in cases were I need its features. I just don't want to use it in this one project I am creating that doesn't really use HTML or CSS (outside of one or two static files), and doesn't really need bundling. All I need for this project is to be able to write TypeScript and have it run in the browser.
As far as I know, the triple slash directives are an older, deprecated way of declaring types. I'd have to look into it more though to be sure. I think that your use case, "compiling TypeScript for the browser" sounds simple in theory but involves the use of bundling. The one time I got away with not bundling when doing this was making a simple script for one page. It didn't involve importing and exporting. I got one JavaScript file after I compiled it so it ran in the browser.
You can use triple slash to refer to reference paths or to reference types. You are only supposed to use it to reference types when creating a d.ts file by hand. There is no indication that it is deprecated for referencing paths though. The documentation says: &gt;**/// &lt;reference path="..." /&gt;** &gt; &gt;*The /// &lt;reference path="..." /&gt; directive is the most common of this group. It serves as a declaration of dependency between files.* &gt; &gt;*Triple-slash references instruct the compiler to include additional files in the compilation process.* &gt; &gt;*They also serve as a method to order the output when using --out or --outFile. Files are emitted to the output file location in the same order as the input after preprocessing pass.* It then goes on to say it outputs files based on a depth first search starting from root files defined in the files section of the tsconfig, meaning it 'should' handle most output ordering issues (but not sure if it can handle circular references properly, though I would imagine referring things by interface instead of by class would fix those issue as well, where needed).
I don't remember and I'm a bit confused...is that relevant here?
If I am attempting to get and map a result from the database I tend to use an await with a chained then. ```typescript try { const people = getPeopleFromDb().then(rows =&gt; rows.map(personFromRow)); // Use `people` } catch (e) // handle err } ```
I've tried this multiple times, but it never works. Because it's impossible to consistently do this 100% since something can always throw errors, and I had many instances where I ignored errors with this method (especially when having a `Result&lt;void, XYZ&gt;`). It's also annoying to not be able to bust your stack but instead have to handle every result manually (the Go `err, res := fn()` problem).
It can be extremely important as it has to do with how the transpiled files will include each other. But it's possible to make a setup where it doesn't matter. So I don't know how you originally tried to set up the output.
Funny, after I posted this I went searching and found a great series here: https://codewithstyle.info/advanced-functional-programming-typescript-functional-exceptions/ I'm sold. Perhaps you could help me. The author recommends the https://github.com/gcanti/fp-ts library which is made by the same folks are the io-ts library I like so I'd like to use it. However I don't see a `Result`. Is there another term used in functional programming? Here's the list of typings available: https://github.com/gcanti/fp-ts/blob/master/docs/index.md Or does this library simply not have a Result object?
I think I was using the default and also tried setting it to '/'.
You can use the class as an interface instead. 
The best thing to do here is create the interface and have the class itself extend the interface. This is a common OOP practice.
Unfortunately not. The problem is, as I mentioned, the class has serverside only logic. For example my class **image-list-options.dto.ts** ```TypeScript import { Type } from 'class-transformer'; import { IsInt, IsOptional, Min, Max, IsString } from 'class-validator'; import { PaginationOptionsDto } from '../'; import { ApiImplicitParam, ApiModelProperty, ApiModelPropertyOptional } from '@nestjs/swagger'; /** * This interface represents * options for request an image list. */ export class ImageListOptions extends PaginationOptionsDto { /** * The id of the remote, from which the images should * be from. If none is given, take the first remote */ @IsInt() @Min(1) @Type(() =&gt; Number) @ApiModelProperty() readonly remoteId: number; /** * The query-string which filters the image. * Search for image OS name or Arch Name */ @IsString() @Type(() =&gt; String) @IsOptional() @ApiModelPropertyOptional() readonly query?: string; } ``` `@ApiModelPropertyOptional` generates thanks to the framework I'm using (nestjs) automatically Swagger documentation. So I am not able to use this class in the frontend because of this.
Yeah, that would be my second option. I know it is common, but it feels quite redundant. It would be a nice-to-have if I could do this automatically somehow :)
You can import the class and *only use it as an interface.* The import statement will be removed from the compiled code, so your server-side logic will *not* be loaded by your client-side code. 
Depends on how much effort you are willing to put in but if you want to deep dive you can walk the ts ast for a class and then create a new ast for an interface with the same members. I've used [this lib](https://www.npmjs.com/package/ts-simple-ast) to work with the ast in a bit simpler of a manner. That library is a little slow, although apparently performance improvements are on their road map, but it works well enough otherwise. And if you are only going to generate the interfaces when you publish a build then the slow run times really shouldn't be an issue at all. I'd just hate to have to do something with that lib while hot reloading changes or some workflow like that.
Ah I see. That's pretty janky, in my opinion. I would rather just set up Webpack once as I begin my project and then code away, importing and exporting how I like, than worrying about triple slash reference directives for each of my source code files and what order things would be compiled in.
Oh wow that is awesome! Performance won't not an issue. I won't trigger the interface-generation script that much. I think I'll build a small CLI tool for this so I may could do this automatically in a CI pipeline. I'll have a look into this and if I have a result I'll definitely post on this subreddit. Thanks alot mate!
Yes right, but it fails during the build process when I changed the frontend code from Angular 6 to Angular Universal. May is another issue, I'll investigate more onto that. But still, I would have more sub-dependencies (which don't get compiled into my bundled file ofc, but it is nicer to have less dependencies). Thanks!
&gt; than worrying about triple slash reference directives for each of my source code files That is exactly how you use import statements, though. Its just a way to import things at build time instead of asynchronously at runtime. If I plan (for this project) to have the client load all of the code at startup, then there is no benefit to using a runtime module loader other than the import statements looks nicer than the reference ones. I could see how a module loader is useful or necessary for most traditional web sites and many web applications, but it doesn't add much to a project that is creating a canvas UI on a single page with an up-front asset loading phase. &gt; and what order things would be compiled in. I won't do that, the TypeScript compiler will.
The code you get after the Webpack process finishes does not import things dynamically. The imports are handled at compile time (it gets concatenated into a big file with functions emulating the dynamic imports). That's what I'm trying to explain to you. Just using a simple Webpack configuration that won't ever grow after you first set it up will get you your non-dynamic, simple, compile time TS-&gt;JS for a browser.
Maybe not just as much, but I use WebStorm (well, IntelliJ Ultimate, but WebStorm features are in it), and when writing JavaScript, the IDE silently reads the TypeScript type definitions for anything it can identify, and then gives me better intellisense and auto complete features using it. It's not as good as when using full TypeScript, but it's way better than just writing JavaScript in a text editor. And it's all because of TypeScript type definitions.
Classes implement interfaces. It's central to what they do together and how they are used. Anything else would feel like a hack and probably would be initially confusing to grey haired folks like myself. If I inherited code where there wasn't a very good reason I would begin to refactor it to be less clever after I uttered a string of "WTF's" under my breath. Also, interface members are public. Private doesn't make sense in an interface. Interfaces should contain method signatures and not instance variables. Interfaces specify a contract of behavior (i.e. methods/functions...verbs or verb phrases). You may want to look at abstract classes if you want have instance variables in your interface. Doubly true if you want private members in your interface as that is quite normal for abstract classes. 
The class is an interface. class Foo { readonly i = 5; } class Bar implements Foo { get i(): number { return 7; } }
I should add that if you want to see it there is an [official page](https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API) for typescript where about 3/4 of the way down they have a small section on how to use the built in tools to parse and create ts asts. That library is basically a wrapper around that stuff.
A bit hacky, but someone have made a library to catch error like in Go (it's compatible with TypeScript): &gt; \[ err, data\] **=** await to(getMyData())**;** &gt; &gt; **if**(**!**err) **return** new Error("bad error") [https://www.npmjs.com/package/await-to-js](https://www.npmjs.com/package/await-to-js) Blog about it: [https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/](https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/)
How do you import a class as just an interface? Never seen the syntax for it so would be interested to know
The import statement looks identical. But you only use it in type annotations; *never* as a value. The TypeScript compiler strips all type annotations during compilation, and if that means it has stripped all references to the class, then it will *also* strip the import statement. It makes more sense once you do it and see the results.
The import statement looks identical. But you only use it in type annotations; *never* as a value. The TypeScript compiler strips all type annotations during compilation, and if that means it has stripped all references to the class, then it will *also* strip the import statement. It makes more sense once you do it and see the results.
As someone who is primarily a Java Developer who pretends to be a front end developer at times, I like Typescript because it makes my JavaScript more like Java. It forces me to think about an actual API rather than `function (value, success, error)` What value does this function want? What are the success and error callback functions going to look like? What data can they expect as input? If this is a small project, or only one or two devs will ever see this the problem isn't as big. `function (value: number, success: (httpResult:string =&gt; string), error (httpResult:string =&gt; number))` is instantly more valuable. I can at a glance understand exactly what the function wants and will produce. 
Thanks for the great post! Your QAs have been added to the **https://www.fullstack.cafe** portal and back-linked!
As a mostly JavaScript developer, I do like that I can create contracts between functions and function calls, but I hate it how interfaces and classes and inheritance steers me away of the best ideas of JavaScript; classless object oriented programming and practical functional style on everything; detaching data and functions into data objects and function collections. 
I have noticed this trend...the primarily OO developers love it, those that have learned to think the "JavaScript way" are the ones more opposed to it. I am not saying they are wrong, it does almost feel like shoe horning on a different paradigm into an existing eco-system. It would be like Higher Order Functions, and functions as first class in Java. Node developers would likely me more happy to adopt it than current Java Developers.
I'm mostly a OO developer---cut my teeth in the Smalltalk days---but I have nothing against prototypical inheritance. I just feel that Javascript's variant is grating to use. If you like prototypical inheritance, check out Io. It's a small language, but their implementation is powerful and easy to use. Having prototypes but lacking reflection, always made Javascript seem crippled in my eyes. I think what attracts most people to types is the reflection---that it tells you at a glance what is expected, as the input and output, and you can write code that takes that into account. This can happen statically as Typescript does, or at runtime as Smalltalk did. Javascript originally was easy to write code in which was utterly unstructured at runtime, so in you would ask "what kind object is this?" and Javscript would "helpfully" reply "object" when really I wanted to know what someone intended this object to be when they defined it in code. 
https://www.npmjs.com/package/typesync
https://aka.ms/types is pretty good for searching through public type definitions. 
I would strongly recommend using vscode with the vim extension. While it doesn't perfectly emulate vim, it now does a pretty good job, and vscode is the best editor for integration with typescript (its written in typescript, after all). From there you would install various intellisense extensions (npm intellisense, path intellisense, etc.), which will typeahead complete your imports.
My dear fellow JavaScript developer. You are free to use JavaScript however you see fit. Even if you lock yourself in with Angular, you can still write most of your code in your own style. JavaScript is the wild west of programming languages. More like the wild west of Westworld. It's your world to do whatever you want! I love TypeScript, but be sure I won't be writing fully OOP/typed style if I just want to prototype an idea, or quickly migrate/transform a database and such. Now if I have serious work to do, you can be hella sure I'm writing in the best OOP style I am capable of. 
TypeScript adds types to all of JS. It isn't just for the OOP related constructs. If you want to write in a functional style you still can and you can still benefit from TypeScript. You wouldn't be using classes, but you would be specifying types in your functions and using `interface` to describe the data structures you're using. 
I jumped around a bit and he explains the type system and how it can help you even if it is a bit scary and sometimes can seems like it is in the way. It feels like an introduction to TS for sceptics of both TS and JS.
For better or worse, `class`es are a first class language feature of javascript. Typescript didn't invent them. It merely supports the classes that are already supported by javascript. It's a specified language feature, just like prototypical inheritance and `for ()` loops.
Vscode has amazing intellisense, when you write your imports it will show the exports, you can also go to definitions (f12) of practically anything and it will open the type inside node modules. It will also try to auto import if it recognized what your doing. 
i tried that but I immediately ran into a situation where a package with embedded types wasnt listed
In that case things should "just work" :)
It works as in "I hunt down the import and add it to the file and everything is ok" but that is the whole base of my question is how to do that without having to hunt it down and manually add it
I enjoyed looking through your code, nice job.
Thanks. :)
You just saved my life
I was thinking of doing something similar. I'll be having a look at your implementation it looks solid :)
Thanks! and any PR welcomed ;)
How does this compare to [https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts) which seems to be doing something similar?
Looks very nice. Perfect for C# devs moving to TypeScript. I like the extensible driver model. I wonder how difficult it would be to make a driver for Azure SQL.
&gt; I like Typescript because it makes my JavaScript more like Java ...which is exactly why a lot of JS developers don't like it :-) We have a deep-seated hatred for Java
Haven't seen that one, thanks for sharing! Seems pretty mature and comes with a lot of stuff.
I would imagine not very hard. There's actually an extension for TypeORM that adds LINQ queries to it, so you can do relations like Entity Framework. 
I have been on the verge of switching to vscode for a while. I ported most of my \`init.vim\` there, but I always get disappointed with something. Right now, I can't figure out how to get it to format my code and respect my \`tslint.json\` file. I could go tweak all the individual settings probably but then I would have to totally different sets of settings. It looks like this isn't well handled yet ([https://github.com/Microsoft/vscode/issues/17627](https://github.com/Microsoft/vscode/issues/17627)). Am I missing some simple way to do this?
Hey on a side note, how do you find typescript as compared to c# ?
I have a bit of a chip on my shoulder when it comes to TypeScript for the same reason I have a chip on my shoulder about any typed language. I've had arguments ad-nauseam with devs and managers claiming that typed languages prevent bugs and runtime errors. I've used typed languages for over 14 years. I know that those claims are patently untrue. I really appreciated the author touching on those points and listing them as bad reasons. The nod to TDD was an excellent touch. I'm a firm believer in unit tests no matter what language you're using. I was all ready to jump in with more bad reasons, and I got a really good article that was very well written. TypeScript will save teams time, especially if they are already familiar with Intellisense/Content Assist. For those saying that TypeScript forces you into OO, I would have to disagree. I've used Scala for functional programming for a little over a year and it's just as easy to do typed functional programming as it is to write functional javascript. Great read!
So pretty. 
Very nice!
Have you installed the TSLint extension in vscode
yes
My vote is for using them. The downleveling of decorators via the `__decorate` helper is pretty simple. If the API changed in the future (which is a pretty big if) in some incompatible way and you had to migrate your decorators to something else, you could easily accomplish this through a one-time automated code transformation. Since there's a straightforward way out, there's no harm in using the feature.
Have you set `tslint.autoFixOnSave` in your vscode project settings? It's one of the configuration points for the tslint plugin: https://marketplace.visualstudio.com/items?itemName=eg2.tslint Admittedly I recently ran into some difficulty getting things to autosave and format as well (I was trying to also apply `prettier`). But I think there's some initial startup cost in setting up any editor. vim -&gt; vscode is worth it imo, having come from that transition myself (well I went vim -&gt; intellij -&gt; vscode).
I‚Äôm still learning, so excuse my ignorance. What does this mean from a TypeScript usability standpoint? What takeaways can and should be applied to real world projects? I understand you can construct custom interfaces and types, but I‚Äôm feeling there is some nuanced concept from this specific example that I‚Äôm not picking up. I hope that made sense. Great article!! 
I argued against using decorators at my company based on the information presented in \[this readme\]([https://www.npmjs.com/package/core-decorators](https://www.npmjs.com/package/core-decorators)) &gt;While the decorators spec has changed and is now stage-2, no transpiler has yet to implement these changes and until they do, this library won't either. Although the TypeScript documentation uses the phrase "Decorators are a stage 2 proposal for JavaScript" this is misleading because TypeScript still only implements the stage-0 version of the spec, which is very incompatible with stage-2 (as of this writing)."
As I understand it, the API has *already* changed versus what is implemented in TypeScript. [See here](https://www.npmjs.com/package/core-decorators) for example. Regarding "you could easily accomplish this through a one-time automated code transformation", at my company, which I'd say is pretty typical, a bulk automated change to an application's codebase would require extensive regression testing. Even just to do the transformation itself doesn't to me seem "easy", which I interpret to mean "something that could be accomplished by a typical developer in less than a day". The first thing that comes to mind is that maybe I could convince tsc to transpile in-place ONLY the decorators. Can tsc even target TypeScript though? Without looking into it, I'd guess it would take a typical dev a couple weeks to come up with a reasonable approach to automating the conversions, plus a few days for each project to apply the transformation and regression test. We have something like a dozen TypeScript applications now in production. So we'd be looking at months worth of developer/tester days, which translates to tens of thousands of $.
Not really full understand your question but `C#` and `typescipt` both was created by MS and I also like the `linq` and `entity fw`style so.. I want to implement it for `js` by using `ts`.
To elaborate on that, I'm kinda sorta ok with stage-0 ("experimental") features. The decorators implemented in TypeScript (and babel for that matter) are not, however, stage 0. They WERE stage 0, but then the spec changed on its way to stage 2. We can say with a high degree of confidence then that the decorators currently implemented by TypeScript will never be 100&amp;#37; compatible with decorators that may eventually become of ECMAScript.
&gt; that the decorators currently implemented by TypeScript will never be 100% compatible with decorators that may eventually become of ECMAScript. The TypeScript team is very open to breaking changes in order to align with ECMAScript.
I am talking about typescript programming language. How do you find programming in typescript as compared to c#? Is it equally enjoyable ?
How to say..? If you like both `javascript` and `c#`.`typescript` is awesome.
Some background info. For a project we wrote a code generator which generates decoders to decode JSON to Typescript types. We use this to validate data we retrieve from REST api's. This way we are sure the JSON response matches the Typescript definitions and we get nice error messages when the JSON response is invalid. We use [json-schema-to-typescript](https://github.com/bcherny/json-schema-to-typescript) and [Ajv and Ajv-Pack](https://github.com/epoberezkin/ajv) together with some lightweight custom code generation to convert a JSON schema to Typescript. This really helped us out in our project so we decided to opensource it.
This is more on the theoretical side on how powerful the type system of TypeScript can be. You shouldn‚Äôt use this in a real life project.
German here. Subtitles are wrong because he speaks in a strong dialect (bavarian). He points out oddities compared to other srong typed languages. The oddities: * if a function returns void, you can still use the function to set a variable. So a void function does not return nothing, it does return undefined. Equally it is okay to return undefined in a function that is defined to return void. * you can use void to skip paranthesis to write a self invoked function (well this is more a javascript odditiy than typescript - but it get's extra confusing because of the void type in typescript) *you can define a function that does only define a front part of a declared function signature and still give that as a valid parameter into the function with the longer singature (eg. callback functions) *you can even define a different return type and value like boolean if the function signature needs to return void. And it works. *intersection types and union types he finds pretty odd (but he finds it kind of cool) - in that part he describes also how types and interfaces can be used almost identicaly *the whole concept of conditional types is mindblowing for him *"next level conditional type shit" on the example of the JSONified type. *case default statements generates warnings if, according to your conditional types, all cases are already covered - or shows you all the uncovered values (this is something he finds really cool) conclusion for him: typescript is an unbelievable mighty tool even for javascript developers, if only for using it together with typed librarys to reduce errors. 
Right, and when they do make that breaking change now I‚Äôm stuck using an old version of TypeScript because I have ‚Äúlegacy‚Äù decorators all over my code. The eventual consistency of TS with JS is a key part of the argument against the stage 0 ones currently supported by Babel and tsc. 
&gt; Storybook's TypeScript docs needs you to (eject and) modify webpack I think Storybook uses its own webpack, and you can override the config in the .storybook folder. It's definitely not easy to set up though.
Nice! Where'd you learn how to make something like this? Always curious as to how people go from CRUD side projects into games / more interactive apps.
I made a [chessboard](http://camccar.github.io/Chess/) a few years back for a job interview in canvas and raw js. I Just read the first few pages of w3school tutorials for canvas. I've been playing with angular 2+ the past 2 years and thought it would be fun to write a game in typescript. Rather than start with a hard game I decided to make Tetris first to learn how one would go about it.
The spec change from stage 0 to stage 2 is not that severe, it's a minor update to the API of the decorator functions themselves. Both Angular (which I work on) and Polymer are using decorators - in Angular the core of the framework depends on them. I took a moment to play with "inlining" decorator invocations, and came up with the following structure: Pre-inlining: declare function decorate(v: any): any; @decorate class Foo { bar: string = 'test'; } After inlining: declare function __decorate&lt;T&gt;(decorators: Function[], v: T): T; declare function decorate(v: any): any; const _a = function(){ class Foo { bar: string = 'test'; } return { Foo: __decorate([decorate], Foo), type: null!, } as { Foo: typeof Foo, type: Foo, }; }(); const Foo = _a.Foo; type Foo = typeof _a.type; Assertions to verify that values and types are correct: const f: Foo = new Foo(); const a: any = new Foo(); f.bar; // should validate. if (a instanceof Foo) { a.bar; // should validate. } A bit messy, but it would work in a pinch.
In what you call "node.js communnity", you could split them in some groups: 1. Defenders of javascript'y style, which means - use functional-y constructs to build things (closures, proto inheritance, no use of `new` and classes); 2. Guys who just can't unstick OOPish style; 3. Guys who don't care; Guys from 1 were heavily against the addition of classes in JS. And they will be agains decorators. A common thought is: if you are migrating to javascript, learn the damn javascript style, don't try to sew you previous language into it, please. Guys from 2 either don't get the JS style either can't get rid of their habits. They want features they used in Java/C# into JS. As you can see, I'm mostly a guy from 1.
There will be eventually a compiler flag for that, if it happens.
And then there are the people who use the best tool for the job. Your problem is better modelled with classes? Use classes. Is it better solved using a functional style? Use a functional style. It's not that I _don't care_, I just find the whole argument silly. Limiting yourself because of some ideology usually just results in worse/harder to read code.
Was just a model, in real world you can't really binarily distiguish groups, it's more like a foggy/linear mix-up. That being said, there is a wide range of problems which can be well solved by both approaches. In many times it really does come down to one's opinion. For instance, 99% of the things you do with a class, you can also do with closures.
Who are your customers? If you have a work SOE where you control all the users, your point is valid. If it's a range of browsers or companies where you don't control all the versions of software, your colleague is correct. The difficulty comes from when the spec changes... you now have the problem of detecting which version is running, then somehow either polyfill to the same behaviour, or for decorators, you might even need two versions of code which you serve based on your customer's version.
Thanks for the readme link! I think you have some good points. While you do argue against decorators with a reasonably valid argument, my coworker had a different argument, which was basically that we cannot trust the TypeScript compiler to not compile decorators to have some weird side effects that we can't predict that will in turn cause bugs in our code. I found that argument to be a bit silly but I was open to being wary of old/changing API specifications. Thanks again!
These are all Node.js services at the moment that we have complete control over. Although we do have a web frontend where we support a wide range of browsers. Those generally already have special code for older browsers. Even so, we don't have to use this pattern everywhere in all of our codebases even if we use it in Node codebases. We can use the best tool for the job. We just need to be aware. Thanks!
My coworker also believes we should only do functional JavaScript for the most part. I just think you are limiting yourself from potential tools. You may hate OOP but in some cases the solution might be that much simpler with a class so, why not?
Very cool! Record&lt;K, V&gt; looks much simpler than: { [key: string]: string } Definitely gonna be using that one instead from now on. 
That's the first thing I thought as well actually. I'm very excited to start using that one.
Once you've got it, puzzle out how https://github.com/bterlson/strict-event-emitter-types works!
The author's GitHub repo with examples - [https://github.com/ainalain/sandbox](https://github.com/ainalain/sandbox)
What makes it confusing?
[InversifyJS](https://github.com/inversify/InversifyJS) is probably the most popular. It's decent. Maybe I'm just a dumbass, but I have had issues with it before and had trouble figuring out how to diagnose runtime errors with it. I actually prefer to use [TypeDI](https://github.com/typestack/typedi). It's not as popular, but it's easier and simpler IMO. It also has great integration with TypeORM and TypeGraphQL.
I prefer Inversify, mostly because it's very easy to set up [child containers](https://github.com/inversify/InversifyJS/blob/master/wiki/hierarchical_di.md), which are handy for request-specific resolutions without having to get into really weird, repetitive factory patterns.
&gt;Record looks much simpler than: &gt; &gt;{ [key: string]: string } It is just an alias? Or there they have different set of features?
To each their own. I honestly miss it when I switch back to C# on the server side. I think it pairs very well with constructor injection.
Just to throw in my $0.02. I'm kind of in the same boat as you. In fact, I'm going the other direction. I'm going from vscode to vim. It's not that I dislike vscode, it's a pretty damn good editor. My requirements though are a bit more broad. For a given system I'm working on these days, I'll usually have to work across Windows 10, macOS, Linux, &amp; FreeBSD. I use SSH + X Forwarding a lot. Vim excels here over vscode in terms of speed. Also, I use FreeBSD heavily and unfortunately it does not have support for vscode. Finally, vim is significantly leaner when it comes to memory utilization, etc. I've also had some issues with vscode where auto-completion will stop working (language server crashed), but that might be something specific in my environment. Anyway, figured I'd throw that out there. Vim is now my primary editor/ide, while vscode is a close secondary option if I want to use it.
You need to make your examples comparable: Record&lt;int, string&gt; { [k: int]: string } It's still simpler, but not "much simpler".
Record is slightly different. It allows keys that aren't just number/string, but more complex types. In the basic case you can think of it as an alias. But ain't.
Mentally I find Record&lt;number, string&gt; much easier to parse. So I‚Äôd say it‚Äôs simpler. But yeah. It‚Äôs definitely subjective. 
yeah I use it because its lighter too. electron apps are just hard on thr memory
I just use default constructor arguments. For singletons I great simple getInstance() static method. No framework needed.
This is an initial version. You can see output generated here: https://github.com/tmc/grpcutil/tree/master/protoc-gen-tstypes/testdata/output/defaults Variations in flags are demonstrated in https://github.com/tmc/grpcutil/blob/master/protoc-gen-tstypes/examples.sh and their corresponding output is here: https://github.com/tmc/grpcutil/tree/master/protoc-gen-tstypes/testdata/output The main thing id like feedback on is 1. What‚Äôs the cleanest way to express the types and semantics of https://github.com/tmc/grpcutil/blob/master/protoc-gen-tstypes/testdata/route_guide.proto and 2. Should I be declaring/generating modules instead of namespaces?
What is the advantage of Record over Map&lt;k,v&gt;?
I don‚Äôt think that‚Äôs a subjective opinion but some people might do fine with abstractions awell
framework needed in an actual real world app for a real product, thank you
I‚Äôve worked on multiple high traffic sites, and built quite a few apps without any JavaScript dependency injection framework. It was useful in Java because the language simply wasn‚Äôt as flexible.
of course it brings another way to do the same thing, but it is very convenient in most cases. You simply need to make a convention and use it as you wish. TypeScript isn't the only language that supports such syntax, Scala for example does it as well.
Hi everyone! I just made this. I'm interested to hear what people think of it. Is it just another pointless framework? My hope was that putting Typescript first, and having deep support for weirder HTTP features like `103 Early Hints` and HTTP/2 push made it enough of a unique thing to be worth building, but I'm curious what the community thinks. 
I‚Äôm not sure I see the advantage over Koa besides maybe some of the http support (which I think koa can do either natively or via middleware). However, given that it is built with. Typescript, what would make this more interesting is utilizing typescript to improve request validation; typing of query, params, and payload, integrating better something like typeorm, and maybe even trying to auto generate an api based on that scheme.
One of the reasons I started, as actually that I found http/2 and sub-requests very painful to do with Koa. It seems like everyone just does real HTTP requests to localhost. Koa's dependence on Node.js's IncomingRequest/ServerResponse classes made it hard to fix this although I have also considered just trying to submit patched there. I like your suggestions though. I'll definitely have a look at TypeORM to see how they go about things, and see if I can bring it back to a web framework.
You might need to do something like this: https://www.typescriptlang.org/play/index.html#src=enum%20Types%20%7B%0D%0A%20%20%20%20SELECT_TAG%20%3D%20'SELECT_TAG'%2C%0D%0A%20%20%20%20SELECT_TAGS%20%3D%20'SELECT_TAGS'%0D%0A%7D%0D%0A%0D%0Afunction%20createAction%3CT%20extends%20string%2C%20P%3E(type%3A%20T%2C%20fn%3A%20(payload%3A%20P)%20%3D%3E%20P)%20%7B%0D%0A%20%20%20%20return%20(payload%3A%20P)%20%3D%3E%20(%7Btype%2C%20payload%7D)%3B%0D%0A%7D%0D%0A%0D%0Aconst%20selectTag%20%3D%20createAction(Types.SELECT_TAG%2C%20(payload%3A%20string)%20%3D%3E%20payload)%3B%0D%0A%0D%0Aconst%20action%20%3D%20selectTag('test')
`Map` is a class introduced in es6. You need to use `.get`, `.set`, `.has` etc. `Record` is a plain object. It has no runtime interface.
You can use an enum value directly if that's what you mean? https://www.typescriptlang.org/play/index.html#src=enum%20ActionType%20%7B%0D%0A%20%20%20%20SELECT_TAG%20%3D%20'SELECT_TAG'%2C%0D%0A%20%20%20%20SELECT_TAGS%20%3D%20'SELECT_TAGS'%0D%0A%7D%0D%0A%0D%0Atype%20Key%20%3D%20keyof%20typeof%20ActionType%0D%0A%0D%0Atype%20Payload%20%3D%20any%0D%0A%0D%0Aconst%20createAction%20%3D%20%3CK%20extends%20Key%2C%20P%20extends%20Payload%3E(type%3A%20K%2C%20payload%3A%20P)%20%3D%3E%20(%7B%0D%0A%20%20%20%20type%2C%0D%0A%20%20%20%20payload%2C%0D%0A%7D)
Enum is one of the early typescript constructs that creates both a runtime and a type element... which may cause some confusion. - (after TS ~1.5 they quite committed on not deviating from javascript) - (classes are one of these special constructs) Let's say you write something like function send&lt;T = 'something'&gt;(t: T) { return t } Even if T can ONLY be `something`, you still have to explicitly pass it to the argument, because otherwise TS would be "magically" adding runtime code instead of just type checking. TS commits on not adding "non-JS magic features". Reading from type info (which is soon to be removed on compilation) and generating "concrete" code from them would be classified as something out of TS scope. (the most notable deviation from that may be decorator metadata, which is tagged experimental). I'm quite sure at the moment there are quite of a dozen of redux helpers for typescript out there (at this right moment 5 people might be writing a new lib so solve the same problem). Even with that - damn - it seems so hard to find those libs -- sometimes one or another pop on social media around and I get quite pissed off how couldnt I find them before. (I myself have written another redux helper bc my searches were improductive at the time...).
Type-signatures and type-arguments (the bits in between angle brackets) only exist at compile time - at run-time you are left with JavaScript code with all of the static-types striped out. So no, you can't do anything like that in TypeScript as it exists today.
Ok yeah, that makes a ton of sense. I need to pass in the enum value in order to pass it as a value, because at Runtime I cannot convert from type -&gt; value since types don't even exist. Thanks for the concise explanation
That makes a lot of sense. Types help us at compile time and within the IDE but not at runtime, so we can't just rely on types to provide values. I know there are a lot of solutions and I am actually learning a lot from other people's code, but I am also just trying to write a bit so I can better understand exactly what I am wrapping when I use someone else's code :) Thanks for the advice.
Honestly this is a bit more convoluted than just passing the payload directly into the function. I was trying to get at if I could use the type of an enum member to get its value, which you cannot at runtime.
No, I was hoping I could use the enum type to get it's value, which clearly doesn't make sense while reflecting since at runtime types do not exist.
In making the two comparable, the second looks even worse to me. ¬Ø\\\_(„ÉÑ)\_/¬Ø
how to add typescript to Angular: Step 1: $ ng new myapp Step 2: there is no step 2
Different strokes for different folks. The React people like to assemble things themselves and that's ok.
It sounds like this is what you're asking: &gt; How do I infer one generic from function arguments and specify the other generic between angle brackets? I'm basing this on your last code example, where you don't want to repeat `T`: function createAction&lt;T, P&gt;(type: T) { The only way to do that is to split the generic binding over two function calls. One function call binds generics via inference, the other passes them explicitly. Something like this: function createAction&lt;P&gt;() { return function &lt;T&gt;(type: T) { return (payload: P) =&gt; ({ type, payload }); } } let selectTag = createAction&lt;string&gt;()(Types.SELECT_TAG); Did I understand the question correctly?
There's a tslint rule to disallow it. https://palantir.github.io/tslint/rules/no-parameter-properties/ Personally I don't think they're so bad, especially in personal projects. But for something larger, if my team was getting confused, I might enable that tslint rule.
Use tsc to build. Run with node. TS-Node will evaluate the typescript on every run, whereas transpiling it only requires typescript to be evaluated once. Also this is better practice when deploying or distributing your application. TS-Node does have its use-cases however. Specifically, I use TS-Node when running tests or coverage as it seems to play better with the NYC coverage utility and in development, would require a recompile anyways (since I'd be making changes to the code between runs).
If you're already using create-react-app why not go all the way and use create-react-app-typescript?
Cool, thanks for the info!
&gt; TS-Node will evaluate the typescript on every run, whereas transpiling it only requires typescript to be evaluated once. Not really true, ts-node caches the compilation result automatically. For distributing libraries, I agree you should compile it, but for everything else there isn't really any reason not to use ts-node (except for slightly higher startup time). I'm using 100% ts-node for a pretty large project, both for dev and in production. /u/GuinnessDraught It has the advantage of reducing your folder depth by one (no /bin, /src needed), not having any kind of cluttering / cleanup, not worrying about differences in ts vs js paths, or declaration files or whatever. Everything just works as if all your files were already .js, and new devs don't even need to know about the typescript compiler (if you use `require("ts-node/register")`). You really just have to get over it feeling a bit weird to be able to directly import both js and ts files.
That's an interesting approach! And yes you are right, I mainly did not want to repeat information so that's a decent solution. I could do createAction(type) for actions with no payload and then createAction&lt;string&gt;()(type) for an action with payload that is a string. 
I use this, it's a little bit advanced, for large scale apps, but it works great with TypeScript out of the box: https://nestjs.com/
Not adding Typescript to Angular is a much more painful proposition though.
Ooooh dear you've just opened this year's tabs-vs-spaces can of worms. *grabs popcorn*
For local development I use nodemon with ts-node. Before deploying I run tsc with an output directory and source maps. Then to run the app I run node in that output directory.
As someone who's never used TS on the backend, I'm curious does VS Code node debugging work transparently with TS?
There is create react app typescript which does all that for you for react.
I'm curious what is it you are looking for help with from contributors?
Identify these first. Routes, models /entities, views, business logic. Work from these. 
I just started with node in TS, Build a couple of APIs with express and VS code seems to hold good.... until now.
You‚Äôre talking debugging with breakpoints and stepping through TS code, right?
So this is like protobuf, but it isn't protobuf.
Thank you. 
Something similar by me, though specifically for socket.io: https://github.com/phiresky/typed-socket.io Can be used to 1. Fully type socket.io communication (without any runtime changes, example in readme) 2. Automatic runtime type checks for any amount of different client messages / remote calls with a single server/client schema definition ([example](https://github.com/phiresky/typed-socket.io/blob/master/example/chat-with-runtime-checks/common.ts#L12-L32)) 
It's too bad typescript isn't a first class language for protobuf. Actually it's too bad typescript isn't the type definition language :P Protobuf has some really weird stuff due to it's very obvious C++ origin. Like the names of enums have to be unique (combined with the fact that there's no nullable types and you have to specify a 0 value it gets very annoying).
Protobuf loses all type information. My library retains it completely from end to end, plus it has automatic shape verification thanks to [io-ts](https://github.com/gcanti/io-ts).
Cool! How does your library handle shape verification of payloads? Mine piggy backs off of [io-ts](https://github.com/gcanti/io-ts) and checks it with `decode`.
Eh, nothing particular to be honest. Just putting it out there in case someone is really passionate about HTML5 and/or Pixi.js and making browser based games. My time is somewhat limited but so far the response to the lib has been positive so I don't want it to suffer for my lack of time. If I had to be more specific a2p could benefit from: - discussion on and possibly updating of overall architecture - General improvements (compatibility, screen size, etc.) - bug hunting and resolution that last one is more for the future as right now the lib needs more update and improvements than bug squashing. But yeah, like I said just putting it out there. 
Same. You declare the shape as [seen here](https://github.com/phiresky/typed-socket.io/blob/master/example/chat-with-runtime-checks/common.ts#L21-L29) , verification also implemented with decode as seen [here](https://github.com/phiresky/typed-socket.io/blob/master/TypedServer.ts#L339-L356)
My tip is to use vs-code for your editor - it‚Äôs typescript support is unbeatable 
1. Make a single class, with those global variables as its static fields. 2. Every global function now becomes a static function on that class. 3. Add typings to the functions. 4. Determine whether any static variables/functions should become static/instance variables. 5. Refactor the class out into separate classes in separate files, if you're feeling brave.
Document classes, methods and etc with jsdoc. The typescript compiler (in vscode or visual studio) can pick up types from jsdoc and make it easier to convert to typescript later. If you need to add properties to `window` then you can use `(window as any).fooBar`. But doing it like [this](https://stackoverflow.com/questions/12709074/how-do-you-explicitly-set-a-new-property-on-window-in-typescript) is safer. Look for classes that can be split into separate files. Then you can convert those into typescript. If the ts files refer to something in the js files, declare them in a \*.d.ts file. If your javascript don't use modules then don't use it in typescript either, until you are ready to convert the entire thing to modules. Typescript files become modules if they either contain a `import` statement or a top-level `export` statement. You can use `export` statement inside namespaces.
Yes, as long as you have source code map generation turned on.
Null is regarded as one of the greatest mistakes. Lack of nullability is an advantage.
I personally would find it easier to rebuild this from scratch, using the old source file as reference for any non-obvious business logic. Once you have it working within a sane boilerplate, improve said business logic. YMMV.
I personally would find it easier to rebuild this from scratch, using the old source file as reference for any non-obvious business logic. Once you have it working within a sane boilerplate, improve said business logic. YMMV.
At 1300 lines this might be easier to re-write. I know the common convention is that starting from scratch risks missing a lot of hidden behaviour in a rat's nest of code but really you don't have a ton of code there so it's possible to build a mental model to capture it all. That thought considered, I would recommend refactoring the JS first and then transitioning to TS. I think doing one thing at a time is better. By all means set up TS such that your file(s) are `.ts` instead of `.js` and your build process includes `tsc` but I wouldn't enforce any sort of strict type checking off the bat. Then you'll be fighting the compiler and the architecture at the same time. I'd move code around into more logical chucks to eliminate some of the problems you identified like global state and gross DOM manipulation side-effects. After you have more sensible separation of concerns start adding typings on top to improve long term maintainability.
Being able to specify "no value" is not bad. Haskell and OCaml have Maybe and it's the same concept as nullability. The problem is in the languages that have sloppy ways of handling this, like not warning you at compile time that a value may be null, and allowing you to act on it anyway thinking it's non-null. That was a bad idea. But null is not!
Looks cool! Maybe you could re-implement your library using mine and save yourself a tiny bit of code ;)
No choice of whether to have null or not is a bad thing. Null is a good thing, because what the difference between a $0 account and a N/A account balance
One of my gripes with the node ecosystem as a whole it a plethora of low-value packages that seem to be widely used to abstract away what really amounts to 5 seconds of work. I'm surprised people don't use `npm install arithmetic` so they can access `add(2, 2)` and such. Sorry, minor rant. My point is that while I have nothing against the effort and work that went into `ts-node` I don't see the problem with building a npm script for "build" which runs `tsc` and then "run" which runs `node` and then stitching them together when needed. For a few seconds of work having one less dependency seems like a good trade off to me.
No. You described two different states of your domain, the type would be something like: `Value(number value) | NoValue`, and you can extract the number value from the type. The problem is that null is never used for just one thing, it's always used for denoting *null references*, and you're mixing that into your domain and making an ambiguity.
It's not the same concept. Nullability comes with null references, Maybe doesn't.
The problem is that null references are required for a transport protocol that has backwards compatibility. Some fields will not be set because an older client won't know about them. In this case there's no way to know the difference between a client that isn't aware of a boolean flag and a client who wants that set to false. They look the same. Modelling it as something besides null effectively accomplishes the same thing. And yeah it might be slightly better, but protocol buffers doesn't allow you to model it a better way. It just sets booleans to false when they aren't set. 
No, different version is different type. You can match against its binary structure with Rust.
Maybe and Null are two ways of handling the same problem. Fundamentally they are the same thing, the difference is merely in the way people have traditionally handled them. The big million dollar mistake is forcing every type to be nullable and also making member access a shortcut for `x is y ? x.y : throw new Exception`. But all of that is **completely beside the point**. Whether you use alternative types, null or Maybe is much better than what google protocol buffers currently does, which is nothing. It supports none of those options and instead just defaults to `false`, `""`, `0`. What I'm arguing is that the system would be *much* better if a decent type system was used, like typescript's awesome system. Then you could do what you've described, and even a lot more as well.
Oh yeah for sure. Having every type implicitly be nullable is dumb.
I have always used `tsc --watch` in the background, and `node` to run the result. I feel this is cleaner, and also I don't really know what `ts-node` is doing for me so it's too much magic for me. But that's a secondary reason.
I agree, and I ended up doing this and ditching ts-node since I'm unclear on the value, if any, it provides.
Ya, this is basically what I set up. I defined a dev mode in \`package.json\` that works great: \`\`\` "scripts": { "dev": "concurrently \\"tsc -w\\" \\"nodemon dist/server.js\\"" }, \`\`\`
Hahaha fuck me this made me laugh more than it should have. Took me way too long to get this shit sorted out, especially when you throw on prettier! Oh boy.....
Is there a single file or some way to check all the routes that are generated like this? I feel like it's a great system, but I dislike the decorators. Of course I'm just a single redditor, I liked being able to easily find all the routes of an application and the `sendsResponse` decorator seems a little much. Why not just pass the typed express request, response and next? I also want to say that this is great work and I appreciate this. I will be digging deeper.
Yes. It will inline the downlevel conversion. Also, if you have lots of modules you should check out [https://github.com/Microsoft/tslib](https://github.com/Microsoft/tslib) as well, which is basically a centralized version of the things Typescript needs.
But it's not just an es6 -&gt; es5 conversion. The method is simply not supported by IE. 
I've not done extensive testing on how Typescript downleveling works in all cases. I imagine just testing it in IE would be a start. Also, a good resource is polyfills.io
It will not polyfill Array methods and stuff like that. You'll need to load a polyfill like corejs.
No, it won't polyfill Array.find. tslib contains helpers for the downleveled forms of native language constructs, like async functions and object spread.
Thanks for your time, sure we are working on generation of routes to use swagger with dinoloop. Pretty soon we will be adding this as feature request :).
I appreciate your help and time, if you look into deeper and let us know your thoughts, pullrequests and contributors are always welcome.
 I appreciate your help and time, if you look into deeper and let us know your thoughts, pullrequests and contributors are always welcome. 
sendsResponse decorator seems a little much. dinoloop watches results of your action method. So if we send response using response object then dinoloop goes into instable state, @SendsResponse informs dinoloop do not watch on these action method, it hanldes its own response. more here [https://github.com/ParallelTask/dinoloop/blob/master/wiki/attributes.md#sendsresponse](https://github.com/ParallelTask/dinoloop/blob/master/wiki/attributes.md#sendsresponse) Why not just pass the typed express request, response and next? We already have request, response and ,next as properties for ApiController. please refer [https://github.com/ParallelTask/dinoloop/blob/master/wiki/controllers.md](https://github.com/ParallelTask/dinoloop/blob/master/wiki/controllers.md) Let me know your thoughts
If you skim through express‚Äô types, youll come across a couple of empty interfaces. Those are left there on purpose for augmentation. So youd write something like declare global &gt; namespace Express &gt; interface Request and that would get merged into the existing one.
Makes sense. I'm a little behind the time when it comes to namespaces, so how would that actually work as real code? 
(I was typing from my phone before) It's called declaration merging, if there are 2 interfaces with the same name, they are merged following some rules. In the express example, these types are declared on a "global" scope (they call it "ambient"). (I actually don't know if you can extend a non-ambient interface, probably yes). In order to declare a type on global scope, either you write it in a file which is not a module (a file without top level imports/exports), either you wirte it inside a module + wrap it with `declare global {}`. If you begin CMD+clicking the `Request` type you first get here: export interface Request extends http.IncomingMessage, Express.Request { Then `Express.Request` takes you to declare global { namespace Express { // These open interfaces may be extended in an application-specific manner via declaration merging. // See for example method-override.d.ts (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/method-override/index.d.ts) interface Request { } now what you should it is to add something like this to your code declare global { namespace Express { interface Request { myMethod: () =&gt; void } } } now typing `req.myMethod` shall bring the proper code completion.
Looks great, I'm stealing that.
Hey! I created this little library because I was getting annoyed by non strongly typed nature of normal EventEmitter. Let me know what you think.
This is really cool, thanks!
As a dev who comes from a C++/Java/C# background and am using JavaScript heavily now, what exactly is `javascript'y style`? I understand that `new` and classes seem to be a clunky, bastardized wrapper intended for OOP devs that don't really get prototypal inheritance, but it seems to me that the underlying concept of Functions as factories (constructors) for creating uniform objects is reasonable. You can even have a constructor return different types of constructors based on parameters and essentially behave like a Factory, so why not use `new` and constructor functions? So far I've really been enjoying the functional parts of the language and the ease of use of object literals, but I would really love if someone from Group 1 could explain to me how to properly write JavaScript as JavaScript and not Java/C#/C++ in V8 clothing. 
&gt;But there isn‚Äôt really any situation where you shouldn‚Äôt use types. Really? How about when writing scripts? Or taking care of relatively simple tasks? Types are dandy but they add verbosity to code you're writing. If you know what you're doing already and are not working on something that needs to scale across multiple modules then going ~~topless~~ typeless is a lot more productive and just plain fun.
All the events and their argument types are declared in an interface? I guess that works really well with subclassing, too. Nifty!
I just added [advanced example](https://github.com/elderapo/typed-event-emitter#advanced-usage) showcasing inheritance.
I quite overstated that. JS as always been an umbrella for a phetora of coding styles, its design was made to attract java developers and even its name having java was an intentional marketing decision. Lots of class patterns are reproductible without the use of classes, but you usually end up doing the same thing in a different way, so its absolutely not wrong going one way or the other way, mostly a matter of style. Ex: A class can be mostly represented the same way by a function which returns an object, the variables you declare there becoming the members. An overrideable method can be represented as an optional parameter in an option bag. I personally consider using classes for heavy usage of intereptor pattern and performance (ex: an object which is instantiated 60 frames per second). I prefer "function-classes" for more flexibility (ex: you can nest scopes, you can "curry" the arguments, you dont have to type `this`) and less worrying about the `this` binding. There's also things like `let x = { __proto__: y }` that I know are really powerful and I hardly use... I mean, you can do the same thing in so many ways...
This worked for me for your intent, after some headhammering const useStringAsKey = &lt;In extends {}, K extends string&gt;( previous: In, key: K, ) =&gt; { return Object.assign(previous, {[key]: 'someValue'}) as In &amp; Record&lt;K, string&gt; } const test = useStringAsKey({ a: 2}, "test" as 'test')
Headhammering : - Removed the "Out" on personal preference (i prefer to think about returns later, also, returns usually dont come is as a type parameter, they are built from existing ones); - { ...previous } yelled me "cannot spread over non object" wut? So I changed it into object.assign - 'test' is downcasted to string, so I wrote 'test' as 'test' (force a literal) - Object assign downcasted K to string, so i recasted it to In &amp; { ... } - In &amp; { [k:K]: string } brought errors so i remembered guys using `Record` for this things, and it worked in the end. SAD
why is it necessary to do `"test" as 'test'`?
Yeah. Not easy to do this, unfortunately :\
I use console.time() and console.timeEnd() to read the time elapsed between 2 points. Check out https://developer.mozilla.org/en-US/docs/Web/API/console
Having had a chance to do anything with It, just glancing at the code. Two things stick out: 1. It's very thoroughly documented so that's excellent. I might argue that some of the documentation is too superfluous but as long as you keep the documentation up to date that's not a huge deal. 2. Namespaces have mostly fallen out of favor since es6 added a module system. Consider just using export or export default instead of using a namespace. It doesn't really add anything to the code.
Thanks, but that doesn‚Äôt support what I needed, which is the ability to easily record a list of multiple ‚Äúlaps‚Äù/‚Äúslices‚Äù of time across multiple points in code or multiple executions of a method. I also have the ability to ‚Äúpause‚Äù my timer to ignore periods of time. How reliably ‚Äústandard‚Äù are console.time/timeEnd? Looks like a de facto standard implemented by most browsers, rather than an official standard. Is it implemented in NodeJS?
1. Anything in particular that you think is redundant? I‚Äôm guessing it‚Äôs the class-level docs. In my attempt to provide a general overview of how to use the class, I ended up duplicating info that‚Äôs documented on some individual methods, but it seemed better than hoping the reader looks at all the individual methods to quickly piece together how they work together at a high level. 2. Probably a personal preference thing. I like putting things related to a class in a namespace that merges with that class. It gives you access to everything for that class with only one import. I also avoid generally default exports in TypeScript: https://basarat.gitbooks.io/typescript/docs/tips/defaultIsBad.html
If I just type code in a console to tty some expression interactively, I don‚Äôt use types. If it‚Äôs worth saving to disk, I use types. Imho, even simple stuff becomes easier and more fun to write with types. 
I like types and understand their value but I disagree in having them in every single conceivable scenario. I think a good middle ground is making them optional in the language itself. Static inference in C# is also pretty comfy for a statically typed language too, I'd like to see more of that around. I tried scripting in C# with `scriptcs` but it was just too verbose for such a thing to make it enjoyable.
&gt;Ex: A class can be mostly represented the same way by a function which returns an object, the variables you declare there becoming the members. An overrideable method can be represented as an optional parameter in an option bag (or you could even monkey-patch the return, or create a higher order function). I tried this out on my projects but one big letdown was that the IDE tooling just wasn't there to support this style vs. when using classes. This becomes more relevant if you're used to fancy stuff like Intellisense in VSCode and such but IMO it's a very nice little feature to have.
Got curious and found this issue https://github.com/Microsoft/TypeScript/issues/13422. Seems like if you aren‚Äôt working with node modules, then using the .js extension for your imports is your best bet, otherwise you‚Äôll probably need to use a bundler or some other post build step. 
Looks nice! Do you consider to support high-resolution timestamps by [`performance.now`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)? There is ["myrne/performance-now"](https://github.com/myrne/performance-now) github project where you can take a look how they use `performance.now` and fallback to node's `process.uptime` and `Date.now()`.
Thanks. I support any time reporting function that you want to use. It can be anything, as long as it is a function that returns a number, and each subsequent call returns a value &gt;= the previous call. It doesn't even need to be a "real-time" time function that directly correlates to passage of time in the real world. It could be a frame count, game loop count, "number of times the user clicked a button" count, etc. You can customize this per-instance via the optional constructor parameter, or set a custom "global" default via `Stopwatch.setDefaultSystemTimer()`, which will be used by default for all future instantiations of `Stopwatch`. Rather than duplicate the efforts of the `performance-now` project, or create a dependency on it within `ts-stopwatch`, I would recommend that you pair them together yourself if that's what you want: // in some common/bootstrap .ts file that's guaranteed // to be included before you use Stopwatch... import { Stopwatch } from "ts-stopwatch"; const performanceNow = require("performance-now"); Stopwatch.setDefaultSystemTimeGetter(performanceNow); NOTE: I couldn't figure out how to import from "performance-now" using import. TSC complains about it not being a module. Even though "performance-now" has a .d.ts file in their src folder, I'm guessing something isn't setup properly to allow TSC to find it without additional configuration.
You can't argue these points but that says nothing bad about typescript imho. 
Well for 1: For instance you have long descriptive comments on the functionality of each private member; like describing that they will be undefined if the timer hasn't started yet. Describing in minute detail the inner workings of private variables is just asking for the comments to get out of sync with the logic since no one will notice if they are wrong. So I would state that a private member is undefined if it hasn't been set. That should be self evident from the code *and* may change in the future. Just labeling start time is more than enough imo. In fact I'd even argue that the name start time is already sufficient to tell another developer what it does and you might not need to comment a simple well named private variable at all. Comments should in general explain why something is done the way it is and be used to describe the public interface. The how, like that start time will be undefined if not set, is what the code already tells me just by looking at it. For 2 namespaces are just not used much anymore ime. They feel like a holdover from pre module js and are basically filling the same role. If you really want to use them go ahead but I don't see them used much anymore outside of type definitions for non modular js.
Awilix is great
He never wanted to say anything bad
Could we add "typedefs authoring and maintenance" to that list?
I know. My stupid typo. Meant, you CAN argue these points but I think these issues are not really bad points so much in Typescript, more the complexity and fragmentation of the eco system. I just wrote that very poorly. üòÇ
A good rule of thumb: tsc makes up for missing syntax (eg. async/await, class), but won't provide missing APIs (eg. Promise, Array.prototype.find, ...)
The problem when you enable strict type checking from the very beginning is that you may end up with too much work to do all at once. Plus, the existing code most likely has bugs which will be revealed by strict type checking. You don't want to end up having to refactor the code *and* fix the bugs at the same time.
Using a decorator, e.g. https://github.com/bet365/override-linting-rule, seems like a better approach than jsdoc comments.
Yes they should be -- typedefs are full of inconsistencies.
That's definitely true? I looked at the react typings recently, and they have all kinds of insane generic types to make them backward-compatible.
I really think the error-messages are a real pain point with typescript only - but I agree that a lot of it is the ecosystem.
Daniel on the Typescript team is looking to fix this issue. 
Rosenwasser? Yeah I noticed, he's been popping up in some of the conversations I've had on twitter about error messages. He's a great guy - I'm hoping he does something amazing with it.
Yeah he is very dedicated. Id like to see Eml style errors in the future. 
I don't know what those look like - can you give me an example/link?
Just that decorators require you to enable experimental decorators support.
http://elm-lang.org/blog/compiler-errors-for-humans
That was excellent. Thanks for sharing.
They‚Äôre so well established at this point it is unlikely that the API for them will not be promoted in its current form.
Both approaches seem equally valuable to me. Although decorators are widely used, the jsdoc tag has the advantage of being non intrusive and exploiting a notation that has been around before TypeScript even existed. The biggest inconvenient of the annotation is that you need it to exist at runtime (Do you \`import\` it, make it available to \`window\`, ... ?) Support for the decorator syntax is planned but I first want to nail the behavior of the rule in complex edge cases. Anyway \*the\* proper way would be an actual language construct, but this has been ruled out of the roadmap for now. This module was made just so that people could experiment with and discuss the \`override\` feature in general, in hope that it will eventually make it to the core language.
You don't need to import it, just set the default to `performance.now.bind(performance) | date.now.bind(date)` instead of `date.now`. This will use `performance.now()` when available, and fall back to `date.now()` if it's not available. It would be a straight improvement, as performance.now is the same thing, but more accurate (due to floting-point arithmetics)
Very cool. Will need to try this. We used to do something similar in our angular.js app but couldn‚Äôt get the typing to work when we converted to Angular / TypeScript and had to just create separate mocks of each service.
and so it begins
The "unpacked" example is a little overkill for you, I think. It gets the return value of functions and promises as well. There's a couple ways to do what you need. The most straightforward way takes advantage of the fact that arrays are basically `type Array&lt;T&gt; = { [i: number]: T }`. // T must be some kind of array. This returns the type of T when indexed by a number. type ElementType&lt;T extends ArrayLike&lt;any&gt;&gt; = T[number]; A second option is using conditional types. Conditional types are mostly useful for inferring types or situations where you want to end up with different types based on what you pass in. This is more complex then the next solution. type ElementType&lt;T&gt; = // is type T an array of elements of type U? If so, return U. Otherwise, return the "never" type (the input is not an array). T extends (infer U)[] ? U : never The "Unpacked" type uses conditional types because it accepts many inputs and does a similar type-level operation to all of them. It uses the "infer" syntax just to show off the conditional type mechanism.
Simplified: type ElementType&lt;T&gt; = T extends any[] ? T[number] : never;
If the return type for non-arrays is never anyway, what utility does this provide that the type argument constraint does not? With the generic constraint way, you get an error where you use the type operator instead of where you access the result type. Simplest: type ElementType&lt;T extends any[]&gt; = T[number]; Because it is **not** a conditional. It is a type operator on arrays. type Foo = { id: number }; // with conditional types let single: ElementType&lt;Foo&gt; = ...; // ... if (single.id === 100) { // error here: id does not exist on type "never" console.log(single); } // with type constraint let single: ElementType&lt;Foo&gt; = ...; // error here: Foo is not assignable to type any[] // ... if (single.id === 100) { console.log(single); } 
thanks, \`type ElementType&lt;T&gt;\` is what I'm looking for Basically I have a data object like ``` interface IData { Key1: Array&lt;IData1&gt;; //... Key30: Array&lt;IData30&gt; } ``` keys resolve to arrays with random data structures. then there are 2 functions like ``` //returns the corresponding array getValues(key, data) { return data[key]; } //returns the first entry from that array getFirstFromArray(key, data) { return getValues(key, data)[0]; } ``` what I want to achieve is to auto infer the types for getFirstFromArray like ``` let data: IData; let data1 = getFirstFromArray("Key1", data); //auto infer as IData1 let data30 = getFirstFromArray("Key30", data); //auto infer as IData1 ``` Which works with conditional types, but I think it should also be possible without them, but then it complains that there is no index type if I try to do it like this ``` interface IData1 { } interface IData30 { } interface IData { Key1: Array&lt;IData1&gt;; //... Key30: Array&lt;IData30&gt;; } //Type 'number' cannot be used to index type 'T[K]'. function getFirst&lt;T, K extends keyof T&gt;(key: K, data: T): T[K][number] { return data[key][0]; } let data: IData; let data1 = getFirst("Key1", data); let data30 = getFirst("Key30", data); ``` hmm, anyway, conditional types do the job
 type UnwrapArray&lt;T&gt; = T extends Array&lt;infer R&gt; ? R : never (99% when I use conditional types is for the infer things, and I just put a never there)
The node module resolution algorithm basically crawls upwards until it finds a directory with a `node_modules` folder containing the package it's looking for. I'm not sure how faithfully the TS compiler follows that resolution algorithm, but if there's no `@types/graphql` in your repo's own `node_modules`, it's possible it might be looking at a directory *above* your repo. The `../../../../../../` seems to indicate that might be the case. If you haven't already, try `cd ../../../../../../` to see what's going on in that dir. I would also try copying the repo to a different directory that has no directories containing `node_modules` anywhere above it in the hierarchy. 
Oh yeah thanks, I looked there before but I totally glossed over an errant node\_modules hiding in my home dir. What a pain. Thanks. If you have a SO account, put an answer up there and Ill give you credit
This is already built in to jasmine's type defs * `myObj: jasmine.SpyObj&lt;Http&gt; = {...}` * `spyOn&lt;MyType&gt;(blah, 'something')` * `jasmine.createSpy&lt;MyType&gt;('blah')` * `jasmine.createSpyObj&lt;MyType('name', ['some', 'methods'])` * etc... [Jasmine TypeDefs](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jasmine/index.d.ts)
Make sure you're committing either `package-lock.json` or `yarn.lock` to your repo. It's possible they're actually installing different versions of @types or other packages than you -- either at the top level in node_modules or a subdependency.
You're right, this approach is even better.
To properly format code on Reddit: - Indent every line with 4 spaces. - Have an empty line between text and the code.
I think the point is that the types provided allow for getting the return type of \`jasmine.createSpy&lt;MyType&gt;(...)\` without actually doing the creation of a spy at that point. This way shared variables in test can be given the correct type and the mocking can be deferred 
The first example I gave is just a type that does exactly that. It's just a type that you can use in a variable or function def
Remember to use `npm` instead of `yarn`. They behave differently. ``` rm -rf node_modules npm install ``` See: https://github.com/yarnpkg/yarn/issues/3951, https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18793#issuecomment-339671513
downvote wtf? Whats wrong here?
Or to just use the same between machines. (they do have differences on how they build the node\_modules folder)
This is the first release of a FP library I wrote. I really tried to create something that takes advantage of powerful functional programming constructs but doesn't feel overwhelming to beginners and people with no FP experience.
How does this library compare to Sanctuary?
Sanctuary is a JavaScript-first library. Because of that, it cannot be correctly typed which means that (at least in my experience) it's unusable in TS. I have found that trying to implement higher-kinded types in TypeScript is a lost cause for now. Instead I went with the regular object instance methods and implementing interfaces, which you may argue is more "OOP" and less in the spirit of FP but I think the trade-off is well worth it - the compiler errors are better, the code is more idiomatic, IDE autocomplete is better, developers are more familiar with it etc. I also put a big focus on making the library more accessible by putting a lot of effort in the documentation, which I think most FP libraries are lacking. The UX of the sanctuary docs is less than optimal. As far as features go, sanctuary is more complete for now, but there is more stuff coming to pure, stay tuned :)
Just to be sure: You tried adding the esnext-lib for AsyncIterator? "compilerOptions": { "lib": [ "esnext.asynciterable" ],
very nice, thanks
Yes that works but I shouldn't have to add that because it builds fine without it on some machines. The problem was an errant node_modules in my home dir
Thanks for the answer; I forgot Sanctuary isn't typed. &gt; I have found that trying to implement higher-kinded types in TypeScript is a lost cause for now. Actually, the way fp-ts does it is workable, just slightly verbose.
Yeah, I quite liked the docs, most fp libs around be quite like "hey you didnt program haskell? come back here later"
First glance makes it look like Ok and Err are structurally equivalent, which means that TS can not distinguish between them (TS has no nominal typing and considers any two objects with the same shape to be the same type even if they have different names). If you change their `kind`s to `public kind: ‚Äúok‚Äù` and `public kind: ‚Äúerr‚Äù` respectively I feel it should wok. 
Right("hello") -&gt; Right&lt;any, string&gt; implements -&gt; Either&lt;any, string&gt; . So: Right.value = string which is valid since the return is Either.value = string|number. Same for left. regardless of interface or type version, both are working. Your approach is wrong. Have a look at conditional types. 
Looks nice. One suggestion: I had to spend several clicks to find a code example to see what this project could bring me. It would be nice if you included one in all that empty space on your homepage :) Perhaps a common use case using Maybe might be a good idea, e.g. fetching an API response or something.
You don't need conditional types for this.
Yeah seems like a common complaint about the site. I'll make sure to include some example code in the landing page. Thanks!
I feel that's much what I tried to achieve with https://github.com/emmanueltouzery/prelude.ts/ -- too bad my library didn't convince you. But I hope pure works out well!
You can assign custom values for enums like this \`\`\` enum Gender { Male = 'male', Female = 'female', Other = 'other' } \`\`\` Does that help?
No, not really, because: 1. string enum members *do not* get a reverse mapping generated at all (from: [https://www.typescriptlang.org/docs/handbook/enums.html#enums-at-runtime](https://www.typescriptlang.org/docs/handbook/enums.html#enums-at-runtime)) which is a problem when being used in a DTO sent back and forth between client and server 2. The shown text needs to be localized 3. Doesn't resolve the problem that the coworker works around the type system In other words: I need a social approach to make my coworker to really understand the type system. There are so many things he doesn't understand like the difference between reference and value types and other things which seems totally crazy for a developer having several years of experience...
yeah but that shouldn't explain why Ok/Err works
You're right! that did work. I thought what I did with assigning it in the constructor was the same thing, but I suppose not. It's still weird to me how you can use actual values as types in TS, but I guess it makes sense
because it was already explained 
I like to think of it as the most rudimentary form of dependent typing :) Hopefully someday it can do more!
Something like this maybe? ``` abstract class EntityBase {} interface IRepository&lt;T: EntityBase&gt; {} class Repository&lt;T: EntityBase&gt; implements IRepository&lt;T&gt; {} ```
TypeScript has a [playground](http://www.typescriptlang.org/play/)! I share this with people who want try things out real quick in TypeScript. It's a great way to view the output as pure JavaScript. On `enum` in TypeScript... I avoid them and prefer to use string unions because the way they transpile is a little easier to read.
Did you try your code? :-/
After posting.
The playground is indeed very useful. Now I just have to get my coworker to respect types instead of stripping type information to make the code compile ;)
This doesn't work as intended, unfortunately. Example: abstract class Entity { protected readonly _data : any; protected constructor(data : any) { this._data = data; } } interface IRepository&lt;T extends Entity&gt; { GetById(id : number) : T; } class Repository&lt;T extends Entity&gt; implements IRepository&lt;T&gt; { public constructor() { } public GetById() : T { // Quick mock test return new UserEntity({ id : 1, firstname : "Tore", lastname : "Aursand" }); } } class UserEntity extends Entity { public constructor(data : any) { super(data); } public get Id() : number { return this._data.id; } } The problem is at the "quick mock test"; "Type 'UserEntity' is not assignable to type 'T'."
That's because `GetById()` will always return a `UserEntity` which may or may not be assignable to `T`.
Your method says that it should return `T`, but you are tried to return `UserEntity`. `UserEntity` might be `T`, because you could `new Repository&lt;Car&gt;()`
``` abstract class Entity { // tslint:disable-next-line:variable-name protected readonly _data: any; protected constructor(data: any) { this._data = data; } } interface IRepository&lt;T extends Entity&gt; { GetById(id: number): T; } // tslint:disable-next-line:max-classes-per-file abstract class Repository&lt;T extends Entity&gt; implements IRepository&lt;T&gt; { public abstract GetById(): T; } // tslint:disable-next-line:max-classes-per-file class UserRepository extends Repository&lt;UserEntity&gt; { public GetById() { return new UserEntity({ firstname: 'Tore', id: 1, lastname: 'Aursand' }); } } // tslint:disable-next-line:max-classes-per-file class UserEntity extends Entity { public constructor(data: any) { super(data); } public get Id(): number { return this._data.id; } } ```
Do you remember the [Gmail beer goggles](https://www.wired.com/2008/10/googles-mail-go/)? Imagine an IDE that would give you small kata or problem to solve every few hours, becoming more frequent when it got late. If you started taking to long it could force you to take a break.
Yeah it does feel a lot like dependent typing, pretty cool for a js extension
Does this coworker use an editor with type hints, lke vscode? If you can demonstrate how immensly useful that is compared to everything being `any`, perhaps it will help?
Yes, he uses VS Code with some addons (including one for TSLint support) - and he still puts an instance of `T[]` into a variable of type `T`. I guess that part of the problem in this case is, that VS Code tries to be useful by providing code completion even though the code is just plain wrong.
Is their code more buggy than other people's? Types help on larger projects with multiple people so may be some hard stats about their flaky code would help them focus.
hi, how does it compare to fp-ts ?
If he has a Javascript background, then I think the main think you should tell him is: write your code as if it's Javascript. Because it is. I find that considering TypeScript a tool to help communicate otherwise implicit assumptions to your coworkers really helps writing it "properly". The above code is something he'd probably never write in Javascript, so he shouldn't usually write it in TypeScript either. (That said, I don't usually use enums either, so maybe that would be a tip you can give as well. Then again, that's probably because I'd use a union type over a string, which is basically how I'd write it in Javascript as well.
Given enough time in the industry, I think we all inevitably run into someone we feel "just doesn't get it". Whatever "it" may be. And, sometimes/someday, it may even be us. With that in mind, I think there are some things you can do and keep in mind when trying to help others understand something new to them. First, I'd like to preface this by saying I hover somewhere slightly above a "duct tape developer". I'm no "rockstar" by any means, so take this as you will. * Consider misunderstandings as a teaching opportunity It may be frustrating, annoying or disheartening to feel like a team member is simply incapable of even pulling their weight. You have two options, try to help or try to get rid of them. Since firing someone isn't usually an option; As someone who understands the problem, if falls on you to try to teach, which you are. So, good work! * Show how you expect it to be done Again, I think you've got this covered, based on your post. * Different people learn differently I've known a number of developers that can pick up a 1k page book, read it over a day or two, and come in the next day and implement something none of the rest of the team knew we needed. I, personally, am almost completely incapable of learning via a favorite exclamation by many developers: RTFM (Read The F#$king Manual). The words between blocks of example code are generally noise, at least until after I've banged it out myself and really savored the concept in practice. I'm not proud of this fact, but it's how I function. * Some "fundamentals" can be easy to gloss over, especially if you didn't RTFM "By Reference" vs. "By Value" is easy to gloss over, imo, as are a number of other fundamental features of any language. You can easily write something that works just fine without realizing you are passing around a reference. It may not until they experience a mind-bending bug that they realize or can even appreciate what they've done. * Different people have different values You see this as bad code, because it is bad code. They may see this as "good enough" because "it works". You may value some code because, "it's less error prone", "it's extensible", "it follows DRY", "it's small", "it's encapsulated", etc. To them, possibly, "getting it to work" is enough to get them to the weekend and on to their next paycheck. When it breaks or needs updating because it doesn't do "the thing" correctly anymore, they'll figure out how to get it to "just work" again. Attempt to determine their values and it will go a long way to helping you understand how to work with them and what expectations you can have for them. * Keep at it, continue code reviews, set expectations Unfortunately, giving up on them isn't an option, unless you can remove/replace them or minimize their damage by distancing them from work that really matters. Their code and understanding may not get better without intervention. I would recommend requiring, not asking, them (and potentially the team) to get take a Pluralsight course (or the like), reading a book, or what have you. Allow it to be done during work hours if at all possible. Either a set number of hours or, heaven forbid, all day. I know a lot of people frown on this for numerous reasons, but if a person has issues valuing the work they do more than "it works", they're going to be resistant to doing the training on their own time. Also consider that the alternative is to not provide training time and there is a, likely higher, cost to an underperforming team member in the long run. If allowing during work hours, stagger scheduling among team members (with this person being the first) so not everyone is doing it at the same time and actual work can get done. Make sure you set a timeframe. I would suggest no more than a week or two; Shorter depending on their ability to do it during work hours. Hopefully this was the tiniest bit valuable. There's no panacea, but I think understanding the person goes a long way. And unfortunately, I believe, there are people who really aren't cut out for certain work, development or otherwise. That valuation is, of course, up to you.
and also, please how does the size compare?
fp-ts and pure have different design goals. fp-ts has higher-kinded type encodings and that is it's main feature. I admire Giulio's work but I don't find his library ready for widespread use. I think that fp-ts is intended for people already familiar with the material who just want a tool to express their ideas in TS. On your question about size, I don't think that it's useful to compare them. fp-ts is bigger in size but it's bigger in features too. For the first release of pure I've been thinking mainly about features and documentation, if you have any recommendations about performance and size optimizations let me know!
I don't think the problem is types as much as it is enums. He's trying to use enums in a way that Typescript really isn't meant for. Perhaps a literal type would be better `type Gender = 'male' | 'female' | 'other'`
Announcing TypeScript 1.8: [https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md)
project references at last!
Support for React‚Äôs defaultProps is pretty great, hoping it will also infer `props` types for lifecycle methods.
Have they fixed the state issue yet? The one where an empty array somehow defaults to `never[]` unless you either assert it directly or via the whole object.
So I actually could put some ts files in a different solution (using VS/ASP in my main project) folder? That could be handy. 
I thought I had a pretty good understanding of what is coming in TS v3. I don't see what TS v3 is buying here that v2 wouldn't.
This project reference thing seems like a bit of a nightmare waiting to happen. I can foresee chasing nested `tsconfig.json` files trying to find out where the heck a certain value is set or why a value I thought I set is being overridden. Am I missing something?
Can you explain what you mean by chasing down overridden values? Others might have the same concern, but I'm not sure what the situation you have in mind is.
I might have understood it wrong but it sounded to me like part of this `composite` feature in the `tsconfig.json` means that there is a config inheritance i.e. values from one config are inherited from another. For example, I could have `strictNullChecks` set in one tsconfig.json and be applied in another project which refers to it.
No, `composite` just ensures that a `tsconfig.json` can be listed as a dependency. `tsconfig.json` already supports a field called `extends` which does what you're talking about, and in practice we haven't seen deep inheritance structures. You usually end up with a single base `tsconfig.json` you extend from so that you can reuse the same settings across projects.
Gotcha, thanks for the info. I just had sudden flashbacks of XML configs in Spring. Good to know this isn't a similar situation.
V8 actually already has a full type system, after all most performance optimizations need to know at least some type information. I don't see why this project couldn't simply add a step to the parser step that pregenerated the type information and passed it into the interpreter directly instead of having the interpreter dynamically infer it at runtime. &gt;&gt;&gt; Accessing types and properties effectively makes a first big challenge for V8. Instead of using a dictionary-like data structure for storing object properties and doing a dynamic lookup to resolve the property location (like most JavaScript engines do), V8 creates hidden classes, at runtime, in order to have an internal representation of the type system and to improve the property access time.
I'm so excited to see the progress on the type system features! It seems like the team might actually consider implementing higher-kindred types after the next few releases, which would get allow to get rid of lots of developer nightmares, like typing `_.mapValues` manually. And the new tuples and named/partial template inference scheduled for 3.1 is super cool.
I understand the confusion here. I'll do my best to explain. Let's say I want to mock the type T, so I create a function `function mock&lt;T&gt;(): T`. If I then passed the object `{ doFooWithOneArgument: (input: string) =&gt; boolean, doFooWithTwoArguments: (input1: string, input2: boolean) =&gt; string }` to it, I would get a strong-typed variant of it in return. That's all good, but what if I wanted to map that type into `{ doFooWithOneArgument: (whateverTheOneParameterTypeWas) =&gt; boolean, doWithTwoArguments: (whateverTheTwoParameterTypesWas) =&gt; string } &amp; { returns: (...returnValuesInSequence: whateverTheReturnTypeOfDoFooWas[]) =&gt; void }`, I wouldn't be able to do it, since there would be no way of expressing `whateverTheOneParameterTypeWas` and `whateverTheTwoParameterTypesWas` in a mapped type, and they would have to be defined as `...args: any[]`. However, now there's "Generic rest parameters" that can express this, as seen in [the example in the announcement post](https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#generic-rest-parameters). See [this example TypeScript file](https://github.com/ffMathy/FluffySpoon.JavaScript.Testing/blob/master/src/Transformations.ts) for an example of how the type is defined. For each property of the original type given, I then handle it differently whether or not it's a function or a property by using the `infer` keyword. If it's a function, I then infer the arguments and its return type and re-express them in a strong-typed manner, but retaining the type safety of the arguments given. This was not possible before.
https://blogs.msdn.microsoft.com/typescript/2018/07/12/announcing-typescript-3-0-rc/#tuples-and-parameters This makes me veeery happy to see!
Is it just me or is the type system getting more and more complex in each release?
Yes, usually type systems grow more complex monotonically. :)
At first glance this looks great. I have been looking for a better mocking library.
Cool! Glad you like it. I'll update the documentation heavily soon. 
Maybe complex wasn't the best word here, I meant that it's getting quite hard to keep up with the language since they release quite fast (not that it's a bad thing) 
I'm yanking your chain a bit. I definitely understand the concern, and I want to find ways to keep the language approachable. It's especially tough when new users come along and read the blog posts. If the cadence is part of the problem, we have recently considered a different release cycle where the language releases maybe every 3 months, but we release patches and tooling features in between. If you have any thoughts here we're all ears! 
Thank you for your suggestions. They give me something to think about and I hope that they'll help my coworker (and me).
I still guess that it's the type system. Consider the following: a=[1,2,3]; b=a; b[1]=4; And my coworker is confused why a[1] changed too.
This makes much more sense. :) Are there any (good) examples of TypeScript solutions on github (or elsewhere) which implements the repository pattern?
His code woeks generally OK-ish, but I have to help him often enough and maintenance of his code is a nightmare.
I honestly don't know, I have really only used typescript for web front end stuff, and that will rely on a Web API 90% of the time. In one app, some things are cached in a service worker, and in another I am persisting a Redux state, but I have never used a repository in typescript.
A slight nitpick (IMO) in the description of `unknown`. &gt; The any type is the most-capable type in TypeScript. &gt; There are often times where we want to describe the least-capable type in TypeScript. If `unknown` is being described as the least-capable type, then if `never` is dual to `unknown` surely `never` must be the most-capable type? I sometimes find the triangle between `any`, `never`, and `unknown` confusing.
/u/DanielRosenwasser there are a couple of typo's in the code examples. When describing richer tuple types, type `LineNumberAndSomeStrings` is defined, but the text below that refers to it as `OneNumberAndSomeStrings`. In any case, it looks to become an excellent release once again, thanks! The first code example for the `unknown` type defines the function `bar`, even though it's called as `upperCase`.
Cats are Animals, so you should be able to push a Cat onto an Animal array. I don't see what the problem is, `animals` is still true to `Array&lt;Animal&gt;` It is the other way around that should not work, if you already had `animals`, you should not be able to assign it to `cats`, but what you are doing should be okay.
I agree with what you are saying, `animals.push(dog);` is now adding a dog to cats. TS is not a true language in the usual sense though, I think they just do a hell of a lot of work to try not let JS bight you. Have you tried running ts with strict on? 
&gt; Cats are Animals, so you should be able to push a Cat onto an Animal array. But I'm not pushing a Cat onto Animal array. I'm creating a mutable array of Cats, which is then coerced to a mutable array of Animals. which allows me to push a Dog into an array of Cats.
&gt; Have you tried running ts with strict on? This type-checks with *strict on*.
my side too... You could submit it as a bug maybe. This is very valid JS, and I guess ts is just checking each statement saying, "yup, looks good".
&gt; Unhandled Rejection (TypeError): myCat.purr is not a function
I don't think there's a bug here. In line 9 you are telling TS that `animals` is of type `Array&lt;Animal&gt;` and it is technically true, but now it is up to you to enforce that. If you remove the type from animals, you will see an error. How is this different from `animals: any = cats`or `animals: Array&lt;object&gt; = cats`? since `Cat` extends both, this is completely correct, there is no point in extending a class otherwise... 
But if they're pushing to the `Animals[]` (i.e. `animals`), they're _also_ pushing to `Cat[]` (`cats`) - because the variable refers to the same object. Thus, in an ideal world it shouldn't typecheck.
&gt; You could submit it as a bug maybe. I agree that the TypeScript bug tracker is a better place for this than reddit. I also agree that I don't think the TypeScript developers would want this to typecheck :)
That is due to type erasure. I think this [FAQ](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-this-incorrect-cast-throw-a-runtime-error) should clarify the reason. &gt;TypeScript has type assertions, not type casts. The intent of &lt;T&gt;x is to say "TypeScript, please treat x as a T", not to perform a type-safe run-time conversion.
True, but there is a limit on how much TS can protect you from yourself before it prevents you from actually doing things.. This is only happening becuase the type assignment on line 9, it is like telling the compiler that what about to happen below in the code is "safe". In an ideal world, there are no 'any's or 'X as T's...
The problem is that generic types in typescripts are all bivariant (both co and contravariant). In this case, you want the T in Array&lt;T&gt; to be neither. [See here](https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance). Implementing proper covariance and contravariance is [an open issue](https://github.com/Microsoft/TypeScript/issues/10717), though I don't think it's being worked on. 
That is true as well and I think that's the reason this happens. Still, you'd expect problems when e.g. assigning (to) `any`s, whereas the situation above is not unimaginable to occur naturally.
When assigning objects, it just checks the existence of *at least* the properties (the presence of an extra property wont make it unassignable). There are some hacks into providing exact types (flow has `{| ... |}` syntax for that). from https://github.com/Microsoft/TypeScript/issues/12936 You may mitigate that by just using less assignments and mutable types, and letting more inference kick in (each assignment is an oportunity for erasure).
I think TypeScript should know however that you're passing an array by reference and therefore the original type declaration can no longer be trusted as sound.
I think this should at least fail behind a strictness flag, it's not that difficult to copy an array by value with spread or splice.
Let me know if you post an issue on TS' GitHub about this, I'd like to subscribe to it. :-)
Because of type erasure the compiler can't make any assumption like that.
You seem knowledgeable! Is there any way yet in 3.0 to map a tuple of functions to their return types in another tuple? e.g. [() =&gt; string, () =&gt; boolean] --&gt; [string, boolean] The args that my API accepts is variadic, accepting any number of functions from the developer. As such, manually doing `ReturnType&lt;T[0]&gt;` isn't feasible.
As someone pointed out, this is covered by: https://github.com/Microsoft/TypeScript/issues/10717
I'm not at all familiar with this field so humour me for a moment... Why can the compiler correctly fail the following: let a = ''; a = 1; But no OP's?
(look at my comment below) Assignability between 2 objects (A &lt;- B) wont fail if B has _extra_ properties (A just must be inside B). You'd need to tell the compiler to do an exact assignment (flow has `{| ... |}` syntax for that).
The reason lies on the fact that in your case variable `a` is of type `string` and the compiler is never confused about its type because it is always well defined and inferable. Hence the compiler always forces you to assign only strings to `a`. In OP's case instead we have `Array&lt;Cat&gt;`. let cats: Array&lt;Cat&gt; = [cat]; The developer is telling the compiler: *"look I only want* `Cat` *objects in this* `Array`*".* What the compiler understands is: * `cats` is of type `Array`.This is type-passing semantics: `cats` is `Array` and this type is always explicit to the compiler. You'll never be able to do `cats = ''` * the objects inserted in `cats` in it must be of type `Cat`. Type-erasure semantics: you added some syntactic sugar (meta data if you will) to perform some extra check on the content added to `cats`. However this information about type is not added to `cats` at runtime (it is **erased**) and `cats` will be just `Array` and not `ArrayOfCat` So Mr Compiler replies: *"Ok fine, however remember that for me* `Array&lt;Cat&gt;` *at runtime is just* `Array` *(****--&gt; type erasure :)*** *). If you do some tricks (for example upcasting* `Cat` *to* `Animal`*) then I will completely forget about* `Cat` *won't be able to complain if you add* `Monkey` *or* `TRex` *in* `cats`*".* So if you do let cats: Array&lt;Cat&gt; = [cat]; let dog: Dog = { voice: 'woof', roll: () =&gt; 'roll' }; cats.push(dog); Mr. Compiler will scream: *"Hell no! you have an array of cats there, no dogs allowed!"* However if you do let cats: Array&lt;Cat&gt; = [cat]; let animals: Array&lt;Animal&gt; = cats; // Java would throw a warning here let dog: Dog = { voice: 'woof', roll: () =&gt; 'roll' }; animals.push(dog); Mr. Compiler will say: *"'sup man? Code looks fine to me. You told me that now we're dealing with an array of* `Animal` and `Dog` is `Animal`, so I'm totally fine. After all behind the scenes the data structure is `Array`, no problem for me*".* This because there is no type `ArrayOfCat` but only `Array`. Type erasure is performed. Generics are syntactic sugar to create templates for reusable code, however they don't enforce any constraint at runtime. If you play some tricks to the compiler, it will let strange things such as this one pass, because that parameter type will not be checked at runtime.
Thanks for the reply! I still don't understand why the compiler can't ascertain (not at runtime) that it's copied another array by reference and remember that. So you do `let animals: Array&lt;Animal&gt; = cats;`, and that's okay because it's compatible, but it should take note that it's just copied an array of a different type by reference and enforce that you don't do anything with it that won't _also_ be compatible with the original type. I don't think you need anything at runtime for that.
 interface AnimalHome { findSome(): Array&lt;Animal&gt; } class DogHome implements AnimalHome { dogs: Array&lt;Dog&gt; = [/* some Dog objects */]; findSome(): Array&lt;Animal&gt; { return dogs } } class CatHome implements AnimalHome { cats: Array&lt;Cat&gt; = [/* some Cat objects */]; findSome(): Array&lt;Animal&gt; { return cats } } let animals: Array&lt;Animal&gt; = askUserToPickAnAnimalHomeImpl().findSome(); You can see that in this case the compiler has no way to infer the type: the user will pick one implementation and all we agreed on is that we will receive an Array of Animal.
Thanks, both should be fixed!
&gt; surely `never` must be the most-capable type? Yes and no. `never` is indeed assignable to everything (whereas `unknown` is assignable to almost nothing). However, `never` also describes the empty union. Unions describe all possible types a value could be, so if all values must have a type, there isn't any value that exists in type `never`! So practically speaking, it doesn't make sense to let users think it's okay to access members on `never`. Usually something has gone wrong if a variable has been narrowed to `never`. So `never` is also very restricted.
There's quite a bit of misinformation in this thread - this right here is the answer. I think I have read or heard Hejlsberg speak somewhere about this and the simplicity vs soundness -aspect of variance in TS, but couldn't find it right now. 
Imho this is not a bug but a feature of JavaScript. Arrays are not strongly typed and their email pushing a dog into a cat array is perfectly legal. Typescript will save you from many bad things but bad JScript features..... Maybe not
So it should! Many of these new additions aren't necessarily things you'll use directly, but they're in use in the typings you use on other projects. Things like mapped types were huge things for me despite never actually making use of them myself.
Thank you for your response. It's a little sad that it's probably not going to be fixed, from the looks of it.
fp-ts lacks good documentation, I am glad to see a similar library. How do we handle async/await inside map, chain .. ?
Out of curiosity, have you tried Immer?
I haven't but it looks interesting, thanks for the suggestion!
If you want to play against TypeScript Compiler API (normal users won't do this), StackBlitz and cia won't work. I'm building a playground just for that and filling it with examples: [https://typescript-api-playground.glitch.me/](https://typescript-api-playground.glitch.me/) And the same as previous, but runs 100&amp;#37; in the browser: [https://cancerberosgx.github.io/typescript-in-the-browser/typescript-compiler/](https://cancerberosgx.github.io/typescript-in-the-browser/typescript-compiler/) And , just in case, trying to build a TS project editor (based on monaco-editor) : [https://cancerberosgx.github.io/typescript-in-the-browser/candombed/](https://cancerberosgx.github.io/typescript-in-the-browser/candombed/) \- but in this last one you won't be able to write TypeScript Compiler API code - just a normal user experience 100&amp;#37; client side This is WIP I'm planning to add more features - but in general is a research project to see how well TS behaves in other platforms than node.js. Tell me whet you think
Now I'm curious. I'm trying to think of any language release that has significantly *reduced* the complexity of its type system. 
So to be honest, I think between 1.0 and 1.1, TypeScript did have some simplifications in the type system, but that was brie and we quickly started adding more. Scala's reimplementation (Dotty) is probably another example where Scala 3.0 will simplify or remove certain constructs.
No, not yet. We can't yet transform individual tuple values. For that, full support for variadic types is needed. See https://github.com/Microsoft/TypeScript/issues/5453 What I am excited about in TS3 though is strong-typing of `bind`, `call` and `apply`. It'll be a game changer.
I have now created much better documentation.
Hi, all. I recently published Zoe, a linter/formatter similar to Standard, Lynt, and XO, but based on **Prettier** and **eslint-config-airbnb**, also featuring out-of-the-box React Flow, and TypeScript support! Note that this runs ESLint on TypeScript files, but it uses `eslint-plugin-typescript` for some TypeScript-specific linting rules. TSLint rules are not currently supported, but I am considering this. Would love some feedback and suggestions.
Is this a wrapper around `prettier` and `eslint`, or is it its own app? What would be the motivation to choose this over `prettier` and `eslint`, other than it being 2-in-1?
It is not just a wrapper in that it also supports TypeScript, Flow, and React without the need to install anything else. For example, currently if you want to use `eslint` (with the `airbnb` rulesets) and `prettier` on a TypeScript-React project, you'd also need to manually install all of the following: * eslint * eslint-config-airbnb * eslint-config-prettier * eslint-plugin-import * eslint-plugin-jest * eslint-plugin-jsx-a11y * eslint-plugin-prettier * eslint-plugin-react * eslint-plugin-typescript * prettier * typescript-eslint-parser And then you'd have to configure your `.eslintrc` file, etc. Zoe includes all of these packages (and more) for an easy, "zero-config" experience.
Wait, sorry, can you clarify, please? If I'm on a TypeScript project, don't I want `tslint` over `eslint`?
Right, sorry. The thing is that `tslint` is missing support for a lot of nicer `eslint` plugins and configs (like `eslint-plugin-unicorn`, or `eslint-config-airbnb`). 
But those don't work if your source code is TypeScript, or do they?
They do with Zoe! ESLint lets you set custom parsers and `typescript-eslint-parser` is a thing.
They do with Zoe! ESLint lets you set custom parsers and typescript-eslint-parser is a thing. 
Oh! That's great to hear! Actually, that makes a lot of sense now. Thanks. Although, you would still want `tslint` for linting TypeScript specific things like type annotations, right?
Yeah, sorry for not being more clear earlier! I also included `eslint-plugin-typescript` for some TypeScript specific rules, but yeah `tslint` has way more, and you can still use Zoe in conjunction with `tslint`! I'm also considering adding `tslint` to Zoe and combing all ESLint and TSLint rules into one report.
That sounds like a good idea. Looking forward to it, if you choose to implement this.
Digesting smaller changes is easier. But sometimes the documentation seems to be lacking for the new type system features. It's concise, but not approachable enough. Hard to internalize, because it lacks the examples and counterexamples. A cookbook would be great - something like Rust's.
Any specific sections that come to mind?
I think it filters for which attributes extend the function.
It's called a _lookup type_. Just as you would access values in a hash table using the square bracket notation: ``` { example: 1}["example"] // =&gt; 1 ``` You can "look up" the right-hand side of a type or interface. ``` type T1 = { example: string; anotherExample: number } type T2 = T1["example"]; // =&gt; string type T3 = T1["example" | "anotherExample"]; // =&gt; string | number ``` But we don't have to provide the property names manually. Since `keyof T1` resolves to `"example" | "anotherExample"`, we can just type `T1[keyof T1` and it will do the same job. In your case, `FunctionPropertyNames&lt;T&gt;` does the following: 1. Loops through all properties of `T`. 2. When the value assigned to the currently inspected property is of type `Function`, it maps this property to its name. If it isn't, it's assigned `never`. 3. It performs the lookup, finding the union of all right-hand values just as in the above example. In your case the union consists of only one value ‚Äî `updatePart`, for only it meets the requirement.
[removed]
Maybe use an interface. Interface IBigOleClass { function1(param1: string): string; function2(param2: Number): Number; ... } class BigOleClass : IBigOleClass { function1 = (param1) =&gt; { return param1 + "somerhing"; }; function2 = (param2) =&gt; { return param2 + 1; }; ... } 
We do this, we use an common extendedArray function to wrap the underlying type. It works well. Btw the use of the term standard library is confusing here. Are you suggesting all browser APIs be abstracted? 
I would vote against it. In case of _.orderBy lodash can easily handle null and undefined values and return correct output. In case of someArray.orderBy we will have undefined doesn‚Äôt have orderBy function. And even with strict-null-checks option we have to wrap everything into if-else every now and then 
 First of all, a usual disclamer about making sure your class doesn't have too many responsibilities applies. As for your specific problem, if you have lots of methods in your class, chances are they belong to different "responsibility zones", and this is usually solved by interfaces: interface Foo { foo(); // Other foo-related methods } interface Bar { bar(); // Other bar-related methods } interface Baz { baz(); // Other baz-related methods } class MyClass implements Foo, Bar, Baz { // Implementations for all the methods } Alternatively, you can use composition: class MyClass { foo: Foo; bar: Bar; baz: Baz; } Technically, you can access `MyClass.prototype` and add methods to it after the class declaration, but TypeScript won't see them, and it will hurt readability.
First of all, a usual disclamer about making sure your class doesn't have too many responsibilities applies. As for your specific problem, if you have lots of methods in your class, chances are they belong to different "responsibility zones", and this is usually solved by interfaces: interface Foo { foo(); // Other foo-related methods } interface Bar { bar(); // Other bar-related methods } interface Baz { baz(); // Other baz-related methods } class MyClass implements Foo, Bar, Baz { // Implementations for all the methods } Alternatively, you can use composition: class MyClass { foo: Foo; bar: Bar; baz: Baz; } Technically, you can access `MyClass.prototype` and add methods to it after the class declaration, but TypeScript won't see them, and it will hurt readability.
I think this is what I am going to use. I just started trying it out, and it reads very well. The reason my class has a lot of methods is that I'm writing a front-end utility and ultimately I need to provide the user with one class they can instantiate from. It will make use of many other classes, but it has a lot of functions that need to be exposed to the user, and a lot of set up methods as well. Maybe when I'm done re-writing the whole thing in TypeScript, I'll post it so people can critique it!
I remember the strict function types feature that was really challenging to understand. ( https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html ) Maybe most users are okay with the example, but I think elaborating on what "possibly sound" and "provably sound" means, showing a counterexample would (have) help(ed). That said, I just reread a few other What's New? release notes and the listed things weren't as scary as I remembered. Sure, conditional types are dense, but maybe that's more for library authors. At least I haven't found myself using conditional types, even though ReturnType and InstanceType sound very powerful.
it seems to me that what you want is a library with better JS collections. there are already several such libraries, like https://facebook.github.io/immutable-js/ https://github.com/funkia/list or my own https://github.com/emmanueltouzery/prelude.ts/ It is the way you say it, you have two types instead of extending the JS builtin array, and the compiler makes sure you don't mix-up. All these libraries also offer convenient back-and-forth conversion functions.
(not self-promotion, useful article) Current test: Page uses `pick`, `groupBy` and `toPairs`. - Direct import (es6 syntax): ~500kB - Babel plugin + webpack plugin: ~70kB - Approach 2 from article (use slash paths): 150kB Conclusion: not using lodash, ill have to rewrite those functions...
I would add the return type, remove the default case and let TypeScript do its built-in exhaustivity checking
Only works if you return something though
Thanks a lot u/TYB069
I do something similar but just with a function in my personal typescript helpers library: ``` export function unreachable(x : never) { throw new Error(`This should be unreachable! but got ${x}`) } ```
Thanks! Yes, `strictFunctionTypes` was difficult to explain without diving too deep into variance and the like. It's the challenge of appealing to a lot of different users.
That fails if your function's return value isn't handled outside of the switch, because TypeScript doesn't see the `throw` unless it's inline.
Elegant. I made a little modification because it's sometimes helpful to have a more descriptive message. ``` export class UnreachableError extends Error { constructor(value: never, message: string = `Unreachable case: ${value}`) { super(message); } } ```
I don't think you even need anything typescript specific here just use some standard js destructuring on the passed in parameter: function someRequestHandler( { body: {id, status} }: { body: Toaster}){ updateToasterInDb(id, status) } } Unless I'm misunderstanding what you are trying to achieve with the typing here?
That is correct. You could also return unreachable(x) (and change unreachable‚Äôs return type to any, or a generic type parameter). 
I want to avoid having to write that type of code. I don't want to create properties of objects one by one, I'd rather define types and have the code do the work for me. For example, if I decided that in addition to the `status` property the update can also apply changes to the `brand` I'd rather not have to go change the DB method and the request handler method. Is there some nice way where I can say: "This is the shape of my data, an update type is just the 'status' of the Toaster type. Given an sanitized input (say from an API endpoint) satisfy that type"
Which particular fields of an object you pass to a function is a runtime concern not a typing concern. Typescript isn't going to change how the code works at runtime. So no, there isn't a type you can specify that will make typescript constrain what is actually passed at runtime. You might be able to create some sort of auto mapper from the fields you specify. But that isn't going to be any shorter code than the above. You would just be shuffling around where the work is being done. And it would still require some actual runtime code not just typing information.
It sounds like you need an ORM like sequelize or typedorm more than fancy type magic. 
or never
How‚Äôs that issue specific to state?
You're right, it's a broader TS issue (since discovered that).
I don't quite follow, in this example I am getting an error as I expect and I am not handling the return value outside the function (unless I am not understanding what you mean by that which could certainly be possible) ``` import {unreachable} from "h-ts"; enum IceCreamTaste { awesome, meh, dunnoYet } function getAnswer(taste: IceCreamTaste) { switch (taste) { case IceCreamTaste.awesome: return `It's like a party in my mouth!`; case IceCreamTaste.meh: return 'Umm I think someone has eaten this before me.'; // case IceCreamTaste.dunnoYet: // return 'Lemme try it first, ok?'; default: unreachable(taste) } } ``` Is giving me this error: ``` error TS2345: Argument of type 'IceCreamTaste.dunnoYet' is not assignable to parameter of type 'never'. 44 unreachable(taste) ~~~~~ [20:32:44] Found 1 error. Watching for file changes. ```
My comment was awkwardly worded. The error I'm describing isn't thrown when you miss a case, it's because the function's return value isn't satisfied when you have a default case that doesn't throw inline or return a valid value. Here's an example of what I mean: function unreachable(x: never) { throw new Error(`This should be unreachable! but got ${x}`) } enum IceCreamTaste { awesome, meh, dunnoYet } function getAnswer(taste: IceCreamTaste): string { // &lt;-- type error here - Function lacks ending return statement and return type does not include 'undefined'. switch (taste) { case IceCreamTaste.awesome: return `It's like a party in my mouth!`; case IceCreamTaste.meh: return 'Umm I think someone has eaten this before me.'; case IceCreamTaste.dunnoYet: return 'Lemme try it first, ok?'; default: // TypeScript doesn't use the information that `unreachable` always throws, // so we get a type error that `getAnswer` doesn't return a string unreachable(taste) // but this works // throw new Error(`This should be unreachable! but got ${taste}`) } } I'm having trouble replicating the exact error on the TypeScript playground that I see in a local project. Maybe it's some compiler settings? Here's what I'm seeing in vscode: &gt; [ts] Function lacks ending return statement and return type does not include 'undefined'. On the TypeScript playground, I don't see an error unless I enable the flag `noImplicitReturns`, but it's a different error than what I see in my local project. &gt; Not all code paths return a value.
Ah ok! I knew I wasn't understanding something. Thanks for the clarification. It's a bit odd that typescript isn't inferring never for the return type of unreachable, it's inferring void. (I think I am spoiled by Scala and it's expression oriented syntax, who has time for return ?) Ok so I see now, in order for it all to work I have to write it all like this: ``` function unreachable(x: never): never { throw new Error(`This should be unreachable! but got ${x}`) } enum IceCreamTaste { awesome, meh, dunnoYet } function getAnswer(taste: IceCreamTaste): string { // &lt;-- type error here // the error: Function lacks ending return statement and return type does not include 'undefined'. switch (taste) { case IceCreamTaste.awesome: return `It's like a party in my mouth!`; case IceCreamTaste.meh: return 'Umm I think someone has eaten this before me.'; case IceCreamTaste.dunnoYet: return 'Lemme try it first, ok?'; default: return unreachable(taste) } } ``` Thanks for clarifying! 
That's nifty, needing to only add `return` vs `throw new`. Trivial trivia - you don't need `new` with `Error`, but you do with a subclass of it. &gt; Scala and it's expression oriented syntax, who has time for return So much agreement - I can't wait for [pattern matching](https://github.com/tc39/proposal-pattern-matching) expressions to get implemented!
There is no reason to use classes. Use typescript to describe what you already have, instead of trying to rewrite the existing code. And you can do this on a file-by-file basis. Just rename to .ts, add types to all function arguments and fix any errors. Make sure you have full strictness enabled. It makes sense to start with the utility functions that are used everywhere, or all code importing them will still be partially untyped. I‚Äôve done this and it works. 
Sorry I don't have any advice, just leaving a comment because I think what I currently don't understand about TS might also be answered here and I wanted to bookmark the discussion. 
Don't use any. It won't save you time.
Yes, that's why the Purge now. Learned it the hard way.
Anything in particular you wonder about?
Tslint has a rule to forbid any typing. Its part of the rules from create react app typescript. 
Thank you very much for your detailed response, I did not think about replacing the JS code one by one, that's actually a great idea! One last question left: Do I continue to export my functions one by one (for my controller) via `module.exports = {}` then? And when to actually use classes if not in such a case where I have a connector for a third party REST API?
 let animals: Array&lt;Animal&gt; = cats; This line basically means "Disregard everything you know about the variable `cats`. It is now an array of `Animal`." It is a *type assertion*, meaning you *know better* than the compiler. If instead, you want to trust the compiler: Don't do this.
All of [these](http://www.typescriptlang.org/play/#src=interface%20Thing%20%7B%0A%20%20%20%20name%3A%20'Hodor'%20%7C%20'Not%20Hodor'%3B%0A%7D%0A%0A%2F%2F%20Nope%2C%20I%20want%20it%20to%20be%20one%20of%20the%20string%20literals%20above%0Aconst%20untyped%20%3D%20%7B%0A%20%20%20%20name%3A%20''%2C%0A%7D%3B%0A%0A%2F%2F%20Works%20as%20expected%2C%20forces%20correctness%0Aconst%20typedNew%3A%20Thing%20%3D%20%7B%0A%20%20%20%20name%3A%20'Hodor'%2C%0A%7D%3B%0A%0A%2F%2F%20Also%20prevents%20copy%20by%20reference%20for%20invalid%20as%20expected%0Aconst%20thingToCopy%20%3D%20%7B%20totallyInvalidProperty%3A%2042%20%7D%3B%0Aconst%20typedCopied%3A%20Thing%20%3D%20thingToCopy%3B%0A%0A%2F%2F%20Also%20correctly%20prevented%0Aconst%20arrayThingToCopy%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Aconst%20typedCopyOfArray%3A%20Thing%5B%5D%20%3D%20arrayThingToCopy%3B%0A) are correctly prevented by the compiler, however.
Yes. Inside your app convert everything to \`extendedArray\` or other Classes. Unlike older jQuery days now I don't use Browser API much anyway. With React.js it's pretty much abstracted and I don't work with it explicitly.
Yes, because a string can impossibly be an object, etc. so the compiler will protest anyway. If you **still** think you know better , you can cast to `any` first. But really. Don't do this. Trust the compiler. If you really have a good reason to do a type assertion like OP, then also make sure you can't accidentally mutate the original array. At my company, we have a lint rule to *always* use ReadonlyArray instead of a plain Array. That helps a lot with nonsense like that.
You should not use `module.exports = {}` in typescript. (Nor in any new js you write.) Use modern import and export statements. function myFunction () {}; module.exports = { myFunction: myFunction } would become export function myFunction () {}; Don't use default exports. They just become confusing. But yes, export your functions one by one. &gt; And when to actually use classes if not in such a case where I have a connector for a third party REST API? There is no reason to start using classes just because you port to typescript. Classes are available in js as well. If classes were a good idea in js, they are still a good idea in typescript, and vice versa. I would do the port as a separate step. Then, when you have most of the code in typescript, you could start working on refactoring it to classes if you feel that is more suitable. 
Im wondering if perhaps you have old prototype based js inheritance? Code like that would need to be converted to use the class keyword instead. I'm not even sure you can use the prototype directly in typescript. 
It's definitely possible to describe but it might be more work than just changing them to use the class sugar. But you can always define something as an interface and when you attach prototype chains the worst case scenario is describing the result as a union of types. Can't say which would be easier without more knowledge of the code base though.
I wouldn't say "Don't use default exports"... more like... either use default export everywhere or not all. It's more important to be consistent. (having said that, I personally try to avoid default exports like the plague :)
I don't really think using Typescript should drive you to using different approaches such as using a class or using functions. If you feel that what you're doing now is sane, than keep doing it. I feel like this really depends on what your "certain functions" do. If they are small, reusable, testable and easy to compose, then I would definitely export them one by one. In regards to "export the class itself and then instantiate the class inside of my controller", that's generally seen an anti-pattern. If you need a certain class in a controller, don't instantiate it, pass the instance down as a dependency. 
Default exports have no name, which make them potentially confusing. Also hard to refactor, since you can‚Äôt change the non-existing name. And you often need to add some more exports from the file later, and then you have mixed named snd default exports...
&gt;Default exports have no name, which make them potentially confusing. Default exports have a name: `default`. &gt;Also hard to refactor, since you can‚Äôt change the non-existing name. Default exports get named whatever you import them as, so you don't need to refactor the name. &gt;And you often need to add some more exports from the file later, and then you have mixed named snd default exports... What's wrong with that? 
&gt; Default exports have a name: default. Well. No. As you mention later, "Default exports get named whatever you import them as". So it is up to the importer to make up a name. That name might not be a very clear one. And in the worst case, and misleading one. &gt; you don't need to refactor the name Yes, you do. Often when you refactor, the semantics of a function changes. The name often needs to change to reflect that. If the importer have defined their own name, you won't be able to automatically change that easily. &gt; What's wrong with [mixed named and default exports]? It is inconsistent. You need multiple import statements from the same file, which is annoying.
&gt;Well. No. As you mention later, "Default exports get named whatever you import them as". So it is up to the importer to make up a name. That name might not be a very clear one. And in the worst case, and misleading one. Let me clarify. Default exports are exported as a named export called `default`. So given: `export default const someVar = 1;`, you can import it like this: `import {default} from "someModule";` If you import it as a default import: `import someAlias from "someModule";`, it gets aliased as whatever name you import it as. &gt;It is inconsistent. You need multiple import statements from the same file, which is annoying. You can import default and named exports in a single `import` statement: `import DefaultImport, {namedImport} from "someModule";`
I mostly use TypeScript with React and I don't understand how to use .d.ts files, I've read the docs, but I'm still confused. Should there be 1 .d.ts file for each component or should it contain types for the whole project ? also I don't really understand how to link to a .d.ts file and if I need Interfaces or not if I am using a .d.ts file.
Enable ‚Äústrict‚Äù and never look back.
I still use `any` from time to time. Especially if I don't actually know the type yet (`JSON.parse()`, etc). I suppose [unknown](https://github.com/Microsoft/TypeScript/pull/24439) will be more useful in those scenarios in the future, though.
You don't write *.d.ts files if you are using typescript. You only manually write *.d.ts files if you have pure js code where you write a corresponding *.d.ts file to add typescript types without having to change the js to ts. It's really mostly just used for libraries originally written in js that now want to offer ts definitions. If you write a library in ts you can tell type the typescript compiler to generate definition files from your code in addition to js files. That way someone else using typescript can benefit from your typing without recompiling your ts files with the rest of their project.
For those cases i just disable tslint for the line `// tslint-disable-next-line`
&gt; Let me clarify. Yes, I know how default exports work. I‚Äôve used them. What you describe is exactly what I call a problem. Let‚Äôs say I have a module with a default export that loads all blog posts. It would be imported like this: import getAllBlogPosts from ‚Äú./blog-posts‚Äù; Later, I realize I need can‚Äôt just indiscriminately show posts from the database, but should explicitly publish them by setting a `published` field to true. Since every consumer would need to filter by this field to keep working as before, I do this filtering before returning the posts from the default export. Also, There should be a separate getter to *actually* get all posts. But the existing imports stay the same and do not reflect this change. What earlier was a good, descriptive name is now misleading. Yes, this is a contrived example, and you could fix it by adding a default parameter instead. My argument still holds. &gt; You can import default and named exports in a single import statement TIL. Thanks. 
For small modules, say hypothetically a simple `add` function, export default makes sense. For larger things, say a set of actions around blog posts, I think named exports make more sense. Like all things, context is king!
Minor addendum: 1. You can use it to type other files that you import with say Webpack. Technically modules in a sense but not necessarily JS. 2. You can use it to globally share type definitions, for example you might want a global `Omit` type.
I'm curious what kind of typing can you provide for a file that isn't js? Also what do you mean by a globally shared definition?
I use Webpack with CSS modules, so I import CSS into my React files and supply the className using the import. In essence all CSS modules is doing is mapping my class names over to scoped class names during transpilation. My CSS typing is as follows: declare module '*.css' { const content: Record&lt;string, string&gt;; export default content; } By globally shared definition I actually mean ambient declarations; typically used for typing vanilla JS libraries, but also used by TS internally to provide you with the "built-in" types like Partial, Record, etc (check out lib.d.ts). So if I make a d.ts file and put the following inside: `type StringOrNumber = string | number;` Then my entire TS project will have access to this type without having to redefine it or manually pass stuff around. This should only really be used for very abstract stuff that's missing from lib.d.ts, such as Omit.
Ok I understand the 2nd example. I don't totally get why that type definition isn't just inside a regular ts file but sure. Ambient. Fair enough. But for the first definition I really don't understand. What does defining a css file as a record do for you? I must be missing something because that looks pretty useless to me.
Well, first problem with not doing that is that - at least in a strict environment - your CSS will be untyped, and the compiler will say it doesn't know what to do with the import. When you declare it like that then TypeScript understands that, although it's a format it doesn't inherently recognise, it's just importing a record.
I dunno about the default libraries in tsconfig, but the node one you gotta explicitly install using @types/node and the dom one should only be available when included in your libs in tsconfig
They are 2 different APIs. One is a WebAPI used for fetch, so it's only native to browsers. The other is a Node API used for streams, so it's only available in Node. 
So then I have something set wrong in my configs. For a node app vscode shouldn't be auto polling in that lib. 
Does `ts-node ./server/server.ts` work if invoked directly?
yup. Look for the `lib` string in tsconfig. It should not include "DOM".
That was it. Thanks!
You can do it in the exact same way. There is no difference to the APIs. TypeScript is just JavaScript with type checking, it doesn't take anything away from it.
It seems surprising you can't find this. So it makes me question what tool you're using to write your Typescript? I would highly recommend you downloading VSCode if you haven't already and write your code using that. It'll light up all your coding experience. 
Yes it does
&gt; "GetElementbyId", and manipulate it in JS, but in TypeScript there does not seem to be an equalivant(I'm probably wrong though...) i think this means you're thinking about typescript wrong. typescript is a superset of javascript - anything you can do in javascript, you can do in typescript, you just have to annotate. const elem: HTMLElement = document.getElementById('my-element'); const child: HTMLEelement = document.createElement('p'); child.textContent = 'You made this? I made this.'; // will throw a build error of textContent isnt a string elem.appendChild(child);
Once you feel a bit more comfortable using vanilla JavaScript to manipulate the DOM you could then add a JavaScript framework to manipulate the DOM. I recommend Vuejs as it's the easiest to get started with. [https://vuejs.org/](https://vuejs.org/)
I suspect the difficulty you're experiencing is not understanding why TS doesn't let you work with the variable to which you've assigned the value of your `getElementById` call. TS is actually helping you here; what if the element doesn't exist? If you chuck it inside an if statement (e.g. `if (myElement) {}`) then it should let you work with it as it acts as a type guard.
Oh, alright then. I thought that there might be a different way to do it in TypeScript but if it is the same way to do it via JavaScript that explains why I can't find much information on TypeScript DOM manipulation. Thanks
Using Sublime Text, but I will switch to VSCode as suggested. Thank you for this information.
What does vue.js help me with o.0, what are the advantages of using this framework and the disadvantages?
Try changing your script to use nodemon's `--exec` argument pointing to ts-node.
With the correct setup, TypeScript will help you with the standard JavaScript browser code like `document.getElementById`. It's actually pretty clever. They've even got types for specific types of HTML elements. For example, the return type of `document.getElementsByTagName('script')` is actually `HTMLScriptElement[]`. You just need to make sure that "dom" is included in the "lib" property of your tsconfig file, so that the compiler will pick up the DOM d.ts files. The JS code you generate will be capable of running in web browsers. Just keep in mind that if you do importing and exporting with multiple .ts files, you'll have to use Webpack etc to produce the final JS file so that everything is configured to still be importable and exportable in the browser.
This is because `React.TouchEvent` and `React.MouseEvent` only live in the type space. Once the compiler converts everything to JS, they no longer exist. You should be able to do something like function isTouch(e: React.TouchEvent | React.MouseEvent): e is React.TouchEvent { return e.nativeEvent instanceof TouchEvent; } Find something that exists at runtime that lets you confirm it's a touch event, and then `e is React.TouchEvent` lets the ts compiler be happy at compile time. You can then do `if(isTouch(evt)) { /* inside here the ts compiler knows it's a React.TouchEvent */ } else { /* inside here it knows it's a React.MouseEvent */ }` and btw, `typeof` always returns a string and would just be `"object"` if you did `typeof evt`, `instanceof` is probably what you want in this situation.
Exactly. Typescript types !== runtime is types. It‚Äôs probably the biggest gotcha of typescript. You have to do runtime validation. 
I think ts-node isn't using your server/tsconfig.json file. It's probably using the root level tsconfig that has `"module": "esnext"` which won't work for node. Try this in your nodemon.json file: "exec": "ts-node --project ./server/tsconfig.json ./server/server.ts" 
Click the variable's identifier and hit shift+F12 to see all references. It'll show you all places where the variable is declared so you can see where it's being "re-declared" from.
gotcha
That's not true, pretty sure it will infer `never ` as the return type. Either way you can explicitly set the return type to `never`. Anyway, there's no point in this helper because you can enforce it statically in the way the article suggests.
This doesn't answer your question, but... You should really restructure your code so that class and function definitions are not right in the middle of your program flow. For your functions, try to use parameters rather than closures.
Cool, I added a link to your tool in README https://github.com/agentcooper/typescript-play#other-useful-links.
vscode gives me no warning. What line and what word exactly is it? What version of vscode is it?
The `if` on line 16 is a method named `if`, with an argument named `_EHP`, defaulting to `0`. It looks like you meant ot have an if-statement...
I got a little carried away https://gist.github.com/demoran23/147825a02f5c569f9d36025081733b66
I'm describing what happens if your function has a return type like `string` - a default case using the function helper instead of throwing causes a TypeScript error saying the function's return type isn't handled. See [this comment](https://www.reddit.com/r/typescript/comments/8zkn19/exhaustive_switch_in_typescript/e2nc6l0/) where I go into more detail.
Ah, I hadn't considered that `noImplicitReturns` might be disabled.
Oh, alright then. I'm really new to OOP (and programming in general) and I do not know about any structure or program flow to follow. I'll probably be on this sub a lot for my code, but that is besides the point. Where do you think I should put my classes and functions? And what do you mean I should use parameters rather than closures? I didn't think I needed any Parameters for the functions I had. Thank you for your help.
I don't know why your trying to show me up on my own thread haha. Seriously though, this is awesome and way more than I could expect. I think you use dictionaries for this code right here, `const damageTypes: { [key: string]: IDamageType } = {` `physical: { type: 'physical', descriptor: 'hit'},` `fire: { type: 'fire', descriptor: 'burn'},` `cold: { type: 'cold', descriptor: 'freeze'},` I probably would have made separate variables for each of those Damage types, so what makes putting them into a dictionary better? Anyways, this is awesome man. This shows me what TypeScript can do if your a good developer.
exporting each of those would work as well, but then you're kind of left hanging semantically with importing `{ fire, cold }` and then you try and use them and there's a bit of a disconnect. By pinning them inside of a dictionary, you can be like `damageTypes.fire` and know what's going on. Another reason is typing. By putting it into a strongly typed dictionary, you're able to gain type surety on the members without repeatedly typing them. I hope the files help give you a bit of guidance as to how to proceed in the basics of breaking apart things into different files (aka modules), using interfaces for polymorphism, using abstract classes to share logic, etc. Feel free to use them as a baseline.
this worked perfect, thanks for the help!
thets the reddits algorithms fault, it keeps showing up on my main page...
The instanceof check itself should properly narrow, no need to wrap in a predicate function. 
?
Almost all advice in the thread so far seems to be about two things. 1. "Best Practices" they think you should already be doing even were typescript not even in the picture, like dependency injection or es6 modules. 2. The act of converting your js to ts shouldn't change much of your code on it's own.
I'm just waiting to see how https://github.com/tc39/proposal-pattern-matching goes. It'd be cool to have something like this in typescript.
I'd make them an npm package and just npm install them onto each the front and back end.
We usually have both front and back end in the same repo with the folders /backend, /frontend and /common .
this sounds great, you don't have some sort of example repo or anything do you? I'm wondering how exactly these would be imported given that with angular-cli all of my ng code lives inside the `/root/angular-project/src/app` and my backend code is `/root/src`. Thanks for sharing!
From experience, only models are suited for share between back end and front end, either JS or TS. To answer your quesrion, yes you can use TS classes
Right, models specifically is what i mean, rather than all classes. How have you shared the same files with frontend and backend?
https://stackoverflow.com/questions/41909207/sharing-typescript-interfaces-between-client-and-server-mongoose-model
Sorry, can‚Äôt share any code. And I haven‚Äôt worked with angular in particular. 
Sorry, can‚Äôt share any code. But I would just move the backend code to `/root/src/backend/`. Then, the backend and frontend are equal, instead of one being inside the other. 
Check out [project references in typescript 3.0](https://blogs.msdn.microsoft.com/typescript/2018/07/12/announcing-typescript-3-0-rc/), the examples given should solve what you're trying to achieve.
Some utilities or libs also fit to be shared, although depending on the use case could be considered part of the model anyway.
Take a look at https://github.com/RobertYoung/mean-stack-typescript-docker
Of you haven‚Äôt already - check out Nest Js
Can you tell me more, is there a subreddit?
I think what you're looking for is index signatures. 
I usually have 2 classes, for example UserDTO and User (or UserViewModel) In UserDTO you have fields that you don't want to display on the page (salt, hash, createdDate) In User you have fields, methods that you need only on the page (getFullName(), getDefaultAvatarByGender())
If I understand your issue correctly, you can do it like this: type ValidValueType = B['value']; const mapData = &lt;TKey extends string, TData extends { [key in TKey]: ValidValueType }&gt; (data: TData[], valueKey: TKey, labelKey: keyof TData) =&gt; { return data.map((v) =&gt; { return { value: v[valueKey], label: v[labelKey] } }) } mapData(myData, 'a', 'b'); // Ok mapData(myData, 'd', 'b'); // Error \[Full example\]([http://www.typescriptlang.org/play/#src=type%20A%20%3D%20{%20%20%20%20a%3A%20string%20%20%20%20b%3A%20number%20%20%20%20c%3A%20boolean%20%20%20%20d%3A%20Foo}type%20B%20%3D%20{%20%20%20%20value%3A%20string%20|%20number%20|%20boolean%20%20%20%20label%3A%20string}type%20Foo%20%3D%20{%20%20%20%20bar%3A%20number}type%20ValidValueType%20%3D%20B\['value'\]%3Bconst%20mapData%20%3D%20%20%20%20](http://www.typescriptlang.org/play/#src=type%20A%20%3D%20{%20%20%20%20a%3A%20string%20%20%20%20b%3A%20number%20%20%20%20c%3A%20boolean%20%20%20%20d%3A%20Foo}type%20B%20%3D%20{%20%20%20%20value%3A%20string%20|%20number%20|%20boolean%20%20%20%20label%3A%20string}type%20Foo%20%3D%20{%20%20%20%20bar%3A%20number}type%20ValidValueType%20%3D%20B['value']%3Bconst%20mapData%20%3D%20%20%20%20)&lt;TKey%20extends%20string%2C%20TData%20extends%20{%20\[key%20in%20TKey\]%3A%20ValidValueType%20}&gt;%20%20%20%20(data%3A%20TData\[\]%2C%20valueKey%3A%20TKey%2C%20labelKey%3A%20keyof%20TData)%20%3D&gt;%20{%20%20%20%20return%20data.map((v)%20%3D&gt;%20{%20%20%20%20%20%20%20%20return%20{%20%20%20%20%20%20%20%20%20%20%20%20value%3A%20v\[valueKey\]%2C%20%20%20%20%20%20%20%20%20%20%20%20label%3A%20v\[labelKey\]%20%20%20%20%20%20%20%20}%20%20%20%20})}const%20myData%20%3D%20\[%20%20%20%20{%20a%3A%20'qwe'%2C%20b%3A%20123%2C%20c%3A%20true%2C%20d%3A%20{%20bar%3A%200%20}%20}%2C%20%20%20%20{%20a%3A%20'rty'%2C%20b%3A%20456%2C%20c%3A%20true%2C%20d%3A%20{%20bar%3A%200%20}%20}%2C%20%20%20%20{%20a%3A%20'uio'%2C%20b%3A%20789%2C%20c%3A%20true%2C%20d%3A%20{%20bar%3A%200%20}%20}\]%3Bconsole.log(mapData(myData%2C%20'a'%2C%20'b'))%3B%20%2F%2F%20Okconsole.log(mapData(myData%2C%20'd'%2C%20'b'))%3B%20%2F%2F%20Error)
It appears that the issue is I'm importing TypeScript modules that are compiled to ES6. Does the TypeScript compiler not compile my imported modules to the target specified in the applications tsconfig.json?
The first trick is really clever! I've only came up with your second alternative myself, and thought it was impossible to just filter keys by value.
The first solution is indeed interesting. Although the solution should fail given the 2nd argument to mapData must be a key into data that returns a string (and v['b'] is a number). I assume we would need to do some similar magic for the 2nd argument to resolve this.
The first solution is indeed interesting. Although the solution should fail given the 2nd argument to mapData must be a key into data that returns a string (and v['b'] is a number). I assume we would need to do some similar magic for the 2nd argument to resolve this.
Are you using anything like [Babel](https://babeljs.io/) in your Webpack config? I target es6 in my tsconfig and use Babel to go down to es5. I honestly don't know whether I'm doing things optimally in my projects, but what I'm doing works for me. Here are my rules in my Webpack config: rules: [ // Node modules { test: /\.jsx?$/, use: [ 'babel-loader' ] }, // TypeScript code { test: /\.tsx?$/, use: [ 'babel-loader', 'ts-loader?{configFile:"tsconfig.json"}' ] } ] Since I'm including other non-TS libs from NPM, I have that "Node modules" rule for also making sure I have all those files covered upon import. I prefer to do it this way is because it allows me to use more advanced [code splitting](https://webpack.js.org/guides/code-splitting/) features via Webpack.
Sounds like this was inspired by Flutter. I think you should build and share a proof of concept.
Thank you. I have been working on this framework for past one and half year, and recently found out about Flutter. 
No, a typescript library that is already compiled then distributed is already compiled. The typescript compiler won't touch that code. You would need to either get the original typescript of the library and specifically target that instead of the *.js and *.d.ts or use another tool like Babel.
It definitely looks interesting but it's hard to tell how it works as an entire system. How do you handle routing? How do you handle things like forms? How do I make a component with a custom layout or am I constrained to only use the widgets the framework already provides? I'm intrigued but can't tell from the example code what's possible and how.
Thank you. You can create custom and composite components by overriding base classes. I have boiler-plate generator for those. At the moment I am working on the form components and the a datagrid (which is very time consuming). The router is a key/pair based system for now (**'/foo/{id}/:slug:'**)
Would the derived classes support use of third-party libraries like [DataTables](https://datatables.net/) or [JSTree](https://www.jstree.com/)? Or would you build a base wrapper for that? 
But none of the examples are doing anything that even vaguely resembles dom manipulation and you said templates are right out. So if I wanted to create: &lt;div&gt;&lt;span&gt;&lt;label/&gt;&lt;button/&gt;&lt;/span&gt;&lt;/div&gt; For my templates view output how would I specify that?
You basically do not do DOM manipulation outside of a component context. Since everything is a component of some sort, you ask the component to change state, dispatch an event, etc.. etc.. The following a VERY rough version of a custom component, but it should give the idea. namespace Reddit { interface IMyComponentConfig extends IUIComponentConfig { caption?: string; onCaptionChange?: TComponentEvent; } export class MyComponent extends Blend.ui.Component { // override protected config: IMyComponentConfig; // reference to the internal button element protected btnElement: HTMLElement; public constructor(config?: IMyComponentConfig) { super(config); this.configDefaults(&lt;IMyComponentConfig&gt;{ caption: '' }); } public setCaption(value: string) { if (this.isRendered) { this.btnElement.textContent = value; this.dispatchEvent('onCaptionChange', [value]); } else { this.config.caption = value; } } protected render(): HTMLElement { return this.createElement({ tag: 'div', children: [ { tag: 'label', children: [ { tag: 'button', textContent: this.config.caption, reference: 'btnElement' } ] } ] }); } protected doLayout(isInitial?: boolean): void { // update this.el, this.btnElement when window is resized or some // other layout change event is triggered. } protected createStyles(configVariables: IThemeConfig): void { // this.loadStyle(......) } } } var test = new Reddit.MyComponent({ caption: 'Hello', onCaptionChange:() =&gt; { // do something } }); 
you can override the \`render()\` method to generate your own DOM tree like the example above. This makes integration of third party libraries possible. I have a working version of a custom component wrapping [http://www.draw2d.org/draw2d/](http://www.draw2d.org/draw2d/)
Oh its a render function. So why wouldnt I just use react? What am I gaining with your method?
Object-oriented access, type safety, and compilation for DOM manipulation. JQuery errors (at least in my experience) are usually found during testing (like race-conditions), not compile-time. It seems to allow for constrained design implementations. Other developers that don't know how things fit in the UI, or what component supports what, could reference the definitions perhaps.
What does that have to do with a react style view renderer? Type safety I understand. React does provide flow and either they or some 3rd party provides ts definitions but it's true that react isn't itself written in ts. But what does the rest of what you said have to do with it?
Indeed, the third argument can be constrained in the same way (I didn't get it from your post that you need it to have `string` value). Using the first solution, I think you can just type it as `ValidKeys&lt;TData, string&gt;` instead of `keyof TData`.
Is there a way to make private npm packages without having to have a paid subscription for each project?
rendering is just a small part of a Component at its lifecycle. Each component contains theming and is integrated in the MVC lifecycle (event management). To best of my knowledge you have to implement all these in React yourself. I did not include the theming in example above for the simplicity. The theme should have been something like: var test = new Reddit.MyComponent({ caption: 'Hello', theme: { labelColor:'#ededed', buttonColor: Blend.material.colorPalette.indigo.C500 } });
Yes, you can configure your own Node package registry on your own server, instead of paying npmjs for private packages. You can also use GitHub repos as npm packages with `npm install --save username/repo#branch-name`; but I am not sure if private repos are accessible.
I'm just not seeing it I guess. [React components have lifecycles](https://reactjs.org/docs/react-component.html#the-component-lifecycle) and handle events as well. I'd point you at the parts of the tutorial for working with events but there's no hash location nearby that I can find. React does have terrible css handling built in. But there are numerous 3rd party libraries for it. Personally I still think it's one of the weakest parts of the react ecosystem but I'm not sure the answer to any react dev would be to use a completely different framework. Just a random idea, and I don't mean to downplay any of the stuff you've done so far, but have you considered just wrapping functionality around react and letting it be your view handler instead? You'd immediately gain support for things like jsx and access to reacts extensive component library ecosystem. I'm just trying to figure out what your goal exactly is here.
Thank you. I appreciate your input. In fact the first version of my library was exactly the way you have suggested. But it was getting too complex integrating it. One of the reasons being the css/style handling, and the need for a bundler (webpack at the time). If have created `Blend.dom.createElement(....)` which accepts a config object (using TS interface) and it generates a DOM tree with event binding (including SVG elements). Once all browsers support virtual dom then this function will support that too. `Blend.dom.createElement(...)` is my mini react. I try to stay away from JSX because I believe markup should not be mixed with code. I guess I am "old school"
You do understand that jsx isn't a templating language like angular's right? Jsx is literally syntactical sugar that can be transformed into a series of function calls not completely different from yours createElement function. You can even write those functions directly inside a renderer instead of using has. Jsx is literally sugar syntax of function calls, not pseudo html with some dsl thrown in. I'm not trying to convince you to use it. But a lot of people who haven't used it seem to be uninformed as to what jsx actually is and assume it's a templating language like angulars.
You can provide the "flow" that you say react provides. I have no experience with react, but I imagine you can make a custom rule-set for your framework similar to it. I meant you can constrain what your other developers can do via your own definitions.
Understood. I'm currently using [Backbone.js](http://backbonejs.org/) and overriding their `render()` method with the template system they provide. Do you see an advantage to switch from Backbone?
JSX is definitely an option since it is supported by typescript. I can support the TSX syntax and pass whatever the typescript transpiler generates to `Blend.dom.createElement(...)` I do not think bundling and integrating React is an option for me at the moment.
Depending on the type of your application, and whether you are able to (want to) use either material design components or fabric ui components, it could be a feasible option. Otherwise you can implement (or wrap) your own set of components. For example the component provided by bootstrap.
You definitely don't have to. But from the original examples it looked like you were handling things in an entirely different manner. But then you showed a custom component and it kinda looks like you are just reimplementing reacts methods. There's nothing wrong with that. But you should know that before anyone else uses your code they will probably ask "So if it's the same why wouldn't I just use react?". I'm not trying to dissuade you from making this framework. I'm all for it; who knows what interesting things will come out of it. But if you are going to try to get users at any point then you should probably come up with some answers to these types of questions.
Why would one constraint anyone else? Shouldn't someone else be able to improve my code as he wishes when I work together with him? I still can talk to him and review his code. Constraining him in any possible way seems like a very bad choice to me.
much appreciated, thank you. 
Don‚Äôt think so. I added the project website to the original post
Of course! That's genius! I'll try that out!
What problem does your framework solve?
By constraint I meant the extensions built from the framework in question. Once those extensions are completely defined, they will act as the constraints for implementing new views or pages.
Thank you for your question! If I had to answer this question to a business person, I would have said: **"*****Develop scalable line-of-business applications for the web, much, much faster than using mainstream frameworks!*****"** (*pretty daring and arrogant, I know...!*) To a developer like myself, I would had said: "***Because of the way it is designed, you don't really need to concern yourself with low level browser programming, like: DOM, CSS, markup, event binding, responsive-changes, theming, SVG icons, layout, (async) form field validation, and some other stuff. You get a high level API to program against, where you can concentrate yourself with the business problem you are hired to solve. Programming against low level browser API is only needed to create specialised custom components.***" Have you ever programmed a native app for the desktop (C# WinForms, C++ QT, Cocoa Swift) ? Just like a desktop API , you don't really care how a button, dropdown, or data-grid is rendered into the screen. You program against the API of those components. I am trying to achieve the same thing with this framework; that is, to create distance between me (the developer) and the browser API.
excellent answer :-) 
A bit annoying that you are sharing screenshots, but I guess that this was the easiest way for you. Anyways: You specify the name of the method as a string when calling createAction('doSomeWork'). This looks to me like there won't be a compile type error if I wrote a type, e.g. createAction('doSomeWokr'), and it also means that if I want to rename doSomeWork to showAlert, then I would have to remember to change the string. If these points are correct, I am sorry, but I think you are doing it wrong. One of the points of using TypeScript over JavaScript is to avoid these kinds of errors, and frameworks written in TypeScript should leverage that advantage.
Thank you for your reply. I appreciate you took the time to dig through the code. The reason for this was because there is no proper reflection is javascript. However TypeScript provides method annotations with decorators. At the moment I have an experiment going with something like the following which hopefully will solve that issue. I am a little bit worried if the TS guys decide to change the annotations (since it is experimental) which will result a much bigger problem should this framework be used by others. class MyController2 extends Blend.mvc.Controller { @controllerAction doSomeWork(sender: Blend.ui.button.Button) { alert(`${sender.getText()} is Clicked!`); } } and then new Blend.material.button.Button({ onClick: myController.doSomeWork }); 
The ##typescript channel on Freenode is fairly active too, for people that care about their memory usage and don't want to use Slack.
&gt; The recommended IDEs for Flutter app development include Android Studio and IntelliJ Idea. Ouch.
That is already a -1. As fullstack dev I must run VS2017 + VSCode in parallel. I don't want to add another IDE
The Functional Programming Slack also has an active TypeScript channel https://fpchat-invite.herokuapp.com/
In fairness, the IDEA feature set is pretty much a superset of most other IDEs out there, so unless you're dealing with particularly arcane things, IntelliJ should cover all your needs. I use it for fullstack stuff, and it can pretty much handle going from the DB to debugging in the browser without much problem.
In fairness, the IDEA feature set is pretty much a superset of most other IDEs out there, so unless you're dealing with particularly arcane things, IntelliJ should cover all your needs. I use it for fullstack stuff, and it can pretty much handle going from the DB to debugging in the browser without much problem.
Can you elaborate pls with the details on this: "There's also a webpack plugin that runs the typechecker forked in a separate process so it doesn't slow down the build". Which plugin, etc.?
I think it's called "awesome-typescript-loader". Their README explains how it works.
Hey cool.... I just happen to be looking for things along these lines right now, I think?... Basically I have fuckloads of JSON data that I've been collecting for years, some my own schemas and data that I've generated, and others have been scraped from the web. I want to build a system with some kind of automation that I can just throw all the JSON files at, and it somehow makes schema fingerprints with a UUID for each one that identifies each unique schema. Also many of the schemas from the scraped data especially won't be ***exactly*** the same, but very close... so I somehow want to have some way to get a "score" for how close schemas are to others... kind of like fuzzy image hashing, but for JSON structures. So JSON files with the same structure will automatically be grouped together, and for each unique schema I've been thinking I'll autogenerate: 1. [JSON schemas](http://json-schema.org/) 1. [Joi schemas](https://github.com/hapijs/joi) 1. TypeScript interfaces ...to assist me with writing the code that will actually process the data in the end. There's tools to convert between the 3 things above, and I'm guessing I'll first generate that JSON schema or Joi, and from there generate the TS interfaces, seeing TS interfaces support the least complexity (validation rules). Could your library be a part of what I'm looking for in terms of assigning the schemas a fingerprint each, and also maybe detect closeness? I'm not expecting to find anything that does everything for me... just trying to figure out the best pieces to put together. Also what are your thoughts on what I'm trying to achieve in general? Your project does sound like it's quite relevant to what I'm doing here... but the README.md could perhaps explain a little more "why" your library would be useful, and maybe some examples of situations people would use it for. Also curious if you use any of the 3 things above and your opinions of JSON schema -vs- Joi etc ... and how does your library differ from them? (not implying it's the same thing, just trying to get my head around what is used for what) ...and any other thoughts you have on the subject in general. Thanks!
This has been fantastic for me: https://basarat.gitbooks.io/typescript/ Unlike most official docs, and even many articles/blogs etc, it's not just the "what" and "how"... but for me at least, more importantly the "when" and "why" to use these features. I find it very hard to learn/remember things unless I have a clear understanding of when and why I'm going to use them. I've just been reading it online at the URL above. You can also download epub/mobi/pdf files, or the source/markdown from Github: https://github.com/basarat/typescript-book ... being a github project it's constantly being updated and improved, and you can post github issues with suggestions etc. Here's the dude's donation link: https://www.paypal.me/basaratali - I've got no affiliation, I've just got a lot of value from how easy this is to read. Coming from PHP, I've found a lot of JS doco and especially NPM package descriptions to be quite vague, and make assumptions about knowing things. This is one of the few JS resources I'm come across that explains things well.
IIUC You should then have the constructor return a function if you want the resulting to be a callable. However this does not suit a class, why not just use a plain old function, in fact the class syntax is sugar for a function, javascript is prototype based and does not have javalike semantics.
But I'm going to follow typescript syntax and rules which classes are recommended
Well if you insist on classes then have the enduser new it up, and call methods on the object like in other languages. class Foo { // stuff } let foo = new Foo() foo.magic()
```ts interface IMyInterface { pushToHistory: typeof(push); { ```
I didn't know that! Thanks a lot.
No problem :)
Where did you get the idea that typescript recommends classes?
Hi, I'm the author of Learning TypeScript 2.x you can learn more about it at [http://learningtypescript.com](http://learningtypescript.com) Please feel free to ask me here any questions about the book if you are interested.
What about performance? These kinds of apps often have to display and process a lot of data. 
Hey, sounds like an interesting project! Although there is no built-in similarity computation, I think ence would be a great place to start for classifying your data. Since it generates a string, the lowest hanging fruit would be to just compare the output with \`===\`. However, since the syntax is very rigid, you can also process each line first. For example, maybe you don't care to make a distinction between numbers and strings. In that case you could: 1. Change the formatting options for both types to the same type string. 2. Replace repetitions of that type string in the output using a regular expression. This would allow you to keep using the cheap strict string equality comparison while being a bit more flexible. The output schema is also a lot smaller than the input, especially if your data has a lot of repetition/arrays. It might be feasible to literally just diff the output git style and calculate some measure of modified characters and lines. A more "native" way to compare the similarity between pieces of data would be to concatenate pairs into an array and compute the schema on that. The more \`empty\` types and the more type conflicts (\`|\`), the least similar they are! \`\`\`javascript // count substr in str const count = (substr, str) =&gt; str.split(substr).length -1; const schema1 = ence(data1); const schema2 = ence(data2); const combinedData = \`\[${data1}, ${data2}\]\`; const mergedSchema = ence(combinedData); // compute change in number of occurrences of \`token\` relative to number of lines const ratio = (token) =&gt; { const expected = Math.max(count(token, schema1), count(token, schema2)); const merged = count(token, mergedSchema); const change = merged - expected; const lines = count("\\n", mergedSchema); return change / lines; } // empty values are a better indicator of bad data const difference = 3 \* ratio("empty") + ratio("|"); \`\`\` As far as comparisons go, I can't say I've used all of them, but I would say all projects have their own purpose. As I see it, json schemas are a great (language agnostic) way to express complex validation on json data. Joi serves a similar purpose, but more focused on being used for runtime validation in javascript. Typescript is entirely focused on compile-time validation of code. Ence is more about describing existing data in a machine-convenient way (ex. grep, diff).
This is weird advice. You can use Flutter very well from VSCode - it's [one of their recommended tools](https://flutter.io/get-started/editor/#vscode), next to Android Studio. The support for Dart+Flutter on VSC is great. They have their own plugin, a good language service, and you can launch directly from the editor.
You don't even need to do that. TypeScript will know the types of the elements by inference. ``` const elem = document.getElementById('my-element'); elem.whatever; // Error: property 'whatever' does not exist on type 'HTMLElement'. const child = document.createElement('p'); child.doSomething(); // Error: property 'doSomething' does not exist on type 'HTMLParagraphElement'. child.textContent = 'You made this? I made this.'; // typescript knows this should be a string elem.appendChild(child); ``` You can see it's even more precise than your annotation, since it knows you created a `HTMLParagraphElement` and not a `HTMLElement`. Your annotations are actually making the type checking weaker. 
good point!
TypeScript is un-opinionated when it comes to Object Oriented Programming vs Functional Programming. TS just adds types and type checking to your code, regardless of the paradigm you use. Feel free to experiment with OOP and FP, or really anything in TS!
Notwithstanding the fact that you asked for a book recommendation and I am about to recommend not a book, have a look at * [https://stackoverflow.com/tags/typescript](https://stackoverflow.com/tags/typescript) * [https://stackoverflow.com/tags/typescript2.0](https://stackoverflow.com/tags/typescript2.0) Much of my TypeScript sharpening has happened there. TypeScript also evolves, and Stack Overflow answers often link to features-in-progress in [Microsoft's GitHub Issue Tracker](https://github.com/microsoft/typescript/issues), and *those* discussions also often informative.
To add to the evidence that TypeScript doesn‚Äôt recommend or prefer classes: The TypeScript compiler, which itself is written in TypeScript, doesn‚Äôt use a single class.
Really? That's very interesting. But I'm going to use Typescript for a small front end library, I mean in the browser. So, I thought maybe I got to use the object-oriented programming pattern which classes have their own methods and it's just feel better sytanxicaly
Yes! I was not thinking about functional programming! It's good to continue on functional programming
No where. I thought it might be the recommended way since their playground examples come with classes
Typescript JUST\* adds types to javascript, you should write TS code in the same way you write JS code.
It's not that there's anything wrong with classes fundamentally. It's just that your comment that classes are recommended is weird. Typescript aims to be JavaScript with types added. It doesn't aim to transform JavaScript into a pure oop language like java. So if you want to use classes feel free. But typescript isn't forcing them on you.
It's not just types, there are decorators, classes, generics, enums, interfaces and etc. I know they are just syntaxes and will not add anything to the JavaScript itself, but those are typescript abilities
I've found the [Typescript Release Notes](https://blogs.msdn.microsoft.com/typescript/) to be a good source of info. 
Thank you. At the moment I don't have any significant performance numbers. This is mainly because the data-grid component is still in heavy development. The main principle I use for developing the built-in components is to keep the event listeners to an absolute minimum, for example, for the click event on the data-grid, I listen to the click on root element, where I map the event target back to a certain row or cell. Next to that, I archive elements when they are not needed on the screen using the `DocumentFragment`, and put them back with `requestAnimationFrame`. I also don't have 2-way data binding, mainly because this is achieved using (system-wide) event dispatching. I also don't use icon-fonts. All icons are SVG images which are usually downloaded on demand and cached in `LocalStorage`
It really depends on the environment. In a browser you usually need to wait for the `document` to finish loading and then run you `Main` class. For this, there are many different techniques available. In a NodeJS environment you handle application startup differently.
decorators are just an experimental syntax based on a proposal for the EcmaScript standard that's several years old (actually the version in TypeScript is based on a proposal that was gutted and doesn't conform to the current one anymore). Classes are in JavaScript itself. Generics and interfaces are just types. Enums is a bit of both and the closest thing to something "not just types" that TS adds, depending on how you look at it. So aside that TS gives you a compiler, as far as the language goes, it really adds "just types". 
Perhaps (this example)[https://www.typescriptlang.org/play/index.html#src=%2F%2F%20In%20File2.ts%0A%0Anamespace%20Greetings.EN%20%7B%0A%0A%20%20%20%20export%20function%20hello(name%3A%20string)%3A%20string%20%7B%0A%20%20%20%20%20%20%20%20return%20%60Hello%20%24%7Bname%7D%60%3B%0A%20%20%20%20%7D%0A%0A%7D%0A%0A%0A%2F%2F%2F%20In%20File1.ts%0Anamespace%20Greetings%20%7B%0A%20%20%20%20export%20class%20Hello%20%7B%0A%0A%20%20%20%20%20%20%20%20public%20hello_EN%3A%20(name%3A%20string)%20%3D%3E%20string%3B%0A%20%20%20%20%20%20%20%20public%20hello_NL%3A%20(name%3A%20string)%20%3D%3E%20string%3B%0A%20%20%20%20%20%20%20%20public%20hello_AM%3A%20(name%3A%20string)%20%3D%3E%20string%3B%0A%20%20%20%20%20%20%20%20public%20hello_CN%3A%20(name%3A%20string%2C%20simplifiedChinese)%20%3D%3E%20string%3B%0A%0A%0A%20%20%20%20%20%20%20%20public%20constructor()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20var%20me%20%3D%20this%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20me.hello_EN%20%3D%20Greetings.EN.hello.bind(me)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%7D%0A%7D%0A%0Avar%20test%20%3D%20new%20Greetings.Hello()%3B%0Aalert(test.hello_EN('World'))%3B] helps
[removed]
I'm not sure if you really need a class here. Generally, you use classes when you're going to create several similar objects that all have state and share some methods. If you don't need state, you use plain functions. None of this is more "correct", and TypeScript is not opinionated about using object-oriented, procedural or functional paradigm. A library can still provide classes to its users, but you shouldn't just "wrap" a library into a class by default.
For some of the newest features it's the only source to get good examples of code, mainly advanced types. Good luck finding stuff about conditional types, mapped types, and keyof changes anywhere else.
&gt; Next to that, I archive elements when they are not needed on the screen using the &gt; &gt;DocumentFragment &gt; &gt;, and put them back with &gt; &gt;requestAnimationFrame This is probably faster than the React Virtualized library which croaks quite quickly in practice. What I miss, and this is as much a DOM problem as anything else, is general occlusion culling. However there's sadly a penalty for actually measuring the dimensions of an arbitrary DOM element. The answer to this is usually "you shouldn't have so many things in the DOM anyway", but I think that's not always the case. It's falsely applying webpage design to the design of applications that people do work with.
I agree
Awesome, thanks for all that info, appreciate you taking the time! &gt; Ence is more about describing existing data in a machine-convenient way (ex. grep, diff). That makes sense, and rules Joi out seeing it uses (or would generate) JS code rather than easily parsable metadata. So just comparing JSON schema to Ence... I guess the idea mainly around the fact that Ence is a more dense format that you can easily read/grep/diff? i.e. one flat ASCII line per property? ... that does seem quite a bit easier to read quickly and analyze with simpler tools than the code needed to compare JSON schemas. Funnily enough I was kind of thinking of coming up with something along the same lines simply for this human-readable aspect. 
Just as a side note, are you already using the TypeScript compiler to check your ECMAScript? (// @ts-check in Code) Output from that should help show why typescript is a good idea. 
I've been wondering a similar thing myself. We have a large react app that we did start effectively from scratch, I tried to convince the others to use Typescript, but for some reason they were against it then. Fast forward to now and they've realized that typing it is a good idea. We've messed around with flow, but honestly it kinda sucks in my opinion. I'm wondering how I would go about converting the project to typescript in a piece-by-piece fashion. 
The [gitter channel](https://gitter.im/Microsoft/TypeScript) is pretty active.
Turn on allowJs and checkJs. Now you can decide on a file-by-file basis how to add type annotations to a file. A) keep the file as .js and add JSDoc-style type annotations. There's a TypeScript wiki page that explains how to do this. B) rename the file to .ts and add necessary type annotations. (Many are not necessary) You can also describe complex interfaces in new .ts files and import them into your other files. (even .js files). For example, you can write an interface in .ts, import it into .js, and refer to it in your JSDoc annotations.
Why do you specifically want to write external .d.ts? Why not enable checkJs and add JSDoc annotations? You can check out the relevant TypeScript wiki page for details. I'm on mobile so I can't get the link.
As others have alluded to adding definition files is best for libraries you can't control but want to interact with typings. If it's your own code then basically any JS project is a TS project. You just tell the TS compiler to chill and it'll effectively do nothing, then over time you can migrate files by renaming them to `.ts` and adding types. I've done a conversion once, a rule we had was any time you have to touch a file you convert it. That way it's not a massive job all at once and work gets done in priority order.
Thanks! I'll give it a try! 
I don‚Äôt know of any guides or blogs, but one place to start to get some traction is [dts-gen](https://www.npmjs.com/package/dts-gen). It takes JavaScript and does its best to create typings. Then you‚Äôll need to go in and refine them. After that, you can make sure your typing are well tested with [dtslint](https://www.npmjs.com/package/dtslint).
&gt;add JSDoc-style type annotations Didn't know about this - sounds interesting. But I have 2 concerns - 1. This seems like a lesser known option. Will there be enough community support along the path if something breaks along this path. (This is not a big concern and obviously we'll have to try this and see) 2. More importantly, is it as flexible / first-class solution as a typedef file - in terms of syntax highlighting, authoring experience, use of variables, etc ?
I understand that ts is superset of js, but from the discussion I had with the team - major block is 1. what if some new member on the team DOESN'T know ts? 2. what if we decide to go back to plain js later - will it again take refactoring? AFAIK, answer to 2 is yes - it'll need some manual refactoring unless you want some weird ts-to-js converted enum in your code. Taking both in mind, the general opinion seems to me like let's do something which can be done progressively and doesn't touch the js file in any way at all (because it might break stuff). Hence, external typedefs seem to me like the ideal candidate as they can't in anyway change existing JS code files, is completely optional for someone who doesn't want/know how to add it.
Thanks for mentioning - I think this is the link [https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript](https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript) From what I understand, ts compiler supports some of the jsdoc constructs, but in no way does it have the full power of typedef files (and of course the authoring experience in whole). It's like they translate jsdoc tags to something similar in typescript typedef language, but obviously the latter is a much bigger superset - hence much less power. It'll mean learning the jsdoc way of doing things, not the ts way. For eg., it will probably not be able to use - typedef already present in external modules, import export typedef from other local files, etc.
Hi, Sorry, I couldn't completely understand the method you mentioned. Are you asking to try running tsc over existing code to check for warnings? That looks like a good way to show others how many problems we are not even aware of :) BTW, I am completely convinced about TS and use exclusively TS for my side projects. Its more about conveying the message to colleagues. From their perspective, either (a) its a new compile to js language \[which obviously is misleading\] (b) they simply have no reason to care about. I have tried to explain (a) by showing some sample JS and TS side-by-side, and (b) with the nice auto-complete and type security I get in my personal projects. To give some context, we have face errors like \`props is undefined\` and \`foreach is not a function\` many times and I just smile at that as its not even a thing in TS land (if done correctly).
Are you using VSCode? If so, and you put ‚Äú// @ts-check‚Äù at the top of your file (there might even be a setting that does it automatically), it will run type checking in your plain JavaScript and give you better intellisense support and type warnings. That should help convince people of the power of the ts engine without needing to actually change any code. 
Thanks for mentioning. I have tried dts-gen and dtslint to add typedef to some js libraries, where the purpose was just to help users of the lib. But I have never wrote application code (where files in the project consume each other) with TS using .d.ts files. I am not sure how well they will work side-by-side.
Yes, I use vscode. Didn't know of this option, will give it a try.
&gt; what if some new member on the team DOESN'T know ts? That's the beauty of converting gradually. Decide as a team how strict into the TS world you want to go. &gt;what if we decide to go back to plain js later You won't ;) &gt; - will it again take refactoring? The application structure doesn't need to change, you'll just have to wipe away the types. You don't even have to change the build process, you could effectively use TS like babel. You could write JS with the newest features (e.g. TS adopted `async/await` well ahead of ECMA) and use the TS build process just to compile to your target output (ES5, ES6 or whatever). I would say it's low risk. 
1. It's officially supported by the TS team, and they're very good at fixing bugs and supporting the features they implement. (They're very conservative with adding features; if they add it, they support it) So I think this is thankfully not something you need to worry about. Also, the conversion from JSDoc to TypeScript is straightforward, and you'll likely want to do that eventually anyway. 2. Yes! You can try it in VSCode and see. VSCode already uses TypeScript as it's language intelligence engine for JavaScript even when you don't configure it. There are a few differences between js typechecking and ts typechecking; all explained on the wiki page. You can totally mix TS and JS. I think once you try it out, you'll see how they are really part of the same package.
It *will* be able to use typedefs from external files, via importing and exporting the type declarations. Basically, instead of `const Foo: Foo` you do `/** @type {Foo} */ const foo;`. As you can see, there's a direct one-to-one correspondence between the native TS syntax and the JSdoc syntax. The latter must appear within a JS comment, so it's more verbose.
I'm not so sure that jsfiddle is the correct format to get help on this problem. I think what you're hitting is a tslint error. ([no-unused-variable tslint rule](https://palantir.github.io/tslint/rules/no-unused-variable/))
If there is any other platform in where I can post typescript and show it to you guys then please let me know. I will look at this tslint error though, thank you.
Thanks for resolving all my queries. Considering everyone's suggestions, I will go for this inline doc style. Although it's bit different from the exact ts syntax, that feels like a necessary compromise considering it's a jsdoc comment. Also that you can import ts files for use within the comments is really great. On the other hand, saw that .d.ts files have a major authoring problem where it can't provide type hint to the corresponding .js file,only to other files (which import it).
I can very much relate to what you are saying, having used it for my personal projects. But as of now, as part of a team who don't want to commit to something new - I also get their POV. My plan is to onboard them into ts without major commitments (i.e. Without making ta files), show them some good wins, and finally make the jump. 
Github. 
Stackblitz 
I tried your code, and on line 53: `XP = 100 * zone` Zone is not declared.
I'm preparing this step now for an almost100 LOC angularjs codebase. My current plan is to take each step slowly, the entire process will probably take a year as we're also still adding new features regularly. The first couple of step is the hardest, once I've ironed out the various build steps and compiler settings, it's simply a matter of creating a few examples for the rest of the team to follow. - first thing we'll do is simply run the entire thing through the tsc compiler as a build step before babel with the `allowJS` flags - next step is to add `@ts-check` to a single file and reply on inferred types and JSDOC types, and expand from there - also incrementally add types using `@types` - once we cross 75% type coverage, turn on the `checkJS` flag in the compiler remove the `@ts-check` flags and instead add `@ts-ignore` to the remaining files - convert files that are 100% checked to ts
As of TypeScript 2.9, you can also import types ad-hoc. It's useful when you want your file to be recognized as a script and not a module (any import/export statement in your file turns it into a module). interface IMyInterface { pushToHistory: typeof import('connected-react-router').push; }
&gt; a team who don't want to commit to something new Why's this? If you can demonstrate clear benefits then that's in my opinion quite a regressive attitude/atmosphere.
There's not really any reason to use Babel as well as TypeScript unless you want to use risky stage 0 features or something.
I tried to run the code you pasted in node. With a few additions I was able to make it work: import * as promptSync from 'prompt-sync'; const prompt = promptSync({}); const alert = console.log; Aside from that, answering 'Attack' did indeed attack. Keep in mind that 'Attack' is different from 'attack'. Did you use the proper casing?
As an aside, I'd suggest you do your project fully in node and put up a repository for it on github. That will make answering these questions a bit easier.
I did a bit of intermediate refactoring on this bit of code. https://pastebin.com/hxmtMrRw The next steps here are removing the functions that act upon `You` and `Them` (which I stubbed in for the module level variables) and pinning them to the appropriate classes (eg Player, Enemy).
Yep, that's why it exists. The `v0` would return js objects, but it really wasn't that convenient to use for anything and I would end up writing code to produce full addresses. So I rewrote it! (with typescript) The initial motivation was to analyze an external api's responses to detect poorly documented changes between builds. Also used it to look for data in huge json files. I really feel it's a superior tool for this kind of analysis, I'd be happy to know it helped you too!
`[clientId: string]` is the first part. `: IConnection &amp; { client }` describes the return type of calling the first part. const key = ‚ÄúamazonClient‚Äù; const myObject = myType[key]; myObject.client.callApi(); The `myObject` object above complies with `IConnection` interface AND it also has an object property `client` on it, but it doesn‚Äôt have any type annotation on it. So it is considered `any` in TypeScript.
 The `{ [clientId: string]: IConnection &amp; { client } }` is, of course, the type that `connections` is said to be. From the outermost braces, we can see that it is an object. So `connections` is meant to be an object. The stuff inside describes additional requirements on the shape of the objects that can be assigned to `connections`. `[clientId: string]` is what is called an 'index signature'. It's a bit like a 'catch-all' for unknown key-names. It says that this object can have any number of keys which should be strings. The `clientId` just indicates to us what those string keys are conceptually. The `IConnection &amp; { client }` describes the shape of the values that are allowed on the object. It means for each `clientId` string key that we had on our object, the value should be an object that matches the shape of whatever the `IConnection` interface requires, AND the object should also have a key called `client`, whose value can be anything (since nothing has been specified). The `&amp;` lets you create a type that combines requirements from two (or more) existing types. 
I think you‚Äôre wrong about that first part. `{ [clientId: string]: MyType }` defines a dictionary/hash object with dynamic string keys of `MyType` values. Not the return type of a function call. I agree with the second part, but here‚Äôs a bit more detail: `IConnection &amp; { client}` is an [intersection type](https://www.typescriptlang.org/docs/handbook/advanced-types.html) that *should* throw a compilation error in most cases because the type of `client` is not explicitly declared, it will be considered `any` if it compiles at all.
Great detailed response here for you OP. This is bad code IMO, the type of thing I'd block in a code review. Multiple better ways to express this that are more readable and therefore maintainable than this one-line wonder.
You're declaring an interface for an indexable type (i.e. for an object). The first part shows you the index signature. `[clientId: string]` means that your keys can be any string. The syntax seems weird at first but you could do a lot of things with it. You could do `[clientid in someList]` to indicate that the key has to be found in some whitelist that you provided,, or you could do `[clientId in keyof someObject]` to indicate that the keys in your object have to match one of the keys in some other object that you have. The second part is your value signature. The `&amp;` indicates an intersection type and all it means is that you want your value to have all the properties from IConnection plus one called "client".
like how ?, just curious
Awesome, thanks! Yeah the single line thing is exactly what I after after for some complex nested JSON I need to deal with. 
First of all { client: any } 
`any` is plugging holes in your type checking, so definitely do not use that if you can avoid it (like you can in this case). If conciseness is your goal, you can just not use TypeScript and skip the whole type annotations.
For anyone else who stumbles across here: it's in the documentation: [https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions](https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions)
Check out TypeStrict ‚Äî https://github.com/krzkaczor/TypeStrict It consists of various rules that improve type checking and catch bugs.
`&lt;any&gt;result` casts `result` to type `any`. You're basically saying to the compiler, trust me that the type of `result` should be `any`. That syntax actually isn't recommended anymore, since it looks similar to generics. Instead you should use `result as any`. 
How do you create an index signature while also having known index keys? Let's say I have an object that I know always has to have the keys identifier, Id and location. String, number and string array. And on top of that it can have any number of other string keys?
Tslint-config-airbnb is my favorite 
Generally, if you need to reuse a type, it should be given a name and made to be stand alone. In this case, formalizing the IClient interface.
Exact same syntax, specify your known ones, add an index signature for the rest.
I suppose with the lattest { client: unknown } üòâ
Wow, alright then. Thank you for all of your help. I'm looking at the code right now and it's a lot better than my un-maintainable mess. The only types that I know how to use decently are classes, functions and variables but you find more efficient ways to do that here. Will make a GitHub repository for this, thank you.
One more question, I promise. I'm only familar with node because I needed to have it in order to install TypeScript. As I recall though it is a backend server language, and this game I want to develop is going to be entirely on the front-end. How would I build my project on node and do I need to? Is Node an IDE or am I missing the point?
Hey, JojoMasterofDojo, just a quick heads-up: **familar** is actually spelled **familiar**. You can remember it by **ends with -iar**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
I have discussed the theoretical advantages, which sounds nice to the team - but not necessary. My point is to start adding it slowly and clearly demonstrate how its indespensible in our own codebase. They are not against it, but also sceptical about its benefits. 
node is simply a stand alone interpreter for javascript files. To run a file in node, just type in `node &lt;filename&gt;`. For now, you should concentrate on program logic, rather than interacting with the DOM and/or browser.
Read up on [Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html). That's pretty much what I mean by 'types'.
To start, this is amazing, love it. I've used / tried out all the various redux-typescript boilerplate reducer things, and have tried making my own. I was at a time doing something very similar to this but kept getting hung up on not being able to get it quite right and had to scrap it. This approach is pretty exactly what I would want for typescript with redux, simple, elegant, easy to use. It's pretty clear what is going on, single file simplicity. Will be using this over redoodle / alternatives going forwards, mostly because it is pretty much exactly what I was trying to get working myself, but just wasn't looking at it quite the way this library does.
`unknown` looks pretty cool. I'm disappointed to see `BigInt` was cut though.
Fortunately still on the [roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap) for 3.1 release.
Thanks
I find AirBnBs standards to have too much visual clutter. I prefer more spaces, fewer unnecessary characters (semi colons etc)
Decorators and classes exist in classic JavaScript too. Generics, enums, interfaces etc are all type features.
Yes, it certainly beats sprinkling `any` all over the place.
Google has an unofficial version right now that they use for their projects
I pair it with Prettier and forget all about that stuff. Ctrl+s will autoformat everything and it‚Äôs amazing. 
Technically it's called a "type assertion" rather than a "cast." In case anyone wants to google it, this should reduce confusion.
There is the in keyword for this situation: `type Foo = {` `[x: string]: number;` **//string key in type** `}` `interface Foo2 {` `[x: string]: number;` **//string key in interface** `}` `type Foo3 = {` `[x in 'hello' | 'world'| '!']: number;` **//union of strings key in type** `}` `interface Foo4 {` `[x in 'hello' | 'world'| '!']: number;` **//Error, invalid in interfaces apparently** `}`
Thanks so much for taking the time to focus on error messages this release, Daniel. It's been a real pain point for some of the more junior members of our team, and it would have been very easy for you to chalk it up to "complex types beget complex errors", so thanks again for doing the unsexy work (in comparison to the oh so sexy features you all have been including in every release)!
Relatively new to TS. The improved error message is a HUGE win for me. Thanks everyone!
I'm so happy to see that in the release notes. I've just tried to get used to the error messages bring so overwhelming. My junior dev friend loved the way the new errors look. I'm sure it'll help beginners a lot. I'm just hoping Angular gets support for 3.0 quickly.
This means so much to read! I particularly value UX improvements, and our experience speaking with users told us we needed to focus on UX this release. As much as I figured people would be delighted by the changes, the glowing feedback we've gotten has been surprising given that it's not what most people would consider "feature work". So thank you for writing this up. :)
kudos!
Not sure when it first appeared but I have to say the "Did you mean 'T'?" hint in an error message is pretty clever too.
Was wondering if `JSON.parse` would eventually change its return type to `unknown`?
Doubtful; that‚Äôd break a lot of people‚Äôs code in ways that‚Äôd make them frustrated with TS. Having a custom paste function though is now super-easy.
TypeScript 2.4 üòä
They unfortunately already mentioned that they will not change it to avoid the breaking change. You can override it with a local declaration file in your own projects tho.
Can you elaborate as to why it beats any?
Such a shame - I use strict mode precisely because I'd like warnings like this. Theoretically, my code shouldn't break since I'm already melding it to the correct type everywhere, but with `any`, it's not unlikely that I forgot in some places. Worst case, you can simply cast occurrences of `JSON.parse` to `any` everywhere in your code when migrating, and you'd be no worse off. But then, I guess the TypeScript team have a better idea of how TypeScript users are using it than I do.
`any` means you know what the type is (hopefully!) but you aren‚Äôt going to tell the compiler for whatever reason. `unknown` means you don‚Äôt know what the type is, but via narrowing the compiler will help you reason about the data regardless. I wouldn‚Äôt say one ‚Äúbeats‚Äù the other, but it‚Äôs definitely nice to have the two, rather than shoehorning the second use case into `any`, as had to be done previously. 
There are several occasions where TypeScript is intentionally not very type-safe, e.g. indexer return types not being implicit `undefined`. &gt; the TypeScript team have a better idea of how TypeScript users are using it than I do. I think they focus too much on not creating breaking changes and make it too easy to adapt for poor JavaScript code. I'd really wish for (even if optional) more strict compiler flags.
{}
just kidding! **{** **"jsRules": {** **"no-unused-expression": true,** **"no-var-keyword": true,** **"prefer-const": true,** **"no-duplicate-super": true,** **"no-duplicate-switch-case": true,** **"no-duplicate-imports": true,** **"no-duplicate-variable": true,** **"no-switch-case-fall-through": true,** **"no-string-throw": true,** **"prefer-object-spread": true,** **"triple-equals": \[true, "allow-null-check"\]** **},** **"rules": {** **"array-type": \[true, "array"\],** **"no-unused-expression": true,** **"no-var-keyword": true,** **"prefer-const": true,** **"no-duplicate-super": true,** **"no-duplicate-switch-case": true,** **"no-duplicate-imports": true,** **"no-duplicate-variable": true,** **"no-switch-case-fall-through": true,** **"no-string-throw": true,** **"prefer-object-spread": true,** **"triple-equals": \[true, "allow-null-check"\]** **}** **}** 
but why and where `T` was mutated to `never | never | never | 'updatePart'`?
Would be nice if that was an option, /u/danielrossenwasser
thank you so much!
I use a similar setup without much trouble, I would think it should be fine. I use npm-run-all instead of concurrently though. I've had trouble with servers hanging in the past on Windows using Git bash, but I think that was resolved after I updated Git for Windows.
Second that Daniel. You picked up on my comment to Basarat on Twitter about error messages to. #Respect
We wanted to enable this with `--strictAny` but then https://github.com/Microsoft/TypeScript/issues/24737
&gt; as had to be done previously. If you cared, you could have done `interface unknown {}`. As far as I can tell the effect is the same.
I think the easiest way to accomplish what you want is to serve your files via a server. One easy way to do this is to run ‚Äúpython -m SimpleHTTPServer‚Äù which will serve up the directory in which it sits. If you really want to ‚Äúcompile to a single distributable,‚Äù you might want to look into using Webpack instead of SystemJS, which you could leverage to inline all of your code and assets into one single html file. That makes it all sound simpler than it is. Good luck!
This is a CORs thing. Essentially, what you did would‚Äôve worked in years yonder, but is being blocked by security policies. (Which I believe you can disable with a flag in Chrome)
But why is something like module importing making web requests? Is there really no way to use the module syntax in TypeScript but have it ultimately compile down to one JavaScript file during the compilation process instead of importing at run-time? I guess I'm mostly confused because importing in other languages is a lot less cumbersome...at least when trying to write a web app that will simply live on a network drive somewhere and not be served from a server over http...
Yeah, try testing all your web apps on an http server. There are a lot of good options on npm, like http-server or local-web-server. That should help clear up the error you are seeing.
There used to be no module system in JavaScript.. for a long time. Multiple modules systems became popular, and now there's kinda support an official standard ([https://www.sitepoint.com/understanding-es6-modules/](https://www.sitepoint.com/understanding-es6-modules/)) The lack of an official standard is basically why it's so complicated right now. In the past you either eval'd new JS code, or appended &lt;script&gt; tags to the DOM which would then be evaluated globally. This is why stuff like JQuery doesn't use modules. It just namespaces itself globally. (as $) TypeScript doesn't want to compete with the ECMAScript standard... or all the others, but they do want to support existing module systems as best as they can. TypeScript doesn't want to be a module bundler. There's existing module bundlers that are very good at what they do. (Webpack, Closure, etc...) TypeScript will just compile down to whatever module system you tell it to. What you do with the compiled JS is up to you. So TLDR, you need a bundler, like the other comment said. What a bundler will do is take all your modules (which TypeScript outputs), and flatten it into a single file. No need to load SystemJS at that point. (Sometimes it still makes sense to flatten your project into a handful of modules instead of one, in which case you would still need to use some module loading system in place.)
Yup! And again it's important to realize the TypeScript itself is really playing a minimal role here. You'd run into the same problem with modules even if you weren't using TypeScript. Also the only reason your first example won't work is because of CORs. (For a good reason, do you really want any .html page you load locally from your filesystem to be able to arbitrarily load any file on your system?)
I understand the CORS issue, I guess my confusion stemmed from the fact that I didn't understand WHY a web request was being made at run-time for module loading. I thought it was something that was handled at compilation time by TypeScript, which is why I didn't bother serving the file from a server. But I think I understand what's going on a little more clearly...and I'm going to look into bundlers! Thanks very much for the help! You're the real MVP! Honestly, this whole situation had me quite distraught and discouraged this morning. I got pretty frustrated at how simple the tutorial made it seem and how much trouble I was having with it...
Just run tsc with different parameters. 
Hi Daniel, does the team have any opinions about how the Project references should coincide with Build servers/pipelines? My AWS CodeDeploy pipeline is triggered when I push a specific project to GitHub, so it does not have code access to the other projects (in my current paradigm). Is the project reference concept based off of any existing package management tools? The tool is very convenient but I wonder if the convenience is at odds with NPM or Yarn's package management?
If all your code is in one git repo - like `shared`/`server`/`client`, or like a Lerna-style monorepo, then project references will be useful. If not, then it sounds like you already have multiple projects published separately from separate repos. That might be a little more difficult, but if you'd like to DM me with specifics, I'd be happy to hear more about your setup.
Got it, thanks. I'm currently migrating a set of projects to the CodePipeline so I don't really have a setup right now, I'm just designing it. I believe that project references can replace lerna, right?
Absolutely not. TypeScript uses structural equality for the types. The interface you declared can be passed to any type, because **every type** implements an **empty** interface.
Thank you I will check that out and if I am unable to get it working I will have to rely on classic js.
I guess I should've clarified, these files are compiled TS files :P
I'd personally recommend the official handbook in the sidebar, it covers how the type system works under the hood enough for you to understand how to use it (e.g. it explains that due to how TS works there's no casting, merely assertion).
I don't have a video but I do have some slides about it [https://docs.google.com/presentation/d/1RoPd4zlNd8sIHPmkd0umlHvNU1Mp5Lu\_3SpUpoJZgCE/p](https://docs.google.com/presentation/d/1RoPd4zlNd8sIHPmkd0umlHvNU1Mp5Lu_3SpUpoJZgCE/edit?usp=sharing)resent Also a couple of videos that might help: \- [https://www.youtube.com/watch?v=CTpKZgy0dpo](https://www.youtube.com/watch?v=CTpKZgy0dpo) \- [https://www.youtube.com/watch?v=WkJagE7b5U0](https://www.youtube.com/watch?v=WkJagE7b5U0) If you want to contribute to the TS compiler check this out as well [https://dev.to/remojansen/learn-how-to-contribute-to-the-typescript-compiler-on-github-through-a-real-world-example-4df0](https://dev.to/remojansen/learn-how-to-contribute-to-the-typescript-compiler-on-github-through-a-real-world-example-4df0)
Would it be possible using a tsconfig setting? Or would that create too much fragmentation?
Right, I will give this a try. Cheers!
Thanks for the videos, I will check them out asap.
I'm not clear what you're saying. This doesn't work. ``` interface unk { } class Foo { prop: number } let x: unk = {}; let f: Foo = x; ``` There's a compiler on the last line. `Type 'unk' is not assignable to type 'Foo'. Property 'prop' is missing in type 'unk'.`
Oh, nice call. That works for me. Thanks. Also, thanks for showing that infer trick. I wasn't sure how to handle that either and was thinking I'd just end up using any or something but you managed to answer a question I didn't even ask. So thanks again.
&gt; type FunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]; &gt; interface Part { id: number; name: string; subparts: Part[]; updatePart(newName: string): void; } It's easier if you break it down into steps. I created a playground with this example for you: https://agentcooper.github.io/typescript-play/#code/PQKhCgAIUgVALAlgZ0iyB7ArgJzQOwAcsAXAOihGHEXxIFMcAzAQwGN7IAFFnEyAN5RIIxABMAXJHxYAtgCNGAbmEj8LWfSnISOWgHMVIkcizzCvEsik8+AbQC6R41kJiWDWyQAU+egHcAOQ0tSB09fH0ASikANwxxFQBfcHBQCGg4JFR0EnhOJloWABtIMXpkRH18MkgAGXoSAHJUeRx6FgBrNH5XCmhqEgBPQk4AMSx8NhJEDHwuHAxRviHgzWQAHlgAPkgAXkFVSDsAaQJITvohjCY4BylYU4dIegAPBnwxVAmpmbmjkQAfkgJwBkCkflijHASTsl2ut1gTlSaTAlEgY0QOB0kH8nFkLEIkDyiyw+ngkEIi2WMwqkBYnzC9E4-iQbApsRKWDpvAKk2ms3wyH6MAQ6Hy7Vx2GKYkg+kQUMgWFQAAMBGhJJBWMVkPQADTSEJSbW6g2mcyWaxakqmpVuDz0LxSXTcyBJFUiwYjTiwejFYoAWXoAHU2fAAGpcioAUXe9E+PwFc1g3q2uwOQmMxzOtAuVxudweTxecc+335f3wkGBLs4xpt9BhqWGozgAEZ9nA-YGQ2HI8VuchYx8xInKynRhsvNtUul0WMMHh6FCcENIJyB5w8h40KgWFqK4KDfLFZpiflKdTGMNDWeWMhKtV6LL-Ig8uf0BvuSKsuhX-65QVThlUgNUNQhZdGANdRNAglczTMCw+CtSEoLtdxPEsKQACJXAwx1LGwt0PUoL1WwASSYftuXI5AAHkmDHQUEHjCd6AAcSAoMWIWJZr1WEI007TNjFOc54QLJEixOZ43hHctfkFMFgVBLMRDg6EUnAFsfQAJk7SjqPoWiGKY5N8nwNjOKhbj8l4mkBM0KdLBnVEMhgABBAC8UgeAWEVEgMDKIL8Awfxd2JIL2hYWU8k4L8eUZXVOHgMLIAJfA1ypPi+EQOkfL8qEfzFVB-1KE9gNVVC8AAH2kSDavqldIDq3D7UwvhsI9LIrnpSU2AwBRaGfAhAsgAArZV+Da-CvGwvV0UUNgWGVTgGSGPIDEgABqUDqpVQCoVQSacU21BkEGxokEiT1tO9SBrPoIMvOKIzkDGRZZAWZdZmVABlBhCCEg5HgkxFkTu1tYAAZk7R7nv9N6PsG77Yl+5AAfoIHYF01y50yF7zwqThlqrRRIAGoa-FlWgxuwPAVTM+YrxWNYKgOglCFGWLvVunSMSKYoACUKiwYp+AOJn7P4tnNmnIA
It's more that we've never added a new strictness feature that wasn't under `--strict`, so it's questionable as to how much use this would get compared to the maintenance cost.
Understandable üëè error üëè messages üëè
If you first filter out the keys that you don't want, then your resulting type won't have those nasty `: never` properties either. And the `infer U` is pointless if you don't use `U`, so you can just use `any`. type OutputCallbackKeys&lt;T&gt; = { [K in keyof T]: T[K] extends EventEmitter&lt;any&gt; ? K : never }[keyof T]; type OutputCallbacks&lt;T&gt; = { [K in OutputCallbackKeys&lt;T&gt;]: T[K] extends EventEmitter&lt;infer U&gt; ? () =&gt; void : never; }; Example link: https://www.typescriptlang.org/play/#src=interface%20EventEmitter%3CT%3E%20%7B%20__eventEmitter%3A%20T%3B%20%7D%0D%0A%0D%0Atype%20OutputCallbackKeys%3CT%3E%20%3D%20%7B%20%5BK%20in%20keyof%20T%5D%3A%20T%5BK%5D%20extends%20EventEmitter%3Cany%3E%20%3F%20K%20%3A%20never%20%7D%5Bkeyof%20T%5D%3B%0D%0Atype%20OutputCallbacks%3CT%3E%20%3D%20%7B%20%5BK%20in%20OutputCallbackKeys%3CT%3E%5D%3A%20T%5BK%5D%20extends%20EventEmitter%3Cany%3E%20%3F%20()%20%3D%3E%20void%20%3A%20never%3B%20%7D%3B%0D%0A%0D%0Ainterface%20Test%20%7B%0D%0A%20%20%20%20foo%3A%20string%3B%0D%0A%20%20%20%20bar%3A%20EventEmitter%3Cstring%3E%3B%0D%0A%7D%0D%0A%0D%0Atype%20TestOutputCallbacks%20%3D%20OutputCallbacks%3CTest%3E%3B%0D%0A
As a top-level comment, so I'm sure you see it: type OutputCallbackKeys&lt;T&gt; = { [K in keyof T]: T[K] extends EventEmitter&lt;any&gt; ? K : never }[keyof T]; type OutputCallbacks&lt;T&gt; = { [K in OutputCallbackKeys&lt;T&gt;]: T[K] extends EventEmitter&lt;infer U&gt; ? () =&gt; void : never; };
Question 10 is **awful** code and I'm honestly shocked that this is even supported. It can lead to fallacy where you believe you have a value at runtime that you don't actually have. Another one of the type-traps of TypeScript. class Point { x: number; y: number; } interface Point3d extends Point { z: number; } const point3d: Point3d = { x: 0, y: 0, z: 0 }; const realPoint: Point = new Point(); const fakePoint: Point = point3d; // Will print true, as the "Point" is really a "Point"" instance. console.log(realPoint instanceof Point); // Will print false, as the "Point" is not really a "Point" instance. console.log(fakePoint instanceof Point); Besides, with the strict checks enabled the code won't even compile. The answer to question 17 is wrong. You can extend from a `type`, as long as it fulfills some requirements. This works just fine: type Foo = { a: string }; interface Bar extends Foo { b: string; } 
Agreed. The only difference I see is that unknown can't be assigned to an interface with all optional properties. 
Pretty sure this is the 'Generic Parameter Default' introduced in TypeScript 2.3. It means if you omit the T then the type of T will be 'any'.
`ForwardReference&lt;T = WithAName&gt;` sets a default generic type. If your example was `let a: ForwardReference = { forwardRef: myAnimal }`, it'd throw an error, but `let a: ForwardReference = { forwardRef: myX }` works just fine.
Oh, you're right. I tried compiling it with \`tsc\` instead of trusting the TSPlayground and it does give me an error that way. Thank you all for the reply.
I do this in 2 steps. First, I filter the keys I care about. Second, I use the filtered union of keys to create a mapped type. The second step is easy. For the first step, I do it like this: type FilteredKeys&lt;T, Criteria&gt; = {[K in keyof T]: T[K] extends Criteria ? K : never}[keyof T]; Basically, the value for each key is either the key itself (if it passes the filter) or else `never`. Then I subscript with `keyof T` to extract a union type. `never` magically disappears from union types, leaving only the keys that pass the filter.
I see what you are getting at. Sorry I misread your comment. I'll see what the errors look like with your method. It's definitely something to at least investigate. Thanks.
&gt; Does anybody know to change the project type from node.js to typescript? Typescript is a transpiler not a runtime. I suggest looking up what typescript actually is before trying to use it. 
Thank you for your insight, but I don't think you understood my question.
Then feel free to elaborate... 
Ah great, thank you
Is awesome-typescript-loader configured to load the imported module? (I'll call it "foo") What is the file extension of "foo"? What are the "include", "files", and "exlude" arrays in your tsconfig? You have "allowJs" set to false, meaning Typescript will not transpile .js files. You don't need babel for this, but you might need to tweak your awesome-typescript-loader configuration or your tsconfig to ensure that Typescript downlevels all the files you want converted to ES5.
Like everyone said, it's the default generic type [introduced in TypeScript 2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#generic-parameter-defaults). And you're right, I don't think it's the handbook. Might as well open a PR for that...
I'll experiment with allowJs set to true, for now because the modules are under my control I've just set their targets to ES5 also. The relevant parts of my Webpack config are: entry: { index: path.resolve(__dirname, '../src') }, output: { filename: 'assets/js/[name].[chunkhash].js', chunkFilename: 'assets/js/[name].[chunkhash].js', path: path.resolve(__dirname, '../public'), publicPath: '/' }, resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, module: { rules: [ { test: /\.tsx?$/, loader: 'awesome-typescript-loader', options: { errorAsWarnings: true, reportFiles: ['src/**/*.{ts,tsx}'] } } ] }
A reference app with `strict` mode not enabled? Really?
Oh? I thought it was enabled by default. I'll look into that. Thanks!
Now I‚Äôm realizing such a setting is a much better fit for ts-lint. :)
I really don't like \`--noImplicitAny\`. It gets annoying on arrow params.
Do you really have implicit any arrow params that often? If the type params can be infered, then it won't be implicit any.
Change the extension of your js files to ts. run `tsc --init` to create a tsconfig.json. Edit the config to your liking, then run `tsc` to compile your code.
couldn't start the server... no such file or directory, open './config.json' 
Oh, good catch! Just pushed a fix.
I found that arrow params sometimes can't be inferred if you pass them as a sibling argument to the one that has the source of the type info. For example using `_.filter(array, item =&gt; ...)` can't infer item from array because they're siblings. Pushing it down a level fixes this, which is why I like lodash's chain: `_.chain(array).filter(item =&gt; ...)` and now the parameter can be inferred from the function it's being passed to.
&gt; For example using _.filter(array, item =&gt; ...) can't infer item from array because they're siblings. Uhhh... This is not true. function filter&lt;T&gt;(array: T[], fn: (item: T) =&gt; boolean): T[] { return array.filter(fn); } const arr: number[] = [1, 2, 3]; filter(arr, /* item is inferred to be number here */) https://www.typescriptlang.org/play/#src=function%20filter%3CT%3E(array%3A%20T%5B%5D%2C%20fn%3A%20(item%3A%20T)%20%3D%3E%20boolean)%3A%20T%5B%5D%20%7B%0D%0A%20%20%20%20return%20array.filter(fn)%3B%0D%0A%7D%0D%0A%0D%0Aconst%20arr%3A%20number%5B%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0D%0A%0D%0Afilter(arr%2C%20%2F*%20item%20is%20inferred%20to%20be%20number%20here%20*%2F)%0D%0A
Oh! Neat. I wonder what I was running into then? I know I ran into something *like* this. Hmm. I'll circle back when I find out.
Yes it is although I like the idea of making a generic keys filter so I can just reuse it instead of defining a filter each time I might want to do this so thanks.
I used to use socket.io but discovered that it was actually a very heavy library with a lot of uneccessary abstraction for modern browsers. Using ws on node and plain WebSockets on the client is just about as easy and much more efficient.
I agree in general (except replace ws with uws for more efficiency). But socket.io does offer a few abstractions that are nice to not have to implement yourself. One example is replying to a message, which socket.io gives you for free, but is a bit involved to implement by yourself: https://github.com/sb-js/typescript-remote-functions
It really helped, thank you!
This really reminds me of ExtJS.
Oh... ExtJS was a nice framework once. Unfortunately they took a very different path which resulted many developers dislike the way ExtJS was licensed and distributed. 
Neat. I made a library that does something very similar to this a couple years ago. Using iterators/yield was _so_ much slower than just using arrays and not worrying about lazy execution. Wonder if that's changed with improvements to engines like V8.
I always run two. Never been much of a problem.
If you use npm-run-all you can fire up both watches in parallel with one npm command. "scripts" { "watch:foo": "tsc -w foo", "watch:bar": "tsc -w bar", "watch": "run-p watch:*" } $ npm run watch
&gt; If I specify "ES2015" as target, why are all consts still converted to vars? Are you sure you are specified `ES2015` as the target, and not `ES5`? Did you really set the `target` value to it, and not `lib`? Are you sure your tsconfig is used? Do you perhaps use additional tooling like Babel or Webpack? Because it works fine. - ES2015: https://agentcooper.github.io/typescript-play/?target=2#code/MYewdgzgLgBAtgUwhAhgcwQLhtATgSzDRgF4YByACwQBsaQYB3EXGgE3IG4AoUSEGggB09NAApEydAgCUnIA - ES5: https://agentcooper.github.io/typescript-play/?target=1#code/MYewdgzgLgBAtgUwhAhgcwQLhtATgSzDRgF4YByACwQBsaQYB3EXGgE3IG4AoUSEGggB09NAApEydAgCUnIA &gt; why does the following assignment not cause an error? It does, at least in my setup, using `@types/lodash` in version 4.14.116, `lodash` in 4.17.10 and TypeScript in 3.0.1, with all strict flags enabled. The code is: import * as _ from 'lodash'; function merge(num: number, str: string): string { return ''; } const curriedMerge: number = _.curryRight(merge); And the error is: &gt; index.ts(3,7): error TS2322: Type 'RightCurriedFunction2&lt;number, string, string&gt;' is not assignable to type 'number'.
Perhaps the [project references/composite projects](https://github.com/Microsoft/TypeScript/issues/3469#issuecomment-400439520) introduced in TypeScript 3.0 could do what you want? I did not check it out in detail myself yet, so I can't tell.
Yes, seems like `tsc -b --watch` does the job but it doesn't provide any output unless you specify `--verbose` and it feels like it's slower than two tsc instances. I will look into it more, thanks. I actually tried it before but I missed Build mode feature.
They definitely did not "go down", though. Their revenue has increased.
I understand. I really meant that a large number of single license developers left the platform and when the company was acquired many of core developers where let go. 
Yeah, I know. I used to consult ExtJS back when it wasn't Sencha. I'm not happy either, but we need to understand that business has different metrics than we developers do.
I agree :)
I think the latest TypeScript 3.0 added a new feature called project references that would help you compile like this. You should google the announcement and read if it would work for your project.
Thanks, yes they did. It's pretty cool stuff. My main issue at the moment is that I use cloud build pipelines and multi-repo architecture. So, it is difficult to use project references because my build tools only have access to one project at a time. I think that I'll switch to monorepo but both sides have pros/cons, so I'm still sorting it out
Happy to help, but I don't really understand what it is that you're trying to accomplish here. Personally, I'd just rewrite your tests manually in Jest.
I'm trying to avoid writing them manually, if possible. It seems to have mostly worked though I just have to fix our mocks 
oh okay, fair enough I hadn't heard of codemods before but having looked it up I am intrigued. On the one hand, I'm not a huge fan of performing operations automatically with tests because I think it's something that should be done manually be a human and thought through - on the other it sounds like you've already done that but you're just switching frameworks...
Yeah - its fine for small projects, but given we are a huge company and a huge part of the company, its not doing it for us.
You can easily change that with a tap output pipe, but my main issue is the diffing / jest you can run only failed tests, only tests that change rather than all the 500. also the diffing is huge, in our app.
Right, yeah - I guess. It just seems like unhelpful behaviour out of the box...
(not very experienced at it but...) jest seems to have really good "pluggability". You can do things like defining your own global testing functions. You probably wont be able to get away with refactoring nested tests, but that might cut a bit of the rewrites.
Ah, my import caused the lodash problem. With TS being a superset, I figured that of course Node-style requires will work. And maybe they do but TS isn't able to connect the type definitions if one imports a module like that? Anyway, I'll remember to use \`import\` with TS even if the target is Node, not the browser... But that const problem still persists: [https://github.com/s-h-a-d-o-w/ts-test](https://github.com/s-h-a-d-o-w/ts-test)
Seems nobody has read the title of your post. I'm not aware of any tools to automatically change from jest to tape, but I'll take tape over jest any day of the week.
&gt; But that const problem still persists: https://github.com/s-h-a-d-o-w/ts-test How are you compiling? I can't reproduce the issue you're mentioning. git clone https://github.com/s-h-a-d-o-w/ts-test.git cd ts-test yarn tsc And the created `index.js` has this content: "use strict"; const message = 'hello world'; console.log(message);
I have used Dart in the very beginning and did like the fact that I had to create all kinds of wrappers/interops for JS functionality. To me it was counter productive. Next to that, Dart felt like a completely new language to master at the time. With typescript you don't have these challenges (more or less) . I develop my code mostly in typescript. At the moment I am working on a large framework that is all written and tested in TS.
You wouldn't.
Besides the obvious fact Dart! is dead... Typescript is much closer to the actual language you're writing. Typescript embraces Javascript, making it more safe without trying to change it. Dart! performs much more magic, trying to hide you're actually writing Javascript.
TS builds on JavaScript and its benefits and language flaws. Same syntax, same data types, etc, etc. TS is basically just typing on top of JavaScript. Dart is a new language, which its own syntax and data types, features etc that does not exist in TypeScript. Dart is more Java-ish than Typescript, for example in JavaScript there is "undefined" and "null", while Dart only has "null". Here is a list of differences, language wise: [https://softwareengineering.stackexchange.com/questions/167070/differences-between-typescript-and-dart](https://softwareengineering.stackexchange.com/questions/167070/differences-between-typescript-and-dart) Like TypeScript, Dart can be used in both frontend and backend. If Dart is used in BE, it has its own platform, like Node.js. If you use Dart in front end you compile it with "dart2js". I agree on that the bridge between Dart and other JavaScript is a pain. TypeScript typings and regular JavaScript is annoying too, but Dart can be way more annoying to get right. But if you compare Dart vs JavaScript, Dart is, imo, a better designed language.
That's it! I wish that basic things like this would be highlighted in big red Warning boxes in any TS intro because it's kind of embarrassing to have to discover things like this. ;) Thank you very much!
No doubt - if you compare Dart with JS, Dart is MUCH better because it has types - (documentation, avoid errors at compile time and so on.) My problem with Dart is that it came up with the slogan "Batteries include" and this was true when it came out. Now languages like TS or JS have much more batteries included than Dart. My repo consists of more than 250k LO Dart-Code. I guess that 50% is just tools and frameworks I had to write because they did not exist for Dart. Darts JS-interop is still poor, C/C++ api support is from stone age... The worst thing - nobody is using it outside of Google. Another example: They removed mirrors/reflection Api from Dart 2.0 (for the web) without providing an alternative. OK - there are 2 or 3 community libs for this but nothing official for such a fundamental package. \&gt; Dart only has "null" These days a language should have a clear concept against "null" at all. (Kotlin) What I learned so far in TS is that "strictNullChecks" comes quit close to what I want. 
I have used all of them, Javascript, Typescript and Dart. I am not a fan of Javascript at all and I would avoid it at all cost. Currently on the project I am working on I am using Dart (specifically AngularDart) for web mostly because we use Flutter on mobile and we can reuse some code between web and mobile if we go with Dart on both of them. I also used Typescript in the past for React Native projects and I really liked it. From a web perspective, I liked more Typescript+React than AngularDart. It really helps that Typescript is a little bit closer to Javascript so you don't have to write/use so many wrappers. Also I really like React over Angular so maybe because of this I am a little biased. I would really like a nice Dart+React solution. There is [OverReact](https://github.com/Workiva/over_react) but it is not used by many people and it isn't backed by some big company like Goole/Facebook so I am a bit more sceptical. If I wouldn't have a Flutter mobile app I would go with Typescript, but because Flutter uses Dart it really helps using AngularDart because of code sharing.
&gt;did like the fact that I had to create all kinds of wrappers/interops for JS functionality you're missing a negation there
Typo fixed
Markdown files