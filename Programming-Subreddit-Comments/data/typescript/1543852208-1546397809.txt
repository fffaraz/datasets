&gt; I don't use full strict mode because sometimes I'm lazy and I just want to be that variable any or external packages don't have any typings. Those things don't exclude each other. You can use full strict mode and still use `any` or packages without types (then they're `any` as well).
I like JSON. Parsers are awesome and it is easy to use. Toml and yaml is not bad at all, until you get to the monstrosities like Amazon Cloudformation. It works, but it's horrible **imo**. I like Golang dsl's more, but Javascript api wrappers the best. Spent a day on Cloudformation, ran away. A few weeks on terraform, which admittedly is better. Nut just another annoying dsl to learn. None of the infrastructure as code languages (which are common) are nice to use. All of them sucks. JSON objects i can easily create, just provide me a first class library...
But you have to go add any type right? What's the benefit there. And If you eventually do add types, then the any would override actual types. Half of types just become unhelpful boiler plate, which is one of the reasons to use JavaScript. I like to make ts work for me, not the other way around..
It do be worth like that
You only have to add an explicit `any` type annotation if you enable the `noImplicitAny` flag, which is not automatically set by the `strict` flags.
I like that he does present some cons of ts. I have been working with ts for a while now and sometimes it's worth if the project scale is large enough. Anything from small to medium scale I will do in JavaScript though. Sometimes typescript type system is just more complicated than JavaScript as a whole. 
Yes.. specially the application is very large and many people of different experience levels working together. And also when you have to refactor some part of your project.. 
You aren't giving us all the code. `S[K]` isn't anywhere in your post. The return value of `combineReducers` is one function that outputs an object of objects. combineReducers({ a: () =&gt; ShapeA, b: () =&gt; ShapeB }); // returns: () =&gt; CombinedShape // where interface CombinedShape { a: ShapeA; b: ShapeB; } So given an object where each property is a function that returns _shape_, combineReducers returns a function that returns an object where each property is that respective _shape_.
Cool! Let us know how it works out. I'd love to see more of the requirements as well.
Sorry I tried to highlight that`S[K]` is in `ReducerMapObject` - maybe not easy to spot first off. And I appreciate _what_ it‚Äôs doing I just don‚Äôt get how it‚Äôs doing it. It feels to me like `S[K]` in `ReducerMapObject` - as mentioned - is a function type. But `Reducer` seems to be breaking it apart. What I actually think is happening is that the inference of `S` is being handed off all the way to reducer. But I can‚Äôt quite work out how it does that going through the `in keyof S` checks etc.
I find it amusing we still have this discussion. There are very few arguments to using Typescript. Actually..... There are none 
FYI your post formatting is different on mobile and not -- on not mobile the initial code block isn't rendering as a code block, so e.g. the definition of `ReducersMapObject` is wrong (so it's true `S[K]` doesn't appear in the post on not-mobile -- its fine on mobile). In terms of the question, the `S` in `combineReducers` is ultimately going to be the state shape. Take this for example: interface State { foo: { fooValue: number, ... }; bar: { barValue: string, ... }; } `ReducersMapObject&lt;State&gt;` is therefore `{ [K in keyof State]: Reducer&lt;State[K]&gt; }`. So each `K` will be a key of `State` (`keyof State === "foo"|"bar"`), and `State[K]` is just the corresponding value (`State["foo"] === { fooValue: number, ... }`). So `S[K]` will never refer to a function, it just refers to the shape of a particular value in the overall state. Does that make sense?
That's weird - I'll try and fix it but I'm on desktop now and it seems to be working fine! Will check. &amp;#x200B; That all makes sense but I still don't know where it infers the state shape from seen as I am \_passing\_ a function to combineReducers. In my mind you'd need to call \`ReturnType\` somewhere to infer the return type of the function that's being passed to combine reducers. I'm assuming ultimately that \`S\` gets inferred right at the bottom - in \`Reducer\` - and then that works its way back out somehow?
Have tried it?
Oh, it's only broken on \`old.reddit.com\` -- maybe OP of this thread is using old.reddit as well. &amp;#x200B; Ultimately I don't think the state shape will be inferred only with \`combineReducers\`. In my codebases I've always specified that generic (except for when working on middleware/code not-specific to the state shape). Not sure if it's helpful but I think these examples demonstrate some: [link](https://www.typescriptlang.org/play/#src=type%20Reducer%3CS%20%3D%20any%3E%20%3D%20(%0D%0A%20%20state%3A%20S%0D%0A)%20%3D%3E%20S%0D%0A%0D%0Atype%20ReducersMapObject%3CS%20%3D%20any%3E%20%3D%20%7B%0D%0A%20%20%5BK%20in%20keyof%20S%5D%3A%20Reducer%3CS%5BK%5D%3E%0D%0A%7D%0D%0A%0D%0Adeclare%20function%20combineReducers%3CS%3E(%0D%0A%20%20reducers%3A%20ReducersMapObject%3CS%3E%0D%0A)%3A%20Reducer%3CS%3E%0D%0A%0D%0A%0D%0A%0D%0Aconst%20a%20%3D%20combineReducers(%7B%0D%0A%20%20%20%20users%3A%20(state)%20%3D%3E%20%7B%20return%20state%3B%20%2F*%20returns%20the%20same%20type%20as%20the%20state%20parameter%20*%2F%20%7D%0D%0A%7D)%3B%0D%0A%0D%0Aconst%20a2%20%3D%20combineReducers(%7B%0D%0A%20%20%20%20users%3A%20(state%3A%20number)%20%3D%3E%20%7B%20return%20state%3B%20%2F*%20returns%20the%20same%20type%20as%20the%20state%20parameter%20*%2F%20%7D%0D%0A%7D)%3B%0D%0A%0D%0A%0D%0A%0D%0Ainterface%20UserState%20%7B%0D%0A%20%20%20%20users%3A%20%7B%20_users%3A%20string%5B%5D%20%7D%3B%0D%0A%7D%0D%0A%0D%0Aconst%20b%20%3D%20combineReducers%3CUserState%3E(%7B%0D%0A%20%20%20%20users%3A%20(state)%20%3D%3E%20%7B%20return%20state%3B%20%7D%2C%0D%0A%7D)%3B%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A) ‚Äã &amp;#x200B; If you check all compiler options it might make more sense. \`a\` is complaining about an implicit any, since tsc doesn't know what this function type should be. \`a2\` typechecks, and sees \`users\` maps to \`number -&gt; number\` since we explicitly specify this, so is ultimately of type \`Reducer&lt;{ users: number }&gt;\`. \`b\` typechecks and doesn't require casting of its argument, since that can be inferred since we're passing in the state shape at the top level. &amp;#x200B; I don't think it ever has to do \`ReturnType\` or any \`infer\` types since the reducer typings expect input and output to be the same. By specifying \`(state: number) =&gt; ...\` in \`a2\`, tsc can just check that return is \`number\`, it doesn't need to infer the return type. And in \`b\`, the required types are kind of handed to you from above.
Thanks, keep up the good work.
the most annoying strict flag is maybe \`noImplicitAny\`. Its a good shot for a lazy man: struct = true + noImplicitAny = false. Nowadays I work full strict, but recently I had to come back to an older project with the aforementioned config and writing things like \`type X = { name; age; gender; }\` is pleasant (of course it brings many ways to shoot on the foot).
to `NOT` using, you meant. lol
Wow, this is cool; I didn't know inference could do this. I'm guessing inference for mapped types understands when the keys are `keyof S` and the value types refer to `S[K]` since that's a common situation. * Infer set of keys from input object type. In this case, `'users'` * Infer value of each key by running inference algorithm against input expression against `Reducer&lt;Value&gt;`. So it it tries to match `Reducer&lt;Value&gt;` against `(state, action) =&gt; {}` And then it generates an inferred `S` using the set of inferred key-value pairs. What I don't know is: when does inference start to break down? Like, if I did `[K in Exclude&lt;keyof S, 'something'&gt;]` would it break? What are the limits?
I‚Äôm half following what you‚Äôre saying! Basically it seems to be doing some odd twisting inference, and then my question is the same as yours: when will it break?! And is there any documentation about how this works, because I can‚Äôt find it. Unless it‚Äôs all very obvious and I‚Äôm missing something ...
That is not my experience. In their docs, they also say that --strict does enable --noImplicitAny: https://www.typescriptlang.org/docs/handbook/compiler-options.html.
Imagine how clueless you'd have to be to suggest that. Try working on more than just a side project lol.
It's always worth it to have a machine check your work.
r/UnexpectedThanos
Here's a sneak peek of /r/UnexpectedThanos using the [top posts](https://np.reddit.com/r/UnexpectedThanos/top/?sort=top&amp;t=all) of all time! \#1: [Thanos comes to us all in the end!](https://i.redd.it/jegcv3exle111.jpg) | [24 comments](https://np.reddit.com/r/UnexpectedThanos/comments/8nsq20/thanos_comes_to_us_all_in_the_end/) \#2: [Damn](https://i.redd.it/c4qks6mcl8z01.jpg) | [26 comments](https://np.reddit.com/r/UnexpectedThanos/comments/8l26op/damn/) \#3: [Perfectly Balanced](https://i.redd.it/g3tjvim9h9z01.jpg) | [22 comments](https://np.reddit.com/r/UnexpectedThanos/comments/8l3lnf/perfectly_balanced/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
Have you thought of just doing \`Object.keys(someObjectThatImplementsMyInterface)\`? I can't imagine a scenario where you need the field names of an interface.
Thinking about it more I think I get what you mean, and yes the `S` gets inferred (in part) from within the `Reducer`. When you call `combineReducers({ ... })` with no specified generic and no default generic in the type, typescript will now try to infer that `S`. It knows that for each `keyof S`, it expects a value whose type is the value type of that key in `S`. So when you provide an actual object, like combineReducers({ users: (state: StateType) =&gt; state }) typescript knows to infer that `users` is a `keyof S`, and expects it to be mapped to a `Reducer&lt;S[K]&gt;`, the corresponding value type of this key in `S`. So it can now try to match the value to some `Reducer&lt;S[K]&gt;`. The specific function we provided here is `(s: StateType) =&gt; StateType`, which matches a `Reducer&lt;StateType&gt;`, so typescript can figure out that `S[K] = StateType`. So it can now finally infer `S` to be `{ users: StateType }`. &amp;#x200B; That said, I think it's still best to specify the type at the top level, e.g. `combineReducers&lt;RootState&gt;({ ... })`. By doing this, you're telling typescript all of `S`, so you can get type safety in all of your reducers without needing to specify argument types. It feels like it makes writing new reducers easier. &amp;#x200B;
There's a custom transformer to do it, but I don't have a link offhand. Google "ttypescript"; I think it's mentioned in the readme.
some refinement ```ts const tuple = &lt;T extends Literal[]&gt;(...args: T) =&gt; args type Literal = string | number | symbol | {} type Element&lt;T extends any[]&gt; = T[number] const PETS = tuple('cat', 'dog', 'horse') type Pet = Element&lt;typeof PETS&gt; ``` 
Damn it! To ***Not*** using it to be clear.
I've required something similar to that. Kinda like reified types. What I do is I describe a type using schema builder functions and let typescript under the type of the objects of that schema. Check out the "Type safe object validation" section of [this](https://medium.com/@dhruvrajvanshi/advanced-typescript-patterns-6cf8826c7944) article I wrote a while ago. Because your types are now reified, you can do all sorts of meta programming like generating serializers/deserializers and such.
There's two ways you can do this. The first I believe is using a static method. In your Car class modify the method definition of `getDescription()` to `static getDescription()`. You may need to check if `this.brand` and `this.model` are empty and substitute with a default value since they may or may not be empty when you call `getDescription()`. The second option is using a `getter`. Change to `getDescription()` to `get description ()`. Then example usage looks like so in your TSX file: ``` render() { &lt;div&gt;{this.props.car.description}&lt;/div&gt; } ``` Again, you might have to check if brand and model are empty and return empty strings as the default value. I think using a getter better fits your needs then a static method but that's just my opinion. 
I‚Äôm half following what you‚Äôre saying! Basically it seems to be doing some odd twisting inference, and then my question is the same as yours: when will it break?! And is there any documentation about how this works, because I can‚Äôt find it. Unless it‚Äôs all very obvious and I‚Äôm missing something ...
Awesome, thanks. But I'm still unclear about how we would actually get an instance of the Car class without doing `new Car()` and having a constructor? This would be in the scenario where we aren't passing a prop through. I know that some frameworks in java/groovy do this for free
I noticed something interesting here. `1: (e, f, s) =&gt; { return (s.direction = 'up', 2); }, // Can only go up` Returning `(s.direction = 'up', 2)` appears to modify the extra state passed in and actually return 2. Is this a null coalescing syntax? I can't seem to find documentation for this behaviour. 
&gt; Have you thought of just doing Object.keys(someObjectThatImplementsMyInterface) He apparently wants the keys as defined by the type-system, but `Object.keys` will only provide the keys of actually set values and will ignore symbol properties. Classes will not help here either, symbols and unset optional properties will be missing.
It's some "clever" code that translates to (e, f, s) =&gt; { s.direction = 'up'; return 2; }; Further explanation here http://es5.github.io/#x11.14 It might be clever and save some characters, but it's just terrible, confusing and less readable.
Yeah, the comma operator just evaluated each expression and returns the right-most expression. It should be reserved for compiler output IMO (you‚Äôll see it loads in Babel output). It‚Äôs not good for readability. Looks an awful lot like returning a tulle, but it does nothing of the sort.
Can you even use `this` in static function?
I guess inference is really just pattern matching, but I don't know if that helps us understand what typescript is doing. I've always experimented to figure out what works and what doesn't, which isn't too bad with the language service tooltips. I know TS internally has this concept of iso&lt;something&gt; mapped types where every key comes from the same source interface. (I forget the word for it). When it detects this, the optional and read only flags are copied from source to mapped properties. Maybe inference does something similar but in the opposite direction with its pattern matching?
Another caveat is that if you have let x: Base = new Derived Object.keys(x) will return the runtime keys found on Derived, while something based on types will only have they keys found on Base.
Yes I see. Abstract classes don't compile their fields. I'm confident the OP knew that `Object.keys` only gives set keys.
I am little confused as to where exactly the issue is you are running into. Can you try to make a codesandbox of the example app you are having trouble with? Is this a mere typing issue? Essentially whatever component consumes the car prop then it will make assumptions about the shape of the object defined by the prop types. All you have to do is pass the car object as a prop to the consuming component either via creating it by the \`new\` keyword or creating it via an anonymous object like you described in your spit balling example. codesandbox for ts+react: [https://codesandbox.io/s/react-ts](https://codesandbox.io/s/react-ts) I created a codesandbox that implements the way you describe in the original post and it seems to work fine. [https://codesandbox.io/s/k2lj6ovnwr](https://codesandbox.io/s/k2lj6ovnwr)
&gt; Have you thought of just doing Object.keys(someObjectThatImplementsMyInterface)? Yes. There's a few things I don't like about this. It adds a lot of code bloat as every interface needs a sample implementation alongside it. Additionally two sources of truth leave an opportunity for the type definition to be out of sync. &gt;I can't imagine a scenario where you need the field names of an interface. My main one is when pulling data from 'untrusted' places like HTTP requests or databases. It would be nice to have run-time interface information available for object validation or mapping. &gt;An interface is not code. Sure it is 
Also take a look at [XState](https://xstate.js.org/docs/) if you're interested in state machines for Typescript.
Thanks for posting this opportunity. Are you seeking primarily juniors, seniors, or a mix? San Francisco is known for its high cost of living -- one of the highest in the country! What is the pay scale to accommodate the increase for anyone moving to that area? Is the position long-term salaried or a contract position? Is it a job an interviewer should anticipate working until retirement?
\- We're open to both juniors and seniors, and we've hired both in the past. \- It's hard to give exact figures because we're open to a wide range of people, but we pay in the low to middle-upper 100K range. \- This is a long-term salaried position. \- We're a young startup (a little over a year old, just got our first three customers). As such, I really can't promise working here until retirement (I'm not even sure a company like Apple or Microsoft could promise that with &gt;90% confidence, if you're e.g. 25 now and planning to retire at 65). Ideally we're so successful that everyone can retire early though :)
I do not exactly understand what you mean, but maybe [NestJs](http://nestjs.com) is what you‚Äôre looking for.
I mean I'm building frontend in typescript + react and want to choose the most suitable backend for it As of nestjs, from the first glance it seemed too verbose to me, but I will try it if I dont find anything better
Just plain old express. Has typings and its mature for production use.
If you need to track state, use a class that can be instantiated. If it's just utility functions, just export the functions. 
Hmm &amp;#x200B; After reviewing express' typing I feel like it's easier to use it in plain js and to ensure correctness with tests, primarily because of things like \`query: any, params: any\` &amp;#x200B; Anyway, the main point is to generate types for frontend automatically, express by itself doesn't bring anything about it.
Is this good practice? how does useState make it immutable? 
I've used [ts-express-decorators](https://tsed.io/tutorials/swagger.html) for quite a few projects now. It's quite good. Didn't really like the ergonomics of nest.js, though I can see why it's the bees knees for many. There's a few typescript interface generators that accept swagger JSON. Not hard to make yourself, so use whatever you like.
Check out [ts-app](https://github.com/lukeautry/ts-app). It's less of a framework and more of a boilerplate, but it should be pretty easy to get started with.
Check out [ts-app](https://github.com/lukeautry/ts-app). It's less of a framework and more of a boilerplate, but it should be pretty easy to get started with.
Immutable?
&gt; immutable ReactJs is never meant to directly mutate the state, therefor is immutable. Is this how useState works?
Hey, AllHailTheCATS, just a quick heads-up: **therefor** is actually spelled **therefore**. You can remember it by **ends with -fore**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
hEy, AlLhAiLtHeCaTs, JuSt a qUiCk hEaDs-uP: **tHeReFoR** Is aCtUaLlY SpElLeD **ThErEfOrE**. yOu cAn rEmEmBeR It bY **EnDs wItH -fOrE**. hAvE A NiCe dAy! ^^^^tHe ^^^^pArEnT ^^^^CoMmEnTeR ^^^^CaN ^^^^RePlY ^^^^WiTh ^^^^'DeLeTe' ^^^^To ^^^^dElEtE ^^^^ThIs ^^^^cOmMeNt.
What if you didn't? We live in an age of spellcheck, so there's realy no poin in correctong people. How bout you mind your own buisness? ^^bleep, ^^bloop. ^^I'm ^^a ^^bot.
Don't even think about it.
Hey, ThisIsAdolfHitlerAMA, just a quick heads-up: **buisness** is actually spelled **business**. You can remember it by **begins with busi-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
hEy, ThIsIsAdOlFhItLeRaMa, JuSt a qUiCk hEaDs-uP: **bUiSnEsS** Is aCtUaLlY SpElLeD **BuSiNeSs**. YoU CaN ReMeMbEr iT By **bEgInS WiTh bUsI-**. HaVe a nIcE DaY! ^^^^ThE ^^^^PaReNt ^^^^cOmMeNtEr ^^^^cAn ^^^^rEpLy ^^^^wItH ^^^^'dElEtE' ^^^^tO ^^^^DeLeTe ^^^^tHiS ^^^^CoMmEnT.
dOn't eVeN ThInK AbOuT It.
Don't even think about it.
dOn't eVeN ThInK AbOuT It.
Yep
It's definitely good practice But you can also choose to continue using class components, there's no plans to remove them from react
Thanks, I'll definitely play around with it and nest.js!
Sounds cool, I'll investigate this one thoroughly
I;m really old. Never have I seen this done in a more clever, terrible, confusing and unreadable way. props john-j.
No, you can't use `this` in a static function.
If you generate a swagger-sdk using swagger code gen from a swagger file, you can actually reuse the types in express or any typed node project to guarantee the responses match the swagger file, and you get a free typed sdk for the client side to use. &amp;#x200B;
I wrote my own, but it's pretty simple. &amp;#x200B; The main point is that the typescript front and backend share the code where the remotely callable methods are declared. &amp;#x200B; This way it's 100% type safe. (although validation is still required, because the client can send anything, and it's a bit of a pain in the ass). &amp;#x200B; I use jsonrpc over websocket for all of this. Http just has too much overhead for my tiny calls.
Query and params are any because their types are both determined during runtime, and TS is only a thing prior to transpiration. 
Classic proggit. Where is your solution? I'd like to shit on it if you don't mind.
Right now it works very similar to a key value store on S3 or compatible storage. I am currently working on collection indexes for querying 
Rolled my own a while ago :( I get ya. Id love to find a mature solution where you declare types and endpoints at the same place and could integrate that into the frontend
Not sure about courses/confs ... but this guide was very helpful for me: https://basarat.gitbooks.io/typescript/
I mean you could do things like Handler&lt;Query, Params&gt; to get typed handlers, as well as app.get&lt;{ userId: string }&gt;, that way errors would be a lot less likely.
Yeah that's what Im looking for too Technically, these decorators-based solutions like nestjs provide it (since you can generate swagger.json based on you server code). The only thing is their approach &amp; code style are very different from mine, that's why I'm not very eager to use it.
Yeah, that's definitely a valid option, thx
The problem would be that nothing would stop an end user from submitting any query parameters that they want. The correct typing for the query parameters in modern TS would be `unknown`, but a pull request for updating to that is stalled because many people are still using versions without support for that. I would recommend that you use the `is-my-json-valid` package to validate the query parameters first, which would then give you a proper type automatically when coupled with an `if`-guard: const createValidator = require('is-my-json-valid') const validateQuery = createValidator({ type: 'object', properties: { userId: { type: 'string' } }, required: [ 'userId' ] } // ... app.get('/foo', (req, res, next) =&gt; { // req.query == any if (!validateQuery(req.query)) { return next(createError(400)) } // req.query == { userId: string } }) (Typed this out in mobile so probably a few errors üòÖ)
What language are you using for the front-end? Because if you use TypeScript you can just use the same types on the front-end and back-end, effectively making them always in sync and you'll also not need any code generation tool like swagger.
To actually answer your question, and not just complain about spelling: ReactJS isn't necessarily immutable - you can use it with mutable data, although it's inevitable harder to keep track of things when you're doing that. The `useState` function is a bit of magic that mimics the functional flow of data. It can be used with both immutable and mutable data, just like setState. Essentially, when you call the function the first time in an app (i.e. the first time the component is rendered) `useState` registers itself, and returns the default value. Every time after that (so on every render) it returns the registered value - either the default value, or a new value if the `set*` function has been called. The `set*` function simply sets the value, and tells React that a change has occurred in this component. Internally, it's mutating state, but internally all React changes mutate state in some way or other. However, from the developer's perspective, it can be used in mutable or immutable way, just like `setState`.
Surely end user can submit whatever he/she wants, but with `any` you don't use types even for correct paramethers. What I would use is stuff like `Handler&lt;Query, Params&gt;` and then checking input with tool like https://github.com/woutervh-/typescript-is, as simple as ``` const getUser: Handler&lt;GetUserQuery, GetUserParams&gt; = async (req, res) =&gt; { if (!is&lt;GetUserQuery&gt;(req.query) || !is&lt;GetUserParams&gt;(req.params)) { throw new Error('Wrong input') } } ``` which would reduce boilerplate drastically
Ty im reading it rn
Yep I'm using typescript. So let's say I have 2 repos: `front` and `back`. How can I consistently share types between them so that it never happens that back &amp; front use different versions of types? In case of code generation I could just generate types as part of CI. That said, maybe the simplicity of just sharing types is worth having a monorepo with both back &amp; front, not sure.
There are multiple solutions available for you, but what you want is not possible (well... it is with ugly hacks but please dont) There are some options available for you: First, `const car : Car = {brand:'Mercedes', model:'X6'}` this is a lie. A variable typed `car` with type `Car` should be an instance of `Car`, but instead you're giving it an plain object with properties `brand` and `model` - it is not a `Car`. That `car` is likely data imported from an API, so you could convert your `{brand,model}` object received from the server to a `Car` instance by `new Car()` before passing it to your views. That way, you have your `Car` with `brand`, `model` and `description` as defined in your class. Another option is to not have `Car` be a class, but make it an interface or type. (IE `type Car = {brand: string, model: string}`) Then you create a class, module or set of functions that generate a description based on your object. Example: `getCarDescription(car: Car): string { return car.brand + " " + car.model; }`. 
Was just coming here to ask the same question.
!remindme 9h
I will be messaging you on [**2018-12-06 00:48:04 UTC**](http://www.wolframalpha.com/input/?i=2018-12-06 00:48:04 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/typescript/comments/a3d46n/how_do_you_generate_your_typescript_docs/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/typescript/comments/a3d46n/how_do_you_generate_your_typescript_docs/]%0A%0ARemindMe! 9h) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
[I posted this same question recently](https://www.reddit.com/r/typescript/comments/9zpdzs/what_are_some_good_ways_to_generate_typescript/), and the answer is basically "there isn't a good way." Every option has problems, but Typedoc is the best (unfortunately). Here's my experience, from best to worst: [typedoc](http://typedoc.org) Still the best of them all, even with the issues. - produces the most accurate and correct documentation, but also is the least human friendly to read. - The templating system uses handlebars for some obnoxious reason, which makes it a pain in the ass to customize. - It doesn't support extra Markdown files, so you can't build in extra documentation like almost every other doc generator. - Poorly documented; there's a lot of features (like groups) that you can only find out about by stumbling onto the pull request. - It can, however, write to json file instead of HTML, which is way more accurate than any other generator. I think the best thing to do would be to take the typedoc output and use it to build your own documentation, like these people: [Article 1](https://blog.ironcorelabs.com/create-beautiful-documentation-7c66a2c5fa19) [Article 2](https://blog.cloudflare.com/generating-documentation-for-typescript-projects/) [compodoc](https://compodoc.app/) I wanted to like it, but it just had too many problems. - produces the nicest **looking** documentation but produces some of the least useful actual documentation. A lot of incorrect or missing information especially for types. - It's very Angular-specific, though I was able to generate nice documentation with a library. - There's also some UX problems (e.g. the constantly unrolling sidebar is so annoying). [documentalist](https://github.com/palantir/documentalist/) Basically typedoc, but worse. - this is basically an internal tool used for an internally specific purpose that got released. it would take a lot of work to make it useful for anyone else, imo. - it only generates a json file, but it's worse and less accurate than typedoc's - it does come with a pre-built pug generator for the json, but the result is hideous, and the json is actually missing some necessary data. - it's really poorly documented, so if you run into any issues, good luck! [esdoc with typescript plugin](https://github.com/esdoc/esdoc-plugins/tree/master/esdoc-typescript-plugin) It's still "proof of concept" and has so many problems I'm not going to bother to write them out. It's not at all useful for TS documentation in its current state. 
You can use `Object.assign` and it will combine the types as you'd like. If that's all your `combineThings` is doing, then you don't have to write extra code! If you need more, you can check out the code for it to see how they typed `Object.assign`. I believe it's with an overload, as I don't think TypeScript can combine based on variadic types [yet](https://github.com/Microsoft/TypeScript/issues/5453). const foo = new Foo(); const bar = new Bar(); const bam = new Bam(); const combined = Object.assign({}, foo, bar, bam) // combined is Foo &amp; Bar &amp; Bam
I would recommend a monorepo. If you really want two repos, I guess you can separate the types into a package and import them in both places.
I think monorepo is the only valid option :C Because if I separate types into a package o user git submodules, there can be a situation when backend uses e.g. `types@2.1.1`, and front uses `types@1.9.0`
Change `const counts = {};` to `const counts: Record&lt;string, number&gt; = {};`
the Object.values call doesn't know what the type is for each field of counts since you didn't give that object an explicit type. const counts: { [key as string]: number } = {}; will probably fix the problem.
`typescript-is` is cool bit requires a separate build step which can be a bit of a hassle. Still, you should be able to use your code without adding `&lt;Query, Params&gt;`, right? After your `if` statement `req.query` should typed as `GetUserQuery`. I would even argue that it‚Äôs more correct to have `req.query` types as `any`/`unknown` before that `if` guard, since it isn‚Äôt know to be a `GetUserQuery` before that!
It doesn't need to be versioned, you can have a local package that is installed with npm link, but I agree that a monorepo is the most sensible option.
Really guys??? function foo1&lt;T&gt;(t: T, obj1: { a: string }, obj2: { b: string }) { return { ...obj1, x: 1, ...t, ...obj2, y: 2 }; // { a: string, x: number } &amp; T &amp; { b: string, y: number } } Are all the cool features already implemented that they have time for such constructs? &amp;#x200B;
Ah, yep that's all it took. Thank you!
Thank you! What's the difference in declaring it as a Record, vs what the other answer suggests?
This is a good write-up of existing solutions. The thing I'm struggling with is this: what do people actually want out of autogenerated documentation? * Who is the consumer? Is this for developers that will be maintaining the code? Is it for external devs that will be calling into the library? * What do the consumers need to know about the code? 
I'm not sure exactly what `Object.assign` does and does not assign, but I'm sure class methods are non-enumerable properties in the prototype chain, and I'm also pretty sure `Object.assign` does not assign non-enumerable properties and/or prototype properties. ```` $ node &gt; class Foo { ... bar() {return 1} ... } undefined &gt; const foo = new Foo() undefined &gt; foo.bar() 1 &gt; const bam = Object.assign({}, foo) undefined &gt; bam.bar() TypeError: bam.bar is not a function ```
Record&lt;T, U&gt; is just a type alias for { [key: T]: U }, though in the specific case of Record, T is restricted to strings. In a lot of my company's codebase, we use keys of type number rather than string, so I don't generally use it on a regular basis.
Yeah I'm pretty much convinced by now, it was just the thing that surprised me a lot - coming from react, where parametherized functions are used heavily
Though the example doesn't make it super clear, proper typing when combining generics and object spread is definitely important language feature. This is especially true when maintaining library methods that are meant to be flexible with user data that is somewhat unpredictable in shape. I personally have been waiting on this feature for quite a while.
A prototype basically just is another object on which you can also use object assign to merge it
Buy a computer from Dell and add bits to the BOM :)
That's awesome! UI driven auto-complete!
This could become a complete game changer... 
T isn't actually restricted to string unless you're using an older version of Typescript. It can also take number and Symbol. It's a nice change.
* There isn't any really. Though, with Record, it's easier (in my opinion) to limit what keys are allowed. For example, you could have `Record&lt;keyof YourTypeHere, number&gt;` or `Record&lt;'a' | 'b', number&gt;`.
It depends what your goal is. If you want to offer type checking for the consumers of your SDK, type definition files is enough. If you want to have your checking within your own library, convert your existing code to Typescript. 
Yeah, you're right, it doesn't do all of that. As I mentioned, if you need more than Object.assign can do, you can look at the code for it for reference in writing your own method. [Here's the type definition](https://github.com/Microsoft/TypeScript/blob/68ce69a/src/lib/es2015.core.d.ts#L266), it is using overloads. You can write your combineThings in a similar way: combineThings&lt;T, U&gt;(thing1: T, thing2: U): T &amp; U; combineThings&lt;T, U, V&gt;(thing1: T, thing2: U, thing3: V): T &amp; U &amp; V; combineThings&lt;T, U, V, W&gt;(thing1: T, thing2: U, thing3: V, thing4: W): T &amp; U &amp; V &amp; W;
Most of the documentation generated for programming APIs is about implementation. However, almost always, the consumers of documentation just want to know what it does and how it works. Documentation should focus on *how to use it* not *how it is implemented*. Most API references get this totally wrong. Elixir is a great example for how to do this correctly. Elixir considers documentation just as important as code, and it really shows, it has aesthetically accessible, simple, and very readable documentation. [This example](https://hexdocs.pm/elixir/List.html#myers_difference/2) is simple, explains what it needs to, and you can infer any extra information you need from the function signature. The usage is explained in plain English - no need to parse six different data points to understand it. Contrast that with something like [this](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.add?view=netframework-4.7.2#System_Collections_Generic_List_1_Add__0_) from C#. It's almost all about the *implementation*, not the *usage*. Before you even get to the usage, you have namespaces, assemblies, parameters, the interface it implements. Some user experience design could improve this a bit: 1) it's extremely unlikely you care what namespace or assembly it's in, that shouldn't be right next to the headline. 2) The parameters, description, and "Implements" can be described in plain english or included in a table to the side where it's out of prime viewing space. 3) Etc. I've been studying what makes good documentation a lot lately, I hope this long-winded reply answers your question!
I think this is all fair and true. Usage is what any consumer looks for first. The problem is that usage is not something that really can be autogenerated; it needs to be handwritten by a person that more or less understands the likely usage scenarios.
[https://stackoverflow.com/questions/53644893/property-password-does-not-exists-on-type-document](https://stackoverflow.com/questions/53644893/property-password-does-not-exists-on-type-document)
The only real disadvantage to the types file is you need to make sure to maintain it with api changes, whereas if it was written in typescript, it would automatically keep pace with code changes 
A prototype is, but class methods (IE functions as properties on the prototype objects) are not enumerable properties in &gt;=ES6 targets. Only if you're using the ES5 target, you can enumerate on the class methods, but that is a wrong implementation of the typescript to ES5 conversion at worst &amp; considered undefined behaviour at best. I also actually tested this: Object.assign does not assign my class methods
Thank you :) That works. Not ideal, but good enough
&lt;3 Thank you Microsoft for making Javascript 10% more awesome
Sorry I missed that, the formatting in the OP is broken, it's hard to tell! Why isn't it ideal? This method is pretty standard. 
I just thought of something else. Wouldn't the consumers of my SDK not be able to use the models? They would be type-checked when calling a method but wouldn't be able to import those models as say types for their own functions, right? 
Don't treat the accumulator in a reduce as immutable, just push into the array. It's inefficient, producing lots of garbage for large arrays, and achieves nothing.
Okay, this is epic.
You can export the models as interfaces. 
Why.
Not a word on privacy, though üòï. Created GitHub issue [intellicode #25 - README: privacy practices need documentation #25](https://github.com/MicrosoftDocs/intellicode/issues/25)
Because: why not. Just for fun üòé 
Lol the package isn't typed!
Let's fix this with a nice PR ;) 
So, you're contributing to the annoying micro-packages that are rampant on npm? Cool. /s
I've been laughing about this exchange for several minutes. Really hits home.
You set your user variable to this. Does this have a password property? It looks like it does not.
Nobody's forcing you to use it. No need to go around throwing shade at those of us that do publish and/or consume "micro-packages".
 Check your user class for passowrd property. Looks like it is missing there
I'll leave it as an exercise for the maintainer. Create a file color.d.ts with contents: declare const _default: '#007ACC' export = _default This types the default export as a string literal. Add a line to your package.json: `"types": "color.d.ts",`. And for extra credit add a file example.ts with contents: import blue = require('.')
Asking to do a PR is the open source equivalent of saying "fuck off". Just because you put some code online, doesnt mean that a) someone will use it or b) someone will contribute. You dont care enough about the package to maintain it, yet you expect others to maintain it for you? In your own words, _do a PR_.
Oh, nice. We're still stuck using 2.7 which is why I thought that. It is a cleaner look from all the brackets.
Do not set your variables to \`this\`, ever. &amp;#x200B; You should be passing along the user property from the receiving function to this function.
At first I‚Äôd like to tell that this package is a humorous thing - don‚Äôt be so serious! ;) Secondly I appreciate the comment of @son_of_meat, and I‚Äôll implement it. I definitely didn‚Äôt mean to say ‚Äúfuck off‚Äù that‚Äôs why used form ‚Äúlet‚Äôs‚Äù, I care about my packages and I like to maintain them by myself - not by giving orders to others! Have a nice day üòé
Yes they are. That's the whole point.
Weird that TS gives an error. It doesn't know what \`this\` will even be, it's definitely not always \`Document\`.
If it's supposed to be humorous you might want to try being actually funny, like is-thirteen, instead of spamming le epic cool face emoji and claiming it's humour.
Hey, that's pretty good!
Thanks
Anyone interested in contributing to a typescript-red fork?
Why do you want to do this? Would the Singleton pattern work?
[Doesn't error for me](https://www.typescriptlang.org/play/index.html#src=function%20createInstance(ref%3A%20any)%20%7B%0D%0A%20%20%20%20let%20instance%20%3D%20new%20(ref)()%3B%0D%0A%0D%0A%20%20%20%20return%20instance%3B%0D%0A%7D%0D%0A%0D%0Aclass%20Thing%20%7B%0D%0A%20%20foo%20%3D%20%22%22%0D%0A%7D%0D%0A%0D%0Aconst%20a%20%3D%20createInstance(Thing))
 interface ClassType { new(...args: any[]): any; } function createInstance(Class: ClassType) { return new Class(); } 
Same. I'm old and think he's using a sledgehammer. But on the other hand he nailed it. It's just nothing is universal - one size doesn't fit all. Would like to hear what you think David?
As the original commenter, I interpreted OPs reply as a tongue-in-cheek "PRs are welcome". As it turns out though in the last few weeks Ive been learning how to write .d.ts type declarations. (So far three PRs accepted to DefinitelyTyped for "micro-packages" so detested by this sub.) I actually would have submitted a PR to OPs repo but thought it would be a fun teaching moment. 
I want to write a blog post about TypeScript and so I use this package to pull in the color and logo. Id say it's not uncommon for OSS organizations to publish things like their logo and color scheme for more consistent branding in their impressions across the web. 
I'll risk my karma by saying no they're not. you can write a program that walks your dependency tree and raises a warning if it finds any "micro packages". Just don't publish your program to npm, and if you do don't tell this sub about it unless you have karma to burn. 
Kys 
You're right, I could change that - although most of devs I know use git bash, windows linux shell or sth like that and that supports grep plus many other popular commands built-in.
Yes, they are. Ever heard of [repeating](https://github.com/sindresorhus/repeating)? Probably not. It's a package that repeats a string by a given number. Even the developer admits that it's pointless now that `String.prototype.repeat` is a thing. It's an ES6 feature, so Babel has it covered. No one needs `repeating` anymore. Now fire up a brand new React app: ``` npx create-react-app my-app ``` Once it installs, go and see if it installs repeating. It didn't, right? ``` cd my-app npm ls repeating ``` Wrong. ``` ‚îî‚îÄ‚î¨ react-scripts@2.1.1 ‚îî‚îÄ‚î¨ babel-jest@23.6.0 ‚îî‚îÄ‚î¨ babel-plugin-istanbul@4.1.6 ‚îî‚îÄ‚î¨ istanbul-lib-instrument@1.10.2 ‚îî‚îÄ‚î¨ babel-generator@6.26.1 ‚îî‚îÄ‚î¨ detect-indent@4.0.0 ‚îî‚îÄ‚îÄ repeating@2.0.1 ``` It's a dependency of some other dependency of Babel internals for a code coverage library that we don't even use. This does not imply that the repeating dev (ya boi Sindre Sorhus), the Create React App team or the Babel team are bad developers. They're all incredible developers; I have nothing but respect for them. But by using the tools they've built, I've installed something I don't need. Even the guy who built the thing openly admits I don't need it. And there's nothing I can do about it.
This module does not even do it correctly on windows; it wouldn't work most of the time without third party tools installed. You'd spend as much time debugging it then you would have just researching it in the first place.
I appreciate the thoughtful response. If you don't have to deal with legacy systems that run on absurdly old versions of software/hardware, you're lucky. That does not mean that no one has to deal with those systems. I worked with a mainframe recently that was so old it had 9 bits in a byte! The only programming languages supported on it were Cobol and Fortran. So your assertion "this new feature was built into the language in 2015 so nobody needs this package anymore" is far far from the situation that we sometimes find ourselves in the real world. The second thing I'll say is that as a community we are able to sunset these no-longer-needed packages because people submit PRs. I've submitted PRs to ma boi Sindre's repos. He responded almost immediately, and we worked together to arrive at a solution. In your specific example, babel@6 still supports Node.js version 0.12, which does NOT have `String.prototype.repeat`. They've only released babel@7 in the last few months, which drops support for that version of Node.js. `detect-indent@5.0.0` no longer uses `repeating`, favoring instead the string prototype method. So stop saying "there's nothing I can do about it", and start submitting PRs!
It's really really really not ok to tell someone to kill themself. The fact that your comment is getting upvoting is almost as appalling, a reflection of how terrible this sub is. Suicide is no joke. I've reported you to the mods, who should perma-ban you. /u/vexator /u/Bartvds
After a little research, I actually think that you've violated the site-wide rules against bullying or harassment and have reported your comment to the Reddit admins. For me, that's the last straw for me and this sub. son_of_meat out.
After a little research, I actually think that you've violated the site-wide rules against bullying or harassment and have reported your comment to the Reddit admins. For me, that's the last straw for me and this sub. son_of_meat out.
now this is pod racing
After a little research, I actually think that you've violated the site-wide rules against bullying or harassment and have reported your comment to the Reddit admins. That's the last straw for me and this sub. weenie peenie out. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/drama] [javascript fag creates useful and revolutionary package on npm, is HARASSED and SHOCKED by the unruly behavior of fellow incel brogrammer nerds](https://www.reddit.com/r/Drama/comments/a3ymqf/javascript_fag_creates_useful_and_revolutionary/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Last time I user sequelize its typedefs werent quite smart
&gt;If you don't have to deal with legacy systems that run on absurdly old versions of software/hardware, you're lucky. If you're using js, you aren't on legacy systems.
Please get a life, then end it.
You can create a Mapped Conditional Type which does the same transform on the type level too. Here's a good intro to Conditional Types https://koerbitz.me/posts/a-look-at-typescripts-conditional-types.html For example written similiar type for [Immer Reducer](https://github.com/epeli/immer-reducer) where I transform class methods to action creators which actually returns the proper action type: ``` class MyImmerReducer extends ImmerReducer&lt;State&gt; { setName(name: string) { this.draftState.name = name; } } // The action actually has a type: {type: "setName"; payload: [string]} type! const action = createActionCreators(MyImmerReducer).setName("bob"); ``` In your case the type would be something like: ``` type MapThunkTypes&lt;T extends {[key: string]: (...args: any[]) =&gt; any}&gt; = { [K in keyof T]: (...args: Parameters&lt;T[K]&gt;) =&gt; ReturnType&lt;ReturnType&lt;T[K]&gt;&gt; }; ``` Usage ``` const Actions = { setName(name: string) { return async () =&gt; { // do thunk stuff return 3; }; }, }; declare const mappedActions: MapThunkTypes&lt;typeof Actions&gt;; ``` Where the type of mapped actions is ``` { setName(name: string): Promise&lt;number&gt;; } ``` This Mapped type only uses Conditional Types under the hood with `Parameters` and `ReturnType` helper. But you would need to write one on top of this if you want to support other action creators than thunks in the `Actions` object. For real world implementation you can checkout the Immer Reducer source too.
Kill yourself dude
Yes it is ok.
You can only specify that a type is an extension of itself so if it was `string` you could modify it to be `string | undefined` but if its `string | undefined` you can't make it `string`. Beyond alt tags you should also have roles defined. Alt tags alone are not enough. 
This doesn't directly answer your question, but might solve your problem. TSLint rules can enforce alt attributes, along with other accessibility roles and settings. &amp;#x200B; My company uses the "tslint-microsoft-contrib" package. You could also use "tslint-react-a11y". &amp;#x200B;
I usually just make them separate projects that get transpiled independently. The front-end using Webpack, which gets packed up to a static folder that the back-end serves. When running locally, I start two servers (one just the back-end, the other webpack-dev-server), with the front-end server proxying API requests to the back-end server.
Is there a reason why the front end and back end aren't two separate projects/repos? They certainly could benefit from separate build processes.
On my phone. Look at this boilerplate I wrote like a year ago. It has a lot of features including react and koa. All typescript. You run everything with the command yarn dev. Didn't get around to writing a production build script, but it's a good starting point for what you want. https://github.com/rhyek/reasonable-web-boilerplate
 for backend you may consider nest.js (TS by default) and for front-end you have angular which is also typescript by default or create-react-app with --typescript flag
Thanks for your reply. Nest.js looks pretty cool though. 
Thanks!
Didn't came to my mind until you and vinnl mentioned it. I think sepereting is indeed a good solution, thanks.
Thanks
You'd need multiple tsconfig files, e.g. tsconfig.server.json, tsconfig.client.json.
On phone so hard to make an example, but I imagine you can do this with Pick where you infer the 2nd generic (the keys you‚Äôre picking). Something roughly like: partialJob&lt;T extends keyof Job = keyof Job&gt;(part: Pick&lt;Job, T&gt;) { ... }
There are a few ways to approach it. - Separate repos - Single repo, multiple projects (package.jsons), multiple tsconfig.jsons - Single repo, single project, multiple tsconfigs All of these approaches have pros and cons. Recently, I put out [ts-app](https://github.com/lukeautry/ts-app), which uses a single project and multiple tsconfigs which inherit from a base tsconfig. It also uses [a single start script](https://github.com/lukeautry/ts-app/blob/master/dev/start.ts), which is super convenient for development. I think it's at least worth cloning this repo to see how it **can** work.
There are a few ways to approach it. - Separate repos - Single repo, multiple projects (package.jsons), multiple tsconfig.jsons - Single repo, single project, multiple tsconfigs All of these approaches have pros and cons. Recently, I put out [ts-app](https://github.com/lukeautry/ts-app), which uses a single project and multiple tsconfigs which inherit from a base tsconfig. It also uses [a single start script](https://github.com/lukeautry/ts-app/blob/master/dev/start.ts), which is super convenient for development. I think it's at least worth cloning this repo to see how it **can** work.
Unfortunately that doesn't work either, but thanks for the suggestion. [Playground link](http://www.typescriptlang.org/play/index.html#src=function%20someOfJob%3CT%20extends%20keyof%20Job%20%3D%20keyof%20Job%3E(t%3A%20Pick%3CJob%2C%20T%3E)%20%7B%20return%20t%20%7D%0D%0A%0D%0Ainterface%20Job%20%7B%0D%0A%20%20%20%20a_id%3A%20string%3B%0D%0A%20%20%20%20a_foo%3A%20boolean%3B%0D%0A%20%20%20%20a_bar%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Aconst%20j%20%3D%20someOfJob(%7B%0D%0A%0D%0A%20%20%20%20%2F%2F%20%3C--%20hitting%20ctrl%2Bspace%20does%20not%20show%20completions%0D%0A%20%20%20%20%2F%2F%20typing%20%22a%22%2C%20however%2C%20*does*%20show%20completions.%0D%0A%20%20%20%20%2F%2F%20So%20I'm%20pretty%20sure%20this%20is%20an%20accidental%20bug.%0D%0A%7D)%3B)
Yup, this is the way to go. :)
Use Parcel, it can build for node and web and works with zero configuration, supporting typescript, scss and much more.
getting back here it seems nestjs has this kind of thing, you might have a look https://docs.nestjs.com/recipes/swagger
I prefer a monrepo. My src folder has 3 top-level subfolders - server, client and shared. They all have their own tsconfig (which may inherit from a base tsconfig.) I usually use one tslint file in the src root. I use npm scripts to start server applications, dev servers, run compilers, cleanups, etc. I compose those scripts into other scripts with `npm-run-all`. So for example with one script I can start up an express app and watch, compile &amp; restart on source changes, as well as running a hot-reloading dev server for the client side. I would stick with the monorepo as long as possible until there is some reason not to.
nest is cool (I'm using it for one of my projects)...but you don't NEED it
Plus 1 for Nestjs! Woohoo!
Backend doesn't need any sort of bundler. Just \`tsc\` or \`tsc --watch\` while developing. It's very liberating.
Create-react-app also supporta SCSS. Just npm install node-sass and change all files to .SCSS extension
Angular supports SCSS out of the box after `ng new app-name` has been ran using the CLI. It generates .css files by default, but if you set `ng set defaults.styleExt scss` and generate your app, it'll default to all `scss`.
Huh, it's interesting that you have a separate tsconfig for shared - do you compile it separately as well, and then include the compiled files in the server and client projects? I usually just compile the shared stuff twice, as part of the server and client projects, and make sure that the shared stuff contains as little stuff as possible that is vulnerable to breaking changes between TypeScript releases.
I guess you need different tsconfigs to specify different environments. E.g. client is DOM , server is node and shared is none of both so it works both on client and server. 
Look for the peertube project repo for some inspiration too
I use this exact monorepo structure for a multiplayer game I'm working on and I can say that it works wonderful. It was almost surreal reading this because this structure is identical to mine down to the folder names, multiple tsconfigs and npm-run-all. :)
If you do that you loose a lot of the advantage, namely shared interfaces and some shared code. 
&gt; Sorry I missed that, the formatting in the OP is broken, it's hard to tell! You're right, how weird! I fixed it
Agree with this. You could even use Lerna to help manage the repo itself if you wanted.
We don't know what voodoo or black magic he's done elsewhere to help the compiler understand what Document is about. It's not a variable you should mess with honestly. Ever. Consider and use it as an external API given by your browser. Don't mess with its values.
Looks like they changed how formatting works in New Reddit vs old reddit. It's unreadable on old reddit: https://old.reddit.com/r/typescript/comments/a3csmx
NPM supports importing modules from other repositories.
Don't separate your client and server repositories. You *will* run into problems with syncing and versioning. It's not a matter of if, but when, and the issues never go away. There's almost no value in separating the actual repositories and a ton of guaranteed pain if you do.
I see! It's also unreadable on the new reddit if you're in the "Single comment thread" view.
&gt; I thought about Webpack but, I can't figure out good way to do it. Have you tried reading the documentation? If you don't want to be bothered with thinking of a structure for your application, let someone else do it: Get a SPA framework like Vue &amp; Angular: Both ship with excellent Typescript support, SCSS &amp; webpack
Yeah you might not need a tsconfig for shared.
But then you have to use angular :(
Please don't be the type of person that's like "I use this framework so it's the best." It's interesting to see what works well in different frameworks and libraries and use what suits your situation the best. Just saying, "I don't like that cause it's not what I use." is a very closed minded thing to say wouldn't you think?
Can you tell us about the proto file? What‚Äôs its deal? It looks to me like it generates Go?
I have an open PR for exactly this issue, it uses conditional types to infer if the middleware will get involved, and modifies the return type if so: https://github.com/reduxjs/redux-thunk/pull/224
Not true, you can use the `Required` generic to force something to be required, which is implemented as `-?`
!RedditBronze
You're violating license rights here. You took the svg from the TypeScript repository without including their license in your project, then re-licensed it as MIT.
May be use a union type in place of any? The other question is to ask what is the purpose the interface. May be there's a better way to achieve the same end.
Why not interface IValues { title: string; desc: string; isActive: boolean; currentCount: () =&gt; number; maxNumber: number; } &gt;
If `IValues` is different for each component, you probably want to use a generic. Generics are made for situations like this! Here's the documentation for generics: https://www.typescriptlang.org/docs/handbook/generics.html They allow you do stuff like this: ``` type Values&lt;T&gt; = T public static getValues: IValues&lt;{ title: string; desc: string; // etc. }&gt; ```
Use generics: &amp;#x200B; `export interface IValues&lt;T&gt; { [key: string]: T; }` &amp;#x200B; `const value: IValues&lt;string&gt; = {` `hello: 'hello!'` `}`
Could you just remove the return type completely and rely on type inference?
Because those are example properties which vary from class to class
Thanks for responding, I decided to go with a union type of number | boolean in the end since I don't think strings really belong there and functions can be made into methods of the class itself
Generics are the real answer. When you learn to use them a while new world of typing possibilities opens up.
http://www.typescriptlang.org/play/#src=const%20foo%20%3D%20%5B...Array(16)%5D.map(e%20%3D%3E%20Array(32)) Run this transpiled code and see what it does
Well seems like the spread operator gets replaced with the slice function at transpilation time and they don't do the same things.
Yup that‚Äôs exactly what I‚Äôm talking about. The transpiled code creates an array of 16 empty elements, rather than 16 empty 32-element arrays
Is that a bug?
That's definitely something which should be looked into in my opinion. I can't say if it's a bug or if it's just due the the way arrays work. When you create an array with array(16) you will create an array with 16 "slots" and they all are set to empty. The map command seems to not work on values set to empty. Slice will simply copy the array so you still have an array with 16 empty values. If you use the spread operator like you did it seems like the empty values will be transformed to undefined and that's enough to get them used by the map command.
If you go looking for small differences like this between typescript and js you will keep on finding them. I'm not pro typescript but I am forced to use it at work. I say I run into this issue about once a week, where something I could express in js just doesn't work in ts or won't compile even though it's perfectly valid. In the end it's easier to just not write it out how you want to write it and try some thing similar. In your case just this should do the trick: Array.from(new Array(16))... your code Such is the ts life 
If the values vary entirely based on class, then you don‚Äôt have a common interface. Type each return individually. 
You dont need to annotate the return type at all.
Babel seems to do the [right thing](https://babeljs.io/en/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=MYewdgzgLgBAhjAvDA2gOgwQQE7bgTwAoBGANgEoBdNAWzgAdCBTJAPhhzyIGYAmc8gChQkEABsmaMSADmhOCgAM1CWBlQAFuSA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion=) in this case.
Agree with this over the generic answer. To me typically generics are for different inner types in the same overall interface/type, whereas if the interfaces are completely different they should indeed just be different types.
seems a bug (an edge case) you could 1. write something similar that works 2. if you are using webpack, set TS to target=esnext, then delegate the downcompiling to babel I'd say using TS through babel is already the preferred way of using TS with webpack, because chances are you will soon fidn another thing that requires babel (like HMR)
As an aside, you can use `Array(16).fill(undefined).map(/* etc */);` instead.
This look better already but i'm still unsure if one should write it like that in first place... What do you all think about this: ``` var x = Array.apply(null, Array(16)).map(e =&gt; Array.apply(null, Array(32))); ``` 
It's probably not attempting to be too clever about compiling the whole expression. Spreading a (possibly holey) array correctly is one thing, the mapping is another.
Thanks for sharing your immer-reducer library. Your type code is really impressive! I‚Äôve been playing with reducing boilerplate for action creators for ‚Äùsetter‚Äù-like state and your types have solve some issues I had quite elegantly. Also this is so much easier to follow than most TS+Redux code I‚Äôve read because you don‚Äôt split your code across a million files. :)
Is that supposed to be "Values" and "IValues" (two different names)?
You're obviously right, that should have been `Values` both times. It seemed to me that OP has a base class that is extended by all components, and all components should have an `getValues` class that can return *whatever*, but should be typesafe within that class context. Obviously that's a big assumption to make, and I may be off. If that's the case though, I still believe a generic makes a lot of sense (in a real life scenario, the generic would be passed to the class being extended, like props and state interfaces in React). I do agree with you, that if `Values` doesn't set up any constraints and the value is not referenced anywhere, there's no need to use a generic. Also, if this is the only implementation of `getValues` and there are no constraints to what the method should return, there's no need to type it at all. Typescript should be able to figure out the return type itself automatically.
In my case every class has two static public methods, getElements() and getValues(), which return IElements and IValues interfaces respectively. getElements() points to elements within the class (which represents a component, i.e. a section of the page) while IValues set up particular values within the component which would need to be manipulated using JavaScript, such as what day the user is setting an event for, etc. I was using any because I wasn't really thinking it through since it hasn't been put into actual practice yet (I'm scaffolding the project right now). I figure now that all the keys in IValues would only return either a string, number or a boolean, since they are not dynamic values in the same sense as a function, which would be more fitting as its own static method of the class.
&gt;It seemed to me that OP has a base class that is extended by all components, and all components should have an `getValues` class that can return whatever, but should be typesafe within that class context. Obviously that's a big assumption to make, and I may be off. Just to confirm, yes, that is what I'm going for. I'm a week or so into static typing and TS so my approach may be a little weird but that is the approach I'm going for.
You have to enable the \`downlevelIteration\` setting in your \`tsconfig.json\`. Without it, it won't transpile features that rely on iterators correctly when targeting ES5. var __read = (this &amp;&amp; this.__read) || function (o, n) { var m = typeof Symbol === "function" &amp;&amp; o[Symbol.iterator]; if (!m) return o; var i = m.call(o), r, ar = [], e; try { while ((n === void 0 || n-- &gt; 0) &amp;&amp; !(r = i.next()).done) ar.push(r.value); } catch (error) { e = { error: error }; } finally { try { if (r &amp;&amp; !r.done &amp;&amp; (m = i["return"])) m.call(i); } finally { if (e) throw e.error; } } return ar; }; var __spread = (this &amp;&amp; this.__spread) || function () { for (var ar = [], i = 0; i &lt; arguments.length; i++) ar = ar.concat(__read(arguments[i])); return ar; }; __spread(Array(16)).map(function (e) { return Array(32); });
Yeah but everytime you are writing a new feature, you have to write it on server first, publish it, then start the work on client without being able to do related changes simultaneously. Not worth it. Unless two completely separate teams work on both codebase, better to keep them together.
This is the correct answer. Assuming you're using the IValues interface for data returned from the server? You should have well defined models for that. Very rare you'll have one interface for everything, especially one so broad
Awesome!
What about: ``` const imagesWithoutAlt = Array.from(document.querySelectorAll("img:not([alt])")); if (imagesWithoutAlt.length) { console.warn(`There are ${imagesWithoutAlt.length} images without an ALT attribute!`); imagesWithoutAlt.forEach((img) =&gt; { img.style.border = "4px solid red"; }); } ```
As far as I know, definitely typed is ‚Äúdefinitely‚Äù maintained, but because it is such a massive repo it will have a lot of issues. 
[removed]
There's a comment here but I don't see it, check if you're shadow-banned dude
Please have a look at [http://dinoloop.com](http://dinoloop.com)
DefinitelyTyped is a massive monorepo where all of the @types packages are stored. Naturally, it has thousands of PRs due to the number of distinct npm packages that are published out of that one repo.
Try this: https://www.npmjs.com/package/web-ext-types
I've made a fair few contributions to DefinitelyTyped. PRs have lately been a little slower than usual to be reviewed, but they definitely *are* being reviewed and merged in. I think its becoming a bit of a victim of Typescript's success. They're getting around 30 PRs a day, so keeping on top of that must be a bit of a nightmare...
It's not just you, I run into this all the time and as far as I have discovered there is no good workaround yet that doesn't require repetitive pattern and factory functions. This seems to me to be a design flaw of TypeScript. The arguments about it have been going on a long time: [#2947](https://github.com/Microsoft/TypeScript/issues/2947), [#13462](https://github.com/Microsoft/TypeScript/issues/13462), [#14600](https://github.com/Microsoft/TypeScript/issues/14600). \#14600 in particular has some workarounds (that are terrible) but maybe one will work for you. Personally, I recommend adding your use case to add some more support to it. It's still "awaiting more feedback" despite people sharing loads of use cases. Some more won't hurt.
yeah github doesn't scale well for this kind of usage. It really is much better to stick typings into the original repos.
they should encourage developers to vote on typing PRs they like/dislike and get a bot who could merge PRs with lots of thumbs up and close those with lot of thumb downs. 
&gt; thousands of outstanding issues DefinitelyTyped is a community effort, it's so huge there is no single maintainer: it is not traditional repo. If nobody propose a PR for the existing issues then they lie there for eternity. PRs for a definition type are reviewed by the current definition type authors and then merged by (mostly?) Microsoft employees. A big thank-you to Microsoft and others, without them DefinitelyTyped would be impossible.
Sounds like a good idea in theory, very open to abuse though.
I think today almost all repo maintainers are open to receiving PRs to add typings for their code if there are none, but I imagine there was a day when typescript wasn‚Äôt as ubiquitous and thus not as well received. Seems like definitely typed is a bit deprecated?
Wow, looks like there's a rabbit hole on this issue. Thanks for the heads up, I'll see if I can add my experience as well. In the mean-time I suppose I'll have to make the methods of sub-classes non-static...
This is 'advanced' only for beginners and javascript devs I hope.
&gt; I think today almost all repo maintainers are open to receiving PRs to add typings for their code if there are none I wouldn't be so confident about that - accepting them into your repo means (or at least implies) accepting responsibility to maintain the typings, which means that the maintainers are then responsible for updating them whenever they update the API. If they do not use TypeScript themselves, it makes sense for them not to want to take up that responsibility. DT makes it far easier for third parties to take up that responsibility.
&gt; I think its becoming a bit of a victim of Typescript's success. They're getting around 30 PRs a day, so keeping on top of that must be a bit of a nightmare... The people submitting typings for individual packages are held to be responsible for maintaining those specific typings (and dealing with PRs) from then on. Only when they do not do this, do the DT maintainers themselves come into play/
Very nice, I'll check it out for [my project](https://takeoff.sh/) which I'm using shell.js in but not quite happy with it
This is why I wrote [Takeoff](https://takeoff.sh/) - if you have a look at the docker config [here](https://github.com/takeoff-env/takeoff-blueprint-default) you can see how to use volumes for dependencies.
When types are in the main module and wrong, they are a huge pain to deal with. I‚Äôve come to prefer separate typing modules.
can't you just fork the module and use your own fork? It's pretty easy to do in just a few CLI commands.
Only 10?
I think we should get in the habit of committing type definitions directly to main project repo and ensuring that the file ships with the published package. In the future, installing an @types/* package should be the exception, not the rule.
It's very active. If you submit fixes for a declaration, they get published in a week, which is awesome. The week gives other authors enough time too submit their review, but if no one responds, a maintainer merges within a week. They have a bot that keeps track of this workflow.
OP why are you talking down to your own audience? Yes it is advanced!
I'd rather not
Thanks I was afraid that people here will tell me that I am posting too short content. Thank you for that opinion I will continue series then with the following: - advanced generic types - extends keyword usage - keyof in usage Sounds ok?
Sounds great. Looking for more fresh content. 
Sounds good to me! There is one change I would make to this post: I think it could use one more example to demonstrate a real-world use case. Otherwise it might not be clear to a reader when they would benefit from `infer`. An example that comes to my mind is when I used `infer` to extract correctly-typed action creator functions from a map of handler functions in [redux-instant](https://github.com/hallettj/redux-instant#readme). Here is a simplified excerpt: // A handler is like a reducer except that it is specific to one action type, // and receives the action payload as its argument. type Handler&lt;S, P&gt; = (state: S, payload: P) =&gt; S // Utility type that uses `infer` to extract the payload type from a handler. // Produces an error if `H` is not a `Handler` type. type Payload&lt;H&gt; = H extends Handler&lt;any, infer P&gt; ? P : never type Action&lt;P&gt; = { type: string; payload: P } // Produces an action creator function that checks the type of its `payload` // argument. function makeActionCreator&lt;H&gt;( type: string, _handler: H ): (payload: Payload&lt;H&gt;) =&gt; Action&lt;Payload&lt;H&gt;&gt; { return payload =&gt; ({ type, payload }) } // A concrete example: a handler, `handleIncrement`, and an associated action // creator, `increment`. function handleIncrement(state: { count: number }, payload: number) { return { count: state.count + payload } } const increment = makeActionCreator("increment", handleIncrement) // type-checks dispatch(increment(1)) // does not type-check! dispatch(increment("one")) 
Yeah, but if the types were in their own module you get another option: ignore the types. Sometimes that really is the best way to go, especially if time is tight or the module just isn't that crucial to your app. Sometimes the types are so wrong that fixing them is tough, especially without context on the module's inner workings.
Your docs are non existent, it's just another advert. Why Are you spamming this? You put no effort into your code. Why should anyone use it?
Please continue with your tutorials!
Apparently React has a similar issue withe some of static class properties. The workaround is to use a separate interface for the class when used as an object. https://github.com/Microsoft/TypeScript/issues/14600#issuecomment-308362119 
The problem is lots of authors aren't interested in Typescript. They also aren't interested in bumping versions for type corrections or holding back new versions until types are updated. If they are dedicated to keeping types in sync, chances are their project is already Typescript.
Hopefully someday we can use deno 
We did not call it a framework, we did call it a library. Give it a try and let us know what really made you think it makes express harder to use. Please throw some points on it. Thanks
Have a look at this and let me know your thoughts [http://dinoloop.com/#/docs/concepts/api-controller](http://dinoloop.com/#/docs/concepts/api-controller)
I think we've reached peak unusability for DT. As TS usage grows you'd expect to see more library authors using it and including their own typings.
Sorry, been busy so forgot about this. Did you figure this out? You seem to be able to get the behavior you want if you use `Pick&lt;Job, T&gt; &amp; Partial&lt;Job&gt;`. [link](http://www.typescriptlang.org/play/index.html#src=function%20someOfJob%3CT%20extends%20keyof%20Job%20%3D%20keyof%20Job%3E(t%3A%20Pick%3CJob%2C%20T%3E%20%26%20Partial%3CJob%3E)%20%7B%20return%20t%20%7D%0D%0A%0D%0Ainterface%20Job%20%7B%0D%0A%20%20%20%20a_id%3A%20string%3B%0D%0A%20%20%20%20a_foo%3A%20boolean%3B%0D%0A%20%20%20%20a_bar%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Aconst%20j%20%3D%20someOfJob(%7B%0D%0A%20%20%20%20%2F%2F%20%3C--%20hitting%20ctrl%2Bspace%20does%20not%20show%20completions%0D%0A%20%20%20%20%2F%2F%20typing%20%22a%22%2C%20however%2C%20*does*%20show%20completions.%0D%0A%20%20%20%20%2F%2F%20So%20I'm%20pretty%20sure%20this%20is%20an%20accidental%20bug.%0D%0A%7D)%3B%0D%0A%0D%0A%0D%0Adeclare%20function%20expectsFullJob(x%3A%20Job)%3A%20any%3B%0D%0A%0D%0Aconst%20partA%20%3D%20someOfJob(%7B%0D%0A%20%20%20%20a_bar%3A%20%22hello%22%2C%0D%0A%7D)%3B%0D%0Aconst%20partB%20%3D%20someOfJob(%7B%0D%0A%20%20%20%20a_foo%3A%20true%2C%0D%0A%20%20%20%20a_id%3A%20%221234%22%2C%0D%0A%7D)%3B%0D%0A%0D%0AexpectsFullJob(%7B%0D%0A%20%20%20%20...partA%2C%0D%0A%20%20%20%20...partB%2C%0D%0A%7D)%3B%0D%0A%0D%0AexpectsFullJob(%7B%0D%0A%20%20%20%20...partA%0D%0A%7D)%3B%0D%0A%0D%0A)
With only IntelliCode
This works and is correctly inferred in my VSCode. ``` function testThing&lt;T&gt;(_aThing: T,index?:number,values?:T[]): boolean { return Math.random() &lt; 0.5; } const a: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]; const b = a.filter(testThing) ``` type of b is number[] so it is correct
Maybe you should update TypeScript?
Speaking as someone who isn't fully into conditional types and their use-cases... I guess this is "neat" on a technical level, but I can't help but thinking that this specific example would fare *much* better just using much simpler, regular, generic types. Can anyone come up with an example which shows how these conditional types provides a better solution than the simpler one?
&gt;Can you tell us about the proto file? What‚Äôs its deal? It looks to me like it generates Go? Yes, that's the advantage of using GRPC. It generates the clients based on protofiles. It's very useful when you have a microservice architecture, it saves a log of time and bugs generating clients for your services.
You can read in tutorial - they are extremly helpful when you need to pass props of object depending on other props.
I think that conditional types are most likely to be useful in libraries to enable flexible APIs. There are some wonderful things that conditional types can do; for example take a look at the `Diff` and `Filter` types in [the documentation](https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types) that are defined using conditional types. The idea of `Diff` comes up in cases like React where you can diff the props a component takes with its default props to compute a type for required props with no default values. In addition to the especially advanced patterns conditional types are good for writing accurate typings for stringly-typed Javascript code. Sure the example in the post could be refactored to use generics or to use a union type. But what if you want to add a type definition to an existing library, and refactoring is not an option?
&gt; conditional types are good for writing accurate typings for stringly-typed Javascript code Sure. That's probably a use-case. Provide type-safety on a foundation (you can't change) which offers little. I can see how that has value. But doesn't Haskell and other "advanced" languages far above Javascript support conditional types too? If so, what do they use it for?
Works fine just the way it is: https://agentcooper.github.io/typescript-play/#code/GYVwdgxgLglg9mABFApgZygFQBYzAcwB5MA+ACgH0BDHPfALkUwEpGAjOOAGxSqQG9EAJxRQQQpAFkqUbADohfACZwAtmWaJCiAAxyArIgC+AKBMQEGRFUZgQqtiiEBtALqIAvImcBGADSIAEwBAMwBACwB+gEAbAEA7AEAHAEAnAE6rmYWYFYiaACCntZywDBcqEJkqBi0BMwA3IgA9M2IEFRoKIgF5pZQwugAQsVUpeWVZEgeJMjoWLgEU8yNLW0dXYgjZkA What TypeScript version are you using?
There is nothing in the core Haskell language that does what conditional types do. But there is a GHC language extension called [Type Families] (https://wiki.haskell.org/GHC/Type_families) that provides a similar function. It is too big a topic for me to get into in a comment. You can get some information from that link. The upshot is that there are a lot of things you can do! Type families are one of the features that support dependent types in GHC/Haskell. That is another topic that is too big for me to get into. The very very short explanation is that dependent types can fully describe any possible program specification at the type level, which leads to definitive proofs that code is correct.
&amp;#x200B; &amp;#x200B; As you can see, in Case A, my editor claims that the function is just as I authored it. In Case B, it correctly understands that I am passing it a number, and changes \`T\` to \`number\`. Your case is something completely different. Type inference for your variable \`b\` comes from the fact that \`a\` is of type \`number\[\]\` and \`Array&lt;number&gt;.filter\` returns a \`number\[\]\`.
 ~/tmp % tsc --version Version 3.2.2 ~/tmp % pacman -Q typescript typescript 3.2.2-1 I have the latest version.
TypeScript version is 3.2.2. You are focusing on the wrong thing though. I'm not talking about the type inference of the return type. I'm talking about the function argument. Hover over `testThing` in Case A and then in Case B, and you'll see the type of the generic function is inferred (or... evaluated?) in Case B, but not in Case A (still just `T` in Case A).
That looks like the magic I'm looking for. I haven't tested it, but I plan on trying out the core fix: declare module 'redux' { /** * Overload for bindActionCreators redux function, returns expects responses * from thunk actions */ function bindActionCreators&lt;M extends ActionCreatorsMapObject&lt;any&gt;&gt;( actionCreators: M, dispatch: Dispatch, ): { [N in keyof M]: ReturnType&lt;M[N]&gt; extends ThunkAction&lt;any, any, any, any&gt; ? (...args: Parameters&lt;M[N]&gt;) =&gt; ReturnType&lt;ReturnType&lt;M[N]&gt;&gt; : M[N] } }
But... it is inferred correctly. The type of `testThing` in case A is `testThing&lt;T&gt;` (because it's still an open generic), but in case B the type is clear by the arguments so it's the closed generic `testThing&lt;number&gt;`. Everything as expected and as it should.
It's something that with Angular is never an issue (as everything is in TS) but heard a lot from React devs. 
There's a decent CLI tool called `types-installer` that will look at the packages in your package.json and install all of the available types for your project, which you can find [here](https://www.npmjs.com/package/types-installer).
One issue that has prevented these from being easy to install automatically is that some libraries once were not shipped with types but now are, and older versions have types defined in DefinitelyTyped. A cli would have a hard time figuring that out. Is it really that bad to have a few more dev dependencies you install? I‚Äôve never thought of it as annoying
The dream of a all TS world I suppose.
haha let's give it a few years 
Yeah I've seen something like that, IIRC DefinitelyTyped had a CLI tool something like this right? Still keeps @types deps in devDeps which I'm not a _huge_ fan of.
Don't think it would be difficult. We can use the npm registry to get all versions of package Y's package.json and use the existence of the "typings" or "types" field as a heuristic if the package has types or not. If it doesn't we can double check to see if there's a definition file that matches the file listed in "main" for packages listed in our package.json. If they really don't exist then fetch from DefinitelyTyped. It is a minor inconvenience, 99.99% of the time its a worth while trade but I just thought about how TS has matured so much but seemed to have left this minor inconvenience behind. Thanks for your response!
Why not? If you place the `@types` packages in `dependencies` then any project that lists your package as a dependency will install of the `@types` modules for your dependencies, but no project should be referencing sub-dependencies directly. As such, nobody would have a need for those `@types` modules that your package defines as a needed dependency of using your package. I can understand that not every project is meant to be seen as a module that could itself be one day required by some unknown parent (say a web server project) but its still a good practice to place all build requirements in `devDeps` and all runtime requirements in `deps` because you never know what the future might bring.
Types literally are devDeps, where would you keep them?
Yeah, that plus outdated typings or typings that randomly break really puts a damper on using TS.
Why do you care if your package.json is "bloated" with devDependencies? I can't imagine typing \`yarn add @types/whatever\` is enough to prevent me from using TypeScript.
Automatically scaffolding new declarations is on the roadmap for 3.3: https://github.com/Microsoft/TypeScript/wiki/Roadmap#33-january-2019 To install pre-existing declarations, this might work: ```bash for package in $( node -p "require('./package.json').dependencies.join('\n')" ) ; do yarn add @types/$package || true done ```
@types are required by developers who consume your library, since their editor will load your bundled .d.ts declarations, and those might refer to the @types declarations. So I always track them as dependencies.
That works! Thank you!
Still waiting for the announcement from FB: ‚Äùwe are sunsetting flow, it had its time, but now its time to go full in on TS‚Äù Really, having two type systems is totally unneccessary, it only hurts the adoption of both. Wish they did something to collab more, or just agree on pushing TS forward.
The Flow analog of DefinitelyTyped, [flow-typed](https://github.com/flow-typed/flow-typed/blob/master/README.md), automates type definition installation in the way you described. It might be worth borrowing some ideas from that project. Flow-typed provides a CLI that scans your dependencies, and fetches definitions from the monorepo that are compatible with your dependency versions and your compiler version. It also creates stubs in cases where definitions are not available. Flow gives priority to definitions bundled with dependencies, so this all works out pretty smoothly. 
That's a very good point and one I should have considered.
And that is why you see where the crowd goes so you can choose the opposite direction. 
I believe newer packages are mostly developed in typescript and this issue you comment will be vanishing slowly while typescript is getting more used
I dream of our glorious Deno future every night.
Thanks for the link, just migrating our codebase to TS and this might save a bit of faff.
Yeah. I'm noticing a lot of stuff get native types. For me, it was a Google Cloud library (Cloud Storage). They just recently finished moving it over to TS so it started being published with types automatically generated by their TS compile process.
Quite the opposite, I've seen a handful of major libraries transitioning to DefinitelyTyped over including it in their source
The advantages of TypeScript appear especially in bigger projects or in enterprise. - Much easier to understand code that you have not written. for example code from your colleagues. - TypeScript takes care of some of the pitfalls from Javascript (scopes, the 'this' context etc.) - With TypeScript you can write much safer and cleaner code due to the typing system. In order to really understand TypeScript, you first need to understand Javascript. And with that I mean stuff) things like micro and macro tasks,the 'this', modules, Es6, Es7 etc. After that you may try the more funny stuff like Conditional types ;) 
I guess the libraries I use other than React have started shipping types recently. Which ones have you noticed moving away from this?
Styled components and redux thunk are two that come to mind. It does seem to be a case of older libraries written in JS though.
It's really hard to say anything intelligent here without understanding the state of the code base you're working on and the patterns being used. Sorry, I know that's not very satisfying. I've worked on a bunch of projects where tooling was a nightmare. This has largely been caused by developers not understanding the tools they chose and treating tooling as a concern only after the fact. If the project is poorly instrumented, then it's going to be a nightmare for everyone, even people that really know TypeScript well. &gt; We have the king of dynamic languages in JavaScript. Why are we settling for a poor mans static language? Because the insanity produced by huge projects in dynamically typed languages is bad enough to justify it.
I understand JavaScript very well. I am in no beginner in js. Js has very few pitfalls except for weird equality coercions that you never see in real world code. The this keyword is only mystifying if you don't understand the relationship between functions and objects. The type system is fine to document intent. But it isn't safe, and one can argue makes code even less safe because validation is definitely less of a concern in ts due to the types. The only positive I see in typescript is documenting intent and extra editor features. But in downside I see a lot of time wasted on configuration, a lot of cryptic errors, lots of integrations with outside tooling that need to be made and very verbose code that can be hard to read (conditional types, function overloading, keyof...). Also just for fun, a very weak distinction between interfaces and types. Also a strong idiomatic predisposition for oop design which I don't consider a good thing.
totally agree with this! 
Typescript isn't for everybody. You obviously did the right thing (trying it out for an extended period of time) which is much better than most. And you found out that it doesn't work for you the way your brain works. Great. So don't use it. I personally think Typescript is brilliant and I wouldn't use Javascript without it. But that's me. Not you.
Yeah I understand. But the tooling breaks on basic things. With typescript 3.2, I can't compile @types/mocha. Im not doing anything with it. Just can't compile the source code anymore. That's extremely frustrating. I keep my tooling to a minimum. The only tool I am trying to get to work is mocha-rest-explorer, that works out of the box with js. It's a nightmare in ts. I can make It work in one repo but not the other. I understand the need for static languages. I just find that typescript is a bad one, and I am hoping somebody can say something redeeming for it. Cause my patience with it is running thin. 
Sadly it was a decision that was taken at my work slightly before I joined. It is hard for me to overturn a company decision. I would switch to node or golang in a heartbeat if I was given the choice. Thanks for your answer. Sorry I am just very frustrated.
You can try looking at large projects using it; see what their reasons are. For example https://github.com/glimmerjs/glimmer-vm
if you don't see any advantages over js then just don't use it? 
My work is going from TS to Go right now and we're enjoying Go a lot more. We went from JS to TS a while ago since we have a big system and appreciated the help having types for everything linking together. But the tooling for TS is tricky. We had issues with libraries missing types, issues getting it to compile when we add blank d.ts files for libraries without types, issues with accurate code coverage... Go seems to give us all the benefits of TS except it just works. Tooling in VS Code is a big meh right now though. Hopefully the extension improves.
This is exactly what I've been thinking. I am going to try and write an official suggestion to start writing our backend services in go. I don't think it is reasonable to work in a language that mostly works. Thanks for your response .
I'd seriously consider Java (or several other JVM languages...Kotlin, Scala, even Clojure) or C#/.NET Core before Go. Go is easy to learn. It also has a lot of really stupid patterns due to `lol no generics` and horrible error handling. All code is super verbose due to these attributes, and as someone that has used Go in the wild, it leads to a ton of copying and pasting and abusing `interface{}`.
My team actually prefers the error handling style in Go. Personally, I don't care either way. Either I handle errors up front or I handle them in catch blocks. Either way, it's bverbose but necessary in my opinion. They aren't fans of using Java. We have Java code right now and it's the same situation, were migrating away from it. They feel it's "too OO" and "too enterprisey". We tend to butt heads, me preferring more "enterprisey" styles (to make code extendible and testable) and them wanting to only think about the one week sprint goal and use as few layers as possible, inject as few dependencies as possible. My team lead apparently keeps me around to lay down the law on them about keeping our code clean. We settled on Go as an alternative to Node (instead of more Java) since we believe it will get us the performance we need (our workload is CPU bound, not IO bound).
I care
\&gt; The type system is extremely complicated, and has next to no value beyond documentation. How is the type system complex? It seems on par with Python 3's type annotations or any other strongly typed language.
Apologies up-front for the ultra barebones nature of this app, it doesn't have a lot of features or polish. I'm posting it mostly to show that this is a thing you can do with Typescript.
Less bugs. We have error reporting done via rollbar at the place i work in, and new code in TS has so much less errors. In fact errors i get with my TS code are usually because there is something wrong with the users connection, the user has a really legacy browser (eg. does not support object.assign) or some ajax call fail because the server has a bug. With our older JS code, theres errors popping in quite frequently. Less testing. This might seem controvertial to some, but i really dont have to test that much with TS, as types already provide me with a testsuite. Now i only test that the actual logic is correct.
I wrote [this](https://gist.github.com/jtmthf/2b9e5e935581e1722461b524c4234067) up a little while ago for this. Use it instead of `npm install &lt;package&gt;` and `yarn add &lt;package&gt;` and it will install the @types package automatically if available. It's pretty primitive and definitely could be done better.
I would give it a try yourself first. Every language has rough bits. I was quite annoyed by the VS Code extension. It doesn't seem to support Go Modules right now. So our only choice is to pull the latest code from master branch on GitHub for our Go dependencies. We can't pin our dependencies to specific versions. So we're relying on Docker builds that we can revert to if things go wrong with our dependencies. It works for us, but it might not work for everyone. I think if you try it yourself and you know it works for you, you'll have an easier time convincing your work to try it.
They also support ReasonML, which is more powerful than both Flow and TypeScript. I think it would make more sense for them to go full on ReasonReact. 
If it helps, I know there's a VSCode extension that will automatically install available types. I'm sure there's similar tools as well
&gt;I currently have a JS script in my React application that is a simple set of tasks for deploying my React application that requires about 10-15 modules that are relatively small like S3, tar, copy utils, hashing but when I swapped this file to TS I got many errors about missing type definitions. &amp;#x200B; What editor are you using? I get a code action to import all missing type definitions when I do an import. As for bloating, type definition modules are really small. It's just a definition so it's really not going to add much to your build time. &gt;Bonus points for somehow making it easier to inject your own definitions so I can write my definitions in a folder for a module that is missing definitions &amp;#x200B; You can just make a deceleration file and declare what you need. In a `d.ts` file ```typescript declare module "MissingModule"{ export function doesSomething() : String; } ```
I love Reason but there are numerous reasons why they won‚Äôt go whole hog in that direction IMO! It‚Äôs just too different from JS for it to be easily adoptable for the average JS programmer for one thing
It looks like it only has a volume for node\_modules, but that by itself does not enable typescript language service to see the dependencies, right? 
Is it somewhat usable now ? &amp;#x200B; I'm following from a distance but last I checked it was far from a 1.0, I like typescript, I'm getting into rust a bit and I like his approach of wiping the slate clean of the node mistakes to start fresh.
I‚Äôm not qualified to say really, but it is moving fast. https://github.com/denoland/deno
Continuation of my series. I will try to write blog post a day about advanced typescript usage. Enjoy!
This one is pretty whack. Why is it GraphQL?
The tutorial is not bad, not really "advanced" but OK. But I agree with you on the GraphQL-thing? It has nothing todo with GraphQL...
I see. I hadn't heard of open and closed generics before. That changes things a bit. I don't quite understand them yet, but I have an idea. I think my new question with this in mind is: how do I make it a *closed generic* without the extra arrow function? Thanks for your help!
&gt; I think my new question with this in mind is: how do I make it a closed generic without the extra arrow function? The more important question is: Why do you want that? What problem do you face? Because the answer to your question is: You can't.
In his defense mapped, conditional, union, intersection, literal, index query types etc are not common in other languages and can be quite confusing to anyone with C#/Java background trying to get into TypeScript.
"Not really advanced" That's what I expected. When I wrote in other reddit post my content is not so advanced people reacted: "Oh man it is advanced don't talk us down". I didn't write it is about graphql neither posted it in /r/graphql reddit. 
Here's a sneak peek of /r/graphql using the [top posts](https://np.reddit.com/r/graphql/top/?sort=top&amp;t=year) of the year! \#1: [The Linux Foundation Announces Intent to Form New Foundation to Support GraphQL](https://www.linuxfoundation.org/press-release/2018/11/intent_to_form_graphql/) | [5 comments](https://np.reddit.com/r/graphql/comments/9uqov7/the_linux_foundation_announces_intent_to_form_new/) \#2: [GraphQL gets its own open-source foundation](https://techcrunch.com/2018/11/06/facebooks-graphql-gets-its-own-open-source-foundation/) | [0 comments](https://np.reddit.com/r/graphql/comments/9vu2pr/graphql_gets_its_own_opensource_foundation/) \#3: [GraphQL Editor - A Visual Editor for GraphQL Schema](https://github.com/slothking-online/graphql-editor) | [3 comments](https://np.reddit.com/r/graphql/comments/9i0plr/graphql_editor_a_visual_editor_for_graphql_schema/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
I always feel these kinds of posts are just borderline spam. "Here is a link to my blog, which contains a sample of reworded Typescript documentation."
Congratulations! Keep them coming... It's great to see more typescript packages instead of having to hunt for separate type defs. I generally just use a `switch(true) { ... }` for any of the examples that you gave in the readme... Do you have any examples that would be better with this library?
Show me that sample from TypeScript documentation or try to google that - you'll hardly find anything. That's why I write these blog-posts on my GraphQL blog to teach people something that was hard to learn for me. Moreover people here asked me to write more about advanced typescript functionalities, you can check few posts before. This is not the only blog-post by me you can check it on that blog I wrote many other longer texts and If only you read this post you would see explanation why this one is so short. People you paranoid?
Conditional type syntax is crazy. And the quirks of certain interactions in the type system. Did you know you can assign a Record&lt;string,string&gt; to a Partial&lt;{a:number}&gt;? Or any partial type? Look maybe it's not that complicated. But typescript types aren't a joy to read or write. Also I have yet to find a good explanation of when to use types vs interfaces with object literals. Seems to be a matter of preference. Try golang for example. The type system is much cleaner, and much more dependable
Here is where we disagree. I don't think typescript types do much. Any time you have an "any" you've pretty much invalidated your type system. Regardless, out the boundaries of your app, if you make a network call and type the response, you have done nothing. You've told your app what you expect which is documentation. But you still need to write validation which seems to go out the window with typescript. I can see that JavaScript code may have more bugs at first, but they would be trivial things. I think typescript encourages bad practices because it is "typed"
Yeah ive written a lot of go personally but never in a professional setting, so I haven't experimented as much with tests and benchmarks. But I like that is is integrated with the standard library. Go module support should get better over time. I was under the impression that go modules locked in your dependencies to the time and commit hash, even if the package doesn't support semantic versioning. If my pitch gets traction I might end up sending you a dm for advice! 
Why is this in /r/typescript ?
Looking forward to any advice you can give me. I'm loving the language so far so I welcome any improvements to my tooling. Best of luck!
I presume because there is a TypeScript repo of the code linked at the bottom of the article.
I presume because there is a TypeScript repo of the code linked at the bottom of the article.
If it's educational, I'm fine with it. Documentation isn't always accessible to juniors. Stripping advanced verbage to focus on one aspect with examples can do wonders for teaching. Further, people don't tend to skim documentation to learn what they've missed. They do tend to read Reddit articles that title a concept with which they are unfamiliar. I think determining validity through voting is likely the best way to handle such a scenario. I personally support anything that makes the community better off and more educated. If readers enjoyed learning, that's great.
Why is this considered 'advanced'? This is just a basic example on how to use generic type constraints.
Stop it
[The third code example here.](http://www.typescriptlang.org/docs/handbook/generics.html)
How this example shows you the usage with objects which is the main usage in real world code? Pass string and return string - GREAT! 
??
The section describes generics in general. It explains that the generic type variable is whatever type is passed to it. If you have trouble wrapping your mind around the *advanced* topic of generic types such that you can't see that they don't act any different on strings vs. object types then maybe you shouldn't be writing about them in the first place. 
[removed]
See my other articles if you think I don't know what I am doing. Discussion about whether is simple or advanced is stupid from the beginning. I want to help people that asked me to write about typescript. TypeScript documentation is not so clear for 95% people. If you understand it - good for you. Have a nice day, again this discussion is pointless
Writing it is not advanced as it is a part of series of articles you haven't read probably. It may not be advanced for you but advanced for anybody else here so it looks by upvotes
Dont feed the trolls ;) I Love to see some real examples. The docs dont really help me that much.
I agree you give an example that informative for someone who has only a basic understanding of that page. But I also agree that it is not ‚Äúadvanced‚Äù. As a rule of thumb, you could probably market tutorials on anything at or below ‚ÄúAdvanced Types‚Äù on the TS docs page as ‚Äúadvanced‚Äù. 
I've found that using the `tadd` npm module to install npm packages greatly helps with this issue. It's a library that automatically installs TS typings for you. https://www.npmjs.com/package/tadd Only thing is you need to remember to type `tadd &lt;lib&gt;` instead of `npm install &lt;lib&gt;`. Overall, I feel like your problem here is really negligible. There's ways around it, and even using Tadd is probably one step into overkill territory.
Easy, I was just wondering why you were responding the way you did to a legitimate question. But to be honest, i also see this post as the regular spam in line of "Click here to see how to use forEach in vue!"
Check 2 posts before on reddit to see the situation inverted
 Now I can nail in that interview at Google!
&gt;Show me that sample from TypeScript documentation or try to google that - you'll hardly find anything. I just did what you asked, person. This discussion is whether or not low effort blog posts that are basically a worse regurgitation of the official documentation are "barely not-spam". You can rationalize all you want about why you made the blog post or why you call it advanced or whatever. The fact of the matter is that it comes across low effort because it contains just a modicum of meaningful content (using generics to augment a return type) while not taking the opportunity to expand to the actual general concept (using generic type parameters in general). You show an example of a generic identity function constrained to \`Point\`, similar to official documentation, but say you're cutting it off short because there's infinite examples of how to use generic functions. How this example shows you a meaningful way to use generics, which is the main usage in real world code? Pass value and return value - GREAT!
Might be worth touching on use with function overloads, as the generics can provide more useful insights into possible different return types/arguments for a function
I tend to let inference go as far as it can, the only time I try to be explicit is with method signatures. Even if the return type can be inferred, I will make it explicit. That balance seems to work for me and my team
It's hard to go back to writing React applications without Typescript. I find out so much quicker when I either misuse a component or refactor something and forget to update a usage somewhere.
Use explicit types where it helps, which I know is a bit vague. My rules tends to be 1. If I can't infer the type easily and that part of the code would be easier to read knowing type then I'll add it. eg I wouldn't bother with "const foo = 123" but I might with "const foo = callApi()" if I'm doing some further manipulation on foo and not just passing it somewhere else. 2. Where I want the compiler to help if the type changes. For example if I've got some object literals representing some test data like "const foo = {x = 4, y = 2}" then I'd add an explicit type onto foo "const foo: Point = {x = 4, y = 2}. Now if I change Point to have a z property, the compiler tells me the places where I might need to change the code. 3. I always explicitly type function signatures as I find it helps with both of the above points.
I use my IDE (vs code) to tell me what isn't inferred by simply hovering over the types, since we allow for implicit any. You could enable strict mode and then you would simply be forced to type everything
This is Dan Abramov's (a React dev) most recent post about how "Great APIs" optimize for change. https://overreacted.io/optimized-for-change/ For me, Typescript makes React into one of the very few technologies that live up to this ideal. When writing UI stuff in React+Typescript, I pay basicially no attention to the "what-if monster" in my head because the answer to "what if" is "so I'll change it".
I inherited a slightly nontrivial React project in js. It is basically a wizard of 10 or so pages. I before adding the requested features, I decided to port everything I imported to ts, so all new code would be fully typed. Best decision ever. 
Is there anything TypeScript doesn't make better? :)
As JSX is mostly syntactic sugar (see [https://fettblog.eu/jsx-syntactic-sugar/](https://fettblog.eu/jsx-syntactic-sugar/)), boiling down to plain JS, and TypeScript is really good at understanding plain JS, both are (to me) a match made in heaven. I have to say I learned to appreciate React a lot more once I started using it with TypeScript. The velocity you gain even for small size projects by using only a couple of generics is outstanding.
I've used React with only JS for a few years now. I've recently just got a new job where we use Typescript+React and it's a total upgrade to just using Javascript on every project.
Thank you for your comments! First of all the `match` function the library provides returns a value. If you want to do this with a switch you need to write more. &amp;#x200B; `let result = match(valueToBeTested)` `.caseX("whatever")` `.default("default value")` &amp;#x200B; vs &amp;#x200B; `let result: typeX;` `switch(valueToBeTested) {` `case X:` `result = "whatever";` `break;` `default:` `result = "default value";` `}` &amp;#x200B; or &amp;#x200B; `let result: typeX;` `if (valueToBeTexted === X)` `result = "whatever";` `else` `result = "default value";` &amp;#x200B; Also, with the match function you always have to provide a default case, so if you are using it to get a value you can never forget it. If you use typescript, with a switch you will be just warned but nothing more. But with the match you can also have the type of the result implicitly returned. &amp;#x200B; A switch doens't allow funtions as cases, it just compare (===), so you will have to relly on if else chains that have the same problem of the switch if you want to obtain a result. &amp;#x200B; I mainly developed the library to treat with [union types](https://www.typescriptlang.org/docs/handbook/advanced-types.html) like in [this example in the README](https://github.com/x-match-expression/x-match-expression-js#instance-check-example); It is very handy to treat with custom errors. Besides that, I admit I have lot of redundant case methods that in the future might be reduced but the core idea is that you dont need to write verbose code. &amp;#x200B; &amp;#x200B;
Why types in general? because they are free tests for your code. I can not imagine to mantain a big project with fear of refactor because there are no types
I would say that if you are consuming libraries or doing common stuff, do not define the types explicitly. On the other hand, if you are creating a library or an API then you can be more verbose for example in return types because it can be used as documentation
I'm so confused. Coming from Angular I don't understand why I see so many posts about using typescript and react... Do people hate themselves? Is react hard to type? What's the go, why isn't typescript just standard now?
React is created by Facebook, who have their own typing system Flow. All of the typescript typings for react are third-party open source from DefinitelyTyped. I imagine that Facebook abandoning Flow is a ways off (if ever). TypeScript is beginning to reach critical mass though.
A type by itself only exists at compile time. It has no runtime representation. You cannot put methods on it like a class, because a method receiver must be a runtime value. But you can write functions that take values of your type as arguments, or that construct values of your type. If your type is an interface you can write classes or objects that implement it. Something to keep in mind is that a class is a combination of a runtime value and a type that happen to have the same name. The runtime value constructs instances when you call it with `new`, and the type is used in type expressions. You can absolutely use classes in union types because a class *is* a type (and also a runtime value).
In my opinion it's because JS developers don't see the power and ease TS provides, they only see the extra code, and extra support you must put in.
This definitely. If you make changes it will cascade through the app. If you explicitly define it you must fine all those definitions and change them.
Are you referring to adding signatures for functions? If so, aren't return types are inferred?
With takeoff at least, what I do is clone the source repo to the local machine and install dependencies locally too, especially for types. The trick is with volumes for me is to mount the apps via the Docker file and connect them, but also within those images have that separate node_modules volume set up. So dependencies exist in two places, one on the OS host and one within the docker image for that OS. I realise I pointed to the main branch and not my future branch, which has the actual changes: For the docker compose: https://github.com/takeoff-env/takeoff-blueprint-default/blob/dogfood-takeoff/docker/docker-compose.yml 
So which would be more idiomatic for TS, obj + interface or just using full blown classes, or something else?
I understand why TypeScript with React is just now becoming a thing. Several years ago, using it with React was a pain because most libraries did't have typings. You either had to write your own, or put up with all those warnings. And defining every unknown variable as 'any' wasn't exactly serving a purpose. I'm glad that things are improving. With Angular it's different, not only was it built with TS from the ground up, but most libraries came from within this platform.
&gt; people don't tend to skim documentation to learn what they've missed. Their loss, really. And poor customers having to pay for their shit.
What are you trying to do?
Depending on what you want to do exactly I think that using Tagged Unions can be a good idea. Then behavior is specified in a set of functions which are big switch statements. [https://blog.mariusschulz.com/2016/11/03/typescript-2-0-tagged-union-types](https://blog.mariusschulz.com/2016/11/03/typescript-2-0-tagged-union-types)
Can you clarify what you mean here, the brackets around the literal object can be omitted in the above code. e.g. \`\`\`javascript (1) === 1 \`\`\`
So you want a way to define an object that can have arbitrary properties? &gt; it needs to be nothing but an object in brackets "({})" Your example doesn't look like that. Also, as /u/cschulze1977 mentioned, the parenthesis around the object is how we sometimes distinguish between JSON and block syntax for curly brackets (`{`, `}`).
The custom framework requires these brackets in this case because of how it merges scripts. That is not something that I can change.
I meant that the produced script must be in block syntax but the object is basically a class like that of Backbone.js - Backbone.View because the custom framework is based on that. Can I write a class in TypeScript that will produce such an object as above? Is there a way I should extend TypeScript myself to do this?
If you just want a generic object that has some keys and some values, you can do this: interface BackboneViewObject { [key: string]: any } If you want to more strictly define some potential properties that objects *might* have, you can do this: interface BackboneViewObject { className?: string randomVariable?: object, events?: { [key: string]: string } initialize?: (options: BackboneViewObjectOptions) =&gt; void buttonClicked?: () =&gt; void } The question mark says "it maybe can have these properties, and if it does, it has to be this type." 
I feel like when you say Typescript and when I say Typescript we're talking about different things. Typescript is a superset of ES6 that allows you to declare the shape of objects. You annotate your javascript inline, and it catches errors for you. There is no "must be in block syntax" when dealing with javascript. If blocking out your code is required, then do so. If not, then don't do so. There is no "extend[ing] Typescript". The language parser has new releases, but that's it. If you'd like a feature, you can hit the typescript repo with a request. As far as actually writing a class to produce the above object, you certainly can. That can be done in Javascript, and it can be done in Typescript. Doing it in Typescript will allow the consumer of the class to know the shape of the inputs and ouput. If I were to declare the shape of the output (ie "type" the output), it would look something like this: interface MyOutputMeaningfulName { className: string; events: { [cssClassName: string] : string }; initialize: (options: Options) =&gt; void; buttonClicked: () =&gt; void; }
I like your website
My goal is to have the power of TypeScript to build my objects with type checking, just that the resulting script file must be an object like above. A TS class is compiled into a variable that must be constructed. Can I write a class that will compile into an object that will not be in a variable but instead in an inline declaration like above, if I understand it correctly? While using TS to write that, I will, of course, employ the benefits of type checking. But everything that TS produces must be within this block.
When using the TS playground online, I don't see any code generated by interfaces. Are interfaces only used in the IDE and completely excluded from the compiled code? Can I then, essentially, write an interface and my object in the same file and have only the object end up in the resulting script?
I just came up with something last night which may be a long the lines of what you're looking for. See [https://github.com/Microsoft/TypeScript/issues/12290#issuecomment-446761961](https://github.com/Microsoft/TypeScript/issues/12290#issuecomment-446761961) It doesn't cater for arrays yet, but that shouldn't require too much of an adjustment (I should have an update later this evening to do that). &amp;#x200B;
That is correct. `type` and `interface` are compile-time only types. None of the type or interface information will end up in your compiled JavaScript. Related, `enum` and `class` will output JavaScript runtime "types". `const enum` will just export string literals with no special time. [Here's an example](https://www.typescriptlang.org/play/#src=%2F%2F%20Does%20not%20appear%0D%0Atype%20Whatever%20%3D%20%7B%20%5Bkey%3A%20string%5D%3A%20any%20%7D%0D%0A%0D%0A%2F%2F%20Does%20not%20appear%0D%0Ainterface%20AnotherWhatever%20%7B%0D%0A%20%20name%3F%3A%20string%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Becomes%20a%20real%20object%0D%0Aenum%20SomeThing%20%7B%0D%0A%20%20Nothing%2C%0D%0A%20%20Something%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Doesn't%20show%20up%20in%20the%20javascript%0D%0Aconst%20enum%20SomeOtherThing%20%7B%0D%0A%20%20Nothing%2C%0D%0A%20%20Something%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Becomes%20a%20real%20object%0D%0Aclass%20FinalWhatever%20%7B%0D%0A%20%20constructor(input%3A%20any\)%20%7B%20%7D%0D%0A%7D%0D%0A%0D%0A%2F%2F%20enum%20uses%20the%20object%20SomeThing%0D%0Anew%20FinalWhatever(SomeThing.Nothing\)%0D%0A%0D%0A%2F%2F%20const%20enum%20is%20a%20literal%200%0D%0Anew%20FinalWhatever(SomeOtherThing.Nothing\)%0D%0A%0D%0A)
I don't want to prescribe one way to do things, and the patterns you use depend on what you want to accomplish. I can tell you a bit about my own preferences. When I am passing around structured data I prefer to use objects described by interfaces. This encourages separation of data and behavior. I use this pattern for example when working with data fetched from an API. I write a "model" module that defines an interface for data, and that contains functions do things like parse JSON into model objects, validate data, and construct new objects. I usually put the code for interacting with the API in a different module. These model objects will be used by API modules, view components, app state, and possibly other places. That means that the behavior relating to the data is split into a bunch of different places with different concerns. It would be awkward to stuff all of that behavior into a class. If I want a type to have its own self-contained behavior I will use a class. Classes are useful because methods can be chained into a fluent API, and class methods and properties can be private, which is useful for enforcing invariants. I use classes most for generic, reusable types such as data structures. I prefer to avoid inheritance. It is not always necessary to write a separate interface. You do want an interface if the class has side-effects, and you want to be able to use a mock implementation in tests. If there are multiple variants of a class I find it useful to use a type union instead of a common superclass because a type union is a sealed type: Typescript can see all the possible variants of the type, and can make sure that have covered every possible variant when refining types with type guards. For example: type Tree&lt;T&gt; = Node&lt;T&gt; | Empty&lt;T&gt; class Node&lt;T&gt; { constructor( public value: T, public left: Tree&lt;T&gt;, public right: Tree&lt;T&gt; ) {} // common Tree methods... } class Empty&lt;T&gt; { // common Tree methods... }
This is what we do too. Method signatures, class properties, etc. are explicitly typed, everything else is inferred as much as possible. It works really well, in my experience. I've caught a few issues by not letting functions ever be inferred. The explicitness of the API also makes it clearer to humans, without having to read through the internals to figure out what it's doing.
TypeScript provides *compile* time type safety and compiles to JavaScript that has no type safety. So the moment you produce a build, all the type definitions are gone. If you want to have an object in the build, you make an object. Interfaces are just type definitions for the compiler. // before compiling interface Example { foo: string } // type cons obj: Example = { foo: 'bar' } // object // after compiling const obj = { foo: 'bar' }
I think I may have been misunderstanding your objective. Are you trying to use Typescript to generate a new code file (ie script file for Backbone.js)?
I was thinking more like this: ``` const result = () =&gt; { switch (true) { case valueToBeTexted === X: return "whatever"; default: return "default value"; } }(); // I like the IIFE here because then I can use returns in the switch instead of breaks. ``` I guess there's a bit more boilerplate there, but you can do anything in the case evaluation... You don't need your evaluation to be a supported one like `caseGreaterEqualThan()`, `caseNewerThan()`. Anyway... just my $0.02. 
I recently migrated a code base from js to ts and after setting up the webpack plugin to handle both js and ts all we had to do was start writing ts and leave the old js files alone. Sometimes we convert a file to ts if we touch a substantial amount of it but it seems like the two coexist very well together. Saved us a lot of time
I would use proper typescript clsses instead of the Backbone `extends` method. While Backbone is not designed for that, it works perfectly fine. https://benmccormick.org/2015/07/06/backbone-and-es6-classes-revisited/ The official typings don‚Äôt support typesafe setters/getters, though. 
Coming from Angular and having added types to a React project, I believe Angular default architecture just lends itself to typing a little more obviously. Angular docs promote OOP styles, and most projects have components and services that can be reasoned about as well defined typed objects. React tends to lean more functional, and as such functions tend to go up and down the component chain, resulting in patterns that either require lots of similar interfaces or more generics. Only a year or two ago, it didn't seem like the TypeScript community even preferred implicit typing, so in a React project it might seem like you had to write a boilerplate interface for props in every component layer in order to "do TypeScript right." For a JavaScript dev that is unfamiliar with TypeScript, generics seem to have dubious value. If everything is amorphous anyway, why bother typing in the first place? Seems like a lot of boilerplate. It's harder to immediately see the value, especially when the libraries you are using aren't giving you any compile errors or IntelliSense for using it. It takes using it for awhile to understand why it's so great. The broad typing support across the community has a snowball effect. Critical mass is enabling React devs to see the value of adding types to their projects.
I was going to say not using typescript, but it helps that too
My general rule is to type only function signatures. An exception to that rule would be manually specifying a literal type for a variable to gain better type safety, that usually comes up when using constant strings or numbers in conjunction with generics.
The problem is that while Angular was built with TS, it misses out on the benefits of types at the most critical level: data binding in templates. Angular *still* has infuriating runtime errors caused by simple typos and mistakes inside of string/HTML templates. TSX completely prevents this type of error by combining templating and "regular" code.
Angular probably qualifies, but that downplays how horrendous Angular 1.x was/still is.
Did y'all ever try codemod like js2ts?
This looks like a viable solution! I knew mapped types should help because they allow circular references for generic types, though I never got it right myself. I'll need to experiment with it more when I have time. Thanks!
If you want interface like behavior at runtime, use abstract classes with abstract methods. Downside is that a class can only extend one class.
Exactly they are inferred. So it's kind of being redundant but you can see the code without any editor and 'see' the types. For that reason I add signatures sometimes. Also I set return types when typescript is stupid enough to understand that some return values are indeed implementing the same interface
Of course they coexist very well since ts is transpiled to js
I have a function that I want to return a `Promise&lt;T&gt;`, and I'd like to be able to specify the return type of the promise via the type parameter of the function. So something like `function f&lt;T&gt;(‚Ä¶): Promise&lt;T&gt; {‚Ä¶}`. I hope that makes sense. So I'd like to pass this function as an argument to another function (or `then()`), without having to wrap it in an arrow function.
That syntax is clean as hell, dog. I hope it becomes accepted.
Def. There's a lot of good stuff in the [ESNext](https://github.com/tc39/proposals) queue.
no, it is not possible
If you use @babel/preset-typescript to compile your app instead of using tsc, then you'll be able to use other Babel plugins such as pipeline. Though tsc may not support the experimental syntax.
You are welcome and I understand. It is always frustrating when you are forced to work with tools that doesn't work well with your brain.
`@babel/preset-typescript` is actually included in the starter template, and is utilized during the `babel` command. I just tried building the same project by skipping the `tsc --emitDeclarationOnly` command and it worked as expected. Are there any potential drawbacks to skipping the creation of declarations?
Wait, what algorithm does `Array#sort` use?
One reason is autocomplete in your IDE.
I think the idea is you‚Äôd use a command line util provided by Babel/preset-typescript (or just Babel?) rather than calling tsc direct 
The good news: Yes, there is! The bad news: The default TS CLI does not allow you to set them for whatever reason, even though the TS compiler actually supports them under the hood. Good news again: Webpack's `ts-loader`, for instance, let's you use them. See the [ts-loader options](https://github.com/TypeStrong/ts-loader/blob/master/README.md#getcustomtransformers-----before-transformerfactory-after-transformerfactory--) . There are also alternative command line frontends for the TS compiler that let you set them. I even wrote one: [ts](https://www.npmjs.com/package/ts) Not sure if there is a transformer for the pipeline operator yet... 
That's already how Microsoft configured the starter template. It uses `tsc` to create typescript declarations only and then passes the transpilation work to `babel`. The question was more about finding out what kind of issues you might run into when skipping the declaration step.
Oh cool, didn't know about official TypeScript transform support. Def will be looking into that a bit more. Do you know of any aggregators or [awesome](https://github.com/sindresorhus/awesome)-style lists for existing transforms? Searched a bit but didn't find much. Did find a few relevant links that seem useful though: - [How to Write a TypeScript Transform (Plugin)](https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943) - [TypeScript &gt; Plugin Support for Custom Transformers](https://github.com/Microsoft/TypeScript/issues/14419) - [ttypescript](https://github.com/cevek/ttypescript) - [Zero-config code transformation with babel-plugin-macros](https://babeljs.io/blog/2017/09/11/zero-config-with-babel-macros) 
This is a good list! Not aware of any existing awesome list. You can always create one, though üôÇ
This is a good list! Not aware of any existing awesome list. You can always create one, though üôÇ
Yup. That's about it huh.
I use ttypescript. It lets you declare custom transformers in your tsconfig file.
Yeah but this one has stagnated for a couple of years. I find it frustrating there is little progress
Agreed. I wish they'd pick up a versioning system like Python, so that substantial improvements could be made over time without worrying about backwards compatibility. For example, there's a proposal for `array.lastItem`, which is unnecessary &amp; inferior compared to a negative indexing solution. However, said solution interferes with an obscure side-effect of how JavaScript treats arrays as dictionary-ish objects, so it would [break compatibilty](https://github.com/keithamus/proposal-array-last/issues/6#issuecomment-401024024).
You don't need to generate declarations if it's not a library. I just have a precommit hook which runs tsc for Typechecking.
Hey, I would definitely vote yes, but I'm biased, since I also have interest in recruiting TypeScript positions for my company, in Lisbon, Portugal!
FIGHT!
That's right, and this required code block format has been challenging me.
No, but you asked for one. All the IDE tooling is amazing. Go to definition, rename all instances etc. Parameter checking. Fearless dependency updates across major versions. Merging PRs and immediately discovering API mismatches. Immediately finding errors in your code without running it. No more surprising `unrefined is not a X` errors. No reading implementation to learn what parameters are meant to be. It's all positives. What problems were you having?
Those things were all minor inconveniences to me when I was doing pure nodejs. The problems I encounter with ts are inconsistent type system, missing types in 3rd party code, incompatible types between dependencies, difficult to impossible integrations with vscode extensions, too much configuration, breakages whenever there is a version update, hurts code readability (I mean it's nice to have a type definition for when you are writing but sometimes to express a simple js function the type definition is more complicated the function itself), it is a typed language but in no way is it type safe, i could go on. Overall it's nice to have a more capable ide with more editing features. But the trade off doesn't seem worth it to me. I would take nodejs over typescript any day. And if I needed a typed language I would find an appropriately mature and type safe language instead of using ts.
Sure. The problems you listed (esp. type conflicts) do come up, and it takes a bit of experience to navigate them. You can patch library types or update DefinitelyTyped yourself. On balance it's usually worth my time typing other libraries as needed, but I've been using TS for a year now so I've become quite efficient. If you don't want to, untyped libraries are no worse than raw JS if you just set them to `any`. Certainly haven't had any issues with vscode. It's designed for TypeScript. Wrt to TypeScript vs Node, that's a false dichotomy but I'm sure you know that. We primarily use TS in the browser where you don't really have a reasonable choice to just use a different language, and TS config is just a tiny part of hundreds of lines of webpack/Babel config etc. Honestly I don't find the config to be a problem. Integrating TS gradually into our very large codebase did have it challenges, but we're past the point of it slowing us down. I do use TS on personal node projects too, and given the chance I'd migrate from rails to node+ts for the backend. FWIW after a bit of resistance our dev team all agreed that moving to TS was the best decision we's ever made. But yeah, sounds like you're frustrated, sorry to hear it. If you have any inclination to continue I'd recommend taking advantage of the TS rooms on gitter and reactiflux/speakJS discord servers. I've learned a lot (and taught a lot) in those rooms and there is nearly always someone knowledgeable and friendly enough to get me over the hurdle I'm hitting.
The community on this subreddit might be a bit small to get anywhere near the HN Who's hiring thread, but you can always give it a shot.
This is a good idea!
How many times are you going to keep reposting this?
Post deleted
Thanks for your response. I am not trying to come off overly aggressive. I do understand the choice to use ts on the front end even though I wouldn't necessarily default to that choice. I am a backend developer and I definitely come at this issue from that perspective. When I choose a tool, I don't expect it to solve every problem or to be magical in any way. I don't think node is perfect by any means. But I expect my chosen language to just work. I don't expect to have to configure it, I don't expect to come across broken type definitions or to have to type libraries. And if it is going to be a typed language (which I have nothing against) I expect it to be type-safe. Issues I've had with vscode have mostly been extension support. Jest doesn't have a side bar or nice interface that allows you to view your tests. You can't even run them or debug them unless the test is failing. Besides ts-jest has weird behaviors that differ from when running the compiled version. That may be fixed but when I try to upgrade ts-jest the configuration file format has changed and I can't get it to work easily as expected. I tried moving to mocha / ts-node and that fixes most problems. The code behaves as expected but not the mocha sidebar extension doesn't work consistently. There's no point in switching if I can't easily run my tests by themselves without running the whole suit. Plus i can't easily migrate from jest to mocha because say I wanted to do it progressively, the type definitions conflict with each other if they are both installed at the same time. So I guess no type definitions then? You can argue that node isn't any better cause it's like writing any everywhere. That's not true. Because you have less overhead, less configuration, less hassle. And the tooling around it works. I mean no super powered editor. That's lame. But I think much less frustration overall as well.
That's because it's an interface, not a class. It does match the interface. If it were a class it would throw an error. This was always the case.
I could understand why first one does not error (it has a height). But, I don't understand why the second one does error as it fully implements the Person interface. I would also understand why both could error because neither one is actually declared to implement the Person interface. The way I see it, either both should error because they are not declared to implement Person or neither one should error because they both include the 'height' member and therefore implicitly implement the Person interface. Classes are not part of this discussion and mentioning them is irrelevant. In any case, the error can be fixed like so: testing({height: 123, somethingElse: 123} as Person)
&gt;In any case, the error can be fixed like so: testing({height: 123, somethingElse: 123} as Person) But I don't want to fix the Error because it should throw an error.
&gt;It does match the interface But it doesn't match it. Person only has one property 'height' not two or more. Also, below code produces an error(rightly) which proves it doesn't match the Person interface interface Person { height:number } let person:Person = {height: 123, somethingElse: 123} // Rightly throws an error
[removed]
The actual error for this explains why the last one errors out: &gt; Error:(100, 23) TS2345: Argument of type '{ height: number; somethingElse: number; }' is not assignable to parameter of type 'Person'. **Object literal may only specify known properties**, and 'somethingElse' does not exist in type 'Person'.
unfortunately this doesn't explain why the first one doesn't fail. 'person' is also an object literal that's been assigned to a variable. It should also fail because it doesn't match the Person interface.
Have you tried looking to see if there's typing for the libraries you're using in [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)?
There seem to be. Also some. Libraries have their own .d.ts file. How do I make use of this?
You simply import the type along with what you're working with. Example in React, you have to install `react` and `@types/react`: ``` import * as React from 'react'; // Typescript knows what to do with the @types library by default. // It will know how to resolve a type, if it doesn't exist in the original repo // Here, SFC is a type that is in `react.d.ts` import { SFC } from 'react'; interface Props { foo: string; } const App: SFC&lt;Props&gt; = ({ foo }) =&gt; { return ( &lt;p&gt;{foo}&lt;/p&gt; ); } export default App; ``` Edit: The same goes for libraries with their own &lt;library&gt;.d.ts. Typescript just knows how to resolve .d.ts files. I'm sure there's a lot of stuff happening under the hood, but I wouldn't worry too much about that
Okay so I don't see an explicit import of @types/react so I assume that by the nature of it existing in node_modules because I installed it, it will be properly discovered and used by typescript and therefore vscode? I'm 98% sure this is what you're saying in the comments. I appreciate your help. 
Yes. Add a dependency on react and @types/react package.json, import react into your file and the compiler does the rest.
The first one passes and the second one fails due to type inference. "person" is of type `{height: number, somethingElse: number}` so the compiler happily decides that implements the Person interface and lets you call the testing method. The second one is try to cast an object literal to type `Person` so you get the "Object literal may only specify known properties" error. If you want the first case to fail like the second you can do `const person: Person = {height: 123, somethingElse: 123}` This is a situation where explicitly declaring the type of a variable can be useful, depending on you want things to behave.
&gt;Those things were all minor inconveniences to me when I was doing pure nodejs I think that the larger the project and larger the team, the more useful strict types become.
&gt;Any time you have an "any" you've pretty much invalidated your type system Well don't use "any" then? I've got TS and tslint set up to fail the build if "any" is used unless tslint is explicitly disabled for that part of the code. We don't end up using "any" very often unless its for a specific purpose. &gt;if you make a network call and type the response, you have done nothing Yes you have. You've told the rest of the app the type of object it is expecting so you get compile time errors, autocomplete etc where ever that type is used. 
An interface description is inclusive, not exclusive. You can add fields to a class that implements an interface. Because you did not explicitly declare that ` let person = {height: 123, somethingElse: 123};` was exactly interface `Person` in your original example it lets it go. `let person = {height: 123, somethingElse: 123};` Is implicitly at least a `Person`, maybe its a `class SomePerson extends Person` so it works in places that need a `Person` `let person:Person = {height: 123, somethingElse: 123}` Explicitly a `Person` so it cannot have additional fields. `testing({height: 123, somethingElse: 123})` Explicitly a person in this case too (your not retaining the `somethingElse` property so its usesless) so follows the above case. [Longer article explaining interfaces because I'm lazy](http://www.syntaxsuccess.com/viewarticle/object-models-and-inheritance-in-typescript) .... now Person doesnt look like a real word anymore.
Absolutely. I would just never choose typescript as a viable static language. I have been using it for half a year and my frustration with it has just increased. Remember I am a backend dev so I could choose another language like golang. But sadly I am not the one calling the shots. Although I am pushing to move away from typescript. 
Yeah but as I said. It's documentation. It's expensive documentation. Expensive in terms of all the problems I've listed above that I take on to have this "precious" ide auto complete. It's not type safe. Typescript is typed but it's never type-safe. I use strict in my tsconfig. I am not half assing it with the types. I try very hard to keep everything as types as possible. But that's what sucks. The work I put in typing my ts code and making sure it compiles is way more than I ever did managing js. And maybe it would be worth it if it wasn't just glorified documentation. 
hey can somebody hire me im starving thanks in advance fellas
Well I don't know what it is your doing but your experience isn't universal. I'm mainly a backend dev and have been doing using TS for about 18 months for both frontend and backend work after years of Java and don't have all these problems your having. I make regular use of the type system, eg around refactoring and adding types to rest calls. For me the types are letting the compiler catch problems exactly as I'd expect it to. 
Sure it can catch internal errors if you are really careful about how you use the type system. Like if you say the funtion A takes a parameter of type string and you try to pass a number. Sure the compiler will save you. That works well enough. However what I am talking about is a rarer case. Suppose an api returns an obect with some key that is an array of something. You can type it as such. But the day the api changes and that key is no longer an array when you are gonna call map on it or access an index you are gonna break at runtime, somewhere in some unreadable transpiled .js file and perhaps somewhere far away from when you got the "wrongly typed - type safe" data. Hence, typescript !== type-safe. Not even if you try to coerce it like this typescript != type-safe. Its a rarer case. But my experience of typescript is that people don't write validation logic because they have types. And i don't blame them. Its hard to realise that maybe you should check the element is an array if you told the compiler to tell you that it is one. I've said it before, this isn't typescripts fault. Its hard to type javascript. There may be some value in it. Especially for the front end where your only choice is some javascript derivative language. But on the backend, i can't help but feel that typescript is a bad static language. I would want to use either a good dynamic language, or a good static language, or better a language that bests fits the problems i am trying to solve. And typescript is neither of those things.
Interesting. Not sure what you mean by side bar, you mean like a UI element for your IDE? I am a bit more minimalist when it comes to testing. I use tap or node-tape, and using TypeScript doesn't make any difference (the former didn't have typings last I checked).
sure. Thats completely reasonable. I generally like to have some kind of UI that displays my tests and allows me to navigate to them easily, and know which ones are passing and which ones are failing. That lets me run or debug them individually. You get that built in with IDEs like webstorm or similar. But i much prefer vscode, and you can get all (plus more visually appealing) with vscode with extensions like `Mocha Test Explorer`. Works like a charm in javascript projects. As soon as you pass over to ts-node/mocha its unreliable. In some repos it works, and in some i get this error: ``` Error: Debug Failure. Output generation failed at Object.transpileModule (/home/davidmdm/Documents/development/e2-stingray/node_modules/typescript/lib/typescript.js:105165:29) at getOutput (/home/davidmdm/Documents/development/e2-stingray/node_modules/ts-node/src/index.ts:245:23) at Object.compile (/home/davidmdm/Documents/development/e2-stingray/node_modules/ts-node/src/index.ts:513:11) at Module.m._compile (/home/davidmdm/Documents/development/e2-stingray/node_modules/ts-node/src/index.ts:400:43) at Module._extensions..js (internal/modules/cjs/loader.js:700:10) at Object.require.extensions.(anonymous function) [as .ts] (/home/davidmdm/Documents/development/e2-stingray/node_modules/ts-node/src/index.ts:403:12) at Module.load (internal/modules/cjs/loader.js:599:32) at tryModuleLoad (internal/modules/cjs/loader.js:538:12) at Function.Module._load (internal/modules/cjs/loader.js:530:3) at Module.require (internal/modules/cjs/loader.js:637:17) ``` Which i can't solve and when i google turns up nothing. This isn't a direct problem of typescript. Typescript isn't directly involved as such. But its just the environment and tooling has to be easy to use somewhat. I want to be able to debug without playing in launch.json every time, and I don't want to be running individual tests via the command line constanly. But if node-tape works for you i might check it out.
Small correction, it's tape and [node-tap](https://www.node-tap.org/). The latter has typings via DT. No vscode integration that I'm aware of. It's not for everyone, but I like its simplicity. This is a quick rundown of the differences: https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4
There's [this thing](https://marketplace.visualstudio.com/items?itemName=numaru.vscode-tap) which doesn't really sound like what you want.
Interesting a lot of that felt like the difference between mocha and jest. I guess it's jest (heavy) mocha (medium) tape (light weight) frameworks. I like what I quickly read. I may look into it. But as a I said above √† ui is a nice to have for tests! 
Yeah I should look into that. All our tests are ruby minitest.
Yeah I should look into that. All our tests are ruby minitest.
Have a look at https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c 
We always use interface because you can do more, like extend them or turn into a class. But types are very useful for enums, or union types, but those are not common cases. Otherwise interface just because it's easy to have a standard
To be fair TypeScript loses some of the value of type aliases by not displaying the aliased name in compiler errors. A type alias is also useful for talking about an instance of a highly parameterized type. Also functions - especially curried ones.
I'm looking especially for TypeScript positions atm so this would be dope
when using strictNullChecks you very often have to specify that the value --- string in our case --- can be `string | null | undefined` and you have to do it very frequently. for this purpose you can create a type to handle this. `type nullableString = string | null | undefined;` and then reuse it in our interfaces instead of writing the redundant or clauses every time interface Dog { name: nullableString; } either the dogs name hasn't been given yet, we chose not to give it a name (null) or we actually gave it a name
Ok maybe I'm dense, but I got halfway though that article without being any wiser. Shouldn't there be a soild easy to explain difference between the two, and when to use them? Personally I use interfaces to describe objects, and types to describe functions. Maybe I'm doing it wrong.
Recent versions of typescript display the aliased name in errors when using type aliases, and allow implementation by classes if the aliased type is a product type (the type cannot be a union). Really now the only reason to use interfaces over type aliases is declaration merging.
Nice. I'm stuck on 2.4 at work right now, so it's good to know I have something to look forward to.
Basically there are some things that you used to be able do with an interface type: 1. Extend an interface like `interface A extends B` 2. Similarly, implement an interface in a class `class A implements B` 3. Display the interface name in errors instead of the interface body `Class A does not correctly implement the interface B` vs `Class A does not correctly implement the interface { some complicated stuff here }` 4. Merge interface declarations `interface A { x: string; }; interface A { y: number; }` becomes `interface A { x: string; y: number; }` With newer versions of typescript, type aliases can do 1, 2, and 3, with some caveats. A type alias cannot be a union type (`type A = string|number`) if you want to use it to extend or implement 
Yeah we recently upgraded our web app to angular v7 so that we could use typescript 2.9+. No problems so far and I'm loving the new stuff they've done with tuples.
All objects have string keys in JavaScript, that's just a reflection of the underlying reality. Being able to restrict keys of `Record` to numbers is just a convenience to mark your intent (keying by id for example).
They are distinctly different and I think it's odd that people discuss them interchangeably. It's simple once you get the hang of it: - `interface` is for when you need to define the shape of something. It could be broken down more. - `type` is for when you need to define a discrete something. It can't be broken down any smaller. Example: // this defines the duck typing of an object, and could be // broken down into "word" and "count" as different types interface SomeObject { word: string, count: number } // you can't get any smaller than this, it doesn't define // duck typing - just an actual type type Useless&lt;T&gt; = T extends string ? T : never My experience has been that the longer you use TypeScript, the more `type` you use over `interface`, because composing types results in (subjectively) easier/better code than inheritance interfaces. I tend to use interfaces now mostly for their purpose - ensuring an object duck types the way I expect. Almost everything else is a class or a `type`.
I understand this part, but it still doesn't explain why you'd ever use types then? Why not use interface always? Why do we even need type? Like I said, for me the reason I use types is for functions. So like this: interface myFnOptions { height: number; age: number; name?: string; } type getUser = (id: number, options: myFnOptions) =&gt; Promise&lt;User&gt;; interface MyClass { location: string; getUser: getUser; ... } So that's kind of where I'm at with this, but I am not sure if that's 100% how you're supposed to do. 
An interface can only express a [product type](https://en.wikipedia.org/wiki/Product_type). All object types, including tuples, arrays, plain objects, prototypes for primitives are product types because they combine multiple types together in some kind of structure. In the case of objects, this structure is as a record with string keys, e.g. `{ x: string, y: number }` is the product of the primitive types `string` and `number`. A function is also a product type, and in fact you can express the type of a function as an interface: interface getUser { (id: number, options: myFnOptions): Promise&lt;User&gt; } If you want to express the type of a variable that can be either a string **or** a number, you would need a [sum type](https://en.wikipedia.org/wiki/Tagged_union), written in typescript as `type T = string | number`. You certainly don't need to use interface declarations for product types, and I prefer to use a single syntax for type declarations, which means I declare both product and sum types using the `type Bar =` syntax.
**Product type** In programming languages and type theory, a product of types is another, compounded, type in a structure. The "operands" of the product are types, and the structure of a product type is determined by the fixed order of the operands in the product. An instance of a product type retains the fixed order, but otherwise may contain all possible instances of its primitive data types. The expression of an instance of a product type will be a tuple, and is called a "tuple type" of expression. *** **Tagged union** In computer science, a tagged union, also called a variant, variant record, choice type, discriminated union, disjoint union, or sum type, is a data structure used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a tag field explicitly indicates which one is in use. It can be thought of as a type that has several "cases," each of which should be handled correctly when that type is manipulated. Like ordinary unions, tagged unions can save storage by overlapping storage areas for each type, since only one is in use at a time. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/typescript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
If those api's were providing their own types and you were using the recent definitions then the issue would be caught. If an api updates with breaking changes and you aren't responding to that proactively that's not really the languages fault. You would get the same problem in any language. Obviously, the types aren't always provided, so the other approach is to use the unknown type and type guards. This ensures that 1) you're getting the data you expect from the api, and 2) you're using the data correctly there after. I argue that there is no reason to use native JavaScript while TypeScript exists. I've worked on massive Python and pure JavaScript code bases, and some ruby. I assure you that whatever pain you're experiencing because of TypeScript is dwarfed by the pain of dealing with a purely untyped code base. Personally, TypeScript has let me quickly grok and refactor large and complicated pieces of code successfully. The fact that MyPy and the optional static typing in Python 3 and Sorbet (and a few other projects) beginning to provide gradual type systems for Ruby really points to the fact that dynamic typed languages are not good for large projects. The fact is that types exist, even in dynamic programming languages, and functions and classes have expected inputs and outputs. Either people manually keep the documentation up to date (which even if up to date can be wrong) or you just push the work of understanding those inputs and outputs to everyone else having to read the code. I definitely appreciate not always having to read the code to know how to use it. I think the type system in TypeScript is descriptive and matches very closely with how most people think about types in a dynamic programming language, specifically structural typing, duck typing, and generics, and maybe function types. The people that complain that typed programming languages are too restrictive are mostly complaining the lack of one of those in a type system whether they know it or not. So if you have to write JavaScript, it should be in TypeScript. 
No you're not being dense. Unless you need the specific features of an interface then like lots of stuff it's partly a matter of convention. 
What confuses me is that you can also write ``` interface IArticle { title: string; body: string; } const article: IArticle = { title: 'my title', body: 'my body' }; ``` or ``` type Article = { title: string; body: string; }; const article: Article = { title: 'my title', body: 'my body' }; ``` So what's the difference? Which one should I use in this case?
Both are valid choices and I find brainbag's explanation confusing at best. I personally use `interface` for reference types (EG where you would build an abstract class or interface in Java, C# or C++) and I use `type` for immutable value types (EG where you would use a `struct` or `typedef` in C# or C(++))
So in this case, you would use `type`? I've been using `interface` to model objects (such as the article example given above), but I've seen people use `type` instead. I'm still confused lol.
I think there is an elegance and a simplicity to working in JavaScript that is simply not there is ts. That simplicity expresses itself in the code you write, in the tooling surrounding the language. For sure, JavaScript and all dynamic languages struggle to remain simple as the project grows. In my experience it hasn't been a problem if your modules are well encapsulated and clear in their purpose, but I get it. It's not for everyone and types are a thing people like. I also like a good type system and I am not here on this Reddit complaining about type systems and how JavaScript is the best thing in the world. I am saying that typescript is a pain to work with. Some of that pain is due to its type system. My main issue with it is that it can't guarantee type safety. Other issues with it is that it's feature set aren't orthogonal in the least. Interfaces vs types for object literals? They do practically the same thing in ts. Maybe you know the special semantics and edge cases where one differs from the other but I'm willing to bet most people don't. The language isn't well designed in that sense. The fact that it's configuration based, but that migrating versions or changing the es target breaks builds and are extremely hard and cryptic to fix. That errors are more often than not unreadable. I recently had the fortune to work on a cli tool and was allowed to do it in js. I was nervous about it because I had been using ts for a while. It was a breeze. So much less hassle to set up. I naturally wrote validation and refactoring was not nearly as bad as I thought it might be. Anyways I'm rambling so let's cut it short. I understand the "why" of typescript. I just don't think it holds up when compared to other languages like go or even js in the right context. It's just very frustrating to have to work in it.
I'd like to actually address when one or the other should be used. My personal opinion is the following: &amp;#x200B; I use \`interface\`s in the same way I would use them in other languages: to define the shape and methods of an object: &amp;#x200B; interface Named { readonly name: string; setName(name: string): void; } class User implements Named { ... } class Dog implements Named { ... } &amp;#x200B; I use \`type\` to define geenric transformations for other types: &amp;#x200B; type Nullable&lt;T&gt; = T | null | undefined; type NonNull&lt;T&gt; = T extends (null | undefined) ? never : T; &amp;#x200B; Or aliases for long complex types that are cumbersome to type manually: &amp;#x200B; type Primitive = number | string | boolean | null | undefined; &amp;#x200B; And while it's possible to use \`type\` for defining the shape of an object: &amp;#x200B; type Named = { readonly name: string; setName(name: string): void; } &amp;#x200B; I avoid this, because with \`interface\` it is more clear than it is intended to be implemented and used as a contract regarding object usage, whereas \`type\` is usually used for creating aliases of other types (making the code more concise) or to reflect the runtime transformations of object on the type level. E.g. if my runtime ensures that an object is not \`null\` or \`undefined\`, I may use the \`NonNull\` from the above example to narrow its type. &amp;#x200B; P. S. One may argue that \`interface\` is also a mere alias for object type. However, I feel like their place in OOP in somewhat special, which is why I tend to use them. That said, I don't think we would lose anything if we had extendable and implementable \`type\`s and no \`interface\`s.
You‚Äôre exporting this using non-ES6 syntax - try using modern JavaScript syntax and it‚Äôll probably work
You *can* do that, but the intent of them is how I described it. This comment from someone else explains some of the deeper differences - https://www.reddit.com/r/typescript/comments/a6aap8/type_vs_interface/ebtfgpg/
They're "valid" choices but are not the same thing, as [others have outlined](https://www.reddit.com/r/typescript/comments/a6aap8/type_vs_interface/ebtfgpg/). If you use them interchangeably, you're going to eventually run into issues and/or you're going to annoy people who understand the difference. As far as your confusion about my reply, if you look at TypeScript itself, and other libraries that are designed by people who understand type systems, they are used the way I described it. An interface is the classical definition of an interface - it defines an API. A type is a singular defined type. The fact that they're moderately interchangeable is more of a characteristic of adding types to a dynamic duck typed language like JavaScript.
Try a relative path for `module app.config` instead of just the file name.
I updated my original post to add extra details that will hopefully help. https://www.reddit.com/r/typescript/comments/a6aap8/type_vs_interface/ebtg44i/
If your `test` method can use rest parameters, you can use a [mapped type](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#mapped-types), like this: function test&lt;T extends string[]&gt;(...values: T): { [P in keyof T] : T[P] } { return values; } let result = test('foo', 'bar', 'baz'] // result infers as ['foo', 'bar', 'baz'] I don't believe you can do it without rest parameters because of how TypeScript infers types.
How often does null come up in your objects? In my experience objects either have the non-null/defined value/type or it's undefined, hence the existence of the `?:` syntax.
null are defined values that don't have data. imagine creating a cache for a request. if the value is undefined, then call the server in order to set the value. if the value value is null or has data, then it means that the value is cached and the server doesn't need to make an unessesary request.
You could solve it by adding explicit overloads for each tuple: https://agentcooper.github.io/typescript-play/#code/GYVwdgxgLglg9mABFApgZygHgCoEZEoAeqYAJmohgE4xgDmAfABQBuAhgDYjoBciA2ngC6ASj6DcQgNwAoUJFgJk6LHgLEUZCtVp0ANImwAmdSXKUoNes3ZdeAvAeOjxjw0elzw0eElQYcfCIzbUtdJxNgzXMdeicAZlNo0KtGVk5uNFdcCISXBxz3PNl5HyV-VQA1DPQkrQtU-iEbGqzDars0MXbWxABvGUREKhQoECokW0zZAF8ZGQgEDERCRABeZQwmfgByYDg4HYMdgCM2KiPEU7YALx3RWRkgA
I gave it a shot using `import` but nothing was working. But actually if I use a `require` statement instead and keep to `module.exports = ...` in app.config.js then I get no error and everything works fine. This is a dirty and not pleasant solution since what is required into the other file is typed as `any` by default. So I suppose a way to fix my problem is to use `require` and `module.exports` instead of `import` and `export`, which would bring up the error. I just have to learn how to write and utilise a '&lt;name&gt;.d.ts' file for app.config.js so it won't be implicitly typed as `any`...
No, I‚Äôm saying you shouldn‚Äôt use module.exports
I was doing that in the import statement but in the d.ts file I was trying to make, the IDE nagged at me not to name the module as a fixed path. Thank you for taking time to respond
You are, and I'm saying that using module.exports and require have worked while using import and export also necessitates extra work in understanding how and where to utilise a typings file for my module
To get to app name you‚Äôd have to use app.app.name with the ‚Äúimport * as app‚Äù - are you doing that?
Before I was doing `import * as config`.
Here, returning \` { \[P in keyof T\] : T\[P\] }\` would be the same as returning just \`T\` no? And yeah, I've seen this little helper function floating around in some places, usually called \`tuple\`, just to easily create an inferred literal array type. const tuple = &lt;V extends any[]&gt;(...values: V) =&gt; values Doing \`extends any\[\]\` instead of \`string\[\]\` widens each literal to \`string\` in the case of an array of strings, but makes it more general. Could easily make a \`stringTuple\` function with \`extends string\[\]\` if needed
What is your noImplicitAny setting is tsconfig? https://basarat.gitbooks.io/typescript/docs/options/noImplicitAny.html
Btw, sorry I didn‚Äôt notice that was a js file.
It's set to true. https://stackoverflow.com/a/51432561/8387505 &gt;Error: Land mine detected ahead... Solution: turn off the land mine sensors!
Also, allowJs setting?
Not included in tsconfig so default value
Yes, the issue here is just that the type of `['foo', 'bar', 'baz']` is `string[]`. This tuple function is neat!
So, did that solve the problem?
What are you referring to?
The [handbook](http://www.typescriptlang.org/docs/handbook/basic-types.html) is probabbly the best resource. You maybe can email Motto's team to get a discount but imo everything you need is in the typescript web itself.
Thanks for the reply, glad to answer that. &gt; Here, returning { [P in keyof T] : T[P] } would be the same as returning just T no? Close but no (that's what the OP is asking) - [TypeScript doesn't infer tuples from generics by design](https://github.com/Microsoft/TypeScript/issues/22679) because it would break other things. If you want to return the set of specific literal types and not generally inferred types, you have to use a mapped type. The OP's code example infers as `string[]` but if you specifically map it with `{ [P in keyof T]: T[P] }`, it will return the most specific types, which are the literals in this case. &gt; `const tuple = &lt;V extends any[]&gt;(...values: V) =&gt; values` This is correct, it will map to a tuple set, but /u/evmar was specifically asking about the tuple being the *literal* type, not the type. Here are the three different scenarios: function test&lt;TValues extends string[]&gt;(values: TValues): TValues { return values; } const tuple = &lt;V extends any[]&gt;(...values: V) =&gt; values function test2&lt;T extends string[]&gt;(...values: T): { [P in keyof T] : T[P] } { return values; } // infers as string[] const x = test(['foo', 'bar', 'baz']) // infers as generic tuple [string, string, string] const y = tuple('foo', 'bar', 'baz') // infers as literal tuple ['foo', 'bar', 'baz] const z = test2('foo', 'bar', 'baz')
I would agree! 
Thanks for the info, but I think my point was missed somewhere. The tuple function I gave there wasn't an alternative to OP's solution, but just a general aside to show what people are using to do something similar. I even suggested that an additional `stringTuple` function could be made with `extends string[]` instead of `extends any[]` Here's the point I was trying to make: in the case of `extends string[]` the mapped type isn't necessary. const tuple = &lt;V extends string[]&gt;(...values: V) =&gt; values const tupleMapType = &lt;T extends string[]&gt;(...values: T): { [P in keyof T] : T[P] } =&gt; values // infers as ['foo', 'bar', 'baz'] const result1 = tuple('foo', 'bar', 'baz') // infers as ['foo', 'bar', 'baz'] const result2 = tupleMapType('foo', 'bar', 'baz')
Also agree. That is where I learned everything I needed, basically.
Welcome aboard!
You're right! Sorry that I missed your intent. The example you gave does infer the mapped tuple return value when extends has a defined type. I'm pretty sure it didn't used to do that, so it must have changed in a recent TypeScript. Thanks for the follow up clarification.
Typescript Deep Dive: [https://basarat.gitbooks.io/typescript/content/](https://basarat.gitbooks.io/typescript/content/)
There should be a plug-in for vue-cli now. Some guys in the next town over have worked on it. 
https://github.com/marius815/vue-cli-plugin-nuxt-typescript/blob/master/README.md
[removed]
[Pluralsight](https://app.pluralsight.com/library/search?q=typescript) is free this weekend if you have the time. 
"TypeScript Deep Dive," by Basarat, the official handbook, and asking specific questions -- with complete code examples -- on this subreddit.
It sounds like you don‚Äôt want to wait a few months, but Orielly‚Äôs Programming TypeScript is coming out in April (I wrote it!).
`const` is documentation. It tells the reader what your intentions are with the variable or parameter. As documentation, I haven't used TypeScript or C++ const enough to form an opinion as to which is preferable. 
I think the const idea is cool, however it doesn‚Äôt protect you from modifying a nested object referenced by the class. That means it can‚Äôt really guarantee immutability, so I feel like it‚Äôs a bit misleading. I‚Äôm all for more tools to lock down bugs like this. I think the lifetimes concept is also cool, however it‚Äôs less necessary in JavaScript because 1. Everything runs on a single thread so data races can‚Äôt happen, 2. Everything is garbage collected and passed by reference,(except primitives), so it doesn‚Äôt really help with memory bugs or reduce memory usage. It might help with catching shared state bugs though. Good stuff though.
The way I implemented const does protect you from modifying the nested objects. class A{ n: number; } class C{ x: A; } let obj: const C; let inner = obj.x; // type is const A inner.n = 6; // Error: property is readonly obj.inner.n++; // Error: similarly property is readonly &amp;#x200B;
This is awesome! The const modifier you wrote is definitely useful. Although the naming is not good for TS because const has a completely different meaning for variable declarations - should maybe be something like `immutable` or `immut` (as an opposite of `let mut` in Rust). Also, I'm not sure if a new syntax for this is even needed, something like this should be equivalent: class A { x: number = 0; f(this: DeepReadonly&lt;A&gt;) { this.g(); } g() { this.x++; } } let arr: DeepReadonly&lt;number[]&gt; = []; arr[0] = 1; this needs a [DeepReadonly](https://github.com/Microsoft/TypeScript/issues/13923) type that correctly removes all functions that take `(this: T)` but not those that take `(this: DeepReadonly&lt;T&gt;)` which I couldn't manage to do right now: https://i.imgur.com/20gJIQ8.png does not work because apparently the "this" parameter counts as "any" if it is not specified for class instance methods (which matches DeepReadonly&lt;any&gt;). So basically to make something equivalent work without introducing new syntax, one would have to infer stricter `this` typing for methods that don't explicitly specify the this type. Something like this is also currently accepted by TS even though it shouldn't be: https://i.imgur.com/ribPVS6.png . Couldn't find an open issue about this right now, though a ton of people have this problem. --- Regarding the lifetimes: That's pretty neat, but I can't really think of cases where that would prevent any errors really and not just make writing code much more cumbersome. The GC already takes care of all leaks which I think is good enough. Something that I think would be much more interesting is adding * operator overloading * slice syntax like numpy (`arr[2:3, 1:] ‚áî arr.slice(4,10).map(inner =&gt; inner.slice(1))` * but also on the left hand side, e.g. `arr[[1,0]] = arr[[0,1]]` which swaps values) * an implicit function syntax: `arr.map(_.foo) ‚áî arr.map(x =&gt; x.foo())` [like scala](https://ananthakumaran.in/2010/03/29/scala-underscore-magic.html) * [pipelines](https://github.com/tc39/proposal-pipeline-operator)
Yes, at first I also wanted to define a type like `DeepReadonly` to filter out "invalid" member functions and make the members readonly but to my greatest disappointment the following is valid: let x: {readonly a: number} = {a: 10}; f(x); function f(x: {a: number}){ x.a = 11; } &amp;#x200B;
I like the transitive const (other than the name), I don't understand why C++'s one wasn't designed that way (D's for example [was](https://dlang.org/articles/const-faq.html#transitive-const)). I would however prefer if the qualifiers on functions could be inferred automatically.
Maybe be you can use tagged template literals to do so that. For example: ```js const foo = graphql` ...yourQuery `; ``` They are widely used for things like graphql, css, templating etc.
Is there a link to a repo to see your implementation?
Graphql handles it by parsing the tagged template literals and generates types by querying the server. I would like to see something similar for sql. It should be possible to run some queries to analyze the type of any sql query, and generate an interface for it. 
Someone posted an hour before you talking about extending the compiler, maybe you can ask them: https://www.reddit.com/r/typescript/comments/a6nh3h/usefulness_of_const_and_lifetime_annotations_in
Flow was trash for the most part -- i'd say the biggest value it provided was giving TypeScript some competition
Unfortunately TypeScript has plenty of these unsafeties. The reason is always either "by design", "architectural limitation" or to make it easier for JS devs to adapt.
Neat. I've been thinking about using diffs for incremental game saves on a little project of mine, so I'll keep an eye on this.
We've updated our FAQ on this topic to make sure things are clear and properly linked. [https://aka.ms/vsicfaq](https://aka.ms/vsicfaq)
Really cool to see this! I think the combination of React and TypeScript is fantastic. You‚Äôre doing everyone a great service. I just read through the Components section and have some quick feedback. * Use `any`, use `object`, but an empty `{}` as a generic or type is an anti-pattern. I use `object` in my component generics when I don‚Äôt make use of the props or state. * You need to initialize your local state in the constructor or you‚Äôre likely to run into trouble. * I find it‚Äôs a best practice to use consistent names for your interfaces in components. Rather than `CardProps` and `CardState`, I consistently use `ComponentProps` and `LocalState`. When it‚Äôs a Redux container, I have `ActionProps` and `StateProps`. Component names change, interfaces get referenced in other function constructors, and having to remember the name of every single interface is a waste of energy. Consistent names keeps things easier to read and work with. Glad to see your section on events. I think the way TS assists with event handling is one of its more useful features when dealing with a React.
That actually looks like a bug , apparently {readonly x: number} extends {x: number }, which doesn't make sense.
I would probably get in touch with the maintainers of `@types/mocha` first, make some contributions, assuming it's maintained. Otherwise offer to maintain it yourself. I'd say do this for a while before bringing the types into your module directly. You might decide not to. Some javascripty libraries can have type definitions that seem too opinionated for some or too un-opinionated for others. Keeping the types separate give people the option to use something else. From what I've heard creating types from JSDoc doesn't work too well but I guess YMMV. DefinitelyTyped itself has some very opinionated linting in place already along with testing requirements. It's some ready-made structure for types maintenance that you won't have to come up with yourself.
Thanks for the suggestion. I‚Äôll try working with them. One thing I‚Äôm concerned about is having the typings match the public API surface (no more, no less). I wonder how they determine where to stop with the types..?
&gt; Testing, linting, or otherwise validating the typings No real point in linting or testing IMO. The only "real" way to ensure that the typings are correct is to have the source in TypeScript, which I assume is a non-starter. &gt; What of @types/mocha if we do? Deprecate it. See `moment` as an example of how this was done. &gt; Is this a bad idea? I‚Äôve seen other projects do this, and it seems we could provide more timely updates. But without validation, we couldn‚Äôt be sure the typings would be even usable. Just copy over the types from DefinitelyTyped as a start. No guarantee they're 100% correct, but that's not different that the currently @types/mocha package.
Notes: \- It is useful to go into the \`@types/mocha\` repo and check \`mocha-tests.ts\` to find usage examples. \- If you both gain control over the \`@types/mocha\` repository, you can turn it into a stub like \`@types/chalk\`'s, where it can be \`npm install\`ed, but do nothing as a stub and remind users they can safely uninstall it. Don't let the \`@types/mocha\` repository go um-maintained after adding typings to the main repository or it can potentially be a security risk. \- Mocha is one of the best projects on npm as-is, but I imagine that you will manage to find at least a few bugs by re-writing the project in typescript.
&gt; you will manage to find at least a few bugs by re-writing the project in typescript. Having typescript compilation running in `strict` mode.
&gt; The only "real" way to ensure that the typings are correct is to have the source in TypeScript, which I assume is a non-starter. Not necessary. In some cases, it's enough to write a few very simple tests in typescript. Such tests should be executed on `dist` version (prepared for npm publishing) with d.ts stuff included.
There is an angular compiler option for that. Full template check.
Unrelated, but thank you for still developing `mocha`. It is a better library then Jest IMO, and I've used both in TDD for many hours.
There are arguments for both approaches. &amp;#x200B; Bundling them in the package makes it easier for developers but it slows the rate at which fixes to the typings can be published, you would have to release a whole new version of mocha to get a fixed typing out there. &amp;#x200B; Having the typings in an \`@types\` package lets it be updated quickly and most typescript devs are used to pulling in an \`@types\` package if they need to. I have had the odd problem with the \`@types\` I maintain and the shear size of the dt repository.
With regards to #1: There are some established linting standards but since they're typings then there isn't a very high expectation for this. Devs infrequently check typings. It is helpful and useful to include `tsdoc` doc comments though, which help with users reading docs via code completion. https://github.com/Microsoft/tsdoc With regards to #2: There can be deprecated `@types/` packages -- the maintainers of them are familiar with this process. Any user that goes to the project page at `npmjs.com/package/@types/mocha` or adding `@types/mocha` as a dep would With regards to #3: I am not sure about this one. You can write tests in TypeScript that use the supplied typings though. With regards to #4: It is not at all bad to ship typings with the `mocha` package itself. As you said many projects do this, and you are correct in assuming there is the possibility that typings will be out of sync with actual code. As I said, you can write tests in TS, but that can introduce significant duplication of effort (eg: writing tests in both JS and TS.) There is the open possibility that all new tests could be written in TS to address this.
I have to say that's a very interesting library. Looks nice!
Thanks! This is great to read. üôÇ 
Thanks for the feedback. If Mocha can better serve typescript users (short of being rewritten in typescript; highly unlikely to happen), please make an issue with your suggested enhancements, assuming you haven‚Äôt done so already. 
You don't need to do the self = this thing here because you are using an arrow function inside your callback. If you would write return new Promise(function(resolve, reject){}... then you would have to do it. Arrow functions keep their this scope. Sorry for the crude explanation, kinda in a hurry right now.
\&gt; When should i use "let self = this;"? Never ever.
Please don't ever do this.
&gt; If you would write return new Promise(function(resolve, reject){}... then you would have to do it. &gt; &gt; You wouldn't *have to* either, as there is always `(function(){}).bind(this)`
d3 forced me to do this for the first time in my development life a few weeks ago. I still feel dirty. * \* In all fairness it's also entirely possible that my limited experience with d3 meant I was engaging in an anti-pattern, but given the poor quality of most d3 content on the web - it reminds me a bit of Wordpress and jQuery - I'm doubtful.
Oh gosh it's like I've transported back in time
It‚Äôs worth the effort to figure out the compiler API for this. Use a tool like: https://astexplorer.net to get familiar with what the AST looks like
Something needs to handle the imported CSS, for example, generate a CSS file that a bundler like Webpack does. What do you use for bundling? If you don't bundle, what do you expect to happen when you import a CSS file?
This is a great idea! One suggestion: use Babel 7‚Äôs AST APIs instead of using TSC directly. Babel has much more ergonomic APIs, and the types API comes with TS typings out of the box: - @babel/types - @babel/parser - @babel/generator
Codeshift might be what you're looking for. https://www.npmjs.com/package/jscodeshift You can programmatically rewrite code.
Well if you're using an old library that forces you use a provided `this` in a callback function, you might need both instances of `this`, and `bind` would get rid of the provided `this`. But you should more likely just use a better library at that point. 
Then your best bet is to integrate some CSS in JS library to archieve this. Otherwise, you will need other bundle tools to deal with CSS files.
You need it if you're using the function keyword: submit() { let self = this; const f = function() { // Here you need 'self' because the function keyword // means this has it's own 'this'. }; const a = () =&gt; { // Here you don't need 'self' as arrow functions don't // get their own 'this' so 'this' and 'self' have the same value. }; }
If you‚Äôre within scope to use the self var then you should be able to bind the function instead. Or you could also use an arrow function.
Well, Webpack is what usually provides that functionality, and TypeScript can't do it, so you'll need Webpack or something that takes over this function from Webpack. Why are you not using Webpack, and are you using anything else? That could help us suggest the best way forward.
There was some reason that neither of those worked, I tried. It was at my old place though, I just changed jobs. So sadly I can't provide a code example.
I never use it anyway, but I saw it in the code at work.. The team member and the team leader are using it.. So I did console.log(this) and then console.log(self) after and before the Promise and I didn't get undefined.. Its why I asked this question but yes seems useless.. 
I never use it anyway, but I saw it in the code at work.. The team member and the team leader are using it.. So I did console.log(this) and then console.log(self) after and before the Promise and I didn't get undefined.. Its why I asked this question but yes seems useless..
There are libraries that bind important data to this, highcharts does it to some callbacks... It sucks
Tru dat. Good point
There is a package that implements the NoInfer too [https://www.npmjs.com/package/type-zoo](https://www.npmjs.com/package/type-zoo), although I don't know how it works. It reference [this issue](https://github.com/Microsoft/TypeScript/issues/14829#issuecomment-322267089) in typescript. Hope it helps. &amp;#x200B; psss, checkout [reduxs](https://github.com/LeDDGroup/reduxs)
Why?
f.bind(this)
Ah great idea! Seems like I could add a Babel plugin, [https://babeljs.io/docs/en/plugins](https://babeljs.io/docs/en/plugins) and avoid having to deal with any of the primitives directly.
Oh that's cool! The high level API looks much more pleasant than directly dealing with typescript - will give it a look!
I'm familiar enough with ASTs...to be dangerous but even getting a toy example up just using the TypeScript compiler AST was pretty painful so was really looking for a more "batteries included" option.
Everything you said is a load of verbal garbage. And your web page is full of more crap. Whatever you're building is going nowhere. The only good thing you said was trying to learn new things. Good on you folks, keep it up. Sorry, everyone starting out needs some doubters so you can overcome it. Prove me wrong. You won't because you idea is stupid, you're building a solution looking for a problem. But criticism either galvanizes you or breaks you. Good luck.
If you can modify the file, you can turn it into a ts file with a string. 
If you don‚Äôt want to bundle it, you can make a separate ajax request for the file. 
Your link does not work.
Here is the code, you can paste in an editor/the playground to inspect the types: type NoInfer&lt;T&gt; = T &amp; { [K in keyof T]: T[K] } export const widens = &lt;T extends string, U extends Record&lt;string, T&gt;&gt;(o: U): U =&gt; o export const doesNotWiden = &lt;T extends string, U extends Record&lt;string, T&gt;&gt;(o: U): NoInfer&lt;U&gt; =&gt; o const a = widens({ prop: 'This will turn into a string' }) const b = doesNotWiden({ prop: 'This will stay a string literal' }) const c = () =&gt; ({ prop: a.prop }) const d = () =&gt; ({ prop: b.prop }) // Inspect the types of c and d &amp;#x200B;
Yeah, I know about NoInfer and how it works, it's just really strange how it works if I use it on the return type, I don't know how exactly does it prevent widening of the string literals in the example. Also, thanks for the link, but at this point I'm more curious about the TypeScript part than solving redux :D
Interesting. What else is out there that natively supports TypeScript (and not transpiled down to Javascript)?
Well, the JS engine on the neonious one actually does not support TypeScript typings.. It does not need to, as the notation is only there for type checking, which is done in the IDE. In this sense, even neonious one transpiles. I meant native in the blog post in the sense that you do not have any transpilation step which you have to do manually before running the code on the microcontroller.
Thanks for the clarification.
Really? Did you even bother to search the subreddit? Try Google.
Thanks. 
And the fact is that he's spamming a bunch of subs trying to drum up support for his pyramid scheme/cult, most are only very distantly-related because they are tech subs and he's focusing on tech people. There's either no response or negative response to that spam. The website reads like a cult, the ideas read like a scam, it all is very reminiscent of scientology or similar organizations. They invent tons of terms and use big language to try to puff themselves up and give themselves an air of sophistication. Instead it comes across as desperate, ignorant, and needy. I mean, instead of a whitepaper they have a "white napkin" whose claim to fame is that it is "written and inspired by Ryoto Nakamoto (Satoshi Nakamoto's stepson)". The document is cryptic in so many ways: &gt; For the sake of anonymity and security, limited details will be displayed for public viewing. This white napkin is only a tiny blueprint of how Kaleidoscope will function. The deeper workings will be revealed to individuals who choose to contribute their time and expertise to the DAO. You're kidding me, right? You want people to blindly join before they learn how everything works, using terms like "deeper workings". Could it get more cult-like? Then they claim they want to focus on crypto and security but here's how they maintain that security: &gt; In order for the DAO to maintain the highest level of security we will require some simple yet unique security measures. &gt; &gt; * Your avatar picture must always remain the same (so choose wisely) &gt; * Your public address must remain the same &gt; * Your screenname must remain the same (so choose wisely) &gt; * Your writing style/personality should be consistent and will be monitored by the community Wait, what? None of those is even remotely secure. Each one of them could be faked fairly simply or outright stolen from the original person. Nothing is mentioned of cryptographic keys, shared secrets, verification schemes, or other proven methods of validation. This sounds like it was put together by a 10-year old trying to get people to join his secret club.
What you think "sucks" is part of the documentation function maxNumber(arr: number[]): number { let max: number = -Infinity; arr.forEach((x: number) =&gt; { if (x &gt; max) { max = x; } }); return max; } Defining a return type and the type in "forEach" shows you at the first glance what's going on. Quote Robert C. Martin: &gt;Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...\[Therefore,\] making it easy to read makes it easier to write. &amp;#x200B;
This looks super cool !
No, I don't think it's part of the documentation ‚Äî for example, every "map" call here uses inference: https://www.typescriptlang.org/docs/handbook/advanced-types.html We can argue about what is more readable, case-by-case, for ages. Would you still go for `const x: number = 4;` over `const x = 4;`? It's just manual work where the compiler can perfectly handle itself.
yeah, and less chance to screw the return type, the interface to a function should be as annotated as possible, in this case if you made a mistake and max turns out to be string, no errors pops out. &amp;#x200B; if the function is as simple as (a: number) =&gt; a, maybe I wouldn't add a return type
Not to change the subject, but Math.max takes an infinite number of arguments, which means you could just spread the array into it. Math.max(...[1, 5, 2, 4, 3]); // =&gt; 5 
Would be cool if it supports [AssemblyScript](https://github.com/AssemblyScript/assemblyscript)
How can you screw the return type without it breaking the assertions in other parts of your code?
I find myself preferring TypeScript to C# because I get the benefits of types as annotation without the legacy restriction of having to wire all the knowledge in at compile time. I also gain easy portability over a range of devices and more relaxed programming.
I guess that means you can update the TypeScript compiler version?
It's easy to write a program to turn a database schema (or at table descriptions) into TypeScript interfaces so you can refer to them in an expression like `.where((s:names) =&gt; s.last == 'joe'); // or fancier using tagged strings` Converting this to SQL and doing schematic evaluation is more difficult. I'm trying to find any implementation. linq-fns is impressive. Now to take it to the next step.
By not having that many assertions, as you said, it's better to let typescript infer the types. Imagine this example function anotherFunction(...params): number {} function functionsReturnsNumber(...params) { return anotherFunction(...params) } Here test infers the return type to be a number, and thats is how is meant to be, but in a subsequent refactoring you make anotherFunction to return string instead because it suits a code used somewhere else, then functionsReturnsNumber would return an string and the error would be hard to locate
What's your problem anyway? If you specify the return type it's 7 character more to type... That happens automatically... I assume you already have the function in your head before/while typing so specifying the return type takes about \~1sec by 650 keystrokes per min. :-))
Sure we could. Think of a `maxBy(objects, getField)`, but simplified for a cleaner example, if you prefer.
This, however, only happens when you directly return the result of anotherFunction. Should you use it immediately in any operation, or as an argument to another function, it breaks right away. I'll admit that omitting return type is debatable for larger functions. However, I am *strongly* against over-typing the stuff inside the function.
yes
As I just said around here, maybe return type is ok. It's just my reaction to people writing `let x: number = max&lt;number[]&gt;([1 as number])`, with no idea that it's not Java and you can skip some of it.
I could see that! Might make sense to show those examples to show some real use cases then.
What‚Äôs the difference of this with TypeScript‚Äôs native `checkJs`?
Agree - that's a bit to much! In my opinion the rule is easy - If you see/know what type a var has at the first glance then the way you declared the whole thing is ok, if you have to go through the next 10 lines of code to figure it out then something is wrong.
&gt;I am strongly against over-typing the stuff inside the function. Yep, I agree
Yes and no. Yes, that is an alternate solution to using `let self = this`. But taking that advice just changes the question from "when do I need to use let self = this" to "when do I need to use bind" which seems to be OP's real question.
Change your profile picture lmao
Glad we've settled this :-)
we would love for you to come share your opinions on our discord:https://discord.gg/6yhXn5t From the temperament of your response i can tell we sparked something emotional in you for you to even take the time to tell us we wont succeed and from studying psychology deep down inside you really do like the idea.... your just upset you didnt come up with it yourself... so you lash out in hopes to destroy a positive movement vs just ignoring the post and going on about your day.... so we love you too man..... 
[Welcome to Costco, I love you.](https://www.youtube.com/watch?v=Z8zNsUTWsOc) When you tell everyone you love them the phrase loses its meaning.
come join us on our discord:https://discord.gg/kFUcjgJ
There are some existing projects that extract types from JSDoc annotations, and use those types to check the file. Here is a relevant article: https://medium.com/@trukrs/type-safe-javascript-with-jsdoc-7a2a63209b76
You're a broken record saying the same things over and over again. We're here on Reddit, having discussions. Why would we want to go somewhere else to have them? If we liked to sow discord we'd be there doing it.
I don't think compiling webpack.config is necessary, I have used ts-node in my projects and webpack uses its config automatically in typescript
You don‚Äôt even need to use ts-node, you can use we pack with a TS_NODE_PROJECT. Here is an example: https://github.com/jasonraimondi/typescript-react-starter/blob/master/package.json#L11
This PoC is also using checkJS. I am checking If we can get detailed typechecking just by using JSDoc and not TS specific code.
Thanks.. article is useful. 
Thank you!
Why the heck does one want to use Bazel? Another build system that no one asked for. Don't we have enough of them?
I was forced to use it today, works smoothly and it's allegedly used to take over cmake. I am having troubles targeting compilers though, documentation isn't clear on that option (if its available)
Build systems in JavaScript are still a dumpster fire of terrible design, so I‚Äôm all for more of them coming out until something more sane takes over. 
I agree if the new systems look at why the others are hard to use. Webpack is just overly complicated IMO and I‚Äôm fine with it being abstracted away by the Angular CLI. 
Please try parcel. It's the only build system that doesn't require a huge starter project.
Bazel solves a particular set of problems better than any other system. It is an open question if those problems are the most important ones for your project, of course. https://bazel.build
Build systems are complicated these days because the whole environment is complex. Webpack is very mature and can handle all kind of tasks and this is needed by it's userbase. It's an illusion to think that Baszel can handle the same complexity with just a few lines of configuration options. Take Gradel for example - Gradle is more or less a programming language with plugin support. Also quite complex but again, this is what we need today.
I'll look at all the dumpster fires and pick the one with the most support I guess.
related [https://github.com/danielpa9708/typescript-test-utils](https://github.com/danielpa9708/typescript-test-utils) 
You are not wrong, but the situation is not much better elsewhere really. 
Like others have mentioned here, you'll have to use a helper function to prevent the compiler from widening the type to `Array&lt;T&gt;`. However, instead of creating overloads or specialized functions for each literal type you can add them as constraints so a single function will return a tuple with preserved literals (tested in TS 3.2.2): ``` function Tuple&lt;T extends Array&lt;string | number | boolean | symbol | object&gt;&gt;(...args: T): T { return args } const x = Tuple(2, "foo", true, new Set()) // [2, "foo", true, Set&lt;any&gt;] ```
thanks for your feedback, I'll try to start a project with ts-node to broaden my horizon
Also https://github.com/dsherret/conditional-type-checks, which uses only types and thus does not emit any code.
cant get much done on reddit.....
As if bazel is easier to use, it's as complex as a nuclear plant
Someone DID ask for Bazel, they‚Äôre just operating on a different scale or with different needs than most of us
That‚Äôs a great comparison. I was thrown into a couple projects that use cmake and it‚Äôs been quite a challenge to really make sense of it and get it right. A new replacement option could be a very nice thing. 
In my opinion this is a Google internal thing they want the community to work on.
google search typescript handbook
Good suggestion. Thanks!
Oh man how did you do this?
[removed]
Your interface/type usage is fine. Some things in TypeScript can only really be written in one or two ways. At best, I would argue that there's probably no need for the 'Log' interface (is any class other than Logger really going to implement that contract?). Some quick thoughts: * Instead of the `log()` function taking a `logColor`, instead it should just take a log level (this is what the Winston logging library does), and the colours for each log level can be defined elsewhere. That way, you avoid coupling presentation to semantics. Similarly, there's no need for an 'override' option on the `log()` function. * When I mention coupling of presentation to semantics, I mean to say that ‚Äì for example ‚Äì maybe the next consumer of your library might want, say, to have ALL log messages be output externally and/or provoke display of the console; that should be configurable (on a per-instance basis of the `Logger` class would be sensible) rather than be enforced. * You can still keep those convenience methods for `info`, `warn`, and `error` but instead have them pass the right log-level onto the generic `log()` function. * No need for 'prefixColor' if 'prefix' isn't specified, so instead you should bundle them up as an optional object called 'prefixConfig' which takes a mandatory 'message' field and an optional 'color'. * Your constructor can be rewritten as just: constructor(userConfig: LoggerConfig = {}) { this.config = { ...userConfig }; } * You may want to allow logging of JS objects (as an optional extra param), not only messages. Writing a good logger is a bit of an uphill struggle, I should warn ‚Äì I'd recommend to leave it to the experts (Winston, Bunyan, etc.) so that you get features like writing to disk, log rotation, sending to ElasticSearch, etc. out of the box. However, figuring out how to set up these libraries the way you might like can be a huge time-sink.
Or don't. If you don't need it to look professional, no need to change.
A constructor can only return an instance of the class. 
Why? The constructor is literally an arrow function already, no need (and not possible) to return something else. No need to return something at all actually. 
`return (message =&gt; { this._message = message; return this; }) as any` Not sure if it works tough
A constructor in JS can actually return any object. For example: const SomeObj = {}; class SomeObjClass { constructor() { return SomeObj; } } console.log(new SomeObjClass() === SomeObj); // true Here's what I came up with over on /r/javascript when someone asked about this a few weeks ago: /** * Base class for extensible functions */ class ExtensibleFunction extends Function { // @ts-ignore constructor(f) { return Object.setPrototypeOf(f, new.target.prototype); } } /** * An implementation of a "callable class". */ interface Callable { (): Callable; } class Callable extends ExtensibleFunction { constructor() { super(() =&gt; { console.log('default called'); return this; }); } foo() { console.log('foo called'); return this; } } Which you can use as expected: const c = new Callable()().foo()(); // default called // foo called // default called console.log(c instanceof Callable); // true ([Playground link](https://www.typescriptlang.org/play/index.html#src=%2F**%0D%0A%20*%20Base%20class%20for%20extensible%20functions%0D%0A%20*%2F%0D%0Aclass%20ExtensibleFunction%20extends%20Function%20%7B%0D%0A%20%20%20%20%2F%2F%20%40ts-ignore%0D%0A%20%20%20%20constructor(f\)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20Object.setPrototypeOf(f%2C%20new.target.prototype\)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%2F**%0D%0A%20*%20An%20implementation%20of%20a%20%22callable%20class%22.%0D%0A%20*%2F%0D%0Ainterface%20Callable%20%7B%0D%0A%20%20%20%20(\)%3A%20Callable%3B%0D%0A%7D%0D%0A%0D%0Aclass%20Callable%20extends%20ExtensibleFunction%20%7B%0D%0A%20%20%20%20constructor(\)%20%7B%0D%0A%20%20%20%20%20%20%20%20super((\)%20%3D%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20console.log('default%20called'\)%3B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20this%3B%0D%0A%20%20%20%20%20%20%20%20%7D\)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20foo(\)%20%7B%0D%0A%20%20%20%20%20%20%20%20console.log('foo%20called'\)%3B%0D%0A%20%20%20%20%20%20%20%20return%20this%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%2F%2F%0D%0A%2F%2F%20Example%20usage%3A%0D%0A%2F%2F%0D%0A%0D%0Aconst%20c%20%3D%20new%20Callable(\)(\).foo(\)(\)%3B%0D%0A%2F%2F%20default%20called%0D%0A%2F%2F%20foo%20called%0D%0A%2F%2F%20default%20called%0D%0A%0D%0Aconsole.log(c%20instanceof%20Callable\)%3B%0D%0A%2F%2F%20true%0D%0A))
Thanks a lot for the comment, extremely helpful. Makes perfect sense. So is `implements` only really useful when you have multiple different class types that should implement the same contract? Yeah, this was more of a "make something that's not a todo app" to learn TypeScript thing, I'll keep using the established libraries/services if I need a logger :)
&gt;A constructor in JS can actually return any object. This is /r/typescript, not /r/javascript. As you can see from the error OP got, TS won't let you return a value from the constructor that is not an instance of the class. Of course, if you use @ts-ignore, you can do whatever you want. I'd venture a guess that this is more of an XY problem though. 
&gt;As you can see from the error OP got, TS won't let you return a value from the constructor that is not an instance of the class. Yes it will. My first example works just fine in TS. The only reason @ts-ignore is required is because of the lack of a `super()` call. If you don't want to use it, then you can just not have the `ExtensibleFunction` superclass. interface Callable { (): Callable; } class Callable { constructor() { function defaultCallable() { console.log('default called'); return defaultCallable; } return Object.setPrototypeOf(defaultCallable, Callable.prototype); } foo() { console.log('foo called'); return this; } } 
That‚Äôs exactly it. This of ‚Äúimplements X‚Äù as a way to say ‚Äúthis class in an X‚Äù.
Are you able to achieve as much through pure ts annotation with my example? The point is that I'd have to rewrite my code to conform to a work around instead of using javascript as god intended.
&gt; Object.setPrototypeOf(defaultCallable, Callable.prototype); This is a workaround, not a solution to the typescript issue. In fact, not only does MDN warn against using Object.setPrototypeOf, but any properties the constructor might have initialized won't be in scope anymore.
I would upvote twice if the code was embedded in your post instead of linked. Links go dead :) 
But is jwt safe?
Actually you need `ts-node` see line in same file [https://github.com/jasonraimondi/typescript-react-starter/blob/605ed5cf64435fc859e61f3b6f0576cb9cbb425a/package.json#L47](https://github.com/jasonraimondi/typescript-react-starter/blob/605ed5cf64435fc859e61f3b6f0576cb9cbb425a/package.json#L47) webpack uses ts-node internally if it finds config file ends with `.ts` [https://webpack.js.org/configuration/configuration-languages/#typescript](https://webpack.js.org/configuration/configuration-languages/#typescript) `TS_NODE_PROJECT` environment variable is used to override default typescript configuration file (i.e. `tsconfig.json`)
(Gist pasted in for convenience) /** * Return an object with only the properties existing on both objects, values equal to what's on the latter object. */ export function pickOverlapping&lt;T extends Record&lt;string, any&gt;, U extends Record&lt;string, any&gt;&gt;(obj1: T, obj2: U): Record&lt;Extract&lt;keyof T, keyof U&gt;, any&gt; { let ret: Record&lt;string, any&gt; = {}; for (let k in obj1) { if (k in obj2) { ret[k] = obj2[k]; } } return ret as Record&lt;Extract&lt;keyof T, keyof U&gt;, any&gt;; } let testObj = pickOverlapping({a: 1, b: 2, c: 3}, {b: 10, c: 20}); testObj.blah; // type error (as wanted) testObj.a; // type error (as wanted) testObj.b == 10; // all good testObj.c == 20; // all good
That makes total sense, thank you for the explanation!
With a relatively simple mapped type (I've called it Overlap below), you can preserve the type information of each property in the object, rather than degrade the typing to an any. type Overlap&lt;T, U&gt; = { [K in Extract&lt;keyof T, keyof U&gt;]: U[K] }; /** * Return an object with only the properties existing on both objects, values equal to what's on the latter object. */ export function pickOverlapping&lt; T extends Record&lt;string, any&gt;, U extends Record&lt;string, any&gt; &gt;(obj1: T, obj2: U): Overlap&lt;T, U&gt; { let ret: Record&lt;string, any&gt; = {}; for (let k in obj1) { if (k in obj2) { ret[k] = obj2[k]; } } return ret as Overlap&lt;T, U&gt;; } let testObj = pickOverlapping({ a: 1, b: 2, c: "foo" }, { b: 10, c: "bar" }); testObj.blah; // type error (as wanted) testObj.a; // type error (as wanted) testObj.b; // all good (typed as number) testObj.c; // all good (typed as string)
Building on @alsiola's version, if you're willing to use an additional `any` typecast in the function body, you can get rid of all the `Record&lt;string, any&gt;` bits. I might also use an ordinary set intersection (`&amp;`) in `Overlap`, rather than `Extract`. type Overlap&lt;T, U&gt; = { [K in keyof T &amp; keyof U]: U[K] }; /** * Return an object with only the properties existing on both objects, values equal to what's on the latter object. */ export function pickOverlapping&lt;T, U&gt;(obj1: T, obj2: U): Overlap&lt;T, U&gt; { const ret: any = {}; for (const k in obj1) { if (k in obj2) { ret[k] = (obj2 as any)[k]; } } return ret; } Worth noting also that `pickOverlapping` will also work on arrays and objects with `Symbol` keys.
I know I'm a little late to the party here, but how would you set this up? Right now I have \`ts-loader\`, \`thread-loader\` and \`ForkTsCheckerWebpackPlugin\` handling transpiling, type-checking, and linting. Wouldn't Babel 7's TypeScript support cause double-emitting of transpiled JS? &amp;#x200B; I'm currently trying to introduce Angular 7 into the project and am having a heck of a time getting linting working as Angular provides its own pipeline for transpilation...
You're losing the types of the values by using `any`. I think the return type could just be `Pick&lt;U, Extract&lt;keyof U, keyof T&gt;&gt;`
Pluralsight.
Are session IDs safe?
Pure sorcery! I've put up a revision of the gist for all. I'm surprised that \`&amp;\` works in the index key of the \`Overlap\` type you've defined. When we \`&amp;\` interfaces we take all of the properties from both interfaces (union), but here we get the intersection, which seems like a different logical meaning? How... &amp;#x200B;
Yes, you can using \`keyof\` const obj = { foo: "something", bar: "something else" }; interface ITest { baz: keyof typeof obj; } const a: ITest = { baz: "foo" };
It makes more sense if you think of types as sets of values. `keyof A` is a set whose members are the keys of A. The intersection of the keys of A and B is the keys that are in both. `A &amp; B` is the set of values that belong to both A and B, i.e. have the properties of both A and B. One of Anders's slides from tsconf last year had this on it: keyof (A &amp; B) = keyof A | keyof B Understand that and you'll understand types as sets!
- Is `strictPropertyInitialization` compilation option intentionally disabled (tsconfig.json)? - https://github.com/Odi-ts/odi/blob/master/tslint.json looks empty.
Isnt nest already heavily inspired by spring and the likes? Annotation-heavy frameworks are certainly something not uncommon nowadays.
1. Yes, it was disabled intentionally, as there were few integrations tests with DI (property will be initialized by DI manager). For example: &amp;#8203; @Service() class FooService { @Autowired() fooRepo: FooRepository; } 2. Oooppsss, sorry. Missed it. Have it locally, but not on git :).
Basically, it's the main difference, that this framework trying not to be annotation-heavy as it's possible but also easily scalable and supportable. There is a big difference with nest, from DI to infrastructural decisions at all. The only common things - TypeScript and Declarative way (Decorators).
Very Nice! Thanks for the suggestion. 
Nice work! Seems very similar to www.tsed.io, the main difference being that you're not using Express. How close do you think your framework is/will be to TSED in the future? I really enjoy TSED right now but am looking for alternatives to Express too.
I love this and would absolutely give it a shot for my next project.
Yeah, this reminds me a lot of nest, but it's good to have multiple options.
We are trying to find out the best practices from other technologies and combine them in the best, convenient and semantically correct way. I guess, that you will enjoy Odi too :)
Can't make this up. You really made my day and my sides are officially in orbit. Your napkin I.. I just can't :*). This has to be a troll post please tell me it is. 
How can i help?
As far as i can tell that just means we have a bunch of half done frameworks.
Sometimes that happens, and it's often hard to choose the winners early, but angular, react, and vue all started like this and wound up very mature.
Are you planning to support auto-generated API Docs for openapi? 
What do you expect to happen if the code is used like this: const a = new A(); a.bar(); 
Can you post the part of the code that actually calls `.json()`?
On mobile but: I think the type reference is wrong. It's not express.Response, it's just Response. You can tree shake import the type interface from express something like so: `import { Response } from 'express`. Make sure you have @types/express installed. 
Why not share a GitHub repo. This wall of text is a bit jarring. Thanks.
False. Also on mobile, but there is a type mismatch between node Request and Express.Request
Ok. Take a look. [https://github.com/atomAltera/car-rent-web-preview](https://github.com/atomAltera/car-rent-web-preview)
I have solved the issue and updated the OP.
I have solved the issue and updated the OP.
There are a lot of things that should be done :) Today-tomorrow (got a trip today) I will create chat on gitter and will update issues. So, if you want to help, you can always check issues list or check the status based on gitter conversation. Thanks so much for your interested in the project development! I very appreciate it! :)
Sure! There few things in plans to be auto-generated: 1. Swagger docs 2. GRPC interfaces 3. GQL files 4. HTTP wrappers for frontend with support for different platforms and methods: Android, IOS, JavaScript (axios, fetch) and others. &amp;#x200B;
`fp-ts` is by far the most complete one, with typeclass instances for pretty much everything you want. It's definitely the go-to library if you're coming from a ML language and you're already familiar with all of the terminology and function names/signatures. I'm also shamelessly plugging my own library: [purify](https://github.com/gigobyte/purify), it doesn't have as many features as fp-ts, but it's simpler and also I've received great feedback from beginners, I put a lot of effort into the documentation. 
cool
My apologies for late reply due to holiday season. But thank you for bringing this to my attention. I was unaware but it should now be fixed.
I expect javascript to behave according to its specification. If an object, is returned, and that object doesn't contain the property **bar**, I expect the error that javascript throws. ```js VM359:1 Uncaught TypeError: a.bar is not a function at &lt;anonymous&gt;:1:3```
Have you looked into `apollo-codegen`? It solves the exact problem described in the readme
Typescript is preventing you from doing that. It's a good thing that this is a type error.
&gt; It's a good thing that this is a type error How did you come to that conclusion? I thought TypeScript was supposed to be a superset of JavaScript.
Cool, I've been meaning to do something like that, but haven't used graphql in a while &amp;#x200B;
Check out [True Myth](https://true-myth.js.org/).
[Looks like it](https://github.com/acro5piano/typed-graphqlify/blob/master/README.md#why-not-use-apollo-clientcodegen)
I'd always advocate for atomic updates on the database, rather than creating the updated data in the application, based on (potentially stale) remote data as ORMs do. So I would probably go for the query builder. Prisma.io might also be worth looking at. Haven't used it myself, though. You can also read a bit about the emerging "avoid ORMs" sentiment [here](https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5) and [here](https://medium.com/ameykpatil/why-orm-shouldnt-be-your-best-bet-fffb66314b1b). Sorry for advertising my own stuff here, but I am working on another alternative solution right now. Using SQL template strings instead of the query builder, but with a tool that can statically validate and even type-check them: pg-lint (not yet published).
Ok, hasnt read it thoroughly enough, thx
I think TypeORM is pretty good if for no other reason than the code-first database migrations it provides. If it offered that but no "ORM" query interface, I would probably still use it.
Most languages refer to this ADT as \`Maybe\` or \`Option\`. It's \`Option\` in \`fp-ts\`, and \`fp-ts\` is most likely what you want. It's the most complete, and when you buy in to using Maybe/Option, you want more than just the type itself. You also want a suite of functions that work with this type when doing things with Arrays, Records, etc.... For example, you'll want a \`lookup\` function for accessing possibly missing keys in a record, various functions for accessing possibly missing or out-of-bound indices in arrays, etc.... So, choice of library is about more than just the type itself, but also how many supporting functions it offers.
It is a superset in a sense that "correct" JavaScript is valid TypeScript. Things that obviously fail at runtime are supposed to be caught at compile time - that is the point of typechecking. Most people want `"somestring".methodWithDoesntExist()` to be an error if it is guaranteed to throw an error at runtime.
come join us on our discord: https://discord.gg/9FxsJ3Y we could use your enthusiasm 
The ecma spec doesn‚Äôt represent correct JavaScript? 
god i love you man you are awesome! too funny come chat with us on our discord:https://discord.gg/9FxsJ3Y
Well, correct is certainly not the right word, but I couldn't think of a better one, that's why I put of in quotes. Maybe "useful"? The spec says this should throw an error. The goal of TypeScript is to find these types if bugs and errors at compile time. From your reaction, I assume that you expected something else from TypeScript? Could you try to explain your mental model of what TypeScript does?
Yeah.. that's a no ;) but gl (you will need a lot of it)
Have your discord come join Reddit, we don't want to leave it.
You should stop using everything that experienced devs built... turn off your internet connection and throw your computer in the bin.
&gt; newbs have all these cool ideas and fantasies Which are just that for the most part. Fantasies. In programming it's not the cool ideas that are the ones that work, it's the hardcode algorithms, programming patterns, and experience that make everything come together. Generally if you're programming to the latest flashy tech every each you're wasting your time and needlessly introducing bugs.
The time cube guy got bored is my thought.
I've been pleasantly surprised by TypeORM. It's got some good core functionality and it seems to be improving at a pretty good pace. Migrations is killer.
I do nr 1
I like to keep the types separate. I use API-specific types, entity/core types &amp; GUI-specific types, and I use functions to convert one to the other. Example: ``` // some-api/SomeApi.ts interface IAPIRecordCollection { total: number; limit: number; skip: number; nodes: IAPIRecord[]; } interface IAPIRecord { /* fields that exactly match your api structure */ } // This class is responsible for wrapping your API. Data isn't transformed class SomeApi { constructor(endpoint: string, auth: something) {} getRecords(): Promise&lt;IAPIRecordCollection&gt; } ``` ``` // myapp-service/IRecordService.ts interface IRecord { /* fields fitting your application / domain logic */ } // Interface for your application to depend on, // so your application doesn't depend on the API directly. // Makes testing a breeze. interface IRecordService { getRecords(): Promise&lt;IRecord[]&gt; } ``` ``` // myapp-some-api-service/APIRecordService.ts // Class to implement IRecordService using SomeApi. // This acts as a bridge between the application &amp; the api. class APIRecordService implements IRecordService { constructor(private someApi: SomeApi) {} getRecords(): Promise&lt;IRecord[]&gt; } function parseRecord(in: IAPIRecord): IRecord { return { /* converted record */ } } ```
Thank you. :)
Thank you. :)
Thank you. :)
Thank you for this suggestion. It seems to do the trick, but something's not quite right. It seems to map all the keys under String.prototype. When i try to apply the value "foo" like in your example i get this typ error: \`\`\` Type '"foo"' is not assignable to type 'number | "toString" | "valueOf" | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "localeCompare" | "match" | "replace" |ndexOf" | "localeCompare" | "match" | "replace" | "search" | "slice" | "split" | "substring" | ... 28 more ... | undefined'. \`\`\` &amp;#x200B; I'm using Create React App Typescript, here are my packages: \`\`\` "react": "\^16.6.3", "react-scripts-ts": "\^4.0.8", "typescript": "\^3.2.1" \`\`\` &amp;#x200B; Any idea what i'm doing wrong?
You could use a [union type](https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types). And do something like: type Thumbnail { file: string; size: string; } type Record { thumbnail: Thumbnail | string; // other props }
It's called a [union type](https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types), but I would probably do option 1 as well. You could also use interfaces and `extends` to remove some of the duplicated properties ie: interface Record { // ... your common record props } type Thumbnail { file: string; size: string; } interface GetRecord extends Record { thumbnail: Thumbnail; } interface PostRecord extends Record { thumbnail: string; }
You can try leveraging [Pick and Exclude](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html).
could you show the code your using, and the type of obj ?
I think you could do 1 without duplicating all properties from the RecordType
Number 1 may seem like extra tedious work (and technically, it is), but it'll save you from all the overhead / other tedious work that number 2 will cause to bleed into all your other methods. For example, with number 2 you'll have to try to figure out which variant of the record you have. With number 1, there's no need to put `typeof record.thumbnail === 'string'` all over the place. And with number 1 you'll more-or-less avoid the risk of accidentally passing the wrong version to the wrong method.
I would definitely say to use a separate type. Otherwise you weaken your type system while having to specify which it is every time. 
But you're getting an array be of "fields". Do you want an array of objects whose length is the length of the field array, or just one object which ignores 1+ array elements?
I don't quite see the issue here tbh. Put the function into some helper file, `export` it, `import` it in any test you need it and you shall be fine :)
I used your code, and it's definitely something wrong with my environment because I tried it in an online talk playground and it worked.
skipLibCheck is only relevant for @types. If you are using a JS library, then you have to download @types which might be incomplete at a lower level, but the things available to you are all there. If a Typescript library falls, then there is something wrong with the library
Basically the only thing that is wrong seems to be that the lib declares bigint in its typings. It actually really needs it for some of its methods. The problem is that having bigint in the typings forces all its users to bump their typescript version to at least 3.2
I basically import it using `import * as fc from 'fast-check' `. I have not checked if I get the issue when I only import the methods I really need :) 
I actually agree with you. I'm not that experienced but I'm getting there. And I can feel that naive optimism dying in me. I found that working professionally as a dev after graduating caused a bit of it. You run into so many issues with management not wanting to green light things you want to do or coworkers who disagree with you and things get stuck in limbo. Or you finally get to work but it took so much effort to get there that you feel drained and uninspired. I don't know the solution. Just feels nice to acknowledge it. XD
It would be against the purpose of TypeScript. Declaration files are source code as well ‚Äî they describe the APIs you're using after all. Using \`skipLibCheck\` will shut up TypeScript, but in the long run, it might come back and bite you.
Why not use a class if you think that would be better?
I totally agree with the fact that disabling types sounds weird :/ But what are the checks removed when switching skipLibCheck on? Is it suppose to check even parts of the lib that we don't use? -- The reason of my original question was: How a ts library maintainer is supposed to deal with the following: adding in her/his lib a specific method working with bigint while keeping all the previous APIs as before? Simply adding the new method is a breaking change at typescript level. Indeed it forces all the users of this lib to upgrade to at least typescript 3.2 (even if they are not using the new method). Is it enough to justify a major version (lots of users will spend time before moving to 3.2, and might be blocked to very old versions of the lib just because of a method they don't even use :/)?
If I ever find myself copy pasting I pull it out into a common space and do the above
 const a = new A(); a("foo").bar(); What is the point of this syntax? Why a class? Why not: function A() { let _message: string; return (message: string) =&gt; { _message = message; return { bar: () =&gt; console.log(_message) } } } const a = A(); a("foo").bar(); Do you intend to use the instanceof operator?
Yeah, but you are passing a reference then. Not the object literal, really.
Yes. But if you do: const t = { height: 3, weight: 3 }; const p: Person = t; // It doesn't throw an error. Which is correct. &amp;#x200B;
To me the better questions you are raising is what are my tests actually testing and could a fixture or mock object work instead of an actual instance or factory method.
Have a look here: https://blog.mariusschulz.com/2018/01/14/typescript-2-4-dynamic-import-expressions You may have to target `esnext` though. 
I would do it the same way: ``` type RecordTo = { thumbnail: { file: string, size: string, }, description: string } type Omit&lt;T, K&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; type RecordFrom = Omit&lt;RecordTo, 'thumbnail'&gt; &amp; { thumbnail: string } const x: RecordFrom = { thumbnail: 'lala', description: 'lala', } ``` Allows you to update `RecordFrom` (Record is reserved) and only change the `thumbnail` property
&gt; Is GraphQL a nail to the REST coffin or a tool to **emopower** your REST APIs? sad boys run my websites
&gt; The problem is that having bigint in the typings forces all its users to bump their typescript version to at least 3.2 File an issue in the projects repository to support backwards compatible types: https://github.com/Microsoft/TypeScript/issues/22605 Besides: fast-check is a backend testing library. Why not just use a version that supports bigint?
&gt; Fast forward a couple of months we consolidated on ESlint for checking both JavaScript and TypeScript code. We accepted that, even though we lost some more advanced TSlint specific rules, it was not worth the effort of keeping both tools in our pipeline. Can you comment a bit more about ESLint vs TSLint? Is typescript-eslint-parser OK? What kind of rules do you miss from TSLint?
You need to annotate the return type of your "set" function. Currently it will return type `T &amp; { [key: string]: V }`, but you need it to return `T &amp; { [key: U]: V }` This type signature works for me: function set&lt;T, U extends string, V&gt;( obj: T, key: U, val: V ): T &amp; { [K in U]: V } { return { ...obj, [key]: val } as any; }
You may wanna have a look at Parcel, it's a zero config bundler perfect for simple use cases.
Frameworks are not a necessity. I've never touched any of the established JS frameworks for my personal projects. However files need to be bundled into one if you wish for them to be used with each other as you would with a multi-faceted web application, so a bundling tool like Webpack or Parcel is a necessity. Unless you are planning to keep all your TS code in only one file.
All you need is a tsconfig file with a few settings in it. You write your ts, then run tsc to compile to js according to the rules set in tsconfig. Thats literally all you need, I tried it myself.
We use prettier in our pipeline, I didn't mention it because it's not exactly related to typescript. ESlint has way more rules than TSlint out of the box, the difference is staggering. On the other hand a lot of those rules are checked by the TypeScript compiler, so overall that's a fair trade. There are a few TSlint rules such as no-any, ban ts ignore, ban types, etc which are not readily available in eslint. We needed to write some rules ourselves in eslint, but it would be simpler to just have them, obviously. As for the parser, I would say it's production ready, as long as you accept that TSlint has unique rules which you would need to port over to eslint or forget about them. 
As far as I know, enums like that are transpiled to JS code, so I think you shouldn‚Äôt even have to specify the value in the .d.ts file because it doesnt effect the code. Long as the underlying js code has the correct enum code than this should work
You can use TypeScript to do this I believe by choosing a different module system in your tsconfig.json or by outputting everything as a single file, but in reality you should be using something like parcel, browserify, or webpack. (I've had issues with Parcel playing nice with certain libraries, so I've recently switched back to Webpack for smaller projects).
Do you know how this compares to Dexie? I recently found it and have been using it to make offline-first apps. 
Make it a `const enum`. TS will inline the values at compile-time so the enum doesn't need to exist at runtime.
To write Typescript without frameworks, write it roughly the same way you'd write plain JavaScript without frameworks. How do you usually do that? We can explain how to accomplish the same with TS.
I just wanted to convert the object with a property that is an array with single object to a regular object containing a property that holds the A and B value. I'm able to do it using the map function. coffees.map(coffee =&gt; (ds.coffeeItems.push({ Id: coffee.Id, Title: coffee.Title, Property: { A: coffee.Property[0].A, B: coffee.Property[0].B }} as ICoffee)) Now trying to wrap my head around .then() combined with a .map() :)
1) Don't use `map` if you're not mapping anything. Use `forEach` instead 2) You still didn't answer my question. What do you want to do with `Property[1]`, `Property[2]`, etc. 3) Object fields should be lowercase. `{id: coffee.ID...}` 4) You don't really need to cast it `as ICoffee` if you're doing everything right
You don‚Äôt even need Webpack or Parcel. You can just run a TypeScript Compiler `tsc` on your source files to be even more simple.
I'll whip up a repo as soon as the holidays die down, but prepare yourself to some prototype based magic :)
You just need to set up the transpiler and then have your script tag in your html point to the outputted js file.
Doesn't the `as any` part mean you could return anything from `set` and it would still typecheck?
1) Ok. 2) I'll explain below 3) That's how I receive them from the server, and I'm trying to keep them the same. 4) I've modified the example so I hope it makes more sense, each coffee has a brand, this brand has a title and an Id, it returns from the server as a single object in an array. There's no property\[1\] since each coffee only has 1 brand. But if I want it in the right format as the interface I'm casting it like that. &amp;#x200B; At the moment I'm trying to work on a cascade for dropdowns. I've got a list with coffees, that contains items with an Id, Title, Brand (Id and Title). Then another list with machines with Id, Title, CoffeeBrand (Id, Title) and Coffee (Id, Title), This machine supports x brands and you're able to choose x coffees. Then I want to simulate an order, so you choose a machine and then a single brand that's possible for that machine. Then depending on the choice of the brand, I get the possible coffee's for that machine for that specific brand. So 1) Select machine, 2) Select brand (that are possible for that machine), 3) Select coffees (that are possible for that machine and are the same brand as 2). &amp;#x200B; 1) Is just get a list of all machines 2) Is getting all brands and using a filter on the selected machine 3) Here's where It's annoying, first I get the possible coffee selection for a specific machine. Then I loop over all possible coffees to check if their brand is the same as the selected brand 2). But to do this I need to get the coffeeList and get the item with the same Title and then I can get the Brand. 4) And finally I want to display the possible coffees in the selection. &amp;#x200B;
`tsc` compiles your files as they are in the directory, i.e. a directory layout like /src |- /classes |- Foo.class.ts |- Foo.test.ts |- /utils |- config.ts |- exampleutil.ts becomes /dist |- /classes |- Foo.class.js |- Foo.test.js |- /utils |- config.js |- exampleutil.js instead of /dist |- script.js which is why people use bundlers such as Webpack and Parcel since they make it easier to have a modular approach to the project, whereas each module is a separate script file importing other script files and at the end of the day these script files are all bundled into one to be linked to in the HTML with `&lt;script src="./script.js"&gt;&lt;/script&gt;`.
take a look at the example i posted, its not as simple as that
I posted my example workspace above - [https://stackblitz.com/edit/js-tkw2wp](https://stackblitz.com/edit/js-tkw2wp) with my tsconfig file. try running it locally the browser doesnt know what an import statement is.
see the example I posted above - [https://stackblitz.com/edit/js-tkw2wp](https://stackblitz.com/edit/js-tkw2wp) , can't get the module settings working in my tsconfig file &amp;#x200B; Thanks
I guess my question was more: how would you write those import statements if you were doing plain JS instead of typescript? I'm being partly rhetorical but I think it's a good question to answer.
see my example i posted above - [https://stackblitz.com/edit/js-tkw2wp](https://stackblitz.com/edit/js-tkw2wp) \- i'm trying to get modules to work without a bundler, trying to see if it's possible or not, so far no luck. when i changed it to outfile, it wouldnt compile said it was only compatible with amd module strategy
Yes I know what you mean - normally you don't use import statements in JavaScript files, you use script tags that link to JS files. So my question is does typescript have an option do that after compiling it turns your import statements into something the browser can understand? Typescript knows what import statements are but it's not helpful unless you can run it in a webpage. Was trying to find a tsconfig combination that would do it for me but perhaps it's not possible
If I remember correctly, there might be a tsconfig setting to correct for this. You are correct that the browser cant handle imports. I went through this learning process same as you are and found it very frustrating. So here's my real advice. Use webpack for your front end stuff. Its base purpose is rifling through all your import statements and glomming everything together into something that runs on the browser. Then on top of that, it has lots of other features. Once you accept this, you will start having some fun. 
Understood yeh that may be the answer. I'm able to get it working with webpack just surprising typescript doesn't have an out of the box option.
If it helps, you could think about how ts and js are kinda cross compatible. You can create a .ts file and fill it in with a bunch of old style js code, still run tsc on it. If you were in js, you wouldnt be allowed to have imports either. You would have to write your code just assuming the other file already loaded correctly without any imports. If you want to use the import feature, you need to either run it on the node server, with ts-node, which handles imports, or use something that converts the imports into another structure, which webpack and browserfy do.
Also, now thinking of it, you probably want the base UiElement to have the type attribute as well...
Yes, in this case you also fool the compiler as a caller of the function. You can break the code by using union string typed key: const b = set({a: 1}, "b" as 'b' | 'c', 2); // compiler thinks: const b: { a: number; } &amp; { b: number; c: number; } But actually `b` only has props `"a"` and `"b"`. Unfortunately, I don't think you can achieve this cleanly without these drawbacks as the only way to describe the type created from `key` and `val` is the proposed `{ [K in U]: V }`.
I'm fighting my Java bias. I really understand OO programming, and am used to using classes for everything. I met resistance working with Javascript developers where I'm hearing classes are unnecessary, and everything classes do can be replicated by modules and factories. So I'm trying to understand the alternate pattern so I know when to use one over the other. TL;DR - Trying to broaden my horizons. :)
Normally I agree. In this case I'm working with a datatype not an OO object. As a general rule I don't mock out data types because there's no gain from it. In this case, what I'm testing acts on these data types, so I need them as an argument. But I want a non-brittle way to construct them.
Is there a convention for this to keep it organized? Do I create an ItemService module to collect all Item-related helper functions? I can convert the interface into a class and the constructor will act as a factory function for free, and then I don't need the helper. But then I feel like I'm falling back on OOP where I'm trying to get my head around functional programming. I'm fine with the idea of putting shared logic in a helper file. But I'm looking for a pattern to keep it organized so I don't end up with a "junk-drawer" of one-off utility functions.
Small correction: Flow is actually a mix of nominal and structural typing. Objects and functions are typed structurally, while classes are nominally typed. &amp;#x200B; [Flow docs](https://flow.org/en/docs/lang/nominal-structural/#toc-functions-are-structurally-typed)
Yeah, I wouldn't advocate for OOP in JS/TS, especially not for something that simple. There is no fixed convention, except for filenames usually being kebab-cased. There is no strict pattern as the one-class-per-file rule in Java. What you are looking for when deciding where to put things is separation of concern and code coherence. Tightly coupled code and things of very similar context should usually be placed very close to each other (like in the same file). Don't start creating `utils.ts` or something similar. Rather create a `fake.ts`file and put `createItem()`, `createFoo()`, `createBar()`, ... in it. It's actually not completely different from Java. It's just that you need carefully decide what goes into which file, whereas in Java you decide what goes into which class.
Yes, TypeScript doesn't bundle your files. Try using https://parceljs.org/ if you find webpack too much work to set up.
Thank you! Looking forward to it.
I will check out parcel Thanks
Moved a little slowly but otherwise very informative for someone considering f#. Thanks!!
&gt;, trying to see if it's possible or not, so far no luck. when i changed it to outfile, it wouldnt compile said it was only compatible with amd module strategy &amp;#x200B;
I updated the paragraph to reflect that, thanks!
Well lets expand this a bit to see if it makes my question clearer. Say I create an ItemRepo that is responsible for item persistence in a REST API, and has all your typical CRUD functions. I can put my fake item factory function in itemrepo.fixture.ts Cool, then I have a tax calculator which is repsonsible for calculating the tax on an item: // salesTax.ts export function calculateSalesTax(item: Item): number Then I can put a different item factory in salesTax.fixture.ts to support it's unit tests. Then I have a receipt printer which formats an array of items into a receipt string that can be printed to the console or a file. // receiptPrinter.ts export function printReceipt(items: Item[]): string Again an item factory can go in receiptPrinter.fixture.ts So my structure ends up looking something like this, it's a bit contrived, but I'm trying to keep this simple. - src - data - itemService.ts - itemService.fixture.ts - itemService.spec.ts - model - item.ts - core - salesTax.ts - salesTax.fixture.ts - salesTax.spec.ts - ui - receiptPrinter.ts - receiptPrinter.fixture.ts - receiptPrinter.spec.ts Now all of that is setup, and it's fully covered by unit tests. Now I want to add a new property to Item, `inStock: boolean` which I can default to `true`. As this is written, I need to update the item factories in each one of my `fixture.ts` files. That's the brittleness I'm trying to avoid. I'm I'm understanding your comment correctly, do I put a `fakeItem.ts` in my model directory? Or is it better to create factory functions along side my interfaces... export interface Item { id: string; name: string; price: number; taxable: boolean; imported: boolean; inStock: boolean; } export function newItem(name: string, {id = '1', price = 0, taxable = true, imported = true, inStock = true}) { return { id, name, price, taxable, imported, inStock, } } But then aren't I just re-inventing the wheel for what classes give you for free? What's the Functional advantage over OOP?
Is this a JSON api? JSON doens't support types like Date natively, your API probably either uses the toString() representation or serializes it to ISO8601. Figure out what format it sends and parse that to a Date object. If it is ISO the constructor can do that.
You return the `result` observable from your method, and that observables `next()` method only ever gets passed a `string` by the `httpClient.get&lt;&gt;` method. The `resultDate` is never passed along, because you never subscribe to the observable you create in your inner function.
You could construct them like: const itemFixture: Item = &lt;Item&gt; {}; itemFixture.name = "Test Item"; And only assign properties that are needed for the function your are writing the test for. Now if you added `inStock: Boolean` the test does not break. That is unless the function should be using inStock and then you would have to update the test anyway and this is unavoidable.
Thanks for the response. API is JSON. Yes the data is serialized however can I expect typescript to understand what type the object should be and de-serialize it? &gt; If it is ISO the constructor can do that. Sorry I don't know what you mean by this. What constructor? 
&gt; Now I want to add a new property to Item, inStock: boolean which I can default to true. As this is written, I need to update the item factories in each one of my fixture.ts files. Why do you need to update anything else than the item factory? If it's really that tightly coupled for some reason, then it makes more sense to put them all into one factory. But I doubt this is the case here. &gt; What's the Functional advantage over OOP? Immutability: Something goes in, something comes out. No mutations. I can't stress enough how much easier it is to reason about that code. Also it's way nicer to debug, since you don't need to consider the point in time you are looking at. The object won't change. Be careful, though, since functional programming paradigms encourage immutability, but JS/TS don't enforce it. You can still mutate everywhere, but usually you shouldn't. Re-usability: This was the big promise that classical OOP made and could never really deliver. The problem is the mixture of logic and data. Logic can easily be re-used. Data is trickier, but it's ok if you are careful and break it down and compose the big picture of small atomic bits. Classes in practice are not as re-usable as they should be, because they mix logic and data. While one is easily re-usable and the other one is re-usable if you are careful, the cross-product of both is unique enough that it ges hard to apply it to a new use case. Add inheritance and chances are that reusability vanishes. Disclaimer: This is to some degree a personal POV, on the other hand I have spent years writing Java, PHP and a bit C++ before moving on to node.js for good. This reflects my expierences.
much love playa, we could use your enthusiasm at Kaleidoscope. Holla at us 
with parcel bundler you don't even have to set up your tsconfig. Just include TS file in your index.js and develop away!
Start up that's hiring? I'm okay for now. I'm in the middle of raising my issues with management right now (I got sick of the lack of motivation) and I'm going to see where that goes first. But thanks for mentioning it.
Thank you for catching that! My method is incorrect however my question remains because even if I return .get&lt;Date&gt;(‚Ä¶) I still get a string in `SetEffectiveDate`.
Yes, your code is setting `originCvg` and `updatedCvg` to the same object. When you change one, it will change the other one. Objects are passed and stored in JavaScript by reference. If you want to have two different copies of the same object, you need to use `Object.assign` for shallow objects, or something like `cloneDeep` from lodash for deep objects.
The `.get&lt;T&gt;()` method is likely performing a request and just deserializes the JSON. The type parameter `T`, in your case `Date` is just a hint to the type system what **should** be returned by the deserialized JSON. It does **not** check if that is **actually** the case. And as /u/brtt3000 said: JSON does not has a `Date` type. Dates are formatted as `string`s, and that is what you get. You can use the `map` function on your observable, which accepts a transformation func. Use that to transform the `string` to a `Date`. Note that this method returns an observable itself. So you very likely want something like (pseudocode ahead): GetCurrentEffectiveDate(): Observable&lt;Date&gt; { return this.httpClient .get&lt;string&gt;(this.apiHost + this.appConstants.EffectiveDateUrl) .map((value: string) =&gt; moment(value).toDate()); }
Of course! Thanks!
we are not hiring , its a co-op, come join when every your ready , check out our website
No, TypeScript doesn't do that for you. To parse you can use the Date constructor like `var d = new Date(myDateString)`. If you use something else like your NgbDate check its docs on how to have it parse from a string.
First off, thanks for helping me think about this. I'm looking for a better pattern. The reason I'm using a class is because the instance of A is stateful, and I need to be able to have multiple a's. In other words: ```js const a1 = new A(); const a2 = new A(); a1('x').doBla(); // affects x of a1 a2('y').doBla(); // affects y of a2 a1.foo(); // reflects altered x a2.foo(); // reflects altered y ``` I could approach this more traditionally by creating a method that allows me to select for 'x' and 'y' on each instance, such as: ```js const a1 = new A(); const a2 = new A(); a1.get('x').doBla(); // affects x of a1 a2.get('y').doBla(); // affects y of a2 a1.foo(); // reflects altered x a2.foo(); // reflects altered y ``` ...but I really like former. Thoughts?
C# is very similar to Java, which is similar to typescript. I think all object oriented languages are pretty much the same. Frameworks make them different. It‚Äôs a personal opinion though
How is TypeScript object oriented or any more so than JavaScript? Just because something has the `class` keyword doesn't mean its object oriented. 
Everything in js is an object, though. Functions are objects. ‚Äò‚ÄúString‚Äù‚Äô is an object. Try ‚Äòfunction test(){}; test.myStatic = true;‚Äô :)
I haven't done C# in a few years now, but even I can tell you-they really aren't that similar. C# is a whole different beast-a true OOP language. Syntax is similar, but usage and modelling of problems is different. 
You can write code that is not object oriented. But I believe the vast majority of ts users do write oo code 
Syntactically they are very similar, C#, Javascript, and by extension Typescript all follow in C's footsteps. The biggest difference is in how you structure the program. C# is very class oriented. Everything you do in C# will be done inside a class. That will probably be your biggest hurdle to learning. Also, coming from Javascript you are going to be tempted to use var everywhere. That is bad practice. You really should only use var on the left when the type is on the right.
TypeScript is closer to JavaScript than it is to C# in my opinion, so you'll have some learning to do. The type systems are quite different. The biggest difference that you'll run into right away is nominal typing. Check out the introduction here: https://www.typescriptlang.org/docs/handbook/type-compatibility.html I suspect they chose this difference because JavaScript object literals are so prevalent.
Lately I have only been using typescript in an Object Oriented style. So things are typed and mostly structured in classes! Taking that into consideration, C# won‚Äôt be hard to transition to, I suppose?
Thanks! I did not know about require JS that's it's just a simple JS library to add but it looks like that will work. I will look into module loaders more but this gives me a great starting point.
Typescript can be (and in my opinion should be) written in a very similar way to C#. Especially if you find a way to leverage decorators. Some words of caution: * TypeScript *can* be written in a **very** different style than C# (either more functional or more pure Javascripty). * Server side TypeScipt with Node.js has no standard library and npm will make you appreciate Nuget in a way you never have before. * It's still a very young language and it can be hard to find good examples and best practices. * No Linq :(
Then no it probably won't be very difficult, the basics are pretty much the same just some minor differences. 
.pipe(map(‚Ä¶)) fixes it. Thanks again. 
I am programming in TS and C# primarily right now. I find them to be similar, in my own mind. It could be said that C# is more strict and object oriented, but I choose to program in TS the way I program in C# (the 'best' way), and thus they are very similar to me.
Agreed! Though almost all relatively popular packages have type support. 
&gt; C# fixes that by not having the amazing package library that javascript has.. ha ha. Can't have bad packages if you have no packages \*taps forehead*\
I would suggest you should actually go the other route: instead of trying to find how similar TypeScript and C# are, identify how are they different and explore those differences in depth. One of the dangers of using two very different languages with similar syntax is that you end up using one of them poorly, because you are making the wrong assumptions along the way, thinking one behaves like the other. Some material to explore: [https://www.triplet.fi/blog/type-system-differences-in-typescript-structural-type-system-vs-c-java-nominal-type-system/](https://www.triplet.fi/blog/type-system-differences-in-typescript-structural-type-system-vs-c-java-nominal-type-system/) [https://decembersoft.com/posts/typescript-vs-csharp-linq/](https://decembersoft.com/posts/typescript-vs-csharp-linq/) &amp;#x200B;
Typescript is to Javascript as C# is to Java. With that said, there are notable API similarities between Typescript and C#. 
Well that sounds exactly what I need but not yet supported by babel/typescript unfortunately - https://github.com/babel/babel/issues/8741
I see. The implementation i suggested would, in a way, be stateful though. Just not a class. For each time you run `A();` there will be a new `_message` variable with its own methods.
In that case you'll have to write the enum in a plain .ts file so that it exists at runtime. It'll get compiled to .js alongside a corresponding .d.ts. should do the trick (unless I missed where this won't work for your project)
I suppose I could create a wrapper function that instantiates the class inside of it. ```js const A = initialState =&gt; { let c = new AClass(initialState); return selector =&gt; { method: c.get(selector).method } } const a = A(initialState); a(selector).method(); ``` The way the class conforms to what you'd expect (which is what everyone else in this thread has been disagreeing with).
If your models are plain objects you can use an interface or type alias. TS is a structural type system, which means as long as the shape of the object matches the type, it'll typechek. No need to instantiate it with a class. Personally I'd use classes only if I have methods etc. Otherwise plain objects feel much better.
It's a case-by-case basis, but generally your definitions should be classes, and you should define and use interfaces only when you need to. If you have a single object that you know will only ever behave in a certain way, who cares if the type is an interface or a class? TypeScript doesn't. // is Argument a class or Interface? Doesn't matter. function something(argument: Argument) On the other hand, if you're building a library and you have no control over what the end user's classes will be, then you're better off exporting an interface so the users can conform to the contract you need. Or, if you know that your own project might have multiple compatible needs in different objects, then yeah use an interface. If you're coming from Java, it's easy to carry over the "everything must be an interface" mindset, but don't do that in TypeScript. Use classes for your objects, and *if* you need an interface, use one. Don't go crazy making everything an interface and a class just because. 
It's now possible to keep backward-compatible type definitions thanks to the `typesVersions` field in `package.json`. See the _Version redirects for TypeScript via typesVersions_ section in https://blogs.msdn.microsoft.com/typescript/2018/09/27/announcing-typescript-3-1/#version-redirects-for-TypeScript-via-typesVersions If the definitions are distributed by DefinitelyTyped, it's also possible to install a specific version of your typings.
Yeah, that works, i guess. Wouldn't call it best practice though. &amp;#x200B; Also you could probably shorten it a bit by just returning `c.get(selector);`
Like /u/satya164 said, if your models are just plain objects, use interfaces. But if you plan to add more model specific functionality or validation, use classes. Like for example validation, which if you're ok with decorators, can be really nicely done with [class-validator](https://github.com/typestack/class-validator).
Hi - I am creator of jsstore. So i wont do any comparision between them. Both library are good, its upto users what they like and how they want to use. Here are some features of jsstore - * Executes In Web Worker * TypeScript Support * Join Support * DataType Support * Complex Queries Support (Every query that you can think can be executed using jsstore) * Api Sync Support * Sql Support - through an extension [sqlweb](https://github.com/ujjwalguptaofficial/sqlweb) * [IDBStudio](https://github.com/ujjwalguptaofficial/idbstudio) \- A management &amp; debugging tool for jsstore. Hope this answers what you were looking for.
I would argue that in JS passing plain objects around is just fine. Interfaces with functions that accept them is the most javascripty way to do typescript. Classes are not necessary and you‚Äôll find that they provide few benefits over objects and functions. Javascript import export module system works best on objects with many separate functions. Exporting a class with a million methods cannot be tree shaken on the front end
We've all done that before.
I'm a big fan of the anemic entity model. It says your data doesn't have behaviour with it. All behaviour sits externally. Therefore, it follows that interfaces are a great use case for domain objects. Also they'll serialise without the possibility of extra work
If you need the types at run time (for example using boolean logic on the types) use classes, if you just want type safety at compile time, and don't want to inflate your final bunlde, use interfaces. As simple as that
Thanks a lot, I will check that :) 
Most JavaScript frameworks are not OOP, nor is that a trend I've detected. Emulating OOP in TS is something I've primarily seen from newcomers from OOP backgrounds.
Most Javascript frameworks are component oriented... a component is very similar to an object, in fact it is an object. 
Unless I've got behaviour I use interfaces and a closure to implement the interface. eg `interface Foo {` `a: string` `b: string` `}` and then create Foo with `const foo: Foo = {a: "Hello", b: "World"}` &amp;#x200B;
Don't forget the best thing. Interfaces don't end up in runtime code so you lose unnecessary weight ;)
You could split my types into four fuzzy categories: 1. Single-use types, defined inline (in the same file as where they're singularly referenced, at least). 2. Types confined to a specific feature / directory, in a `types.ts` at the root of that directory. It's a pattern I sparsely use in React apps, and they're typically just type aliases. 3. Common interfaces in a types directory in the root of the project. Not entirely sold on this yet myself, though I have found it helpful in TS-isomorphic projects. 4. Common contextless types in an ambient declaration in the root of the project, for example `Omit`. Technically I also have a typings directory when a library I'm using doesn't have any types provided either directly or from DT. Curious to hear how others handle this.
I don't use namespaces, and I don't think you have to in a nodejs or typescript project, you could think of a namespace as a whole module, like \`import \* as UserNamespace from "./model/users"\` &amp;#x200B;
I would recommend only exporting a single thing from each file. With regards to the folder structure I would recommend delaying taking the decision on how to structure until you actually need to do it. So when you have too many files in a folder - whatever you feel that is - then it is time to figure out how to group them in subfolders. If you delay creating the folder until after the files have been created, it's usually quite obvious how you could be grouping them. Moving files around does, of course, add the annoyance of having to update the import paths to these files. You can mitigate this by dragging the files inside Visual Studio Code, since it should then update the paths appropriately, and by avoiding having multiple classes/files with the same name in different folders.
Depends on the project. I'm a big fan of keeping things flat, but at work we have hundreds of files so the source folder has subdirectories: utilities, components, services, types, redux etc.
I agree with the components, services, types structure. Where do you put shared components? Most of the time I do components/xyz/xyz-list/... components/xyz/xyz-card/... components/xyz/xyz-details/... components/abc/abc-list/... components/shared/datepicker/... components/shared/autocomplete/... ...
&gt; they usually cram several different classes, interfaces, standalone functions all in a single typescript file. one reason they might do this is to work around webpack's inability to handle reference/dependency cycles, including those that would be acceptable in Java or C#
If you're making a SAP in typescript, I recommend looking into [Angular](https://angular.io). It takes care of the compilation/build pipeline by just using terminal commands (Angular CLI), and the project organization is well defined, so you don't even have to come up with your own, all you have to do is write TypeScript code: https://angular.io/guide/quickstart
We just put them directly under `components/`. Components tend to be reusable by design so it's easier to avoid the decision and keep it flat. In the case that one component is complicated enough to require multiple files that will never ever be shared then we put them in one folder (or even a small tree if significantly complicated). Just give components long names to describe what they are rather than grouping by directory. Keeps import paths short and reduces decision overhead and the busywork of moving components when their usage changes. General rule: avoid nesting unless you have a really good reason.
Thanks for posting this.
My pleasure! Really want to encourage more people to participate in the project
How old is your browser? Use a more modern one.
Typescript supports an import-less style of coding as well. If you avoid using top-level imports or exports in a file, it will consider all top-level declarations in that file to be globals. The TS compiler, for example, is written in this style. They wrap everything in every file in a `ts` namespace. The compiled code ends up doing roughly `var ts = ts || {};`, so it uses the same global ts object across all files. tsconfig's `outFile` option can do the concatenation for you, but I think it requires you to explicitly list all source files in your tsconfig's files array to set the right concatenation order. There are caveats explained here: https://basarat.gitbooks.io/typescript/docs/tips/outFile.html
This is really great. I had no idea about this project and it looks incredible
This is really great, thank you! The whole thing provides a high-level deno understanding I couldn‚Äôt easily get from the project itself.
Unless you gained 3,000 stars and 9 contributors since you posted this, I think you're doing all right! Sarcasm aside: those 9 other contributors were all involved a while ago, not recently. Did you ever talk to them about why they contributed in the first place, and why they didn't continue contributing?
Thanks I'll read up about namespaces. What's the issue with RequireJS? Seems like that would work fine in my initial testing.
The repo looks great. If you don't have any contributors, maybe there's nothing someone \*really\* needs.
thanks !
No. Even if for us now it would be a no brainer, think about when jQuery was a standard and many called for it to be included in a browsers by default. Would it make sense today?
No other platform supports running a typed language directly. Pretty much every language have to be compiled down to a level that includes essentially no actual type information. Adding more steps for the browser to do, as typescript would take strictly longer than Javascript to compile, would mean a website made with typescript would be much slower. Instead, what I'd like is a typescript to web assembly compiler that could produce a more efficient build than the equivalent Javascript. 
No, but I predict strict typescript will be one of the main languages compiled/transpiled to webassembly. Wasm is statically typed so TS have an advantage over plain JS in that regard, but is is popular and similar enough to be the obvious choice when wasm "takes over". 
The real contributors I know in person :| Rest is usually correcting small bugs in readme etc. Is there any portal where I can find people willing to help me build these or create feature requests?
People are using the app already together with mock backend. I am thinking about talking to other companies with some real profits for them. I just thought it was working different :|
I took a look at it putting myself in the "possible contributor" state of mind. Everything looks well organized and documented, but the one thing that leaped out at me was the lack of content in the open issues. For one, there weren't a lot that looked small enough to get my feet wet, but more importantly, I didn't see a lot of information in the issues except the title. If I want to contribute, I'm looking for some well-defined task I can get started on, but I can't do that with no information. Try to fill in more information for existing issues, and establish minimum requirements for reporting issues, it might help. Otherwise, it looks really good. It looks like it has a lot of potential. 
Typescript has so much of js still in it (all), so compiling it means basically including a complete js runtime. Perhaps a subset of typescript could be created, where it could be used as a statically compiled language, just like C. 
Not clear why they would do this. 
It exists already: https://github.com/AssemblyScript/assemblyscript
I don‚Äôt even think it‚Äôs a good idea. I rather have it stay flexible for further development and not fall into backwards compatibility issues. Right now you can choose the version of TS that you want and your code will keep compiling and you working for years to come. 
This is the correct answer. Type script was never designed to be interpreted. It would be slower than languages built with interpretation in mind. Including java script. It doesn‚Äôt make any sense to have browsers read it directly unless for development purposes not production.
As you already found out, you can't easily add those kind of constraints to the standard Express API. To do that, you have to add your own typesafe layer on top of Express. In [this article](https://federicoferoldi.com/2017/12/28/using-the-typescript-type-system-to-validate-express-handlers.html) I explain a way to do that that I've been using in one of my projects. It's definitely more code compared to the "unsafe" API, but you get the benefit of a compile time check of returns types - that is very handy, especially if you generate the Typescript types for your API directly from a Swagger spec (for instance with a tool [like this one](https://github.com/teamdigitale/italia-utils/#gen-api-models))
Thanks for this constructive answer! I will try to improve the issue description! Thanks a lot!
Well there is https://github.com/denoland/deno by the nodejs guy.
I love typescript but I think Dart will be the go to for wasm. It‚Äôs got a great standard library and is a more modern language. I fear Typescript will never be able to move on from the shortcomings of JavaScripts ecosystem. 
Thanks for the article! Will definitely check it out. 
It's just outdated and less commonly used. If you're going to go to the bother of adding a module loader, you might as well use a bundler rather than requirejs, because you'll get more power from a bundler. It can do dead code elimination, it eliminates the need to specify all your source files in order, it combines everything into a single file, etc. Requirejs means adding an external component to handle your imports, so it's really no better than using a bundler. It seemed like you wanted to avoid adding any extra moving parts. If that's the case, you'll need to stick with the namespaces style.
Es6 modules spec supports a translate hook that can transform source code. I that it would do the trick. But I might be looking at outdated information.
I don't know much about Dart, but it is probably better than JS :) Why do you think Dart is especially suited for overtaking JS in a Wasm dominated future? My bet on TS is because it is the least resistance for current front end programmers. Apart from that, Java and C# will probably be used as well. I would bet on Python (it seem to be everywhere nowadays) if not for its dynamic typing. One point against Dart is that it apparently got a very different type of garbage collector. The current plan is for Wasm to expose the GC of the JS runtime. Dart could bring its own GC (like all languages do today) but it brings its own problems. 
That‚Äôs interesting. But the subset they support is so limited, it is not really typescript anymore. https://github.com/AssemblyScript/assemblyscript/wiki/Limitations For example, unions are not supported. I feel like Discriminated Unions are one of the cornerstones of idiomatic typescript. 
You can do this yourself easy enough. The compiler can run in browser, so send down raw TS and compile locally. Store locally. Done
One thing missed here in the comments is Microsoft is jumping to use Chrome as their browser. Ryan Dahl is already working on a native TS runtime. There's no reason for them \*not to attempt\* to add a native Typescript-based ECMAScript runtime, just skip the middle step of compiling to JS. How it would work in practice \*on\* the web I have no idea, but it could be an interesting step for the language.
Oh neat, had no idea anyone was working on that.
Small correction to some comments in this thread: Deno is still internally doing trans compilation to JavaScript. The compiled files are cached to avoid repeated recompilation, and the TypeScript compiler is snapshotted directly onto V8 heap to start up much faster (than say, ts-node)
Glad it helps!
Google initially built dart to replace JS. It‚Äôs fairly trivial to pick up if you understand typescript or Java. Unlike Java and C#, dart has promises (Futures) build in for concurrency and compiles to readable JS. Normally I‚Äôd say that wouldn‚Äôt be enough for wide adoption or even enough incentive for google to implement wasm for the dart vm; but with google moving android to fuchsia and having flutter fully support it they have every reason to make sure dart stays relevant on the web as well. Maybe I‚Äôve been in dart-land too long but dart feels like the ideal middle ground for backend and front end devs. Will always love typescript just my opinion ATM.
The whole benefit is to catch more bugs before runtime, so I‚Äôm not clear on the benefits of doing that at runtime. You already get runtime errors without typescript... maybe there‚Äôs a use case for runtime assertions as a DSL though but that‚Äôs not what typescript is designed for
C# has out-of-the-box support for promises/futures since 2012. It's just called Task&lt;T&gt;. 
I never knew that thanks!
[Here's a proposal to add optional static type annotations to JS.](https://github.com/samuelgoto/proposal-pluggable-types) The type annotations basically do the same as comments at runtime, and an external program would be used to check types, like TS and Flow do now. I think this is a really good approach which allows us to leverage our existing tooling, as well as seamlessly fitting into the JS ecosystem.
I would have guessed jQuery was inspiration for queryselector. 
It probably was. But I meant people wanted the whole library to be included :) 
No, and Microsoft has said that was never the goal. However, Ryan Dahl (main author of node js) has moved on to a new project called Deno. Which is an ultra fast high security typescript runtime written in rust. https://github.com/denoland/deno
You mean something like Blazor??
I think that's quite a big correction actually. OP seems to wish that the runtime would do additional type checking on top of what TS currently does during (and pre-) compilation. Deno does not do that and I don't think TS would be a very good candidate for that kind of thing as it was designed to be purely a compile time tool. Lots of TS code in the wild just wouldn't pass those runtime checks - there's too much trickery with _any_, union types, etc. being used. 
I 
I don't think it's a good idea. All of the type annotations are not required at run time and will just add extra weight. So people will still have a step to transpile/filter before production to remove all of the extra stuff (spaces, annotations). Might as well compile to JS then.
Why IS your library useful?
And java has futures
Google already tried that and declared it a failure. The main problem was maintaining type checking when files can be loaded in different order or even on demand
But we're pretty much there. Some things have been changed a bit but spiritually it is there. Makes you wonder if adding the literal library would be better
You underestimate the amount of stuff that jQuery still brings.
Chromium, not Chrome
Can't give a longer (and possibly more helpful) answer right now, but check out generics: https://www.typescriptlang.org/docs/handbook/generics.html
Thank you! I will take a look! I was hoping I was just missing something that could solve this!
I'm pretty new to TS also but I think what you want is a generic
This does appear to be EXACTLY what I was looking for. Thank you for pointing me towards this!
also beware of the rest operator. You need to keep in mind that it only does a shallow copy of the object. Example: &amp;#x200B; `const a = {` `prop: 'value',` `nested: {` `nestedProp: 'nestedValue'` `}` `}` &amp;#x200B; `const b = { ...a, prop: 'newvalue'}` `a.nested === b.nested // true` `b.nested.nestedProp = 'will change A'` `a.nested.nestedProp // "will change A"` &amp;#x200B; You're probably aware of this behaviour, but I think TS won't give any warnings in the case of your utility function &amp;#x200B;
Thank you for bringing this to my attention! I am aware of it, but it helps to be reminded, and hopefully will help others who come across this!
First, I am working on the quick start now. I will put together a simple bare-bones example of how to use the library. Second, on why it is useful: I found myself wanting to use TypeScript's type checking to give me auto-complete, and to make sure I am always calling my requests with the appropriate parameters. I started doing this by make an "api class", and creating functions with all the inputs and outputs. I noticed as I was doing this that I basically did the same thing over and over. Then I abstracted it out to a crude version of this library. Finally, I saw I did this in multiple projects, so I extracted it out to a library to share to each project. It takes all the boiler plate of typing out an api and allows you as a developer to focus on the types specifically.
Very nice.
The problem is that passing \`this.SetEffectiveDate\` unbinds the method from the instance, so when it is invoked, \`this\` points to something completely different.
When invoking a callback in JavaScript, functions have a different notion of what `this` is. When you use an arrow function (as in the commented line), that has an implicit bind to `ngOnInit`'s notion of `this`. To get the first line to work, try using `this.SetEffectiveDate.bind(this)` to explicitly define things.
Thanks for the explanation.
In a similar situation I used the [instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) operator like this: eventHandler(ev: MouseEvent): void { const target = ev.target; if (!(target intanceof HTMLElement)) { return; } // handler stuff } Not sure what impact it has on performance (if applicable) but in my case it works perfectly.
Thank you.
To answer your question directly, no, ts doesn't have a built-in option for this. This sounds like a feature that would be really tough to get right. There are legitimate uses for the `any` type, and it's used in TypeScript's built-in declarations. Disallowing it completely would probably cause all ts projects to fail.
Sounds like this is what you are looking for: [https://basarat.gitbooks.io/typescript/docs/options/noImplicitAny.html](https://basarat.gitbooks.io/typescript/docs/options/noImplicitAny.html)
I'm afraid this is enabled already via the --strict option. https://www.typescriptlang.org/docs/handbook/compiler-options.html
As others are saying, the compiler can‚Äôt and shouldn‚Äôt enforce this. Tslint, however, provides a rule that will. https://palantir.github.io/tslint/rules/no-any/
I tried tslint quickly with the no-any rule but couldn't get it to work. Are you sure tslint should be able to detect this any type?
A combination of Typescript compiler options and TSLint can completely block `any` from your project. A few notes: * TSLint needs to be run with the type info flag set (on my phone so I'm not sure what the actual flag name is). * You'll probably need to turn on a few more flags than `no-any`. * For linting to work as intended you'll need a script that automatically runs the linter server side (like a CircleCI build, Jenkins job, or Gitlab Pipeline) and blocks code that fails linting from being merged. If you're working by yourself a git pre commit hook might be enough.
I tried the tslint "all" rule config which looked promising at first, but looks like it didn't completely prevent the use of event.target.should.not.compile variable. (which of course throws runtime error).
You could use a less generic event type, eg React.ChangeEvent&lt;HTMLInputElement&gt;
I think this is a bad idea. You never know when you will need an escape hatch, especially if you are going to rely on any 3rd parties. I suggest you try to approach it instead as a best practice on your team not to use any. You may even be able to find or write a list rule to trigger warnings
&gt; I find any useful when I‚Äôm developing. If I‚Äôm quickly riffing on code and haven‚Äôt quite figured out how I want it to look, I‚Äôll start there and then lock it down once I‚Äôm comfortable. I like to start with `{}` or an empty interface. That way, you get compiler errors when you're making changes and you can fill out the interface as you find yourself adding/removing properties.
There's probably some additional rules you need to turn on or configure? Like `typedef`, `no-typeof-undefined`, `strict-type-predicates`, etc. Here's the config I use for tslint: https://github.com/CSMastermind/tslint-config/blob/master/tslint.json I turn on the following compiler options: { "compilerOptions": { "allowJs": false, "allowUnreachableCode": false, "allowUnusedLabels": false, "alwaysStrict": true, "baseUrl": ".", "esModuleInterop": false, "experimentalDecorators": true, "forceConsistentCasingInFileNames": true, "lib": ["dom", "es2018"], "module": "commonjs", "moduleResolution": "node", "noFallthroughCasesInSwitch": true, "noImplicitAny": true, "noImplicitReturns": true, "noImplicitThis": true, "noUnusedLocals": true, "noUnusedParameters": true, "outDir": "dist", "paths": { "*": ["node_modules/*"] }, "pretty": true, "removeComments": true, "sourceMap": true, "strict": true, "strictFunctionTypes": true, "strictPropertyInitialization": true, "strictNullChecks": true, ... } Note that you'll have to pass the `--type-check`flag into tslint. 
Coming back to this a couple months later; sorry for the delay. You went above and beyond with your example code, my friend. Your example made it very clear. Thanks a lot for taking the time to do that. Happy New Year!
Coming back this after quite a while, sorry about that. What you wrote made complete sense to me. Thank you so much for explaining that whole thing to me, I really appreciate it! All the best to you in the new year!
Import the whole module, and use tree shaking to optimize the size. https://webpack.js.org/guides/tree-shaking/
Got it working, thank you! Looks like `--type-check` is deprecated but `--project` flag did the trick too. The exact tslint rule which i was looking for is called `no-unsafe-any`.
The way I do TS is I write JS code I `.ts` files while using a relatively strict `tsconfig.json` and fill in types when the IDE complains (in my case, WebStorm).
That sounds very interesting! Thanks! :)
this is not a TS runtime as of today, Deno is compiling TS to js.
You're looking for the "unknown" type
treeshaking happens if it can, there is no way to use tree shaking
You could write a definition file which exports the appropriate thing: ```ts declare module 'jssha/src/sha1' { export { sha1 } from 'jssha'; } 
The TypeScript compiler does not support tree-shaking, sin order to "use" tree shaking you need to use a tool that supports it (and perhaps configure it accordingly).
OP is talking about bundle size, if they are generating a bundle, I'm fairly certain they are using a bundler and not TS compiler by itself. Pretty much every modern bundler such as webpack, parcel and rollup do tree shaking by default. There's no configuration necessarily to enable tree shaking except building for production which they should be doing for production bundles.
Exactly right, I'm using rollup to bundle and I am not using the TypeScript compiler in the build pipeline (only using `tsc` to type-check before running it through babel with `@babel/preset-typescript`).
When placing that in `declarations.d.ts`, TS complains as such: &gt;Module '"./node\_modules/@types/jssha"' has no exported member 'sha1'. ts(2305) and also doesn't seem to pick that up (maybe because it's invalid), complaining it can't find a declaration file for module 'jssha/src/sha1'. If I try to put it in the same file where I import from jsSHA, it says: &gt;Invalid module name in augmentation. Module 'jssha/src/sha1' resolves to an untyped module at '/path/to/node\_modules/jssha/src/sha1.js', which cannot be augmented. &amp;#x200B;
@tsnoobforreal that's just example code, you have to export the proper typing from there. if `import sha from 'jssha'` and `import sha from 'jssha/src/sha1'` have the same types, you can `export *` (see updated comment). TS compiler probably fails because the types aren't correct in my example. I usually create files like `types/modulename.d.ts` and place it there, but `declarations.d.ts` should work fine too after fixing the types.
Here are some examples if you need: https://github.com/expo/snack-web/blob/master/typings/prismjs.d.ts Another example there is in `prettier.d.ts`
Interesting. I looked up the error I was getting from trying to use `export * from 'jssha'` and messed around until I got this: ``` declare module 'jssha/src/sha1' { import jssha = require('jssha'); export default jssha; } ``` That was fine syntactically, but type checks were still failing. Then I moved it from `declarations.d.ts` to its own `types/jssha.d.ts` and now it's recognized and everything appears to be passing! That startles me - is there a difference between those two file conventions? 
I have never used a `declarations.d.ts` file, so I'm not sure if there are any differences.
I could have sworn I got that from the TypeScript docs, but maybe it was one of the many blog posts or tutorials I've read on TS lately. Regardless, thank you so much for your help - the matter appears to be resolved! üéâ
That's really cool. Getting close to angular üòè
For anyone who happens to stumble upon this in the future, `declarations.d.ts` did not work and `types/jssha.d.ts` did work because I had `"include": ["src"]` in my `tsconfig.json` and `declarations.d.ts` was at the root of my project, while I had accidentally created `types/jssha.d.ts` _inside_ `src`, where TS picked it up. TL;DR - the two declaration files are equivalent, I messed up.
Yup, but its nice to be able to use Vanilla TypeScript without being forced into using Angular, Vue property decorators og React TSX
I totally agree! Do you have this anywhere on GitHub? Would love to take a look at a little example app. This could be pretty useful for one of my pet projects at work. I'm currently using angular 7 and it's massively over kill
https://github.com/mrtt1000/custom-htmlelement-decorator \&gt; npm i &amp;&amp; npm run build Then it should work
Surprised you didn't come across [Stencil](https://stenciljs.com/docs/my-first-component) which has decorator components as well as it's own routing and state for web components.
Have you tried this? showResults(form:any){ this.searchService.getResults(form.searchBox) .subscribe(data =&gt; { this.results = data; console.log(data); this.searchEvent.emit(data); }); } Most of the time when you write function(data) instead of data =&gt; then you end up throwing 'this' away, so when you call 'this' it is something completely different that what you expected.
Use an arrow function to make this refer to the function. 
^--- this is the answer
how did you do get the syntax to format? I want to be around here more to figure out TS. Interesting. I thought fat arrow and function were the same thing? I might have to look into fat arrow more. 