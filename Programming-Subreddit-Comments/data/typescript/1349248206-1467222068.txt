Another little feature that I really like is that you can declare member variables in the constructor's argument list (p. 65 of the spec): class Point { constructor(public x: number, public y: number) { // Constructor body } } is shorthand for: class Point { public x: number; public y: number; constructor(x: number, y: number) { this.x = x; this.y = y; // Constructor body } } You can also combine this with default arguments: class Point { constructor(public x: number = 0, public y: number = 0) { // Constructor body } }
mmm member variables and type hinting
Pretty good overall article! I really think M$ is doing a winning move by adopting a language spec that has a really good chance of being ecmascript 6, and making the additions beyond that ( static typing declaration ) completely optional.
This would actually be really great to have. If anyone is looking to add this functionality without waiting for ts to implement: http://tamejs.org/
Man, this is awesome. I'm kinda impressed with the toolset available at launch for TypeScript. I mean, it makes sense considering that it's MicroSoft and they would have the resources for something like this, but the fact that they're even throwing some resources at this is impressive.
I'm waiting till this weekend to properly set up my dev env with the sublime text syntax file. This page is actually linked from http://typescriptlang.org but it's hidden towards the bottom - you can barely tell there's a link.
What if you passed in undefined as the value for the name? Then it's incorrectly changed to the default (although you could conceptually claim that is the same as giving no parameter). arguments.length is the only way to be 100% sure if a parameter is given or not.
Isn't undefined literally the same as giving no parameter? I mean, if you were in a case where you needed to pass something as "undefined" just don't set a default value for it.
Literally speaking, no, if you provide undefined then you have provided a parameter. For example it will be stored in the arguments, and reflected that it's been given through checking arguments.length. However conceptually, a tonne of JS programmers (myself included), use undefined as a way of saying 'no parameter'. Technically it's wrong, but we still do it. It really depends on context. If it's stuff I will only use, I'll accept undefined. However if I expect others to use it, I'll use arguments.length, as it's the only fool proof way of knowing.
If there was a case where you had to treat undefined as undefined explicitly then you could conceivably just set the default value to undefined which fixes your use-case. 
That's why JavaScript has both undefined and null values. :-) The undefined means that the variable (or property) is not defined (and it is logically empty), so it means that it should change to the default value. But when you pass the null to the function, it also means the parameter is empty but it's defined. And it's the important difference.
Yeah, that's what I said above, and already agreed. However technically speaking, you are wrong: var f = function() { console.log(arguments.length); } f( undefined, undefined ); // prints 2 Undefined **technically** counts as a parameter, because the developer provided undefined as a parameter. You can talk about what it conceptually means, but that's all subjective, because technically speaking, it's there. Again, the only way to check if a parameter is provided or not, is to check arguments.length.
But you should never pass the undefined as a regular value. ;-) Imagine we have a function: function doSomeMagic(el : Element = document.body) : void { if (el !== null) { // some code here } else { throw new Error("No element passed"); } } And we call it multiple ways: doSomeMagic(); // The body is passed doSomeMagic(undefined); // It's still the body doSomeMagic(document.getElementById("not-existing-id")); // Error 'cause it returns null Sorry, I can't think of a better example but this could explaint it a little bit.
You really shouldn't be passing undefined unless you mean to pass it to be equivalent as missing that parameter. I think it would be very misleading if a function manipulated an undefined parameter differently than a non passed parameter. Both should run equivalently.
&gt; Both should run equivalently. Should, but they don't. That's my point.
 function foo(a, b) { this.a = (a != undefined ? a : 5); this.b = (b != undefined ? b : 'brown'); } Is a common way of handling if parameters are passed. Both: var bar = new foo(); var bar2 = new foo(undefined, undefined); are equivalent. This would be pretty basic functionality that I would expect anywhere and would really confuse me if I found a place where it was different.
Agreed, as I said ... &gt; although you could conceptually claim that is the same as giving no parameter However technically, it's not the same.
Hi everyone, I created a TypeScript interface (kinetic.d.ts) for the www.kineticjs.com/ library (awesome library for canvas drawing and animations). The interface adds the KineticJS Library Types to the VS Intellisense which makes it easy to use in your TypeScript projects. Hope you guys like it. **Disclaimer** The creation of the interface was a lot of handwork in typing the classes and reading the documentation. Overall I think I got most of it right. But ofcourse I could have made spellingerrors or small errors like required parameters where they should be optional. If you find such errors please let me know so I can fix em and update the interface. 
I must admit that I almost cried when I read your comment, you gentlemen sir! That was damn epic. [My reaction upon reading this](http://i.imgur.com/SUuXts.jpg)
Haha nice :)
But practically it is the same. I don't care if the undefined value is given by a programmer or by an interpret, it's still undefined and I should replace it with the default value.
Whoa... look at AerateMark's comment history. Looks like he's an upvote bot.
I have some working JS where VS highlighted the entire thing in red. The module thing probably is a bug; you should submit it to their tracker on CodePlex.
 if (!dest) dest = new vec3(); The test here coerces 'dest' to become a new value. It converts it from a vec3 object to true, or a 'null' value to 'false'. Then it does the check. If you change this to ... if (dest === null) dest = new vec3(); Now 'dest' is never converted from one value to another. Whilst a 'true' or 'false' is still returned from the '===', this change can actually improve speed on some runtimes. Further if you look at the code generated from the first two lines ... intersectRay(rayStart: vec3, rayEnd: vec3, dest: vec3 = null): vec3 { if (!dest) dest = new vec3(); This will generate the code ... function intersectRay(rayStart, rayEnd, dest) { if (typeof dest === "undefined") { dest = null; } if(!dest) { dest = new vec3(); } } So it's now testing 'dest', twice. So you can optimize that by making 'dest' optional instead. intersectRay(rayStart: vec3, rayEnd: vec3, dest?: vec3): vec3 { if (dest === undefined) dest = new vec3(); Now 'dest' is only tested once. Obviously benchmark it to confirm, but I'd place money on it that you would get a (very minor) speed up. That might help if this is called heavily, such as in a 3D game engine. Finally classes should really start with an uppercase letter, 'Vec3' rather than 'vec3'.
Hooray for generating `else if`. Previous version produced levels of `else`s.
You now can in [version 0.8.2](http://blogs.msdn.com/b/typescript/archive/2013/01/21/announcing-typescript-0-8-2.aspx): &gt; It’s possible now to specify output directory when compiling external modules. This gives a cleaner way to build external modules without having the output in-tree.
No shit, its not supposed to be. Typescript is meant to help during development, not to enforce anything in the generated code. I mean, if we make sure members are private in javascript then we might as well make sure types were correct in javascript as well no? I don't think the author would like to have type checks in every function :)
If you go all TypeScript, this is a non-issue. It's also not that surprising, giving that TypeScript explicitly does not aim to generate 'intelligent' JavaScript, just dumb plain JS. With my own JS, I follow the Java route, and presume fields are always private. If I need access, I'll have to write a getter, even if it will never do anything other than just return the value. If he followed this pattern, this is a non-issue. It's only an issue when you are mixing TypeScript with JS, and tbh as long as you (and your team members) are not choosing to circumvent the system, it's a non-issue. i.e. only use public methods/fields, since they are stated as public, in the source code and documentation. I think the bigger issue here is that TypeScript-JavaScript is not that friendly. Mixing the code within TypeScript files is a pain, almost making more of a TypeScript separate language, than a superset. Importing JS libraries is also painful with long type declarations, or lots of code to port (with 100s of 'any' types to track down). But really, it's not that surprising that it behaves like this. &gt; var that = this; &gt; But think about that single line from a C# programmers point of view. WTF is a that and why does it have to store this? What kind of ridiculous ass language changes this to that and then changes this to many different objects depending on context, while holding an internal reference to the original this which is now called that. I disagree. I'll agree it's less common, but Java has inner classes, static classes and anonymous classes, and so any experienced Java dev would have come across similar notions of having multiple contexts in one place. I'm sure C# has similar (and probably goes further than Java).
JavaScript has never had strong typing - hence the reason that was never enforced. What JavaScript does have is a best practice for creating private members by hiding them in a closure. http://javascript.crockford.com/private.html
Having worked in C# for several years, and working with C# developers now who have never been exposed to JavaScript - I can tell you, explaining this=that to them was like explaining a programming language from an alien planet.
Creating private members that way while is the best practice for creating true private members, is generally a really bad practice of creating methods. These members will be instance specific and exist for every instance of the class.
Still no truly private properties. 
This is looking awesome! Generics adds what I never knew I needed so badly.
Funny. I had to go back and look. Yes, I guess he liked his syntax highlites.
In that case, it's strange that the blog of a web development firm does not make use of [JavaScript syntax highlighters](http://alexgorbatchev.com/SyntaxHighlighter/) like every other blog does for listing code.
I am not sure that it makes sense here. I think the Zen has something to do with appearance, which fits very well with Python. But in a C style language, it isn't as 'elegant' of appearance (IMO). That said, I feel that at this early stage of my experience with TypeScript (using 0.8.x) I am enjoying it a lot more than coffeescript or pure javascript. So I can see an elegance of design.
Reading through, it seems like all of the gripes I've had with TypeScript have been solved. Yay!
Would be much better if typescript allowed operator overloading. :(
That's true. but I think you get used to it pretty fast. After all, it's not much more to write: v1.add(v2) compared to: v1 += v2 etc.
Looks very interesting but I personally don't agree with the choice to depending on the haskell platform: TypeScript's own compiler can run on Node.js so I'd think it makes sense to build any additionally tooling on the same, and leverage NPM ecosystem. For example I would like this in a `grunt` task, so all users and CI's can run it with zero hassle. But if they need a haskel environment to use this tool it gets to complicated to my taste. There is quite a ecosystem growing on npm: see `grunt-ts`, `grunt-typescript`, `tsLint` (and `grunt-tslint`) and soon also the new [tsd](https://github.com/DefinitelyTyped/tsd) (and some more)
The emphasis on building complex programs out of smaller parts certainly helps, and a lot of the core libraries (e.g. parsec) are structured in that way. I find it also affords better forms of abstraction, that while not impossible in a language like TypeScript, are more difficult to maintain due to lack of support from the type system. For example I often fall into the trap of the compiler inferring `any` in TS and letting a bug fall through the cracks. Type annotations help obviously but you have to remember to use them in quite a lot of places.
Thanks for the info. Runtime presence of the types is what I sometimes miss in TS (and JS in general). I used to a do lot of heavy ActionScript 3 which is so similar to TS but the AS3 VM uses (and enforces) the typing at runtime and also allows for useful introspection (in this it was miles ahead of it's EMCA origins, like JS with its shabby `typeof` and `instanceof` :) 
Sounds like fun.
wut
I have very little TypeScript experience, so apologies if these are dumb questions. :) Is the intent behind offering both 'small / isolated' module builds and the 'monolithic' one focused on development/debugging vs production? Since it mentions Visual Studio, is this intended for ASP.NET sites? I would think that you'd have TypeScript always compile to a matching file (the default behavior - same location, change extension from .ts to .js - certainly makes side-by-side views easier :) and combine/minify/etc would be done via ASP.NET's existing bundling/minification support (which AFAIK already has debug-friendly vs production support). If the goal is more around having small/isolated modules and having them require each other as needed, it might be worth including a compare/contrast with using /u/SubStack's excellent browserify npm module and the typeify module that adds TypeScript support to it. That's what I'd probably use today if I was trying to do "isolated module development" in TypeScript, so understanding what tsmc offers/does differently/better/etc would be great!
What kind of projects are they?
Microsoft employee here. I work on Visual Studio Online, and we use TypeScript extensively. I honestly can't imagine going back to raw JS at this point.
I'm working on a WebGL powered graphics engine in TypeScript. I've published the vector and matrix library that I've written for the project on GitHub: [github.com/vexator/TSM](https://github.com/vexator/TSM)
Are they open? If so, link?
Working on a rewrite for an online gaming company and we're using TypeScript.
I experienced this problem and I like this solution but I have a few questions: 1. does `tsmc` work well with non-Visual Studio projects? I use WebStorm and usually compile using `grunt-ts` 1. does `tsmc` work with 'modules' that have &lt;reference&gt; to code outside their own directory? and if so, does it bundle these into the module or does it force them to external in some way? (looking at the Quick Start it seems it has some capability there) 1. is it ok if we name the config files .json instead of .tsm? 
I'm currently working on a pretty rich implementation of a mapping tool using the google.maps api, Typescript and knockout.js and am quite pleased with it. It takes postal code boundries that the user configures, draws them on a map, and allows them to apply demographic driven themes, overlays and radii to the map. All very rich, and actually quite responsive. When loaded with about 1000 postal code areas the tool still runs pretty well in the browser. 
Yes. Swap your function () {...} for a typescript lambda and the this will be captured for you. You can check the generated source code to verify.
Thanks, yea, that worked. Guess it just looks wrong when debugging.
I am talking about libraries to make parsers, not parsing typescript. I have started playing with recursive descent parsers in the absence of anything else.
Oh, hah. Well, if you need a parser in JavaScript more then it has to be in TypeScript then npm is full of crazy stuff: I know of Jison (Bison in JS) but there is much more: first random search: http://node-modules.com/search?q=parser+library
I am using AngularJS right now with TypeScript. It works really well. In the post above I was talking about writing a custom typescript emitter that added reflection data. Then rewriting the AngularJS injector to make use of those custom reflection attributes. The threads about adding reflection in TypeScript seem dead. I think it could me nifty to add an extra flag to the compiler --reflection that would generate the reflection info in a different javascript/json file. We could add a comment to the top of the TS files that should generate reflection. /// &lt;reflection /&gt; 
TypeScript is best script &lt;3
U too huh? I'm doing something similar writing an Engine/Editor on top of ThreeJS and some other libraries with TypeScript. Hoping to get the editor to a good spot then build my game with it (I imagine it'l make moding / community map making much easier later on) Good luck on your game!
You should have posted this in /r/javascript :)
WRT the bundling, it already supports having the output go to a single file - are you looking for something different?
If you're doing TypeScript in VS, make sure to use (or consider) ReSharper - they've made great progress in their 8.x releases bringing it close(r) to the functionality they have for languages like C#
Just an FYI - You can give feedback and discuss the language with the TypeScript devs directly: https://typescript.codeplex.com/
My main issue with typescript has been when I have to deal with the runtime javascript part. I usually have certain expectations that come from the types in C++, but I cannot make in javascript.
I guess I was looking to have specific .ts files put into one .js file without having to do bundling. It would make importing modules a bit easier. 
I have looked at resharper. It's not really my cup of tea. I don't get a lot of value from the tool, and it seems to be a dog consuming memory. But, then again, I haven't looked at it in quite some time. 
project properties -&gt; TypeScript tab -&gt; 'Combine JavaScript output into file' See the screen shot @ http://blogs.msdn.com/b/typescript/archive/2013/12/05/announcing-typescript-0-9-5.aspx
You can get a list of some of their TypeScript improvements in their 8.2 release here: http://blog.jetbrains.com/dotnet/2014/03/17/more-typescript-support-in-resharper-8-2/
I think he means more as features are bundled together. Like his admin area is in one bundle and his regular site in another. It bug feature that only half the people will use in another
It was a language design choice: &gt; Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is contrast with nominal typing. From: https://typescript.codeplex.com/wikipage?title=Type%20Compatibility%20in%20TypeScript This means also: interfaces are only a 'contract' that makes *explicit* which members a class should implement. It is not the actual type. In your snippet you could remove the `implements xyz` part of the class declaration and it would still work, as the compiler will see that Foo and Bar are compatible for IFoo and IBar. But then the compiler cannot check quickly if your classes follow the contract (important for bigger codebases), so it is better (and more readable) to explicitly state which interfaces a class should implement, so you can be 100% sure they are there as expected.
It is still under construction but it is already a lot more usable then the terrible language specification docx/pdf.
Finally!
I enjoyed reading the language spec :(
As specs go it is not bad but to learn the language it is a bit harsh. And who publishes just .docx an .pdf these days? Why not a html format? Or does MS realise Word's HTML exporter is still shitty?
Sure, but even EMCA now managed to have a simple HTML exported version. Still one huge page, but it is an improvement. It was specifically mentioned by some JavaScript guru in a presentation (I think Brendan Eich).
I find the best angle to approach TypeScript is to treat it as power-boosted and formalized JavaScript instead of a dumbed-down C#/Java/AS3 variant.
Can't you use a framework like angular or knockout with the appropriate typings? 
its not just templating, but we love angularjs + typescript.
We have gone down the same path, angularjs + typescript. It's fantastic!
how much TypeScript do you need it? why not plain JS templates like `handlebars`?
I certainly appreciate your point about docs for third party libraries and needing "to know what goes in and what comes out." I've experienced how helpful docs like that have been in my recent attempts to learn Ember.js, but their comparatively superior docs still aren't enough. I would argue though that knowing what goes in and what comes out isn't the same thing as having static typing. In a prototype based language I don't think it really make sense to speak of types. It only makes sense to say the object passed in is expected to have these properties/methods and the object returned will have these. That isn't the same as a type (though I understand it is similar and can see the confusion from people who are used to class based languages). I do appreciate the hard work you and others have put into the DefinitelyTyped project. You might want to check out a discussion on hacker news spawned by this post that raises some concerns about versioning in the project https://news.ycombinator.com/item?id=7496569
One thing I would point out is that typescript allows you define not only "types", but expectations. You bring up the pointthat working with new libraries bring's in the issue of not having a definition file, but I actually don't find that hugely an issue. In cases like that, I simply progressively add interfaces for the libraries as I access them, providing typing only information that I actually actively need "typed". This allows me to quickly and simply add a small safety net by setting expectations and also gain intellisense for the most commonly traveled paths.
I strongly disagree with a number of assertions this article makes. About the only one I agree with is that the definition ecosystem is still young and inconsistent. This I naturally expect considering the small community and the fact that we'll only be hitting 1.0 here shortly. That being, here's what I find wrong: 1. You mention that type checking doesn't actually address the core issues of JavaScript. I strongly beg to differ. For example, you give the example of "==". Typescript *does* "fix" this, in fact, because it will throw a royal hiss fit if you try to compare incompatible types in a number of scenarios, or at the very least it will attempt to warn you. Not only that, it allows you to catch the other pitfalls of JavaScript like it's odd scope and the weirdness of "this" using compilation analysis and fat arrow functions respectively. 2. I would hope that developers know that if they store a function in a variable, it's going to break "this". Nothing is going to make that easier without serious analysis or typing the variable. TypeScript's whole point is allowing you to catch a relatively large class of errors that you'd otherwise miss by setting expectations, while still allowing you to use (or abuse) the underlying language when you need too. I think simply hand waving it away as not going far enough or addressing the "wrong issues" is foolish. Edit: To sum, this article seems to bash TypeScript partially for not replacing JavaScript.
Sure, but in practice nobody really cares too much about this protoype vs class based distinction. You are picking at theoretical details while JavaScript is all about getting shit done. If you want full strictness and big theory you should use C# or Java. I've been doing JavaScript and ActionScript (1, 2, 3) for ages, like ~15 years.. been there done that :) Anyway, I posted a big reply about DT on hackernews: https://news.ycombinator.com/item?id=7498775
I forgot to add note about types: You say: &gt; In a prototype based language I don't think it really make sense to speak of types. It only makes sense to say the object passed in is expected to have these properties/methods and the object returned will have these. That isn't the same as a type (though I understand it is similar and can see the confusion from people who are used to class based languages). This was asked here few days ago: http://www.reddit.com/r/typescript/comments/21b4s8/identical_signatures/ &gt; Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is contrast with nominal typing. Which is exactly what you describe.
I'm a big fan of TypeScript. Thanks for all your work on DefinitelyTyped. Recently I converted a large single page app from JavaScript to TypeScript. The resulting code was much smaller, clearer and more obviously correct. Defining interfaces for data in the system formalised thinking and drew out abstractions. The exercise revealed several bugs in the old code as well. I now do all browser development in TS and would encourage any sceptics to give it a proper go, especially if you have historically enjoyed static typing.
Interesting to hear the version problem is finally being addressed as I know it was a problem when I worked on some definitions. I also wonder if some of the bugs I opened like not being able to extend Date got fixed by the compiler team... I think I gave up when generics were causing out of memory errors when trying to type check some definitions with generics, perhaps that has been fixed as well? Maybe it would be interesting to get back into writing the definitions but I haven't written a lick of JS/TS in 4 months after I stopped contributing. I had/have high hopes for TS but at times I have to say it does seem like its just a temporary fix for JS when optional types + modules/classes should just be added to JS directly. And lambda syntax... I mean what TS added isn't super revolutionary or anything for languages. Heck even Java 8 has lambdas. Ah well maybe this is the best we can do for now ;-)
Apparently I mis-understood what the point of this was, whoops.
&gt; versions Yea, well, like I described: in practice there are not many users who care enough for older versions to declare them. But it can work, if the data turns up in a PR. :) &gt; I also wonder if some of the bugs I opened like not being able to extend Date got fixed by the compiler team... That is still pending but it is a huge pain that we harass the TypeScript team about a lot. It could be solved if they updated it in the `lib.d.ts`(they did some stuff to it recently); so we'll have to see. Maybe now we reached 1.0.0 they can start to clean up. &gt; generics were causing out of memory errors Dear lord that was fun: I was creating bluebird definitions and got a 12mb type error: https://typescript.codeplex.com/workitem/2190 , it was a bug, solved in 0.9.7 (current) &gt; what TS added isn't super revolutionary or anything for languages That is what I like, like JavaScript with more power and less funk. Lambda's have lexical `this` (eg: great inside methods) and the shortcut notation that cleans up chained (functional) style code: // classic arr = arr.map(function (elem) return elem.name; }); // lambda arr = arr.map((elem) =&gt; return elem.name }); // short lambda arr = arr.map(elem =&gt; elem.name); &gt; best we can do for now It is not perfect but still beats all other contenders easily on overall points, without major flaws.
If you are developing a rich / responsive web app you should use some form of MvvM framework. Knockout or something else. The important part is seperating html and your client side viewmodel. Treat your clientside the same as your server side. If you just need a Crud app thats not public facing, use base mvc and html helpers. There's alot of resources available.. A quick google gives this: http://channel9.msdn.com/Events/TechEd/NorthAmerica/2013/DEV-B338#fbid=
I have to say that I'd really prefer that definitely typed had a separate repo for each definition. We started out using the dt-bower definitions, but they are not comprehensive enough, so we decided to use DefinitelyTyped rather than port every library ourselves. For the definitions that I created myself, I would match the MAJOR and MINOR versions with the library semver, and increment the PATCH version for bug fixes. This fits in with the semver model which uses MAJOR for api incompatible changes, MINOR for adding functionality, and PATCH for bug fixes. Since the definition file is really just an api definition, a PATCH increment on the library shouldn't effect the dt file at all, but the MAJOR and MINOR changes should. Why do you think that the dt-bower model has not worked?
Hmm, here's an idea to improve the type definitions: compile the library tests for the JavaScript library with the type definitions. This would expose at least some errors. For example, lets say that the type definition says that ".getElements()" returns an object with the type JQuery, but in reality it returns a Promise&lt;JQuery&gt;. Most of the tests in DefinitelyTyped are basically simple "hello world" type tests that don't really test much. However, the library tests are often complex, and would probably have a test like ".getElements().then()", and the error could be caught with it. And you wouldn't need to rewrite all the tests again to DefinitelyTyped and maintain them.
How about creating a single npm package for each definition? E.g. "jquery-ts". It would fix the version issue, and be compatible with the existing package system a lot of JavaScript libraries seem to use these days. Sure, maintaining 400 repositories seems excessive now, but they can be maintained by the individuals who created the definition files in the first place (or delegated to other people over time). Creating a new package manager for TypeScript definitions seems like reinventing the wheel.
There are single Nuget packages for each set of definitions that seem to be generated systematically.
Thanks for pointing out the type checking on ==. I wasn't aware of that. I have added an update to the post about it.
DT tests only the definition file itself. While it doesn't verify if it is correct with the library code this still catches a lot of mistakes. It can be very detailed if you spend the time on it (I have a pattern now), and it stops regressions. But people are lazy :) Somebody is doing a real analysis tool that verifies against real module code: https://github.com/asgerf/tscheck This guy means business too, it is a very techy approach. He sent in first proof of concept fix to DT just this week.
It is a complicated thing, I had a chunk of it in the OP. dt-bower was an export of some of the DT defintions, but only a few. Even then they never updated them. It is just not practical to maintain for hundreds (or thousands) of repositories. If you look at current DT you see that there are a flock of very much used definitions, and a huge long-tail of loose stuff that are still very valuable to some users. If you break it all up, then who is going to maintain all those repositories? It is easy to keep an eye on a few hundred file in one repos, but 400? or 1000? How do you keep any form of quality control? Where do you handle tickets? It will be chaos unless you spend time and complexity on an automation. Chaos of scale will also happen in a single repo, but at least that would be a low-tech form of chaos. Then there is the thing that bower is just bower, it cannot do anything specific for TypeScript. Afaik NuGet is a lot more intelligent about code. TSD is a domain-specific package manager and can do some interesting things specifically for TypeScript. NPM can do as much as bower. This semver scheme you mention is it or the versioning of the definition file? Or does it describe with the libraries semver? How do you keep it sync? What happens if you miss a few major versions? How are you going to backport fixes for mistakes in the type description? Do you think most all the def authors have time for that? They all are busy with own projects. There are a load of other aspects but I'm already putting down a huge slab of text (I have that habit). You'll find lots more it if you search the DT repo's issues for 'bower'.
This has been going for a while and it is getting pretty good. If you are serious about code quality then you want this running in your project. The validation rules are extendible so you can contribute rules (or load your own at runtime). There are also grunt and gulp tasks and some custom reporters on npm. Note: first run might hurt your feelings.. 
Its dangerous to release or announce things on April 1^(st) :-).
I'd just like to say (having used TypeScript for months now) a huge thank you to you guys. I've submitted a few updates here or there for files, but it is a massive undertaking and with some libraries changing often its got to be a nightmare to keep everything working :). I know versioning is a pita. It would be nice if more JS authors would add their own TS files. I know BreezeJS and LinqJs both provide them which is wonderful since it means you can update the source and not have to spend an hour fixing the defination files. So, big thanks to everyone who updates those defs! :)
Thanks for your contributions! Large or small, every bit helps. The org members just manage the PR's and try to keep some basic sanity going. We don't actively hunt for updates or sit down to update stuff we don't use ourselves (who has time?) The updating you mention is a bit of a trade; if you use a lot of free code then many feel a need to contribute too (open source is amazing like that). And if you do spend an hour updating some defs, you're already benefiting from many hours of work from other people. Plus, you got to learn that API anyway, so it is not a full loss. It is like a small investment? If you want the typing goodies then you need to pay some definition time? Then we just do the human thing and pool resources. 
Thanks for your response. The semver scheme I was talking about would be for updating the tags. If you need to backport a fix for a particular major/minor version you could do something like: 1. Create new branch off latest tag for that minor version. 2. Fix issue. 3. Tag with incremented patch version. It's not an easy process, I admit, but no easier or more difficul than backfixing bugs in the parent library object. Additionally, nothing like that even exists for it with the current DefinitelyTyped model. What's the plan for maintaining separate definitions for angular 1.2.x and 1.3.x? Or even 2.x.y which will have a very differenent api than 1.x. Currently, if you want the latest angular definition file, you have to use the latest angular-ui, jquery, ...etc definition files as well. I see the problem you mentioned with the problem of missing/outdated definitions in dt-bower repos. But, this could be solved if instead of the dt-bower repos copying code from Definitely Typed, DefinitelyTyped included the dt repos as submodules. If no one cares to maintain a separate repo for a particular definition, then sure keep those definitions in DefinitelyTyped. However, for a defintion like dt-angular, which would be far more utilitized, then it would be nicest to have that code in a separately maintained repo so that I can pick 1.2.x or 1.3.x as I choose. 100s of repos, sure but there are already 100s of library repos.
Cool, thanks for the challenge (I don't mind playing ball on this as it helps thinking :) The other thing about dt-bower: it creates a lot of hassle and complications. But there is not much traction so far, and it cannot do anything for TypeScript itself. Nor for npm modules, component/io, WinJS code etc etc. For versioning: DefinitelyTyped already supports semvers: https://github.com/borisyankov/DefinitelyTyped/wiki/How-to-contribute#version For example these have it: https://github.com/borisyankov/DefinitelyTyped/tree/master/node Ideally the latest one should have a version too, I guess this is a legacy thing (imperfect but could be easily solved if it becomes a problem). But again, usually nobody seems to care much. Angular probably will get a semver if they do a 2.x.y, like node. But other libs? &gt; What's the plan for maintaining separate definitions for .. Keep in mind DT org members don't do the maintaining: the users do that (this overlaps of course but is not same thing). We can create a semver postifxed copy when a major version bumps (or accepts a PR) but we don't chase releases or anything (who has time?) So the plan is: unless someone steps up to actually maintain different versions nothing happens. This person would have to watch all the versions, and for every fix done (because defs are never ever perfect) see if it needs to be fore-and-backported to all versions (`1.8.10`.. all the way to like `0.9.3`)... I'd vote to support it but I'll believe it when I see it happen. Also if the problem of older versions is not that big. So what you have `1.4.17` and the def is `1.3.5`? You might miss a few methods, not a big deal (compared to having nothing at all). You fix them and proceed (you still have unit/acceptance test I assume). Also, if you already got an old project you just keep your old definitions, and otherwise why start a project with a legacy library? Maybe you should [watch] the repo for a while and see how it goes and what kind of stuff people send in. It is all amazing and welcome but hard to make it as tight as you might hope or assume (herding cats? :) 
I am watching the repo. I think you guys have really done a great thing for the community. There is nothing else out there, without this project, we wouldn't have anything. A big thank you. The fact that it doesn't play nice with bower is really just a nitpick and nothing against the great work you guys have done. Keep it up.
The work project that I'm working on presently (a portfolio management tool used by a venture capital company) started life as a simple ASP.Net MVC project. As requirements became more complex it evolved into effectively a combination of classic ASP.Net MVC and mini-SPA's powered by Knockout / JavaScript. As the mini-SPA's became more and more complex we started experimenting with using TypeScript. (It allowed us to avoid a whole class of type errors and eased refactoring.) This proved useful and the minute generics were added we made the jump - all our mini-SPAs were migrated over to TypeScript. As time goes by more and more of the vanilla JavaScript is migrated over to TS. It just makes life easier. The next project I work on I intend to use TS from the start. 
Cool, and thanks for the back pressure (we never get anywhere without challenges :) DT is MIT licensed though so you can do whatever you want with it. I'd only say to be careful and not schism the community typing effort. For this thing with bower etc I have some stuff in TSD planned but it needs a few other things first before I'm happy to make it a real feature. The idea is to parse bower.json, package.json (etc) and use it to find definitions for all known names. Only problem is at this point the DT repos does not 'know' which files are valid npm/bower modules, nor does it block duplicate names. Once we figure out how to annotate this we can do this kind of thing. And I'm still paying back a huge technical debt on TSD: it started as a TypeScript 0.8.x project with a single output file (internal modules). This was the wrong choice... but I stuck with it to get it Live. Also I used too much home rolled code. I'm now moving it to external modules, pull more code from npm etc, quite an epic re-factoring (a paying boss or client would never allow it :)
Sure, it can be done, sort of. But how do we version these? The semvers, what do they mean? npm does [not allow to republish previous versions](https://github.com/npm/npmjs.org/issues/148) (so back-porting fixes is not possible) And what about the other package managers? The 400 repos thing is not practical (I think). Authors are not that committed to maintaining a definitions. I had some more info on this [in this comment](http://www.reddit.com/r/typescript/comments/21sine/about_typescript_and_definitelytyped_of_which_i/cghznmb) further down the thread.
Yeah, I've been using this for a while and it's great. Incidentally, I wrote that small gulp plugin :).
The 1.0 also comes with everything being publically available (spec, compiler source), and they are accepting pull requests on Git.
Both this and the [TypeScript](http://channel9.msdn.com/Events/Build/2014/3-576) talk by Anders Hejlsberg are very good. Pretty much drove me toward using TypeScript rather than Dartlang.
Super useful and handy reference. Part of me wishes this came in like a pocket book or something.
If you haven't already looked, there is a todomvc project example using typescript/angular. http://todomvc.com/labs/architecture-examples/typescript-angular/#/ 
Yes I've seen it but thanks
There are some examples in side waffle which is an extension for visual studio. Its open source on git hub so you can view the files. I use the controller as syntax
note: this is not mine, I found it on Twitter
Nice!
Thanks for posting! Added this to my project and helped clean up a bit. Are there any grunt tasks (or similar) to aid in formatting TS files in accordance to lint preferences? 
Sorry for my late reply, this is not my daily account :) There is https://github.com/vvakame/typescript-formatter, it supposedly can read different configs like tslint.json, .editorconfig etc. (it is by a Japanese TypeScript pal who also collabs on DefinitelyTyped org) AFAIK it doesn't have a grunt task yet, could be your time to shine :) 
Great article!
Full disclosure, I work for the company (Platypi) that is hosting the repo. Let me know if you have any suggestions!
You should make a section about TSLint. Somewhere at the top end, so more people use it.
Awesome feedback! We do not use `--noImplicitAny`, although it might be a good practice to start following. The variable definitions are a carry-over from JavaScript, it's just the way we've always done them. That being said I do see your point about clutter/confusion when you throw in type definitions to a single var statement. Good point on the return-types. We actually do this for the most part, I just didn't remember it when I was creating the guide. I'll add that in!
&gt; Is it just that no one out there is doing node work using typescript? Hah! Windows Azure is doing well on node.js + TypeScript :) You are missing something, the SO article is good info. Use require like you'd do in vanilla JavaScript, with the npm module name: import qOrm = require('q-orm'); But this only works if there is a type declaration with the string-name 'q-orm', otherwise the compiler will throw that error. If want to use it untyped change the `import` into `var`. var qOrm = require('q-orm'); If you want to create a definition that supports `import` get one on DefinitelyTyped or roll your own: declare module 'q-orm' { var foo: number; function bar(): string; // ... } Simple example: https://github.com/borisyankov/DefinitelyTyped/tree/master/lru-cache In this case the `.d.ts` is the declaration, and the `.ts` is a simple test that also shows usage. (notice the `&lt;reference&gt;` tag in the test). The declaration can also be in your code file. Small project for a node/npm module that uses this kind of stuff: https://github.com/DefinitelyTyped/definition-header
I still dont get it. Having a definition is great, but that code will never import the *actual module* which lives at a specific path (../node_modules/...)
Oh, that is just a node thing. It will find it with the identifier: `node_modules` is a magic folder and node will look into it to find modules. There is quite a clever scheme going in how that works with dependencies. See the manual: http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders But you are wrestling with two things at once: node itself, and learning TypeScript-with-node. Maybe it is best if you use some plain JavaScript to figure out how to node, and install some stuff from npm, hack some code and get used to how node does things. Then rename your code to .ts and add types. 
Great writeup. I have used Typescript in Webstorm everyday for over a year. While it is far from perfect, it is still better than using plain JS for a large project. &gt; Bottom line, if you are using TypeScript, don’t use WebStorm. Eclipse remains the only usable multi-platform TypeScript IDE. When did the eclipse plugin happen? Is it any good? I have used Typescript in Webstorm for over a year, therefor "usable" is hyperbole but after getting hosed by the refactor methods, I was more discriminating in the features I used. 
I really gave it a shot, but it just doesn't seem to be that simple. Have a look here; if you've got any suggestions, I'm all ears~ http://stackoverflow.com/questions/23739044/how-do-you-write-a-node-module-using-typescript
BOOM! https://github.com/DefinitelyTyped/demo-typescript-node-minimal Let me know if this helps, then I'll post it to your stackoverflow question too. Cheers :)
Hm, the two things I'm really interested in don't seem to really get explored though; all it does is show off the most simple case unfortunately. First of all, if you add --declaration to the end, the index.d.ts you get is: doug$ cat node_modules/demo/index.d.ts /// &lt;reference path="typings/xregexp/xregexp.d.ts" /&gt; See how it doesn't reference lib/greeter.d.ts; sure, that greeter.d.ts file is generated, but you can't import it, because if you try: import demo = require('demo/lib/greeter'); You'll get an error for the module name not matching the declaration name. So, in this case, how do you use the greeter class? You also don't export greeter in index.js, so when you try to import it as a node module, you get: &gt; var x = require("demo"); [ 'abc', index: 0, input: 'abcdefgh' ] Hello Dave undefined &gt; x {} &lt;--- No symbols were exported. The problem seems to be that if you import a module (import greeter = require('./lib/greeter');) you can't export that module as a submodule, I feel like I need to do this: export module demo { export import greeter = require('./lib/greeter'); }; ...but the compiler wont let me. /index.ts(20,3): error TS2136: Import declarations in an internal module cannot reference an external module. It seems to come down to writing the module.d.ts files by hand to me...
You can do `export import demo = require('demo/lib/greeter');` although you don't have to export *everything*. That's the whole point of modules. Why are you messing with exporting the declaration files for your own code? I almost never use those. What do you try to achieve? 
http://stackoverflow.com/questions/5364928/node-js-require-all-files-in-a-folder I thought that was a very common node pattern; I'm definitely seeing it in lots of code from npm. 
I use index files but never loops to assign exports. It makes it more difficult to see what is going on (adds a level of indirection when reading the code because now you have to refer back from code to the directory). Just copy-paste-edit and make a chunky export block. But like I said earlier, you probably don't want to discover both node/npm AND TypeScript at same time. It will become very confusing (/thread). npm is a change of direction of 'classic' browser/global Javascript, and TypeScript has some odd cases on it's own and now you are wrestling with all of it. Also, in general, you want to keep things as simple as possible. If you need loops to require stuff you are either making a mess of have some advanced use-case. 
seems like fair advice~ Thanks for all your help! :)
Interesting that they're building a runtime type checking system, essentially an assert. As it happens, I built something like that (I call it [typed-javascript](https://github.com/panuhorsmalahti/typed-javascript)). It was just an experiment on my part, though.
Nice! I've been meaning to play around with Phaser.
I had the brilliant idea of starting a chess engine in typescript using node purely as a cli. Being kind of a javascript noob (I feel I have a good grasp on the language itself just not the huge amount of libraries and such surrounding it) the experience has been dreadful. Documentation is very sparse and I find myself pulling my hairs with every bug. Getting the modules to work was the biggest one so far. It turns out that it couldn't find the file as require('file') nor as require('.\file') even though I'm on windows. After trying everything and struggling to understand internal vs external modules, AMD, etc.. all I had to do was use the "right" backslash...
Yep. If there's one thing about typescript I vigorously dislike, its that: let x = require('x'); Is an invalid statement if there is no header definition file for x: /// &lt;reference path="../deps/x/x.d.ts" /&gt; You get: error TS2071: Unable to resolve external module ''x''. There's no way around it. This is simply broken, and poorly considered by the typescript developers. What it *should* do, is import x as type 'any' if there is no declaration for x. Instead you're forced to write endless stupid declaration files, often even for *your own typescript submodules* because the default generate .d.ts files are not valid. It's pretty rubbish. The best I can offer is 1) consolation; you're not the only one fighting with this, and 2) you can use this boiler plate for most things: 1) Add 'x' to your package json as normal (eg. toml, glob, etc). "dependencies" : { "x": "^2.0.6" ... } 2) Add a defs/x.d.ts that reads: declare var X:any; declare module "x" { export = X; } 3) Import x in your code including the def file: /// &lt;reference path="../../../../defs/x.d.ts"/&gt; import x = require('x'); x.whatever_here(); It's worth noting that despite the complete lack of documentation around it, these declaration files are actually pretty easy to work with. The syntax: declare module "foo" { } Is for declaring an 'ambient' module; ie. something you can go require('foo') with, instead of require('../../foo'); The export = bar means export this as the name itself, rather than foo.foo. So for example if you want to add your own type hinting you can write: declare module X { export function parse(value:string):any; } declare module "x" { export = X; } ...and then you'll get type hinting when you attempt to use x; var x = require('x'); x.parse(1, 2); // &lt;-- Compile error, no match for decl Pretty obscure, and virtually undocumented. Such a pain to work with...yet despite it all, I still find myself using TS because it is actually pretty good, once you get over the initial hurdles. 
Not sure what excites me more, the 5x speed upgrade or to finally got rid of that crappy codeplex.
Assuming you are just using Chrome 36 or later, rather than a polyfill? From: http://wiki.ecmascript.org/doku.php?id=harmony:observe_api_usage it looks like it won't be type safe at all, because as you say a string is being passed representing the change on the object. As TypeScript is only a compile time, type safety system, there is no way of it knowing that the "radius" on "circle" is a number, because it could have been set to anything at all, by for example non TS code. But if you only have one handler per type, you can easily make your handler cast to the known TS class, you could use generics to do this. However you still will not know the type of the oldValue. I think a better question is what kind of help do you think TS should be able to give you in your handler? After all, you can happily Type your handler!
&gt; As TypeScript is only a compile time, type safety system, there is no way of it knowing that the "radius" on "circle" is a number, because it could have been set to anything at all, by for example non TS code. I find this with Knockout atm. A observable cast to numbers will often be turned into a string when the value is updated by the user. &gt; I think a better question is what kind of help do you think TS should be able to give you in your handler? Object.observe seems (from my brief reading, haven't used it yet) to be tailored to normal javascript. It returns a collection of changes. I don't see how this could be type safe. Really I would just love the whole system to work the same way as knockout so I could observe a property with type safety. I expect I will have to write a small library (or someone else will) to do that.
On the KnockOut think, it depends on how the binding works, as it could push anything into the observable. However, you can use the 'extend' method, we do this on our software (I'm CTO of a SaaS firm) because in our domain model, we want to use c# decimal class, but in Javascript land, this is of course a string, so we've got a BigMoney class that acts as a decimal. Thanks to extend we coeorce it to always be a big money, even thou it's just using the 'value' binding on say a input textbox. Extend allows you to coerce the value to the kind you are expecting, effectively providing a 'layer' of runtime type safety. This whole Object.observe thing is a bit different, as you say it's a kind of event notification of change, to be honest, as we have to support way more than Chrome, I've not used it yet. But from what I gather it lacks the ability to coerce in the same way you can with knockout, it doesn't have the separation of a 'subscription' and an 'extension', that being the extensions are called with higher priority.
Yes, it's very helpful for that. ko.exetnders["example"] = &lt;T&gt;(inner: KnockoutObservable&lt;T&gt;, options: any) =&gt; { } Is about as typed as you can make the extension, you might want to make the options typed, but sadly users will have no way of knowing about it. Actually, now I think about it, you could make your own interface extensions for the whole useage side of things. But given that many interfaces expose the .extend({}) stuff, I doubt you could nicely wrap it, but I'd be interested to know if you are able to come up with anything nice.
TypeScript is one of those things where I don't know how we ever managed without it. Yes, we wrote pure JS for years before it, but our codebase depends on it now. I can almost guarantee it will still be around in 5 years.
Who exactly is 'we' here? Is this Microsoft calling in? 
I'm referring to my team. I happen to work at Microsoft, but I am not speaking on behalf of Microsoft. These are my own opinions.
Well, that is interesting. What is the uptake of TypeScript like at MS? I know that Visual Studio Online moved to TypeScript ( https://www.youtube.com/watch?v=3Jrg8hfNXmU ) and it is not exactly a small project. 
I work on Visual Studio Online, actually :) I don't really know how much it is used by other orgs.
I am really wondering why typescript isn’t the new buzz out there.. It should. Plus nowadays there exist a JS compiler, so TS could also be used inline with HTML code. https://github.com/niutech/typescript-compile
I can think of a couple of factors as to why TypeScript isn't making as much buzz as we might expect: * It is still early days for TS. It just came out. * The majority of front-end developers need much JS. Even most web-apps are just CRUD interfaces on top of a database. People are not writing much JS. They are busy shuffling things around inside some template language. * I suspect that quite a lot of front-end developers don't have a background in Java or C#, and hence don't understand how typing can be useful. TypeScript makes sense when you have larger code bases and you are doing complex things like Google Docs, Visual Studio Online, Prezi (=has a HTML5 version now), big things which we would expect to be desktop applications. There are not as many of these projects/products compared to all the little custom CRUD webapps out there. 
&gt; I suspect that quite a lot of front-end developers don't have a background in Java or C#, and hence don't understand how typing can be useful. I think this is the main point. I am a part-time teacher, and I am willing to promote TS as much as I can. There are a lot of good ideas in this language, it is a pity IMHO
I like it for everything, big and small. It is not just about type checking but also the cleaner code from the ES6 sugar, and that is good in any size codebase. But there is some overhead on using it, to set it up in some build flow. And you need either a IDE or mess with plugins. Then getting it to work with definitions for your libs, and there aren't any defs if you use non-mainstream libs (like random jquery plugins). Anyway, if people do a lot of JavaScript then it is very likely they would enjoy the benefits of TypeScript. I'm pretty sure because it is so similar to how ActionScript evolved when it added type-sugar to AS1. It was a great success, lots of small creative stuff got done with it (and big apps too).
Can you share the repo if you have one with the TS. 
[**@ahejlsberg**](https://twitter.com/ahejlsberg): &gt;[2014-10-04 18:01:25 UTC](https://twitter.com/ahejlsberg/status/518460898982113280) &gt;Initial implementation of Union Types in TypeScript. [*github.com*](https://github.com/Microsoft/TypeScript/pull/824) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2ib7s1%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
This is really good for the typescript definitions of libraries. Some time ago I wrote a definition for a library, and it had lots of places where it could receive or return variables of more than 1 type. In those situations had no chance but to say its type any.. The syntax looks nice as well.
Encouraging. What I do miss is a some kind of optional interface feature to help with mixins ( https://github.com/Microsoft/TypeScript/issues/371 ) and some way of saying "never null". Also, does anyone have an idea when 1.1 will be out? 
Today, apparently! (^_^)
Is there anything special I need to do to install 1.1 in VS2013? I edited the project as they said but I get an error on build saying it can't find the 1.1 TSC.exe
Refactoring typescript in webstorm works great some times and completely destroys your project other times. I am terrified to use it any more.
Are you giving them feedback? What are the problems that you're having?
I don't find much value in refactoring tools so when I used them and they wrecked my project, wasting an hour of my time, I never went back. It was a long time ago but I think I tried to rename a method with a common name like "load" and the refactoring tools matched code in my node_modules folder and renamed completely unrelated code. The following link lists some of the failings. Even with it's flaws I find using Typescript in Webstorm to be very productive. http://www.reddit.com/r/typescript/comments/25mxlj/webstorm_8_typescript_support_review/ 
Have you ever looked into sharp kit. With sharp kit you can write code in c# and it compiles to JavaScript. I used it for months and felt it was well designed but I still prefer typescript because you can write plain js more easily. 
how do I update to this release with npm ?
VCL.JS-Free typescript RAD for business web apps Vcl.js takes the Delphi/VB approach into the HTML5 world,providing a full stack for a true web RAD development.Build Node.js&amp;.net web app in no-time. for more information http://vcljs.com
Very good talk. Funny how they try to stay syntax compatible with TypeScript. Please note everybody is now reinventing ES4/ActionScript 2 again, which is more then a decade old! (wtf happened?!). 
Yeah I'm working on a large, extremely modular SPA and I don't see how it could be possible without typescript. I need all of those definitions and checks or I'd be spending all day debugging instead of coding.
As far as I can tell, those mean different things. `function(input: ?string)` allows `null` as the `input` argument, which TypeScript always permits, but Flow rejects by default. I'll also note that he did say "mostly" compatible. Non-nullable types are a good call IMO, and worth breaking compatibility. We'll know more when FB actually releases Flow.
Yeah ironically this is closer to C# than Microsoft's own typescript. I think optional parameters at required for old code though.
Tried it in IDEA (13.1?), had to manually set up the file watcher and arguments passed to the compiler, compile time was rather lengthy, and manually putting in references at the top of every file was... "Fun". I do have a small feature wishlist for VS's extension, but it's mostly just quality-of-life things like referencing the output of other Typescript projects in the solution.
Every feature that I care about works great in Webstorm. They had problems with refactoring support. I have not re-tested their support in the newest version. I have not tested VS support for Typescript so I cannot give you a comparison but I find Typescript very useful and intuitive in Webstorm.
I've only used it standalone (running tsc with node.js), not with VS. My first TypeScript experience was on Linux. I needed to port a game from Objective C to Javascript, and TypeScript's classes and type checking made it a lot easier. I usually just have a batch file or shell script that runs: tsc -w --noImplicitAny --out outfile.js infile1.ts infile2.ts ... The -w tells it to monitor for changes, and -noImplicitAny just makes it stricter about unspecified types. I don't usually bother with reference tags, and just specify all the .ts files on the command line. I've also used [grunt-typescript](https://www.npmjs.org/package/grunt-typescript) for more complicated builds, but it's not as fast.
[eclipse-typescript](https://github.com/palantir/eclipse-typescript) is pretty good. Occasionally a version has frustrating issues (some of which may be due to changes in the TypeScript language service, which seems to still be evolving), but for the most part I've been very happy with it! Eclipse itself, of course, is sort of love-it-or-hate-it. For those who hate Eclipse, eclilpse-typescript is obviously not going to be appealing.
I use WebStorm with `grunt-ts` and `tsd`, it works pretty good and the Gruntfile based build makes sure it compiles anywhere. Also everything gets better if you use `import/require` instead of internal modules (aka `&lt;reference&gt;` hell).
It works quite well in a Unix-y workflow. At home I use Vim: * Syntastic plugin gives error highlighting * Ctags gives a reasonable jump-to-def * There is a better-maintained syntax highlighting plugin out there than the one MS originally provided For package management there's npm or bower. The excellent tsd for definitions. I've tried grunt and make for building - both were good but at the end of the day think make is the more flexible tool. For debugging I think Firefox dev tools plus getting tsc to generate source maps is pretty good. If you're already comfortable in a Unix environment then it's a totally viable way to do TS. Probably not as good as Visual Studio, but the nice thing is the above setup is not very specific to TS - it would work equally well for Python, Haskell, etc.
There's also [Typscript-Tools](https://github.com/clausreinke/typescript-tools) which I use for autocomplete and error checking
Finally got round to trying it - it's awesome. Thanks for the recommendation!
I dont know about finally.. its only been out as a full RTM for a little less than a year. Agreed though, this is a great feature to be added to the language. I can only expect more traction around TS with the recommendation around Angular 2.0 and the fact that TS will be a subset of AtScript. 
What is your stance on interfaces. In C# (and other static-typed languages) I've always had my interfaces in separate files, and I like using that method in TypeScript as well. It offers a few benefits: 1. You don't mix logic and declarations in the same file, making things cleaner. 2. You can follow the methodology of exporting 1 object from each file. I've been toying around with using declaration files and modules to namespace my interfaces. It does require you to use `&lt;reference&gt;`, but essentially you maintain 1 references.d.ts that has references to all your interface.d.ts files. Then the interfaces are always available without having to put require everywhere you need them. I am already using tsd, so I already would have to have a `&lt;reference&gt;` for tsd in every file anyway, so this doesn't really affect any workflows (other than that every file has a `&lt;reference&gt;` to the references.d.ts instead of tsd.d.ts). I'm not sure if this is the best approach, I have found that it makes things a little bit neater because it keeps all the interface declarations out of your logic files.
I work with a team that uses git with VS, Webstorm, Sublime, Eclipse, and Vim. We don't enforce using any IDE, so people end up picking the IDE/Text Editor that fits their own style. That being said, not every IDE/Text editor plays well together. We have a standard `.gitignore` that ignores all the IDE-specific files (e.g. .csproj files in VS), allowing minimal clutter when you clone a repo. As for development, having used all the different IDEs/text editors mentioned above I would definitely put VS at the top. That being said, I would never recommend relying on VS's implicit referencing, because it will lock you into a VS-only environment. Even though I use VS as my main editor, I still use explicit `&lt;reference&gt;` tags so that people using other editors can work alongside. If you have a good CLI build process in place (e.g. grunt/gulp) everyone can always fallback to using it if they need to.
Union types!! What I've been waiting for since v0.9!
This is awesome. I see several improvements here that bring some Flow features to TypeScript, making it more compelling than ever.
I think rather than making your interface generic, you want to make the function generic. For example: interface foo { &lt;T&gt;(param: T): boolean; } var myFooFn: foo = &lt;T extends Object&gt;(x: T) =&gt; { return Object.isFrozen(x); } var result: boolean = myFooFn&lt;Date&gt;(new Date());
Interesting... I've used Guava (Java) previously, and their function interface is similar to: interface Function&lt;I, O&gt; { public O apply(I input); } But in your case, you have suggested instead to do something like: interface Function { public &lt;I, O&gt; O apply(I input); } I guess the latter is fine, but it seems like both should be applicable. Will give that a shot, thanks!
Keep in mind TypeScript interfaces are quite a bit different than Java interfaces. They're only used at compile time for type checking. Furthermore, TS uses structural type checking rather than nominal checking, which means ANY JS object with the same property names and types is type-compatible with the interface, regardless of its specified type. I don't remember exactly how Java is, but in TS it doesn't make sense to have access modifiers on your interface members. You might want to consider making your interfaces classes. TS allows you to extend as well as implement other classes.
&gt; which means ANY JS object with the same property names and types is type-compatible with the interface, regardless of its specified type. Weird, but I guess I can see where that is useful. Duly noted on the access modifiers. In Java interfaces, it is typically useful when specifying public vs. protected. Private would be pointless.
I've just started working on my first Node app, after using Typescript for client-side programming for quite a while. I've personally found the process quite smooth. I've been working with Express, Socket.IO and MongoDB on the server-side, and Backbone on client-side. Although, some tutorials are a little outdated, I have found these to be a good starting point: * [Typescript Image Board example](https://github.com/Microsoft/TypeScriptSamples/tree/master/imageboard) * [Getting Started With Node.js, Express, MongoDB](http://cwbuecheler.com/web/tutorials/2013/node-express-mongo) In response to your points: 1. I haven't notice any issues with the definition files. I assume you're getting them from [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped). 2. I've been compiling to AMD, and I'm using the RequireJS NPM. Check out [RequireJS in Node](http://requirejs.org/docs/node.html). This approach has allowed me to share server and client side libraries. 3. Via require, my entry point is a simple script, and I have some static methods to wrap my route initialisation. But my controllers are classes, e.g. I have a controller class that manages the Socket.IO instance, and anything else can use OO patterns. I hope that helps to get you started.
I've been using TypeScript with node for a little prototype which uses Express, and it works quite well. I just compile to commonjs for the node stuff. For client stuff I use AMD. I use very little of the Express API and I can't comment on how up to date the definition files are. I did have trouble figuring out how best to use the Express API/definition file. I had trouble referring to Express types. But I've got that sorted out now. I've also hacked up the occasional .d.ts file to cover the parts of JS libraries that I want. I don't feel pushed by Node to code in any particular style, OOP or otherwise. You can certainly code in a non OOP style and just use interfaces to define your types and no classes. The biggest problem that I've encountered is finding or inventing a decent build system. I don't like systems which put plugins in between me and the command line tools I want to run. Nor do I like systems where I can't define my own goals and dependencies and what happens during each step. Right now I mostly use Make, but may move on to using more ShellJS (http://shelljs.org/) in the future although it is a little weak when it come to running external commands. 
Thanks for replying. In Visual Studio, when I view a TS file, I can get a split screen that shows me the compiled JS output for that TS file. When I change code in my TS file, that JS file is NOT always updated. This is frustrating, because now I have to stop my debugger in VS in order to compile the TS into JS. That breaks my productivity, because I should be able to save my TS, which should update my JS, then I only need to refresh my browser to get my latest code changes. This is not happening consistently enough. When this happens, I have to stop debugging, I have to resave my csproj settings to enable compile on save, etc. It invades productivity. I cannot tell what I am doing wrong with this tool that others are not experiencing. Thanks for any help.
I recently found that Web Essentials was killing TypeScript and had to disable it to get the compile on save working again. I re-enabled it a couple of days ago and it seems okay now - you might want to try this?
Have you tried enabling Browser Link? I know with certain elements, and that enabled, you can get immediate results with out refreshes. I'm not sure about TypeScript compiles though.
When in debug mode (which is great for breakpoints in rest calls or any other part vs can step in), with changes to Javascript or CSS files, a save is good enough no need to rebuild. This lets us run a webapp in debug, make css/JS changes and refresh the browser without having to stop or pause the debugging. 
I know. In saying if you run without debugging you can also update server stuff much faster (just rebuild vs having to stop -&gt; build -&gt; start debugging).
Nevermind I was able to figure out my problem after reading through most of the modules page. I had confused Internal vs External modules.
From my experience I'd recommend to stick with external module pattern, it gives the most control over visibility/scope of your code, and it macthes well with modern idea of modules. Only reason to use &lt;reference&gt; are .d.ts files and *maybe* your own interfaces. Also you'd (almost) never type AMD or commonJS specific define or var/require, only the import/require version, then have the compiler create either commonJS or AMD. I'd go for commonJS output, and bundle that for web using browserify or webpack (use grunt or something to rig the whole thing up).
Interesting that you suggest browserify or webpack to bundle CommonJS instead of using AMD. Is there any gain to doing it that way? I almost wonder how long AMD will even be around once ES6 is out. Regardless, I'm encountering issues where I have one bower dependency that is an external typescript module. It seems that the `.d.ts` files can't be referenced when they have the syntax: export declare class A {... When I remove `export` from the definition file, it seems to work. On top of that, I'm not totally sure how you `require` from a bower dependency. Is that more of a shim thing?
This solved itself: Github did an infrastructure upgrade that broke the HTTP E-Tags. They spotted it themselves and it was fixed (everything back to normal). edit: also props to Github support for being quick and polite (as always)
I've found that mixing classes and interfaces in the same file causes unexpected compile errors. Which is a bummer, because I have a lot of methods which accept options objects, and I'd love to define interfaces for them without creating a ton of files
Sorry about that... http://bengale.io/typescript/grunt/javascript/tools/2015/01/20/Using-TSD.html
I've found that the best way is to look at some of the examples of definition files in [DefinitelyTyped](http://definitelytyped.org/) and at the documentation for the library in question. Usually you get enough to start writing definitions. The thing to remember is that you're just declaring interfaces (and sometimes `declare var`s), not writing the implementations for those interfaces. 
in `fn:(element:A,index:string|number)=&gt;B` "index" is a union type but you intend to somehow derive it from generic type `A` so that it is one or another depending on whether `A` is an array or an object. I don't know if that's possible.
https://github.com/clausreinke/typescript-tools He's still working on compatibility with the latest TypeScript version, but this plugin is really useful because you can check the inferred types.
This looks really cool, but I'd be very reluctant to build an application that renders to canvas. For something like a game, sure, but not your typical application.
Sorry to bother you again, I was wondering if you know of any github project that has typescript plugins? I was searching but could not find anything useful.
I strongly dislike your use of underscores. We should be writing readable code even for esoteric things like parsers. You use an underscore to represent a whitespace parser and as an unused variable in your lambdas. It's unnecessarily difficult to read. I don't quite understand why you declared your whitespace token as `Parser.m(x =&gt; /\s/.test(x)).zero_or_more();`. What's wrong with `Parse.m(x =&gt; /\s*/.test(x))`? Given the implementation of `ManyParser` is this a way to ensure the accumulator and index pointer are updated correctly? I assume the lambda is only passed one character at a time as well? How would I match a token like `==`? Correct me if I'm wrong, but `zero_or_more()` seems to return a new instance of `ManyParser` for each character that is checked against the whitespace parser. This seems like it would be problematic to parse large documents. `then()` may be better served with a different name. Given that this is JavaScript land, my first thought was that this was a promise resolver, and I wondered what the purpose of async code for text parsing was. Why not `andThen()` or even just `and()`? `next()`? Anyway, seems like a fun project.
TypeScript allows for many of the best features of functional and dynamic programming along with OO and static programming. Classical.js is a TypeScript library which optimizes for all paradigms. Help us make it better: https://www.nuget.org/packages/Classical/
The reason I define whitespace matcher as the way I do instead of the way you suggest because I'm assuming the input stream consists of single characters. If you preprocess the input so that instead of single characters you now have something like `['a', 'b', ' ', ...]` then your definition would work but if you don't preprocess then you have `['a', 'b', ' ', ' ', ...]` which will fail with your definition since it will match once and not consume the other whitespace characters. I delegate to existing definitions for `zero_or_more()` and that does mean creating new instances every time we parse but I haven't had any performance issues. It is easy enough to fix the problem in the constructor by just creating the parser once instead of every time during a parse like you noticed. Feel free to make a PR (pull request). You make a good point about the names. I was just lazy and chose whatever I thought would be obvious to me. `and` doesn't quite work because sequencing is not commutative, that is `a.and(b)` is not the same as `b.and(a)` which is implied by the colloquial definition of `and`. `next` and `andThen` seem ok but I leave that to whoever wants to use the library. It's only 250 lines and refactoring `then` to `andThen` is easy enough.
TypeScript allows for many of the best features of functional and dynamic programming along with OO and static programming. Classical.js is a TypeScript library which optimizes for all paradigms. Help us make it better: https://github.com/drubino/Classical
Cool, thanks for the response. &gt; If you preprocess the input Can you show an example in this context?
Looks like https://github.com/jneen/parsimmon
Ah I see. So the use case in the example on github passes an array of characters into the Parser. I was assuming the parser a stream of text and did the array conversion. Now it makes sense, thanks!
No problem.
I would file an issue at https://github.com/Phaiax/ArcticTypescript
Thanks! I will do just that.
Wow, I didn't see this coming. This is great news. Presumably this marks the end of AtScript? EDIT: [yep!](https://twitter.com/ngconf/status/573521849780305920)
What a strange stroke of sanity on the Angular team's part. Good for all of us! 
As a developer, can I right-click on a button on the canvas and say "Inspect..." to see a visualisation of the settings on the button, and edit them to immediately see how the button would look with different styling?
If you haven't found it already, I've had a great experience on Mac OS X with [Atom](https://atom.io) and the TypeStrong plugin (note: there are several plugins for TS, but the TypeStrong one seems the... er... strongest). It's actually slightly ahead of Visual Studio in some respects. e.g. it already supports the `tsconfig.json` project file format that is slated for TS 1.5, with some extensions that mean you barely have to do anything with it manually. It's also faster at updating the UI when you fix a type or syntax error. Can't recommend it highly enough.
Yes, I believe it's a 1.5 screenshot.
Awesome!
What fails exactly? I personally wouldn't worry about the output of a compiler failing a linter. That is a something for the compiler writers to worry about. 
No such flag I'm afraid, you're probably better off using the /*jslint ...*/ options thing to suppress certain checks. Note that the compiler will guarantee many of the things JSLint is trying to check, so there isn't so much benefit to TS+JSLint. There is a TSLint, by the way. Never used it myself though.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Builder pattern**](https://en.wikipedia.org/wiki/Builder%20pattern): [](#sfw) --- &gt;The __builder pattern__ is an [object creation](https://en.wikipedia.org/wiki/Creational_pattern) software [design pattern](https://en.wikipedia.org/wiki/Design_pattern_(computer_science\)). Unlike the [abstract factory pattern](https://en.wikipedia.org/wiki/Abstract_factory_pattern) and the [factory method pattern](https://en.wikipedia.org/wiki/Factory_method_pattern) whose intention is to enable [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science\)), the intention of the builder pattern is to find a solution to the telescoping constructor [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern). The telescoping constructor anti-pattern occurs when the increase of object constructor parameter combination leads to an exponential list of constructors. Instead of using numerous constructors, the builder pattern uses another object, a builder, that receives each initialization parameter step by step and then returns the resulting constructed object at once. &gt;==== &gt;[**Image**](https://i.imgur.com/XbNt7sp.png) [^(i)](https://commons.wikimedia.org/wiki/File:Builder_UML_class_diagram.svg) --- ^Interesting: [^Creational ^pattern](https://en.wikipedia.org/wiki/Creational_pattern) ^| [^Carbonado ^\(Java)](https://en.wikipedia.org/wiki/Carbonado_\(Java\)) ^| [^Factory ^method ^pattern](https://en.wikipedia.org/wiki/Factory_method_pattern) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cp6v4uy) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cp6v4uy)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
The need to add three lines of code comes partly from the general suckyness of classes. They suck balls. A possible alternative: function makeEntity(options?: { position?: components.Position; velocity?: components.Velocity; sprite?: components.Sprite }) { // declare any private data and functions // do any once-per-entity setup return { // public methods of entity: doStuff() { // refer to private data and functions, and // options.position, options.velocity etc. } }; } Now to add a new option, just declare it one one place. You can use it anywhere in the code inside `makeEntity`: so that's in the one-time setup code, or in private functions or public methods. If you are concerned about entities being expensive due to having lots of function properties (make actual measurements!) then you can use `Object.create` on a prototype that has the common methods. But you'll need a very large number of entities before that's a significant problem. TypeScript is awesome, but unfortunately it can't make classes significantly better. They just aren't very good.
Wouldn't that still require me to declare it in two places? The constructor and the return? And I am not too worried about the method thing, seeing as I. ECS's the entities / components are only data, no methods.
Mine don't have an ID property per-say, it's ID is just its position in the entities array. But yeah I will probably go with an interface. Also why `&lt;Entity&gt;Object.create(options)` instead of just `&lt;Entity&gt;options`?
So.... dart 2.0 ?
dart what?
Traceur can emit normal js out of SaneScript source. Also, it's compatible with TypeScript
The real reason this is AWESOME is that we might see this ported to nodejs. When you are working with a huge team of people with various skill levels, a language that features static type checking can help manage the chaos. This could make nodejs more palatable to the mega corps.
Back in the days of IE 8 and earlier I would frequently hit differences between CSS interpretation across browsers. But in modern browsers (anything since IE9) the problem essentially no longer exists. The browsers all track WHATWG and self-update. XAML is neither better not worse - just arbitrarily different in all the details. Also XAML does allow you to create your own components. I frequently did when using WPF.
It'll error but it'll still compile afaik. Type errors don't halt compilation 
Exactly. Paste the OP's example into the playground and it will generate JS output, because the input is syntactically valid. But it will highlight the error in the source window, because the input is not type-valid.
Having tried it, I wouldn't use node *without* TS. I don't find it adds complexity at all. It just makes it completely frictionless to call an API and know that I'm using the right function name and passing it the right things without having to look at docs manually. It speeds everything up. Re: modules, I wonder what issue you hit? If you compile using the CommonJS module option, each .ts file produces a .js file that (from a module perspective) looks exactly like what you'd write yourself in JS, e.g. import fs = require("fs"); becomes: var fs = require("fs"); I've written about 50000 lines of TS (commercial production code) over the last few months, but in that time I've written about five classes. They're not as useful as you'd imagine. They push them in the demos as a gimmick to attract people who are used to classes in other languages. One relevant gap in TS at the moment is a way to describe the type of functions like `extend` (a.k.a. `Object.assign`), which effectively merges two interfaces. But even that can be worked around pretty painlessly.
It has been a long time since I tried to use Typescript in node. In the mean time I have written a complex ORM-like backend for my latest project using standard javascript and node practices. I have not felt a strong need for Typescript in this environment. Node's built in module system removes most of the pain that I experience with client-side js. Unit testing removes the remaining pain. I am part of a very small team will very limited resources. Typescript is not a good replacement for unit tests. I don't need Typescript to generate errors, if I have unit tests. Setting up and managing a TS build takes time, setting up unit tests takes time. I would rather have unit tests on the server and typescript in the client. The language of node js seems to be moving quickly without Typescript. I would rather wait until something like Sound Script becomes native.
TS is not a time-drag when the libraries you want to use have good interfaces in the definitely typed repo. When they have bad interfaces or no interface TS is a time drag. Many node libraries had bad interfaces or no interface when I played with it 9 months ago. For example Express 4 was out for months before the interface was updated.
Yes, I know about atom-typescript. I've been using it and tsconfig and quite enjoying it. 
Not too keen on the game, your implementation is brilliant though, stunning graphics! Well done.
I don't understand your question. Do you want to develop in VS? I work with TypeScript in VS every day of the week, so I might be able to offer guidance there, but I've never used PhpStorm before.
Everybody praises the tooling Microsoft provides for developing TypeScript in Visual Studio. I never tried it. I'm quite happy with PhpStorm for VisualStudio. I want to know if I'm missing something by not using VisualStudio, preoductivity-wise, tooling-wise, whatever. Something that I don't know that I'm missing, of course, because I never tried it. Do I make myself clear now?
Because it usually takes time to become productive? If I try it for a few days/one week I'm going to leave feeling that I was more productive in PhpStorm anyway
Ah, gotcha. In that case, probably just watching videos of people demonstrating usage of Typescript in VS should be good enough to get the idea across. FWIW, I use VS2013 and WebStorm, and while WebStorm 9 just invoked the TypeScript compiler as a file watcher, WebStorm 10 (release candidate available) has a built-in compiler supporting TypeScript 1.4 The biggest headache IMHO is just version lag. The TypeScript team will make sure VS has a good experience for each new version (like 1.5, soon in beta), but we have to wait for JetBrains to catch up to get those features supported in *Storm. They're fairly fast, but there's still a lag. 1.5 and 1.6 are huge leaps forward for TypeScript (having to use traceur/babel to get async/await was unfortunate, so having it finally show up in TypeScript is awesome), but I'm just hoping they're supported quickly by WebStorm.
It seems analogous to "edit and continue" in Microsoft's terminology: the code is replaced with a new version but the data persists. There is a drawback to this idea: you use version 1 of your code, it manipulates data, then it is replaced with version 2, which manipulates the data some more. At this point, the data is quite likely to be in a state that it will be impossible to recreate with version 2's code alone. So any further exploratory testing you do will be unrepresentative. It would be better if the app itself was smart enough to persist its state. At a minimum it would use the URL to record the "location" within the application, so refreshing would not require as much navigation back to the same spot. And even better, suppose the UI is an editor, it should support regular flushing of unsaved changes to the server (like "autosave"), so you can refresh at any time without losing your work. Users will appreciate this too...
**Where is the produced JS** The default config of both Visual Studio and Webstorm is to have the produced JS next to the TS unfortunatly for me. You may config WS to produce the code in another folder but the sourcemaping seems to be buggy. Concerning VS, my teamates are religiously against it: i didn't go futher in my testing. So, i'm using a gulp task to transpile the code and put it into a target folder after concatenation and minification. In this case, you may still encouter an issue with sourcemap location (sourceRoot) if you don't concatenate your files (with gulp sourcemaps or the --sourcemap option of tsc). TSC seems to be designed with the JS next to the TS in mind. **Do we have the ts files next to our js files** Obviously not. In a small project you should not really have a problem. But in middle/big project i advise to put the produced code into a separate folder. Moreover, if some non web dev come on the project (due to the hype around the HTML5 for example), they will not be confused by the 3 files (TS, JS and sourcemap file) in the same location. And if the sourcemap is not well handled (by the dev, the browser or something else) they may end up modifing the JS code instead of the TS and those devs will tell to everybody how horrible is TypeScript (&lt;= you may replace this by any transpiled tech). **Can i mixe JS and TS code in the same folder** You can mixe your code, but be careful with the file ordering. If you base your dependency management on TypeScript, you can tell to gulp-typescript to output files in the correct order. If you use CommonJS or RequireJS, you should not have file ordering issue even if you have mixed code (TS and JS) *ninja edit about VS/WS usage* 
Thanks for the reply. I am thinking if I make a npm module I'd like to use typescript to make things easier.
I've recently moved to Atom and the Atom-Typescript package. I'll have the typescript source directories in the root directory, alongside a `www` directory. HTML/CSS will go into the `www` directory, while the typescript files have their output set relative to `www` (IE, `root/engine/long/path.ts` becomes `root/www/engine/long/path.js`). There's undoubtedly a better way to do it (Particularly for GitHub pages), but this works for now.
All the suggestions to use gulp are not wrong but using gulp with typescript was a huge pain in the butt. I eventually wrestled it into submission but only after much suffering. The easiest way to get started with typescript might be with Webstorm. I like to use the --out flag on the tsc compiler to compile all of my typescript into one output file. Normally the ts watcher in webstorm compiles a js file next to your ts file. You can configure the watcher to always compile your main.ts --out main.js file whenever any ts file is changed. At the top of your main.ts file import every ts file in your project. If you import all files into your main file with &lt;reference&gt; tags you will not need to use &lt;reference&gt; tags in your sub files. If you neglect to place &lt;reference&gt; tags in your sub files you must be sure that the imports in your main file are in order of dependancy. For example make sure you import animal.ts before you import dog.ts when dog extends animal. Because I hate using the references tag, I have a gulp task that seeks all ts files and makes a file called project.references.ts. This file imports every ts file in my project except for the main.ts /* auto generated file, do not edit */ /// &lt;reference path="one.ts" /&gt; /// &lt;reference path="two.ts" /&gt; /// &lt;reference path="three.ts" /&gt; I import this auto generated file into my main.ts **JS with TS** Many times you can rename your project's js files to ts and import them into your ts build. This will not always work perfectly because sometimes typescript doesn't like the way you wrote your js. 
example code plz? Edit: never mind, got it, it's there on the page
thanks for doing that! that output isn't too bad
We're used to thinking: compiler error == no output. TypeScript is unusual in that it will still generate JavaScript as long as the syntax is valid.
It's a valid point, I thought about giving reasons for each style convention, but I wanted to keep this guide short and simple. The real reason I wrote this is that I've been following these rules for a long time, and just thought I'd write them down for code reviews etc. Some style guides seem to give reasoning for each rule, but some don't. Perhaps I can make another file to the repo to explain the rules, or I can just answer here.. The number[] over Array&lt;number&gt; was explained in the other comment (and additionally because I think number[] is more readable, that's a personal opinion of course). The line length 140 is default in tslint.
&gt; The real reason I wrote this is that I've been following these rules for a long time, and just thought I'd write them down for code reviews etc. That's perfectly fine! I just wanted to know why you did certain things, even if it's just "I do it this way, you may like it, or not, but I think it's nice". I just like to have a reason so if someone else asks me why I do something I can give a better answer than "Well, some guy on the internet told me to do it this way" you know what I mean? &gt; Perhaps I can make another file to the repo to explain the rules, or I can just answer here.. That would be awesome! &gt; The number[] over Array&lt;number&gt; was explained in the other comment (and additionally because I think number[] is more readable, that's a personal opinion of course). Depending on what language background you come from, but yea, me personally, I do like number[] better. &gt; The line length 140 is default in tslint. Cool, had no idea! I mean, i'm all for converging on a standard ya know, I just like to be able to explain to a co worker if he asks why something is done, otherwise cool guide man!
Be aware that the module system will be changing in the upcoming TypeScript 1.5 version which hopefully we'll be seeing very soon. These closely align with the ES6 module system. The current module system will still be supported, but you probably won't want to use it for anything new once it's released and I doubt you want to do the same job twice.
To add onto this, if you don't want to wait for 1.5 to release, you can install the 1.5 alpha (npm install typescript) and start using that now since it includes the ES6 module support already
Not an option I am afraid, this is an existing code base that can not be altered to much. The beatuty of changing : define(["dep"], (dep) =&gt; { //... }); To: import dep = require("dep"); //... Is that the rest of the environment is unaltered since the output is largely the same. But it's good to have this is mind, thanks.
It looks (almost) like an AMD module. You can configure TS to output AMD modules with the switch `--module amd` assuming that's what you're really defining here. So then if the TS source is: import foo = require("foo"); export function bar() { foo.x(); } The output will be: define(["require", "exports", "foo"], function (require, exports, foo) { function bar() { foo.x(); } exports.bar = bar; }); 
Well yes, this what I am asking about. The point is that I am trying to mix the two.
Do you think the compiler should allow this: greeter({ id: 1, name: "foo" });
Yes. But, only if Person's id is a number and name is a string. "name" could be defined as an Array for all I know, the compiler doesn't seem to care.
It doesn't, check my other reply. It considers both of those compatible with the any type, though.
&gt; *What's the point of specifying the type in the interface, if it means nothing?* It *does* mean something - users of that interface can expect this member to have that type, and once you explicitly specify the type of the member in the type implementing this interface, the compiler will verify it as well. The problem here is that pesky `any` type - it is considered equal to all other types, that's its purpose. Avoid it if you can. There's a `--noImplicitAny` flag which tells the compiler to require an explicit type declaration, that way you *have* to explicitly say if your `id` member is a `: number` or `: any`. Both these types will still satisfy the requirements of the `Vehicle` interface, but other types will cause an error. Enable this flag for extra motivation. ---- ---- &gt; *Also, I can change the type of id in the Person interface to a string, and the compiler apparently still thinks is structurally equal to Vehicle.* Errors earlier in the program can cause mis-detection of errors down the line. If you have a compile error on the `var car = new Car...` line, then the `greeter(car)` line is not flagged as an error, but once you fix the previous error, this one becomes an error (assuming you don't have any other errors above that line...).
I get that and thanks for the compiler flag, that will be useful. That still doesn't answer my question: Is there any point in specifying a type of a member in an interface? Or are interfaces only supposed to care about the name of the member? Am I wrong to want to define types in an interface?
The interfaces are not equal, and the compiler does not consider them as such. See all the other replies in this thread, the problem is that your implementation classes have members with type `any`, which is designed especially to "punch through" the type constraints.
You absolutely should specify all types in an interface, that's the whole point. If you try to specify id's type as string in the Car's constructor you will get a compile error. If you don't specify the type you will get a compiler error if --noImplicitAny is used (which should always be used).
I believe the reason for defaulting to any is because typescript is supposed to be a superset of javascript, thus any valid javascript code is valid typescript code and any is the default in js. using the noImplicitAny flag as stated above will remove that
That totally makes sense. I think I'm starting to better understand that one of the main goals of TypeScript is to not break compatibility with js. Pretty smart way to handle it, actually.
I would suggest clarifying the scope of your style guide. Currently, it's a mix of TypeScript and general JavaScript guidelines. I would at least put the TypeScript-only features in a separate section. If this is going to be JavaScript style guide as well, there's a lot more to cover and the document could become quite large. I would also consider who is the intended audience for this style guide. For example, if it's intended for relatively inexperienced programmers, "do it this way" without explanation could work. But if the reader is an early adopter type, saying "use four spaces" comes across as micro-managing and out of scope.
&gt;I would suggest clarifying the scope of your style guide. Currently, it's a mix of TypeScript and general JavaScript guidelines. I would at least put the TypeScript-only features in a separate section. Since JavaScript features are TypeScript features, I don't see much benefit from this suggestion. I clearly don't want a separate guide. A TypeScript developer will benefit from TypeScript and "JavaScript" conventions, and a JavaScript developer should use another guide. &gt;If this is going to be JavaScript style guide as well, there's a lot more to cover and the document could become quite large. It's not going to be a JavaScript style guide, but a TypeScript style guide which includes conventions that also apply to JavaScript. There may be alot to cover. If the guide becomes too large, I can split it. &gt;I would also consider who is the intended audience for this style guide. TypeScript developers, experienced or not. &gt;But if the reader is an early adopter type, saying "use four spaces" comes across as micro-managing and out of scope. I disagree. The whole point of style guides is to set out conventions like whether or not to use spaces or tabs (and how many spaces). Otherwise there will be mix of different conventions, which makes development slightly more inefficient. It's certainly not out of scope.
I guess TS will have something like JavaScripts' Proxy class.
I use browserify + tsify, because the sourcemaps match from source to the final bundle file.
It would become handy for implementing persistence libraries similar to Ruby on Rails's ActiveRecord.
AWESOME!!
Someone should explain to me how this is different than their recently available Community edition? 
This is a text editor with some IntelliSense features (for some languages). This is not a compiler nor does it support Visual Studio project files (although you can load project directories in it). It's not a full IDE, it's just the most essential features of an IDE in an extremely lightweight package. It's already decent for web development if you're using a text editor instead of a full IDE. VS Code is more akin to Atom (from Github) or SublimeText: a text editor with limited understanding of the code you are editing. Atom and Code (and SublimeText with extra plugins) can talk directly to Git source control. You can edit C++ or C# files (because they are text) but you can't run them. The limited debugging support uses Node.js and presumably is limited to JS. I only used the app briefly and it didn't even understand JQuery "$" references... yet. *Tl;dr: What it is now is a very polished v1.0 of a code-aware text editor with limited language support. What it will become is unclear. *
And to be clear, VS Community is all the "full IDE" things that Code is not. But again, since we don't know what Code will become as more language (and plugin?) support is added we can't full judge how different it will remain from Community. But they're both free, and only one of them support Linux and OSX so it's not like we have tough decisions to make.
Yup, Angular 2 is the one built in TS. This is "future Angular". Sorry for not making it clear.
Great video, and a good "modern" presentation on TypeScript too.
Fantastic demonstration, I'll be showing this to people when they want to know why I choose Typescript for webdev.
Check lib.d.ts
Specifically: https://github.com/Microsoft/TypeScript/blob/master/bin/lib.d.ts addEventListener(type: "keydown", listener: (ev: KeyboardEvent) =&gt; any, useCapture?: boolean): void;
Interesting, hadn't heard of Ionic before. Wonder how good it actually is.
Has anyone compared this to [clausreinke/typescript-tools](https://github.com/clausreinke/typescript-tools)? That one's been around for a bit longer.
I used typescript-tools prior. This one has been much more stable for me.
thanks, i'll give it a try too
I rustled up a quick app to test how smoothly it scrolled and it was pretty impressive on an iPhone (5s)
You must not have looked very close, there are multiple links to Aurelia once they start taking about it. The getting started link on github links
It will display warnings, but it should still emit code.
That's exactly right. Most type errors will still compile in typescript. 
TypeScript declare files (*.d.ts) exist solely to give the TS compiler information about types found in external libraries. Obviously, jQuery is written in JavaScript with no type annotations. However, in the DefinitelyTyped project, the community has crafted a declare file for jQuery that provides type information to the compiler. For example, it asserts that there is a variable called `$` (and `jQuery`) in global scope, which is a function. Here's what that looks like: declare var jQuery: JQueryStatic; declare var $: JQueryStatic; JQueryStatic explains all of the members of the `$` object, as well as the fact that it is callable with certain parameters. Now, when you are calling the `$` function in TypeScript, the compiler won't complain that `$` is not defined (because the .d.ts file said it will be defined), and furthermore, will be able to check that the arguments to the `$` function are type-compatible.
http://www.typescriptlang.org/Handbook#modules-working-with-other-javascript-libraries &gt; To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, modules are a good way to represent them. We call declarations that don't define an implementation "ambient". Typically these are defined in .d.ts files. If you're familiar with C/C++, you can think of these as .h files or 'extern'. Let's look at a few examples with both internal and external examples. By the way, here are the steps for refactoring JS to TS from the Build 2014 talk on TS. You may find these helpful. 1) Change .js files to use the .ts extension. 2) VS will prompt you to install nuget packages for TS. 3) Examine errors in individual files, one file at a time. 4) Assert types on untyped assignments. 5) Set types on method arguments and variables. 6) In TS settings, uncheck "allow implicit 'any' type." 7) Refactor variables to classes, enums, etc. 8) Now you can refactor your code.
It's all for type/method/parameter checking. You could just declare $ as "any" and it'll happily compile all your jquery code, but it won't tell you if you're using something incorrectly. Then I haven't used the Visual Studio integration, but I imagine Intellisense will use them for completion/suggestions.
No support for referencing type definitions?? Nothing to see here, move along...
The example shows the backbone definitions just concatenated at the beginning of the file. It works, but it would be nice to see some form of DefinitelyTyped integration
TypeScript is a superset of JavaScript. Therefore, I think you should learn JavaScript first and work with it for a bit in order to (a) be able to dive into all your dependencies, which will mostly be pure JavaScript and (b) know exactly which additional features TypeScript brings to the table, and the reasoning behind the specific quirks and design choices. 
Typescript. Without a doubt. I adopted it about 2 years ago now, on a project that has grown far larger than I ever thought it would, and it's saved my ass about a billion times now. I'll never code raw JS again. 
So you'd have to add @spy to the implementation code?
&gt; So you'd have to add @spy to the implementation code? I've been talking with some devs and they didn't like the idea of adding test related code (@spy annotations) to the actual application code. We are thinking in allowing a few styles. Take a look to this gist https://gist.github.com/remojansen/8e2aff308bb777071571 Please feel free to join the chat (https://gitter.im/AtSpy/AtSpy) and share your suggestions and opinion it will help us to create a great framework.
"I've been talking with some devs and they didn't like the idea of adding test related code (@spy annotations) to the actual application code." Yup — that was my concern too. I'll check it out. Thanks!
Learn JavaScript first because that's what you'll be working with in the debugger. Source maps aren't as amazing as some people think. Also, you'll probably have to interface with a lot of non-typescript js.
Sounds interesting. Link?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javascript] [Useful TypeScript tools for the NPM run-script builds \[X-Post from /r/typescript\]](https://np.reddit.com/r/javascript/comments/38d90l/useful_typescript_tools_for_the_npm_runscript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
That is how I do my TS projects by default. It is much simpler, I don't need a layer of out of date plugins or any such nonsense and I've never seen a tool which didn't have a command line interface. It is also easier to debug the build when you can see what is being run. 
You could use the parameter instead of `this`, e.g. class SomeClass { name: string; action() { $('.object').each( (i, elem: Element) =&gt; { $(elem).html( this.name ) } } } edit: However, each isn't even necessary in your example. You can just do... action() { $('.object').html(this.name); }
Did the first module. They start at ground zero which is a blessing and a curse. Highly recommended though for people who want to get a jump start on it! We have cookies and kool-aid on the other side!
I have had similar problem in node.js few hours ago when I was fighting with typescript. I was able to progress forward by declaring classes without namespaces and using export keyword to export this class. // a.ts class A { } export = A; // b.ts import A = require('./a'); class B { constructor( ainstance: A ) {}; } export = B; Compiler options: --module commonjs
Thanks for the suggestion. We're pretty big fans of proper naming and clean coding, which for us also means having classes in well defined packages. So for now, we went with not exporting the modules, and compiling all our TypeScript into a single file. Not idea, but, yeah.
Really appreciate the support for JSX. Babel already support the JSX extension and it is being adopted quite a lot in describing nested structures even outside of React, although I personally use it quite a lot for React.
Missing link
It confuses a lot of people :)
I get what you mean with the `any` sentiment, but the more I use union types, the more I think they're an important construct in any language, not just something to make some JavaScript output work in a more-or-less strict way. I use them when in places where I need completely different types (normally primitives), when an interface wouldn't make sense. Union types can be abused though: one normally shouldn't have something of many union types. To me, more than 3 is a pretty good indicator that there's something wrong. Much like inheritance, union types is one of those things one needs to thread carefully because it's easy to misunderstand it.
I'm not so sure. I think no type information is a different, but equally egregious, situation than too many types.
what the hell
Why didn't you use typescript to generate the js for the index HTML. :/
If you used swagger, there are a number of tools ready to go that can consume that data.
But nodeJS will fail with class not found error.
You have to pass the harmony/ES6 flag to node: node final.js --harmony
Hey, this work perfectly. Thank you!
lines 45-50 can be removed and replaced with return /[A-Z]/.test(msg); I'd tweak your constants class (honestly, probably dont even need it). export static CIPHER_KEY: string = 1; export static STRING_NO_VALUE = ""; The encode method. lines 60-73 if you declare the default value for string earlier, there is no need to return the string no value. string no value == "" == default value for result. var result: string = ""; if (!this.isValid(msg)) { this.hasOperationFailed = true; } else { for (var i: number = 0; i &lt; msg.length; i++) { result += this.encodeChar(msg[i]); } return result; other than that, not too bad for your first typescript. 
You could also just make that whole loop a simple fold and return it directly.
Here are a few comments/suggestions in no particular order: - the STRING_NO_VALUE constant property seems kind of silly. - the CIPHER_KEY constant also seems weird. Why wouldn't that be an input from the user? - You probably want to use `document.addEventListener("DOMContentLoaded", callback)` instead of `window.onload`. - Just in case you aren't aware, it's usually not necessary to include the type in your variable declarations if you're also initializing on the same line. E.g. this works: `var myNumber = 5;` - you will still get all the benefits of typing because the compiler knows that 5 is a number. - Line 36, where you replace " " with "", will not work for strings with more than one space (only the first space will be removed). To fix it, you can use a regular expression: msg.replace(/\s+/g, "") - On line 45, you are checking that msg contains at least one uppercase letter. Is that your intent? - Control flow statements without {braces} make me twitch ;) - It's good practice to avoid altering a function's arguments. Some JavaScript engines fallback to a slower compiler for that function when this is done. For example, your cleanUpInput method should just have one line: `return msg.replace(" ", "").toUpperCase();` - The validChars and cipherLen should be static members. - Never use ==, always use === That's all for now, let me know if you have questions about any of these items.
Yes!
Agreed. In languages that have more than one Number class it's definitely more relevant than in JS/TS.
Just one tip. Now is an excellent time to ban the use of `var`. TS 1.5 lets you use `let` and `const` even when targeting ES5 as output. 
Have to agree with most of what this guy says. It's wonderful, but you can really tell that it is an infant framework.
&gt; It's easier to build TypeScript outside the bundler. Definitely so, although I still wouldn't consider it ideal. I've personally been using webessentials, but I agree. What I really want is it to have a .tsproj file that can include a specific subset of .ts files, reference it in your other projects and have it automatically compile all the javascript as one file into the /scripts/ directory. 
&gt; Definitely so, although I still wouldn't consider it ideal. I would have agreed, but even Microsoft is moving towards the typical build tools web developers are using. They really are trying to embrace what's happening outside of Microsoft. To that end, Web Essentials has removed some features, like SASS compilation. The goal being that not every webdev needs VS to build a MVC or WebApi project. That happens to work out well where I work. &gt; What I really want is it to have a .tsproj file That would be pretty nice. I sort of accomplish this with a _references.ts file that every TS script references.
exactly, you can also set a flag for `--no-implicit-any`
I used to be a huge fan of Dojo back in the day where jQuery was the standard for building web apps. It was modular, and very nicely built. Stopped using the project for a while it looks like they are pushing a new series of energy back in the project. Really excited about its future developments :D
I went with TSLint instead of using this flag, and I have to say it works very well (once you turn off all the silly rules, like "Trailing whitespace" for example). I'd like something like this to be built directly into TypeScript at some point in the future, rather than having to download a third party nuget package.
Incidentally, even the Typescript compiler uses this Map type.
Which browser are you using? I just tested in chrome with local data deleted and it loads fine. The GUI is very similar to the one JSBin (http://jsbin.com) uses, with multiple panes that you can toggle on or off with the tabs. In fact, I just wanted a JSBin with proper typescript support and seeing that it'll probably never come to JSBin I decided to roll my own based on the typescript on ace editor example I found. I'm open to feedback though, I thoroughly suck at creating understandable intuitive GUI's. Maybe I should make sure that the tab buttons are aligned to the actual panes hmm 
&gt; This is either a good thing, or a bad thing. I can’t decide. To be honest, I wish TypeScript did force you to use its own paradigm. You can easily write pure JavaScript inside a TypeScript file and it will all compile and “just work”. That is the main thing that's drawing me to TypeScript. This guy needs to ask himself _why_ so many people are using weakly/dynamic typed code despite its clear drawbacks. In my opinion, there are very frequent cases where having to worry about types is counterproductive. A very common one is when writing throwaway or single use code. Like test cases, or one-ish liner scripts. TypeScript gives you the best of both world in that particular case; you get the benefit of types in the longer-lived or reusable code you refer to, and you just don't give a fuck about the code you're writing. If your code turns out to need to be reusable, adding types is in fact very easy. I can't think of any other language that allows this paradigm. 
Thankfully this is evolving very fast. 
I messed around with generating type definitions from jsdoc JSON dump. https://github.com/icholy/cesium_typescript_generator edit: I'm thinking about rewriting it as a jsdoc template.
Many people tried, there is some code for it around (on npm or on github). There also were some threads about it on DefinitelyTyped github issues, maybe also on their site.
[Look on this page](https://atom.io/packages/atom-typescript) for "React". Support for JSX in TypeScript. 
&gt; I can't think of any other language that allows this paradigm. https://msdn.microsoft.com/en-us/library/dd264736.aspx &gt; That is the main thing that's drawing me to TypeScript. FWIW, this "feature" of TypeScript is only there because it would not be possible to exist as a superset of JavaScript without it. It's purpose isn't to allow developers to avoid types, but to allow for the existence of unknown and uninferred types.
I'm still pretty new to TS, so if anyone cares to offer a critique, please do. TIA.
I can't figure a use case.
Well, the PR itself presents a few examples. If nothing else, it saves time from creating a new interface which simply extends two types and is only use in a single place.
Who is that JsonFreeman? And why Andres needs to answer his questions; to get a merge permission? It just seemed that they are on completely different level understanding-wise, like a pupil and a teacher.
Agreed on that a review process should be in place.
That was/is my one greatest pain point with TypeScript!
Blech. Already not a huge fan of union types. This is gonna make all sorts of ugly typing cruft too. enum Foo { A = 1, B = 2, C = 4 } function(foo: MyFoo &amp; MyBar | MyBaz) { return Foo.A &amp; Foo.B; }
Ah, I see what you mean. No, that won't work. You need either ES6 or a module loader (requirejs).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javascript] [Our Framework is now Open Source \[X-Post from /r/typescript\]](https://np.reddit.com/r/javascript/comments/3dieu4/our_framework_is_now_open_source_xpost_from/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
I find the github to have mode in-dept informations https://github.com/Microsoft/TypeScript/wiki/Compiler-Options 
TypeScript simply has new syntax for ES6 modules. It still compiles to either AMD or CommonJS. I hear it'll also support System.register once 1.5.2 is complete. This'll have the benefit of supporting all the features of ES6 modules (in particular circular deps). 
Compiles fine for me with the following usage: let a = new noise(); a.seed(1); But it looks like the original library should actually be used as: noise.seed(1); So your declaration should probably be: declare module noise { function seed(value: number): void; function simplex2(x:number, y:number): number; function simplex3(x:number, y:number, z:number): number; function perlin2(x:number, y:number): number; function perlin3(x:number, y:number, z:number): number; } It's not a class to instantiate, it's just a module exposing some functions.
If `noise` is a service/singleton/... and not a class you have to prefix the functions with **static** to be correct. Your declaration would expect the following JavaScript Code: function noise () {} noise.prototype.seed = function ( value ) {}; But I guess `noise` is already instantiated and its code looks something like this: function () noise () {} noise.seed = function ( value ) {}; 
Does anyone have experience using TS with iojs (ES5 output thus) and core-js? 
Still lacking Async/Await, Generators, and JSX. But the next versions will have them, and then it will be complete enough for me \o/
Until the next bunch of missing features is discovered....
You should be able to use the same files for both. For the client you'd just need to have script tags with the src pointing to their location on the server -- no cross domain issues that way. Now for the problem with special requirements for clientside, you might want to check for the existents of the window object: if (window) { // Define classes, etc. for clientside... // Use interfaces for clientside. } else { // Do stuff for server... // Use interfaces for server. } When defining interfaces you don't have to worry about where they'll get used. Instead you apply them as the types used by the code for either clientside or server. Hope that's clear. I've done some similar stuff recently and this approached worked great for me.
I'm not sure exactly what you mean? The issue lies with i don't know how to write the export module syntax to make it work for both. As you said, interfaces are probably fine, since they are only for the compiler, but the constants... if i add export = Constants to the end of the file, The client does not know what the "Constants" object is...
Use modules for both the client and the server. TS doesn't play nicely with a mix and match strategy if you want to reuse them. Use browserify (or webpack) to build the client-side file. The tsify browserify plugin has done well for me.
Thank you for feedback, I will look into it ! 
I've been fiddeling around with this a bit now, though, i'm running into problems when i'm supposed to pack files from bower, especially pixi. browserify seems to look for node. Have you had a look at this as well? It's mainly pixi which is my issue right now. There's https://github.com/eugeneware/debowerify but it seems to build pixi wrong somehow.. though i just started messing with this :) EDIT: It seems as if the "require" within PIXI (it's built using browserify) is messing with the browserify.. hmm
Have you tried using the npm version of pixi.js? https://www.npmjs.com/package/pixi.js
Cool. :) I'm in the midst of "soft launching" a large web site that uses Angular and TypeScript. Part of our research has been [how to write directives](http://blog.aaronholmes.net/writing-angularjs-directives-as-typescript-classes/) with TypeScript. Unfortunately, my employer and our clients aren't big on open source sharing, so I don't think I will get a chance to write about some other things we've done. Suffice to say TypeScript makes the entire process much simpler and way more maintainable. We're at some odd 33k lines of TypeScript now.
Yes, just did.. that seems to work, however the filesize is bigger, i think it might require more files somehow, or maybe it's just not minified... hmm. 
A directive with an isolated scope doesn't prototypically inherit its parent scope. So by uncommenting those lines you are introducing an isolated scope and the directive no longer has access to the enums you exposed on the controller scope. Edit: There are 3 potential solutions/hacks. 1. Define the enums on the isolate scope 2. Use $parent in your directive template to refer to the enum members of the controllers scope (hack) 3. Define the enums on the rootScope and use $root (hack) Edit2: After looking at this on my PC (not mobile) I have two further thoughts. First, you really, really shouldn't be relying on the parent scope within a directive here. That is your main issue. This line: return (unitType === scope.design.unitType) ? imageService.getUnitTypeImage(unitType, ImageType.Active) : imageService.getUnitTypeImage(unitType, ImageType.Inactive); is mixing scopes. But my second thought is, why can't this just be done with CSS?
Thanks for your thoughts. I know this isn't the correct way to do it (since it doesn't work) and yes, it tries to mix scopes. I have to think this through again. Where should I store the design which is changed with every button click? The picture is redrawn every time the design changes so it should be in scope somewhere and it should be watched? I wouldn't go with CSS since some of the button images' names may vary depending on other choices in the design (eg. I choose A1 and B2 =&gt; C's images are like [a1_b2_c1.png, a1_b2_c2.png] or it could be [a3_b1_c1.png, a3_b1_c2.png]) so it needs some logic behind it. 
I'm OK with babel and es6 for site projects. For libraries, Typescript is still king. There's an ability to refactor, debug and expand code that only the strictness of something like TS can offer. 
Check out https://github.com/vivainio/typescript-ng1-style/blob/master/further_topics.md
TypeScript isn't intended to replace JavaScript. It's a *superset* for a reason. Yet, your response indicates you are approaching this as a "ES6 vs. TypeScript" problem, which doesn't make much sense. TypeScript will compile down to ES6 and look almost identical, with typing syntax removed. Additionally, I think you are intentionally avoiding the fact that you don't need to use .d.ts files for your own code. I take issue with your statement that momentum is far more important than technical merit as well. Rather, I think momentum creates a mob mentality. For example, now we're stuck with a million and one NPM packages for single-line functions that all do the same thing. It's a crap situation to be in. Worse, I suspect the companies writing large, purely JavaScript applications will run into significant maintenance issues when their current teams move to other companies. JavaScript has significant momentum despite its technological issues. What does that mean for the future?
&gt; It's a superset for a reason. [Well, kinda...](https://smellegantcode.wordpress.com/2015/07/11/is-typescript-really-a-superset-of-javascript-and-does-it-even-matter/)
&gt; Look at the Dart failure; no one cared, despite its technical merit. But it had zero technical merit. It was barely distinguishable from Java. Its failure was absolutely predictable from its design alone. &gt; tsds suck. Presumably you mean you've found some `d.ts` that sucked? &gt; Typescript is a strong presence in the C# ecosystem, but beyond that I've found a lot of very skeptical folk. Have you heard of Angular?
I'm not sure I agree with his conclusion, but I don't have the time to construct a solid argument. Rather, I'll just leave it with the fact that TypeScript will still compile the output as long as you don't have any syntax errors. Perhaps a better name would be "[proper superset](http://mathworld.wolfram.com/ProperSuperset.html)."
After thar "var directive =..." I just console.log(directive) and it shows that within the directive myService is undefined. And the same inside the link method. I'm perplexed too, it seems to be as in the examples behind the links I provided but it doesn't work. I'm getting a little(to put it mildly) frustrated by this.
Well, I do, so that part doesn't apply to the projects I work on. So, type errors being significant in TypeScript, but not JavaScript, the fix is to call `.toString()` on the variable, or to directly cast it to a string. I don't think this really excludes it from being a superset. 
If you're genuinely interested, you should actually read the whole blog post. It's not that long.
To be sure, can you change that code to the following? var directive = (myService: Foo.MyService) =&gt; { console.log(myService); return new MyDirective(myService); }; *Inside* the link method, the issue is likely one of binding the right context. The ngClick handler is [lately-bound](http://javascript.info/tutorial/binding#late-binding) to the element which triggered the handler. There are a few ways to fix it, but the simplist (since you're using TypeScript) is to use a lambda. link = (scope, element, attrs) =&gt; { scope.fooClick = () =&gt; { this.myService.foo(); scope.foo = this.myService.getBar(); } };
angular 2.0 you mean, that one big project that uses typescript because Dart failed and they need a way to support their legacy applications using dart by cross compiling TS to dart? yes... thats called a *compelling use case*. They had a need, typescript filled it.. It was and is a great choice. For them. I'll say it again; lots of people are unwilling to use typescript. If your choice is; use es6 and get 80% of people on board, or typescript and 30% of people on board, which is better? Is it better to have some great code? or lots of good code? I'm not going to argue that technically, TS type annotations don't result in better code. TS is, categorically, better. ...my argument is, TS is only good *if everyone uses it*. ...and my personal experience has been that many people can't be bothered; but because es6 is *easier to get into trivially*, theyre willing to use that.
Also, if I try to console.log(Foo.MyService) within that block, it says undefined too. It's like Foo.MyService isn't visible within the factory EDIT: After adding module Foo to app.ts, then console.log(Foo.MyService) prints out "function MyService()"
Thank you for commenting, the issue got resolved here: http://stackoverflow.com/questions/31830239/angular-with-typescript-and-undefined-injected-service-in-directive
Well, sorta. I don't know if it is Visual Studio or something else but sometimes services are found just fine and are defined as they should but sometimes if I make an irrelevant change to code (eg. add console.log) all services are undefined again. And then after some change (maybe comment console.log or something similiar) services are fine again. Very frustrating. This happens alot and I have no idea why it does that.
https://en.wikipedia.org/wiki/Argumentum_ad_populum
Take a look at the output .js file. Maybe the order of the various js transpiled from ts is wrong from time to time
I've checked that and it seems to be the same with every build
I really really want to like Haxe, but everytime I try it I feel let down. I even booted it up again this morning and tried a cross compile to PHP, Python and JS. PHP was reasonably fine, but failed to find the documented \_\_call\_\_ method which gives access to native PHP methods. Otherwise I got a basic templating system going. Python crapped out with a simple hello world compile. Saying it couldn't find whatever trace compiled down to. JS was the smoothest run, but just seems kind of pointless. It makes it tricky to leverage existing JS libraries. And if you are only compiling to one language, you might as well use the ones 100% dedicated to it like Babel or Typescript, or just write raw. Again I want to like Haxe, guys like Deepnight always use it on ludum dare comps with great success, but just feels so limiting. 
Hey I know this is an old thread--but how are you refreshing your browser automatically when using Atom-TypeScript &amp; tsconfig.json? Do you still use gulp at all side-by-side with the Atom-TypeScript plugin?
Ah completely understood...I'm used to using something like grunt or gulp to refresh the page whenever I make any HTML/JS changes, but I guess according to [this link](http://stackoverflow.com/questions/31483522/atom-typescript-updates-the-ts-file-but-changes-in-html-dont-update-upon-save), atom-typescript has no concept of HTML, therefore, I'll need to perform this step manually. Thanks for the response!
The book introduces TypeScript including functions, OOP, decorators, testing, automation and architecture. The book ends with he creation of a framework similar to backbone.js from scratch. Feel free to ask me any questions bout it :)
You can have a mother and a father just as long as your father is your mother.
Do you minify your JS files? If yes, you may lose some data as Angular evaluates injections by arguments name, which may be changed by minificator.
Sweet, sweet abstract classes. No more of this Snake extends Animal implements IAnimal crap
Is there documentation about this somewhere? 
Nah, that's not exactly what I mean. Ad hoc polymorphism is more like a use of the [adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern) where there's no need to explicitly wrap the value you're passing to an interface that requires the adapter. What's nice about it is that it greatly reduces the need for the inheritance/interface hierarchy to be established a priori. You can instead define adapters/typeclasses after the fact. It's also great because it allows you to leave the core class focused on core operations. In untyped JS, I think the usual solution to this is uses something like `extend` to mixin new methods that would unify a set of types however you see fit, which can even be done functionally if you use `extend({}, coreClass, adapterMixin)` so that it doesn't mutate anything. But I'm not sure this pattern works with TypeScript's type system.
That's a demonstration of the fact that the type system is [structural](https://en.wikipedia.org/wiki/Structural_type_system) instead of [nominal](https://en.wikipedia.org/wiki/Nominal_type_system), but I don't think that's what I'm getting at, because it still requires `numberOfLegs` to be defined on the underlying class, not added.
Yeah, I figured it was a stretch, but it seemed similar to type classes in the 5 minutes I had to read about them. I don't think there is a way to do exactly what you're asking for since TypeScript's type system doesn't exist in JavaScript so the is no way for the compiled code to type match correctly after compilation. It would be a nice feature, though.
I hope not because of that site tho. Took me a while to figure out the slides move with the keyboard on pc. Also borked on my iPad, crashes Alien Blue and in Safari it's wonky at best.
Nah it doesn't really do anything in my case, even the compiled output is exactly the same as before. But it helps for reasoning with the code. And *maybe* it can be used for optimizations in the future.
Meh, maybe for basic use cases but I rather have a specialized tool do the bundling. Don't see tsc beating webpack on advanced options.
X-Post referenced from /r/programming by /u/DanielRosenwasser [Announcing TypeScript 1.6](https://www.reddit.com/r/programming/comments/3l7r5w/announcing_typescript_16/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
Good point. As far as I'm aware webpack doesn't have this yet. It has all the less advanced stuff so I suppose it will get this too. 
If someone is interested in writing one, it'll pop up. Otherwise, I don't expect Microsoft to take a strong initiative there.
&gt; Are there any showstoppers? Maybe because the developers are too busy working on the [TypeScript roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap), and are giving themselves a break by knowing that there are already ECMAScript to JVM and CLR (.NET) compilers that are very well-maintained, which are [Jint](https://github.com/sebastienros/jint) for the CLR, and [RingoJS](http://ringojs.org/) and [Rhino](https://github.com/mozilla/rhino) for the JVM. Sure, ECMAScript to JVM and CLR isn't quite the same as TypeScript to JVM and CLR, but at least it allows you to take TypeScript's ECMAScript output and then run it on the JVM and CLR. I guess this fact allows the TypeScript maintainers to develop the language in peace until some people start complaining about the "ECMAScript intermediary" involved.
I find more likely that they will implement compilation to web-assembly first. http://www.2ality.com/2015/06/web-assembly.html
I half-assed a calculator which, for now, can only do addition, take a look at the code, I hope it helps you: http://jsbin.com/zekifu/edit?html,js,output I'm a TS newbie too and never built a calculator before. Don't think I followed any best practices in this code. Like RickyMarou said, this is using just JS. Every time you can't find how to do something in TS it is probably done with plain JS, and even when there is a TS way (new feature and so on) you can still use the JS way without a problem.
I'd rather see C# to JavaScript, which already exists. TypeScript is alright and I like it, but it has some inherent warts simply because it's a JavaScript superset. I wouldn't personally want to use it for anything other than writing better JavaScript. While I don't speak for anyone else, I suspect I'm not alone here, and so I believe the motivation to create a TypeScript to "X" compiler is very low.
I improved the calculator, got almost everything working except for percentage. Also moved to CodePen: http://codepen.io/wkoch/pen/JYbNPm/ It took me around 5 hours of work, 2 in the first part linked above and 3 more today.
you can fix your formatting by either put two newlines between lines or put a * at the beginning of each
Using typescript without using classes and inheritance. 
&gt; Using typescript without using classes and inheritance. Do you mean talking about other styles of programming like functional programming?
I'm working hard to get this published to NPM. Latest check-in converts all old style import/export syntax to latest.
My whole interest in Typescript comes from being good at JavaScript and hating it. First I looked at C# to JS stuff. But by nature of the beast, Typescript wins. I think it would be neat, but like others are saying, its probably not worth it. If you want to write typed JavaScript, JScript.NET has been around forever. It had types before ActionScript. You can code in JScript.NET and its basically what you're asking for. I started writing ASP pages using JScript, then migrated to JScript.NET on ASP.net. But then... C# won me over.
You probably shouldn't be using a global variable for what you're trying to do, but… to let TypeScript know about your own properties on the global object you need to augment the Global interface in a d.ts file: ```` export interface Global { myProp: string; } ````` If all you want is to 'share' stuff across files (i.e. modules) you probably want to export from your modules rather than add to the global object.
I was able to as well, but I realized that it wasn't ideal since the source could get out of sync. Might as well let it be embedded in the map.
TypeScript 1.6 looks for typings in the package.json file, in each directories of /node_modules: https://github.com/Microsoft/TypeScript/issues/247 Also, it might help to concatenate all the .d.ts generated files with dtsgenerator, but I'm not sure it is recommended with the new module resolution. For a browser standalone library, you can use the --standalone option of browserify to be compatible with amd or global variable style modules.
That seems like a vast amount of code to build such a simple UI. I recognize that this is probably more React's fault than TypeScript, but still.
recommended. That way people can just reference the JS file and bring in the d.ts file for writing the TS. No need for the actual .ts
hey - thx - saw that and will look at tonight
You don't have to use definitely typed if you don't want to. Just use any. declare var $: any;
True. Typically, unless I'm using a fairly popular library, I make my own definition file by starting out with something empty then filling it in as needed.
I don't really understand the point. If you don't want the client to have access to private data, don't give that data to the client.
As you say, not really surprising - typescript is there to save you from yourself before runtime, not during... Though it would be interesting to see what trade offs would be to have the private keyword emit something like the module pattern.
Nothing in JS can ever really be private because its all handled by the end user anyway, all you can do is make it harder to access, but they will always be able to get it if they want. Private is just setup to make it so you don't modify those fields directly while working on your code, so that you make sure to use the public facing method to do your work.
Author claims working in Visual Studio Code is better than working in Visual Studio proper. Anyone else have this experience?
What makes VS Code preferable to you for typescript?
Author of the article here. Babel is the main competitor of Typescript. Most projects evaluating what ESx transpiler to go with will likely have only Babel and Typescript on the table (Traceur, google's ES6 transpiler is quite dead).
I could see that being handy. VS can be big and slow to install. I've been meaning to try it on my netbook. It stopped running VS well with 2013. A big chunk of what I do recently has been js/ts.
If you have FooBarController, you can search for e.g. fobaco. Ctrl+, needs a full match. In VS, you need extension like resharper (which brings its own share of perf problems)
For me it's simply the ability to target other versions and have it compile correctly down. Being able to type things like ```const``` and my new fav: ```for(let v of array)``` and have both work as expected is just awesome.
I used to do that, but sadly TypeScript cannot translate ES6-style imports to CommonJS/Node-style requires (or the other way around), or at least it couldn't the last time I've tried in TS 1.4. These days I always make TypeScript generate ES6 and then just feed the output into Babel. I would say main reason I use TypeScript is because of the type annotations, tools like Visual Studio Code (or VS2015) are pretty good at autocompleting and refactoring TS.
I saw the star wars thumbnail, read the title, and was very confused.
Aside from types and ES6? Well there's not much left. Decorators, probably.
You can use closures to create private data. function MakeBank() { var balance = 0; return { deposit: function (amount) { balance += amount; }, widthdraw: function (amount) { balance -= amount; } }; } 
Sure but anyone can view the source, or even extend it to pull those variables out / make them public, thats what I meant by private, as in hidden from the user
This is interesting.. at work today we were contemplating the two projects, and how they really seem to have a lot of synergy, just different routes to the same goal. We wondered if the projects might someday merge and allow Babel to use Typescript as another input dialect. I think we lean toward Typescript because of the huge boon that static typing and interfaces can give you to ensure correctness. But I also like the concepts behind Babel and writing to an evergreen ECMA spec. It's almost like we need a "syntax mixin" strategy where we are allowed to take different language elements from both projects and create our own custom input dialect and output standard ECMA-something. I know enough about language design to understand the problems with this, but it would be awful nice :)
async/await... if it ever gets implemented! :)
Have you tried it? :). Check the typescriptlang.org playground. Its looking interesting. I think the sad part about this is we're getting into a gray area where you have to include the code for a promise :(. Which although I think the interface is well defined, will Q be the winner or es6-promises :/
Babel does support Flow-style type annotations (it won't do anything with them except strip them out, but this makes it easy to use with Flow). I was really hoping that TypeScript and Flow would converge on more type semantics, but it looks like they're starting to diverge more now.
well, it does really generate classes, if you target ES6
TypeScript developers can just look at what kind of es5 babel emits for a given construct, and implement that. That's sort of the easier problem than improving &amp; leveraging the type system (it's also mostly a problem for MS that pays for r&amp;d, users don't need to care short of the few months delay in getting the fresh features)
Or look at the variables in debugger
[removed]
I totally dig the sticker. I would never put a sticker on my MacBook mind you (because it looks nice and I'm a bit OCD about keeping it clean) but it is definitely cool.
[removed]
yea, I tried using vs2015 its not bad. This is me venturing into the OS x world a bit. Also it seemed like the same issue with a lot of the nuget packages. I'm using tsd which is backed by the same thing all those nuget packages are made from - definitely typed. WS/unix in general has a lot better node/npm support. There is sadly a path issue with npm on the windows side, to a point to where I don't understand how they can claim windows support. 
There is a roadmap item to add full JavaScript support to TypeScript compiler: https://github.com/Microsoft/TypeScript/issues/4789 Currently TypeScript compiler only supports the TypeScript subset of JavaScript, and the file has to be `.ts`. If that is implemented, TypeScript compiler will be able to pick up JS signatures w/o needing to have definition files. (Actual developer experience TBD)
Libraries and their ts definitions vary in how up to date they're kept. The viability of a typed compile-to-JS language seems to rest on its having type defs for JS libraries. I wonder if there could be a universal type definition format. Are d.ts files general purpose enough for other languages to use?
You get the nice type-safe features from typescript + the nice support of ES6/7 features in ES3/5 browsers from Babel 
Thank you very much! I didn't saw it. I see that it's almost done, so i can use it on my own risk.
What about sourcemaps? Can you generate a sourcemap that maps the babel transpiled ES5 to the original Typescript?
[removed]
I think people interested by typescript already know how to use npm. There should be only typescript specific information about npm, such as type definition files configuration. Especially for fixing npm permissions, this is very specific to the environment (permissions on windows ? linux ? which distro ? osx with official npm, nvm or brew?), and the goal (teaching typescript) is apart from system wide configuration.
I've used TS with grunt, webpack, and the compiler by itself. Honestly, it doesn't make a whole lot of difference what you use since they will use the same compiler under the covers. I would recommend getting familiar with the tsconfig.json since the build tools I've used use pretty much exactly the same configuration format. I'm also pretty sure the compiler will pick up the tsconfig.json no matter which tool you use. If you're not specifically looking to learn how to use another build tool, my guess is gulp will work fine.
npm works on my win10 box.
You can use gulp to compile your TypeScript projects via `gulp-typescript`. It includes its own compiler, so you don't have to download that separately. Also you'll probably want to look into `tsconfig.json` files, which is basically a configuration file for compiling your project's TS to JS. It can work with `gulp-typescript` too. Based on how you have this file configured, you can combine all your source files and/or put them into a specified directory (I do this, and put it in a `build/` directory in my project root). However, it can also be configured to compile the JS files next to their TS counterparts (leaving the concatenation up to you later). Here are some links you may find helpful: [https://www.npmjs.com/package/gulp-typescript#using-tsconfig-json](https://www.npmjs.com/package/gulp-typescript#using-tsconfig-json) [https://github.com/Microsoft/typescript/wiki/tsconfig.json](https://github.com/Microsoft/typescript/wiki/tsconfig.json)
I'm currently working in a large-ish server app but it is unfortunately in a private repo. What I can say is that working with local node modules and TypeScript can be a bit of a trick because of when you need to transpile things and trying to maintain the inter-dependencies. I have a [StackOverflow question](http://stackoverflow.com/q/33239832/207247) open regarding some of the complexity involved but haven't been entirely happy with the answers yet. Here's a quick repo of the [simplified structure](https://github.com/MrHen/TypeScriptNpm) but be forewarned that we had to do things weirdly because of legacy constraints.
Very nice. Setup instructions were really clear as well! Writing a Mandelbrot viewer was one of my first forays into programming... so long ago.
Thanks for the reply! I'll look into it when I get a chance. 
We are not. It seems pretty much like an "all-in" thing... does it integrate the TS transpilation with msbuild?
VS had a default Clean and a Rebuild step for TypeScript back when I was messing with it. See if the normal Clean step nukes what you'd expect. If it doesn't, I would start by looking for an equivalent config for one.
I had the same issue, wrote my own clean script: https://gist.github.com/yesman85/25478d48ca18bcecfadb
&gt; since 1.5 they changed it so it always compiles the complete project instead of just the file you saved Is this true? I have 500+ files in the project (some 100 KLOC) and haven't found any slowdowns when migrated to 1.5.
I migrated straight from 1.4 to 1.6, but when I spoke about the issue at Microsoft they said it's like this since 1.5.
Issue for us is that the CPU jumps to 70% for quite some time, and the IDE becomes very unresponsive.
You sure that's not ReSharper? 
You can use tsc with --watch (the watcher is not broken so I don't think you must use tscw) and have a project working with any IDE / text editors instead of locking yourself with visual studio.
I use tsc in the npm scripts for small projects, easy to set up and the integrated watcher is very efficient thanks to partial compilation. Have a look on "tsc --help" and the tsconfig.json file for more information.
I tried yeah, but am I supposed to watch a whole directory? I tried adding just manual files but then it doesn't know about any references in other files. What about d.ts files? Should these be watched too?
Currently I would not prefer using --save option of tsd, as sometimes you'll need to update the declaration based on your needs. Self-maintained declaration files could be better.
If you are using a 'tsconfig.json' the option you want is 'outDir', you can read more about it [here](https://github.com/Microsoft/typescript/wiki/tsconfig.json). Also you might wanna give Microsoft's [VSCode](https://code.visualstudio.com/) a shot. It supports any OS, and it is really good for typescript and Node debugging. I used Sublime for as long as I can remember, and I've now switched completely to VSCode. 
I actually wrote a post about real-world TypeScript project structure, as a step by step tutorial using Visual Studio Code. But everything except the tasks configuration should be able to apply to Sublime Text with latest TypeScript plugin. https://vane.life/2015/11/22/code-in-real-world-typescript-step-by-step/
The above happened to me too. And not just 'cuz I work there!
As mentioned, outDir in compiler options in tsconfig says where to emit the js files. You can use sourceRoot to say where the ts is. https://github.com/Microsoft/TypeScript/wiki/Compiler-Options Remove the double dashes before putting in tsconfig.
Thanks! will be looking more into this tomorrow :)
Awesome! I'm opting for a more general implementation because not everyone uses vscode. Great resource though :)
I have a little trouble understanding it, but it will be interesting to see how it matures.
I personally use webpack to compile and bundle my whole node typescript project into a single javascript file. Incremental changes to my typescript result in almost instantaneous rebuilds using the webpack-dev-server. I can share my configuration with you if you're interested. 
I was leading a project using TypeScript 1.5, about 20k LOC, not big actually. It's a traditional website with routes, controller, logic modules, data models, etc. And we just modularize like that. TypeScript 1.6 now support node module resolution, which would bring a lot of benefits for modularization by separating a big project into smaller ones. And I am also trying to do something speeding up the debugging procedures. Something like a router supports development-time dynamic loading: https://github.com/vilic/vio
I'm just getting started with typescript but at first glance this looks great. I really dig pattern matching in languages like elixir and have wanted it in Javascript since discovering it. Great job man! 
[removed]
I personally find Gulp a much more flexible way to transpile any ECMAScript2015 or TypeScript into plain JavaScript. Setting up compiling and watching on Gulp might take some time upfront, but pays off very well once configured. It'll also allow you to pin down your versions and upgrade step-by-step (in your case, upgrading to a newer TS dist) using node and npm. For TS I use [gulp-typescript](https://github.com/ivogabe/gulp-typescript/blob/master/readme.md), which might get you started. I use this plugin for compilation per-file at around 50+ files and still close to instant. My final bundle is then built from my source code + jspm dependencies using [systemjs-builder](https://www.npmjs.com/package/systemjs-builder). Hope any of this is valuable to you.
Sorry for the late reply, I think that I'll go with bootstrap and some basic material ui theme with bootswatch. I'll be able to do the job quite simply, and do not have to worry about everything Angular involves. I'll check how to do a basic dashboard with bootstrap, but resources don't seem to be lacking. 
Found my answer. I'll be including definitions at http://definitelytyped.org/ aka tsd, as well as having a file within the module. I hope this helps someone else searching in the future.
Since it's JavaScript, you'd be better off using typical JavaScript extension patterns with it. Your TypeScript should be fine with that. Using ZeroFrame as a basis, you could do something like this: // define constructor: var newFunc = function() { // any setup in here you need. } // Assign ZeroFrame to prototype of new object: newFunc.prototype = new ZeroFrame(); // Define new method on newFunc: newFunc.prototype.newMethod = function(args) { this.stuff = args; } // Override method on ZeroFrame: newFunc.prototype.log = function() { console.log('Stuff'); } Not sure what your IDE is, but Visual Studio Code handles mixed TypeScript and JavaScript projects quite well.
definitelytyped can be a pain since there tends to be only one definition per library, making versioning a problem. I'd love it if module devs included .d.ts files in their modules!
If you are at TypeScript 1.6 or higher, you can include them in the npm distribution. Put a `typings` key in your `package.json` pointing at the entry `.d.ts`. The TypeScript 1.6 compiler will automatically check npm packages and assume that anytime you do `require('foo');` you want to read the typings file referenced in `node_modules/foo/package.json`. This beats uploading things to TSD because: * You can automatically publish it using npm so nothing gets out of sync * People using your module will not have to configure their TSD to grab your typings files * In the future, after TSD is essentially deprecated, your typings will "just work" * It more closely mimics what you would need for local development If you are curious about the inner details, check out the massive discussion at https://github.com/Microsoft/TypeScript/issues/2338 ([specifically this helpful image](https://github.com/Microsoft/TypeScript/issues/2338#issuecomment-101486950)).
[removed]
When you run the tsc command you need to send it all of your files *and* the `tsd.d.ts` bundle file created by TSD. It looks like you were [experimenting with the `tsconfig` file](https://github.com/dmoonfire/mfgames-culture-js/blob/reddit-001/src/tsconfig.json) and that may be the easiest way to include it. That being said, your setup is exactly the scenario I had trouble with back when I asked the StackOverflow question linked above. Since I don't actually publish my npm modules anywhere, I "cheated" and hooked into the `postinstall` npm script and ran the TypeScript compile there. To deal with typings, I ran them at the greater project level and all of the inner projects used a reference to the outer project's TSD bundle file. That obviously isn't ideal for publish npm modules, though, so that may not really help you. I'm not sure what the proper way to "cascade" TSD typings files across dependencies is. Sorry. :(
Yeah, always having fun with that bugger. But I really don't know what I'm doing, I just fumble around until things stop breaking. Takes a while sometimes, but the methodology seems to have worked for a few decades at least. :D I did find [this article](https://medium.com/@mweststrate/how-to-create-strongly-typed-npm-modules-1e1bda23a7f4#.fqmemkcsa) which may answer some of the questions. I'm going to try it and see if that also works. Thank you for your help.
No problem. If you find a working solution I'd love to see it. :)
I had a similar issue to this with Webstorm 10 and Typescript 1.5.
The only workaround I was able to find is to not use tsconfig.json but provide all that compiler options as params in webstorm. This way there will be no error about "TypeError: ts.parseConfigFile is not a function" and it works ok with async/wait. P.S. Voted for TypeScript 1.7 on jetbrains tracker as well :)
Which version of pycharm are you using? it defenetly works for PyCharm 5.0.2 EAP
- Since the original ZeroFrame file is a CoffeeScript class, it's not that hard to convert it to a TypeScript 1. - Of course you don't need to go as far as to convert the whole class to TS but merely describe its members in some ".d.ts" file. - 1st we need to identify which 1s are methods &amp; which 1s are instance variables. - Methods are easy to spot on. Their template is something like `method_name: () -&gt;`. - They'll be described in TS as something like: `method_name()` - Now we need to hunt the instance variables. They're all prefixed w/ `@` or `this.`. - However, most of those can be method calls too! - In order to correctly identify them go 1st to constructor where most of them are born. - For the rare 1s which happen to be spawn outside constructors, just check whether they aren't already methods. - In your particular case, only _@target_ happened to be an instance variable born outside `ZeroFrame`'s constructor though. - Specifying types for members, parameters &amp; local variables are completely optional in TS. - But I tried to guess all of them below. Check it out my attempt for "ZeroFrame.d.ts": # declare class ZeroFrame { url: string waiting_cb: {} next_message_id: number target: typeof window.parent constructor (url: string) init(): this connect(): void onMessage(e: MessageEvent): void route(cmd: string, message: {}): void response(to: number, result: string): void cmd(cmd: string, params?: {}, cb?: number): void send(message: {}, cb?: number): void log(...args): void onOpenWebsocket(): void onCloseWebsocket(): void } interface Window { ZeroFrame: typeof ZeroFrame }
Atom. But Webstorm is more "IDE".
Vs code. I switched from atom due to a lot better typescript support. The only thing I miss from atom is the vim-mode.
I use both Visual Studio 2015 and Webstorm in my day-to-day job as well as personal freelance time. Honestly, I prefer Webstorm. Visual Studio still has issues with slowness and the manifest file means unless you specifically add files to a project, new directories and files are not picked up right away. It's a minor annoyance, but Webstorm has always been good to me.
This sounds like I can check out the source to see its implementation. Thanks for the link! 
In the last 2 years I have changed my changed my day-work language from C# to JavaScript (as many others I believe). In JavaScript I don't need async/await as it is handy in C#. I think that promises solves all my problem everyday.. and from time to time I like to use a plain old callback. I am curious about a performance comparison between these techniques.
Just add a try/catch or a .fail on the every top promise (in this case the result of the anonymous async function)
webstorm is the best. atom is good but it cant be called IDE even with its super plugins. webstorm has best UX. the only thing currently I dont like in it is color schema it uses in darcula there (annoying colors). but typescript support is best I think
vim
It's new to javascript, but definitely not new.
Honestly I found TS support in VS better than in WS! It didn't even understand that these 2 are equal: `new Array&lt;string&gt;` and `string[]`.
I don't know Vue but can you not extend the class and use `super()` in the constructor?
For those new to JSFiddle, here's how: http://i.imgur.com/n2JnpH3.png
I don't know Vue either, and I'm sorry to be the kind of person that will propose something else, but TypeScript plays very well with librairies using a virtual DOM, such as React and Maquette.js (but not riot). In that kind of librairies, the templates are JavaScript or TypeScript code, so they are statically typed and any change in any interface can be reflected in them at compile time. You won't have to verify the html before hand and have type errors at runtime. This property of those librairies is little known, but since my remark does not respond directly to your problem so feel free to down vote.
Yeah I agree, but I think that if the books explains a certain path then it should be explained how to get atleast the dev env up and running. If the author would have worked in Webstorm or Visual Studio then maybe the NPM stuff would have been less relevant.
Yes, ok, maybe a small "up and running" chapter explaining one path from absolute beginner to have our first project, but referencing official documentation or well known tutorial for more details.
I took a slightly different approach. I'm using the new [`typings`](https://github.com/typings/typings) util instead of `tsd`. I'm also adding `babel` to the pipeline to get support for async/await and generators now. You can try out a yeoman generator that I just published with that workflow: [`yo ts-module`](https://github.com/eggers/generator-ts-module) 
I wasn't talking about ts plugin, but for other languages, since there is a lack of support for some of them (e.g. vim mode, linters, etc.). They do have a great toolset out of the box, but it wasn't enough for me.
Atom and vs code show a lot of promise, but I've stuck with Webstorm. I like being able to build with gulp and have any errors links back to source from within the IDE. Also the ability to source debug remote servers and transparently SFTP changes.
Ok, well then I'd say it's a false premise. You don't have to write type definitions for a third party library to use it. You won't get the benefits of static type checking, but at the same time it's no worse than what you'd be doing in vanilla js. 
I dont even know what this is. reads like a statement, doesn't read as a question. Secondly consumption etc. of external JS libraries is pretty well documented. Just have to look a bit. Try google, I hear it pretty good for searching the internet. 
It is a statement, but that seems to be how you ask questions on that site.
I have answered. When you start to use "declare/any" for external modules I wonder if Babel and a good linter can give me better support
I want to take you seriously, but I don't know what "transpiled with a linter" means.
Then you don't use them ... or you update them.
&gt; However, those won't be able to magically give you type-checking on an untyped third party library. I really hope that Typescript will reach your described scenario, but when I tried it in the last year, I had the following problems: - Type definitions are not always up do date to latest library versions or problem between TSD dependencies - You can't find type definitions for all the libraries out there - Sometimes you have to find workaround in a Typescript way (https://github.com/petkaantonov/bluebird/issues/304) I don't want to convince anybody.. I just wanted to see if someone else got frustrated about these things. I like when libraries like Vue and React ships with a dev version with more detailed error messages.
It works fine for any library you want. But if you're using a library without definition files then the transpiler can't type check it. It's not complicated.
"super" is used to access the base class elements. Just try some example and check the compiled javascript, probably helps you understand.
Mozilla's reference for JS **super()**: https://developer.Mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super Oracle's reference for Java **super()** too: ;-) http://docs.Oracle.com/javase/tutorial/java/IandI/super.html
Yes they overlap, I sometime think that TypeScript should have only typing verification capabilities, erase only type information in its output, and leave the ES6 to ES5 features to other tools, but I'm happy to use only one tool to first get the job done, and using another one to have more. Usually I write the tests in TS, but in a recently migrated project, I've left them in pure JS to begin with. I use mocha, chai, or jasmine, and the typings on definitely typed are quite good. Ultimately, it's always the generated JS that get executed and the frameworks are the same, so using TS or not is not really an issue. What TS brings in the tests is auto completion, and I didn't measure it but "pure interfaces tests" are no longer needed, since it won't compile otherwise. The real problem I'm facing now is code coverage, with multiple transformations and sourcemaps, I haven't found a good solution yet. I have the feeling that coverage is not widespread in the JS community, but in my company where we primarily use Java and all the associated tools, not having coverage on a platform lowers its credibility.
WebStorm is extremely fast. Even instantaneous for tool-tips, compiles, error detection, etc. 
Do you have resharper installed?
Never worked properly in any version.
Maybe in webstorm I guess. I have pycharm and always been buggy.
 ///&lt;reference path="../typings/lib.d.ts"/&gt; import angular = require("angular");
I'm on leave and I want to try this out, do anybody know of other typescript stacks like this? Just so that I can compare the different approaches. Does Microsoft have a full stack, Google, etc?
The normal Visual Studio is the worst IDE to use TypeScript.
You can look at this repo, it's not a "state of the art" kind of project but it may answer some of your questions: https://github.com/cybrown/my-music For the sake of simplicity, I am not using gulp nor grunt, tasks are defined in the script section of the package.json file.
It just calls the parent constructor. It is needed for the parent class to perform initialization and also to pass any arguments it needs to it. Generally, you are going to want your parent class fully initialized before you do any of your own initialization in the child class.
AFaIK nTypeScript is updated quite frequently to match TypeScript beta versions. And that's the compiler used by Atom-TypeScript package. If you can't w8, you may try asking for it: https://GitHub.com/TypeStrong/atom-typescript/releases 
[Here's a post](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750) from the creator of Redux that may give you some insight. What you have certainly works but for the reasons discussed in the blog post you may want to consider higher-order components instead, or inheritance in some specific cases.
I liked typescript more because it's object oriented. I wanted a similar experience to android app dev for web dev. This approach in my opinion combines web components, MVC and routing. It's also simpler in my opinion and you don't have to learn a lot of new stuff. 
angular2? Separation of ts, html, css is baked in
I'm working on a single page app, and currently using grunt and grunt-ts to compile. I do like that I also package in my json configurations, compile the sass/html, and everything else with grunt into a production build. However, I started this project before tsconfig.json was a thing, so i have a reference file that's massive, and my compile time has taken a hit. I'm going to be reevaluating my build process in the next couple months, but I'm on some tight deadlines to get it done. Going forward, I'd like to compile to individual files rather than one very large output. I'm not quite sure how this will work with a large single page app though. To the chamber of understanding!
WebStorm. JetBrains has the best refactoring support, by far. Better than anything MS or any other IDE has ever made. For example, they made Resharper and IntelliJ. All of that power comes by default with WebStorm when you code in something like TypeScript. Further, it auto-compiles everything continuously and instantly when you make changes. TypeScript is a huge win. 
Using the wrapper with exports is what you need to do if you want to use external modules. The updated syntax of namespace would be wrapping the contents of each of your files with a module of a common name. You'd need the references but you can throw them all into a single files so you only need to add the one reference. http://www.typescriptlang.org/Handbook#modules-splitting-across-files
I know basics of javascript. I also have some experience with java. I have reasearched TypeScript a fair bit with the intention of learning angular 2. I just bought the angular 2 book (https://www.ng-book.com/2/) it has exclusively typescript examples so i plan on working through it and using google for w.e. i dont understand it assumes a fair bit of knowledge or atleast moves very fast from the basics to the intermediate.
To me, it's more of a workflow to work up with how you want your preprocessors to work, modules or not. Otherwise it's as you say, pretty much just add types to es6. 
[removed]
Check out this [video](http://youtu.be/C0F2E-PRm44). She uses Karma with Jasmine.
[removed]
Try "./TestClass"
I went through 4 solid days of trying to figure it out last week including abandoning it for ES2105 before coming back to it and finally getting it all working. I skimmed your post before but let's see... You don't need the &lt;/// reference to TestClass in App.ts. I don't think you need the node reference either but I don't know what you're working on. In TestClass use export **default** class. export default class TestClass{ And instead of import testClass = require("TestClass"); use: import TestClass from "./TestClass"; If you run into anything else just post again, you're really close. There's a lot of old and incorrect info around on the web and it's really hard to find accurate current info. 
Thanks!
Created this since I couldn't find any solution for what I was doing. Hopefully it helps some people!
If you want to use typescript, you've got two options that I know of. One, build using Cordova. It is basically a Web page stuffed into an app. The other is nativescript. You can write in typescript and compile to js. On mobile, so I can't offer a more detailed response, but the latter will give you native functionality and performance. 
Ty dude, this is perfect. I have used the ng2 book until now and it's really good. Will look at this for sure.
I also just remembered that T4 (.tt files) templates can be compiled into a DLL, maybe you can look into compiling a custom TypeLite tt into a DLL.
It's not hard, you write the definition according to the API documentation. If there is no docs you can try to rely on the auto complete of your IDE, otherwise you will have to figure it out from the Javascript code.
I've had to do this a couple times. I wouldn't say it's easy, but it's not hard either. Just takes a little bit to grasp the concept of it, and the difficulty mostly lies on how easy it is to figure everything out about the library you're using.
&gt; If you want to perform multiple things when componentWillMount as three separate mixins, how do you do it? Typically the latest definition overwrites the earlier ones. It seems i misunderstand how mixins work. Aren't methods just called one after another? (that's how it's done in my snippet) I don't see technical difficulties to have multiple mixins with one life cycle method inside one component - just wrap method if it exists in every mixin or have internal service queue. As i understood the main claim to mixins is that all these mixins can change internal state of component. Should i create a proxy for life cycle method inside `HOCLifecycle` or how will it be proxied otherwise? Create proxy for each higher method and then optionally override it? Do i understand correctly that each higher order component makes react component tree deeper? How do you think will it give notable performance penalty?
There is no standard well defined way that mixins work (in JavaScript) when mixing in two traits with the same method. The best mixin implementation I've seen is this: http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/, but it has other issues. Namely that if you want to mix new behavior, you need to call the super function in order to get it to actually call them one after the other, as you stated. I.E. you need to do this: const myMixin = superclass =&gt; class extends superclass { newMethod() { super.newMethod(); /* implementation here */ } } Well, if the superclass doesn't *have* `newMethod` defined, you need to wrap it: const myCheckedMixin = superclass =&gt; class extends superclass { newMethod() { if (super.newMethod) super.newMethod(); /* implementation here */ } } That may not look so terrible, just an extra line of boilerplate, but it limits what you can do. If you want to use some standard mixins they all better have this boilerplate, and if they don't they aren't necessarily safe to use. As for your last point about performance, there's going to be some kind of chain in each case anyway. In the mixin style there is a prototype chain which can get long -- that's bad for performance, too. In the HOC style the prototypes are flat (more or less), but you have object chains. Which one is more performant is going to vary from app to app use case to use case. There are going to be instances where each will do better than the other. As you pointed out, there may be other mixin implementations that queue things and have a flat prototype, and those may very well be more performant, but right now the approaches with the best tooling and support are the HOC wrappers and class mixins. Typescript can only support HOC wrappers at the moment, so if you're using TypeScript I'd recommend it for that reason alone.
Exactly. That's just for React components, not more. I generally don't call component methods from outside, just render it. And specific logic for React life cycle methods is a little convenience. This approach seem to satisfy my needs (though i didn't use it a lot yet) however i had the same feeling about mixins and suddenly they are undesired and unsupported approach.
Another day... another way to create Typescript typings from C# code. Last week: https://www.reddit.com/r/typescript/comments/3zr61x/gulp_plugin_for_converting_c_pocos_to_typescript/
Meh... I do not want to be inpolite, but I have seen quite much attempts to build systems that will be generating CRUD wireframes including UI, but they were not succeed. IMHO, everyone has to develop its own solution for that since we all are using different approaches and different system design templates for our CRUD systems. 
As far as I know, there's currently no way to import JavaScript without a module declaration. I don't think it has to be in it's own .d.ts file, and it doesn't have anything complex. A simple example would look something like: declare module 'mod' { export default mod:any; } And of course, definitely checkout [DefinitelyTyped](http://definitelytyped.org/) for existing typings if you haven't already. 
It would be easier to advise you if you posted your whole source (or a [Minimal, Complete, and Verifiable Example](https://stackoverflow.com/help/mcve)), not just bits and pieces. Look at /u/riventropy's post - having the full source would have answered all those questions right away.
Thanks for the insight about submodules. I know that a lot of people don't like them for various reasons. Yeah, .gitignore *.js is my best friend since I don't generally like storing generated artifacts in my repos. `npm link` is another possibility I will make sure to explore. It should solve the problem of needing to compile files outside of the natural source root in A &amp; B.
Wow, thanks for the detailed response. I believe I understand your workflow and it makes a lot of sense. Downside is that it's really far from what my team has been doing up until now (which might be out problem...) but it might mean a lot of retraining of old habits. Problem #1: We're only really leveraging npm as a "git repo injection tool" for submodules right now. As in, we dont even bother doing npm publish, we just have a line like: "dependencies": { "my-shared": "git+ssh://git@bitbucket.org/me/my-shared.git" }, which sucks the whole repo right into node_modules. So there's not really a "prepublish" step for us. Problem 2 is that we've been conditioned to think that checking the compiled JS into the repo is never good. Therefore we wanted to figure out how to compile the shared code IN THE CONSUMING PROJECT, (after npm install of shared is done). I did manage to do this with calling tsc from postinstall script in shared's package.json, but again the NPM folks warn me not to do this. :) Problem 3 is that the developers like to run gulp connect or lite-server to just preview the main app without doing any rollup (with browserify or what have you) so Im not sure how one can load the shared .js files other than from loading http://node_modules/my-shared/src/shared.js ... which again seems wrong. Any ideas? It feels like we either have to really switch our workflow or else abandon the shared module idea.
It doesn't have all the bleeding edge stuff that Babel covers but it handles a lot and the type system is worth it if you ask me. I refactored something the other day and was struck that I never would have tried it so casually in pure Javascript as I wouldn't be confident that I had caught everything. That tells you something about my tests but I'd rather write type annotations than tests for everything. That said, currently I wish Typescript supported React stateless function components and the ES7 spread operator. I haven't noticed anything else that I'm missing. 
Stateless components are supposedly coming in the next version, which is probably only a couple of weeks away. I think the ES7 object property spread is a while off yet.
I use the same and it works fine if you use the source map preloader. I'm using it the same way as this demo: https://github.com/onybo/webpack-react-typescript-demo/blob/master/simple/webpack.config.js#L9 I switched my devtool setting to source-map instead of leaving it as eval, though.
I'm working on a side project with typescript and webpack right now. Happen to know if there is a way to use webpack to handle all of the typescript transpiling without having all of the files declared in the typescript config file? 
Go for it. Seriously. The amount of time saved with strict typing is beyond worth it. The build process becomes a natural part of development. 
What does typescript have to do with Galaxy? 
I started using `typings` for a while know. I really like it, not only because it requires less overhead to get those packages that hadn't updated (I just throw them in my typings repo to test), but the whole ambient/non-ambient was nice.
So any so you want to go to a fluent binding? 
What an incredible release.
But that's not the standard way to do that any way. That's an anomaly. You shouldn't use the "new" keyword with a function like that. You should define a proper constructor. Otherwise, with your example, this is better: var x = X(); // result: x === {} Using the new keyword does not return a new instance of X, but just the result of the function. Not what any user would expect.
I've been struggling during a similar project. I'm not sure what your issue is without some code to look at, but for me it was import resolving improperly. I started using jspm to resolve my npm packages and it now works correctly. I think you could set something up with System.js on your own but jspm takes care of that for you so I wouldn't know how to do that.
A couple of questions: * What IDE are you using? * How are you compiling the TypeScript, e.g. straight through tsc, gulp-typescript, whatever
Some people has asked for it in the past and they can be considered "more developer friendly"
I think most people compile to ES5 output for real use, so consider it ES5 features plus most of the **syntactic** features of ES6, some of ES7. You get things like ES6 template strings and ES7 decorators that are transpiled down to ES5 equivalents but you don't get ES6's expanded standard library (so no Array.includes). 
What a shit article. It can be summarized as, "Use d.ts files"
Thanks. I've been trying to build a good VS Code and Typescript workflow for the past few days.
But I'm not instantiating it, I have a page with a map, where I do it, and it all works fine, and another one, where the user should just log in, and it is on the login page where the error happens.
I used to use AMD modules and load them with require.js for development/bundle them with r.js for production, but I switched to using CommonJS and bundling them together with Webpack. With r.js, bundling was damn slow, so it was only done for prod, but Webpack manages to do it much faster so it's always on. Plus, using CommonJS allows integration with node-based tools like Jest.
I just scrapped typescript all together over this in favor of just writing the js that would have been generated and having solid tests. Much happier with my life now haha.
I'm sorry for negativity (and thanks for open sourcing code), but 35 lines of real code, with 19 files of gulp, travis, vscode, npmignore, gitignore, tslint, typings, package, license, interfaces, 200-line test, etc. to replace one line: ``` return !deepEqual(nextProps, props) ``` seems like over the top.
Thanks - trying to edit
Great link. Lots of effort put into this.
at first i was like, implicit returns, at least ( i thought it's like in scala).. but nooo :( welp, still useful at least somewhat. But we really need a final keyword or override keyword for methods , i can't even count how many times did i screw myself, by unknowingly overwriting a method.
I thought that the compiler accepting functions which declare a return value but don't have return statement, was in fact a bug. function foo(bar): number { console.log(bar); } The implicit 'return undefined' returns a valid number, string etc because these types include undefined and null. I'm glad that this can be flagged as a compile error now. 
[removed]
Why would you want that? You can just do `return console.log(bar);` if you really want that behavior. Also, a lot of my functional code omits returns ES6 style, semi-implicitly returning the "last" statement: let foo = (bar): number =&gt; console.log(bar); Typescript correctly throws a type error: error TS2322: Type 'void' is not assignable to type 'number'.
[GIFV link](https://i.imgur.com/uzuEneW.gifv) // [FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot)
Is it worth the $100 price tag? 
Worked like a charm. Thank you! A shame I couldn't find it myself on my googling journey. :)
If you are using SystemJS and the latest version if TS then the syntax is: import MyClass from '../relative-location' or import TheirClass from 'named-module' or import {justAnExportedFn} from 'named-lib' or import * as Lib from 'named-lib'
While this might seem like a good idea, comparing objects deeply can turn out to cost as much or more than a render. `shouldComponentUpdate` is best used with immutable data or when you can make a shallow comparison. 
I use gulp for watching. Works fine for me.
The TypeScript plugin in Atom automatically compiles files when I save them. So I'm good. 
[removed]
sure, i'll comment there, but i think the issue already reported in some other issue
Not merged yet but looking absolutely fantastic for some future version. The ambiguity about the type of `this` (and its tendency to be implicitly `any` even when you've asked the compiler not to do that) is one of the most irritating holes in the type system. Hope this goes live soon.
`this` in javascript is so braindead. I was so happy when `=&gt;` arrived. Now, any time I have any question about what `this` is, I declare the function with `=&gt;`, and the problem is solved. It's nice to have other options, but I prefer `=&gt;`, though I recognize this new feature will allow some different use cases. 
I avoid the whole problem like this. class C { foo = () =&gt; { ... } } // do whatever you want! no surprises
In which case, just do this: function C() { return { foo() { ... } } } That way, any private data you declare inside `C` will genuinely be private (at runtime, even). The only real comparative advantage of `class` is that it supports implementation inheritance, which isn't necessarily a good thing as neither JS nor TS has the necessary features to protect against brittle base classes. Another supposed advantage of class is that it shares all method definitions via the prototype, reducing the size of instances, although this isn't really much of an advantage in most apps.
The [Wikipedia page](https://en.wikipedia.org/wiki/Fragile_base_class#Solutions) mentioned Scala's `override` keyword, but didn't mention that this [was in C#](https://msdn.microsoft.com/en-us/library/ebca9ah3.aspx) four years before Scala's first version! So I've fixed that page. And C# (and VB.NET) are *very* mainstream languages. Many books recommend against implementation inheritance, though they tend to be Java books, and Java has no protection against brittle base classes, so maybe that's why.
Disclaimer: I've never programmed in TypeScript, or ran this code. type AbsolutePath = string; type RelativePath = string; private _foo(): Map&lt;AbsolutePath, RelativePath&gt;(); Taken from https://blogs.msdn.microsoft.com/typescript/2015/01/16/announcing-typescript-1-4/ Also known as type aliases.
Thank you.
Yep that works, however on a compile error it still mentions the (inferred?) string, so no mention of RelativPath. Also the code completion for the "set" method in vscode still shows up as (key: string, value: string) Would be cool if it could show the type aliases instead in those cases, like it does when you try to assign the wrong class. But it's a start, cause if I ctrl+click on RelativPath it jumps to the type alias.
Microsofts own Visual Studio Code: https://github.com/Microsoft/vscode A testament to the power of TS
Pivot: https://github.com/implydata/pivot
~~Angular 2: https://angular.io/~~ edit: the typescript compiler https://github.com/Microsoft/TypeScript
whoops, missed that.
no problem, thanks for linking it though! :)
Try: https://github.com/trending/typescript?since=daily
Not a *big* open source project by any means, but you can check out [this tool](https://github.com/martellaj/commemoji) I wrote using Node and TypeScript. I think it's decent for learning because it's clean, uses a couple of popular Node packages, and it easy to understand.
This is currently not possible in a nice way. This would be known as "nominal type matching", which TypeScript does not yet support. It's planned for TypeScript 2.2. You can find more information, and a few (shitty) workarounds here: https://github.com/Microsoft/TypeScript/issues/202
RxJS https://github.com/Reactive-Extensions/RxJS/tree/master/ts
Well I love being able to use ES6 - 7 and just running it through the loaders without changing any code. And the live module reload is a blessing for a project as big as mine. Also, I use RactiveJs and I can just directly require the template files and it'll automatically convert them into JavaScript same with sass. It lets me think more in components with all the resources for that component in the same folder and just importing them in. 
I prefer WebStorm. VSCode is really good and eye-candy, but WS is an ultimate weapon for every task (at least, for those I faced). And it's really cool, that they have EAP versions (pretty stable tho) for free.
I haven't read it, but it is, by definition, _super_ out of date. Any book written for a fast evolving platform will have the same problem. You'd be better off with an online resource (you can print it if you want, or save a PDF and read in an ebook reader I suppose). * The [official Wiki FAQ](https://github.com/Microsoft/TypeScript/wiki) is a great start that came from, and (I assume) will eventually replace, the [online handbook](http://www.typescriptlang.org/Handbook) (which is really becoming out-of-date). * [TypeScript Deep Dive](https://www.gitbook.com/book/basarat/typescript/details) is a great introduction to the language by Basarat Ali Syed. It really reads like a book and there's ebook versions. * Finally, I suggest reading [the specs](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md), or at least having it as a reference. It may be dry, but it's well written and kept up-to-date.
&gt; besides Angular 
Do you know javascript already? If so, then you can just read the official docs to learn it, otherwise I would learn javascript first and then go into typescript.
How well do you know JavaScript? If you're not a beginner just go to [http://www.typescriptlang.org/Playground](http://www.typescriptlang.org/Playground) and look through the examples, play around, you'll get the hang of it quickly as it really is just JavaScript with type annotations
Ionic 2
Glad you got it figured out! You can get rid of `default` by just using `export` instead of `export default`
Yep, I started out with system. I tried amd when I couldn't get that to work. Now that I have amd figured out I should go back and try getting it to work with system..
OK. Should be just System.import() call in a script tag in your index.html (after loading systemjs and your bundle of course)
Can confirm: about two weeks or so ago, I switched my employer's Typescript SPA from webpack to just typescript. Compile times dropped substantially (because just-TSC's incremental builds are much quicker than webpack+TSC) and the whole setup is much simpler. In so doing, I had to introduce SystemJS (because we were using webpack to spit out a file we could just include with a script tag), but that was a tiny change that wound up making our app's boot-up process less opaque.
I've given it a try and it works well. However, I'm concerned about the reliance on system.js to run. Webpack would basically create a self-contained bundle, but now we depend on system.js. Considering that system.js module loader is about 5000 lines of code while webpack module loader is 50 lines of embeded code (in the created bundle file), what is it that makes system.js require 100x more code to do what I would call "the same thing"? Is there any way we could have the same lightweight result as webpack while benefiting from the "system" module? I'm asking this as a developer of a gulp asset pipeline. Using webpack is simply a matter of adding a node/package.json dependency, while in the latter we have to inject the system.js library in one of the user js bundles.
More like: &lt;script src="app.js"&gt;&lt;/script&gt; &lt;script&gt; System.import('app/main') .then(function (m) { m.myMain() }) &lt;/script&gt;
Webpack also let you require CSS and image files (and whatever else you could find a loader for) in js files to move the CSS closer to where it's being used instead of having one big monolithic CSS file. Doesn't seem like the TypeScript compiler has anything like that.
OTOH, if you are using less / sass you may not care about that (as you can keep lots of small style files around and import them)
I guess that's better.
It's not mine it's from the official angular 2 tutorial, that was my whole point the way they do it seems clunky to me.
Sure, I wasn't blaming you on that, just a lazy typist on a tablet ;). I guess angular examples use that approach to make them work in Plunker &amp; the likes. 
We have found that it is not yet clear how to do the whole job for production builds this way; but it is worth the effort of setting up even in development because it is so much faster than any other approach we have tried (the most common ones, WebPack with ts-loader, SystemJS with JSPM with TS-in-the-browser). 
Yes, and it works quite nicely.
I tried AMD/require.js successfully as well. require.js minified is about half the size of system.js and the AMD bundle is a bit smaller than the system one. &lt;script src="require.min.js"&gt;&lt;/script&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;script&gt; require(['main'], function(m){m.start();}); &lt;/script&gt; 
Turns out I made I typo in my `tsconfig.json`. I had `modules: amd` instead of `module`. :( So brunch was defaulting to commonjs output. And apparently brunch (or maybe brunch-typescript) includes a micro loader for commonjs? That's how my require statement was working without actually including any more libraries. I tried it again with amd, and system but both complained of undefined functions. So I guess I will stick with commonjs if I don't want to include another library. Phew! This is a lot of rigamarole. 
The idea is that it is unlikely that an ordinary string is going to just happen to contain an exact ISO date string, as it's quite a fussy format. If you are concerned that this might happen for some property in the JSON you can declare its type appropriately: interface A { maybeADate: string|Date; } The TS compiler understands typeof checks and preserves type safety. Check out "union types".
What's the problem with your production builds?
Yeah, the lack of module reloading is what's keeping me away from what the author is suggesting. Sure, I notice this lag between hitting save, and then seeing the browser refresh, but, at least, I don't end up having to click through my app in order to get back to the original state before I hit save.
I don't really like the idea of assuming something should be a date just because it looks like one. Not to mention, I have other class instances that are not as easily identifiable by their string representation. Also, I wouldn't want to use a union in a place I know there should be a specific type. Then you have to use typeof everywhere. 
It's not a problem per se, just something that is not in typescript yet. I'm talking about the overall production build process of gathering up lots of individual files / modules from all over your node modules directory and bundling them up together. Typescript just bundles up application code so far.
Yes, excellent, I will switch to that also.
Of course it may not work for data generally. But specifically for ISO date format, it's a very particular format that is very unlikely to mean anything other than a date, so it's widely used as a safe assumption that it can be round-tripped as a date. This is how its treated in a lot of client and server side frameworks.
Yeah, that makes sense. In my case, I wanted a pattern that would work for all scenarios. Also, someone else commented that if I rename the encode method to toJSON, JSON.stringify will automatically invoke it.
I've updated some parts of the post based on feedback. Can I get your thoughts?
Seems to be down at the moment.
Seems to work for me, maybe your trying to access it with https?
You could just subclass String with AbsoutePath and RelativePath subclasses.
Oh nice, I was looking at the PR earlier today. Cool to see it merged.
Is this a typescript 2 feature?
But... what will Flow followers complain about now? I kid, I kid. Convergence!
lol, ikr
http://www.typescriptlang.org/community/friends.html
&gt; Previous baggage: if you or the majority of the team come from a strongly typed language like C# and does’t really want to go JS all the way, TS is a good alternative. Eh... while I agree that it is way easier to go from C# to TypeScript than it is to go from C# to JavaScript, I question calling previous experience "baggage." &gt; The old Microsoft used to take something that is standard and add proprietary non-standard stuff to it and try to force developers pick one. Typescript is exactly the same thing to Javascript. This isn't really true. TypeScript and JavaScript play just fine with each other and nothing suggests you need to stay in TypeScript-land once you've entered it. &gt; When you’re better off without Typescript? I'm surprised that they didn't mention the external typings quandary as an explicit negative. The biggest issues we had on our team were dealing with external typings files. [Typings](https://github.com/typings/typings) looks a little better than TSD was but it still doesn't "just work" yet. &gt; Extra transpilation tax This is accurate but I wanted to point out [ts-node](https://www.npmjs.com/package/ts-node) for those of you who haven't seen it yet. This allows node and similar tools to run the transpilation as needed. I've been using it to run mocha tests and it helps ease this pain a bit. ---- All told, the author gives what I feel is an accurate overview of the whys or why-nots of using TypeScript. There is a time and a place for it but I feel that teams better have good answers to these questions: * Why TypeScript over just JavaScript? * Why TypeScript over C#? There are very good answers for both but those answers aren't the right answers for every team and project. I *will* admit that I don't think I would have converted 18,000 lines from JavaScript into TypeScript. Yeesh.
&gt; The type system is like helper wheels. It keeps you from falling at the price of slowing you down and limited maneuver Starting with this is nearly enough to make me stop reading. A strict type system is not helper wheels. It's not something you need while you're learning, only to be discarded later; it's not going to slow you down. Instead, a type system allows you to move *faster* because you know where you're going. A better analogy, in my option, is to using a map when going from point A to point B in a city: you will get there without a map by just driving in the general direction, and you're free to take whatever route you want. But using a map where you can see the best path allows you to be there *faster* and *safer*. It "limits" you in the sense that it shows *where you should go*. It reduces the amount of errors. The amount of time you need to spend making sure you have the right type fed into something (duh?) is vastly overshadowed by the amount of time you can spend finding an error caused by a typo or a wrong type somewhere in JavaScript. &gt; Performance penalty There is no "performance penalty" just because one is using a language that offers you more features. I'm having a hard time understanding this point as it makes no sense. If one wants to ignore enums and inheritance, the language is not forcing that into the developer; the generated code doesn't pass everything through a filter or anything. &gt; it’s quicker to set up something in Javascript I'd argue the opposite. Both TypeScript and modern JavaScript suffer from the massive analysis paralysis one can have when setting up building tasks for a new project and deciding on what to use (webpack? gulp? browserify? npm? etc) but development is much more agile in a language like TypeScript exactly because you know you're not going to break your house of cards that easily. In my opinion, this list looks it was written by someone who haven't (or barely started) using TypeScript or other similar languages/platforms. Interestingly this article does not touch on TypeScript's biggest *actual* problem for projects, the need to rely on definition files for JS projects and how that can be problematic for projects that go frequent updates. He/she mentions it briefly, but the fact that it is mentioned in a positive light means they didn't really spent much time with it (and just to be clear, to me it's more of a "neutral", since it's a necessary evil for a greater good, but still problematic by definition for projects that don't auto-generate it).
Yeah, but that's the conundrum: you can do it, but then there's no advantage to using TypeScript (in regards to that specific library). In an ideal world very library would be created in TypeScript.
Lovely stuff on the way, the `strictNull` demo is excellent.
I'm just happy to hear 2.0 will be the next version. It feels like we've been waiting for await / async downlevel forever, and it'll be nice to drop Babel from my toolchain (purely for performance reasons, I love the tool). I also didn't know I needed strict null checks until I watched this, so it's a good watch.
Thanks, I think it's better to have more checking be the default but I guess for compatibility reasons perhaps.
Like the demo says, switched on with a new compiler flag. It introduces a whole new level of checks so if it defaulted to on then the 2.0 compiler would reject probably 99% of existing TS source.
 You'd probably want to call it with `.call(this, ...)`. var View = (function () { function View_compileTemplate(template) { var str = ""; return str; }; function View(template) { var c = "var arr = []"; var pointer = 0; var str = View_compileTemplate.call(this, template); } return View; }()); 
I watched the video before I posted. Let me elaborate. Usually, when designing or improving on a language... a choice made early on makes it really difficult to add a large feature like this. This friction tends to prevent these features from happening. They were able to implement this without having to change the language in any big way. I am still very impressed. 
Next step: get rid of gulp and just call tsc and sass in npm scripts.
Given the tasks I have in this project, that actually seems totally doable.
Will the fixed up code work with the new compiler w/ feature turned off? I guess it has to, otherwise we will need perma-fork of everything
Do you mean import {stuff} from "node_modules/lib/file"? If so, I think it is technically possible, but it would break the "dev" workflow of dynamic loading. The TypeScript bundling process can import files from wherever though.
Please do not spam. A link without an editorialized title should be enough. Not [flooding reddit with it](https://www.reddit.com/user/1-2-3-4-5-6--).
I'm not clear on the exact problem. If you're converting your methods, do it inside modules. interface UserContext { // context fields } module myNameSpace.AJAX { export function myBooleanMethod(params: myBooleanMethod.Parameters, success: (result: boolean) =&gt; void, failure: (fault: any) =&gt; void, userContext: UserContext): void { // Implementation } export module myBooleanMethod { export interface Parameters { // parameter fields } } export function myStringMethod(params: myStringMethod.Parameters, success: (result: string) =&gt; void, failure: (fault: any) =&gt; void, userContext: UserContext): void { // Implementation } export module myStringMethod { export interface Parameters { // parameter fields } } } If you're using your JavaScript functions in TypeScript and you need to declare existing JavaScript objects, you could do it like this: interface UserContext { // context fields } interface API { [methodName: string]: (params: any, success: (result: any) =&gt; void, failure: (fault: any) =&gt; void, userContext: UserContext) =&gt; void; } declare var myNameSpace1: API; declare var myNameSpace2: API; // and so on (That's a quickie solution without full type-checking for parameter and result types, but it could be a precursor to a more detailed declaration.)
That helps with the context, thanks. I may be able to build on that. Meanwhile, to provide more explicit examples: First, I found another, simpler, reference to what we are doing: http://weblogs.asp.net/dwahlin/understanding-asp-net-ajax-web-service-proxies (It's from 10 years ago!) In javascript, we have a method like this: function PopulateCallNotes(CallID, CallDetails, CustomerID) { MyNameSpace.AJAX.CallNotesLoader(CallID, CallDetails, CustomerID, SucceededNotesCallback, FailedCallback, "UserContext1"); } This calls a .NET Web Service method that is exposed to javascript via an ASP.NET ScriptManagerProxy pointing to the Ajax.asmx page in the project. &lt;asp:ScriptManagerProxy runat="server" ID="scriptManagerProxyId"&gt; &lt;Services&gt; &lt;asp:ServiceReference Path="Ajax.asmx" /&gt; &lt;/Services&gt; &lt;/asp:ScriptManagerProxy&gt; The proxy generates the javascript methods needed by our code, allowing our AJAX call to be a single line as above. The problem with converting to TypeScript is that it has no context to understand `MyNameSpace` as valid. I'm trying to find the simplest way to give it that context.
Do what /u/mcalesy said at the end of his post, write a .d.ts file declaring these namespaces and methods for the TS compiler.
Using npm scripts is fine. That's [what RxJS does](https://github.com/ReactiveX/rxjs/blob/master/package.json). The downside is that for anything more complex you have to use platform-specific commands like `rm -rf` so it wouldn't work for Windows.
After struggling with trying to get the declarations right to make my .js file (now as a .ts) work with the js classes generated by the ScriptManager, perhaps there is a better way? What is the simplest way to handle AJAX async calls in TypeScript? The examples I am finding end up being pretty complicated, mostly because they appear to build up from a direct raw GET or POST. Is there a TypeScript way of handling these calls?
&gt; function sword(material: Material): Weapon { &gt; return { material }; &gt; } Should be: function sword(material: Material): Weapon { return { material: material }; }
 function sword(material: Material): Weapon { return { material: material }; } is equivalent to: function sword(material: Material): Weapon { return { material }; } In ES6, which typescript can (mostly) understand. This could also be written as an arrow function, which can help to illustrate the simplicity of the factory: const sword = (material: Material) =&gt; ({ material });
Additionally, whenever you want to start splitting up your code, you [can just use modules](https://np.reddit.com/r/javascript/comments/4bbtlg/the_current_state_of_dependency_inversion_in/d17th2u). Javascript's modules are *not* namespaces and can act as a layer of indirection, just like DI would. 
Try my version and see what happens (unsurprisingly, for an example that long, I wrote it in VS Code).
Really? It doesn't come across that way. It would be clearer to note the terminology change at the start and then use the modern terms throughout (particularly in the title!)
Thanks for the feedback - I'll edit the post and hopefully clarify earlier on!
http://devdocs.io is marvellous
That's for the next version, no idea when that is released though.
There's a not-widely-known feature of TypeScript's existing module resolution that is similar: a JS package can include a `d.ts` file so that when you `npm install` it and `import` it in TS, it all just works. Example I submitted to immutable.js (please upvote it!): https://github.com/facebook/immutable-js/pull/808
Yeah that makes sense. If you npm install a package and you have node_modules included in your tsconfig then you would get any .d.ts files it pulls down.
Huh, you're right - apparently the trailing slash matters :S I'll see if I can fix that, and meanwhile resubmit. Thanks for mentioning it!
Good collection of tips, thabks
Great! I really love this, getters and setters are some of those things that I would like to do automatically however I've been lazy to make something like this Thank you very much!
Usually i'm also too lazy but now the amount of manually typing these things put me to a point where I was using public variables in classes.. just to omit the getter/setter-drag ;-) In the near future I will also add a constructor-generator and the ability to hide already added getter/setters. After that.. I hope someone has already made an auto-import extension ;)
Background: we switched to using this approach earlier, as described in https://medium.com/@vivainio/with-latest-typescript-you-may-not-need-webpack-417d2ef0e773. /u/enaukkarinen extracted the functionality as an easy to use boilerplate for another team to use (with a good "no bloat" philosophy). If I were starting a new ng1 app today, this is the boilerplate I'd use - as it strips away all the outdated stuff used in most older boilerplates.
The boilerplate has Less compilation + less sourcemaps through gulp-less. That stuff you just need to watch in gulp. Third party libs are just concatenated together and shipped as separate .js file
I always found "Hello World!" examples annoying, so I'm kinda glad.
I haven't tried it, but it's all just JavaScript, so it should work. If it doesn't, that would be a bug in Babel.
Absolutely possible. I set this up recently at work and by god it's so much easier and readable to use awaits than thens. Our build is managed by webpack. Hopefully I can narrow down the minimum amount of components and get back to this thread. Maybe the only annoyance is the final JS looks less readable than if it were all then chains. The babel polyfill separates the calls into different blocks of a state machine implemented with a switch statement, but it's not unreadable when debugging.
Hey thank you for this comment! First of all I am already used to this because I am already using babel with stage-0 preset and polyfilled async/await. I see stacktraces not ideal but quite readable, enough to track down exception if its needed and I dont really need to see whole source code as it is already bloated with __webpack_require and unreadable ES6 class definitions transpiled to ES5. The question is how and if it is good idea to add TypeScript on top of that as a webpack addtional step, because I already use async/await with webpack's babel-loader both in node.js and frontend development and it works great even with its downsides.
Yeah I used it to transpile es6 imports before node implemented them.
Yes, here's the relevant lines from my Webpack config: { test: /\.tsx?$/, loaders: [ `babel?extends=${path.join(__dirname, '.babelrc-dev')}`, 'ts', ], include: path.join(__dirname, 'client'), exclude: [ path.resolve(__dirname, 'node_modules'), ], }, Here's my `.babelrc-dev`: { "presets": ["es2015-native-modules", "react", "stage-0"], "plugins": ["transform-runtime",["react-transform", { "transforms": [ { "transform": "react-transform-hmr", "imports": ["react"], "locals": ["module"], }, { "transform": "react-transform-catch-errors", "imports": [ "react", "redbox-react", ], }], }]], } And my `tsconfig.json`: { "compilerOptions": { "target": "ES6", "jsx": "preserve", "experimentalDecorators": true, "allowSyntheticDefaultImports": true }, "exclude": [ "node_modules", "typings/browser", "typings/main", "typings/browser.d.ts" ] } So it applies Typescript's compiler first, generating ES6 (and preserving React JSX code), then Babel generates ES5. Note this is my dev build, so it includes hot module reloading (which works!) and the like. *Why preserve JSX?* Babel has plugins for production simplification of React code. *Why react-transform-hmr?* Hot module reloading works great even in Typescript modules. *Why so many tsconfig.json excludes?* I use `Typings` to import typings for VSCode autocomplete/intellisense but if I don't add those excludes I get duplicate declarations. 
Thats great thank you. You could be intrested in awesome-typescript-loader package which seems to address issue of compiling TS-&gt;ES6-&gt;ES5 automatically and claims to be more performant. I'd have one more question. I have quite large project that I would want to incrementaly transform to TypeScript, but unfortunately I have one problem. In my webpack config I used a resolve: { moduleDirectories: {...} } utility and I set resolution from ./src directory. It look like this: resolve: { modulesDirectories: [ 'node_modules' , __dirname + '/src' , ] , extensions: [ '' , '.js' ] } , And I am using absolute path from src on my all imports. Like, when I have file ./src/controller/a.js and ./src/model/b.js I am refering b.js in a.js like this: import B from 'model/b.js'; It works perfectly with webpack and babel and even typescript loader for webpack understand this, but unfortunately not Atom IDE. It just claims that b.js does not exist and it is quite right in terms of standard typescript module resolving. And I am left with error and no code completion from this module, even though webpack understand and compiles this correctly. AFAIK Atom just uses tsd to validate project files, is there a possibility to specify something like "base path" in tsconfig.json in order to make IDE understand whole thing? Or should I replace all absolute paths to relative, which I dont like because it feels so unreadable to me with ../../../../ all over the place.
Thank you!
Here's my gulp config var gulp = require('gulp'), merge = require('merge-stream'), uglify = require('gulp-uglify'), babel = require('gulp-babel'), sourcemaps = require('gulp-sourcemaps'), typescript = require('gulp-typescript'); gulp.task('build', function () { var tsResult = gulp.src('src/*.ts') .pipe(sourcemaps.init()) .pipe(typescript({ target: 'ES6', declarationFiles: true, noExternalResolve: true })); return merge( tsResult.js .pipe(babel()) .pipe(uglify()) .pipe(sourcemaps.write('.')) .pipe(gulp.dest('build')), tsResult.dts.pipe(gulp.dest('build')) ); }); 
That's it? Yeah I need to ditch grunt.
Does not write what you said?? https://babeljs.io/repl/#?evaluate=true&amp;presets=es2015%2Cstage-0%2Cstage-2&amp;code=let%20testFn%20%3D%20async%20()%20%3D%3E%20%7B%20%0D%0A%20%20return%205%3B%0D%0A%7D%3B%0D%0Aconsole.log(%20testFn()%20)%3B and I get different errors in jsbin and jsfiddle. Is it not supported in browsers yet fully?
I can't wait.
https://github.com/icholy/MessageBus/blob/master/package.json
While dealing with the state machines isn't too horrible, I set up two separate builds for some projects. One that targets ES6 for debugging async functions compiled to generators and the other targeting ES5 for browser support. This also tests that you're not violating temporal dead zones or something else Babel doesn't catch.
There wouldn't be any good reason to not use TS for any project IMO.
 const hello: string = "hello world" console.log(hello)
That's a pretty nice idea. I'm trying to get chrome to work with source maps so it debugs the TS files directly.
I want to use TypeScript throughout my projects but when I want to do a very small project as fast as possible i just go with es6. I tell myself the code is more clear to read and faster to type.
No this is for work, but I'll try and put together something when I'm free (rare). Hopefully someone else might link us with something. 
It comes in useful once you're refactoring.
If you like TypeScript for big projects, then you might like it for small ones too. * If you're publishing a small reusable module on GitHub/npm/bower, writing in TypeScript is the best way to provide seamless support for larger TypeScript projects that may wish to consume your module. * TypeScript IDEs like Visual Studio Code are so good for displaying warnings as-you-type. I find it helps me focus on writing more code at a time before I need to actually run the code – the as-you-type error detection is enough for me to know my code is working and on the right track. I often write small CodePen projects in TypeScript. I like it a lot, but if you want to roll freestyle on a small project, that's cool too.
How do you pass correct JS depending on browser support? I've had this idea some time ago, to deploy app.es6.js and app.es5.js and use more readable/performant es6 version where applicable. But unfortnuately I have no idea how could progammaticaly decide which one should client browser load.
I don't do it dynamically. This is just a debug build that I use in Chrome to step through async functions a bit more easily. It should be doable if you checked the user agent string and returned content based on that though I'm not sure I'd recommend it since UA string databases can be a pain to manage.
You're creating unnecessary work. You want to add code to satisfy some desire to make this library look like it's a class with decorators. More code, more complexity, more opportunities for errors. Keep it simple. There's nothing wrong with the way it is.
You can try https://github.com/pleerock/routing-controllers Its under active development yet, but Im already using it on production
Or https://linqjs.codeplex.com/
That looks amazing! Thanks. I'll give it a try. Although can you explain why the Req() and Res() decorators are needed? And are they just the Request and Response objects from Express? 
Can you post an example?
ES6 defines things called iterators, analogous to IEnumerable. It would make more sense to implement that pattern rather than duplicating it with different names.
&gt; Really, would just prefer people use the much more established, much more conventional lodash rather than trying to port some part of C#. We already have enough fragmentation in javascript. Strong disagree. This kind of attitude flies in the face of innovation.
What are push/pull collections?
I'm curious, how exactly do you see copying an already-existing API as innovative? Regardless, we don't innovate for its own sake. This is an already-solved problem in javascript. 
imo, it's not about copy/pasting any certain API, it's about doing what's most efficient. LINQ is able to gain amazing optimization through iEnumerables, which we will eventually get with iterators. I expect various libs like lodash, sugar, underscore, etc may switch to using this method, and some new libs will appear. I do agree that trying to copy the exact same API as LINQ is not super innovative, but getting the ability to iterate or enumerate like LINQ is a big win.
It's the attitude itself that goes against innovation. As a very big fan of LINQ and not a very big fan of lodash, I think a port of LINQ to JS is totally a good thing. I know you think that lodash solves the problem, but not everyone agrees with you, and it seemed like you were coming down pretty harshly on OP, imo.
Push collections are Rx style "collections" - basically event sequences - they push elements at the iterator. Pull collections are standard collections - you "pull" elements from a collection in to an iterator. 
Sorry, not familiar with the term "Transducers". Will look it up.
Its lovely now. Generics for the win.
RxJS is really sweet. Pull: IEnumerable&lt;T&gt; Push: IObservable&lt;T&gt;
They basically compose operators instead of streams. Like say you have a map and a filter and so on - RX/LINQ will first create a select proxy then a filter proxy and so on observable/enumerable. Transducer will combine map and filter and so on in to a one function and then apply all of them to the input stream in one "pass". It's a bit more tricky to explain properly but that's the gist of it. The other cool part about them is that the transducer implementation of map/filter works on both push/pull w/e collection - the underlying input abstraction is more powerfull - so you only have one version of map/reduce/filter/etc. that works on all transducable sources
Yes - although that's not the motivator behind developing them - the main reason they were introduced in clojure is to avoid having to duplicate functions like LINQ/RX for observables/enumerables - that they end up being more efficient when chaining is a bonus.
The project is using angular 1, so most architectural stuff was already layed out, and (sadly) there are very few components. The creators were Java guys. Communication , if any, between controllers (or "directives", angular components,) is done mostrly through the templates. Which is not great IMO, I would rather have something like you have, or React. One pattern I do see that we use, is using the following: `do((arg1) =&gt; this.method(arg1))` instead of `do(this.method.bind(this))` when passing callbacks. We happen to be using promises almost everywhere, so there is always just one value (or none) being treated in callbacks, and this pattern looks OK to me. So we're universally using arrow functions, which deal with `bind` automatically at compile time, and since we're using promises, there is no big deal in being verbose when writing the value name/type one more time in the arrow functions. &gt; All the classes were written from an object oriented design, so all the functions were written as if 'this' would work correctly when called from within another class. I would say that javascript's "bind/this" handling is quite object oriented, actually. IIRC, in Java, if you want to pass around something like a callback, you use an instance, and then call whatever method on the instance. You can do the same in Javascript. It's just that having and using first class functions is extremely useful, and less painful, if you are conscious about the context. &gt; I'm trying to find a better way and get the new tech lead to get onboard changing this, but his experience was with writing pure javascript targeted at older IE browsers, and as such has an obsession with small memory sizes. Personally, I don't think trying to get small memory size from the prototype system is a great idea. I mean, most of the time you won't have *that* many instances of a class alive for memory to be an issue at all, except for stuff like games. In your position, I would go for approach 4, but do it automagically with a class @decorator. It is a quite anti-javascript approach, but it solves the `.bind` madness you're describing. --- One thing that caught my attention, is the `&lt;cast&gt;parent.FindController('Controllerid')` part. On a past project, we converted a ES5 codebase with backbone.js and a custom component system with calls exactly like that. This "getting different types from a string-value" is a huge pain in the ass with TypeScript (and any type system). What we ended up doing, is declaring the list of components/controllers in the parent class like so: public children: { ControllerId: Type ... } = {}; and then you populate that in the constructor or something like that. When converting the code base, writing all this for each controller was a pain point, but after the conversion it was then a breeze to get the types always right without any casting. 
This is what I was looking for! Thanks a lot!
You seem to be conflating OOP with types. Typescript doesn't add OO features to Javascript, only types. Though like Babel and Traceur, it can compile ES6 classes down to ES5. All that said, I think TypeScript is ideal for web-based gamedev. Most of the major game dev libraries have type definition files, and I find types are especially helpful for ensuring correct usage of complex APIs, data structures and math as gamedev tends to require.
I agree BUT I hate the way project structures balloon as you build out an ExpressJS REST API. You can divide it by resources and have something like.. /api /resources users.js comments.js api.js ... where each module contains ~6 CRUD endpoints exported as a router. Or, what i'll normally have is the endpoints segregated for easier TDD or BDD etc. /api /users create.js delete.js update.js /comments create.js api.js Again with a router being exported in api.js . MAYBE something like view classes (Django style) can make it cleaner, maybe there's some other solution lurking, but I really think the OP is targeting a very valid problem that Typescipt's syntactic sugar can help somewhere. Because as it stands, making large REST API's leads to messy projects that are hard to parse. Imagine the example I give multiplied out to ~100 endpoints with 15 resources that criss cross each other in various ways (relations, embedded objects, creating two resources with one endpoint, etc). 
Yeah but what about template files and angular 1.x dependency injection? Angular template caching? I think there will always be use for gulp/grunt.
Also, TS makes programming in JS easier for those with OOP background.
The *string* is optional. It'll still type it as a string if you leave it out.
Nah, I just have multiple exported things. Yes, if I am exporting a single class, the file name will probably be the same name as the class. But I wouldn't say that it's a hard rule, but I probably follow it 99% of the time.
Thanks. I use the Flux architecture in my app and I'll have a bunch of 'actions' as classes, but it doesn't make sense to put them each in their own files. I have a file called actions.ts that just exports all those classes, and I import them as needed.
Yes of course it's ultimately just JS. But you'll have to experience for yourself the beauty of coding it all in TS and the benefits of doing so. I would have to write a book to explain fully. With it all in TS, modularity just works, and you spend less time playing the refresh and run game. Even from a readability perspective TS wins. Future features like async/await will transpile seamlessly into ES5 after TS2.0. If you're an ES6 person and use a transpiler like Babel or Traceur, IMO, TS does it and does it simpler and better.
https://www.npmjs.com/package/typescript-dotnet Latest release has a big improvement in code coverage.
Hmmm.. So I'm probably looking in the wrong place, but the *.d.ts files I've found for RxJS don't do a great job with generics. :/ Am I missing something?
Yes, pretty cool
Recent files are already shown on left edge (or under ctrl+tab) so tabs are unnecessary visual bloat - that can only show few files at a time anyway. I guess it's a familiarity instead of productivity thing
What is MEAN?!
It's the acronym for the Mongo/Express/Angular/Nginx stack. Another example of a stack acronym (stackronym?) is LAMP - Linux/Apache/MySQL/PHP - commonly used by WordPress
Oh, you mean MEANT?
Huh, I stand corrected. I always assumed it was Nginx as a parallel to Apache in the LAMP stack. Which is equally pointless other than making it easier to say. 
namespaces for internal use, modules for external use/packaging although, i don't understand why i have to still use 'export' for namespaces.
The Metadata section at the bottom has almost exactly the implementation of OPs request
Unless you're turning off some options, these types of errors should be caught when transpiling to Javascript - well before run-time.
They're not meant to be parallel -- MEAN doesn't list the OS or the webserver or the language, and LAMP doesn't list the frameworks (server- or browser-side). About all they have in common is the database.
My general rule is that if they have the same name and there's only one implementation, the interface is pointless. This is especially true in TypeScript, where interface implementation is implicit. I do have some projects where the interface is public and the implementation is hidden within a factory. Not sure it's usually worth the effort, though.
Also, if I have a file that's just declaring an interface, I use the ".d.ts" extension. Interfaces don't get transpiled to JavaScript, so your "skeleton.interface.js" would be empty.
TypeScript classes implicitly adhere to interfaces. If you have this class: export class Skeleton { boogedy() { console.log('boogedy'); } } And then somewhere else you have this: interface Boogedier { boogedy(): void; } function boogedyBoogedy(boogedier: Boogedier) { boogedier.boogedy(); boogedier.boogedy(); } Then this will compile: boogedyBoogedy(new Skeleton()); This is in contrast to Java, etc., where you would actually have to put *implements Boogedier* in the definition of *Skeleton*. You can also do inline interfaces: function boogedyBoogedy(boogedier: { boogedy: () =&gt; void; }) { boogedier.boogedy(); boogedier.boogedy(); } 
It really depends on your framework. I do a lot of Angular work, so I use John Papa's Angular Style Guide: https://github.com/johnpapa/angular-styleguide/blob/master/a2/README.md
Ok that makes a bit more sense
Sadly, it didn't. I know it's a problem with the typings for Material-UI but some components, mainly `List` as in my example, don't have a `styleName` or `className` prop. I could add the properties manually (in fact, it's probably what I will do if I can't find how to just add a prop to every single JSXIntrinsic object), but I would rather find a way to just have TypeScript allows certain props on any JSX it encounters.
Yeah I'm pretty sure all that info wasn't actually in the post when I replied.
If I'm converting an ES5 site to typescript should I replace my IIFE's with modules instead of namespaces? Namespaces seem easier to use as its a simple replace but lately everything I've been reading has focused on modules
Now if it only had remote-ftp from atom, I would have hoped over to VSC months ago... It does have similar plug-in, but it's pain to use tbh :/
http://www.typescriptgames.com/www.battlelinegames.com I suppose you want to use absolute url not relative?
Yeah I think in that case it makes sense as an incremental change.
So I'm trying to understand what that good reason is... :/
Because this all happened over [Gitter on May 15, 2016 11:53 PM](https://gitter.im/Microsoft/TypeScript?at=57396e690cb634927f7f2e6c) and others should know the solution/outcome, here's the short of it: use non-relative imports just like you would in standard Node code. Check out these sections in the handbook: * [Module Resolution](https://www.typescriptlang.org/docs/handbook/module-resolution.html) * [Typings for npm Packages](https://www.typescriptlang.org/docs/handbook/typings-for-npm-packages.html)
I recall listening to a talk by Anders (or maybe from their new code samples?) saying that you should just include main.d.ts until you run into a problem with the definitions. For most libraries, the main and the browser definitions are equivalent. I'm working on a universal (formerly dubbed isomorphic) project in VS Code and my original solution was two separate tsconfig files, one for client and one for server. However, the IDE would incorrectly report errors in shared files between the two solutions which would disappear when restarting Code. I moved back to just a single top level tsconfig using main.d.ts and i haven't run into any problems yet.
That is generally fine advice (although it suggests that the current behavior of `typings` could use some further refinement). However, for an Electron-based project, there are indeed significant differences between `main.d.ts` and `browser.d.ts` that preclude you from just using one or the other. There has to be SOME guidance for when users run into problems with the definitions and genuinely need both. The entire purpose of Node.js is so "full-stack" developers can use the same language on the back-end and front-end simultaneously. So why build a non-modular type definition manager, that assumes a project will only be one or the other?
https://github.com/typings/typings Well, typings 1.0 came out today, and it seems like they produce a much different structure than they did before. It is now typings globals react index.d.ts index.d.ts where typings/index.d.ts is the only thing you need to reference
Haha... well so much for all the time I killed this past weekend! I forgot **Rule #1** of the JavaScript community: *If you hate something, just wait a week or two and it will be re-written or replaced anyway.* :)
You need to export your namespace and import it in Main.ts. You can remove the &lt;reference&gt; directive in Main - no need when you're importing. Do the following: 1. Add an `export` before `class ServerWrapper`. 2. At the end of ServerWrapper.ts, add `export = Scratch;` 3. In Main.ts, remove the `&lt;reference&gt;` directive and add to the top of the file: `import { ServerWrapper } from "./ServerWrapper"; 4. (Optional) Fix the typo in Main.ts: `Scrath` =&gt; `Scratch` I think that should get you moving. Edit: Just a bit more, the &lt;reference&gt; directive is really not necessary in a NodeJS app. You can reference your declare files in tsconfig.json, and the compiler should be getting the rest of the type information from traversing import statements.
Ok, implemented your suggestions and now there are no error messages but the js artifact is empty as described in the github case
Are you sure about that ? - The way I understand what it says is that when combined with amd or system module targets it will do the right thing as far as organizing the closures is concerned. I remember using --outFile to combine multiple .ts files into a single js artifact without modules in early versions of typescript.
wihtout --outFile it indeed works but ServerWrapper becomes a module and is being require()ed at runtime which is not what I want. 
Oh hey, same guy! The comment above is tongue-in-cheek... my "Reddit tone" is much different from my "GitHub tone". I *love* you man! :) Yesterday I got hit by a bunch of work-related Monday stuff, returning to the office. I hope to give this personal project another go later today, or possibly evening.
Gave it a quick shot... deleting my project's `typings.json` file and `typings` subdirectory, and re-running: `typings install github-electron --ambient --save`. However, although this command worked over the weekend, it now fails in the following manner: C:\Users\Steve\Desktop\MediaGallery&gt;typings install github-electron --ambient --save typings ERR! message Unable to find "github-electron" ("npm") in the registry. Did you want to try searching another source? Also, if you want contribute these typings, please help us: https://github.com/typings/registry typings ERR! caused by https://api.typings.org/entries/npm/github-electron/versions/latest responded with 404, expected it to equal 200 typings ERR! cwd C:\Users\Steve\Desktop\MediaGallery typings ERR! system Windows_NT 10.0.10586 typings ERR! command "C:\\Program Files\\nodejs\\node.exe" "C:\\Users\\Steve\\AppData\\Roaming\\npm\\node_modules\\typings\\dist\\bin.js" "install" "github-electron" "--ambient" "--save" typings ERR! node -v v4.4.4 typings ERR! typings -v 1.0.3 typings ERR! If you need help, you may report this error at: typings ERR! &lt;https://github.com/typings/typings/issues&gt; A `typings search github-electron` command reveals that this definition is still there, and was last updated 8 days ago. With the new release of `typings`, is the existing `github-electron` definition now incompatible... and it's up the contributor to publish an updated one?
I started doing something like this and if you use Node with Express to start it's not that difficult. I suggest forking this while you can, it might help: https://github.com/electricessence/Recordly I'm going to probably delete it eventually. But it works. Uses EJS for templates. Has types implemented for everything and preps for using passport but no DB yet.
On mobile, but it's most likely the syntax change issue. You can see it on the README, but now you need to do `typings install dt~github-electron --save --global` if you want to install from DefinitelyTyped.
Oh thanks, that's my "emerging" knowledge of TypeScript showing. Early on I had tried some variation of... `import { electron } from "typings/index.d.ts"` ... or something, and obviously that doesn't work so I just wrapped the code in a namespace. However, this **does** work... `import electron = require("electron");` ... and simply replacing `var/let` with `import` doesn't affect globals.
It might be because you have no type definition for Material-UI. Try looking it up on [DefinitelyTyped](http://definitelytyped.org/tsd/). Also, Webpack can handle your require call and that is why you can use it that way. What is your exact error message when you try to import?
My bad, I should have specified. I do use a type definition for Material-UI. Actually, my code *compiles* properly. Once in the browser though, everything is undefined when it comes to that specific library. If it's a component, React will complain that a component can't be null or undefined and if it's one of their helper classes, it simply won't find the method, saying stuff like "Cannot find fade method of undefined".
https://github.com/Microsoft/TypeScript/issues/8672 
As was mentioned, it's likely because you don't have typings for Material-UI. One thing that I wanted to add is that now Typescript is able to import plain Javascript ES6 modules (if you've added the `allowJs` configuration option) which then would give you a pretty decent editing experience. Typescript can tell you what names are exported from what files together with basic types.
I tried, but I get "JSX Element type 'RaisedButton' does not have any construct or call signature". This is starting to be irritating...
more like super-stupid
You should just be able to do `import BaseClient from 'client-base'`. Despite it being compiled to js, the d.ts files in your package allow the same style of importing as if it was a typescript file. The only difference really is that typescript will recognise the BaseClient symbol and should get the type hinting right
When I do `import BaseClient from 'client-base'` I get an error that it can't find the module. I wonder if it has anything to do with the fact that it is a local npm module
I get `cannot find module client-base`, which subsequently means that every method that relies on the parent doesn't exist
Then how can I import a module that I get through NPM? If I use the es6 import style, ie: `import BaseClient from 'base-client', TS tells me that it can't find my module, even though NPM installed it just fine.
The typings are already in the external module and listed in the typings field in the parent modules "typings" field. According to the docs, I shouldn't have to use triple slash references, specially considering that they are all but obsolete now.
Thanks! Glad you liked it. This is one of the most under-rated features of TypeScript IMHO.
Those look like paths to the ambient type declarations for 3rd party APIs, e.g. node. There is definitely no way it makes sense to refer to that from the `typings` property of your package. The idea of that property is to say "Here's where you can find the type information for the module named by the `main` property of this page". The TS compiler will build this for you if you specify `--declaration`.
I guess that I misunderstood your question. As described above, the parent module, has this in it's package.json `"typings": "lib/index",` which correctly points to a definition of the index file.
this is good stuff!
Better explanation: https://github.com/electricessence/TypeScript.NET/blob/master/source/System/TypeValidator.md
If you want to go full runtime typescript type, you can tweak the tsc source to save the interface data structure generated by the compiler that contains every type seen, then load that at runtime along with a little code in front of it to match against a target object. Those interface things can get pretty big, but you get literally everything typescript has, including union types, literal string type, extend/implement, etc, and you don't need another syntax or duplicated type definitions to get them. I'd expect there are probably projects out there that do that. somewhere. 
Yeah. I've had to do some hackyness where I render types then reuse them. :P 
I looked around a bit looking to edit my comment with approaches resembling what I described, and I didn't really find anything that'd have a chance of working well with recent typescript versions. It's a shame, because I'm fairly sure it's completely doable. There'd be non-negligible cost in speed and download size, but I can imagine scenarios where they'd be reasonable trade offs.
Can you give the link to that? Anyway in typescript from what I remember, you can achieve read-only data with either the 'const' declaration (works for numbers/etc but with objects only the reference is constant, the properties can change) or use getter in classes (without a setter). Don't know if that's what you're referring to.
See also object.freeze and object.seal
In the newest version ( maybe ahead of the stable) you can declare a field in a class readonly: class MyDataStruct{ public constructor(readonly public id: number){ } } do not use object.freeze, since the compiler can't infer it, and you can still assign to it, only that it will not do anything.
One common need in immutable data is a "record" which you can't modify but you can easily make a modified clone of, i.e. a newly constructed object that has the same values for all its properties except one. I wrote a small library called [doop](https://github.com/danielearwicker/doop) that provides this facility for classes with the specific aim of being fully type checked in TypeScript.
I think the best way is to start a project and learn the best practices from that. Angular 2 project seems to be a logical place to go. Books are not very useful as they are always out of date regarding js (apart from ones about CSS)
Don't bother buying books IMO, just do this: 1. Learn JavaScript 2. Write JavaScript 3. Save JavaScript as ".ts" 4. If you want, add type declarations to your JavaScript (hint: you do) 5. Figure out how to install (sometimes write) typings for third party libraries (this is actually the hardest part) The online documentation covers pretty much everything, I really don't see why you would need a book. The language is very simple, if a book about it has more than 100 pages, it probably mostly teaches JavaScript and frameworks instead of TypeScript. Classes and all are just regular JavaScript nowadays.
This is a very blatant advertisement. I wonder if it's allowed on this subreddit.
I'd also recommend not buying books for this specific domain because they become obsolete so fast, also because some of the official documentation is systematically comprehensive and always current.
Hi - here is the video: https://www.youtube.com/watch?v=yqJS34H5-r8
Sure thing - here is the video: https://www.youtube.com/watch?v=yqJS34H5-r8
Hi - I’m aware of those. They are called ‘persistent’ data structures in the FP world. I’m trying to find out about the ones used in the compiler.
These were used in the TypeScript compiler from early on. I will probably just research it and post back here.
If your question was about the stuff around 20m, then they aren't talking about typescript or javascript data structures. They're talking about data structures that store the source code/AST within the compiler. Think of that as something like immutablejs (or clojure data structures) but for the compiler. Interesting video though, thanks for sharing the link
Thanks for the video. It's not what I was thinking, it's more about using functional programming than about read-only stuff. Basically when you have a change in your data, you create a new object, rather than changing the existing objects. You can write in a functional way in typescript, but only if you're careful in how you write, the compiler won't confirm that for you.
Not from early on, readonly is a new construct, before this you would have needed to make the fields private and create a getter for each property
I can't figure out how to scroll this website. Things I've tried: * scroll wheel on mouse * down arrow on keyboard * looking for scroll bar * space bar * selecting text with mouse and dragging down * clicking middle mouse button, and moving down This is disappointing because scrolling websites was a completely solved problem by the mid 90's. Edit: I reloaded the page, and now some of the scrolling methods work.
They are also often called immutable data structures in the FP world. And sometimes they are called purely functional data structures. Other times they are not called anything because immutability is implicitly assumed.
You sure were. Just goes to show the barriers that exist to any new language. Here is someone who would only benefit, who knows and appreciates the team from their work on other languages, and yet originally didn't read all the way through a one sentence description of the purpose of TS! A sobering thought for anyone thinking of inventing a new language.
Well, to be fair on them, I remember earlier typescript code (~0.8.8) giving the impression that they *were* going to diverge away from ecmascript. There was a very heavy reliance on classes - which hadn't been standardized yet - and constructs which only existed inside of typescript, like namespaces. Now, we can understand TS as basically an ES6 dialect with types, but it wasn't always so. 
TS was always targeting JS-future (indeed it continues to: async/await). This was made abundantly clear in all early documentation: pre-release TS would change where necessary to track emerging standards. The class syntax was an ES6 proposal several months before TS went public and hasn't changed much since. Module syntax changed wildly after TS 1.0 so they had to maintain the old import/require syntax just for backward compat. Perhaps the most surprising thing they've done is integrated JSX (or "TSX"), as that is obviously not covered by any standard. But arguably .tsx files are something else: an application of TS to a specific use case. TL;DR: TS has always been a best-effort prediction of where ES would soon be, plus types. They don't just throw in transpiler sugar. 
&gt;TL;DR: TS has always been a best-effort prediction of where ES would soon be, plus types. They don't just throw in transpiler sugar. Except namespaces and internal/ambient modules, right? :) What the documentation says and what the code actually does is different. For a long while, typescript *was not* implementing anything on the standards track, and doing its own thing. Even now, typescript doesn't compile correct class syntax without warnings (members must be specified etc), and supports non-standard additions, like primary constructors. I remember very distinctly having a conversation with my colleagues around the time people were still using traceur and 6-to-5 hadn't even came out yet - the choice *then* was something that was clearly and consciously targeting the standards ... or typescript. My team, and most of the teams I were aware of, choose the standard over microsoft's thing. In hindsight, more trust that in microsoft to eventually come to embrace the standards would have been the better long-term decision, but I don't fault the author at all for thinking that they wouldn't. Namespaces and a bunch of classes made it look very much like dart did - trying to impose familiar semantics onto javascript to make it easier for .NET developers, and I know a lot of JS devs resented it for that. 
Yeah, if anything, typescript is the one thing that hasn't changed much. Harmony proposals changed every other day.
They call that a "parameter property", rather than a primary constructor. I can't see how someone, hearing about TS in (say) 2013, would have read far enough to discover parameter properties and then say "The jig is up! This is just coffeescript all over again!" I agree this feature strays beyond static typing and into syntax sugar, but it can be defended given that without it, TS requires an extra line of declaration compared with standard JS. The type of the property has to be declared, and parameter properties "over achieve" on avoiding ceremony. It would get ugly if JS-future ever uses that exact syntax with a different meaning, but that seems pretty unlikely (what else would public/private on a constructor parameter mean?) So I'd say it's at worst a minor transgression, easily justified, that in no way upsets the overall mission of the language.
Really looking forward to the terminal.
I guess for me the word that leapt out was "Type". I was happy to wait for the ES features - to me they are so much fluff compared to static typing with good inference. So I started using TS as soon as it got generics (an absolute must). My attitude at the time was "arrow functions: great, classes: not interested". Was initially cautious (just wrote some automated test scripts in it), but that was so positive I began hankering after it in the main codebase (~100k lines of JS). So I started converting in stages, and every so often a new version of TS would come out with new delights in it... it sounds weird but I look back on it with great fondness. It's the best experience I've ever had adopting a new language - so many great, tasteful decisions have gone into it. It *seems* like it all naturally had to be that way, but that's an illusion created by brilliant design choices. After a couple of months I'd converted about half the codebase. Over the last year having changed jobs I've been back in the CLR zone during the day but I grab each new TS version immediately, and build hobby stuff with it whenever I can. The type system is already way more powerful than the CLR's and with non-nullable support in 2.0 it's going to leap far ahead. But the reason I mention this is that in the 50k lines of TS I ended up with in my last job, there were hardly any classes. TS has to support `new`, and implementation inheritance because they are part of the JS landscape, but I'd built that original JS codebase having consciously decided to avoid all those things. Classes are just not very good in ES, simply because: obj.method() ... might work, and yet: const m = object.method; m(); ... might not, because the type of `m` is not directly callable if it references on `this`. It's more like a factory for making functions by calling `bind` on it. TS has the potential to fix this, though they are being quite cautious about it.
I cant agree "I don’t really think there are many, if any, JavaScript developers wake up in the morning and say "I am really glad I work with JavaScript, it is such a wonderful language." I really love JS and I think it is great language. Both as syntax, closuers, objects and its flexibility. Also you can deploy into so many platforms, mobile devices, windows/linux/mac programs, websites, even gaming consoles. And if you are building complicated tool/app/website/backend/mobile app/game/whatever you can always use TypeScript which will make your life easier. Seriously I dont understand all that hate towards JS. Its the best language I have worked so far and I've worked in C#, Java, C++, FreePascal, ObjectiveC, PHP, Python, etc. Especially when PHP programmers start talking that JS sucks, it is getting really silly..
It was very interesting, thanks for posting
&gt; Tab support is the number one User Voice request. While the full implementation will take multiple iterations to fully deliver, we wanted to share progress made during the May iteration. They're working on it! That said, I do really like their implementation wide the sidebar. /me hides from the rotten tomatoes
C# is waaay better than js.
no tomatoes.... i just want to know WHY? HOW? I gave the side bar a shot, it is so hard to jump around when you are referencing several files on the left pane and several files on the right pane.
Generally, I agree with you. But the gotchas tend to bite *hard* when they do, and sure - the behavior is documented - but tools that are difficult to use are poor tools, period. I'm very pleased that there are (better) options.
Out of curiosity, how complex are the applications you work with on JavaScript and the size of the team?
Probably yes, but I think every language has these. I like that JS is quick and not very verbose, for example Java is great language and when you write it you actually feel that both ide and language are trying to do their best in order to make sure you wont make a mistake while developing. But it is overly complicated many times. For example while I understand the reasons for Java stream system with stream types, interfaces and such, it makes a lot of sense and is carefully planned, in reality more often than not, I have to create and connect like 5 class instances to just read simple text file from disk. Also in some other community that I also participate in posting, many PHP developers love saying how bad JS is but actually PHP is waaaaay worse than JS. Examples are that string are objects in methods instead of simple types (anyone know php parameter orders and "_" usage for strpos, str_replace, explode etc)? PHP does not have module system so you actually develop in PHP like you would in JS but you are forced to wrap everything into classes just because autloader wont be able to find your file. Node has package manager integrated into core, it has async nature that is accepted by community and every single package in npm work in async way; it has way better performance than php and if you develop complex app, typescript outperforms php5 and even php7 in terms of static code checking. 
Well I probably wasnt 100% clear in my first post. I am talking ES6/ES2015 specification. If we would talk about ES5/ES3, then my rating would really go down. But I am talking about most recent specification. In my opinion PHP7 is superior to ES5, but looks like garbage vs ES6. And about TypeScript, making your project in TS created a severe cost in terms of maintaining both type checking and type definitions. While dudes from typings do really great job, it is never a "fire and forget" job. But if project you develop is large and complex enough, it will quickly pay off reducing the amount of unit test you have to write, giving you really good code completion feature, quick compiler and rich type system. It may be not ideal, but it is great. And TypeScript 2.0 that is going to be released in this month probably, will contain support for async/await feature in ES5 and ES6 compilation target. This is going to be really great feature.
I am not sure if what you are doing is a "good practice" since you are "extending" rather than "decorating". You can create a base class or do mixins to avoid that. To answer your question to create a type declaration you will have to effectively tell TypeScript that the type is extended like the below, which looks function stoppable(constructor: Function) { constructor.prototype.stop = function() { }; } // ambient declaration declare class Stoppable { stop() : void; } @stoppable class Car extends Stoppable { public start() { this.stop(); } }
I haven't tried git bash from VSC but the git in the new terminal works well enough.
TypeScript 2.0 will also have non-nullable types.
Why? How? Those I can't answer. I can give my opinion on the sidebar though. In my other IDEs (WebStorm, for example) I'm used to having a handful of things on the sidebar. My project dir, gulp, npm, etc. And having the things I need most over there just 'works' for me. I think it's a matter of taste, really. I think it's pretty easy to jump between files in VSCode, but if tabs are what you're really used to, that's fine too. When I jump between files, I tend to use the magic bar (not sure what it's called `Cmd+P - 'filename' - enter` ) I do the same in WebStorm where I'll hit shift twice, start typing the name of the file I want, then just hit enter once it's in the dropdown.
&gt; When I jump between files, I tend to use the magic bar... Yeah, that, or just `Ctrl+Tab`.
I'm talking about things I'm not happy _right now_ as opposed to things that I won't be happy about whenever 2.0 is released. That being said, I use TypeScript daily because I think it's the better option all things considered (if you cared to read my post! :-P). You also have [union types in flow](https://flowtype.org/docs/union-intersection-types.html) but I'd say that's a different issue (or non-issue). As of today, I take TypeScript over flow for the reasons I mentioned above. 
&gt; if you cared to read my post I read your post. My comment was about the presentation you linked to. You might have missed it. Also, notice my comment was not about whether flow had union types or not, but the fact that non-nullable types on TypeScript are *based* on the union functionality. It's a different approach to how nullables work.
About concurrent calls I just wanted to give an idea how large project can be. And for non-typed code no it is not a serious problems. Of course we had some bugs that were just because of no type checking in raw ES6. But if you do not overextend with dynamic nature of JS, you will be fine. For example we are not creating functions that may accept variant parameters like either you can pass an array or an object or a number. We stick with single parameter type and we name our function parameters in a way you can easy figure out what you have to pass here. For example: function fooBar( user ) { ... } &lt;-- you must pass a complete mongodb row from `users` collection function fooBar( users ) { ... } &lt;-- you must pass array and only array. if you want to run this function for single user, just pass an array with single element. no variants function fooBar( userRegisterParams ) { ... } &lt;-- here we already know that this param is some dynamic object that will be mapped into something else in future For example jQuery coding style is something we do not accept in our codebase. A function that behaves differently depending on how many and what types of args you pass is bad in large codebase and you dont really need this feature. Also we try to keep a non-nullable parameters for functions whenever it is possible. For example we do not make a function that is named: setUserProduct( user , product ) that either sets a new product if you pass it or clear a product if you pass null. this is common in other languages, but we try to avoid this. it is better to split it into two functions: setUserProduct( user , product ) clearUserProduct( user ) This way when you look at source, you will easly figure out what is going on here. Also if you keep your variable names verbose, it also helps with maintaining large codebase. Do not name your variables "param" , "u" , "tmp" etc. Describe your variables so other programmer can only look at name and quickly figure out what type of variable this is: "userRegistrationParams" , "user" , "counter" etc.
I am not talking about those extra chars (like :number) you must type every function parameter and class field. It is just easier to bootstrap a webpack+babel backend project as this is a matter of minutes. And as you continue developing project, you just npm install whatever you need and go. TypeScript instead forces you to configure compiler and manage type definitions. It is not straighforward as raw ES6 as EVERY single package need either .tsd file, hand-written tsd or "declare variable xxx:any" hack in order to work. There are thousands of packages in npm that do NOT have their Typings entries. And many of them are either incorrectly described (like jQuery, lot of compiler errors on correct calls), or outdated. If you are creating a small website with 5 pages, simple registration and comments feature, you dont really need TypeScript. And TypeScript is really great, it is a live-saver for JS projects and I love programming with it. But unless I have to develop large project, it is just not worth spending time with configuring things, managing tsd, typing code because there is no serious benefit in doing so. Talking this way, I can suggest you to make your website with 3 subpages to develop in C++, why not? You will lose only "seconds, at most minutes" because codebase is small. Indeed it might be great idea to write it in C++ and have highly performant custom http server with your application, but what is the point in it, if raw JS is more than enough to do the job? Alongside with static type checking, the best TypeScript feature is that it have full 100% reliable code completion if you do not shortcut your way with :any types. This is the second main reason I'd choose TypeScript into my project as no other dynamic language can match TS autocompletion. But still, it is not worth to use it in small project, just waste of effort.
Interesting to see, we have a similar code style and library, no nonsense and no crazy weird hacks. But we are 100% TypeScript and as a C# team it has helped us alot with catching simple errors and having good code completions with definition files.
Sorry I read that in that way, I assumed you meant differently. On the other topic, OCaml's option type is also basically a union (`None | Some of 't`) so under the hood there isn't much difference other than syntax sugar (which I prefer, rather than having to type a union on every optional prop). I think it's great TS is getting it soon.
For those interested in the answer, I needed to use bind(this) to pass the this of the dataservice to the xhr handler. this.xhr.complete.bind(this) etc.
&gt; *To really understand why Typescript is better, you have to have used a a typed language, then switched back to the typed language so you can actually feel how much worse it is. It's fairly rare for webdevs, who are mostly new developers (no shame in that) to have used a typed language before. So they don't know that there's an actual benefit.* Absolutely. (Although you probably mean "switched back to the *untyped* language" up there.) I suppose parallels can be drawn with the SQL-vs-noSQL rift, plenty of devs turn to Mongo because "no more schema slowing me down, yay", and then poorly reinvent the same RDBMS machinery in their application. &gt; *Worse, you can't really proselytize it to them, because people proselytize things to webdevs every day (new frameworks! new libraries! Less! No, Sass! Coffeescript! no wait, not coffeescript!) and most of them have little benefit to no benefit whatsoever. How could they possibly understand that this new thing is really a game changer, when everything else appears on the surface to be equally game-changing?* Magpie-driven development. Grab the latest shiny! It doesn't matter what it does, it's shiny!
Just to put this in perspective, C++ became a mature language decades ago. There is still a fight going on between users of C and C++. It's particularly vicious around Linux due to Torvald's very strongly held (and to me unconvincing) opinions on this. TypeScript is very unlikely to win over a majority. But that won't hurt it and doesn't indicate anything other than what we already know about human inertia and irrationality. I am currently using this form of words to explain it: * The value of static typing is that it makes your working environment into a more intelligent, knowledgeable assistant. * It makes helpful guesses, it returns useful answers with higher probability. It does this because you’ve told it stuff about what you’re trying to do, so it becomes more able to help you. * Don’t keep secrets from your tools. Tell the machine what it needs to know so it can augment your memory and make “you” (the combination of you and your dev tools) more intelligent as a working combination. * Unit tests are an *imperative* way of stating facts about your code. Types are a *declarative* way of stating facts about your code. Each has its benefits and limitations. Be smart: use both, and get all the benefits and none of the limitations.
ES6 is valid Typescript -&gt; 'nuff said
Another one that hurts my brain is when you have an Angular developer who when you tell them ng2 is built using Typescript, or that VS Code is built on Typescript, or that Typescript is built using Typescript. They still have a blank look on their face.
In a team I would highly suggest using TS, but for a personal project I don't see why I would use it. It doesn't make me code faster and barely catches bugs (that's what tests are for). People have different opinions and calling them ignorant just because you don't agree with them is pretty naive
&gt; JS is a language focussing on getting things done quickly, no matter the trade-off. Write once, never maintain. That's not a fair claim against JS. There are a lot of very clued-up people working in JS in the best way possible, i.e. tons of test coverage. The stereotype of it as a script-kiddie language is around 10 years out of date now. &gt; TS is the complete opposite, coming from and made for C++ devs Not remotely true. TS is a smooth extension of JS allowing the user to gradually add as little or as much type information as they want. You can literally start with your `.js` file, rename it to `.ts` and then start annotating parameters on methods, one at a time, and by default it will still produce `.js` output that still runs even though the compiler is producing type errors. This is a fundamentally different experience to previous statically-typed languages and is purposely very `.js` user-friendly and with a learning curve that you can take at your own pace and get as much value out of it as you want. (Also I don't see any sign that the designers of TypeScript are huge fans of C++ at all). &gt; (arithmetic) quality ? &gt; But you have to admit that you cannot use generators and "bind(expression)" in a meaningful productive syntax inside TS because the compiler will annoy you with bad syntax messages. Generator syntax is supported as-is, when targeting ES6. TS 2.0 will support it on all targets. Not sure what errors you're getting? And by bind, do you mean `Function#bind`? It's not properly typed in current TS but that just means it works exactly as in JS. Again, no reason for unusual errors there. &gt; not for LISP and Haskell guys that think differently. This is a very strange conflation in the context of discussion TS. LISP is dynamically typed (like JS) and Haskell is statically typed (like TS). The type system of TS has much, much more in common with Haskell than with C++.
I doubt that.
Tests !== compile time safety. Keep tests for the business logic, if you enjoy writing tests for things that a compiler can catch for you (+ all the ones you didn't write tests for) it's your choice but tests are definitely not for type safety.
&gt; TypeScript is very unlikely to win over a majority. At least not for projects that don't otherwse require a build step. For a small project, with maybe just a couple of files it might not feel like it is worth the hazzle. And getting a project to build at all (especcially if you rely on js libraries) is a bit of a PITA, to be honest.
Well. You are not *wrong*.
I would consider using TS also for a personal project, but I agree with your main point. In my experience static typing catches very few bugs, and when it does they are usually trivial. There is also data to support that the benefits of static typing are oversold: http://games.greggman.com/game/dynamic-typing-static-typing/ Hoewever, satic typing does have some benefits, mainly documentation and IDE support, which can often make it worth while. 
Babel has a variety of plugins that do more than just ES2015 compilation.
Getting it to build is very easy. What takes slightly more effort is getting it to not emit any type errors. Enter this into an editor: import {hi} from "ballsack"; hi(); Save it as `crap.ts` and then at the command line enter: tsc crap.ts It will emit an error: Cannot find module 'ballsack'. But it will build the equivalent `.js` output. The ease of working with libraries is dependent on how conveniently their type info has been packaged up. For example `immutable` is a popular JS library that happens to include TS type information partly as a convenience to users and partly because it's how they document the API. So if you say `npm install immutable` then this will "just work" (note that it is just ES6): import {Map} from "immutable"; const m = Map({ first: "Home", last: "Simpson "}) There is literally nothing else you need to set up. For TS 2 they are going to allow 3rd parties to create addon npm modules to supply types for modules that don't do it themselves. This will be almost as convenient as the type info being built in. This should help a lot.
I don't understand 100% the context of his statement, but he is correct. You can copy paste ES6 into TypeScript. In reverse, well, of course not. If we are attempting to compare the two as equals: ROFL
TypeScript is a simple transpiler to ES5/ES6, but it doesn't offer much more than just selecting the module export type. Things like loaders, shims, etc are usually only (or better) served by other tools.
You can find more about [what's new in TypeScript 2 in the roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap#20). Will be out [soon](https://github.com/Microsoft/TypeScript/milestones).
I would have to intensely disagree with this statement. For a personal project that is only a few lines of code? Maybe. But I've written a few personal projects or even small 1 man team projects in the past few years and TBH, TypeScript was essential for success. Not because I can't code in JS, (I've been at master level for many years) but because of how complex these projects are even if they are only a few files. Anything involving a class structure and it simply becomes tedious in JS. You could argue "just use ES6" and I have to laugh because that's like saying, "just use a Prius" when there's a Ferrari in my driveway.
That's awesome information. Thanks! 
For example?
async/await works already in TS 2.0.Also generators for ES3/5. Everything is available in typescript@next. The only downside is that most of the plugins isn't compatible yet. You will probably run into a few issues, and one major change is how the 'this' keyword are used now. 
It still stands, but as this project readme says, you have this option "npm run tsc". Compile TypeScript down to ES2015. And Rollup only grab that bundle and do it's magic. So no need to use either Babel or Buble. Just 'npm run tsc' There is a huge switch between TS 1.8 and TS 2.0. And as you write non-nullable is a good thing, also the 'never' type. https://github.com/Microsoft/TypeScript/pull/8652 And it hopefully gets better ES2016 support through the --experimentalDecorators flag. When you use the non-nullable types make sure you activate /de-active the strictNullChecks flag
I'm pretty sure you can set allowJsSources (or something like that) in tsconfig.json to allow a hybrid project.
This is the right answer, then slowly convert to typescript
files and exclude properties can not be used at the same time in tsconfig.json.
The Buble step seems redundant if you're using the latest Typescript? Especially now it can retain es6 modules for Rollup to use - https://github.com/Microsoft/TypeScript/pull/9042
Before I reply to your question, I have to mention that this repo was just ment as a basic setup for people to modify after it's own needs. But it changed, so I'm going to take this a step further soon.. Too your question. I know Rollup can handle ES6 files through the 'jsnext:main' option in 'package.json', but it's not a standard. And hopefully things will change soon. Node has settled on an official convention of using the .mjs extension, but they try to change the names. This repo take the ES6 transpiled by TypeScript 2, and Rollup pick it up with through the entry flag. Buble is probably not needed, but added for the sake of older browser support. I choose this combo simply because if you transpile TS down to ES5 you will get a ugly looking source code. If Rollup do the job, you get a nice looking source. Anyway. I will change some of this soon... 
I've been converting a react/babel/webpack codebase to typescript/webpack. Webpack makes it reasonably easy. I've just added the ts-loader and then started converting from the leaf-files inwards. I don't think you can import a javascript file into a typescript file but you can do the opposite with webpack helping with the bundling so if you want to convert one file you have to convert the files it is dependent on first. Otherwise reasonably easy. I've been doing it slowly over months. Mostly whenever I find something in a JS file that would have been caught by Typescript, I convert that file and its dependencies over. Nearly there now!
I'll take a look at the bugs if I have a moment... maybe they can be fixed in the `d.ts`. Totally agree about the `Record` class, I came up with [a lib called doop specifically to solve that problem](https://github.com/danielearwicker/doop). It works the same as `Record` internally for efficiency.
So another reason to add a transpiler
I will try to do an experiment on that soon and add my findings to the repo. For async /await. Yes, many uses Babel for this. E.g. you can archieve this with `babel-runtime`. React are using it for async. You can also use a similar solution as found in Angular 2 without Babel.
I found this repo: https://github.com/episage/typescript-es7-boilerplate It may give you some ideas on how to get it working.
&gt; ES3/ES5 generators? That is what I heard, but ofc. things can change. Main focus now for the TS team now is to get a smooth async/await transpiled down to ES6 without bugs. But you can run generator on tsc's ES5 output if you set the the target to es5 and use this repo https://github.com/facebook/regenerator E.g. `regenerator -r app.ts-es5.js &gt; app.es5.js`
Yeah, I don't know why angular2/vscode doesn't provide functionality to check whether an binding expression in template is valid.
Thanks. I'm using Babel to get generators at the moment (TS &gt; ES6 &gt; Babel). According to the roadmap they are due for 2.0 but they've been a long time coming, and I wouldn't be surprised if they were pushed back. Hopefully not.
&gt; Files that you want to be type-checked just need to start with the Flow comment: /* @flow */ In TypeScript they just have to be renamed to `.ts`. &gt; React is supported out of the box. As it is in TypeScript! Rename your `.jsx` file to `.tsx` and a whole lot of popular IDEs will give you autocompletion and red squiggles in your `render` functions.
Not on Windows. I don't like the idea of using something that isn't officially supported. 
Repo updated to handle npm@typings. Improved UT. 
[removed]
You could do it if you are willing to use `permission['prop1'].has` instead, but that's not very user-friendly IMO. The main issue of this problem (as of TS 1.8) is that you have to treat `prop1` as either an property or an index, but not both. 
That's true, but I want to keep it generic so the keys on the input match the keys on the output, and that seems to be the challenge.
No, that's impossible. Types in TypeScript are not like Types in C# or Java or C++. They are just annotations of the compiler, and are not there at the runtime at all.
This looks like obfuscation to me. Why not just say `btoa(exampleB)`?
Well, the point would be to use it in implied conversions too. I just wanted to emphasize the conversion.
God, no. That does sound very much like a bad idea. I mean when I explicitly make the cast (`someB as A`), when I assign to an already-declared or new explicitly-typed A variable, or when I call a function with an A argument and pass a B. Casting whenever an instance method cannot be resolved does sound like a bad idea.
Hm. I didn't actually know TS has non-goals. All the same, though, I'm not sure when the second half ("emit...") would really be a problem. The first half is definitely to be avoided, but could you provide an example of where the second would be dangerous?
One thing you could take advantage of is that types and values have separate namespaces and so both can use the same name (the namespace keyword creates a value that is an object): type A = {n: number}; type B = {myA: A}; namespace A { export function from(b: B) { return b.myA; } } let exampleB: B = {myA: {n: 4}}; let exampleA = A.from(exampleB); 
Sounds useful, except it doesn't solve the other problem I have with just writing a converter function and using it directly. I forgot to explain it in the post - I've edited it.
&gt; sometimes, type inference changes to be more or less restrictive in what it chooses to infer In this case, doesn't it just accept anything `foo` does with `a`? Isn't that what `any` means, or am I mistaken?
installing typescript@next doesn't give latest version it seems. do typescript@1.9.0-dev.20160613-1.0 
If inference changes, it might stop interpreting a param as `any` and start interpreting it as `A`. Then, suddenly, your `btoa` function is emitted when it wasn't before.
I don't think emit behavior should depend on whether a type is explicit or inferred. That seems even more fraught.
Very cool! :D
Do you get hot reload? Looks good otherwise!
I haven't used webpack on this repo because the thought is that the end-devs should configure itself. However you got a TS 'watch' task that recompile your files, and Rollup - as I'm using in this repo - got it's own watch task. If interest for it I can put up a similiar solution to hot reload with live reload and Rollup watch for unit testing in browser. 
How does the npm types installer work? It must only work if the package has it's types set up in it's package.json?
Like?
Don't install the types then.
This: ❯ npm i -D @types/lodash ❯ tree node_modules/@types/lodash/ node_modules/@types/lodash/ ├── README.md ├── index.d.ts ├── lodash-3.10.d.ts ├── package.json └── types-metadata.json 0 directories, 5 files 
I'm a new convert to TypeScript and accidentally discovered MobX at the same time. MobX deals with plain TS classes that are a joy to use and get intellisense for. And the fact that it doesn't bother with immutable objects makes your difficulties with Immutable.js a non-issue. I'm in heaven! 
Repo updated. VSCode integration supported. Debug and run server tests. More new TS 2.0 pre features added. All over. Huge refactoring. 
For type checked property setting in an immutable record, try my library [doop](https://github.com/danielearwicker/doop/blob/master/readme.md).
Thanks for the link - that PR looks great. I was trying to find a way to do actions with string literal types and that may help. It also seems to help some of the situations where I wanted to use string literals in index signatures. edit: Discriminated union types just landed in the nightly, and they make working with actions so much nicer! The new implementation is on Github.
CI now tests on both linux and osx. And on x86 and x64 for Windows. Upcoming changes will be improved browser testing, and TS for handheld devices. Plus testing on mobile platforms. Need to find a good balance here. But next v.0.10.0 will have some new features in this direction. 
Cool library! I recently read something that promoted the idea of immutable object oriented programming. I'll play around with it.
Thanks. I went the whole hog with the OO thing in that it supports inheritance, methods and so on in a fairly natural way.
I have a pretty limited experience here but I use Sequelize which can target multiple DBs (including MySQL) and has expansive typescript definitions (with documentation)
Awesome, great to hear. Thank you!
Much better version: https://www.reddit.com/r/typescript/comments/4onmqw/easy_gulp_typescript_rendering_with_promises/
I went through the readme it looks pretty nice. You also have a number of other cool looking projects on your github, I'll have to check them out later Nice work
This... it just looks over complicated :o
The process of turning TypeScript into ECMAScript is called **transpiling**, not rendering.
Well if you want to do the same with thing with pure gulp and subsequent dependencies, it's even more complicated. Dependencies that are hidden here: * del * stream-to-promise * uglify * gulp * gulp-typescript * gulp-sourcemaps And more.
 For the average person just using ```tsconfig.json``` should be sufficient. * But what if you need minification? * What if you need more than one target/module type? I've been using Gulp to trigger builds for quite some time. Originally ```gulp-tsc``` was how it was done which was then surpassed by ```gulp-typescript```. ```gulp-tsc``` mirrors ```tsc.exe``` but ```gulp-typescript``` is more Gulp friendly. Both of these Gulp plugins have their own strange quirks that even to this day do not make them equals. ```tsc.exe``` is much better today than it was and for the most part you could probably write a simpler batch script to render multiple dists :P So for example... If you wanted declaration files to be included with your JS, you'd need to write this code (pure JS no type guarding): https://github.com/ivogabe/gulp-typescript#basic-usage var gulp = require('gulp'); var ts = require('gulp-typescript'); var merge = require('merge2'); // Require separate installation gulp.task('scripts', function() { var tsResult = gulp.src('lib/**/*.ts') .pipe(ts({ declaration: true, })); return merge([ tsResult.dts.pipe(gulp.dest('release/definitions')), tsResult.js.pipe(gulp.dest('release/js')) ]); }); Might seem simple enough until you need sourcemaps and minification. It gets even more complicated if you aren't using Promises. :| Am I making more sense?
One more thing to note. All this code ***is*** TypeScript and is fully typed. So the simplest thing like *module type* is using typed literals. 
Nice article, Gary! Not really related, but on a recent node project I was happy to see that typings search debug" showed an entry for the visionmedia/debug module. :)
After using Sequelize, Knex and Bookshelf with TypeScript ; I went back to C# with Entity Framework for the server side. ORMs in JS are way behind EF. Node.js world unfortunately favors NoSQL.
You're transpiling and then minifying the JavaScript. So, don't take this the wrong way, but npm already suffers from far too many people making their personal flavors of things into packages. This adds to npm's - and this entire ecosystem's - biggest flaw: decision fatigue, as you describe in other comments here eloquently. It's why you made this in the first place. What nobody stops to realize is that by publishing your own flavor as a package on npm, you're just making it worse.
Yes, I'm very familiar, I'm a .NET dev and I enjoy the same TS/.NET stack :) I have day dreams of a multiplatform typescript solution but these ORMs are miserable for typescript. Typeorm is looking great so far!
Have you tried webpack?
&gt; Personally, (strong opinions here) most of the code I find on NPM is... (politely) sub-standard. I agree with you. Particularly coming from a .NET background where the BCL is standardized and very high quality, it's staggering how many npm packages are obviously first timers, college students, and others who have obviously never worked in a commercial software development environment vomiting all over npm. I think there's already a need for curation on npm to reduce this problem; someone, or someone's, need to spend time to establish an npm "BCL" stack or stacks - think Linux distros for packages. There are a few already (like Express for example) that are the first forays into this. &gt; So am I supposed to decide to use the status quo of not-so-great fragmented functions? Where is the line drawn when you take time out to contribute to someone else's repo and wait forever for it to get published, or simply take things in your own hands and publish your own? I am like you and prefer to write my own stuff, because when it breaks I know how to fix it. I work with a guy who is the opposite. He doesn't understand why I refuse to accept "industry standard" plugins. For example, we started using ASP.NET core and six months ago their OData implementation was frankly awful so I just wrote my own. Cost me a a week of time, but its drastically better than what was there. I haven't published it. What if it takes off? What if everybody loves it and then wants to start contributing and expects updates? I barely had time to write it to begin with; I absolutely do not have time to curate an open source project. And that's one of the problems with npm. Publishing is a commitment to a community. If you just want to share your code, leave it on github. If you want to develop &amp; *maintain* free software, publish on npm. I'd say 90% of the packages there should have just stayed as github open source projects.
Wow. Yeah. Totally. So your OData implementation is on GitHub? Did you fork? Pull Requests? Just curious. :)
[TSD is deprecated](https://github.com/DefinitelyTyped/tsd/issues/269)...
Ok. Other than transpile, what word would you suggest?
Build.
Or assembling.
1. Yes. 2. Yes. 3. That's a bigger question. Do you mean a JS project that was originally a TS project? Then definitions are not needed. Do you mean a JS project? Well, definitions are normally created by hand, and few (if any) of such projects maintain their definitions file updated with the project itself, so adding another thing that needs to be done before publishing a new version is not desirable.
Interesting... Can you elaborate? It already is a command line interface no?
That's a TS 2.0 feature I believe: https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/
Sounds interesting, and I don't have an informed opinion either way. But I would say at the very least that it introduces friction when installing updates. If a minor version with no interface changes is released to, say, fix important bugs (from 1.0.0 to 1.0.1), you now need to wait for the definition-enabled package to be updated and republished. With separate package and definition dependencies, you can just update the main package dependency. That'd be automatic on a per project basis anyway as long as you used semver on your declaration. Definitely typed has [1837 packages](https://github.com/DefinitelyTyped/DefinitelyTyped) for definitions right now. Imagine updating all of them on every minor change of each. Some amount of automation may be possible, but it wouldn't guarantee it would be correct. A separate definition package gives project maintainers more freedom.
Good point. But couldn't you simply make your versioning in NPM just be ```^1.0.0``` so that when getting the latest it simply updates?
What about (as a class name): TypeScriptPackager? TypeScriptAssembler? TypeScriptBuilder doesn't sound right to me :/
nice!
So simply for the class name... I'm renaming to "BuildHelper". But then the question next is what function name should I call '.render()'... I need a world that effectively means "go" or "start". :/ 
Looks like you use the WebStorm compiler integration for your gulpfile.ts and gulp-typescript for your project source files. How is WebStorm not trying to compile your project source too? EDIT: The video references some setup from the "last video" but I don't see a link to it. Maybe you covered that there?
&gt; Aren't we headed to simply use NPM for everything? (no strong opinions there) God, I hope not. NPM is a flea market, not a boutique. There are some treasures there, but the vast majority of it is garbage.
@0:30 I explain that in your ```tsconfig.json``` you need to ***only*** compile ```gulpfile.ts```. Then you use gulp to compile the rest. ;) Does that make sense?
... previous video is indicated in the (i) card at the beginning.
Apparently there's shit in my ears. Thanks!
Stupid mobile web view. Didn't see it. Thanks again.
You basically summed up my experience with TS. It's great.
&gt; Implicit typing removes a lot of the ceremonial type annotations required in C#. I haven't used C# in a long time, but can't it do the same thing with the `var` keyword?
There's a lot I still like about C#, especially the fact that it's still *stricter* that TypeScript in some cases, and I prefer the way it does overloads (TypeScript still feels like a hack in that regard). But there's one thing I really like about TypeScript that is way ahead of C#, which is the way it does type inference (I think it's called "type guards"). This is valid TypeScript: if (typeof foo == "string") { console.log(foo.length); } C# (or rather Roslyn) doesn't seem to do that well. This is not valid: if (foo is Bar) { foo.someBarMethod(); } You need to cast first, which could be unnecessary. if (foo is Bar) { ((Bar)foo).someBarMethod(); } It is, of course, expected. But after using TypeScript for a while, it started feeling pretty dumb. Same applies to Java, of course, but expecting anything remotely modern or any push towards succinctness from Java is not realistic.
I believe pattern matching on the next version of c# will sort that out.
For local variables, yes. For things like methods/properties/fields, no. So, in C#, something like this: public class Foo { private string myField = ""; public string MyMethod() { return ""; } } becomes: export class Foo { private myField = ""; public myMethod() { return ""; } }
I like both. I would prefer the static checking of C# but my preferred environment (using Chrome as a front end) pretty much required me switching to JS/TS (Electron) if I wanted to get anything done. So I've been building up my TS libraries (after implementing them in Perl, Python, Java, and C#).
For me, the only thing left to feel at home w/ TS is making `this.` optional when there's no local variable or parameter w/ that same name within scope, like we got w/ both Java &amp; C#: class ThisTest { constructor (public a=10, public b=20) { } test1() { return a + b; // return this.a + this.b } test2() { return test1() * b; // return this.test1() * this.b } }
Could you elaborate further on this conversion process you mentioned please? I'm interested from Python point of view
That is true, I'm used to tslint rules that require explicit access modifiers on everything. C# has default access modifiers too so I think there's no real change in verbosity there.
Yeah, that was jarring coming to TypeScript, and when I introduce new folks to TypeScript, they say "why is this sprinkled everywhere." I could be argued that forcing references to this could mean better readability. When you have implicit references to this/base in C#, it's not immediately clear when looking at code if you're referencing something in the local scope or on the current instance.
&gt; if (foo is Bar) { ((Bar)foo).someBarMethod(); } Try this: (Foo as Bar)?.someBarMethod(); Once in a while I use is in a LINQ query but generally any time I care whether type A is type B, it's because I'm about to cast it. By casting with as, I can just check the result of the as operator for null. is, as, and type casting are all more expensive than a null check, so doing an is followed by a cast is significantly more expensive than just casting with as upfront.
Things I prefer about TypeScript over Java: functions, object literals, type inference, Typescript's interfaces and modules The things I don't like: 1 number type (no integer), 2 null types (null and undefined) I've just started with TypeScript though, so I'm sure my opinion will evolve and mature as I gain more experience with it
People writing classes in Java and C# often use a prefix like `_` to distinguish fields from locals. `this.` is like an enforced way of doing that. Of course, you can avoid it altogether by simply not using classes: function ThisTest(a: number, b: number) { return { test1() { return a + b; } }; } 
&gt; People writing classes in Java and C# often use a prefix like _ to distinguish fields from locals. Never seen such cases before in either Java nor C#! Instead, prefixing w/ `_` happens in languages w/o access level declarations like JS, Lua, Python, etc, in order to duck-tape that some member is `private`. IMO, it seems illogical to replace `this.` w/ `_`! 😲
&gt; it's not immediately clear when looking at code if you're referencing something in the local scope or on the current instance. Fields are generally declared at the very top of classes. And apart from the constructor, it's uncommon to find any local variables w/ the same name as of a field of its class. Therefore, if it's neither a local variable nor a parameter, it should be a field, even w/o `this.`. 😇 Besides, if we really wish for that `this.` pollution everywhere, just stamp everything w/ it! TypeScript should also allow us to freely choose whether to prefix or not members w/ `this`. :P 
Hmmm.. 1) Extending prototype of existing built in objects has always been taboo. Hence why ```prototype.js``` was effectively a failure. 2) Love how you think it's just that simple. The above LINQ library follows the same lazy principle as C# and operates on more than just 'arrays'. 3) Or you if you don't care about lazy, you could use what Arrays already have built in: ```var selected = array.map(s=&gt;s.property);``` ##### C# / JavaScript - .Any / .some - .All / .every - .Where / .filter Could go on here, but you get my point. And again, for JS there's RxJS and IxJS which are extensive and widely used. For me, I'm more comfortable with LINQ, it's syntax, how it works, and the generics provided. 
&gt; What I would love to see is actual LINQ. Query-syntax LINQ. A foreach keyword. A using keyword. The TypeScript compiler is open source. You wanna make something awesome? Fork the TS compiler, implement those language-level features (using your BCL, since that's how query-syntax LINQ works: the compiler translates them into an AST via the Expression class by using Expression.Call on the Queryable/Enumerable static extension methods). That would kick ass, and you'd get tons of users - although you'd probably annoy Anders. You may want to look a bit deeper here. I only pointed out LINQ because you mentioned it. As I pointed out, if you are only dealing with arrays, then it's best to just use the existing array methods. https://youtu.be/izQjE77TmOM?t=4m16s (I skipped ahead for you) 
Welcome to web development. It's an on-going scrap between multiple overlapping communities who are contributing ideas. TypeScript is aiming to track the consensus of those ideas as they evolve, while adding the advantage of static type checking. TypeScript is not the source of this complexity; it's just allowing its users to access libraries that conform to ES6 or to CommonJS. As you're not interested in the facts you can ignore the rest of this comment! The two `import/require` examples are importing modules that are not compliant with ES6 and in fact ES6 is effectively incapable of importing them. If TS didn't provide a way to import them it would be significantly less useful to its users. &gt; For example, there are at least 3 "LINQ" frameworks on npm and will be 3 more in another year as more and more developers just try to straight port C# into TS More fool them. They should read about `map`, `filter` and `reduce` and learn the native JS way to do these things.
I think that could be easy but I don't have any oracle database installed on my environment. Could you point me what version of oracle database (and what node driver) do you want to use? And may be I can try to code that this weekend.
I have no idea, I only use node for frontend stuff. No worries, just curious.
1) Implemented before they were available. 2) IEnumerable isn't exactly the same and has a familiar pattern for .NET users (```.getEnumerator()```). I then extended IEnumerable to be forward/backward compatible with Iterators. Generators are ES6. So if you want them as is, you have to currently do all the Babel/Traceur bs. IEnumerable does what we as .NET developers expect and allowed me to continue the inheritance chain with ICollection, etc and do so with ES5. :) The pattern I have for creating an enumerable isn't as simple as writing as a generator or a true C# yield return, but it works and has an init and dispose phase. // The name EnumeratorBase came out of a conflict with IE. new EnumeratorBase&lt;T&gt;( () =&gt; { // init. }, (yielder)=&gt; { // yielder logic }, () =&gt; { // any cleanup }, isEndless ); 
&gt; Welcome to web development. It's an on-going scrap between multiple overlapping communities who are contributing ideas Correct. As an ecosystem, this is one of its weaknesses, but it's not "web development" - it's web development using the the node/npm stack. .NET developers typically have one and only one choice these days - ASP.NET MVC - with, if they choose, a couple of optional client side frameworks which are pre-selected for them by a curator (Microsoft). Express and Connect are MVC-esque, but right away, there isn't a gold standard, so the process begins with decision fatigue, and continues with decision fatigue the deeper you go. So, "using C#" for web development generally means that, and that is one of that platform's strengths in contrast to one of the node (and, preferably, the TypeScript language on top thereof)'s weaknesses. &gt; TypeScript is not the source of this complexity; it's just allowing its users to access libraries that conform to ES6 or to CommonJS. Never said it was, only that it could do a better job of erasing that complexity. TypeScript is a tool to make JavaScript better, and in this area it hasn't done enough, IMO. &gt; As you're not interested in the facts you can ignore the rest of this comment! No need to be rude or to jump to conclusions, buddy. &gt; The two import/require examples are importing modules that are not compliant with ES6 and in fact ES6 is effectively incapable of importing them. Again demonstrating my point about how this is currently a failure of the language and ecosystem. If there's a way for me to know which npm packages are compatible with ES6 *before* trying vainly to import them using one of several "include" mechanisms (import/require/whatever), I certainly don't know what that is - and that's after investing a large amount of time into TypeScript. If those modules can't be imported by ES6 then a compiler warning to that effect would be nice. I've read a fair bit about modules and you're the first person to coherently explain *why* two different mechanisms were even used in these samples. I knew something was up with certain npm packages, but I didn't trace it to ES5 vs. ES6. It clears things up, so thank you. &gt; More fool them. They should read about map, filter and reduce and learn the native JS way to do these things. I agree. I'm having a side conversation with /u/electricessence in which I am trying to dissuade him from porting the C# language and its BCL into TypeScript but it's not going well. 
[removed]
(applause) &gt; TypeScript on the other hand has PromiseLike&lt;T&gt; in its lib.d.ts. I don't know if this means promises are therefore the TypeScript way or whether they're just trying to be unopinionated, but I like promises because they're like .NET tasks. Like, mind you - not exact copies of. They get me to basically the same place (well, your LazyPromise is more like tasks, really) but as a .NET convert I can understand them relatively easily. PromiseLike&lt;T&gt; is there to guarantee based on standards agreement that the ```.then``` signature is available. Without it async/await would not be possible going forward. Yeah, I agree. I actually have a branch that attempts to copy/port the System.Threading namespace, but there is/was a clear point of breakdown and over-engineering for engineering sake where it just doesn't make sense to continue. I only began to create promises and task-like classes that made sense to make. Not fully copying .NET but attempting to adapt to the fusion of the two paradigms. 
Thx for the clarification! I was pretty aware that in C# even methods were UpperCased. In Java &amp; JS, only classes &amp; interfaces are. But as you can see from @smellegantcode's comment: &gt; People writing classes in Java and C# often use a prefix like _ to distinguish fields from locals. Which for me is totally bizarre, given the traditional use of _ is to indicate private access for languages lacking an easy way to enforce it. However C#, just like Java, got the `private` &amp; `protected` keywords. Dunno why C# would have any need for _ underscore though. :P Nonetheless, what I'm trying to convey here is that both in Java &amp; C#, `this.` is optional. And since TypeScript can statically analyse code, it shouldn't be too hard to bring such feature to it. :D 
Assuming this is for browser... just add a script tag and use it as is, without type info. Sometimes people forget (or don't know?) that this simple approach works.
X-Post referenced from /r/reactjs by /u/Xananax [I wrote a little library to reduce redux boilerplate and co-locate stores and components, hope it is of use to anyone. if you can test it and give feedback, it'd be terrific.](https://www.reddit.com/r/reactjs/comments/4pzdyf/i_wrote_a_little_library_to_reduce_redux/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I've never used webpack, but maybe it doesn't like relative paths in `require` calls?
It's the lesser of the two evils.
Any idea why it's using Symbol values for types?
Thanks! You can expect these issues to be improved we are awaiting typescript 2.0 to be released to remove external typings repository.
Symbols are immutable which can help us to prevent errors.
No major breaking changes associated with the PR, so maybe a line in the sand moving towards release candidates?
Is this in response to my reply above? If so you should reply directly to my comment to keep the conversation organized. It's just a reddit thing.
yes...my phone messed up! Thanks again! 
I can't remember ever being hyped for the major release of a programming language before. HYPE
https://github.com/webpack/webpack/issues/2142 Ok.. so although it definitely freaks out with UMD... I've also found webpack doesn't like whole lot of things: 1) any non-standard ```require``` usage it freaks out. 2) any node only modules it can't resolve and errors. Any way to trick webpack into ignoring this stuff? Since all the times I do the above I use an if statement to avoid errors.
Ok was able to solve this: 1) Need to resolve 'child_process': https://github.com/webpack/webpack/issues/744 2) Then need to use 'eval' to capture the require object so webpack doesn't parse it. 
When you pass a reference to a function, for example when adding an eventlistener to a mouseclick, the meaning of 'this' in that function can be quite confusing and undesirable. You can use .bind to set the correct scope for 'this', or use arrow functions which look much cleaner.
For regular JavaScript functions you can consider `this` as just another argument: `function f() {}` * `context.f();` here `this` within `f` would have the same value as `context` * `f.call(context, arg1)` here `this` within `f` would have the same value as `context` * `var f = context.f; f();` here `this` is undefined Such behavior has very limited applicability scope, and most of the time developer does not expect this behavior. Hence different ways of solving this problem: * `Function#bind` solves this by "binding" different arguments (including `this`) to some value. `f.bind(context)` will return a new function that calls `f` with the value of `context` as the value of `this` * `var _this = this; function f() { /* use _this instead of this */ }` a common "manual" workaround. * Arrow functions: `a =&gt; this.b` arrow functions are basically an automated workaround from the previous bullet. Arrow functions retain `this` from the outer non-arrow function, which is what you want most of the time: class A { constructor() { this.f = () =&gt; this.value; } } (new A()).f(); // OK var f = (new A()).f; f(); // OK Here `f` member function will always have the proper instance of class A as the `this` value.
Thank you! I'm only learning the ropes, so it's good to see a barebone project, the structure, tools, scripts, etc.
I'm getting starter kit fatigue... what's the difference between this and your previous one? https://github.com/Kflash/sikky
Awesome timing for me. Coming from a .NET world - really excited to use this 
If you want to try typescript@next in VS Code, don't forget to set the "typescript.tsdk" property in your *settings.json* file. https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions