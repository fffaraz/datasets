Don't you mean pHpStOrM? 
this is what I use every day: - PHPstorm, for bigger Projects it might get slow, then I use sublime text or atom. - composer - xdebug extension for working with breakpoints - docker (for working with multiple PHP versions) 
I also remember the time when Zend Framework was a thing (a slow thing I should admit) and JetBrains products just hit the market. So much time passed already, uh. At a time when I tried Eclipse (failed and moved to JB IDEs), I had to invest significant time into setting up configuration. Then I had to migrate it to other machines, it was a nightmare (6 years back), hope these days the issue has gone. Also, a new generation of developers is amazing: I keep learning from them constantly =) And I definitely like your writing and salute you =)
Always: Composer Sometimes*: PHPUnit for testing, Psalm/Phan for static analysis Occasionally: XDebug (if you're doing something fancy, and want profiling) *sometimes you don't need assurances about your code, e.g. when writing an MVP
Unfortunately, this is something that's really hard to prove to people. It's one of those things where you have to spend a lot of time doing things both ways, and then start to see what a false siren debuggers are and why they're so insidiously inefficient. The fundamental problem is that they lull you into setting breakpoints and single stepping rather than thinking about the problem. When you put in print statements to write to a log file, you have to put in the mental prep work to think about what's relevant to the problem. Sometimes just that process leads to figuring out what the problem is. The other advantage is that putting in debug statements into logs gives you more easily interpretable information. If you want to see what happens through a loop, in the debugger people typically run each loop iteration or watch the result of each function call. When you run it and all that is dumped to a log file, you have that information in a flowing narrative that's much easier to see what's going on, and it's all right there. Generally it takes a lot less time to stick in a few print statements and do another run than it does to sit there and SS, SS, SS your way through it. And then if you have to start all over again, setting up the circumstance is another big pain. But print statements are cumulative. You can add more and typically rerun whatever you're testing very quickly. Note this is also a huge boon to reliability, because you're seeing a log of an entire run. That gives you a much broader view of what's actually happening. Like I said, this all very counter-intuitive and people never believe me. But I've done it both ways, in a variety of different projects and languages, and there's just no question that debuggers are insidiously evil.
Still regularly used in level 3 and below education in the UK. Teachers taught in Dreamweaver as its great for people who are less technically inclined but very bloated for any real development. 
And a shoulder to rest your head while you rage
Excessive stupidity can cause brain damage
Notepad++ and netbeans
All I'm trying to do is give an idea on the range of projects I've worked on. In many ways I'd say the small niche webapps were more bad ass than the large ecommerce site. Point is that you can thrive without a full blown all in one IDE.
Insert "ACKSHUALLYü§ì" meme here
Hmmm PHPStorm has got a very good db tool. Have you tried it instead of MySQL Workbench/SequalPro?
Unfortunately, the Eclipse foundation still uses [Bugzilla](https://bugs.eclipse.org/bugs/). They maintain plugins on their Github page, and the IDE has a built-in dependency manager that you can add third-party plugin vendors to and view all plugins with a nice search feature and summary text. I really like the Jetbrains IDEs. But the C / C++ extensions haven't been updated in a couple of versions and no longer install in a current version (CLion is an older build of IDEA), and there's no Haskell support. 
Most people have given great answers. I'm learning PHP and for my money I don't actually see how you can work on PHP *without* composer and a decent IDE and proper logging in place. I would also like to add Google in there. I have no idea how you can write decent PHP code without Googling. One example is T_PAAYAMIN_NEKUDOTAYIM. 
I spent much time in getting the IDE I feel comfortable with. I tried Eclipse, Netbeans, Visual Studio Code, Sublime and in the end I am using PhpStorm now. For all the other IDEs you have to invest much time to get it as comfortable as with PhpStorm. I like the integration of Git which lists all code problems and prevents you from comitting. I like the integration with Vagrant / Docker. My Webserver, DB etc. is all running in Vagrant Box. I'd love to use Docker but since the OS I have to use is Windows Server 2012 there is still the Boot2Docker needed. In PhpStorm you really have support for all the latest PHP technologies and language improvements. In general the tools I use daily when developing: * PhpStorm * Git * PHPUnit * Composer * xDebug (sometimes) * Vagrant * rsync :D
Very good suggestions in this thread. Let me add some of the tools I use daily: * phan * phpstan Both static analyzers. You'll hate that they make you fix trivial mistakes at first, but ultimately they'll make you a better developer and code-reviewer.
And hard liquor for when you do git blame on the badly written code...
Excellent stuff! Thanks
Please don‚Äôt downvote this. He is asking a genuine question and is adding to the conversation. 
Especially when you realize it‚Äôs your own code
You're fooling yourself there. Printing stuff to the logs will never give you the same amount of information you can get with a debugger. It also won't allow you to change the state to try a different flow or something like that. For small projects that may be fine but I would hate you for life if you littered my prod logs with your shitty var_dumps. Using a debugger allows you to see what's happening instead of trying to guess where to put your print statements. Saying that setting up the circumstance is a pain shows that you probably don't really know debuggers that well and you're bashing something you have little knowledge about. There is such a thing as conditional breakpoints, you should look it up. Finally, I find your superiority tone really really annoying.. And defending var_dumps over using a debugger is borderline sociopath
Docker is absolutely perfect when working on school projects. Sure, it may cost some hours to get right. But then everyone has the exact same environment, taking away a really big bottleneck.
It is overdoing and you should take this with a grain of salt. You don't NEED most of what he listed to develop efficiently. Version control, a nice db client, a good editor or preferably an IDE, a debugger, a testing framework and a package manager should be more than enough. Also, you don't have to use those flavors of these things, check them out but also check the alternatives
My first job out of college was writing PHP in Dreamweaver. On our production server. 
&gt; Finally, I find your superiority tone really really annoying You're probably right that I should've phrased things a bit more diplomatically, but I was annoyed by the superior tone of the IDE advocates. Still, no excuse. Like I said, I've had this debate before, and no one believes me, even though I almost universally crank out more quality code than others. This is just Reddit, so it'll sound like bullshit to you, but there's are reasons that I came to this conclusion. There are also reasons why the very best programmers typically don't use IDEs and typically use Vim. That's not universal (notably John Carmack uses an IDE and doesn't use Vim, sadly), but it's more often true than not. Torvalds notoriously hates IDEs. In fact, looking for a juice quote from from Linux, I came across [this blog post](https://lemire.me/blog/2016/06/21/i-do-not-use-a-debugger/), which funny enough has famous programmers saying what I said almost word-for-word: * Linus Torvalds, the creator of Linux, does not use a debugger. * Robert C. Martin, one of the inventors of agile programming, thinks that debuggers are a wasteful timesink. * John Graham-Cumming hates debuggers. * Brian W. Kernighan and Rob Pike wrote that stepping through a program less productive than thinking harder and adding output statements and self-checking code at critical places. Kernighan once wrote that the most effective debugging tool is still careful thought, coupled with judiciously placed print statements. * The author of Python, Guido van Rossum has been quoted as saying that uses print statements for 90% of his debugging. The one place that debuggers definitely came in handy was in assembly language programming, mostly because seeing processor state is often important. &gt; And defending var_dumps over using a debugger is borderline sociopath Or maybe you don't know as much as you think you know.
Badly written AND uncommented.
Why does it make you sad that Carmack doesn't use vim? Also, https://en.m.wikiquote.org/wiki/Argument_from_authority
Yea I just use notepad++ guess I'm missing out with all the other stuff
Wondering why some people not expand an IDE window? Too big displays? 
VSCode can do pretty well with the right plugins/setup for free, but nothing feels as smooth as PHPstorm. So many nice built-in features. 
No, I mean that on the screenshot I see an editor window not expanded and there are gaps on the sides and I see the desktop background. I saw Taylor Otwell does the same.
I'm with you, can't stand phpstorm. VS code is just so much more intuitive
Try vs code. Just as fast, just as light weight, but with some cool add-ons like integrated terminals, xdebug integration etc. And before you scoff because it's windows, it's an open source project.
oh that one. I have no idea either. That is just a stock photo I found on the internet. I myself prefer a full width window for work. I don't have a big screen though.
To do that I use Notepad ++
For what you've described, I'd do a _combination_. I'd absolutely use a framework... because that 5-10% is going to save you a tonne of time. That 10% is likely going to be made up of: * turn key auth with password reset and activation flows * a pile of testing infrastructure that you just don't need to set up * build/asset pipelines for your frontend bits * solid building blocks like cache, queues, mail, notifications Obviously your milage will vary framework to framework...but typically I need those things all the time, and not having to write them is a major leg up. But then, if you are adding member area, a profile page and a settings page every time, build out some libraries which are compatible with your framework of choice and just plumb them in on every project you work on. The idea here is to spend as little time as possible on the things which make every project the same, leaving you as much time as possible to spend on the things which make them different.
Makes me happy that other people are actually using Vim in professional environments as well. I've stuck with it the past 8 years or so, and it's so incredibly convenient to just be able to copy your .vimrc into almost any remote UNIX system and just start developing, and it's not exactly difficult to set up the plugins you need. I don't have anything against PhpStorm, Eclipse, Aptana Studio, etc., it's just that Vim is the editor/IDE for me. 
You can tell this guy must be a joy to work with... His poor co-workers
Got it, it's pretty close to PHP infrastructure when core team took extensions maintenance over to get them stable. It's also a good idea using GitHub - the infrastructure is there already, less headache maintaining own infrastructure. You know, your programming language set is pretty advanced =) 
Contrast for the picture ?
Why do we even care about performance when using php. If you want performance use java or dotnet. 
Get over yourself.
+1 from me. Very lightweight, much simpler. I also love that I can very easily write my own plugins for it to customize it to my liking. I did just that to be able to render binary uuids correctly so I can easily copy the string representation for testing specific records
Yep, I love psysh! I usually think of it as "tinker" though, which is laravel's name for it.
Another useful page is https://semver.mwl.be/
I think better would be public function runFunction($num_apples) { if ($num_apples !== 5) { return; } //do stuff }
Archlinux
I'm sorry for you if you had bad experiences with the tool. Just, when exactly is "the past" ?
I understand your point, except for the part about it being hard to read. I'll be reading it as "run function if num apples equals 5". How do you read it?
I agree
How does your approach make things any simpler? why not to combine these statements in a songle consitional, like if ($num_pears == 4 || $is_raining ) $class-&gt;runFunction();
I read it as "run function if num_apples equals 5"
I've never seen something like this before, which means I have to take a double look to see what its actually doing, and then I would have to check the body of `runFunctionIf` to double check what it did. It would then give me less confidence in the rest of the codebase to be "normal". Also calling the function `runFunctionIf` doesn't make sense because you *are* calling the function, despite what you pass in. It increases function parameters which in general adds complexity, especially if you are calling that function from other places where you don't need to pass a conditional and just passing true/false every time. 
The conditionals don't appear together, they are scrawled all over the app
People that read a lot of code will not read it like this. 
yup.. exactly
I don't think one should give up easily, especially when the initial responses are basically just saying it's no good without explaining further. After asking /u/betterhelp a little bit more, his second response has actually convinced me that it's not a good idea.
Maybe worth mentioning in the title that this is Laravel specific.
You've got it backwards. The code sample doesn't require a docker harness. The docker harness requires a code sample.
I think one thing that you're missing here is that as an experienced developer you're much better at understanding what code does. Junior developers will often find reading code and just knowing how it's going to act much harder, which is where actually looking at what the code is doing is very useful. If you're working on a very large system then it becomes even more useful if the same code is repeated in multiple places but in one specific place it's not set. Remember that as awesome as Linus is, he's not a domain programmer, he's a systems programmer. Most PHP development is business logic which doesn't map well onto languages such as C and Go.
one of my cousins did a PHP course here. He is now in a very good position and a well-known web developer now.
What @cronofdoom said - each tool serves its own purpose.
People with basic English literacy will.
I always laugh when I read that. "Launches the fastest". How many times a day to you launch your editor? Does it really matter if you wait 3-4 more seconds at the beginning of each day? fwiw I use neovim ; I don't remember what a launch time is, but that's reason #989342 why I would use an editor over another..
When I learned phpunit I didn't used a MVC framework.
nice 
You realize you're commenting on your own posting, right?
This tutorial has been done countless times by countless people in books, blogs, and youtube videos. What are you offering with yours that hasn't been covered already?
Clearly hoping to earn revenue from youtube ads rather than provide new, relevant information. As mentioned by dlegatt - This tutorial has been done countless times. Your motivation is clear.
The image size for nginx is 544MB and the php-fpm is 799MB. The base centos image is 197MB. If you're worry about disk usage, there are pre-built images that are much smaller than this. https://hub.docker.com/_/php/ https://hub.docker.com/_/nginx/ If you need to install new packages, you can run ```docker exec -it &lt;container id&gt; bash```. This will get you into the container and you can run whatever command you like. Also, if you want to be able to reproduce this again, edit the Dockerfile (https://github.com/iamawwsome/docker-nginx-php-fpm-7/blob/master/.docker/php-fpm/Dockerfile)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [iamawwsome/docker-nginx-php-fpm-7/.../**Dockerfile** (master ‚Üí 222e32d)](https://github.com/iamawwsome/docker-nginx-php-fpm-7/blob/222e32d0984f03d72f4767537e88fd1d30d4f7b8/.docker/php-fpm/Dockerfile) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
This kind of structure indicates a problem in your code structure. Either the code calling the function should care about the condition, or the function itself should care about the function. This design ensures both sides are aware of the conditional, so it's leaking. For example, if you have User object. You could have a "role()" function that returns based on a conditional, but anything using the User object shouldn't be aware of it. Alternatively there could be a User "save()" function that updates the user, and the code calling it only wants to save if it has some condition, but the User object doesn't care about that condition.
Because there isn't any argument to make against fanboyism, it is plain stupidity and arrogance.
Also ibuprofen, but not too much!
Why not just do if ($num_apples === 5) { $class-&gt;runFunction(); } IMO, the calling scope should be handling the condition check, not the function.
What if your magical number of 5 changes? Your client says today: If i ate 5 apples, stop eating. So: ```if($client-&gt;numApplesEaten &gt;= 5) { $client-&gt;stopEating(); }``` One year later, you have another job and some other guy at your old job gets a support ticket: "This application doesn't work. I'm always hungry!!!11!" After some digging he finds the client can't eat more than 5 apples. "This application is surely the worst one written ever!!!1"; He has to replace the number "5" in many places, accidentially repacing the number of weeks in a year from "52" to "72", thereby creating a new problem for the next guy/girl. So why not introduce a constant, define or variable that says: ```$numberOfApplesClientCanEat = 5;``` (Bit too long variable name, but this isn't about naming things) After that, it waaaaay easier to change the app to changing requirements: ``` // $numberOfApplesClientCanEat = 5; // 2017 $numberOfApplesClientCanEat = 7; //2018 if($client-&gt;numApplesEaten &gt;= $numberOfApplesClientCanEat) { $client-&gt;stopEating(); }```
It looks good but I would personally prefer to keep the JSON-decoded data as pure PHP arrays and objects. The getters and setters are a bit weird to use to be honest, lack of (assoc array) autocompletion from IDEs, comfort of isset() calls, etc. Also, you could use [json_last_error_msg\(\)](http://php.net/manual/en/function.json-last-error-msg.php) instead of [this](https://github.com/jshannon63/jsoncollect/blob/71c4bf9fb2d6b97139e927659506f88cab0306c4/src/JsonCollect.php#L62)... or at least fallback to that function if you want to override the error messages. 
Not only do you suck at asking questions, you also missed the big notice on the submission page for this sub which says *"Please note that /r/PHP is not a support subreddit. Please direct all support-related posts to /r/phphelp"*. Try again and try not make people give you a full solution but rather explain what you have tried and what specifically you need help with.
You have some valid comments. As far as the IDE issues, it can cause some clunkiness. All said, I believe it is a matter of preference as I have found collections to be very empowering and tend to clean up my code quite a bit. Good suggestion on the JSON error msg handling. Think I will take your advice on a future release.
As a golden rule, I'd say that calling functions and methods is expensive (slower than not having to call them). So if you can avoid the call, do it ;P 
My own completely unsupported hypothesis is that Fabien was just having a bit of fun when posting this article. For years Symfony has been characterized as bloated and slow. Benchmarks always seemed to use the standard edition which contains quite a few optional modules. Serious developers already knew that, unless they were fortunate enough to get paid writing Hello World applications, that real performance was basically unrelated to the out of the box benchmarks. So now Symfony has a new and much slimmer default installation. And hey, less code turns out to be faster than more code. The tables have been turned. Take that. Hah. Justice has been served. Of course once you add back in the code that most real apps need then speed differences due to frameworks pretty much goes away.
IMO `setname` and `getname` are a bit weird, but I guess that's because the library doesn't make assumptions whether `setName` should be `name` or `Name` in the JSON dictionary. A possible solution to avoid these names would be `-&gt;name()` and `-&gt;name('foobar')`, where the version without arguments is the getter and passing an argument makes it a setter.
I wrote [Chronicle](https://github.com/paragonie/chronicle) because not every problem that sounds like a good fit for a blockchain actually calls for a blockchain. This is a client-side library for writing arbitrary data to a Chronicle instance. This is useful for security event logging. If you setup a Chronicle that your services can write to, then have private Chronicles configured to replicate *that* Chronicle, you have verifiable and tamper-proof security event logging.
Not giving an opinion on whether this is good practice or not, but just wanted to show what I'd think if I see a function named `runFunctionIf`: function runFunctionIf(bool $condition, callable $function) { if ($condition) { $function(); } } it can then be called like this, callFunctionIf($num_apples === 5, function () { echo 'Yay!'; });
HORSE SHIT
https://github.com/FreeDSx/LDAP Posted this a while ago, recently tagged a new version. It's a pure PHP LDAP library (no core LDAP extension needed): * Renamed from phpDS to FreeDSx (avoiding confusion with the phpds extension). * Added LDAP server functionality. You can add your own request handler to respond to client requests. * Added an LDAP filter parser so you can use string LDAP filters in searches. * Added lots of documentation for both client and server usage. The LDAP server piece is *nix only since it requires PCNTL (uses fork on incoming clients).
Doesn't matter, stars are 1 per account anyways. And this looks more like a bug.
Ok, show us on the doll, where did Symfony touch you 
Yes, is a bug. I remember one time than google had something like this for a gmail feature, I fill the inbox of a girl that I liked with gmail notifications. 
uhh you again are you following me or what? just block me already :D 
I enjoy reading r/php. Your shitposting lessens my enjoyment. I don‚Äôt like blocking people because I‚Äôm not a three year old. Besides, not everything you post is shit. 
As we already knew: India =&gt; Codeigniter France =&gt; Symfony Russia =&gt; Yii2
Wow there's a lot less symfony usage than I expected. Makes me a sad panda
&gt; Excessive stupidity can cause brain damage. Gotta love the php community 
Hey Scott, do you know what the throughput and concurrency handling of Chronicle looks like? It seems like a good fit for event-sourced applications with particular security requirements.
You are a strange, sad little man. 
I was waiting for you :D
Off topic, but how well does docker work on centos?
With Doctrine you can drop down to using SQL + PDO whenever you have to. Seems you just need to learn how to use it properly...
Actually I would have liked to use only the key name for the getter/setter methods. Unfortunately, I feel it is too likely that a dataset would contain keys that would conflict with the 100+ methods of the inherited class. So to avoid any conflicts I just prepended get/set to the key name and moved on. The __call magic method will respect the case of the JSON key.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Eh. A relevant class that is supposed to do something would probably be helpful. TDD you should start with a failing test and make it pass.
So, what's really a difference between using this library vs. designing proper data structure and using Symfony Serializer component?
I have not encounter any issues using CentOS as the base image. 
Looks interesting, but after a quick read-through of the docs I'm unclear what functionality this provides above and beyond the tightenco/collect library that it's wrapping?
This goes beyond just serializing/deserializing the data. The main benefit of moving the data into properly structured collections is to be able to leverage the large number of high order functions available for collection handling. The related code becomes easier to refactor, maintain and it is a lot more readable. IMO.
Actually, very little... but what it does do is quite important. it deep dives the data set making sure that everything is collection friendly. So that the Illuminate Collection library can work un-impeded on the entire contents of the collection. It's a simple tool and credit is certainly given to the great library it was built upon. I used it for a project and it proved very helpful... so I though it best to share.
So what does it have to do with JSON?
It is tuned for JSON. JSON comes in.... gets something done to it.... and then JSON goes out. The project this library proved useful for was a micro-service that received a large and deep JSON data tree. It had to perform several hundred operations on the data and then return it. The high order functions available for collections made the task quite easy.
I have certificates in SQL. I know Doctrine all internals very well. I have no problem in using it.
Your videos are terrible, please stop trying to teach people to program before you have learned for yourself. Also, excessive self promotion is against the rules of this subreddit 
I use phpcd. Works great.
Yeah also passionless programming still pays a lot better than working an assembly line. That's a pretty bad example. He must have worked in a really fun factory at some point.
Performance is going to largely depend on: * Which database backend you're using (MySQL, SQLite, PostgreSQL). * Whether you're using sodium_compat's implementation or PHP's. * Server configuration (e.g. HTTPS ciphersuites, PHP OpCache) But when you strip everything away, writes basically have the cost of dealing with database transactions and a [BLAKE2b hash](https://blake2.net).
Thanks, does it support rename func or variable?
I find this cycle of "we must come up with and use as many weird standards as possible" ---&gt; "oh no, it's all so complicated now! it sucks now!" very funny. REST is not the new SOAP, because REST isn't even a thing, everyone molests it into their own definition and so it means about a billion different things. Just write simple HTTP APIs. That's all there is to it. It's very simple. A standard should be used when **immediate** value is to be gain, not future or theoretical value. In most cases, you don't need PUT, DELETE and PATCH. There I said it. If these were so crucial, HTTP forms would probably support them. They don't. They know something you don't. Just use GET, HEAD, POST correctly. There - it's simple again.
Coincidentally, GraphQL uses HTTP as a dumb transport and there's only queries and mutations (like GET and POST). If mutations can insert, update or delete, so could POST all this time. All the complicated workarounds inserting hidden _method fields in forms were not necessary all this time. All the thoughts about which method, and which response status were right for that REST API were just wasted time.
It's just an anecdote, but one of the vendors I deliver data to, recently announced that they're switching to a REST api in stead of SOAP. The actual change consisted of taking the usual xml payload, json encode it and put in the body of a standard HTTP POST request (including a Basic auth header). This fabulous new REST API has *one* static endpoint that supports *one* HTTP method. I sure as hell hope it was worth spending hours figuring out why it always returned 400 Bad Request. Lesson learned: Don't sheepishly add a "Content-Type: application/json" header just because the docs tell you to. Because the actual server might not even know what that means. Luckily the server (IIS) was configured in such a way that the api user (me) would receive a *very* detailed stack trace in the response body. Otherwise I would never have caught on to that particular error. I once thought I understood what RESTful means, but those days are long gone. Now we're at a point where it can literally mean *anything*, and it can add several layers of confusion to something that ought to be the simplest thing in the world. I don't know the full story, but it seems likely that someone from middle management was laughed at by friends when he told them his company used SOAP. Then some poor developer was told to convert the API to REST and have it ready by Monday. Mission accomplished, legacy secured.
So are the cool kids doing RPC again? Now seriously, I am considering using json-RPC to do internal integration between systems. I seems better suited than a REST call, in this case.
I use it similarly, but still close it - the fact that it stores unsaved documents/changes is my favourite thing about it.
JSON RPC is great.... although I am desperate to a-hem... extend it... by including a parameter which defines an object to call it on. 
I implemented graphql api recently, and found it cool. It is pretty much RPC, but self describable and the client gets to choose what data it wants to get as a response.
Why not just have a specific endpoint?
I largely agree, but when working with more sensitive data and/or significant caching, you need PUT. Being able to accurately predict the state of the server generically is incredibly useful and not something baked into POST.
I feel like this is the root of the author's agitation: "I don‚Äôt care. Trees are recognized by their own fruits. What took me a few hours of coding and worked very robustly, with simple RPC, now takes weeks..." He seems unhappy that REST doesn't work the way his familiar tool (RPC) does. I myself worked with middleware-messages-over-TCP systems for a decade before switching to web apis. I don't have this issue. And I personally don't follow the "holy specification", and REST works just fine for me.
 How do you express the diversity of error conditions, using the very limited bunch of HTTP codes? Use swagger to document it, it allows you to document only one [error per status code](https://github.com/swagger-api/swagger-ui/issues/1466) /s /s /s
Not exactly php-specific, but vdebug is a good DBGP client. Linting with phpmd and phpstan is done using Ale (which it looks like you're including anyway) I briefly used https://github.com/adoy/vim-php-refactoring-toolbox for simple code generation and refactoring, but it was all a bit ghetto. Been a couple of years though so might have improved? Worth evaluating. And maybe not ready for prime-time yet, but https://github.com/phpactor/phpactor is a very exciting project (with its own vim plugin) that in theory could turn into the real solution for AST based refactoring, restructuring, code gen etc. Worth keeping an eye on at least.
OP uses a CentOS container through Docker. Docker itself is running on OP's own OS which might be (and probably is) an entirely different one.
PUT isn‚Äôt about write through caching, which you seem to be talking about. This isn‚Äôt a part of the HTTP spec. The write representation may not be the read representation. The server may resolve incoming representations in unpredictable ways. I know that cache proxies like Varnish support write through caching with PUT. But this is the reason why this isn‚Äôt enabled by default. So you already have an additional layer on top of HTTP here. PUT caching is at most an optional convention, not a standard.
There are people using php for everything too
To reiterate, I don‚Äôt think we disagree on implementation semantics. That said, PUT is defined as idempotent, which comes as a major benefit in that you can predict your impact on the server, if even only the PUT representation. You correctly point out that the GET representation must be the same for PUT if local predictability is to be attained, and I believe that is part of the trick of making a good REST API, which IMO should generally end up being CRUD-like in the end. REST is the philosophy that, if followed, should produce some level of robustness for your need of robustness, but it‚Äôs not an implementation prescription.
so graphql is the new black?
https://github.com/amphp/parallel-functions ‚Äì A library to easily write parallel PHP code.
Fieldman says REST is not about CRUD. HTTP also doesn‚Äôt define the PUT semantics you are talking about. So it‚Äôs up to opinion, optional conventions and hearsay. Don‚Äôt confuse optional convention with a hard standard. When use cache with PUT, this is not REST and it is not HTTP. 
This is why REST is so contentious - everyone has their own definition. As I believe it to be a philosophy, like any other philosophy, you take what you want and you leave what you don‚Äôt. A central tenant of REST is cachability- to discount the potential of caching PUT, IMO, should at least be a conscious decision. Is that a hard standard? Of course not. Is that in the spirit of REST? I believe so. You have a gradient of RESTfulness and each API falls somewhere on it.
OP uses CentOS/RHEL as host machines and CentOS containers for production. Enterprise software and vendor are very picky and rarely update their software to support the latest and newest version. Also, OP uses MacOS to do day-to-day task as it's the best of world (Windows + Unix).
Speaking strictly, REST is not a religion so it‚Äôs not a matter of belief. It‚Äôs what Fielding defined it as. But yes, absolutely everyone has their own idea what it is. Which is why saying it‚Äôs like SOAP is laughable. SOAP at least knew what it was. REST is everything and nothing. A term so overloaded it is entirely useless right now. 
I was 100% sure this was going to be yet another "use GraphQL for everything and forget REST ever existed!!" article. Glad I was wrong!
&gt; This is why REST is so contentious - everyone has their own definition. As I believe it to be a philosophy, like any other philosophy, you take what you want and you leave what you don‚Äôt. It's not a philosophy, it's architectural style. You know - strictly speaking, REST is what Fielding defined it as. He came up with the term, he wrote the paper, it's somewhat ridiculous that everyone claims REST is what they personally believe. It's basically like me saying I personally believe Jesus hates gingers, therefore that's what Christianity is about. Well, Fielding's paper is much simpler to interpret than the Bible and it's there for everyone to read. But instead it's there for everyone to ignore, I guess. But yes, absolutely everyone has their own idea what it is. Which is why OP saying it‚Äôs "the new SOAP" is laughable. SOAP at least knew what it was. REST is everything and nothing. A term so overloaded it is entirely useless right now. &gt; A central tenant of REST is cachability- to discount the potential of caching PUT, IMO, should at least be a conscious decision. "Tenet", BTW ;-) Also, you're reading REST like Satan reads the Bible. Yes, caching is *one* of the constraints of REST. But another is "uniform interface". When **some** people choose to make **some** of their APIs have write cache through PUT, this is the exact opposite of uniform. It's ad-hoc, it's arbitrary. Also how much more clearly could've Fielding spell it out in his actual REST paper than this: &gt; 6.3.3.2 Write-through Caching &gt; **HTTP does not support write-back caching.** An HTTP cache cannot assume that what gets written through it is the same as what would be retrievable from a subsequent request for that resource, and thus **it cannot cache a PUT request body and reuse it for a later GET response**. There are two reasons for this rule: 1) metadata might be generated behind-the-scenes, and 2) access control on later GET requests cannot be determined from the PUT request. However, since write actions using the Web are extremely rare, the lack of write-back caching does not have a significant impact on performance. Emphasis mine. So, any doubt left? Using PUT to cache GET request **is not REST and it's not HTTP**.
&gt; In most cases, you don't need PUT, DELETE and PATCH. There I said it. Oh my god you heathen! We need them because they're *semantic*!!! What will my browser inspector think of me if I'm sending delete or insert instructions with a POST request? ^^^/s
The sustaining popularity of those gimmicks is frankly fascinating.
You dont like DI contianers?
This isn't a IoC container. It's basically an autowiring service locator, used for *what looks like DI but isn't* and what *often is incorrectly referred to as IoC, but isn't*. There's no inversion of control here. The components reach out and can grab any singleton from the environment through automatic resolution. Anyway, long topic. Long story short, I like IoC containers. I like DI. This is neither of them in any way, except in name only. 
I just thought you didn't like the idea of IoC or DI, my bad
This walks developer through the process of inventing new product. However, it does not say how to evaluate the result of this walk-through, which is "open source canvas", or what to do with it. Also, text is hard to read.
Author used a lot of words to say "don't be rigid and ideological, just be pragmatic."
If someone doesn't like idea of IoC, then probably he shouldn't use frameworks (since it's all about IoC and not in terms dependency resolution).
I wouldn‚Äôt argue PUT‚Äòs usefulness for performance but for loss of connectivity. An offline client, or one where connectivity is spotty, benefits greatly both from PUT idempotence as well as caching. I appreciate your scholarlyness on the topic but I do feel it‚Äôs a bit in the weeds, and perhaps on the other hand I‚Äôve elevated REST beyond what it was intended to be. To me it is clearly not a hard specification but a way of looking at the world. I have gotten a sense that Fielding was coming from that angle, as well, since he first described it while attempting to justify HTTP design decisions. Designing complex software can be overwhelming and falling back on the principles of REST is never a bad decision.
&gt; I wouldn‚Äôt argue PUT‚Äòs usefulness for performance but for loss of connectivity. An offline client, or one where connectivity is spotty, benefits greatly both from PUT idempotence as well as caching. I'm not aware of a *single* HTTP intermediary in mainsteam use which automatically resends PUT requests, based on the fact they're idempotent. An offline client can trivially send and re-send idempotent requests over POST, intermediaries don't need to be aware of the idempotency of the request. Also you keep saying there are great benefits to PUT caching... for the third time, this is not HTTP compliant, it's not REST compliant, it's a custom application-level semantic as much as idempotent POST would be. There's no difference here, no benefit to be had. They're both custom assumptions that REST nor HTTP make. &gt; I appreciate your scholarlyness on the topic but I do feel it‚Äôs a bit in the weeds Nothing is "in the weeds" here. Specifications, as I said, are not up to your belief or philosophy. Specs are specs. You cannot negotiate or convince a spec to do something it's not written to do, no matter how much you want it to. In that sense, it's very simple. &gt; Designing complex software can be overwhelming and falling back on the principles of REST is never a bad decision. It's never a bad decision? Oh, boy, looks like Fielding has failed at the very mission he set out for his paper then. &gt; Some architectural styles are often portrayed as "silver bullet" solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved. Choosing the right architectural style for a network-based application requires an understanding of the problem domain and thereby the communication needs of the application, an awareness of the variety of architectural styles and the particular concerns they address, and the ability to anticipate the sensitivity of each interaction style to the characteristics of network-based communication. The very point of the REST paper is that an architectural style like REST **can often be a bad decision**. It can also be a good decision, but you need to be aware of the style constraints, properties, benefits and drawbacks. You need to be able to analyze the style *objectively*. Instead you're describing REST as if it's a set of general-purpose best practices, a "silver bullet" solution for all forms of software... The very thing Fielding was frustrated with... 
anus maximus
What extension do you want to download?
any extension, or just going to the page https://pecl.php.net
[Yes](http://www.isitdownrightnow.com/pecl.php.net.html)
Any idea why it‚Äôs always down? I feel like it‚Äôs down more than it‚Äôs up.
Not a clue, sorry.
Do you have any links that illustrate the correct way to use dependency injection and/or inversion of control?
Your characterization of what I am attempting to communicate is grossly inaccurate. At this point I have tried my best not to talk past you as you are me. I can quote Fielding too: &gt; I had comments from well over 500 developers, many of whom were distinguished engineers with decades of experience, and I had to explain everything from the most abstract notions of Web interaction to the finest details of HTTP syntax. **That process honed my model down to a core set of principles, properties, and constraints that are now called REST.** That is the description of a philosophy. A philosophy that yes, at some point, begets a specification which, at some point, begets an implementation. I am not describing it as a set of best practices, but a foundational view from which to build best practices upon. Core principles (in his own words) are not "silver bullets" or best practices- they are to guide your decisions through a particular lens. "Do not kill" is a best practice. "Treat your neighbor the way you want to be treated" is a principle. Clearly, philosophy has had these types of disagreements since the beginning of time.
DI is the simple act of manually passing arguments to an object's method or constructor arguments to satisfy its dependencies. You're in full control of what dependencies you will give the component. In a reflection-based autowiring container the set-up seems similar, but the caller has no awareness of what the object is asking for, and blindly satisfies requests based on type. The object may end up depending on just about anything from the environment, which brings back all the negatives of non-DI solutions. Think about it like this. You want you money to be safe, so you buy a sturdy metal safety box and mount it in the wall. That's DI. But then you decide it's too much hassle to go hide and look for the keys every time, so you just leave the keys straight on top of the box for everyone to see. That's autowiring DI. You achieved nothing in the end. As for IoC, that's a much larger topic that DI is merely a tiny subset of. Many people call autowiring DI containers "IoC containers", but IoC containers are much larger than this. Any environment where your job is to write "plugins" for it, rather than write the application, is an example of a IoC container. For example when you use Drupal, the control is inverter: someone is calling you (the plugin), you don't control the application itself, you plug into the application. And since IoC is an architectural concept, not a code sample, I can't show you a "correct way to use it". It's just a concept about who control the app: you, or the third party vendor package you're using.
And this is why REST doesn't matter.
I ask because I rarely use it. Most of php extensions are available to install using package manager
To borrow your previous analogy, that‚Äôs like saying the Bible doesn‚Äôt matter. Even if you dismiss everything in it, it has made a huge impact on the world. REST matters insofar as at least people are making better API design decisions. But yes comparing it to SOAP is still asinine.
Mainly just to allow the API server to determine routing rules, with HTTP for example it could be managed by just adding ?against=user:1 for example, but if the JSON is being passed by another method that doesn't have that out-of-band information, that solution falls flat... It would be possible to do a double-wrap, have a procedural like call with the target object defined within the parameters, then a set of sub-arguments to pass to it, but that feels a bit ugly, although it would retain standard compatibility. I was thinking more along the lines of: { "jsonrpc": "2.x", "instance": "user:1", "method": "slap", "params": { "reason": "Breaking public specifications" } } It has the benefit of including the routing information at top level. In my own code, the RPC request comes wrapped in a JWT for authentication, once the origin of the request is known, the instance is loaded and interrogated to see if the caller has sufficient permissions to access the method in question before passing it on. 
I more often see people make bad choices based on their subjective idea of REST, than good choices. If REST is no single thing, REST doesn't matter. The ***word*** REST matters. It's a popular buzzword, that everybody wipes their ass with.
You seem bitter. Surely it has led to better design decisions than RPCs on a whole.
HTTP is a form of RPC.
Thanks for the feedback. I suspected is was the automatic wiring aspect that you were complaining about but wanted to be sure. I think your fears are somewhat exaggerated but worth keeping in mind.
That strongly encourages statelessness and thinking of data in a specific way.
The connection/interaction is stateless in REST, not the actual applications. There's nothing stateful in a basic RPC protocol either. Also keep in mind this is less and less true with every passing year. First, almost no "REST" API is actually stateless, in that it runs in an authenticated session. Second, HTTP/2 is highly highly stateful. It emulates the stateless HTTP/1.1 semantics, but underneath it's all about state. Shared connection, shared headers, pushed content server-side, pipelining multiple resources, etc. In fact, a lot of the talk about "intermediaries" in REST is rendered utterly irrelevant thanks to the heavy push of encrypted connections. Intermediaries can't see dick anymore.
May be exaggerated, but then again, I've had to fix messed up apps that went the spaghetti/singleton/autowiring/container route too many times to count, and so it's deeply ingrained in my mind what works and what doesn't. Autowiring is a wolf in sheep's clothing. It is encouraging high interdependence on global mutable state, but is dressed up to look like a best practice. Seeing people fall in its trap over and over tends to get frustrating.
Yes, you can achieve the same goals without HTTP, but having methods built-in is not a bad start. Eventually, many times you end up at a similar place with more non-standard code to maintain. HTTP has already thought up a lot of the nuances that you can take if you need them. You have astute observations about session, but I‚Äôd say we are moving away from that. OAuth is a great example - authorization has nothing to do with the resource piece of the architecture. And even if you want to get pedantic about tokens, increasingly the token is an encrypted payload that is simply trusted by verifying its contents. I‚Äôd say in implementation of HTTP/2, caching and uniform addressability are at least as important as before. ‚ÄúIntermediaries‚Äù can mean many things other than proxy servers- client caches, server caches. I do worry about HTTP/2 opening the door to bad decisions. But just because the implementation is stateful, the general usage on top should not be. Stateful is not inherently a bad thing as long as it‚Äôs at the correct level of abstraction.
You are always in control. Even if you decide to delegate that responsibility to a 3rd party vendor. If an object depends on an interface and you instruct the 3rd party to alias that interface to a class YOU are in control. I don't understand the purism in this case.
Not interested in GQL or just tired of hearing about it?
A service container that exhibits a properly implemented IoC pattern is a very handle tool. You're right... this one is not. DI is a specialization pattern of IoC, but it is not IoC in itself. A proper IoC container would be able to select the appropriate concrete implementation for an interface and with a DI pattern provide it's dependencies. This is a great thing if your code is strewn with references to a class that later needs to be swapped out (i.e., smtp-mailer -vs- ses-mailer). Whereby the preferred route would be to provide a "mailer" interface and allow the service container to provide the chosen concrete implementation based on it's bindings. If preferences change, then swap out your container binding and allow the service container to do all the work initializing the proper object throughout your code. In any case, I applaud the author for putting himself out there, presenting his topic and spurring this discussion.
I didn't write this code, I've googled this piss out of this and tried adding different headers but no matter what I do, it goes to the spam folder. Any pointers?
I think the main issue is usually that people forget to set mime and content-type headers. I'm no expert but I'd say that's where you'll wanna start to look. There are libraries for sending emails that help you with this, such as swiftmailer and phpmailer. If you don't get it to work you could probably check them out and compare what they do differently with the headers.
For starters use an actual and proper mail library (swift or phpmailer) like a normal person. Secondly use a proper authenticated smtp server with decent reputation. If it's still borked *then* ask your question.
Thanks I did do the mime and content headers to no avail. But yeah I'm just going to do the phpmailer route. 
Will do thanks!
Also ensure you have set up your SPF records correctly.
There's a lot of mis-information about this. An shocking amount of web developers insist there's something wrong with servers I manage due to this problem. Every PHP document or tutorial that ever discusses mail forms needs to get prefixed with the same advise: You cannot just send "from" any old address and decide that you are authoritative for it. Use a reputable SMTP relay, and then get their advise on how to setup SPF records.
It's been noted elsewhere that windows.php.net seems down too.
I have a feeling that most likely it has nothing to do with that code. First you need to see what happens on mail(), i.e. what is that server using for mailing. If they are sent from the same server then you need to make sure that server is not blacklisted, also SPF and DKIM should be set. Using a library mentioned in other comments also helps. Also, something can be marked as spam by one server (e.g. Google) but not marked as spam by another (e.g. Yahoo). In the end, it's possible that is a combination of issues that lead to emails getting delivered to spam folder.
Don't send email using your webserver, send it via your domain's SMTP server. Google PHPMailer - it's an easy to use library that lets you do this.
I think it's funny when people stress about this. I have no preference as long as the URL makes sense.
First AIM. Now PECL.
Yes, this. If you want to reply to the form completer, then put their address in the replyto header. But from? No, the email is from *your* server.
Urgh this has crashed my site. Can't build.
This is a terrible reply.
I will look into it. and SpaceVim's PHP layer will be improved. and I will add a debug workflow for php in SpaceVim.
If you are looking for a relatively simple integration, Vimeo is a good choice... takes a lot of the headache out of setting it up yourself. Also your client could handle some aspects of the video library management. If you are leaning toward coding much of it yourself, it is certainly doable to present video in HTML5 and store in an S3 bucket served from the Cloudfront CDN. Or any alternate non-AWS provider method. Of course, you'll have to provide the necessary management tools for the client.
AWS recently launched some extra services for video platforms https://aws.amazon.com/mediastore/?hp=tile&amp;so-exp=below
&gt; Use a reputable SMTP relay, and then get their advise on how to setup SPF records. There honestly needs to be more education on this, seeing as mail service providers have become more harsh on trusting senders.
Nice article filled with a lot of truths. I recently wrestled with which HTTP methods and statuses to use for the n-teenth time and I've been thinking of a simpler way since. From the client's perspective, it goes like this: * GET = Tell me something * POST = Do something * Status 200 = Everything is fine * Status 400 = I did something wrong * Status 500 = Something went wrong at your end That's it. Specific errors would be conveyed in the payload with, as the article says "your own clunky error format" and a message (like exceptions have served us for decades). Error code 0 means no error. Error code 1 means an unknown error. A list of other error codes is in the comprehensive documentation (something I think HATEOS unintentionally subverts).
&gt; ORMs suck at aggregating or building report data. Because it's not purpose of ORM. You have SQL for that. &gt; but they disregard isolation of persistence logic Actually they not. The goal is not to make your code portable to any SQL database, but isolate all database specifics in separate layer. &gt; Performance of ORMs is quite poor and not because of technical implementation, but rather due to logical design. This is comes from your first point. Just don't use ORM when you simply need report of read only data. Also the problem is that most of the time we are using same data model for read and write operations, and we tend to optimize it only for write part (normalization for example). &gt; even work hard on providing data for those drop-downs / auto-complete callbacks. I didn't understood the problem... You want to mix UI and persistence layer? I really didn't have such problems. &gt; For comparison Agile Data defines pattern differently, enabling code like this: Here is example in DQL. ``` SELECT SUM(item.cost) FROM Basket basket JOIN basket.items item WHERE basket.owner=:owner ``` We could use query builder to get very similar code that you shown. But this is very simple case. Let's say that total cost is depending not only from overal cost of products in your basket, but there are also discount programs like "buy 2 stuff and get 3-rd free". Or "Any green color product will have 20% discount! - Hail mother nature!".
I really don't get why there is so much abstraction around databases. Whats wrong with just doing: public function getBasketTotal(User $user) { return $this-&gt;query(' SELECT SUM(cost) FROM basket_items WHERE id = ? ', [$user-&gt;getBasketId()]); };
discounts, special offers, total price which depends on current phase of the moon... it's all about dependencies and how quickly you could change behaviour. 
This post doesn't really explain what "change" is and what is "reason for change" is. I could say that provided example fits better for explanation of Interface Segregation Principle rather than SRP. As for SRP - you could digg into Responsibility Driven Design. Bob took this idea of SRP from there. Also, it's very important to understand goals of open/close in order to fully understand why SRP is matters.
Well, the last semicolon will be a parse error, and trailing commas are blasphemous! But, more to the point: the author probably chose this example for clarity's sake, and so the use-case isn't meant to convey the benefits of the various abstractions over not using any of them. Raw SQL can be notoriously hard to follow when doing non-trivial things, and requires that you continually go from an OO- to a relational-mindset and back again, which is a cognitive burden.
WTF you call these two silly paragraphs one of which blatantly copy-pasted from Wikipedia a "well explained principle"? 
Thanks, @ImSuperObjective2, But, I am clarifying the "auto-wiring" which is the main function of DI Container, and PSR-11 clearly points that. 
As an addendum, what I eventually ended up doing was using a bit of name mangling on the method: user:31$method
&gt;&gt; ORMs suck at aggregating or building report data. &gt; &gt; Because it's not purpose of ORM. You have SQL for that. It is not how it works out in reality. Many ORM fanboys are quite reluctant to write plain SQL. Let it be fanatism, pragmatism or lack of skill. Many business rules will be sprinkled all over the ORM layer and the first sane person trying to write plain SQL is screwed and has to extract or duplicate the rules. Actually as a sane person you will be torn if you should even do that. 
&gt; Let it be fanatism, pragmatism or lack of skill I see it as lack of imagination mostly...
Thanks, @ImSuperObjective2, But, I am not referring to IoC, I am referring to the implementation of Container in Laravel, which is the main function of it is to bind/resolve the dependencies in your application.
&gt; Unlike Java developers who wholeheartedly accept patterns such as ORM or Event Sourcing, PHP language is used by a different developer audience. For many it‚Äôs to ‚Äúget the job done‚Äù. Quick and simple solutions are preferred over big and enterprise-ish architectural designs. Making sweeping generalizations like this is really not a good way to start your article. I'm quite sure everybody would prefer quick and simple solutions, if they were available for the problem at hand. Implying that developers who use language X would not do that is just flame baiting.
It's call the [Data Mapper Pattern](https://martinfowler.com/eaaCatalog/dataMapper.html).
This is something I'd like to learn more about, with some good REAL WORLD php examples. Anyone have any good links?
The best stack for developing PHP applications under M$ Windows is WinNMP https://sourceforge.net/projects/wtnmp/ It is based on Nginx, it is a lighter alternative to XAMPP and WAMP, with Composer, Adminer, LetsEncrypt certificates, WinSCP, multiple PHP versions, projects and virtual servers. 
SRP highly depend on context of project, it's pretty subjective principle. If you have problems with SRP, try to get to it through ISP and OCP. Also you could try to firstly learn GRASP since it's principle less subjective and don't require you to analyze flow of changes of your system. Another good way to learn solid - apply it on refactoring and make it to split your job into small iterations (few hours instead of few days).
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I found the explanation of the very bad. What is the actual difference in the getBasketTotal method? How does the SQL look like? How does it help in more complex use cases?
That is inheritance spiced with interfaces.
&gt; Or "Any green color product will have 20% discount! - Hail mother nature!" This case is interesting, because if the cost logic is embedded in the "Item", then it can use it inside the `cost` field (because rich field definition allow expressions / logic) and the example code remains un-changed. With the DQL you would have to take that into account. Another example is that you have spell out basket owner explicitly with DQL and this condition is implied transparently by AD. 
That's beyond the scope of the article, but my point was that the SQL could be very different depending on various factors: - how "cost" field is declared. Physical? Expression? Joined? - what conditions are implied on Item? Soft-delete? Many-to-many relation? Should those change any time throughout your project, e.g. "soft-delete" is enabled for the "Item", your query will automatically adopt without refactoring.
I used Doctrine DQL for getting reports, should I say it was a pain in the ass and the DQL it wasn't compatible with postgresql. What you cannot do in PHP with mysql is to get a new connection, IIRC you can only get one mysql connection by time, so If you're running doctrine, you cannot get a mysqli connection and run mysql queries. Running mysql native queries throught doctrine was entirely discouraged as the performance is lame. last time I read the manual it said that 
AFAIK JSON-RPC doesn't say anything how you use the undelying protocol. Just add the method to the URL and route the request in the proper place. OT: I considered JWT but I ditched it for related reasons. I wanted to use JWT to achieve a pure client base session and remove complexity from the backends. But in my thought experiments I always ended up with more complex flows.
This article got some serious bashing on HN but I can relate to it. REST at this state seems to achieve a tight integration with HTTP. What we need is a protocol that is useful for web apps and works well with HTTP, but the latter can and probably should be entirely optional. Using JSON-RPC with the mature parts of HTTP seems reasonable for me.
So I am bad because PHP has no good debugger?
This is the first culprit to fix. To be clear, when it says "From your server" we mean the From: address you use must be hardcoded to one actually owned by you. And the DNS of the server must be correct so that other people can verify that.
Also, this code is vulnerable to header injection.
&gt; Fieldman says REST is not about CRUD. If it's not about CRUD then it is about nothing. For me, in some cases, it actually maps to CRUD just fine.
I had some iptable issues when setting it up but after resolving those through firewalld everything was stable.
I am not sure that I can agree with you. Historically with respect to DI there has been much emphasis on object construction. Any system that moves object construction from the application to a container is already doing IoC. Even naive autowiring can be useful, because you move control of the construction logic and dependencies. I think your point is about the control which consumer receives which implementation of an specific interface. For this you need to do manual binding and override autowiring. Autowiring is just a convenient default if you have no varying implementations that need manual binding. IMHO autowiring isn't that useful and shouldn't be done. It is confusing for the newbies and adds complexity to containers and cloaks a bit what containers are about. I can agree thought, that the IoC and DI topic is much deeper than most users assume. Nowadays containers are everywhere but the community didn't evolve past the point that it is just a better registry. But that probably boils down to the fact that OO isn't as well understood and useful as it could be.
While I agree you are _technically correct_, the pragmatic realist in me doesn't share that view. 1) Placing business logic in the wrong layer, miscommunication, and/or opaqueness of the implementation is the cause of most bugs. 2) ORMs frequently result in #1, #2, and #3. I had a longer rant here with examples of all 3 but then I'm sure some of my old coworkers would know my Reddit account so I'd rather leave it at that. :P
Pot calling the kettle black for complaining about Rasmus' attitude toward programming. I know because I used to feel so entitled that my opinion alone should be canon over anybody else's learned opinion. Let's just say that i was so high up on my high horse that when I finally got knocked off, the landing was rough. Suffice it to say, it was a hard lesson to learn but worth learning. I hope this person learns too. 
haHAA, DRAMA BTW
Well then it‚Äôs about nothing. You said it. 
I see you‚Äôre back to your old self Taylor. Good to see you.
You might be remembering the original Doctrine? For Doctrine 2 getting the actual PDO connection is trivial. And if you really want to use the mysqli interface then you could do that as well.
This is something not related to Laravel specific, you can look at Yii2: http://www.yiiframework.com/doc-2.0/guide-concept-di-container.html, or even Symfony: http://symfony.com/doc/current/components/dependency_injection.html
PSR-11 doesn't mandate autowiring, so that's wrong. All PSR-11 does is provide an interface for *some* object to return *another object* in *some unspecified way*.
&gt; A proper IoC container would be able to select the appropriate concrete implementation for an interface and with a DI pattern provide it's dependencies. It's not just that. It's also when to NOT provide any implementation to an object. When you work in a team, it allows you to catch the junior dev trying to fetch back-end services in your template. This is like security. You can't do security by black list, it has to be a white list. And same with dependency control and architecture. You can't open the kimono for everyone and then just deal with the exceptions. It's a recipe for spaghetti chaos.
&gt; Yes, you can achieve the same goals without HTTP, but having methods built-in is not a bad start. Eventually, many times you end up at a similar place with more non-standard code to maintain. HTTP has already thought up a lot of the nuances that you can take if you need them. If you're using standard methods with non-standard semantics, such as using PUT for caching, then you're not using standards. It can be said you either use non-standard logic on top of standards, or you're plain using standards incorrectly. You can't just *decide* that PUT philosophically means more than it says on paper, and still call it a standard use. You don't seem to understand the role and purpose of a standard. It's not extensible ad-hoc based on someone's feelings about what philosophically fits or doesn't fit.
Thanks for sharing your opinion, but what I have tried to say in the article, Simple implementation of PSR-11 with going further with resolving dependencies, and I have given a simple example pointing to some modern frameworks implementations. No more. No less.
Again, you are condescending and mischaracterizing. Designing your read and write entity to be identical allows you to forgo additional client logic - caching on the client side, not necessarily intermediaries. Do you have to? No. Is it there as an advantage if you‚Äôd like to? Sure. But again, the idempotence of the standard is still important for robustness however you choose. I am not saying it is part of ‚Äúthe standard‚Äù but that if you follow ‚Äúthe standard‚Äù and then some additional conventions you can design it in a way that helps your client. I think you have trouble with levels of abstraction.
Magento 2 sure is something special, huh?
Well Magento 2 + business rules written by people who don't understand Magneto 2's potential issues is a bad combination. Magento 2, in and of itself, when used cautiously isn't too terrible.
The issue was, the mechanism I was using it for included passing the RPC commands between servers through a REDIS queue, so there was no URL to add extra data to. Ultimately I settled on including additional routing in the method name, but there's no standard for that either that I'm aware of. 
It's not a problem for fat controller apps, where you write structural code and depend solely on (framework) libraries plugged into it. Try to reason about composition that is couple of levels deep, while you see only one dependency forward. It's like talking about 3D objects while seeing only its 2D cross-sections and having a way to traverse them. Good luck recognising bad architecture in legacy code with this amount of control. Aliasing an interface creates another problem. Do you make use of polymorphism for something else than tests? Command pattern? Strategy? How do you switch between these aliases?
Are you sure you are replying to the right person? I haven't talked about fat controllers, framework libraries. The only thing that makes sense to me is this: "How do I switch between these aliases?" My answer is this: The IoC always has a factory for an object. It could be one the developer provides or one that it generates. I never switch between aliases, I change the factory. That's how League's Container works.
If you naively map basic data accessors to full-blown SQL queries that run two-way network traffic and hit disk on the other side, then your performance will go through the floor the moment you need to fetch a few more properties, or items (say, in a loop). The ad-hoc approach only works if you write dedicated queries for every single permutation of data-fetching requirements you'll use in your app. This approach would scale quite terribly and you'd soon have literally hundreds, of not thousands of *very similar* SQL queries scattered around your code to maintain. This is why *some* abstraction is needed. To reduce code duplication and to introduce query batching, consolidation and in some cases transformation and caching of data. Note I'm not saying the current crop of mainstream ORMs are the ultimate answer. I don't like them. But *some* abstraction will eventually be necessary in any app whose complexity goes significantly above "hello world" type of one-off application complexity.
This is example of buisness logic which cannot be covered by any SQL related tools. In my case i need collection of items, i will also have some kind of specification of products which are on sale, and then just try to check is objects fits to corresponding specifications. Then I could fully unit tested it. That's why I don't use DQL for buisness logic (there are exceptions, like reports, but I could make it without duplication of buisness rules).
&gt; I see people make with them. I see people, they write shitty code and they event don't know about that! (you know the reference) I don't think that ORM are causing this problems. You could make it with or without ORM. Devs will always put some buisness logic into their controllers/templates. I also think that we don't attend to separation of concerns enough. Any tutorial is just about obvious cases, but I don't seen any good resources to understand how to separate things. &gt; Its all we should desire. I need verify that structure of this "arrays" remains correct and I don't forget to change it. Right now I think of "data mapper" which allows just that (you still need to test it in runtime, but it only requires you to build valid SQL and executed even on empty database, in order to be sure that structure is unchanged and all types are compatible).
Beyond youtube and vimeo you can look at media services like cloudinary. Will the pricing be transferred to the client?
I thought you're referring to auto-wiring (not IoC), where you can only see nearest dependency and need to traverse "links" recursively to see whole structure.
&gt; discounts, special offers, total price which depends on current phase of the moon... it's all about dependencies and how quickly you could change behaviour But I don't see how this would be different if you used an ORM.
https://github.com/ankitpokhrel/tus-php - A pure PHP server and client for the tus resumable upload protocol v1.0.0. tus is a HTTP based protocol for resumable file uploads. Resumable means you can carry on where you left off without re-uploading whole data again in case of any interruptions. An interruption may happen willingly, if the user wants to pause, or by accident in case of a network issue or server outage. 
wiat what? do those extensions all conflict? that all do Intellisense. ?? 
But I haven't seen any php fanboys as crazy and delusional as go fanboys, acting as if Go is taking over the internet when it is just an overhyped lesser programming language that are good and only good in some circumstances.
3 of these extensions do the same thing. I always thought you shouldn't install multiple language servers / intellisense plugins for the same language. - php intellisense crane - php intelliphense - php intellisense Why would anyone install all of these? OP you are clearly the author. Can you please explain? 
Been doing WordPress for a long time. Since udemy.com had their deals going over the past month, I finally decided to try them out and finally start learning Laravel. Any suggestions or tips for someone picking up Laravel as their first PHP framework?
Dropping a comment here real quick to come back in a few minutes and really answer this. I did this a few years back. It's hard. Have monies for git + software?
Oh boy, that sounds painful. You may or may not have some success with the content from [PHP The Right Way](http://www.phptherightway.com/), but more importantly, you should be able to answer these questions: * How bad is it really? That means, the code may be setup in an old-fashioned way, but how bad is it really? How much duplicate code is there? How bad are the abstractions? Is it tested in any way? * How much is this costing the company? Does it take days to add new functionality, just because you need to wade through tons of legacy spaghetti? * What's in it (for the company, and for the lead dev) to change all this? The last one is the maker or breaker; if there's no clear business value (to the business in total) or development value (to your lead), I don't see things changing. In the end, the software exists to support the business, and as long as it's doing that, as unpopular an opinion that might be, it's "good software". Don't get me wrong, my hands start itching by just reading your story, but at the end of the day code doesn't exist to please you and me. See if you can answer above questions, preferably supported by numbers (at least when you present them to your lead), and work from there.
Tooling aside, your senior analyst is reluctant to make changes for a good reason. Modernizing an old app, let alone one with a million lines is very hard to pull off. Because you don't have proper automated testing, there is a very good chance you'd break one of fifteen hundreed things, and your senior analyst will say "I told you so!". Start with small things. In your next project, try using composer to install packages. You dint have to use Symfony components at first. Just dump your files and use composer to Autoloader them. Convince others how easy that was and point out the lack of rocket science. When you need a certain feature, write it as a separate library and load with composer. Write tests for that library, and try to automate it. Get Travis or something, and make it test your library. Intentionally use PHP 7.2-specific features, and insist your team's inky use PHP 7.2 or later. When you and your team mates are confident with composer and decoupled packages, discuss with them how you can improve that giant app. Tooling: phpstorm of course. Use composer for dependency management. Phpunit Isa great and most popular testing g framework. PHP right way, Paul M Jones modernizing PHO book, and Larry Garfield's eating elephants presentation are very nice resources. I'm on mobile so didn't bother to kink to them, by they all are easy to Google. 
I attended a talk a while ago that was similar to [this blog post](https://stovepipe.systems/post/migrating-your-project-to-symfony), "basically" to wrap it in a Symfony response. There was more things to it as well, but that's the general idea. But with a million lines, it won't be easy. Without going into specifics, I'd generally recommend Symfony as a good general-purpose framework.
The first major caution I want to give is that with any larger group of people, you can lead the horse to water but you can't force it to drink. Perhaps the easiest things to add are those which are tangential to the actual code. * Version Control (git, svn) * Reproducible server environment (docker, vagrant, etc.) * Modern IDE (I like PhpStorm.) 
Quit. You are damaging your future career and earning potential by essentially being left behind working on some ancient code base. You are not project lead so you cannot drive change, you can only suggest it. It isn‚Äôt good enough unless you are being paid ridiculous money for the sacrifice. No version control, no OOP, no composer(?), unfamiliarity with frameworks and moving towards jQuery as most are moving away. Unless you are planning to retire at this company or are doing some exceptional side projects I would leave.
This is depends on what ORM you use, and does it allows you to build object model. I use concept of Whole Value in order to reduce dependencies. I also rely on persistence ignorance principle. So in my case Doctrine will fit better (unit of work, data mapper, repository pattern and so on). If you have active record implementation, you could look for row data gateway pattern and implement simple unit of work. There are many ways to do such things not only with complex tools like Doctrine.
As with the other suggestions here -- start small. 1. Version Control - You could integrate this into your company's workflow within 1 day. Very quick change. 2. Automated UI tests (Selenium etc). -- This is to make sure that things are still working after you change the implementation. With the added bonus of not touching the codebase yet. 3. Map out your code base. What can be grouped in a package? What are the dependencies for each? Which modules can be changed with as little change to other modules as possible? 4. Upgrade your code bit by bit starting with the 'stand-alone' modules. Adding Unit Tests along the way if possible. I suggest use of Symfony Components as you don't need to rewrite the entire codebase to fit the framework, just use what you need. https://symfony.com/components Good Luck
Just give us a link to the site. I'm sure reddit hackers will provide reason enough to update this application within an hour. That's how it normally goes down. (OP: don't give us the link.)
Baby steps. 1st order of business is to move your code deployment into svn/git. I haven't used svn in ages, so I recommend you just skip it. Start using it. Very simple to add codebase into a git repo. Biggest gain is version control + distributed version control. Once this is successful, then bring in the big guns like PHPStorm. This will cause a pretty huge productivity boost relative to say zend studio, which is pretty ancient. Once you do that, then you can bring in "PHP The Right Way" as someone else mentioned. so.. git -&gt; PHPStorm -&gt; PHP The Right Way. PHP The Right Way will kinda come along with things like using composer, and then additional frameworks which mitigate things like CSRF, help you do stuff like worker/queues with php etc.. via composer. Anyways.. Take it 1 step at a time.. otherwise you may alienate your boss.
I think I can second this. This is a very precarious situation to be in. It will bring up the stinky question later in job interviews of why didn't you use such and such.. you should have just left.. and will put you on the spot of not being able to identify your employer.. Anyways some say that you need to figure out if your employer is the right suiter for you, you evaluate your employer every bit as much as they evaluate you as a developer, and if you see them taking advantage of that, then you need to really think about how best wisely to spend your time. Is this really something you want to spend your time doing, because this kind of in-house-fighting will get really messy, extremely frustrating, and will you learn anything in return. The marginal utility of you affecting change in this organization is questionable.
XDebug is not that bad, it lacks a few features, but it's a real life working debugger.
Is there budget for conferences? If so, take the entire team to a conference: make them see how "modern" development is done. Are there meetup groups nearby? Try to bring your team there. Can you do in house presentations? Maybe watch a conference talk you liked together? 
I really don't know how this is gonna fly here, but w/e it's been my experience in the field. I'm in my late 30's, and have worked for 3 companies for periods spanning from 1 year, to 11 years, to 6 years - all in systems and / or software engineering, ranging in company sizes from 8000 employees, to 80 employees, to 1800 employees. In all my years of experience, there's really (and maybe unfortunately) no substitute for just, doing what needs doing -- even if it means doing it subversively. The phrase "ask for permission now or beg for forgiveness later" comes to mind because we already know the answer to asking for permission don't we? It's no. It's pretty much always no, and pretty much always for some bullshit reason. If there are real problems, and you really care about fixing them, and you have the chops, then just start. You'd be surprised how quick people start coming around once you have results speaking for themselves. We know how easy it is to dismiss new ideas (even if they aren't really new, but rather just new to the company) when they're just that - ideas. You'd be surprised, it's quite another thing entirely to dismiss existing properly functioning systems! Do not focus on how big the task is. Just start. How do you eat an elephant? You start eating. So much of developing your career is confidence, willingness to put yourself out there. Look at it this way - dumbass B players that can't actually help do it all the time. They throw themselves out there, take the shit, and get promoted. Then they hire more B players, or C players. Meanwhile you have A players sitting around terrified to put themselves out there, because of how self aware they are. They see all their flaws and it petrifies them. Everyone else has those flaws too! More A players need to put their ass on the line, do the needful, and get promoted. A players tend to hire more A players :) If you're max railroaded and can't do shit, for real. Then fuckin bail, why bother. There's so much demand in this field you shouldn't waste your time. But honestly, most of the time what's holding people back is themselves. It's easier to just wave your hands at everything around you and go SEE IT'S FUCKED NOT MY FAULT, and do not a single godamned thing about it. tl;dr start doing the needful, fuck the haters, or bail. good luck!
The first thing you have to assess: what do you get from improving things. Can you easily get a job elsewhere? Is your company in some domain you really like? It feels good to be the hero who saved the day (decade in your case) but it won't get you a lot to show for your efforts. If you really really want to stay and improve things start by reading [Working effectively with Legacy Code](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052). Then: setup a git server for you and then your colleague can try it once you can show them how it works. A VM with a gitlab instance on your own rig is enough to start: you'll be able to negotiate for a server once people see how it can improve their lives. To improve the code, you want tests. Not unit-tests but acceptance tests: your clients don't care about your-awesome-thing.php breaking. But they sure don't like when they click on something and it does not do what it is meant to do. Even worse if it is a bug you resolved 6 months ago and it is coming back. So you have to test. You don't have to automate it: just open a text file, note the steps you have to do and what you expect. Then code. Then just manually do your tests every time before you put things in production. It'll take months before you see a return but the first bugs you catch from this will help you. You can even dabble with Selenium and something like Codeception to drive your tests on a VM. The important thing is: every time you touch some part of your app, you prepare tests for it. So one year down the line you have tests for most of your app and with some luck your colleagues see the advantages and write their own. Once you have a good test harness you can be confident you are not breaking things for your clients when refactoring parts of your code: the fun part can start.
1. Forget Udemy, use Laracasts. 2. Check out October CMS, as it's closer to Wordpress than raw Laravel.
Moving away from jquery,?
Indeed "business value" is the name of the game. A few other comments have given suggestions about *what* to change / introduce, but based on things like "no repository, no frameworks" and "OOP PHP tutorials or practices" I get the idea that Walrus_Pubes knows roughly *what* he want to introduce. For every new thing you want to introduce, you'll need to figure out *why* the business *should want* you to make that change. Going off the list trpinoy posted, here are a few suggestions. Version control can help you keep all your code in sync. Based on what you describe, I imagine you often need to spend some time manually merging files, figuring out why that bug you fixed a month ago is back, etc. Make an estimation of how much time this costs you. Then make an estimation of how much time it takes to implement some sort of version control. You now know just how long it will take before the (time) investment you need to get version control is paid back. I suggest starting with a simple versioning model. If a part of the team has never worked with any sort of version control, "everybody works directly on master" is already a good step forwards. Once you have that, you could start using branches and tags, things like that. Likewise, for automated (UI) tests, estimate how much time is spent manually testing things. Find a particular area of your application that takes a lot of time to test, but isn't very complex. An example of this could be a long form with a lot of fields. Pick some tool (Selenium is nice and easy to get started with) and spend an hour to automate that test. If regression testing is one of your tasks, you could even start with this before you've fully convinced the other developers. Just play around with your tool of choice, automate some tests, and then after successfully using them for a while, tell the rest of the team about it and show them how to run the tests. If you're afraid you'll get into trouble because you wheren't allowed to spend time on this, you could invest that first hour in your own time (eg stay late of come in early one day). After that first hour you should be saving some time every week, so you can use that saved time to automate more tests. In both of these examples, I'm describing small steps. That is because it is extremely difficult to convince people to make big changes. By starting with a small change instead, you're making it easier for everybody to adjust. Once that first step is taken, the next one of often easier: the step from "no version control" to "you have to commit and push every time you change something" is much bigger then the following step of "if you're going to make backwards incompatible changes, you need to do this in a branch". What also helps is that you're only asking for a little bit of time to get started with each thing, meaning not much is lost/waisted if something doesn't work out.
What do you mean by "procedural" ? Some devs use it as equivalent to nonOOP, and that's imprecise. Which PHP version? Operating system? DB? By procedural you mean: a) Lots of functions b) Lots of huge switches and some crazy global state manipulations c) Spaghetti html + css + js + php together What is quality of that code? Is it easy to work with? Do you have trouble finding your way in code? Does introducing changes require small changes spread over too many places? Does introducing changes require deciding what code most definitively should not be changed among thousands of lines of code? Etc. 
Check out Joel Spolsky's blog, especially his post [Getting Things Done When You're Only a Grunt](https://www.joelonsoftware.com/2001/12/25/getting-things-done-when-youre-only-a-grunt/). He doesn't blog much any more, but back in the early 2000s he wrote a lot of really good stuff about the business side of software development, and most of it is still relevant today.
It's not that bad. If one could convince whatever make decisions that some changes are required it will be good topic for a conversation on future job interviews. "I put 10GB of code base under git" make good impressions. I know. That's my line :D Followed by "then I designed workflow for developers to efficiently use that git repo and branches". Scores some nice points over competition ;)
jQuery is a great API but if you want nice optimal code, you can achieve everything using vanilla JavaScript, all except perhaps $(document).ready({});
&gt; it's comparing apples to oranges What specific criticisms do you have here? Without details it sounds like you're suggesting that Fabian is either lying or being intentionally misleading.
I'm not suggesting that at all, the frameworks serve different purposes and it makes total sense that out of the box they have different features enabled. You could also throw in Ruby On Rails into the comparison just to compare it to something more, it won't make much sense though.
I agree with @ayeshrajans the inbuilt arrays and array functions of PHP are one of it's greatest strengths. I don't like the laravel collection class because it teaches people who only build in Laravel those methods rather than the actual methods that exist in PHP like array_map, array_filter, array_replace_recursive, reset(), current(), end()... I know it's not consistent and it's a constant tug on the OCD developer but at least it works everywhere and incredibly quickly without external libraries.
Paul Jones wrote a great book on [Modernizing Legacy Applications In PHP](https://leanpub.com/mlaphp). The IDE that you are using really does not matter, you can write good php just as easily in vim as you can in phpstorm. The only real requirement is being able to replace in multiple files. If you want to fix a legacy codebase, especially one that's still in production, the first step is version control, followed by re-factoring (creating tests as you go). You don't *need* to use a framework, as others have mentioned, something like symfony components is ideal, as that allows you to pick and choose what you need, as you go. I have worked in situations like your before, and there are a number of problems that are very frequent, and easily resolved. For example, with a single massive shared codebase, it's not infrequent to have someone accidentally overwriting someone else‚Äôs changes. This is of course resolved with version control, which also has the added benefit of being able to roll back individual changes etc. How often does a change break something else? This is easily fixed with testing, and while testing can be tough to get your head around, black box testing is pretty easy to implement as you go using tools like [Codeception](http://codeception.com/docs/03-AcceptanceTests) and is a great place to start.
GraphQL looks exactly like SOAP, but with JSON. It's going to cause the same problems but at least the definitions are more readable.
I had the Cto and supervisor and my job tell me that 'we don't use debuggers here' and proceed to assign me the job of... QA and bugfixes. I was like, "Of course you don't need a debugger when writing greenfield spaghetti garbage in dreamweaver. The problem comes after you have clents!" 6 months later we all have phpstorm and xdebug.
Have you considered the possibility that you have died and gone to hell?
I'd also recommend Paul Jones' book. I've been actively following his suggestions and greatly improved my code base. 
I still don't get the point you're trying to make. # Both frameworks use the same language and can be hosted on identical infrastructure. # It's useful to compare frameworks. # Performance is an important dimension for comparing frameworks. # Most developers, most of the time, will use a framework in it's default configuration. Are any of the points above untrue? If (like me) you think these are truthful statements then your position just doesn't make sense.
Serverless PHP could become a thing if someone like AWS or IBM create the infrastructure for it. PHP 7+ is generally faster than Python (which is favoured along with Node for writing AWS Lambda functions) and could open the doors for more developers to start using this kind of architecture. There's already a framework [here](https://github.com/ZeroSharp/serverless-php) but it would be great to see someone like AWS embrace PHP and offer it as a native language.
I think your points are valid but it stays comparing oranges to apples and for me it's not a preferred method. Comparing it to previous versions of the same framework makes more sense to me. A framework is so much more than just speed. To be clear: Symfony is my framework of choice for years and I simply don't think Symfony needs to compare itself to others as it is perfectly fine on it's own.
Your single biggest 'win' will be in the devops realm. Getting source control, a proper test environment, and a proper push strategy will greatly improve your workflow and reduce the number of issues you deploy to your production environment. From there, meet up with your other developer once a day then make a list of what's up for review and what's ready for production. If you have Dev, Test, and Prod environments, you can selectively merge from Dev into Test when something is ready, then push to prod from Test on demand if there are no issues. The next thing I'd focus on is security. The single biggest issue with roll-your-own everything is issues with security. You'll want to look for two sorts of tools: a static analysis tool for your php code, and a vulnerability scanner that can look at a site that is up and running. Once you have data you can sell security to your organizational leadership. The best strategy is to take a hybrid approach. Take a few weeks to triage the biggest issues, then as you touch additional areas, fix things that you found with the scanner. Oh - and keep scanning. It should be one of the first things you do once you push to test. Automate that if you can, and set a goal of no new vulnerabilities going to production.
You aren't likely to develop transferrable technical skills working at this company. Over time, as your knowledge of the company grows, you will be paid more, but this knowledge be non-transferrable and therefore will not be valuable to other organisations. Eventually, if you wish to leave, you will probably have to take a big pay cut due to your limited technical skill. If I were you I'd start looking for a new job immediately as doing so will only get harder the longer you wait.
I was in exactly this position two months ago. Left the job and the difference it's made to the quality of my time at work is like night and day. We sort of did gradual improvements when I suggested Jira and version control... but this was mostly for new projects where we still had a ton of maintenance to do on ancient, shitty code the old (read:1994) way. It was a great start but too little, too late. I would recommend perhaps leaving unless you're willing to stick with it until whenever.
Thanks for the tip on Laracasts. I didn't even know what it was. I came across [their beginner course](https://laracasts.com/series/laravel-from-scratch-2017). Is it always free? Seems like a good way to find out how what Laracasts is like before spending a bunch of money for paid courses. That is exactly why I finally tried udemy. Its scary spending $200 on a course when you have no idea if it will be any good. Some of the intro videos on udemy are so vague or pointless.
New year resolution is usually understood as something you think will do yourself in coming year.
PHP demo app to make happy all the HR in the world.
I will still choose PHP - which has much more mature frameworks and for which the environment setup is still easier. And NodeJS does async, that's probably true, but that's not threaded either - you can still spawn as many PHP processes as you'd like, pretty much the same you could with Node anyway. I don't see any benefit in Node, sorry.
I am a casual programmer (not really earning any money, just simplifying my routine tasks) and I can't imagine my life without these tools. Reading about professionals programming like I did during my first year sounds like a sushi cook using a butter knife. 
Using frameworks is not a requirement for modern development. The use of a framework depends on your needs and the type of application you are writing. While many of the things you speak of show a conservative development environment that could see improvement, you should be careful not to start adding a lot of ‚Äúnice things to have and what you have heard of to the list of things to change.
Nope. 
Lol I can understand :P
try to do array destructuring: array_reduce($arr, function ($result, $item) { if (!$item-&gt;someCondition()) { return $result; } return [...$result, $item]; }, []);
https://github.com/dmirogin/fakemodel Model factories for Yii2. Another way to handle with fixtures.
&gt; but that's not threaded either this not needed in case of async network I/O (database connections, http calls and so on).
I suppose I should clarify the million lines are split among 12 separate in-house apps. 1. The code is extremely well organized. We have a central template that he/we designed that we base each system off of. Any repetitive/duplicate code, to an extent, is made into functions and stored in a common library. We also have a nearly identical test environment which is running php 7.1.x. Our production environment is running 5.6, but I'm in the process of switching that over now. 2. Because it's so well organized, we can pump out changes relatively quick. I suppose that's why we only have 2 devs for the amount of work. Even our systems written in the old template are well structures and easy to pick up. 3. At this point, not a lot, other than ease of use and preserving my sanity haha. You make great points. Perhaps the office isn't in that bad of shape given the amount of legacy code / data we're working with. It would be a massive hassle to make major changes now. Side note - In my spare time, what can I do to stay ahead / with the curve? I'm well aware procedural php isn't nearly as in demand as OOP. Learning that is my first step, but what else should I familiarize myself with? Thanks again, I appreciate the feedback!
At my current job, we're moving a bunch of older, mostly no-longer-supported technologies like classic ASP to PHP. With the application I'm working on now, what I did was simply break the application down into functions and move functions over to the PHP and repoint the links in the old application. I started with any function that is currently broken or that would need work lasting more than a few hours. I would suggest going with one of the more popular current frameworks (after researching how much they support things like your current database or other specific needs you have). Like other people have already said, you might be better off creating a continuous integration environment starting with stuff like GIT, Jenkins, etc... first. I really like IntelliJ with PHP plugins (we already use IntelliJ for Java).
You mean Human resource things?
I'm in a fairly similar situation as you, but for me I've taken to doing the following: * I've modernized smaller scripts as I go. * Moved all re-usable functions into an OOP format. * Got some of us to move into PHPStorm * Mentioning version control pretty often. * Focus on performance boosts. Basically, I've shown that it can be done incrementally and what it provides. So we have a custom-built framework reliant on PHP5.3, that was recently fully converted to PHP5.6. Even though I'm the most junior developer in my team, I've convinced them that converting the framework from PHP5.6 to PHP7 would severely benefit in marketability and performance (which it will). I'm undertaking this (will probably take a year), but I believe that it'd be a great discussion during interviews.
Zero ambitions to retire here haha. I've stayed because it's resume "experience" while I finish up my degree. I've worked with GIT in my spare time, but honestly I have no idea what composer is. Sounds like I need to start there. Do you think the on paper experience is worth sticking out the last year until I graduate? I do get a fair amount of front end practice here as well, which is nice. Thank you for the feedback!
I don't need any feature really. But perhaps named arguments will be useful 
As in Docker running on CentOS? Works perfectly fine for me. I'm running on RHEL at work and zero platform-specific issues that I can think of over the past few years.
The answer depends on how you look at it. If you have a lot of blocking I/O and very few business code to run, they'd still all block the execution at some point. You may spawn a lot of processes, without non blocking I/O and have a the same result in the end, with the only difference that your pages would be served a little bit quicker in the end, but you probably have the same server capacity globally - the same amount of CPU would be spent in the end, instead of being better utilized in the same process thanks to async I/O it could be sharded amongs multiple process. You would be able to serve more request at the same time, but all would be slower somehow (sorry I just wrote this real quick, so it might full of nonsense).
Man, that hit close to home haha. Between our senior and director, I have little to no say in our department's direction. Might not be a bad idea to say fuck it and take the initiative. I'll only be here for another year or so, what's the worst that could happen? Thanks is for the advice!
We absolutely can. Do you have any resources you'd recommend sharing?
I do for personal use, but the office is on a relatively tight budget. We're a government agency after all haha 8). If they're life changing, we could swing it.
- PHP Storm IDE - Slim Framework because it doesn't care how you structure or do your projects which will be an easier transition coming from where you are. You can easily integrate it into most projects with minimal amount of effort. phptherightway.com
We currently have an identical test environment running php 7.1.x. Our production is running 5.6, but I've been slowly pushing that over. Right now to integrate from test to production we use batch files. I have no experience other than this, but I'm sure it's ugly hah
Thanks I didn't about 7.2 PDO prepared statement debugging 
If you haven‚Äôt graduated yet, I think it‚Äôs fine. I worked at a similar place for my previous position and things turned out fine for me.
Composer is PHP's NPM, APT or YUM. Very useful to manage dependencies cleanly without versioning them.
Use ffmpeg and a queue to transcode each video into webm and h264, generate a `&lt;video&gt;` tag with two sources. Hosted solutions are of course easier, but there's something to be said for resisting the Amazon hegemony
https://philsturgeon.uk/php/2013/11/12/benchmarking-codswallop-nodejs-v-php/
https://dependabot.com/ TL;DR It'll create pull requests for you whenever there are updates to the dependencies in your composer.json. Wrote this when I was at GoCardless, and added PHP support a couple of months ago. Spent all of last week working on getting it polished, ready to come out of beta. Code base for all the clever stuff in it is [here](https://github.com/dependabot/dependabot-core).
&gt; the same amount of CPU would be spent in the end it's not due context switching and other stuff your process scheduler done in behind the scene. Also you don't encounter memory consumption per each process.
Git has some really good tools for doing merges, and it's very scriptable. Getting your prod environment to a newer iteration of PHP is a good plan too - your old software is possibly not maintained any more (been a while since I wrote PHP code) and that's a huge risk.
Is this mostly useful if importing a lot of external apis or heavily nested libraries? Right now we have a few required libraries in our header, but nothing unmanageable. I just watched a few videos on composer and I think I'm misunderstanding the use.
You can make symfony as small as you want/need with the [microkernel](http://symfony.com/doc/current/configuration/micro_kernel_trait.html). But I highly recommend to stick with standard symfony, even if you know what to do. You never know when your app will grow and having a solid base is an immense help.
If you have a server you can dedicate to vcs, do that. Gitolab or other tools are nice even without the github ui. Sublime and atom have annoying reminders to purchase, but are okay systems. Composer is your friend, start identifying namespace/common classes structures and set up a /lib/ and start moving code to object code. Easiest transition for the team without freaking them out. Added bonus, if you haven't been writing tests yet, moving towards composer and oop will help organize your tests and be a nice topic to focus discussion on - now we have tests so we can be better. Docker (or vagrant, if that salts your bun) is a good mechanism to containerize your application, isolate for test runs and build deployable architecture. Several modern ides integrate with docker, but it's team choice. I personally use and advocate IntelliJ ide. When writing in multiple programming languages, IntelliJ is the modular Swiss army knife for the purpose. Php storm is the little brother. .editorconfig, eslint, phpcs, phpunit, composer (I've repeated a few) can all be used to help keep your code and styles consistent. Phpcs even has an autofix binary, which will fix issues to make code syntax (spacing etc) more consistent in one sweep. Obviously get a testbed set up to make sure you didn't break stuff.
There are a ton of solutions out there and it really depends on how detailed you want the information or how coupled to you application you want to be. For overall system health and monitoring, I really like netdata: https://github.com/firehol/netdata
The Spiral Framework (https://github.com/spiral/spiral) which we created for our clients support both ORM, ODM and hybrid transactional connection between databases.
New Relic is great and easy but quite expensive. At a previous job, we just wrote a little bit of code to do this automatically and send the data to graphite through statsd. That's a pretty common setup.
It's a good tool to autoload namespace objects in your codebase to import and use throughout your project. No more requires procedural by file path, unless you want to.
I want at least on project running on GraphQL, you really have to flip your thinking on DB design 
Jquery may be a crutch, but it's a mostly stable modular crutch with a fax machine.
Meet-up is good, but any big name conferences like drupal, php meetups, aws are a good place to get swag. Learn a thing or two too.
There's an argument that unit tests capture better test failure while acceptance tests capture oh somethings wrong. I fully support unit tests for as much as possible, while using loose Front-end tests for acceptance criteria. Also, static and dynamic scan codebase with veracode or like hellion software to identify vulnerabilities.
Symfony 4 came out recently, which nixes the entire bundle paradigm. Still need to convert over to class structure but symfony is now as slim as its counterpart, slim.
Well said. I also have similar thinking when I wrote the the library. It won't do all the cases but if it can do 95% with same efficiency as raw SQL it's a huge step forward. 
1. Run GIT locally with a good GIT UI for showing diffs and how awesome that is. Split up your various tasks into branches allowing you to easily switch between multiple projects. Seeing is believing. 2. Another thing I would suggest that is dead simple is setting up Loggly on your production servers. It's 50 a month and I view it as our departments hardest working employee. The install is for dummies easy. Automatically emails PHP exceptions and warnings to me on the hour. Huge for new releases and easily pays for itself each month since errors in our reservation system are caught immediately, generally I have created a bug report and know the root cause before someone has a chance to report it to me. 3. If you are not doing sprints or using project management software then do what I did at my office. Use Asana, its free and the learning curve is minutes. Go to a weekly sprint cycle. My company was resistant but I explained that we should be able to create a weekly "contract" of what we are going to work on. 9 out of 10 times something that comes up during the week can wait until the next sprint, because our sprint cycles are so short. You also feel a sense of accomplishment every week and also feel less swamped since new tasks go into a queue and not your primary workflow. Limit releases to a single day (outside of critical bug hotfixes). I had us standardize on Tuesday releases. Don't do it all at once, starting with Git locally is easy. (P.s. bitbucket is free for small teams, thats what we use).
As someone who's been in the business for a while, I just want to say that you're on a great path there. I, for one, would be impressed with your story on the other side of the interview table. Specific things that are standing out, and should be worked for all they're worth in an interview: - Charting an incremental path to modernity is a big win. You get to modernize without ever really rocking the boat. It's a mature perspective to take as a craftsman and steward of a project. Too many devs would want to burn everything down and start from scratch. - Managing up to get this change in place is also a big win. It means that you have the ability to navigate interpersonal issues, which is a difficult to teach skill. Thumbs up!
It all depends on what it is you are building. They each have their uses cases, some of them overlap, in some cases, PHP is better, some node is better, but without knowing what it is you're trying to do, nobody here can honestly answer your question.
Sure, that's interesting. Considering spawning processes, depends on your OS, if they all fork from the same parent and their memory don't diverge, it might not consume extra memory at all - but I guess you've got to be very lucky to have that.
I'd highly recommend pulling in Symfony components once you have Composer in place on the project. The components are nice stand-alone libraries that you can incrementally move onto. The nice thing about them is that going from being a project that uses Symfony to being a Symfony (framework) project is something that can happen gradually, while no one's looking. Just getting Composer in use on your project would be a big help, aside from opening the doors to modern dependency management. You can start to get rid of all of the `require` and `require_once` statements from your code. If anyone claims that autoloading is "slow", you can point out that it's also slow to load and parse code that never gets run, which Composer would eliminate the possibility of, and that running the `-a` option on Composer will give you a fast class-map for loading files and won't fall back to a slow directory scan.
I hadn't thought of that, but the security is probably abysmal. That's a huge liability that the company is waiting to trip over. If the company is still stuck in the 90's in terms of code style, use, and dev practices, then it's probably stuck in 90's PHP security.
How so? GraphQL still uses relations in data, it's just the input/output that changes
Thanks! I'm entirely self-taught, basically coming from an open-source .NET world (I literally just made and gave away source code to all different types of programs). I don't like to rock the boat because I understand the value with consistency and that a business needs to turn a profit (so having me push all profitable work off to re-write probably 100k+~ files would be insane). So far my method of updating as I go has been received well :) Out of curiosity (I ask this of everyone I meet), in your opinion, would getting a degree be worth it? The general consensus says no unless I plan to go somewhere large. I have, * Years of open source experience (I started when I was 11 with VB6, I'm now in my early 20's). * Professional experience of over a year * Several large ventures (I had a popular gaming forum running with 2-3 million unique visitors monthly, and 10 million hits). My concern is having difficulty finding positions, but it would cost me $100k to get my Bachelors from Penn State (only local school that offers CompSci/Software Engineering online).
If you've found a place that you love to work for, stay. It's hard to find places that make work seem a pleasure. But until you've been around a few companies, you probably don't even know what you're looking for. There are also places that will try to throw glitterdust in your eyes with pool tables, arcade cabinets, etc. You're there to work and will be expected to do so, even with such perks present. They're often just a distraction, both from company practices and from potentially lower pay. If you haven't found the place you want to retire from, stay no more than three years in a place. Your career and paycheck will both benefit from the varied experience you would get from having multiple employers over the years. If you're not even liking the place that you're working, stay no more than two years. Life is too short to spend it at a job you don't like.
Yep this guy is doing stuff that we were doing back in 2007. Eventually got the "CIO" of that company fired because the CEO saw all of his senior engineers leaving, lost most his team in 6 months. Evolve or die.
They force a particular IDE on you? It's too late, get out.
@OP: If you pay for PhpStorm yourself, you get to keep the license when you leave the company. Just start using it and watch people's eye pop when they see it in action.
Weird huh? Most organizations don't care. I had one force Windows on me. I didn't last long there as I am a Linux guy. But they still allowed you to use an IDE of your choosing.
It really depends. When I started out, most employers wanted a degree that's at least nominally related to computers. You have documentable experience, so that should short-circuit that particular issue. However, not having at least a Bachelor's degree will handicap you. Having one, for whatever subject, is often a requirement to even be considered at a number of companies. A degree also has more utility than just vocational training. Even if you go for a comp sci course, the humanities classes that you'd take would be immensely valuable. You're not just being taught job skills, but how to better and more clearly think. That's life-altering, if you pay attention to all of your classes. I would not do an online course, though. A large part of the benefit of school is in having and interacting with peers. They'll teach you things you'd have otherwise missed. You'll also build a social network that could be useful after school. That last part is actually the biggest benefit that the Ivy League schools confer. They're not necessarily that much better in instruction; you walk away with more valuable connections. That said, $100k sounds like too much. Shop around for schools. You may find something more affordable that still gets you what you need. You're at the point in your life where you don't have to put off paying a mortgage, caring for a child, or doing any one of the numerous things that adult life foists upon you. If you're going to get one, do it now.
Appreciate the input! Well the issue is that I wouldn't be able to go fulltime any other way. I commute an hour roughly and have 2-3 hours a night which generally is taken up by something unfortunately. Every school I've reviewed gives degrees equivalent (and exactly the same) as the degree that you would receive in person. The only downside is potential cost and not having networking as you stated. But for example, PSU is $550 per credit for in-state tuition last I checked and I'd require 126 credits to graduate. So prior to all of the other 'fees', this would $70k. I'm hoping an online school opens up near me with competitive rates, because other schools are usually $200 for in-state students. For example, http://studentbusiness.fsu.edu/tuition-fees
Ouch. In-state is definitely preferable. It may be worth checking into what it would take to be considered in-state and then making that happen prior to starting with the desired school.
There are some people who still do. For example those who don't want to learn TypeScript. I myself moved to Angular 2+ but still using AngularJS for some projects
Async PHP, posibly with amphp and/or reactphp. 
I don't encourage people to use anything. It's a fact that AngularJS is still used by many developers. I'm using Angular 2+ and also AngularJS for some projects 
Symfony with Doctrine
Sorry I may not have been clear haha. PSU is Penn State University, which is 5x the usual in state tuition ($555/credit). I live in PA. The one I linked is Florida, at $180~/credit. Out of state for these schools is usually $700/credit, so I'm kind of stuck with PSU unfortunately. I'm mainly waiting it out and hoping for cost to drop or another school to offer an online/off campus program. 
I post links to tutorials I've created so is that not allowed now???!
&gt; it might not consume extra memory at all Only if you use Copy-on-Write wisely and know OS specifics. 
GraphQL is not about databases. If you want graph db - try things like orientdb.
I went to OU and liked it. It's a solid Tier 2 school. Looks like the out of state tuition isn't ruinous: https://www.ohio.edu/admissions/tuition/ As a bonus, the geography is more similar to Pennsylvania than the rest of Ohio, in case you ever physically go.
Wow thanks! I'll keep that in mind. I live on the other side of the state, I'd ideally like to have something semi-close so I could go on campus for meetings occasionally. But yeah, the per credit cost is just about half the price. https://www.ohio.edu/admissions/tuition/#online-tuition
My understanding is that in order to get the most out of it you need to think backwards. You set up relationships based on how you want to query your data rather then the standard normalized sql. But learning is the reason I want to deploy an app with it this year, as I have only heard anecdotal information and Node guys crushing. 
Initiative is very good, I like your spirit. But you should think that if changing culture with your team is hard, changing culture in managerial level is much harder. You have to show that you lost money without a CVS, that helps you in managing that million lines of code. I say the same thing about enviroments and IDEs. Money talks..
It‚Äôs called excessive self promotion and is against the rules of this subreddit. Also, the blockchain miner shows you have no class. 
What will you choose to do plow a field, ferrari or tractor? If you are choosing ferrari you are doing it wrong
I hope to add at least one of these features: - Co-variant return types and contra-variant parameter types: interface Parent { function m(Child $x) Parent; } interface Child extends Parent { function m(Parent $x): Child; } - Parameterized types, also known as generic types: class Box&lt;T&gt; { private $data; function __construct($item) { $this-&gt;data = $item; } function get(): T { return $this-&gt;data; } } - Pattern matching for objects and object literals: $o = {"p": 42, "q": true}; // above is equivalent to: $o = new StdClass(); $o-&gt;p = 42; $o-&gt;q = true; list{$p, $q} = $o; // above is equivalent to: if (!\is_object($o)) { throw new TypeError(); } $p = $o-&gt;p; $q = $o-&gt;q; This would generalize to any class without a constructor, including no inherited constructor: class Site { public $name; public $url; } $site = Site{"name": "Reddit", "url": "https://reddit.com/"}; // equivalent to: $site = new Site(); $site-&gt;name = "Reddit"; $site-&gt;url = "https://reddit.com/"; 
Maybe I‚Äôm blind but it would be nice to search through laravels collection by values, for example: has(), only supports searching by key, not useful if your keys are numeric.
I didn't know about [ninja-mutex](https://github.com/arvenil/ninja-mutex) lib, it looks good 
This year we're upgrading from PHP4 to PHP5! /s
Quit now. You‚Äôve already wasted 6 years here. Get out while you still can.
Yes, learn about PSR-0 and PSR-4 as well
https://github.com/etsy/logster
[contains()](https://laravel.com/docs/5.5/collections#method-contains)
Acceptance tests are usually a lot easier to introduce in an old codebase. Refactoring to introduce unit tests mean you are refactoring code which is not tested: always a bad feeling. Doing it after you've put acceptance tests let you feel more at ease about the fact you're not breaking things everywhere.
I agree. Especially since refactoring should be a separate process from testing/writing the code (don't do them at the same time). It can get overwhelming.
Syntax is valid. Looks like Github doesn't like the `self::` maybe try changing it to the class name, ie `ClassReflection::`
That was just a random example I got from a public repo; I get the same when the default argument is an inline string or a class constant ([https://i.imgur.com/csppcvJ.png](example)).
interesting.. definitely a Github issue. 
Looks like the PHP interpreter agrees that GitHub is in the wrong here: `&lt;?php function foo(string $param = 1); }` `PHP Fatal error: Default value for parameters with a string type can only be *string or NULL* in /test.php on line 2`
And me being an idiot is proven once again hahahaha
‚ÄúOh, you‚Äôre a builder? You can use any hammer you like to get the job done‚Äù -Bad company 
 &gt; is a bit overkill for my small app. A framework basically gives you a router, db abstraction, view rendering, dependency injection container, service registration, session integration and form handler. You're going to need all of them for your app. I don't see how it's overkill. There's 3 reasons I wouldn't use a framework. If it's literally a single route site, I know what I'm doing and I'll make something more optimized for higher traffic/scalability or I'm pulling in components to make something lightweight. Don't worry if you think the framework won't scale well. You're going to get 100+ requests a second on a tiny box or thousands if you add more servers. And if whatever you're doing ever gets to 1K+ requests, you're probably making money and can hire someone to build something better.
We don't "force" an IDE, but we say you have to get one that has certain features. It's just to make sure you have code formatters and a can run xdebug. I would probably frown on someone that's just using a text editor.
BlazeMeter, Sentry, Locust 
In all honesty, leave. Just from your post it seems like you're either the smartest developer there or the only one trying to get better. Go find a place that uses newer technology and there are much smarter people than you. It's the only way to get better, by learning from others that know more. These are the people that will push you to try and be better than them. Also why you are at it, learn another language. Try to pick up Node and Go. I got better at my older languages when I picked up other languages.
Not sure I'm so fond of curleys directly after the class name... Seems like a good place for a new "new" keyword then wrapping it in parenthasis. $x = build MyClass ({ "hello": "world" }). Hmmm ... actually if "build" remained as "new"... well that'd just be function overloading the constructor and passing it an array-like single argument with inbuilt default behaviour... __construct (ClassProperties $p) { ... } Or... if there's no constructor defined at all, perhaps the default constructor could just accept an array and do the same thing? Curious. As for generics... if you pull it off... a selection of drinks shall be delivered to a location or your choosing! 
[removed]
I will love you forever* for those top two.
NEVER buy anything on Udemy without coupon. Udemy always have discount coupons. Just google them before buying.
Thanks for the heads up. I bought a few courses for $10 each when they had every course for $10. I saved something like 94%.
I find it so weird to teach SQL JOINS in the context of a PHP framework. How about learn SQL first? How about do a course on relational databases?
For external monitoring I use [API Science](https://www.apiscience.com/). It is a simple tool to measure and log API uptime and response times. Been happy with them so far. For internal monitoring, ie. logging how much time is spent in database etc I use a self made tool called [Instrumen](https://github.com/tuupola/instrument) together with [Grafana](http://grafana.org/).
You can Stat using Git on your own without any cost or knowledge of by your employer..`git init` and start committing. 
You're going to get lots of opinions here, good luck navigating through them. I use Cake 3 and enjoy it. We have a SlimPHP app for a small client that connects into our larger Cake API. I am migrating away from it into Cake 3. I don't care about the performance, I rather just have all the pieces there for me and focus on coding rather than finding a component. Varnish solves performance. This opinion comes from a guy who has used cake for 6 years though. People seem to really like Laravel though and I have a good buddy who swears by Zend. Like I said, you will get lots of opininos.
Agreed try accepting complex requests through a GET string. Array types structures become var1=x&amp;var2=y or comma separated values in the parameter. I find it ugly. It can be done, but I rather receive a JSON payload via POST and easily convert it into a complex variable versus trying to convert a primitive into something complex. Gross.
It's not a Github issue nor a PHP bug. It's a suggestion to move code logic into the body instead of providing a non-null default value. This gives you more control over the default value. A little more about it: https://github.com/kalessil/phpinspectionsea/blob/master/docs/code-style.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [kalessil/phpinspectionsea/.../**code-style.md** (master ‚Üí bbe5a7c)](https://github.com/kalessil/phpinspectionsea/blob/bbe5a7cd8437f4159b333c9b82c3bab7ba6baa9a/docs/code-style.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drglz9r.)^.
On the SOAP note, I cringe when I have to implement a SOAP API. When it works, its okay, but there are instances when PHP cannot consume the WSDL. This then leaves you writing raw XML, because you can't trust converting objects to XML will result in the proper SOAP XML schema. I've seen implementations where engineers tried using fsockopen to communicate with a SOAP server. Don't do this. Use SoapClient::__doRequest as you can still use PHPs native Soap client and pass raw XML. I spent a week rewriting a jenky fsockopen soap client implementation that was slow at best and failed at its worst.
We have 4 errors types. 400 you sent us something bad, 401 not authorized, 404 we don't have it, 500 we messed up. Example: { "message": "Unable to parse JSON. Is the request body malformed?", "url": "/foo/v3.0/.json", "code": 400 } Works pretty well for us.
The name of the GET and POST variables in PHP are a bait of a misnomer. It has nothing to do with the method. I‚Äôm talking about methods, not variables. 
Did you read the article? I think I have covered basics as well.
Did you read the article? I think I have covered basics as well.
Yes of course, that was implied, but you don't use CoW by yourself, your OS does.
Yeah I had very good experience from ZF2 so I was thinking about come back to that, but learning a new Framework could be interesting (that's why I took Phalcon when I started my app). I don't really understand the hype for Laravel, though. Thanks for your opinion about cake, It was on my "list" but as I had bad expersion of it when I worked on a shitty coded app, It was not in the top. 
It's true almost every app eed lots of features proposed by Zend, and other "big framework". And I already know a lot about ZF2 so ZF3 should be an "easy option". Thanks for your opinion 
Yeah I saw the microkernel a bit after posting &gt;.&gt; But it's true that standard installation will be more useful. Thanks for your opinion.
As being able to set a default value is quite common, I would have thought the first place a coder would look for a default value is the method declaration. This is also something that IDEs will show up with code assist type displays. This looks fine on trivial examples, but if a value is used throughout the method, you would probably end up doing a simple assignment as one of the first steps to set the default value. 
Are you sure? It's the same colour GitHub uses for marking errors in other languages, and it doesn't seem to mark other code suggestions with such a colour... I've never heard of GitHub giving code style suggestions (i.e. for valid, documentation-sanctioned code) on its own, to be honest. That would seem a bad idea with many projects having their own coding style paradigms. Looking at the [grammar](https://github.com/textmate/php.tmbundle/blob/4b5c247c34f6c73e193ec810f320acad8a61b263/Syntaxes/PHP.plist#L539) GitHub uses for its PHP highlighting, I think the problem is that the relevant bit hasn't been properly updated since PHP 5.1, when arrays and class names were the only allowed type declarations in function arguments. Indeed a declaration like `function foo(array $test = array('value')) {` passes fine and doesn't get marked as an error, while short-hand array syntax that was introduced in 5.4 (`['value']`) isn't parsed. See [this](https://i.imgur.com/rhBx01K.png) for example, which seems to confirm that suspicion. 
I've been experimenting with the Actor model in PHP for some time now. Hopefully I'll have something to show in 2018.
I'm glad you think text is hard to read despite its size, too. I thought I was having an optical migraine.
I tried to do that the other day, wasn't sure if it was part of the rest/spread operator. Something like `$x = [$y, ...$z]`. I was disappointed.
FWIW I would not use a default argument that didn't match the declared type (except null) no matter what some syntax highlighter or the PHP interpreter allowed. If the behavior isn't clearly specified in the manual, I don't want readers to have to guess what happens.
Human resource beings, especially head hunting section. Work exclusively on intra net apps, so need to populate my private repo with some code of good quality.
Quite common doesn't mean it could be done better. If your default value, for example, is an empty array, the method doesn't know if you passed an empty array or if it was the default value. Also, I don't think it's a good practise to just accept a default value and don't look what the available options are. 
Lets say you get a 401 for wrong password,401 for account not activated yet and 401 because you've been banned in a login request, now the 401 response for a ban response has adittional data as perhaps the reason and the period of time that youve been banned. How do you document that?
Nice find!
&gt; Co-variant return types and contra-variant parameter types: I thought that this isn't possible since this kind of information available only at runtime.
How that works? If i made sql requests to db inside the map, they will be performed in parallel?
CakePHP 3. Has a fantastic ORM out the box, and an official ODM extension (based around ElasticSearch).
[removed]
I just recently switched from Sublime to Brackets. Especially with Plugins a great tool. If Sublime-reminders annoy you, give it a try. 
My thoughts exactly. Especially when the argument of how difficult and expensive implementation will be comes up, having it already implemented and running on your own is a huge argument. And even if it doesn't become company-standard, being able to access the benefits in your daily work is preferable to not having them. 
Q: Is language A or B better? A: Depends on the job you want to do. They are both good in their own fields. Every article ever I mean, it's not wrong, but it's also not surprising. 
Lol :p
Hello. Please check out my library, bingo-functional - a functional programming package for PHP. Here's the link: https://github.com/ace411/bingo-functional
Was on my phone earlier so kept it short, but, yeah. Git is so cheap to start using there is really no reason not to. The first time that you are able to use something like `git bisect` to find problems, you will quickly be able to convert your co-workers to join you, and eventually management. Especially since there is no cost to using git, the software is free and there is no need for servers. If you want to have a central repository, gitlab.com gives you all of the benefits of a github paid account for free. ( Note I don't work for gitlab but would be happy if they hired me ). You will see lots of people saying that "git is difficult" but, frankly, I can't take anyone seriously as a developer if they think that basic git usage is anything but a joy to use. Advanced branching, and merging and rebasing can be complex topics to wrap your head around, but that is only because they are so powerful. TLDR; Today go into your project directory ``` git init git add * git commit -m "initial commit" ``` 
Yes and no. Your database connection usually isn't serializable, but you can open a database connection in each worker and use that. ``` // This function ensures we have one connection per worker. There won't be a new worker for each job, they're persistent. // This function avoids creating a new database connection for each job. function getDatabaseConnection() { static $connection; if ($connection === null) { $connection = ...; } return $connection; } $collection-&gt;parallelMap(function () { $db = getDatabaseConnection(); $result = $db-&gt;query(...); return $result-&gt;fetchAll(); }); ```
Unless you are a command-line-freak, git is a bit difficult to get into. But I agree that it's definitely worth the effort. I wouldn't go as far as saying not using git is unprofessional, but not using a version-control in a professional environment definitely is and git is a very good solution to that problem. And it's great for everything that involves text that changes. I'm pretty sure if you want to write a novel you can use it too. 
That might have been true back in the old 4 and 5.2 ages, lot of things have changed. It now has the state of the art ORM of them all in PHP :) Try it - and you have a better point of decision making here.
I'm surprised nobody mentioned the fact that Doctrine can be used with Phalcon just fine. Doctrine isn't bound to any specific framework, it's a stand-alone project. As for Symfony, it's a pretty easy framework to learn and use. Symfony Flex with 3.6/4.0 makes it even easier. Symfony now defaults to the microkernel, making it far smaller and more modular. Of course, if you're comfortable with Zend you can use that as well. It should handle projects of any size, though I haven't used it since ZF1. The main thing is, if you don't like a component provided by a framework, you can replace it with a third-party component. If Phalcon's ORM doesn't suit your needs, but you think Doctrine might, then use Doctrine.
Even "standard" Symfony now uses the microkernel by default.
Oh yeah I didn't event thought about using Doctrine with phalcon... &gt;.&gt; It might be my savior, but will need lots of works, as there isn't existing module of Doctrine with Phalcon, though I'll learn a bit more on how to integrate Doctrine in Frameworks, thanks. 
Oh yeah I didn't event thought about using Doctrine with phalcon... &gt;.&gt; It might be my savior, but will need lots of works, as there isn't existing module of Doctrine with Phalcon, though I'll learn a bit more on how to integrate Doctrine in Frameworks, thanks. 
I second vimeo. It has an API so you can even hide the upload process if they don't want to hand out the account to a bunch of people (we had this happen on a project).
It is available only at runtime, yes. However our inheritance validation (usually?) happens at runtime via the `VERIFY_ABSTRACT_CLASS` opcode. As long as the definitions can be obtained prior to running that opcode we are okay.
For a reasonable list of styles you can look to Wikipedia. https://en.wikipedia.org/wiki/Indentation_style Personally, I use Allman style, which is similar to the standard PHP style but puts every curly brace on its own line. I like the visual breakup vertically. I would also suggest to look outside of PHP for other best practices.
It would be really cool to have copy on write for those.
Basically `return array_merge($result, [$item])` or `return $result[] = $item` do the same for that specific case.
The community version of Kaltura might be an option if you want the whole video stack... it's designed to be supported and customised in the enterprise tho (think Uni environments) so depending on your integration it might not be useful - but it can work smaller too. Upgrading etc without support can be a pain tho
Coding style is very subjective, but [PHP The Right Way](http://www.phptherightway.com/#code_style_guide) has some decent suggestions.
I also prefer Allman, although sometimes I feel alone in the world :(
I played with Phalcon 2 briefly, whatever the previous major version was. For me it was a little too barebones. Its approach of being a fast php extension has its appeal though. But you can tell from my post, right-or-wrong, that I prefer an all-in-one framework. If it was a Cake 2 app that my have been why. They ceded some ground to other frameworks during version 2. Going to Cake 3 was not bw compatible. Truthfully I feel all these frameworks let you do the same stuff. Just get good with one and most of your skills will transfer over to another one minus learning curve. Laravel seems to have a very active community. And one person brought up how modular Symphony is. In fact, Cake uses some Symphony components. So that framework did indeed nail that aspect.
This guy certainly might know a thing or two about Cake.
Write less PHP
Wow, do I know what you mean. I tend to think the reason for the popularity of PSR-2 has a lot to do with modern screen resolutions. 1080p screens take just enough away to cause a person to want to compress the vertical space of the code. Well, that's one take. Like EnragedMikey states below, the coding style someone chooses of very subjective.
I can think of: http://www.phptherightway.com/ https://symfony.com/doc/current/contributing/code/standards.html 
I can't stand the Allman style. Much prefer curly braces on the same line where they're out of the way.
I have developed https://github.com/atk4/data, I'd love to hear what you think of it. It is not affiliated with any major frameworks so you can use it as a drop-in replacement. It's free to use and development around it is quite active. 
Quite impressed with the syntax, especially cross-database relations. Well done, wolfy-j. What is your motivation and long-term plan to keep maintaining this under MIT?
Honestly. If you are working in development you should be fairly comfortable with the command line, especially enough to use git. Using git doesn't require any scripting, just simple commands. If you find the command line confusing, what are you doing programming. Also there are some pretty simple GUIs 
We are using in a bunch of production applications on a different scale. This is 7 years old framework and we are not planning to abandon it :)
`return $result[] = $item` will result `$item` and `array_merge` is messier. This is just small syntax sugar and I just interested to get my knowledge about PHP insides more clear.
Try Yii2
Whichever standard you decide on for your codebase, use [PHP Code Sniffer](https://github.com/squizlabs/PHP_CodeSniffer) to help enforce it.
I went and bought a Laracast membership. But it seems like most the intro videos aren't behind the paywall.
Must have : https://github.com/FriendsOfPHP/PHP-CS-Fixer
Once you work in a team you realize that "following the PSRs and be done" doesn't work. Because there so many more things affecting codestyle which are simply not covered in those PSRs and some things are considered to be more philosophical, etc. We tried various approaches but ultimately settled with a 3rd party service https://styleci.io/ . You can configure it in any way you want. And the best part: automatically commit/fixes the violations. Short: it doesn't just report violations, it immediately fixes them and your developers waste less time (not 0 time as practice shows, but less üòâ). But I think the most important lesson I learnt: set rules and enforce them. Doens't matter if some team members don't like it, consistency of the code base is more important than the pride of individuals (note: common sense applies, doens't matter rules don't get hanged, etc.).
It‚Äôs just incorrectsyntax highlighting. The PHP package in Sublime Text had a similar issue with `array $asd = []` at one point. 
Have you tried https://www.opulencephp.com/ ?
Check out the PSR-12 proposal - https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide.md. That proposal specifies some more and since it is still a proposal you can suggest changes or ask for more clarity.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig/fig-standards/.../**extended-coding-style-guide.md** (master ‚Üí 0aa9461)](https://github.com/php-fig/fig-standards/blob/0aa94615efbe82aed7cc6dab5eb7cb7b469d1455/proposed/extended-coding-style-guide.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drhkn23.)^.
&gt; Much prefer curly braces on the same line where they're out of the way. Except where you're declaring a function or class? Never understood the reason for not being consistent with that.
I put curly braces on the same line for everything. class Controller { public __constructor($foo) { if ($foo === 'bar') { //... } else { //... } }
asdf
Honestly, this seems like spam.
I actually prefer them on the same line but telling new devs "PSR-2 format" is so much easier than "PSR-2, plus this (ever growing?) list of exceptions". So these days I just have everyone do it PSR-2.
Not very interesting, as always. They should finally add parallel download support. They are ignoring pull requests for it for years. It's a major composer problem that's it's slow.
&gt;Except where you're declaring a function or class? Never understood the reason for not being consistent with that. Personally Allman just looks overblown for control structures (especially with single statements under them), but fits well for classes and functions where I like a blank...ish line between the signature and body (especially if the body is longer and contains blank lines itself). I value readability/clarity more than rule-consistency. What I never understood is the harping on that point every time PSR comes up. I even saw people arguing that PSR needs to fix this "inconsistency" and that it's only there because people where too lazy to fix their legacy code. As though K&amp;R 1TBS isn't a valid style. A style guide is about consistency within the project's code, not about consistency of rules.
Finally another NetBeans user! :D
Late reply but turns out I got this idea because the precedence of the operators is different in Javascript. https://i.imgur.com/JGnRkos.png I had been thinking that I was insane for thinking this for the past month or so.
Actually, the real truth is the following: nobody can force you to use a specific code style unless you have a project leader who makes the decisions regarding the mentioned code style. In this community, where the most defended this is the freedom (don't forget about Free Software Foundation), you can choose your own code style in every project. But the key is not about figuring out what code style to use, it's about following it. So choose a code style you want, existing or not one, and follow it.
Why not both? My general rule is unless it clearly a socket based application then php is the default choice. But just because you build the bulk of your project in php doesn't mean you can't build microservices in nodejs when its suitable.
Continue to not use third party libraries like Composer in all of my projects.
kewl thx
Ha no problem :)
That's my resolution every year. Unfortunately it never worked out. Every year legacy PHP code causes more problems.
WHAT‚ÄôS NEW IN PHP 7.2? https://www.titechglobal.com/whats-new-php-7-2/
Hmm? Correct me if I'm wrong, but IIRC, except for the handful of 16:10 monitors at 1920x1200, most popular monitor resolutions before that had way less than 1080 vertical pixels, so 1080p doesn't take anything away from anyone.
Your code creates only one connection. 
I'm developing my first CMS using Laravel 5.5. Now I just finished creating my first models and migrations to create my first features and the CRUD for products. I would like to know how do you organize your workflow. I'm drawing and writing all the functions, routes, models and controllers I'm going to need. Then I start writing and testing the app. And you?
I wonder how all these APIs will fare with the upcoming [EU GDPR](https://www.eugdpr.org/) requirements? With REST, it is fairly easy to determine if things should be logged. If the response contains any data, which is person identifiable, log it. This exercise is a bit more tricky (though not at all impossible) with SOAP and GraphQL. These API types may return only partial data in a single request. But many bits of partial data may still be coalesced into something, which may be utilized for identifying a person. **Example:** * Request 1 returns a user's age based on a user's ID. Logging is not required, but the age is now exposed. * Request 2 returns a user's home address based on a user's ID. Logging is not required, but the address is now exposed. Combining the data from request 1 and 2 may, by method of elimination (a person of a certain age living at a certain address), reveal who the person is. This problem, of course, goes beyond APIs. But it's a very good place to expose and exemplify such issues.
No. The callback is magically run in different processes and it creates one connection in each process.
There are dozens of us, DOZENS!
TL;DR - listed and explained over 100 features / criteria which modern ORM/Database Access Libraries may or may not implement. Comparison table here: https://socialcompare.com/en/comparison/php-data-access-libraries-orm-activerecord-persistence, it still need some work.
My (unpopular) opinion is that everyone should be using PSR-1 and PSR-2. Simply because it should be a case of 'this is the standard, you will use the standard as its what everyone else does'. 1 set of standards means its easier for all of us. I dont care if you prefer a curly brace on the next line, or if you prefer 2 spaces instead of 4. Stick to the most popular standards. Theres things in the standards that we all dislike but its not about personal opinions its about making everyones lives easier. TL;DR Knuckle under.
I'd be interested to see Bunny benchmarked with its async client. 
"objectively"...
A just in time compiler.
I lol'd at the title picture.
I have two monitors side-by-side and then a third vertical which I use for code, and aside from a few small issues, it's the greatest decision I've ever made.
Oh Tobias, you blow hard!
Hey, I've got only my point of view :) That's why I ask your help to me make it more neutral. But you gotta be more through with your feedback, what things to remove, what things to add. Care to help?
PHP is already serverless. AWS Lambdas exist to isolate environments between requests and focus on high response times. This is something PHP had from early days.
This website is terrible. Persistent content on the top, hat prompt on the bottom, and the scrolling effect make it a horrible mobile experience 
@wolfy-j, your work motivated me to re-activate my older comparison table. I think more people should be able to see and compare ORMs on features. I've added column for Sprial ORM, but perhaps you can help by filling in the blanks: https://socialcompare.com/en/comparison/php-data-access-libraries-orm-activerecord-persistence# I also wrote a LONG article explaining in great extent what different features mean, which should help. It's linked in the description.
I wonder if they had a chance to _fix_ the behaviour of `composer exec` to display output by default...
&gt; PHP is already serverless. AWS Lambdas exist to isolate environments between requests and focus on high response times. This is something PHP had from early days. That's not what serverless is or does. And if you needed fast response times, I'd suggest avoiding serverless. "Serverless" services (like AWS Lambda) primarily exist as a way to run code and pay for usage without managing infrastructure at all. Benefits provided to end users: server software is always up to date, autoscaling is automatic and configurable, and cost only scales to usage (if it's not used, you don't pay for anything).
Much appreciated, didn't know about it üëç
I found out recently that with apache instead of modifying the configuration files, you can simply add environment variables to /etc/sysconfig/httpd
im so hyped to get this going with Slim over the xmas break
Is there a similar benchmark for consuming?
I made a fictitious fitness site for a class
My first real work was with PHP (4) at a company I got hired at. The entire site was built already (doing about $200,000 a day in sales), so my first was adding features and fixing bugs. Can't remember what my first new build at the company was. I do remember some of us trying to push to a more OO type of setup (everything was legacy spaghetti scripts) and after an hour presentation of what we'd like to do, why, etc, someone raised their hand and said "I still don't get it. What's an object?". So that was fun... 
I made a data miner for OGame with PHP+GreaseMonkey - lots of fun and LOTS of data.
I wrote some time ago library which might be helpfull to you. It's not generator, you use it more like regex but it uses notation simmilar to BNF and return syntax tree. Check out examples. https://github.com/farafiri/PHP-parsing-tool
email newsletter/bulk mailer (no bounce handling or anything but did pretty much everything else, but it was designed for (at the time) less than 5k sends at a time). Surprisingly to myself it took only a week. I'm a designer and it was my first attempt at programming other than the bug fixing I had been doing (which was how I learnt PHP, someone had to fix the bugs and I am a one-person company, previously had employees, but that's another story).
At first glance I thought something else was going on. Had to double-take.
What's wrong with composer?
Threads outside of php-cli would be awesome. It's not going to happen, but it would be awesome.
&gt; Any other insights Language macros can go a long way towards adding new syntax and semantics to every-day code. I'd suggest looking at https://github.com/marcioAlmada/yay and https://preprocess.io for some ideas as to how this can be done.
Agreed. However this doesn‚Äôt strictly apply to PHP
So, I'm the builder of YACC (as you mentioned). and yes, there are plans to continue it. The current state is it is functional and tested (well, manually tested). It needs some unit tests, documentation, and a command line invoker (right now it has a simple script). Looking for help if you're interested!?
Clion rocks!
A friend on the internet challenged me to a PHP forum competition. I didn't know anything, he knew slightly more. We both roughly kept pace in features, but he had a better idea of what to do next. He'd do a feature, I'd implement my own one naievly, then he'd show me how I created a new security flaw and broke mine
The question is: to do what?
Did a website that showed photos of a detached bathroom my father had built, everything was built using dreamweaver and absolutely positioned links on the image to navigate inside, the php part was something like: &lt;?php if($_GET['p'] == 1) { include 'home.php'; }else if($_GET['p'] ==2) { include 'door.php'; }... 
use firebase for authentication (fb,g+) and websockets , but any other backend related stuff in php.
You should look into AWS Fargate. It's what you described but runs Docker container and PHP too. Only announced recently.
My first contact with php was ganerating custom bbcode (for phpBB forum's extension) that genrates bidding and card layout tables in bridge. Still have the code - fragment below. I was so proud of this back then:) ... &lt;table width="100%" bgcolor="#FFFFFF" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0"&gt;&lt;tr&gt;&lt;td&gt; [table]&lt;?php if($_POST[Title] != '') echo "[t0]$_POST[Title][/t0]"; if($_POST[NS] != '') echo "[ns] !S $_POST[NS]&lt;BR&gt;!H $_POST[NH]&lt;BR&gt;!D $_POST[ND]&lt;BR&gt;!C $_POST[NC][/ns]"; $W = "[ew1] !S $_POST[WS]&lt;BR&gt;!H $_POST[WH]&lt;BR&gt;!D $_POST[WD]&lt;BR&gt;!C $_POST[WC][/ew1]"; $E = "[ew2] !S $_POST[ES]&lt;BR&gt;!H $_POST[EH]&lt;BR&gt;!D $_POST[ED]&lt;BR&gt;!C $_POST[EC][/ew2]"; if($_POST[WS] == '' &amp;&amp; $_POST[ES] == '' &amp;&amp; $_POST[NS] != '' &amp;&amp; $_POST[SS] != '') echo "[tx]"; if($_POST[WS] != '' &amp;&amp; $_POST[ES] == '') echo "$W[ew2][/ew2]"; if($_POST[WS] == '' &amp;&amp; $_POST[ES] != '') echo "[ew1][/ew1]$E"; if($_POST[WS] != '' &amp;&amp; $_POST[ES] != '') echo "$W$E"; if($_POST[SS] != '') echo "[ns] !S $_POST[SS]&lt;BR&gt;!H $_POST[SH]&lt;BR&gt;!D $_POST[SD]&lt;BR&gt;!C $_POST[SC][/ns]"; if($_POST[B11] !='') {echo "[bid][b1]$_POST[B11][/b1][b23]$_POST[B12][/b23][b23]$_POST[B13][/b23][b4]$_POST[B14][/b4]"; if($_POST[B21] !='') echo "[b1]$_POST[B21][/b1][b23]$_POST[B22][/b23][b23]$_POST[B23][/b23][b4]$_POST[B24][/b4]"; if($_POST[B31] !='') echo "[b1]$_POST[B31][/b1][b23]$_POST[B32][/b23][b23]$_POST[B33][/b33][b4]$_POST[B34][/b4]"; if($_POST[B41] !='') echo "[b1]$_POST[B41][/b1][b23]$_POST[B42][/b23][b23]$_POST[B43][/b23][b4]$_POST[B44][/b4]"; if($_POST[B51] !='') echo "[b1]$_POST[B51][/b1][b23]$_POST[B52][/b23][b23]$_POST[B53][/b23][b4]$_POST[B54][/b4]"; if($_POST[B61] !='') echo "[b1]$_POST[B61][/b1][b23]$_POST[B62][/b23][b23]$_POST[B63][/b23][b4]$_POST[B64][/b4]"; if($_POST[B71] !='') echo "[b1]$_POST[B71][/b1][b23]$_POST[B72][/b23][b23]$_POST[B73][/b23][b4]$_POST[B74][/b4]"; if($_POST[B81] !='') echo "[b1]$_POST[B81][/b1][b23]$_POST[B82][/b23][b23]$_POST[B83][/b23][b4]$_POST[B84][/b4]"; echo "[/bid]";} ... 
Can I ask, why make you're own CMS? Is it a personal learning project or something that will see the light of day?
yes they are having sex not racing
I've used [ANTLR](http://www.antlr.org/) in the past for some Java projects. It does **not** have a PHP runtime yet, but [it could be done](https://github.com/antlr/antlr4/issues/1850).
[removed]
Sure. I'm not saying command-line is a bad thing. Just that it's a threatening thing to some beginners. But I agree with you. 
Are you asking because you're curious, or do you have a real problem at hand you're looking to solve? One idea to explore if you actually have a need to create a parser within PHP would be to instead use a mature tool (e.g. yacc) and then expose the result as a PHP extension. You'll have the benefit of using a well established and maintained tool, and get better performance in the end. On the other hand, it's harder both to distribute and to find contributors that way.
It appears to be written in old-school procedural PHP, but the [Damn Vulnerable Web App](http://www.dvwa.co.uk/) may work for ou.
A good thought, but it can't be a ready designed application. Students must not be able to simply google all the exploits.
How long would it take to refactor on to an older framework with some known security vulnerabilities though? Or to just alter it until it‚Äôs non obvious where it came from?
Made a website for a Turkish company that sells scout uniforms, in 2003. https://web.archive.org/web/20040226214406/http://abreizci.com:80/
We get student interns each year. We set up a very basic open source project for them to work on. This year they worked on an MVC message board: https://github.com/BiffBangPow/message-board
https://github.com/daveh/php-mvc seems to be part of a tutorial on how to build your own mvc in php...maybe a start point?
It's MIT licence so do what you want with it
Also POMM is missing 
[sample code from my book](https://github.com/PatrickLouys/professional-php-sample-code) I actually go through quite a few of the vulnerabilities during the book. First implementing and then fixing them. Maybe it will help.
Does it need to not use any framework? 
**No**, because MVC is not for "basic apps". That is the entire point.
It will be posted for sure.
https://github.com/komarserjio/notejam
The one I'm still working on and trying to improve/add features to. While I try to come up with other ideas. I made a movie database script to keep track of all my DVD's/Blu-Ray's so I could keep track of who had borrowed what. Or "Do I already own *insert title here* when I'm at a store in doubt of what I have on my shelf." Then I adapted the code and put it into a separate repository to keep track of games and books. Then I changed it all from procedural code (it's still there in it's original form just a different branch) to OOP code. 
LOLed on PHP-Yacc. &gt; How does it work? &gt; I don't know. I just ported the code until it worked correctly.
I was a junior developer for UK Property Channel, which is now known as RightMove.co.uk
Do I need to have rabbitmq installed for this to work? Or these are standalone?
Of course, you need an AMQP 0.9.1 compatible broker, for example, RabbitMQ. 
We're using beanstalkd and are happy with it, are there any advantages to consider that AMQP offers?
A chat system extension for radio NRJ europe back in 1998 . Was a bulletin board, user gallery registration etc and linked to a eggdrop bot that gave voice status to users that were registered via the community. The chat itself of course was IRC.
Look at this: https://github.com/php-fig-rectified/fig-rectified-standards/blob/master/PSR-2-R-coding-style-guide.md It is from one CakePhp developer and seems very good to me.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig-rectified/fig-rectified-standards/.../**PSR-2-R-coding-style-guide.md** (master ‚Üí 381bdfb)](https://github.com/php-fig-rectified/fig-rectified-standards/blob/381bdfbb77580f21815f559314e5751c38e95e30/PSR-2-R-coding-style-guide.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drke8p7.)^.
[removed]
&gt;How does it work? &gt;I don't know. I just ported the code until it worked correctly. :D
It's me or the lastest release of PhPStorm doesn't work fine? I have issues with function that it doesn't recognize and mark as undefined constant, cannot copy and paste, the indentation got fucked after pressing enter
Nice! So, aren't these test results dependent on the broker? For example it may be that rabbitmq works better with a specific implementation and not with some other one, or this doesn't make sense?
Stop using Laravel for anything that needs to be in prod for more than 1 week
I tested it with RabbitMQ broker, I took stock Docker container, default config. 
First link from Google looks good to me https://nitinbhojwani-tech-talk.blogspot.com/2016/09/message-queues-beanstalkd-sqs-rabbitmq.html
This is a really nice though. If anybody need to add a Github token the URL is: https://github.com/settings/tokens happy staring
Brilliant, easy and meaningful way to say thanks!
&gt; I decided to use the default versions of both the frameworks Sorry - but the _whole_ point of Taylor's statement is the default versions of both frameworks are not apples for apples. Laravel comes pre-configured with more out of the box (sessions, ORM etc), whereas Symfony 4 is more of a bare bones structure that you can add things onto (like sessions). If you are going to "test" what Taylor is saying, then you need to actually test _what_ Taylor is saying.
&gt; as long as there is one and only one instance available to meet the dependency requirement This claim used to be true in 2.8, is deprecated in 3.3, and is plain wrong in Symfony 4. With Symony 4, autowiring works *by-name*, not by type. So 70,80,90 percent of your above statements are just misleading to readers.
You couldn't change the behavior of objects in runtime? In order to test code via mocking you'd need to actually have two versions of the code - a testing version and a prod version? At least those seems like problems if I'm understanding what you're saying correctly.
lol, github stars....
Why would you need to change behavior of objects in runtime? I totally agree on the second point though - the current implementation is untestable.
I find appalling that the very first dependency in those popular packages is `illuminate/support`. That being said, can we have something else that BS article trying to show how's got the biggest dick? Masturbate on GitHub stars if you want but really guys stop taking that as a primary metric of popularity and stop talking about it, keep it for yourself 'ty.
I was not expecting this when I clicked the link. What a fantastic idea!
Why with the scrolljacking? Can't I just scroll down like a normal person?
So, if a class implements `CartFacadeInterface` something external will automatically call `setCartFacade()` on instances of that class? If so, then I would say this is just a combination of autowiring and [setter injection](https://martinfowler.com/articles/injection.html#ConstructorVersusSetterInjection); its not much worse (or better) than autowired constructor injection if you ask me. The other option is that the traits are just "helpers" that make it easier to manually pass along the dependencies; $obj = new SomeServiceClass(); $obj-&gt;setCartFacade(new CartFacade()); In that case, I agree it isn't optimal, but not because of the setter methods; it sucks because apparently dependency creation is an "every object for themselves" deal in this application.
Based on the code you've shown, for testing purpose, you can just do something like `$myService-&gt;setCartFacade(new MockCartFacade());` couldn't you? That looks pretty testable to me.
https://github.com/jupeter/clean-code-php
But how else am I supposed to start another Symfony vs Laravel fight in the PHP community?
What is the equivalence stars to bitcoins?
nginx rox 
I can't see it any other way than two rabbits shagging. Is it supposed to be two rabbits next to each other? 
PHP Opcache. /thread
Thanks.
That's true, but I cannot make a simple constructor injection, because the traits are loaded after the constructor actually fires. So, if I try: public function __construct(WhateverFacade $whateverFacade) { //.... it won't work. I need to implement another interface that loads additional "constructor" that could actually load the injected class. This creates an unnecessary overhead and makes it really hard to track all dependencies a class might have. Previous developers used 10-15 traits / interfaces in one class without thinking how tightly they're coupling all these classes. I don't think that having a dependency with another class should be related to a trait AND an interface.
Lol, this article is a complete garbage. Did you even read what Taylor said in his article? 
At the end of the day, nobody cares about hello world benchmarks.
&gt; That way when you need a factory (which is not a factory at all, but that's a completely different story) you "just" need to use the corresponding trait and voila. Who calls `setFactory` on it?
Not sure if totally first but at least the first OSS contribution was [Image_Remote](https://github.com/pear/Image_Remote/blob/trunk/Remote.php) PEAR class. Functionality was later added by someone else to PHP core.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pear/Image_Remote/.../**Remote.php** (trunk ‚Üí 92bbc6a)](https://github.com/pear/Image_Remote/blob/92bbc6afe8220f08ecd86651f38ee3ff99590b89/Remote.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drkma37.)^.
Ah the good old days of first webchats. I was running one for Kiss FM.
yes. The traits contain only one method - *setFactory()* or if it's a facade trait - *setFacadeXXXX()*
Not exactly. Or maybe there is a bug in the S4 implementation. Start with a fresh S4 skeleton and make a transform interface per the docs: https://symfony.com/doc/current/service_container/autowiring.html#working-with-interfaces So you have the interface: interface TransformerInterface { public function transform($value); } An implementation: class Rot13Transformer implements TransformerInterface { public function transform($value) { // TODO: Implement transform() method. } } And a consumer: class Whatever { public function __construct(TransformerInterface $transformer) Now according to the docs, autowire should fail: &gt; But now, the type-hint (App\Util\TransformerInterface) no longer matches the id of the service (App\Util\Rot13Transformer). This means that the argument can no longer be autowired. But it works. Try it. The service gets injected and all is well. And if you add a second implementation of the transformer then boom. Autowire fails. Maybe S4 is not supposed to work this way but it does. And "fixing it" could cause some unpleasant "BC" issues. And even it if worked right it can still be confusing since you do want your classes to typehint against interfaces but with multiple implementations you have to fall back to hybrid wiring.
This is great! Could it be a core in `composer` itself somehow? Like `composer say-thanks` that I can run in each project, rather than pulling in a package?
https://www.youtube.com/watch?v=3IYQXUfezxY
No, no. Who *calls* the `setFactory()` method and passes it a parameter?
Exactly. Laravel's default config is "ready to go with all the common features enabled", Symphony's is "ready to enable the features you need". Argue the merits of each all you want, but their default state is not comparable for benchmarks.
Thanks. I can try adding it, but I have never used it. Could you help me populate it?
I do really hope that Composer adds this command (which is tiny by the way) to its next stable version: native `composer thanks` would be awesome!
there are some auto generated "factory" classes (really long, like 1500+ lines) that generate methods like this: public function createShoppingListModelShoppingList() { $class = $this-&gt;transformClassName('Model\ShoppingList'); $model = new $class(); if ($model instanceof FactoryInterface) { $model-&gt;setFactory($this); } return $model; } It's pretty much the same method, with difference string that's passed to the `transformClassName` method
Setter or Constructor Injection is both perfectly fine. Your problem is that you have only setter injection (hidden in traits) and you dont know which services you need to mock now. That is the problem of having needed deps per setter instead of constructor. Convince them to use a very simple DIC (standalone for new services for example) and force them to use constructor injection for deps that are required for your service to run. Example setter injection is an optional logger for example. Or at least throw exceptions in the methods if the service is not set so that you see which service you need to mock :-)
I checked it out, and it lacks depth - very small framework covering bare basics, single vendor database support. If you still want to add it, go ahead, but I think that majority of the features would be missing.
One advantage of using setter injection is that it frees up your constructor for other arguments. In other words, let's suppose that quite a few of your classes need some of these traits but not all. If you used constructor injection and needed to inject some other class specific dependencies then your constructor signatures will all be different. I'm probably not explaining it very well but it could help reduce the number of constructor arguments and make the classes easier to maintain. Not recommending it though. 
Give them something more or less up to date to attack like the [Symfony Demo Project](https://github.com/symfony/demo)
The first comment: &gt; Axel Guckelsberger said on Dec 21, 2017 at 10:06 &gt; Sweet, thanks for this innovation! you can feel the sarcasm through the screen ! 
Does this package go on to star every package you used on their github repos turning it into an attack?
My completely unsupported hypotheses is that Fabien was just poking fun at the thousands of other benchmarks which compared the slightly older fully loaded out of the box Symfony default installation and concluded that Symfony was slow and bloated. All good fun. And by the way, here is another core Symfony developer mentioning that [Laravel is 30% Symfony](https://medium.com/@javiereguiluz/30-of-laravel-code-is-symfony-a49dcf30e809).
Afaik, there is no MVC in php (unless you're using PHP-GTK).
I am not against setter injection in general. I am against using a magic trait that's called from a god class simply to make a dependency and making constructor injection almost impossible while hiding dependencies (in a way).
That's a very good point. This is exacly one of the things that's been bothering me - having ONLY hidden setter injections in traits.
`composer install --thanks`
You're aiming to build something that mimics SugarCRM, or just replaces the front-end of it? Because, neither sounds like a good idea to me... by all means build your own CRM, but replacing it wholesale sounds like a nightmare (source: I've worked with the backend of the monster, we ended up replacing ZuckerReports with a custom report that just looked at a handful of tables to get what the sales team wanted as a stopgap between Sugar's end and moving over to Dynamics) Building your own bespoke CRM may be a better approach, but then you're going to miss out on a chunk of functionality until you catch up...
https://packagist.org/packages/laravel/framework - 32 million downloads Thats the one you should be looking at.
We are looking at providing the same fucnitionality with some more using the lastest paradigms as outlined. 
This is pretty awesome.
Amen.
&gt; Are you asking because you're curious, or do you have a real problem at hand you're looking to solve? Both, actually. Thing is, in the past I often had the urge/desire to use something to quickly throw up a parse which isn't just a bunch of weird recursive functions with regex which no one understands after 1month, even me (again: this brings me back to the perl6 example I gave =&gt; this stuff is incredible useful). I was observing other teams using other tech stacks (spoiler: NodeJS) and the used PEG.js a few times, and even for small stuff, it's just so much more readable (the parser definitions) then anything custom you could come up with yourself. Ofc. it's necessary to learn how PEG.js works (but at the point you're looking for such a project, you [are supposed to] know what PEG parsers are, etc.). I feel something like this is much more accessible than when you have something which requires external tools like YACC. Although it should be the first choice (longer around then some developers, mature, tested, etc.; i.e. I assume the reason /u/ircmaxell ported it). Also, IMO, there _is_ a benefit at times *not* having to leave your stack you know best. I know a few great (PHP) developers but the hardly have a grasp of C (I bet they never used `make`, etc.) were the word "extension" would never cross their mind. And TBH, I rather adapt PHP code for a newer PHP release then having to change C code because the internal Zend API changed (just an example, but maintenance and production deployment may get one more complex edge too).
The yay-project is actually one of the ones in my "others I left out which deal specifically with augmenting/parsing PHP"-category. I wasn't aware of preprocess.io, much appreciated üëç (looks similar). Maybe I brushed them off too quickly, as it's not a goal to parse PHP related stuff (when I did something like that, I used nikic php-parser which is easily the most awesome tool in that category; to me at least), but I'll revisit them. Thanks!
Indeed I haven't heard/found this one. Thanks, I'll check it out!
The package/command actually gives you a nice link to just click and get a token if you don't have any set yet.
You can make it to the next level. Create a command that will ask to connect to your Bitcoin wallet, then say thanks AND give Bitcoins in random amount to packages' maintainers.
Some OPCache links I collected a year ago to look at, that might be useful. http://stackoverflow.com/questions/17224798/how-to-use-php-opcache OpCacheGUI: https://github.com/PeeHaa/OpCacheGUI opcache-status: https://github.com/rlerdorf/opcache-status https://tideways.io/profiler/blog/fine-tune-your-opcache-configuration-to-avoid-caching-suprises
80% of page load time is spent on the front end (HTML, CSS, JS) so it‚Äôs definitely worth spending time there if you haven‚Äôt already. Optimise images, setup up HTTP/2 (requires HTTPS), minify CSS/JS. Besides that, make sure Opcache is on like laurencei said. Then do some profiling with xdebug and see if there are bottlenecks you can speed up.
Preprocess uses Yay underneath, so same macro syntax. Just better integration with Composer and a handful of pre-packaged macros.
Rollbar, Datadog, Sentry, Site24x7, Prometheus....
php decimals and random functions? 
Setter injection is _not_ fine. Setters can be called multiple times and thus change the state _and_ behavior of your object, giving different results for the same function call. This can cause severely unexpected behavior. In addition to that, the setter might not be called at all, causing null pointers. Constructor injection ensures the object is in a valid state and doesn't change behavior mid runtime.
Well symfony/symfony also isn't the main framework package...
Sure looks like it to me... https://packagist.org/packages/symfony/symfony
As long as the dependency is not required for the service, it *is* perfectly fine :-)
Yeah but that's not how symfony works... Case in point is laravel being made on symfony... Symfony is much more than just a "framework"
And loiter the code with if checks? Way to pump up the npath complexity for no reason. Even if so, better to use an optional constructor argument, perhaps use a null object when nothing is passed. Anything but stupid setters, had far too many issues with those in the past.
Yeah but you compared the framework stats. laravel/laravel is just the project skeleton. That is only downloaded once per application on project creation. Just like symfony/skeleton. All of the real code lives in laravel/framework and is subtree split into the illuminate/* compontents just like how all of symfony is in symfony/symfony and is split into symfony/* So they are comparable. It doesn't matter how much the components are downloaded because thats not what you were talking about in your first post. You were trying to discredit Laravel by saying the Symfony framework is downloaded more which is false.
symfony/framework-standard-edition vs **laravel/laravel** **symfony/symfony** vs laravel/framework These is the correct comparison. 
My late entry, I know. Instead of new features let's first: * clean up the base functions to use consistent naming, arguments and results, e.g. date/time, arrays. * remove deprecated stuff. * make all features work the same on all platforms. Then add : * UTF-8 as base encoding for all text processing features. * be able to catch all exceptions, warnings and notices in code. * add implementations of HTTP Request and Response classes, a must have for a web programming language. * an Enum type. * have a block of static code run when loading a class. What I expect? Well, nothing form this todo list will get done. 
Thanks Laravel!
The PSR's are mainly about formatting. A style guide can also include: * naming conventions for all language elements. * maximum number of lines per class/method, method arguments, *use*d classes etc. to indicate complexity. * coding conventions, like only 1 return per method, or all literals should be constants. Think about tools to help you, like automatic formatting for consistency. And static analysis tools to check the rules you decide on. I like [SonarQube](https://www.sonarqube.org/) for this, but there are others. 
There is a PECL module that reports some of the stats similar to new relic https://pecl.php.net/package/APM its not as comprehensive as the new relic module though
My goodness. I've imagined You standing in the middle of some medieval bloodbath trying appeal to reason. lol.
Something like NewRelic with all its different features doesn't exist, it is too many products in one for OSS to reasonable tackle this problem space. As someone building a NR competitor I can speak from experience. But you can build up the parts: If you want a tracing system to collect low overhead, low signal data from end users, take a look at Jaeger http://jaeger.readthedocs.io/en/latest/ and find a library for php on packagist: https://packagist.org/?q=jaeger&amp;p=0 - There are only new ones, because jaeger is so new. It might need work to get the PHP client to be perfomant and not directly sending data via HTTP but through a local agent. For server monitoring you could look into Prometheus or Zabbix. For Exception/Error Tracking you should look at Sentry, which is also available as open source self hosted version https://sentry.io/welcome/ If you need a production profiler for callgraph data, there has been XHProf historically, which for PHP 7 we forked into the tideways extension (https://github.com/tideways/php-profiler-extension). You can combine it with XHGui (https://github.com/perftools/xhgui) or https://github.com/preinheimer/xhprof
Awesome. Thanks so much.
I... don't get your point 
My point is that if anyone needs to be convinced that this is wrong, then it will be difficult. It's so cryptic that it must've been built on wrong assumptions recursively. Maybe rewriting one use case in isolation and showing its pros would open some eyes.
+1 to this, I'd like to mention that the easiest way to get HTTP/2 + HTTPS is using Caddy https://caddyserver.com/. It's dead easy to use with PHP and you get very good default security settings. Easy to enable gzip as well for some extra speed.
I think my biggest gripe is the TODO list item #1 &gt; error track Whenever the parser fails, only `false` is returned. This makes using it really difficult to work with (an error in the grammar definition (i.e. not a syntax error but a logic one)? an error in the input) and leaves no choice than trial and error. Basically you can never be sure where the problem is and it's really hard to find out except for very simple cases. Are you still planning on improving the library or is it abandoned?
the stars will go to several symfony package :D
You must consider https://github.com/hoaproject/Compiler which is pretty popular and solid. This project is used by Doctrine for instance. It comes from the INRIA research laboratory. Check out the README and the documentation to learn more, but it supports LL(k) ‚Äìwith a grammar description language‚Äì and LL(1).
A similar tool [oraoto/thank-you-stars](https://www.reddit.com/r/PHP/comments/7l8zgx/say_thanks_to_the_php_libraries_you_depend_on/) that I made sometimes ago, which are inspired by the Haskell and JavaScript implementation :) Do a [simple serarch](https://github.com/search?utf8=%E2%9C%93&amp;q=thank-you-stars&amp;type=) on github, you can find many similar tools.
What you're describing is simply a "programmer" error, not a problem with setters. Sure you feel the need to be mother goose who wants to protect those other poor developers from themselves (dumb plebs), but you know what, if you want to drive a car you need to learn how to operate it. Constructor injection is a bitch to test (especially higher level services with many dependencies; have fun passing those null, null, null, null parameters?). Constructor injection is an anti pattern, breaking SOLID and constructor injection is anti composition. 
It's neither the most minimal way of doing this, nor the most correct way of doing this, but it's a way of doing this. You didn't say why you think it's "a bad practice". Your objection is that "it's not DI" but you should know that if you enter into an argument over names and labels, i.e. "it's not true DI", "it's not true REST", "it's not true SOLID", "it's not true DRY" and so on, this is ultimately a highly subjective and highly counter-productive way to argue about architecture. It doesn't matter what you call it, or if it's a "true XYZ", it matter what concrete benefits they see in that approach, and what concrete drawbacks you see in it.
This is a spam, please report it
FYI your link points to this thread instead of your repo (I"m guessing it wasn't the intention).
Awesome creativity to saying thanks, great work 
Oh, I copy the wrong link.
And thats completely fine. Us laravel peeps are perfectly happy using the battle tested http/routing/console etc with a nice laravel wrapper around it. No need to re-invent the wheel for everything.
Thanks for the nice response :) 
That's a good point, but the rabbit hole is really deep... 
I am a PHP developer with nearly 6 years of experience. I have been developing PHP applications using CodeIgniter, Yii 1 and Yii 2. Recently I have been using Yii2 a lot for all kind of applications including building RESTful APIs. But sometimes it feels Yii2 has too many things not needed for a pure REST API app (Maybe I am wrong?). Can someone suggest a good API building framework with Oauth2, Basic auth and JWT features? Also a good frontend JavaScript framework to go with RESTful APIs.
If you have more than 3 or 4 dependencies, you're probably already having your unit doing too much anyway ;) Constructor injection is an anti pattern? Back to school.
This is shitty code! Downvoted
RAM. SSD. Proper configuration according to workload. 
Graphite. With this solution you can build detailed real time profiles in your application and also gather and combine it with other valuable information like status codes if you wish. 
well whatever it is, it's a totally different ratio than the stars, so the stars are still the most useless metric you could use... I've had a github account for a decade and I've never starred a thing
well whatever it is, it's a totally different ratio than the stars, so the stars are still the most useless metric you could use... I've had a github account for a decade and I've never starred a thing
My main issue with Composer is that people overcomplicate PHP. You don't need a package manager for every bit of code in projects. Honestly, I just find it as lazyloading someone else's script.
This content management system is being done by me to a company with problems in their warehouse. I got in contact with them through AIESEC and I went to Romania to do this project during 3 months. I arrived with no knowledge about php and Laravel, just knew the theory of databases. After two months I got enough knowledge to start constructing the application. It's a mix between my desire to learn and their desire to solve a problem. I'm now prototyping the first features and constructing the product idea with the CEO, in the future this will be a product launched in the market, but not by me. I'm a mechanical engineer student in the process of creating an IT career. Before that experience I did study Python for 2 years, but just for myself and for solving Check.io challenges. This will be my first back-end project to my portfolio and my first experience with product management. I hope one day I'll be a great CPO hahaha.
My point was, if it's a CMS they need, why not use an off the shelf CMS? Plenty to choose from. Then, if bespoke business logic is required, built that part in Laravel/framework of choice, and hook it up to the CMS?
To add to what I said earlier: What we are intending to do is replicate the minimum feature sets as available today with SugarCRM but programming it from scratch using a framework/assortment of micro-frameworks, providing a proper ReST API, Web Sockets connectivity, a standards compliant JS client etc.
I don't agree with that. Why should the rules be different for libraries and applications? If you use that for your application, you're likely to miss bugfixes. At least for our packages (which very strictly follow semver), we only release patch versions for the latest `major.minor` release, never for `major.oldminor`. There's no point in doing that if you follow semver.
&gt; Package mangers Christmassy typo? ;-)
I prefer to use the more descriptive syntax of `composer require "php:^7.0,&lt;7.1"
&gt; latest agile technologies uhu
Blog like app. So authorization, basic page creation, blog post with categorization. Was far from anything viable for production but bug solving made me love programming and i decided that's what I want to do in life.
This will bring symfony stars up to exceed laravel. Secret plan hehehe
I hate sites that do this, its one thing that'll just make me go 'fuck this' and close the window. 
This will only get you so far. I‚Äôd say a well optimized site would run better on significantly worse hardware compared to an unoptimized site on next gen hardware. 
This is great, thank you! I probably should not have titled it parser "generator" as strictly any kind of parser/compiler project would likely be helpful and this one certainly seems that way!
I understand, the answer is my learning process with this creation from scratch, as you said. And also because their idea is to create their on CMS and sell it to small warehouses. They will have a product that will fit better with the Romanian market, here the warehouses have many problems and their workers have now idea how to use a computer. So they want to create something new to this market. But you made me curious, how can I find those CMS? I want to take a look at their code and try to add new features as an exercise. 
Take your pick, WordPress, Drupal, Joomla etc. I'm a WordPress and Drupal developer and both are very flexible in terms of adding new functionality. The issue with making your own CMS is that your trying to reinvent the wheel. As for it being a learning exercise, I really don't think that should be done when someone is paying you to make something for them.
I got your point, that's true. The good point is that this is a volunteer project with them. I'll take a look at CMS already done and think about replanning it. It's a good idea because I already know how does a CMS work inside, going ahead as you said might make me grow much more. Thank you for so much help
_(this is just my opinion and I don't plan on responding to anything)_ I love the work zend's putting into PHP, but if this is the _ONLY_ change to mark expressive 3.0 then this is kind of a disappointment. I'd honestly say use Flex and that's coming from someone who's for the past 3 1/2 years used custom micro-frameworks and silex/slim framework w/ composer packages to get work done. Expressive still has that problem where you have to deal with writing tons of factory classes for manually setting up your DI and it's just tedious. Sure there's Zend Service Container or w/e it's called and it simplifies this a bit, but that's literally your only option. They didn't even bother to allow you to use your own container and write code to USE your container to do what the Zend Service Container does for DI. That would've been a better _option_ than to say just use our shit. Now, sure it's probably faster because it's all hand written DI management, but I'm not about to sit here and spend half my time updating those factory classes when I add a new dependency, we've come too far in php where we have tools available to us that makes DI/auto-wiring 10x easier to deal with. Not all disappointment though, I do respect them pushing 7.1 and started the process for updating all their packages to do the same which is the direction we should be heading in 2018. Hopefully with 4/5.0 maybe it'll be the Silex 3.0 we've been waiting for who knows.
Hi folks. I would like to share this library of mine. I've been using, improving and optimizing it for the last year and a half. I think it turns out great. I hope it will be useful for you too. Any suggestions and recommendations are welcome.
I uses stars to add to favorite project to check it later, then I unstar. But I really wish they were private as It make you look like you're were discovering a project. For example if I star today a package like composer I will feel strange as someone could think I recently discovered composer, like If I were a newbie.
[removed]
The author has also compared symfony standard release with laravel 5.5. Laravel works good there.
I believe they are sending stars only to the packages you're requiring, symfony packages are dependencies, these don't get thanks :( 
I agree. Lately, I have to constantly Select All text in the file, Edit &gt; Convert Indents &gt; To Tabs. I've committed code with spaces now instead of my usual indents ARGH
Yes, this will bring Symfony stars up ... and Laravel stars too ... and Drupal ... and Composer ... and that's great. The entire PHP community deserves many more stars. So, let's say "thank you" to all of them.
Currently using: https://github.com/Masterminds/html5-php Can you compare them and tell me why I would switch?
How will Github feel? More unnecessary traffic for them
Have you looked at Kibana with Beats? + https://www.elastic.co/products/kibana + https://www.elastic.co/products/beats Open source links: + https://github.com/elastic/kibana + https://github.com/elastic/beats It can visualize, for example "Slowest MySQL queries" &gt; https://github.com/elastic/beats/blob/master/filebeat/module/mysql/_meta/kibana/5.x/visualization/MySQL-slowest-queries.json And many other things: &gt; https://github.com/elastic/beats/tree/master/filebeat/module Including PHP: &gt; https://github.com/elastic/beats/blob/master/metricbeat/docs/modules/php_fpm.asciidoc
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [elastic/beats/.../**php_fpm.asciidoc** (master ‚Üí 226c3a7)](https://github.com/elastic/beats/blob/226c3a7a8fd2f9735ebc24275653e74d9849462f/metricbeat/docs/modules/php_fpm.asciidoc) * [elastic/beats/.../**module** (master ‚Üí 226c3a7)](https://github.com/elastic/beats/tree/226c3a7a8fd2f9735ebc24275653e74d9849462f/filebeat/module) * [elastic/beats/.../**MySQL-slowest-queries.json** (master ‚Üí 226c3a7)](https://github.com/elastic/beats/blob/226c3a7a8fd2f9735ebc24275653e74d9849462f/filebeat/module/mysql/_meta/kibana/5.x/visualization/MySQL-slowest-queries.json) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drm8hrs.)^.
I still do some work from time to time (usually when I come up with new features). For now error tracking works partially: It doesn't work for grammar definition yet, but it work for parsing strings from built grammar (check testErrorTrack in https://github.com/farafiri/PHP-parsing-tool/blob/master/tests/ParserTest.php)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [farafiri/PHP-parsing-tool/.../**ParserTest.php** (master ‚Üí 1e319b8)](https://github.com/farafiri/PHP-parsing-tool/blob/1e319b8cedc3a5f543f142c156d81fa5a51f483b/tests/ParserTest.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply drm8r8w.)^.
I believe they need to add a favorite button, as I'm using stars to add to favorite projects to check later. I don't star Symfony, or composer, I know these projects, I also follow people on github to see what they star, but now I't seems that feature will be flooded with ordinary projects, at least Symfony developers were staring even a symfony-intl this week. Never saw stars as a way to say thanks, I always saw as a way to show interest in some project, to check later the source code, etc, forks are even better. 
Try clearing the cache/index and restarting, I've run into a glitch a few times where PHPStorm can't access it's index for whatever reason and doesn't know where any of my classes/functions/etc are anymore. 
You're asking for help with a Node.js application in this subreddit. I get that SugarCRM is written in PHP, but this is a bit of a stretch. :) Anyway, I've copied the core functionality of SugarCRM to a different application using Doctrine and other goodies. Took me 3 weeks to complete, including data migration. I also added on top vastly improved search functionality, great reporting generating features, and more. All I'm saying is that the task is not as daunting as it may sound when you have a perfectly good template to work from. Also, I could be interested... :) 
How does that differ from symfony/dom-crawler + symfony/css-selector?
It was a website for the municipality where I'm coming from... in 2002/3. In fact, it was a "rewrite" because the website was already there, but totally static and the first round was exploiting "include" so I don't have to update tens of pages every time something changes in header/footer etc. The next round was integrating an open-source script for publishing news, then adjusting it because it wasn't delivering 100% of what I wanted. There I got stuck, I wasn't really reading tutorials or anything so it was just guessing and hoping something works (and it didn't 99% of the time), so I cut the crap and decided to make the damn thing myself. I found a book online, "PHP-MySQL.pdf", and a couple of weeks later I had a working news system with comments and simple admin area for publishing news and moderating comments, and even banning commenters by IP! :) It was all procedural, mixed PHP/HTML/everything, but hey, I made it and it worked just fine. That kick-started my love for PHP and 12+ years later we're still happily married.
Awesome. But just to clarify, it would all be coded in PHP. But, there would be a realtime notification system added via Node, a background task processing daemon in C++ with tight integration with Redis and RabbitMQ. I am pm'ing you right now.
/backend results in 500 error
Check this talk: https://nomadphp.com/product/profiling-php7-applications/
If I were your colleague and would read in a public place: &gt; We have some really **weird** old custom framework at my work. [‚Ä¶] In my eyes this is **terrible** and not DI at all, but **weirdly** enough, my colleagues think that this is completely normal DI. How can I convince them I don't know how I would feel about working with you.
PHP OP Cache, Memcache if you are using a DB, and last Varnish if its a website that is front facing. Varnish will hands down give you the best benefit because it caches HTML. 
Expressive 3.0 supports using Auryn (via `northwoods/container`) if you prefer the autowiring approach. (Full disclosure, I wrote `northwoods/container` and the Expressive support for it.)
there's already https://php.ug/
We've been working on an opensource project called OpenCensus (http://opencensus.io/) which is meant to be the instrumentation layer you add to your application. It was bootstrapped by Google, but is/will be maintained by the community. The PHP version is here: https://github.com/census-instrumentation/opencensus-php. It has an abstraction for exporters so you can choose a backend service to store your request traces (like Zipkin or Google's Stackdriver Trace). It also has an optional PHP extension to let you trace arbitrary function calls. Full disclosure: I implemented most of the PHP version.
For anyone else wondering! &gt; Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in microservice architectures. It manages both the collection and lookup of this data. Zipkin‚Äôs design is based on the Google Dapper paper.
Nice try-- but, no cigar yet... Tweak, fiddle, repost.
I made this, which some folks might handy: http://composerversioncheatsheet.com/
I believe you can install this globally, and run in each project, rather than having to require it in each project individually.
Doesn't work on mobile. Nothing happens when you click on a pin.
Thanks for picking that up :)
Libraries and applications are different because they are opposite sides of the coin. The issue is not if you follow semver, it's that everyone else is, and not everyone does. An application wants more strict, less changing requirements because you have tested them to be compatible with your application, you have no reason to change them unless you need to (hence, bring in new versions is really only a risk). With a library you want to be the opposite of strict, you always want to test your library against the newest versions of all packages so that it will fail fast against the versions that people are most likely to be using. If a bug arrives with someone using an old version of your package its easier and more constructive to tell them to update to your latest version (with the bug fix) that it is to manage lots of different versions that all have to have bug fixes.
That works too. Although if you never care about the patch version then `7.0.*` will also do the trick.
That's cool! One thing that popped into my head is what happens with "~1"? Does that work the same as "&gt;=1"?
Been looking for something like this
That's nice! I think I might fork it to print exceptions at the end of a failed test case, instead of at the end of the whole suite, and try to integrate it at work
He has just updated that and proved all of what we said right again: the framework overhead in those hello world benchmark is mostly due to the autoloading, i.e. the sheer number of files present in the vendor directory
Phalcon has all of these built into their C extention. https://phalconphp.com/en/
This is what I don‚Äôt get, laravel is built ON TOP OF symfony. So how can we exactly have this debate?
Or desktop. Cant use scroll wheel to zoom either.
Literally unhackable.
That‚Äôs what I noticed it was missing when I was plugging it into Codeception today, otherwise it‚Äôs pretty slick. 
Brilliant! I've always wondered why PHPUnit didn't have nice output cooked into the box. Good work. 
Yeah. Only reason I need it is because our work has had historical issues with tests failing crashing php before they can finish all the tests. But this is definitely going in personal projects
I get a 404
I was already going to reply `~1.2.3` leads to dependency hell. Then I realised article is about applications only and read it again. You raise a valid point.
Awesome! Even though I'm a fan of [whatthejeff/nyancat-phpunit-resultprinter](https://github.com/whatthejeff/nyancat-phpunit-resultprinter) this looks a lot more useful :)
Is it just me or is it way too early to have tightly defined your stack like so, before having gathered the developers you're going to define the application with together? This all sounds like you've been busy developing for quite awhile already and your stack decisions have already cemented. Are you really starting from scratch or do you need extra hands to finish what you already started?
Well, I have been developing CRM solutions for a while. A lot of times, the bespoke CRM's tend to spin off of Sugar or Suite. So, the stack has basically been something that has been an answer to a lot of my previous problems through the years. But, I am open to discussing the choices. And this is going to be a new OSS project.
It looks very interesting. Have you done any benchmarks? I am currently working on my own html parser ([DomQuery](https://github.com/Rct567/DomQuery)), but with a focus on following jquery. I am using xpath internally, but i am not sure if its faster than getElementsByTagName/getElementById. 
What is it with all these "moving" posts when it comes to programming languages? If you're treating languages as just tools to be used at your disposal (as you should be), then forcing yourself to move completely from one tool to another doesn't really make a lot of sense. Different tools (languages) will each have their own benefits and drawbacks at different tasks, so just keep adding them to your toolbox (repertoire). (I didn't bother reading the article, I'm just criticising the way all titles seem to use "move" in them.)
Ah! Okay then. I don't see the need for involving C++. PHP has perfectly good integrations with Redis and RabbitMQ. And background task running can also be achieved with PHP, and not just through cronjobs. The support for WebSockets in PHP is definitely getting to a point where it is super reliable, so there's not really a need for a separate Node application, either. I haven't received a PM yet? :) 
I apologize. I am at the hospital with my father. Give me a few, driving back home atm.
No worries. I'm quite busy during Christmas anyway. I hope your father is alright. All the best.
Don't forget https://github.com/ScriptFUSION/PHPUnit-Immediate-Exception-Printer.
That's a debate post and the title alludes to the other article. What is it with all these "I didn't bother reading the article but dare to criticize it"?
Thank you so much for that. The Composer documentation is lacking there IMO.
&gt; That's a debate post and the title alludes to the other article. I know what the title was alluding to. &gt; What is it with all these "I didn't bother reading the article but dare to criticize it"? Welcome to Reddit! We hope you enjoy your stay :)
That is just bullshit. If you have too little memory you won't "run" at all. A well done setup dosn't need SSD at all, but it helps with badly optimized apps. The point is that you have to evaluate available hardware setups and optimize within bounds. Which can also mean no optimization is possible because hardware is scarce.
Fuck you
[removed]
&gt; Versioning and vendoring: This is probably the thing I missed the most. Using external dependencies in Go means that you have to choose between including all the code used in a library and using the master of the repository. Both approaches seem inconvenient to me but between them I prefer the vendoring one. I don‚Äôt like the massive PRs including vendored files that are all over repositories in github using this approach though. Not really true, but what is true is a lot of smaller libraries don't version their releases for what ever fucking reason. Almost like they think their code won't change or bug fixes won't come. The larger libraries out there seem fine in that retrospect But yeah I don't think the author knows about 3rd party package managers such as `glide` which is pretty damn important working with anything go related https://github.com/Masterminds/glide
Thanks for the info, much appreciated. Yes, I found the readme "okay-ish" but then looked around and realized that there are a lot of, practical!, tests =&gt; very nice of you!
It's actually a well written and balanced article. As I don' use go myself, I can't vouch for it's truthfullness, but it seems honest and pragmatic. It give you a good overview of the (some, prob more exists) pros and cons. Thx /u/jcchavezs
Go is not an alternative to Php, there's really no need to "move". Its like comparing C to JavaScript, or a power drill to a double sided claw hammer.
Most people have a "main language". I mean, you can do most of the same things with Ruby, Python, PHP, Nodejs, etc. Even if you know all of them, you probably have one go-to that you'd normally use. So "moving" simply means changing your go-to.
You should search for "microframeworks" if you look for something more compact. There are probably some frameworks that claim to be super RESTful, but that likely just means that you have to do REST how they think it should be. I suggest to stick to a framework that can adapt to the workflows that work well for you. You shouldn't use JWT unless it is an external requirement. Same for oauth, it can also be an internal requirement. Just pick a framework that has a decent redis backend for session storage and maybe a simple ACL solution if necessary.
I think every framework basically does it. It's not exactly a tool like you want, but if you take any MVC framework, you can do it. I can refer to my experience with Yii2, where all you need to do is generate CRUD, and you get Model for that table, Controller to read the data and View file with a nice bootstrap grid with all the filters etc. 
Thanks for that comment, I should have said that in the original comment - our company has a strict no framework policy. Apparently ran into some issues a few years ago and now require everything to be native code. Thanks for the comment though I appreciate it!
Oh god I'm so sorry.
And as expected the closest one to me hasn't had any activity since 2015.
I think you might bring that up, because it's fairly unreasonable. There is no difference between already made framework, and the one your company programmers will eventually create. Except of course it will probably have much more weird issues
Quit. Quit now. Your job is stifling your career.
I use a modified version of this code. I set my css classes and just pass it an array from MySQL: http://www.aidanlister.com/2004/04/converting-arrays-to-human-readable-tables
Less than 1GB RAM and Composer won‚Äôt even run. But let‚Äôs say a 2GB system has a large table with indexes and a 8GB without. Guess which would be faster? I ‚Äúfixed‚Äù a clients CRM by adding indexes to the tables and got far more performance than just throwing RAM and processors at it. Which they had already done, to little avail.
Now add 6 GB data to your well indexed db and see it fall over.
Nobody says it's an alternative. A programmer could be given such a task / area of responsibility where Go would be a natural choice. So they would move. It is unbelievable that so many people would judge an article by a single word in the title
&gt; The Go community now has the [dep](https://github.com/golang/dep) project to manage dependencies. Please consider trying to migrate from Glide to dep. If there is an issue preventing you from migrating please file an issue with dep so the problem can be corrected. Glide will continue to be supported for some time but is considered to be in a state of support rather than active feature development.
Because many articles are click bait and makes you read stuff that you're actually not interested in. I confess, I also judge articles by the title, and this link was not an exception.
This must be really new, haven't used go in about 6+ months. I'm glad they're finally having official support for package management. I'm just baffled that it didn't come sooner.
I understand what you're saying. But with that line of thought you don't need frameworks, unit tests, a fancy IDE, PDO, GIT, and a tons of stuff either. But we use them because despite the added complexity, they make our jobs easier.
I found out that there isn't a single best way to find the elements you require. Sometimes getElementsByTagName is the fastest, sometimes recursively iterating over childNodes is the fastest. That's why for different selects my library is using different approaches. Performance is top priority for me, and I think https://github.com/ivopetkov/html5-dom-document-php is real beast :)
SugarCrm CE stopped being updated a long time ago. SuiteCrm picked up the slack and seems to be getting in a better spot as of late. SuiteCrm 7.10 beta3 was just released and is including a completely rewritten REST API. You may want to take a look at the project as well as the new functionality and see if any of it helps. I've worked a little bit on putting Symfony/Console in it for some things I needed to do and hoping that it will continue to improve in the future. 
I've tested symfony/dom-crawler long time ago and didn't like the performance. That's why I used the native DomDocument and improved it in https://github.com/ivopetkov/html5-dom-document-php
Yup! I have implemented a few SuiteCRM instances. It is wonderful indeed. I am envisioning something with more enterprise features viz., distributed task queues, realtime chat support et al. 
This web app comes to mind: https://semver.mwl.be Very handy for developers using Composer.
I'm not really sure why they wrote their own parser. I guess because in 2013 the native DOM library has many more bugs than now. My library extends DomDocument, fixes some bugs and adds query selectors supports. So I believe it's more performant and familiar if you already use DomDocument.
Know where I can buy a double sided claw hammer? I want to give one for the holidays.
It's a non-trivial investment of time to move from one language/ecosystem to another, depending on the language and/or framework. Hence, "*moving*" feels like the appropriate verb.
So if I understand this correctly, you're using three containers: one for PHP, one for redis and one for the common volume that both will use. Then you're using UNIX sockets on the /tmp/docker/redis.sock file and using that to cut down the overhead. Is that correct?
Yes, exactly.
This only works if the web server and redis are hosted on the same box, correct? 
This is a great example of why containerization isn't all that great. It adds an insane amount of network overhead (due to all network traffic going through the host process -- which you can get around by using --net=host but again defeating the point) not to mention a single-point of failure. Also by requiring unix sockets, you're restricting the containers to live on the exact same host. Which also significantly defeats the benefits of modular containers. Now you've got a separate container purely to share the UDS file? This is just absurd.
You only need the container executing PHP code and the Redis container on the same host. In the Docker community it's not considered good practice to combine the web server and PHP in the same container. In my case I have them all on the same server for convenience, and I use Nginx and PHP-FPM, to separate out these concerns into separate containers. So if I wanted to, I could have the PHP-FPM and Redis containers on a separate server to Nginx and use `proxy-pass` to point at that IP.
Not leveraging containers gives up a large amount of time and effort. It forces you to ensure every server you use has all the required dependencies. You can never just pick up and move somewhere else. With containerised apps, it takes me no more than 10 minutes to move to a new server if I want to. That's why I'm confident in my decision to take advantage of it.
i assume that connecting nginx and php-fpm via sock file in the same manner would also speed up things? 
If you use any provisioning software such as Ansible, Salt, Puppet, Chef, etc. moving servers is often pretty simple (if you set it up correctly). I happen to be using Ansible and I build an entire new stack on AWS from scratch in about 15 mins by running a single command. No containers involved. 
I've been managing server dependencies and/or images for the past decade using Puppet and more recently Ansible. Before that I did it mostly by hand and it still wasn't that bad. Multi-term connections and run the same apt-get or config changes. Docker Containers has a seriously flawed networking model and people's insistence to deploy them per process (separate container for nginx, and php-fpm, and mysql, and redis, etc) instead of purpose-based is also amusing. Also if you wanted to improve performance anyway, you'd be far better served using shared networking between the two containers. Bridge mode easily loses 20-25% performance. Just put the two containers on the same network and you mitigate almost all of the networking overhead. It's incredulous to me that you're so adamant about saving time on development/operations, which happens relatively infrequently, and to achieve this you give up a massive amount of application performance (which happens all the time) just so you can deploy easier. 
Is disabled right now? Or it doesn't work on my browser
I'm in a 2 person team. We don't have the time for that. Docker is much easier and much less time consuming to set up. It also lets us develop with confidence because our dev and prod environments are the same.
Time for.. what? Configuration management tools like Puppet/Chef/Salt/Ansible? I've worked in a very small team environment (1-3 people) running a multi-million dollar business for a decade. Docker/Containers are pretty new. To imply that you couldn't run your business without Docker is laughable. Containerization brings in a lot of cool new approaches but it also brings a hell of a lot of bad practices, fragile design, and ignorant statements like people thinking it enables something never before possible. I've head the same shit about RubyOnRails, MongoDB, NodeJS and now Docker. New tech is great, sure, but please drop the charade that it significantly changes the playing field.
Currently, hell no, we couldn't. Our business is in on-prem installs of our server software. Scripting those things on a customer's server would be very complicated. The amount of simplicity and ease of installation that we gained by switching to Docker is incredible. We just run a single script now to install docker then pull down our containers (via docker-compose). Infrastructure as code. It means that if we need to add another piece to our puzzle, we don't need to do complicated installations, we just add or swap out a container and everything is fine and dandy. E.g. we started using Redis for caching/sessions, and all we needed to do was push the container to the customer's docker-compose file and it just worked. Polluting the host system with installed software is problematic for handling upgrades if we need to remove things or switch versions. With containers, that's all wrapped up and we can very easily and reliably control what it's running on. I don't understand why you need to be so aggressive about this, some tools work best for some people and not for others. Your tone is really rubbing me the wrong way, OP doesn't deserve the shit you're flinging at him.
OP's article is complete shit due to his misunderstanding of Docker. His article could be rewritten to state the known fact of "Unix Domain Sockets are faster than TCP". The docker aspect is completely irrelevant aside from network=bridge is significantly slower than host or shared but it has nothing to do with UDS vs TCP. Your use case makes a lot of sense and I still don't think your two-person team comment is relevant. It sounds like you have a good setup regardless if you have 1 or 100 people. Deploying a known state into unknown territory is a perfectly awesome use-case for containerization. My tone is because the tech/startup world is this non-stop fucking mess of people reinventing the wheel and presenting like it's a game-changing technology solving never-before-possible problems. Docker has a lot of that in the community. It has some great aspects (as your use case points out) but when people launch EC2 instances just to slap another unnecessary layer of Docker containers inside them, so now we've got multiple layers of virtualization/containerization, it's really over-complicating the entire situation for zero gain.
We started combining Go and PHP in our projects year ago, development is now so much joy. It‚Äôs pretty easy to use them together, you can RPC to go from PHP and pipe from Go to PHP. This is one of the libs we‚Äôve created for that : https://github.com/spiral/goridge
Maybe try ordering an online course from udemy that walks you through it, with someone explaining along the way. Otherwise, find another profession. 
"complete shit" is a bit much. Maybe mildly misinformed re: the right way to use volumes, but you're really not helping anyone with this approach in your criticism. I understand where you're coming from, but it's still a pain in the butt to boot up new cloud instances in general. I find that using Docker in them is a massive help in keeping them reusable if their purpose needs to change. I really don't like having a mess of installed dependencies on the host. For us, Docker _was_ a game-changer. The gains are very apparent - easily disposable installations, easy upgradability, separation of concerns (which is huge for security), easy testing and assurance of reliability, etc. Obviously container tech isn't new, but like the commenters on the [hacker news post from yesterday](https://news.ycombinator.com/item?id=15992664) were saying, Docker became popular because of its ease of use and tooling, and the incredibly fast adoption rate which means almost anything can be _easily_ run in docker.
It's not that I want PHP as a profession, but I own a a few sites which I think served their purpose and now need a bit more attention than just CSS. 
Docker itself is primarily popular because of a concentrated VC effort to embody it within the community. This is the exact same strategy MongoDB applied starting in ~2009 and Joyent/Node applied in ~2011. Every hot startup was using MongoDB (even though superior alternatives like Riak and Rethink and Cassanda existed) because of a concentrated guerrilla marketing effort. Mongo went on to raise a shitton of money, imbue themselves into nearly every startup from '08 - '14, and now those same companies are paying MongoDB Inc heavy consulting/service agreements to keep their shitty system afloat. NodeJS/Joyent was experiencing the same sort of VC focus prior to being acquired. Docker Inc is following the exact same path. It's only partially due to a good product. LXD and RKT are both arguably better than Docker but they are almost completely shunned because they aren't part of the hype-machine. Remember this little discussion a few years from now when Docker Inc goes public and suddenly the massive public backing of it suddenly falters. A lot of opinions, especially on HN, are formed only partially on the sort of things you cite (actually good tech) but heavily based on popular opinion and forced trends managed by careful upvote/downvote of opinions that support the VC's best interests. HN is not a open discussion community to be clear, it's there to serve the best interests of YC and the VC community.
 &lt;?php print "Hello world"; I win! *waits for someone to post one without the white space*
Check out perl
Perl is really nice for report formatting and system scripting. I'd never use its OO feaures though, or for building an application.
Honest question, wouldn't it be easier to just create rest api's that spit out json in either language if you really wanted to communicate from go to php and vice versa? Can you give me a use case where using goridge would be more appropriate than what I mentioned?
I've been interested in playing with Go, but probably won't in the foreseeable future given other priorities/interests. From TFA: &gt; map/list with types: This is something I really missed &gt; in PHP - there is no way to declare a map[string]. Aren't Go maps just hash tables? Why can't you declare a dynamic object property in PHP (they're just hashes too)? public function foobar($key, $value) { $this-&gt;$key = $value; } &gt; Go compiler forces you to drop unused functions, variables and imports You can use a linter with PHP to achieve the same effect. Personally, it's a little strict for me in development. I set a strict linter rule in my CI configuration and allow unused tokens in my local dev environment.
Just another way for Taylor to stroke his dick and get attention. Dude can‚Äôt let shit go. 
Accept this has nothing to do with him. This has to do with Fabien and his article is faster then laravel even though laravel is built on it.
If you are getting that from a query, you can do this: fetch the result of any query into an array using fetchall $arr= $stmt-&gt;fetchall(\PDO::FETCH_ASSOC); Then run it through this function to display as a table public function query_dump_table($arr){ // fetchall array echo "&lt;table&gt;"; $col_heads = array_keys($arr[0]); echo "&lt;tr&gt;"; foreach($col_heads AS $hkey =&gt; $hvalue){ echo "&lt;td&gt;$hvalue&lt;/td&gt;\n"; } echo "&lt;/tr&gt;"; foreach($arr as $row){ echo "&lt;tr&gt;\n"; foreach($row as $key =&gt; $value){ $value = htmlentities($value); echo "&lt;td&gt;$value&lt;/td&gt;"; } echo "&lt;/tr&gt;"; } echo "&lt;/table&gt;"; } 
Laravel isn't built in top of Symfony. It uses a lot of Symfony components, but extends them and strings them together in its own way, along with other libraries. Of course they can and should be benchmarked separately. After all, these benchmarks are pointless when they don't measure the real-world performance of the entire system.
It‚Äôs not super accurate to say it‚Äôs built on top of Symfony. We use HttpFoundation and a small part of Routing for most requests. Most of our other Symfony usage during an HTTP request is very minor. Laravel is slower out of the box because it had more features enabled out of the box that in my opinion most applications will end up enabling. Things such as sessions, encrypted cookies, configuration is not cached so DotEnv is running on each request and all files are being included, etc. These things add up to make Laravel ‚Äúslower‚Äù out of the box. As I noted in my blog post, if you disable them all the comparison is more fair and the speeds are much closer. That being said, PHP developers really need to focus more on building businesses that actually have a scaling problem. Almost everyone that argues about this does not even have a problem in real life. 
You‚Äôre missing half the conversation. 
Seems like a good upgrade to docker would be to reroute network traffic that is bound for a local container. Hmm, doesn't VMware esxi do this already...
I cant seem to find most of the conversation, which is apart of the problem of my misunderstanding. There just seems to be this pissing match when it doesn't make sense when one is built on top of the other.
So why isn't laravel, by default, disable all of these things? If the average programmer, like my self, doesn't use half of them, why make us disable them? I get that there are things we can't disable or the framework falls apart - but it seems like your saying: Theres x,y and z that are enabled by default you'll never use" - Am I wrong?
So then ... why the pissing match? weather it's built on or with components - doesn't make sense.
Most people don't need encrypted cookies, or DotEnv files. The only one I agree in that list is sessions, and a session only needs to be started when it's actually used (a value is read or written), not by default. So from the list you're giving, if the features are implemented competently, they can't explain Laravel's slower performance.
Honestly, there isn't a pissing match. Only one person really cares about these discussions and you'll know by the person that responds to most of this _user created drama_ threads lol. At the end of the day, all of us php developers should be trying to create the best software and open source packages for our community. Everything else is irrelevant. 
&gt; Our business is in on-prem installs So you're basically a distributor? Then yes, it totally makes sense for you to deploy containers. [edit: word order]
Develop + deploy + support, so not purely distribution. It's the full package. But yeah.
&gt; So why isn't laravel, by default, disable all of these things Taylor already answered that. &gt;most applications will end up enabling [these features.] ----- because Laravel caters to its most common use cases. Typically one doesn't install Laravel in order to run micro benchmarks, so it doesn't make sense to optimize for that. 
HTML and CSS isn't programming, sounds like your not a programmer. No worries just try something else; maybe your good at design? 
Then hire a developer and don‚Äôt worry your head about it? My instructor in college once told me that sometimes its better to work smarter, not harder.
I need to write tests first
Because Laravel is supposed to be more "batteries included", get straight to writing code with as little friction as possible as opposed to premature optimization and the necessary configuration and research that goes with it. There are definitely faster frameworks, but Laravel is more concerned with reducing friction to getting product out the door than code execution speed (or I guess a better way of putting it is developer speed and developer experience over code execution speed). 
I'd just like to point out that this "debate in our community" is just a vocal minority. Plenty of us out here who don't find the squabbling particularly relevant or interesting.
Well this is apart of why I am confused. What exactly is the ‚Äúfight‚Äù over? 
I assume then laravel takes the rails approach then, convention over configuration? 
Basically
I agree with this and I didn‚Äôt intend to cause drama, I was legit confused over these conversations when, as stated, one is built on or using pieces of the other.
Give an example of what you want to do
Is PHP a good first programming language to learn? 
It‚Äôs basically this: http://extrafabulouscomics.com/comic/200/ 
So, why not put PHP and Redis in the same container?
Does anybody know why the hell they implemented the encryption support for zip, documented that this needs libzip &gt;=1.2 and then still shipped with prehistoric 1.1.2?
Understandable, also I was more talking about past threads over the past few years which were a bit more heated.
I also tested it a while ago and i think it was (is?) because the DOMXPath instance and 'css to xpath' results are not cached with the symfony dom crawler. For most usage its not really a issue, but with big parsing jobs it really add up.
Disable what you don‚Äôt need, easy as that. Laravel can‚Äôt cater to everyone‚Äôs needs. 
Did you even read what said?
But if you know how 'technical' majority of developers are with operations, you also know that the first technology that will enable you one command deploy will win. By no means is docker perfect, but it deploys anywhere (even windows) and you have public repos. Hype machine is created when product is usable by masses with 0 prior experience. Even mongo was peeling off the SQL language as a requirement (which not that many people actually know that well from my experience). Now you are in a position when you can have an entire project - front, back, dbase - written in Javascript, you will see plenty of new people coming in and doing their own thing because they suddenly can do stuff that was beyond their capabilities. And so hype pulled new masses, which needed to know only one thing. And you want them to be critical with products they know nothing about and do not care?
I thought the debate was still about whether to use a framework or build your own? Or whether it's ok to use WordPress (even though it sucks, which is generally agreed upon by both sides)?
yes, I am a designer too and PHP (well all programming) is unnatural to how my brain works, which is to see things, so once it gets to any kind of abstraction I get lost, like joins and classes and other things that programmers seem to say are not difficult
That would violate the principle of one process per container
I've always wondered this: why do programmers have comments that seem to be implicit in the code anyway? Like // Start the table $table = "&lt;table&gt;\n"; Is this considered good practice or something? (sorry I am self taught and find this annoying)
Having `thanks` option be true by default, so only `--no-thanks` to be implemented.
The author deserves kudos for his courage and insights. If you really struggle with it like you do, then I will stand behind other comments on this post and say: is what you're trying to achieve worth learning and understanding programming or is it a better idea to hire someone or find a partner and stay happy about your current expertise? You're probably great at what you do, so don't mess it up by shifting focus to something that will probably suck up lots of time and money and may result in mismatched expectations between you and your clients, in terms of time, cost and delivered results. You may still want to try and dabble with programming, but I'd suggest doing that exclusively on a personal project or site until you're confident it won't badly affect your professional life. I hope you can give us more pointers to what you are trying to achieve so we can better formulate an answer to your problem :)
Or just use Nginx.
Do you run this in production? 
Learning programming is a huge time investment with a good risk of getting addicted to it. If programming concepts simply feel alien too you, you have to keep learning and experimenting with the basic things until you grasp it. If you don't have time or interest in another addiction then delegate the work.
&gt; That being said, PHP developers really need to focus more on building businesses that actually have a scaling problem. Almost everyone that argues about this does not even have a problem in real life. Maybe you want to fix that paragraph. Unless it was your plan to make it easy to introduce scaling problems.
Opcache, object caching if your code supports it, then sprinkle some static asset and FastCGI caching on Nginx level.
This. In other words, separation of concerns
The post is very misleading. It is really Apache centric and at some point it uses PHP to process URL redirects. The title of the post would suggest something like .htaccess management through PHP, but this really isn't the case.
&gt; &gt; map/list with types: This is something I really missed in PHP - there is no way to declare a map[string]. &gt; Aren't Go maps just hash tables? Why can't you declare a dynamic object property in PHP (they're just hashes too)? I think his point was that you cant specify/enforce the types in PHP
Rigid unchanging principles, or eating a huge performance penalty in your IO.... 
Agreed. Topic is down right incorrect.
Think you read that the wrong way round - Laravel includes common things you would want, turned on by default. Symfony doesn‚Äôt, so obvious benches quicker, but it‚Äôs not really an interesting comparison. Bit like saying that just the engine of a car would hypothetically do 100 mpg, but when you build a car using it it only does 50 mpg. That‚Äôs because the car has features you probably want (air con, heated seats, somewhere to put passengers etc). You can remove those things, but if you don‚Äôt need them, maybe you should have just bought an engine (Symfony) and built your own car from scratch.
Yes, you're basically saying "I dont need this, so the framework guys should change stuff around for me". The other guy is telling you to change those things yourself. If you don't need all those features, and you don't want to configure it, try looking for a framework that suits your needs better.
&gt; session No he said the need to be started when you actually use them, this is especially the case for sessions it'≈õ bad design not to do this.
We are not using such bridge for generic API communication, but on infrastructure level as an application server (Golang alternative to PHP-PM), as result we can drive boot-loaded PHP scrips in queue or as http worker for REST API with minimal latency and very high bandwidth. I have some early prototype benchmarks: PHP-PM: https://prnt.sc/hcyju4 Go-PHP (PSR-7 + unix sock): https://prnt.sc/hcyk9j Go-PHP (PSR-7 + pipes + keep alive): http://prntscr.com/hrp4k8
Not sure why this is being downvoted, this is true. 
Or having one process crash and a dead undetected container running. Yes, one process per container all the way.
&gt; Also by requiring unix sockets, you're restricting the containers to live on the exact same host. Which also significantly defeats the benefits of modular containers. I'm with you on this and it was my first though on the article. It's a decent solution for a 1-server deploy with `docker-compose` or something like that, however. And a good peek into some cool shit that docker *can* do. 
not sure what you mean. MVC stands for Model View Controller. It is a design pattern, independent of programming language. It is not specifically concerned with desktop GUI like GTK and is the most popular pattern for separation of concerns in a PHP application. This article explains it nicely: https://symfony.com/doc/current/introduction/from_flat_php_to_symfony2.html
The logic is usually trivial. Focus on the concepts. Examples could be provided that people wouldn't take you seriously if you said you didn't understand them. The most important thing is to recognize that the technology is mostly irrelevant! Don't use it as an excuse for not understanding something and let that become a barrier. If you can explain to a person how to do a task explaining it to a computer is just syntax. Often things that people think they don't understand are just a collection of things they *do* understand. The said the best way to learn is by doing it. The Worst way to learn is by trying to do it perfectly! If you listen to people on the internet many will place *huge* obstacles in your way and you will never learn anything. You start at hello world for a reason.
I know exactly what it means, but PHP simply doesn't work like that on webservers due to request &gt; response. Imo http framework is a better description but ADR is the design pattern that fits better imo.
No, their intention was to say that "having a business that is so successful as to have scaling problems is a good thing, and instead of dissecting micro-benchmarks, we should be working toward ridiculously successful business." As a smart guy said, "Premature optimization is the root of all evil in programming." Make successful business, then optimize.
You mentioned your goal for learning is to be able to make changes to sites you already have, what's their deal? Are they WordPress? Something someone built for you in PHP? Or just plain HTML sites you want to start spicing up? If either of the former two, it might be the existing structure making things hard to grasp, not PHP itself. I'd recommend starting from the ground up somewhere you can isolate concepts to learn one at a time. Grab a highly rated book from Amazon on getting started with PHP where you can read the first few pages and see how approachable it feels to you Don't listen to the haters telling you to just hire someone, it sounds like you're already thoroughly drawn to it. I bounced off the surface in my first couple attempts to learn too, until I found the right context and walkthrough for me
Why don't you use named volume instead of data-container?
You can use those too. They're perfect for when you want to share volumes like in this case.
Yes.
Merging two concerns into the same container is not considered a good practice in the Docker community. Separate each process into a separate container.
Yes, it would.
what is?
Thats a lot of implications and wrongdoings in there. Scaling a business is completely different thing from scaling software. Most sucessfull businesses will have only minor software scaling challenges, just because not everyone is google. Reducing baseline framework latency will help to scale out, but a 50ms difference won't matter for the majority (if we consider only front ends performance). What matters is user perceived perfomance. If a solution is 50% slower and gets worse with each added feature it will ruin your and your users days. That being said, neither symfony nor laravel are impressive at performance. 
I don't take it too seriously, at the end of the day I'm sharing my results and trying to helping people. https://www.youtube.com/watch?v=Owasda2eak4 üòÇ
From the PR: &gt; This adds support for the `scalar` pseudo-type with parameter type covariance and return type contravariance to PHP. Please refer to the included tests to see what that means for you as a PHP developer.
sorry, I don't have a clue about what that means, but I found this in stack overflow is related? https://stackoverflow.com/questions/11493902/parameter-type-covariance-in-specializations
It means you can type-hint scalar values as parameters or returns
It means that you can narrow down or broaden your type constraints to something that is compatible, depending on whether you are constraining a parameter or return type: * [return type covariance](https://github.com/Fleshgrinder/php-src/blob/ee94d783d17943b5528b4d41e9ba9a65f6de25ba/Zend/tests/type_declarations/scalar/scalar_basic_007.phpt) * [parameter type contravariance](https://github.com/Fleshgrinder/php-src/blob/ee94d783d17943b5528b4d41e9ba9a65f6de25ba/Zend/tests/type_declarations/scalar/scalar_basic_008.phpt)
Exist some book where I could learn this things? I feet like if I the OOP and programming that I saw in university was very basic. I worked only with PHP, python, javascript perhaps, this is more natural in Java and C# or perhaps specialized php projects?
Imo the issue is about preference and field of work. Someone throwing out small sites for small businesses will require a slightly different workflow than someone working on one huge project that spans over multiple continents and servers. Working alone vs. Working in a small team vs. working in a large team. But people like what they use. Try to read over the personal preferences and pick out the arguments that are actually worth something. Both are successful for reasons. Not entirely the same reasons though. 
Hack also has support for it, so do all other mature OO languages (C#, Java, Kotlin, Ceylon, Rust, ‚Ä¶). I think that the Wikipedia article on this matter is a good starting point: https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
**Covariance and contravariance (computer science)** Many programming language type systems support subtyping. For instance, if the type Cat is a subtype of Animal, then an expression of type Cat can be used wherever an expression of type Animal is used. Variance refers to how subtyping between more complex types relates to subtyping between their components. For example, how should a list of Cats relate to a list of Animals? *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
If you keep up with the discussions in the PHP RFCs, you can learn about these features and their merits, as well as the idea behind them. As these features ate yet to be implemented or will be rejected, you probably won't find too much sensible literature outside of their specification and discussions surrounding them.
Here is the corresponding RFC: https://wiki.php.net/rfc/scalar-pseudo-type
I think ~1 would essentially mean ‚Äúlatest version‚Äù, since that would let the ‚Äú1‚Äù increase. 
So you have three containers for two tightly communicating processes instead of one container. When a "good practice" results in questionable results in terms of performance and maintenance, maybe it's time to refine how you apply the practice. Say, if you're honest with yourself, you'd put those two in one container, and measure performance *again*, so you can see if you're not throwing away vasts amounts of performance chasing after a "good practice" that doesn't give you absolutely anything in this case.
&gt; Yes, you're basically saying "I dont need this, so the framework guys should change stuff around for me". That's some serious lack of reading comprehension.
Finally.
I know but there is lot of features that are not yet implemented in ODM and lot of things nood some rewrite with ORM. I post these problems on forum and github and they admitted it need a bit of rework, that's why I'm searching others framework 
I think what you're lacking is actually basic programming concepts. I'd suggest you to try to learn C first. Give 2 months time to C, 3-4 hours per day if possible. Practice a lot. Start with basic challenges and move to harder challenges. Revise all the concepts again and again in depth. DON'T leave a single doubt about the language in mind, no matter how trivial it is. Learning a language needs full dedication and clarity of all the concepts. If you can't spare this much time, I'd suggest you to hire people to do your task.
Why‚Ä¶ is this useful? Where do you need *specifically* a scalar type? I don't think this makes a good case for itself.
Great for learning! I wouldn‚Äôt use it in prod though. I came to this crossroads when I was learning and made the realization that an secure, safe login system is not only difficult, but creating one yourself requires a great level of trust in your ability. I would recommend using a framework or a library for this functionality as either of those options often have multiple developers working towards the single goal of making that the best authentication system possible whereas if you develop it yourself there isn‚Äôt a lot of code review and it‚Äôs possible to make a slip up. Perhaps take a look at Laravel as a framework for the authentication portion? I like Laravel and found it a great place to start learning and I continue to use it even though years of experience programming.
Thanks!
It is rather bad. It tries to do too much things without explaining things in depth. Some infos are wrong. I.e. section 5 tells you to sanitize PHP_SELF. Sanitization is usually a bad decision and you simply don't need PHP_SELF. 
A few example out of an endless amount of possible procedures you could construct now to show the usefulness of this. function sprintf(string $format, scalar ...$params): string {} class Database { function fetch(string $query, ?scalar ...$params): ResultSet {} } function strpos(string $haystack, scalar $needle, int $offset = 0): ?int {}
It would be useless if php allowed method overriding the way java does it (different parameters equals different method), but as PHP doesn't support that, you'll sometimes need to use flexible arguments.
No problem! As an open source framework source diving their implementation of the login system greatly helped me learning what‚Äôs used in typical prod environments and was more beneficial than similar articles to the one you linked above! Good luck OP!
I mean you're almost saying why not with every app you throw your DB, caching, etc into one container/server. That's definitely not good practice and definitely doesn't scale. This docker way makes it easier when you have to connect to a Redis cluster or multiple master/slave databases. Heck, it makes it easier when you only have one of those instances.
This makes for a pretty easy `is_scalar` implementation using try/catch. :\&gt;)
&gt; Imo the issue is about preference and field of work. I agree. We don't use PHP as much anymore, but when we did, when people came in for interviews, what people used Laravel for was drastically different than what they used Symfony for (or Symfony components). Most of the interviewees with a Laravel background were from places that pumped out site after site for clients that would never be touched again. The Symfony guys usually created microservices or interacted with databases with hundreds of tables and relationships or it was an internal system that needed to be maintained for years. Imo, if you really care about performance, don't use PHP. With something like Go, we changed one of our time critical client facing API's and noticed a 5x performance in both requests a second and response time. But if you only know PHP, it's easy enough to add more servers to go with your scale.
&gt; Go is not an alternative to Php I mean doesn't that depend what you do with PHP? We moved a lot of our systems from PHP to Go, it's definitely an alternative. Yeah it's not great yet for pumping out websites (which isn't what we do), but we've converted API's, queueing systems and ETL pipelines to Go and have seen huge performance boosts in latency, scalability and response time.
The laravel makes this extremely simple and easy 
Yes I just red some documentation It is looking awesome! Now I'm searching for a nice tutorial to create a login system.
Oh ffs, no. This and falsables and the rest of these half measures are just "we want union types but we can't be arsed to do it right." Fuck this. Let's do union types and stop dicking around.
To be frank, this article describes a very short-sighted usage of linux containers, and the author should have at least mentioned the heavy downsides of this approach. The whole point of containers is to make workflows and processes more readily respond to business requirements, by building distributed system so that multiple components have a high degree of isolation and decoupling. Leaving aside the fact that the proposed implementation uses outdated practices (like using a busybox container to hold a volume; very quirky and un-elegant), the end result is that your PHP process is tightly coupled to Redis: you can't use service discovery, you can't perform rolling updates, you can't handle both processes lifecycle independently, you have to be sure they have UDS IPC available, you can't clusterize Redis, you can't scale it horizontally, you don't have fault tolerance, you have a single point of failure. If your one Redis instance goes down, everything goes down. These are all things where containers shine: replication, horizontal scaling, continuous deployments, fault tolerance... and you're giving all of this away for 14% on a synthetic benchmark. So why are you using containers? Ultimately it's all about trade-offs: Github uses single Kubernetes pods where NGINX and Unicorn containers are coupled together and they share IPC, memory and IP address, as if they were just running on a physical host. This is a very similar use case to PHP-FPM/NGINX, and there is a reason for that: you can treat each group of reverse-proxy+backend as a single ephemeral process, which you can easily manage because it's basically stateless. I don't see the upside of this sort coupling with a storage service, though, because these are stateful and usually need to be shared across consuming instances, so it doesn't make much sense architecturally. After all, there is a reason why network is so common as IPC, and that in turn is a big reason why non-blocking I/O and concurrency are a thing. Even if OPs point was "TCP/IP is not a silver bullet", the answer would be "neither are UDS".
I don't think any of your examples should have a scalar type hint. sprintf and strpos should also take anything that has a __toString method. Though ideally it would be a Stringable interface. Database methods like fetch() should also be able to accept objects when appropriate, like for DateTimeInterface.
There is no `Stringable` interface in PHP, however, I would add that and extend `scalar` to support that as part of the `string` type it contains. Note that I will extend `scalar` to accept objects with a magic `__toString` method in weak mode so that everything is consistent. Accepting of a `DateTimeInterface` makes sense but is not what this features will or can provide. This requires true union types and would be written as `scalar|DateTimeInterface` afterwards. Of course, you could also always write `bool|float|int|string|Stringable|DateTimeInterface`.
I think there is enough boilerplate that we have to write in PHP as it is.
I believe that this shorthand is useful in many situations, even with union types being available.
Using Laravel? [It's right there in the documentation](https://laravel.com/docs/5.5/authentication) `php artisan make:auth`
Oh, almost forgot, I plan to create another PR with the following interface: interface Convertible { function into(): scalar; } Objects that implement that interface are considered to be `scalar` and automatically converted to their equivalent `scalar` value upon passing them to a procedure that requires `scalar`. Hence, all your problems could be solved then. final class Date implements Convertible { function into(): string { return "{$this-&gt;year}-{$this-&gt;month}-{$this-&gt;day}"; } }
its perfectly ok to build your own for fun, its not ok to build it for production (this was my understanding of that debate) and wordpress is a whole other blackwhole of despair in this community, one I'm on the fence of good and evil.
Suppose you have a generic ORM load method that can take a `string` or `int` (corresponding to the primary key type). Because PHP doesn‚Äôt support union types, there‚Äôs no way of typing that requirement. `scalar` typehints are more specific than no type hint at all in this instance.
I would call those PHP and MySQL version requirements alone already a breaker for your security, unless you paid real big bucks to Red Hat for PHP versions modded with security patches. To be really frank and without consideration for the author, this "tutorial" should be assessed as misinformation and deleted wholly. It will only serve to misinform its target audience and is no help to developers that are able to spot the errors in information.
Can you keep the vitriol a bit down? This is a very useful type annotation because it doesn‚Äôt coerce like int/string etc. Scalar is a legit type. Types can inherit one another, remember? This is the super type for the concrete scalars. There is nothing half measured about it. 
No I‚Äôm not saying that. I‚Äôm asking specifically about Redis and PHP when Redis is used as a cache. There is a nuance and balance in these decisions. To have such binary view of containerisation like you do - either everything is separated or nothing is, just shows silver bullet mentality and lack of experience. Case in point what is tha basis for saying ‚Äúit won‚Äôt scale‚Äù if you put them together? What won‚Äôt scale, how will it not scale? Do you honestly thing Unix pipes would scale better over Ethernet than sockets when the time comes to involve multiple servers? And if you won‚Äôt involve multiple servers how are the separate containers helping you ‚Äúscale‚Äù? If you dig a bit deeper into your convictions you may find there is nothing underneath. 
I wouldn't recommend it, although it's not nearly as bad as it was 5 - 10 years ago. If you do decide to start with PHP, be sure to thoroughly read [PHP: The Right Way](http://www.phptherightway.com/). It's one of the best resources out there and will limit the number of bad habits you might pick up otherwise.
Good to start getting an understanding of what is taken into consideration for a secure login system. This tutorial is many years old. If you are at the tutorial level, don't design one for a professional website. Unless you are building projects for fun or to practice I recommend going with PHP 7.1 and a modern, well supported, updated framework. This will provide everything you need in terms of secure login and will make your life easier on so many levels.
Wow, what a cool idea! I just installed this on all my production servers. I may have forgotten to look at the code before deploying...
Or just implement union types?
Unless you actually accept null, boolean, integer, float and string, `scalar` seems inappropriately broad and misleading (implies those types behave the same). Just omit the type declaration.
One accepts ALL (countably infinite) types with `mixed` whereas `scalar` limits it to exactly 4. Seems not inappropriately broad to me. Especially if we consider that these 4 types have things in common: - All can be coerced to `string` without problems. - All can be printed without problems. - All can be sent to other systems without problems (e.g. databases). The introduction of `scalar` also allows us in the future to provide other things that will bridge the gap between primitives and objects.
You should not call it a dependency then ;)
That was by all measures a polite way of rejecting the idea... I highly recommend reading some of Linus Torvald's put-downs when he thinks something is a terrible idea or someone is being lazy. Legend has it that when you request to merge into master on the linux kernel, you are first offered the chance to sign up for medical insurance to have your testicles surgically reattached should he verbally castrate you.
I pity for looking up to Linus Torvalds because he's the king of arrogant brash replies. His opinions are wrong as often as they're right, and they even contradict each other at times. Linus Torvalds did a lot for the software industry, but this doesn't mean we should take his sociopathic way of handling communication as a norm to measure by, let alone a recommendation. Don't put vulgarity on a pedestal. It's OK to require some basic decency and well constructed argument, logically and factually, when you critique something. We have here a person who is respected for contributing to PHP, repeatedly insult the work and integrity of another person who has *just* contributed to PHP. How do you even hold these two thoughts together in your head? How do they not clash and reject each other? Figure out what you stand for.
Perhaps your wording might be softened, but I wholeheartedly agree with the sentiment. The only thing remotely connected to this that I might find useful is a "number" type hint, which would accept both int and float. But if a use case accepts int, float, string, and bool, then I believe the value is scalar by accident, because these types have functionally nothing to do with each other. What we need is union types and generics, not this half-assed measure...
Null isn't scalar. And yes I do often accept boolean, integer, float, and string, and I want a compact way to reject: - array - object - resource - null And now we have it.
There is no cognitive dissonance in my beliefs. Sara's role is to not only contribute her own high quality code and feature enhancements to the codebase, but to prevent what she perceives as bad ideas and low quality code from being added to it by others. That's why she has a vote on the RFCs. Also, in the software engineering industry, Linus' "sociopathic and destructive way of handling communication" IS the norm for people acting as gatekeepers to large mission-critical codebases.
&gt; Sara's role is to not only contribute her own high quality code and feature enhancements to the codebase, but to prevent what she perceives as bad ideas and low quality code from being added to it by others. That's why she has a vote on the RFCs. You think the way to prevent "bad ideas and low quality code" is to shower it with primitive vulgarity on a public forum? Where is the well-supported position that this is a "bad idea". Where are the specific claims that demonstrate this is a "low quality code"? Or would you automatically decide anything Sara curses at is proven bad? As I said, I pity you. Sara has one vote. Her vote also often goes contrary to the majority opinion, including for many very popular changes made in recent releases. Her vote isn't a free pass card to act as a moron towards other contributors. The fact you, and apparently others support such behavior is pathetic.
If you're offended by "ffs" then you may wish to consider that your sensibilities don't reflect what is considered reasonable language in modern culture.... or that of the last 15 to 20 years to be frank. But, I shall translate it from British into quaint southern for you. "Oh my golly gosh, this simply isn't the right way to go about it. I do declare we should not introduce code that handles individual use-cases at the cost of long-term maintainability, rather than building a proper unified solution that will handle all use cases... I say, it would be most splendid if we could summon a commitment to creating such a unified solution" *wafts self with fan* In fact, it is YOU whom has used the most personal statements, you have repeatedly stated we are deserving of pitty, that Sara is acting like a moron, that I am pathetic. So fire up your php-cli and feed yourself into the reflection class =)
&gt; If you're offended by "ffs" Why are you doing this? It's the least offensive thing she said, and I was careful to quote everything that "offended me". If you can't have the intellectual honesty to even represent what was said accurately, I think I'm quite done here. And since you respect this kind of expression, apparently, let me speak your language: keep sucking Linus' dick.
I can't say I particularly want to suck Tolvards' dick anytime soon... I have however had my mouth around many a unwrapped penguin in my time. https://images-na.ssl-images-amazon.com/images/I/41QjT7GYaXL.jpg
https://wiki.php.net/rfc/union_types It was **declined**. I am not sure if I have the time and strength to fight that fight again, especially if we consider that the old RFC came from Levi, a respected contributor of PHP internals.
https://wiki.php.net/rfc/union_types It was **declined**. I am not sure if I have the time and strength to fight that fight again, especially if we consider that the old RFC came from Levi, a respected contributor of PHP internals. `callable`, `iterable`, `object`, and `void` were all accepted with little drama. I have use cases for `scalar` and hope that this RFC goes without much drama as well as helps to prevent [`mixed`](https://wiki.php.net/rfc/mixed-typehint).
`numeric` and `number` would both be very useful.
Make your own.
&gt; Null isn't scalar. In what way isn't it?
In the way it represents not a value, but **a lack of value**. Null is "a lack of an array" as much as it is "a lack of a scalar", or "a lack of an object". It is its own type, which is also supported by PHP's existing APIs: var_dump(is_null(null)); // true var_dump(is_scalar(null)); // false var_dump(is_array(null)); // false var_dump(is_object(null)); // false The RFC for this feature also doesn't include null as a scalar. So the real question is where did *you* get this notion that null is a scalar?
I think trying again and lumping in intersection types might do it. It failed 11- 18 which indicates there is some support for the feature, just wasn't enough.
Is there ever a point to these top 5 lists? Learn to write something that isn‚Äôt blogspam. And please, as a Christmas gift to the world, stop the damn scroll jacking!
&lt;?="Hello world"?&gt;
I found it to be just fine as a place to start. Certainly more secure than my first login form. I does much of what our login system at work does. We added in google captcha as well if an IP fails authentication 5 times, after 20 we lock the account.
The first time I tried learning programming I failed. I took 2 college classes. I passed both those classes, but didn't feel as though I learned anything. I think the teacher wasn't good though. The second time I tried was because I had an idea for a business and no money to pay a developer. So I grabbed a book from the local library and went through all the examples for about a month. I'd modify the examples, just like you would with HTML/CSS. Once I felt I was comfortable enough with the concepts I started building the website. It didn't take off, but my career did. I went back to school again after being a self-taught developer. I failed again passing the classes but not learning much...or maybe Java is a boring and complex language to teach at a 1010 level? The way they teach computer science just didn't work for me. So if you want to learn and you're motivated try some different tactics. If you can enjoy what you're learning, that should work.
Yeah I can't tell you how confusing a loop was to me. I am not sure how a loop could be confusing today, but 12 years ago I was confused.
Is there badblood or zealotry between Symphony and Laravel? 
Whats the best Christmas gift for a PHP developer?
Although it is expensive, a subscription to Phpstorm would be nice.
&gt; I‚Äôm asking specifically about Redis and PHP when Redis is used as a cache. And so was I. We have 16 r4.2xlarge's with clustered Redis that we use as cache. There's no reason why each individual server or container should have it's own cache. How do you even share them across other servers? You can't, unless you are doing something hacky. But at that point, you have the same network latency you were complaining about. &gt; To have such binary view of containerisation like you do It's not a binary view. I've always separated concerns. There's absolutely no reason to have your cache on the same exact box as your app. Unless you're only getting a few requests a second, how are you scaling this system? Are you just going to keep growing the instance size until it's one gigantic box? Then what? You better hope that PHP or Nginx or the cache don't fail, otherwise your whole system is down. &gt; lack of experience Please tell me more about my lack of experience scaling ETL pipelines processing terabytes of data a day and API's handling 10K+ requests a second. &gt; Case in point what is tha basis for saying ‚Äúit won‚Äôt scale‚Äù if you put them together? What won‚Äôt scale, how will it not scale? Honestly how does having Redis on one server with your web app scale? What do you do when your cache grows larger than the amount of ram? What do you do when you have more than 100 requests a second and your server is being pushed to the max? In what world does not having redundancy make sense? Where does it make sense to have an individual cache per server? What's the point of caching a database result if the next request for it lands on a different server and has no cache? &gt; how are the separate containers helping you ‚Äúscale‚Äù? Because I'm using resources efficiently. I no longer have to have 1 Nginx running per PHP server. I can have 3 Nginx containers with 10 PHP containers. Since concerns are separated, if a specific container fails, it's restarted. When my load is increased, I can monitor what containers require extra processing power and just scale that up. Do you always have a 1 to 1 relationship between your Nginx, PHP, database and cache instances? The answer is obviously no.
&gt; And so was I. We have 16 r4.2xlarge's with clustered Redis that we use as cache. There's no reason why each individual server or container should have it's own cache. How do you even share them across other servers? You can't, unless you are doing something hacky. But at that point, you have the same network latency you were complaining about. I don't know why my question is so hard to understand. If you have your kind of setup with clustered Redis, then you're already leaning on UDP and TCP for your communication, so emulating Unix pipes over TCP rather than... just using TCP brings you zero benefit. So this author obviously does **not** have your setup. And then the question arises why doesn't he combine the containers, if local performance is his primary goal. &gt; It's not a binary view. I've always separated concerns. Separating the concerns requires you identify "concerns". Not everything that's divisible is a separate concern. &gt; There's absolutely no reason to have your cache on the same exact box as your app. Right, but as I said above, if you don't have it on the same box, there's also absolutely no reason to emulate Unix pipes. &gt; Please tell me more about my lack of experience scaling ETL pipelines processing terabytes of data a day and API's handling 10K+ requests a second. If you apply the same amount of planning and execution to your morning coffee that you use in "experience scaling ETL pipelines processing terabytes of data" then you do very definitely need more varied experience. You don't kill a fly with a bazooka. Different scale of problems, different solutions.
I don't think this is an appropriately worded response to open source contribution. I would also like union types added to PHP.
Let's see how my upcoming contributions are received and afterward I might take a stab at it. `scalar` stays of interest because it allows us to implement bridging between primitives and objects, which is a very important thing.
Is this new? Because I've had those features for quite some time already (like years)
By definition, a scalar type is any value that is not a complex type. null is a single value and can not contain other values. Therefore, it is scalar. That it ‚Äúrepresents the absence of a value‚Äù doesn't matter. So does `false`! 
Where do you get this definition from? For a change, PHP has it completely right. `null` is not scalar in math and so must not be considered scalar in a type system. It also has no value as you claim, it is always an empty set (nothing, it's cardinality is also always 0). - [Scalar (Mathematics)](https://en.wikipedia.org/wiki/Scalar_%28mathematics%29) - [Is the empty set a vector space?](https://math.stackexchange.com/a/1115508/52199)
**Scalar (mathematics)** A scalar is an element of a field which is used to define a vector space. A quantity described by multiple scalars, such as having both direction and magnitude, is called a vector. In linear algebra, real numbers or other elements of a field are called scalars and relate to vectors in a vector space through the operation of scalar multiplication, in which a vector can be multiplied by a number to produce another vector. More generally, a vector space may be defined by using any field instead of real numbers, such as complex numbers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
It's not new, and the plugin was there for some time. Composer recently got a new `script-descriptions` directive and this plugin added support the next day. I thought the authors awesome work deserves another shout-out. 
Null represents a lack of value. You can argue with me, you can argue with the RFC, you can argue with two decades of PHP APIs but it won‚Äôt change the fact it represents a lack of value and it‚Äôs therefore neither a simple or complex value. It‚Äôs **no value**. Your subjective feelings don‚Äôt play a role here. Oh, BTW ‚Äúfalse‚Äù doesn‚Äôt represent no value, so you are wrong there too. You might want to brush up on your type theory. 
I don't consider 8 euros a month expensive :p
Fair enough!
&gt; Can you relax and keep the vitriol down? jesus christ, we can't curse now? lol wtf.
 - With `scalar` type hint and `object` in PHP 7.2, we'd have covered all `is_*()` functions (except for resources, but we don't often pass resources). So this is good for consistency. - From what I read, it allows the `scalar` type to be replaced with a more finder type in a subclass (`parent_func(scalar $var) -&gt; child_func(string $var)`). Commonly called variance. For `object` type, the variance vote [didn't pass](https://wiki.php.net/rfc/object-typehint#doodle__form__object_type_should_implement_variance) (only had 1/3). If this RFC passes and variance is there, then we'd have an inconsistent `object` type hint w/o variance, but `scalar` type with variance. 
I think "pumping out sites that are never touched again" is a great description of a large area in php-programming... It's not the most prestigious one, but I agree that it's probably one of the categories PHP is best at.
Not implementing variance means its inconsistent with `iterable`. No clue why that vote came out as it did, makes no sense at all.
I know that, I asked why didn't you use them in this case? Is there any pros/cons or this? Like "it's simpler to destroy data-only containers when containers stopped and don't need shared link"
&gt; which is a very important thing. why?
 type numeric = int | float p.s. Wish PHP has type aliases/definition...
&gt; If someone's plausibility in this community is based on "fuck" count in their comments, we're quite doomed. This is most irrelevant thing that anyone should encounter when thinking about community. I don't see any "anti-intellectual" and so on. If you can't see idea behind all this "fucks" - this is your problem.
I don't think that anyone really need `Stringable` interface and even more make distinguish between `string` and `Stringable` types. From callee side it doesn't matters and even in strict mode it should be treated as same type. Right now any object which implements `__toString` is already valid string value. Even if this kind-a implicit type definition, I don't see any problem with this particular case. &gt; you could also always write I don't have functions which receives all this types. Also `DateTimeInterface` cannot be treated as scalar type. If we are talking about functions like `var_dump` or `var_export`, then `scalar` typehint is not useful here. 
Objects that implement `__toString` are not valid strings, they are coerced in weak mode, yes, but that's about it.
Erm, `iterable` is covariant? `$amount * $discount` would be implementable and equivalent to `$amount-&gt;into() * $discount-&gt;into()`. Your objects would not be mutated, hence, encapsulation is not broken. Well, this is unless you consider getters to break your encapsulation.
&gt; they are coerced in weak mode just as your case with `Convertible`. I don't need any casts in strict mode. But in weak mode I don't need `Convertible`.
if you go to /r/javascript you can see a lot of people downvoting all of react or vue or angular posts because each one wants their own framework to "win". Same thing happens here, everyone is happy or confortable or settled with the tools that they use and other tools are a ... complication.
&gt; Erm, iterable is covariant? your method `info` specifies post condition, that it will return any scalar. In subtype we have covariant that type will be not any scalar but `string`. Right now PHP doesn't allow you to enforce post-conditions in subtypes. &gt; Your objects would not be mutated, hence, encapsulation is not broken. Encapsulation != immutability. I want interfaces of my objects to hide the way in which they are operate. For example inside of `Money` class I will operate with integers instead of floats and I also could use GMP/BCmath. In your example we are not hiding anything, we just take value from object and do job. This is violation of information hiding and also pretty much weak encapsulation. &gt; getters to break your encapsulation. Well.. about getters and encapsulation, it all depends on how you use it. Also we need to distinguish getters from badly named query methods. Getters will decrease level of encapsulation and also are signals that our object is not cohesive enough. If you have `getTotalPrice` method which calculates something for you rather than just provide access to field, then we are talking about badly named method which still provides encapsulation over some behaviour. There are also cases when getters are appropriate, but this is mostly to deal with UI layer of your application. In this case `__toString` is enough. You could get more information [on c2 wiki](http://wiki.c2.com/?AccessorsAreEvil)
&gt; Where do you get this definition from? [scalar](https://en.wiktionary.org/wiki/scalar), *n.*: 2) (computer science) Consisting of a single value (e.g. integer or string) rather than multiple values (e.g. array) It is what ‚Äúscalar‚Äù means in a CS context and the only useful meaning in PHP. After all, otherwise a string wouldn't be a scalar. &gt; `null` is not scalar in math and so must not be considered scalar in a type system. Math doesn't have `null`. The empty set is not the same thing. &gt; It also has no value as you claim, it is always an empty set (nothing, it's cardinality is also always 0). In [the computer science use of the world](https://en.wikipedia.org/wiki/Value_\(computer_science\)), null is a *value*. It may be used to represent the absence of some other value, but it is still a value. Much as 0 or an empty array or an empty set are values. Math is not computer science.
&gt; Null represents a lack of value. Null is a type that has a single value, `null`. If it were not a value, it could not be passed as a parameter, returned from a function, be used in or produced by an expression, etc. Now, it is a value that is used to mean the absence of a value. But it is nonetheless a value, and if people keep trying to tell me that computer science definitions of words are not real I will print out the source code of the Zend Engine, bind it into a book, and throw it at them. &gt; Oh, BTW ‚Äúfalse‚Äù doesn‚Äôt represent no value Oh, but that's funny, because you just said: &gt; you can argue with two decades of PHP APIs Have you noticed how often PHP returns `false` when it doesn't find anything? This is silly.
Set theory and type theory are closely related and in set theory [the null set](https://en.wikipedia.org/wiki/Null_set) is the set of zero length. Null is a type, not a value. It is used to denote the absence of any value. The absence of any value by definition cannot have any value, otherwise, there would be a value.
Coercing means to force something to become something else. In this case, no coercion would take place because your type actively opted-in for being the same as some other type. It is basically the same as implementing an interface.
But it's 8 euros a month forever. 
I repeat, `iterable` is covariant and contravairant: - https://3v4l.org/eLUQc - https://3v4l.org/dua6h Immutability is something that is very important to ensure proper encapsulation without deep cloning everywhere. The `Convertible` interface does not break encapsulation because nothing is capable of reaching into your type and changing its state. All operations you want to add, you can add. The `Convertible` interface does not hinder you in doing so, nor does it promote anemic design. This are all things you brought to the table. Getters are also not weakening encapsulation as you claim they do. They actually ensure proper encapsulation because nothing is capable to circumvent them and change the inner state of your type (as always, we ignore reflection mechanisms. There is also one important thing you are actively ignoring with `__toString`. Adding it to your type means that your type is from now on comparable to strings. An undesired side effect of the cast object handler that is being used internally. Another short-coming is the inability to throw exceptions. The c2 wiki page you linked is telling you that you should not create anemic desigsn. I believe that they are very right about this. However, it has nothing to do with accessors. Just scroll beyond the main body where the discussion is taking place and you will find many other statements that are in the same sentiment.
An empty set and a null set are not the same thing. An empty set has cardinality zero, a null set has measure zero. Null is both a (singleton) type, and the only value of that type. What you probably have in mind is the bottom type, which is distinct from the null type and which does not *explicitly* exist in the PHP type system (though we do make use of it in analysis, where the bottom type coincides with an empty set of union types).
8 euros? Looking online it says the price for the first years subscription is $200 USD
Congrats and merry christmas to all of you as well üëç Could not find link to home, docs, et cetera on this page on mobile. Might be a friendly gesture to lurkers/newcomers like me ü§î 
I found it, just go pass the GitHub repo and turn left: https://docs.phalconphp.com/en/3.2
Props for writing that in a constructive way, we need more of that.
&gt; but to prevent what she perceives as bad ideas and low quality code from being added to it by others. That's why she has a vote on the RFCs. Nobody is negating that. It's just that this can be done while respecting people that want to contribute to an open source project.
No. This paragraphs intention is to slight other devs with an underhanded insult. 
6Gb data is small. We have a table with 350+million rows and approx 45 Gb size at the moment. We have a parallelized processing system with one coordinator and up to 40 processing workers that all queries and updates this table. Database is on SSD but it wouldn't work If we didn't had the correct indexing of table. Too many indexes can also be a problem. Php optimization has nothing to do with this scenario. From my experience database optimization is the biggest issue to most php programmers. This is the first thing you should all benchmark. When database time is lower than 50% of processing time you should also consider optimizing php. Go for the biggest consumer. We use PHP (5.6 and 7.x .. trying to move everything on 7.2) and MySQL 5.7
Tbh I wouldn't have found the choice of language as disrespectful - It's the kind of thing I'd shout out loud at myself in the third person if I caught myself potentially talking a lazy shortcut when coding. Perhaps it's something lost in cultural translation, but from how I read it, other than saying "no" to the idea of "scalar", the rest of her comment was more aimed at herself and the other core internals team to express frustration that people were wanting to make untidy shortcuts to improvise around a perceived deficiency in the core language - and when was needed was an effort to create a universal solution. So the OP should try not to take offense. Her comments were not aimed at him, they were frustrations with the language itself. 
Why both of them and how do you see this setup?
Nginx and php-fpm work very well together and you should not encounter any real problems. The only situation where the switch would be difficult is if you're relying on a lot of htaccess stuff in Apache, which is an antipattern anyway
This is really no problem. We have only one php file for all PHP requests and htaccess rules to redirect any request that doesn't match an actual file to this php file. This can be replicated easily in nginx
I ditched Apache a few years ago and can't imagine going back to it.
Sounds like this will be an easy switch. Apache and mod php is older but php-fpm and nginx is just as mature. You will have better memory usage with nginx and php-fpm as well.
Memory was not an issue but this is a good news anyway. Thank you for the answer!
Nginx is way more efficient and faster than Apache. Nginx was created to tackle the problems with Apache. For example, in apache every request spawns a entirely new process, while in nginx it just creates a new thread. I have a build a few vps's with nginx and php 7, those things are blazingly fast. Nginx can be a bit more difficult to setup, because a lot of software, such as WordPress, have more documentation and examples for apache and can often auto config themselves on apache. With nginx you often need to manually configure a lot, because frameworks and cms systems can't access your vhost files.
&gt; If you have your kind of setup with clustered Redis, then you're already leaning on UDP and TCP for your communication, so emulating Unix pipes over TCP rather than... just using TCP brings you zero benefit. But to scale you need clustered Redis, right?
The site I run gets around 5,000 requests per minute on average. We use nginx + php-fpm to handle the requests, and it does an amazing job. We have no issues with maintaining PCI compliance. PM me if you want any help with configuring.
I'm using Kubernetes with weavenet + kubedns and there is no single point of failure. Also how do you use sockets with Redis or MySQL clusters?
&gt; I happen to be using Ansible and I build an entire new stack on AWS from scratch in about 15 mins by running a single command. No containers involved. There is no claim the one needs containers to provision infrastructure.
&gt; Docker has a lot of that in the community. It has some great aspects (as your use case points out) but when people launch EC2 instances just to slap another unnecessary layer of Docker containers inside them, so now we've got multiple layers of virtualization/containerization, it's really over-complicating the entire situation for zero gain. How do you scale on-demand without using the cloud? Also how do you host in different datacenters to ensure HA?
Event MPM + fcgi + php-fpm works pretty fast too. I don't have a 1:1 comparison vs nginx, but the Apache's bottlenecks are mod_php and htaccess (`AllowOverride`)
I think you might be replying to the wrong person. I'm not the one advocating using Unix Domain Sockets.
Just out of curiousity, why is it an anti-pattern?
&gt; For example, in apache every request spawns a entirely new process, while in nginx it just creates a new thread. This was true like 8 years ago. Have a look at workers.
1. Performance, as Apache has to scan the directories along the path for .htaccess files when a request comes in 2. Couples your codebase to Apache more than having a centralized config 
Well, even the [apache docs discourage .htaccess](https://httpd.apache.org/docs/current/howto/htaccess.html). First is performance: if allowoverride is on, apache must scan not just the current directory but also every parent directory above it for .htaccess. If you have a heavily nested directory structure you may be facing a handful of unnecessary disk reads _per request_. Especially bad for serving static files which should really not need more than one disk read per request. Second is security: any directory in your application can now control server settings. Third is maintainability: any directory in your application can now control server settings! This makes certain directories "magic", which is never good. It also makes your application less portable. If some mod doesn't exist on a new server you may get silent failures, changed behavior, or flat out errors, depending on how the .htaccess is written. It also couples your application to apache, whereas your application should really be server agnostic. Fourth: it's not really necessary anymore. .htaccess was popular and useful during "shared host" server days, where you just uploaded html and php files and had no access to server settings. .htaccess allowed developers to customize aspects their server without having access to the server config. But these days, most people use VMs (or VPSs), and do have access to server config. In general, and almost in all regards, it's better to centralize your server config and maintain a single source of truth of the behavior of the server. 
&gt; Second is security: any directory in your application can now control server settings. For that directory, It's not like you can override access controls on unrelated directories or anything.
How would one do something like mod-rewrite for clean URL's without .htaccess?
You really got off the wrong side of the bed today didn‚Äôt you? How much more embarrassing can your argument get? PHP API's don't overall return `false` to represent "nothing", they return `false` to represent an *error*, a *failure*. Try returning *nothing* from a function. What do you get? False or null? Null. Now, try a function with no determined output (a function with side-effects). In PHP, it often results in it returning boolean true/false to represent success/failure. In *some* APIs that have a result that was poorly appropriated to return non-bool for success, and false for no result/error, but that's PHP for you. Big community, lots of varied quality in core. We've all been calling this a deviation and a *poor practice* for ages, that some of our less competent colleagues have used in their API designs. You'll never find anyone competent argue that "non-bool for success, false for error/no result" is a good design. I'm afraid this exchange has made me reevaluate your personality, experience and overall skills. How much more **obvious** can this get, starting from this: is_scalar(false); // true is_scalar(null); // false I guess it's never obvious enough for you! ^^Please ^^don't ^^contribute ^^type-related ^^features ^^to ^^core, ^^thanks. 
Nginx has easier config and is way faster out of the box. There's really no reason to use Apache over Nginx these days.
&gt; Expressive still has that problem where you have to deal with writing tons of factory classes for manually setting up your DI and it's just tedious. That's because they know something about autowiring that you don't: it's a terrible practice that results in DI with the same drawbacks as using singletons or a global registry for your dependencies. Of course, that's just a default, you can plug another container in V3 and shoot yourself in the foot regardless. &gt; but I'm not about to sit here and spend half my time updating those factory classes This never happens. One has to wonder what went wrong for you to spend "half your time updating those factory classes". Those factories are at worst 1% of your dev time. What on Earth would you change so often in your dependency lists?
if on nginx, there is the map function, where you can map the $uri variable to a new variable you define, like $real_uri You then do all your calls based on the $real_uri variable instead of $uri
If you have clustered Redis, the entire thread (using Redis over UNIX pipes) doesn't apply. So you *cannot* do both together and end up with a performance increase, and this is entirely irrelevant to how many containers you use.
I personally recommend Caddy rather than the other two. Look it up.
Lol it‚Äôs the truth man, the overwhelming majority of developers will never need to truly scale an application. It‚Äôs not a diss it‚Äôs a numbers game. I would be fucking ecstatic if one day we need to hire an IE and scale out.