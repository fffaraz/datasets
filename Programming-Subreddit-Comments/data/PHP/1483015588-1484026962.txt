Are you using memcache or memcache*d* driver? I think memcache is not available on php7, but php7.0-memcached is. It requires a little different syntax, it was the biggest change I had to make when upgrading couple of apps previously using php-memcache, just had to remove some parameters from function calls.
That is sad :( i recently learnt php and memcache really does impressed me . but at the same time i also wants to use php7 as they say it is faster than php5.6 . combination of both would be definately give me good results :) 
i believe im using memcached as i used this tutorial to cache query results . Link of tutorial : http://www.9lessons.info/2012/02/memcached-with-php.html by looking at their code, it seems like its memcached. correct me if im wrong :) 
I'm a Symfony developer with around 12 years experience in the Netherlands creating all kinds of project for the biggest brands in the world. My latest project was a backend for an app which reached nearly a million players in the first month, very exciting project!
Actually that's one of the inconsistencies, if you have a namespace then old style constructors don't work. That's one reason to remove it in my opinion, as it means the same code breaks depending on if you have a namespace or not. I think expecting code that was written for PHP4 to run perfectly in PHP8 would be unreasonable, and this would be an easy thing to migrate over (either rename the method, or have an __construct method that just calls it).
Ah but that actually reduces the problems, I think - because almost all new code is written with namespaces, so you only have a special case for non-namespaced classes, which is an easier edge-case. Except for the old-style constructors, most code written to be compatible for PHP4 would run on PHP8 - which would be great. There are other possible imcompatibilities (for example the now-reserved string keyword), but they often don't occur. And a lot of projects still have some parts written a long time ago - even if it is just 2% of your codebase or some dependencies, it will still just use up time to refactor without bringing any benefits.
That's a good point. See, this is what I mean. There are pros and cons to both sides of the argument, and articles that address both sides are quite informative. The article he wrote wasn't, at least not to me
I'm using memcached for many years in production on multiple servers, haven't seen a single issue. It's mature and reliable. I would trust it way more than some 2 months old project with one contributor.
Thanks
Looking forward to seeing how this turns out. I'm slightly sceptical, my experience with nearly all end to end testing like this in the past has been net negative, but given the integrated nature of everything in Laravel as a full stack framework, if you stay close to the recommend (might not be the right word, maybe "popular") way of doing things, it could work out really well.
To save you time: All three are related to `unserialize()` which [you shouldn't be using on user-supplied inputs](https://paragonie.com/blog/2016/04/securely-implementing-de-serialization-in-php) in the first place.
i will give it a try, Thanks :D 
i will search about Redis :) thanks
It sounds like a nice feature but it's getting more and more bloated. I'd rather see this to be a package which is framework agnostic.
This is what I thought... And of course they said it impacts 80% of the servers... Just waiting for some big headline now about how every PHP site is vulnerable... 
This just in, 82% of websites vulnerable to remote code execution if you pass `$_GET['a']` to `eval()`. Stop the presses!
Just because you care about something doesn't mean everything you write upholds it. Someone can argue very strongly that your entire application should be written in one single PHP file. Models, Views, Controllers, et. all. That doesn't mean they're right or that their code is more stable because they can argue it is the case.
Yes, there is a way to do that in PHP: [Aerys WebSockets](http://amphp.org/docs/aerys/websocket/intro.html).
I'm so glad you're not a security adviser. There are probably more vulnerabilities in c libraries this uses than in the mailer itself.
This is very good research. The news coverage of it is just unfortunate.
Some companies would have let their lawyers handle such an issue.
* As an alternative, you can go with Lumen and import what you really would like to use out of the Laravel framework. Works well enough for me.
&gt; so it'd be unwise to be giving armchair advice without having the opportunity to study the project in good detail Disagreed. I'm quite comfortable saying that there's something off about OP's architecture. For starters, admin, reviewer, and author are not types of users, they're different roles users can have. That's the first problem. It's a common mistake to conflate these two, but it's an important distinction. Secondly, "UserController" is massively generic. I can think of at least 20 different things that user controller could be responsible for, which would make it considerably bloated, meaning there's likely a lot of duplication in each of the other "controllers". Third, nested controllers is simply not a thing you will ever really need. If the purpose of the controller is to render different views, that can be easily handled by a single controller. Meanwhile any specific logic that needs to be performed (data fetched/processed) can be done by delegating to role-specific classes in the domain, not different controllers. I'm going to say that there is never a single case in web development where nested controllers makes any sense makes any sense (in PHP anyway - front-end UI components are a bit different, but at that point we're not really talking about controllers). If you find yourself needing to use nested controllers, then you're expecting your controller layer to be responsible for too much work. &gt; Say, they may be rendering a different "My Account" page depending on the type of user, in which case, this branching makes perfect sense. Polymorphism is not supposed to be found in the controller layer. Different views should be switched by a single controller. And in fact, I would abstract this switch logic out to a `ViewLoader` or even `AccountViewLoader` class that simply returns the correct view based on the `User` that gets passed in. The views themselves can then be polymorphic, and extend off of a common `AccountView` if needed. If all OP needs to do is get the right string to render a template, then that's all the `AccountViewLoader` or `ViewLoader` has to do. 
I'm not allowed to criticize Laravel?
The criticism doesn't make sense. You're criticising it for following its modus operandi.
&gt; Disagreed. I'm quite comfortable saying that there's something off about OP's architecture. I'm sure you are. But I wasn't saying there'd be a shortage of people being comfortable giving advice. We have plenty of those. I was just implying the advice would be speculative and useless, the way your comment turned out. If you enjoy random speculation, may I recommend a TV show subreddit. I really shouldn't dig into this, but I can't ignore a couple of nuggets here: &gt; Third, nested controllers is simply not a thing you will ever really need. &gt; I'm going to say that there is never a single case in web development where nested controllers makes any sense makes any sense Can you tell me which of the letters in M.V.C. stands for "router"? It's not there, because routing is a part of your "front controller". And what this controller does is instantiate and call another controller. But I'm sure there isn't *a single use case for those*. I'm sure you just have separate entry points for every URL. &gt; Polymorphism is not supposed to be found in the controller layer. What a random statement. Surely you have a source for this?
TBF it's not like I expect anything better from most PHP developers.
TIL about Beats. Thanks!
Almost 5 minutes to explain how to use include and require, and nothing else? What were you hoping to accomplish by sharing this?
Looked at the docs mostly. That and see how frameworks used it. Why?
I only expect some minor documentation / editorial changes until we can finally tag `v1.0.0`.
Look at what I need to do, then search for something to do that thing.
Use a framework that doesn't stand for it then? There are use cases for both approaches. There would be no point in homogenizing frameworks to all be the same.
I am using a different framework but that doesn't mean I can not look at other frameworks at all. I just don't like what Laravel stands for currently. Too bad people seem to be really offended by this and can't seem to handle criticism.
https://phpdelusions.net/pdo
Well yeah, I would have asked for resources but everyone just points to phptherightway without really anything else, so I was trying to avoid that by phrasing my question that way. And absolutely, autodidacticism should be the best skill any developer works on.
This looks great, thank you very much.
Hmm, they're basically saying they added two existing PHP extensions: - PThreads - Event If you're thinking their PHP supports the "async/await" syntax, like Hack, nope.
Are you actually using Event and PThreads, or did you just want to plug Magento... :P?
[PhpAcademy (now CodeCourse)](https://youtu.be/QtCdk459NFg)
Bitbucket -&gt; Jenkins -&gt; Robo.li -&gt; Effing Package Management -&gt; createrepo -&gt; puppet ensure latest
Mission accomplished. You plugged everything.
There is no wrong way to do it. Except the wrong way, which you'll likely discover in due course. I'm a self-taught programmer, now a director of engineering at a ~500 engineer company, and the "right way" to write PDO code isn't even something we completely agree on internally... But there is a right way *for us*, which has more to do with our unique circumstances than it does abstract truths. For abstract truths, read the documentation.
It's a package. Not part of the framework.
I jumped on the docker and kubernetes bandwagon and I feel like its the future. We used ansible before. It did its job.. But started getting messy with multiple microservices. Having a container with your app and being able to reuse that same container in every environment is pretty cool. It also fits super well with the CI pipeline. Having it in container also allows you to do review branches easily (check a merge request with production data or staging data without merging) 
From a small development team (3 developers): * GitLab - Central Repository, Continuous Integration * Runs docker images for various PHP versions * Tests run: * PHP Lint (`php -l`) - catch syntax errors before they catch you * PHPUnit (unit tests, integration tests with faker-provided database) * DeployBot - Manages deployments * Manually triggered * Executes script to checkout/install in target environment (staging, production, etc.) * New Relic - Production Monitoring --- Things we're looking to do: * Move away from DeployBot to handle deployments through GitLab (still manually) * Move to docker-driven deployments (generate data-only container from build artifacts, push to private registry, pull from registry on deploy) * Add selenium into the build pipeline to allow end-to-end testing
I'm paid per-plug and per-tweet! 
Some of the combinations of tools I've used: https://www.karllhughes.com/2015/continuous-integration/
Instead of asking us if we find a use case for a function that literally pokes around a data tree randomly (as in literally randomly), maybe *you* can tell us why you needed it? Also what you call $json is not JSON, but an array you've decoded earlier. So just call it $array or something.
&gt; Can you tell me which of the letters in M.V.C. stands for "router"? It's not there, because routing is a part of your "front controller". And what this controller does is instantiate and call another controller. But I'm sure there isn't a single use case for those. I'm sure you just have separate entry points for every URL. You're setting up a strawman. The front controller is not what we're talking about here. &gt; What a random statement. Surely you have a source for this? 12 years of programming and never needing it, and seeing first hand how needlessly convoluted it can make a simple problem? 
Try jq: https://stedolan.github.io/jq/
Love how /r/php try to downplay this whole issue...
I am open to suggestions. Can you point out at any part that looks opinionated to you?
"Looking at the docs" made generations of PHP devs to use only 20% of PDO's power. there is a difference between a *reference manual* where you basically know what you're looking for, and a *tutorial*, that lists the basic features and gives you overall idea what to look for.
Yeah, the configuration is in php -- I don't see anything wrong with that. :) You can do custom tasks in deployer as well. So they're probably similar, if it's working for you - don't fix it. :)
Link?
Thank you, added a link!
Yeah, exactly. That's why it says at the very beginning, &gt; Note that although PDO is the best out of native db drivers, for a modern web-application consider to use an ORM with a Query Builder, or any other higher level abstraction library, with only occasional fallback to vanilla PDO.
Well, I have made many different projects over the years, and can't think of a single one where this vulnerability could be relevant. It's not very common to set "from" field or mail headers from user input, let alone without any validation. Or to use local sendmail in production for projects of any considerable size. You should ALWAYS validate and/or sanitize anything user inputs, no matter what language you use and what you are going to do with it. This shouldn't be an issue at all if the code is written properly.
Welp, crap. But now I know how to explain why we need to drop PHP 5. YAY
As others have noted: 1. If you really want to learn PDO, your only real choice is [this](https://phpdelusions.net/pdo). Nothing else comes close to explaining how to actually use PDO; certainly not the official docs. 2. If PDO is a bit too low level for you, Doctrine has a DBAL layer which is quite good (not to be confused with Doctrine's other layers; the Doctrine ORM is built on top of the DBAL.)
&gt; It's not very common to set "from" field or mail headers from user input, let alone without any validation. Part of the problem is that the exploit uses an email address that's perfectly valid according to the relevant RFC. &gt; You should ALWAYS validate and/or sanitize anything user inputs, no matter [snip] what you are going to do with it How does one sanitize / escape if the target environment is unknown?
Did i say it was?
Its those damn millennials !! Anyways i think you should stay on topic. "How people learned PDO" i believe it was.
There are plenty of alternatives if you want a more bleeding edge version built on debian, so debian itself being a bit slower to adapt new major versions of applications is a feature, not a bug. For example ubuntu started shipping php7 as default from 16.04.
Debian will [enter soft freeze](https://lists.debian.org/debian-devel-announce/2016/11/msg00002.html) next week. That means they block new packages in Stretch and focus on fixing bugs until they feel ready for release. Following [the most common schedule](https://wiki.debian.org/DebianReleases#Production_Releases) we can expect Debian Stable to have PHP 7.0 in Q2 ([not 7.1](http://lists.alioth.debian.org/pipermail/pkg-php-maint/2016-December/015881.html) unfortunately).
So you see not everything you can take from the manual. Although I appreciate your snobbery, the real life does proof otherwise. You see nobody learns a foreign language by a dictionary. There are textbooks. A PHP manual is more a dictionary, a reference manual than a textbook. So a good cumulative article is always better than dozens separate articles scattered here and there. Besides, not everyone is a mister smart aleck like you. Some people prefer a plain narrative. Either way I'd like to take look at your code. To boast "I know all" is one thing and to show your real code is another.
The Zend PHP certification checks your knowledge about PHP, so if you buy their book and spend some time studying..plus you have at least a year of experience in the field..you should be able to pass. As far as my experience goes, it is a huge advantage in appointments, specially now when there are so many applicants missing basic knowledge. If you have to pick from two similar devs you will go with one who has the certificate..but for senior positions not really necessary..If you still decide then visit zends site and get the book..read it and register for an exam..it is not expensive so worth a try
&gt; ll this effort should be going into bringing async primitives to the language, not building user libraries. It is the right solution at the wrong level. Even if/when it gets official language support, it would be nice to have the interfaces and behavior sorted out.
You mean, Php 5 won't be getting brand new bugs and just security updates? Guess it is a good time to stick to php 5...
I would suggest that studying the Doctrine Database Access Layer (DBAL) source code is a pretty good way to learn how to use PDO effectively. A few spots here and there to watch out for but overall, DBAL is an excellent wrapper.
The rant about exceptions is very out of place. Also, it first states "prepared statements are the only secure way of having values in queries". Then it says "emulated prepared statements are just as secure as real ones". Those can't *both* be right. Also many of the PDO features are mis-features, and so this guide being comprehensive only serves to confuse. For example, I can't think of a *single use case* for doing FETCH_UNIQUE in PDO, rather than selecting DISTINCT on the server side.
http://thehackernews.com/2016/12/php-7-update.html
Good job on using a namespace; a lot of people don't. You might want to use an all-caps filename for the read-me; i.e., `README.md`, because then your structure will be in sync with roughly 70% of all the packages on Packagist (cf. [pds/skeleton](https://github.com/php-pds/skeleton)). 
See https://www.reddit.com/r/PHP/comments/5kxkkt/3_critical_zeroday_flaws_found_in_php_7_%C3%A2_one/ These issues involve `unserialize()`, which isn't to be applied to user input anyway.
Not really - the PEAR package I have been using is not maintained anymore and has been superseded by a package on a different PEAR channel, where it was completely modified and does not suit my needs anymore (has a lot of new dependencies and was integrated into a whole new set of libraries). I always find it a bit disappointing if everybody just tries the easy-out argument of "hey, why don't you just fix everything yourself". That is the main point about old packages - first, it is usually not easy to fix it, basically not a matter of doing a simple pull request. I would spend hours on finding out how the package works and doing changes to the source code, releasing it - without adding ANY additional benefit to it. That is my main argument: People are forced to abandon working solutions OR they need to invest a lot of time for no gain whatsoever. Because keep in mind: this is just for one dependency in one project which covers 0.1% of the application. I will probably just remove this part of my application at some point because I would rather invest it in something either I or other people will use a lot more. Maybe there even already exists a new solution doing something similar like the PEAR package - but I would still have to find this new dependency, integrate it, find out how it works, test it and therefore invest quite some time for something which used to work perfectly fine before and does not add value for anybody.
We've only just completed the replacement of **mysql_** with **mysqli_** and I see we've also got the POSIX regex functions to do too before we can go to 7. Deep joy. 
&gt; The rant about exceptions is very out of place. No offence, but I would rather call *this* statement of yours opinionated. Can you elaborate a bit more, in regard of your statement "opinion versus fact"? &gt; Those can't both be right. Emulated prepared statement is still a prepared statement - I fail to find any proof for the otherwise. Can you? &gt; I can't think of a single use case for doing FETCH_UNIQUE in PDO, rather than selecting DISTINCT on the server side. There is just a very good example in the article. If you never had to index the returned array with unique field to have a hash instead of a list, it doesn't mean noone needs it. Given every major framework offers the similar functionality, I think that's rather a problem with your experience than with this feature. 
&gt; Not really - the PEAR package I have been using is not maintained anymore and has been superseded by a package on a different PEAR channel, where it was completely modified and does not suit my needs anymore (has a lot of new dependencies and was integrated into a whole new set of libraries). Okay, then take your revised version and toss it on Packagist so you (and others like you) can have a maintained fork available via Composer. The only problem here is an unwillingness to put some skin in the game.
I didn't bother reading this sensationalism, but I can assure you that unserialize() on PHP 5 is just as vulnerable as on PHP 7, even if some of the specific exploits differ. This also happens to be a very well known class of vulnerabilities that will likely never go away completely due to fundamental design issues in the format. If you are passing user-controlled values to unserialize() in 2016, you deserve whatever is headed your way.
&gt; Can you elaborate a bit more, in regard of your statement "opinion versus fact"? It's very simple. A fact is explaining when and how PDO throws exceptions. An opinion is having a long section talking about how all other tutorials are shit, and what exactly you should do and shouldn't do with those exceptions, based on your subjective idea of good practices. &gt; Emulated prepared statement is still a prepared statement - I fail to find any proof for the otherwise. Can you? Seriously? &gt; There is just a very good example in the article. If you never had to index the returned array with unique field to have a hash instead of a list, it doesn't mean noone needs it. Oh I have, but this doesn't belong in the DBAL. It's a data transform. And FETCH_UNIQUE is a very misleading name for indexing an array by a key. &gt; Given every major framework offers the similar functionality, I think that's rather a problem with your experience than with this feature. Cheap shot at a personal insult, but no, I know my separation of concerns, and PDO has a bunch of random representations that don't belong in a DBAL. Not to mention the interface with those constants is atrocious.
You said "tear it apart" but the only thing I see of concern is that you've mixed tabs and spaces and Github doesn't render it well. https://github.com/nehero/friendlytimezone/blob/1cc4568e04067dfb7d703a7b2a4e13921721c026/src/FriendlyTimezone.php#L109 That's mostly Github's fault, though.
i don't get it
Good suggestion! I'll look into a new name for that one :)
Damn PhpStorm... I'll see if I can clean that up!
It can technically be done with search/replace and some minimal changes. If you're making the effort though, you might as well go all the way and upgrade to the OO interface and prepared statements.
Hmm, you're using the Microsoft time zone names. But PHP uses tzdata time zones. Shouldn't you use friendly names that fit tzdata's zones? Edit: Ah, but [there's a mapping from tzdata names to Microsoft's time zone IDs in the CLDR](http://www.unicode.org/cldr/charts/latest/supplemental/zone_tzid.html). Okay. A further comment: time zones change a lot. Maintaining this will probably be an ongoing commitment.
It could perhaps rely on features of the framework. But I think most likely is that it is just being released alongside 5.4, similar to passport being released alongside 5.3 etc.
Could be, maybe Taylor could tell us a bit more :)
Use JSON. If serialize() is *required*, always use the allowed_classes whitelist.
Yeah... until 31 Dec 2018. We've got lots of time.
Do they really? daylight savings and whatever is adjusted now and then, but how often is the actual list of zones changed?
Sounds like an ad for platform.sh. Who's excited about this? Who actually uses pthreads in PHP? I'm not saying they're bad, I'm just genuinely curious if anyone has actually implemented multi-threaded PHP? Also...what the heck? Platform.sh boasts "byte-for-byte copies of production" and yet... we're dependent on whatever crap they have installed? Why not just use Docker containers or something so that *I* can choose what's installed?
Mumble muble happy holidays mumble.
Are you working with the ReactPHP and Icicle teams?
Common sense tells you that you shouldn't spew SQL errors (or any error, really) to the end-user. That's not PDO specific, so why should it be in the PDO docs?
&gt; Emulated prepared statement is still a prepared statement - I fail to find any proof for the otherwise. Can you? I think the point is that if PDO can successfully escape a statement on the client, then so can a user. Ergo, prepared statements are *not* the only way to properly escape a statement. In fact, PDO provides a method for doing so: [`$pdo-&gt;quote`](https://secure.php.net/manual/en/pdo.quote.php).
- define $opts as array $opts makes sure you get an array - @var array doesn't say much - @var string[] is better imho - same for @return array - an array of what? - reconstructing $utc = new DateTime('now', new DateTimeZone('UTC')); nearly 90 times seems a little excessive - I didn't test the code, but GMT seems to always be the last option, without taking the order into consideration - formatNumberToTime lacks @param for the input - formatNumberToTimenever returns a float - the code is simple enough, but adding unit tests would be easy and helpful - offset says it returns float|int but is actually string - the method name 'get' could be a little bit more explaining - like 'getTimezones'
/u/Revisor007 said to have the interfaces sorted out, in which case the underlying implementation doesn't make a difference. It doesn't matter if a userland vs native solutions are worlds apart in implementation. The interface for each may be the same. Which is kind of the point of interfaces.
Just a reminder that PHP 7 has unpatched security flaws https://www.bleepingcomputer.com/news/security/unpatched-vulnerability-affecting-php-7-servers/
Sorry, I was asking /u/adbmal what he would suggest as a replacement for PHP :) 
Reason #273 why PHP can do without Taylor.
Come on guys, too much trolls for today :) Come tomorrow, may be I'll find something to feed you.
Thank you! These are the 'tear me apart' comments I was hoping for!
I'm wondering if COBOL or RPG programmers have the same problem.
See https://www.reddit.com/r/PHP/comments/5kxkkt/3_critical_zeroday_flaws_found_in_php_7_%C3%A2_one/ Also, this was said right below here, in the other answers.
Do you fancy working on that? If so, good for you! If not, then telling people that they're working on the wrong stuff is certainly an opinion, but not one that actually helps. 
They do accept pull requests.
Python pickled objects, PHP's serialization, Java's serialization, etc... are stupid and dumb. They should not be used by anyone.
But what about patches for 5.3 or 5.4 that aren't relevant for future versions? No one is actually looking for those anymore, which is why they're insecure. People seem to forget this when bringing up RH/Canonical/Debian LTS support.
Here's a dangerous idea: write yourselves a compatibility layer that takes POSIX syntax and converts it to PCRE syntax, then keep your existing code as-is, and use PCRE only for new code. I think PCRE is mostly a proper superset of the semantics of POSIX, so this should be possible.
I didn't explain myself very well. With regular return types you always get one type returned. With nullable types you can receive *two* different types. That means we can't make assumptions in our code. We have to test return values to know for sure. There's also a potential for very subtle bugs to be introduced with nullable integers and booleans. I wouldn't say nullable return types are never appropriate but generally they're a strong sign some design decisions need to be rethought.
Your disgust fuels me :)
You're using timezones to be able to handle DST changes, tzdata seems to get updated often enough, so it's probably better to use the list provided by the OS instead on maintaining your own list. Also, pretty sure [php already has a way to enumerate them](http://php.net/manual/en/datetimezone.listidentifiers.php).
It's just yet-another-array-wrapper, like Collections, isn't it. So basically it returns "array", but covered in Taylor's special sauce.
I mean low-level primitives. One of the key flaws of user-land implementations is being limited to raw sockets and having to re-implement every network protocol with socket programming. All the major async frameworks now include an HTTP(S) client/server implementation, but offer little beyond that. If we could bring async support to all the network protocols PHP currently supports *in PHP* that would be invaluable, not just because more services would be supported, but because their implementation would be battle-tested by the millions of people using it which is something these fringe async libraries that almost nobody dares use in production are severely lacking and will continue to do so until this challenge is tackled properly.
I found the php7cc tool quite helpful. If your app has an automated test suite, simple run it and you will see where needs changes. For some sites I had, I went ahead and upgraded to php 7 (personal sites), but kept an eye on the error reports and I surely could see few minor problems that was easy to fix. Most IDEs can emit warnings too, of you set the language to 7 or 7.1. If you are using mysql_ extensions, note that 7 has it removed for good reasons. In the other way, php did get many syntax changes as well. Group use syntax, list syntax, short array, type hinting, etc they all are new to 5.3, so code written for 7 will break fatally in older versions. 
You can use php-cs-fixer as well, or use some sort of a CI-like tool like StyleCI.
PHP lets you enumerate tzids. Those are the IDs the OP is trying to avoid presenting to the user.
[Here are some benchmarks](https://www.techempower.com/benchmarks/#section=data-r13&amp;hw=ph&amp;test=plaintext).
hmm, sorry i read it the wrong, btw is php means php7? 
I work in PHP, but those stats are incredibly misleading. Check out the latency of database-access responses for the .net mvc test. Their test bed has something improperly configured. You (and apparently, they) are insane to think that 600ms latency for result sets is somehow "normal". edit: their core environment is properly configured, this is the data you AUGHT to be referencing. I'm also suspicious of the fact that there is a larger-than-expected set of variations in the data for the query-based benchmarks when switching between physical and cloud hardware. I'm beginning to believe that this data is loathe to be trusted. https://www.techempower.com/benchmarks/#section=data-r13&amp;hw=ph&amp;test=plaintext&amp;l=4fthbx&amp;p=zi8sfz-zik0zj-13xhxb&amp;f=zik0zj-zik073-zik0vz-zik0zj-zik0zj-z6nlrz-3j
5.6 will receive security-related bug fixes.
A lot of hosting providers are updating to PHP7 without BC to &lt;5.6 and have most of client's sites broken.
Fuels you to do what exactly?
Which artificial constraints? 
Sure. Icicle is now deprecated in favor of Amp 2. React has an open PR. 
With high concurrency your latency will increase roughly proportionally to the concurrency. You can spin these tests however you please, but you won't get anything different other than PHP, an interpreted dynamically typed script that reboots its environment on every request, is much slower than .NET, a compiled JIT platform running in a persistent process.
&gt; there is nobody to do all the work Except all the people already doing the work. In the wrong domain. That was the entire point.
&gt; Apart for learning purposes, your projects should use a framework There are a lot of situations when frameworks make sense, but this is a bit too absolute statement.
&gt; given an invalid id Shouldn't it throw an exception?
An exception.
Actually, they do change a lot. It certainly isn't every day or every year, but in Sri Lanka for example, time zone was changed two times after 2000. This was the adapt to the day light (we don't have DST), save electricity, political reasons, etc. These changes hardly make it to international news, so I'm sure other countries have changes like this too. 
Most of them know PHP, but no or not enough C / PHP internals. 
https://www.codewars.com/ - Great site, not just php 
Hi! You should try a reusable tool to sort array of entries by criterias (meeting website for example) by geolocation, preferences, ... Also, you should take a look at https://code.google.com/codejam/
On real world applications..there are no differences..because the speed of the language , framework is not usually the bottleneck
Instead of doing 30 worthless things, why don't you pick something that'll be useful to you, or someone else, and work on it for 30 days?
&gt; If you are passing user-controlled values to unserialize() in 2016, you deserve whatever is headed your way. If that's the case, why was "allowed_classes" added. This only makes sense if the content is untrusted. 
If you like puzzels, challenges and not only in PHP then https://www.codingame.com is the best practice for you. Multiple levels and events also.
I personally really like https://www.hackerrank.com. Their profiles are similar to GitHub's, so you can see an overview of all your contributions (in the form of submissions you have made to challenges). If you're active enough on there, it may even be worthwhile linking it to your CV (as you would do with your GitHub account). There's also: - https://codefights.com - http://exercism.io - https://www.codewars.com - https://programmingpraxis.com And loads of others too...
BTW what makes the format inherently insecure to the point, as you say, "it'll never go away"? Aside from the fact you're instantiating objects based on untrusted data.
asp.net because is compiled but I found asp.net hard to learn because of the lack of documentation. I don't use Laravel either because is full of bad programming practices they say.
That's entirely possible; what you did is something I find incredibly annoying. People have volunteered their time and energy to produce some open source code. You are immediately criticising them for undertaking this effort and instead saying your own preferred solution, but not actually volunteering to help make that solution become a reality. This just shuts down people's efforts without making your own idea any more likely to come to pass. You could have expressed your message in a way that actually drives the conversation forward like: "I can see why you guys wrote this, but it seems to me that solving this problem would be better done using language primitives rather than userland code. What are the problems with doing it in that way? Is there anything I can help with?" My understanding is that it's just too massive a task to either implement it natively in PHP's engine, and also too large a task to persuade PHP internals that such change would be beneficial. Both those things are completely side-stepped by implementing it in userland.
Everyone's a fan of their favorite; e.g., there's also [Aura.Di](https://github.com/auraphp/Aura.Di).
You'll want to ask the Container-Interop folks (Negrier and Napoli) about the history and future intent here, but the originating container-interop project has wider adoption and is in actual use, whereas the projected PSR-11 is not yet approved.
The serialization format supports turning any earlier unserialized values into a reference. This means we have to store pointers to all unserialized values. These pointers need to stay valid for the entire duration of the unserialization, which is very hard to ensure. It's impossible to ensure if you can run arbitrary code during unserialization in the form of __wakeup. For this reason we will probably soon land a change that delays all __wakeup calls until the end of the serialization (even though this is an observable behavior change). However there is nothing we can really do about Serializable::unserialize(), those cannot be effectively delayed :/ (If the serialization format would instead indicate that a certain value is going to be a reference, all these problems would not exist. Alas, the ship has sailed...)
For the last 20 years I have maintained a C based program. Much of the code dates back to 1985. Been remarkably stable but it does seem like every 5 years or so we need to make adjustments as libraries and operating systems change. Painful. But at least we have gotten good at writing tests.
[removed]
&gt; Please do not used mixed return types. This is a really good idea. &gt; With the comming of PHP 7 PHP7.0 allows return type declarations. function(string $value):string{ ... } PHP7.1 will be adding nullable argument type hinting and nullable return type declaration. function(?string $value):?Car{ ... } Union might come later. function(string|int $value):Car|Truck{ ... } All around, great suggestions.
Why would you need `Command` interface if it has no methods? Why would you use separate `CommandHandlerLocator` and `CommandHandlerMap`? Isnâ€™t this the same responsibility with a different interface? This needlessly complicates the system. 
It's not PSR-11, but [Opulence's DI container](https://www.opulencephp.com/docs/1.0/ioc-container) is very powerful and has easy-to-use syntax. It's not bound to the Opulence framework (it has 0 dependencies), and you can use it as a library on its own by including the `opulence/ioc` Composer package. Besides being a DI container, it also includes support for [bootstrappers](https://www.opulencephp.com/docs/1.0/bootstrappers), which is a simple way of binding entire modules to your DI container. &amp;nbsp; Here's the source: https://github.com/opulencephp/Opulence/tree/1.0/src/Opulence/Ioc
In fact the app was showing an error message every time until I switched wifi off.
Every loop vendor needing their own libraries for everything.
&gt;I want to build a pseudo-portfolio on GitHub Have a nice life.
PhpStorm already has this feature built in. 
That's not an exceptional event, at all. You'd rather wrap every single method that could possibly return a `null` value around `try/catch` blocks?
Puppet, Chef and Ansible shouldn't be used for continuous updates to existing infrastructure. They're more handy when you're wanting to keep installed packages in sync between one or more machines. If you're looking for dynamic configuration changes, ie you have several HAProxy instances that need to be aware of App servers to redirect traffic, you would use something like [Consul](https://www.consul.io/) for service discovery and [Consul Template](https://github.com/hashicorp/consul-template) updating config files in real time, triggered off of service discovery.
Not everyone is a fan of the 'Tip of the day' feature because it could be considered to be a bit intrusive; you're opening phpstorm to start working and don't want a popup distracting you. Also every tip on the blog will have tags to browse related tips, links to the phpstorm docs to continue learning from the source, and a comment thread for users to discuss the tips.
Deployer looks interesting -- thanks for bringing it up. Is this used on local host? I suppose this wouldn't work well for team deployments? 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; Containers are application-layer classes, not domain-layer classes. I have come to think that containers at the library/component/module level are also useful, whether in the domain layer or elsewhere.
Awesome site and great idea. Thanks and keep up the good work.
It's not too late to design a newer, better alternative to `serialize()`/`unserialize()` format for PHP 8.
The version I'm stuck with on Production is not even in the calendar graph :)
Free for now, it won't be for long and it looks like for free it's only 50 minutes of run time per month
Thanks!
Nice clean design and I learned some new stuff!
And btw api's should be cacheable so framework performance shouldnt matter
Thank you very much!
Are you real?
Anything called *handler* either has a bad name or is a bad thing. Sometimes both.
Any chance you`ll create a youtube series?
No, I'm a bot. 
Out of curiosity, could you expand on that? What are the use cases of DI containers at that level?
Look mostly good so far. I'd move the `TaskRepository` to the application layer, since the Infrastructure layer shouldn't (imo) know about any interfaces in the Domain layer. I'd have it accept a TaskMappperInterface, or something similar, which is then defined in the application layer and implemented in the Infrastructure layer. That way your Infra knows even less about the domain, you and you move the persistence outside of the Repository (Since the repository interface is defined in the Domain, it's a Domain concern, therefore it shouldn't handle persistence. Imo). Other than that, I can't see anything glaringly wrong without seeing more code. I would question if `TaskType` is just a class wrapping around `Task`, so it works with Doctrine more easily, or if it's an attribute of the `Task`, in which case it doesn't belong in the Infra. But yeah, looks like you'll be off to a good start Edit: Quick Ammendment I'd suggest not writing your first persistence method a file persister, but rather one that simply stores and gets from an in-memory array. It's easier to write, and quite frankly easier to test from scratch. Rather than worrying about files existing/not existing, and seeding files, you just set values in an array. It allows you to start by focusing on the most important part of your application: your domain. How you *store* it is just an implementation detail, so start with an in-memory array. Upgrade later
Why?
...and WordPress will support PHP 5 until 2099.
and if I'm not a mac user?
What is your theme ?? 
I'm using it on a server to just deploy a symfony app and run some tasks, but it can be triggered remotely by anybody as well - you just have to configure deployment targets, though I haven't done that myself.
Agreed. Great Idea to do pro-tips in gifs. Keep 'em rollin' ;) 
I wouldn't bother entering into conversation with the dickhead to be honest.
For PHP7. memcached isn't an option. and your point about something being new and maintained about 1 person, wut?
Nice site! Im liking the way that info is presented
Not really. Some are quite similar, but cmd-n on Mac is alt-insert (I think...) on windows. For this to be truly useful, shortcuts for Linux, Mac, and Windows should be listed. Extra points for sniffing user agent and showing shortcuts based on browser platform like in the jetbrains help docs. 
Nice. Good info, nice site. How are you creating the gifs? They run quite nicely.
I don't see the two as mutually exclusive. I tend toward an ADR implementation but to build an app that can be consumed as easily from the command line, or through an api, as it can be through a browser, a command bus can be a great option.
Or you could just download release candidates for free here: https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Early+Access+Program Completely free to use, they automatically deactivate after 30 days so you have to download a newer version or if non available, buy it / get student license
Idea: You could open the gifs as a popup model on the page to avoid page loads and make it easyer faster to go from tip to tip :P
Thank you very much!
What feature?
Speaking of which, I am sill waiting for your feedback regarding my last email, Paul ;)
he can make money out of it and be totally fine too
I use Camtasia to record my screen, edit and export to gif. It does it very well.
Thanks for the suggestion!
Thanks!
ShareX is a great tool too
Do you know how to convert namespaces to use the new grouped feature added in 7.0?
I agree. I enjoy reading articles about different ways to do things but I'd really like to see some actual applications. In particular, commands are fire and forget. CommandBus::handle never returns anything. So your web app typically has to redirect just to see the results. Which adds another layer of complexity. Oh well. Maybe there will be a part 2.
&gt; `$l___l_='base'.(32*2).'_de'.'code';` So encryption, much obfuscate, wow.
thanks mate! you're amazing!
The question is, in PHP7+, why would we prefer a more error-prone custom stringly typed version of a "container", instead of using a PHP interface with return types to describe which services we need. The concept is so common it has a name: SPI (Service Provider Interface), it's the other side of the coin with APIs.
/u/mlebkowski `Command`: it's a marker interface pattern. Empty interfaces (also known as "marker interfaces") are often used to mark a class for its indended purpose. https://en.wikipedia.org/wiki/Marker_interface_pattern `CommandHandlerLocator`: I could put all into one class avoiding the Map class. But I think it's useful to have `CommandHandlerMap` separated as a first class collection http://softwareengineering.stackexchange.com/questions/139353/why-should-we-preferably-use-first-class-collections 
###Here's a sneak peek of /r/phphelp using the top posts of all time! ####\#1: [I think I peed in my girlfriend](https://www.reddit.com/r/PHPhelp/comments/516s75/i_think_i_peed_in_my_girlfriend/) ####\#2: [I'm behind on PHP. Last version I used was 5.something, in 2013. Need tips and even a book recommendation.](https://www.reddit.com/r/PHPhelp/comments/4200n3/im_behind_on_php_last_version_i_used_was/) ####\#3: [PHP training via IRC starting now](https://www.reddit.com/r/PHPhelp/comments/wrchn/php_training_via_irc_starting_now/) ^^I'm ^^a ^^bot, ^^beep ^^boop
My point is that you separate out your persistence from the repository. The repository class can accept an implementation of an interface that does the persistence, instead of doing the persistence itself. That way each layer only knows about the layer directly below it. That's my preference. As for the remembering between requests, my personal approach is to do the requests part later. With test driven development, I'd focus on making sure the domain and application layers work and are tested first, no need for requests at that point, then handle the requests part. Basically building and testing the most important part of your application first, leaving the small details for later. But that's just how I personally would go about it, and all of this is just my opinion, not hard fact. 
&gt; Standardizing the DI container interface makes sense in a world where you can mix and match components together. This has to be qualified, why would you need to standardize the DI container to "mix and match components"? I'm thinking why that'd be, but programming to interfaces and injection is all you should need in order to do that. The same thing with "standard configuration". Why does it have to be XML (as per your link), when it can be... PHP. Then those who want can parse data out of XML on *top of this* to extract PHP configuration to pass to a component. Configuration mechanics shouldn't reach so deeply into every component in order to be interoperable.
Hi Nikush, that's alright, I understand. I appreciate the shout out in the Twitter bio, keep spreading the knowledge :).
That makes sense. Thanks a lot for your reply, I'm just a lowbie self taught guy who doesn't have anyone IRL to discuss these things with so I apologize if it seemed like a dumb question :) Now that I think about it, my thought process was wrong. I imagined a Card object (Magic: The Gathering of course) having two options for price. An int, or null. Null would be having no pricing data available, and of course int reflecting the price. The implementation was bad for this use case. It wouldn't make sense to force an implementation to return null if, say, price data were available for every card in the database.
I'm still thinking. ;-)
I also had that thought and which was part of my confusion, but I stripped my card example down to barebones to be more focused. If you had in your Interface... interface CardInterface { public function getPrice(): ?int; public function setPrice(?int $price); // i know, setters suck, just using it as an example } Your implementation HAS to accept ?int for setPrice(). But, there's no way to enforce that getPrice() has to be able to return null. It just seems odd to me :(
You are right, you should avoid to pass the DI container around as that would mimic a service locator. But there are 2 spots in every(?) framework where you need access to the DI container to manually pull a dependency from the container in a service locator fashion: 1. to resolve the action/controller that needs to execute the current request, 2. to resolve the view/template/responder that will render your request. Multiple formats for the configuration do make sense but to be fair, given how long it took to reach consensus so far for just one particular format makes me wonder if we would ever reach the end goal. A lot of people (me included) are very opinionated when it comes to DI. And if you ask me, we have a long road ahead, we still do a lot of things wrong and it will take some more years til we reach true component interoperability.
I still don't understand where specifically the problem of interoperability is coming from. What does resolving controllers/views have to do with this? When something needs a dependency, it can ask for it from its creator, either by taking it in during construction, or taking in a factory for it during construction. All of this is PHP 101, so it's already interoperable.
Jeez that's not much. We have a code coverage test that takes nearly 90 minutes each run.
Yes, and I think it's worth pointing out that "type safety" and "actual correctness" are not one and the same - as in your example. Contravariant parameters and covariant return types are the only type-safe solution (other than invariance) due to LSP, but that doesn't mean it captures what you actually want to do. And I believe some languages actually ignore that aspect of type safety in order to allow covariant parameters (wikipedia just told me it might only be Eiffel).
Mine take 2-3 minutes to run in full, so I can only do 25 tests a month which is a shame It would be better if the docker container didn't have to download each time, and if composer didn't have to do a full install, if it could remember a save state to start from each time (I guess I could make my own docker container)
The page you linked specifically advises users not to use that function, in favor of prepared statements and bound parameters. 
I was thinking "should probably be using a has method for this type of thing earlier" when I was replying. I must have spent close to 45 minutes last night searching reddit for this and I couldn't find anything. Google wasn't of much help and reddit search just seems to be of little use. I'll give them a good read, thank you!
[So this is just a quick example](https://github.com/Garethp/hexagonal-ddd) that I whipped up in 20 minutes, just to show what I mean about separating the mappers from the repositories. I took it one step further and separated the mappers from the adapters. The adapters being what actually writes the data somewhere. You can combine them, but this is what I did for my last multi-team project using DDD and a Hexagonal Architecture. The advantage here is that while there's not that much more code to write to seperate adapters out from mappers, if you want to change how you store your data there's a lot less to write. We were basically just storing whole entities (We were going to use Mongo on release, so for development we just serialized and stored), so the responsibility of the mappers was to do the deserialization or filtering of arrays if we were doing something like that. This way each layer is only aware of the layer directly below it, the storage is separate from the repository and the infra. doesn't know about the Domain. Iirc, when I had roughly 8 repositories, migrating from array to json files was about 20 minutes work (with tests), and from json files to mysql using doctrine's dbal was roughly 30 minutes work (with tests). Because then I only had to write one adapter and just use my DI container to pass them in to the mappers, as opposed to having to re-write every mapper to use the new storage. Additionally, plans were in place to put the adapters in to a shared repo, so when someone created a mongo adapter, everyone could use it
Not node.js? Fucking noobs. 
&gt; `$l___l_='base'.(32*2).'_de'.'code';` The easiest way to put this: - A variable is declared called $l\_\_\_l\_ - Its value is a combination of strings/numbers concatenated together. Concatenation in PHP is done using a period. This means the value is &gt; 'base' . (32*2) . '_de' . 'code' Put this together and you get "base64_decode". But since you didn't literally write "base64_decode" the "most basic" php interpreters will not detect it. You can then simply call the variable name and the base64_decode function is called cause PHP works that way and you can still pass arguments to it.
An automated tool might look for calls to base64_decode in an attempt to find malware. 
He's just trolling. You did a great job, the site is great. :)
Hi I learned PHP ~3 years ago, I created CRUD apps, Authentication, Administration panel, used Sessions, Cookies, ..etc Now I want to go back, not to the very basics by reading for some resumes (blog posts..) about these important stuff and the best practices so I can help myself understand a classified-ads CMS (Script-Pag) made by PHP, to edit for a client.
Eli The Computer Guy's PHP videos on YouTube are really good: https://m.youtube.com/watch?v=27dR_sLaM74 But W3School's is my GOTO reference: http://www.w3schools.com/php/
2 questions : First of all, if you grab data from GET, should you use urldecode()? Second of all, how should you add a "log off account on every computer" type feature, would you need to create some kind of `logon` database to do this? And should you ask the user to input their password (or even use email verification) before they can use the feature?
Just glanced over it quickly, but already seeing things I didn't know. I started with PhpStorm less than a year ago, so this is definitely worthy of a bookmark. Thanks!
1. That's annoying to continue doing every month. 2. By doing this you're saying "I don't care if you continue making this a better product" 
Canvas - http://canvas.toddaustin.io
Sulu, a CMS built on top of Symfony
[removed]
&gt; Taking it during construction does not work in this case, because that meant to inject all your 50 controllers which need 50+ services and repositories. Having 50 controllers doesn't follow you need 50+ services and repositories. There's some unspoken context here, or you may be making assumptions based on a particular framework's approach or weaknesses. &gt; It is inefficient to build the whole application object tree for just running one controller/action that is responsible for executing the current request. You don't have to build it. Pass in a factory implementing an interface that your module requires (which contains your 50 controllers). Factories then lazily build what you need on demand. &gt; In addition to that you do not want to constantly modify the class that is responsible for executing the controller and its action and add another controller and another controller. What's there to modify that bothers you, more specifically? &gt; A factory or a service locator is a much better approach as you pointed out. And guess what, you can use your DI container as a kind of factory, so problem solved. But it only gets interoperable when you have a defined interface that you can use, hence the reasoning behind container-interop / PSR-11. This doesn't explain the need for PSR-11 in any way I see. Here's a solution you can use today: interface BlogConfig { function getServiceA(): ServiceA; function getServiceB(): ServiceB; function getServiceC(): ServiceC; } // Module's public interface, containing 50 controllers, or whatever. class Blog { private $config; public function __construct(BlogConfig $config) { $this-&gt;config = $config; } } Notice we didn't need any PSR in order to use this. And it's self-documenting, type-safe, and just works. I don't see how PSR-11, or container-interop or any other similar solution is self-documenting. It's more like a black box where the identifiers, and their type is entirely implicit. That *could* be ok as a shortcut at the top-level of your app, but once you start replicating this pattern throughout your modules, components and even deeper, that's *not a good thing to promote*. How is the creator/caller of that module above to meet the contract of your dependencies, when this contract is not declared anywhere in the code? Your IDE becomes useless and you rely entirely on circumstantial runtime errors and comments/documentation to detect problems. Let's assume that you find types inconvenient anyway, so you want a more stringly solution. Then let's assume you have a container, but it doesn't implement some module's config/container interface, but another interface: interface BlogConfig { function wanna($serviceName); } interface SomeOtherContainerInterface { function gimme($serviceName); } Now, if only we had PSR-11 to get past this, right? Nope, because the solution is trivial: $container = new SomeOtherContainer(); ... $blog = new Blog(new class($container) implements BlogConfig { private $container; function __construct($container) { $this-&gt;container = $container; } function wanna($serviceName) { return $this-&gt;container-&gt;gimme($serviceName); } } Compared to the actual time you'd be spending elsewhere in the code, spending a couple of minutes to write this adapter is entirely inconsequential to the big picture, and it requires no standard or instant compliance to it from everyone.
is there a PHP example with AJAX or Websocket?
You said they shouldn't be used by anyone. But there are circumstances when you need to serialize data in a performant way. These functions are faster than for example JSON because the format contains the metadata needed to allocate memory in large chunks. If well designed the format also could also be made so that elements are read in the right memory order. For a balanced search tree this could mean the difference between constantly rebalancing the tree or needing no balancing at all! (Not that PHP have a balanced search tree datastructure, but Python and Java has). At the extreme end one could argue for storing a raw memory dump but that would be even worse for security. We prefer JSON as the first solution to serialization, but have also had the need for faster alternatives from time to time.
@maadinsh Actually the opposite, memcache is supported by thirdparty extension and works very well. Developement on memcache**d** extension seems on halt. We are actually using memcach**e** from here ( https://github.com/websupport-sk/pecl-memcache - NONBLOCKING/PHP7) and it's rock solid. While memached has issues (lost keys, segfauls) under high load. Probably you can't use memcache as memcache**d** replacement, as functionality is limited and this would also depend on script requirements (eg. no CAS support). @DrWhatNoName have spoken with a guy who wrote another memcache*d* extension for PHP7, and seems it's very good... https://github.com/cybozu/php-yrmcds/ however we haven't tested that, but if you need memcached and don't want to try something completely new i believe that's the way to go for now... not sure if it'll work but it should. I also invite you to use my server (FlatDB), it works in production for over half year without crash. Basically the github project is fairly new, but code isnt... so i believe it's stable and well tested. You'll need to install a server to do that, there is very simple tutorial page for auto-starting/auto-restart systemd service also in SERVICE.MD file. If you need some help setting things up, etc. you can send me a message. As for some quick history and comparison... like 4 years ago i forked original memcached server and replaced the code that deals with garbage collection because LRU was not fit for our use case (eg. 90% of memory was garbage, that fork is also available on github and we still use it :) Also i was working a lot with sockets communication and that's also included as another project, as a part of FlatDB. Basically the project is there because in original memcached we had memory management problems and then after php7 there was stability issues so i had 2 options, to fix extension or to write something completely new. I'd also have to modify server code if we go with original memcached, so i went with writing everything from 0, as i already had some other code that was needed (php-go client/server library, memory management code for slab allocator, etc.) I can come with any synthetic benchmark showing how much better it is vs memcached, but in real use case we see that CPU usage is about 70-100% UP, while memory usage is like 5-10 TIMES down. That's comparing to my fork with better memory management already so with "normal" memcached you'd probably see larger differences in used memory. We're also using very lazy settings for slab free and re-balance for flatdb, so if optimized this would be even higher. We have very dynamic data, eg. some keys have 2 seconds TTL and 10 bytes, something else has 500kb and 6 hours TTL. So you can expect, under specific use cases with very varying TTLs that you'll have twice as high CPU usage but even 10-30 times less memory consumed. We're currently using simple class that'll map memcache calls to flatdb, and there are functions to limit CPU usage too (like get-first item from set, atomic cache).
I'm not against your solution vs. Docker, but please point out what would be the main advantage of setting up xdebug with Vagrant vs. Docker. The way you're phrasing it is just "it's better" which doesn't really help anyone understand why one solution might trump the other and in what cases.
Have you looked at https://symfony.com/doc/current/components/http_foundation/sessions.html
Ok, thank's for the explenation, I didn't know that. I'm using memcached extension on multiple sites/servers with php7.0 and even one with 7.1, and I haven't seen any issues with it, but I'll keep this in mind.
Good news! Most of us are based in the UK! But we do have a few members spread across the globe, my ambition is to have a team that chats 24/7.
October?
You just set up your php executable to be "remote" this allows you to use vagrant, docker , or ssh. Once you've done that you just goto your test you want to run and right click and select run. It's really useful. Also, I just noticed Docker support for the first time. So there isn't really any difference.
If you want a great blog then Ghost is a really good option
Essentially been looking through WordPress source code to extract parts of it. I am aware KSES has a non-WP roots, but it's old and AFAIK broken for PHP5.6+. Rather than just fix the broken I thought I'd spin it off and add unit tests etc. Main difference is AGPLv3 license using DI to send in functionality, class based (won't say OOP in-case someone jumps on); and more meaningful method names. There are 3 methods that could be injected at some point, and I'm looking for strategies (thinking static method ATM) to construct without worrying about dependencies (using stock deps). Most of the interfaces and the validators belong in separate libs I think. It's not done (only attributes right now). Need to think of suitable way to present (maybe facade pulling in other functionality).
So, kinda like an online user groups as opposed to an "in person" user group?
thanks for sharing great resources. You can any good detailed course on udemy.com that start with basics and then covers advance topics.
I wanted to try Grav myself. Is there something wrong with it that you are looking for other CMS?
Drupal is a complicated beast with it's own subset of config hell but you can build out quite powerful blogware when wp is just a bit too simple. Being based on symfony has been a great change for it.
That's funny because after I've tried https://upstatement.com/timber/ in WP for the first time I fell in love with Twig and was even happier to see that Grav is using Twig too. Of course there are other template engines but If I would be looking for CMS then it definitely would have to use some templating engine instead of mess like WP themes code can look like.
Oops sorry. Thought I was posting in a different subreddit. It is node based but very good all the same.
https://gist.github.com/odan/a0dd66bf681fae46d0df14b103108f23
thanks for your advices! let me read more about your suggested link :)
Your README.md has this line: `docker-compose down` do you know what that does?
Re-blog spam. Actual article here: https://laravel-news.com/80-laravel-tutorials-packages-and-resources
PyroCMS https://www.pyrocms.com/ It's Laravel 5.3
A few thoughts. - I think it'd more appropriate to call this a fork - not a port. And idk that re-licensing is something that anyone except the original developer can just do. If it was then what's to stop people from taking GPL licensed code and just arbitrarily deciding to re-license it to themselves with a proprietary license? - I think it'd be good if the README.md file contained a description of what the original KSES did. - How does it compare to http://htmlpurifier.org/ ? 
Take a look at Laravel.
we use pimcore
Sounds like Perch CMS offers exactly what you need. 
Slim or Silex frameworks are probably the best bet. Not sure if they have User Systems available or not. Here's a tutorial on using [Slim with Sentinel](https://www.sitepoint.com/removing-the-pain-of-user-authorization-with-sentinel/). Only bad thing about it is that it is for Slim 2. Here's [Silex Simple User](http://www.jasongrimes.org/2014/09/simple-user-management-in-silex/) which might be of use. [UserFrosting](http://www.userfrosting.com/) should meet the first two requirements. I don't know about it's templating system. Could roll your own using [Aura for PHP packages](http://auraphp.com/) . Laravel,Symphony are full size frameworks so they might be overkill for what you want. Wordpress isn't a framework. It's a CMS. Though it does have support for 'headless' use. Can read about it : https://css-tricks.com/wp-rest-api-remote-control-wordpress/ Here's the REST API docs : https://developer.wordpress.com/docs/api/ Your 3rd requirement is going to be a problem. Moving from static HTML to dynamic will always require some effort. How much work really depends on the level of integration and the admin controls added. [Slim Framework](https://www.slimframework.com/) [Silex Framework](http://silex.sensiolabs.org/) 
@Garethp I've just update the structure, follow your idea about Adapter (https://gitlab.com/martinpham/symfony_hexagonal_todo). Please when you have some minutes, could you please help me to check if I haven't made some wrong things? Thanks!
Thank you!
Statamic - [https://statamic.com](https://statamic.com)
&gt; 5) Is there really a use for all the different persistence mechanisms? I personally like different persistence mechanisms for different stages of development. I like to have in-memory arrays for unit-tests, MySQLite DB's for initail development and something different for later on or production environments. But more to the point, I like separating the concern of persistence out so that it's an implementation detail that can be changed at any point 
.. or maybe you could learn programming and application architecture before starting to worship latest hyped framework.
That would probably go a fair way to fixing WP's problems. But in general WP doesn't really follow many established best practices (namespaces, PSR4 autoloading, composer, SOLID). Part of it is their refusal to drop support for PHP 5.2. If they made 5.4 the minimum most shared hosts would upgrade pretty quickly. 
People hate wordpress because it's slow, unsecure and the API is horrible. The require_once are not a problem, there is way more magic in any other framework / CMS. The hate comes from people who have to work with an existing (and almost always) outdated wordpress site and have to make the architecture work somehow.
I'd say slow is the least of the issues. For a system as customizable and extensible as wordpress its performance is good. 
Well, with point 3 I meant that i have a simple html with js website, and i need a simple back-end framework, or even a full framework, in which i can easily put my own html with js and add a few framework function calls, thats it.
From my very own experience : I work for a multinationnal company where each country is independant in their choice of technology, and each need the same type of commercial website (read : 10 static pages, some forms, a few articles, some mails). (strange I know, but reasons) I made the very first website in plain 5 years old style php, then rewrote it in laravel last year. Way better than my old crap. The two other countries made their website using wordpress with an external webdev agency. I worked on something else at that time. The 3 websites are hosted on the same 3 replicated servers (not same type of server, the very same metal piece). Wordpress websites use **500% more ram**, have **at least twice the page load time**, the lowest score I have ever seen in [google page speed insight](https://developers.google.com/speed/pagespeed/insights/). And the most important thing ? **Daily attacks** (DDOS, database intrusion attempts, phishing, remote code exec attemps, root access (to a honeypot \^\^ )). So far, only one succeded (that we know of), and not a critical one, thanks to my maniac and sleep deprived server admin. 100% of the attacks were either directly on the wordpress websites, or from IP logged as trafic in those wordpress. 0 on my custom one (that I know of, agreed). To me, using Wordpress is like going out with a target on my back giving ammunition to hackers. That and the fact that our New York WebDev Agency TM with office around flatiron building was terrible. Sold wordpress "because you won't need us for maintenance, customisable, fast dev, easy to understand"... ALL WRONG. Every plugin is out of date, dev was uber long, devs where shit and only new how to configure plugins, don't ever ask those to do something themselves, management always wanted more money even to start a discussion about what they didn't delivered... At first they outsourced everything but management in India. Bad idea. Not speaking for all indian devs, but those were shitty. We got them to take real programmers in europe. Still not good. Designer branded as full stack dev this time. I patched XSS, SQL injections and the lot myself. Code is still a mess, coz they rollbacked it a month later, by copying an old zip instead. And no git/subversion/anything else than copy and paste. In the end, we got a website 6 month later than expected, with shitty features for half the original price. They know they did shit. God i'm angry talking about it. **TL;DR; I won't ever use Wordpress or consider a webdev agency doing everything in Wordpress. I want real programmer, not plugin installer or designer with a small bit of knowledge about how to install a plugin.**
Thanks * I'm pretty sure I can re-license as long as it's more open. Honestly IDK, right now IDC. AGPL fulfils all of GPL to my knowledge and just adds more covenants on the developers using. * I Have linked to the original KSES, and WordPress (as they have taken up maintaining); but the API is clearly going to be breaking, and it may be some things it does are... less than desirable (it's very rigid). * Thanks for the link. Looks much more mature... I wonder if it's the LGPL that stops WP from using it.
Thank you for the reply, don't you know any open source blogs where I can observe the common things made by PHP how they're done properly? like "Don't trust the user inputs"..etc
It will probably take less overhead for you to get up and running with a new laravel app. My concern is there's a heavy opinion towards Vue.js in the Laravel world. I hope this testing framework keeps to just using existing browser emulation so you can use any JS. 
&gt;communicate between a Website and C# HTTP, Ajax or websockets &gt;I have no experience with html or php So are you running C# or PHP on the server? situation unclear... &gt;Website should recognize it when the c# program sent smth website should recognize? what is the "C# program" trying to do? &gt;i tryed to do it with sockets websockets work fine, you probably did something wrong, just be careful of browser support &gt;i had to refresh the php file constantly :) &gt;after a few seconds my browser denied these refreshes you're obviously doing something very wrong. --- you need to be way more specific to be able to get any help, this situation is completely unclear...
To me it's more about creating a stronger separation of concerns. Having multiple persistence options means that it'll be a lot easier to see when you're coupling yourself to your persistence when you shouldn't be
What is their reason? To not piss off a lot of people?
Site takes too long to load on mobile, direct video link: https://youtu.be/tIX0LaJ5zAo
I [have been using](https://bitfalls.com/en) a small one called [Grav](https://getgrav.org/) and have yet to regret it. Very easy to extend and use, very easy to update, healthy community, bunch of plugins, cute dashboard. Multi-language was kind of important to me, so that helped me decide too.
That's a great example. The best code tends toward clear, simple responsibilities that are permissive in what they accept and strict in what they return. Not only does it reduce bugs and help isolate functionality, but it makes the code base easier for other devs to pick up too.
Thanks for that, but wouldn't this have dependencies on symfony components? Sorry I am away from Pc so asking via Mobile
It's hardly different on another OS/framework...
Well, yeah.
If I can automate it... then ace. Look up the new URL each month and wget it into my app folder, other wise your right. Although there's always the downsides of nightly releases. 0 guarantees that my current set up will work. Few things to weigh up I guess
right but this isn't KSES, it uses very little of kses code (regex's and tests as both are accomplishing similar tasks). I mean if you think it's a problem I don't mind renaming it and removing any of their code. I'm quite sure you have the licensing backwards but like I said IDK, maybe I do.
I should've mentioned that I'm pretty sure Docker and Vagrant are interchangeable with this configuration. I've only been able to get it working properly with a PHPStorm generated Vagrant box. 
Not sure why this is downvoted, it's a valid answer. Once you're asking for authentication your website ceases to be "simple". Laravel includes what OP needs. 
Feel free to ping me when you've fleshed out your domain and application layer with some code, I'll happily review it. It's pretty quick and easy to do if you focus mostly on those bits.
https://github.com/Codeception/Codeception/issues/3888 I created an issue here. The link to the repo where you can reproduce the issue is https://github.com/Faryshta/codecept-depends-bug/blob/master/frontend/tests/functional/DependsCest.php
I think we're going to see alot of focus on admin scaffolding for Laravel. We have, what, 4 options now. It is quite empowering.
&gt; we use pimcore How do you like it? I wouldn't say it is obscure, but it is rarely talked about. It is based on Zend isn't it?
This is interesting to know. I do think the switch to Symfony is good and will get better, but you rarely hear of anyone suggesting it for blogs, just really big sites for government and university. Has it been moving in that direction, sort of taking Joomla's spot?
The only issue with Grav is that the admin doesn't let you do everything you can do with code. It is good for sites and devs, but less so for power users. For a generic blog it is fine. I really like it though. Theming is easy enough and the code seems solid. The only reason I'm considering something else is to experiment.
My biggest interest in Processwire comes from trying to get my coworkers who know WP on it. Processwire seems to be really usable for people with basic programming knowledge, but who aren't devs? Do you have any experience or perspective with this? 
Still interesting. I may take a look at thins, golang has been on my *to learn* list forever.
Oh. Well if it isn't KSES then it shouldn't be a problem. Altho at that point it seems like it might be better to say that you are using the x license instead of re-licensing it. Well, in any event, good luck with your project!
Ah yes. I forget that Wordpress was released......13 years ago according to wikipedia. Damn.
It's really great :) the backend and object handling is simple but powerful. Yes it's based on Zend but I like it 
Do either of the caching interfaces supply a method for performing atomic reads &amp; writes?
The hate comes from al the reasons WordPress cannot let go of the past.
There are a number of methods which return a boolean indicating whether or not an error occurred. However there's no way to get *what* the error was. This makes the interface feel very C-like, and not at all like a modern object-orientated language. Why do these methods return a bool, rather than throwing an exception on failure? In addition, `get`, `getMultiple` and `has` don't return a bool, so there's no way of indicating an error in the same way as the other methods. As a separate issue, the `$ttl` parameter to `set` can take an `int`, but there's no indication of the units of this value in the doc comment. What happens if a negative or zero interval is given? Is an exception thrown? What?
Video warning. Who wants to spend half an hour watching something that would take 5 minutes to read?
You are kind of late to the party with these comments. The PSR has been long in discussion and review already and that was the time to voice these opinions.
Thanks for your suggest, actually ``` $this-&gt;adapter-&gt;setModelClass(Task::class); ``` was my "hack" because I have no idea how to write Doctrine adapter for all repositories. I also thought about creating adapter for each repository like you said, but it will be a lot of things to be defined (each entity will have 1 repository and x adapters)...
What's up with posting and delete this [7 hours](https://www.reddit.com/r/PHP/comments/5llrve/the_phpixie_cache_component_psr6_and_psr16/) prior to resubmitting, /u/dracony?
It's fantastic for that level of programming experience. The API's syntax is specifically modeled after jQuery so it's easy to get the hang of it and go by referencing the documentation and the API cheat sheet. When I first played with it I had a basic multipage site done in about 3 hours. I love the flexibility in customizing the manager and how easy it is to tie that in to the page. In the end you can go complex with templating or go to an MVC pattern- or just code out a static page and switch out content areas with php that pulls content from the CMS. This is the cheat sheet, and that's all there is to it. [Processwire API Cheat Sheet](http://cheatsheet.processwire.com)
Fast answer, I'll complement what I said [here](https://www.reddit.com/r/PHP/comments/5llolm/are_the_require_once_in_wordpress_the_reason_of/dbx6b3b/) ----- &gt; Sounds like the agency is the issue here, not WordPress. It could've been any CMS (or even a framework) they used, but if they're incompetent then you'll end up with the same result. More incompetence in WP shops than in regular ones, according to my exp and my dev friends (except the WP dev black sheep friend, but we like him anyway, and he is good). ----- &gt; Most WP hacks don't result from WordPress itself, it's from poorly written themes and plugins from bad devs. Granted that attack attempts are more common, but that's just an unfortunate side-effect of popularity. It's no different to hackers writing more viruses for Windows than macOS or any other OS; it's just more popular. Like I said in my answer to /u/rustbelly : Yup. Wordpress IS popular, so whatever I do I'll have to deal with those liars. PITA. ----- &gt; The main failing of WP is the lack of standards. No PSR, no composer and silly things like functions printing instead of returning - programming 101. Nothing to add. I plaid the fifth. ----- &gt; Still a great tool for certain jobs, but totally agree that if you need more than 1 or 2 basic plugins (acf and wordfence) then there's a good chance it isn't suitable. Maybe. Can agree on that. But they used a lot more than 2 or 3 plugins...
I haven't forgot about you buddy, I gave you credits here - https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-16-simple-cache-meta.md#53-contributors
Guess it's time to make `\PSR\SlightlyBetterCache` PSR-16.1
Sadly, I think you increase your odds of crap work significantly with wordpress. Not because it is impossible to do a good job with it, but because everyone and his dog is marketting as wordpress dev. Like I said, I can't blame the software for the users, but I can choose not to use the software because of the users.
No. The usage of require_once() is among the least terrible things about WordPress.
I saw it! That's really nice =) 
How do you make an application wide error handler?
I agree that the boolean returns are a bad idea, since they encourage implementors to return a boolean instead of throwing an exception. However I suspect the creators don't intend the exceptions listed for each method to be exhaustive. Only exceptions related to the signature (i.e. `InvalidArgumentException`) are listed, since other exceptions would be details that might vary between implementations. The authors want implementors to throw a `\Psr\SimpleCacheCacheException` on error. TTL is in seconds, and a negative or zero TTL automatically expires: &gt;The TTL is normally defined by an integer representing time in seconds, or a DateInterval object. &gt; &gt; [...] &gt; &gt; If a negative or zero TTL is provided, the item MUST be deleted from the cache if it exists, as it is expired already. 
Hi guys! I'm about to start writing my first API and I've decided it to be not CRUD, but RPC. Currently, I'm looking for RPC router or framework. So, if anyone have any advice, I would very appreciate it. Thanks!
Nice. Having recently written library code that uses the existing cache interface I really appreciate the simplicity of this. Nice work!
&gt; As of 1st January 2016 I'm happy to announce that Psst, its 2017 :-)
Use Asp.net mvc, or just ajax. dont know why you posted in php
Aside from a catch-all try catch block, you could also use these. http://php.net/manual/en/function.set-error-handler.php http://php.net/manual/en/function.set-exception-handler.php
Done! https://github.com/fruux/sabre-cache
It's that douchey attitude that keeps me away from caring what your opinion is. How can you take someone's really good thought out response and basically just say, "too bad". It's unacceptable for someone in your position. You honestly think that everyday joes who aren't in the meta scene know about the feedback and voting phases? Most of these PSRs aren't widely known until afterwords, usually due to the varying time to get into the accepted/final voting form. I understand that it takes awhile and we support the PSR on our own free time, for free. But when you're managing something that's basically a developers QoL, you should be more receptive to developer feedback.
It has it's own utility for setting things up, because it's so complicated you need to automate the framework changes. If you don't know a simple one, that's fine, but don't be dense.
[removed]
Don't PSR's evolve over time as needed ?
Wouldn't that be more of an implementation issue?
Feel your pain 
Sure, but not every two years, right ? psr-16 was needed to add simplicity to psr-6. But I dont see any other cache psrs coming soon honestly.
If you read it again, you'll see that I asked questions. I imagine other people reading this PSR for the first time will have similar questions. People like yourself can provide answers to these questions, if you're more in the know than I am.
 Having 50 controllers doesn't follow you need 50+ services and repositories. There's some unspoken context here, or you may be making assumptions based on a particular framework's approach or weaknesses. I haven't said that is has to. All I said it could be the case. Yes, there was some exaggeration involved to prove my point. Even having 60 controllers and just one service and instantiating everything for every request is stupid. The main message simply was: Instantiate only what you really need. I guess we can agree on that one, can we? I thought you were trying to point out to inject each and every dependency like this when you said "by taking it in during construction". I did not get that your whole point seems to be to use a composable factory. class ControllerExecutorMiddleware { public function __construct(Controller1 $c1, Controller2 $c2, ...) { } } I guess we can agree that injecting 50 controllers - just to refer to my previous example - is probably not the best idea? To go further I think we need to distinguish 2 use cases: 1.) PSR-11 within the application layer 2.) PSR-11 within the framework layer As for 1.) you basically should never inject a container / factory / service locator into your application classes. Always define your dependencies explicitly. Because even though in your example you injected a BlogConfig which exposes 3 services it is not clear from the outside which of those service are actually used. Try to pretend not being able to look in the code of the Blog class. Try to guess the dependencies just from the method signatures. Try to always to explicitly expose your dependencies. And guess what, this is is the basic idea of DI and IoC. There is no need for you to interact with a PSR-11 container in your application layer. And guess what, you explicitly type-hint your dependencies, thus you exactly know what is needed for your code to run. When you define that your Blog class needs ServiceA and ServiceC you know exactly what you get - well to be precise you will "something" that implements or extends both services but in the end you do not need to care. As long as the contract you tried to establish is fulfilled, everything will work fine. Type-hinting is important, that is what led me to create [Disco](https://github.com/bitexpert/disco) because I see the lack in most DI container configurations when it comes to type-hinting. Since most DI containers use a non-code language to define the dependencies and their relationships you need to "build" the container first and then try to access each and every component to be sure that you do not run into type errors. Even the DI containers using PHP code as the main configuration language often just use strings to express the dependencies, thus you also can't be sure if all types match unless you fetch the instances from the DI container. As for 2.) this is what PSR-11 actually is for. PSR-11 allows us to use my favorite DI container of choice with a framework or a component that I want to use. So the framework layer will call the get() method of the PSR-11 container and yes in this case the framework do not exactly know the type it will receive which is a problem in fact. But to be fair speaking of a bootstrapped framework you grab your middleware from the DI container, the controller as well as the view/template. Adding 3 simple instanceof checks probably won't kill anyone. If you would go the interface way as you described it for the framework layer I guess that you need to have in an in-depth knowledge of the framework itself to know where is which dependency needed and need to provide quite a bit of glue code in your application layer to connect all the bits and pieces. That might hurt the adoption rate of the framework itself because it is not "easy to use". 
fixed, thanks. Habits y'know ;)
It's part of http-foundation: https://packagist.org/packages/symfony/http-foundation
Here is how I view the blogware landscape. If you have a very simple blog, only needing a single model or content type, with some tagging. WP is probably the quickest, and cheapest to run/maintain. The second you start talking about multiple content types, and slightly more complex lists and index views, you should look at drupal. The great thing is it manages it's entire data model, and presentation from the front end. All you need is to put some theming on it. For a few extra hours you can have a fully functioning content workflow with roles, states, permissions etc. The downside of all of that is Drupal, especially 8 REQUIRES a professional in it's lifecycle. You might not need to spend thousands of hours, but you will want them to set up proper configuration management, and set up the permissions correctly. I don't know if joomla ever, was filling that niche, I've only seen one, busted as jooma set up so I don't know if that's a framework or developer issue.
Why not just send a pull request? 
Just learn Laravel. Some will say it's not "simple" but it really is. Once you have login you have sessions and storage and you have a bit more than a simple app.
Declaring invariance would not violate LSP, but it's still unnecessary. You are arguing for it based only on your `StrictKeyVal extends KeyVal` example, which violates LSP.
Any reason this isn't merged back into the original project? It says they accept PR's
Instead of trying to remove the active sessions it might be easier to just store the time when the global logout command was issued in the database (in the user table for example) and then check that against the log in time (that you keep in the session) for each request and force the users to log in again if necessary.
Regardless of the merits or pitfalls of this specification: [everyone gets an adapter \o/](https://github.com/Roave/DoctrineSimpleCache)
My main issue with Wordpress is that it's a hassle to setup a good workflow with git, dev/staging/production and automatic deployment to autoscaling services like AWS Elastic Beanstalk.
I write a lot of code, and I primarily work on WordPress.. :(
I started to clean up the code, I'll send you a PR when I'm done ;)
stuff like this make devs hate wp: https://github.com/WordPress/WordPress/blob/master/wp-includes/load.php#L647
EDIT: tried to make a joke, but it was kinda stupid, so meh
I had no idea JetBrains is actively developing their own programming language: Kotlin: Statically typed programming language for the JVM, Android and the browser; 100% interoperable with Java It doesn't sound bad at all, and I'm betting the IDE is terrific. http://kotlinlang.org/
I apologize in advance for my cynicism - PSR-6: Overengineered, no one likes it - PSR-16: Second attempt, now without Doctrine\Cache, the most widely used cache implementation Neither of them solves the hard problems, may even hinder solutions for implementors: - Cache stampede (the item just expired, you say? Let me request its regeneration a thousand times) - Tag-based cache invalidation (eg. invalidate all cached data regarding users foo and bar) - Atomic replace - Asynchronous delete (Redis supports asynchronous [UNLINK](https://redis.io/commands/unlink) as an alternative to synchronous DEL since version 4)
IMO WordPress gets a bad rap because it has an antiquated code base and as a community they support PHP versions long outdated and no longer supported. Also third party libraries are shoe horned into core (ex encryption library), which makes working with WordPress miserable.
Can't say for blogs, but for content-heavy sites, Drupal is really fantastic.
I disagree. But if you want Laravel style, at least go with Lumen
wow. had no idea.
I've used both. I would not agree. Performance differences are minimal for non API or analytics style apps where absolute TTFB differences are critical. Lumen, or a stripped down framework, is not by default better. Simple is not the same as stripped down.
Is the wordpress core actually insecure? I got the impression the security issues these days are caused by plugins. 
&gt; `2. Restrict PHP Information Leakage` &gt; `3. Disable Remote Code Execution` Thank *the gods* they prioritize `expose_php=Off` above disabling RCE bugs, and even moreso that they imply disabling these features will disable RCE bugs entirely. Okay serious talk: If you're using PHP 5 make sure whatever you do with `open_basedir` you make this change: - open_basedir="/var/www/html/:/other/paths/" + open_basedir="/var/www/html/:/other/paths/:/dev/urandom" This will save you headaches when one of your dependencies includes [random_compat](https://github.com/paragonie/random_compat). Also: PHP security has more to do with how you write code than which configuration settings your sysadmin enables.
You see so much complaining about Drupal, it is good to see someone put it in rational terms. The need as you said, for a professional in its lifecycle, makes a lot of sense. 
I agree with you that Simple is not the same as stripped down. But the amount of stuff you have to do and learn and keep under control on Laravel is bigger when compared to Lumen, at least if you're only going to add a small amount of functionality. Otherwise you might generalise this same concept to say things like "Use Zend2 or whatever the most complex framework is" for simple stuff. Simple is simple. It's having less stuff to mind.
That's my outsorcing experience all time every time: **Nothing but a complete wreck**.
&gt; 2) safe and easy work with databases (need to execute only selects and inserts), Afaik you regulate this outside of php by assigning rights to the mysql user of your DB.
&gt; Even having 60 controllers and just one service and instantiating everything for every request is stupid. The main message simply was: Instantiate only what you really need. I guess we can agree on that one, can we? We did from the very beginning. &gt; Always define your dependencies explicitly. Because even though in your example you injected a BlogConfig which exposes 3 services it is not clear from the outside which of those service are actually used. It uses the three services defined in the interface, can it be more clear at all? "BlogConfig" as the name suggests, is a part of the Blog component, not some generic interface outside it, which is precisely my point. &gt; Try to pretend not being able to look in the code of the Blog class. Try to guess the dependencies just from the method signatures. I'll look at the method signature of Blog and see it needs BlogConfig. I'll look at that interface and from the method signatures realize I need to implement a factory producing ServiceA, ServiceB, ServiceC... Just because it's in an interface, so it can be lazy, doesn't render us suddenly unable to comprehend what we need to do. It's quite basic, so I don't understand the argument. &gt; Try to always to explicitly expose your dependencies. And guess what, this is is the basic idea of DI and IoC. There is no need for you to interact with a PSR-11 container in your application layer. I think I'd need a code example because so far this doesn't connect logically. Here are the statements: - We should always explicitly list dependencies in our constructors. - We shouldn't explicitly list dependencies, or they'll be created, even if not used in that request. - We should have a standard for containers, so everything can interact with it. - We should never interact with containers, it's some framework detail. All of those conflict with each other. Furthermore the separation of "framework" and "application" doesn't make much sense because "the framework" is an **application framework**, it's the foundation of your application. Outside your application, I won't see "oh, a framework and an application, two distinct entities". I will see "oh, an application, which if I dig into its implementation, happens to use this framework". So then *who am I giving the container to* in your application? *Where are the dependencies declared for me as an application instantiator*? Questions with no answer so far in the PSR-11 solution, which my code answers quite clearly. &gt; So the framework layer will call the get() method of the PSR-11 container and yes in this case the framework do not exactly know the type it will receive which is a problem in fact. But to be fair speaking of a bootstrapped framework you grab your middleware from the DI container, the controller as well as the view/template. Adding 3 simple instanceof checks probably won't kill anyone. So static typing is important, but actually it's not important? Which one is it? I demonstrated an approach so simple towards *typed, lazy dependency providers*, that I could include the *entirety of it in a code sample right here*. The contract is explicit ("I need a factory that can give me on demand ServiceA, ServiceB, ServiceC"), and it's lazy, not eager. I thank you for responding to me at length, but it's as if your long answer doesn't address anything of what I'm asking about: - Why do we need PSR-11. - How would a generic container with "get()" actually explicitly declare to an outside creator of the module/app which dependencies are needed. It seems as if no attempt at all to an answer to the first one was made, and the answer to the second is "we should always declare dependencies explicitly, but never mind we won't do this, we'll do instanceof checks at runtime". &gt; If you would go the interface way as you described it for the framework layer I guess that you need to have in an in-depth knowledge of the framework itself to know where is which dependency needed and need to provide quite a bit of glue code in your application layer to connect all the bits and pieces. Where is all this coming from. What I wrote in my sample is exactly what you need? "I'm Blog. I need a BlogFactory providing ServiceA, ServiceB, ServiceC". You need to know **precisely nothing** about the Blog's implementation, or "where is which dependency needed". Where is this honestly coming from?
Yes. Fair enough.
Assigning rights in db is just a little part towards safety, it doesnt prevent sql injections and other kinds of hacks.
found a nice redis implementation https://github.com/naroga/redis-cache
I need java, but don't need java. I just want to over complicate a simple hello world app by enterprising it. LOL.
Main reason - legacy support. At some point CI 2 was big in the framework world. The old company (EllisLab) put it in the state of limbo when the framework was at the high of it's popularity. This was the big blow to the framework. For several years they made only security patches. After the limbo status was dissolved, they had to choose - delete everything so far and start fresh, or tide the existing code. They didn't want for the CI to go into oblivion, so CI 3 was born. It was more a security update, then evolution of the framework. They know that a lot of things are bad and out of date, and that is the reason they are rewriting everything for the CI 4. CI was my first framework, and I have nostalgic feelings tide to it, so I hope they will make a good framework with a long life, with the version 4. But yea, there is no reason to use this framework in the real work environment. Maybe as a tool to get the very basic idea behind MVC (it have a very small learning curve), but even this is quite questionable in today state of PHP.
I have a script that already does this. var gulp = require('gulp'); gulp.task('default', function() { console.log('Your code is shit.'); }); 
Slightly off topic, but one thing to note, for best performance is that if you're using the default sessions handler (IE: It handles sessions by file-storage), it's best to do all of your session retrieval and storage at the beginning of your request, and then call [`session_write_close`](http://php.net/manual/en/function.session-write-close.php) so that it can free up the file lock earlier, so it doesn't block other requests.
And Laravel's is pretty simple too. A couple of commands and routes does it. 
Why the fuck would you want to install npm to just run a few executables? If you're using Jenkins or Travis or any other CI tool then you can just as easily hook it up in one system. If not, write a simple shell script if you're too lazy to run two commands. This is just overkill in a box.
Hey that's pretty awesome, thanks for sharing. As a side note, do you know of any PHP libraries that send HTML via SSE, HTTP, or websockets to the clients and the clients calculate the diff and update? I've heard of other languages getting these libraries, they mostly advertise "send dynamic updates without writing JS".
u/pmjones can you clarify or confrim this for me; I'm really curious by this but want to make sure I understand. Is the goal of this to bring components of PSR7 into the PHP core? Or rather bringing the concepts of PSR7 into the PHP core? From what I'm seeing this isn't PSR7 as it doesn't implement the same interfaces, but it does a lot of the same things; right?
&gt; do you know of any PHP libraries that send HTML via SSE, HTTP, or websockets to the clients and the clients calculate the diff and update No, but it sounds like a challenge. :)
Right but protecting against sql injection has little to do with "only selects and inserts" right? As in, it should be bullet proof against all sql injection.
&gt; Generally, if you're doing "modern web development" then keep things separate, otherwise it just feels like your (impersonal you) approach is "just wing it" instead of doing proper research and applying proper tools for the task. Yeah they're seperate, I have my PHP in my `.php` files and my JavaScript in my `.js` files. &gt; There's no such thing as "cryptic errors", it's only cryptic when you don't understand it. If you don't understand it - dig deeper, try to understand the issue and fix it. "I don't know why, but this seems to work" is not a good strategy when answering the "Why?" question. No, cryptic errors are real. Cryptic errors are when installing seemingly simple packages require you to become a Red Hat Certified System Enginer to actually get it installed. Cryptic errors are when the error message itself is 3 tangents derived from the actual issue. Cryptic errors are the ones you google and get zero results from. Cryptic errors are not caused by developer inadequacy as you so rudely asserted, they are the error message does a really bad job describing the error. &gt; It's Googled "how to execute command in shell script" and came up with this. Just sayin'. I'm sorry if that sounded too harsh, but the amount of "just google" type of questions, people missing the point of KISS or just blatantly refusing to think is astonishing. Also, this is the internet. :) None of that shit applies. I shared a nice article on how to X with Y and you blew your shit over somebody doing something differently than you. That was very egocentric and uncalled for. When you have opinions or recommendations you should be sharing them politely instead of randomly freaking out and poisoning the community with this disgusting toxic behavior. You are arrogant and rude as fuck. 
I love the fact that `expose_php=Off` is a security risk by exposing the version, but anyone can still find the version using curl. 
Don't get me wrong, I talk about areas of drupal I hate every day. And I'm constantly trying to map out my process for deciding if a blog/cms app is too complex for drupal and will be a hinderance later on in the project. Config management is hellish to say the least. Doing a diff of config loaded in from a database, and in code is insane to say the least buuuuut, at the end of the day, I can still build you a site with full permissions, workflow, multiple levels of categorization, and dynamic indexes in a half day (given a finished E-R diagram). Not an ounce of custom code there, just knowing the HIGHLY specific drupal recipes. edit: at the end of the day my question is this, at which point does drupal stop gaining me time by skipping things like menu router, models, back-end interface/ui, etc; and I start loosing time, for things like writing views_plugins which are a visual sql builder for drupal. Those things are a 5 minute thing using eloquent or some more traditional code based query builder. edit 2: don't even try to start an oss project on drupal as well. The domain knowledge to participation in drupal is highly limiting.
i just recently found out it can compile to JavaScript: https://kotlinlang.org/docs/tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript.html
In addition to what zeraific said, you should disable errors in php.ini on your production server. That way, even without an error handler, nothing will be displayed to the end-user.
Right, but `string[]` tells you a lot more than `Fluent`.
Well let's be honest, it just tells you a *little bit* more. PHP's type system being undercooked as it is (even with PHPDoc enhancements on top of it), you have to rely on the comments describing in plain English what's in the return array. Now when they *don't*, that's the real crime, not Fluent per se (despite Fluent is 100% superfluous).
Ahh, I didn't realize that. I'll update my post since the idea still stands as a possibility.
Right, but OP's claim was that we should upgrade because PHP 5.6 is *only* getting security updates.
Well, it's time to start considering an upgrade, because that's the last step before EOL. These things usually have to be planned. If you wait until EOL to start planning, then you'll be running your server on potentially insecure software for quite some time.
You're really buying into ``string[]`` comparisons, but how would you typehint an array that contains keys "foo" (string), "bar" (integer), "baz" (boolean)? The array syntax in PHPDoc covers only a tiny subset of possible array configurations. For the rest... it's just "array", or "Fluent", it doesn't matter. Additionally, although static analyzers could do something with ``string[]`` I've not seen them do anything with it, only object types.
Mixed feelings on this! Is it: a) Meant to make lives easier and things more performant for those maintaining HttpFoundation and PSR-7 implementations b) Be something that will deprecate those above c) Advanced level trolling If it's a, I think it could be a good thing, but I'm not super excited about it being around, especially as said frameworks will probably have to continue supporting PHP installations that don't have those objects around. I'd rather see further language improvements that I can use in *my* userland code.
True, :P bigger fish to fry
An initiative to bring something like PSR-7 to core is a great thing. Except that it would make a lot more sense to actually *be* PSR-7. A lot of user-land code is written around PSR-7 now, since the community has adopted it's own standard since there was none. And it's a good standard. It would make a lot more sense to try and get *that* in to core than to get the entire community to shift towards your version
It has everything to do with it. You dont want someone ending your sql query with a little trick and doing their own dirty stuff in your database. I meant i dont need for that framework to support full blown database manipulation as i will be doing only simple data selection and insertion, but i still need full safety.
Thank you for your help, just one more thing about any resources to learn more about sessions and cookies (for authentications)?
https://bitbucket.org/product/pricing/upcoming $2 a month per user gets you 500 minutes
is it portable ? 
https://github.com/php-enqueue/enqueue-dev/tree/master/pkg
Very nice. Any plans to support other transports (redis, SQS, etc)?
Without PSR-7 support, as mentioned in a similar post before this one, this is more than one step backwards ðŸ˜¥
 * Installing something like https://www.rfxn.com/projects/linux-malware-detect/ (Linux Malware Detect) or * Having a firewall that restricts or stops Apache/PHP from being able to initiate outbound http or smtp connections * Using SELinux to restrict what PHP can do, rather than relying on safe_mode etc. * Or just making sure you're running a supported and recent PHP version.... ... 
Everything on Github and MIT licensed so you can take it and do what ever you want What do you mean by portable?
This looks awesome, thank you for your hard work and publishing this!
Both AMQP and STOMP are supported by RabbitMQ. hence nothing prevents you from using Enqueue with RabbitMQ broker. There is a good example of how messaging could be used. I played with fos:elastica:populate command and was able to speed up it at least 5 times https://github.com/FriendsOfSymfony/FOSElasticaBundle/issues/1186.
Dunno, the best I've found so far is "we disable it because some guide said to long ago". Maybe it made sense in some much-older version of PHP in a shared-hosting environment?
Most likely the arbitrary file access, but fopen/fread, file_get_contents, etc have the file access too, so that argument is pointless. 
But PMJ hates PSR now that it disowned him :\^) To that end, this is a smart play by him. By ignoring PSR-7 and getting his own version integrated into core, more people will adopt his solution just because it's built into the language, and insodoing, he fights back against PSR. 
I wish I had this article a couple months back. You should add a blurb about `yield from` to it.
I mean C99 clean 
You could also just make a listener and listen to endTest. IMO cleaner than trying multiple inheritance to execute some logic that your test shouldn't care about.
I don't think it's avoidable when you're adapting diverse caching strategies to a single interface. Redis isn't Memcached isn't PHP arrays isn't filesystem caching.
I get what you mean by this, but you're mixing PSR (a concept) with PHP-FIG the organization. PSR simply means PHP Standard Recommendation. Anyone can create a PSR with anyone else in the PHP community (or their organization), but PHP-FIG is the first organization to make the concept mainstream in the overall PHP community.
Thanks for the suggestion! It sounds great. People are welcome to tweet me their tips, or do you think it would be better to have an actual form on the site?
&gt; The recommendation to provisionally ban chx from DrupalCon What bullshit is this? ", the CWG has unanimously voted to recommend to the Drupal Association that you be banned from attending future DrupalCons, including associated code sprints" What's "provisional" about that?
This is a very simple login form in PHP: http://stackoverflow.com/questions/19531044/creating-a-very-simple-1-username-password-login-in-php Once you have this working you might want to get login and password information from database instead of hardcoding it.
I can see you put a lot of thought and a lot of work into it. Congratulations on the release.
generates are for cucks
It is pretty useless as it is now. Essentially you get subset of phpmyadmin's table creation interface and the result is yii2 db migration (php) script. What it promises: &gt; * No more hand writing complicated migration scripts. But this struggles even with easy ones: can not even link 2 models together with foreign key. &gt; * Design complete database schemas in seconds. &gt; * Our intuitive UI helps you to stay focused. Working in the UI is just as tedious and timeconsuming as it is with phpmyadmin. Try HeidiSQL to see what is pretty good on that matter. 
That's a nice first step. There will be criticism. Embrace it to improve your project. :)
Murze.be is posted ridiculously often in this forum, often with what i'd consider to be blogspam.
Thanks, I really appreciate your kind words. :)
Yes, I conflated PSR and FIG, and everyone understood. Do you want a medal for your pedantry or will Internet points suffice?
Going from memory, there were flags and taxonomy features that you could set in the markdown files, but not from the admin. It wasn't much, but there were a few things, and it was a bit frustrating. Maybe it is has changed in the past few months. I figured it would have been a pretty simple fix, but I never found the time to investigate submitting a pull request.
Ok thanks for the response.
That was just bad wording on the author's part. `expose_php=On` sets the PHP version info in the HTTP Headers of the response, allowing you to view them using `curl -I http://your-url.com`. Setting it to `Off` means those headers wouldn't be there and you wouldn't be able to tell it was a PHP application. Edit: Prior to PHP5.5 there was also a way to use the query string to print out a PHP logo when this directive was `On`. http://php.net/manual/en/ini.core.php#ini.expose-php
[removed]
&gt; That is an interesting gotcha but it must be very configuration specific. I would think the DB driver/abstraction would be able to know when that situation occurs and opens a new connection. Not at all, because that wouldn't be side-effects free. You might be in a transaction, have set some state on the connection and so on. &gt; Iterating on a large result set and doing other queries is quite common. Unless I'm missing something. Most likely you haven't noticed query issues, because PDO tends to buffer results by default (which means you're not saving RAM for large result sets by iterating with ``fetch()``).
I've used it with unbuffered set on the connection. I think down below we create a new connection for that (as you mentioned). It's been a while since I looked at the DB abstraction. In any case the consumer shouldn't be concerned with open connections behind the iterator and when an iterator is needed on a large result set, above precautions can be made. I may think to include the warning in the article, but seems it is a bit esoteric.
It's esoteric until it bombs ;-)
Do you have an example of this?
It basically gives an invite to exploit your site as many softwares are based on ini configurations.
Oh Really?
Thanks for sharing your knowledge :)
I got around to benchmarking on PHP 7.1 on a 2GB dual core DO server. Hitting a route that prints "Hello, world" in production mode (enables some caching within the framework) consistently yielded ~950 req/s. 
Comparing it against https://github.com/php-amqplib/RabbitMqBundle what does it have that's not already supported. And Why NIH instead of submitting PRas against mentioned bundle. 
Enqueue A LOT better. I used RabbitMQ bundle for three years as a main instrument so I know its pros and cons. I will write a dedicated blog post where I compare both &gt; And Why NIH instead of submitting PRas against mentioned bundle. RabbitMQ bundle is tightly coupled to AMQP and RabbitMQ. It is hard to solve by sending PRs to their repo. This coupling makes functional tests a bit harder to write than it should be. 
Looks very promising, will try it some time. Good job and thanks! :)
Functionality that we try to abstract, hide and keep away every single time we build even the tiniest router/http-based framework.
https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html
Dig through the source code for Wordpress. Then maybe you might understand. Wordpress is held together with toothpicks and duct tape and bad practices that pervade the code and gets amplified by the quality of the plugins. Wordpress is an example of an open source project that accrues technical debt, becomes a victim of its own success, caters to a non-technical market and becomes paralyzed to fix the technical issues and architecture as a result.
I think any article about generators would be remiss to not mention [`nikic/iter`](https://github.com/nikic/iter), which makes working with them much more pleasurable
`post_max_size=1k` is *tiny*. It means you can't upload files larger than 1K in your forms, which in today's terms is hardly useful. The recommended memory limit these days seems to be 128M. 30M is too small for big apps like Drupal and WordPress.
tweet should be sufficient, maybe promote it on the start page. 
Ah alright so the class i did was a simple model, Thank you so much i was really confused.
I use PHP for CLI scripting quite a lot. It's almost more usable for this than it is for websites. Its default configuration is sensible, there's no time limit by default. The memory limit is still there, though, but you can adjust it as necessary.
It seems a bit weird for the language to implement a PSR. A PSR should be a recommendation and not a requirement therefore hardcoded language support seems a bit odd.
An interface is an interface regardless of where it is defined - whether php-src wants to incorporate it or not is a different question. Also, a language is just a set of lexemes and AST evaluation definitions. PHP comes with a standard library: there's no issue in importing interfaces into it, especially if they are proven to be working well. Most PHP extensions (bundled ones) are actually interfaces imported from existing C-level libraries into PHP class definitions, so this approach suits well, except that we're not importing from C, but from PHP.
If my server shuts down unexpectedly, do I lose anything in the queue at that time?
Another gotcha I find interesting is when you mock out something which returns a `Generator`, and you want to yield an empty set. As there is no syntax for `yield nothing` - ie this will throw an error: function foo(): \Generator { }; you need to fool PHP into thinking it *could* yield something: function foo(): \Generator { if (false) yield null; }; 
 &gt; PSR-7 implementations could easily wrap these Which is what we don't really want: more and more adapters that fail in adapter-ish ways.
Looks OK to me. - Some error messages will go unnoticed, the deprecated errors for example. Why not track E_ALL, but specifically log the full stack trace for specific error types? - If you are using monolog, do note it already has a stack trace log functionality. 
If it's just you, then use whichever scripting language you are comfortable with. If other sysadmins will be accessing the box and performing tasks, don't assume they are comfortable with or know PHP. (Bash scripts have been around forever and a sysadmin who can't handle them isn't worth their weight.) Also, bash, Python are available by default on Debian, PHP is not. Out of curiosity, what specifically don't you like about Python? 
https://phpunit.de/manual/current/en/extending-phpunit.html#extending-phpunit.examples.BaseTestListener.php
I've used it in the past for local scripting, mainly due to rest of team being comfortable with PHP and I don't want to be the only one having to deal with looking after the scripts :) Built various things from log parsers, DNS checkers and other bits and bobs.
In my experience posting under discovery thread does not generate any noticeable exposure or conversation as posting as a separate topic. Most authors want to showcase what they were working and therefore going for the top post anyways. Perhaps if this thread would sit there for "month(s)" not week it could give more mileage and would be sensible for project advertising. Finally, consider including link to "Previous" discovery thread, which should let people find older posts easier, alternatively some sort of aggregator for collecting and creating "newly discovered" projects in a categorized way and presented in a way which others can easily skim through in search of something interesting. 
Depends on your OS and goal of the script. I found bash a lot more sensible for the CLI than PHP, simply due to the functionality and speed.
&gt; Some error messages will go unnoticed, the deprecated errors for example. Why not track E_ALL, but specifically log the full stack trace for specific error types? It was my understanding from the docs that as long as I return false the normal error handler will take place and if you are using error_reporting with E_ALL or E_DEPRECATED it will still come through http://php.net/manual/en/function.set-error-handler.php &gt; It is important to remember that the standard PHP error handler is completely bypassed for the error types specified by error_types unless the callback function returns FALSE.
I use php scripts for cron jobs, deployment, migrations and so on... PHP shell scripts running on linux, mac and windows. You can even (x)debug php scripts. I'ts easy to create logfiles and query a database. Calling a php script is very simple: php myscript.php Examples // disable time and memory limit set_time_limit(0); ini_set('max_execution_time', 0); ini_set('memory_limit', '-1'); // check if running as sudo if (posix_getuid() == 0) { echo "No sudo\n"; } echo "Hello php script\n"; 
I was thrown off initially by you calling your error handler "exception_error_handler". There's such a thing as "exception handler" in PHP which is distinct from "error handler" so it's best to remove "exception" from the name, as those are unrelated to the handler you're writing. Other than this, the code looks ok, but I'm not sure sure why you need to manually log specific types of error levels, when PHP would do this automatically if you set "log_errors" in INI (or runtime) to true.
I've used it for limited scripting, and it works quite well, but like many here, I would consider bash first.
Or start your script with #!/usr/bin/php &lt;php then call it like a shell script ./myscript.php
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
PHP can def do the job. That being said, some local scripting in another ubiquitous language might be beneficial. For example, it's in part how I learned Python - I decided to do some text/csv parsing in Python instead of PHP one day years ago.
And coming from php did you enjoy Python? I've not taken the time to learn it, but just looking at the syntax gives me a headache. Would you recommend giving it a shot?
But this will only work under Linux and not under Windows.
Yes I'm also using this. Works wonders.
Should you be working that.out yourself? Is it homework or similar?
Those are binary operators. Learn what `&amp;` and a left bitshift do, and you'll be able to figure it out.
He was editor of PSR-1, PSR-2, PSR-4, and sponsor of PSR-7. That's more useful contribution than any other member of FIG. Literally no other name comes up 13 times on http://www.php-fig.org/psr/. He would have had to be 99%-political for quite a while longer on the FIG e-mailing lists just to reach the productivity of the average FIG member. But he opposed the COC crowd so now we slander him every time his name comes up, as a warning to future thought criminals. 
I'm opposed to the COC as well, so I'm not just on a witch hunt: somebody simply got a bit personal with a vote ;-)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I hate WordPress and PHP but this it was outsourcing and not PHP or WordPress.
oh .. its actually written in php .. so it isn't a part of PHP but just code written in PHP. I get it.
Just a quick note, `max_execution_time` [is 0 when PHP is run from the command line](https://secure.php.net/manual/en/info.configuration.php#ini.max-execution-time), so you don't need the `set_time_limit` or `ini_set('max_execution_time')` lines.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You can do wonderful things with Wordpress (no sarcasm here, genuine thought), and there is some really good programmers that specialise in Wordpress. Yes, I agree. But the amount of bad devs/shops that do Wordpress only because of push button plugin install is unbelievable, as well as the security issues with those guys plugins. Like I said, I can't blame the software for the users, but I can choose not to use the software because of the users.
Pretty much the same experience here as all the other posters. I actually use it more for scripting across multiple operating systems than I do for anything else. 
I do like this too, but I've been running into some memory issues because it needed like 1GB+ RAM for some reason which wasn't availabe on a virtual machine. 
If all else fails, try running something like acunetix against the application. Remember to throttle it down unless you want to DDoS yourself.
I wanted to learn the right way, but nobody linked to me any sort of guide or great framework or fantastic collection of video tutorials. Guess I'll continue to indent with a tab and 3 spaces and cram as much PHP into a single line as possible. Classes smasses!
Wait, you don't love COC? First I ever heard of it, boy next door.
I find the options [-r, -B, -R and -E on the command line](http://php.net/manual/en/features.commandline.options.php) super useful when I need run some quick code (-r) or process some files (-B, -R and -E) direct on the terminal.
How do you use prestissimo? You just run the `global require` and that's it? No config required? How do you know if its working? I timed my `composer install` before and after and it doesn't seem to make a difference.
http over fax.
The file is called "Frost Protection", so I'd guess it's an automatic system for avoiding frozen pipes. 
I'd imagine in this case that the first half is checking that the $return_data1 is not *null*, e.g. data was successfully read in. Using &amp;&amp; would have been better. 
i couldn't even begin to guess what this code is actually doing :)
better to use #!/usr/bin/env php
xDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
My day parameter is 1 in my example see [mktime docs](http://php.net/manual/en/function.mktime.php)
The problem with the GitHub driver that makes it slow is that there will be multiple calls per branch/tag for every dependency when running `update`. This scales really poorly - some of our dependencies have close to a hundred releases and it takes several hundred calls to parse that repo via the API. You can see this clearly if you invoke composer with the verbose flag, ie `composer update -vvv` When using the `no-api` option, Composer simply checks out the repo with `git` and when you run `composer update`, it will make a `git pull` before resolving the branches, so you will always be up to date. The speed improvement banks on that a `git pull` if faster than the GitHub API, which is very true for large repositories. There are no drawbacks that we've been able to identify. I added a link to this discussion in the post. Thanks!
from the docs &gt; 0 is the last day of the previous month
Interview question? 
This would be so awesome. I really hope this gets into the core. :)
This is correct. I was unaware of the distinction. Thanks!
The issue occurs on any month that has the first day the same as the day you are looking for. For example, if you want the first Monday of the month and the first of the month (May this year for example) is a Monday, you will get the 8th. The real issue is that this is incorrect to be getting the first sunday of the month in the first place, see the comment from [Jabba1983](https://www.reddit.com/r/PHP/comments/5m1iyv/getting_date_for_the_first_sunday_of_january_is/dc0389k/)
when it does "ord(fread(...,1))" it's getting the ASCII value of the first character of the output into `$returned_data1`. then your highlighted portion checks if the 8th bit (7th from the right, zero-indexed) is a 1. it's equivalent to `if ($returned_data1 &gt;= 128 &amp;&amp; $returned_data1 &lt; 256)` in cases where `$output_number` is 8. which in terms of ASCII is the cutoff for 7-bit vs 8-bit encodings. http://www.miniwebtool.com/bitwise-calculator/bit-shift/?data_type=10&amp;number=1&amp;place=7&amp;operator=Shift+Left since it's effectively reading the left-most bit of the first character, the goal might just be reading a single bit off of a port, and this is just one way to read a single bit in PHP, through `ord()` and bit math. changing the `$output_number` to a 7 would read the second bit in the response, only. etc.
If you go with php (someone in here suggested GO which I think you really should look at if you like C) you should possibly look at http://symfony.com/doc/current/components/console.html to make life a little bit easier. I don't know if it's appropriate for your use case but I don't like the amount of work I have to put into building an argument parser and man pages. This makes most of that trivial and don't have a huge amount of dependency.
reading a single bit off of a port response. it's definitely somebody's homework...
That seems awfully fast for a timeout ^/s
This is a great response. While I have some basic security training from college I will consider what you say and not bother in this case. I don't imagine that the client has compliance issues, but all the same, I'll leave it to them to let me know what they want changed. Thank you for reminding me that I shouldn't be auditing my own code anyways. 
Because sometimes you can't do the same job with standard ints
&gt; While I have some basic security training from college I will consider what you say and not bother in this case. That's a reasonable choice. If you have the spare time and a desire to learn, I also encourage you and anyone else to do so. It can be fun work. :) Also, you *can* audit your own code, it just doesn't count for anything. It's great if you can implement code auditing techniques into your SDLC, but when an audit is required it has to be done by a third party.
If you want a very comprehensive (althought maybe a bit dry) resource on web app security, I recommend [The Web Application Hackers Handbook](https://www.amazon.com/Web-Application-Hackers-Handbook-Exploiting/dp/1118026470), it covers most of the web security stuff like remote file inclusion, sql injection, csrf xss etc etc.
&gt; why use bitwise operators and numbers like these when standard ints could do the same job? For one thing, sometimes the bitwise operator is a more concise expression of what you are trying to do. x &lt;&lt; 5 is clearer than x * pow(2, 5) or than x * 32 which hides the meaningful 5 inside the arbitrary-looking constant 32.
I am currently working on a custom varnish integration and I have to say that the implementation from OP is okish, but the strategy is likely limiting. You eventually want to have different cache rules for varnish and browsers for php responses. The problem is that it you set cache-control to "public, max-age=XXX" the browser will cache the page too, which in turn is not possible to invalidate (with reasonable effort). To keep control over cache invalidation you want to set cache-control to private/no-cache and a ttl for varnish that is prefarably controlled by the application. My current approach is that the application is sending instead of x-cacheable a header surrogate-control with a ttl. That header sets the ttl for the response and is removed. The application can set cache-control to whatever is reasonable for the use case. Another point is the cookie handling from requests. It is a never ending story, there are millions of cancerous marketing projects that may rely on cookies on your domain. I would suggest to bail out from caching if you find a cookie in a request that you know that you don't want to hit the cache like session ids. Depending on the app that might need extension, but the way it is now it is guaranteed to need a extension. With the ~ operator it is fairly easy to test, the cookie vmod is also very handy to edit cookies but has to be compiled. Oh and cleaning hashes from urls shouldn't be necessary. ;)
 withUrl(array $url) I wonder how that will make life easier. I usually keep urls around as string and tokenize them if needed. 
can you explain when? I've been using pho for a long time and never had the need to use bitwise operators? 
The php-cli install has things like max_execution_time disabled by default. php-cli is invaluable for scripts and cronjobs because you can rely on your existing ecosystem and the fastest if you don't know anything else.
From my quick observation this was done by someone who knows what they're doing, probably an experienced C programmer, but not experienced in PHP. He definitely didn't give a flying f\*\*k the next person will just see a little pool of undocumented bit mangling on their server. Chances are that editing this file in any way whatsoever may cause earthquakes &amp; sudden volcanic activity, illogical Moon orbit shifts, black plague outbreaks, and in some cases Cthulhu sightings. Your only course of action is contacting the creator and asking them to guide you.
\&gt;_&lt;*
That's all I've used it for for over a decade. Only problem is other people you work with have the php stigma so won't even want to work with it
&gt; Why not try GO then ? Isn't GO compiled?
No, it checks if a specific bit is on indicating a relay is active. The returned data is the state of 8 relays.
Will check this out, book recommendations are always welcome. Thank you. 
In this case the output number is a relay on a driver board. http://www.robot-electronics.co.uk/htm/eth008tech.htm
Right? I'd just buy two Sonoff 4ch wifi devices for $15 each and flash custom code on them. https://www.itead.cc/sonoff-4ch.html
I can't speak for PHP as I don't know what kind of performance a bit wise operation provides, but in C, bitwise operations are (were?) incredibly common because they are basically an EXTREMELY fast way to multiply or divide by any power of 2. On old video game systems, division and multiplications were very, very expensive things to have to do (for example, the GBA does not have hardware division support, so a divide operation compiled into a long set of assembly) so any time you could use a power of two, you needed to try and do so (or at the very least, keep the values you need in a lookup table) Edit: another neat trick is that You can also use bitwise "&amp;&amp;" and "||" (AND and OR) to store and manipulate smaller numbers that don't require an entire integer. For example, you could store 32 discrete booleans or two 16bit shorts or four bytes in a single 32 bit integer by making a number that contains a "1" in bits you wish to obtain and a "0" in bits you don't need then bitwise AND the mask and integer. This isn't really important in the PHP world, but in low powered embedded devices it's a common trick to store more data than would otherwise be possible 
Right, because the fact that it represents a relay was the part he was struggling with, not what it was doing with the bits.
It depends on context.
Yes. I use PHP more for CLI stuff these days than anything. It's great and pretty cross-platform. 
/r/PHPhelp 
Nothing. This is not a layer of the onion. The user can write, this is indistinguishable from delete. Spend the energy on other security initiatives, like securing that user's access or DR. Edit: or the application 
Yeah, the IP address at the top makes me think it's pulling temperature from a wifi connected thermometer.
&gt; This is not a layer of the onion. Wrong. Not locking down the user's privileges and the MySQL host is like leaving a key in a safe when you leave the house. The house may be locked, but if a thief breaks a window to get in, they now have easy access to your valuables that you didn't bother to lock up properly. &gt; The user can write, this is indistinguishable from delete Not in the least bit true. You can grant INSERT without DELETE.
Thanks for the suggestions. &gt; This could possibly be alleviated by having meta-packages (or virtual packages, as in the Debian world)? I'm interested, could you elaborate? My initial reaction is that meta packages would not improve the situation and add complexity. Consider a project A depending on 3 packages, B,C,D. When updating code in B,C,D, you need to run `composer update` in A. Now we put B,C into a metapackage, E. Dependencies for A is now: D, E. How does that help us? If we need to update B, we now need to update the metapackage E and then update A to use the new version of E. That's an extra step...
GO programs can be compiled into a native executable so they can be run like a program would for the respective OS. In addition, GO programs can be run as scripts. The command "go build program.go" will generate a compiled executable whereas the command "go run program.go" will compile and then execute the code.
hard to answer for OP, but him and/or his maintainers might not know a lot of bash. Even if not that, they might to deal with an advanced data structure or use a library or another PHP codebase asset.
for small stuff, `go run script.go` is more than fast enough by comparison. No different than having a python/php interpreter installed.
You can also grant SELECT without INSERT.
What do you mean PHP isn't available by default on Debian?
Why only look at warnings and notices? Other kinds of errors also exist.
There should be a .conf file in that conf folder. It should be in there somewhere...
In my opinion, the most useful thing about generators is the performance gain, especially when iterating over a large amount of data. There are much better ways to enforce good application design (e.g. the mapper / repository design pattern) than using generators for that. As already mentioned: For me, it seems like a pretty bad idea to send a SQL query inside a generator in general, because of the possible side effects.
yes this point is valid.
The SAME output? Did you see the output change to whatever the new string value was? Also, View Source and see if you see the php code there. If you do then php isn't running on that request. 
Wow. I wish i'd learned all this stuff. Makes me wish I went to Uni. Thank you so much for the detailed answer.
&gt; Why not try GO then ? Why not try PHP then ?
To be fair here. Host specificity is a great one on this list and should be observed.
Didn't know that. I took a quick look at go right after it came out and been wanting to spend more time with it. Being able to run it as a script is a great way to get into it. Thanks for that info.
In addition to what /u/bga9 mentions, one thing I try to do is have different users for different roles. For example migrations will be run by a migrations user which does have the table alter and drop table capabilities, the admin panel has an admin user that can view the admin user/acl table and maybe has different permissions than the web view on the other tables, reporting is done by a reporting user (run on the slave), etc. It isn't even just about minimizing damage from compromised accounts, but it's also about defining boundaries of what each part of the application can do. For example if a developer needs to access the admin tables from the web view, then that says something about the architecture of the system as a whole, with blurred responsibilities, etc. and without these bounded contexts it becomes difficult to refactor and/or move to separate services.
Good suggestion. I'll add something soon. Thanks!
Fear to speak up is how bad ideas spread. Most of us are anonymous so there's no need to succumb to the groupthink.
Careful, guys, he's a SAGE Level IV.
1. `rm -rf code-igniter`
&gt; SQL level permissions aren't where you want to build strong security. SQL level permissions are not the only place to build security for sure but there is no such thing as a single point of `strong security` and why not compartmentalise SQL as well so you can add it to a list of things to tick.
From what I see, this is to include a stack trace for PHP warnings and notices into the log.
Another really cool trick that uses bit shifting is "fixed point arithmetic". It's how the PlayStation 1 and similar systems handled decimal numbers without a floating point processor. Basically you would use the first x bits as "precision" and would shift x bits to the right before doing any mathematic operations on your data. For example. If you had an integer with 8 bits of precision that represented the x value of your character, you would throw out the first 8 bits before performing any operations. This means that you effectively only add "1" for every 257 values added. You can effectively consider the number a 24 bi binary number with an 8 bit decimal point and thanks to the extreme speeds of bit shifting, has almost zero performance penalty whilst allowing you to do anything a floating point processor can do 
lack of mature concurrency would be one killer takedown as would distribution of compiled executables. I actually side with you, but it's important facts are put out there
Happy cakeday AutoMod, I guess?
they mean it's not installed (python and perl I believe are, php is not, go does not require go to be installed AFAIK or there is an option to compile in such a way go is not required)
Yes, also the user should be able to delete only the rows that he has created and not the ones that others have created. If the user is a manager then he should be able to delete only the rows that were created by the users he has created. I think this can be achieved using PostgreSQL.
Ahh. I install via netinst so even Perl (I think) and certainly Python aren't installed by default, so it takes the same amount of effort to install them as it does to install PHP, for me. That's where I was confused.
[bash is coming to windows though!](http://www.theverge.com/2016/3/30/11331014/microsoft-windows-linux-ubuntu-bash)
If you don't want to disappoint your potential customers and be accused of selling vaporware, you better scale the marketing rhetoric right down on the modelup.co site. Eg. you should disable the About menu immediately. I'm not a big fan of phpmyadmin myself so I wish you the best of luck with this endeavor.
i just opened the quick tour side and the very first thing i noticed is that it has a part called "Psr" - which is kinda bad choice of a name, as it in PHP context is an abbreviation for PHP Standards Recommendation the second thing I noticed is createQueue, which is named a bit misleading, as what you are doing is kinda selecting a queue. an oddity seems that when testing for a false condition rather than doing if (!is_numeric(...)) you'd do if (false == is_numeric(..)) then i noticed that within some of your packages you do have sourcecode, or parts of the sourcecode within your root folder (psr-queue for example) I didn't go through all code, but most of what i saw looks ok. I didn't run any code quality checks on it, but the cyclomatic complexity of one or two methods might be a bit high, there is a like a hand full of static method calls that I saw which don't seem to harmful, but you know good practice and so on. also i saw a hand full of methods that did more than one task, so you might want to consider looking into breaking those up, but overall code quality doesn't seem too bad. as a small hint for improving your composer packages: check if requiring a virtual package for the drivers might be something for you. (https://devedge.wordpress.com/2014/09/27/composer-and-virtual-packages/) one more thing i'd do - i'd separate the git repositories of the single composer packages.
[obligatory XKCD](https://xkcd.com/927/)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Kind of horrified reading this. Granularity is tied directly to roles, and roles are a cornerstone of application security. They constitute the first and last line of defence for your web application. For example, say your front end takes in sales, perhaps credit card information or postal addresses: your front end web server role would have INSERT permissions to the payments table and nothing else. Your CMS role might only have SELECT permissions. Super users and migrations would have looser permissions. Having a strong password won't protect you if every front-end user to your web app has the permission to update or delete data in your most sensitive tables. I know we all write perfect code and never ever, even accidentally, write buggy, insecure code (man, could you imagine what could happen if we DID write buggy code?). But as unlikely as it is, just in case, batten down your hatches. 
For example, I've seen setups where there are several servers behind a load balancer, but each use the same user to connect with and the sql grants are in the form of user@'http_.example.com', since an underscore is a wildcard for a single character. Using an IP does help reduce a dns lookup, but hostnames are just as flexible. But my point was that you should never use the wildcard @'%' **by itself** because that would allow connections from any host.
&gt; i noticed is that it has a part called "Psr" - which is kinda bad choice of a name, as it in PHP context is an abbreviation for PHP Standards Recommendation I agree, it is a bit misleading but it is the best from what I had. I believe some day it become a real PSR standard. &gt; the second thing I noticed is createQueue, It creates an object queue and does it same way as JMS (Java Message Service) standard. &gt; an oddity seems that when testing for a false condition rather than doing if (!is_numeric(...)) you'd do if (false == is_numeric(..)) It is matter of personal taste which is not contradict to PSR2\Symfony coding standards. I am using php-cs-fixer to fix coding issues and it is fine with it too.
&gt; then i noticed that within some of your packages you do have sourcecode, or parts of the sourcecode within your root folder (psr-queue for example) That's because of subtree split from development repository. I dont like it too but there is no much I can do.
&gt; I didn't run any code quality checks on it, but the cyclomatic complexity of one or two methods There are a lot of unit and functional tests to make sure the code works as expected. 
&gt; as a small hint for improving your composer packages: check if requiring a virtual package for the drivers might be something for you. Thanks for the hint it would indeed a good fit in my case 
so you can only do this for private repos? or is there also an undocumented cli flag that would prefer no-api for all the things?
I disagree, just learn symfony. Symfony components are what built laravel, slim, silex, .... why not just go straight to the source...
Hey Paul, If PSR-11 passes as it is currently proposed (https://groups.google.com/forum/#!topic/php-fig/I1a2Xzv9wN8), there are no differences. Same methods (get / has), same exceptions. Only the wording has been improved. If so, we will write a new container-interop version that extends PSR-11. That way, your containers will be automatically compatible with PSR-11 (nothing to do on your part, that would be awesome :) )
Dang it and thank you. sometimes my copy and paste fails me spectacularly. 
Virtue signalling is just as common here as it is on internals.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
There are tons of reasons NOT to run every .htm or .html file through the PHP engine though, I'd strongly caution against doing this. It'll hurt performance but it could let someone run PHP code unintenionally (or worse, maliciously)
A application user doesn't differentiate user accounts for its users. 
And how big of a security concern is that on the SQL level? That a user who can fill out the feedback form can't read or alter what other users have written in the site_feedback table? 
My first comment, "This is not a layer of the onion" - which references the classic analogy of security being many layers. What I'm trying to say, is stay sane and don't get "creative" on SQL permissions because the onion has many layers and this isn't one to get hung up on. Do the basics. *INSIST* on the basics, but don't do more than that here. Focuse your security practices on other layers. 
And more recently there's been support added for [Docker Remote Interpreters](https://blog.jetbrains.com/phpstorm/2016/11/docker-remote-interpreters/) in addition to 'regular' remote interpreters. 
I've got this guy tagged as [spammer](http://i.imgur.com/W9ntsAS.png) for ages now. Some of his spam is worth reading but in the end it's mass submissions(~750 submissions in the past month) for that karma.
Maybe https://thelia.net/? Since it's based on Symfony you can easily integrate it in your own code.
If you go with OpenCart, make sure to go with OpenCart-CE not the original OpenCart. http://www.openwall.com/lists/oss-security/2016/01/19/16
Glad to help!
Without specifying what PSR-7 lacks, you don't explain why you decided to go for ServerRequest/Respone instead of just making PSR-7 an rfc to core. You concede that there's more application development in to moving away from something that's already a standard, bu there's explanation of *why* that should be done. They have different purposes, but why is your solution better?
Ok I tried opening the file by browsing directly (e.g. http://localhost/enteringinfo.phtml) and I get an error message: site cant be reached. Both files are in xampp -&gt; htdocs This is what im using. enteringinfo.phtml &lt;html&gt; &lt;body&gt; &lt;form action="learnphp.php" method="post"&gt; &lt;table border="0"&gt; &lt;tr&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td align="center"&gt;&lt;input type="text" name="username" size="30" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Address&lt;/td&gt; &lt;td align="center"&gt;&lt;input type="text" name="streetaddress" size="30" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;City&lt;/td&gt; &lt;td align="center"&gt;&lt;input type="text" name="cityaddress" size="30" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt;&lt;input type="submit" value="Submit"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; And learnphp.php &lt;html&gt; &lt;head&gt; &lt;title&gt;Information Gathered&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php print "&lt;p&gt;Data processed&lt;/p&gt;"; ?&gt; &lt;/body&gt; &lt;/html&gt;
No it is not worth a look. [This is a little old, but I doubt anything has changed](http://www.techchattr.com/never-use-opencart) Even if you don't care about security, their system of "extending" things is ridiculous.
Seems pretty obvious to me. Focuses on one use case instead of two. Two classes instead of 7 interfaces. No need to fool around with pseudo-immutability and stream stuff unless you really want to. withXXX methods that can handle arrays instead of a single value. All around, a much cleaner and more usable api. And, as mentioned in a previous thread, I don't see any obstacles to extending these classes and making them psr7 compliant if you really need to.
His solution is worse, the same way an orange is worse than a shoe: it isn't, because they are completely different things and shouldn't be compared. Those two implementations are non-competing, non-conflicting, where one solves a problem and the other just encapsulates information. I'd very much like to see the ServerResponse become a thing.
I still don't understand the point of ignoring PSR-7. The only argument I see is the "question" you want to solve is different: PSR-7: &gt; â€œHow can we model HTTP messages for receiving a request, and sending back a response?â€ Your RFC: &gt; â€œHow can we take the request-related superglobals in PHP, and the various response-related global functions in PHP, and encapsulate them in objects, to make them at least a little more object-oriented?â€ "*a little more object-oriented*" doesn't sound good like a good reason in itself. I'd rather have it completely modeled properly in OOP, or not at all, but in-between doesn't make sense. And as a result PSR-7 is much closer to being a proper OO abstraction. And, more importantly, it's already everywhere in the ecosystemâ€¦
Have a look at: Silex: Symfony components "Silex is a PHP microframework for PHP. It is built on the shoulders of Symfony and Pimple and also inspired by sinatra." http://silex.sensiolabs.org Lumen: Laravel based "The stunningly fast micro-framework by Laravel" https://lumen.laravel.com Also look at the microkernel for Symfony: http://symfony.com/doc/current/configuration/micro_kernel_trait.html
Check out: https://www.opulencephp.com/ 
https://github.com/paragonie/awesome-appsec might be worth perusing too
I used Snipcart in alot and its a great platform. Things that would be really nice : Be able to really change the html of the cart. For the moment, I can do things in css and use your github cart theme but there are limitations: I can't really move the subtotal in the step 1 one the cart because its in the header. A client of mine wanted to put the subtotal at the bottom of the cart just under promotion code. I had to manually add html with javascript to do that (its not the best solution). Another thing would be to be able to specify some product price to never be affected by promotion codes. In some situation, like gift card, I don't want customers to be able to use a promo code to buy a gift card. It was a request from a client. I had to work around the issue and create promo code that work for all product ids EXCEPT gift card. Again, not the best solution. But it can be done! Snipcart is a great solution, really easy to use and your support is really quick! 
i wrote my own mini "framework" based off of slim, that i just created a private repo that i clone when i start new projects. Slim has done me well for "small-ish" web apps. haven't tried to really scale anything from it. 
Proper planning and discipline ? What you are describing is day-dreaming. Take a piece of paper. At the top put the project name. Below that write down version 0.1 , then determine the time frame you are going to have available to work and list only what you can accomplish during that time. 2 week sprints is common for agile development though you may prefer a shorter sprint. Move to 0.2. Repeat. On the back, write down those possibilities. Move them from the back to the front as you complete versions. The mantra is 'release early, release often' .
I fully understand this. As soon as you have something that works, you find something you could have done better in the first place, so you go and refactor everything. It can create a positive feedback loop of refactoring and distraction, while totally killing your progress. It seems like this is less of a coding problem and more of an organizational/focus problem. What I have been doing lately is writing down everything. I was getting distracted at work a lot, losing my place, and getting carried away chasing rabbits. So I got a cheap notebook and I write down what I need to do and the problems I am having. I found out firsthand that sketching out a data model for a client by hand, as opposed to jumping right in and writing the code, really helps me think problems through. Writing things down also helps to get me back to where I was before when I do get distracted, or if I need to step away and come back to something later. I also try to make sure that I write down what I need to do before I do it so that I do not end up chasing rabbits like I mentioned before. It still happens, but it happens a lot less. I think the idea with it is that translating your thoughts to another medium helps you solidify your ideas.
How come you don't use a private Composer repository with that many dependencies? E.g. the new [Private Packagist](https://packagist.com/) or previously toranproxy. Using git repositories directly will be slow the first time you run it on a new machine regardless of which mechanism you use (e.g. new developer on the team, new server, new setup, ...)
Thanks for the variety of recommendations! I hadn't looked into Silex yet, though I've seen it on quite a few "best" lists. I also didn't realize it was built on Symfony components. Probably a good one to work with if I wanted to pair up a more full-featured framework like Symfony for bigger projects. I had considered Lumen - but it doesn't seem to have a view layer. It seemed that it was primarily built to be more of an API back-end for a heavier front-end or just as an API layer. I do want to take advantage of templating - if for no other reason than view inheritance. I wasn't aware of the Symfony microkernel - I'll look into that one too.
Yes, he was talking about the composer.lock file which would contain the results of processing the composer.json file.
I find Slim more intuitive than Silex, but that's probably just personal preference. I certainly don't think there's anything *wrong* with it, though. If you like it, go for it... don't let the perfect be the enemy of the good.
Slim is a good starting point for web apps. The question ist how much do you need in the future? Maybe you also need translations (i18n) and a more sophisticated sql query builder. What about logging, unit tests, caching and database migrations? Think about where to put the business logic. A good directory structure is very important to organize your PHP code and all other resources. If you use Slim check out this skeleton. https://github.com/akrabat/slim3-skeleton. You should also consider this new php standard skeleton https://github.com/php-pds/skeleton. PS: An alternative would be to create your own framework on top of the Symfony Components. http://symfony.com/blog/create-your-own-framework-on-top-of-the-symfony-components
Thanks for the input. I definitely agree with not letting the perfect be the enemy of the good. One thing that bugs me about Slim is seemingly no way to just pull an archive down, but having to install, configure, and use composer to pull it down instead. Silex has pre-built "fat" and "slim" archives to download, unzip, and roll with. I like that. I'm going to keep looking into both. I do have some previous experience with Symfony, so presumedly I'll have some familiarity with Silex if I go that direction.
See wikipedia: https://en.wikipedia.org/wiki/Application_programming_interface API: &gt; In general terms, it's a set of clearly defined methods of communication between various software components. Web service aka Web API: https://en.wikipedia.org/wiki/Application_programming_interface#Web_APIs &gt; When used in the context of web development, an API is typically defined as a set of Hypertext Transfer Protocol (HTTP) request messages, along with a definition of the structure of response messages, which is usually in an Extensible Markup Language (XML) or JavaScript Object Notation (JSON) format so: API &gt; Web service &gt; REST API
Did this work?
you could probably clone/export [their skeleton app](https://github.com/slimphp/Slim-Skeleton) instead, if you find that easier. I'm already using composer, so that part didn't occur to me.
you mean when we create API for application to application communication then it's a Web API or Restful API but when we talk about device to device communication then web services will be useful?
This is the thing where deadlines actually come in handy. Set yourself a deadline, then decide what you can get done by that deadline and do that. It's up to you to maintain discipline, of course, but be serious about meeting that deadline. In other words, your main goal is not the app itself, but meeting that date. Per [Hofstadter](https://en.wikipedia.org/wiki/Hofstadter's_law), you'll almost always end up cutting things out rather than adding them in.
We are talking about web services when two endpoints communicate over http..the API is the actual application endpoint which provides the means of communication. REST is an approach on how to communicate ver http. So you have REST-full web services. The REST API is your application endpoint which allows other applications to communicate with yours e.g. at www.mywebsite.com/api/v1 sits a php script which accepts a POST request. That script is your API endpoint
Yeah, I had heard of Phalcon - but I haven't checked it out yet. I'll take a look at that one too. I had read that it was built in C or C++ and that had something to do with the speed of the framework - is there any special installation/configuration due to it being built in C/C++ rather than pure PHP?
I was just reading about [Zend Expressive](https://zendframework.github.io/zend-expressive/) yesterday, which could be useful. I haven't actually used it yet, however it seems promising and offers some flexibility as far as the underlying components.
I wrote several different responses and decided to not publish them. Basically I'm trying to say I don't like PSR-7, many people have already expressed the same, and I'm not sure why anyone uses it. I haven't fully evaluated the proposed [ext/request](https://gitlab.com/pmjones/ext-request), so I'll decline to comment there.
rest api is a form of web service
I found the file and added that at the end but it still did not work.
It's not necessarily a problem unless you let it become one. Typically I'm used to thinking of new things to add into my projects/products but it's only a problem if I let it delay a release. I don't mind constantly pushing updates to my sites because it gives me a reason to contact potential customers with new things, it shows everyone the site is still evolving, and most people like new things. If you constantly feel the need to clean up though, that can be troubling. There's definetely parts of my scripts that I wish I would have done differently but until I want to do heavy work in those areas or they prevent an upgrade, I'm leaving them alone as there's more important things to focus on. Unless you're distributing code or your code is making people working with you slower, there's not a real reason to clean up. Your end user shouldn't be affected and if they are affected then that's a good reason to move forward with cleaning.
This isn't a language specific question but more a structure question. I really suggest a book called, "The Lean Startup." Basically you need to ask yourself what's your minimal viable project that solves the problem, or disrupts the norm. It may never need to be coded, wireframing it or excel formulas make is viable. That's your first version nothing more, nothing less. Just remember perfect is never done and done is never perfect. If you remember that, you can get any idea executed. Because the faster it's executed the faster you can determine if there's a market, and if it's time to pivot, stay the course or shut it down. 
No, you can do this for public repos as well.
If you'd say that to me after looking into the code, you'd pass :)
[removed]
If you think you need to do this you are doing it wrong, [whatever it is](http://xyproblem.info/).
BUt isn't is on the same level as laravel or any of the framework you think is overkill ? Anyways, i have tried using it. Clean but i couldn't just wrap my head properly around the ORM
Sylius
Doing god's work. Heaven forbid authnet would tweet this or put it on their status page or put it on their support page. It's only thanks to fine samaritans such as yourself to spread the word.
Thank you indeed. 
I know its probably a code smell but it would make the API for my test helper much cleaner and I'm going with api over design for the sake of test readability.
It might be - I haven't looked into it yet. I do like getting opinions of frameworks while I'm investigating them though.
Interesting - I haven't heard about that version of ZF. I used ZF2 several years ago - but I didn't know they worked on a pared down version of their framework too.
Many lower-level protocols pack information into specific bits or ranges of bits. So you have to first AND out the part you want and then right-shift it down to the actual number.
If you see a mysterious Error 2 and nothing is posted to the Post URL after transactions, this is certainly the problem!
Look for $content_attributes It's not shown in your code.
Is it not possible to simply include the composer.phar in your project, like in a bin directory?
What can I do to help users better understand the ORM? More examples? Better docs? Or is the repository/data mapper pattern itself just kinda foreign? Let me know where I can improve.
&gt; I really doubt you practice what you preach because you're not thinking through the implications. FFS. What would make you say something like this. Most of my time is spent building public-facing APIs for clients. If something of mine gets hacked and my client is the least bit litigious, I am on the hook legally and possibly financially. So everything I do -- including projects that are just for me -- are built from the ground up via this path: schema &gt; permissions &gt; API end-points &gt; permissions &gt; logic I know that I make mistakes (postgres permissions are incredibly time-consuming, so they are the most likely to have lazy errors), but I honestly try my hardest. Every. Single. Time. I've sadly worked in companies that have been "hacked" (repeatedly in some cases) and every god dammed time it has come down to either a) uncaught regression in the codebase or b) utter carelessness. And none of them would have happened or been as severe as they were if our developers had used more than one public-facing database role and thought from the start about permissions. Also, in my opinion security isn't something you should think of as "adding to an application". In my head, your starting point should be total security (think: unplugged computer, locked in a safe, in the bottom of the ocean). Then you loosen security only enough to make your application work. Group your users into theoretical security groups and grant them only enough to make things work for them. Here is an example, say for a large news site with UGC and maybe an independent moderation team, I might break things down like this: visitor, commenter, moderator, editor, admin and super-user. * `visitor` gets read-only access to public tables. * `commenter` gets write-only access to `comments`, `votes` and other UGC stuff. * `moderator` gets update-only access to only `comments`. * `editor` maybe gets read-write access to public tables and read-only access to certain private tables (e.g. `users`). * `admin` gets read-write access to everything. * `super-user` might be how the developer accesses the table directly and might be what you use for migrations and can basically do anything (though some sysadmins I know wouldn't let a developer anywhere near a DB with GRANT DROP.) So that's for a pretty large project with a lot of people, but smaller sites might use a much smaller structure. But I don't think I've written a site in the last ten years that doesn't have at least `PUBLIC_READ_ONLY` and at least `PUBLIC_READ_WRITE`. Lastly, remember that a public user would get comments via `visitor` and submit comments via `commenter`. A moderator would read comments from the `visitor` role and approve/decline comments with the `moderator` role. Ideally, each API end-point maps to one and only one access group, but mixing-and-matching is probably fine too. And your database permissions structure is what everything ultimately boils down to. You can add a separate service that acts as a gatekeeper, yes, but the permissions will likely simply mirror what your DB has already. My bottom line is this: If you use a single role for all your db calls and someone stumbles across an injection point in some part of your code base that really only needs read-only access? 100% your fault. I've seen it happen. Do whatever you want. But I will do my best to not let it happen to me. 
&gt; I don't think that is what he/she is advising at all. For DB permissions, unless I am totally misreading him, that is exactly what he is advising. &gt; The fact that today you can run *SQL on your own anywhere changes that equation. No it doesn't. We've basically moved back to the pre-shared-hosting days, where you either ran your servers on-site or had a co-lo somewhere. We are exactly back where we started, except the machines are all virtual. And if the rules were wise then, why are they suddenly not now. Did companies not get hacked in 1999? And my point here is that you are still using an SQL client (your *SQL API either is the client or it wraps it). You still have accounts (evidently only one, according to a lot of people here) with appropriate permissions. You run queries (hopefully parameterized or stored procedures). You get back datasets. What in this has changed. &gt; unless you have very specific concerns Only one concern: not getting "hacked" because of some uncaught regression or idiot mistake I've made. That's it. Permissions are easy (if you ignore postgres) and free and they work 100% of the time.
Seems like the comments kind of made this a bit more complex than it should be. So let's use an example: www.kraken.io is a **web service** that allows you to send images to their servers which spits out optimized images at a lower file size. Now in order to use this web service, we need a way to communicate with their servers to get a job done. So they provide a simple [REST API](https://kraken.io/docs/upload-url) so we can post data to their servers and receive a response (our newly processed image or an error message) from their servers. The web service is just a tool that allow users to do a common task for you over the web and the rest api is just allowing outside access to communicate with that web service, to keep it as simple as possible. Also note, not all web services require server to server to be considered a web service, there's also server to client (browser) which could essentially mean anything can be a web service today. Another real world example is gmail is a web service.
What makes this API RESTful? Is it really a REST API, or this is a CRUD API, or may be this is a "just some API"?
Thaaaanks! 
It's not xdebug fault but fair to say reading its profiles requires cachegrind and to a lesser degree kcachegrind
I can't see what what that code is in your screenshot, but it would be logical to put it there.
For me, it's the data mapper implementation.. "it's kind of complex" compared to Active record .. I think the docs are fine 
WP is in a state of limbo. I am a WP dev (plugin development mainly) and the problem is (you're right) that Automattic has no clear vision. They're still thinking of it solely as a blog platform. Hell, the CEO (the founder also) is a 2-bit web dev who's more interested in blogging. 
I'm very much satisfied with the customization and your support, best admin template ever seen. Thank you 
Thanks for the input! We've had a lot (&gt;10) of staff changes during last year. Some of them left because they felt like they were going nowhere/not learning new things, some left simply because they got better offers elsewhere. So i feel like our produt/code quality has dropped, and it's time to start implementing new things. Also, as i said, we're trying to adopt agile, and i feel like it's also putting some restrictions on the growth of our staff. For ex. before we started with agile our teams were separate: we had a backend department, management department, frontend department etc. And every department had their own office space, so they were constantly engaging with each other, talking to each other, helping each other etc. Now that our teams are divided into mixed groups devs only communicate with the members of the same team, most of the time. Yeah,friday...i dont like it either :D should we try and move it to thursdays and leave fridays for code reviews/retrospectives/preparations for the next sprint? 
Ahhh, HTML mixed with PHP edited in Notepad++, I remember those days ... *shudder*
If you want to make your own AR to learn from just look at all 500 of them and try to consolidate them or something. If you want to contribute something to the open source community don't make a new AR implementation because 1 is already too many.
Password hashing is not the reason why WordPress is not secure. Sure MD5 is garbage but they have much bigger fish to fry.
Sure. We've previously published [*On the (in)security of open source CMS's*](https://paragonie.com/blog/2016/08/on-insecurity-popular-open-source-php-cms-platforms#wordpress-insecure) which delves into the other core out-of-the-box security deficits of WordPress in detail. Solving this is a side-effect of a larger goal: Making their automatic update feature [not an enormous SPOF](https://www.wordfence.com/blog/2016/11/hacking-27-web-via-wordpress-auto-update/). I'm not sure I'd agree that there are much bigger fish in stock. The long tail of vulnerable plugins/themes isn't going to go away until they invest heavily in security automation. Also, "Making WordPress Secure" is going to be a series of posts I make here over the next month.
:P
I get that, my only argument would be that at least it's right there in the test method staring at you. In a large test class, that tearDown could be 200 lines away, or it could be in a parent class, or as another commenter mentioned, it could be in a listener.
Phalcon was more beneficial for speed boost when we had PHP 5. With the PHP 7 performance levels, I think the gain of using Phalcon is now rather small. (IMO)
Hey there, creator of CoreShop here. CoreShop is a plugin for the PIM/DAM/CMS Pimcore. Pimcore is great in managing Content and Object Data, so I build an ecommerce on top of it. Maybe you should take a look at it: https://github.com/coreshop/CoreShop https://www.coreshop.org https://www.pimcore.org
&gt; Which NOSQL will you prefer... ...for what? There's a million different NoSQL systems; each is good at different things. Although (spoiler alert) you should probably be using some mixture of postgres and redis. (Not that there aren't applications that would benefit from other tools, but if you have to ask what datastore to use, the answer is always postgres.) &gt; ...with PHP? The same one I'd prefer with any other language.
&gt; From my own personal and professional experience, working with a variety of teams, a variety of platforms and a variety of products, permission at the DB level are the first, last and best line of defense. In any mature product there is no longer "the DB". A service would use a variety of storage and caching mechanisms to implements its business requirements. This is why the service/application becomes the center where those rules are enforced. Because it's the only place which is factored according to your domain, so you can see how the security you implement actually applies to your direct use cases, and because it's the only place where the language has flexibility to match your exact business requirements, instead of messing with a limited set of command/table based permissions sets. You may enforce, say, INSERT only permissions on your SQL user, but your cache, which has some of the information you'd otherwise SELECT, doesn't have such permissions. Which makes your data readable no matter what your SQL permissions are. This is why focusing your entire attention on "**the DB**" as the "first, last and best line of defense" makes no sense. What you're talking about simply is completely irrelevant to a modern development stack. Which we use not because "2017" like you say, but because it allows us to do things which if you're stuck with "**the DB**" you can only dream of, in terms of both performance and features. And I somehow doubt I'll ever see a reasonable explanation to how you maintain transactional consistency and keep your code comprehensible when juggling 6+ SQL connections with all the resulting dozens of repository combinations. The reason you're focusing on the DB, is because you see it as the center of your application. I'd also expect to see a good chunk of business logic factored as SQL stored procedures in such setups. As I said, if it works for you, fine, but it's simply very inflexible and crude compared to what we can do with a modern approach. 
Seems you don't have a completely clear goal. Get a clear goal and then write down what is the absolute minimum needed to get there. This is your version 1. Add nothing to it after you have written it down. Version 2 should come from your users. They will tell you what they want and what you should build. Sprinkle lightly with your ideas. Repeat steps for v2
&gt; or would I just wait until PHP provides PSR support itself ??? AFAIK PHP is never going to provide any kind of PSR support. Internals != FIG.
Per the docs, returning false with the function registered in set_error_handler will allow PHP's normal error handling to happen. I just wanted to add stack traces to notices and warnings as the default is to only log the line on which they occur and I had no idea what code was calling those lines
I just happen to release a plugin to add bcrypt support with password_hash() (https://wordpress.org/plugins/password-hash/) I'm no WordPress expert and don't even know many people from its inner circle. But to be honest, I do the think this will get through unless there's a huge push from the community. UX/UI changes tend to go pretty quick and users love to upgrade because there are no BC issues and they make changes that users see and feel. An update that basically makes all passwords reset will sure upset a lot of users. 
I see no reason not to do it. internals also inst C internals, yet the php functions mirror a lot of C ones.
You have one called Crane or something else (I'm on the phone right now). Just search for PHP on the extensions and you will find something useful. This article may help you too https://code.visualstudio.com/Docs/languages/php
 &gt;(Not that there aren't applications that would benefit from other tools, but if you have to ask what datastore to use, the answer is always postgres.) No, it isn't, far from it. Even if you narrow it down to just the use cases where relational databases actually are a good choice, postgres isn't always a good answer - that's just bad advice. 
laravel is not more simple than symfony, just use the standard framework that includes everything you need, no assembling required. symfony documentation is also superb.
Ahh, sorry, hadn't considered the php installation not supporting phar
Minimal Viable Product, release fast, release early, release often, iterate.
Fuel uses a front controller, by default it is in the "public" directory - so you need to copy the /home/folder/example.com directory and look for an index.php in either /home/folder/example.com/public or maybe another directory used as an entry point. You should also make sure only this one directory is accessible from the outside, otherwise you will have security issues. For "nice" URLs you will need to configure your web server to call this index.php for all files not found in this public directory, for example in Nginx this would be something like try_files $uri index.php; Or replace index.php with @php if you have a PHP location to call scripts. Only index.php needs to be executed by PHP. The Fuel documentation is also available on http://fuelphp.com if you need to find out more details.
Got the crane one installed, but as with the felix becker intellisense extension it doesn't seem to pick up everything I'd expect.
composer require zend/diactoros nikic/fastroute php-di/php-di Spend as little (or as long) as you like bootstrapping those packages and deciding on the rest of your structure. If you want to make it some tiny MVC app it'll probably take you &lt; 10 lines of code (excluding tests). Add in anything else you need if/when you need it (eg ORMs, middlewares, caching, etc)
[PSR-7](https://packagist.org/packages/psr/http-message) has 17M installs, I think this is good evidence. For scale PSR-3 has 48M. And also Symfony's HTTP foundation has 26M.
That's not really necessarily a problem with NoSQL, rather server configuration. The same could happen to any exposed MySQL database.
That's an interesting cart approach. Definitely comparable to snipcart. I'll keep it on my mind.
&gt; There's a million different NoSQL systems; no way there is a million
Incredible find
Don't forget to store credit cards as a plain number. Because, reasons.
It clearly didn't work, but you get an A for effort. I'm surprised this is possible because I thought companies were entered manually by a clerk, not an online system.
It is secure. [Here are some](http://security.stackexchange.com/a/6415) outstanding reasons why.
Bcrypt on PHP &lt; 5.3.7 isn't.
The linked ticket has a section on how to migrate legacy hashes which linked [here](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016#legacy-hashes). Upgrading hashes this way is instant and doesn't force a password reset; it's transparent to end users. https://www.reddit.com/r/PHP/comments/3lwxlw/hash_and_verify_passwords_in_php_the_right_way/cva6y6p/ Kudos to /u/NeoThermic for outlining it in the above Reddit comment.
Nope, you've missed the point, it was the DEFAULT in MongoDB to allow ANYONE access to the database. Anyone who thinks this is a problem with MySQL are very much wrong because it isn't the default to allow anyone access to MySQL. Down vote all you want but you'd have to be insane to think this was a good, solid default security policy to take but hey the truth is MongoDB did it.
PHP Bug tracker: https://bugs.php.net/bug.php?id=69205
/me nods to /u/Disgruntled__Goat and /u/ThePsion5 Yup, that's exactly what we're all used to in PHP 5.x. However, 7.x has a [null-coalesce operator](https://secure.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce), which makes that kind of method unnecessary. The examples above would become these instead: $value = $request-&gt;get[$key] ?? $default; $value = $request-&gt;post[$key] ?? $default; This also has the benefit of exposing those property arrays *as arrays*, with all the attendant PHP functionality. Do you get where I'm coming from? 
`mysqli_stmt::bind_param` binds using references, rather than copying values. So each value it is passed needs to be a reference. &gt; `call_user_func_array(array($stmt, 'bind_param'), &amp;$params));` PHP doesn't have call-time pass-by-reference any more, so you can't put a `&amp;` in front of `$params` to make it into a reference. Rather, PHP will take a reference to it if the function demands it. `call_user_func_array`, though, doesn't take an array by reference. It just takes an array value. So using an `&amp;` here would be useless even if it was still supported. Even if you could pass a reference to an array to `call_user_func_array`, though, it wouldn't help you with `mysqli_bind_param`. That array isn't passed to `mysqli_stmt::bind_param`. The array is taken by `call_user_func_array`, and each individual element of it is passed as an argument to `mysqli_stmt::bind_param`. None of those elements are references, so `mysqli_stmt::bind_param` doesn't get reference arguments. So it doesn't work.
Thanks, OP, you saved us from a massive headache this morning. 
Could you talk a little about your commerce model? We can all blindly give you bad advice but if you give us some more information you'll get more educated answers.
Disappointed to find that [Aura.Di](https://github.com/auraphp/Aura.Di) is not included in the benchmarks; would have liked to have seen where it stands in the ranking.
Where did your copy of PHP come from originally?
That's a good point too. I've developed in Symfony in the past, and I know that it's easy to use and develop for. It's been a few years, and maybe it was due to the incorporation of custom bundles and things, but it felt like starting an app up with Symfony was a bit of a push-up. I will go back and take a look at the start-up for Symfony and see if there if any compelling reason not to use it. I'm also under the assumption that the additional features/functionality of a full-featured framework might make it run a bit slower, but I reserve the right to be 100% incorrect there. Thanks for the advice.
I can include it for sure ðŸ˜Š but happy to receive PRs too!
Ahhh good ol Bobby Tables
That's a good point, I forgot about the null coalesce operator. More reason to get my applications upgraded to PHP 7.
I'd also like to see [Opulence's DI container](https://github.com/opulencephp/Opulence/tree/1.0/src/Opulence/Ioc) included in the benchmarks. Here are docs for how to get started using it: https://www.opulencephp.com/docs/1.0/ioc-container#basic-usage
&gt; happy to receive PRs too! Fair enough -- I know that benchmarking is a ton of work. :-)
[Auryn](https://github.com/rdlowrey/Auryn) is also not that unpopular, would be appreciated to see it in comparison.
https://imgs.xkcd.com/comics/standards.png
That's not the fault of mongodb. Hire a DBA or do some research before you put your misconfigured database out there.
There are about 5 meaningful ones.
Agreed, this isn't perfect. Anyway I don't think it's black or white/everywhere VS nowhere. Still PSR-7 is spreading, it's used in popular frameworks and libraries, in itself this is an argument. And anyway same argument could be made about Symfony's HTTP component: why not bring that into core instead of creating yet another model?
Oh now that would be funny if a crawler didn't sanitize their data and lost their company table.
A pure PHP crypto library seems like a bad idea. How will you prevent timing attacks for one?
This is a good question. * https://github.com/paragonie/sodium_compat/blob/9bf31d61796b5ba017a0f096e63512bdd68513fc/src/Core/Util.php#L215-L236 * https://github.com/paragonie/sodium_compat/blob/9bf31d61796b5ba017a0f096e63512bdd68513fc/src/Core/Util.php#L322-L348 * `hash_equals()` Also, the asymmetric cryptography is [based on the ref10 implementation of Curve25519](https://github.com/paragonie/sodium_compat/blob/9bf31d61796b5ba017a0f096e63512bdd68513fc/src/Core/Curve25519.php) (both ECDH and EdDSA over the curve; known respectively as X25519 and Ed25519 in most circles), which is designed to prevent timing attacks. The answer is simply: By knowing where the timing leaks happen and [writing code that doesn't leak](https://cryptocoding.net/index.php/Coding_rules). Also, the most important killer feature of the polyfill as written is: If you have the C extension, it will use that instead of the PHP implementation. Ours is just for maximum portability.
I don't like PSR 7 either I use it now as some standard is better then none, but I would prefer if a new PSR comes to supersede it without the immutability nonsense it just makes it too verbose to work with and my IDE will keep complaining about reassigning the same variable. Even guzzle has become worse imo from v 5 to 6 when they switched to PSR7 it makes it all more complex without any benefits.
Yes I use symfony console almost daily (not the framework) https://packagist.org/packages/symfony/console
Has probably something to do with [leap cycle](https://en.wikipedia.org/wiki/Leap_year#Algorithm) of 400 years or [week number](https://en.wikipedia.org/wiki/ISO_week_date#Last_week) calculation.
I have just added Aura to the benchmark, but I ask you to review the configuration before sharing the results. In case of any suggestion, please leave a comment/issue on Github: https://github.com/kocsismate/php-di-container-benchmarks/commit/27d6a2d11904db05b76730a487a03846df9ea956 BTW: I used autowiring and I know it was a debatable step (but I always do it if a container supports it as noted in the "Method" section).
The problem is that they wanted to provide an API that you can build up requests/responses with while simultaneously being immutable. Just do a read-only API; that's honestly all that is needed because anyone can construct the innards of a new request any way they want and when it gets passed to someone else it's back to read-only. Mutable state is not the problem; it's *shared, mutable state* that is. Consider a large 2D grid. If I want to modify the interior points of the grid a bad solution would be this `withPoint(x,y, newval)` nonsense. Making a copy of the full `n * m` grid just to change one point, then making another copy just to modify the next one, repeated roughly `n * m` times? It's pretty obvious that's bad. The key is to build a new grid with completely mutable state, but when it gets shared with other things only expose read operations (or copy it and give them the copy). PSR-7 would have been perfect it it just exposed the read-only interface necessary for inter-operation.
Better just code in assembly to be safe. 
Neat catch! I'm curious though, what kind of use case do you have for working with dates so far ahead in the future.
You are right, the first two test suites use prototypes, while the second two singletons. Symfony being among the slowest in the last two tests was a bit weird for me too. But if you have time, I would be glad if you could review the config of Symfony!
It's weird to me how some PHP devs are obsessed with what one-way hash they use. It's really bizarre that it seems to be only the PHP community that maintains this obsession with what is the "right" hashing algorithm to use. Is this really that big of an issue? Doesn't Wordpress have other much more pressing things to deal with? Salted MD5s are far from ideal, but surely there's much more important things to focus on.
It also took me a long time to realise that there was really nothing wrong with this. I thought a lot about learning Python and advanced shell scripting, simply because "that's not what PHP is for". Then I realised how much shit I wasn't scripting purely because I was never going to get around to learning python etc. Now I write pretty every script I use on all my computers+servers in PHP. I know it well, it's fast, and has never caused any problems for me. And it makes perfect sense, as I can reuse lots of my existing code, and easily integrate OS/system stuff with my web systems. I even have a long running script that gets executed when a server starts up and stays running until reboot (inside screen). It forks multiples threads per minute (time sensitive web scraping), and despite a million people saying this is a bad idea with PHP, I've had zero problems running it for about 3 years now 24/7 on multiple servers. Never even goes over about 7mb RAM usage. Like some others said, the only reason not to use PHP for your script would be if you're working with other sysadmins that aren't into PHP. Most would likely have an aneurysm over this.
That is fucking hoooooorrible.
Sure - will do
 Like Willm said, you might be able to prepend on line 21: ``` 'attributes' =&gt; ['target' =&gt; '_blank', 'class' =&gt; 'icon-' . ```
As I understand it, Dusk was originally based on nightwatch (hence the name), but was a bit of a pain to customise.
I don't know if this is related to their cert... We had the same issue with Paypal the other month. Had to do CentOS 6: Upgrade CURL yum update php-curl libcurl Then restart any services that use PHP like Apache HTTPD service httpd restart However that's not the fix just yet. Anywhere you use CURL it still defaults to TLS 1.0, this is an upstream issue and can be resolved by forcing TLS 1.2 curl_setopt($ch, CURLOPT_SSLVERSION, 6);
have an upvote. haters gonna hate
For making a from-scratch php blog, should implementing Google's recaptcha be enough to prevent spam?
I also find it very weird, I tried to play with the dumped version to change the code to match Zen one, and compared that new version to the original, the gap is not much (5% which is -90us) and inconsistent (one time faster, one time slower)... Might be worth to look into.
&gt; Salted MD5s are far from ideal, but surely there's much more important things to focus on. As said earlier, the ability to move towards a password hashing algorithm is [a side-effect of one of those more important things to focus on](https://www.reddit.com/r/PHP/comments/5mcmjv/making_wordpress_secure_a_modest_plan_to_migrate/dc2jg66/). Not fixing this too would be negligent, especially since it's overdue by about 8 years at this point.
&gt; It's really bizarre that it seems to be only the PHP community that maintains this obsession with what is the "right" hashing algorithm to use. I would venture that this is probably because most of the other communities got this right half a decade ago, and the PHP community still hasn't.
Before anyone angrily downvotes or tries to correct him because of the existence of the password hashing API in PHP 5.5, I'd like to point out that joepie91 was commenting on the *community* not the *language*. * WordPress uses salted MD5. * Drupal uses SHA512Crypt. * Joomla only recently switched to bcrypt. * MediaWiki still uses plain MD5. There's a lot of cleanup still to do. And yes, it does matter: Bcrypt has slowed attackers down who have dumped hashes.
What did you change in the code? So that means that you also found Symfony rather slow in the latter tests?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phpsec] [FYI: Authorize.NET cert.pem might need upgraded today self.PHP (from r\/php)](https://np.reddit.com/r/phpsec/comments/5mfw05/fyi_authorizenet_certpem_might_need_upgraded/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
In the original dumped code, you get something like that: protected function getDicontainerbenchmarks_Fixture_Class99Service() { return $this-&gt;services['dicontainerbenchmarks\fixture\class99'] = new \DiContainerBenchmarks\Fixture\Class99($this-&gt;get('dicontainerbenchmarks\fixture\class98')); } I tried to change (applied to each method) to it to: // Same as Zen protected function getDicontainerbenchmarks_Fixture_Class99Service() { $entry = new \DiContainerBenchmarks\Fixture\Class99( $this-&gt;services['dicontainerbenchmarks\fixture\class98'] ?? $this-&gt;get('dicontainerbenchmarks\fixture\class98') ); return $this-&gt;services['dicontainerbenchmarks\fixture\class99'] = $entry; } // Another version protected function getDicontainerbenchmarks_Fixture_Class99Service() { $entry = new \DiContainerBenchmarks\Fixture\Class99( $this-&gt;get('dicontainerbenchmarks\fixture\class98') ); return $this-&gt;services['dicontainerbenchmarks\fixture\class99'] = $entry; } I did a custom script to profile the `$container-&gt;get()` with 1000 samples for each of those versions. The difference order is as stated above, 5%, but inconsistent: one time the original is faster than the Zen version and vice versa another time, so I guess it just means the difference is too small to be measured properly at least on my machine.
I see reasons not to make use of active record (Srp, testability ) .. but the total complexity "don't seem justifiable" to me and I'm willing to always make that tradeoff. 
Good job. I've also created a small app skeleton based on symfony http/translation packages, monolog, plates, phinx etc. https://github.com/odan/micro-app
Another name for this is *argument unpacking*; see the [docs](http://php.net/manual/en/migration56.new-features.php#migration56.new-features.splat).
composer update
I might be blind, but these two versions seem to be the same. Did you want to write something else for the second version? In fact, I don't think that the difference between Symfony and Zen lies in if the $entry temporary variable is used or not (am I right that this was your assumption?). The last two tests shouldn't even touch these parts, because these services must be cached during the cache warming phase. I'll try to catch the bug!
unless you use php-pm or similiar methods.
Oh yeah, `-vvv` says its loading. Thanks for the tips! Probably didn't make much of a difference in my case because everything's already cached.
And to continue with that analogy, if you ask such a broad vague question, there's a good chance you should probably just be sticking with Car anyway.
Great plugin, thanks for all the continued work. 
Funny, but this rfc isn't designed to replace psr-7, at least I don't think it is. It's designed strictly for the browser &lt;=&gt; php app relationship, which is traditionally done with Super globals, header() calls, and echo'ing content (among other things). 
In order to fix inconsistencies in results, consider using phpbench/phpbench. Opened an issue about it, but won't be able to pr, sorry ðŸ˜¥
Possibly an interesting approach, but it still isn't worth the effort. Why do I now have to maintain something in Rust when it can be maintained in the target language? Let's focus on language optimization, AOT, JIT, etc instead.
&gt; in a well-architected application you won't call your DI Container hundreds or even thousands of times because there should be only one injection point: when you invoke the controller(s) which handle(s) the request (but there is a good chance of needing the container in other places of the application layer - e.g. in your middleware or bootstrap files). This demonstrates a quite narrow "web framework" view of injection. Injection is not controller-specific, it applies to any object with configurable dependencies (and controllers are hardly the only configurable objects in a "well architected application"). This is irrelevant to the benchmarks, but I find it odd as a statement, as it tries to communicate what "good architecture" is about, and it's not that.
You will never be able to upgrade to PHP 7. Eventually your current version of PHP will be totally unsupported and any vulnerabilities in it will not be patched. Basically it will become a countdown to when not if your site is hacked.
Good idea! However compiled containers should offer comparable performance to a POPO factory. They usually contain some isset() invocations as a plus.
Not all REST APIs run on the web (or HTTP), either, if we care at all what Fielding has to say about it...
The mix of opinions in this thread should tell you precisely what both of these terms have come to mean: nothing and everything. And that's the only truly accurate answer. 
Well, you are right that maybe I shouldn't talk about "well-architected applications" in a benchmark. My intention with it was to highlight that mosts tests in the benchmark are not that realistic because in a good scenario (which I consider good) you won't call the container more than let's say a dozen of times during a request. You are also right that dependency injection is not controller specific, you might misunderstood me (I wish I wrote "there should be only one composition root"). That's why I'd like to share two posts about the topic which I enjoyed and agreed with very much. Hopefully they will communicate better what I wanted to say: http://www.brandonsavage.net/service-locators-dont-belong-in-controllers/ http://blog.ploeh.dk/2011/07/28/CompositionRoot/ I hope that you'll also like them. :)
&gt; My intention with it was to highlight that mosts tests in the benchmark are not that realistic because in a good scenario (which I consider good) you won't call the container more than let's say a dozen of times during a request. Indeed, but we need to run multiple requests, so it still adds up :-) Thanks for the links.
Ah, I see. Yeah, maybe there is something with the benchmark because I still could't find out why Symfony underperforms. :/
If you have "many files" with mysql_* functions you're already doing it wrong. Try creating a set of functions or a class that wraps the mysql functions. Once that's done it will be much easier to switch to mysqli or PDO. 
Although I call this solution a Poor Man's DI Container :) , this is a very sensible approach for many applications because it has less accidental complexity, just as you told. But as a project grows and you have more and more objects then a "real" container (especially one with autowiring) might help you to manage the essential complexity because you don't have to wire everything manually in the Factory anymore. At least this is what I prefer, but I can also agree if you think it otherwise. :) P.S.: You can find Symfony's generated container here: https://github.com/kocsismate/php-di-container-benchmarks/blob/master/src/Container/Symfony/Resource/CompiledSingletonContainer.php
&gt; Bypass your web app backend cache using only the browser This article could have been so much shorter when adhering to the title: Just cache bust it. Change http://some.domain/a/path/response.json to http://some.domain/a/path/response.json?randomChacheBusterWhatever=lalalalalala12341234 :P 
I'm not talking about browser cache, and the example is not sending headers to the browser, it's checking if the browser sent the no-cache header and acting differently if it was sent.
I was primarily making a joke.
Will you provide an example of a console app you use at work that runs on PHP ? I'm seeing many more people providing optimistic feedback than I expected. Edit : to be clear. I'm very familiar with PHP console apps like Artisan in Laravel, and other for-web-app console apps. I'm asking about PHP not being used as a helper for web applications. 
[removed]
I think he mean to tell you to group your data-access part into several class or function, once you want to migrate to another db or driver, you just need to take care of that group.
Or, you could just not shove so much crap into your headers?
You abstract away sql code by ORM. Now You can easier change databases but at the same time it's harder to switch frameworks 
Please answer the question!!!
step 1 TLDR
PHPDoc is used because the debug mode of the dumper is enabled, I've opened a PR to change this behavior: https://github.com/dunglas/php-di-container-benchmarks/blob/374015192f3c65620359be60d54a3d40f8eb2d0e/src/Container/Symfony/SymfonyContainer.php
Nope, HTTP is a requirement of the REST specification.
I'll share the updated results soon! But can you tell us why Symfony is slow in the last two tests? I tried to discover it but I couln't. :S
Another word of advice: do NOT enable HPKP unless you really know what you are doing. Enabling it is an almost certain vendor lock in. If you need to offload your website to a CDN or just an external HTTPS terminator later on, you can't unless you find a provider where you can import your existing private keys. 
PHP 5.3 is also not supported for security. So what's your point besides trying to push your libraries? 
Don't hate the hater, hate the hate
[safe mode](https://github.com/aidantwoods/SecureHeaders/wiki/safe_mode) will take care of that too :) See for the max settings safe mode will allow: https://github.com/aidantwoods/SecureHeaders/blob/master/SecureHeaders.php#L2220
Curious as to what you mean? RE the length of the CSP shown in the post: that's what is required for embedding Tweets, YouTube, loading fonts, Google analytics and Disqus. There's some reporting in there too, but that's really it.
What a horrible mobile website... Not optimized for mobile and not zoomable.
&gt; wrapping these methods adds cycles to every db access So does calling *any* function instead of always coding it inline. The difference is negligible, and pales into insignificance compared to the actual query execution time. &gt; What really pisses me off is seeing code that queries a DB loops through the recordset to store it in some obj/arr structure than passed back to the caller to be looped through again. Again that's negligible for the most part. And most wrappers allow fetching rows one at a time if needed. Generators in modern PHP make this even less of an issue. 
I have about 10 sites now in the HSTS preload list. Almost every CDN has HTTPS support. CloudFront does too (although they charge higher for HTTPS requests), and mixed content errors are trivial to fix. HPKP, unless you use includeSubdomains clause is specific to the particular domain name. If you use a CDN under a different sub domain, don't use that option. 
Hoping to see a lot more A's on there now! ;-)
So it improves upon the built in one? Or replaces it? 
Back in my day, 2Kb *was* the blog post with two shillings change to buy a life time supply of Freddos!
Thanks for all the responses. It has really put things in a different light and perspective on my end of things. I will try to take as much of these tips in as possible!
7+ has active support, everything below that doesn't. 5.6 is going to get security updates for another couple of years, as you said, but it is not actively being supported. That only means "critical" security updates. It is not enough for me to feel secure - like locking your front door but leaving the garage door open. So that's why I say 5.6 is unsupported right now. There will be no bug fixes, no security updates aside from ones considered by PHP to be critical, and there are newer versions with full support that should be used instead, and have been for over a year.
That's a good point, I'll do a followup covering some options. The TL;DR is: * shapes are part of the type system so must be built-in. They also are much more open to static analysis (eg the hack typechecker) than runtime options * TypeAssert is a composer-installed library. It's basically just meant to mean "I must have this type", and the error cases are FredEmmott\TypeAssert\{IncorrectTypeException,UnsupportedTypeException} - I should probably but some more work into the messages in those exceptions, especially in nested types. * There's no error if the API starts giving you more data, as long as they keep on giving you the data you've declared. * In an ideal world, your primary source of error checking should be making sure that the curl request had a 200 response. In practice, you also want to check that the json_decode() gets valid data, then depending on the particular web service operates, your options can include shape('error' =&gt; ?self::TError, 'result' =&gt; ?self::TSuccess), seeing if array_key_exists('error', $decoded_json_data), or, catch the exception when trying to assert the result type, and then try to assert it matches the error shape. Edit: list formatting
Also, shapes pretty much are arrays but with type information; they're not objects, and have the same sort-of-but-not-quite-COW semantics as arrays.
Or well if you don't want to pay for the IDE (you are making money using with that IDE right?) then at least you can consider Netbeans. Although the phpstorm personal license subscription is relatively cheap.
Hey, thanks. At my place symfony serializer is used as well, although a bit differently (and I think in a much worse way), someone figured GetterSetterNormalizer would be a good idea to use here so when we map an array to object we just iterate through an array and if there is a method with a name `set{$key}` then call it with the value. I guess by callbacks you meant validation? Like, real go-to-database-and-check-this-ID-exists kind of validation, I'm afraid this doesn't belong to the mapper (well unless you map IDs to entities, in which case you could work this out). So you'd have two stages: first is a mapping-and-type-validation stage, second is a business-rules-validation stage. Something like Symfony's validator fits here pretty nicely. Different config types is definitely something I intend to do, including Yaml, current design is config-type-agnostic so it's just a matter of adding a new implementor of `MetadataProvider`.
Everything in life comes down to conditional statements.
Thanks for clarifications. &gt; In an ideal world, your primary source of error checking should be making sure that the curl request had a 200 response Yep, I'm not opposing it. Just imagine that we are building an API (not consuming like in the post) and we use shapes in order to parse (or type-verify) incoming data from the request. And if there are some invalid pieces we would like to report them all in the response (along with a 400 code) say in the format of: {"errors": [ {"code": "incorrect-type", "field": "bid", "expected": "number"}, {"code": "missing-field", "field": "bid-type"} ]} If it is possible to do that with `TypeAssert` and shapes alone then that's what I was asking for :)
Which approach is best largely depends on the design of the API; eg if a good result is { "somefield": "somevalue" }, then: try { return TypeAssert::matchesTypeStructure(type_structure(self::class, 'TResult'), $data); } catch (IncorrectTypeException $_) { try { $error = TypeAssert::matchesTypeStructure(type_structure(self::class, 'TError'), $data); throw new APIReturnedErrorException($error); } catch (IncorrectTypeException $_) { throw new APIReturnedInvalidResponseException($error); } } If a successful query is structured like { "results": [ ... ] }, or even both "errors" and "results", then: type TAPIResponse = shape( 'errors' =&gt; ?array&lt;shape('code' =&gt; string, 'field' =&gt; string, 'expected' =&gt; ?string), 'results' =&gt; ?array&lt;shape('somefield' =&gt; string, ...)&gt;, ); Another option is: if (array_key_exists('errors', $data)) { throw new APIReturnedErrorException($data); } return TypeAssert::matchesTypeStructure(type_structure(self::class, 'TResult'), $data);
He is talking about back end cache..but he has a strategy that if the request received on the server has a no-cache header..he invalidates all the back end caches that the user can get a fresh page..so he does not wait until ttl expires
So this is not meant for shared cache just for private..have not realized it :)
Firefox in Android. Can't zoom out to read more without any left/right scrolling.
The cache can be shared too, doesn't matter.
Move the connection out of the function. It will let you determine if the problem is the connection or the query. Read this answer from SO on how to setup the connection : http://stackoverflow.com/a/15622468 This site has a function based option (looks like a singleton pattern) which might be easier for your use case : https://www.binpress.com/tutorial/using-php-with-mysql-the-right-way/17 (under the 'Connecting to the database' section) Also, you should post to /r/PHPhelp with support questions. 
thank you, I didn't know about /r/phphelp
debian/ubuntu backports the security fixes, so as long as you apt-get update + upgrade you are safe from the security point of view. if you need something else (bugfix, small feautre) from the newer micro version, then you can indeed upgrade via using the ppa.
Minor version would be upgrading to 7.1.x, which you should probably do anyway there are some nice new features. 7.0.14 would be a microversion update.
Doesn't the Forge UI kind of encourage multiple site servers? It's painfully obvious that yes, you can host multiple sites on one server. Forge makes it extremely easy to do so.
Including all post parameters is dangerous and might log secrets like passwords in plaintext. 
We log a full stack trace, a shorter stack trace with only our files, user id and email, a trace of their previous 20 page views (with time), their user-agent and IP, the HTTP request method, URI and the HTTP response code the user got. Some of this data is also posted to Slack immediately.
If you break it down further, it's comprised of 1s and 0s.
If an attacker on the network can intercept a single HTTP request for some HTML, or JS (just one bad redirect is all it takes), then lack of the httpOnly flag would let them bypass any CSRF protections the application may have (via JS injection). Without secure, well... attacker has the cookie on a single insecure request (be it for an image even â€“ mixed passive content is allowed out by most browsers). Actions that are CSRF protected in the first place, really should to be going over HTTPS â€“ so secure shouldn't be a problem for the pages that actually need to use it. httpOnly doesn't prevent the client accessing the cookie, it prevents JS accessing the cookie. Won't protect in all cases, but may protect in some. [OWASP recommends doing this anyway for CSRF mitigation](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet). This is the default behaviour because IMHO it has the potential to do the most good â€“ if it doesn't suit your application, then it is of course [configurable](https://github.com/aidantwoods/SecureHeaders/wiki/protected_cookie).
&gt; a project that adheres to semver ...*oh, my sweet summer child*... 
OK. When do you include it, make sure to use the dev version. I just discovered an issue with my git-subtree, so the tag that's there isn't the latest version. Thanks.
I've pushed an update removing the minimum-scale, and initial-scale params â€“ hopefully that should allow zooming out, and phones should detect the correct width (I guess for FF on Android it thinks scale 1 shouldn't encompass the whole page for some reason) Meta is now: ``` &lt;meta name="viewport" content="width=device-width"&gt; ``` Let me know if that helps/about any other issues you encounter :)
Yes, and then you're running a magento 2 webshop, that works fine on 7.0 but doesn't work on 7.1. It's not always simple. 
Is this project far in development? If not, you really should try to teach yourself a framework (Like Laravel). This way of writing code is very "oldschool". By using a framework like Laravel, not only will you save a lot of time (by having code re-use, and abstraction), but it will also be way more manageable. Also, the SQL querys in your code can potentially be vulnerable to code injection. Please check out how to do prepared statements. Now, over to your main question. In your first snippet, you are fetching the logged in users data from the DB, into an array named $userRow. So what you could do next, is to check the access value from that array, and redirect/do an action depending on that value. switch ( $userRow['access'] ) { case 1: //user has "admin" privilege // INSERT YOUR ACTION HERE break; case 2: //user has "manager/supervisor" privilege // INSERT YOUR ACTION HERE break; case 3: //user is a general user, and has no special privilege // INSERT YOUR ACTION HERE break; default: //user has an unknown or missing access level //WE ABORT HERE! throw new Exception("Invalid access level"); }
First, please use /r/PHPhelp for these types of questions. At first glance I am not sure what you are trying to do here $password = strip_tags($_POST['password']); $email = $DBcon-&gt;real_escape_string($email); $password = $DBcon-&gt;real_escape_string($password); This will alter the password the user entered. The password is not being put into the database so it does not need to be cleaned. If my password was `&lt;p&gt;&lt;span&gt;password&lt;/span&gt;&lt;/p&gt;` you would be only checking against `password` instead of the whole string. Also this line: if (password_verify($password, $row['password']) &amp;&amp; $count==1) { might throw an error because you are checking the count second and the `$row` variable might be empty.
I'd like to have whatever OP's having.
[removed]
[removed]
[removed]
Shit pseudo code but should be pretty obvious. $p = $_GET['password']; $db_hash = query('get the hash'); if (md5($p) == $db_hash) { // Login using old hash, transparently update to new $newhash = password_hash($p); query('update customer set password = '.$newhash.' where user = current'); } elseif (password_compare($p, $db_hash) { // Login using new // stuff... }
I think to use multiple on one server, you have to remove the default first and use custom domain names for each.
I understand, and I commend you for doing what you can with what you're working with... that said it's irresponsible for Wordpress to keep holding their ecosystem 6 years in the past.
There isn't a difference obviously but I was trying to keep it really simple and "small".. Having multiple files for those classes 'breaks that..' I know you can define multiple classes in a single file but that's a smell to me
So your answer is half yes and half no?
Where's the two tweets?
You are welcome, hope it helps on daily basis ;)
Meant less than 280 LOCs
"... in less than 160 tweets!"
In case of php, yes, objects. In JS carrying could be used.
Thanks for taking the time to reply--this the it into perspective for me.
Building a simple validation in 1 reddit post (and less then 2 minutes): // fullname:length=&gt;3|50 $valid = strlen($fullname) &gt;= 3 &amp;&amp; strlen($fullname) &lt;= 50; // username:length=&gt;3|25 $valid = strlen($username) &gt;= 3 &amp;&amp; strlen($fullname) &lt;= 25; // mail:email $valid = filter_var($mail, FILTER_VALIDATE_EMAIL) !== false; // another_mail:length=&gt;4|50,email $valid = filter_var($another_mail, FILTER_VALIDATE_EMAIL) !== false &amp;&amp; strlen($another_mail) &gt;= 4 &amp;&amp; strlen($another_mail) &lt;= 50; // password:length=&gt;3 $valid = strlen($password) &gt;= 3; Small, simple and really no dependencies. ;-) 
What does the errorBag function offer over just using an array? That seems to me an abstraction for abstraction's sake.
Thanks alot. Can you have a look on "Sources: Subversion, Git, Source Search" - Source Search doesn't work
&gt; BTW, can't we have an /r/phphelp link in the sidebar on the main page? Already there: &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help [...]
Ahh, good idea. Custom coercer would definitely work for this problem. Only other thing I can think of at the moment is for example 'state' field. We are using winzou/StateMachineBundle in our project and 'order' entity has some 'state' fields that needs to be transitioned with state machine from mentioned bundle. But I imagine this could also be done with custom coercer. I will give your package a try :) 
From codegolf.stackexchange.com Here is the link to the original answer: http://codegolf.stackexchange.com/a/105821 And another one, only 69 bytes long: http://codegolf.stackexchange.com/a/105823 It would be interesting to investigate both solutions. 
One should definitely use this style of coding wherever possible to demonstrate an high iq.
Who in their right mind would care about a -0.14% change over a year?
PHP is great for some types of applications (anything web related), but not for others (desktop and mobile applications) and it does its job well. I don't think there is anything to wake up from. If PHP continues to add new features with the rate it did in the last years, it's well on the way to stay relevant. Looking at where other languages are going, I would like to see better UTF8 support, native support for asynchronous programming and for saner functional programming.
I don't know where they get there sources from, But github statistics show PHP as the 5th most popular language.
Interesting, thanks. I didn't know about this, but it works with the help of this little feature: http://php.net/manual/en/language.operators.bitwise.php &gt; If both operands for the &amp;, | and ^ operators are strings, then the operation will be performed on the ASCII values of the characters that make up the strings and the result will be a string. echo '`' ^ '*'; // ord(`) = 96, ord(*) = 42, 96 ^ 42 = 74, chr(74) = J echo '@' ^ '/'; // o echo '`' ^ ')'; // I echo '@' ^ '.'; // n echo '`@`@' ^ '*/).'; JoIn The whole expression: ``` &lt;?=($__='`@`@'^'*/).')(($_='-&gt;.&lt;:'^'__@[_')('&gt;'^@_,'%'^@_)),$__($_('|'^'=','|'^'&amp;')),$__($_(':'^"\n",';'^']'^@_));``` Could also be written like this echo // &lt;?= join( // $__ = '`@`@' ^ '*/).' range( // $_ = '-&gt;.&lt;:' ^ '__@[_' 'a', // '&gt;' ^ @_, _ is an undefined constant of "_", could also be '_', but this is 1char shorter 'z' // '%' ^ @_ ) ), join( // $__ range( // $_ 'A', // '|' ^ '=' 'Z' // '|' ^ '&amp;' ) ), join( // $__ range( // $_ 0, // ':' ^ "\n" 9 // ';' ^ ']' ^ @_ ) ); 
Number-wise, market share isn't just about losing ground, but its about others growing *while* losing ground. Perl and Visual Studio jumped up. The top 5 languages saw bigger losses-- so you can look at it either way. P.S: Popularity contests shouldn't matter when figuring out priorities and design.
Have you seen their methodology? They actually type in +"php programming" into Google and count the number of hits... I agree with your argument, it just doesn't apply here because the numbers themselves don't mean anything relevant.
That's why my P.S. is there. It shouldn't really matter *what* these numbers are. If it was 40%-- should we care? Not really. The "Who ... would care about a -0.14%" implies that there's some point where we should. If someone were to care about such numbers, we're probably past the point of needing to show concern.
I'm actually starting a new business based around this efficient code style. It'll save developers so much time!
but these days people flock around proved frameworks, libraries and all that stuff, forums are going the way of the dinosaurs and and if you see the graph, actually, almost every language on there, that was long enough, has a down trend. And I don't think it's actually due to losing popularity. I, actually, have way to many requests for my services than I can handle.
Because crawling search engines can really get you accurate results. And that stats can be manipulated by what you search for. Where as github is just simple they have X amount of repositories that are PHP or what ever.
i think its more important "we have X amount of downloads per language"
Yeah, xdebug is not even installed on the Docker image. The last benchmark result is generated on my host machine but it is not loaded either.
&gt; Of course but bugs on older version are often more known than on new one. yeah, that's usually means less surprises which is a good thing for stable distributions. &gt; We often hear about bugs on old version and half of the time, upstream fixed it in a newer version. The bash security bug few months ago, or hearth bleed are good examples : they were fixed on upstream but not on debian family. you mean that the distro did not backport the security fix at all? that would be surprising. hearthbleed: https://security-tracker.debian.org/tracker/CVE-2014-0160 not sure which bash bug you are referring to, probably shellshock: https://security-tracker.debian.org/tracker/CVE-2014-6271 https://security-tracker.debian.org/tracker/CVE-2014-6277 https://security-tracker.debian.org/tracker/CVE-2014-6278 https://security-tracker.debian.org/tracker/CVE-2014-7169 https://security-tracker.debian.org/tracker/CVE-2014-7186 https://security-tracker.debian.org/tracker/CVE-2014-7187 they were all fixed for debian/ubuntu.
The reason for this is that in PHP &lt; 7.1 generator arguments are only bound when the generator is resumed for the first time. You would see an error if you wrote `foreach (bug('a') as $v) {}` or *somehow* made use of the generator. As of PHP 7.1 generator arguments are bound when the function is called (i.e. execution now stops after argument binding, rather than at the very start of the function).
Definitely agree, this ranking methodology isn't very useful. Its just that with numbers, especially percentages, it requires looking a little to see if they're significant. We still don't know (though we could with $5000), but we know the usefulness of the numbers isn't a very good measurement.
`iterator_to_array()` works for me: https://3v4l.org/e9Ef4
Those account managers looking for Perl developers are so annoying.
Anyone notice the "n" in "\n"?
Regarding http://codegolf.stackexchange.com/a/105823 The string contains all the characters that need to be printed, bitwise inverted. The tilde is the bitwise operator, that inverts the string back to the regular representation, before printing it.
&gt; Why enforce secure and httponly for csrf cookies? Because it's been a best practice for a long time. 
&gt; Question 1: Do I also have to use DI Container for PSR-7 Response and Request objects? No, but why wouldn't you? Anytime an object is resolved from the DI container, you create the opportunity for people who develop using your framework to make changes that they see fit. &gt; Question 2: Is it oke to store DI Container as property? I say yes, some others might argue. I don't think it's that important. &gt; Question 3: Am I using the DI Container correctly? Do I even need a DI Container? I think this is a tough question to answer, I haven't looked at Aura DI other than the brief click through of the docs I did. The DIC's that I've seen, tend to define services in Service Providers. These are standalone classes whose sole purpose is defining services for your DIC. Defining services in your Kernel just seems a little awkward, though not bad. &gt; Do I even have to use DI Container for the Route object? Why not? I'd remove the call to the DI container to get the route in your `bootstrap` class. At this point, you're using the DIC as a service locator. If you have some code that is dependent on another object, you should inject that object. That's what the DIC solves, is the injection of that object into the related code. You can take your closure from bootstrap and create a class that takes two constructor parameters, `Controller` and `Route`. Those two objects will be resolved from the DIC container. Other things of note from the boostrap method. - Why is the return value of the controllers action ignored? - Why is the variable name for the controller render method called $html? `$body`is a better variable name, maybe you're rending XML, JSON, or yaml, HTML isn't going to be all that you will return from your framework. &gt; Question 5: As the controller class is not known yet (the controller class is retrieved from the route), I use lazy method to retrieve the router and create a new instance based on a value in the route. Is this good practice? Create a new class called ControllerFactory. People might disagree, but I'd pass the DIC into the ControllerFactory and have the DIC container resolve the Controller, that way people can inject whatever they want into the controller. It should have a `make` method that takes in your `Route` object. Move all of your validation logic from line 117 to the `make` method in your `ControllerFactory`, throw an error if the controller isn't valid. &gt; Question 6: Is it good to store the services as properties in the kernel or is it better to retrieve them from the DI Container every time they are needed? Services should be stored as properties on classes that need them and should be injected through either the setter or constructor. You shouldn't be injecting the DIC and using it as a service locator, except where I said it was ok in answer to question 5. Because I SAID SO. &gt; Question 7: Do I need to use DI Container for Dispatcher? Sure? &gt; Question 8: Is this the right way to print a PSR-7 Response? I believe it is. I'd try removing the DIC from your kernel and remember there's nothing wrong with take a private function and breaking it up into a small class. This is specific for question 9 which I didn't answer. Why not have a route factory class that takes a request and creates a Route. It'll be easier to test by itself than try to test from with in your Kernel.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Popularity shifts all the time, and yet you would directly translate that to relevance? Wow. Shit, I mean, that's genius. I would definitely work with a developer who makes choices solely based on popularity. Keep it up!
Duh. Nothing compared to the Php/wordpress Apocalypse we have been running for years now though...
Is it just me or is this a bit of a non story? Is it a surprise that foolish people (who don't add a password to the administrator account of their database) eventually get their database compromised? &lt;RANT&gt; I hope the front-end-full-stack-npm-node-yarn-agile-gulp-js-es-bullshit-wankers who don't know the first thing about system adminstration but "manage" these databases get fired. Less clueless fucks in the technology ecosystem === more robust technology. &lt;/RANT&gt;
Isn't that a bit hypocritic thing so say from /r/php, whoes whole selling point is that it "empowers" people like that to build stuff and host it on shitty shared hosting so that they don't need to know the "first thing about sys admin"?
Serves them right. A fool and his data are soon parting. 
You're a bit late with your exercise. PHP 5 is outdated for more than a year already. And your coding style is outdated by a century.
Well, if you are exposing your database to the internet without admin password and don't have backups, losing your data is pretty much what's expected. Hard to even blame the hackers.
Step 1: Don't overload functions/methods
So MongoDB has accounts and passwords now? I don't see any mention of that in their getting started guides. 
Taking down 10,000 databases is pretty significant, although the article doesn't mention how many of them are well-known sites. 
&gt; Question 2: Is it oke to store DI Container as property? As a general rule, it's not ok to pass your container to other objects and let them store the container as a property. This is a service locator trait and creates scope creep. The main reason to have a container is so your container can wire your services accordingly and inject the dependencies (not itself) into them. If you need to do dependency resolution INSIDE a service, then you are PROBABLY doing something wrong.
Its is (was until recently) the MongoDB default to leave the database open, that's the real story here
"The blackmailers aren't attacking randomly, they've only entered and stolen possessions from houses left unlocked and with nobody home!"
Can they rightly be called "hackers" in this instance? 
As pretty much all the big C-like programming languages with some sort of OO-like programming paradigm likes to use PascalCase/StudlyCaps or camelCase without underscores for class, object and member names, and since PHP belongs to that family of languages, you will greatly reduce the general confusion for any C++/Java/C# or PHP-programmer reading your code by not using anything else. The same goes for CONSTANTS and therefore also CLASS_CONSTANTS which were already being capitalised and separated by underscores before 1972. So, if avoiding confusion about your code in general is your goal, you might as well take a look at the PSR-1. This leaves lower case $under_score notation for local variables, but let's not start any religious wars now.
camel_Score
I do have some critiques on this article. Some points are true, other points are one-sided and other points are just plain wrong. &gt; Efficient: there will be an enhancement of the performance of the particular website built in PHP which is scalable in coding part and reliable when to deal with more web pages. This is just plain wrong. Efficiency is not only a matter of picking the right programming language for the job, but it's mostly a matter of choosing the right techniques and algorithms. &gt; Cost Efficient: Using PHP your website can be developed in the minimal cost as it is open source and free of cost. The same goes for Python, Ruby, Java and a bunch of other programming languages. The programming language should not be a factor in the costs. The developer is to biggest chunk in the costs of a website/application. &gt; Independent Platform: PHP supports all the major web browsers. It may be of Windows, Linux, and MacOS etc. So does Python, Ruby, Java, etc... &gt; Secured: PHP has got many security layers to protect against threats and viruses. It is one of the most secure ways of developing websites. This is by far the most ridiculous statement in the whole post. If this was true, I shouldn't be dealing with exploited WordPress websites on a daily base. PHP is not more secure than any other programming language. In fact, I dare to say that there are many programming languages that are by default more secure than PHP. The type-system of PHP makes it really easy for an inexperienced developer to create a very insecure website. Again, the programming language is just a tool. It's the job of the developer to make and keep it secure. &gt; Speedy: PHP can results into faster loading speed as it uses its own memory so it can automatically reduce the loading time. Again, not true. Speed is a matter of using the right techniques, hardware and algorithms. It has little to do with the programming language. PHP being an interpreted language will always be slower than a compiled language.
I agree with you. When I first started using mongo I didn't even know it had authentication, no joke. I always had it only accessible behind my firewall. Of course since then I took care of authentication (and kept it behind my firewall!) but the installation and getting started never mentioned authentication. I like how with PostgreSQL you can't even connect to it outside of localhost without setting up authentication. 
https://docs.mongodb.com/manual/administration/security-checklist/ Points one and two on their own security checklist. If you use new software on a production environment and only read the "getting started" guide you deserve to have your data deleted. Any system admin (or hell, even developer) worth their salt should have thought "I wonder how this thing authenticates people?" and would have realised pretty quick that they need to set up users. And even if none of that happened, a good firewall configuration would have solved this. I stand by my point that the people who have (mis)managed these databases deserves to be fired.
you should use invisible characters in your variable names and other utf characters to make your code more fun: throw new à² _à² ("WTF");
We use [PSR-1](http://www.php-fig.org/psr/psr-1/) with: - `StudlyCaps` for class names, namespaces and file names of classes - `camelCase` for property, method and variable names - `UPPER_SNAKE_CASE` for constants - `snake_case` for service and parameter names in the [Symfony](http://symfony.com/doc/current/contributing/code/standards.html#naming-conventions) service container and for names of templates and configuration files
&gt; snake_case I also use 'snake_case' for database field names in PHP. e.g. $row['customer_type_id'] 
Oh great they've added an authentication system, but weirdly unlike most databases it comes initially disabled. I've not used MongoDB since it first came out and back then it had no authentication, so when I wondered how it authenticated people there was nothing to read. I uninstalled it and went another way. It's good to see that it has it now, but they really should have their installation routine set it up, and the getting started guides should cover authentication before writing to the database. It still seems like an afterthought in MongoDB. 
Eloquent is Laravel specific, but I think most frameworks or even just workflows would be better off if they were using their equivalent tools
Link to the site has "http//eloquentbyexample.com" instead of "http://http//eloquentbyexample.com", missing the colon.
&gt; No browser will load insecure scripts on a secure page. That's true â€“ most do allow the user to enable them though. Most will also request HTTP pages if redirected there. &gt; Even if it did and your cookie wasn't accessible to JS, it must be in the page somewhere so it could just be pulled from whatever hidden input it's in. Also true, but it might not be in every page. Defence in depth is the goal here. (are there any reasons why JS should have access to a CSRF cookie?) &gt; CSRF tokens are not meant to protect against XSS, and they will never be able to. Nope, but making the attackers job more difficult by preventing JS access to sensitive cookies in the cookie store is always a plus. &gt; Could you please point out which part of that OWASP page recommends httponly for tokens? It only recommends it for session cookies, which a token is not. CSRF cookies *are* session cookies. They might not be the *session id* but they form part of the validation of the users identity when making requests (they attempt to ensure you served them the page that the request was made from). (indeed an attacker on the network can impersonate the user if they get hold of the CSRF token. So they should be protected in the same way you'd protect other session data.
You can certainly do this, but you should be aware that this is mixing an object cache system (memcached, redis) with HTTP caching mechanisms. They are both "caches" but are two distinct systems with separate purposes. The article is using HTTP cache mechanisms to decide whether or not to serve something from an object cache. It's sort of like using PHP for async code. You can do it, but it wasn't really designed to be used that way. (Not judging here, it's an interesting idea!)
But if you do this through \_\_get/__set, how would you define a read-only property, and prevent it from being overwritten? You're just causing more issues, by solving one. There is a reason for PHP not having annotation support. And as far as I'm concerned, moving code to annotations is a really bad practice, which is basically what you're trying to achieve. Yes, some vendors utilize some sort of annotation support, but i'd recommend you not being tempted to follow in their footsteps.
In my example, I have a read-only property, *$baz*, which I declare as such in phpDoc: &gt; @property-read int $baz Trying to write to this property will throw an exception, while reading it will work perfectly.
Yeah, I closed the tab when I saw it.
This is really a bad idea..I read the comments but I mean having an annotation parser because you think getter and setter methods are too much code and hard to read..they are anyway auto generated by your IDE and are actually very readable kind of best practice..you are making yourselves so much issues instead of following standard approach..if it is just a DX issue follow standards
This follows _pretty_ much every bad practice in existence. Don't use this as a guide / tutorial.
SQL injections and XSS/CSRF at all levels, this could be a very good material for security trainings
One of the old dependencies will probably be taken off line because of a copyright claim breaking the entire composer setup. It'll take a team of historians months of Googling the "[Wisdom of the Ancients](https://xkcd.com/979/)" to find out [Kik](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) broke the internet. 
Good point, we use that too.
This is an interesting opinion indeed. Here, the annotations are just an implementation detail as your class really has the property, but I understand you point, and I usually have this very same opinion (that's why I ask for feedback on Reddit).
Insofar as I can tell, you're getting the most bang for your buck invested in Laravel according to almost every metric here. * Lowest lines of code for the most features (if you care about downloaded size in composer). Seriously, [features](https://laravel.com/docs/5.3) * Lowest method complexity for the most features (if you're reading source, as you should be). Seriously, [read the source](https://laravel.com/api/5.3/) * Static methods aren't even a discussion at this point, everything evens out to within a few % points of eachother. Seriously, if you're lost, here's a [map](https://laravel.com/docs/5.3/facades) Anyone looking at choosing a framework right now for a brand new project (or even swapping parts of existing projects out) would be nuts to ignore this stuff. 
Would love to see the repo that you used to create the benchmarks. Does this include the vendor folder? As although it might not necessarily be Laravel, if the Laravel components are reliant on a zend/symfony components that would in turn would result in a higher cyclomatic complexity. 
Even that doesn't really excuse anything.
Stop posting horrendously bad code. On the upside, this code will not work in PHP 7
Accept I don't think it is, [it has it's own github](https://github.com/illuminate/database).
always camel case. Never underscore. At least in PHP
This must be what a zoologist feels like when the stumble upon a living specimen of an animal everyone thought was extinct.
He didn't wrote the measurement algorithms, he only used them. Why so sensitive on take the results as they are a measure of code quality?
&gt; I don't use Laravel or Php, so I don't care, yet I still took the time to be a troll lol 
THANK YOU! You saved me lot's of time and my client a lot of money.
No SQL injections! Yay!
This is like trying to teach someone else algebra before you've even learnt to count yourself. Why would you do this?
Connecting to a database that doesn't have a password should not be called "hacking".
You can just use CI's query builder, db forge and migrations. https://www.codeigniter.com/userguide3/database/query_builder.html https://www.codeigniter.com/user_guide/database/forge.html https://www.codeigniter.com/user_guide/libraries/migration.html As far as dealing with complexity I'd make sure to put all your DB access behind a repository pattern class you access the DB with so you can swap out implementations. Use something like pimple for a dependency injection container so your db config can determine what implementation your advanced queries run when you ask the repository to fetch data or run an operation. http://codereview.stackexchange.com/questions/42498/repository-pattern-with-plain-old-php-object That is the best advice I got. I like CodeIgniter's simplicity and maintain a lot of old apps with it as well as use Laravel for new projects. Setting up CI 2 apps with Pimple, Composer, Mockery &amp; PHPUnit keeps me sane and happy during my work day. 
What's the best method to turn mysqli connection warnings into actual errors? If I do `new mysqli('localhost', 'nobody', 'nopassword')` I only get a PHP warning, not an error. In particular it's causing an issue with Travis because a failing unit test (which is trying to connect to the database when it shouldn't) is showing as passing when in fact the build just breaks at that point.
You're free to run them on your own: https://github.com/sebastianbergmann/phploc
/u/colshrapnel so i need two classes, yeah. And "require" db to user, create constructor and then everything will be good, yeah?
whatever makes you feel better i guess
yes, you can do it this way. 
&gt; It is very hard to believe that after this highly-mediatized rash of ransom attacks any database administrator won't double-check to see if his MongoDB server is available online and if the admin account doesn't use a strong password. No it's not hard to believe. What I find hard to believe is that so-called DB Admins and their Management could install software without a decent admin-level password in a production environment that's open to the world?! 
I'm using Eloquent in a Slim project. Works like a charm.
Thanks for your good and extensive answer! Really appreciate it. I will try to implement all your tips :)! &gt; I'd try removing the DIC from your kernel Do you mean moving the DIC to somewhere else or do you mean to complete get rid of the DIC?
Try creating it in `index.php`, see if you can resolve everything from there. So rather than creating an instance of your Kernel. See if you can resolve your Kernel from the DIC. //index.php // 1. create DIC // 2. Add DIC Dependencies // 3. DIC-&gt;get(KERNEL) // 4. kernel-&gt;run 
Thanks, db forge is exactly what I was looking for. btw, what advantages you found in laravel after moving from CI?
**Here's a sneak peek of /r/myspace using the [top posts](https://np.reddit.com/r/myspace/top/?sort=top&amp;t=all) of all time!** \#1: [Best of /r/MySpace 2013 Awards (winner thread)](https://www.reddit.com/r/myspace/comments/1su3ws/best_of_rmyspace_2013_awards_winner_thread/) \#2: [Here's my Myspace account if anyone wants to look at it, though I doubt it...](https://myspace.com/theantsyartist) | [comments](https://np.reddit.com/r/myspace/comments/54laxq/heres_my_myspace_account_if_anyone_wants_to_look/) \#3: [Nail In the Coffin? MySpace Hacked, 427 Million Users Emails Passwords Dumped Online (hackread.com)](https://www.hackread.com/my-space-hacked-passwords-leaked/) | [comments](https://np.reddit.com/r/myspace/comments/4lteg5/nail_in_the_coffin_myspace_hacked_427_million/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Strawpoll](http://www.strawpoll.me/12056440)
Probably. Im a developer not an english major :) i always get the 2 mixed. Thanks though
Clearly my boss will be impressed right? I can just imagine their faces - almost worth it.
From laravel dependencies: "symfony/console": "3.1.*", "symfony/debug": "3.1.*", "symfony/finder": "3.1.*", "symfony/http-foundation": "3.1.*", "symfony/http-kernel": "3.1.*", "symfony/process": "3.1.*", "symfony/routing": "3.1.*", "symfony/translation": "3.1.*", "symfony/var-dumper": "3.1.*", Basically speaking... this metrics is just meaningless. 
For some reason SCREAM_O just popped into my head. I guess thats what ill call it now.
&gt;Laravel only uses http-foundation and console in any meaningful way. Oh. Why not then just get rid of the "meaningless" dependencies and code (and maintain) them yourself before shitting on the people you yourself are thus depending on.
Nobody is "shitting" on anyone. I released some code metrics using a tool somebody else wrote. I love Symfony and am thankful for what they do.
I think you're missing the point. Average complexity per method is indicative of a particular "style" of coding. It has nothing to do with the solutions. Very complicated problems can be solved with low method complexity. I'm sorry you find the metrics uncomfortable but that doesn't negate the facts. Doctrine chooses to solve the database problem one way and I choose another way. Nothing about the approach they chose dictated what the average complexity of their methods should be. *They* chose that, and that is what I'm measuring. If you want to simply throw your hands up and say their problems can't be solved cleanly and with low complexity then that is your decision I guess.
So what is this metric actually good for? I can't really see the point..more complex frameworks have more complex metrics..thats why Laravel is at the level of a microframework? Or is it just about best practise to have short methods?
He didn't actually "shitting" anyone. But this has effect like this since most of developers will think something like "Oh... so it simpler and all this frameworks are just a scary mess". This is the same marketing trick that was used years ago: http://static.tvtropes.org/pmwiki/pub/images/free.png
&gt; at the naivety demonstrated I think he [know what he is doing](http://images.dailykos.com/images/153228/lightbox/Screen_Shot_2015-07-10_at_10.03.35_AM.png?1436540645)
There's nothing preventing you from using any routing library you want within an Opulence app. The one that's bundled places nicely with its HTTP and DI library (if you're using the rest of the framework), but it can be easily swapped out. It also allows for grouped routes, middleware, and generation of URLs from route names. I think those might be compelling reasons to use something besides FastRoute (although it is a slick library!).
interesting, first I have heard of this. Taking a look :)
&gt; Average complexity per method is indicative of a particular "style" of coding. Nope, this just means that this code contains multiple execution paths. Nothing more. &gt; Very complicated problems can be solved with low method complexity. Implement any parser (json for example) with low cyclomatic complexity. &gt; They chose that, and that is what I'm measuring. What I'm trying to say is that focusing on metrics doesn't solve anyone's problems.
Taylor, what exactly are you using symfony/routing for if it's not a meaningful (or even critical) aspect of routing in Laravel? Second, of the dependencies listed, the two you mentioned are the two largest and most complex. I realize you were looking to primarily measure *code you wrote* which makes sense, as this type of metric is about helping you check for things to improve or give yourself a report card. So, I definitely respect this post for what you present it as, despite the fact that I really (personally) dislike Laravel every single time I have to use it. I do think that the inclusion of "% static methods" is kind of bullshit though. True, Facades (as you implemented them) are not true static methods that operate without an instance, but the *complexity* static methods introduce is not about the fact that they're static, it's about the fact that they can be called from any scope and a parent scope cannot restrict a child scope from doing so. The ability to call something statically even if it's not actually a static method introduces a LOT of complexity and mental overhead in my experience, and basically all of Laravel's complexity, again in my opinion, is hidden away in this little niche. (EDIT: It would add just as much complexity to have a service locator or dependency container that you add a static instance accessor to.) It also makes writing tests more complex, which discourages testing, reduces ability to reason about code, and reduces stability of the application. I am not surprised that Laravel scores very well with these metrics, because Laravel's complexity is in places these metrics will miss.
I really like the Host Matching as part of the router. I really like Multiple Methods - $router-&gt;multiple(["GET", "POST"], "MyApp\\MyController@myMethod"); Most of it really makes sense...spoofing REQUEST types begs the question, why add hacks into it that you could add yourself in 5 minutes? Other than little things like that, I like it.
We make one call to Symfony routing to compile the route regular expressions. We do not use the rest of their code. Facades are easy to write tests for, as the documentation demonstrates and as I have proven on numerous occasions. If you have some example of a situation that is hard to test give it to me and I will either A) prove it is easy to test or B) make it easy to test by improving the framework.
I'm sorry I can't continue discussing this with you. It's clear you are very distressed about these results (as I expected people would be). That is normal. But the conversation isn't going anywhere.
&gt; There is no reason for most of the private properties in your app class. Especially pdo. Pdo should be injected (by the container) into whatever classes need them. Storing it as a property makes little sense. Same for the other ones. Pull them out when you need them. I removed pdo as a property and injected into the classes that need them, thanks for the good tip :). However, the other ones are being used inside the bootstrap method of the Kernel. Is it better to pull them from the DIC there, or better to store them as properties in the construct function so that I can use them later on in the same class without having to resolve them from the DIC?
&gt; I wanted to compare the quality of the code written by the author's of the projects Then the title is misleading. Right now it implies that the complexity-metrics say something about the overall "solution" a developer might pick. I could write my own "framework" which is nothing but a simple wrapper (with all the heavy lifting done by vendor/ code) and get meaninglessly awesome scores on this metric. 
This looks like a great way of decoupling the DIC from my framework! However by doing this I need to be able to resolve the Route object and Controller object before calling the bootstrap method from the Kernel. I am having some trouble doing this, as the kernel gets all the routes from the pluginmanager, gets the right Route object depending on the Request object and then retrieves the controller from that Route. Not sure how to resolve all of this before creating the kernel.. Only way I see this work is if I pass the DIC to the kernel and resolve the Route and Controller objects inside the bootstrap method.
How is host specificity handled for situations where the application servers are ephemeral and dynamic (e.g. EC2 auto-scaling groups)? Edit: Answering my own question, MySQL [allows you to define IP ranges for hosts](http://dba.stackexchange.com/questions/48992/mysql-user-with-host-set-to-a-range-of-ip-addresses).
Quick question: what's the largest Laravel app you've worked on? Because for the large ones I've seen, the advice to put all business logic in scopes would lead to absolutely INSANELY large models. Like thousands and thousands of lines. That seems like something that looks really clean when you're doing it then looks like absolute shit when you're using it or maintaining it.
So what you linked me is something I have to pay for. From what I can see of the example pictures it's using factories, which will affect the database, which was the main complaint I was expressing. The problem is not that I don't know how to test, it's that testing almost any other PHP application is one way and testing Laravel is another. It's all, as far as I can tell, vendor lock-in. EDIT: &gt; Again, I've built multiple applications using AR and Facades and never had a lick of trouble testing anything. Of course, your DB repositories will have to hit a real database at some point (even using Doctrine) if you want to actually test them. This is just false. What are you testing by actually hitting the database? The DB library/ORM? The library has its own tests for that. The database engine, like MySQL? Why would you want to test that using your application and potentially be confused about where the problem is? The biggest rule of testing is to know what you're testing and test *only that*. That's not easy to do in Laravel.
At provision time the dynamic host needs to authenticate somewhere in order to be admitted to the network (even private networks). That's the time to also update allowed connections in mysql. Ranges, tbh, are fine for general stuff. But highly secure things need additional assurance. Cloud providers give you an API to check. Is this one of your hosts? Query meta data service. It is, now add it's IP to the list of allowed hosts. This is sort of what I mean elsewhere in this thread - it removes the logic and responsibility from SQL roles and puts it in security groups/firewalls/etc. Why would I use rdms for security when security products exist?
no, not ALL the business logic - definitely not! Sorry if I gave that impression. I was focusing more on teaching people to move it out of the controllers. That said, insanely large models or insanely large services or insanely large repos....they are all just classes, the code has to go somewhere. 
You are testing your actual query. If you do not hit an actual database at your repository level how do you know for certain you have written the correct DQL query? The correct query builder call? You don't. I seriously hope you are not mocking chained query builder calls or comparing DQL against some expectation?
Fair enough! I only meant that the ideas here would apply to any other project and their native tools; this isn't just another "Laravel thing"
DQL is Doctrine only, right? I'm not actually talking about Eloquent/Laravel in relation to Symphony/Doctrine. I honestly prefer neither. In *general*, I would say that your query builder code should be isolated from other application code if at all possible (something like a repository pattern) instead of appearing directly in controllers and services, but this isn't always possible or reasonable. If that is the case then you don't mock chained QB calls, you mock the one call to a repository method. As for testing the actual DQL/QB for semantic correctness, your only two options really are to compare the DQL/QB/SQL against some expectation or to run it against a database. But if that's the *only* thing you're testing then you're fine. Tests that try to test multiple things at once are bad tests, and unless it's on its own, database calls always end up being a 'multiple' thing. If they get separated out completely into repositories or some logically equivalent design, then when you test them you have confidence about what you are testing and you can reason solely about that thing, which makes the test much stronger and will expose problems more clearly. Basically, if you are testing your actual query why do that where you are also testing application logic?
Yeah it's pretty great.
I basically agree with you then after that clarification. I separate out all my DB interaction into repository classes that only do DB interaction. I mock those repositories in my controllers. But, when testing the repositories themselves I hit a real database since they only do database interaction. Note that I advocated this approach in my book about Laravel I wrote like 3 years ago. It's a common pattern in the Laravel world to separate all database interaction in this way.
CSRF cookies are not session cookies. They're used for CSRF prevention, and their value needs to be known to the client for that to work.
Why would CSRF require a client side cookie? It's usually server rendered data: https://wiki.php.net/rfc/automatic_csrf_protection https://laravel.com/docs/5.3/csrf But hey, if you want to use a cookie, don't set httponly on that cookie. This doesn't make the flag worthless and broken for the majority of cookies that don't fit your use case. 
Cookies are a common mechanism used for CSRF protection and it's just as secure as using a server-side value. Cookies are only available to the origin to which they belong so they're an acceptable mechanism for keeping a token.
So less code per method to me implies more methods, what about the amount of private methods and function calls? I know that doctrine and Symfony often try to avoid calling too many functions (methods) to prevent this overhead. What about run-time executed code vs compile time executed code? I also know that some of the more complex Symfony code is only ran compile time. I don't think it's fair to match a data mapper vs active record as comparison ;)
Wait, do you mean to tell me a framework author has selectively picked only the metrics that reflect his own framework in a positive light in order to falsely present his own work as superior to all others? Do you really expect anyone to believe someone would actually do that? Just go on the Internet and lie?
It looks like misdirected effort. Your fundamental designs are still fucked.
I've heard that tossed around though I can't recall seeing any hard numbers or stats on it. I believe there is a cost to calling a function vs running code inline but I would think that is something that is going to only make a large impact in very specific cases. I think the same argument applies for both sides of the coin. "We made this method long because it was faster that way" should be backed up in the same way that "I took these 100 lines of code and turned them into 20 functions because it was easier to read" should be backed up. Sadly, I think the latter is more subjective and besides things like Cyclomatic complexity probably hard to get stats on.
&gt; The biggest rule of testing is to know what you're testing and test only that. I'm not aware of any institution and/or person sufficiently qualified to express this as a rule. So let me talk about my personal opinion. That is, the biggest value of tests is that they test domain logic and pick up things that are actually breaking. That's not to say that re-testing things is great. It's wasted processing. But if I want to test my application: the simplest way would be to hit a URL as a browser would, and check the response, database etc. to see that the changes I expected have taken place. The approaches may differ, but the importance is not how small the units are or how little you re-test. There are benefits and trade-offs to each approach (like being able to zero in on breaks in smaller units, quicker; or being able to see how interconnected parts aren't talking properly to each other). The value (for me) is in having enough "good" tests to tell me when my domain logic is broken. If they do that, I don't really care whether they are integration tests or unit tests, whether they use PHPSpec or Selenium, whether I re-implement the public API of MySQL or actually write to the database. Those things don't really matter that much to me. And I think I have a reasonably balanced outlook in this area.
&gt; What I find hard to believe is that so-called DB Admins and their Management could install software without a decent admin-level password in a production environment that's open to the world?! Easy, those are the defaults upon installation.
Good point, and good efforts in maintaining the framework. I personally think that as the size of a project grows, the stuff you have to compromise in order to keep both complexity and readability in control keeps on increasing. Sometimes, its better to lean a bit more to the readability side since its getting important day by day. No one's going to make a fuss about a few functions or classes written extra, or that you created a wrapper class for something that could be achieved without it, thus making the code "more complex". But forget to indent code at right places or have variable names that are difficult to understand and people will complain a lot.
The point is not to avoid retesting, it is for a failing test to say something meaningful, like "oh, this change to a service somehow broke that thing I thought was unrelated" instead of "is that test because of the unrelated change I made to this service, or is there some migration I wasn't aware of, or..." Good tests tell you *what* is wrong, not *that* something is wrong. As you put it, you can test that from a browser. Most developer time dealing with bugs is not spent on discovering if things are broken, it's on figuring out why. This is the basic principle behind TDD: the tests define the behavior of each section of the code, and if the tests break then you know what behavior is broken.
I think you mean subjective.
A developer is a writer. You should learn to write English before you attempt to write code otherwise you'll just be another bad developer.
This probably won't be popular, but I don't personally judge code with a million small methods as being less complex as code with a smaller number of larger methods. It really depends on how the code relates, and for me it's often easier to follow a medium sized method than follow around a bunch of function calls that are split purely to remain extremely short.
That was the previous solution, but our Dev-Ops guy quit due to health reasons and no one seems to know how the existing mailgun service was configured or even how to access it. I'm not really an Ops guy either, and I know very little about setting up smtp. This was originally supposed to be a "small" task, since the emails were already being sent from the dev server. I just needed to hook it up to the production environment. Sounded like an easy task of just setting the correct parameters for the office365 server. I agree in hindsight, though. It would have been much better in the long run to just use mailgun. I've probably lost 2-3 days of work on this altogether.
Can be. That's why I read through every class and method by hand to look at that sort of thing.
composer is actually a php dependency manager. If your apps have no dependencies at all then, yes, I can understand the tediousness. Maybe start small and try Doctrine's [DataBaseAbstractionLayer](http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/) It should simplify some of your database code and maybe get you used to using a dependency.
Indeed, it all comes down to what you are testing. If you are testing the behavior of your repository, you should be testing against actual implementations. If you are testing a service that uses a repository and you simply need that repository to always return a specific entity on every -&gt;findById call, you can get away with a test double. &gt; What are you testing by actually hitting the database? The DB library/ORM? The library has its own tests for that. The database engine, like MySQL? Why would you want to test that using your application and potentially be confused about where the problem is? I cannot count the number of times I've had bugs in how I interact with persistence libraries. For example, I've done a LOT of work creating in-memory implementations before working on the integration layer with a proper persistence store. There are almost always bugs in my implementation of the persistence layer as I work through it. &gt; The value (for me) is in having enough "good" tests to tell me when my domain logic is broken. If they do that, I don't really care whether they are integration tests or unit tests ... This.
I'm far from being a fan of the Facades, but you are making too much of a deal of nothing. A Facade in Laravel is not different from ContainerAware in Symfony: they are both a way to have a Service Locator, i.e. not making use of the Dependency Injection. For testability: Facades tend to make it a tad harder (at least I find it so as it feels unnatural to me), but same goes for a ContainerAware class... Both should treated equally "evil". And I'm putting quotes there because there is places may you might simply don't care, e.g. often Controllers and Commands (it's a matter of opinion though). As for Doctrine/Eloquent: you may have unit tests if you want to, but it looks necessary to me to have integration tests (i.e. actual database calls) at some point.
I like /u/utotwel article because it's a kick in the pride of a few people that shouldn't take quality of their code for granted and review it a bit. But otherwise I agree with /u/simensen: ultimately those comparison are meaningless: - Depending of what the problem is, it's not always possible to easily split things in multiple methods without making things overly complex - There is a performance impact. Whilst I believe it matters not in most cases, there is very good reasons why Doctrine UoW is 3K LoC with little methods: performances are a critical part there - It is a matter of taste/opinion: some people believe a single big method of 100-200 LoC well written is more readable and easier to follow than 10-20 methods
If you develop exactly the same website again and again of course that it will be tedious. It will be tedious if you are using a framework as well, you will have to create the forms, the controllers, the views, the model, etc. At the beginning will be new and exiting but hen again tedious If you move to a new lang it will be new at the beginning but then again tedious 
Some of us get paid to build specific things. "Build fun things" is not a solution to that problem :-)
This is how I usually respond to bullshit marketing attempts... Do you patently listen to every marketing call you receive and respond in a insightful manner as to why you think they are full of shit?
I presented some interesting stats in a calm, reasonable way, calling attention to the fact that it is not an "end all" stat and that Laravel uses HttpFoundation. *shrug* 
&gt;I presented some interesting stats in a calm, reasonable way.. [Like this? as another user here have pointed...](http://images.dailykos.com/images/153228/lightbox/Screen_Shot_2015-07-10_at_10.03.35_AM.png?1436540645) 
I mostly agree with what you're saying, but why does everyone start taking about Symfony when I say something about Laravel? I never said anything about this problem being unique to Laravel.
:)... You can have a special preview of tomorrow's post since you felt like today's was unfair: https://medium.com/@taylorotwell/php-framework-maintainability-872fcdd83085#.vwgpogv1q 
Was C# ever popular? I mean its a cool language but ... 
Look at http://php.net/manual/en/function.move-uploaded-file.php to move the file out of /tmp and into your own temporary directory. Also look at the $_FILES[] array to see what the file's original name is. 
It's always DNS. 
Just elaborating on this a bit. Creating a class with a dependency of the DI Container means that class now has hidden dependencies. It could be using that container to get all sorts of things and you just can't tell by looking at the class definition.
I would think total number of functions would also help in pointing that out. I think it's safe to say Laravel isn't so much less complex as it is complex in a different way that can be and often is influenced by personal preferences.
&gt; Shit, even noticing the comments reducing by 3 characters each consecutive line should clue people into the care and dedication put into the code. How could I miss that in 2 years full of source diving O_O. I'm an oblivious man. Now, the real question is, do /u/utotwel has a natural talent, or does he have to reformulate his sentences until it matches the drop ? \^\^ Seems like black magic to me, even in my own language...
[isitdns.com](https://isitdns.com)
The joke I was emphasising *was* the typo an.
What you are experiencing isn't really specific to PHP. Sounds like you are getting bored with developing standard CRUD apps. Maybe it's time to branch out into other things. Maybe try out some API's or do some web scraping stuff and then build something with that data. Lastly, it never hurts to learn other languages. Elixir with Phoenix is a joy.
Sorry but you have a serious misconception of frontend, backend and client/server on your first paragraph
Dude. It is downright stupid. Not unfair. You are making a pathetic fool out of yourself. Please stop it.
I had to modify your code to get to run (as below), but it still fails with the authentication error. $transport = \Swift_SmtpTransport::newInstance('outlook.office365.com', 587, 'tls') -&gt;setUsername($username) -&gt;setPassword($password) -&gt;setOptions(['ssl' =&gt; ['allow_self_signed' =&gt; true, 'verify_peer' =&gt; false, 'verify_peer_name' =&gt; false]]);