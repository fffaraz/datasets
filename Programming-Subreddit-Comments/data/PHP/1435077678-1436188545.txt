So its purpose is to show they're just a communication tool by replacing them with something that strips them of their value as a communication tool. [Nice.](http://www.reactiongifs.us/wp-content/uploads/2013/08/picard_clapping.gif)
For the uninformed, what's their upgrade/patch process like?
We also had a new guy a month ago. A legacy project was his first one and he did not like it because it wasn't laravel or anything like that. So he left after his first week.. For example I don't care whether it's an old project or new cool project. (since it pays me well no matter what) http://replygif.net/i/718.gif
This is so true. If you haven't learned anything that's your problem and not because it's an old legacy project. 
If it makes you feel any better, I am migrating 15 year old classic ASP to PHP. Most of the logic isn't even in ASP, it is in a dozen stored procedures that call each other. All throughout that string of SP's are random bits of html floating around. Some of the html is in the ASP, some is in the SP's, and some is in the DB itself. In the middle of one of the procs are a ton of dynamically generated HTML tables that are all named with just letters with no explaination. Table A,B,C...AA,AB,AC... all the way up to table DA. We can't just throw it all away because there are super complicated business rules that no one knows and are not documented anywhere. Luckily, my boss understands how completely screwed everything is. The crazy thing is that this site has 3,000,000 users in its lifetime and they don't complain that often.
Good question. One of the common complaints after the Shoplift hack was that Magento hadn't documented the upgrade/patch process at all. They do now have this PDF: https://info2.magento.com/rs/magentoenterprise/images/Installing-a-Patch-for-Magento-Community-Edition.pdf
/r/phphelp
Since nobody seems to be giving you any specific answers, I would guess that there are some more common patterns that may be useful. I'm not an expert, but I think some common use-case patterns would be: abstract factory, factory method, and singleton(used in error logging... mostly). Behavioral patterns depend on the situation, including things like: Chain of Responsibility, Iterator, Observer, Template method. I would choose some of these to get started with some projects to test this out with. But honestly, some of the bigger concepts used in frameworks like laravel already have exposed you to some of the methods if you look into the source or understand the behind-the-scenes implementation. I think it is beneficial to figure out which patterns align with these standards. Of course, some patterns eventually become a preference amongst most programmers until they become a standard, just like programming language preferences. I would appreciate any extra tips as well because I don't have any professional experience with PHP either.
I have mentored plenty of people with less experience than I have. Its a real thing. Learning is always up to you, mentoring isn't school, its not a class. Its guidance. A very junior developer trying to make things "better" on his own with little or no guidance is very likely to only make things worse. Not there fault, its the fault of management and senior developers for leaving that kind of task to that developer without the help they need. The remark that everyone is a junior is a good one, but I feel a its a bit misguided in the way you mean it here.Everyone doesn't know most things. Everyone is lacking experience in most things because there are so many things you could know. Everyone has a lot more to learn. There are not many people who are generically "senior". In that sense, you are correct. Often times when companies are looking for "junior" developers, they still expect to get someone with tons of experience - by "junior" the mean "we want to pay you less". I do not support this idea of some super-dev who just knows everything and can do anything. That is a fantasy, and perhaps what you've seen is simply senior devs within a domain, who admit to not knowing everything. Thats a good thing. However, there are people who have enormous amounts of meaningful experience within a domain. Its the difference between technical knowledge and practical experience. Those people can offer guidance to people with less experience in that domain, and they should. A good team will have developers who are senior in for the major domains of the project. From there its a gradient of experience down to the most junior people. Everyone should be learning from everyone else. This is not a pipe dream, and its not wrong to want that. Its the way it should be, but it can be hard to find. I'll admit that I personally didn't receive much guidance. I did get some, what I got was more like direction. "You should look into this technology/technique to solve that problem." - that sort of thing, it was helpful. You have to learn on your own but you need to be able to be checked and guided by those senior level people. Again, don't expect classes and lessons. You need to do the leg work, but junior devs (and everyone else) should feel free to ask stupid questions and ask for help in how to solve problems.
Yes! Personally enjoying your job is not everyone can hope for, but in our industry its possible. Let me get something clear though - I also don't want to instill in people this idea of a perfect job where everything is awesome and you love the work and the company. A job is ultimately a job, and your doing it not as a passion, but to pay your bills. They are hiring you (with few exceptions) so they can turn a profit on what you build. If you enjoy learning, then thats what you need to look for - just keep looking for places that are doing something you haven't done before. You don't need to love the company or have a hard on for that specific domain, just keep on learning. 
Then honestly, you may be in a good place. As u/lastrites17 says above and below, you have an excellent opportunity here. When I started dabbling in php around 2004 and 2005 it was all the simple stuff like &lt;?php echo $_POST['foo']; ?&gt;, but you've been handed a gold-mine that I never was: you have the ability to through and find things like that and and refactor them so that use proper a security practice (or whatever the code needs). Speaking of gold mines, at least you're not working 12 hours a day for a dollar in a dark, cold and cramped gold mine, all the while breathing in gold dust and get lung problems.
You're now officially the most generous person in this subreddit, for gilding a whole thread :D That's amazing. Thanks, and have success with your test code coverage :)
and they say wordpress is bad.
&gt; I think there are better ways than using a switch statement. Do any ideas come to mind? Thanks for the tip on dependency injection - that does make sense now that I think about it! Would it make sense to register that dependency in the same service provider, or should I separate it into another one?
&gt; This is a collection of known design patterns and some sample code how to implement them in PHP. https://github.com/domnikl/DesignPatternsPHP
Sure, here is some pseudo code to demonstrate what I'm doing: In config/services.php: &lt;?php // ... 'team_host' =&gt; 'bitbucket', Then in app/providers/SomeServiceProvider.php: &lt;?php switch($app['team_host']) { case 'bitbucket': $this-&gt;app-&gt;bind('Full\Namespace\TeamHost', function ($app) { return new Bitbucket($guzzle); }); break; // etc... } So the Bitbucket class uses the Guzzle client to make HTTP requests to the API. It will implement an interface that defines common methods, ie one to pull the user's email address. I also figure I should mention that I'm using Socialite to authenticate with Bitbucket in this scenario.
Reading? It's not right to expect your employer to spoon feed you, take some initiative and find avenues of improvement, then if you reach a point where training will be beneficial your employer can step in.
Magento's security policy isn't the only thing that needs to be overhauled. Their extension approval process is downright abysmal
I gotta say the "$app" container aspect of Laravel is not very well designed. It's essentially global vars in disguise, and like with global vars, it's best to put as few items (... if any, but that's longer to explain) in it as possible. If you need a user-facing config file, where one can simply put "bitbucket" or "github" that's ok, but maybe you don't need to put in in $app. If you can't avoid it, you can probably at least namespace all configuration keys under $app['config']['team_host'] so there's less chance one of your config keys might conflict with a service name later on. Other than this, as I mentioned above: switch, hashmap or other way, picking one of several classes (including at runtime) to implement a given interface / contract as a dependency is common and a good practice.
Good call! I actually do have it namespaced in the actual code I've written, but I appreciate the feedback. Do you have any suggestions as to alternative ways I could do this?
You have the option to completely own this project, re-write it from the ground up, or even start again completely. I got given some utter shite projects when I was a junior, you just have to put up with it and make sure you learn from everything, even if it's how not to code something. Also, you can still ask colleagues for advice and such, so it's not like you're stuck. The problem is at junior level, you'll never get put on the new super-fancy tech project until you've proven that you can do the shit stuff first. I ended up having to work stupid hours and do allsorts to get my title removed, but now I've done all that and it's totally worth it.
Despite of all that's being said here, if you stay in a project you hate, eventually you're gonna quit-and-stay or just quit... This may help you: http://c2.com/cgi/wiki?QuitSuddenly http://c2.com/cgi/wiki?FraidyCats And of course: http://c2.com/cgi/wiki?CareerLimitingMove
Is there a story behind https://www.symfony.fi/favicon.ico ?
This, a thousand times. In 15 years, I've only worked at a couple of places that actively encouraged real mentoring. Even then, you're talking about something that happens on specific, management thought up projects under a limited timeframe and very infrequently. Pairing with a senior developer sounds fantastic as a way to learn, but from a business perspective, it's putting twice as many resources (and potentially a resource that's billed out at a higher rate) on the same problem. Learning from other developers is more like... yelling over cube walls or shooting out an IM about a specific problem. If I had expected to learn from classes, conferences and actual hand holding from other developers, I wouldn't have gotten very far. That sounds like a negative thing, but most developers I know are bored out of their minds a couple of days into some extended training on a framework or particular piece of software. Learning and adapting on the job is one of the most important skills for a developer to have. The other thing that gets overlooked a lot is the types of knowledge available. OP seems to want to learn more about newer version of PHP or specific frameworks or something, rather than the domain knowledge of the company. From a boring business perspective, having that knowledge of their legacy system is extremely valuable. If it's existed for a decade, it's important. Knowing where in that old school mess to go when something goes off the rails is worth a lot more to the mortals in the company than knowing the ins and outs of Shiny Fictional Framework's newest release. Development can be really boring. You can have to use a boring framework, work on a boring project, deal with a boring client or solve an obvious problem. There is no type of software company where this isn't the case. Game development can be boring. Working on social media can be boring. Creating websites for celebrities can be boring. Trust me on all of those. It's not all eureka moments and leveling up your brain. Anyway, bottom line, the talking pretzel is right. Senior developers are junior developers who pulled themselves up by their bootstraps. 
The fact that you think this is "below your pay grade" appears to be largely a statement of ego. The project you are assigned to sounds like a perfect learning experience on how to reactor a huge code base. Pick up a copy of *Modernizing Legacy PHP Applications* and learn everything you can from this code!
Sure, but not that exciting. I've had that favicon on my personal site for the longest time - for nostalgia. It's lovely when people have no clue what it is. Each time I notice a 404 for favicon.ico on my services I just pull a "curl -O http://janit.iki.fi/favicon.ico" to get rid of it.
Just seemed ironic on a post about HTTP/2 :p
Hi guys I have created several images to create containers with different versions of php with the xdebug support. these containers are stable with apache. placed inside of container designs are available over http. Additionally you can use DNSMasq for assign local domain for each container's IP. all this wrapped with bash-script. I think that you can use only image without efig wrapper for assigning domain for each container. You can simply run container with project and publish 80-th container's port to host's network interface. But efig can deploy data into database (now MySQL only). Look here: https://registry.hub.docker.com/u/dvapelnik/docker-lap/, https://github.com/dvapelnik/docker-lap (you can use this docker files for build images locally), https://github.com/dvapelnik/efig You can ask me about this if you need
Reddit in a nutshell.
&gt; the reality is that seniors are just juniors peppered with years of experience dealing with all kinds of crap and problems thrown at them this is a universal truth right here As to OP, the transition from junior to senior doesn't happen while a senior is holding your hand, it happens when you're 10 levels deep in code deciphering strange rituals that God himself preferred to forget. 
When you go to look for your next job, your prospective employers first question will be "why did you leave your last job?" You have the option now to choose what the answer will be. You can either say A) the work was boring and hard and I didn't feel like doing it; or B) after converting a legacy system into a new framework, erasing technical debt, adding appropriate functionality and commenting the damn thing so the next developer will know how it all works, I felt ready to move on to a more complex challenge. Think carefully about how your experience at this job will inform your next one and you will know what to do.
I was impressed originally with Magento's ease of startup for simple ecommerce sites and actually included it in some technology recos for some clients. I've only used it / worked with it on a development plaything level, but I'll have to check back in 6 months and see if they've updated their policies before including it any more.
Security patch process is to download a .sh file and run it on your server. I would hope any large software like magento would have an auto updater.
That's what I'm saying. I started there and learned slowly on top of that. Sanitation was the next step in this case.
I missed this great post, but... fuck that shit. Line up a new job and when you tell them why you left, show them the date that PHP 4.4 was EOL and ask them why they don't give a shit about their employes. Don't listen to these people telling you that having to learn about shit programming patterns from 9 years ago is good for your career. **Fuck that shit.** Your company is not gonna pay you convert it, if they were willing to do that, t would have been done 6,5,4,3,2, or 1 years ago. Your time in php will be fraught with dumb legacy code if you let it. Some of it can't be avoided., but I would never work for a company on 8-10 year old php code as a junior developer. That shit is cancer, and getting paid junior developer levels of money to do it is akin to robbery. They are robbing you of your youth and your drive to learn. You should be spending time practicing learning design patterns, clean coding principals, and software architecture. You are at least smart enough to know when your getting the short end of the stick. If you really want to do php and not be pidgin-holed for 5 years maintaining a php 4.4. app, _get the fuck out of there_.
I would create an interface for each possible override like the following: interface HeaderPluginInterface { function header($previousContent); } interface BodyPluginInterface { function body($previousContent); } interface FooterPluginInterface { function footer($previousContent); } A plugin now implements only the methods it really changes. A plugin would then look like: class FooterPlugin implements FooterPluginInterface { public function footer($previousContent) { return '&lt;div&gt;Special footer text&lt;/div&gt;' . $previousContent; } } You then just register all plugins in a big list of plugins and work thru them until your output is created: $plugins = []; $plugins[] = new BasicTheme(); $plugins[] = new HeaderPlugin(); $plugins[] = new BodyPlugin(); $plugins[] = new FooterPlugin(); $headerContent = 'Page title'; $bodyContent = 'Simple default body'; $footerContent = 'Footer'; foreach ($plugins as $plugin) { if ($plugin instanceof HeaderPluginInterface) { $headerContent = $plugin-&gt;header($headerContent); } ... } echo $headerContent; I think you get the idea. You may want to pass an additional parameter to the plugin functions that holds all current page context, wrap all that stuff in a class, ...
not sure about the 10 year old project, but i started a jr job with drupal and i felt the same it was all insanity nothing made sense and none of our client sites had any documentation, for me made it worse everyone was to busy to help right away. I was searching through code the same way, but u will get used to it, sometimes u have to search around for stuff, if u want some bonus points offer a differnt approach to the 10 year old project, maybe a better more rapid development framework.
I'd recommend LightHTTPD and SQLite if sheer install speed is what you're looking for. You're getting a lot of weird responses here because you weren't very specific about *why* you need this particular setup, and without reading all the comments where you've explained so far, it sounds really questionable. Even after reading them, and understanding where you're coming from, it still sounds ill-advised. I really don't think you understand your market. I've been privvy to a lot of small-business metrics in my position, and ease of setup for web properties in general is most often rated as incredibly low importance. Unless you're looking at a business of 2-3 people, most places are going to have either a contractor or in-house IT to do their software setups.
Any decent self hosted alternatives?
Honestly, a LAMP stack is like 10 minutes of effort and maybe a dozen commands to setup. Why do you feel that this isn't "turn-key" enough to be competitive? Even at an hour, I can't see taking a loss on an intranet app sale over it...
http://www.woothemes.com/woocommerce/ In most cases you wont need to self host. If you do for some reason, just use woocommerce. If your actually making money selling things, a hosted solution is usually more bang for your buck.
The quoted article (from zdnet) is written in such a way that it sounds the issues are in Magento software, while if you dig into actual reports: 1) 1 issue with a theme (from 3rd party) you can download from some site 2) 2 issues related to private messages and forms on Magento Connect website All the issues were fixed since then.
Ok, we passed few more minutes of this video (about casing all patterns to one - mediator, to show that all patterns just describe how objects interact with each other). As you already know from history, first there was a OOP and it's 4 main principles. In 1994 some guys wrote a book, where they collect all common solutions which they used in their projects and called them "Design Patterns". Those patterns was grounded not on OOP principles, but on their experience. In 1997 good guy Craig wrote a book called "Applying UML and Patterns" where he connect those design patterns by introducing GRASP principles (he called it patterns only because patterns were popular in those days). This video is all about misunderstanding of reasons and effect. Most of developers which want to learn OOP more closely fall into design patterns trap, since they don't have understanding of underlying principles. Patterns isn't something that developers must to learn. Without understanding of OOP principles this is just pointless. 
I would much rather work with Magento than Wordpress. The Wordpress codebase is a clusterfuck. That said, Magento has always failed hard at releases. We live in hope that Magento 2 will be better.
So, for those who might be wondering, this would be in the context of asynchronous PHP, like ReactPHP. I'm kind of curious if promises are a good idea for the PHP ecosystem or not. 
I use Prestashop, not sure how it compares in its entirety, but it feels better. EDIT: Sure, downvote me, but at least give an explanation or alternative. 
Going from one bad codebase to another isn't much of an improvement.
By and large, I agree with this (my last full-time position was as a Sr Architect; I do consulting now). I'm naturally a bit weary about any sort of rewrite (especially given the state of things), and it sounds like that may be near-impossible both practically and politically anyways. I think the key take-away from OP is this: &gt; Now, I don't particularly mind that, however I'm literally not learning anything new In any SWE job, and especially in a junior-level one, this is a huge red-flag. Anyone can bang out copy-pasta all day long; in fact, that's almost certainly how the codebase you've been assigned to got into its current state. Learning and understanding how to work more efficiently is how you make career progress, and doing that comes in many forms (SOLID design principles are generally huge here) In your position, I too would start looking for something new. I get the impression that talking to management about improving your current situation won't be very productive, though it probably won't hurt to ask. If it's a huge financial hardship or job availability is tough where you're located, try to cut down your spending now so you can buy yourself a bit of cushion. If the company isn't willing to help with your career progress, I wouldn't feel terribly guilty about looking for alternatives on their dime. Do you know what you're looking for? Skills you want to learn (or apply)? Any particular industry? You're already a part of an industry that comes probably #2 in ageism just behind porn (at least that's the case here in Silicon Valley). Getting good at PHP4 is so deeply beyond irrelevant that you really are actively hurting yourself in the long term. Recent PHP5 releases, even while it will always take some flak for its legacy, actually will have you learning skills that translate well to other software. It's the difference between being a PHP developer and a software developer that happens to be writing in PHP, and you should strive be the latter. If you want any more specific advice, including interviewing tips, feel free to PM me. One of these days I'll write up a series of posts on what I was doing while interviewing people, but until then I'm happy to do one-offs.
No it is on hold: http://blog.jetbrains.com/phpstorm/2015/06/hack-language-support-in-phpstorm-postponed/
It tells you you won't have to handhold them through their education. Very important for adding juniors to a team, as non-motivated or self-help oriented candidates are a drain on your more productive team members.
The remote coding capability sounds really great. I've never used Hack, but I'll give the IDE a shot with a PHP project and see if it offers anything else that PhpStorm doesn't have. Edit: After trying it, Nuclide (and Atom) are nothing more than a vim (or emacs if you swing that way :P) alternative. 
I've programmed in nodejs for a bit. The big problem in node is it was kind of split between regular callbacks and promises in libraries. There were ways to convert between the two but it just added some complexity. Promises were great for getting rid of the waterfall callback problem that node had. But for new developers it adds another thing to learn, which can be daunting enough if they're just learning asynchronous programming. I know speed and performance were big things for nodejs promises. If PHP has them, they need to be fast!
I'm frankly amazed at your ability to randomly connect fact and fiction into some non-existent epic battle between design patterns and OOP principles. You should write fantasy books and sell them. You have talent, it's undeniable. Meanwhile, in the real world, no one ever said "you should learn GoF patterns &amp; ignore everything else". Go figure. **EDIT:** Was wondering... can't you work dinosaurs into this story? [It'll be awesome, think about it!](http://imgur.com/Tb0rrEa)
&gt; Promises were great for getting rid of the waterfall callback problem that node had. But for new developers it adds another thing to learn ... That is one of the reasons I shared this survey. I'm not 100% confident that promises are a good idea for the PHP ecosystem as we move forward with better async support and practices. It would be possible to drop them entirely in favor of coroutines, which are much simpler to use (though not easier to understand how they work). &gt; I know speed and performance were big things for nodejs promises. If PHP has them, they need to be fast! I know that ReactPHP's promise implementation has some recursive stack issues, but it should be trivial to make performant promises in PHP. I'm pretty sure Guzzle's implementation was designed well for speed, and with the various performance optimizations in PHP 7, I'd think it would be possible to use promises with almost no overhead, especially if "then()" was totally dropped in favor of "done()".
"Comments rot. " - Uncle Bob If you're using / needing comments, means your code isn't showing its intent like it should. 
I don't believe that's a collaborative model, but a feature of the typical unmaintained solo project. Every non-trivial project has documentation, so there's no reason to avoid separate comment files...which were abandoned at some point in history as a strategy, without any scientific analysis of efficacy.
"Everything I need to know about Islam I learned on 9/11." ~ "Everything I need to know about Magento I learned from a [hello world example](http://stackoverflow.com/questions/576908/how-to-create-a-simple-hello-world-module-in-magento)."
Hmm... &gt; "Tests rot. " - Uncle Bob &gt; &gt; If you're using / needing tests, means your code isn't fulfilling its intent like it should. But I guess uncle Bob wouldn't say this because he loves tests. Interesting how we can put a spin on everything to confirm our bias, isn't it?
A web framework doesn't have to be hard-coupled to a container like Laravel is. Showing web pages and composing dependencies are two distinct concerns and mixing them causes issues like I mentioned above. The trouble is that if you decide to *not* use $app's container, you'd be fighting Laravel at every step. There are ways to do it but it's a long topic. The pragmatic alternative is like I said - keep the number of objects in $app small. And to add... keep your services and business logic separate from the framework. A web framework should only ever touch controllers and templates. **EDIT:** BTW, I might have forgotten to mention Laravel fans don't like me much.
If we're basing this on things he's said, then he's definitely a fan of tests and not a fan of comments. - statement offered without comment on the validity of comments
Loved Slim since the very beginning. Time to refresh my knowledge 
It sounds like you're planning something I'm going to be super interested about...
Thanks for the informative answer. What's the most reliable hack-compatible redis client?
I don't really understand what you mean by doing the same mistake.. but: Do you really think, that your framework is that great that your (serious) competitors would choose it over the thousands of alternatives (no offense)? And a framework alone doesn't make a great web developer.
I am trying to prevent or avoid a competitor from taking the application and using it as for their own site. I am talking about the application and my experience not the core framework itself. I am realistic and i know there are tons of talented developers out there that far exceed my talents but the reality is many competitors within the esports industry cannot afford to pay developers. I do not want to risk throwing the application up on git and helping the competition.
I didn't mention any market, I mentioned technical requirements for a PHP stack. But, lets take an example of a popular enterprise product right now, Splunk, which is a log management tool. You can download, install and play with Splunk in 5 minutes. Compare that to competitive Log Management solutions that might take 1-2 days to get going, after all the separate components are installed and working together. The advantage is obvious, but in case it isn't... Now lets say an enterprise operations department plans to spend $1M on Log Management software, and asks 10 vendors to proof of concept their software. One of the things each company will be rated on is how easy the tool is to install and whether the customer can do themselves, whether special skills are needed, or whether services have to contracted. I gave plenty of information in the post, and I'm thankful for the people that answered that allowed me to get to a solution.
If you could put the barebones framework on git then I'm sure we could review it and see how you work. You don't need to have a whole application up on git for us to see your workings. If you're refactoring a spaghetti jungle into an oop friendly framework then I would recommend this book. https://leanpub.com/mlaphp I personally haven't read it yet, but it's been in my sights for a while now. :) Also, you should check out the vast amount of web development books on there to learn even more PHP goodness. Your sites look nice, but on your design website it looks like you are undercharging. I would take a guess that it's because of your experience, but if you can offer something like your framework as a selling point then I would start to charge more. :)
I don't understand the hatred shown towards Magento. Yes the release policy is bizarre, however the code is not that bad to work with. Certainly much better than wordpress. I feel sometimes people hate it because they don't understand it and it scares them. Yes it is slow, yes it can be cumbersome to change something small. However this is the downside to having such a powerful system, that is incredibly flexible.
When you say "posted on git" do you mean Github? Git is a tool, completely independent of Github.
Wow, just wow. I've been happily developing with Laravel for just over a year. Small, medium and larger projects alike. I haven't hit any problems so far. Especially no performance issues. So seeing all the haters in this thread really confused me. None of them actually explained what exactly their problem is. Use what you feel comfortable with, adjust when you hit problems.
I was talking in the more general sense, not just releases - in my opinion, wishing for a better Magento is futile. I do think their use of `__call()` without adding phpdoc magic method annotations is disgusting, but I agree that it's subjective. Combining the autoloader with code generation is a much bigger WTF, though.
If you'd like to build a chat application you should take a look at WebSockets and [Ratchet](http://socketo.me/). This is not exactly like Facebook Messenger, but it will do the job for a relatively simple chat application.
Yes. Things that execute in parallel are async.
Magento is garbage.
Buy a copy of the gang of four's Design Patterns and read it front to back. https://en.wikipedia.org/wiki/Design_Patterns
Why trying to re-invent the wheel? - http://www.igniterealtime.org/projects/openfire/ - https://www.ejabberd.im/ - http://strophe.im/strophejs/ Have fun!
Much movement. Such WOW! :p
Surprised this hasn't been mentioned yet, but TEST! Your code looks fine, a lot better than most of the stuff out there, so that's good. You mostly seem to be sticking to PSR-2 and variable names are OK (little confusing in some places.) The overall flow of the application seems to be fine, but I haven't tested it to see if it actually functions correctly. However, there are no tests in there at all, and that screams bugs. If you're not familiar with unit testing in PHP, acquaint yourself with PHPUnit - it's really easy to get started writing unit tests - tests that cover one specific part of the code. In your example, that might be a test for checking the regex in your router works as you expect it to. By doing that, and running the test suite before you push the application out, it means you know if any changes you make elsewhere in the code affect anything else (you'd be surprised how many bugs you catch with failing unit tests.) Testing is really interesting to learn about, and will definitely be useful in future - because once you know how to test, and what to test for, you can write tests about everything in every language. TDD (Test-Driven Development) is where you write code based on tests. It doesn't really matter if you write the tests before or after, but you aim to make your code as testable as possible, so lots of little units that do one thing, with predictable results. Once you've done that, and you're in love with PHPUnit, take a look at something called 'Behat'. It's a lot like unit testing, except instead of testing the code, you test the server and it's behaviour (Behaviour-Driven Development / BDD). Depending on the type of application you're making, it might be more of less useful, but it's another really cool bit of software. Instead of unit testing, Behat is a functional testing tool. It tests functionality - whether or not your code actually does what you say it's going to do. For example, if you promise me that a request to http://YOURSITE.com/pages.php will return a list of pages, I can write a Behat 'feature' to check that it does. I'd write something like &gt; Given I am a normal user &gt; And I have logged in to your CMS &gt; When I do a request to pages.php &gt; Then I should get a response code of 200 &gt; And the response should have a div called 'page-list' If you can write a full suite of tests, both unit and functional, you'll find that your code is a lot more consistent, and bug-free, and due to the way that you write tests you'll actually need to move your code around / refactor it so that it can be tested - which makes you think more about the design of your code. Sorry if you already knew all that and just haven't included your tests in the repo, but that's most of the information I wish I had when I started my first project like this - testing would have saved me so many hours of bug-hunting! Great start, and good luck!
DDD / CQRS :-)
You can go with Slim without any issues and I'm sure you can actually use just about any other framework since you can disable any cron based processing.
It's not the only way to do it, but I design my service APIs in such a way, so I can expose them to the public. "Can I make this public" is a good test for how well it's designed IMO. While the internal logic might be either of the code snippets you posted, the public API would be something like this: $result = $domain-&gt;bids-&gt;create([ 'listingId' =&gt; $listingId, 'amount' =&gt; $amount, 'description' =&gt; $description, 'startDate' =&gt; $startDate ]); $domain-&gt;bids-&gt;accept([ 'id' =&gt; $result['id'], 'userId' =&gt; $userId, ]); Notice I deliberately avoid having any object references in the API interface. This means: 1. I don't have to interact with the repository manually by "finding" objects to pass to an API. I pass an id, and the API will do the find()-ing if necessary in order to validate it. 2. If the API takes in simple assoc arrays and returns simple assoc arrays, you can expose it as an AJAX service 1:1 without any work (I'll show this a bit later). Now, if you want more static typing you can wrap your API calls in *Command objects*. Those are Data Transfer Objects (DTO) which exist only to describe an API call and are not part of your domain (they have no methods that take an action): $result = $domain-&gt;bids-&gt;execute((new CreateBid) -&gt;listingId($listingId) -&gt;amount($amount) -&gt;description($description) -&gt;startDate($startDate) ); $domain-&gt;bids-&gt;execute((new AcceptBid) -&gt;id($result-&gt;id()) -&gt;userId($userId) ); This gets you autocomplete and so on. It's nice but I consider it optional. You can start with arrays and add it later as an enhancement if *you need to*. Also notice I kept all bid-related activity on the "bids" endpoint (the "accept" call). The "users" endpoint should preferably have only actions related to user management: sign in, sign out, edit profile, change email and password etc. Here's the same API when used in AJAX context: $.post('/api/domain/bids/create/', { listingId: listingId, amount: amount, description: description, startDate: startDate }).done(function (result) { $.post('/api/domain/bids/accept/', { id: result.id, userId: userId, }); }); It's basically the same thing (using jQuery here, but, of course, that's a detail). It's *really nice* to be able to consume the same APIs from PHP controllers and JavaScript controllers, and it's *even nicer* that you don't have to put effort in creating and maintaining separate APIs for both. Exposing any endpoint via JSON can be done in a reusable way with a bit of reflection and a json_encode() call. Notice how the API URLs in JavaScript map 1:1 to endpoint methods. P.S.: In a real example, all API calls will have an additional field: authorization token, which both PHP controllers and JavaScript requests should send.
I think that a lot of frameworks should work on shared, just remember to composer install locally then upload the vendor folder alongside your project.
Honest question, why not? I personally find inline comments about the reasoning behind code helpful. Sure, you should be able to read and reason about the code by itself. Sometimes just knowing WHAT the coder did doesn't explain WHY they did it in the first place. Maybe 1 week/month/year/decade later it looks like pointless code that can/should be culled. But, in reality, it's actually got a purpose. Also, I find that as I start a new method that writing out what I want it to do in comments useful in collecting my thoughts fully on how to implement the method. Adding code to each of those steps results in documented code. Of course, I tend to prefer verbose coding over terse for the same reasons. Removing information, just because it's deemed unimportant right now, makes working on things harder in the future.
Design patterns *are* about building functional, real-world software in a way that can be reasoned about and communicated about with other developers. They are a set of solutions for known, common problems encapsulated in a common, known definition. 
Because I would like to.
If you want to do "pop REST" - sure. However HTTP doesn't constrain us to that interpretation. What I follow is: 1. Prefer GET (alternatively PUT or POST) for nullipotent actions (cacheable, no side-effects, i.e. no domain state updates). 2. Prefer PUT (alternatively POST) for idempotent actions (applying the action twice has the same effect as applying it once, for ex. setting a value of an entity). 3. Use POST for any other actions (not nullipotent, not idempotent). This is compliant with HTTP, and hence is properly interpreted by HTTP intermediaries. What you refer to I call "pop REST", a literal mapping of CRUD terms to HTTP verbs, which the REST paper doesn't talk about, yet it's a popular trend right now. HTTP being less perfect than we're willing to acknowledge, using the HTTP method as the only and canonical action identifier comes with a number of issues, some of which are hard technical limitations: 1. Some servers won't accept PUT, DELETE, PATCH requests, or require special configuration. 2. Some intermediaries won't treat PUT, DELETE, PATCH correctly (say Varnish may use PUT for write-through caching; it's optional, but it's against the HTTP spec). 3. GET requests can't contain a body, so you can run out of space when encoding a complex query in the URL. 4. DELETE responses can't contain a body, so you can't send information about the deleted resource. And there's also the fact that mapping everything to CRUD, its mental model doesn't scale well for complex APIs that should remain comprehensible by humans. It helps to be explicit about the action taken, either via the URL or passing a field like "action", rather than inventing confusing resource nouns to try and express a non-CRUD verb. The important thing to realize is: it doesn't matter to an HTTP client. HTTP doesn't assign any meaning to the words we use in URLs so what we put there is entirely subjective. The big arguments you see online about "verbs vs. nouns in URLs" are essentially fabricated out of thin air, and amount to little more than a "tabs or spaces in code" type of debate. To HTTP (and REST) a URL is an opaque identifier. An action can be a resource. *Anything* can be a resource. And the URL is the "variable name" pointing to that resource. BTW, case in point, how'd you map "accept bid" in pop REST :)?
&gt; Non-persistent web app framework with shared hosting? Hmmmmmmmmm &gt;The most popular web frameworks seem to have processes which are constantly running. hmmmmmmmmmmmmmmmmmmmmmm This does not make real sense to me. What do you mean "persistent process"? it's just apache running PHP, this has nothing to do with the framework you use.
And that is the correct attitude when you want to learn things.
I’m on Dreamhost. I know they don’t allow Node or Django or CouchDB, for example. I know this is extremely vague, but their Acceptable Use policy states “any script/process/etc that adversely affects the ability of any other customer to satisfactorily use their provided services is forbidden.” Perhaps I’m wrong, as others have chimed in saying frameworks like Laravel aren’t always running.
If I have ssh access is there a reason I need to avoid running composer on the server? Or you’re just saying that’s the safest way to approach it?
As I have little time to reply right now this will be brief. I don't disagree with your sentiment at all honestly. I've spent a lot of time thinking about API design over the years and I like the idea of RESTful design, but it's also impractical in some cases and you hoop-jump to make things work. What I was trying to point out was while your example looks like it's trying to have RESTful styled resource endpoints, you are also using RPC style calls. In this case, why mix the two? Why not embrace that RPC aspect or the REST aspect exclusively?
So it's like both a crappy IDE and a powerful editor?
Seriously? No. Just no.
Haha, I'm not particularly married to Laravel so that's alright by me. Thanks for the food for thought.
I can't point you to an article, but from my experience, digital ocean offers one of the best quality vps services at one of the most affordable rates.
Thank you for the feedback. The application is no where near finished i have been searching for online resources or tutorials to find better ways of doing things, etc. Would jumping straight into testing be the ideal route to take or continue tutorials, etc. finish the application then testing? I have glanced at phpunit and have a few tutorials bookmarked, but i have been prioritizing grasping oop and building the application to gain a bit of experience. Are there any resources you would recommend in particular for continuing learning/growing? Maybe some with realistic code examples, etc. - I know this question is unrelated to testing, and i apologize just trying to extract as much knowledge/help out of everyone as possible :) 
https://www.easypost.com
Because engineering is about designing according to goals, and not according to trends. I do understand people emotionally associate RPC with solutions like SOAP and CORBA, while REST is associated with the web (which it's modeled on). But that separation seems artificial. - With RPC, you have a client-server model, where the client calls procedures (functions, methods) on a server. In general they represent commands and queries. Commands may manipulate state, queries may fetch state representations. - With REST, you have a client-server model, where the client calls procedures (HTTP methods) on a server, that focus on manipulating and querying resources. Which encapsulate state... but sometimes also encapsulate a command-queue, i.e. a procedure (many REST APIs do the "POST command-to-do to /commands-queue/" trick when CRUD fails them). The mindset of those is slightly different but they're entirely equivalent. The one distinction is that RPC doesn't talk about a uniform interface, while REST does. But I do follow that interface and gain benefits from it (like caching) - I don't violate it. Instead of me guessing, I'll just ask: what should I do, in your opinion, so I "embrace RPC". And I'll answer why I don't do it, or why I do it.
You can add the error.log to .gitignore so that you're not uploading your actual error log. I'm glad you purged your /application/config/constants/system.php file of all relevant (to you) information, but in the past, other users have cautioned not to have a config file in your repository (so that it wouldn't be overridden on upon downloading a new revision). It would be best to have an installer/updater file that checks for the file and creates as necessary, or ignores if it's already there.
I still don't agree with the Throwable interface. I think Throwable is more confusing than using BaseException.
I think you should choose the one that works best for your design goals. But I also think mixing the two styles is... inelegant.
Well ok, but can you clarify how would I "unmix" the two styles. I have an idea what mainstream RESTafarians want an API to be like and I addressed why I don't match that verbatim. What about the other option - what should I do in your opinion, in order to "embrace RPC"?
https://www.rocketship.it BUT you could spend some time and do it all yourself. UPS, FedEx, USPS all have their own API's publicly available. They use SOAP calls last time I looked, which aren't hard to do yourself, and you will gain added functionality by writing it yourself. It will take quite a bit more time, but you can totally do it. I did this a few years back on a project and it worked just fine.
The "server" commands in a lot of these frameworks are just PHP's local server, and should only be used for ease of development or testing, not in production.
Didn't realize i uploaded that, thank you for pointing that out. As far as the config files i am assuming you are talking about using github vcs. I am new to github i provided those files just for feedback. Once i learn how to use github properly i will keep that in mind :)
You have three options: Ajax polling every few seconds or minutes, Ajax long polling, or Websockets. Websockets have fairly universal support at this point, and some websocket libraries even provide a flash socket fall back. Ajax polling is simple to implement, but causes a lot of overhead traffic. 1 user would be making 10-20 requests a minute, so you would run out of resources fairly quickly if you had a lot of users. The upside is that your code is simple and you can configure keep-alive on the server to handle it, but again, not recommended. Ajax long polling is essentially sending a request to the server, the server sits in a loop until something happens or a few minutes pass. If something happens, it immediately sends back the result. The client processes the result and reopens another long polling session. If the loop expires, same thing, null is returned, a new request is made. This is what Facebook used for a long time prior to using sockets. It works great, but is more difficult to configure. You have to worry about blocking processes (sessions especially) that cause issues with the connection locking up. Finally websockets are great and I use them. You can use Ratchet to create them in PHP, or you can use any other language. Essentially it is a process that is constantly running (like a webserver) that looks at a specific port, receives and processes traffic and responds. The websocket server has a lot of security protocols and handshakes, so using a packaged library does help. It is fairly universal and runs on any browser (http://caniuse.com/#feat=websockets). Like I said above, some client libraries even provide a fallback to a flash socket that can interact with your websocket server. I like Ratchet, but it can be a little overwhelming at first. I also use Node for a few websocket servers. If it is just chat, Node would be very very simple to get up and running. If you are doing more interactions and storing stuff in databases, Ratchet may be easier for you. Either way, I suggest using Websockets over the other two methods. 
not entirely sure whats with the indiegogo ... this leaves me feeling very unwell.
Well HHVM has Redis support built-in, but a Hack specific one? Don't know of one.
$0.05/package is worth paying for, IMO.
Hi Geggieto, Can you expand on your concerns here? I know some developers are very passionate about open source and that some believe that code libraries should always be open source. We've been providing proprietary libraries for the better part of 2 years now. I try to open source as least 1-2 packages per quarter though. Thing is I invest a considerable amount of time and money into our open source products but one area that is always an issue is justifying the training material costs beyond basic documentation. With web application security such an important topic is such a campaign out of the question? What fears do anticipate from campaigns like these?
You're basically saying that if I use more than one URL, it's REST, and if it's REST, then POST should create something under /create/. Let's explore the basis of that claim: 1. REST doesn't say anything about what POST should do. In fact, the paper doesn't mention POST at all. 2. HTTP suggests POST *may* create a subordinate resource, however, a "subordinate" resource doesn't mean its URI should be the parent URI + a suffix. The URI can be *anything*. Which means the URL I send POST to can also be *anything*. 3. HTTP also says: "The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. [...] The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result". What is that convention you cite based on? It's not the REST paper, nor the HTTP specification. So is there any remaining reason I should follow it? I see nothing but a fashion trend in the developer community, but fashions don't last. Also I have to call out what your example changed. It's still HTTP, with a URL and method POST. The difference is the disclaimers embedded in the format: two mentions of RPC, mention of "method" and "params", and dot as a separator. To what end? Are zealots so scary we must pepper our APIs with redundant details as a series of tedious winks and elbow nudges towards the REST crowd, saying "see, it's not REST"? And to address the elephant in the room - what happens with my cacheable crawlable GET requests? Or my idempotent PUT requests? So I lose tangible technical benefits of the HTTP protocol, but I win avoiding the wrath of REST zealots (who haven't read the REST paper). I'm not convinced.
See http://git-scm.com/docs/gitignore. Though not directly applicable to the types of actions PHP normaly creates, see https://sourceforge.net/p/freecol/git/ci/master/tree/.gitignore as an example of a .gitignore file for a JAVA project. It keeps file that can be generated separately off the repository as those can be compiled on the end-user side. For PHP projects, the only files I can think of off-hand would be: * log files * config files * directories and files created by uploading binary data (images, pdfs, etc.) to said directories by the end-user of the CMS. See https://www.codementor.io/tips/1196438172/recommended-gitignore-for-php-web-projects as well.
node and databases are services that are constantly running, just like apache is constantly running. apache only runs PHP code when it's requested, the php creates a response and apache sends that back. in between requests PHP is not running, it's not persistent in anyway just by itself. There is no "php daemon" so to speak, it's just an executable, e.g.: when you run `php myscrip.php` the executable runs the file and stops after it has finished. Node runs more like a service, and does for javascript what apache does for php (as a very high level example). it's bound to a port and keeps listening to that port for incoming requests. (the same as apache binds and listens to port 80) That being said, if you really want, you could also make these kind of applications with PHP (like [reactphp](http://reactphp.org/)), these would probably be prohibited on your hosting environment. but these are very special frameworks or use cases. --- EDIT: Have a look at the [Symfony2 documentation](http://symfony.com/doc/current/book/http_fundamentals.html), it's rather good, and many, other frameworks (laravel, drupal8, ...) are built using the symfony HTTP components as a base. 
Thanks
I think my main reservation is that as a developer I care about security and I get that you are trying to recoup some development costs. However what happens if your code requires updates and you don't meet your targets? Does the code go unpatched? Is it going to be forgotten in the near feature since you have milked all the money out of it? I would feel much better if it just had of been a donate button.
Okay, this is very promising then. It seems some of the best frameworks available are based on Symphony, so I’m happy to hear I should be able to use them without issue.
I've only watched a couple of these videos, but they look promising: https://www.youtube.com/user/phpacademy I also hear that team treehouse has great tutorials (I haven't tried them either): https://teamtreehouse.com/ These won't teach you exactly what you are asking about though, just general PHP knowledge. I imagine making a site like that would be pretty difficult if you're just starting out with php, especially if you want to code the bot yourself (which would most likely require some knowledge in another language as well).
&gt; Or we can keep using POST, which hasn't really changed its semantics ever since HTTP 1.0 Hah, finally something I can refute easily! :) http://www.w3.org/Protocols/HTTP/1.0/spec.html#POST In 1.0 a POST request "is used to request that the destination server accept the entity enclosed in the request as a new **subordinate** of the resource" This definition changed in 1.1 obviously. Roy makes a good point about POST, but seeing that there is a defined HTTP method that was designed specifically for updating a resource where POST has multiple possible uses (as you pointed out), it seems prudent to use that method when possible. As an interesting side-note, in that article's comments you see Roy discuss performing an action on a resource via a POST. POST /api/domain/bids/{bidId}/accept Presumably if you need to tell who accepted the bid you would pass that in the body.
There are a few different security categories [SQL INJECTION, XSS[Cross site scripting], CSRF[Cross site request forgery] Session Hi-jacking ... which one did you want additional information on?
I actually already addressed the "subordinate" point in my previous comment here. Subordinate to URI doesn't mean "URI + suffix". The distinction is semantical. When you pass a payload to a function, that payload is also a "subordinate" to the function - a parameter. You should also read the rest of the definition. Both HTTP 1.0 and 1.1 say a resource doesn't have to be created. It may be created. Or not. This kind of ambiguity is intentional, because as I noted POST is a bit of a catch-all as defined, and the list of possible interpretations are very broad and take the form of suggestions, which is very clear as you read it in the specification.
I came here to learn how to ship APIs better...
While user-defined classes cannot implement Throwable, it is worth noting that another interface can extend Throwable. That interface can be implemented by a class extending Exception or Error. interface PackageThrowable extends Throwable {} class PackageException extends Exception implements PackageThrowable {} try { throw new PackageException('Message'); } catch (PackageThrowable $e) { echo $e, "\n"; } 
There's no significant difference between the 1.0 and 1.1 definition of POST. There's another thing we're not touching on. There's an implicit assumption that a bid must be a resource. But it doesn't have to be. What is a resource and what isn't is up to who models the domain, not up to some made-up convention that nobody can trace back to a source. So: I can provide a bid collection as a resource, /bids/, provide several "action" resources for it and stop there. That's precisely how I model it in my domain, anyway, and how most repositories are modeled. It's a bit of a tragedy to think that we should bend our domain in order to expose it as a fully participating set of resources in HTTP, when it's clearly not the case. In my PHP infrastructure for endpoints I do support "parametric instances" (i.e. with id and so on in the URL), and I use them sometimes, but it's rare.
&gt; it is worth noting that another interface can extend Throwable Right, that's what I meant by extending it in this case.
Yep, just wanted to make it clearer for anyone reading, since Throwable can't be implemented by regular user classes. I might add that example to the article.
Too late, dev groupthink is too strong now. Just give it a couple years, these same people will be decrying the lack of documentation again.
o7 m8!
I understand, but I think this is a happy medium. We also have a pretty long track record for keeping our packages up to date, accepting PRs, releasing new versions. With the paid premiums we'll also maintain a vested interest. This way Sentinel is free and we have a chance to advertise, raise funds for cool features, create training material. Is donating to open source a bad thing? If there was just a donate button the library would you donate? From experience this is not the case. Sentry, predecessor to Sentinel had a donate button for years. We collected around 1k in that time. I put at least 60-80k on top of sweat equity into it. At least this way those that wish to support the project can simply just donate to the cause, or donate a little more and get some perks.
Have you bound the SCMHost to a concrete class? $this-&gt;app-&gt;bind(SCMHost::class, GitServer::class); 
While true, if you don't have the sysadmin skills to setup, configure, and maintain the VPS... things will get bad quickly.
[Lumen](http://lumen.laravel.com/) or [Laravel](http://laravel.com/).
This is a bit snarky, but if you don't have a database and you don't accept and user inputs then you've just reduced your potential surface area for attacks. But that won't be a very interesting website if you are afraid to take input or have a database. You could take the middle ground where you publish a static site with something like Jekyll and use third party services for all the stuff you may need like comments (Disqus) and forms (WooFoo). You could be even host that from a GitHub repo so you don't even have to set up a server with a hosting provider. I think this approach covers quite a few use cases and you might be surprised how much functionality you could get. 
Indigogo and kickstarter are supposed to be for startup companies to generate the revenue they need to start operating and produce a product. There is a growing trend where established companies which do not need crowd funding are using them as marketing/payment gateways for non-existent products in order to eliminate all potential risk to themselves and shift it to the backer. Given their rather extensive portfolio of projects, and the fact that they claim they are successful, I don't see how this needs crowd funding. **Especially** not flex funding.
&gt;thanks for your replay .... security in form input which goes to the database 
Fair enough; alhough, as I noted, there is nothing preventing you from distributing your own free Linux image, preconfigured with the best environment to run your paid app.
i'm using code academy at the moment to learn php. Is that a reliable source? if not can you suggest me some websites and sources?
I am not an expert with this and don't proclaim to have the "one true answer", but in my experience of running many small sites on a common CMS platform, each with 90% same functionality but some customizations (not as complex as you, but kinda similar)... I tend to prefer the "many copies of the app" approach that you've been taking. Functionality that can apply to many of the clients can go into the core app, but yeah have separate modules or override code for the client-specific custom stuff. The reason I prefer this way is because then the code of each customized app makes sense according to that particular client's needs (that is, the code is understandable in terms of how it serves the business goals, as opposed to serving an abstract architecture), and also the codebase is smaller. These 2 factors (code serving biz goals and smaller codebar) are the most important things (in my opinion) that help keep code maintainable. The alternative is you lump all custom code into 1 big codebase and have lots of switches... it's just going to be a total mess and depending on the customizations you have might not even be possible to separate out in a clean way. In terms of the big downside you mention (having to update a bunch of apps for even the simplest of core bugfixes) is, I believe, an easier problem to solve than the alternative. What I'd look into for solving this is: 1. Implement a version control strategy that facilitates it. If you're using git, maybe have one repo with the core app, and then use submodules or "subtree" for the individual client apps. Or utilize some complex branching strategy if you want everything to live in 1 repo. 2. Changes to the core app can be merged into all client apps fairly easily... BUT you'll want to make sure you have some tests for each client app just in case a core fix breaks some custom functionality. 3. Automate the shit out of this... for example you could have each client app running on an internal staging server, and continuous integration automatically pulls updates to the core repo and then runs automated tests on them. If they pass, you can be somewhat confident that the core fix is safe to push live for that client (and if not, then that's some more tests you will write so it doesn't happen again in the future)... so if you're feeling confident with the system you could then automate the deployment from stage to live server if/when the tests pass. It's going to be somewhat complicated to set up and educate your developers on, but will pay off in terms of helping manage the complexity over time. As with all complicated systems, start out slow, simple, and manual... then gradually automate things as you get confident and/or bored with them. Best of luck!
That will only work with your interface, ScmHost, isn't in a namespace. Also since ScmHost is an interface you cannot instantiate it. You cannot create an instance of ScmHost, `return new ScmHost;` will error out. Lets assume you want to use `GitServer` where you've typed hinted `ScmHost`, you could do: $this-&gt;app-&gt;bind(ScmHost::class, function () { return new GitServer; }); For this to work, `GitServer` has to implement `ScmHost`. In my original example, `$this-&gt;app-&gt;bind(ScmHost::class, GitServer::class);`. That says whenever you type hint `ScmHost`, replace it with `GitServer`. I highly recommend reading the documentation http://laravel.com/docs/5.1/container#binding-interfaces-to-implementations
There's nothing wrong with PHP, it gets the job done and there are some good frameworks built for the language. I would suggest to stick with PHP but hone in on design patterns and best practices. Branch out from the mid tier and learn the other ends of the stack such as SQL and frontend stuff like css and javascript. Also learn the tools available for PHP like composer or PHPUnit. If you've taken the time to lay down the foundation, just keep building on that. Don't jump around with languages right now. It's not about the language anyways. It's the frameworks, patterns, tools, and configuration stuff. 
How come an oauth server is a stretch goal for 75 000 $ ? There are literally tons of oauth servers written for PHP, and bridging one should not require that much effort to justify the sum
For those wondering, Invoke is a route-based authentication/authorization solution that makes it easier to check for things like groups and permissions too: [Invoke on GitHub](https://github.com/psecio/invoke)
I disagree. And maybe that's Python coloring my view. In Python, all exceptions extend from the common ancestor: `BaseException`. There's just a few exceptions that extend directory from it: * KeyboardInterrupt * SystemExit * GeneratorExit * Exception And then all other exceptions extend from the `Exception` class. This allows some exceptions to be "special" in that they won't be caught by the insidious `except Exception as e` pattern but still fit into the hierarchy (which [looks like this](https://docs.python.org/3/library/exceptions.html#exception-hierarchy) in case you're curious). Now, it's just as easy to dismiss Python's implementation in this discussion because Python doesn't have things like interfaces and traits -- we use abstract classes and mixins to fill that void.
As others have mentioned WebSockets are the modern solution for real-time chat/messaging. If you'd like to take a stab at writing your own PHP socket server without Ratchet, there's a short blog series that discusses the topic and covers things like encryption and the WebSocket handshake: https://chatbadger.com/cb/?s=chronicles&amp;c=10. Good luck!
The benefits of this RFC outweigh such a small use case IMO. For all we know, we could possible get new sibling exceptions, to how Python does it.
If an unnecessary closing tag is your biggest problem you're in pretty damn good shape.
That's exactly what this RFC replaced. Functionally, the end result is about the same, but the hierarchy is a bit cleaner. You can catch `Throwable` like you'd have previously caught `BaseException`, and your previous `catch (Exception $e)` (or equivalent `except Exception as e`) doesn't change scope from the sibling-level introductions. The only material user-land change is that your "oh shit" case changes from `catch (BaseException $e)` to `catch (Throwable $e)` - everything else works the same way. As a general rule (and this is not anything specific to PHP), your type-hinting should prefer interfaces over concrete classes, as it leads to more testable code. `catch`/`except` blocks are roughly a type hint^[1], so this is just an implementation of that principle. **Because** interfaces aren't a first-class concept in Python, it's forced to use the `BaseException` approach for the catch-all scenario. Ruby has a similar limitation. ^[1] In practice, it's closer to traditional overloading, with an implementation that can be though of as a series of `instanceof` checks.
+1 for Ratchet
We currently have the same business setup as yours - a core platform with several customizations for each client. Luckily for us we use Symfony which provides bundle inheritance http://symfony.com/doc/current/cookbook/bundles/inheritance.html This allows us to maintain our core platform while having the flexibility to customize for clients. So for example a client wants some customization in the Inventory module we just extend the CoreInventoryBundle to ClientXInventoryBundle then put all the changes there. Then any useful features that are developed there are folded to the core platform in the future. And as usual core versioning for each client is handled in composer. I'm not sure if Laravel has anything like this out of the box. You might have to cobble up several packages to emulate this functionality but this might give you an idea on how to structure your platform. The downside of our architecture is that we have an entire standalone application for each client, but maintenance is just a matter of updating the composer file and running update. My suggestion would be to have a single instance for the clients that has no customizations and a standalone application for each that has. This would make maintenance a lot easier.
Take a look at [Metasploit](http://www.metasploit.com)
It's not that interfaces aren't first class in Python. You can emulate them with abstract classes. Sure, at a conceptual level, abstract != interface but an abstract class that holds no state and has no implementation is functionally the same as an interface. Because of that and multiple inheritance, Python doesn't need interfaces. I suppose an Interface metaclass would be possible, but there's much more interesting things I could do with a metaclass. However, that's distracting from the point. If all your exceptions are going to inherent from exception which implements the Throwable interface and the interface won't be used anywhere else (would you implement Throwable for a nonexception - I cant think of a good usecase), what's the need for the interface? I'm not arguing against interfaces. They're really useful with or without multiple inheritance. I just think in this case, it's over engineering.
It's there any torrent to download that box? I am in really bad connection so.
Honestly? Haskell or Clojure. They will make you think about the fundamentals of logic and programming. They will make you a better programmer in PHP or any other language.
I'm going to provide the most basic, quickest answer: Have a look at your source code. Are you using prepared statements? When I see compromises like this, particularly when someone mentions a 12 year old codebase, it's nearly always a bunch of string concatenation and SQL injection vulnerabilities. (the longer answer: [Bursuite](http://portswigger.net/burp/) is probably the closest tool to your wireshark analogy) Edit: &gt;OWASP As much as people always refer to OWASP, they tend to do so because of one, short, "top ten" paper. Outside of that, your points are valid. OWASP has a tonne of projects that have no ongoing effort, and much of its information is obsolete. 
&gt; It's not that interfaces aren't first class in Python. You can emulate them with abstract classes. Sure, at a conceptual level, abstract != interface but an abstract class that holds no state and has no implementation is functionally the same as an interface. Because of that and multiple inheritance, Python doesn't need interfaces. They're not the same thing, and serve two completely different purposes. Interfaces are a contract. No more, no less. If something accepts an object implementing `Foo`, you're guaranteed that all of the methods in the `Foo` interface exist (and are public). Abstract classes are designed to be a base class that *does* contain state and some methods. There's of course nothing forcing you to do so, but it's a much more powerful concept. To use the stupid, over-used animal example: abstract class Animal { abstract protected function getSound(); public function speak() { echo $this-&gt;getSound(); } } class Frog extends Animal { protected function getSound() { return 'ribbit'; } } As you rightly point out, you can absolutely achieve the idea of an interface by having all methods in the base class be abstract (and hint to this base class). However, in larger systems, this approach becomes limiting when you need to add another abstraction layer, and this RFC is the prime example: the only way to cleanly add something "next to" the base class is to shoehorn in an additional class underneath it and add even more stuff into the hierarchy, whether it belongs there or not. This is in contrast to an interface, where you just have the other class implement the interface and be on your merry way. To think of it another way, **an interface defines your API**. It should not change (outside of major releases if you follow SemVer). You're **not** free to rename its methods without unleashing hell, so hopefully you've actually designed a proper system. The public abstract methods of an abstract class implicitly give you the same thing, but an interface makes it explicit. When you're creating a platform, explicit is always better than implicit. &gt; If all your exceptions are going to inherent from exception which implements the Throwable interface and the interface won't be used anywhere else They don't, though! If you'll look back to the original post, the new class of engine errors do **not** extend from `Exception`. I'd hazard a guess that internally they look pretty different as well, though I can't really bothered to decipher PHP's source code to confirm either way. &gt; (would you implement Throwable for a nonexception - I cant think of a good usecase) No, you would not. The goal of the Throwable interface is to define what an exception looks like (though, semantically, I'd argue `Catchable` may be a better name, especially with the functionality it offers). Again, it's simply being explicit, over the previous implicit approach. &gt; I just think in this case, it's over engineering. I'll politely disagree with your opinion here. And I'd personally prefer to have an over-engineered language feature over an under-engineered one any day (*cough*PHP4*cough*) It's certainly not the Pythonic way (nor the Ruby way), but it's neither Python nor Ruby.
&gt; At which point, the data can be labeled malicious and we've come full circle... At which point you can label it malicious, but it's no longer just "data", it's a specific type of data we can talk about. Some think that certain traits in a string demonstrate it being malicious. Like it containing certain words, or combination of characters mimicking HTML tags and so on. So then they try to filter out or deny input that has those traits. But I can type &lt;script&gt;alert("foo")&lt;/script&gt; here and Reddit doesn't freak out on me. Because it treats what I'm typing as text, and not HTML. It isn't malicious until Reddit decides to use what I type as HTML. Look for people discussing data "sanitization". I've noticed if people use this term, chances are they have this kind of blacklisting approach, which tends to backfire a lot in terms of both user experience and security guarantees. &gt; ...and you probably have autism. No, just being an idiot with opinion.
RESTful *and* RPC calls together? Oh, OP, for the love of god, please don't go anywhere near this approach 
I'll bite. What are the *actual* drawbacks of what I did? I'm ready to hear any engineering or technical reasons, not just emotional ones. **EDIT:** http://i.imgur.com/bcbM5uF.png ...
&gt; Is there a proper open source, easy to use, free penetration testing tool available? Not really, to be completely honest. Most of the good offerings are paid services, in my experience. They're not horrendously expensive, but if your budget is literally $0 that doesn't help you. As others have suggested, your code is the best place to look. Searching around for direct use of $_GET/$_POST, strings containing CRUD operations that may be buggy/unsafe queries, calls to stuff like `mysql_query`, etc. Prepare thine statements! Also, make sure your DB server has the service port, usually 3306, firewalled off from the outside world; ensure it requires connections with good passwords. And I'm right there with you on OWASP - good concept, horrible execution.
I had hit or miss experiences in the past with [RIPS](https://en.wikipedia.org/wiki/RIPS), but the project is SourceForge hosted and hasn't been updated in a while. YMMV. 
The primary goal there is for a video series that follows a set of tutorials. This would in our minds cover multiple use cases up until winding up with authorization through Oauth. It's these tutorials and videos that are time consuming.
My previous employer had luck with what I believe was Netsparker, but I may be confused with another product. Looks like Netsparker is not exactly free, so it won't help you in the long run, but you can use it for free for fifteen days.
I'd never thought of pentesting distros. Good one. There are probably several ones specifically for security testing. Find them [on DistroWatch's search page](http://distrowatch.com/search.php), there's a search form where you can select a category, try the "security" category.
It might be caused by that function/extension being deprecated.
I run symfony based applications on Dreamhost. One of them gets about 60k users a month and performs just fine. Getting a VPS that you have to manage yourself may be overkill for you right now. Here are a few things that might be helpful. - You may run out of memory if you try to run Composer commands on a Dreamhost shared server. My workaround is to run Composer related commands in my local vm, gzip the vendor folder, then transfer it to the server via SFTP and unzip it. - Make sure to update your config to point to whatever MySQL database hostname you setup in your Dreamhost control panel. Generally, you cannot access your MySQL db from localhost and many configurations automatically put localhost in as the default. - They support git so depending on if you use bitbucket, github, etc, you can likely create a deployment key and have your website a working copy of a github repo. This would allow you to pull just a delta of your code changes, switch branches, etc. without needing to sftp your entire project when you make any changes. - Switch your default version of PHP to whatever the latest dreamhost supports, their default I think is php 5.4 but they support 5.6 if you select it in the control panel.
Yeah sure, I reacted because it was literally in the first class example the book had. In a book about "PHP 6". It's full of other horrible practices as well, and seems very outdated.
Yeah, I'm not surprised. I see blog posts going back to [at least 2007](http://davidwalsh.name/php6), and imagine the first books were dated similarly. Best practices have changed a lot in 8 years (namely, they've been established)
"Vagrant provides easy to configure, reproducible, and portable work environments built on top of industry-standard technology and controlled by a single consistent workflow to help maximize the productivity and flexibility of you and your team." If this doesn't look like a container of some sorts then I can't help you. Discussing personal interpretations is pointless imho.
It's 2015. Stop using shared hosting. 
Thanks for so much info, really helps me and yeah I know I posted the exact same a week ago, but the further I go the more I find out that I will need to learn more and more of things and it starts to be kinda overwhelming like you said, but yeah, you're right I should just cut things down into small pieces and just start working on then, thanks.
This should definitely be in /r/lumen. Nice post though. :)
&gt;SourceForge &gt;YMMV. *Insert warning about SourceForge inserting malware in downloads here*
Think the approach and complexity will depend on what you allow to be unique to a customer or configurable per customer. We run a large rental platform here and we offer our clients the ability to do this kind of bespoke work, although the majority of the time it is purely visual changes or slightly "tweaked" flows. We use a template hierarchy structure in our views that allow us to easily override any view for a client, so long as a dev has componentized the views well enough this is extremely flexible and removes any client specific business logic from our views. Sadly the backend isn't quite as elegant :( 
For messaging, Facebook uses Erlang for I/O, C++ for persistence, Thrift for internal communication. On the client (the browser), it uses JS which speaks to the server using websockets. For you I'd recommend the same, but replace Erlang/C++/Thrift with Node.JS - it's more approachable, and it's JS like your client. I you insist on using PHP, check out React.PHP. I see someone mention Ratchet here, that's also an option. But I'd use a platform that specializes in async I/O which is Node.
Hi. I'm a Certified Ethical Hacker/Certified Penetration Tester. If you would like, I could take a whack at your site for free and help you out. It's been a while since I've done much in that realm and so it would just be fun for me to try. It's cool if you don't want me to. Just a thought.
Yea I messed around with the demo about a year ago. I wish I knew how I could word it to justify getting a license to my manager. It's pretty expensive, but so is having any of our sites being trashed i guess.
It begins, hell yeah!
Adding tests to a finished product is not trivial, but it can be done. I would recommend you go look into testing right now, maybe do some side projects while you learn that, and then return to this project. Any new functionality from here on out should be built with tests at the start, and then you can slowly add tests for the rest of your platform as you go on.
Given PSR-7 MVC should die. No more controllers, they are dumb and don't apply to the web. A modern framework should Accept Requests, and output responses. How you get there is not a "controller", its request processing. 
Let your users decide.
&gt; Allow injections directly in the action method. Then dependencies will be contextual. At which point I assert one might as well separate out the method to its own class. Then one can use plain-old constructor injection, and the class is created only on first use.
By that you mean making a poll, or allowing both implementations ?
You're making many of the points I made in the [ADR paper](http://pmjones.io/adr), which is satisfying. It's always nice to get independent validation. Anyway, it's funny you should ask about this now. Having worked with ADR for a little while now, and in collaboration with Woody Gilk and others, I have within the past 24 hours released [Arbiter](https://github.com/arbiterphp/Arbiter.Arbiter). The idea is that each Action really does only three things: collects input for a domain call, makes the domain call with that input to get back a payload, and calls a responder with that payload. So even the actions can be reduced to their component parts. I have just this morning converted [the core Radar package](https://github.com/radarphp/Radar.Adr) to use Arbiter, to good effect.
In my implementations actions will be just one of many kinds of chainable processors that are built into chains ( and each chain in turn is also a processors and can become a part ofanother chain), e.g. the HTTP chain looks like this: https://github.com/PHPixie/Framework/blob/master/src/PHPixie/Framework/HTTP.php#L49 
&gt; PSR-7 represents a standardization of everything we've already been doing in MVC I don't think that's an accurate assessment; PSR-7 represents not the separation-of-concerns outlined in MVC, but the structure of HTTP requests and responses. Those are not themselves MVC.
Just ease it in slowly. Gauge resistance.
Would it be fair to call that kind of system middleware-ish? (FYI not a fan of the term middleware, especially since /u/idiot-with-opinion pointed out its previous history, but you get my meaning.)
Well not really. Middleware ideology is more about nesting and processing in sequence. I use linear processing mostly ( although nesting is possible ) and allow forking ( the checkIsDispatchable is a fork that either processes the request or forks to the notFoundProcessor which shows a 404 page ) 
Personally I'd use inheritance for that. But the thing I often see is when all the logic is moved to the actual domain a lot of actions become oneliners, which do look better grouped in a class.
I meant PSR-7 represents a standardization of everything we've already been doing in MVC *when interacting with HTTP messages*. There's been some reliance on message mutability in some frameworks, but that's not so essential. Come on, you can give me the benefit of the doubt, I'm not an idiot... Wait...
All of PHP is written in C?? 
&gt; I meant PSR-7 represents a standardization of everything we've already been doing in MVC when interacting with HTTP messages. That's fair, although the original message didn't give me that impression. Glad that I read it wrong.
Mostly because we're discussing how we should split our actions in separate classes, so the class doesn't receive dependencies it won't use. If you completely agree then... we're arguing over a problem that doesn't exist.
The origin of middleware is from Ruby's Rack, which is a play on "Rack of servers", and all its handlers are referred to as "apps" and so things that wrap them are referred to as "middleware". So it was a brand name, that some clueless folks thought is a technical term for this kind of a plugin. But I'm going to call any word abuse a laraword, anyway. The fact it's inaccurate makes it even more suitable.
&gt; But I'm going to call any word abuse a laraword, anyway. The fact it's inaccurate makes it even more suitable. Heh. It's sure way to Rack up points with that crowd. ;-)
I did mention you can pass dependencies to the action methods. That's just one thing you can do when the user is allowed to build it (or provide a factory that builds it inside the router). But what I do is have my app module define a factory interface of what it needs. Then I pass a concrete factory to the controller constructor, so the dependencies are created lazily. And if you can pass the factory by yourself, you can avoid needing a DI container at all. It's just amazing how good architecture makes a ton of problems disappear, and yet it's less code. Magic.
It does have some good content, too bad it hasn't been updated in 6 months.
Fancy: ✯ ~ brew install php70 ==&gt; Installing php70 from homebrew/homebrew-php ==&gt; Downloading https://homebrew.bintray.com/bottles-php/php70-7.0.0-alpha.2.yosemite.bottle.tar.gz ######################################################################## 100.0% ==&gt; Pouring php70-7.0.0-alpha.2.yosemite.bottle.tar.gz &lt;snip&gt; ✯ ~ php -v PHP 7.0.0alpha2 (cli) (built: Jun 24 2015 21:37:50) Copyright (c) 1997-2015 The PHP Group Zend Engine v3.0.0-dev, Copyright (c) 1998-2015 Zend Technologies
PyPy is Python in Python - isn't that the same level as writing PHP in PHP?
PyPy is written in RPython, which is a subset of PyPy, which compiles to machine language. No such thing exists for PHP. Frankly it'll be a very bad idea for PHP, because part of what makes PHP useful is the integration with all the C libraries out there. If you make it self-hosted, it should have C interop, and half the thing will be C libraries again, so beside the literal circle-jerk the benefit would be nil.
&gt; ou could start checking when and where from the guy came in, see the logs, find what did he target, and work from there on to plug at least that one particular vulnerability. That's what I've been doing, but it's slow since for every one request that might leak data, there are 10's of thousands that won't :/
Isn't laraword an laraword itself. It inaccurately links a term to the framework.
Hahah 😛
&gt; So what happens if I need to call multiple domain services, multiple times, with different input in order to produce one responder. There goes the Arbiter. I assert that if you need to make multiple calls to different domain services, you should probably wrap all those calls in an upper-level domain service. Your action can then call that one domain service, which in turn will coordinate the other domain calls. Further, if you're in a Request/Response environment, you only get one set of input from the user: the Request. Extract from that the input needed for your upper-level domain service call, pass it in, and you're done. UPDATE: Re "in order to produce one responder" -- for what it's worth, the domain does not produce a responder; it produces a payload, describing the results of the domain activity, which is passed to a responder. The responder in turn builds the response.
[It's... been done](http://blog.ircmaxell.com/2014/08/introducing-recki-ct.html).
You're basically saying I should have UI-specific code in my domain services, such as the combination of service calls I need for a particular portal page in my website. Well, I "assert back" that what you're doing is just moving your client-specific controller glue code to the domain thus negating the very point controllers exist for: to glue client UI concerns with domain services without the domain being polluted with client logic or vice versa. You know this saying: make it as simple as possible, but not simpler. You're trying to make controllers so simple, they fail to work as controllers anymore, so now you have controllers in your domain. Just... no.
&gt; If this is to check errors when app is in production Correct. &gt; How exactly is someone going to get meaningful data out of this 1000s of lines? Usually you know around the time an error happens. Then you can correlate it with other events around the same time. Other options include making your own logging class/integration to send off logs to a logging server like Graylog. That makes it searchable in a nice interface and you can search for any piece of data you want however you want it which is what I do. I receive about 2 million messages per day on it and finding a specific users action takes all of 5 seconds.
Yep -- while PHP5 and PHP7 are both entirely written in C, for HHVM, an awful lot of the standard library is written in a combination of PHP and Hack. (HHVM's core runtime and JIT is all C++ of course; PHP isn't a great language for expressing the kind of specific systems stuff you need for a JIT.)
&gt; But what I do is have my app module define a factory interface of what it needs. Then I pass a concrete factory to the controller constructor, so the dependencies are created lazily. Do you use something like a container or do you have a method for each dependency in the interface? Having one method per dependency won't you end up with a fairly big interface for a small, but not micro, app?
Fair.
By default, [the supported versions page](http://php.net/supported-versions) calculates the dates for each version's support lifetime based on the release date of the first stable release on that branch. So for 5.5, that was 2 years from the release of 5.5.0, which happened on June 20, 2013. In practice, though, those dates don't necessarily line up with the exact release cycle in use two or three years later, and that's what's happened here: [the 5.5 maintainers intend to make one more "normal" release on July 9](http://news.php.net/php.internals/86784), so the support dates for 5.5 on php.net have been adjusted accordingly. (July 10 was picked mostly in case the 5.5.27 release slips into the next morning, which happens occasionally depending on one's time zone.) Ideally, that should have happened in advance, but since 5.5 is the first release to hit EOL since the supported versions page was added, nobody really thought to reconcile them until after the fact. (Edited to add: it's likely that the exact date for 5.4 ending its security only support phase is going to change ever so slightly too; that date will be announced in the 5.4.43 release announcement in a couple of weeks.) **tl;dr**: One more "normal" release was in flight; the site wasn't updated to show that until later than it should have been. Our bad. Mostly my bad.
i dont think its good idea, i am creator of quite big private ERP system with hundreds of actions in several controllers, and some of them have only 1-5 lines of code (like simple ajax delete update etc) and having hundreds of 3 lines files would be huge mess
Yep... 
well the first C compiler was most likely written in assembly code. then the following c compilers were written in C.
Are you saying point 2 is a breeze? You must be using databases very lightly :) 
&gt; I'm interested, as I've been working for over 10 years with PHP now, and never found a real need to use these I've written about [the need for prepared statements](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide) before, if you care for the long explanation. Prepared statements solve a fundamental problem that merely escaping does not: They separate the data (your parameters) from the instructions. The query string and the parameters are sent in separate packets, in fact. This prevents malicious data from corrupting your query string, because it's denied any opportunity to touch it. If anybody thinks escaping is sufficient, please read [this StackOverflow answer](http://stackoverflow.com/a/12118602/2224584) by /u/ircmaxell and reconsider. &gt; Now, by these security advices going around, it seems to me this is a lazy-boy option to avoid input validation; let PDO deal with it. So it seems to me it's a bit of a crutch to use it this way, some delegated responsibility. But I maybe wrong. Prepared statements do **NOT** remove the need for input validation. For example, if you need an email address, make sure the input is formatted as a valid email address. This is basic QA. Aside: I wish there was an easy way to parametrize output to prevent XSS like there is for SQLi.
I'd have to see more of the code to understand / answer.
Thanks, I am indeed interested in long answers, I'll give it all a good read!
Well, it'll be my first time presenting at a real conference... so, me too ;)
B++ maybe?
Ok the comment was a bit tongue-in-cheek. Seriously though, any of the expert PHP developers I've ever met, uses either: vim, emacs, sublime or phpstorm. Those still using eclipse are the ones that haven't been keeping up with the latest IDE technologies and probably still using PHP 5.2. 
The reason prepared statements via pdo are the best choice to prevent sqli is because it's a standard mechanism that we all use (or should anyway). SQLi is a serious issue, one that too many developers neglect to learn about. Not using prepared statements is asking for trouble. You best be certain that your own input validation is as good as the driver if you choose not to use it.
Yup, I already had DO also, and when I found out, I cancelled my private github subscription and moved all my personal stuff into my gitlab. It's pretty awesome. 
Although there's been debate about this with MySQL not actually doing it by default... prepared statements allow the database server to cache the actual SQL parsing and building of the query. That in turn leads to performance improvements, on top of the security benefits.
&gt; please read this StackOverflow answer TIL: &gt; A new C API function, mysql_real_escape_string_quote(), has been implemented as a replacement for mysql_real_escape_string() because the latter function can fail to properly encode characters when ... 
Interestingly enough, I saw your comment (nearly 100%) verbatim in this [comic](http://cube-drone.com/comics/c/diplomatic-appraisal).
Hah! Nice find! Now I'm crossing my fingers to be parodied by Weird Al. :D
Thanks, Indeed I *can* lead to performance improvements, I was aware of that. Altho it really depends on how/where you use it, afaik. We don't have many statements that are the same from visit to visit, bar one or two, so the benefit would be rather minimal in our case. In fact those queries are well indexed and really lightning-quick already, so we've much better alternatives to spend our time on if we're after performance. :) 
Seriously fancy. Macports is still on alpha1!
It's dangerous to believe that prepared statements alone fix SQLi. It takes awareness and discipline to keep your queries safe while still building them from tainted variables. One example that comes to mind: SELECT * FROM whatever WHERE x = ? ORDER BY {$_POST['order']} Although $_POST['order'] would be concatenated in a way that makes it less obvious it's tainted. 
More like a miscarriage if you ask me.
co-founder of fortrabbit here, just lurking and learning what makes you tick.
Nothing, really. You sell yourself as "PHP as a Service". I would like to detach from PHP and being able to use "* as a Service". ;-) I will start with php and then move to whatever language I want, so a more generic service is probably a better choice. 
It's still not bootstrapped. When php can be compiled to native, then it can be bootstrapped (look at the recent Go bootstrapping effort, which eliminates nearly all C code)
There's a log analysis tool built specifically for Laravel (although it works with any other source as well) that you may want to take a look at: www.understand.io. It makes getting "meaningful analysis out of 1000's" (or even millions) of lines really easy. [disclaimer - I work there]
Yes
Interesting. I once read that Linus Torvalds says that you cant write an OS in C++ Does that mean he might use a compiler written in C++ to compile an OS written in C?
Do yourself a favour and stop doing so.
There is no *technical* reason why you could not write an operating system in C++. Of course you'll need some assembly for the boot process and some of the interaction with the CPU, but this is no different when writing an operating system in C. You also have to be careful about certain C++ features, e.g. you should not use exceptions before you have implemented the necessary stack unwinding runtime support. What Linus was really saying is that he just doesn't like C++. People implementing hobby operating systems on the other hand often use C++. Or more exotic languages like Rust. You can use pretty much any thing that is low-level enough.
Debugging is much easier with a suite of tests. PHPUnit, Codeception, PHPSpec, Behat - the PHP world has some great testing tools. There are many benefits to writing tests - overall code quality will improve, your personal code quality will improve, business confidence in the codebase / you / your team will grow as future code releases contain fewer bugs... Software development is not easy. You can stack the odds in your favour by writing tests that prove the system behaves in the way you expect. Whilst you will still have to debug, the scope of what you are debugging will be narrowed, and when done fixing the bug, you can re-run the test suite to prove that the fix you just implemented didn't break something else (so long as the other parts are covered by tests :))
This is essentially ad-hoc debug logging. It can get messy but there's nothing wrong with it within measure. If one wraps the call it gets easier to control, though: if (DEBUG) DebugLog::dump($var); Now this method can generate a trace and it'll know where the call happened (file, line, full stack trace). But... sometimes you debug someone's code without your tooling. Gotta do what you gotta do.
I'd like to help, but I struggle to infer specifics about your situation from the given description. Can you present a more concrete, grounded example, and we can discuss it. Also you aren't very clear where your bottleneck is: 1. Bandwidth. 2. Number of requests and resulting lag. 3. Controller logic. 4. Domain logic. 5. Database queries. etc.
Same, such a clickbait title.
You're correct! This is one of the things this sanitizer will protect against :)
Xdebug is the way to go, php simply feels empty without it. Also you might want to check PHPStorm. All my collegues but one switched from netbeans to phpstorm for its debuging tools (it also have vagrant, typescript, react support and many other cool features netbeans lack)
I like unit tests more than xdebug, but I'm weird.
&gt; you may not need FILE permission and so on. Just disabled them for all users and updated my.cnf to disable them! It boggles my mind that MySQL has file writing and querying options enabled by default :S
Totally do this. Changed my entire life.
Besides XDebug you can have a look at [Tracy from the nette framework](http://tracy.nette.org/). It's basically var_dump on steroids and very helpful.
The interface UserService asks for is UserServiceDeps. That interface doesn't have a method for getting the app. In any statically typed language, calling a method which is not in that interface would be a compile error. In general, when a class asks for an argument of a given interface, it should only use what's on that interface. Your IDE will show in autocomplete only those methods, and anything else would be considered a IDE type error, even if the method is a valid Environment method (because the typehint is not for Environment itself). And so the problem can end there by coding to the requested interface and not doing runtime tricks. Of course, PHP allows you to call that method at runtime, technically. And you can even add an instanceof guard which will remove the error in IDEs which detect instanceof usage as a "cast": if ($deps instanceof Environment) { $deps-&gt;getPublicSiteApp(); } Zend Studio will recognize $deps as an instance of Environment in that codeblock. The purpose of a module, however is that it may be used in different apps, and class Environment might not even exist when a module is deployed in a given situation. Programmers tend to know when coding modules, that making assumptions about $deps which they've not declared in the interface is a bit like shooting themselves in the foot, because everything else might or might not be there in a different configuration, the type system won't guarantee anything. If you don't trust your devs (say they're inexperienced, junior, so on), you can always use adapters and enforce your constraint, sure. It's slightly more verbose, but not that much. But once people get the hang of programming to interfaces, it's not really necessary to do so. **tl;dr** If you need it, ask for it in the typehint. If you haven't asked for it: don't use it.
&gt; I do consider frequent use of Xdebug suspicious. 100% disagree. Why would you let an app run a full cycle just to read logs, when you can watch your data be manipulated in real time? I'm speaking strictly in terms of development.
There's a feature `replace` in a composer.json which handles that. See symfony's main composer.json https://github.com/symfony/symfony/blob/2.8/composer.json
Just run the absolute latest version available for your platform. The "MySQL doesn't support prepared statements" was true when /u/ircmaxell wrote that answer. I don't think you'll need to worry about it unless you're building atop fossils.
Versioning: I've had the problem with versioning for a long time, so now I append the major version of the package to the namespace. It works because if you follow semver, major versions are the only points of breaking BC. So Vendor\Foo is the first version then Vendor\Foo2, Vendor\Foo3 and so on. The composer package name also gets the major version, so to Composer it's another package. Is it ugly? Yes. Does it work &amp; solve the problem? Yes. You get used to it. We got used to backslashes as namespace separators, everything else seems easy now. What doesn't kill you makes you... stranger. Components: Instead of redundantly copying component A in component B and marking it with "replaces A", just refer to A in B's composer.json as a dependency, and Composer will install it. There's no great reason I can think of to want one component in two places. Is there any?
Bottlenecks would be the controller logic and db queries related to generating/building the bracket. If i were to do this user end the unlucky user who was tasked with this could/would experience a 4s+ page load time on top of the original page load time. For large tournaments it is even worse. 
This is a subset of the more PHP Paradox once I elicited here. Because no one really knows what they are importing into their project, they can find themselves in problems due to conflicting versions. Especially under rebuilds. A problem solved easily through vendoring. 
The point being made here, which I agree with, is that in theory you shouldn't have the event dispatcher at /vendor/symfony/event-dispatcher and /vendor/symfony/src/Symfony/Component/EventDispatcher.
Personally, I'd say go to 5.6 if when you update 7.0 isn't at a stable release yet; 5.6 still has another year of full support and a year beyond that for security so you'd be fine for another 12-18 months post-update there. From my own testing, code that's working on PHP 5.3+ and not using deprecated features is working generally well on PHP 7 (I've seen very few compat issues with what I've tested and it's all documented in the changelog so it's easy to catch).
The problem is if you map it to no-version name you still can only have one of them loaded at a time. In a solid module system it should be possible to have multiple versions loaded in parallel and everyone gets the version they want. This is how modules will work in Java 9, for example, and this is how modules work in NPM. If we follow semver, we can simplify things a bit and instead of having Vendor\Package\v3_4_5 we can just have Vendor\Package3, because semver guarantees minor and patch versions are compatible. So then you can have multiple major versions loaded in parallel and Composer doesn't have to map them. Any holes in my explanation ;) ?
I am looking for a short term solution to get things moving, to optimize the site quickly now while i work on a better solution on a separate server. Would caching the pages every few minutes based on importance of live data work? So for example page 1 is cached ever 5 min because the changes seen are not as important. On page load the cached page is searched for, if it has expired generate new page cache if not display the cached page. Page 2, 3, 4, etc. could all be cached at various times dependent on the requirement for fresh data. ( by cache i mean the html for the page not db results although i am looking into indexing, caching, etc. ) Also i made an update to the question mind taking a look?
&gt; The reason one would have a component in two places is quite simple though. Consider logging or event dispatching, very common concepts that occur in multiple components within an application or package. Not sure I understand. Elaborate?
As somebody who's dealt with the madness that's called `class_alias` before, please don't. It's not even a "maybe", but it's a "I'm pretty damn sure" that you'll shoot yourself in the foot with this. It's not a scalable model, in fact, it doesn't scale at all on a nested dependency level, everyone will still need to reference exact version. But why do the aliasing at all? Why not have the version in the namespace?
That's exactly what I said :)
&gt; When I get a request like this, I have instant regrets for not having a cohesive open-source example on Github or smth. to show people. Maybe I have to just do it some weekend. I encourage you to do so; it's a lot of work, but then you can just point people to it instead of havig to re-explain stuff. Regarding these ... interface UserServiceDeps { function getDb(): Db; } // ... class Environment ... { function getUsersEndpoint() { if (!$this-&gt;usersEpt) { $userSvc = new UserService($this); $this-&gt;usersEpt = $userSvc-&gt;getUsersEndpoint(); } return $this-&gt;usersEpt; } } They, along with the `*Deps` classes, look remarkably similar to a collection of hand-written containers, and used as service locators. 
I tried using that, but I couldn't find a way to get any sort of default SQL fuzzing script. There are no tutorials on the recent version. The one SQL fuzzing tutorial I found for it, seemed to have prepopulated fuzzing scripts ready to go, but the new version doesn't. I feel like this would be a job for Google - create a super easy to use, super powerful, open source web security tool.
&gt; having a convenient interface for rendering the logs intelligently is important. If it's just a giant text file, that wouldn't be as good This must be the difference in your scenario and mine. Also, if I'm debugging by logs, it's usually not my logs I'm using to debug anyways. The only logs I ever get to see are just a big dump of data that I have to sift through. Your example of **id** vs **userid** would not be in the logs in my world. =(
&gt; Creating strings of HTML in your code is horrible That's exactly what this library is doing...
Please take a look at http://php.net/echo and /r/phphelp.
&gt; rewriting a lot of it for the sake of prepared statements just does not seem a feasible option Playing devil's advocate here: maybe this is the real issue you should be concerning yourself with. Why is your code written in a way that this is so difficult? How can you abstract away the query portion so that, if you decide to change how the query is performed (PDO instead of mysqli_*, for example), you can easily swap out the implementation without affecting your application's uses of it?
In the service of fair feedback, a good library should do two things: 1. state a clear, well-defined problem 2. show a conclusive solution I neither see a well-defined problem, nor a conclusive solution to it.
This probably fails when assigning or fetching a property by reference, so it might break some apps. Just thought I'd mention so you can document it. I have something simple internally that does the same (without AOP, it's just a trait, that can enforce property type or immutability) with the same limitation.
Yeah, saw that one, will have to fix it in the GO fw
Step 1, install vagrant. Step 2, follow the instructions for compiling it on a sane development platform.
I mean you like that kind of stuff... as in, parametrize output for a given medium. That's what XHP does (among other things).
RocketShipIt creator here: Thank you for the recommendation! We currently offer a 50% discount on additional carriers. For basic Rates and Tracking you can get all carriers (and future supported carriers) for $145. One advantage of going with RocketShipIt over other SaaS solutions is the request is directly generated and sent from your server to the carrier which provides transparency and fast response times.
[What have you tried?](http://whathaveyoutried.com)
It'd be best to talk about PDO and prepared statements as two separate subjects. One can use prepared statements with other PHP DB drivers.
I'll second this, after a year and a half of professional development experience getting a pmp certification makes it look like you don't really give a shit about code you just want to make more money and possibly manage people who actually do give a shit about code.
&gt; A "Service Locator that's not global" is like a "Singleton that's not single". I think this is the central point on which we differ. The Encapsulated Context object is still a container; the dependent object pulls its dependencies out of the injected container, and thereby hides the "real" underlying dependencies for that object. The difference in name appears to indicate only a difference in scope, not a difference in behavior.
I didn't ask how to use it in vagrant. I asked how to use it in MAMP. If I wanted to use it in Vagrant, I would have done so.
So basically, some packages undergo more frequent or heavier development than others, and different package maintainers may use very different versions of packages which break API compatibility, thereby preventing third-party developers from using two such packages that depend on different incompatible versions of the common library. Frankly, I would try to avoid a robust workaround for this "problem." I don't want 3 different versions of Guzzle. I want 3 packages that work with the newest version, and HTTP abstraction who's API doesn't change so frequently that there are 3 other libraries using 3 different versions. What if a major problem or security vulnerability is found in some older version, but only gets patched in the latest? Are we supposed to apply and maintain hotfixes for X number of versions backwards because some other third party library which depends on version 2 no longer cares enough to update to version 5? Having had this discussion with respect to internal packages, to me there seems a clear solution. Update the packages which use the out of date stuff (if they are truly necessary); find or create alternatives if they are not. This is how the ecosystem progresses as a whole. As far as I can tell, suggestions here represent a way to treat symptoms of a set of larger problems, namely: 1) The whole ecosystem is still very immature - as libraries stabilize, major BC breaks should not be so frequent and other packages should be able to catch up. 2) No one is really devoting their time to being a package maintainer, even if they are a lead developer on a library. Note, I'm not saying this is their fault, most people still have day jobs and lives. 3) Some larger systems with lots of complexity and lots of sway (looking at you Symfony), are looking for solutions that automate solving the mess they have created for themselves. Here's a few things I think library devs, package maintainers, etc, can do to help themselves and their community: 1) Clearly state the versions they are supporting (fixing bugs in, will backport hotfixes to, etc). Part of this is making it clear what versions are DEPRECATED. Anyone use Atom? Why is their plugin ecosystem so good? Because the moment an API is deprecated there's an obvious notice in the UI that the package is using deprecated functionality. I recall updating a bunch of Symfony packages recently and they were literally throwing deprecation exceptions at me (although I don't suggest this as that actually means you BROKE the old methods), raising notices might be good. 2) Help other major packages which rely on yours move to newer versions. This could be anything from migration guides between BC breaks to actually updating other libraries and submitting pull requests. 3) Make your intended future clearer. This doesn't have to be so far as official long term support cycles, it could be short term support cycles. "Starting work on 2.0 in Q1 of 2016" might be enough to tell someone that the library they intend to be at v1 in March, should maybe coincide with dev versions. On the other side of this... don't pull a Propel 2.
This is a neat idea ocramius. I'd be too scared to enable in on my legacy app though.
(/me shrugs) It seems to me it's poorly named; instead of an "Application" Service Locator, it's a "Module" Service Locator. That "it does not contain dependencies it does not need" seems related only to its scope, not its intent or functionality.
&gt; It seems to me it's poorly named; instead of an "Application" Service Locator, it's a "Module" Service Locator. This won't be the first time I ask you to stop abusing terms, and now you're abusing "Service Locator". A Service Locator is a *central registry of services, which can be modified at runtime by adding and removing services without re-compilation*. Make it "without re-loading the locator class" if you want for PHP (for obvious reasons) but if you see actual implementation of a Service Locator, you'll instantly realize it's not just a "container". It's a container with very specific properties. It's a hub where services can *register themselves* so other services can find them. In contrast, the Context interfaces from my samples are *statically typed* (can't add, remove, change methods at runtime), *not global in any way* and *provide no runtime registration API*. Precisely **none** of the negative effects associated with a Service Locator apply to Encapsulated Context, and so far you're failing to list one to contradict that. &gt; That "it does not contain dependencies it does not need" seems related only to its scope, not its intent or functionality. I can't parse this sentence, but I'm assuming you're trying to hand-wave your way out of this conversation.
I can tell you are committed to this particular topic, so I will reply one last time here and leave you the final word, though I do expect to blog about this exchange, which I have found interesting and informative. &gt; which can be modified at runtime by adding and removing services without re-compilation Yes, that would be a "dynamic" service locator. A non-dynamic one, [per Fowler](http://www.martinfowler.com/articles/injection.html#ADynamicServiceLocator), fits the description you give; that is, the service-specific methods are defined as part of the class, and the services cannot be modified at runtime. That the Service Locator is dynamic (or not) is unrelated to whether or not it's global. &gt; I can't parse this sentence I'll try again, at greater length. First, I am approaching it by analogy. I will allow, for this discussion, that a Service Locator is always-and-only an application-level object, one that holds all dependencies for all objects across the whole application. But what would one call an object *not* at the application level, that holds the dependencies only for *one* object, or perhaps a *limited set* of objects? It seems to me that you're using the term Encapsulated Context to describe that. Aside from the fact that one is application-wide and one is sub-application-wide, I find no difference between them. They serve the same purpose, but serve it for a different range of objects ("all" vs "some"). Again, my thanks for telling me about Encapsulated Context; it certainly has been educational, even if I have not learned the lesson you would have preferred. (At least not yet; I reserve the right to revise my opinion. ;-)
&gt; (by design) is only good for stateless APIs That's an interesting take. The web is stateless, after all, so that would seem to make it a good fit for anything web-related. But my guess is that you mean "not using sessions" given your later sentence. Do I have that right, or did I miss your meaning?
&gt; This is essentially ad-hoc debug logging. dieing is not debugging.
I am very disappointed that I will not be able to attend your talk. These sound like great discussion points.
&gt; I would hope, at this point, that I would be recognized not as a bullshitter, but as an honest interlocutor. (Taking your advice on renaming Pipeline would be one point of evidence there.) No, renaming Pipeline was like allowing me to taste blood. I'll never be the same.
Yeah I just think XHP is ugly. :P
So it's in a good company with prepared statements then.
It'd be difficult because there are a lot of SQL statements in the code, a lot even built by the code - pretty much completely; table names, fields to select, even joins. It's not because we're repeating them, it's because there's a lot of different functionality. :) This question RE PDO/prepared statements is not really an "issue", it's more of an interest.
Agreed, it's just that they more often come as a "package" deal, offered often without any deep insight, almost just like a "folk tradition". 
Output buffering, the `__FILE__` to know exactly where it was put. Of course you could wrap it all up in a function with some pretty output and a stack trace, but this at least gets my point across. 
Disagree that a computer science degree is something necessary. Also disagree that a programmer leaving before 6PM is a bad sign. He could have been working solidly all day and nailed a load of problems and he simply made the sensible realisation that his brain was done for the day. It happens. 
The close method flips the order so that you can use the same selector with both open an close (e.g. assign it to a variable). Is that what you mean?
Sure.
It's a joke :| Anyway, for the record I'm not saying you're a "bullshitter", I'm just saying the argument about hidden dependencies was bullshit, and so [duty called](https://xkcd.com/386/).
I think you want /r/pmp not /r/php
I must have completely mis-read your comment. My bad
He's not saying a computer science *degree* is necessary. He's saying a CS *education* is desirable in obtaining some base skills..."But without the right experience, such a person will never be more than an average quality programmer." He's emphasizing continuous learning and continuous practice to become a good programmer (which is quite obvious). I do vehemently disagree with the entire 6PM premise though. His arguments on this are simply idiotic and I would seek employment elsewhere if he were my manager.
&gt; Try to make groups of methods that use the same dependencies. Or a class hierarchy that uses the same dependencies. Then you can group by module or namespace, instead of by class.
Keep in mind this article was written in 2002 and you should take it with a grain of salt ... mostly because of gems like this one: &gt; Your business success will depend on the extent to which programmers essentially live at your office. 
Since I assume you are posting to hear criticism and pointers, here it is: Use composer, you want to have two repositories, one with a skeleton app and one with your framework files themselves. This let's users of your framework upgrade easily. Right now there's no clear upgrade path for code written by you the author. This will also teach you about solving other problems that now appear, such as making your framework modular, or allowing functions of it to be extended or replaced by the user. Finally, avoid static functions as much as possible, I get that your adopting a laravel style, but they are not actually using static functions like it appears they are. Making use of objects you'll find opens you up to much more flexibility with databases and handling requests. 
Thanks for replying, criticism and pointers is exactly what I want to hear! I will try to do everything you said, I never quite liked composer, but I guess I just need to give it another try... Thanks ;)
If you want an alternative to those static classes which doesn't involve a complicated third party dependency injection container, you can read [this gigantic thread](https://www.reddit.com/r/PHP/comments/3b36k1/seperate_classes_per_each_action_and_getting_rid/csik6fn), which I produced for some ungodly reason. The **tl;dr** is that you should pass the class instances to those who will use them, instead of them reaching out to a static name. This allows you to change implementations and configure one component differently than another (say, different databases). When the noise becomes too much to pass objects one by one, you can combine them into little "bundle" objects specific to a given part of your application, where every method returns a dependency.
Because people are telling you to learn, which is a good idea anyways here's the best approach I think &lt;video width="400" height="300" controls&gt; &lt;source src="&lt;?php echo $link ?&gt;" type='video/mp4' /&gt; &lt;/video&gt; 
Are you planning on using it for evil? 
Such crud. Please don't follow these suggestions. They will lead to burnout and a very ineffecitve team.
You should adapt the PSR coding standards. While it looks like you do a pretty good job of sticking to a consistent standard, your road will be smoothed significantly when you work with others (especially in the open source world) if you take the time now to pick up the standard that the community agreed upon. * http://www.php-fig.org/psr/psr-1/ * http://www.php-fig.org/psr/psr-2/
2005 called. They want their Framework back. 
Well done, but runtime behavior dictated by annotations? No thanks. I know your next question is "why?" so here it is: * unnecessary complexity - you're adding a bunch of code that now has to parse the source you've just finished parsing? Annotations for one-time configuration generation would be questionable, but on every execution? * hard to explain behavior - so now you've got a new "gotcha" for everyone who works on your project. Comments are comments. They should never impact the runtime. * a new potentially hard to track point of failure - typos in your comments can now cause your code to break in new and exciting ways. Code that does this sort of introspection on a language so all-over-the-place like PHP is also bound to have some pretty esoteric bugs as well. The benefits to this sort of thing in php are at best, minimal. If you really want stricter PHP, you'd be better off exploring Hack, or some other language choice.
https://www.youtube.com/watch?v=31g0YE61PLQ
I prefer this one: &gt; Microsoft Internet Explorer is a much better browser than Netscape Navigator.
It's faster because it ignores the dependencies. So if you really love manually managing your own dependencies and seppuku, then go for it.
It sounds like your doing more work this way, which also makes it easier to make a mistake. Why reinvent the wheel for the sake of a few seconds?
this packages where I used this, have no dependencies, thats another reason why I use this humm
You should document the original source for your zipcodes CSV file, the license it's under, and how frequently it's updated (particularly from the point of view of users of your API service). Also, a little trick regarding the selection of points within a radius: If you work out the min / max (lat / long) limits of the bounding box first, you only need to run the full formula on points that lie within that box. (Essentially, if you're drawing on a paper map, you draw a rectangle around your origin, then you only work on data inside the rectangle)
Gotcha. That's a great point. I will add this to my TO DO list. =) Thank you for the help.
Bower either uses `git clone` internally, or downloads a ZIP, the same as Composer. Either way, this seems highly unnecessary.
I've never really used Mamp like I do with vagrant. But I imagine if you are crafty enough, you can look the Mamp app and open it up. But you should probably know some objective c for the mac app part to locate where Mamp is loading the php version
It is intended to solve the same problems as twig or smarty, or blade (but I'm not very familar with last one), but in addition, it can be used to provide partial rendering and reloading parts of web page because of it's hierarchical structure.
mostly useless unless you plan to go to a largeish company.
You're introducing new problems on top of the original ones you're trying to solve. For example: * This requires a lot of modification to the static HTML, which increases the time needed to integrate any non-trivial template. * Any syntax error will prevent the whole template from rendering, at which point you'll need a JSON highlighter or a custom JSON parser to see where the error is. * I can't quite see how this solves partial page reloads better than existing templating engines - care to demonstrate?.
&gt; I can't quite see how this solves partial page reloads better than existing templating engines Yes, controller can have action like `reloadUsers()` with invoking method that does partial rendering of view: public function reloadUsersAction() { $page = json_decode(file_get_contents('Page.json')); return $this-&gt;view-&gt;renderPartial($page[1]); }
I would split that part off to a smaller nested template and get rid of the `[1]` part instead, this approach feels like a pain to maintain.
The form on the right? Honestly the harder part is the HTML/CSS/JS, the PHP part would just accept the form data like any other form and process it as needed.
It's just an HTML form with radio buttons. If you're having trouble putting together a form submission page, you should start with some PHP tutorials on Code Academy or elsewhere.
&gt; with dependency inversion, you would create an interface called Fruit Why an *interface*? I never understood this point. What's wrong with an abstract class? Maybe every Fruit has a method that'll be implemented the same way in 99% of use-cases. Why create an interface, and then create an abstract class based on that interface which defines the exact same methods *again* but implements a few of them? 
Oy, you're trying to complicate it again. If I don't pass this DB in, how's the class going to instantiate it? Am I going to pass in my username, host, password and database name instead so that my class can instantiate it? Wait, that's 4 params. Fuck that, I'll just force the developer to give me the DB object and they can deal with that shit; it makes my life easier and simpler. Oh what's that? I'm inadvertently doing "dependency injection"? No, I'm just doing what's simple and logical. Okay fine, to be fair there are two other options. I could nab my database object out of global space. That makes my class a lot less flexible. Or pass in some "container" bullshit which I *might* be able to pull a DB object out of. I don't know why I'd ever want to add that extra layer of abstraction which only muddies things up though. I've done the global thing. It's a bitch to pass along a DB object through 10 different layers to get it where you need it otherwise. Especially when you *think* you don't need it anymore after layer 5 and then realize oh shit, there's this one weird case on layer 8 that needs it. Yeah, okay, maybe there's something wrong here and you got your responsibilities messed up, but ehhh...we've got deadlines. Even Laravel uses global databases up the wazoo. Every one of their "facades" references some global somewhere. And anyway, how often are you going to mock a *database object*? Really? Everyone uses this example, but has anyone ever mocked a *database* in practice? Like, what, you built an entire engine that parses SQL and returns fake data? Or even if you don't go to the SQL level -- just something that understands the whacky ORM syntax which pretty much translates directly into SQL anyway? You'd mock *models* for sure, but I can't think of a scenario where you'd mock a database. At best you'd just create a database full of test data and just use a real DB object. 
Too contrived. I wouldn't even fret constructing an object or two inside my method. Like what if its easier to write my "calc" method using a "Point" object instead of "x" and "y". Should I force the caller to give me a Point instead to simplify my algorithm? No, who gives a crap? That's an implementation detail -- that's none of their concern. I'll construct it inside the class. And I'll use the *exact* implementation that I need, not some arbitrary bastardized IPoint that they decide on. You only need to let them pass in objects where there's a reasonable use-case to override something.
looks like an automated SQL injection tester. I see a few things to suggest they were trying to dump the information_schema table. If you use prepared statements though I doubt these attacks pose much threat. When I ran a pretty high traffic site I encountered automated hacking attempts daily. Especially from China, Russia and the Ukraine.
I had trouble getting a few extensions compiled with 7, overall it seemed stable enough but I would recommend going with 5.6.x as well. Unless you enjoy being a Guinea pig.
&gt; http://cssdeck.com/labs/ldmtsmfk Here's the concept you're looking for, if it absolutely has to be circular, look into W3 Schools rounded buttons to give you a better idea of how to modify the CSS to your needs.
thanks mate, we do use pdo, i guess thats the reason we are still up and running. Any ideas / mitigation of such attacks ?
thanks mate, looking into it
* You don't hash a database, or it becomes useless when you want to read back. Perhaps you were thinking of passwords? * This is an article for MS SQL server * This article recommends MD5, which is a terribly dead and insecure hash. * It details an "encryption" function which is in fact an MD5 function. It also suggests MD2 and MD4.
What I really meant to say was that different processes executing in parallel are async. I already said in my top comment that multi-exec curl is not true async.
7 is going to break things from 5. 5.6 is the highest backward compatible version.
I think you're definitely trying to solve a problem here, but it's likely caused by something in your workflow, something we can't see clearly expressed in the end product. HTML is hierarchical as well, so that can't be it. Maybe you're not sure how to separate parts of a page from the full page in other templating engines?
You can actually also find the inner bounding box (the square that would fit inside the circle) - points in that area are *definitely* in range. Then you only do pythagoras stuff on the points between the two boxes. With the right UNIONs this can be a pretty efficient SQL query
Does anyone have a comparison and/or benchmark of Propel vs Doctrine vs Eloquent etc?
just saw it now. good thing i didnt take it seriously
* Upvote straight away for idiot thing. * Yeah, nice find, we save slugified form of search term so that we redirect it as example.com/search/slug-of-the-term.There's only one such field. * We would look into allowing or disallowing characters, but since its a UTF-8 based search-form, we have allowed all characters so far, including these SELECT and all ones. * We would have to discuss about the IP blocking. Currently we use Cloudflare's free plan which as it is blocks *some* threats. Thanks alot for the suggestions mate :)
So does using HEX of DORKTESTDORKTEST do something ( like bypassing some queries or something)
 &gt; unnecessary complexity - you're adding a bunch of code that now has to parse the source you've just finished parsing? Annotations for one-time configuration generation would be questionable, but on every execution? It's not a runtime tool: performance doesn't matter here. I could re-parse the entire source tree for every function call and it wouldn't matter anyway ;-) &gt; hard to explain behavior - so now you've got a new "gotcha" for everyone who works on your project. Comments are comments. They should never impact the runtime. Comments that don't reflect the truth are lies: this project detects lies. These lies may be in the comments or they may in the source. If you don't believe in keeping your docblocks in sync with your sources, then don't use docblocks in first place. &gt; a new potentially hard to track point of failure - typos in your comments can now cause your code to break in new and exciting ways. Code that does this sort of introspection on a language so all-over-the-place like PHP is also bound to have some pretty esoteric bugs as well. You don't need to "track" this failure, it's not a tool for production anyway. This tool helps you going as you code day-by-day. Forgot that a value could be nullable? You get a failure. This is massively helpful for adding test cases and correcting documentation. &gt; The benefits to this sort of thing in php are at best, minimal. If you really want stricter PHP, you'd be better off exploring Hack, or some other language choice. This is the usual "PHP IS NOT JAVA" argument that I reject upfront anyway. Yes, I already code in hack, but I'm forced into PHP for many daytime job projects anyway, so I needed a strict checker for assertions that are implicitly part of the code invariants. These invariants are usually specified via docblocks, because that's what your `@return` and `@var` do, and we have no other construct for them anyway, in PHP 5.x).
&gt; MS SQL server &amp;nbsp; &gt; recommends MD5 Checks out.
This is pretty normal; any site on the Internet will eventually be hit by things like this. It's most likely a bot that's scanning for security flaws and, as your website starts to get more traffic, you'll get more and more of these. (For example, [here's a graph of how many bots have tried to guess our servers' root passwords over SSH in the last few days.](https://u.tyler.vc/Screen-Shot-2015-07-06-09-46-06)) If you're using prepared statements, you shouldn't be vulnerable to anything it's trying to achieve. You can try to IP blacklist them, or use something like Cloudflare which will pick up on it automatically and block them, but this is really not something to be super concerned about on its own.
~~I've not downvoted you, but I'm shaking my head at the soup of terms used to describe this framework and the components it uses. Maybe we don't need a middleware framework &amp; have every single thing defined and implemented as middleware. Just maybe.~~ **EDIT:** Never mind the whole thing. Move along.
What makes Tonis better than Relay?
if you have a slug 'abcd', and your server allows the SQL query slug='abc'+0x44, the page will render normal what he would probably do next is something like: use a hex or unicode semicolon,comma and/or quote, and do `where slug='invalid123';select password from users where id in (0,1,2,3,4,5,6,7) as bodytext` thats my hunch anyway
[Here's an alternative to the standard var_dump or print_r.](https://github.com/craig-russell/D-bug) It was created with Magento in mind, but it works for other kinds of systems as well.
According to Newrelic, our time in PHP code dropped by ~85%. Database time stayed the same, as you'd expect, but switching to HHVM was a cheap win. We did encounter a few issues along the way, though: * HHVM's default sort works a little differently from the standard PHP sort. * HHVM is a little more strict about code style, so some of the crappier code needed minor cleanup before deployment. * I had to write a bit of code to make Newrelic aware of our internal routes. * There is no official HHVM extension for Newrelic. The unofficial one is okay, but it lacks a few of the features that you'd get with the standard PHP one. Most PHP code I've encountered worked out of the box with HHVM, and all of the code that we've written worked exactly as expected. Just be sure to run HHVM in your development environment, and test all the things before deployment.
Now it's Eloquent's turn to realize that :)
For this to happen, Laravel will need a mature leader who cares about architecture beyond what's neat in demos.
I know. And he is implementing a few other features that people already ported. And then someone will pickup where he left off, just as he did with someone else, and implement a few more. It's been happening for a while now, and has every indication of continuing. Like I said, at some point we should step back and think.
Hi, OP. [Take this](http://global3.memecdn.com/seal-of-approval_o_320864.jpg). You've earned it. **EDIT:** To explain my reaction, I think this is a step in the right direction. Monolithic frameworks had their chance, but now that we know what a typical application pipeline looks like, this is a far more flexible way to build an app.
PHPStorm is slow in part because it's an IDEA...
I consider myself a solid programmer. I'm not dependant on eclipse but unfortunately due to our company sticking to subversion.. im totally dependant on subclipse. There simply isn’t (imo) a better svn handler out there. I merge between multiple branches from dev through to production and it just makes it seamless. The only thing I'm tied down to dev wise is the necessity of code hinting. I would use any software that provides me the necessary productivity tools. The tool itself has no impact on my ability to be a good coder. Just a faster coder. 
You worded that a lot better than I was able to. The point of this is to give an example of how I personally have done it, so others aren't as afraid about doing it themselves (thinking that they may be alone in their venture). It's great for discussion.
Something I've wondered for a while, but never seem to find the answer to: In models, it seems like the convention is to pass in required classes when instantiating. I always wondered about that with respect to controllers. Do you have any insight on that? If controller methods have $instance = new Model() in them, does that mean that inversion of control is only for models? If so, do you know why?
Do you have an example of what you mean about the models? With controllers, and almost everything else, using dependency injection (passing an object to the function, instead of having the function itself create/get the object) makes unit testing easier. I don't think that answers your question, though.
I don't think the purpose of dependency injection is simply to make tests possible, although that is a huge practical consideration. And controllers aren't as likely a target for tests (I don't think). I guess what I'm wondering is: is having class instantiation happening in controller methods "not doing DI/IOC"? And the follow ups would be: If you're not "supposed" to have DI in the controller, why not? And if you are, how is that supposed to happen? Even with reflection, I don't see how you can fully tailor this without using a service layer at some point. Even a container won't fully resolve this I don't think Anyway, I was looking through your code and figured since you were disassembling stuff and playing with it you may have some insight. This questions has been on my mind for years.
I've never personally heard of a rule that states you're "not supposed" to have DI in a controller. Business logic shouldn't be in a controller, but.. to say that every programmer is perfect is flawed, and would lead to blocks of code that are not vetted as well as they should be. Controllers are more poised for integration tests, though. Maybe someone with a bit more experience with this can chime in?
Am I reading this correctly, in that php7 will have performance on par with hhvm?
Yes it appears so and when they implement JIT into php 7 it should be faster again.
Yup, with the big difference being that you'll still have most of your PHP extensions that may simply not exist in HHVM. HHVM *is* faster in repo.auth mode (which is what you'd use in a production setting, for sure), so it still leads, but is less attractive now I think. There are other factors too, I think HHVM still uses less cpu, can still handle more overall requests better, and is more memory efficient. But if you gauge just by 'average page speed out the door" it's not quite as attractive as it used to be.
&gt; Well you cold put in code that recognizes non-standard queries/injection attempts and log all of those IPs, We can do that , certainly, thanks for that. HTTP headers is already disabled, but wil re-verify.Same with open directory listing.
we are already on cloudflare, so this attacker has successfully bypassed that, let me check about IP logging though.
Didnt know about the Hex trick. TIL. In anycase PDO is ensuring it to be safe.
but wouldnt that query be logged in Error_log ( TRY-CATCH ) as that table or view doesnt exist. ( if user tried something like that ) Also, ideally we would expect PDO to bypass such attempts right?
[Nope] (http://www.reddit.com/r/PHP/comments/2xe8t4/experimental_php7_jit_is_faster_than_c_in/cozktj9)
You're right, that's another great feature of Hack/HHVM. However, Hack is a relatively substantial bet. Not saying it's going to go away or anything. If you've got a codebase the will work in HHVM, and you trust Hack to stick around, you've got a viable option there. If you're starting from scratch, there are other great languages for async-y-ness (like Node and Scala) which might offer much of the same benefit without as much risk.
This probably will seem like insanity for some, for me it was a fun way to play around with type hinting in PHP7. Yeah, it does eval() things to generate a class on the fly - but it's only as dangerous as the values you feed it. I think it's kinda neat because I often find myself creating basic data structures/models that offer very little other than some properties and some getter/setters. Having this sort of syntax could make that a bit easier. 
Guess I should have quantified the statement with additional improvements rather than a blanket statement. Thanks for the link was informative 
That is really cool and I wasn't even aware that made it into PHP7. Seems like an easy way to refactor out the eval statements. Thanks for sharing.
I agree. There are other great languages.
I can't buy food with \PersonalKarma.
When I'm unit testing, I've heard you shouldn't be using static functions. You instantiate an object (mock), and unit test its methods. Why? I can see the need for mock objects when testing filewriters and database calling methods, but why not unit test static logic-and-return functions?
I think you misunderstood that. You should of course thest static logic-and-return functions. BUT you should avoid using them, since you can not mock them when testing other components. Usually you want to test object A not by mocking itself, but the other objects it collaborates with. Look at this example: class SomeClass { public function updateStoredEntity ($id, $newContent) { $entity = StaticStorage::getById($id); $entity-&gt;setContent($content); StaticStorage::persist($entity); } } Testing this would be hard, since you are wired to StaticStorage. Consider instead: class SomeClass { protected $storage; public function __construct($storage) { $this-&gt;storage = $storage; } public function updateStoredEntity ($id, $newContent) { $entity = $this-&gt;storage-&gt;getById($id); $entity-&gt;setContent($content); $this-&gt;storage-&gt;persist($entity); } } This way you can inject a mocked storage, and use behavioural expectations to verify the entity is mutated correctly. 
well shit, who needs dependencies
Thanks. This is what I needed. ` "autoload": { "psr-4": { "Darkhorn\\": "darkhorn/" } },`
I've recently switched from Sublime Text to PHPStorm, and my Sublime package list looked roughly like his. What finally made me switch was the XDebug support. The package for Sublime is very unstable, and I thought it was just that XDebug was like that, until I saw a colleague use it. The connection is stable, the variable overview is excellent, and I like the way the values appear as 'comments' in your code. Overal it's just the better editor for PHP, and do think no amount of packages is going to bring Sublime to the same level. The code-completion for project code is excellent. Running PHPUnit test with XDebug straight from the editor is amazing. I didn't know I had been missing the refactoring and 'smart delete' functions, but I had. The little 'TODO' tab that looks for 'todo' comments in your code is quite handy. And there are more functions that I forgot to list now that I use every day and come standard with PHPStorm, but I didn't have in Sublime. Sublime is still my default editor for PHP files, but my main projects I do in PHPStorm. I do miss the overal speed and fussy search Sublime Text has, but it doesn't weight up against all the added functionality in PHPStorm.
&gt; Construction injection (e.g. simplifying injecting a property into the constructer as a property, setting it in the constructor, and defining the class property) is something I think can be solved with a clever macro—but I haven't seen that clever macro yet. I tried this once - it's not possible. Sublime macros miss one important feature that would make this possible: Go to next/previous occurance of a substring or pattern. It might be possible to do with a plugin, I should try writing it at some point.
Startup speed has never been important to me.. Shit, i leave the IDE open 24/7 anyways.
So much about this post is just, bleck.
I don't see any advantage with this projet. First of all, forcing user to change the choosen behaviours of their pages to allow this project to run should be (at least for me) avoided. Secondly casting type based on a string should also be avoided. And finally allowing users to extend struct by implementing method ? Really ? It seems a bit like a public class. You're trying to re-implement C's struct.
It's quite common, many frameworks will inject dependencies if you specify them in a controller constructor. I'm not a fan of that *exact* approach (because it means the controller can ask for anything... including stuff it shouldn't access directly, say raw SQL connections), but... it's a way.
Library !== Framework. [See here](http://martinfowler.com/bliki/InversionOfControl.html)
Why not create a human readable version of the log on create? At least in that moment all relevant data I assume are readily available. 
I think it would be interesting to use this as a less verbose way of declaring entity classes. You could take a db schema and turn it into a bunch of classes via the array conversion, maybe add a couple of methods here and there, and then you could use type hinting to pass objects around through your code. The benefit would be not having to maintain a bunch of classes manually and not having to add/remove fields from them as your schema changes.
This is me
Hmm, I'm not sure I agree with you, although I'm not even sure what we're discussing now. I was arguing about the &gt; When they all come from one framework, the author may advertise component-based architecture, and they might be putting some honest effort into it, but the temptation is often too great to add a bunch of shortcuts that hide complexity for the purpose of demos, sample apps and the documentation (a.k.a. "convention over configuration" - familiar phrase?), and you're back stuck to a monolith before you even know it. Components used in frameworks are not different to general-purpose libraries that are out there. Take Symfony 2 for example (since that's what I use,) you can take anything out of it, like the form component, the Doctrine 2 ORM component, the DBAL, the router, the HttpFoundation, the routing, security, any and all of the component as you see fit. If you're not using it, you can either not use it or you can remove it and it won't have the slightest effect on constraining you to use those components. Those components that I just mentioned, are also standalone. If you have composer, go for it. Require the component and you can use it in your own project without ever using the framework. Nobody's stopping you from using Propel or Doctrine 2 on your own projects. In fact, they're so modular, you can create an entirely new framework out of them. The Laravel team uses some of Symfony's components to make their framework. If that doesn't demostrate how modular and standalone those libraries are, I'm not sure what can. The author of this article, links to his GitHub repo of this https://github.com/Mike724/Frameworkless. If you have a look at it, it is basically a framework. A framework doesn't have to be one of the popular multi-purpose megaproject, it can be as tiny as a set of PHP scripts and clean separation of roles and ta-da! You have a framework on your hands! A framework is simply a collection of components making them ready to use, which is **exactly** what the author has come up with. And he calls it "frameworkless". How ironic. Edit: I'm not trying to bash anyone, hopefully nobody finds it that way!
I actually do this, to pass in an instance of PDO to the controller constructor.
BTW, as a side remark, it's good to be able to specify which dependencies are valid for which layer, this helps enforce the intended architectural constraints in an app. Let's say you have a central app container which has dependencies like various services, db connections and so on. Let's say you have dependencies A, B, C, D, E. You decide: 1. I want controllers to work with A, B, C only. 2. I want services (domain logic) to work with C, D, E only. When a controller tries to ask for D or a service tries to ask for B, it's good if there is either no way to do it, or it at least yields a runtime error. This ensures components stay within their scope, because watching what every class types in its constructor if you have automatic resolution becomes impractical at some point, and then people are tempted to violate the architecture of the system, if nothing stops them (either due to ignorance, or pending deadlines). I've not seen a PHP framework from the popular ones that gets that right yet.
EventSourcing is often what has happend, you could also look into the CommandBus. This is what the user wanted to do.
Yup. Most benchmarks I've seen show a promising 40-60% decrease in execution time. I'm certainly looking forward to a stable release.
/r/html
Thank you for your help, I'll read AJAX then.
&gt; Why not create a human readable version of the log on create? 1) Speed 2) If you ever want to change the formatting, you now need to have a task to update the previously created human readable version - which would be a bit of a nightmare.
I already dislike your not-framework framework for making the assumption that I want to namespace controllers by Controllers rather than App\EntityName\Controller Otherwise I really like the concept! Upvoted.
This seems on par with the other benchmarks published so far - about 50% reduction in time. It seems to jive with my own understanding that a lot of the speed comes from internal data structure changes, which reduce memory use. 
Josh Lockhart said the exact thing in his book "Modern PHP", handpicking packages and combining the is the future of PHP, it is an exciting time to be a PHP Developer :)
&gt;I wish i could see the same operations with HHVM, just for comparison. [Here you go.](https://docs.google.com/spreadsheets/d/1yhviFhFfSJANcnVoQL7SoD-21KDuoaF3fkBcDJZQ-SY/edit#gid=1189539722) PHP7 is definitely on par with HHVM - in some cases ever so slightly faster. But we're talking about 1-4ms of differences.
Exactly. You could mock the static object through some horrible hacking around with includes and autoloaders* but it would be daft; after all, the reason you want to avoid static objects isn't just about Mocking. it's about being able to swap out dependancies in general. *SOURCE - once tried this like a fool
I suspect this is more of an XY Problem. What are you wanting to do in general? What made you consider that triggering the PHP from JS is your solution?
One of the nicest looking blogger sites I have come across actually... would probably not have noticed it without you mentioning it, looks like an interesting framework, I will be testing it out.
Love it. I've been using Symfont and Zf2 throught the years, but more and more thinking "I can make it simpler" and without so many deps. Your approach is something I've been thinking of doing for a while - clean and elegant.
I'd rather not add another employment-prohibitive felony hacking conviction to my record if I can avoid it.
Yes! I need to finish reading that book, it's awesome.
Thanks! Good luck, and if you discover anything, feel feel to contribute back to the repo :P
[The Aura project](http://auraphp.com) has made that kind of thing possible for several years now. [PSR-7](http://www.php-fig.org/psr/psr-7/) and [Relay](http://relayphp.com) now make it even easier. Nice to see other people popularizing the idea after so long.
tiredness, and lack of experience. thanks
It doesn't force the user to change their behavior of anything. It works like any other composer library, just plug it in and use as needed. The only thing abnormal it does is add the struct function to the global namespace. Yes, methods can be added similar to golang/ruby structs.
Sorry, I'm tired. What I'm going to do is load a blank page with javascript code to send a $_GET with the size of the screen, then I'll use php to determine the size of the text and the images. because stupid chrome doesn't work correctly on linux right now, and if the user changes the zoom on the screen the measurement of the screen messes up. with this I expect to have the very same resolution on any zoom. (I don't know if I'm tripping but the "em" on firefox looks way too different on chrome, and my design needs it to be precise. Thanks for the help, but I made an overnight and I'm kind of annoyed.
Usually screen size issues are handled in CSS with media queries. Is there a reason you can't solve this with CSS?
As far as I know you're not wrong, however I think structs are extremely useful and should be included as a core feature of PHP; for now this would make do as a nice example of how it could work.
Why are you bothered with HHVM? I really don't understand. So what if HHVM is a few benchmarks faster, which in some cases after the lock down, it is. Just be grateful to the HHVM developers that PHP devs have been forced to up their game in which you will soon be winning by upgrading to PHP 7.
Every time I see this talk about PHP7's performance, I remember the table on the RFC page that tracked the number of operations as the code evolved. And then it reminds me of the the [Sanic Hegehog meme](https://i.ytimg.com/vi/h4sLNP2JxKY/maxresdefault.jpg)
silex
not trying to hijack your post, but have you seen zippopotamus?
Just for curiosity and, as you said, its a good competition. HHVM, somehow, forced Zend engineers to pay more attention to PHP community and opinions. And to make a faster language.
Lumen - http://lumen.laravel.com/
What's a "BOM" and what's a "MRP"? I've been doing PHP web dev for many years, but I've never heard those terms. I Googled it, and if that's the same thing, I think they're business accounting terms?
Good question, BOM makes me think of byte order mark.
I know! My corporation committed to moving to pgsql for years, with marginal success, due to the complexities of migrating apps from MySQL. Then we committed to migrating to HHVM by Jan 1, 2015 [successful as of Jan 27] and then to HackLang by Jan 1, 2016. We immediately realized a lack of support for Postgres. We immediately suspended the pgsql migration efforts. Then we found https://github.com/PocketRent/hhvm-pgsql Stability isn't exactly perfect, but it's not bad, either. The project is very actively maintained. The performance benefits from HHVM were far and away worth it. HHVM is where all the true innovation is these days. And dealing with their core maintainers with issues is a MUCH nicer experience! Plus, I remember submitting a bug report for an HHVM security function and then I was contacted a few days later by Facebook Corporate: "Where should we mail your cheque?" -Excuse me? "You have been credited for discovering a security bug. We want to send you $800." I cannot even imagine that happening with Zend :O There, I have filed several critical failure bug reports (one where `new DateTimeZone('EST');` would cause a segfault in PHP) and usually just ended up having them chronically ignored for months and months or treated with disrespect.
Radar: https://github.com/radarphp/Radar.Project
Slim heres a nice little skeleton app as well (uses twig for templating) : [slim skeleton](https://github.com/slimphp/Slim-Skeleton)
Why would you move to pgsql? What advantages made it worth the effort of learning the intricacies of a new db engine, let alone the time to recode and test? 
Above average returns or above average turnover? You don't get above average returns by just squeezing people dry. When the last company I was with started tightening their belts and making us work more hours for the same (below market) pay, I started looking for a new job fairly quickly, and while I remained there, I certainly didn't care about doing my best work for a company that treated me like a commodity. You can't expect developers to work 80 hours a week. People have families and lives. We didn't go into a profession where we expected to be working 80 hours a week (e.g. medicine) nor one where we are paid what would be expected of that.
I would recommend using a framework like [Slim](http://www.slimframework.com/) too, otherwise your ajax code can end up looking like spaghetti. 
bookmarked, thanks!
Why don't you show us your version first? ;) Not to imply, you'd let us do your homework :D
My company uses Slim framework for many public-facing projects. This choice was made several years ago when Laravel was in early infancy. All of our data comes from internal APIs, so we didn't need an ORM or anything like that. Later we borrowed a few components from Laravel, particularly Illuminate\Cache. When Josh Lockhart added class-based routing to Slim 2, things got really nice. Nowadays, Lumen looks to be a great choice, too.
All of this depends on purpose and scope. Do you want the log for a few admins or customer service to review recent activity? Or for a social activity stream among users depending on their relationships? Maybe you want a format for [activity streams}(http://activitystrea.ms/). Then read some code about how it could be implemented: https://github.com/redpanda/ActivityStreams Or maybe a complete server implementation: https://github.com/DracoBlue/activitystreams-php If you need something fast and searchable, perhaps elastic search or kibana fit the bill: https://www.elastic.co/products/kibana
The problem is in the fact that most distros bundle this broken json extension with PHP nowadays which, I would argue, means that most default PHP installations (and, hence, the majority) have a broken implementation. This, in turn, makes a library that relies on the *working* extension break on all such platforms, which leads users of it think it's the library's or PHP's fault, when in fact it's the fault of one developer who didn't think feature parity was important enough to be bothered.
I'm most curious to see what can be done about the major frameworks. Every benchmark test I've seen of various frameworks always puts things like symfony, etc near the very bottom.
If you ever need to do that again, have a look at [runkit](http://php.net/manual/en/function.runkit-method-redefine.php)...
Instead of an iframe, you may want to consider using javascript w/ AJAX
i learned html, css, js, jquery, php in a month. so. I just need practice. and I get confused with so much data in my mind
Yup. This convention dates back hundreds of years, when keyboards didn't have keys for the vowels.
"computer of the client" sounds to me like a way to say "customer's machine", not client-side as in the browser. 
"customer's machine" y like it! bad English sorry. Spanish country.
Applying labels means both of us know what we're talking about. That's the whole point of design patterns.
you say "computadora del usuario" in spanish
Interesting point, thanks! But OP said "that encapsulates all my services", which doesn't seem contextualized.
I wasn't trying to say "good" or "bad", just putting a name on the 10 lines you wrote.
Anyone know how it compares to python/gunicorn? I'm a PHP dev but have been considering a switch to Python/Django/Flask. The web is short on comparison benchmarks! 
PHPStorm &gt; any other PHP IDE.
OP himself already explained before you even bothered posting: &gt; Now, please dont ask why we are not using C++ / Java etc.There are a lot of background why we are using this product If he's explicitly stated that he doesn't want to talk about why they're not already using something else, there's no *way* he wants to talk about potential replacements – potential replacements he's aware of, as he stated he doesn't want to talk about them.
My English is not that good, but I think "I would" does not mean that the original poster is forced to follow my advice. I never asked him anything, and I do not expect a response from him, about tales of my previous experience when dealing with performance issues.
The essence of repo mode is not that you don't have to check if files changed, but rather that the compiler can assume that it already knows all classes, functions, methods etc (as dynamic creation is forbidden). This means, for example, that a call like `strlen($foo)` can be optimized because the compiler knows that this is the normal, global `strlen` function and not a namespace override (which it could also be ... and which could be introduced at any time).
Your response implies that he should be pursuing those as an option. What you said, to an English speaker, is "[If I were you] I would..." when the guy specifically said that he is aware of better options, but cannot (most likely for internal political/cost reasons).
For anyone interested in Hack, it has actual structs known as shapes: http://docs.hhvm.com/manual/en/hack.shapes.php
Yes it will be compatible. There are a few dropped features but thats mostly stuff that has been unused by the masses for a while.
!RemindMe 5 months Look it up? No. Follow it? Hell yea. We'll find out, won't we?
Probably because your comments are not relevant to the discussion. OP is only reporting their results when changing one part of their application environment. Perhaps the app was written ages ago and has been modified countless times since. Perhaps the company could only find PHP programmers. Perhaps it's time for a rewrite in PHP or a more suitable language but that's outside the focus of the post.
&gt; Hehe, please tell me the dropped features will include the "mysql_" functions. I'm tired of hearing about how bad of a programmer I am for using PHP, despite only using PDO's for a good while now. :P I can confirm that mysql_* is [dead and buried](http://git.php.net/?p=pecl/database/mysql.git;a=blobdiff;f=README.md;h=6247865a570aa6a643b6ed051f5e07468279b4d0;hp=de41e521c4d62d7184069887e9be0ee6b906574b;hb=01751ce1a8881ffaa111b5bda2139cc87aa9091b;hpb=4336b316747528bbacc6d6cc357b1a67b63fc7c5). There's a good summary of the changes in PHP 7 at: https://github.com/tpunt/PHP7-Reference As long as you write good, clean code, you generally shouldn't have any problems with moving from PHP 5.5 or 5.6.
&gt; this is a chance either for me to learn, or for you to learn I agree, although I confess I have become somewhat wary of you, given that in our past interactions you don't seem to think I am an honest interlocutor. So let me flip this around on you: what are the constraints on the module design such that you find it necessary to ... - collect the dependencies into a single object (call it Foo), - pass that collection of dependencies (Foo) into the dependent object (call it Bar), - and have the dependent Bar object retrieve its dependencies from the injected Foo object ... instead of passing the individual dependencies for the Bar object directly into Bar? That is, what leads to prefer the collection of dependencies in a single object, rather than injecting the individual dependencies?
&gt; Now, I'm comfortable with PHP. I've written a few applications in it, and I've overcome many of the minor quirks [...] When it comes to web stuff in Python, I'm blind. If this is in a commercial environment, what you've said here should be a good enough reason. The only good justification for using Python, given this information, would be that your colleagues are (on aggregate) significantly more familiar with Python and will be contributing to / maintaining the code that you write. 
With PHPUnit, why does all documentation show "$this-&gt;assert" instead of "static::assert" since all the assert methods are static? edit: spelling
If they scoff at performance you can always throw out the largest sites on the web use it, Facebook, Wikipedia, Yahoo and many more. A lot of their biases IMO will be outdated. Just be prepared for those and you should be fine. 
A context object is not strictly an object container, as it may contain not just objects, but any settings and APIs that a module requires in order to carry out its operations. It's more of a *Delegate* than a container (but more on that later). I'm just saying this again so the list of reasons makes sense. - Using a context object allows the module to fetch non-typed settings like strings, numbers, booleans, arrays etc. Example: "which directory should I use for my cache files?" $rootDirString = $context-&gt;getCacheRoot(). - Using context method names allows dependencies to be fetched by a name meaningful to the module, in case type is not sufficient. Example: "which db should I store runtime data to?" $pdo = $context-&gt;getRuntimeDb(); "which db should I log metrics data to?" $pdo = $context-&gt;getMetricsDb(); *Note:* The method names on the context interface are defined by the module, so they're meaningful to the module. In contrast, this is a big problem with DI containers - dependencies are differentiated by type (interface or class name), but when that is not sufficient (two PDO instances like above), you're forced to either create redundant classes: class MetricsPDO extends PDO {}, or you're forced to use @annotations which refer to global container names, thus breaking the module self-sufficiency and making it reliant on global state (global dependency names). - Using context method names means lazy creation of dependencies is trivial - you're already calling a method, so that method can perform tasks on demand. In contrast, with DI you need an explicit mechanism, like a proxy object, or passing in a closure factory. *Note:* Before you say "aha, lazy means you're not using all dependencies every time" - using all dependencies *every time* is a really poor rule of thumb about whether you need said dependencies. I may have a module that caches information in Memcache. If I have fresh cache, I don't need to load my repository or the database class it needs. I can give countless examples when dependencies are not used on every single execution, even if the module is quite specific in its purpose (referring to SRP). Also you may remember the discussion how eager dependencies make multi-action controllers impractical because every action needs different dependencies. This problem is avoided with lazy-by-default providers like said context methods. - Using context methods means you can provide functionality which is not exclusively about reading configuration, or fetching objects, but also about communicating with the caller, or *delegating* tasks back to the caller. In this case a context object method serves as a Strategy or a Delegate for the module. For example $context-&gt;notify($event) can be a compact &amp; performant alternative to passing in an Event Bus object as a dependency. The caller can then decide where to send the event on its own without burdening the module with a specific dependency contract. You know, as you get to a smaller and smaller scope within a module, you eventually start injecting dependencies directly, because it becomes practical. So Context is not an alternative to dependency injection, it exists alongside it, and it's just what "dependency injection" looks like at a larger scale. Why larger scale? Because a module is represented by one class, but the keyword is "represented". A module is a set of classes (and interfaces) that form a cohesive unit of functionality, and not just a single class that stands on its own. Think about it like a Symfony bundle, without the cruft: a plain old PHP object. BTW, this model of programming is used extensively in OS X &amp; iOS (all objects under the names "data providers" and "delegates") and no one yet has called it out as bad in any way. If anything, the more Cocoa evolves, the more extensive their use of data providers and delegates. It's an extremely succinct and expressive way of declaring the contract between two communicating entities. Not to mention, it doesn't require magical reflection-driven "DI containers" in order to remain maintainable. When two ecosystems have such a different opinion about basics of OOP, it only punctuates the need to diversify your experience as a programmer, and check what other languages and platforms do, otherwise you risk confusing the echoes from the chamber for wisdom. ---- Anyway, I keep explaining why a Context has benefits, and I keep explaining why Context has no inherent drawbacks. Yet, I've not heard any argument from you why I *shouldn't* use a Context. If you insist to be seen as a "honest interlocutor", probably it's time to start backing up your opinions with something tangible, that I can either confirm or falsify, like I try to do. And, you know, like in science.
If you're working in a python shop, you'll be lucky not to wind up a pariah for even suggesting it. Not that I think there's anything wrong with using PHP for some projects, but many python programmers look down their nose at anyone who decides to use PHP by choice.
None - other than type checking. In C++ structs are actually just classes with only public properties.
I would recommend Java. It gives a good introduction to OOP programming. I would also recommend you to start out with the book Objects first with Java. When you've learned that, you'll find OOP PHP, Swift and some other languages pretty easy. (Thats my own experience)
For us, Heroku.
Zend.com has a cool little [infographic](https://www.zend.com/en/resources/php7_infographic). Not sure how accurate the data is, but unless it's just miles and miles off it's still impressive. 
Looks like someone was running _sqlmap_ on your site.
Agreed on the first points. I am using 127.0.0.1 to avoid any DNS resolution issues. On a whim I did try both, and localhost is maybe a few milliseconds slower.
For what is worth, I've used phpredis for years and haven't had an issue, so I don't believe phpredis could be at fault.
Then it sounds to me there is something in your stack interfering between your code and your redis instance. Either that, or the benchmarking procedure is flawed. I would set up a new machine with the barebones necessary to run PHP and a local instance of redis, then run the benchmark there. If the results are the same, something's up with the benchmarking code. If it seems to be faster, then slowly add one by one all of the components in your stack (be it php extensions, databases, etc) to the barebones machine and test the benchmark for each until the culprit shows up. It's the poor man's way to debug, but it might just work if nothing else does.
This did start as a barebones os install a week ago, so there shouldn' be much cruft. I tested both local and remote instances of redis (local is faster, but still slower than the remote MySQL instance). The remote redis is always proportionally slower than the local instance, which seems fine to me. I could disable php extensions if that would help - I agree that sometimes you have to distill down one layer at a time to debug! I should also clarify that I'm testing both with my own full php code as a "real-world" benchmark, and using the redis-benchmark tool. The redis-benchmark tool seems to indicate that both the remote and local redis instances are behaving properly - &lt;7ms response for GET in the average worst case (remote). Does that sound proper to you?
Not really, from my experience it should be fine out of the box.
https://www.youtube.com/watch?v=oBzvMLW0ii4
In modern languages "struct" mostly means having value semantics (unlike PHP classes which are reference-based). This is not the case here. 
Interestingly, Python also implements some very similar functionality in its standard library, called [namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple). It can come in handy all the time. It also uses an [eval](https://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py#l373) of a [templated class code string](https://hg.python.org/cpython/file/3.4/Lib/collections/__init__.py#l237) to construct the resulting object. Which has resulted in many, many user arguments over whether that is The Best Way To Do It ever since.
That is great but honestly I don't find it very exciting, because as far as I've seen code execution is very rarely the bottleneck for most websites with lots of traffic, db connections and file system IO are almost always the problem.
Care to explain the difference/benefit over the [official library](https://github.com/stripe/stripe-php)? (I have never used it, so I'm genuinely curious if there is a difference here.)
Did you try to build a responsive site? doing this with js and css only seems enough, do you ever heard of 'media query'?
&gt; If you insist to be seen as a "honest interlocutor", probably it's time to start backing up your opinions with something tangible Let's start with this, and proceed thereafter. As "something tangible", recall that I renamed Pipeline to Relay based on your note that it was not actually a Pipeline. Is that sufficient in itself to establish my honesty, without caveat, hedging, or other evasion on your part? It not, then there's really no point in continuing. A "yes" or "no", without qualification, will suffice.
Predis will assuredly be slower than phpredis since it runs through the php engine. Do you know what complaints they had with phpredis? I have full control over the stack, so really see no advantage to using Predis.
Most of the common definitions I've found are about them being a simple data structure with generated accessors and setters, although most are implemented as pass by value. Would probably take a native implementation for that, I can't imagine a way to pull that off. 
You already tried querying remote and local and is working as expected (local is faster) so it must be something in your stack. Instead of guessing, try profiling your code with Xdebug and then analyze it with a tool like Kcachegrind. Do it for both (remote and local) and see what is taking so much time in your stack.
Yes.
I like how you're putting this. Let's say I wanted to inject things into the controller. Would this be through reflection or just a DI container? Seems like it could get messy fast.
Are you using a single Redis instance or multiple servers? I previous encountered an issue where the connection library would take up to a few seconds to determine that a server in the Redis cluster was not operating correctly.
Mm, good point
Hmm, okay. I'm sure that they are still standalone to some degree, but you seem to have more experience in that than I do so I'll take your word for it.
That is a practical use of injection, yes. Injection in general means to give things what they need from the outside, as opposed to the things that need other things finding it themselves. Contrast this with this code example where injection isn't being used: $app-&gt;get('/blog/{id}', function ($id) use ($app) { Or this: $app-&gt;get('/blog/{id}', function ($id) { global $app; Or this: $app-&gt;get('/blog/{id}', function ($id) { $app = Application::getInstance();
What about exploiting the US Government? Hack the NSA and ransom them! Probably get assassinated on your second day but hey, it's worth the risk!
I do like your concept but I don't think there are good reasons to go with arbitrary statement that classes should 'do things'. In fact there is no big difference between classes and structures in languages which have both. Differences are really small. What is important is of course that: structures are made for representing data structures. But in languages that have lack of this another type of data and have only classes, these classes may be used instead of structures without violating any of good OOP good practices. There are even really popular patterns like Data Transfer Object that are expected and supported in popular libraries (for example in Doctrine) and you cane make clear distinction between data objects and classes by using fixed namespaces and logic naming conventions by prefixing or suffixing your classes name. I don't think your concept is wrong. The point I'm trying to make is that the classes are just fine for using them as structures specially in languages with lack of built in support for structs.
How do you not find it exciting? It is obvious that speeding up just the code in a project like this one had a *major* impact, and the maintainer of any sufficiently complex application should be incredibly optimistic due to this.
Oh for sure, enums are supremely useful and I have ended up using various solutions to emulate their behavior in php for years :)
Awful article, which is a year old.
Not sure if you're the author; but that blank 'usage' box in the read me needs to be filled...
Not the author, /u/crell is.
I'll definitely be visiting that page when I need more work and when it becomes more busy. :)
I separate my app strictly into domain services and clients using them, and I've struggled to see what makes sense in terms of factoring, so ask me any details and I'll share my experience. &gt; I read and now understand why it isn't wise to place http redirects within a service layer. How did you place redirect in a service? For what purpose. Not sure what you refer to here, and I'm curious. &gt; I also read that the service should not do anything outside of its purpose. A "user service" (also "identity service" or "authentication service") is a relatively standard component in any project and typically has these kinds of responsibilities (all of them from neutral input from, say, a controller, as you said; this applies to all services): - Create (register) a user. - Produce auth tokens: take username/pass, return token. - Authenticate: takes token, return whose username/userid it belongs to (and if you use RBAC, you can also return which roles this user has /client, staff, admin, system, .../). - Get and edit core user fields and profile settings (avatar, name, email, change password). If your ecosystem is large, some of the user profile data may be stored separately and be specific to some of your services (based on the same username/userid), but typically you have at least *some* user fields on its core identity, say an avatar, so the identity can be expressed consistently throughout your system. &gt; Example: User Registration should only create a new user, using input passed by controller, but i am wondering if it is also fine to set flash messages within the service layer. The session conceptually belongs to the client (client here = controller + templates that form the website frontend). Services should not be aware of the session on their own, because at some point they may end up split off to another process, machine or language and have no access to the PHP session^1 . Notice how the user service produces tokens, instead of having signIn() and signOut() commands that keep something in the session. You'd have a client-specific service that your controllers can access, which will return state that is stored in the session: - Current token (fetched from user service, passed in here) and cached user details, to display on the page ("Signed in as: Joe | joe@example.com"). - Flash messages. - Current CSRF token (if you use session-wide one, which is typical). - Anything else you've selected to implement on the client side that saves state in the session (say you may have a shopping cart here, although it can also be differentiated as a domain service that multiple clients can use - that's project-specific decision). &gt; My application displays a lot of flash messages session based notifications for users [... like ] The username xxxxxx is already in use Usernames Should be &gt; 5 Characters [...] Should/can this be defined/set within the service class or is there something wrong with that? The controller should take the user service result and feed the errors in the client service; the user service is not aware how its messages are displayed, it just returns them. In pseudo code your controller will contain code sort-of like this: $result = $userService-&gt;register($registrationForm); if (!$result-&gt;success) { $clientService-&gt;flashError($result-&gt;errorMessage); } else { $clientService-&gt;flashSuccess('You did it!'); } At the PHP level, a service object may communicate an error in many ways: throw exception, return error object, return array with errors, this is not what's crucial here, just pick one that feels natural to your workflow and be consistent with it (I also return a *list of errors* from services, not just one error, which is handy for a list of validation errors on forms). What's important is the controller is acting as the glue between two services here, that's what its role is. If anything is unclear about what I said or you have other questions about services/controllers, ask. ^1 It's ok to "cheat" and use the session in services, but only in a way where it can be easily replaced with independent storage later on. The test on whether it can be easily replaced is: "can I keep the same exact API for this service, if I did NOT have access to the PHP user session?". If yes, go for it.
Makes complete sense. Ok a secondary question based on your answer. Right now i am creating a framework to learn and make these sort of mistakes. The project i am working on includes user login's and csrf tokens. UserAuthentication will check session userid, key, and token, and csrfValidator checks session csrftokens. At the moment i launch my application as follows This is the core app/bootstrap file https://github.com/ICJR/esportspCMS/blob/master/library/core/esportspcms.php If you take a look here https://github.com/ICJR/esportspCMS/blob/master/application/config/autoload/classes.php I call the method to validate tokens. Within that method i set a session alert which uses this helper https://github.com/ICJR/esportspCMS/blob/master/library/helpers/alerts.php Is there a better way to handle this? Should the csrf token return false if invalid and within the autoload/classes file i check on the bool and assign the alert through there? 
I placed the question on both stack overflow and here to see the different answers i would receive. http://stackoverflow.com/questions/31133431/restrictions-within-mvc-service-layer/31133765?noredirect=1#comment50280433_31133765 From what i have read here i was told to leave input validation within the service but to exclude or replace the way i handle the error output from services to controllers. In the overflow answers i am being told to run the input validation within the controller. What was said here makes more sense because i wouldn't have to copy the validation checks if for example the user is forced to login on a separate page ( admin panel, separate client portal etc. the validation would be the same - see service `validateInput`). From what i provided there is that the correct way to handle the error output? The services extend the main service class which provides the method to set errors ( all it is doing is adding onto the protected errors var within the service class ) then if the login was unsuccessful the controller requests the error messages from the service and sets the alert messages. If i am correct this is separating all of the layers and if i ever moved away from session flash messages all i have to do is alter where the alerts are saved by the alert helper class.
No i am passed that, your right, and i understand that already and now i am understanding the issues with session error setting within services and keeping it separate from controller. I wrote question/response below before seeing this but what are your thoughts on the code provided in the link.
The latest/newest convention is same like the oldest convention ;) Any of these could work depending on how you want to factor and abstract your code: $userService-&gt;login($user, $pass); $userService-&gt;login(['user' =&gt; $user, 'pass' =&gt; $pass]); $userService-&gt;execute('login', ['user' =&gt; $user, 'pass' =&gt; $pass]); $userService-&gt;execute(new LoginCommand($user, $pass)); $commandBus-&gt;send(new LoginCommand($user, $pass)); (new LoginCommand)-&gt;user($user)-&gt;password($pass)-&gt;execute(); // etc. I'm sure I'm missing plenty of variations in that theme. But in general, unless you're implementing the Builder pattern, or have a fluent interface requiring that you be brutally succinct, keep your methods verbs and your classes nouns. In a different world what you do may have been commonplace and be all right, but it just's contrary to all the other code I've seen and so it's hard to read and understand the intent. **EDIT**: Added one more example with a fluent Builder, demonstrating how one typically expects non-verb methods to be used (user = implicit setUser etc.).
There's nothing wrong with choosing a well supported framework and running with it. 
Here's a small benchmark running over the main product I'm working on. http://i.imgur.com/ir7dkFx.png The first three are synthetic, the last one is rendering a page of our application. Bloody impressive.
The motion on the floor is to change the name of /r/remotephp to /r/H1B. The motion requires simple majority to pass. All those in favor say "Aye."
To me it is the difference between building websites (Laravel) vs building web applications (Symfony 2/Zend Framework 2). In a typical website everything can be handled in the web-tier, i.e. web framework, whereas with a typical web application the web-tier is normally a smaller (and less important) part in a larger piece. I.e. when I build a website I think first and foremost about the pages (the stuff a user "sees") whereas when I build an application I first think about the domain objects and business logic and the web part follows much later. To me Symfony 2 and Zend Framework 2 are much easier to add (or integrate with) a plain PHP business domain with. 
I'd be interested in hearing this as well.
Apparently Crell = Larry Garfield. 
Not all experienced developers consider Laravel poorly designed. All of the frameworks have pros and cons, shipping with an Active Record ORM (and integrations to go with it) doesn't make a framework poorly designed.
I updated the param middleware to use Relay PHP. It works well and is slim &amp; trim. I do, however, miss the Error Handling capbaility of Stratigility. e.g., Calling an error: ```$next($request, $response, 'Error');``` Handling an error; ```function($error, $request, $response, $next);``` I'll add an issue on GitHub to get your 2c.
So would you say that building a business class application ( to me over 100 visits per day) in Laravel is a bad idea, as I will be regretting it after the app grows in size?
Laraval is not a well constructed application. It's codebase is to make it extremely easy to use not to be the perfect web architecture. This is most evident with Eloquent... You are so abstracted away from the inner-workings that it is literally "Magic". Most IDE's don't even know how to deal with Eloquent unless you install a helper module (which I would say, is one of the most blatant symptom of it being a pile of poop)... having said all that, i still use Eloquent. Everything can be applied in a proper way, Laraval is a tool. Know its strengths and weaknesses and you will do fine. Given that Laraval now has LTS releases it isn't prone to large API breaking changes which was not the case in the past.
There is no one magic question.
14 years pro PHP here, and I'd say that the choice of framework has a lot to do with the type of project and the requirements of it, so anyone who sees any framework as the "golden hammer" probably needs to branch out a bit. That said, these days I find most of my projects fall into two categories: * Large, complex systems with lots of functionality and many devs. For these I prefer Symfony, since it's a very capable and full featured framework that facilitates writing clean and modular code that tends to be pretty easy for other devs to understand / improve. * Small, fairly simple "web page+" type apps (usually single dev) that don't have a rapid dev cycle or extensive requirements. For these I prefer no framework, and assemble the functionality needed from modules directly. Most small projects don't require an entire framework, and you can minimize your exposure to dependency rot (modules or framework being EOLd / deprecated / etc) by carefully interfacing to just the modules you need, which is handy on projects that you may only be looking at every few months or so once they're launched. I feel like Laravel is sort of designed to occupy a space between those two (enterprisey vs simple sites) extremes somewhere, but I guess I don't find many projects that fall into that area.
There are a number of questionable things within Laravel that if you *avoid* you will save yourself some long term hassle... * Facades - prefer the injection of the underlying objects. * Global helper functions - many added in Laravel 5, in place of facades (work the same way, resolve things out of the container and give you a convenient bit of syntactic sugar to do things - only problem is it ties you to the framework in ways which are painful to untangle) .. It looks like these were added to maintain terse syntax which looks great in demos but is not something you want to do in reality. They may *look* great, and are probably reasonably safe to use in framework specific code such as controllers, but they are all too simple use in the rest of your app. Again, prefer the injection of the underlying objects * blade template injection - avoid this like the plague. There may be a handful of cases where this saves you some bother but the fact that you can just resolve *anything* and throw it into your template is pretty insane. I've already caught people in my team injecting repositories and querying the database via this... gross. There are some other parts which people have mixed opinions on. Eloquent springs to mind. I personally think ActiveRecord is just fine for a many things - it is easy to conceptually reason about and gets the job done. You don't have to use it though, you have options. You can just use the query builder, or straight PDO. Or you can bring Doctrine along to the party. Eloquent is fairly optional, but you can get a lot milage out of it, especially for simple(r) apps. And most apps are fairly straight forward simple things. Many people isolate their app from Eloquent by creating some first class domain object which wraps it up (referred to as a "repository", but not certain the term is correctly used... someone who is more terminology savvy than I will probably weigh in on this). This limits Eloquent's blast radius somewhat, allowing you to replace your persistence layer in a *reasonably* pain free way in the future. Laravel can be put to good use and can be quite enjoyable to work with... but think beyond the hype and be smart about how you use it. My advice for all frameworks is to do your best to isolate your app from them as much as possible. Try and keep your "real" app code as agnostic about the framework as possible. 
&gt; So would you say that building a business class application ( to me over 100 visits per day) in Laravel is a bad idea, as I will be regretting it after the app grows in size? There are two ways apps grow in size: performance requirements and complexity. In your case chances are you'll hit the complexity problem much before you hit a performance bottleneck. It's still a problem though. When people talk about "we have to rewrite our legacy codebase" they're referring to an app that has outgrown its framework (or one that is has grown organically in random directions... which does tend to happen when the framework doesn't support that complexity from the get go).
Single Redis instance, no read replicas or anything like that.
Being somewhat new to PHP, frameworks hurt my brain. Is there any tutorial for these things? Each one has documentations but they are too advanced for a beginner. 
&gt; Can you link an example? [Unfortunately yes.](https://www.reddit.com/r/PHP/comments/3b36k1/seperate_classes_per_each_action_and_getting_rid/csik6fn) I'm saying unfortunately because I wrote like a little book on this in here in the last few days. Must... rest... I think I won't comment for a few days (or weeks (or months)). As for rebuttal, [bookmark this one](https://www.reddit.com/r/PHP/comments/3bftou/frameworkless_or_how_i_use_php/csn3x64) and let's hope he delivers.
**Simple answer: it is designed to fit the widest range of people and not everyone is a senior developer**. So it really depends on the usecase you are in for. For example you say that Eloquent is not testabe, but would you actually be unti testing your models? A lot of people use behavioral testing like Behat and for such tests the ORM type doesn't matter at all. &gt; Laravel is maybe fast to develop and easy to understand but its only because it is poorly designed Well not *poorly*, just focused on a different set of priorities, ease of use being the most important one. So complaining about laravel not having good architecture is like saying that a tractor is a bad racing car. It's just a different niche. The only realy big problem is security and stability imho, e.g. we allremember the time this happened: http://www.reddit.com/r/PHP/comments/2i95rx (after an update it would delete your ENTIRE TABLE from the database)
[Hiiii...](http://img3.wikia.nocookie.net/__cb20130708221223/monster/images/3/36/Errr....Hi-there-Joker.......jpg) It's me again. The problem with unserialize() is that __wakeup() is very rigid, it just gets called once deserialization is done, so you can't map one set of fields to another set if your object model has evolved, like you can with __set_state() + var_export(). So you can alias the name, but you still need to match the legacy state 1:1 in the new class. So instead of aliasing, you'll have to build a replica of the old class only so when it gets deserialized there you can call a method on it to produce an instance of the new class from its internal legacy-formatted state. JSON requires a "manual" mapper, but you get to walk it and map it how you prefer, so you don't need to perform those class gymnastics in PHP as your codebase evolves. If I had a legacy problem on my hands with tons of serialized objects in a database, and once I'm done placing a hit on the old developer, I'd probably fetch something from Composer (or write it myself) that would produce simple arrays out of serialized objects (what class name they are, what fields they have) and use that to map to my new classes, as I would with JSON. **EDIT:** Feel free to add that to your bootcamp :P
I'll try to be as short and thorough as possible. I appreciate you asking the question. The Stripe PHP package uses Curl which can be slow and unreliable. &amp;nbsp; We use Guzzle, an HTTP client to interact with Stripes API. By using Guzzle developers gain capability. Some of these especially important for applications interacting with the Stripe API in high volume. &amp;nbsp; When we first started this package, Stripe didn't keep the PHP package up to date with the latest versions. This appears to have changed in recent months. &amp;nbsp; We attempt to maintain full coverage with in a couple weeks of the latest version. &amp;nbsp; We feel, and i'll stress this is our opinion only that the Stripe package is a bit over engineered... rushed. It's up the individual developer to browse between the packages and decide for themselves. &amp;nbsp; Our packages are engineered to be easily extensible, follow consistent patterns, adhere to semantic versioning, and follow PSR-1, PSR-2, PSR-4. 
Holy crap... can we be friends?
Sure! I'm actually new to Slim myself, coming from the Drupal world (which is more a monolithic PHP application than a framework). I'm writing these tutorials from the ground up, so if you start with my first one (linked from the first paragraph in this tutorial), you may be able to follow along. That said, are you just new to PHP or are you new to web application development in general? How much do you understand about HTTP requests and responses, request routing, and the various pieces of code you might need to do things like logging, e-mailing, database querying, etc.?
tl;dr - I just prefer Symfony, Zend, and Doctrine . I've never touched Laravel. I've only seen code examples ; which are not appealing to me. I've seen code examples for Laravel, and some of it looks messy and inefficient to me. For example, wrapping things in singletons/static classes. The blade templates look messy with the triple-exclamation-point eg (!!!) . I'm pretty sure Symfony's implementation of Events and Twig templates is more architecturally sound and feature-complete than Laravel's implementation of events and templates. The Laravel event dispatcher looks like it's missing an observer object.
I feel like people who criticize framework A or B try too hard to over-architect their applications and *go out of their way to avoid using the framework* - defeating the purpose of using a framework... When building a web application, you have three choices: 1. Build everything yourself from scratch and have "perfect" architecture built precisely to your own standards. 2. Use a framework, build what you need quickly, and live with the fact that your application and your framework are attached at the hip. 3. Use a framework, and try like hell to keep the framework away from your "application" code, writing dozens or hundreds of boundary adapters, wrappers, and interfaces, plugging all leaky abstractions etc. All of these have advantages and disadvantages. \#1 makes you an unproductive code hipster \#2 means you'll build what you need quickly, but you're now stuck with with your framework. If you don't plan on changing frameworks, great, no major problem. Just don't make your shit untestable - but that's on you, not the framework. \#3 means you're basically not using the framework to your advantage, because you're writing a shitload of insulation code (adapters, interfaces, POPOs) and using a framework.... by not using a framework??? What I've found is that rarely does "leaky framework" usage cause problems, unless you like porting your application between different frameworks for some reason. What slows you down is *your own code architecture*: 1. Inappropriately applied abstraction 2. Poorly designed cohesion 3. Loosely and tightly coupling the wrong things 4. Poorly defined responsibilities Not once have I ever said "shit, I wish I didn't use Eloquent here" or "Man, that request facade is really biting me in the ass" or "Crap, the router has too many methods". What I *have* said is: "shit, I tried to solve two similar but different business rules with the same method, and now they're tightly coupled together, and separating them out is going to be a pain in the ass". Also, I don't know about the rest of you, but for me, 75% of the code of basically any application is inherently "http" code. Views, routes, controllers, forms, validators, css, html, javascript - stuff a human being will interface with - stuff that a framework like Laravel *was designed to make easier to build*. So when your colleague says "when you need to rewrite your code in one year...." what the fuck does he think it is that you're going to be rewriting?
&gt; Admit it, you rewrote Aura to fit this thread. Yes, although going back in time to 2010 to do the rewriting retroactively has severely depleted my Delorean plutonium reserves.
I am going to be scaling to clusters in the near future, but that cache looks pretty nice. I am using opcache for script performance (without timestamp validation). I tested using predis as some others had suggested - same results, maybe 5-10% slower than phpredis (not terrible). Given these results, it does seem like it has to be something further down in my stack, very puzzling. I'll keep drilling down - would you like me to update when/if I figure it out? Thanks for your help!
yeah Stripe's official package is not so good. They only very recently added namespacing. Felt like the PHP library was a bit of an afterthought. Congrats on this btw, it looks awesome. Great job. 
Laravel 5 takes a step in this direction. The HTTP layer is very clearly segregated from everything else and the Command paradigm encourages you to keep all of your business logic out of the HTTP layer completely. 
Right now you would probably need to do something like: $app-&gt;when(['PubCont1', 'PubCont2'])-&gt;needs('A')-&gt;use('A1'); $app-&gt;when(['AdminCont1', 'AdminCont2'])-&gt;needs('A')-&gt;use('A2'); Of course I could make it more terse using a `*` wildcard if I wanted, but that would have performance implications.
So my real job is a database engineer focused in the performance and tuning aspect of databases. So I have extensive knowledge in SQL and Bash Scripting. This led me down the path of HTML and PHP. I've built a few websites and PHP applications so I know my way around the language. I get HTTP requests and responses but get lost in the routing aspect. Confident in the ability to learn just hard to find the documents. thanks a ton for the help BTW. 
I would like to see someone actually create a printer driver in PHP. That would be interesting, but I've seen equally odder stuff, like IP routers....
&gt; Maybe you and I are working with different kinds of Service Locators and DI containers. The ones I work with use named services for exactly the reason you mention: to allow for different instances of the same types. Cf. Aura.Di for a named-services DI container, or Aura\Html\HelperLocator It doesn't matter where the name is specified. Annotations are just a typical example that I hoped would speak to you. Reading it via reflection from a parameter name or some other way doesn't solve any of the issues I listed with it - the fact it points to a container-scope name, and the scope of the DI container in most apps isn't just that module (it's often the entire app). &gt; I think there benefits to using it. (I do think there are drawbacks, but then I think there are drawbacks to anything -- tradeoffs, tradeoffs.) Right but you're not mentioning any of them... Which is the entire point of this debate as far as I see, because I already spent way too much time listing the benefits. I wouldn't mind a serious critique but I don't see it. I can name one drawback if you won't: contexts require that a module writes an interface, and requires the other side implements it. That's N + 1 extra files, where N = number of implementations. Although... in PHP 7 with anon classes it becomes 1 extra file (just the interface). It's still a bit extra typing, but you get clear explicit contracts in your code which scale better with increase of codebase complexity and larger components. So it's a tradeoff I'm glad to accept. What else is there? I mean you say "drawbacks" in plural, I'm naming the obvious one to get us started, what's another drawback? &gt; My response is that the difference in scope (module-specific vs application-wide) is not a significant difference and does not change the dynamic of its operation in a substantial way. It's surprising that *you* of all people wouldn't see how scope changes the dynamic of a codebase. - If scope wouldn't matter, we'd be putting all our variables in the global *scope*. - If scope didn't matter Microsoft wouldn't be investing millions in componentizing and untangling their kernel (project MinWin). - If scope didn't matter Oracle would not have spent years modularizing the Java runtime libraries (project Jigsaw). - Also if scope didn't matter you wouldn't consider small independent components a benefit for Aura. All those examples come down to "scope". Coupling is about scope. How large a circle we need to draw around a component to cover everything it's interacting with. That's scope. And it ranges from hell (global) to paradise (fully local), with most real examples somewhere in-between (but hopefully closer to paradise than hell). But it's not just that. The reason I'm so specific about "who defines the module context interface" is because scope changes the responsibility of components. In a global service locator, or a singleton, which is fairly similar, someone somewhere has set the database to be a dependency named "Database" and that's now a fact. A module can't ask for a second database, as it has no responsibility of defining the global services, it just uses what's out there. In contrast, with a module-specific context, a module is "empowered" to ask for two or three databases for different features, and it's up to the caller to satisfy this somehow. The dynamic is not just different, it's flipped 180 degrees, and you probably recognize it as an instance of IoC (even if it's not classical parameter-based DI). IoC is often explained with the Hollywood principle, as in... the "control" is in the caller to define the dependency *implementations*. But the receiver also gains control: the control to define the dependency *contracts* (which it can't define if it's forced to read existing services from global locators or singletons). Muddy up the scope and you no longer know who's in control of either the contracts, nor the implementations. Scope is crucial.
IMO Laravel is the meat and potatoes of php. It can be used for 4/5 of the projects and works well enough out of the box. Sometimes meat and potatoes is all you need.
Can you elaborate on the blade issue you listed, and what other template engines do different in that regard? 
The question is: why do you need a list view in the first place. There is a reason behind not exposing everything altogether. In the worst case scenario you should consider contacting the owner. If you are not stealing data, which I hope you are, there should not be a problem.
I have contacted the owner. They are fine with us using the data in such way and are offering to provide monthly data dump. However, they do not have or plan on developing a method to list all entities. Back to the technical question.
I dig. Sounds like you've got a good start! You may get some mileage out of my Slim tutorials, but I'm only just beginning and I didn't take the time to explain everything (i.e. what is routing? how do PHP namespaces work? etc.) I've been a Drupal developer since 2006, so most of my PHP experience has been wrapped up in that - with some small bespoke projects and osCommerce hacking sprinkled back there in my Dark Ages. I learned a lot by going through Fabien Potencier's tutorial on building a framework on top of Symfony2. You might consider starting there and seeing how far it helps you along: http://fabien.potencier.org/create-your-own-framework-on-top-of-the-symfony2-components-part-1.html I did this a couple years ago and made a repository that uses branches to contain the code examples from each part of his tutorial. Probably not necessary if you're a careful reader / don't mind learning as you go, but if you get stuck you can always see the code I produced following the tutorials here: https://github.com/rszrama/symfony-tutorial
Often business requirements prevent developers from doing what they enjoy. We aren't all working for ourselves, many of us have to answer to someone higher up who may not know what they're doing. 
So instead of separating each user service into its own class i should implement one userService class that defines all of the user services within it? So login, registration, logout, etc. etc. would all be in one userservice class? 
If the owner is OK with brute-forcing their API (which is what you're describing in your original post above), it means one of two things: 1. The owner doesn't understand the implications of what you asked (like multiplying the utilization of their service by several orders of magnitude with most calls being garbage calls, slowing down operation for everyone else). 2. You're not describing your situation accurately. To answer your technical question - if an API doesn't provide a list of identifiers, get it from somewhere else. If it's movies, get them from IMDB (or similar). If it's car models, get them from a site providing a list of car models. With this third party list in place, this will change your brute-force attack into a dictionary attack, which has a higher % chance of success of hitting an existing entry in their DB for every call you make. There. I helped someone abuse a server today. I... I think I should stop posting.
Look up the "Lambda architecture" which in a nutshell is how to combine somewhat-out-of-date batch-processed full copies of a dataset with realtime-but-incomplete datasets in order to produce a combination that resembles up-to-date full dataset copies. I'd explain further, but your attitude is somewhat off-putting when you say things like that to people who are trying to help you: &gt; Back to the technical question. &gt; (The reason monthly exports do not work for us is outside the topic of the discussion.) Anyway, google it. Good luck.
It's one way to do it. I did edit my comment above specifically to add the fluent command object approach that I thought you'd like more: (new LoginCommand)-&gt;user($user)-&gt;password($pass)-&gt;execute(); In this one you have one class per action, like you seem to prefer. The key here is that in those objects you always have one standard method which performs the action (execute, or call it exec, run, send, whatever you feel is best), all other methods merely configure the parameters of the command. This makes it easier to create complex command configurations, and make it explicit when the action is performed (when you call the "verb" method: execute()). You can have all those command objects implement the same interface: interface Command { function execute(); } Which means you can configure a command in one place, and pass it to another place expecting a Command instance, execute() it there and fetch the result. It's very powerful. Here's a hypothetical example of a more complex login command config: $cmd = (new LoginCommand) -&gt;withUser('foo') -&gt;withPassword('bar') -&gt;asRoleAdmin() -&gt;sessionTimeoutSeconds(60 * 10); $result = $cmd-&gt;execute();
I totally agree, I hate when these types of discussions come up without anyone mentioning the size of the project, the size of the team, or the expected life span of the application. If you've only worked on small sites with maybe one other person at the same skill level that has maybe 5-10 pages and maybe 10k LoC you're going to have a significantly different perspective than someone who is working on a site with 100+ pages and 2+ million LoC with 20+ devs ranging from very junior to very senior.
There's a lot of benefit to everyone on a team using the same tools. In a team setting, if you have to use symfony, suck it up, or make a larger case for laravel. More to the point, though, if done 'properly', most of your business logic should be in relatively portable objects anyway, and the framework is more a way to glue them together. If your work colleague has loads of symfony-depencies in core business logic, I'd say his code isn't any better than yours. If you focus on testable components to describe your project's logic, 'rewriting' to use another framework, or upgrading to the next symfony or laravel or whatever shouldn't be a difficult task. FWIW, I'm not sure what's "not testable" about active record. Perhaps not 'unit testable' in the strict sense of the term, but I certainly run test a test suite against code that uses an active-record based library, and the tests run just fine. 
A PHP testing framework 
You're actually... making a very good point that FIG might include tests for its interfaces. Maybe you should talk to them and ask them to consider making this an official feature of the PSRs.
Note to OP - this advice is a double-edged blade. Doing what you "enjoy" is certainly not always a good idea. And also, just because something is over-engineered, it doesn't make it bad. Note: Not a symfony fan myself (or laravel for that matter)
&gt; Strong Symfony fans have a very hard time accepting Laravel as a legitimate framework. I promise you - you will constantly fight against this type of programmer. I don't know if I'm a "strong Symfony fan", but I've used it on lots of projects. I think the prevailing attitude among many devs on the enterprise / large project end of the spectrum is that Laravel is an entirely legitimate framework, but it isn't clear exactly what type of project it's ideally suited for. Many of the projects I personally run into are either medium / large (where many choose Symfony exactly because of it's flexibility / "enterpriseyness" / complexity) or small enough that a framework's benefit is very limited over direct use of packages / custom glue code. That said, I think we can all agree that no single framework (or lack thereof) is ideal for all types of projects, and anyone who says otherwise is probably either not very knowledgeable or is selling something.
The idea that Laravel is not suited for "large" projects it primarily something that echoes around the Symfony developer community, and it may have been a valid opinion 4 years ago, but it's not anymore. In fact, Laravel has quite a few features out of the box that many would consider very enterprise such as job queues and command buses, and of course was the first major full-stack framework to implement the new middleware stuff people are excited about. I think if some Symfony developers would really give it a good shot, they would find it works fine for large projects - just as well as Symfony at least. Of course, it still might not be their cup of tea, but I don't think it will be because they feel it is only suited for smaller projects.
The problem with old Laravel versions was the structure change between versions. From 3 to 4, 4 to 5, 5 to 5.1 It sucks write your project one way and had to change it every update. Now, with LTS, people can feel more confidence on the framework.
We're doing that too: https://github.com/hhvm/oss-performance/blob/master/conf/php.ini#L38 If there's anything we've missed, pull requests and issues are very welcome :)
Don't blame the libraries! :-) Long post is above, but my code was flagging every Redis return as a cache miss since the original handling code was written for memcached, and the return structure is slightly different. It failed silently, and gracefully in that it hit the database instead, so that's good... So pleased to have figured this out. Thanks for your pointers!
Laravel now has predictable release cycles (6 months), LTS, and typically requires less than 1 day to upgrade. The upgrade to 5.0 to 5.1 was 15 minutes. Of course, I don't expect you to be satisfied by these things. :)
&gt;I encountered huge problems with the way some parts of Symfony2 and especially(!!!!!!!!) Doctrine2 are designed / intended. Like what(???????) 
First, verify that SASS works on your machine. Open command line, go to the directory where your SCSS files are, and execute `sass &lt;inputfile&gt; &lt;outputfile&gt;`. Did it work? Good. Now find out where that SASS actually is. Type `where sass`, and now you know. The "bat" or "cmd" file is the one you should paste into Watcher Settings &gt; Program, and everything should work.
I haven't tried this yet but you may need to register your service providers on run-time. App::register('AdminServiceProvider'); //etc &gt; More importantly, if I have a reusable controller like "JsonApiController" for exposing my JSON APIs, I can use the same controller on the public and admin side, so the class name won't be different. I don't see what's stopping you from doing this already.
So this list (from symfony.com) is incorrect ? BrowserKit Console CssSelector Debug DomCrawler EventDispatcher Filesystem Finder HttpFoundation HttpKernel Process PropertyAccess Routing Translation source : http://symfony.com/projects/laravel 
Hi, I come to shine some light on you as I ran into exactly the same problem and I made a package to solve this issue. It's a (route-based) Contextual Provider binding, so in short, you'll have the possibility to bind any service provider depending on which group of routes you are (primarily, you can also use the Context facade to bind a context independently of which route or context you already where, useful for tests and other stuff). The repo can be found at: https://github.com/rtroncoso/Laravel-Context, take a look and tell me what you think! :)
In an ideal world, developers would walk away from that kind of management. Those higher up that don't know anything technical should stay out of technical issues. Obviously they should know what's going on and understand things at a basic level, but they should never impose technical decisions because it's completely out of their realm of understanding.
Your package is indeed solving a problem suspiciously close to my example scenario :) I'll just mention /u/utotwel/ so he can take a look at it. What I'm thinking: - In a modular application you choose your context, and *then* load the context-specific routes, dependencies and so on. - In the $app-&gt;when() example and your package we load the router, dependencies and so on, and *then* you we "teach" them how to tell apart contexts through rules. **EDIT:** *Wait, not for you, though, you rely on middleware with the contextual routes, that fires only if the prefix matches I guess... This is better that I thought at first glance.* Rules help in select scenarios, for example $app-&gt;when() helps in cases where you have this one dependency conflict between two classes. Your package helps in cases where you have groups of controllers (a common enough scenario to warrant a solution). But there are plenty of contexts which are defined differently: per service, per component, per bundle... Ideally the framework would be architected to fit this hierarchical nature of a well factored modular codebase without adding a lot of specific rules about specific use cases. I.e. in a more modular architecture, components wouldn't have rule engines that contextualize their state, but they, as objects, would only exist in the context they are relevant in. And for this, Laravel would have to change some things around. Laravel is not *the only* framework to suffer this issue, but it's probably the one with most "unmodular" approach by default from the popular ones (I can cite plenty of old PHP frameworks which are even worse). I think your solution is solving the problem nicely without disrupting Laravel too much. Thanks for sharing :)
&gt; Granted, Laravel has made some progress as of late in these areas
want to see my KnapSack/StockCutting algorithm implementation run on PHP 7 with 8600 pieces and tree different stock sizes...
Laravel will allow you to do in your blade templates in 5.1: @inject('Some\Class\Instance', 'variableName') This will automatically use the IoC container to instantiate the class and make it available in your template as `$variableName`. Typically, another framework would not provide a shortcut to the IoC and force you to use a controller to add the class in question to it's view-specific data.
&gt; because Doctrine2 did not support "core" features of a SQL dialect. ... If it's only in a specific vendor's dialect, then it is not "core". 
Yes and No. The level of abstraction in Doctrine2 is too much for me, in the sense that the advantages that come with it, also bring their downsides, because it tries to target a lowest common denominator. 
I agree with you that it isn't actually core functionality, that's why I put it in quotes. MySQL is one of the most used RDBMS system around the common web, especially in combination with PHP. So it is mind-boggling for me that I have to "re-implement"/install a 3rd-party package for (My)SQL functions for the DQL dialect.
That's my point, you don't build applications in the /app directory. It seems you are building you applications "IN" the framework whereas it's a much better idea to separate your application from the framework. This means that your core business logic will probably end up in your /vendor which you expose to the framework through some framework mechanism (Bundle for Symfony, module for ZF2, etc). 
This has nothing to do with performance or hits per day. It has to do with the problem domain. If your business is a single form on a website where people place their orders, a website build in Laravel might very well be a good solution. However, if you need to asynchronously process and refund payments, generate reports, collect activity streams, etc then your architecture will likely be very different and you will probably end up with the "web" part as just being a smaller component of the entire undertaking. 
I'm having trouble following what you're saying, but you can use Doctrine with Laravel if you prefer it to Eloquent.
You can use Doctrine with Laravel, and some people do choose to do that if they prefer a Data Mapper. You can actually use both for different models in the same project if you really want.
I wasn't around for the change from 3 to 4, but moving from 4 to 5 took me about a day for a fairly large project (mostly dealing with adding namespacing and changing the Blade escape codes). Moving from 5 to 5.1 took less than an hour. I really wouldn't call the changes "structural". They did move around a bunch of folders, but that wasn't too hard to deal with. The changes were relatively small things and everything pretty much worked just about the same way.
sorry, thanks
It doesn't use static/singleton classes. Those are what Laravel calls "facades" and they're actually dynamically resolved, but give you the simplicity of using them as if they were static classes. Facades are optional, and some devs prefer things like dependency injection which is also available. Blade doesn't use "!!!". It does use "{!!" and "!!}" for unescape output. Personally I don't like typing that either, but you do have the option to change it to something else. The exclamation points are intended to remind you that unescaped output is potentially risky. Regular escaped output uses "{{" and "}}". You can also use Twig with Laravel if you prefer. At first I didn't like Blade and couldn't understand how we were expected to do everything we need to do with such a bare-bones template system. But then I realized the concept is it makes things like foreach and outputting variables easy with a short-hand syntax, and for everything else you can still use PHP in the template (which you actually end up not needed very often). But it makes a lot of sense. There's no need to reinvent a complete language for templates, just make common stuff quicker and let us still use the PHP we know for everything else. It's also easily extendable.
&gt; In fact there is no big difference between classes and structures in languages which have both. Differences are really small. [...] structures are made for representing data structures Exactly! - And in languages which have both - the most important (I would argue) difference of those few is behavior, which structs don't have. If some complex entity has properties / data, but no behavior, it's a data structure and will naturally be implemented as a struct. But you're absolutely right - in languages which don't have structs, but have classes, those are a natural fit... just not perfect. PHP was designed to be so simple and flexible that you could use arrays for most things and get a lot of stuff done in a simple way. And (if you know to avoid the pitfalls) and take care of sanitation / checking in the consumer, they are still just as valid an implementation of a data-structure as a class. You're right, too that behavior must not be the only difference-maker between structs and classes. I thought about it some more and remembered that classes can be a valid implementation when you need inheritance, even without external behavior (aside from setting and getting). But then, it's mostly possible to solve the same problem with composition (eg strategy, decorator) instead of inheritance, and you can build actual structs, as well as assoc-arrays by composition. In any case - yes, I agree it's fine to use classes for structs in PHP, as well as assoc arrays, since PHP doesn't have native structs. But if it had good native support for structs, I would say many classes in many projects would be better suited to them, conceptually, than they are to the class-concept... namely all those instances where classes are used as data containers &amp; type safety providers / complex data structures, instead of providing behavior (f)or application-infrastructure. Another aspect - if a class doesn't just receive and provide data unmodified, but somehow transforms the input, for example by sanitizing and/or consolidating it, I would think that counts as the kind of behavior that I took to distinguish (though not uniquely) the role of classes in the OO-paradigm from that of mere structs. 
Oh... I see. I'm working on my first Laravel site atm, didn't even notice the docs for that. Thats just...wrong.
&gt; you're probably 100% correct in stating that business logic belongs in the controller. This was sort of what I was suggesting you avoid when talking about making your application code framework agnostic. If you end up throwing your business logic into the controller, you limit your ability to reuse that business logic within your project and also in other projects (which may or may not be built using the same framework). Instead (and incidentally this is something that the Laravel community has long advocated), it's preferable to place your business logic in objects that exist in a layer below the controllers. You can then either inject the necessary dependencies into the controller or use the more currently-in-vogue approach of dispatching commands. Your controllers then become little more than a thin veneer between the HTTP request and your 'real' application. 
Hey thanks for the feedback! Indeed, it's kind of a patch of the current dependency injection and concrete implementations, but it works as a charm for my biggest projects in which I work with single-project applications which use a shared core package. What is really helpful of this is that I can have the different implementations of my repositories (which are binded to a context) completely separated from each other, and for example, use one set of repositories for administrative CRUD operations and the other one for just listing (i.e. API repositories).
Symfony 2 was the first PHP framework I learnt. Authentication and all. Their documentation was fine, even with my inexperience. Perhaps Laravel is easier to learn, I'm simply stating that Symfony is not difficult to learn. The community around it is huge, there are plenty of great bundles, plenty of answered questions on stack overflow. As for Eloquent vs. Doctrine. Just do a quick Google around "active record vs. data mapper". Eloquent appears to be; quick, simple, but it violates SRP and couples persistence logic with business logic. Doctrine is more complex, but it doesn't violate SRP. Doctrine is very flexible, and very well written. SOLID exists for a reason. Perhaps the issues that using active record over data mapper causes don't become apparent until you built more complex applications - which Symfony lends itself to easily managing by providing a solid architecture to build upon. Also, "Literally nobody is doing service location in views.", people will be using it. If it's there, it's quite likely it's being used. Especially as it's an easy way out of doing things properly (like the kind of route new PHP developers may end up taking).
Recorder is awesome!!!
I agree with this actually. It's totally understandable. Perhaps it could have come sooner, but it is good for Laravel, and a step in the right direction. However, /u/AlpineCoder has a good point here. Frameworks like Symfony are more "enterprisey", and they have features (like the bundle system) which really help when writing large applications. I'll also take something from something you said in reply to me elsewhere in this thread as evidence to why Laravel doesn't make the cut vs. Symfony for enterprise applications, "Literally nobody is doing service location in views. It's just a feature that was ported over from .NET as an experiment". Experiments don't really lend themselves to enterprise applications. If I want to make a small application, I'll use a micro-framework, maybe Lumen will make the cut, in the past I've used Slim personally. If I want to make a medium-sized application, I'll use Symfony. If I want to make a large-scale application, I'll either use Symfony, or another framework in a more suitable language depending on the project. This is what /u/AlpineCoder is referring to when he says "Laravel is an entirely legitimate framework, but it isn't clear exactly what type of project it's ideally suited for", and many people have this issue. Symfony follows more "enterprisey" conventions and best practices like adhering to SOLID principles and Laravel doesn't in many places. 
Agreed. It seems odd to want to build your application 100% custom and separate from a framework, then use a framework to have a 'website' on top of it. Seems to defeat the entire logic behind a MVC framework to begin with. You can, and we do, still think about domains and logic at the start of building an application, which is just good practice. The guy you're responding to basically says "I do a bad job implementing this framework, therefore it's bad."
&gt; It appears to use static classes, but those are what Laravel calls "facades" and they're actually dynamically resolved Not this again. The "facades" are not facades, they are proxies; and yes, you are making static calls when you use them. That the result of the static call is resolved out of a container does not change either of those facts. Thus, they are static proxies to a service locator. That does not make the misnamed "facades" more or less useful, but it should provide clarity about how and when to use them.
Nice.
Yeah, it just seems like a really bad plan all around. Even if you doing testing. Edit: Even if you *aren't* doing testing.
The word facade in Laravel's facades does not refer to the "facade pattern" in OOP. He probably would have named it something different if he knew some people would complain about that, but the word facade was an English word long before the "facade pattern" in OOP. Yes, they are a service locator. If you don't like them, you can absolutely use dependency injection or other resolving methods if you prefer. Laravel also makes that easy and it supports that style of development (especially in Laravel 5). If anything, the Laravel documentation now seems to encourage dependency injection over facades. Personally I usually prefer Laravel facades because I put simplicity of design at a higher priority than strictly following software design dogmas for the projects I'm currently working on. But the choice is yours, if you don't like them, don't use them, but there's no point in complaining that they exist as an option.
&gt; You can then either inject the necessary dependencies into the controller or use the more currently-in-vogue approach of dispatching commands. On a sidenote - I really do not understand why Laravel 5.1 deprecated the commands namespacing convention in favor of "jobs". edit: &gt; This was sort of what I was suggesting you avoid when talking about making your application code framework agnostic. If you end up throwing your business logic into the controller, you limit your ability to reuse that business logic within your project and also in other projects Would you consider repository decorators as suggested earlier to be an adequate solution in this case? 
I strongly encourage you to listen to DHH's interview on Full Stack Radio on this topic.
&gt; The only realy big problem is security and stability imho, e.g. we allremember the time this happened Ok, that was one hell of a gawd-awful holy shit that's bad situation if you accidentally used that one method wrong. But I wouldn't forever condemn the whole framework as forever being one with "really big security and stability" problems because of that one issue in 4.2 that was quickly patched. That's actually the only data-loss bug I can think of that I've heard of in Laravel. And for security, it's actually pretty great. I can't think of any significant security issues that have come up, or at least not anything that wasn't fixed right away. It does a really good job of making it easy for even bad PHP developers to follow best practices for security (encrypting cookies, built-in CSRF protection, best practice salted/encrypted password storage, escaping template output by default, etc.).
 I can tell you have seriously never used Laravel because you keep saying stuff about bundles, and Laravel service providers are basically the exact same thing. That tells me you have never really used Laravel for anything serious.
I don't like the word "artisan". It's pretentious and makes my skin crawl.
&gt; On a sidenote - I really do not understand why Laravel 5.1 deprecated the commands namespacing convention in favor of "jobs". We can speculate... Taylor has said that it's because he sees them more as being a replacement for "queue jobs"... There also seems to be an undertone of a distaste for the use of a command dto and a dedicated command handler. That has been completely removed from all the docs etc. It still works by the favoured practice is now to use self handling commands which I personally find less flexible and a bit of a smell. All that aside, nothing stops you from continuing to call them commands and continuing to use them in the way that they were defined in Laravel 5.0 - as best I can tell there is no suggestion that this behaviour will be deprecated in the near future. And there are other options - you could just build your own command bus if it did disappear..they are not terribly difficult things to make. &gt; Would you consider repository decorators as suggested earlier to be an adequate solution in this case? I guess? not sure what you mean by repository "decorators". Basically I just build my apps so that each class has a single responsibility etc etc. I have a services namespace which deals with communication out to areas elsewhere in the stack (mail, web services, report generators, etc etc), a Repositories namespace which deals with data retrieval, a Commands namespace which deals with actions which can be taken (AcquireCustomer, PurchaseProduct, etc etc)... Other utilities find their way into their own namespaces etc.. I wouldn't suggest using a repository as a dumping ground for ALL your business logic any more than I'd suggest using controllers for the same. Organise the code however it makes sense for your project, and make sure that you have clearly defined responsibilities for each class, grouped up into like-collections of responsibilities for each namespace. 
"Because SRP. Because SRP. Because SRP. Because SRP. " (I literally just listened to that episode of the Laravel Podcast and then I come on and see this. I think you win all the internets here)
Hahaha, so true.
I don't think there's a website size or complexity where you outgrow Laravel. There are some very high traffic sophisticated sites that use it. I think a better way to make the choice is on how worried you or the company are about being tied to a particular framework. With something like Symfony, it's more of a collection of modules and you can choose whether or not to use certain parts. Laravel is more cohesive, everything is designed to work together, but it's often trickier to use parts of it without using the whole thing. When you use Laravel, you're very much creating a Laravel-centric development (which is good and bad depending on your perspective).
It's just a non-issue. It's not like this is a central part of Blade templates. It was just added in the most recent release, and maybe there is some situation that it makes sense. I don't know, whatever, just don't use it if you don't like it.
Ok so i began to make the switch. Now i have a separate question. What would be the best route to call services at the start and end of the application. So for example the startup of the app authenticates user, starts sessions, etc. for the rest of the app and is located here https://github.com/ICJR/esportspCMS/blob/master/application/config/autoload/classes.php But then i need certain services to run just before the script ends. In my case the script is ended in the view helper once display is called https://github.com/ICJR/esportspCMS/blob/master/library/helpers/view.php Currently layout puts together the header, footer, and notifications php needed for the layout. Is there a better way to go about this? 
Exactly.. but it's worth pointing out the dangers. My post at the top of this branch was enumerating the things that you should avoid because they are known to cause problems. The issue is that these *very real risks* associated with these strategies are often glossed over or hand waved by some in the community. Nobody's saying "don't use Laravel because it forces you to use X"... we're saying "If you use Laravel, avoid doing X". As an aside I use Laravel as my primary framework..both for work and side projects. So nobody's hating on anything here... 
&gt; domain driven design type dogma Do we have to call it "dogma"? It's not dogma..anymore than any other mode of work is "dogma". It's a technique which is useful under many circumstances.
Just out of curiosity. What if you where dealing with disjoint-set data structures and you needed to parse a deeply nested DTO? Would you handle that within the view as well? I realize that it's fairly common to pass DTOs into the view; I just don't think my controllers/views will be fun to look at either way. 
First of all let me say thanks for the comprehensive explenation. I wanted to ask if you think symfony shares many of the same flaws or even if you could just share your thoughts about symfony in general?
Depends how you see the complexity. If complexity for you mean a lot of traffic , a lot of DB transactions and a lot of file access then yes program execution speed is not important. But we are talking about programs with complicated logic and calculations. Doing a lot of permutation, combination and then again doing a lot of mathematical operations depending on the result and finally showing simple messages to the business users. And speed matters a lot here.
I definitely agree that it's useful under many circumstances. I think in a lot of ways it's a great innovation and it allows for better code reuse, more adaptable systems, etc. But so many people use it blindly for every project regardless of the scale and requirements of the project. That's when I say it's just a dogma. There is a big trade-off in that really following it thoroughly adds a great deal of complexity and added layers of abstraction that are more difficult to develop, debug, and maintain. As long as developers understand the trade-offs and use it only when it actually makes sense, then great, use it when the complexity of the problem requires it.
Of the many ORM's out there, I would not describe Doctrine2 as pandering to the lowest common denominator in the least. Most of the confusion and rejection of the library that I see comes from a misunderstanding or lack of knowledge in how it works.
WoW , too long
lol, only a Drupal dev would come up with yet another way to deal with HTML in PHP. 
&gt; But so many people use it blindly for every project regardless of the scale and requirements of the project. I don't think this is the case. At least it's not in my experience. Sure it's popular to say things like this right now, especially in the Laravel community, but the premise is based on a very uncharitable view of how people approach projects at best, and at worst is a downright fabrication. &gt; That's when I say it's just a dogma. But it's not dogma... *a principle or set of principles laid down by an authority as incontrovertibly true.* Literally no one is claiming to be an authority or stating that DDD is the "one true way". At all. Even a little bit. It simply isn't happening. 
First off, a Json Api Controller should not be a controller, you should be using response()-&gt;json(Array) for return json responses. As far as using "string-based" rules, I am not sure what you are getting at as using the when-needs-use syntax...that is regulating dependency injection which allows for greater flexability, so I am not sure of the complaint.
Can you provide a link?
&gt; retarded strict typing they are gonna put in php7 what exactly is retarded about it?
They are still working on making it faster. They recently had a performance lockdown and got some good gains in specific applications. FB's problems are somewhat unique - their data centres are so big that saving a handful of cycles on a each request can lead to a substantial reduction in their energy bill.. so as long as they are marginally faster for their own use cases, they'll probably keep it going. Then there is hack.. which they rely upon.. and unless vanilla gets feature parity with hack I doubt they'll shift away from it. One thing that we never really see in the benchmarks is how optimised HHVM is for running FB itself. One has to speculate that they've got some pretty specific optimisations that only matter to their code... perhaps it's significantly faster than vanilla in that circumstance?
Is SRP not a valid argument? Does it not help to produce clean, testable code?
If you use Laravel with Doctrine (and other "enterprisey" stuff) you are building a web-app with Laravel. Your initial claim is that Laravel is for websites not for "web-apps". There is a contradiction that's all.
Architecturally sounds or not Laravel makes me 5 times more productive. I finish my project faster and get paid faster. The neck beard programmers can go and invent the next architecturally sounds framework and looks like Java, I'll be spending time with my kids. 
SRP is a valid argument. But you shouldn't reason about it in a circular fashion. "SRP violations are bad because they violate SRP" is a common mode of argument amongst less experienced devs. Provide a concrete example as to how the violation impacts a particular problem being solved and you are likely to get a meaningful debate. But be prepared for someone to point out how the violation does not impact them. For example, eloquent is a big SRP violation but its violation does not greatly impact *my own* code. I can sufficiently isolate my own objects to minimise the impact. This is a trade off I personally find acceptable for a number of projects. Violated SRP? Sure. Care factor? Often (but not always) very low. 
Which site is that? Could you tell us?
I'm really not sure how I'd begin to answer that question..? 
I wholeheartedly agree with you there.
Really? So [Eloquent](https://github.com/illuminate/database/blob/87da6ace3bd8533de4c1f23224bfe2baa2ebcb63/Eloquent/Model.php), a 3400 line class with ~150 public methods is "extraordinarily simple and yet somehow powerful"?
https://phpunit.de/manual/current/en/code-coverage-analysis.html &gt; It makes use of the PHP_CodeCoverage component, which in turn leverages the code coverage functionality provided by the Xdebug extension for PHP. http://www.xdebug.org/docs/code_coverage
Use the mysql command LOAD DATA INFILE. By FAR the quickest. https://dev.mysql.com/doc/refman/5.1/en/load-data.html
The PHP League has a pretty good [CSV library](http://csv.thephpleague.com/). Maybe it can help.
yes, I have. This command works best when the table and the CSV have the same structure. My second approach would be to * create an import table and import the file, for temporary use. * create a MySQL command to copy the data over to the existing table. Here is my SO question about this exact subject from many years ago: (http://stackoverflow.com/questions/414828/update-mysql-table-with-data-from-another-table) If possible try and do this without bringing the data from MySQL to PHP. That is where it will get very slow. MySQL on it's own is amazingly fast at processing this sort of data. A file with 100k lines will be easy to process.
As a learning exercise I created a class which splits a large CSV into small chunks a while back: https://bitbucket.org/NeilJ247/csv-chunk/src/734f267c5790a18c43f2fb8e9aeae110f101a950?at=master. It uses the split command on linux. Note I haven't worked on it in a while or written any tests for it but from manually testing it worked fine, but use it at your own risk.
How do you, personally, unit test with Eloquent? I've got a couple of Laravel projects on the go at the minute, and it's driving me mad. I can do functional tests just fine, I can do acceptance tests just fine, but anything going anywhere need Eloquent I just can't unit test. PHPUnit's built in mocks have a real hard time of it because of all the magic and using Mockery I always seem to run into blocking trouble. It ends up that I either write a massive accessor to abstract all the statics out, and mock *that* out instead, or spend three times as long frustratedly getting a test cobbled together as I do to write the code. For one project, the previous devs just did everything with functional tests, but that means that to run the test suite takes a full minute. It's very, very tedious. I would usually have core unit tests run on save in about 2-5 seconds, then functional and acceptance on commit, but there are no unit tests! In the other project I was in from the start, I've abstracted out the Eloquent bindings as above and can unit test, but at a huge cost of code bloat and complexity. Eloquent is making me very sad atm, so a real solution would make my day.
You don't have to do manual validation in the function. If your function asks for an integer, it will get an integer every time (no matter whether the caller had strict hints on or not). Think of it this way, if it helps. It actually probably doesn't work this way but it's a useful analogy. If you have strict hints on and you call something that depends on an int, passing a string, this will happen: $input = "1"; functionRequiringInteger($input); // error If you call the same with strict hints off... $input = "1"; functionRequiringInteger((int) $input); The engine will implicitly cast. From "functionRequiringInteger's" perspective, it will always get what it asked for, or you'll get an exception. No ifs, buts or maybes. You can rely on the fact that you will always get an integer (or whatever you ask for). So in both cases you can do away with validating inputs in the function (well, maybe... if you're hinting on an array, you may still want to validate that the structure is correct but there's no getting around that). So no, it doesn't defeat the purpose. strict_types=0 really just means "conform fairly closely to the old juggling semantics"... so you can't do MORE than you used to be able to do... &gt; In this example, with strict type checking OFF the array is type checked but the boolean is not... In both cases, the body of hte function doStuff will be guarantee that data is an array and flag is a boolean, assuming that whatever was passed was castable to these. You can check it out yourself by doing: function doStuff(array $data, bool $flag) { var_dump($data); var_dump($flag); } with strict on and off.. in both cases you should get an array and a bool.
The second approach sounds like a good idea. Then I could update the original table with the data from this temporary table. &gt; If possible try and do this without bringing the data from MySQL to PHP Sorry for a noob question, but since it will have to be done on a daily basis, I will still have to use php for running mysql queries to insert the CSV data and update the original table. Do you think there is a better way or it will still be as fast if I run that from php? 
I am not able to discuss the site. Sorry :/
I was under the impression that you'd still get the type you hinted, just that the engine would automatically coalesce (based on the standard PHP rules) the variable into that type with strict checking not enforced...
Your friend overextend his thoughs. Yes, Symfony is better framework in terms of architecture and correctness. But no, this does not make Laravel bad. I personally think that Symfony is better, but writing in Laravel is order of magnitude faster and its only "a bit less correct" than Symfony, so my choice is obvious. Anyway messing with something like Symfony with all patterns in that shitty language seems like overkill for me.
&gt; _currently_ does not greatly impact my own code FTFY 
There is one happening in Boston in August. http://2015.northeastphp.org/
Is this Vue a viable choice? There is strong competition in this area...
Symfony seems to do a US specific conference once a year. It was in NYC in October last year. I went to it, and it was ok, but was kind of small and only offered one track. To boot, most of the talks given were not Symfony specific, but rather talks given at all the PHP conferences. I think really only the workshops were Symfony specific. Their site says "coming soon" for the US version this year: http://live.symfony.com/ I also went to SunshinePHP in Miami in February, and I highly recommend that. Not Symfony specific at all, but a great conference nonetheless. http://2015.sunshinephp.com/
Thanks, that explains everything. I just tried it on one of our slowest servers and it works really fast. Thanks very much again - this will work perfectly.
Please don't sock-puppet. All of your comments are about this site being "good" - https://en.reddit.com/user/Praveen4india It's almost as if you're connected to it.
Unless the data set within the rows is huge this doesn't seem that large and as your processing this daily (i'll assume nightly out of hours) then it should be simple to produce an importer that you can setup to run via cron. Look into http://php.net/manual/en/function.fgetcsv.php or just use league/csv. 
If there business rules that need to be applied to each row, then you'll need to process each line individually and then insert one by one. These could be rolled up as a transaction so are only committed to the db if all are successful, but that might not be a problem for you.
PHP.net has an [upcoming conferences page](http://www.php.net/conferences/) While some conferences may have more "big name" speakers than others, a lot of the value in conferences is "off track" in the social and networking aspects as well as in the talks themselves. Any conference from that page is almost certainly worth your while. (Don't forget to check with your company to see if they have a "learning expenses" / "training" budget that might cover part of your conference costs!)
Keep searching for that true Scotsman, you'll find him some day.
&gt; You're not actually making any argument other than it being misnamed and using static calls. You are correct; that is in fact the only argument I'm making, and it is only in response to two widely repeated misstatements of fact: (1) that these are somehow not static calls, and (2) that they are somehow "facades." They *are* static calls, and they *are not* facades.
:D
Why would you think that reset tokens should have a many-to-one relation to a user? 
I'll accept it may've been a bad example as I didn't explain the use case in enough detail. I was referring to a controller exposing arbitrary domain service APIs via HTTP + JSON. I use one like this, it's highly reusable (just feed it a different service... done), and more complicated than your example suggests. But **tl;dr**: class name != object usage context You can use two instances of one class in different contexts. Another example: a multi-tenant blogging system, where the same blog engine is used to drive differently configured blogs (different template themes, different blog posts etc.). For this you'll need to be able to inject into controllers based on their context, not based on their classname, or based on the app they're running in (one app = multiple blogs).
I think I don't emphasize that because I don't really think it's that great of an approach to build your typical web application application. Again, that's just my personal opinion.
You have 14 years of experience programming but you can't answer that question. OK. 
More, actually. I'm just not sure how you can "average" projects. I've worked on projects ranging from 3-page wordpress websites handling 100's of hits a year to huge scale backend GIS systems written in C, and a ton of stuff in between.
Awesome. Really, awesome. Nothing something I'd suggest using in production, but an awesome demonstration of dynamic programming. One idea, instead of eval, create a series of anonymous functions with the proper type hints, and set them into an array. That way you have a map for each property and a callback to validate it... But this kind of experimentation is what I love to see from the community. Keep it up!
same reason I prefer PHP over Perl . I've played with Perl a little bit; but not much. It looks like tourettes syndrome and I'd rather not mess with it
I didn't post the original comment, that was /u/pan069.
Personally, I went the direction of using a test database and I let Eloquent create records in it. I could try to mock out the database interactions, but so many of the issues I want to test for are things that would only show up if I'm actually accessing an actual database. But I also don't use test driven development, so I don't need my unit tests to run exceptionally fast (I think TDD is usually a bad way to design software because of the same sort of reasons that [DHH argues](https://www.youtube.com/watch?v=JoTB2mcjU7w), but that's a separate debate). So someone else who does more of that type of fast unit test development might have a better answer for you (maybe post in /r/laravel or StackExchange?). 
We (I am an owner/organizer) have a symfony track at php[world], this November: https://world.phparch.com/schedule/
My experience of this coming from Rails is that the tooling around testing using fixtures and factories in Laravel is lacking to say the least. It makes for a noticable seam between where the tested framework (Eloquent in this case) ends and my application begins. In terms of TDD it's not always the goal, but being notified of regressions or breaking changes can be useful when they happen, and not later on when I remember to run the tests.
&gt; They care much more about the practices a framework encourages when you throw 15 or 20 devs of various experience levels at it than shiny new features (especially ones where we'll probably already have existing or preferred internal implementations). A team that large should have a tech lead who is responsible for establishing standards and best practices - no framework, or tool, can guarantee a consistent "appropriate" usage. Also, I wouldn't exactly consider Symfony's ***outright abuse*** of annotations "best practice".
I'd imagine there's an implicit "nor is it likely to in the reasonably near future".
&gt; how the hell do you test your template then? Let's think about this.... Here's how you use it: http://laravel.com/docs/5.1/blade#service-injection &gt; The first argument passed to @inject is the name of the variable the service will be placed into Knowing that, it means we can hydrate the view with the same variable name that's declared in '@inject', from the controller, to inject the data like normal. So the next question is, how do we disable the '@inject' behavior so it doesn't override the variable we're passing in? This depends on what you mean by "template". Do you *actually* mean "View"? If so, test the view like normal. Otherwise you have to compile the template, which means you need to use the BladeCompiler, which means now more of the framework is involved in the unit test. Since the framework is involved, you can replace the BladeCompiler with your own compiler since it adheres to an interface: https://github.com/laravel/framework/blob/5.1/src/Illuminate/View/Compilers/BladeCompiler.php 1. Extend the BladeCompiler 2. override the `compileInject()` method to return or echo anything 3. Bind your modified compiler into the IoC in the Test Suite's setup 4. Use `View::make('....', $data)` to return the compiled and executed template with the data you wanted to inject. 5. Done. Of course, you could just go ahead and construct the view manually or invoke the compiler directly. Up to you. Either way, it's easy as hell to unit test templates even if there is `@inject` in there.
There's no such thing as a perfect web architecture, so that's a bit of an unfair standard.
/r/africa
Laravel provides a way to have requests that validate incoming data - all you have to do is create the request class and typehint it as a parameter for the controller method and it will validate it. For example, here's ImportMemberRequest source code: https://gist.github.com/thepsion5/f35d09ed9b5c8393671a It will check the submitted form/query string data against the defined rules and automatically redirect back with an error message. EDIT: [More on Laravel's Validation component and validating via request classes](http://laravel.com/docs/5.1/validation#form-request-validation)
As mentioned by others, LOAD DATA INFILE in a tmp table and then "insert into ... select from tmpTable" with some conditions you need.
I'll never understand why someone would release a library with 0 documentation. Especially when they go as far as making a website for it... Where are the docs? How do we use this library? WHY would we want to use it over X? How about some examples of how to do it in xPDO vs X?
FYI, The SDK follows FIG Standards. Requires at least PHP5.5 and uses the GuzzlePHP.
Ah. I didn't realize this was a Laravel feature. Thanks!
It really depends how you design your domain services, which is the "UI-independent PHP code" component in your ASCII diagram up there. I prefer to expose the same exact service both to PHP controllers and JS controllers. If some piece of information is hidden from a JS controller, I've not found a reason a PHP controller would need it. If you think there are such examples, let me know and I'll tell you how I do it (or maybe you can teach me about a flaw in my approach, who knows). But in a nutshell, I think it's very doable to do this (and this is what I do): [UI-independent PHP code] &lt;----------------&gt; [UI-supporting PHP code] [UI-independent PHP code] &lt;----------------&gt; [UI-supporting JS code]
i have to agree here, the README on the github only shows how to create the xPDO object, the website doesnt have a documentation at all. At least adding more examples to the README is absolutely necessary, looking at the tests setup and configuration already is complicated, also the XML file schema needs documentation. The tests are not self-explanatory themselves.
You'd probably start by listing off the common functionality that you believe qualifies the project as being between simple and enterprise. Surely there are some commonalities that can be identified, otherwise it wouldn't be possible to make the original comment. I was/am genuinely curious what would be on that list. 
yes
Explain exactly how static calls in this context cause any problem. And not everything has to follow a design pattern. 
pretty much this.
3 mobile apps, 2 server architecture projects, 30+ production websites (laravel, wordpress, drupal, flask, go), 7 RESTful APIs (laravel, flask, scala, go), 10+ small games (c, python, scala). That's just what I can list off the top of my head. Edit: Changed 1 mobile app to 3 (i built 2 POC apps for clients, and 1 that I have on the market)
&gt; Explain exactly how static calls in this context cause any problem. I don't say that they do or do not cause problems. I say that they *are in fact* static calls; stating otherwise is counter-factual. &gt; And not everything has to follow a design pattern. And if you're going choose the name of a design pattern for something, it should *follow* that design pattern. 
Looks pretty cool. I was actually wondering about looking into creating a bot when they announced it with Telegram 3, this looks like it'll make life a lot easier. A few generic ideas I have for bots: * Daily weather forecast (hometown, work) * Traffic report for my route * Random weekly fact * Movies coming out this month * Link to Wiki article for a term 
Please don't use this library. Not only, as others have said, does it lack any sort of documentation. It is also poorly written in my opinion. It's using paradigms from php from 4.x era and doesn't seem to understand that objects are pass by reference. Then mix it with methods with really large cyclomatic complexities like [this](https://github.com/modxcms/xpdo/blob/develop/src/xPDO/xPDO.php#L841). The methodology of the bootstrap file seems unnecessary since the only way you could get to this state was if you downloaded the library by hand in which case you've defeated the purpose of using composer to begin with. There are lots of weird things in the code like [this](https://github.com/modxcms/xpdo/blob/develop/src/xPDO/xPDO.php#L218) which make no sense. Other than to save typing why copy a static collection locally? More over why use a static at all? Why not use a session manager like class? It's not like PHP scripts typically run for any extended period of time it's not going to be preserved across requests so you're not saving anything. The only things that are cross request persistent are the actual PDO connections and they're managed at the FPM/CGI layer. I'm sorry, I understand what the library is attempting to achieve but it really has a lot of tell tell signs of someone who came from a C++/C background and doesn't understand how the language works nor have they kept up with the best practices.
Can't you do the same thing by only using the parts of frameworks that you want? laravel: https://packagist.org/packages/illuminate/ symfony: https://packagist.org/packages/symfony/ 
Better order of operation, remove from the main table items NOT in your CSV, update ones that exist and insert new ones?? Isn't that the same as clearing the table prior to upload?? 
Pretty much the same - when I found out what $_GET and $_POST do. Being able to take user input from the browser and then doing something with it blew my mind. The second mind blowing experience was when I saved and retrieved shit from a database for the first time. Closest I'll ever get to feeling like a wizard.
Yep, It will. Sounds good about those ideas, they look interesting! Some more bot ideas: * Monitor web apps/sites and notify me/user when they go down, Good for webmasters ofc! * Send top reddit posts summary or Maybe subscribe to some subreddit like /r/gifs and send top gifs once a day/picture, could also be a viral video (Since the bot feature supports sending videos too, Either download and send or just send the YT link..whatever). * Daily Horoscope (Ofc as per your sign) * Daily Jokes * Funny Memes * Latest/Hot News of the day * Social Media Account Poster (Like if you send a message, It would post to fb, twitter, etc. or upload image including on Instagram), So it's like one place for all. * Trending Topic of the day * Some bot for IoT (Maybe to make home smart using Telegram, Since its like your own app). I've asked Telegram Bot Support to put up their service on IFTTT, that would open up more ways to easily connect things and automate more stuff :) 
Mh, can't really remember when i had my breakthrough moment. Must've been about 10 or 11 years ago wen i was deep into multiplayergaming and turned out to also be the tech guy for the clan i was part of. First time i was "it doesn't look too bad" with something i wrote was in 2008 when i released something to the public for the first time ever. I'm still not writing nice codes but i get it done to make the stuff i want to do happen :) (does it make sense? donno... 4 in the morning sleepless because its so hot) 
I will become this wizard. Then I will make good money!
Was it one of those moments for you that felt life changing?
One mindblowing memory I have is when I was hired by my college to take over an inventory application that some previous guy started. I barely knew PHP as I had only taken a single class (my focus was on .NET). I was always taught that processing a form took two pages: an HTML page that contained the form, and the PHP script that the form submitted to to process it. Upon looking at this guy's code I discovered that you could actually process a form on the same fucking page as the form with a simple if(isset()) statement. I didn't even know what isset() was, but I have since recognized its power. My other notable "breakthrough" was when I bought my first official hosting and domain and put up a website (that wasn't Geocities or Angelfire). Ah, memories...
And 100% Magento compatibility (damn near it, since everything else besides the following feature works in my experience) is incomming in HHVM 2.8 or 2.9 :) After lots and lots of petitioning, we finally convinced a developer to take on the missing feature which was keeping most Magento installations from working property because if you chose to use a secure method of sending e-mails, which required encryption, any feature in Magento that involed sending e-mails simply did not work, meaning you won't be sending customers any order confirmations or tracking numbers to their e-mails, customer's won't be using your contact form to contact you, and etc; because it would try to send the e-mail and error out. 
Your README is very well laid out, but a bit verbose. Consider moving some of it to another directory, like 'docs', with some usage examples.
Thanks! Yep, I noticed that as well. I have that on my roadmap. Probably when i push another major feature, I'll break down the README and separate it into docs and various other sections as well as setup a site/docs page. Thanks for the suggestion, I appreciate it. 
No problem :) And yes, Telegram is packed with some awesome features and much better + dev friendly. Just that, They don't market their product like their competitors, due to which a lot of people still have no idea about it. Hopefully some day it'll reach out to all and people adapt more. It's still huge though.
I have plenty of experience (if it matters and we're counting, I'm at 10 years professionally engineering software). Some of the jobs I've had meant pumping out projects for clients (of varying size), others meant working long term enhancements of a single product. Of course the more projects you complete the harder it is to answer the question of what an "average" project is, but when you narrow the scope to "between a simple website and enterprise application", you should be able to identify patterns of business requirements that fit that mold. An application isn't it's technology stack or what sort of architecture it has, it's about the problems it solves. A "mobile app" is not a requirement - it's the environment in which the application runs. A requirement is *what the application actually does* and (should) dictate things such as platform, architecture and technology stack. 
For me it was when I discovered design patterns (especially dependency injection!). Finally no more code-mash and I can code like a professional!
&gt; Heh; I had originally suggested "surrogate" as a synonym of "proxy", and sent a completely backwards-compatible PR for it, but even just "proxy" would be fine. That's what it is, after all. Until someone writes a book that has a Surrogate Design Pattern
It kinda is, but the problem is that there is going to be a 5k+ rows that come directly from the website. So I cannot just clear the table and insert. 
 &gt; What are your thoughts on injecting a Service Locator in your Controllers? NO. &gt; I've read the arguments that you usually not want to unit tests controllers, but instead use acceptance tests or functional tests for that. You want unit tests for anything testable anyway. Injecting something unmockable is not an excuse to stop testing your code. &gt; And just make sure all libraries used are unit tested. all.the.code. &gt; What are your thoughts? NO &gt; Service Locator in Controller fine or not? NO NO NO
no :3 why would you want this anyway, might as well use $globals
In my opinion, the background service approach will create more problems than it solves. You can use something like Redis to fast store/update/retrieve the stats you need and avoid hitting the database. If you really want to keep the stats in the database, you can have a cache layer in front of the DB and use INSERT DELAYED to persist the data. Keep in mind that when updating records, INSERT DELAYED is ignored.
I have not dived into redis or any of the alternatives yet ( relatively new to php ) so i apologize if this is a stupid question. Would this require me to replace the pdo db interaction layer that i am using, or is this another layer that sits on top of it. With redis does it just store the information it is given? ( quickly read the redit website ) so i would still have to read from db to count all of the stats required ( some stats like users are multiple rows that are counted ) then store it using redis? I am going to look into it further since i see it everywhere ( books, tutorials, etc. ) 
Do you realize you're just repeating "[NO NO NO](https://www.youtube.com/watch?v=8IXCK1EyP4s)" without explaining why? Let's have a more substantial debate than just barking orders at each other. &gt; [unit test] all.the.code. I totally believe you unit test all your code, so considering in the front-end &gt;95% of the code is HTML, CSS, JS and &lt;5% is PHP controllers, I'd be curious if you can share how you manage to unit test "all the code".
Would you be able to explain what is the difference between container and a global container? For example, in silex, is injecting $app means that it's injecting a global container? 
By the way, isn't Hack still faster than even PHP 7?
Spent a Lot of time in php and very reluctant to go to asp and mssql because of cost, less flexibility and, more learning curve. I run c on my linux server for math-intensive processes. I already got gearman down for a light distributed system. Why should I bleed to switch?
&gt; The "unit" of controllers + templates is the UI. And because UI is intended for humans, the best way to test it is via.. humans. Detecting changes in HTML output doesn't mean the UI is broken. Only a human can assess if it is. So there's no way around it, and yes, I wouldn't say unit testing UI makes sense in most cases. wait.. what? there are plenty of tools to test representational layers and client side stuff such as html and javascript, saying the best way to--and the only way to assess if its broken by, a human..? would mean in my case i would be manually testing for atleast an hour a day if everything is functioning correctly and possibly kill the remaining joy i still have in todays webdevelopment. hello, 2015.. also, **no** reason to not test controllers, do it manually if you prefer. whats the point of just unit tests if there is something wrong in your controller. &gt; That aside, even if you prefer to unit test your controllers, a Service Locator, as typically implemented, is highly configurable at runtime, so you can easily replace services with mocks. this is why you inject dependencies, and not containers or service locators.. &gt; The problem comes from elsewhere: who is this locator for? If it's for the entire app, you risk coupling your controllers to global dependencies (and their global names) in a way that gets hard to unmesh and control over time. why would it not be for the entire app? and you dont risk it, you just did it by injecting the SL **tl;dr** never, inject a service container.
I am thinking I prefer programming over designing. I only have so much of an eye for design... enough to get by.
I remember throwing up my first non wordpress site. That was a great moment in my life.
&gt; The "unit" of controllers + templates is the UI. No it's not. The controller does stuff. The template (or view) shows stuff. They are completely separate concerns and should be testable separately. The fact that most current PHP frameworks make this really hard to do is a problem with the frameworks that isn't going to go away just because people don't like admitting they're not unit testing their code.
xPDO documentation here http://rtfm.modx.com/xpdo/2.x/ There is a link to the documentation at the bottom of the xPDO site page.
&gt; wait.. what? there are plenty of tools to test representational layers and client side stuff such as html and javascript, saying the best way to--and the only way to assess if its broken by, a human..? would mean in my case i would be manually testing for atleast an hour a day if everything is functioning correctly and possibly kill the remaining joy i still have in todays webdevelopment. hello, 2015.. There are tools, like Selenium (which I use sometimes), but their functionality is limited to recording human activity (or accepting commands that simulate it), and then repeating it to see if it looks the same in a purely mechanical way (say "is that DOM element where it was last time"). Such tools are most useful as a quick *substitute* for unit testing, when you want to see if refactoring logic on the server side broke your client. If you unit test your services, which is far more useful over the long term, testing your UI "works 100% the same" is... quite a lot less useful. No tool copes well with UI that has refactored HTML DOM and interactions, even if the resulting difference may seem superficial or invisible to a human (say moving from tables &amp; div tags to semantical HTML5 tags). Feel welcome to share any borderline-AI tools you know of. Google will be quite interested, they spend inordinate amount of resources building bots that try to see web sites the way humans do (and while they're the best out there, they're still not that good at it). &gt; also, no reason to not test controllers, do it manually if you prefer. whats the point of just unit tests if there is something wrong in your controller. The desire to test a controller typically communicates you have more domain-level business logic in your controller than is warranted. - Do you validate input in your controllers? - Are controllers the authoritative source for whether an action is allowed for a user or not (permissions, authorization)? - Do you operate with repository-level ORM in your controllers? - Do you even make raw SQL queries in your controllers? If you answer yes to any of the above, I don't judge, it works for small apps, but then your controllers are not simply controllers anymore. They are controllers with dispersed domain-level business logic in them, so the need to test them comes from there. And the solution is to isolate your client &amp; UI logic from your domain logic, until the only thing a controller does is map UI-level concerns to domain-level concerns. And nothing more. &gt; tl;dr never, inject a service container. You know that's a very poor tl;dr for your comment, given you said nothing substantial to support that statement. 
xPDO has been around for a while, but it's been predominantly used within the MODX CMS and that's also where the documentation has historically been hosted and updated: http://rtfm.modx.com/xpdo/2.x/ This is a new website for xPDO now that it's becoming easier to use standalone thanks to the upcoming v3 and composer. 
Probably but on the other hand hack isn't PHP and HHVMs PHP interpreter could, in theory, deside to not follow PHPs featureline or completely drop support for it in future. AFAIK HHVM is only 100% PHP 5.3 feature compilant (please correct me). So i'd say you either switch to HHVM and learning hack or stick to PHP with 7 in mind on the long way. Edit: Seems HHVM has 5.6 support. Still they can drop PHP in favor of hack anytime. 
&gt; The controller does stuff. The template (or view) shows stuff. Wow. You sound like you really know what you're talking about. I better listen. So what do models and services do? Do they also "do stuff"? Well controllers already do stuff, so I better stuff all my stuff in the controllers then?
My proudest day in PHP was when I got my first job in it at the age of 21. A local solar retailer needed a developer to work on their website and ecommerce solution, so they interviewed for PHP developers. Out of dozens of applicants, I was apparently the *only* one that actually brought a laptop and **demonstrated** that I knew PHP. They said all the other applicants had college degrees in technology and listed PHP as a language they "knew," but it turns out not a single one of them "knew" it any more than briefly going over its syntax in school along with a dozen other languages. I was proud that having been self-taught with no degree and having only ever used PHP at a hobbyist level, I beat out dozens of college graduates. My first week there, to familiarize myself with their systems, I wrote an application that effectively produced a domestic sales report. It produced a table with states as columns, and months as rows. Inside each cell was a number and a dollar amount. The number was how many orders were placed in that state in that month, and the dollar amount was the average total of those orders. It gave them valuable insight into what best to market in what areas - for example, before they had only really guessed that in New York, fewer people bought solar hot water systems, but more bought things like solar fountain pumps and solar lights. So the number of orders was higher, but the average order total was lower. While in California, the opposite was true. Lots of people bought the solar hot water collectors, so there were typically fewer orders, but the average total was much higher. By the end of my first month, I had gutted and replaced the majority of their inventory management and order fulfillment processes, liquidating two positions and thus paying for myself twice over with just a couple weeks worth of work. I really miss solving problems all day every day. It was mentally exhausting, but it was some of the most rewarding work I've ever done.
I'm the same. But http://getbootstrap.com or http://getuikit.com will help you would with design ;)
I pretty much felt the same way when I was introduced to BASIC (the one that came with DOS 3) in 1989. A neighbor showed me how to take input and compare it to something. So the first thing I ever made was a password prompt to deny my dad access to out shared computer. I felt like I just got a superpower. Some advice: Play around, do stuff that is fun for you and **definately** get a decent book (actually, many of them) like Modern PHP by Josh Lockhart. Also, try not to confine yourself within one language. Checking out other languages will teach you new valuable concepts and open new possibilities. E.g. if you learn Java you'll learn lots about object oriented programming that helps you in PHP but also enables you to write Android apps.
&gt; There are tools, like Selenium (which I use sometimes), but their functionality is limited to recording human activity (or accepting commands that simulate it), and then repeating it to see if it looks the same in a purely mechanical way (say "is that DOM element where it was last time"). your view on the subject seems very strange to me, but i(and basically any acceptance testing suite out there) can be wrong. but what more do you need to know that a story within a app works from a to z. this is what you test, thousands of companies do it, we save several hours a day by automating it. you say, dont do it, you cant, this is for humans. ok?.. i guess &gt; Such tools are most useful as a quick substitute for unit testing, when you want to see if refactoring logic on the server side broke your client. If you unit test your services, which is far more useful over the long term, testing your UI "works 100% the same" is... quite a lot less useful. there is a very large chance that the functional frontend/client side code can break for a google'nth reason that has nothing to do with the server side logic. unit testing services guarentees nothing in the front end. client side can go beyond rendering views 
&gt; Feel free to be a idiot - please don't expect people to discuss things with you. I expect nothing, you chose to reply to me, genius.
&gt; but what more do you need to know that a story within a app works from a to z. this is what you test, thousands of companies do it, we save several hours a day by automating it. You can't tell a computer "test this story". A computer can record a set of events and repeat them verbatim, producing very brittle tests that break on almost any UI change, even if it doesn't change the story. Any automated tests I run on the template output side typically test machine-to-machine interfaces (not visible to humans while browsing) that happen to be expressed in HTML, like - presence of micro-formats, - Facebook's OG tags (and similar), - crawling for broken links. Those are testing non-UI aspects that happen to be in the UI later, and not "a to z stories". I'm willing to believe QA people are some sort of a scam that's not really needed, so tell me. How do you and thousands of companies **automating** the test of a story "from a to z"? Care to be specific? 
It's all the more funny because his flair says "ZF2 team" and zend framework 2 does inject the ServiceLocator in the controller...
OK, so functional testing. It works, but it's not fast enough for TDD in this case. Personally, I'm on the fence about TDD. Mostly I spike, then test, but if I've a particularly complex logic issue or an information web I find it hard to hold in my head, it's TDD FTW. In those cases, a unit test suite is best-by-far. Having to create a way to do it when I really, really need it is a very painful distraction!
I previously posted this in /r/javascript but thought it was relevant here too.
The problem is that it allows for very "quick 'n dirty" coding that remains sticky afterwards.
Just to add one more to the list, we hold [Lone Star PHP](http://lonestarphp.com) here in Dallas, Texas each year in April. Our next conference will be coming in April of 2016, the 7th through 9th.
Not only, as others have missed the tell tell signs, does it have documentation. Its author can write complete sentences, too! It was written in 2006, and originally included a PDO emulator for PHP 4. Yes there is "cyclomatic" complexity that needs refactoring—but the code works and is quite efficient. The bootstrap file is copied from Composer. Why copy a static collection locally? Because you can't do late static binding in older versions of PHP supported by the library and the MODX CMS written on top of the library. I don't think you took the time to understand what that code is used for. BTW, I've never written a line of C++/C in my life, and I contribute to cutting edge PHP projects that adhere closely to the latest PHP standards and best practices. In summary, please don't listen to this troll. Not only, as I have pointed out, is he way off base. Tell tell signs I tell you!
So if a class would express a "locator" via an interface where methods have a return type, does that resolve this problem in your opinion (hint, hint, PHP7)?
This goes into more (excessive) PHP-specific details: https://www.reddit.com/r/PHP/comments/3b36k1/seperate_classes_per_each_action_and_getting_rid/csj7npo Many bigger projects implement aspects of this, but every in their own way, I can't think of a suitable example, sorry. Still, yesterday, I got linked to this: https://github.com/rtroncoso/Laravel-Context It's a specific add-on for Laravel, but achieves similar modularity despite Laravel is not modular by default. If it weren't for Laravel, you can do achieve modularity without libraries though (more like the first link here explains).
The difference here is if you want to process it FAST - like more than one row at a time, LOAD DATA INFILE is a solid route. Depending on _how_ the data has to be processed is another part of the puzzle here. I am highly familiar with the Migrate framework but even it could not handle what I needed to do (parse 90k rows to 500k mappings in less than 5 minutes). I WAS able to do that after taking the CSV parsing load off of PHP and just getting it into a MySQL table: https://gist.github.com/kevinquillen/45fb33206559449e9cb2
Motivation is weird with programming. It comes and goes in strange ways.
I think it's just fine. I'm never going to bother injecting the session, templating engine, URL generator, form factory etc. into every single controller I write. I don't think controllers are worth unit testing. The only interface they implement is the one of turning a request into a response. I'm more than happy having global state in my templates (generating URLs for routes and assets, partial template rendering etc.), and I feel controllers fall under the same category. As long as they are kept logic-free, I'd much rather cover them with acceptance tests than unit tests. In a perfect SOLID OOP world you won't be doing it, but I'm far more a fan of getting things done. There are a lot of worse code smells you should worry about.
That *could* work, but that's not a locator anymore, but rather a factory.
&gt; I'm asking what do you think the solution is. Strict constructor (and constructor-only) dependency injection.
Yeah. Well, every time I show it to someone and tell them "so it's like a factory" and they tell me "it's a service locator", so I've completely given up arguing about terminology at this point. I just wanted to demonstrate how parameters and "container interfaces" can be isomorphic in terms of combining dependency type with another differentiator (position for parameters, and method name for interfaces). It also provides for lazy fetching of dependencies, which becomes necessary in larger projects (say passing a dozen dependencies in a larger CMS module to be injected more traditionally as parameters in internal classes as need be). We still need some sort of containers at some level, so before Zend ditches theirs (injected in controllers), it's good to think about this, and also about the *context* of dependencies (i.e. dependency "foo" for one group of controllers needn't be the same as dependency "foo" for another group).
&gt; What are your thoughts on injecting a Service Locator in your Controllers? What makes you ask the question? If the reason is "because my controller has a lot of disparate dependencies and it's inconvenient to inject them individually" then your controller is doing too much. In that case, consider breaking the actions out to their own classes, a la [Action-Domain-Responder](http://pmjones.io/adr). Then you can inject the dependencies individually for that specific action.
&gt; It also provides for lazy fetching of dependencies, which becomes necessary in larger projects (say passing a dozen dependencies in a larger CMS module to be injected more traditionally as parameters in internal classes as need be). Not really. I've developed components for lazy-loading dependencies, so that you can avoid passing factories/locators down to your dependencies. &gt; We still need some sort of containers at some level Agree, but they are used only in very initial portions of the app that are actually doing proper service location (routers, anybody?).
Yes, it's proxies. TBH, I got rid of the constant runtime overhead, but I didn't yet rewrite the consumers of the proxy generator.
A wild pmjones appears.
I had to do a quick search as I remember hearing something about this back when I was first looking at Laravel, and it happens to be a quote from yours truly. &gt; Laravel [is] also more opinionated out of the box. [link to comment](https://www.reddit.com/r/PHP/comments/1bdln1/symfony2_vs_laravel/)
That was 2 years ago. Things change.
Not sure what you're doing there, too much to go through. But I know it can't be done transparently without C.
I was not ready for this. Really cool! Nice work!
&gt; A controller is supposed to control the flow and data through the application by orchestrating the services, so it needs the service locator imho A controller is supposed to be a bridge between your application's core layer (the domain) and the HTTP layer. It translates incoming requests to some domain service and translates the result to a HTTP response. It should only be making logic decisions that relate specifically to that.
&gt; how the human "perceives" it is totally irrelevant, it works, or it doesnt work. The problem is due to that silly stupid gap of perception, "doesn't work" and "works" don't actually coincide between human and machine a lot of time. If they did, most of the time, you'd be golden. What I'm trying to say is, in a nutshell, this approach gives you a lot of false negatives and false positives. - Lots of false negatives means: you need to send the product to QA never mind if it passes the tests or not. - Lots of false positives means: you will be acting upon plenty of fake red signals you wouldn't be acting upon if those tests didn't exist. You'd also be spending time fixing false red signals to make them green again. The first item means tests help with nothing as they don't change your behavior. The second item means *you become QA* because you now have to spend time *manually testing* your software when you get a red signal, to make sure it's a true positive. In other words, it'd be like someone in QA flooded you non-stop with fake bug reports. Semantics, semantics.
You don't need to *insert* them one by one, just process the business rules. You can save up 10-20 rows to insert in one query which would be more efficient.
Using 'ON DUPLICATE KEY UPDATE' on your insert query is faster.
But you said if they are not in the CSV they're gonna be deleted...?
/me nods And my googling around for it has not revealed anything either. As such, I have to stand by my claim that if a factory retains a created instance for reuse, it's no longer a factory, it's a container. I will of course submit to authoritative opinion if it can be found in future.
Magento's admin grid system is incredibly powerful. Have you seen the Enhanced Admin Grids extension?
Yes, but these rows which comes from CSV will have "source" field with the "CSV" value set. All other rows will have source as "website" for example. So those fields with "website" source cannot be deleted.
Will you donate it all?
This is exactly the kind of information I've been trying to find for like 5 years, now. Can you mock up like a quick request to response including how the various classes are instantiated? Or can I call you or meet with you on Skype? Or see your presentation?
Some of the comments in your /r/javascript thread very accurately portray my opinion on full-stack javascript: &gt; Just because you can doesn't mean you should &gt; I don't want to live on this planet anymore. &gt; oh man, why? &gt; Dear god, why would you do that to yourself? &gt; Barfs violently Why did you post it there? It feels like trolling them. 
Because the idea is to work with JavaScript rather than replace it, as demonstrated by the use of jQuery in this demo.
I can't wait to see the first application using Node.js for the server and php uniter-jquery for client. Next is a db in pure css, and sql for stylesheets (I wont be surprised if that one already exists). 
Neat demo, no question, but you're not demonstrating full-stack PHP, because PHP is not just the syntax of PHP. It's a PHP stack + PHP dialect of JavaScript demo, at which point, I'd rather be writing JS (or using a mature type layer on top of it, like TypeScript).
Or in the cloud! Don't forget the cloud! Excel 365 cells containers with vb macro glue is the future man! Ok, I think it's time I go back to finish my prolog 3d game engine.
Alternatively, can you link to the sources, or describe the thought process, that led you to believe that it's within the definition of "factory" for it to retain its created instances for reuse? (I know you had to come by that understanding somehow, and it might be educational for me to learn how you got there.)
Meh. I want full stack VHDL. I'd settle for Verilog.
I think this is a neat idea. I'd be interested in seeing a short list of re-usable widgets. 
The service/model parts should somehow provide *access* to results (not just successful ones, but also exceptions/warnings) and it is entirely the Controller's job to notice and react to them, doing whatever is appropriate for the particular workflow/UI that the Controller is supporting. Here's a very simplistic example: class MyController { function someAction(){ try{ $result = $this-&gt;service-&gt;someTask(); }catch(TaskException $e){ $this-&gt;makeErrorRedirect($e-&gt;getMessage()); } foreach($result-&gt;getWarnings() as $warning){ $this-&gt;addFlashMessage($warning-&gt;getText()); } $this-&gt;renderSuccessThingy($result-&gt;getData()); } } The key I'd like to highlight here is that the service doesn't know *anything* about "flash messages", it just knows it has to provide easy access to a warning-string. That string might get internationalized, it might get shown in a webpage, it might get shown on a command-line, it might even turn into pixels in a JPEG, whatever. You may also be interested in the CQRS-style, where successful activities can cause a cloud of events, and different controllers may be interested in different sets of events.
Finally I won't have to write my websites in assembly!
And how you feel about it though?
It's a bunch of hogwash. PHP is a fine language. You can write shit code in any language. The PHP community has really embraced best practices and design patterns over the past few years, and it's definitely helping PHP get a better rep and making it a better language to work in.
&gt; The PHP community has really embraced best practices and design patterns over the past few years .. Though, in my opinion, it feels like a hard swing the other way. Too much focus on patterns and best practices to the point of over engineering. Although I'd rather be on this side of the curve than the other.
Thanks! The plan is to continue implementing most PHP standard library functions, so it won't just be a PHP dialect of JS - but it opens up the possibility (as demoed) of talking between PHP and JS. For example, pulling in some PHP libraries as dependencies with Composer and some others with NPM and wiring it all up as a PHP app. Thanks again for the feedback!
I'd actually especially test stuff like that: very dangerous to leave it pending, and most likely a source of bugs. The infrastructure adapter has just lower priority than the core domain, but that doesn't mean it will be ignored: it will be ignored if somebody puts haste/budget issues into play.
&gt; all.the.code. I disagree and will leave this here: [Testing like the TSA](https://signalvnoise.com/posts/3159-testing-like-the-tsa)
Many factory methods tend to do that, actually (since they know about whether it is safe to use a singleton or not). For example, [Optional](https://github.com/Ocramius/ocramius.util.Optional/blob/32cd741ebf9e6edcd63fe35dd7965c9014ec2687/src/ocramius/util/Optional.php#L84-L87) does that.
heres a related [comic](http://qph.is.quoracdn.net/main-qimg-fc91cdf23051fab5c8d97955485e6f6e?convert_to_webp=true) that addresses your concern
This is what bothers me, PHP is good in so many ways but the haters focus on just a few consequential aspects of it. It's like hating on America Online not realizing that thanks to them they got internet access in the first place
A *factory method* inside a container is not quite the same thing as a *factory object*. This kind of supports my point about containers creating *and retaining* objects.
People who are bashing PHP either do not know how to implement it correctly, or are using it for the wrong things. They are just professing their ignorance.
I bash PHP all the time when in the company of my fellow PHP developers, but I'm disgusted whenever PHP is brought up on /r/programming and the same ignorant circlejerk ensues. I'm vocally negative about most stuff I deal with, but I make it my point to know what I'm bitching about. These haters tend to cling to the same minor issues (such as inconsistently named functions) and quite often go out of their ways to find things which are wrong with PHP (such as "sometext".1 confusing the parser in some older version). It's rarely that I see PHP bashed for something that actually annoys me during my 9-to-5 job. And even when they do have a point they're missing the fact that you can find similar flaws in every language. 
Thanks!
Factory method disagrees and returns itself as a counter-response.
I stopped reading stuff written by DHH, it's toxic. [EDIT] I actually read it and had a good laugh, thanks :-D [EDIT2] Then I cried, thinking about the juniors that still read his stuff.
Most of my controllers don't have anything worth testing. Almost seems like proponents of unit testing/DI have some rather fat controllers. Which is a far bigger problem than using service locators in a slim controller. public function indexAction($p, $limit = 10) { $rows = $this-&gt;get('SomeService')-&gt;doSomething($p, $limit); return $this-&gt;render('some_template.twig', [ 'rows' =&gt; $rows, ]); } Unit testing slim controllers like these is beyond pointless and fat controllers shouldn't be tested but rather refactored. 
Take that, Node!
&gt; So seeing someone mimicing Java enterprise design in PHP makes me laugh. In other words, because PHP is a dynamically typed language, developers shouldn't use enterprise ideas and methodology? Then I suppose we shouldn't follow SOLID or unit testing either? Happy to have fed you, *troll*.
This doesn't seem to cover the why. I don't need to have the entire stack in one language. Besides, I JUST started to tolerate coffeescript. 
when i made 3k in 1 month with adsense with my first sites learning php. like u, super motivated. 10years later a much better prpgrammer, but not even close to making that money
You can still do all the inserts in a transaction, just do them in batches.
Facebook, Yahoo and Wikipedia amongst others. They are the number 2, 5 and 7 ranked websites in the world. Twitter started in ruby but had to rewrite in Java cause it couldn't handle the load. 
&gt; One day I will make a car sales site. Nice goal! I've been working in the Automotive Sales Industry for 13 years now making websites and inventory systems, I'm surprised at how much I still enjoy it.
No, that is not true. Laravel injects the exact dependencies a controller needs since the controller itself is resolved through the container. This means the controller doesn't need to have a service locator or any knowledge of anything other than what is injected into it.
"Correctness" is important to enumerate. Code should be these four things: 1. Change-insulated (changing one thing doesn't cause an avalanche of bugs in unrelated areas) 2. Change-friendly (opposite of #1 - making a change shouldn't require duplicated effort all over the place) 3. Readable (can I look at my code or someone else's code 3 months later and understand it completely?) 4. Testable (you need to be able to PROVE your code works) As long as your code is those things, then it doesn't matter how you get there.
Pretty cool idea. But even being a massive fan of PHP - if I had to go "full stack" (which is never a problem for me anyway) it's always going to be Node.js for obvious reasons. 
Of course, it's your implementation, so it's you that's responding. ;-) But again, if you can link to articles or literature on "factory method" that include retaining the created object for further use, that will help to support your case on "factory method." It may or may not support your case regarding containers and "factory objects." EDIT: Referring to GOF "Factory Method", on p 108, "We call CreateDocument a **factory method** because it's responsible for 'manufacturing' an object." On pp 112-113, we see a Creator::GetProduct() method that retains an instance, but only as a result of the CreateProduct() method call; CreateProduct() itself appears to be the factory method, not GetProduct(). Further, the Creator class does not itself appear to be a factory object. This section appears to be the strongest case in favor of your interpretation, but it's not clear to me that's the intent of the example. AbstractFactory on p 87 makes no reference to retaining created objects, either, at least not that I found.
And why is a static all on the proxy an issue?
I like what I'm seeing there, but I'm not totally clear on how everything would be instantiated. I wonder what a single-file app with minimal classes (1 controller, 1 view, 1 model, 1DB) would look like with a single request / response route.
But not everyone is on Reddit (I don't have proof of this), and I've never thought that Reddit was meant for long-form discussions. It's more about commenting on external articles. 
This whole codebase reminds me a lot of PHP 4, which is definitely not a good thing. A custom autoloader, files that end in `.class.php`, multiple classes per file...I think I'll pass.
Hm, according to [this pleasant conversation](http://community.sitepoint.com/t/new-articles-are-using-disqus/191149) in the SitePoint forums, the switch back to Disqus is only temporary until they finish modifying Discourse to support inline commenting. (Though it obviously is taking a while.) They switched to Discourse, then decided they wanted inline commenting (which I don't find all that necessary), so they switched just article comments back to Disqus temporarily. Its not really Discourse's fault that SP wants it to do something that it was designed to *not* have. Of course, I'm not part of the SP community, so this is an outsider's view. I'm not trying to defend Discourse either; do you have other forum software in mind we could use?
Thanks for the feedback.Fixed
Sorry you wouldn't give it a closer look as I think you were looking at the legacy code base, which has all of those things. It was written in 2006 originally. However, the develop branch has been modernized a bit with namespaces, proper autoloading, and is available from packagist via composer. I'm giving some renewed attention to bringing the code up to date and will be working on documentation for the 3.x branch once I'm ready for beta.
As a backend dev, this feels like it makes so much more sense than CSS.. I want to write CSS like this.
&gt; sql for stylesheets I never knew I wanted to use this so badly... hmmmm
you could use http://php.net/manual/en/function.register-tick-function.php and http://php.net/manual/en/function.debug-backtrace.php
I seen someone make one and I want to be as good as the guy who made it.
I make very little with adsense. I need to improve that.
Rendering it 100 times. The benchmark function runs code multiple times, as denoted by the " xxx runs" note.
"Inline" means commenting on the very page of a post, something absolutely essential when something is used as a comments system. With Discourse, a user was required to go off site to make a comment, which is unacceptable. The Discourse team knew from the start that that was what was required of them, and made promises they couldn't keep.
&gt; "Inline" means commenting on the very page of a post, [...] I knew what it meant. ;) &gt; [...] something absolutely essential when something is used as a comments system. Which Discourse is meant to be more of a forum system. I do admit the inline "comment" views is an unusual idea, but Discourse isn't *required* to implement inline typing if they don't want to. A little OT at this point.
*OP mentioned "Service Locator"* [http://i.imgur.com/Vzeukqe.gif](http://i.imgur.com/Vzeukqe.gif)
&gt; A little OT at this point. A little :) Discourse *is* required if they're paid to do so.
You can use this reference code to parse huge file and insert the data to mysql database : &lt;?php $row = 1; if (($handle = fopen($inputFile, "r")) !== FALSE) { while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) { $num = count($data); echo "&lt;p&gt; $num fields in line $row: &lt;br /&gt;&lt;/p&gt;\n"; $row++; for ($c=0; $c &lt; $num; $c++) { echo $data[$c] . "&lt;br /&gt;\n"; } } fclose($handle); } ?&gt; Also use multi insert if possible. Instead of running multiple queries: insert into table (col1, col2) values("row1-col1", "row1-col2"); insert into table (col1, col2) values("row2-col1", "row2-col2"); Building one query like this is much quicker: insert into table (col1, col2) values ("row1-col1", "row1-col2"), ("row2-col1", "row2-col2"); By the way, you can also load a file directly into mysql: load data local infile 'file.csv' into table table_name fields terminated by ',' enclosed by '"' lines terminated by '\n' (col1, col2)
Every designer needs to be using git, but that's not likely to change in the short term to fix this project. I would suggest that some planning and story boarding on his part with input from the client early in terms of interface and flow will ensure the project gets done on time and on budget. Try and set the expectation that you should receive the final design and so you can write the code to make it function. This won't always be the case, things change, but if you can set the expectations high and then save the day later. Someone's paying you extra to redo it over and over again, if the designer isn't receptive to more planning and story boarding you might discuss it with the client or the boss depending on how your shop is set up. Development time is expensive, better to get it done right the first time around... Have you discussed these concerns with the designer and/or the senior devs?
This is how many people hate writing JS so much they'd rather write their own transpiler: https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS
Yes, but what does it have to do with your comment about clearing the table?
Agreed, this sounds like bad management more than anything else. Ideally you have some sort of issue tracking system (jira, redmine, even github or something). Try to get a lead/senior dev involved on the scope/specifics before accepting/adding a task. If the scope changes, the designer has to get the change approved by said lead/senior. Any respectable lead/senior will take the proper measures.
You have yourself what's known as a [value object.](https://en.wikipedia.org/wiki/Value_object) Typically a VO would be stored in the same location as the models folder under a /vo folder, or in the services portion of your component. [Further reading.](http://gojko.net/2009/09/30/ddd-and-relational-databases-the-value-object-dilemma/)
If you have `deploy.php` in your repository, wouldn't it expose your keys and passwords?
Love you. thanks :)
Sorry that I linked to the tweet. I forgot about the groups email. Linking to google groups email : https://groups.google.com/d/msg/auraphp/M6KTmcBiXo4/AJbnU_S9a6kJ Thank you
Cool, but what's new? Would be good to supply a changelog or something. Unless I'm missing it...
great work! :D
I get a 500 error when I try to go to that link
Thanks! My site has 20k hits a month. It ranks number 1 for google in its niche, however its not a very profitable one. I tried selling an ebook but it was better to go with adsense in the end.
There's a [non-standard CHANGES.md](https://github.com/auraphp/Aura.Filter/blob/2.x/CHANGES.md) stub. Nothing newsworthy. Probably didn't have a release process till now. And the commit history seems unsuitable to refurbish.
 &gt; Look up chown/chmod commands as those will probably be what you need. Please be careful when advising users to change file and folder permissions and ownership. You are not wrong in your answer, but there are probably good reasons why they are what they are. And even if they are wrong, we don't necessarily know this, and someone less savvy may take your advice as gospel and just go around changing permissions every time they have a similar problem. :)
I'm curious what makes this "full stack"? I'm a bit old [school], so I might be thinking in old [school] ways, but a "full stack" used to mean everything from the server architecture all the way up to the web browser. It seems this is more middleware than full stack. But I'd seriously be interested to know if I need to update my terminology. My meta question aside, regardless of what it's called, I'm sure you put a lot of effort into it. Good work! I would have never considered doing that, and stuff like this is what fuels innovation. So keep it up! 
A linter checks that the syntax is valid - a static analyzer works with what the syntax describes, and tries to decide if the code actually makes sense (referring to valid classes, etc.). From the github README: 1. Checks for calls and instantiations of undeclared functions, methods, closures and classes 2. Checks types of all arguments and return values to/from functions, closures and methods 3. Supports phpdoc comments including union and void/null types 4. Undefined variable tracking 5. Supports namespaces, traits and variadics 6. Basic tainted data detection
Valid point! I tend to forget how tricky linux can be when getting started. 
 &gt;Typically a VO would be stored in the same location as the models folder under a /vo folder, or in the services portion of your component. I would agree with this, if the VO is exclusive to the model. I like to use a naming convention that extends the model. For example, if I have a namespace for a model called \Foo and the model is called Bar (\Foo\Bar being the FQNS), and I needed VO - lets call one Stick - used exclusively by Bar, then I would name them \Foo\Bar\Stick. Conversely, if my VO was to be shared between \Foo\Bar and \Foo\Baz and \Foo\Fighters, then I would try to find a logical common place to put it so it's more clear that it's shared. In my example, I would choose \Foo\Stick. It can get more complicated if the VO is needed across multiple namespaces (ie \Foo and \Bar and \Baz), and that would take a little more thought. You might even consider creating a new namespace for those circumstances. If you use the PSR-2 nomenclature, and have a vendor namespace - \MyVendorName - then that would help. Nb you may or may not be using namespaces, but if you equate the namespace hierarchy into a file path, then it still makes sense. HTH
&gt; T_MAKHSHEV_TAPUAKHADAMA A new one of [these](http://docs.php.net/manual/en/tokens.php)? PHP has an Israeli heritage thanks to Zend. `T_PAAMAYIM_NEKUDOTAYIM` has gotten a bit of drama about it over the years.
I would hope that's a joke and it most likely is but for anyone wondering it means T_COMPUTER_POTATO.
What I read... &gt; T_HAKUNA_MATATA
/r/linuxquestions
Thanks. Linux is private right now because of the "big" reddit upset over the loss of an AMA mod. It is big btw that was not sarcasm. Just sucks when its hard to get the quick answers.
I think you got the answer from pmjones.
&gt;So if my current class is my model, what is my Files class? it's not a controller and it's not a view it's only a class used to create objects, does it qualify as a helper? what is it? It's part of your model, the M in **M**VC isn't referring to *a* model or models, it's referring to *the* model. It is a collection of classes that should represent all your business logic and handle persistence, some of these classes will be models but many of them won't be. 
Didn't they improve on this in 2.5? Or are you saying it's still a pain in the ass to work with?
Kind of, the underlying idea is to bring the two worlds together. You might pull in some PHP dependencies with Composer, eg. a service container library, and then some JS dependencies with NPM and wire it all up in either PHP or JS-land. Another example could be packaging up an (environment-agnostic) PHP library and publishing it as an NPM module that could be used without ever needing to know that it's actually written in PHP. And thanks!
I guess it's a little similar to Google's GWT, but a lot worse, no? (GWT is Java that compiles to Javascript to run in the browser) 
T_FUCK_IT_IM_OUT
100% agree. Where I work, all features tickets are in Jira and requirements and mockups in Confluence. Although for smaller features reqs and mockups are usually just in Jira.
Hi, Sorry for the late response. I just checked it. But I'm glad you were able to fix it. I think this should be mentioned on their site. I'll ask support and see if they can add or maybe I'll just add it within my project. Thanks for the update as well.
I'm not 100% certain if this is what you're trying to do, but if you're trying to have files copied from outside of vendor, I wrote a solution for this for my company's packages which is available here: https://github.com/imarc/opus If you look at the "extra" stuff in my framework's routing package, you'll get an idea of how it works: https://github.com/dotink/inkwell-routing/blob/master/composer.json Note that the package should require opus and "type": "opus-package" see line 6. The README on the opus page should have some more information, but basically you can map directories in the package to copy to directories in the main project, or specific files. 
Brightpearl is written in PHP. It's not very complex as far as ERPs go though.
My main dilemma at the moment is whether to widen the interface of the termination strategy, so it gets informed of events directly, or whether implementing strategies should just subscribe to a separate event dispatcher, with events fired from the PSR-8 object itself. Thoughts?
&gt; No big PHP organizations got enticed by the ERP market (I guess few hundred billion market) What? Even [optimistic projections](http://www.alliedmarketresearch.com/ERP-market) place the entire ERP market at 41 billion by 2020 with an aggressive 7.2% CAGR.
Smart. Glad this is being proposed. I'd love to see `struct` added to this list, so we could potentially add a value object structure of some sort down the road. If anyone's curious, the idea's already being explored as a side-project (not mine) of sorts: - https://gist.github.com/auroraeosrose/2036d1d675a4bd254450 - https://gist.github.com/Antnee/237334e1eb937892ad7a
I think ERP is one of those things where people either buy something off the shelf, or go totally bespoke and build something that's very specific to their organisation / the way they do things, so you don't get people releasing ERP projects as a thing in the same way you do with content management systems or ecommerce stores (where lots of people want something very similar). When you're using "off the shelf" for that kind of software that basically underlies the processes of your entire organisation, you're going to want commercial backing on it (and it may even be demanded by higher management, so you don't get much choice). Maintaining open source projects that do something fairly specific is more than enough work for most people. When you start getting into platforms like ERP where you're essentially piecing together multiple systems and integrating them to form work flows in a larger system, the complexity multiplies.
That blog post is confusing. Let's just run through the patterns one by one and see how they fit together. [Repository](http://martinfowler.com/eaaCatalog/repository.html) =========================================== Seems you know what you're doing. So I'll make this quick. A repository abstracts fetching information from a datasource. So instead of writing an SQL-Statement or parsing an XML file, you define a specialized method in your repository. Calling code only relies on your specialized method and is (ideally) ignorant of your datasource. class MyRepo { public function retrieveCondimentById( $id ) { // Actual Magic happens here return $user; } } $user = $myRepo-&gt;retrieveCondimentById( 123 ); // Calling code does not care what the actual datasource is [QueryObject](http://martinfowler.com/eaaCatalog/queryObject.html) =============================================== Repositories and QueryObjects are often used together. The QueryObject allows to define the query, without knowing how that is translated for the datasource. In turn the repository needs fewer specialized methods. $q = new Query('Condiment'); $q-&gt;findId(123); $repository-&gt;select( $q ); // The repository turns this in an appropriate command for the datasource [Specification](https://en.wikipedia.org/wiki/Specification_pattern) =========================================== A Specification is an alternative solution to querying a repository (and is useful beyond that too). Think of a specification as a boolean expression, that tests if an object matches. interface specification { /** * @param User $user * @return boolean */ public function isSatisfiedBy( User $user ); /** * @param Specification $s * * @return Specification */ public function andSpecification( Specification $s); /** * @param Specification $s * * @return Specification */ public function orSpecification( Specification $s); /** * @return Specification */ public function not(); } $spec = myCondiment( 123 ); // Just imagine the Repository already has all Users hydrated and just passes the to the specification // returning those that satisfy the specification $repository-&gt;select( $spec ); The advantage of specifications is that they can be combined to create new specification. Evans describes this as closed under the operations (in his book *Domain Driven Design*). Just like int is closed under addition (int+int is always an int), specifications can be combined with and, or and not and will always yield a specification. Another advantage is that they can free you from the how. $s = new SlightlySaltySpec(); $s = $s-&gt;andSpecification( new HotSpec() ); $s = $s-&gt;andSpecification( (new SweetSpecification())-&gt;not() ); // salty &amp;&amp; hot &amp;&amp; !sweet $repository-&gt;select( $s ); [Beberlei's Post](http://www.whitewashing.de/2013/03/04/doctrine_repositories.html) ========= Benjamin started out with saying that using a repository without a query object leads to an abundance of methods on the repository. Every combination of properties that might be queried needs its own method. A solution for this would be a query object, but this might lead to code duplication or inheritance for the sake of sharing code. So he presents specifications as a solution to this. However his definition deviates slightly from above. Instead of asking if an object satisfies a specification, he manipulates the querybuilder. This is okay because we know that every object returned from that modified query will satisfy the specification. Like above, instead of defining how to query or what to query, you can specify what you want. The code outside of the repository would not know about the querybuilder. You would query the repository like this: $s = new SlightlySaltySpec(); $s = $s-&gt;andSpecification( new HotSpec() ); $s = $s-&gt;andSpecification( (new SweetSpecification())-&gt;not() ); $repository-&gt;select( $s ); // The repository passes the query builder to the spec and creates the actual query. [RulerZ](http://blog.kevingomez.fr/2015/02/07/on-taming-repository-classes-in-doctrine-among-other-things/) ======= Have a look at this [example](https://github.com/K-Phoen/rulerz/blob/master/examples/using_specifications.php). Kévin likes Benjamin's approach, but would like to expand it to collections in general. At first glance it might seem that Kévin proposes few non specialized methods on the repository. Instead opting to filter the resulting data later. $condimentColl = $repo-&gt;retrieveCondiments(); $rulerz-&gt;filterSpec($condimentColl, $spec); Actually he proposes to combine Benjamin's approach with a general approach to filter collections. In turn his specifications can be used to modify the querybuilder *and* be used in other situations. $s = new SlightlySaltySpec(); $s = $s-&gt;andSpecification( new HotSpec() ); $s = $s-&gt;andSpecification( (new SweetSpecification())-&gt;not() ); $repository-&gt;select( $s ); // The repository passes the query builder to the spec and creates the actual query. // But hold on, what can we do, if we already have a collections of condiments to deal with? // assume that $condimentCollection has been loaded before. // For example this might be in a basket and you want to display condiments in groups. $s = new SlightlySaltySpec(); $s = $s-&gt;andSpecification( new HotSpec() ); $s = $s-&gt;andSpecification( (new SweetSpecification())-&gt;not() ); $goodStuffColl= $rulerz-&gt;filterSpec($condimentColl, $spec); My 2ct ====== So it seems Kévin is trying to combine the our original definition with Benjamin's approach. Which is great because that means we centralize our logic in only one specification (Only one place to check what salty means). This specification can be reused *a lot*. However: - I never understood Benjamin's idea to exclude the `isSatisfiedBy()` method from the specification. - If RulerZ combines those two ideas, why not adhere closer to the definition that Evans gave. The example and explanations are a bit confusing too. To come back to your examples. It would look like: ProductRepository::select(new ProducedBySpec($manufacturer)); You could do either of the following (probably more), depending on your exact requirements - add a `ValidProductSpecification` to each call - add a `ValidProductSpecification` from the beginning - make the `ValidProductSpecification` mandatory and add it in the select-Method **Edit**: Proper Headings **Edit:** Formatting
Off-topic advice. Either something is very wrong with your keyboard, or your spelling is atrocious. Although being able to write clearly is not always necessary, in most interactions with other people, how they react to you will be affected by having such poor standards. Actual advice - I'd suggest Python. It seems to still be growing (slowly) whereas companies are realising that Ruby on Rails is terrible for large application, and so it is dying a little bit. That means there are lot of Ruby programmers looking for work.
personally I wish I had time to learn and switch to golang. it depends a bit on your ambitions. I've done php, ruby and python. I like python a bit over php and am not a huge ruby fan, but I wish I'd have a strictly typed language which I'd mastered.
Both the Folder and File classes are models. A Folder hasMany File, even if they are just value objects. You should have a controller method to do $folderInstance = new Folder($path); $fileArray = $folderInstance-&gt;getFiles(); $view-&gt;render('foldertemplate', $fileArray); Let the Folder model discover its files, instance a File model and deliver them as an array. 
Is this updated to the latest Symfony or is this the exact version that was on Fabien's blog?
Please elaborate
When I see people bashing PHP I feel sad for them. Not because I love PHP and they dont. But because they chose to spend their energy on something they do not like instead of spending their time and energy on something they truly love. As it was said in other comments, PHP is a bit more pron to bad coding but that does not mean you cannot do something clean and efficient. 
RoR projects tend not to scale well, performance-wise. It is not impossible to mitigate up to a point, but this requires efforts and strong understanding of Ruby/RoR internals. 
golang is pretty easy to pick up, if that can motivate you.
&gt;If you only know PHP and you’re curious to learn something else, give the Python tutorial a whirl and try Flask for the web stuff. (I’m not a huge fan of its template language, but it does the job.) It breaks apart the pieces of your app, but they’re still the same pieces and should look familiar enough. I might write a real post about this later; a whirlwind introduction to an entire language and web stack doesn’t belong down here. Oh I love that conclusion, the guy criticizes the hell out of PHP but in the end he doesn't provide us with something better. That's just fucking great
A huge jump, no doubt. Go would be much easier to pick up for a PHP developer (speaking from experience).
I don't understand. Anyone want to help me understand? 
All looks good here. May be something to do with google ?
If your main goal is a high salary, might I interest you in some Cobol? Vintage language, in high demand by banks and other big clients because they still have critical systems written in it. All in all, fantastic job security. At the cost of your soul. 
I'm not gonna criticism your dislike for Python, but what are the big gotchas that you remember? I went PHP to Python and I've never regretted it. Of course you have to change your mindset when going from PHP to Python, but I'm sure a change was needed when going to Go as well, just like I find a change is needed from Python to Scala. What deployment issues did you find with Python? Usually my problem is trying to remember what knobs I need to fiddle with on uWSGI. 
Reading spec may have made my IQ drop. It's the dumbest thing I've seen all year. I assume it's a really, really poor joke.
Explain?
Honestly I only replied in just because your main motivation for choice of programming languages can't be money when you're just a beginner anyway.
I laughed. 
I use bldr myself :)
I want to try node or one of its variants, but I don't have a real reason to.
I have not.
Have a look at the date that the PSR proposal was made.
Like what?
Yeah I've certainly noticed the speed difference between gulp and grunt, but honestly moving to meteor has made both mostly obsolete to me. But since this is /r/php we'll move on :) For my LAMP projects, grunt has always seemed to work better for really just one reason - deploying dbs. I never did, and have not, found a way to deploy mysql dbs in gulp. Compared to grunt where I can watch my git head and see if something was moved to master and fire off grunt deployments. Everything else you're saying is spot on though. 
That is a possible solution to this specific instance of the problem, but the bigger picture problem is "How do I run different logic for different classes?" and your solution doesn't scale for that. We'd wind up with a lot of isStream, isOtherThing, isFoo, isBar, etc as more edge cases came up.
Well, strictly speaking, is that exception something you need to handle? As it stands right now you're throwing a generic exception. If you didn't have that check there you would get a BadMethodCallException exception from PHP core. Should StreamSource care, insofar as acting upon it, if it gets the wrong type of event loop passed to it? If this were me, given this example, I'd be wrapping `$source-&gt;attach($this);` with a `try{} catch(){}` to handle logging or whatever and if StreamSource can only work with StreamableEventLoop then I would be changing the accepted argument type to StreamableEventLoop. Without seeing the real implementation it is hard to give specifics on what might be the best option. You're right that an exception needs to be thrown in your example. It's just a matter of what makes the most sense. What level do you need to handle it, or are there built in exceptions that handle it already?
Those are some good thoughts. I'm mulling them over right now. I *would* like `StreamSource::attach()` to type hint for `StreamableEventLoop`, but that breaks the `Source` contract, since anything that implements `Source` *must* accept any `EventLoop` (even though I don't really want it to). :/
Your second example is basically the Visitor pattern, but when you have Visitor you typically no longer have to do instanceof checks, yet you do. How come you need to account for all four of these cases: 1. Loop handles stream, source is stream. 2. Loop doesn't handle stream, source is not stream. 3. Loop handles stream, source is not stream. 4. Loop doesn't handle stream, source is stream. Are all four of those reasonable possibilities and why? You need to explain more about your architecture for us to figure it out, but I bet all this can be much simpler. Until you explain more, I'll just mention option 3: interface EventLoop { public function attachStreamSource(StreamSource $source); public function attachSomeotherkindofSource(SomeotherkindofSource $source); public function detachSource(Source $source); public function run(); } Now you have to use the right method to attach the right source. No instanceof checks, no exceptions.
If the big concern is using `instanceof`, what about using `is_callable` in your StreamSource attach handler? It approaches that logic from a different direction. I personally don't know of a better way than the second one to do what I understand you're trying to accomplish. Sometimes the best way still feels gross (and that's why new programming languages and frameworks get invented).
I think you may be right, but the perfectionist in me *(ugh, sucks)* wants to explore just a few more possibilities before I go write the interfaces in stone. And yeah, I think Go interfaces solve this problem nicely if memory serves correctly. ;)
I was wondering can't we use normal methods for filters and validators instead of passing those verbose constants and untyped string names (and we can, but I'm just nudge nudge wink wink-ing you in that direction).
Sure, maybe I can explain a bit more. Of the four cases you listed, #4 is invalid and should cause some sort of exception, but #1-#3 are OK. #1 and #3 probably occur most often. The idea is that each source has 0-n special requirements that must all be met by any event loop it is attached to. Event loops can support 0-n special cases (though almost always 2+ are supported: sockets and process signals) and are able to handle any source within those boundaries. Any kind of event should be implemented as a `Source`. An event loop can be used to give sources processing time and register callbacks for sources. I suppose I should give the correct relevant method interfaces for `EventLoop`: interface EventLoop { public function attachSource(Source $source, callable $callback); public function detachSource(Source $source); } And then the full definition (currently; pasted from my project) of `Source`: https://gist.github.com/coderstephen/39274888033dd6089361. The doc comments might help. How might I use the Visitor pattern properly?
... Someone made a library named the same as the alias for gcc, or are you high? 
Maybe the Visitor pattern is not suitable and entirely coincidental then. What about my option 3 above? It seems to address your use case somewhat. It enables #1, #2, #3 and makes #4 impossible. An EventLoop will implement only the addKindOfSource() methods it supports (and you can have corresponding EventLoop interfaces for each one method). Technically you can use Visitor to simplify the interface for end-users of loops and sources, but maybe it's a step towards obscuring the logic of the loop, rather than helping.
I can agree with this suggestion as well. Make is simple, fast, and battle-tested. Might have some extra work to do with some tasks that don't have scripts/binaries already though.
Personal itch to scratch, or even take something you use every day and give it a go to re implement it. Also I said node, I did mean iojs(basically nodes future).
I kind of like how clean that would be, but how would you handle sources that require 0 special handling? Keep an `attachSource` method and tell people to not use it unless you know the source doesn't need special handling? I think this is one of the toughest design problems I've had to deal with for at least a year. :P
So I thought a bit here's my final conclusion: 1. Have one interface EventLoop with only the methods for consuming the loop (method run() for ex.). 2. Have one interface EventLoopWithX for every type X of source it supports (methods attachX() and detachX()). 3. Real world loops will implement EventLoop and at least one of the EventLoopWithX interfaces (or maybe they can go it alone, why not?). And the above structure allows arbitrary combinations of source-kind supporting loops without having to explicitly check for types in your code at runtime. Ex.: class MyLoop implements EventLoop, EventLoopWithStreams, EventLoopWithSockets { // EventLoop function run(); // EventLoopWithStreams function addStream(Stream $src, ...); function removeStream(Stream $src); // EventLoopWithSockets function addSocket(Socket $src, ...); function removeSocket(Socket $src); } Stream and Socket may still extend a common interface Source or not, depends how much they really have in common.
Having a source with "no special handling" in a group of sources who need some special handling, also is a form of special handling. So treat "Source" as an abstract interface you never implement directly, but implementing one of its descendants. StreamSource extends Source, SocketSource extends Source, and for those without special handling, let's say SimpleSource extends Source. Then never typehint for Source directly, use it only to host the common methods. By having SimpleSource, a source has to *explicitly* declare itself as not needing special handling, so then it can only be accepted by methods addSimpleSource() and removeSimpleSource().
Excellent thought!
I think I might have to go with this solution, since its portable and allows just what I'm looking for. I would prefer a generic method for what my head is calling "simple", but its probably a false hope. Maybe generics would work here, but alas, we have no generics in PHP. Thanks for your time, btw!
If this were Java, this would be one method name, overloaded with different implementations for different signatures (i.e. source types passed in). In PHP we use separate methods because we have no explicit overloading and the implicit one is way too vague to document and use. You'd like separate methods not just for the reasons we discussed, but also because over time you'll find the different attachSomething() methods might evolve to have *different parameters* (I mean aside from the first one, which is the source). Best to keep it explicit.
 How about this: class StreamSource implements Source { public function attach(EventLoop $loop) { return $this-&gt;attachStreamable( $loop ) ; } public function attachStreamable(StreamableEventLoop $loop) { $loop-&gt;handleStream($this-&gt;stream); } } attach() satisfies your interface contract, but then just passes the call on to attachStreamable(), which has the stricter requirements. You still get an exception if the passed event loop doesn't meet the requirements, without having to throw it yourself. It achieves the same effect, with the improvement that the API now expresses its dependency on StreamableEventLoop in a function signature, rather than buried in the code. 
pretty sure they're just implying you use make and customise the makefile
Agree completely. Perhaps an example would be useful: class FooController { public function __construct(PaymentMaker $pay, ShipmentMaker $ship) { ... } public function postPay() { ... $this-&gt;pay-&gt;complete($order); } public function postShip() { ... $this-&gt;ship-&gt;send($order); } } At this point, the controller should probably be split into separate controllers for payments and shipments. As a general note, I find that any time you create a class with `new`, it points to a dependency inversion problem because you have created an object that cannot be (easily) mocked and therefore will be difficult to test.
Well my question is, is enum an object, or an array or resource-like complex structure? Id love to have enum in PHP, but only if it is object oriented. 
I am a regular visitor of the FuelPHP forums and there are countless threads/comments where people say they are coming from Laravel and they are happy that they changed to Fuel. I don't doubt that the same is true vica versa, but one difference is that people coming to FuelPHP claim to be experienced developers. My personal opinion is that I can't work with a framework which has its core completely rewritten with each release. (That's the major complain about Laravel on Fuel forums)
I could just point you to a library that does it, but it seems like a wasted opportunity to see some different solution emerge. I'll say - it's possible &amp; the solution is simple - no heavy reflection magic or codegen. How'd you do it? **EDIT** One more clue: composition.
@emperorkrulos' answer pretty much sums up what I'm trying to do with RulerZ. Sorry if the blogposts aren't very clear, I find it hard to explain concepts I just discovered in a language that isn't mine. Regarding @baileylo's question, I'd follow @emperorkrulos' advice and make the `ValidProductSpecification` mandatory and add it in the select-Method. But it means that the whole application will only be able to work with valid products, which can be a problem. Assuming that you only want valid products to be returned in the public part of your application, you can create a repository that will ensure that only valid products are returned and only use this repository in this part of the application while you'll use another repository in the rest of the code.
 // Alert Container Used By Controller to Set UI Alerts protected $alerts = [ 'errors' =&gt; [], 'info' =&gt; [], 'success' =&gt; [], 'warning' =&gt; [] ]; That's UI concern in a service. Services shouldn't have UI concerns, like displaying "success" messages. Not returning errors = success for a service. Level "warning"... maybe. But "info" and "success", I don't think so. // Define and Sanitize Post Data $input = $this-&gt;input-&gt;get(['username', 'password']); There's no way you're "sanitizing" anything in there. You're just reading input. Your question about methods is too vague. Define your problem more clearly. 
Yes, this has been updated and reviewed by Symfony docs team for the latest Symfony 2.7
It's not the error "alerts" I'm pointing at, but "warning", and with both hands at "info" and "success". Services shouldn't be handling UI concerns. Returning errors if the action can't go through is a service concern. But the rest isn't. If you go back to your previous thread, you'll notice the poster wasn't suggesting that success messages come from the service, only error messages. Also if you just collect errors in a service-wide array you risk picking errors in the wrong context (something else generated errors, you pick them up as if you did), or ignoring the fact the action failed (like an exception forces you to acknowledge). It's not a big deal, but generally do try to have patterns in your code that encourage service users to do the right thing. &gt; I am asking about the necessity of the UserService class or examples/changes that i should make to my services altogether. I have no idea what this class does as written in your example. It just holds a directory name, it's like reinventing classes. Can't you have a class with methods, instead of pointing to a directory holding methods as classes? I mean either you want one action per file (class = 1 action), which is fine. Or you want many actions per file (class = many methods, each one action). But you're trying to have it both ways by doing filename resolution magic. Not sure it's warranted.
If you want a job with good salary, learn java, hibernate, ejb, jsf 2 etc etc etc. If you wanna a really good salary, work hard. Doesn't matter the language, really good professionals are well paid.
It helps to think of it as a "service", not as a model. Think Twitter's API or Facebook's API or any other API. Then it becomes a lot more clear how it should work.
PRs welcome.
Where did I say I disliked python? Do I dislike PHP because I moved a certain use case to python? Unlike a lot of PHP devs, I don't just develop in PHP. I do javascript, perl, bash, swift and many years ago did C#. It was easy for me to start using GO. It's also a very well documented fact that python is very slow: https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/ The deployment issue is that I'm a bit of a purist. I dislike having build tools on production servers. I didnt want do use pip on each box and install all the modules by hand. Instead I packaged them up using pyp2rpm and installed from my copr repo. I have several front-end boxes and was easier to do it that way. I'm a sys-admin for many years also. One more thing, I'm not the only one who is moving from python to Golang: https://www.reddit.com/r/golang/comments/2aup1g/why_are_people_ditching_python_for_go/ Lots of threads like this one on Hn.
The command + handler pattern is better for this. It truly decouples the intent ("this describes command") and the behavior ("handle the command"). Here's a basic example with the Tactician command bus (a "bus" is basically a *chain of handlers*): https://github.com/rosstuck/tactician/blob/master/examples/1-beginner-standard-usage.php 
PHP has always had a powerful array-implementation and standard library that goes with it. Some may find the support for both numeric and key-value arrays in the same implementation, a bit difficult to understand. But undoubtedly we have all created good things with PHP's array. Since the introduction of the splat (...) operator for declaring variadic functions and unpacking function arguments in PHP 5.6, it has become quite clear that we need the splat operator in basic array arithmetic as well. Simple examples are `[...$originalArray, $pushNewItem]` but also `list($one, ...$theRest) = [1,2,3]`, these are missing utilities in the array toolset we use at work everyday. I do hope to see this incredibly useful operator in PHP 7.
I have physical servers. I run into billions of impressions per month. The cloud is actually too slow with latency issues at various parts of the stack (believe it or not). I have my own tools and processes for deployment.
This is pretty neat! I'll still prefer using things like Jekyll. 
Docker isn't a cloud thing. Well, it started as a cloud thing. It's like if a VM and a process had a baby. I'm not second guessing your infrastructure, obviously you'd know it better between the two of us (and likely everyone else other than the guy who built it unless it you...whatever, you know what I mean). Was just curious if you'd tried it at all.
10/10 awesome idea. Tuple unpacking is one of my favourite things in Python, and if I remember correctly there's a PEP under consideration for bringing unpacking into literal syntax as well. To be curious, is it possible to unpack nested sequences with this? 
If it isn't in PHP7 by now, it's probably not going in. We're two days away from the first beta being tagged, so you'll at least have to wait for 7.1 for something that never went anywhere in eight months.
I'm generally in agreement with /u/maybe_john. Your service should be have no UI-level concerns, and it should be stateless. Having a stored `alerts`array that gets populated from other methods violates both of those principles. Also consider the "ask, don't tell" principle. Your controller shouldn't *ask* if something went wrong with the service's last operation, the service should *tell* the controller if something went wrong. You can use a DTO object for this or exceptions, though for one-off operations I prefer the latter. Also, if you want to limit the need for try/catch blocks and you're working with a Laravel controller, you can override the `callAction` method and wrap the parent call in a try/catch block. That will allow you to catch all exceptions of a certain type and handle it by, for example, redirecting back and displaying the exception message. I would only do this for your userland exceptions however.
I think this would be helpful: http://www.katschthaler.com/wp-content/uploads/2014/01/Ira-Glass-ForBeginners.jpg
There's a lot of talk about "best" without the commensurate description of the valuation. Your work isn't bad because it's not the best for a given scenario. Code written by 5 people looks WILDLY different from code written by 1 person. There's good reason for this and they can both, subjectively, be considered "best". You can make changes. The most difficult problem in software development projects, is management of the project (what to change, when and how). There's a whole subculture of discussion about how to best do it. So don't worry about a better way to do things, just keep at it and slowly learn the patterns of what works and doesn't work (which are partly affected by your personality). It never ends.
Just keep doing it. I've found self doubt can be a very useful tool. It's already making you work harder to be better. Being bad at something is only bad if you aren't identifying the problems. So keep failing and keep learning. 
The title is misleading, if you didn't have atleast a 'hello world' example you should have made that clear in the title. 
Yeah, an example would've been nice.
hardwares softwares middlewares
Honestly, you're on the right track. If you feel like you have more to learn then you're in a good place. Once you admit that you know everything then you've failed as a programmer. Keep researching and keep learning, but don't give up on your projects unless there is more of a legitimate excuse (such as finding a possible alternative that you didn't know about when you started the project). Admitting you're not good enough is not a reason to give up. You may need to take breaks, but that's normal. You should know that even after a decade of programming I still feel like this all the time and my hunch is even the best and most humble programmers in the world still go through this.
I edited the post to include my current `ForgotPassword Service`. The point of the `UserService` 'Access Layer' Was to act as the bridge between the controller &amp; actual services being called. Within the actual services themselves ( see edit ) they define errors that are set within the service classes ( protected var within the base service class they are extending ). After execution the alerts are pulled via `UserService` layer to bundle them all up. If i am running multiple forms or services on a page and alerts come up then i would manually define within the controller to grab the errors from x, x, x, and x which would cause a lot of duplicate code or i can do this. My thoughts are if i am going/need to output an error than its there for the user to see. I also thing=k i could be confusing you all at the moment. Errors, Info, Warning, Success are the flash message alerts sent to the users when their input data doesn't meet criteria or something along those lines. For specific services like logins things get a bit complicated because i have built the ability to lock a users account, and bruteforce check. So the login service needs to set a variety of alerts that notify the user that their account has been locked for x minutes etc. If i threw that into the controller i would need to duplicate it for admin login, or modal login, etc. I was attempting/using the `UserService` as the DTO. If this is still the incorrect method of doing things what would be the exact changes here that would/should be made. I can't wrap my head around why this is incorrect since the services themselves are not outputting the flash messages they are just holding them within themselves and it is pulled when needed/requested by the controller and then output as an alert from the controller. 
just build your webite\service; the beauty with programming is there is no right\wrong way and over time you learn to do things more efficiently. Then; 100% start using a framework, speaking from experience that elivates that notion - until I started learning a framework and I'm talking in the context of having build a dozen small\medium projects over the years I wasn't abl to shake the feeling too. Also, don't feel ashamed for using GOOGLE, part of being a good problem solver is by knowing how to find information out fast and not just sitting there staring at the screen. 
Keep doing it until you feel like you are good enough. I know it doesn't seem like it, but there will come a time when you are comfortable with your own capabilities.
It's definitely an alternative solution, but I don't think it meets OP's requirements. I think he wants a singular `attach` method because of an API he is working inside of, integrating with, or architecting. I've done stuff like that in the past, but sometimes you really do want that generic `attach` method instead of having to define a new method for each type you're attaching. edit: Nevermind, OP mentioned below this sort of solution (bit different form) is fine.
Well, there's a good old remedy for impostor syndrome: study more and grow balls (self-esteem) =)
Yeah but what happens if you end up shipping something that breaks because you didn't even know about XYZ concept? (A legitimate fear of mine)
Everyone here is 1000 times better than you. Everyone here has the exact same feeling as you. You might as well get used to the feeling. It's never going to leave you. Your skill has absolutely nothing to do with it 
Well, i was talking about design patterns....
This syntax seems really wrong to me. When I see `...` in an array I think `range()` not merge. I'd rather see the `+` operator overloaded to implement this functionality. 
You will. No matter what you do, or who you talk to there will be SOME area of expertise that is not covered and some piece will not be as good as it can be. That's fine. Improve it when you find it. Perfections a nasty target to shoot for.
Clearly someone had a college typography assignment. Jesus christ that was bad.
Long story short; I used to think like you until I met actual senior devs who had big knowledge gaps and couldn't draw up a useful UML. Everyone has the strengths and weaknesses, regardless of experience 
Have you ever wrote code and then a year or two later look at that awful code....it happens to us all. Just keep at it and try to look up best practices when needed.
Yes, someone made a library named the same as the alias for gcc. They must be hella high. `make` is a generic tool that can be used to control the generation of files and execution of binaries. Most - if not all - task runners have their roots in `make`, and may just add "extra" features on top.
I find mysql workbench usually does everything I need. Connecting via a tunnel over ssh is one of my favourite and most used settings. You can also export queries into php using prepared statements, this can be a great time saver sometimes. 
it might never go away, im 10+ years in it, and know exactly what youre talking about ;) it might be a character thing. on the bright side, i can promise you--having this chracteristic--you'll one day meet developers who are suppose to be god almighty seniors who think very highly of themselves, that will be schooled by you ;) having the feeling you're always steps behind, and not up to your game, will push your buttons 24/7. just enjoy yourself
In summary, the old Unix adage. Make it run. Make it right. Make it fast. 
Why is it that whenever people recommend frameworks, i never see zend framework? Most of the time its laravel or codeigniter. Just asking because we use zend at my internship and kinda want to use it for my own projects but i would like to know the bad things to. I just want to know the general opinion about zend framework?
I am making a custom shopping cart system. When customer add items to their cart, an array of item objects is stored in the session. This is how the array looks like: http://pastebin.com/rzh1Qi09 I have limited customers can only have maximum of 10 items in their shopping cart. I am worrying that the server does not have enough hard disk space to store the session data or that the server does not have enough memory to handle it if there are too many concurrent users. 
I added a note clarifying this with some examples :)
I'm still new to PHP; mind guiding me the right way? The website in question is effectively a hand-built CMS and each page runs by starting a session, getting the unique ID and then checking for a $_POST, then after that grabbing database data and echoing that out into all the fields. It's not very DRY but I don't know how I could structure it better. Can that be done better? (I assume yes... :p)
I wouldn't worry about it. If you'll have that problem you'll be able to afford terabytes of hdd.
..... book?
If you know you suck, then you are one step ahead. No one will ever be the best. There will always be a space for each programmer level, and you don't need to be the best to success. You need to learn why you are failing, you need to learn tools that make your code developing almost stupid-proof. It's hard, it's long, and it's boring sometimes. And at the end of the day, you realize what you have done is beautiful, and no one will ever use it correctly, you will get underpaid, and any person who is not a programmer will never understand your frustration. Programming is hard. You have to really love it. It's not something you will learn by force, you have to be attracted to it. If not, just walk on and try other thing. Programming is not for bitches.
look at who or whatever is making you feel like that and repeat after me "fuck you" then go do whatever it is that you're trying to do. if you make mistakes, then learn from them
Hi thanks for your reply! I now tried to implement it and I knew it would throw a fatal with non called object (format) This means that $xdat is not a object right? Can I write it like this? : new DateTime($xdat['zeitraum_von']; new DateTime($xdat['zeitraum_bis']; and after that your snippets?
I did. I used it like there, but I get an Fatal Error which says that format is a non called object.. I will debug a little bit and maybe I will find it! Still thanks!!
I normally use ``` ini_set('display_errors', 'On'); error_reporting(-1); ``` for error reporting, maybe the change will give you a more helpful error message?
Spot on. You get over that and start playing around with front end stuff once you get really bored with backed. 
Just use : $this-&gt;text_ausgeben(date_format(date_create_from_format('m/Y',$xdat['zeitraum_von']),'Y') . ' - ' . date_format(date_create_from_format('m/Y',$xdat['zeitraum_bis]),'Y')); But it's not very readable code (even if result is the same) Edit: If it still doesn't work, it must be because your date variables are not "08/2012" strings and as such not understood by date_create_from_format(). If so, debug to find the type, and read the linked documentation to figure out how to reach the desired result. @mods : I somehow thought I was browsing/replying /r/phphelp . Sorry this doesn't belong here.
Sometimes shared hostings crash on things like: $a = [1, 2, 3]; Which version of PHP is available online? Can you change it in the admin panel? 
That's the main problem, I have 5.3.3 on the hosting and there is no way to change it. This is the only library I found that still supports 5.3. Anyway, I managed to solve the problem.