Isnt it PHP with additional features? It seems marketed that way.
I personally much prefer adminer. phpMyAdmin has become bloated and slow over the years IMO.
Two things: * How are the locks released if the process crashes/exists/fatals on synchronize? (I think flock manages this, but I don't know about the other approaches.) * LockMutex uses only 'finally'. Shouldn't it catch any exception and release the locks and throw it again?
MySQL Front
&gt; How are the locks released if the process crashes/exists/fatals on synchronize? `finally` takes care about the non crash situations. Crashing is handled by the respective lock mechanism. Which implementation in particular are you interested? &gt; LockMutex uses only 'finally'. Shouldn't it catch any exception and release the locks and throw it again? What you are describing, is exactly what /only/ `finally`is doing.
Well, there's Facebook's main codebase, obviously. And yes, that doesn't help since it's all closed source. Also in the FB bucket, but decidedly more open are: 1. HHVM's Systemlib. Much of the runtime library in HHVM is written as PHP/Hack code and you can find it under hphp/system/php/ or in hphp/runtime/ext/.../ext_*.php 2. One-off tools like FBShipIt Beyond that, there's the PocketRent framework, which uses a ton of HackLang specific features. Even packagist has a few small libraries tagged "hack", including my async-process lib. ----- All that said... No, there's not much of an ecosystem out there for HackLang. PHP7 getting off its ass and doubling performance over PHP5 without sacrificing all the industry knowledge around PHP has a lot to do with that. It's why I've been pushing on PHP to take up Hack's more useful features (ideally in a compatible way, but I'll settle for the PHP NIH way).
[removed]
Oh yeah I see I had a small misconception about finally. I don't know how universal crash handling is for each lock mechanism, so instead of explaining it here it would probably nice to add it to the readme. In addition what alienated me a bit is that you for example use "balance" as lock id. It may be out of scope but having something like "balance {$bankAccount-&gt;getId()}" would make more sense.
[free community edition](https://github.com/webyog/sqlyog-community/wiki/Downloads) 
dbForge is great, the comparison tool is awesome, fast and reliable. You can command lines to compare / sync databases. The JetBrains is good for running queries and stuff.
I used to use SQLYog and really liked it. I don't use mysql enough these days to buy it, though. I just use MSQL workbench.
&gt; It is closely tied to facebook, which is a no go for various reasons. Why? React is closely tied to facebook and thats a YES GO for many reasons. &gt; It impacts workflow and operations too much to quickly jump into. How? At the end of the day your PHP code should work just as fine while you integrate new concepts and tools the language provides. &gt; Facebook is so nice to give us a "patent grant". No idea what patents affect hack or hhvm but enough reason to give a fuck about this project. I sort of agree here.
Another vote for navicat, but if i was starting out with one, id use a free one as some of them have gotten relly good since i bought navicat like 8 years ago. The big plus for navicat for me over the years is when needing to work with a database without direct access, they have a php file you upload to the site to tunnel navicat through (of course there are now also single file versions of phpmyadmin type programs) 
React transpiles to JavaScript, Hack doesn't.
Only if they generally make sense
[removed]
&gt; I would have loved to test Hack, but loosing backward compatibility is a no-go for most the projects I'm working on. You won't lose backward compatibility: https://docs.hhvm.com/hack/tools/transpiler
&gt; Where are ruby and node? :P Still highly used and popular. The same question could be asked of java. Every tool has a specific purpose. 
&gt; React transpiles to JavaScript, Hack doesn't. Because transpiling to JS would be silly. Hack does, however, transpile to PHP. (h2tp)
Hack understands the assert-like invariant() statement to deal with that: function foo(?Bar $b) { $c = $b; // c is a nullable Bar invariant($b !== null, "We don't really expect nulls in foo()"); $d = $b; // $d is Bar (non-nullable) }
It would be great if it didn't crash more times than it ran a query.
That's what I meant. React -&gt; JS, Hack -&gt; PHP. Though I didn't know that Hack transpiled to PHP. I thought it was its own interpreter/byte code compiler. My bad.
I used SQLyog for years, but switched to DataGrip 6 months ago and am happy with it.
It is not PHP7 compatible though.
Code which is PHP 5.6 compatible runs on PHP 7...
So basically FIG should only have 2 voting members?
I meant PHP7 code is not Hack compatible.
I don't get your credible/pervasive standpoint. The way you put it you're looking for a cult not a "standards body". If there is a need for a standard, it doesn't matter who publishes/creates it, as long it is eventually doing well what it is supposed to do.
It *can* be transpiled to PHP (how reliably?), but you'd normally run it on HHVM.
I use this as well... I don't think it's great, but it's good enough for what I do.
I even use it on Linux (under wine) because it's so much better than MySQL Workbench, and it's free. I like Navicat but I'd like to meet the person who can afford a license for it.
Some legal departments are more than a little concerned by the implications of the grant. As far as I can tell, the team behind react don't care, but FB's legal team might... 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions
HeidiSQL
Or better yet: [password_hash](http://php.net/manual/en/function.password-hash.php)
I kinda wonder why this, and the WeakRef extension (for PHP 5), aren't bundled extensions.
Yes, this. The transpilation option is for switching back to PHP from HHVM, not normal ops. :)
Don't know, but the real usage of soft/weak refs in php is quite limited, I never faced such problem until start embedding v8 into php (github.com/pinepain/php-v8). The problem comes when I want to wrap v8 object representations and pass them back and forth between php and v8 runtimes. It is not possible to connect v8 object representation and php objects that will refers to it in a weak manner so that when v8 object can be GCed by v8, PHP object can be also GCed and vice vers. It even sounds bit weird. Originally it was just weak references support - https://www.reddit.com/r/PHP/comments/40gko5/php_7_extension_that_adds_weak_references_support/ but lately I had to catch object right before it death and prevent it from dying in some exceptional, I would even say bleeding edge, cases. 
Whether you like Laravel or not, there's no need to be rude. 
Half the PHP 7 features are actually Hack features (scalar typehints, return typehints, and now with 7.1, nullable types). As for others, like anonymous classes, there's active work being done for them to be added to Hack. So the "promise" is still valid. If you want to complain, you'll always find a reason to complain, though, as is evident. How much PHP7-specific code do you have? Tons, I bet...
the one with the worst documentation. the one with the most inconsistent styles of code. (like the infamous inconsistency in php array function argument order, needle or haystack first?) i wanna mention codeigniter in terms of documentation, they have improved their documentation, but its still shit, look at this http://www.codeigniter.com/user_guide/database/results.html scroll down to the reference for row() ... now tell me exactly what it returns when there are no more rows? null? false? empty array? empty string? some weird object? who knows. i had to only look 1 minute in codeigniter documentation to find this kind of lack... edit: better example, from codeigniter 2.x http://www.codeigniter.com/userguide2/database/queries.html .. what does the query() method return if its a 'read type query' that fails? false? an object? woot?
Go through these, very carefully, one by one, and tell me which ones are affecting generated PHP 5.6 code running on PHP 7: http://php.net/manual/en/migration70.incompatible.php Facts™ - always a click away!
Not sure why you are down voted. Okay, Atom is more an editor than a IDE but there are many plugins that can give you all the tools you need. I do use PHPStorm for large projects. But for smaller, or js/php hybrid projects, I really love Atom :)
Apache uses a process or thread pool approach: each new Request spawns a new Apache thread / process, allowing it to handle many requests in the same time. This approach is however limited because you can't truly handle an infinite number of process / thread in parallel (it's usually limited to the number of available core, provided no other service are using those). On the other hand, nginx uses an Event-Driven approach: a Request usually spends some time "waiting" (for example waiting to connect to a database), during this waiting time nginx is able to accept more Requests. Well that was the main difference at some point, I'm not sure if Apache finally closed the gap in that domain. Another strength of nginx is how efficient it is at serving static resources like images, javascript and css. But I think the main difference between Apache and nginx is that nginx has been built to be a proxy. It can be used as a load balancer in front of some apache instances, it can be used as a "reverse proxy" (HTTP cache speeding up your application to many folds), or it can simply be used as a web server. If you ant to learn more, I'd recommend this article from nginx explainig in their view their advantages over Apache: https://www.nginx.com/blog/nginx-vs-apache-our-view/. If you're curious about Event-Driven architecture and want to understands how it works, I've written an article explaining how to implement it (I understand best things I build): https://gnugat.github.io/2016/04/27/event-driven-architecture.html
Yeah, probably
Ugh... lots. Not the usual political ones for a change. Well perhaps those as well, but there are more fundamental technical hurdles to deal with which I haven't sucked it up and sat down to even scope out yet. Secretly hoping someone else gets to it before me. :p
&gt;If you want to complain, you'll always find a reason to complain I don't really care, I'm on PHP not Hack :) Or rather this is a deal breaker for me so I can't ever consider it. &gt;If you want to complain, you'll always find a reason to complain, though, as is evident. How much PHP7-specific code do you have? Enough to find out that was the case when I wanted to try it ¯\_(ツ)_/¯. Some are actually quite easy to encounter: - typed variadic parameters https://github.com/facebook/hhvm/issues/6954 - throwable interface: https://github.com/facebook/hhvm/issues/6037 - arrays in constants: https://github.com/facebook/hhvm/issues/7214 And the full list there https://github.com/facebook/hhvm/issues?q=is%3Aissue+is%3Aopen+label%3A%22php7+incompatibility%22 I'm not implying they're not doing anything about it, but it doesn't look like something that will be solved before half a year or a year either.
From my experience, "Enterprise" (for most licenced software) is basically "if the software fucks up, it's our fault, and we'll pay or fix it for you". That's what you get with most enterprise CRM/B2B/DB/blahblah. It's not about software features per-se, but pure licencing features. 
So Magento offers nothing functionally superior to say Prestashop or Opencart? having a quick look over the feature lists they are pretty much identical. 
Edit: here was a long and what I would consider useful reply to the question culminating in "learn general CS stuff instead". No attempt at pixie promotion was made. But since I get downvoted anyway and same old snarky jokes flt, fuck it, why do I even try contributing to this sub.
Magento itself is pretty much feature-complete to other similar solutions, but Magento CE vs Magento EE is mostly a biz-relations thing.
What this guy said. Similarly, you can position higher-end hardware solutions along a spectrum of how much support you get if something goes wrong. As a brief example, the range is somewhere between "call us to open an issue and we will help you fix it" all the way to "any issue is guaranteed to be resolved within two hours" (that is a real guarantee that I have heard).
I think your title is a tad confusing, as Magento has a Community and an Enterprise edition. The difference between those two is minimal at best as stated by others already. Instead, it seems to me you want to know what makes Magento the industry standard for eCommerce solutions, as opposed to others?
 function returnSomething(array $param) { if (!is_bool($param)) { That makes not sense, it's an array, so it cant be a bool...
I really don't understand why you're looking at reflection at all. Surely this is all you need? /** * @expectedException \Exception */ function test_exception_is_thrown_if_some_argument_is_not_a_bool() { $b = new B_Class(); $b-&gt;returnSomething(['some_argument' =&gt; 'not-a-bool']); } 
Yes, Magento boosts about having the biggest market share but what makes it such an attractive system over everything else? What does it do that other systems can't?
Tested it myself, works like a charm with your exact (corrected) example (and same phpunit version, with php 5.5, 5.6 and 7.0).
I have another perspective, my salary is pretty good at the moment and the calls I'm getting are for similar or higher salaries. I've found it has less to do with the particularly programming language but rather the industry (I work in fintech atm) and what you can bring to the table on-top of just knowing PHP (can you architect systems, do you know operations, have a business background?, etc).
I disagree that it the pay is less `because it's a kid's game...` The reason PHP devs tend to get paid less than other devs is supply and demand. If you have 100 people applying for a job then you're going to have some pretty talented people to select from and you are going to have some people who are desperate for a job and they will do it for nothing. When you have JAVA/C/C++/go/etc you're going to have less people because less people develop using those languages therefore you end up having to pay more to get the better people. With that said you should see evidence, over the next 5 to 10 years, that all developers are going to get paid less and less. There are more and more people getting into software development and there isn't as much of a demand as there used to be. Companies are realizing that the more people you throw at a problem the longer it takes to solve the problem so companies are moving to smaller and smaller teams. Years back offshoring used to just be a mess but now you can find really good developers all around the world. The last thing that is dropping the price is that companies are allowing remote developers. If you can get someone in the middle of the country that is a great dev and their cost of living is a 1/4 of what it is in a big city then they can be paid less. This drives down the price for everyone as well. So there are multiple factors that go into the decline in pay and it isn't specific to PHP. We are just seeing it there first because we have such a large number of developers. 
Zend Framework is the hardest to learn by my experience..mainly because it is not meant for starters. I found Symfony the easiest and Lumen, Laravel, Nette, Yii somewhere between.
100% agree on this one
As someone who started as a PHP dev around 2006 and now hires PHP devs for my teams, the salary is definitely going up (in Germany). I'm talking about real php development here, not Wordpress-plugin-installing. As others have mentioned, industry is important. You can earn a lot of money in Berlin with comparably cheap living costs, if you actually have some skills.
I wouldn't be surprised it was some counter-movement of the companies seeking to have a better start negotiation position.
plz do not ever use opencart. ever. ever. ever.
There are over 9000 people who all learned PHPIXIE in just 5 seconds at exactly 2am last Saturday.
Hi - I currently work with Magento and have previously worked with OpenCart. Magento is far more powerful than OpenCart. The flexibility it offers is much greater and the community around it is of a higher quality. Also, the owner of OpenCart is an absolute asshat. The code of OpenCart is also the stuff of nightmares and it doesn't have a 'proper' plugin system. On the other hand, Magento is COMPLEX. I have been working with it for over a year now and I still learn new thing about it. Yet at the same time it is wonderful to work with, a proper hooking system (observers) and you can rewrite/extend just about everything without hacking core. The other issue you need to think about is performance. We have found it necessary to use Varnish and Redis to get a *good* performance out of Magento. With great power and flexibility comes big performance sacrifices. Also, if you don't know XML, be prepared for hours of looking at XML configs working out what the hell you have done wrong.
You might want to add a `composer.json` for autoloading and make it available on Packagist. Also consider rewriting your tests with PHPUnit; it's the most prolific way of writing tests. It will also provide you with valuable code coverage data. While looking at the code, I notice that everything is in some rather long static methods. Can you refactor this into more proper OOP? How short can you get your methods? Can they be made to fit into 10 lines each? If I were doing this, I'd probably expose it as `PugDocument(string $pug)` with a `toHtml()` method. The `PugDocument` class might encapsulate collections of whichever elements you find in a Pug document, then render each of those into HTML, concatenate them, and output the final document. Each of those element types might be worth making into its own class that implements a `DocumentElement` interface. Just a couple thoughts, since you asked. I didn't look closely enough at the code to say for sure that what I've described is a viable approach. It's merely an impression I have after a couple minutes of reading.
I'm seeing the opposite happen. Where you would normally see jobs for $50-80k I'm now seeing them go for $90-130k depending on the role (I'm in Phoenix). 
What current range for senior PHP dev - getting in hands everymonth? 
Thank you for this valuable feedback! Refactoring the class is definitely something I want to do, but the goal of this project is to be one class you drop in your project for using PUG. To parse PUG in a much more advanced way there is php-pug, a parser that supports very advanced language features. I will definitely look into automating the test and putting it on Packagist. This is a learning experience for me since I have never build or published any php tool or libraries. 
HeidiSQL is what i normally use. I really like Adminer Editor if i am to throw a quick "admin panel" together.
you are intriguing me... living and working in Canada right now. danish of origin. wondering if i should stay, because the Vancouver housing market is so messed up...
Why you are testing a protected method? You shouldn't!
I agree that some WP experts do indeed know what they are doing. Helpful and well-meaning advice: it is popular on Reddit to shout about ones "six figure salary" but you're probably thinking USD - the OP is in the EU, where they use a number of different currencies. Also, some readers here may interpret this phraseology as look-at-how-rich-I-am, which doesn't always go down too well! 
If you're getting 6 figures, then I don't think you're dicking around. I know tons of people who do Wordpress, but only use it to churn out websites. Register domain - setup cPanel - Install WP - apply skin - install a few plugins - MAYBE edit a few outdated plugins to do what you want (actual PHP work), and that's about it.
For 8 years, I've mostly done e-commerce with Magento/Zend/Symfony. The demand in this area is pretty high and the supply is rather low. I only get recruited for large projects, and the pay goes with it. Also, I've recently gained some Python experience, and this has helped me show that I'm not "just a php developer". All I'm saying is my path has worked for me.
I'm not saying demand for developers is decreasing. What I am saying is that the number of developers is increasing. Therefore you have more supply than demand and that decreases pay.
In Manchester, not really. If you're paying you're juniors that in Manchester, great you're pay way over market average. Good stuff. :) Also if you're comparing a British wage to one on the continent or other countries you need to factor in cost of living and taxes. The average British salary is £24,000. And taxes are 0% for the first 11%, 20% on everything over that. Then another 20% on the amount over £43,000. And another 5% on any money over £150,000. I used to complain about the 40% tax bracket when I was in the UK. Now I miss the UK tax. (I've had far too many people complain about the UK salaries, when it was actually more money. It just sounded less because the difference in taxes)
Depends what company you're working for. 50,000-70,000 is the price range.
&gt; I'm "dicking" around on WordPress, but......why?
Sure, I also didn't say that I make six figures, I simply said that I get offers. 
Entry level PHP developers usually suck. This is why pay is low. The jump in pay the first few years is usually much higher when compared to the jumps other languages hand out.
If there was market saturation, they wouldn't be cold calling you. What I see happening is that the same lousy positions get picked up by recruiters who try to get a match and then hand it back. The great jobs are soon gone often before you even notice them, the lousy ones stay open and get seen by everyone. Cold calling old contacts is a recruiters last ditch attempt to find anyone at all for a function. The hot functions he is not going to bother calling someone he hasn't had contact with in years. 
Let me shamelessly give you this: https://www.youtube.com/watch?v=TUWB7cW8UTg and this: https://jobs.flixmobility.com/job/job-php-symfony2-developer-f-m-_3.aspx (sorry for the shitty job site ) shoot me a pm if you're interested
I think in general there's more language diversity and people have noticed it's easier to find talent among the many languages that aren't PHP. Generally if prices go down, the simplest conclusion would be that there's more supply than demand.
How do you know when you are a senior developer? In this explicit case, I mean PHP, what do you have to know?
Solid advice about Rocket. I wouldn't say Housing is messed up. Yes, there is gentrification, yes you may need to search a bit for a flat, but with a IT salary and job security, you won't have any real problems finding something.
It's a pretty common strategy, and you have toolsets like Apache Cordova and those build on top of it to just wrap up a webpage as a phone app. That said if it's really just sending 3 numbers, returning 1 calculated answer and storing it that's so simple you can make a pretty simple native app for all platforms to interact with your server pretty easily.
A language shouldn't force you to do anything. "Easier" is just a way of looking at this. You can write shitty code in any language.
Can you say which country you are in? I have a suspicion a lot of changes in salaries are quite specific to a country.
Possibly.. I tend not to read most of the framework stuff on /r/PHP because from my experience it's nothing but biased responses about what individual like better and leads no where.
Why is that?
Just because your cold call salary is going down, you think it's a global issue?
I experienced it the other way around. I, myself settled for systems, architecture, workflow design, quality assurance etc. With knowledge how to implement that, of course. Yet from what I hear through friends, former colleagues, contacts to hr and recruiting, people are willing to pay more for what they can actually see and understand. So a "frontend php developer" may actually get higher salary than the "backend /architecture guy".
Usually it's not mentioned that TDD is suitable only for specific types of projects. For example of you're writing a parser, this is ideal for TDD. You have the input, and the desired output before you start coding by default. Pure APIs also fit TDD, although depends on how much state the API holds. You'll need repository mocks or fixtures etc. But web controllers/templates don't fit TDD, and they are usually 80% of a typical semi-dynamic PHP website.
invalid doctype for 2001 ;)
Yeah it's basically that simple. I might add on more, my users always seem to have more ideas. Right now I have 3 calculators, so that would be 9 apps! I'd take this on, but I don't want to drop 2000 dollars on a Mac. Do you know what kind of problems I might run into? 
I think (but am unsure) you are thinking 1st world it'll be higher, I'm in South Africa and salaries are going through the roof
I wouldn't count on it. We'll still find a way. Where there are people, there is drama.
It's rather variable, but I'd say good indicators are that your code coverage is often above 80%, most of your code is Domain Driven so that it's not coupled to a Framework and you have a good grasp on how you'd plan a roadmap to refactor a legacy application to a more modern one. On top of that, a lot of Senior Developer skills are also (in my opinion) not quite related to the language itself. The ability to set and meet deadlines. To communicate effectively with managers, product owners, end users and so on. The knowledge to be able to research quickly in to new techniques and make recommendations on a large variety of situations. The ability to be able to effectively balance business value with developer concerns. Being able to see the big picture without it clouding your vision of what you're working on at that moment. Those are things that I would look for in a Senior Developer
I WAS AHEAD OF MY TIME, DAMMIT!
You're taking the quote out of context. &gt; There are more and more people getting into software development and there isn't as much of a demand as there used to be. What I'm saying is there are more people getting into software development and demand isn't growing like it used to be during say dot com, y2k, etc. Here is a great article by forbes that might clear things up for you http://www.forbes.com/sites/quora/2016/04/14/how-the-salaries-of-software-engineers-have-evolved-over-the-past-20-years/#486562021170
&gt; Monthly, in Euro? That's not bad. Not enough to be worth moving, but better than I expected in Berlin. Uh, that would be yearly. If that's a monthly salary, that's probably high for even CEO's. I'd say 55k pounds/y is about right for London
[removed]
I feel like this question is best answered after examining where the PHP framework ecosystem has a lot of duplicated work. I've been digging pretty deep into Slim and Laravel lately, so I'm not in the best position to answer that question. From my perspective, there are still plenty of framework-specific conventions that are *almost* interchangeable, but whether they should be standardized and the complexity of such standards are up for debate.
I get that, but don't see how it relates to your initial credible/pervasive argument.
Could be, we don't. I don't mind farming out my front end but my backend is too complicated for me to be comfortable to do that
&gt; Are we going to see more data analytics and machine learning libraries finally? I strongly doubt that, specially because PHP still lacks consistent advanced math operations and native functions. Working with statistics in PHP would be a nightmare as of right now.
Monthly, lol. 
Because the more pervasive it is, the easier &gt; Not just to write the code, but to hire people who already have experience coding against that interface instead of against the framework itself. It makes me more comfortable when I leave a project that's built against a standard because I know there's a greater chance that the next dev who picks it up will have worked in the manner that I'm working. is, and the more credible it is, the easier convincing people who need convincing to use it
Sorry, no. Backend stuff I want my guys here. Front end stuff we do and we're staffed 
No. Listen to Larry (this is always good advice, BTW).
Combination of MySQL Workbench and phpMyAdmin.
I'd agree with Larry that FIG has become the de facto PHP Standards Body as opposed to a framework-specific standards group. Perhaps it has evolved beyond its own name and PIG would be more appropriate.
I did some research on this subject, and if you have the knowledge (or you could learn) the best way too go imo is this way (considering you say you want to use a browser and not a native app): - first you build an API backend for your application (doesn't matter if it is in PHP, node or whatever, i personally use a PHP symfony API) - next you create a pure HTML frontend, using the API. (I prefer using angular 1 or 2 for this). Make sure you build this responsive so it will also look good for mobile. - next you can use your frontend as a website, but you should also be able to port this as your mobile application using apache cordova / phonegap to as a mobile application. The benefit of this setup is that you can update your application for both mobile and the website at the same time without having to manage two different projects. Note: you said you didn't want to buy an expensive mac to publish your iOS application, but you will need an OS X environment to be able as far as I know. The only solution I found so far, is running OS X in a virtual machine (for example virtualbox) on your current host (whether it is Linux, Windows, ...). Inside this machine you could run Xcode and do everything you need to do. - But the catch will still be that you are required to have a apple developer license in order to publish, which is paid by year and costs around $ 100 I believe.
Like the only thing that's wrong up there is that he started a session in his template... It's not that bad.
Does anyone else agree with the difference between a webdev and a programmer, or is that just a personal thing? 
Some Irony in "making sure your code is domain driven" sort of goes against the whole functional programming grain. Objects can very quickly make your application feel obfuscated via many intermediate abstraction layers just for 2 similar interfaces. When it comes to debugging it runs into a rabbithole trying to figure out wtf the library truely gets initialized within the deep abstractions. You could call someone "senior" but they're just Senior at obfuscating &amp; complecting their logic.
I hire by skill and attitude, not by degree. Salary is equally determined by that. Can only speak for my company/department though.
At my office we understand ourselves. Webdev would hate the work programmers do just like most programmers would hate doing the webdevs work. Some of them enjoy both though
Agreed. A re-branding along with the 3.0 workflow would be sufficient as a next step in evolution, in my opinion.
Thanks for the detail. I'll have some fun tonight 
&gt; If you're paying you're juniors that in Manchester, great you're pay way over market average. That still seems like a shockingly low number for a software developer. I'm aware that my perspective is biased as a resident of silicon valley, but am I right to assume that SWE roles aren't particularly respected in the UK? *Starting* salary here is ~$100k (~£70k) fresh out of school. Even in much cheaper parts of the US, $57k (£40k) for senior swe is... not great.
Part of this is that base web publishing platforms are so much easier to use out of the box. Plus local business starting out don't even need custom web page with facebook, linkedin, twitter. You can get an online store set up in minutes that just works it may not do custom logic, but if you need to sell things you have at least a dozen options that are reputable.
Where are you located and do you have remote employees?
&gt; the PHP job market There are two different markets, really. One, which I think you're describing, is "PHP developer" (can change some variables in a wordpress template). The other, which isn't really having issues, is "developer that will be working in PHP" (actual developer)
People hate WordPress because the code is a mess of spaghetti.
You're = You are. Your = ownership / belonging etc .... 
I have a weird experience. I've been a mid-level PHP dev for a while and recently took a job at one of those tech companies with the anytime beer fridge (3 actually) the Foosball / Table Tennis / Pool tables (all 3 again), free breakfasts, free coffee, free Friday lunch, beer o clock, an in house coffee shop (which is not free but is subsidised), and my biggest salary yet. It's double what I started my career on which was above average to begin. Here's the thing is though. I applied as a senior PHP developer, they took me on as a mid-level PHP (untested so I can understand) still gave me a good senior salary... and just as I arrived... they killed off their PHP projects. I'm still there doing JavaScript (React + Redux which I didn't know before I arrived), as well as helping progress infrastructure and CD pipelines using Docker and Jenkins. If I'd been pure PHP I don't think they'd have wanted me in the first place. Similarly a friend of mine recently applied for a python role and they asked me what else he knew. It seems to me, at least in this case, that knowing a wide range of things surrounding your main area, and being adaptable enough to transfer to completely new things is what the real value is, regardless of what your skill in a particular area is. TL;DR: PHP roles don't seem to be going down, but being a good programmer is better than being a good PHP programmer, even if you're only going to work in PHP. 
Well, I'm a back end. If you sponsor visas for employees abroad, then I can send a PM. 
We do not
damn that's too bad ;(
Do I work with you? ;) The company I work for has the exact same stack. PHP/JAVA takes care of API/REST and micro-services. Throw in an Angular front end or two and its about the same. Probably the only under thirty guy in my city that knows COBOL and works on the legacy system. Its almost impossible to find anyone with the skills (for the price of course). The funny thing is, the COBOL work has stood the test of time, so we are very hesitant to change to codebase without seriously thinking about alternatives.
In Spain you can break open the Cohibas and put your feet on the table if you get £30,000 as dev. If anyone asked me "Assuming Silicon Valley was full of BS, what would be the most damning sign?" I'd say "For all their 'creativity' they failed to tap the dev market overseas"
Yes, I was joking - the person asked for monthly, and got an answer of 50-70k.
To be fair that is true in some cases but if you have the choice you should never work in a company that does not understand what they hire you for. It leads to a lot of headaches. 
include( $_GET['page'] );
In my APIs I always implement a strict distinction between the user who has authenticated, and the user who is being mutated or queried by a given API call. IOW, "Hi, I'm Joe, change Jane's email", instead of "my email". It's always explicit whose user I'm messing with, no matter who am I. Then the relevant API can choose how to restrict this depending on ACL and roles. Seems... like a much simpler way of solving this issue than this whole impersonation dance.
Spoken like a troll.
What would make you switch to a new, previously unknown (to you) framework?
I actually had to work on a site back in 08 that uses that. They refused to let me change it, it's still there lol. 
[removed]
Using [Betteridge's law of headlines](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines), then the answer is clearly no. If people think that FIG has lost direction, then it's better to put it back on course than declare it lost.
Obvious advantages, usually which are easily seen through good documentation.
Any reason why that is?
A number of people just dont enjoy "business". We just want to make cool shit.
Yeah... Simply, people tend to "dick around" with easy tools, so SF would never be one o them. As told by others, Laravel is the target of the season for that reason IMHO, and WP will always be for the same..
&gt; PIG Agreed, but I think we need something better than PIG. Don't get me wrong, I like me some bacon, but I just think it sends the wrong message for a standards body. :P
We spend a lot of time brainstorming together and system is so big that it's super helpful to be able to scream: He joe can you come for a sec and walk me through this 
Thats fair enough. My concern is that as adults, we want to invest in a house for ourselves. At least in my country, this is extremely difficult, where all the webdev opportunities are in the big cities. Working remotely is becoming vital because of this, so I would encourage you to consider the possibility.
Or you can just approach a company with a proposal and give examples of your work. You dont NEED to brown nose.
That's sad!
thats helpful.
[removed]
I disagree with this. We had MANY situations where a bad template f*cked up everything for a customer and an emergency patch was needed. And the same certainly goes for controllers. But, get this. It's just php. And you can test it. And you should if you are writing serious software. TDD is about tests first, and sometimes it's insanely hard, that is true. And sometimes you just can't start with a test, or sometimes you know the architecture you are aiming for, because you've done it a 100 times. But that's the point of coding dojo. That's the point of exercise. If you've done weight lifting a 100 times, it doesn't mean that you won't get sloppy and out of shape if you stop doing weightlifting. There were also many situations for me, where I would have had the problem done in an hour, but testing complicated things, and it went on for half a day. But boy was I very happy, when I had to get back to that part of the project a month later and had no idea how it works until I read the tests. And boy was I happy when refactoring was a breeze or applying a patch was easy, since I just had to run the tests and that's all. I know, you aren't against testing in general probably, I get that. But writing a test, even a small skeleton -- with comments describing the test --, helps massively later on in designing the feature. Hey, maybe for the 101 time, you realise you've been doing it all wrong. :) Also, once it's done, it's usually fire and forget. And people don't come back to write tests to it later on.
It sucks but anywhere decent and available for a week is probably already booked for months. 
A beginners guide to cheap seo spam.
That's the reason I joined another company a few months ago. Well it was not the only reason, but payment and atmosphere were playing a huge part.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
"PIG", as in the official PHP standards committee, Agree'd. The only thing better than standardizing frameworks is the standardize the language. and as many a blogger has blogged about. php needs some official core language standards.
&gt; Compete with junior developers for leads. That's as an easy choice. It's easy to compete with junior developers when you're good.
I don't have a degree, I'm generally the highest paid person in IT.
&gt; When you pull user input from, say, a form to put it into a database, it's obviously important to validate the data for security purposes. What I'm having trouble understanding is, why would we sanitize it? The word "sanitization" should be eliminated from a programmer's dictionary as its very meaning is misleading about what should be done. PHP has a lot of lingo like this, because it was started by pragmatic amateurs, who more often than not invented wheels in the way things are done. Nothing wrong with that, but now we're past that. &gt; If you verify the information, why would you also sanitize it? What does sanitization do that validation can't? No, your hunch is right. Validate, don't "sanitize". "Sanitizing" data is like brushing dirt under the carpet. If you have no dirt, you have nothing to brush under the carpet. &gt; For example, you can sanitize an email address to remove invalid characters. But why wouldn't you just validate the email address in the first place and return an error message saying something like "Email must only contain valid characters?" Can't say anything again, except "yep, you're right" :-) Note that there are some transforms on input you should perform, even when validating, say, trimming whitespace on user-entered input fields, like name, address, or reformatting a CC number to a canonical format (say some users may enter dashes, some may not). But I call this "normalization" and "formatting input", not "sanitizing input", and its role is not security, but bringing data to a strict format from a less strict, but identical in meaning format (normalization doesn't alter the meaning of content, just its representation, while sanitizing instead filters input in often destructive ways).
A very good question. Many would benefit from a good answer. Hope the mods wouldn't discard it mindlessly as usual. &gt; it's obviously important to validate the data for security purposes. It is not. Validate your data for sake of the business logic, not security. Validation is non-obligatory measure. You may, or you may not validate your data. &gt; What I'm having trouble understanding is, why would we sanitize it? We wouldn't. "Sanitize" is too vague a term to be used. Call it *formatting* instead, and you will get your answer in that instant. Instead of "sanitization" you just have to properly format your data before use. For example, if you are going to use some variable in the SQL query, you have to format it, to make it usable with SQL. But the thing is, you are doing it not for whatever "security" but merely for the SQL consistency! [You're doing it not for Bobby Tables but for Sarah O'Hara](https://phpdelusions.net/sql_injection#whatis). While having security just as a side effect. This is why you are ought to use a **prepared statement** for the every query you run, not only for the data that you think "it have to be sanitized". - Besides, there are cases when validation won't offer you security. For an e-mail addres - yes, but what about a free-form text like this very comment I am writing here? Even being fully validated it still could be extremely dangerous, if not formatted properly before use. - Besides, whatever "all-embracing santization" you are having in mind just doesn't exist! Every chunk of data can be used in dozens of contexts - each requiring its own formatting rules. It's just impossible to "sanitize" your data to suit them all. You'll likely just spoil your data instead. this is why you should not sanitize your data but properly format before use. - Besides, **a good application is separated into multiple layers**. And one layer have no idea what happened in another. Imagine there is a database layer in your application that have to save a user information, and your app is not a spaghetti code stuffed in one file. How you suppose to tell a database layer, "this chunk of data has been validated, do not format it, while that chink is raw, so sanitize it". It will be highly inconvenient and wouldn't make sense at all.
I would use "escaping" rather than "sanitizing" when dealing with, let's say, HTML display for the end user (get rid of XSS, etc..). I would use "normalizing" or "formatting" when dealing with rewriting the value for, let's say, make sure a phone number is unique before sending it to the database for example (e.g. 0033 6 ... vs +33 6 ...)
I cringed at "do not validate for security purposes" -_-; Than people say php is not safe.
For those wondering, 50k gross is 2.5k net (after taxes and social insurances) per month, assuming you're single.
I agree, but there are a lot of inputs that do not "require" validation and people skip step 2 because of that as bad habit. For instance, count times when I was looking some code and people got pagination or page sizes and just put into the SQL totally trusting it from the request because they are not user inputs, but generated by the page ... People forget someone can *change* that.
To put the money into perspective. I rent a studio apartment with electricity and gas paid for 550 a month. So on 2,500 I have about 1,900 disposable cash. My rent is quite cheap, I know some people paying about 1,000 a month on rent, but that's really expensive. Eating out for lunch is about 10 euros, eating out for dinner is about 20 euros, a beer in a bar costs 3 euros. 
Don't worry guys as long as interest rates never go up the tech bubble won't pop. Eat drink and be merry. Vaporware for everyone.
So many juniors with so little skills... obviously they drive down the averages. If you are any good, your pay should be decent, and growing.
&gt; Have you had any luck integrating the bash.exe with Console2, cmder, etc? I've had luck integrating it with phpStorm! So the terminal tab in PhpStorm opened bash. But at the time I tried it, PhpStorm was in EAP and had a bug where it wouldn't see bash.exe, but if you copy-pasted bash.exe it could use the copy
That's a great steaming pile of horse manure!
For me in the UK the salary offers I'm getting are defiantly rising. The salaries for agency work does seem to be falling but I'm getting far more offers for 'in house' teams in corporate set-ups and these offers are inflating at a rapid pace. Many predict the death of the agency and from the offers I'm getting I can see this as the work seems to be shifting in house but with this the wages are increasing 
The general conclusion, from a significant proportion of my colleagues, that it had benefits to move to.
Validation is used to ensure values are correctly formatted. Sanitization is used to prevent code injection.
We offer remote working but only if the staff can attend the office at least a few times a week. Its not that we don't trust them and over the years we see most of our devs are actually more productive from home but we still need face to face meetings, training, brainstorming etc. So we allow remote working but you must be willing to travel on site, this seems to work best for us.
Pfft I'm using preact. Good luck with react 1.6mb file lol. Yes go he says. Haha
Yes we always try to hire programmers over 'web devs' purely because a programmer has a much deeper understanding of how languages and computers work rather than 'I can use function X in language Y'. A programmer is of much higher value to us because in general they can pick up any language and work away at it giving us much greater flexibility. PHP can't do everything and it certainly isn't the best choice in all situations.
Lol, ironic. Have you seen the wordpress code base?
The housing issue is EU wide in the main stream countries. The share volume of people entering Germany, France and here in the UK is on levels never seen before, the infrastructure here in the UK is on its knees, housing is rocketing because of the shortage, they simply can not build homes fast enough. We have a net migration of over 250,000 a year and we are only building around 120,000 new homes max each year. We are a tiny island in comparison to other EU nations and land available to build on is at a huge shortage.
No wonder it was cancelled! Surprised at the low amount of interest though.
&gt; Just wanted to add that there are definitely cases where you want to sanitize data. One example is logging or error reporting where you may want to make sure that certain request parameter (credentials, payment information, etc.) are not logged they way you received them. I better word for this would be "masking sensitive user data" or simply "removing sensitive user data". Sanitization is too broad and inaccurate as a term to describe what's being done for logs.
I've read your reply before you removed it: it contained some decent advice on focussing on learning general programming skills. I agree that learning that is harder than (hopefully) any framework!
&gt;For example? Go look up the magic methods supported by python. Almost every thing can be overloaded. Also look up python descriptors... &gt;Dynamic capabilities are not the cause of Python's performance, that's just an excuse. The reason Python is slow is because there's no one in the community with the right combination of will and skills who can improve the engine. Ok. 
What about trimming white-space characters or other junk being pasted in by accident?
Read my comment until the end... I mentioned that.
Pretty much anything. Toolchain, framework, tech stack, office environment controls, background music, amount of sleep, weather outside, comfiness of chair, choice of mouse/keyboard, day of the week, amount of alcohol consumed, lack of alcohol consumed, last nights dream, quality of coffee, how happy they are with their phone and what OS it runs, what OS the dev is working on, if they like the OS, if they like how their hair is styled. Really, you'll have to be more specific
Keyboard clickiness.
I'm personally most affected by whether I see a plausible big picture that my work fits into. The moment I feel I'm in a [death march](http://bit.ly/1P1qWuj), I cease any ability to code and I turn into a cucumber. No matter how hard I try to be productive, put a gun to my forehead, I can't do it. Conversely, give me a realistic (if daring) big picture and I won't sleep until the project is complete. It's a quirk I wish I didn't have, and yet, the fact that many people can go to work 9 to 5 without any care what their work sums up to does feel awkward to me.
A brain.
this is the only correct answer in this thread. holy shit what are these other people talking about? the saying goes "validate input, sanitize output" you never sanitize input.
Depends on the workplace...in our office only a handful of devs even drink coffee, and even then rarely have one at work.
Impossible!
The problem with these terms is that everyone is taking them differently. Hence the discussion. 
I don't think that Magento EE does them, but Oracle sure does: http://www.businessinsider.com/oracle-customer-explains-audit-threats-2015-9
&gt; The problem here is that valid data could be dangerous. &lt;script&gt;alert('Hacked')&lt;/script&gt; is valid comment for this thread, but obviously dangerous if not formatted properly. It is not clear from your answer, whether or where this formatting should occur. I answered here: https://www.reddit.com/r/PHP/comments/4x0yvj/basic_question_about_sanitization_vs_validation/d6bjzy8
I work in the middle of our dispatch center [so pretty much constant distractions]... I get literally nothing accomplished.
This!
&gt; While to me, the situation is quite opposite: the list of validation rules is undetermined, and therefore quite useless for security purposes. While formatting rules are simple and determined, and thus plausible for the real life use. They're both determined. Validation makes sure input is aligned with the domain model schema (which is quite determined, or at least I hope yours is). And output encoding makes sure the data is expressed in whatever language you're producing the output in (SQL, HTML, etc.). It's not a one-or-the-other situation. It's both, and for different purposes, neither of which is strictly "security", but should be done in order to be secure.
you would escape input, though. preventing SQL injection for example.
Ok, I'll put it in other words: validation is not determined in security terms, because it's business logic domain, irrelevant to security. And therefore should be taken off the discussion, while a stress have to be made on formatting instead. And your answer makes a contrary impression, "validation is required, while formatting[sanitization], once data gets validated, is not". Or it's just me.
I second this. Any distraction can set me off track and I can't get back on for another 10 min. The exception is when I'm stuck on something I can walk away for a few minutes and a solution will pop into my head that I couldn't see while staring at the wall of code.
Motivation.
How much focus is solely on making the company money with no progression and/or learning time for the developer. If they aren't getting anything out of their job, why would they put anything more than the bare minimum of effort in?
You see, it's mostly a terminological discussion, and it is sad. Many won't agree with you though. It is the same output as with HTML: you are outputting your data in SQL, you are outputting your data into HTML. See the resemblance? While escaping input to prevent an SQL injection you'll end up with one.
nobody mentioned that yet: meeting overhead ... especially people with 2-week sprints in a scrum environment tend to waste too much time on meetings. Communication is important, but not if 30h from the 80 possible working hours a 2-week sprint has are speend on meetings
I would like to stress that input validation is _also_ a security measure (i.e. too long input may drop the SQL query and thus render a logging query off). It's just hardly never alone enough (security-wise speaking).
Seems pretty fragile and complicated to me. Why not use the API, it's just a few lines of code? http://stackoverflow.com/a/30830220
This is very likely.
So much. Had a gig where morning standups required us to sit down...
Uh what?
All non-PHP things really. The biggest is the lack of a quiet environment though.
that made me giggle
Open floor plans don't help.
Hi there. Thanks! In regards to specific unit tests. I believe I said "focused" on Unit Testing not "specific". Maybe in future I should be more clear. Thanks for the feedback. Btw, I also thought it was a good video. Didn't expect to only have 1 upvote lol.
Yes... it is... I can't even do headphones cause the asshats just yell at me to get my attention to talk about nothing
Either way I changed the script to use preg_match_all. For this simple solution I don't see performance being an issue. Thanks for the tip.
The codebase. If it's old, legacy and written to use globals with little use of functions, other than a container for manipulating global state.. you're going to have a bad time. 
Thats a pretty useless metric of 'popularity of PHP'. Any decent programmer should know some statistics, and that certainly doesn't reflect knowledge of the area.
What do you think about Skype conferences, etc?
Given a phone number input, let's say the user enters `(321) 678-945`, that is valid, but you don't want to store the number like that, you want to clean or "sanitize" is to `321678945`, so that all user input is the same in the DB. My biggest pet peeve is what I consider "user enforced sanitization", i.e. a credit card number or phone input form that requires no hypens or spaces, so that the receiving code doesn't have to do any work and can just shove it in the db unchanged.
I'm a loud typer who slams the keys on the keyboard to assert dominance over the computer. When I'm in the zone it gets really clackity. What annoys me the most is a keyboard that makes a bad noise, like my Mac at work has a squeaky right shift key. My Yoga is perfect though and has handled the abuse.
lolz. I think this is a very general factor :D
Sounds good. Keyboard noise can be controlled by using better ones i think :)
Don't worry! I appreciate your comment. Yes, we don't offer compensation, but we expect the person who'd join us not be extremely experienced and to want to gain some experience.
I am not sure PHPBB would be the best way to learn anything. Unless it's community moved really fast in the last 5 years. What you want are hobbyists, not professionnal dev or juniors that wants to involve. Those have better ways to do so in my mind. Then again, do you work with github (don't give the repo here, yes/no is fine), svn, gitlab, something, or just send zip all over the place ? How do you expect working together ? Support ? Specific tasks you will give to the newbie / skills you need ? If you want to be taken seriously, don't ask what you want vaguely, but give precisions about what a potential dev would need to know before accepting. Open source ? otherwise I can't show any code in a job offer. I don't like to be judged on my design capacities (or my teammate's) when I apply for a PHP job.... So far, only redflags * No mention of version control * it seems you are all only hobbyist * PHPBB * No compensation * A forum like so many others * pretty unclear goal of the website... list of features ? * timeline ? deadlines ? * marketing experience but you don't know how to sell your project... (ok I troll a bit here... but not completely) Time to rewrite your offer/pitch.
Can't believe no one's said this yet, but having a decently powerful computer. At any one time I'm running a couple of VMs, PHPStorm, MySQL Workbench, SourceTree, Chrome with half a dozen tabs, and (ugh) IBM Notes. The one thing that has boosted my productivity over the last few months is my company paying for a new MacBook Pro with all the upgrades.
Your comment does not make any sense. Try to clarify if you actually have a point...
A big factor for me is doing something interesting. If I'm piecing together a generic website that is almost identical to another generic website, it is so hard to get motivated to chug through it. I've found that once all of the fun planning/problem solving is done on the project I have a limited window to finish up the boring stuff before I lose complete interest and I'm forced to pull out the mind games and productivity tricks just to make it through the day.
Ever heard of google?
The general consensus in that thread is that OP was wrong about decreasing salaries.
Well, the vulnerability lies there: &gt;that do not "require" validation If it can be changed by the user, it *does* require validation. Not (or not only, depending on the level of abstraction you are looking at (compare: "bigger scheme of things")) because of security, but because of correctness!
I hate this so much, SO much. I've always allowed my users to enter their information in unrestrictive ways, and did the validation and sanitization myself. 
Pointless meetings.
Imagine if someone showed up at a gathering of artists telling them to stop painting, sculpting and creating music, because it's full of art out there that can be deemed similar to theirs. They'd be laughed out of the room. This is how we should treat the "can't you just, like, stop making things" crowd as well.
Don't reinvent the wheel! Besides, this is too simple, I could understand it under 10 minutes, a real professional would build something that requires at least a year of training... puff ... 
/u/clickclickboo [gets us](https://www.reddit.com/r/PHP/comments/4x3h4h/simple_php_easy_plus_now_this_is_how_you_do/)
Left my previous job cause of this
They were every morning. Luckily I am not there anymore.
Haha. So a client says "thanks for giving me an image upload. But I don't like don't an image at a time ..." Fix It. While not a great example I'm simply saying you can shoot for completing a task, only to get sucked into amending or maintaining a library :(
Happy Cake day :) Sadly they pay well and don't seem to care that I don't do anything...
 &lt;?php // Architecture(tm) try { runComplexApplication(); } catch ($e) { http_response_code(404); die('404'); }
Look at what they labelled you as strong in: - Form Processing in PHP - Encryption and Graphics with PHP - PHP Arrays and Array Functions - PHP Operators and Expressions - PHP Objects Who cares about "PHP with Other Technologies" and "File Handling with PHP"? Shrug it off, mate. You are doing fine for a 1-year PHP programmer. The only part I'd be concerned with is perhaps the PHP Control Structures section.
IIRC Apple revolutionized so hard the concept of a "smart phone" in 2007 was downgraded to the term "Feature Phone" and the boys at Google went back to the drawing board while creating the yet unreleased Android OS.
[LMAO](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition)
[And this](https://gist.github.com/lolzballs/2152bc0f31ee0286b722)
Wow that is some top-quality stuff right there. I will probably spend my entire day tomorrow to hack into this and add support for subtraction
Missing a dependency injector.
&gt; echo "hello world"; Too complex. Hello world would be enough with php.
I know you didn't take code from the private codebase of my employer, but damn, those lines look straight out of the version 1 of the API I'm refactoring. *sigh*
Then you may want to check https://github.com/pinepain/php-ref-lib which provides WeakMap implementations (WeakKeyMap, WeakValueMap and WeakKeyValueMap). I recently updated it to work with latest php-ref version and now it should work like a charm. 
&gt; If two pieces of software provide basically identical features then yes, they should be basically fungible. I suppose you wouldn't mind if I switch your Linux distro then, or swap it for a copy of Windows 10. Bullet points are not the only thing that matters. Execution and quality matter as well. Overall philosophy and approach, also. &gt; We're talking about things like people making the same framework again and again with little or, more often, nothing new. No, we're not. You are. The thread is about creating new frameworks and libraries in general. 
&gt; A company that asks you to take a test but then doesn't offer to pay for it... I would not work for them that is very sleezy. Agreed, particularly because this is definitely not an industry standard test.
I do use file handling and globals rather extensively outside of packages. I do find that packages are nice shortcuts, but I feel you actually have to know about what those packages do before you implement them, and sometimes packages don't have use cases for certain conditions. That is the only excuse for using that on a test. However, I also don't like static tests (or whiteboard tests for that matter) to help a hiring manager identify someone's competency level in a language. They essentially exist to try and disqualify a candidate for a position (whether intentional or not), as the candidate's credentials (with, maybe a small code sample) should be enough to determine the team/leads want to work with the candidate or not.
I think it's a fair description.
&gt; Are we just afraid of new ideas No, just tired of junior devs going "well, I could spend an hour to adopt this battle-tested, high performance library into my codebase, OR I could spend 12 hours re-implementing it badly from scratch!". This is especially true when people post stuff that's intended to be "simpler" than the existing solutions, but achieve this simplicity by sacrificing significant performance, security, or the ability to handle very common scenarios. Occasionally (rarely!) that sacrifice is worthwhile; more commonly I'm reminded of GK Chesterton's parable about a fence: &gt; There exists in such a case a certain institution or law; let us say, for the sake of simplicity, a fence or gate erected across a road. The more modern type of reformer goes gaily up to it and says, “I don’t see the use of this; let us clear it away.” To which the more intelligent type of reformer will do well to answer: “If you don’t see the use of it, I certainly won’t let you clear it away. Go away and think. Then, when you can come back and tell me that you do see the use of it, I may allow you to destroy it. If you don't understand why the existing libraries look like they do, then I have no interest in the code you're going to produce to replace them. On the other hand, if you have a deep understanding of the current ORM/datamapper/DB abstraction libraries, and you think you see a way to improve it, I'm going to give your ideas a respectful hearing. It's just, you know, 99% of the "look at my new library" posts obviously fall into the former category rather than the latter. :) Edit: As a corollary, the most important part of an announcement of a new library or tool is the listing of all the ways it's worse than the existing solutions. If you omit that (either out of hubris or ignorance) then yeah, you're going to get mocked a bit and told to stop reinventing the wheel, because you've spent time on something no one is realistically going to be able to use. If you include it, then 1) I'll be able to figure out if your library is useful to me and 2) even if it isn't, I'm not going to criticise you, because I know it'll be useful to someone, even if not me.
&gt; I mean this isn't unique to PHP at all: Javascript is plenty infamous for it now and in the past plenty of other similar situations have existed. That's because like PHP, JavaScript is popular. When you see people stop creating tons of libraries for a platform (similar or unique, doesn't matter), that's how you know its days are numbered. Unique inventions rarely happen at once, if you look close enough. They evolve little by little, through iteration and "reinventing the wheel". It's also how life happens. There are plenty of people in this world, which are "fungible", but somehow people keep making more people, go figure. In any case, just like you don't get to say who will paint and compose music, you don't get to say who gets to publish code. If you don't want to use it - don't. Problem solved.
Bringing AngularJS or React into this to get some kind of Ajax driven user input. How du you expect to interact with it. Don't forget to bring some kind of server as well
That's not true, the features are not everything, the way it is coded, the API, the performance, the trust you put into the developer behind the code, all of that makes a big difference. You are basically saying that every Bach symphony is the same thing, whatever the orchestra interpreting it, but that's not true, and interpretation changes a lot of stuff. The same applies to code, and writing your own framework is fun, creative, interesting and some people will prefer using it because it suits their taste better, and why should that be wrong?
&gt;That's because like PHP, JavaScript is popular. When you see people stop creating tons of libraries for a platform (similar or unique, doesn't matter), that's how you know its days are numbered. That doesn't make the millions of clones any more or less redundant. &gt;Unique inventions rarely happen at once, if you look close enough. They evolve little by little, through iteration and "reinventing the wheel". Yes, but rehashing the same old MVC framework isn't evolution, its repetition. The fact so many repetitions exist is why people are so quick to demand a justification for the framework being written.
If you're in the south-east, there's no such risk. The amount of work in London is ridiculous, and proper software development at that.
[removed]
I'm using Java 8 from this ppa (used it for years): https://launchpad.net/~webupd8team/+archive/ubuntu/java Everything works fine, including anti-aliasing.
Honestly, it doesn't matter what you write. Do as you please. The caveat in all that is that once you *publish* your work and/or ask for comments you will invariably receive hate mail unless it is a stunning piece of work. We all learn by doing, and some of us have a great deal more learning time than others. One of the best ways to learn is by *mimicking*. If you look closely at some published works you'll find that a little to a lot of the content is mundane code - nothing special and nothing that makes it any better than any other bit of mundane code. But what enterprise people want is something that has gone through a lot of wringers - including code auditing and an (expensive) security audit. Be assured that there is quite a bit of code out there that has has seen little to no outside auditing. And, unfortunately, there are quite a few people who seem to enjoy slapping a new hopeful in the face rather than being civilized about it. They seem to think that a good beating is preferable to a simple explanation, or that *their* time is too valuable to be wasted looking at your stuff. (Why such people don't just walk away is beyond me. Maybe it's a crusade or something.) No one owns you but yourself, and the same goes for whatever code you write on your own. Feel free. Experiment. Make a couple of apps with it. But in the end, it's very hard to break into the pedantic boys and girls club of people invested in ridiculing their way to smug satisfaction - even when they are right.
Not sure why you got downvoted. This is true. Android before the iPhone reveal was a BlackBerry clone. And everyone else followed suit and copied Apple.
Yup yup. I've never even owned an iPhone, Android 4 Lyfe. But have to be honest about the history.
&gt; this is the case on most solutions the difference is that in magento you have mostly developers while in the competitors you have mostly guys who learned to play around with the CMS I'd be interested to see some statistical backing to this statement. It seems speculative. 
The company where I work offer a similar kind of "enterprise" license (but in the context of government website software). These decisions (about who's fault it is) are always decided by whoever in the company is responsible for the client. Unless it's clearly a security fix or a fix for behaviour that is a departure from the original statement of work. That is, most of the time it is subjective. The clients benefit by making these arrangements with companies that place client satisfaction above the desire for profit. 
One of my friends worked for IBM Global Services on a bank contract for a few years (I think it was IBT, you can look them up). They have similar SLAs, which makes sense considering that certain systems could cause millions of dollars of loss *each second* when unavailable. The way IBM handled that was with aggressive shift management and very disciplined on-call policies. To attempt to balance the impact to certain key folks, they just paid extremely well. I'm not saying that burn-out doesn't happen, but it wasn't like everyone was working regular 80-hour weeks, either. At least, not when things were all running correctly. I'm struggling to remember who it was who had the two-hour SLA, but I'm pretty sure it was Hitachi, on a high-end storage system. If you've been in the industry for long enough you know that failures in these types of complex and often mission-critical systems can cost companies millions, or even cause them to fail completely. Such an SLA is only offered because the competition is so stiff and the demand is so high. Even two hours is an unthinkable amount of time for, say, Uber to completely lose its ability to serve its app users (drivers, especially). You can hire the best team in the world and still be caught with your pants down if your whole compute stack is built on hardware from a vendor that can't get replacement parts fast. I've got plenty of stories about that kind of stuff too.
I 100% agree that after a year this OP should be happy with his score esp if PHP is his first and only language. I think what the OP is saying is that if you or me want to see the test we would have to pay. I believe the company paid the for the OP to take it.
&gt; The way IBM handled that was with aggressive shift management and very disciplined on-call policies. To attempt to balance the impact to certain key folks, they just paid extremely well. This is a sensible way to handle things. I don't imagine many companies would go to such extremes to protect the health of their employees; in proportion to the number of companies who would make these claims without any consideration for their employees.
Well, it's IBM... Big reputation, big money on the table. It probably hinges quite a bit upon the uniqueness of the job. If you're Hitachi and you need to offer 24/7/365 support for a hardware product that nobody else in the world actually fully understands, you'd better treat your people well because you paid many thousands of dollars to teach them how to do what they do, and training up a replacement puts a wrench in the works for some time. I imagine that they manage to attrition very closely. For folks who do 24/7/365 datacenter NOC support or whatever, where it's general purpose networking or hands-and-feet support, you're basically replaceable; maybe you're a high-earner, but you're still replaceable, and quickly.
Because it will keep me in employed at the same company for 30 years. I'll also get to see the same colleagues every day because the company is too afraid to promote me out of my current position in case they can't find a replacement at the salary they're paying now.
cough... Lumen. cough... Silex...
For those who haven't seen it yet, http://vanilla-js.com is a similar type of joke.
yes but if $firstNumber and $secondNumber are strings, what will that output? I don't have time to remember a million rules. I think this library solves this issue. 
This doesn't scale though, it will never go beyond 2 ;)
http://stackoverflow.com/a/10885673 For the xing out you'll need to use Javascript to manipulate the CSS. Maybe consider bootstrap. 
Hey just a heads up - the /addons directory is for your project addons. All the core addons are in /core ^_^
Hahahhahahahahhaha I'm rolling &gt;even when they get ddos
Demo and build download tar / zip coming soon with the release of the store!
[And this: SimplePHPEasyPlus](https://github.com/Herzult/SimplePHPEasyPlus)
To me, validation and sanitization mean very different things. Validation is when you require a very structured format for your inputs. Email addresses or dates, for instance. In those cases, you should not sanitize the input. Just reject it outright if it doesn't match your requirements. Sanitization, on the other hand, is when you accept arbitrary inputs. A comment on your blog post or a description of yourself on your social media profile. You basically clean the text that is posted to you to make it safe to store in your database and avoid XSS vulnerabilities where bad actors will try to exploit your site by putting Javascript or whatever in there that gets stored in your DB and then gets executed when your site renders the content (ie. displaying your comment to other visitors etc).
[JavaScript is DOOOMED!!!](https://www.google.com/trends/explore?date=all&amp;q=javascript)
Just turn it on and it scales right up
God, why do all these people have access to a PC?! Just use XPath query on the document contents to extract tags you need. `'//meta[@itemprop]'` will find all the meta tags as a nice DomNodeList of DomElements. Also use Xpath to fetch views `'//*[@class="watch-view-count"]'`and likes `'//*[contains(@class, "like-button-renderer")]//button//text()'`. This code is much less brittle and the queries can be easily modified. Finally, the proper way to get likes is the API, which returns a pretty json for any video: "statistics": { "viewCount": "100812", "likeCount": "2008", "dislikeCount": "57", "favoriteCount": "0", "commentCount": "778" } 
Today it has no meaning at all. This is a contemporary witness of PHP-6 when Unicode was a thing. You find more information on an archived version of [is_binary()](https://web.archive.org/web/20090403051843/http://us2.php.net/manual/en/function.is-binary.php). The [PHP language specification](https://github.com/php/php-langspec/blob/master/spec/09-lexical-structure.md) is still very optimistic about that: &gt; The optional b-prefix is reserved for future use in dealing with so-called binary strings. For now, a single-quoted-string-literal with a b-prefix is equivalent to one without. This syntax was introduced in PHP-5, before they knew that PHP-6 will be dropped. It has to stay because of BC.
WHOOOSH!!! That is the sound of the joke flying right over your head.
Why do you have them? Why do they pointless?
Op is deliberately lying to make his case. His lie? He says people are being discouraged to build anything new when they are being told not to re-invent the wheel. But re-inventing the wheel is NOT building something new. Building the space shuttle was building something new and they did not re-invent the wheel while doing it. It is a trap I have often fallen into, I want to build some project and get totally distracted by re-inventing a new model design and never get to the point of building the actual project I wanted to build. It is like wanting to build a new house and get distracted on re-inventing the nail. Now a new joining method, that is fine, go right ahead. Perfecting the nail, go right ahead but I find that if I am just redoing something that has already been done, I am wasting my time. And that is what often happens with tom, dick and harry frameworks. They waste their time building something that already exists and that is not building something new. Build the next facebook, not another facebook. You can read announcements quite often on this subreddit: Hi guys, I build a new framework. Then people ask "how do I do X" and the answer is "well, I haven't coded anything for that yet". And then the reply is "Oh, well, then it is useless". Go ahead build yet another variation of the wheel, don't expect many takers if making it roll is still on the todo list. I have had to force myself to stop trying to re-invent the wheel on my personal projects and just use what the framework gives me and my productivity on personal projects has sky-rocketed. I am actually writing the code that matters to my project. To often people insist they should be praised for releasing something that is just different for the sake of being different while being incomplete, has no documentation and an attitude towards bug solving that is actively hostile. 
Even further clarification, but a very important one: not for MySQL[database], as many would take it, but for **SQL string literal**, which makes a HUGE difference. I am sure you know the difference, yet the phrasing is very important. Too many people are still under the delusion that mysqli_real_escape_string()'s purpose is to protect their MySQL database from injection.
validation -- make sure input is valid based on rules sanitation -- make sure values are clean/scrubbed based on criteria before accepting them yes, they can overlap.
They are okay through the week but it still can't beat being face to face. We use a mumble room that everyone is in (separate channels) so if someone needs to talk things over they can do instantly.
True, I'm in the North West and there is work (Manchester area is booming at the moment), I get offers a few times a week but its the overall risk of not having a steady income. I didn't use to care if I went a few months without work but my opinion changed once I had dependants 
Your comparisons make no sense when relating to the PHP world. People keep reinventing routers, validation classes... and what ever else without producing anything better like in your examples. PHP is reaching a maturity now where it has a solid ecosystem of well produced, well tested, well maintained code. I have yet to see a newly produced framework that offers anything better than the current crop of big players, the thing is, in the PHP world, the next 'Telas' or next 'Google Maps' isn't happening. The things people are reproducing are worse than whats currently out there and at best the same.
[Everything is a remix](http://everythingisaremix.info/)
&gt; There is the Youtube API using json too but this is so simple I thought might help I can't work out if you're trolling us or this is a genuine post? What could be easier than getting a JSON array back via the official API?
You were 6 marks off being in the Top category. Keep doing what you're doing and don't worry about it. 
Just use PHP7, it solves *all* performance problems!
&gt;This is especially true when people post stuff that's intended to be "simpler" than the existing solutions Yeah, better take a 2000+ files complicated 3rd-party repositories full-featured framework suite with a minimum of 17 dependencies instead of writing your own single-file class with 3 functions and a total of 200 lines of code.
Re-invent if needed.
Sure, those numbers are totally realistic and not a strawman at all. Most 2000+ file projects can easily be replaced by 200 lines of code, if not less. &gt; with 3 functions and a total of 200 lines of code Not to mention, as an added bonus, an unknown number of security vulnerabilities and performance gotchas just waiting to be found. Score! Where do I sign up?
 &lt;?='' ... is a valid PHP script.
&gt; I see your point, but at some point it's just semantics. In programming everything is just semantics.
I think we'll need a bit more information if you want an answer with any real substance. What kind of tests are you wanting to perform? Typically PHPUnit is the place to start, but if you're wanting to also test AJAX in the browser you'll likely need some form of Selenium based suite. 
I am building a PHP based website with its frontend utilizing ajax processes. I am now looking for best practices on to automate testing for the project
Testing of *what* though? Front end functionality? Back end functionality? Load times? What components need to be tested and why does that testing need to be automated? The answers of PHPUnit and Selenium can cover just about everything. It's hard to get more granular without more information. 
 If you want to test API's, perhaps BDD is the way to go? Try Behat
Thanks for the help, i was able to finish this and other relatable things with Ajax, really appreciate the help that you guys gave me.
Yeah, you can never have enough abstraction, because you can never know how implementations might change in the future. Many developers learned that the hard way from having lots of calls of `htmlspecialchars` without specifying the `$encoding` parameter. &gt; 5.6.0 The default value for the encoding parameter was changed to be the value of the default_charset configuration option. &gt; &gt; 5.4.0 The default value for the encoding parameter was changed to UTF-8. Don’t get me started about the `mysql_*` functions.
Probably an over-simplification, but Sanitize = try_to_make_this() Validate = is_this_already() 
&gt; Also consider rewriting your tests with PHPUnit; it's the most prolific way of writing tests. While suggesting that the package is put on Packagist is common sense, PHPUnit is simply pushing personal preferences under the guise of "best practices". Saying PHPUnit is "most prolific" is entirely subjective. I find it extremely verbose and counter-productive. And coverage is provided by Xdebug, not PHPUnit. PHPUnit merely uses Xdebug data.
 * Escaping is a type of sanitization * normalizing is a type of formatting, which may be a part of sanitization in some contexts * Database constraints are not a form of sanitization! Sanitization is basically making something `safer` within a domain. It's not the same as neutralisation, doesn't predicate formatting (what if you have the right format already), but can. 
&gt; Escaping is a type of sanitization Escaping leads to converting one set of characters to another set of characters (typically by prepending an escape character before special symbols). "Sanitization" implies removal of data. Nothing gets *removed* during escaping. &gt; normalizing is a type of formatting, which may be a part of sanitization in some contexts Ok, so everything is sanitization, but it's contextual, like based on the alignment of the planets... &gt; Database constraints are not a form of sanitization! ... except this. I think this is why using more specific terms is preferable. Your choice of what's "sanitization" is entirely arbitrary, and it's the same with everyone who I've seen mention that word. It's best to call things what they are. When you encode, you encode. When you validate, you validate. When you normalize, you normalize. 
I would also add that senior dev needs to known most used Design Patterns, and knows when to apply which one.
There are tons of tools that produce nice reports out of Xdebug data. As for the value of seeing *which test* hits which lines, I find the value of this dubious. Likewise about "CRAP" scores and so on. It's important to keep in perspective why we do tests and what the goals of testing are. I only need to see lines that aren't covered by any test (to which my response would be to write a test, or extend an existing one).
&gt; Opis String As a German I have to smile a little ...
I work with joomla as a developer making around $15 an hour. I also hand-code my own PHP applications from scratch, but have yet to find a job requiring a programmer. Everyone seems to love the pre-built packages.
In my production environment I sometimes (although not always) need to add *three numbers*, so I'll wait until this is ready for prime time. Real potential here though.
Your "better way" is actually the "worst way", though I will grant you that the current common way of doing things (single, monolithic entity class for each entity) is also a "very bad way". The "better way" is actually to create classes that solve problems, and stop trying to maintain a useless 1:1 class:entity mapping. There is absolutely no reason to pull and hydrate an entire "Contact" class, and its dozens of datums just so you can generate a simple name/phone # list. Rather, your repositories should be tailored to your application's needs here, and should return whatever class best fits the context (perhaps a `SummaryContact` in this example). Ditching your code contracts is virtually **never** the right answer to any architectural question.
So does that mean people should stop trying? The auto industry had companies like Daewoo before Tesla came along. Just because many have failed to produce anything revolutionary, doesn't mean people should stop trying. And who knows? Maybe those crappy routers and frameworks are people's first attempts at open source PHP projects. Hopefully they'll take what they've learned, continue to improve, and someday release something truly remarkable :)
https://www.google.com/trends/explore?date=all&amp;q=javascript,php,python Just... stop posting links to Google Trends, ok?
I often wonder this, but I have yet to switch over to arrays over dumb objects, or even public properties on an object. I have a couple reasons for this: 1. As you stated, you created a defined contract for the object. Any developer will know what properties are available as well as their return types with out having to find where the object is built. Think of it as: does this project is `created_at` or `created_on`? In this array is it a string or is it a \DateTime object. 2. Allows future proofing. In the example we have a `Note`. Lets say there was an expiration date for the note and notes that are expired aren't visible. You could add a method `isVisible` to the note based on the current time compared with the expiration date. Later, you decide to add the ability to delete a note, deleted notes aren't visible. You only need to update your isVisible method and it's updated everywhere. Obviously you could have this in your `NoteService::isVisible(array $note): boolean` method, but why not just use an object. In regards to your first two points, I don't write getters &amp; setters till I need them and generally force constructor injection. That being said, my IDE creates all the getters and setters for me in about 1/2 a second. So creation isn't a huge deal, code bloat is true but as I said, don't create the getters/setters till you need them. As for array deserialization, well there are classes for that. If you're interested in any I suggest (Zend's Hydrator)[https://framework.zend.com/manual/2.4/en/modules/zend.stdlib.hydrator.html]. It's really flexible, thoug you can easily add a factory function on your object that takes an array. I often wonder about what doctrine consider's partial objects. I think it's an interesting problem. Like you said, partial objects are nice because I may only want a subset of the data and partially empty model classes are obnoxious. I almost always think it's better to go with the full data. You'll lose a lot of SQL benefits like index only scans. But you maybe able to take advantage of a more robust caching layer. Assuming you have two code paths that both need different portions of the Note data, each path is used on subsequent separate requests. You'll have to make 2 queries for the partial object. Or you can make 1 query for the full object and 1 cached look up. This is specific to your code and can be achieved with arrays. But I'm using this as a point for always having a full object hydration rather than partial object hydration. Not trying to say you're wrong. I've wrestled with the ideas you're bringing up and these are my reasons for not using arrays.
After reading the code a few minutes (to a few hours) and reading the documentation about architecture and design, I'd definitely test it for fun ; But using it for business reasons, I'd like the community to be active, and the product mature (more than 3 years of existence, at the very least, and 3 years is very young...).
No of course not, its also the best way to learn. Just stop bloody publishing the pure and utter shite that you dream up that is no help to anyone and at worst a noobie picks said library or framework up and produces crap code with major security flaws 
It looks like a bad example of reinventing the wheel because [Stringy](https://github.com/danielstjules/Stringy) exists already and looks popular. And what's the point of not depending on mbstring? &lt;-- that's the honest question from php newbie
This is funny, but numeric calculations can get complex, if you want to do them correctly. Floating point issues, truncation, overflows are difficult to deal with. Databases seem to do better math than PHP. If speed is not an issue and accuracy is needed, it might be a strategy to do calculations on the database rather than in code. 
But the few thats out there ... remember : Don't re-invent the wheel :P Hahaha.
I feel this is also what internet trolling is all about.
No offense but if the dependency doesn't follow semver even using carot isn't going to help.
why cripple yourself with a lackluster coding experience? https://netbeans.org/downloads/ https://www.jetbrains.com/phpstorm/
Maybe because people can make their own choices about what type of environment they want to develop in? Don't be an asshole.
I'm not being an asshole. I'm legitimately confused as to the benefits of using a text editor as opposed to an IDE with everything built in...a 2 second faster startup time doesn't seem like a good trade off to me.
While it does not seem to be a common pattern, Doctrine does allow you to create multiple entity managers each of which can have their own unique entities. So if your application has multiples domains and, within a domain, you want entities to contain only specific domain related properties, then you can do so. However, given that most php apps are pretty much crud oriented (which is not a bad thing) you don't see the multiple entity managers technique used much.
just saying its good isn't an answer to my question. WHY is it better than an IDE with plugins built in, more functionality built it, and better project management built in? I know you can download plugins but they aren't that great...plus you're going to spend an entire day setting them up? god knows how long tweaking them. Who even knows if the plugins still work since a lot of them are never updated in a timely manner?
Good as in "I need to open text, any text, right now". 
&gt; So basically what you're saying is that with PHP you'll have the hash-map penalty anyway. And you are wrong with this one. I just tried a simple benchmark with a class with a defined public property vs a dynamic array and it was way faster. It was way faster... to do what exactly? We're talking benchmarks, you know how easy it is to make a wrong one, and your statement is so vague, it's almost a parody of itself. Keep in mind a real world scenario involves having the array, then having to deserialize it to an object... and then having to serialize it back to an array, say for persistence. But we can skip that, and just talk initializing objects with custom runtime data, if you will. I've also done my homework.
&gt; Your "better way" is actually the "worst way" Ok, but then you say... &gt; The "better way" is actually to create classes that solve problems, and stop trying to maintain a useless 1:1 class:entity mapping. That's indeed what I proposed, when I said "multiple representations". Still there would be some aggregate root for a set of entities (often not just *one* entity type, hence no 1:1 relationship), because if you don't split things in aggregate roots, then at some point you end up with a big spaghetti ball of interdependent code. So is it 1:1 or 1:2 or 1:3, still the same idea. &gt; Ditching your code contracts is virtually never the right answer to any architectural question. I'm not ditching any contracts, I simply move the place of enforcement to the collection (instead of the representation instances). So your objection is a red herring, I'm afraid.
so can notepad. doesn't mean its good.
The post was about dependencies that *do* follow SemVer, so it's unclear who/what you're responding to.
no but you didnt answer my question yet lol. for php programming specifically. yeah if you need to change two lines of code i would use notepad too but im talking about full projects which is what I assume OP was talking about since he wants every plugin.
The ~~only~~ **right** way you could iterate through all characters of a string. No mb_string. Fast. $unicodeTestString = '♜♞♝Дворцов;τελευταῖόν σεकमपरमवशं न不亦說乎ஸ்றீனிவாஸ'; $codepoints = IntlBreakIterator::createCodePointInstance(); $codepoints-&gt;setText($unicodeTestString); while (-1 !== $codepoints-&gt;next()) echo IntlChar::chr($codepoints-&gt;getLastCodePoint()); 
&gt;The answer to this question lies in the implementation of uniqid(): in order to avoid time-induced collisions on the same host, uniqid() literally waits before getting the current date. That’s why there is a usleep(1) call in the function’s implementation. That won't even guarantee no collisions, though, will it? Small adjustments to the clock might cause a collision, or more likely different PHP processes could both end up getting the same time in any case.
Stuff like this is why I always find a way to design a system without UUID. At least I avoid UUID for frequently created items, like primary key for entities where I'm expecting thousands (or millions, ... or billions) to be created every day. UUID is suitable to identify a product SKU, an entity *type*, a server node, things like that where the thing being marked is created relatively rarely, will stick around for the long-term, and will be referred to in a global context. For everything else, there are ways to use a hierarchical sequence. See how Erlang does it (which is often praised as a language designed to be distributed out of the box).
I'm on DigitalOcean. The hosting provider has nothing to do with this problem
Some hosting plans have special rules where you can't specify /var/www in some cases but have to do ~/ followed by some folder where your web stuff is stored like public_html, httpsdocs, httpdocs, https_docs, http_docs, etc. The ~ means your own private directory, and then usually there's a folder under that where your web stuff is kept. You'll know this is true if, when you ssh into your hosting plan at command line, your prompt would say ~ in it instead of #.
I've just made a test to check for myself File size: 1.3 MB ----------------- intl example: 612ms opis/string: 918ms There seems to be a 30% speed gain by using the iterator provided by the *intl* extension. I will definitely use this for those users which have the *intl* extension installed. Thanks for sharing. LE: I've just realized that when I tested *opis/string*'s speed I was iterating the string twice. Here are my test results updated File size: 1.3 MB ----------------- intl example: 610ms opis/string: 421ms 
What's the exact situation, though? If it's easy to just check if a previous unique ID has already been used you don't need to do anything very interesting, just keep making new IDs however you like until one that isn't currently in use comes up. If you don't care about using a sequence... just use a sequence. Those are pretty easy. If you want some seemingly-random ids you can randomly generate some characters or whatever and just ensure the id doesn't exist in the data store yet. uniqid is probably fine as-is, but if you want something a bit better look for other UUID implementations.
Now, if your hosting plan allows you access to the /etc/php5/apache2/php.ini file, then you're probably on some kind of dedicated server, VPS, or something like that. If that's the case, then you are debugging errors differently than I do. In my case, I have my open_basedir = commented out with a semicolon on the line as the first character. Then, for debugging, I simply do: tail -f /var/log/apache2/error.log Or, I can also use `tac` or `cat` of this file, piped to the more command. Or, I can copy the file to /tmp and use the `less` command to inspect it. I know my error log path for my domain is set to that file because when I look in /etc/apache2/sites-enabled folder, I see my domain's conf file (or you'll see 000-default.conf file). When you look in the file appropriate to your domain (or the fallback of 000-default.conf), you'll see an ErrorLog line that specifies the path where your error logs are stored. Also remember that if you edit the php.ini file, then you'll need to do `service apache2 reload` to reload the config again.
Lol most of what are distractions is a matter of opinion. I have no problems with meetings planing a project before one line of code is started. After that it really should be weekly and just for official communication to make sure everyone is on the same page. With that being said, for me it isn't the deadlines, it's the feeling of being forced to when my mind doesn't want too. That's why a lot of companies are more "open" for office required hours and have a more laid back atmosphere. I always want a tour and meet the "team" before I decide to take a contract or position. F those damn cubicles listening to dumb senseless conversations, people eating loudly or omg my life's over cause I can't go to lunch at noon on the dot. 
I came here to say PHPstorm. I currently use Sublime (and love it!). I'd like to switch to PHPStorm for the integrated features, but every time I try, I don't have the time to come up the learning curve. If I was just starting out, I'd use PHPStorm. Every new release, I try to make the switch.
BC is not preserved *at all* in a semver project below stable version 1. [It explicitly states this in the spec.](http://semver.org/#spec-item-4)
r/laravel *I am a bot; I link the subreddits mentioned in the title for easy navigation*
Sometimes it's not about the benefits and it's about what you have available and what you are allowed to use. IDE's aren't always available on every system.
/r/laravel discussion is here: https://www.reddit.com/r/laravel/comments/4x80qm/all_laracon_us_2016_videos_are_now_available_for/ I have posted a magnet link there if you're interested in downloading the talks for offline viewing.
Yep. 
Also indemnity. 
Alternativly you could use something alone the lines of public function generateUid($length = 10) { $chars = '23456789abcdefghjkmnopqrstvwxyz'; $uid = ''; while (strlen($uid) &lt; $length) { $uid .= $chars[random_int(0, strlen($chars) - 1)]; } return $uid; } 
this. its standard practice to use a UUID4 and ramsey/uuid is pretty battle tested by the PHP community.
I was thinking much the same thing last week when I was playing with the idea of using Laravel for my new hobby project. After going through the official tutorials (and an e-book I used when I found out how bad the tutorials were, the hard way), I had to laugh that a framework billing itself as "The PHP Framework For Web Artisans" was 90% automated copy-pasting. It did get me more interested in composer, though. Now I just wish packagist had some sort of tagging or something to make it easier than just going through it alphabetically or by popularity. 
[According to OP](https://www.reddit.com/r/PHP/comments/4x7nf1/manipulate_multibyte_strings/d6dlu22) mb_substr is hella slow for what he was doing. 
With out getting into a debate, I use laravel to build my site, from the blog you may have read to some of the services on there. We also use it at work to build finical applications and I find it incredibly powerful and VERY simple :)
Don't forget to add *.idea* to your [global .gitignore](https://help.github.com/articles/ignoring-files/#create-a-global-gitignore)
I'm at work sorry, just had a very quick glance, there's actually a lot of composer stuff (including the phar!) which should not be included in your project and ignored out. I can give a better reply when I actually have time. 
You should probably fetch your credentials from a [.env](https://github.com/vlucas/phpdotenv). It may also be a good idea for you to pass them into the Database class constructor rather than invoking static methods on the Config class. Dependency Injection will help you here since it will increase the re-usability of your code and make it easier to test. There are a few good DI Containers available on Packagist which will allow you to wire up your application dependencies through service providers, etc. 
uniqid does not supply a UUID as defined by the RFC - See [the wikipedia page](https://en.wikipedia.org/wiki/Universally_unique_identifier). You'll need to use a library for that which is my preferred option...
FWIW, at least on Linux, the time is read locked.
 "psr-4": { "App\\": "app/", "Plugin\\": "plugins/", "Config\\": "config/" } I would put these namespaces under a top-level namespace like `NimdaTS3`. What if somebody wanted to install your bot as a dependency and their project had an 'App' namespace? I would advise you to look at the packages that you have installed as dependencies and try to think about your project as a potential dependency for other projects.
Down voters: care to elaborate? random_int() is part of the PHP 7 CSPRNG, and the example is random as it can get. 
haha I just bought a Navicat license as an early birthday present to myself.
Hm, care to post the code you tested with? Btw, you can also split unicode string to chars array using `preg_split('//u', 'asdf', -1, PREG_SPLIT_NO_EMPTY)`.
Because this ISN'T a unique ID, it's just a string of random characters. If you read the Wikipedia's post about UUID (https://en.wikipedia.org/wiki/Universally_unique_identifier), you'll undertand that a unique ID must be UNIQUE.
&gt; or more likely different PHP processes could both end up getting the same time in any case. The uniqid includes (should include) the process ID that generated it, so it should be unique on any one particular host.
Why hash a uniqid? It makes it longer without making it any more unique.
What relative values? All are search volumes.
Thanks for the reply. That's an awesome guide.
Look at the scale on the left. It's 0-100, means %. The ? sign explains that the top value is the top search volume, so it doesn't have any meaning per-se, only compared, like in here: https://www.google.com/trends/explore?date=all&amp;q=javascript,php,python
Carbon extends DateTime, which is a mistake, because while you can still pass in a Carbon instance to anything that takes a DateTime, if it returns a DateTime instance, it won't be Carbon. You have to re-wrap it. And re-wrap it. And re-wrap it. Likewise, if you accept DateTime as input, you have a choice: either wrap it in Carbon every time before use, *again*, or you require Carbon instance, which means now you're coupled to this 3rd party library in your method signature, and all your users should be aware of it and be using it. And there's no reason for all this, because Carbon only tacks-on helper methods to DateTime. It doesn't add additional **state**, it doesn't **modify existing behavior**, which would necessitate extending DateTime. It just adds helpers. Those helpers could be functions, they could be static methods, and while static methods have few good uses, this is one of them. Take in regular DateTimeInterface, return regular DateTimeImmutable. And that is a mistake I'd forgive, because, ok, Carbon did it this way, didn't think it through, so screw it. But it does leave a bad taste in my mouth to see other libraries, like Chronos imitate this mistake. Please stop abusing inheritance. Also, I'm unsure what "adds ChronosInterface for proper typehinting" means. It's highly unlikely someone would want to re-implement the exact set of methods Chronos has, so why have an interface? Typehinting for a class is still "proper typehinting". Interfaces are there to allow for abstraction. If abstraction won't happen, you don't need an interface. **EDIT:** ChronosInterface has **more than 140 methods**. Good luck to any reckless volunteers who might want to create a second implementation for this interface. Why have an interface at all?
`bin2hex(random_bytes(16))`
Minor versions can add features, and patch versions can fix bugs. If you rely on those features, or those bugdfixes, asterisks won't help you. Say you rely on features added in 2.1.0, and you rely on bugfixes added in 2.1.3. Well, 2.\* allows 2.0.0, so your app will break.
Convenience is a reason that comes to mind. If PHP were not an OO language, I would entirely agree with you, but the fact that DateTimeInterface exposes formatting methods shows that it is not just a value object. Otherwise there would only be a the value object and a big array of different classes for formatting, manipulating, and calculating differences between the value objects.
Oh, I see what you mean. But running `composer update` will always get the highest available, won't it? What situation could arise where, when requiring 2.1.3, only 2.0.0 is retrieved?
&gt; This is what we got, and in order to produce a better experience out of what we got, I think adding convenience methods living in the same objects is a pretty good thing for developer experience. Calling this experience "convenience" requires very tinted glasses: function (DateTimeInterface $dt) { if (!$dt instanceof Chronos) { $dt = new Chronos($dt-&gt;format('Y-m-d H:i:s.u'), $dt-&gt;getTimezone()); } $dtMonthLater = $dt-&gt;addMonths(1); ... } Versus: function (DateTimeInterface $dt) { $dtMonthLater = Chronos::addMonths($dt, 1); ... } I find this turf war over who gets to define the class for DateTime to be quite misguided. You'd think the focus would be on providing value, but no, it's considered a badge of honor to declare your own DateClass subclass as the official DateTime class, for some reason. Additionally, the way Chronos abuses traits to split itself in manageable files is a quite self-defeating admission that it is becoming way too big to be a single class. Gathered together, the class is **2700+ lines**. If we add the pointless interface, which the class depends on, it becomes **3900+ lines**. All this is spread in **13 files**, all of which will get autoloaded the first moment Chronos gets used, no ifs, no buts. And all that fat... so you can provide a few helper methods. But I'm sure all this is very OO.
If another library has specified, for example "2.0.23", and you specify "2.*" then Composer will install "2.0.23". You don't control what other libraries specify, so you have a choice, either be specific with tilde and caret, or play Russian roulette with your code stability :)
Just curious. Do you use the UUID4 in URLs as well? Say if I want to read an article hosted on a webpage using UUID4 for their article ids, would it sort of be like http://example.com/index.php?articleid=UUID4 ? Or do you use another simplified ID for URL/prettyprint purposes? Edit: I did not intend for that URL to be a link. I wanted to point out the structure of the URL, not the content (or lack of) behind the URL.
&gt;for a sequence with letters Yeah, if you want something unpredictable it's useless, but it's useful if a sequence is acceptable and the client has an irrational distaste for numerical ID's. I'm also considering it's use in a barcode system to maximize unique barcodes within a limited character length, but that project isn't purely PHP.
To be spec-compliant, if the major version is 0, the caret should only choose versions exactly equal to the specified version. In 0.x software, according to the semver spec, any update to the version number is allowed to contain breaking changes, even patch changes. The only semantic version that is guaranteed to be API compatible with a particular version is that version. The article suggests that 0.1.5 will not contain any breaking changes from 0.1.4 - this is a widely accepted convention, but it is not what the semver spec states. I think this is what the poster was trying to get at.
Hi, that worked. But now the images generated for A are smaller than the ones generated for M. A had much more padding than M. What I want is the letters to have the size 26*26 pixels and for them to be encased in a 32*32 pixels black image. Could you look at the code below and see how I can make the padding for both A,M and other characters the same? http://pastebin.com/vZzxZkKt
&gt;People keep reinventing routers, validation classes... and what ever else without producing anything better like in your examples. I've actually been struggling to find a router to fit a project's needs this week. It's not so much that developers keep reinventing routers. It's that there's no diversity when they do. It's overwhelmingly the same solution for the same use case.
I am a different person than the one you are asking, but I would like to add a comment. I believe the reason for using UUID4 is to assign a unique id to an object without being dependent on a database. In other words, an object should be able to be in a valid state independent of what system you use for storing your objects(database, csv-file, etc). In order to acknowledge collision you will have to check the system you are using for storing your objects. Hence such a system should work independent of using database or a csv-file for storing your object. I belive Marco Pivetta touches this topic in [this presentation](https://www.youtube.com/watch?v=rzGeNYC3oz0) (I do not remember exactly when, and I do not have time to watch it agian now), it is worth a look.
Or use the [uuid-ossp](https://www.postgresql.org/docs/9.5/static/uuid-ossp.html) module and call `uuid_generate_v4()`.
 $dt = new DateTime('2015-01-31'); $dt-&gt;modify("+1 month"); echo $dt-&gt;format("Y-m-d H:i:s"); //2015-03-03 00:00:00 well, fuck So what does Chronos do? $dt = new Chronos('2015-01-31'); $dt = $dt-&gt;addMonths(1); echo $dt-&gt;format("Y-m-d H:i:s"); // 2015-02-28 $dt = $dt-&gt;addMonths(1); echo $dt-&gt;format("Y-m-d H:i:s"); // 2015-03-28 but // starting on the last day of a month $dt = new Chronos('2015-01-31'); $dt = $dt-&gt;addMonths(2); echo $dt-&gt;format("Y-m-d H:i:s"); // 2015-03-31 // so -&gt;addMonth(2) != -&gt;addMonth(1)-&gt;addMonth(1) $dt = $dt-&gt;addMonths(1); echo $dt-&gt;format("Y-m-d H:i:s"); // 2015-04-30 // last day is correctly set to 30 instead of 31 $dt = $dt-&gt;addMonths(1); echo $dt-&gt;format("Y-m-d H:i:s"); // 2015-05-30 // now we keep 30, so we're not on the last day of the month anymore... No matter what you try, dates are just inherently fucked...
good point. The programmer would have to explicitly choose between 28, 30 days or a whole month depending on the business requirements, one of my clients for instance uses 28 days so they end up in the same weekday
We use Postgres which allows for uuid fiekds
&gt; running composer update will always get the highest available, won't it? Not if another dependency requires `2.0.0` only, for instance. In this case it's better that your package refuses to install (if the bug stops it working). It's also possible to run `composer update --prefer-lowest` to validate your lower bounds are in fact correct.
Ok, I get it. Bloat, wrapping, we can keep going on and on w/ the issues. What's the solution? If you work w/ dates w/ any frequency, what do you use that is slim, effective, and not ridiculously verbose? Edit: BTW, I really enjoyed the interchange between you and Jose. It seems that this discussion could be brought, at this exact moment, to PHP / frameworks as a whole, and I would find it impossible to believe that it could be done w/ as civil a tone as you both had.
&gt; If you work w/ dates w/ any frequency, what do you use that is slim, effective, and not ridiculously verbose? As I noted in the comments, the solution is extremely boring... static methods that take in DateTimeInterface and return DateTimeImmutable. Those can work on existing DateTime and DateTimeImmutable instances, without having to decorate them as other objects (Carbon or Chronos, etc.). This would also allow different processing tools to be split in different classes, when suitable. So, for example, some of the more exotic processing tools can be put in another class, so you don't have to load *everything* when you need to "addMonth()" to a date. I'm not saying anything new, just look at the thousands of StringUtils in the PHP space. And, thank god, they all work on pedestrian strings, imagine if they all required wrapping your strings in "new FancyText(...)" objects, then passing them around like that... And in fact, some people do that, but thank god it's mostly experimental, not a common practice. I also find many of Chronos' methods to be somewhat unnecessary. Do we really need "isMonday()" "isTuesday()" "isWednesday()"... I think "getDay() == Chronos::MONDAY" should be enough. Checking the day is not something that we should obsess over micro-optimizing in terms of interface compactness, because it's hardly the most common activity you'd be doing with a date in your code. That goes for a lot of the methods on Chronos (and Carbon). Frameworks these days tend to go for flashy shortcuts that make a splash during demos. But when the result is 140+ methods, as it is with Chronos, it needs to give us a pause. And not to mention that it's really easy to miss *useful* functionality in a pile of 140+ methods. The authors are shooting themselves in the proverbial foot, by making their class harder to use, because they want it to be easy to use.
/u/MrJohz is correct. The article suggests that using carets for dependencies under version 1 will somehow be better or more reliable than tilde or asterisk. However, that's not the case at all. Before version 1 in a semver project, *there is no public API* and changes can break BC on any version bump of any kind (even patch versions, e.g. 0.1.0 -&gt; 0.1.1).
&gt; Why do we keep building those empty models (which aren't even models, just DTOs for one possible entity representation that came from elsewhere) Mostly because when a service wants a particular subset of data, I want that data to be internally-consistent and valid. A service using `array $book` is prone to annoying logic errors that can propagate through a system like a blood clot. If I use an entity or a DTO, the object is self-validating and an entire class of logic errors becomes impossible.
I fully agree with you please see my other [comment](https://www.reddit.com/r/PHP/comments/4xckv0/chronos_let_there_be_time_a_modern_php_standalone/d6ek96u) for a proper new date time implementation. Edit: To explain a bit more. The problem is that the DatetTimeInterface is completly broken and basically impossible to implement properly. Because you really really want separate class for Date, Time, DateTime and Unix timestamps, because they behave completely different with regards to DST and timezone changes. E.g. adding 1 day (24h) to a timestamp could give a different result than adding 1 day to a DateTime object if DST are in the game.
Interesting, what does random_bytes offer over openssl_random_pseudo_bytes? Apart from the much easier to type function name ;)
I like [this image](http://delta-associates.com/wp-content/uploads/DOHP-Main-Image-Wheel.jpg) when it comes to re-inventing the wheel. That said, only reinvent the wheel if needed. Most parts of "the ecosystem" where made when someone scratched an itch. When something existing didn't suit a need. Always reinvent the wheel just for the fun of it!
&gt; "Always reinvent the wheel just for the fun of it!" Why just for fun, what if during the re-invention you make it stronger or develop new concepts to help the community?
You're misunderstanding the approach significantly. It's in part because the conversation is at a too abstract level, but also because you're too determined to dislike whatever I'm talking about before you can even understand it. Let me ask you, how do you maintain the "contract" when your API client is not in PHP at all, but say, JavaScript. You can't pass PHP objects over the wire to JavaScript. Just data. Objects have a scope they exist in. They only move in that scope, and they can only guarantee their self-consistency in that scope. And in a modern app that relies on dozens of third party services, and may be distributed on dozens of servers, that scope is pretty, pretty small, everything else is serialized data on the wire. If am to buy your narrative, it should be a massacre out there. End of times, cats and dogs sleeping together. Yet... it's fine. APIs receive data and return data, and contracts get followed. Maybe you're missing a good chunk of the picture.
I included vendor for good reason. 1. Teamspeak-php-framework i did a bug fix on, and waiting for the (inactive) author to accept my pull request. the .idea I don't know why that 1 file got included.
Code contracts exist to enforce **behavior**, not data (nor its structure).
The behavior is still in the model, so what is the problem here?
why did you commit the composer.phar?
have you looked a phar.io before?
Let's try approaching this discussion from a different direction, lest we keep going in circles. Give a minimal code example of your design for a single domain entity. If I've misunderstood you, it'll be blatantly apparent. If not, I'll elaborate on why the design is deficient in more concrete terms.
Isn't this already possible using `list($x, $y, $z)`?
yes, it's like the `array(1, 2, 3)` to `[1, 2, 3]` change, just making it prettier
Yeah, much prettier and more logical. 
At least it's better than the functional cluster fuck that it used to be.
I wasn't referring to consuming code (we'll get to that later). I'd like to see a barebones example of the design you proposed here: &gt; What will happen if instead of using "entity model" classes, you use arrays for holding entity/value representations and focus the model business logic in a service object that produces, mutates, deletes and queries said entities. In other words, you still have a model, but the model is a collection of entities of the same type, and not just one entity. And the model produces representations of its entities, not the entities (as they're typically remote in a DB, anyway).
Early January-March there were some okay roles out there for PHP £60k - £70k. Not sure about just PHP as I tend not to look at anything without extra responsibilities and a more diverse stack. I'm not actively looking, but I get a lot of recruiter traffic. To be honest this time last year jobs were up to £100k. Since then the knuckle-draggers voted to not be in Europe... It does seem things are getting worse in all walks of life since then. To be honest the few specs I ever look at seem like they had been assembled by toddlers with a technology fridge magnet collection.
You have an object, say you're managing users, you'll have a $userService, which is just like a repository, with the exception it also encapsulates the business logic of the domain, validates incoming operations and data (and internally, it may use a repository, if the storage logic has to be isolated in a separate class). A barebones example would have your typical CRUD methods (though CRUD modeling is not a necessity), like $userId = $userService-&gt;create([..fields..]); $user = $userService-&gt;getById($userId); $userService-&gt;delete($userId); And so on. Once again, asking for a "barebones example of the design" of a domain is a very abstract question. Check the application by OP here. It does almost nothing, and it's hundreds of lines. You can't expect me to rewrite the entire article here, right? Please ask more focused questions. If it's the interface of the service, I hope the above is clear enough.
Is this the right place to ask for code reviews or do those belong in /r/phphelp?
[Patchwork 2.0](http://patchwork2.org/): basically an implementation of [runkit_function_redefine](http://php.net/runkit_function_redefine) in pure PHP.
It depends what server you're using. Apache uses mod_rewrite but there are alternatives like isapi_rewrite on other platforms. 
Currently I'm working on a function that will take an array and loop through the values checking if they're empty. If all come back not empty, it will return true otherwise it will give false. I think this should be a pretty effective way to keep them cleaner. I'm also creating another for checking max lengths. 
It's rather interesting why this happens to you, given I never had to write a line like this in my 10+ years of work with PHP (also, god damn it, 10 years). In fact, I can't remember using empty() recently. I use isset() mostly. My point is, maybe the solution can be refactoring whatever is causing you to write those lines, so if you want to share more, let us know.
Most frameworks have built in ways to deal with form validation or automatically do it.
Just google mod_rewrite tutorial for a start. There are online tools out there that will generate the code for you, but I'd recommend learning it so if anything goes wrong you can fix it. It builds on regular expressions, so if you know regexp you've got a head start. Also make sure the module is enabled in apache. 
Exactly. It's a JetBrains thing -- so if you're using phpStorm then you'll have a .idea folder that you don't really need in repository or on your server..
I've recently gone away from using `$_GET` for routing and use `$_SERVER['REQUEST_URI']` instead, then break it down over the slashes. Then you can route based on nested switch statements $uri = explode('/', $_SERVER['REQUEST_URI']); switch($uri[1]) { case 'view': return ViewPost($uri[2]); case 'edit': return EditPost($uri[2]); } Normally you'd want https://url.com/something/abc123 to show that the abc123 ID belongs to the "something" objects or is an action (hence the view/edit in the example), unless you really only have one thing to show. Alternatively, and if you're consistent with the path ordering, you can use `list($discard, $action, $id) = explode('/', $_SERVER['REQUEST_URI'])` then `switch($action)` and `ViewPort($id)` The `$discard` is because `$_SERVER['REQUEST_URI']` always starts with a `/` and returns an empty string for the 0th index after explode. You can also `trim` it of the slashes first. This even works when submitting a form with `$_POST` parameters. Keep the `action` of your form to look like `/edit/abc123` and do you routing as you would $_GET requests, but within `EditPost()` or even in the `switch` statement, see if `isset($_POST) &amp;&amp; count($_POST) &gt; 0` then call the code to actually modify the object. This might seem a little complicated at first but definitely a lot more straight forward than dealing with web server mods and rewrites.
&gt; you'd have to ignore basically the entire framework documentation and examples True. Or you'd have to pick frameworks that were built with decoupling in mind. (Is this the part where I mention [Aura](http://auraphp.com) and [Radar](https://github.com/radarphp/Radar.Project)? I think it is! ;-)
To answer your question: function areEmpty(){ $args = func_get_args(); foreach($args as $arg){ if(!empty($arg))return false; } return true; } and use if(areEmpty($a,$b,$c,$d)); this also works for more/less variables
Thanks for the heads up @pmjones, will create a demo out of Aura :-)
Nice. I don't recall if I mentioned it, but we took to heart [your blog post about database queries and iterators](http://www.dragonbe.com/2015/07/speeding-up-database-calls-with-pdo-and.html). In Aura.Sql v2 you will find [new `yield*()` methods](https://github.com/auraphp/Aura.Sql#new-yield-methods) that return iterators, and in v3 you will find that [the same methods actually use the `yield` keyword](https://github.com/auraphp/Aura.Sql/blob/3.x/src/AbstractExtendedPdo.php#L599-L716). Thanks for your research there!
Do you have this set as your PK? Any indexing/performance issues?
Before I reply, is `$user` an array in your example? If not, I'm afraid I still don't understand what you mean by this: &gt; use arrays for holding entity/value representations and focus the model business logic in a service object
Using a method like the above for 50+ fields does not sound correct, I guess you should solve this problem on another way. (e.g. some kind of array that knows which fields you want to check and looping through those etc.)
You need a few things in place for this. For whatever web server you are using, you need to have all of your non file directory requests go to one PHP file. You mention .htaccess, so I assume you're using Apache, so maybe something that pushes all non directory and non file requests to an index.php file RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule . index.php [L] Next, you need a router to parse and route the request to the correct endpoint, usually a class or class method, with the URL parameters as an argument or arguments. You're probably better off using a framework for all of this instead of rolling your own. Google PHP frameworks routing for some ideas.
No, you don't have to ignore them. How you use framework services doesn't change just because you've decided to use them in an adapter instead of directly in one your service/business layer. Really, de-coupling is simply a matter of shifting how you build your app. Usually people build it from the outside in - starting with the tools the framework gives you. Instead, if you build from the inside out (starting with the core business logic that makes your app what it is), you can then decide what interfaces it should use for the dependencies it needs, and then you simply implement those interfaces through adapters, using one or more frameworks or libraries, slowly building an application *around* your domain, rather than building a domain *inside* of an application. But here's the massive gotcha: most web apps are "inverted icebergs". There isn't some giant complex domain hiding beneath the GUI that warrants such aggressive decoupling. SOMETIMES there is, but usually the majority of the code is related to the GUI part of the app, not the domain - CSS, Forms, Validators (e.g. markup), Controllers, Middleware, and Routes. These are the things that the framework gives you useful shortcuts for, and if you attempt to decouple the framework from these, then you literally might as well not even use a framework (or even a set of libraries) at all. Meanwhile, going full gung-ho decoupling from your comparatively small domain layer doesn't save you that much in the long run, because most of it is simple CRUD. That's not to say you shouldn't do it, but the rest of your app is going to be married to the framework *anyway*. Of course, I want to re-iterate that I'm not generalizing all sites/web apps. Some do indeed have massively complex domains beneath them and relatively trivial guis to interact with those domains. In those scenarios, decoupling pays huge dividends. However, in situations where your app is mostly markup and controllers and routes and things, and your domain is simple, decoupling is arguably counter-productive.
I think that when people think in this layer of abstraction they forget what the point of the framework they chose was. Not many people, if any, "replace" their current framework with out a full re-write.
Debian Wheezy uses 5.4 (LTS until 2018-05), Ubuntu 14.04 (LTS until 2019-04) uses 5.5. On the other hand: Variadics have better semantics than `func_get_args` because the parameter is part of the signature and can be used in static analysis. I’d say this is one of the choices that need more context or that depend on the target audience. I’d opt for compatibility if the price doesn’t seem too high. I think it’s the pragmatic choice, but I know that it’s not very popular. So, yeah, there are pros and cons. Good thing is, code that doesn’t use newer syntax features won’t stop working because it is in fact valid PHP 7 code. That is a great feature of PHP.
Because your idea of unambiguous would break every January 29th (but only on non-leap years), 30th, 31st; March 31st; May 31st; August 31st; and October 31st, and which contingency to use for this is highly context-dependent (cap it at the last day of the month, roll over the overflow days into the month afterward, etc.).
&gt; Debian Wheezy uses 5.4 You get 5.6 in wheezy backport
I've always used isset(). It does exactly what it says, which is to check if a variable has been set. I only use empty() to check if an array is empty. I just assumed that was how you're supposed to do it.
Depends if you want to know if the variable is empty, or if its set or not. You should use the function named after the functionality you're interested in. Things besides arrays can be empty, and software can be interested in knowing if something is empty.
Be careful using `isset(...)` to check if a key in an array is set: it will return `false` if the key exists but assigned with `null`. 
Indeed, but the context is forms, and form data never contains null values. 
Perhaps try splitting the definition of the form (what fields it has, what restrictions there are etc) from the data (what the user submits from their browser). So, e.g: $definition = array( array( 'field' =&gt; 'name', 'maxLength' =&gt; 32, 'minLength' =&gt; 6, 'required' =&gt; true, ), array ( 'field' =&gt; 'email', 'maxLength' =&gt; 32, 'minLength' =&gt; 6, 'required' =&gt; false, ) ) and then : $v = new Validaro($definition); if($v-&gt;checkNotEmpty($_POST)) { // do something.... } That way you avoid PHP moaning that you're accessing array keys that do not exist (when someone's not filled in a field), and it allows you to differentiate between a POST and GET request - if you need/want to - or use the same code for checking what may have been submitted in a json encoded blob. $json = "{ name: 'bob', email: 'bob@example.com' }"; if($v-&gt;checkNotEmpty(json_decode($json, true)) { .... } If you get really carried away, perhaps add a filtering definition to the definition description, so you can e.g. run something like `filter_var($email, FILTER_SANITIZE_EMAIL); ` - but that probably means you'd need a `$v-&gt;getValue('email')` type function. 
Learn **basic** programming and **basic** PHP
I need a php script for these things. Can you help me free of cost?
yes dear, it'x coming soon visit our website: www.updatelab.com
I've used a project named [Fortress](https://github.com/userfrosting/fortress) in the past. It has some nice features, and is framework-agnostic. You provide a schema in JSON format, in which you can define required fields, data types, and a variety of other checks (eg. start date must be before end date). It allows for custom error text with localization support, and can automatically apply transformations, including running input through something like [HTML Purifier](http://htmlpurifier.org/). One feature I really appreciated was that it can export the same schema into a format consumable by front-end javascript validation libraries, so you can validate on the front end for user experience, and the back end for security, without writing validation rules twice.
filter_input and friends
uh?
Being able to work focussed without distraction is key to being productive. At our company we use the pomodoro technique were you work blocks of 25 minutes. During this time you just focus on one task and remove all channels of distraction, so: no email, no slack, no phone, .... It's impossible to do this all the time. But the periods you use this technique it's amazing how much you get done. 
I think you might've missed my original point - `array_filter()` will throw a notice if one of the arguments in the array is unset. And if you try to pass `empty` to `array_filter` as a callback, it won't work: $a = 1; unset($b); var_dump(array_filter([$a, $b])); // PHP Notice: Undefined variable: b var_dump(array_filter([$a, $b], 'empty')); // PHP Warning: array_filter() expects parameter 2 to be a valid callback, function 'empty' not found or invalid function name 
Circular dependencies.
I don't understand the circlejerk in this thread. You shouldn't use single variables but a hash with the form names as keys and values. Then you can just loop over the fields and check if they're empty or not and add more logic if needed for each field type. 
A word of caution, don't just take input from the $_POST, $_GET etc. globals. You need to sanitize and more extensively validate client data in order to be able to safely assume the data is correct and secure. For simple validations, you could use beberlei/assert, which is installable through composer. It works somewhat like your library but offers a lot more options, throws customizable exceptions, is extendable and does not require your data to be part of an array of configuration. Alternatively, you could use DTOs with annotations for validation (like how a framework like Symfony does it). Look into composer and packagist, they allow you to easily use and track (third-party) packages in your project.
A digital abortion...
On a side note, there was an RFC trying to make the empty variadic. It would've solved your problem though, but it was declined by PHP internals: https://wiki.php.net/rfc/variadic_empty
&gt; So I'm ripping off pimple. That's fine, Pimple is ripping off objects and nobody seems to mind. It's an object that implements... a fake array that implements... the concept of an object (defining and calling methods /named closures/, having method visibility /public, private/, etc.). For some reason we live in a world where this: $mailer = $foo-&gt;mailer(); ... is just a stupid object. Not a good container at all! But this... $mailer = $foo['mailer']; ... now this is a great container. Good job.
From mp3 files? Similar to Exit data in jpegs, mp3 has id3. PHP has support for them as well (I have not used them for myself). http://php.net/manual/en/ref.id3.php
Lol. People need more lessons on how to identify a troll when you see one. In 2010 may be, programming forums were flooded with questions like this, and the answered were equally terrible. I have done that myself, and miss those simple days. 
There is a fig psr proposal for di containers: https://github.com/php-fig/fig-standards/blob/master/proposed/container-meta.md Still in the flopping and failing stage but might consider implementing the interface. And to be honest, I think your array access falls under the heading of cruft. 
It's an invisible variable, you guys.
Empty is just "not set or not truthy". Checking the length of an array is a better way to see if its empty.
Or once we finally get round to a passing vote on arrow functions.. function allEmpty(...$args) { return !array_filter($args, $arg ~&gt; !empty($arg)); };
No need for the callback even, array_filter does that same check without a callback.
Huh, completely forgot `array_filter` had a default callback. Too busy trying to be clever. Thanks! function allEmpty(...$args) { return !array_filter($args); };
Your question is a bit vague. Could you supply more info? Perhaps you are not looking for id3 but apis? http://www.last.fm/api https://wiki.musicbrainz.org/Development/JSON_Web_Service
I wouldn't consider all these projects as "flopping and failing": https://github.com/container-interop/container-interop#compatible-projects (including Zend Framework, Zend Expressive, Slim, etc.).
I would generally make a separate class for partials.
The ORM i'm using is [Opulence/ORM](https://github.com/opulencephp/Opulence/tree/1.0/src/Opulence/Orm) that leaves the data mapper implementation to the user, so that wouldn't be a problem. 
Can you expand on why?
There's no reason to do this until your entities are absolutely massive (like holding megabytes of binary data) and you've identified them as a bottleneck which affects performance. Relations is a different story, they do affect performance when lazy loaded (can easily trigger 100s of queries), so you should eager load the relations you need before using these fields. Define scopes to hold frequently used relations.
Ideally your business logic should be portable. As long as you arent re-inventing the wheel youll be fine. ZF is a really bloated beast that trys to offer a tool for everything, but you are in no way obliged to use them. I tend to take the same approach - TDD a standalone module and then 'wire it up' to the framework in a plugin. 
or composer.phar
I have a form and if I type in 'Green Day' in the form I want to retrieve a list of albums by that artist, then the list of songs on those albums.
Well, nothing is as permanent as a temporary solution. Sounds like you're looking for an excuse not to use frameworks. Granted, they aren't always necessary. If you write good code without them, fuck it. Go ahead. However, writing code with the thought of "I'll definitely refactor that into a framework someday" is just lying to yourself.
Any good framework will assist you in prototyping. It seems to make more sense to just do the prototyping and rapid development with the framework and then refine it later.
DI for life fooo! No but seriously, the standard these days, unless I'm severly out dated is to use DI to inject jazz. So I am going with the standard as to not rock the boat
soooo, they are inherently fucked lol
&gt; Eventually, I realize that I should port my work into a proper framework, but in terms of hammering out technical requirements into running code, the creative juices seem to flow more freely when I'm making prototypes using plain old PHP. Don't feel obligated to use a framework because you "should", i.e. out of peer pressure. That's the path to hell. Instead, use it if you see *exactly* what value it provides you. As for prototyping. Prototyping your project leads to a better architecture and more thought-out design, so if you have the time and will to do it, by all means do it. The only reason not to prototype are deadlines and budget. Don't forget: *"The first draft of anything is shit."* ~Ernest Hemingway When you don't prototype, the shit ends up on your production server.
The basis of module systems is: *you have well isolated, well encapsulated modules, and you can wire them however and exactly as you want.* The basis of a module system isn't: *you have modules and they squirt singletons in a global container all on their own, so they all know about each other without your say, and soon you have no idea which module uses which module, so better watch out what you tweak before y--- oh my god you broke everything, you idiot.* What Symfony and co. does with those automatically registered dependencies in the container is nothing else but tomorrow's bad practice (in fact, it's yesterday's bad practice, but it seems the news hasn't reached these areas). For some reasons a lot of developers are **extremely stubborn** about using global state. "Don't use global variables!" wise people told them... so they started using singletons. "Don't use singletons!" wise people told them... so they started writing static registries (aka locators, aka containers, aka injectors, aka ...). "Don't use static registries!" wise people told them... so they made them non-static, but slapped an API on their module system so modules can basically write to a global container. Finding increasingly obfuscated ways of implementing global state *isn't fixing the problem* of using global state. The fact that modules provide dependencies, doesn't mean they have to end up in the container *automatically*, and *under a specific hard-coded name*. That's just "global $service;" with another syntax. In a better architecture you'd still have your modules, but you'd wire them *explicitly* in your composition root. I'm doing this and I'm a "modular architecture" lunatic, so you can trust me it doesn't hurt modularity.
&gt; This directly contradicts what I said earlier: "internally, it may use a repository, if the storage logic has to be isolated in a separate class". Ignoring the fact that this wording conveys that such a separation would be *optional*, it's still problematic either way. Whether or not the actual implementations exist within the class or as dependencies of it, you're still expanding the class's public interface to absorb multiple responsibilities. It now has (at least) two reasons to change: if entity behavior changes, or if repository behavior changes. &gt; I wonder what constitutes "entity activates itself" here. If we dig a little deeper, I suspect it'll be nothing more than a glorified setter for a boolean flag. Let's call things by their real names. In our overly simplified example, this behavior is correspondingly simple. I'm sure you can imagine that in more complex, real-life cases, entity behavior can go far beyond just toggling a flag. I feel like this is mostly irrelevant to our discussion, though, unless you don't think non-trivial entity behavior exists? &gt; As for complex services that send emails and so on, I'll just say nothing prevents one service from calling other services, there's even a name for it: "orchestration service". Things can be factored as the domain requires. Most certainly, and this would very well be what `UserActivationService` would be (most of my examples given for what "activation" may entail would live in separate services). &gt; I'm just telling you why the naive DDD approach you're describing doesn't perform in a concurrent and distributed architecture. Dealing with concurrency is a whale of a separate problem that's purely situational and not very productive to talk about here. Your approach would also suffer from concurrency problems in various architectures (e.g. horizontally scaled), so you aren't offering up any kind of universal solution. Even trying to contend that it's "more concurrent" than traditional designs is just a red herring, because concurrency is not directly part of DDD; it's expected to be woven in and tailored to your custom use-cases, as/if necessary. If you want to go down this road, I'm not really interested in the discussion, because you're no longer proposing what I assumed to simply be a take on general application design. &gt; You're forgetting that the service is the model in my layout. It's the model's direct responsibility to have knowledge of the inner workings of its own state, and the entities represent model state here. No, you've simply overlooked that the "service" we're talking about here is the `UserActivationService`, not your `UserService`. So, assuming you inject your `UserService` into a `UserActivationService`, and then instruct the activation service to activate a user with a given ID, how would it go about doing that? How does `UserActivationService` use `UserService` to make the appropriate entity modifications without having direct knowledge of the entity's inner workings? If it's all encapsulated inside `UserService` and the activation service simply does something like `$this-&gt;userService-&gt;activate($userId)` then I'll point you back at the SRP violation you keep saying doesn't exist. If, instead, it takes a more hands-on approach like `$this-&gt;userService-&gt;update($userId, ['active' =&gt; true, 'active_since' =&gt; new DateTime()])` then the activation service has direct knowledge about the inner workings of a user entity, and here we are again. &gt; Typically I do this by exposing transactions from my repositories. Yes, this is the desirable approach. Maybe we're still not on the same page with this portion of the design, though, since I don't know how this would be possible if external repository implementations are only optional, as you put it previously: "(and internally, it may use a repository, if the storage logic has to be isolated in a separate class)". &gt; That's great in theory but I'd like to see the spaghetti of implementations you'll end up for a single entity if you try to model all possible subsets of a user as distinct classes. Luckily, you'll find that there are usually a very limited number of distinct ways in which an entity is used, and therefor, a very limited number of subsets of an entity's data/behavior required to perform the necessary tasks. A large number of tasks will share behavior requirements. Activation was overly simplistic, and probably a very bad example in that respect. Consider something like a `LocatableUser` with geographical location data/behavior which may be all that's necessary for generating driving directions, plotting users on a map, creating mailing labels, and various other tasks. Or a `BillingInfoUser` for various reports, billing jobs, etc. It's okay that an implementation contains minimal data/behavior that isn't used. We're only trying to minimize waste as effectively as possible, not eliminate it entirely (which would be highly impractical in most cases). &gt; I highly doubt your repository has a dedicated getUserButOnlyAsActivatedUserDontReadTheRest($id) method. And you would be correct. I would be much more inclined to inject an appropriate factory which can be queried for the fields it requires to create the desired representation. But since you're seemingly scoffing at this premise, though, I'm curious to see how your user service would go about producing the different representations required for different contexts without doing something similar.
I'm using Slim 2 PHP as my framework, either I'm not aware of any built in validators with that framework, or I can turn to a 3rd party library to help out. Any suggestions on a 3rd party library / package?
It really depends on how comfortable you are with each framework. Symfony for example you can use for projects of every size, it scales really nicely since you are the one writing most of the structure. But for rapid prototyping or small to mid sized applications (think under 50 requests/second peak) I absolutely love Laravel, normal PHP isn't even close to the speed of writing apps with it for me.
Ask "is it bad to not load entire entities": people will say yes. Ask "is it good to select all fields in SQL": people will say no. Now consider your entities *almost always* come from an SQL database... and despair.
I'd recommend Symfony's Validation component. (Components can be used standalone) http://symfony.com/doc/current/validation.html It is well maintained, and can work in straight PHP (no annotations, yml files, etc.). Slim also has a 3rd party validator. I haven't used it, and it isn't official (beyond being linked from Slim's website), but it looks decent too. https://github.com/DavidePastore/Slim-Validation
Nice article and more elaborative.
[removed]
Ok, so I just updated my system (Ubuntu) and I'm using a PPA that comes with PHP 7.1 (https://launchpad.net/~ondrej/+archive/ubuntu/php) and that one does consistently seg faults at the same exact spec. When I compile myself it doesn't. So it must come down to some specific modules I'm not compiling with apparently. Anyway, the specific spec that it seg faults on isn't too complex: https://github.com/ldaptools/ldaptools/blob/master/spec/LdapTools/Schema/Parser/SchemaYamlParserSpec.php#L167 . I'm digging into my parser class at the moment to figure out at what specific spot it actually seg faults at. But it doesn't seem to be PhpSpec related at the moment. This is a class that I really need to re-write anyway sadly.
What a dumb recommendation. Waste of time for 99% of projects and the ones that need it are terminally sick or growing so fast the focus should be on something else or the resources are there to build it in later. This is like recommending every app be database agnostic just in case you decide to switch from MySQL to SQL Server. The number of apps this *ever* happens to is vanishingly small or starts with that as a specific requirment. Just like this decoupled framework horseshit being peddled right now. So, decouple from your framework so you can waste time on your app early instead of making me think your app might be worth a shit to use and then making some other dumb choice and killing it.
I am pretty sure. It's not crypto safe because it is predictable, not due to lack of uniqueness.
Eloquent sort of does this, but only sort of. It works more on a collection basis though. I wish type hinting were better in PHP, that's for sure.
I'll definitely take a look at Cake, thanks you! But I'd advise you to take a look at Laravel as well :)
The projects mentioned are fine. The flopping comment refers to the process of actually generating a psr. And the link you included is to the existing interop container interface. It's the psr version (which is basically identical) that is ever so slowly moving through the fig process.
Call me old fashion but I like my objects to behave as objects and not hashed arrays. A simple get() for retrieving and maybe a set for setting. As it stands, you could pretty much replace your code with an array.
&gt; but you'd wire them explicitly in your composition root. Any articles that discuss this in more detail? In my Symfony experience it is pretty easy to tell what is being injected into whom. 
Yes, this is absolutely okay to do (advisable, even). But it's not always necessary. Like virtually everything in computing, whether or not you should do it depends on your particular needs and circumstances. Generally speaking, you won't see the practical benefits from it until you're working on larger, more complex applications/domains.
0.25. Is that lower than average?
&gt; HTTP is the TCP/IP based application layer communication protocol ... and itself it depends upon TCP/IP to get request and response between the client and server Uhh, no... HTTP is not based on, nor dependent on TCP/IP.
I narrowed down where it is failing in my code, but I can't for the life of me figure out why it's failing. It specifically fails at the end of this loop: https://github.com/ldaptools/ldaptools/blob/master/src/LdapTools/Schema/Parser/SchemaYamlParser.php#L111 . All that loop does is construct an array of objects that essentially serve as metadata. It doesn't even fail in the parse function of the loop. It finishes parsing all of the objects into the array then right as it exits the loop is when it seg faults. I was finally able to compile PHP 7.1 from the source off github directly and got a copy of the backtrace. I'll open a bug for it. Edit: The bug -- https://bugs.php.net/bug.php?id=72829
Respect validation is great, very expressive.
There is such a method: http://agile-data.readthedocs.io/en/develop/model.html?highlight=set#Model::set Immutability is better working with compiled languages, with PHP you could face some performance problems if you go too heavy on object cloning, so I decided not to implement it.
Have you verified that approach is reliably performant? In 20 years with mysql I've never found subquery optimization to be entirely predictable or consistently fast.
I have actually looked at PHPixie ORM, it is pretty good, but I wanted to make something better still. Joins are not only for SQL. They are vendor-independent. Here is a test-suite for Array-based joins: https://github.com/atk4/data/blob/develop/tests/JoinArrayTest.php. I haven't implemented them for MongoDB, but I'm sure I can do it transparently. Moreover, I'm looking also allow join cross-vendor, here is more info: https://github.com/atk4/data/issues/91 Agile Data is not an ORM, I mentioned that it's similar, but it's a different concept. It implements relation support - one to many, many to many as well as one to many to many to many. (deep traversal). http://agile-data.readthedocs.io/en/develop/relations.html Here is example: $m = new Model_User($db); $m-&gt;load($logged_user_id); $sys = $m-&gt;ref('SystemAccess')-&gt;addCondition('is_deleted', false)-&gt;ref('System'); var_dump($sys-&gt;export()); This simply outputs list of systems that are linked with a user record through many-to-many relationship and on top of that adds a condition for the joining table. The above code will map into a single SQL query. Relations are implemented through a special relationship class, that are pretty flexible and can transition between different data sources too. For the "Nested" data, the implementation is quite simple: $invoice-&gt;hasMany('Line', function($invoice) { $p = new Persistence_Array($m-&gt;data['lines']); return new Model_InvoiceLine($p); }); Here is how you can use it: $invoice-&gt;load(123); foreach($invoice-&gt;ref('Line') as $line) { $line-&gt;updateTaxValue(); } $invoice-&gt;save(); Thanks all for the feedback so far, keep it coming ! 
You can still clone a model ;)
I think the article was saying that HTTP belongs in application layer if the TCP/IP model. And http relies on the lower layers of the stack; transfer, network, physical to pass the http payloads from client to server. I'm not sure how this is not true. 
Would I be able to just use uniqid() then? All I'm doing is getting images from users and then storing them in a directory. They just need unique names that don't have a chance of repeating. 
Thank you for your comments; I can make those adjustments. Since the code is meant for only one user on their own local computer, I took some short-cuts, but I can go back and fix those. I hope you liked the overall design better than the details. 
Can we get a working 201 Created implementation that uses the `Location` header as the location for future requests for this resource, and displays the body of the response? Y'know, like the HTTP1.x 201 Created response was supposed to do? I think it'd be really amazing if we could cut the number of requests by oh... about 50% over POST-redirect-GET, if we could just provide the page in response to the POST request and tell the browser where to go if the user attempts to reload the page. With the increasing number of ad agencies hijacking the back button, I'm pretty sure history hacks to fix this are going to go the way of popup windows.
People often cite performance as a reason not to use immutability. What reference do you have to back this up?
There were a few cases. This is the issue from my older version of a similar framework, but the implementation was quite similar: https://groups.google.com/forum/#!msg/agile-toolkit-devel/tdV1x8GTR8M/OftBCachBVMJ 
&gt; Should I check if the ID exists in the database or will random_bytes never repeat? There should be a unique index for the column that stores the I.D. Although in theory you will almost never see a random number repeat, bugs in random number generators an occur, as well as just bugs in your code can occur, where you accidentally insert the same data twice. If a duplicate key does cause an exception, just reprocessing the whole request is the correct thing to do. On the re-process a different random number will be generated, and if you're getting two duplicates in a row, something is seriously weird. Reprocessing requests on database exceptions should be done anyway....as DBs can be randomly unavailable due to networks not being 100% reliable. 
I wasn't to follow all of that but it seems like the issue was creating too many object references that are not destroyed by garbage collection. Doing `$foo = $foo-&gt;withThing()` is (typically) garbage collected and results in no significant memory overhead.
The problem was actually with time it takes to set up all related objects. Model object in Agile Data is not trivial, so even cloning would take time. Agile Data have been based on feedback from thousands of users and it's the first time immutability even came up. I don't feel that it would improve any aspect of the library.
HTTP is client-server model agnostic. A network stack doesn't necessarily even need to be involved. I know it sounds pedantic but I feel it's an important aspect of HTTP.
As long as you only need to worry about collisions, and not users guessing or gaining access to other files, then yes, uniqid (with both parameters, prefix and entrophy) by itself is sufficient. The UUID that /u/mnapoli mentions is a bit more standardized across libraries but is overkill for the scenario you've described.
"Took some short-cuts"... Not that that would be ok anyway, but no, no you didn't. Your in_html function body is more verbose than simply using htmlentities.
Why don't you just use the md5 hash of the image as the key? That way you won't Store duplicates.
Uh-oh **agiletoolkit**, it looks like there's **1** broken markdown links in your post. I've listed them below: Fixed Link | Original Markdown | Fixed Markdown :---------:|:----------:|:----------: [Agile Data](http://git.io/ad) | [Agile Data](git.io/ad) | \[Agile Data\]\(http://git.io/ad) *** ^(I am a bot, and this action was performed automatically.) [^Feedback](https://np.reddit.com/message/compose?to=lucadem1313&amp;subject=Link%20Fixer%20Bot "Contact to report issues, ask questions, or leave some feedback") ^| [^Formatting ^Help](https://np.reddit.com/wiki/commenting "Reddit.com markdown guide") ^| [^Subreddit](http://np.reddit.com/r/thelinkfixerbot "Subreddit for bot info") ^| [^Original ^Comment](https://np.reddit.com/r/thelinkfixerbot/comments/4vo43z/list_of_all_posts_with_broken_links/d6gvscs "Record of original comment")
If you hash based on the content, not on the name, then both will be stored with different names.
Could you provide benchmarks? It would be interesting to see wether this might be worth it to use in some of my more db-heavy projects.
That's a good bot.
It's a good way to eliminate the possibility of guessing identifiers. There are multiple use cases where this could come in handy. This, however, does not replace checking the user's permissions. It's also nice that you can generate the UUID before inserting the row into the database, where-as with auto increments you have to insert the row (or retrieve NEXTVAL()) before you know the identifier.
Decoupling is one of those things that's great to strive for but probably impossible to achieve. Interfaces in particular suffer the Goldilocks problem: an interface trying to meet the needs of multiple projects will end up being too simple or too complex for the majority of them.
The biggest advantage for UUIDs is that you don't need the actual database to create a (primary) key, which of course helps a lot with distributed databases but also few edge cases where you want to skip network roundtrips. It is also unique everywhere, so you can just handle users and blog posts with one index. xP With UUIDs you have to rethink a few things. Inserting a single record by hand is impractical, because you need a UUID first. Bulk operations make this even worse. What is likely to happen is that you have a stored procedure in your database and in php which should act in the same way. This way you can insert records without generating UUIDs by hand, but you also have the option to generate them on the fly without a database. UUIDs are also much larger then integers which can be an issue if you want to conserve memory consumption. Keep in mind that every database requires you to keep indexes in memory to respond reasonably fast. I would avoid UUIDs as long I don't have a serious need for it.
Objects should be in a valid state as soon as they are instantiated, relying on your database to create your entity's id means that it is in an invalid state until it is persisted. Generating a uuid and passing it to your objects constructor eliminates this issue.
Having a 20 years of PHP development experience and after spending 6 months in research, refactoring and building a [project](http://git.io/ad), [sharing](https://www.reddit.com/r/PHP/comments/4xjus9/agile_data_my_second_opensource_project_efficient/) it on reddit and being critiqued on a minor points, I can say this: - re-consider. Do you need publicity? Will your project benefit from it? - running a public open-source project is a lot of work. Are you prepared to maintain it for next 5 years? (especially financially) - do your [research](https://www.reddit.com/r/PHP/comments/4f2epw/reinventing_the_faulty_orm_concept_subqueries/). Are you actually solving an existing problem? - try a narrow audience first. Avoid sharing with friends, ask people you have never met before. Do they find your project newsworthy? If you clear those questions and are willing to continue, do the Stack-overflow challenge: Find questions that users posted and were unable to find a solution. Would your library/framework be an ideal solution? (don't spam answers there) If you are still willing to continue, here are some tips: - expect negative feedback. If you get a good comment, that's great! - be polite. Follow up with posters, many of them took a good time to look through your project. - most users feel an obligation to pick a bone, make them search deep for it. - reddit consists of experienced PHP developers who are set in their ways. Is that your target audience? Maybe a local PHP group with more novice users could be better fit? - have your expectation right. Post to get suggestions. - if you post overly positive post, people will be more negative. If you are neutral and are asking for advice, people tend to be more supportive. - post elsewhere. Find a good format and ask around. Be very clear about what you try to achieve. - if you get negative feedback, don't get discouraged, review your solution and try again. - it's normal that 95% of visitors will decide not to use/try your project. Several years ago I've posted my UI framework on stack-overflow and after a while I had 30k users. Not much by some standards but given some time you'll see the result. I might write some more posts and perhaps even do a talk on how to correctly do "reinventing". I think there is a lack of guidance and just like there is "http://12factor.net" for app development there needs to be a check-list for reinventing.
It's called ISP, and not CSP, for a reason. ISP is not a solution to partially loaded entities.
He applauds your horrible effort.
This brings forward an architectural flaw of how ORMs tend to do persistence, rather. The better factored approach would be you pass construction parameters to your entity collection manager (aka service, aka repository, aka mapper, aka ...), and then get back an object in valid state.
&gt; Inserting a single record by hand is impractical, because you need a UUID first. Can you explain your reasoning? I have no problems inserting records 'by hand' (though I usually use code). &gt; What is likely to happen is that you have a stored procedure oh heck no. That completely defeats the purpose of using UUIDs. Just create the objects in memory, and save them.
&gt; It's a good way to eliminate the possibility of guessing identifiers. I can think of only one issue with guessing identifiers: guessing the volume of business a company does. There are ways to hide this information without changing the schema of the database (i.e. you can keep using incrementing PK internally). Any security reasons I've heard about avoiding incrementing identifiers are mostly an attempt to obfuscate a different flaw in the system, instead of solving it where it should be solved. But I'd be happy to hear an objection to this statement.
You are technically correct, the best kind of correct.
When you have distributed database or you just don't want to be tightly coupled to specific db (in domain-first approaches)
Every entity should have identifier right after you call constructor. This is responsibility of entity to provide such identifier. This could be user's email, book ISBN or anything that identifies that entity. Sometime you need some generated uniq id and UUID also helps here. All this infrastructure stuff should not interfere.
It's best to separate the concept of identity from authorization. You can have a short Dropbox file identifier, followed by a long random password. The identifier doesn't have to be the password itself, because the identifier alone is not enough to access the file (as a user). In fact, in the case of Dropbox links, I'd argue it's best to make the password longer than 128 bits (length of UUID). UUID is not sufficiently complex to be secure in this context. It's only sufficiently complex to avoid collisions within some pragmatic range it was designed for.
&gt; &gt; What is likely to happen is that you have a stored procedure &gt; &gt; oh heck no. That completely defeats the purpose of using UUIDs. How do stored procedures defeat the purpose of using UUIDs?
I would argue never, because UUIDs are an over-complicated format. Try 16 random bytes instead.
I'll never stop being nervous about collisions, because while I understand the math behind it, as an industry we have a history of data corruption and security problems caused by misbehaving PRNG not delivering the entropy they promise.
I have never considered this before, but now I want it.
yay im stupid! guess I googled bad! good thing it took me not more than 2 hours. but how would you go converting to a string only containing letters in [a-zA-Z] range? edit found it in the second piece of documentation., I'm totally dumb.
The benefits by far outweigh the dangers.
BTW. [Hashids](http://hashids.org/php/) is a pretty cool library for converting ints or sets of ints into string hashes
Yes, but I believe that the entity may not be valid since it hasn't actually been committed to the database. You can have a representation of what should be in the database, but there is no guarantee of that upon construction. I guess what I'm trying to say is that there is a difference between an action (storing data) and the effect of that action (a row in the table).
I figured
Are you a Web developer?
You can redo the package to make this task easier, it still has value. But it will be much smaller and a lot more efficient and faster :)
&gt; How do stored procedures defeat the purpose of using UUIDs? They prevent you from being able to create a complete valid object in memory, without having a round-trip to the database. Instead you have to either create a partial object, and then send it to the database to be converted into a full object, or, more commonly, you create an invalid object and save it, at which point it becomes a valid object. Example code using DB to generate the Id: class User { function __construct($id, $name, $emailAddress) { ... } } $invalidUser = new User(null, "Danack", "Danack@example.com"); // This user object is not valid, null is not an allowed value for the Id $validUser = $db-&gt;save($invalidUser); //Only now is the user object in a valid state. With using UUIDs: class User { function __construct($name, $emailAddress) { $this-&gt;id = UUIDV4::create(); $this-&gt;name = $name; $this-&gt;emailAddress = $emailAddress; } } $validUser = new User("Danack", "Danack@example.com"); // user is in a valid state whether it has been persisted to the DB or not. When you have a way of completely eliminating a whole class of bugs, then it's almost always a good thing. Having objects always been in a valid state eliminates any possibility of doing stuff to an invalid object. 
I can't actually use base_convert() since it will accept a base that is no bigger than 36. but an example in the documentation from that function will help me greatly reduce my code base. I'm not that strong at math. as you might have noticed.
Also instead of passing incremented Ids in the url. 
Cool. I used https://github.com/php-mock/php-mock yet for this. Can you perhaps short explain what are the differences? So far there are any.
Mine doesn't rely on namespace fallbacks, so it's okay with things like non-namespaced code, or `use function strtolower as toLower`, or `$callback($string)`, and even `array_map('strtolower', $array)`. Edit: obviously, it doesn't make sense to redefine/intercept `strtolower`; it's just an example.
There are some benefits in REST services to let the client determine the URI of the resource you are creating. Doing this allows to `PUT` new resources using the target URI that will be created, instead of `POST` on some sort of parent/collection resource. This gives you a number of benefits, notably idempotence. It's useful for a client in those cases to pick resource URIs that are likely to be unique. Using a UUID for a part of the URI is pretty common here.
That's literally what the linked article is about? Having said that, there is always the option of a v1 UUID that would eliminate this issue.
I agree, I don't care how many zeros of probability. It's not hard to check either, or have a auto-increment primary key.
I wasn't specifically referring to UUIDs. You said: &gt;I can think of only one issue with guessing identifiers It says nothing about the length. Make the link contain some random 100-300 byte string and you are good to go. If you call that id, id + password or whatever seems purely semantic to me.
$Money 
Those problems are fixed in the revised code that is now available for download. But, it looks like I've used up my 15 seconds of internet attention with some amateur-ish errors on my part. The un-answered questions in my mind are: Is anyone else looking for a lightweight, cross-platform, portable program vehicle, and, if so, what do they think of my modest first attempt? And, is anyone else looking for a local note-taking application, and, if so, what do they think of my attempt in that regard?
I talk about manually inserting a row via shell.
IMO, that's the wrong PoV there: just make a unique key constraint and you'll have your familiar failed transaction, with no need to overthink it. That 1 in a billion request will just fail, but you'll have a generally simpler system. EDIT: I also make this analogy, usually: The possibility of a 128bit RNG collision is so low that it is more probable that an asteroid hits our planet. Should that happen, then we got bigger problems than just your app.
@thyde2 nice work putting this all together! it's a great way to organize a bunch of little notes. There are many things we could offer as suggestions on your code and organization, many of which would likely be really helpful as you deal with bugs and modifications. Some of the most helpful first steps could be: - modularizing the code into separate files (with separate namespaces, either using PHP namespacing or …cough… classes as namespaces) - incorporating some kind of template system to allow some clearer separation between the "server"-type code from the HTML presentation of the data (could use something easy like Smarty or you could …cough… roll your own) - adopt a more standard style for code formatting. check out the PSR-1 and PSR-2 standards (http://www.php-fig.org/psr/psr-2/) and some auto-formatters to make the transition easy (http://cs.sensiolabs.org) - some of the coding style is particularly prone to allowing bugs in undetected. specifically, the use of `if (…): endif;` is curious because it hides the many nested conditionals. that is to say, it appears like there are independent `if ()` conditions being examined when in fact the second or third only execute if all the previous ones are true. these kinds of things aren't technically bugs, but they make it very easy for bugs to slip in and can make it very difficult to debug. just curious, is there a reason you have avoided using curly brackets on conditional structures? as a final note, it is worth pointing out that there's a difference between something being simple and something being limited to primitive code structures. this note app doesn't use many higher-level PHP features and in that sense it could be considered simple, but in reality it is not the design or the code overall that is simple, but rather individual lines in isolation that are simple. the simplicity of the individual lines obscures what could be the simplicity of the way the app works from a higher perspective. this looks like a fun project to publish in a public source repository (like GitHub or BitBucket or GitLab etc…) to elicit feedback and contribution. best wishes with it as the project progresses.
&gt; you should eager load the relations you need before using these fields Or just use joins like a sane person. 
Use a better hashing method. 
What am I looking at here? More stupid FIG drama?
&gt; Thank you very much my pleasure! &gt; years working as a one-person department I get that. we all do. the way I like to think about it though, is that we are always programming for other people because our own self six months from now will be a very different person than we are right now writing out code. we'll lose a ton of context if we start working on other problems and it will help us just as it would help someone else to use these code practices. that is to say, I think you will find that it benefits yourself as a one-man-show to code as if you were writing for others. &gt; However, I still like the idea of distributing the program as a single file curious why this is. the package already contained several files even though it was a single PHP file. there are ways of packaging PHP source into a `phar` file for distribution. personally I find it dizzying scanning through 2000 lines of code instead of being able to make a reasonable guess based on file structure - "views/note_grid.php" or "note_storage.php" or something like that.
&gt; As we know eager loading generate multiple queries instead of join. That's not the case. Eager loading simply means loading things in advance, instead of on-demand. With that in mind, you'd need to correct your question so we know what you're really asking. Also, a better place to ask would probably be either in the discussion thread pinned on top of this subreddit, or here: https://www.reddit.com/r/phphelp
The EAP expired for me after 30 days.. am I missing something
I work with eloquent nowadays . For example $books = App\Book::with('author')-&gt;get(); the above code will generate two separate queries for getting Book and Authors table right ?. This is what I meant. Please correct me If i am wrong 
Certainly looks like it. Thought this crap was over with, why is it being revived? 0-0;
Eloquent is not able to automatically generate a join for a command like that, as far as I know.
You are not getting my point. There is a reason join exists. In this example there are only 2 relations. There could me many more $books = App\Book::with('author.comments.commentsAuthor')-&gt;get(); This is now 4 separate queries instead of join I know this how it happens with Eloquent. There is nothing wrong in it. There are certain situations we should go for eager loading and there are some situations we should not. 
Joins don't work well for one-to-many relationships, especially where you are selecting several of the one. Laravel is perfectly capable of using joins, if you use the has() methods or whereHas() you will see that is uses them, they have chosen not to use them for eager loading.
&gt; None of that is easy with **16bit** custom implmentation. With 16 bit hash collisions are major concern if your application has distributed high volume writes That's right, but note /u/the_alias_of_andrea was talking about 128 bits. With 128 bits or 16 bytes, it is not possible to see a collision. To put this on number, there is a 1% change to see a collision after *2.6 × 10^18* runs. With such huge numbers, it has nothing to do with luck, it is pure math. 
Article needs *a lot* of work...
Can you please explain how it can be ? I just tested it on my servers and logged time for both. Joins looked faster
...
Dear, why you so rude? :D btw, he/she posted another article about http env vars you should read it (lol)
I don't understand your gripe here. Querying multiple times per request isn't bad
If you are writing a very complicated query that has the potential to be slow (probably for something like a report) it's quite likely you'll want to use the query builder or even just a raw query. Pretty much anything "standard", Eloquent will handle well.
It is not bad . But on properly indexed tables joins (inner joins) are much faster
&gt; Also how the hell can it be fair that Paul Jones can cast a vote for himself as Aura...no other secretary nomination is a voting member. On what planet is that a fair voting system? It gets better. There's a [bylaw that prevents secretaries from being voting members of the FIG](http://www.php-fig.org/bylaws/membership/#eligibility-criteria): he's not even eligible to be nominated. However, people are reading that bylaw charitably and saying that he can be nominated, but if he does get elected, he has to resign his membership then and will have to appoint someone else from the Aura project to be its voting member. Considering pmj is the largest contributor to the Aura repos by an order of magnitude or more, the chances of him not either a) creating a sockpuppet or b) appointing a proxy vote for himself are slim to none. And even better than that: pmj [blocked the nomination of a Silex representitive on the exact same grounds](https://groups.google.com/forum/#!msg/php-fig/R5TQ_YD7unI/GBy-b8KIHa0J) years ago. 
Thanks for the quick answer. I definitely will give it a try.
1. /r/phphelp 2. You cannot "fix" it. there is no PHP where Javascript runs. Go to phphelp subreddt and ask a brand new question not on couters but on the more general problem you are trying to solve. 
It is, it's just not always the best/most efficient way of doing it, especially when you add caching into the equation.
Yes *only* four simple queries that map directly onto the orm objects that could actually be a complex tree structure. And that is done without having to de-duplicate the results that you would have got if done using one query joining all these tables - just how many times would the name of the book have been fetched? At least as many times as there are comments. Eloquent eager loading can help speed that up immensely. 
Then you have to unravel the results if you want to put them into the orm model objects. If you just want the raw data for a report, then go for the custom query.
thanks for reply and sorry for wrong subreddit. shall i delete this post?
The short story of HTTP/2 is that Google had enough balls to say out loud HTTP sucks, and make a competitor (SPDY). Then that competitor started to see adoption... So the HTTP committee was pressured into adopting SPDY as the first draft of HTTP/2, despite earlier deciding all is cool and HTTP/1.1 is perfectly fine as it is. That's all good, and just proves that even standards need competition, or everything goes stale. P.S. Did you know that when the HTTP group was recently revising the HTTP specs, they decided GET requests can have a body? I don't know if anyone is using that, but... huh. It's a nice addition, despite I don't know if anyone is using it.
[removed]
Can you please write an http:// URL which doesn't refer to a TCP/IP socket? :-) I know it sounds pedantic, but the **hypertext transfer protocol** is a lot less useful without **hyperlinks**. You can tunnel a bunch of plain text through anything (as Google's QUIC experiments show), but HTTP is still bound to TCP for all practical purposes.
In reasonable/typical query row sizes and number of rows the overhead of the extra book name is far less than the query overhead, every time and always. I'm really surprised to see so much FUD related to this in this thread.
&gt; True, I'm currently using class prefixing for logical separation. Prefixes "Persistence", "Field" and "Relation_" can happily live in their own namespace. Since this is a 1.0 version it still needs a lot of polish, but I wanted to get the initial traction with the user-base before committing to further refactoring. This might not have been the best idea if you want to comply with SemVer - backwards incompatible changes to the external API are only possible in major increments IIRC.
I'd say there's no point in using auto incrementing identifiers other than laziness. It's easy to accidentally expose stuff you shouldn't by using aii. For ordering it's very standard to have an order column. For indexing it makes sense, but that's not an identifier. If an object is identified by a value, having that value give info about other objects and volume information about the system is an unwanted side effect. The only drawback is collisions. But that's also easily avoided. 
You can define whatever conditions you like to make solution A "better" then solution "B". The real world is a bit more complicated than that - nobody here is saying any ONE approach is ALWAYS better than any other approach. I don't see the FUD. Just *understand* what is happening within the code and platform, then you can make the most appropriate decisions on how to build, which should also take into account the costs and benefits of premature optimisation.
&gt; As a rule of thumb, if you generate IDs with 128 bits of entropy, there is no need to check whether the ID already exists. As an expansion to this, just use a UUIDv4 at this point. [ramsey/uuid](https://github.com/ramsey/uuid) is the suggested solution, as it'll use random_bytes if you have it (or other trusted CSPRNGs if you are not running PHP7 due to the usage of random_compat)
This reddit post was the first exposure to any developers apart from my core team, we have literally just finished the first stable code. That's why I'm trying to collect feedback early on. The poll issue is here: https://github.com/atk4/data/issues/101 and I will follow our versioning guidelines: https://github.com/atk4/data/wiki/Use-of-branches.
I'm aware of the real world. I've scaled multiple web apps to millions of users. I've also screwed up that process in other apps. The FUD in this thread is this odd recommendation to just "Do some more queries, they don't really matter." That is, in my opinion, an inaccurate default recommendation. The correct default is to make as few queries as possible, but if you know the data enough to do otherwise then have at it. In the case of my reply above, I'm not creating a straw man. A typical app has limitation in the data it returns that are just base on usability. Most apps don't return 10k rows because they won't be diaplayed. Real world apps return 10s or 100s of rows. In these cases returning an extra column is going to be under the extra query overhead just about every time. Are you implying a join is premature optimization? A join is not premature oprimziation. it's literally the default state of handling related data in the second most ubiquitous data storage system (various file systems being first) on the planet, an RDBMS.
JSON, YAML, etc are nice. But PHP format, as in OP, is nice too. Once compiled to bytecode and saved in opcache it's wicked faster to access: no parsing and re-parsing required. Of course, the difference will only matter if hitting it frequently on a high-volume site. $stuff = '&lt;?php return ' . var_export($myConfig, true) . ';'; file_put_contents($myConfigFileName, $stuff); 
within 30 days they most of the time have another EAP
Makes me wonder, how come the PHP FIG doesn't have a... PHP voting app for this stuff, anyway. It took the RFC system ages to get one, now this. You'd think it's the first thing to occur to a PHP developer - "Hey, I can PHP this!"... But... no.
&gt; As a rule of thumb, if you generate IDs with 128 bits of entropy, there is no need to check whether the ID already exists. If you could be so kind as to explain how you tell if you have 128 bits of entropy for the lesser mortals ;)
You are right parsing the file can be a problem in a busy site, and a php file with op cache will work a lot faster. Thanks for the complete example as well. 
Unfortunately all kinds of crap happens everywhere. The main difference is how well encapsulated it is, and in the open source world it's less encapsulated, than, say, compared to what happens at Oracle, Microsoft and Apple. It's like objects. The internal implementation is always crap, so at least make sure the public interface is clean. :-)
I'm interested in knowing what volume you are experiencing for uploads, or what problem you are attempting to solve? **KISS** (**K**eep **i**t **s**uper-**s**imple)
My mistake I miss read as 16bit.. which is obviously much smaller . However the point regarding standard libraries compatible libraries still remains
In php ? Ramsey/uuid has worked well for me so far. Adding bits alone is not going to help. entropy is a bigger factor. I do like mongo's object _id . it can be easily indexed and still supports distributed generation. client side creation of course is not possible. 
That's not what the RFC says. Edit: Also, the URL and URI are different. The HTTP server doesn't need to know or care what you typed as the URL. It only knows the URI you passed to GET (or another verb).
why do you need mutable datetime or single interface or implementation for datetime interactions? It's smarter to have smaller, easier to test units of code, and are they not just signed integers under the hood? 
&gt; That's not what the RFC says. It's what it says: *"Although HTTP is independent of the transport protocol, the "http" scheme is specific to TCP-based services"*. So you can send HTTP however you want, but "http" links always point to a TCP socket. &gt; Edit: Also, the URL and URI are different. That's quite irrelevant here. URI or URL, the scheme is "http" (and "https"). A link can use any scheme, but there's currently no standard about links that point to HTTP on top of anything else, except TCP. 
I fixed one yesterday. Support tickets. Anonymous people can create new support tickets. They'll leave their email address and get an email with the link. The link was /ticket/[incremental id]. This is obviously bad. However it's a requirement that people without logging in can create, view and update their own tickets. Here the uuid solution is OK in my opinion. The system doesn't have critical information so if a single ticket would be 'compromised' damage would be contained. The alternative would be to automatically create user accounts for initially anonymous tickets. I agree that would he safer and better, tho in this situation overkill. However using incremental ids is obviously very bad in this scenario. If you have a better solution, I'm open to it. 
Unless you have a really good reason, don't generate php files. If you need to store some info to file just go json_encode() and file_put_contents(). 
Here's what the HTTP RFC says (Section 1.4): &gt; HTTP communication usually takes place over TCP/IP connections. The default port is TCP 80 [19], but other ports can be used. **This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks. HTTP only presumes a reliable transport; any protocol that provides such guarantees can be used;** the mapping of the HTTP/1.1 request and response structures onto the transport data units of the protocol in question is outside the scope of this specification. As an example, you can have an HTTP server listening over local [named pipes](http://stunnix.com/a/http-over-named-pipes.shtml) if you wanted, which uses memory mapped files. Listen, I get it that HTTP, the way it's implemented today, relies on TCP/IP about 99.999% of the time. But it doesn't change the fact that the core HTTP protocol is independent of it.
~~+0~~ +1 from user Dgc2002
I keep referring to the hyperlinks schemas, and you keep citing something I never disagreed with. Without links, you can't use HTTP for its intended purpose. &gt; As an example, you can have an HTTP server listening over local named pipes if you wanted, which uses memory mapped files. Yes, and how do I link between resources on my named pipes, again?
This.
What kind of apis are you looking at? How different? Most things are json rest(ish) nowadays. Is there a specific api you want? 
DAE avoid switch statements? I think the syntax looks so horrible and unlike any other syntax (colons, lack of curlies) that I rather write if else statements... Am I alone in this and should I get over it? 
If you don't disagree with what I've cited in the RFC, then why are we having this conversation? &gt; HTTP only presumes a reliable transport When you boil it down, that's all that needs to be said. It only presumes a reliable transport, i.e. that the messages, in their entirety, are guaranteed to get from A to B. It doesn't presume anything else. After that you're just splitting hairs.
Have fun dealing with this then: https://github.com/ramsey/uuid/issues/80. No offence, but even mentioning Mongodb makes me question your skillset.
I didn't notice the link &lt;_&lt;
e.g. to generate config files.
&gt; Now that the vote is done, I can assert openly that this was a “clearing the decks” operation. It was intended (in large part) to remove the most-vocal opponent to the FIG 3.0 proposal by Larry Garfield and Michael Cullum, and to prepare the way for implementing the Contributor Covenant (or some other SJW-inspired code of conduct). Look, I think CoC's can be absolutely silly as well. But you know what, if it makes women and minorities in our community feel safer about coming out to events and getting involved, so Im all about it. Get over your fears, no one is taking anything away, they are just trying to make sure that no one is kept out for fear that someone will be a dick to them. And if they are a dick, there is a way to take care of things. Good lord, reading the shit you write you would think there is about to be some war about it. There isn't. Like someone else pointed out, it would have been better if you took the high road and just shut up. 
There is nothing unprofessional about sharing your view on a matter which directly affected you. In fact, it is the lack of opinions and views which leads to group think, creates lack of challenging thought and ultimately deteriorates quality of discussion, inclusion and output of any organization. So Paul's views are more than welcome :) Looking forward to part 2.
Not at all! When looking for code smells, `switch` is a prime candidate for refactoring. https://sourcemaking.com/refactoring/smells/switch-statements
As one of the people whose name was in the list, I gotta say this is not true. And that I'm disappointed that it seems not a shred of it has made you consider how you interact with others. 
Since he said a lot of things... which ones are "not true", more specifically?
Troll.
Are you using Eloquent because you are also using the Laravel framework? You could maybe use another ORM that supports loading associations using joins?
HTTP doesn't presume anything else, but it *depends on the HTTP URI schema*, and that ones presumes TCP. We're developers. You'd think we understand how dependencies work. As it is, you'd need to invent a new URI schema in order to use HTTP effectively over non-TCP transport. So the HTTP spec is not ready to be called "independent" of TCP as a whole, despite a set of RFCs covering aspects of HTTP are independent of TCP.
&gt;Lack of curlies is no ones fault but your own: Not really, [the official documentation](http://php.net/manual/en/control-structures.switch.php) avoids them. &lt;?php switch ($i) { case 0: echo "i equals 0"; break; case 1: echo "i equals 1"; break; case 2: echo "i equals 2"; break; default: echo "i is not equal to 0, 1 or 2"; } ?&gt; 
&gt; There is nothing unprofessional about sharing your view on a matter which directly affected you. The *entire article* consists of assigning motivations to people without any supporting evidence whatsoever.
"evolvable" seriously... PHP-FIG will never stop to amaze me. Those interfaces are either too opiniated, either too small and too restrictive (nothing about segment ? scheme ? anything about manipulation of those links ?). Damn, not really useful.
He's eligible to be nominated, just not to actually become a Secretary, when you stand for president, you can be a senator, you just have to resign before you take office. And as I stated, unless Aura resigns entirely, there will be a vote on whether or not he is eligible to be Secretary and Lead Aura Dev whilst Aura has a vote.
The vote has settled the matter of "what to do about Paul". He remains the representative until such time as the voting members decide not (as in the case of being elected as a secretary for example). I do not want to discuss this point further (except where related comments/threads directly counter assertions he makes in the post linked at the top of this thread). &gt; Now that the vote is done, I can assert openly that this was a “clearing the decks” operation. It was intended (in large part) to remove the most-vocal opponent to the FIG 3.0 proposal by Larry Garfield and Michael Cullum, and to prepare the way for implementing the Contributor Covenant (or some other SJW-inspired code of conduct). I predicted that conversations about both would resume very soon after the vote no matter which way it went, and that looks to have been prescient. There are 12 names on the list. 12 people that wanted to publicly state their distaste for how Paul communicates on the mailing list. Further, a number of people mentioned how they went directly to the secretaries and/or directly to Paul about this issue before the discussion reached the mailing list: - Stefano Torresi mentions the behavior in question being discussed (at a FIG meeting on PHPDay), and then talking to Paul about it on the mailing list. (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/hRargwV8AAAJ) - Mike van Riel mentions indicating that "there is a situation that needs to be resolved". (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/Drfp9kB8AAAJ) - Lukas Kahwe Smith mentions attempts being made by several people off-list (including [himself]) to improve collaboration of Paul with others on the list. (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/N6dulQlCAQAJ) Note: I make no assertions about whether the people on the list communicated directly with Paul or not. The claim that "this was a “clearing the decks” operation" seems predicated on the idea that Michael and Larry hoodwinked at least 8 people into observing, putting their names to, and publicly discussing a non-existent problem. The voices of many people (https://groups.google.com/forum/#!topic/php-fig/w38tCU4mdgU) speak against that theory. &gt; The complainants, and their secretarial collaborator, wanted a vote (not mediation) from the outset. I guess they figured it would be a slam-dunk to have me removed. What they didn’t expect was that roughly half of the participants would be either against my removal, or against the complainants themselves. I can't speak for what the other folks on the list expected, but I can speak for myself. I expected a reasonable discussion aimed at fostering better communication in the group (with a last resort vote, as the only bylaw-allowed process for removing a voting member deemed destructive to the goals of the group). At best, this is an attempt to put words in my mouth. &gt; So instead of a slam-dunk, they had actual resistance on their hands. That’s why the secretarial collaborator dragged it out past the 2-week point, so there could be some chance of rallying support for the “removal” side. Little support was raised that was not shortly pushed-back against. This is a lesser point (but I do not want to be accused of cherry-picking parts of the post that could be twisted to suit any kind of narrative, to borrow heavily from the political tone of the post linked at the top of this thread). - The discussion hit the group on June 24th. - Paul Tweeted about the discussion on the July 1st (https://twitter.com/pmjones/status/748935397619617792). - Paul first responded to the discussion (on the mailing list) on July 6th (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/EUehhuf6CAAJ). At this point, the 2 weeks was already almost over. It's reasonable for the discussion period to be extended, especially given Paul's comments (on July 6th), that; "The complainants should specify how removing me as a Voting Representative will salve their woes." &gt; Then the complainants realized they had no options other than a vote, which they now thought they might lose. This is why they revived the idea of “alternative resolutions”. But they themselves presented no alternatives other than “shut up” and “go away”. The first message (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/R1oyiIMuAAAJ) specified a couple things. If the discussion went on for too long, a vote would happen. And that an agreeable conclusion could also be reached before that happened. Again, the only bylaw-permitted (final) resolution to the discussion is a vote to replace a representative. The secretaries (Samantha was just as vocal as Michael in the discussion) did nothing outside of what is allowed in the bylaws, and helped only to serve the voting members by facilitating discussion. Many people indicated that they felt a vote was a last resort, and that a constructive outcome could be achieved: - Graham Daniels thought "the _discussion_ was warranted and [would] hopefully have a constructive outcome". (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/2IR3Dh10AAAJ) - Matthew Weier O'Phinney (and the Zend Framework CR team) viewed an expulsion vote as moot and that the discussion was not done in a meaningful way. (https://groups.google.com/d/msg/php-fig/J6FFP2x74k4/mN4SUpOwBAAJ) - Jordie Boggiano voted for expulsion, but made it clear that it would not ban Paul from the list but would send a message about the behavior the voting members support. (https://groups.google.com/d/msg/php-fig/J6FFP2x74k4/F4apc547BQAJ) - Fabian Potencier shared the same views as Matthew Weier O'Phinney and the Zend Framework CR team (https://groups.google.com/d/msg/php-fig/J6FFP2x74k4/5Ye-I0qMBwAJ) - Mike van Riel mentioned; "Despite the current situation I would prefer to see the issue resolved without the need for drama but that a solid understanding of the issue and mutual empathy will bring us as a FIG closer together." (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/Drfp9kB8AAAJ) - In response to an inflammatory comment from Paul, I stated my view that "Asking for something to be addressed/discussed is in no way a desire to hang you". (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/JA-pXcb4CQAJ) - Rafael Dohms reiterated that he felt alternative conclusions could be reached instead of an expulsion vote. (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/ezenzZZ3CgAJ) Some of these statements were made before the vote started, some during the vote. They all seem to suggest that voting was not the only (or even an effective) detterant to undesired behavior. To suggest that "we had no other options" is demonstrably untrue. I'll not go too much into detail about the suggestions (to Paul) about what Paul could have tried. Some of them were questionable (like a separate language review group), but a recurring theme was an appeal for Paul to at least consider how he was communicating with the group. By all appearances, that did not happen. &gt; Even at the end, to keep their actions and their bias hidden, the secretaries suggested (to me personally) making the vote private, on authority they have not been granted. I have no knowledge of this suggestion, but I do know that someone else also suggested this (https://groups.google.com/d/msg/php-fig/w38tCU4mdgU/UWuxMeNCAQAJ). Paul doesn't seem to suggest that anybody attempted to force a private vote, merely that they offered it as a suggestion. Did they declare this would happen or did they suggest it? That seems more considerate to Paul than anything else. &gt; Remember: the secretaries, in particular Michael Cullum, overstepped their bounds once again to enable this drama. I can only assume this is about the Dracony expulsion vote, in which the secretaries reversed a mistake they admitted to making mere hours after making it, in public. I remember very clear how Paul flagellated them then, and it seems this will be used as the basis for conspiracy theories for a while still. Paul hasn't pointed out any transgressions from any of the secretaries in the discussion about his removal or the vote that happened thereafter, so I'm left to wonder what overstepping Paul is referring to here. &gt; Even so, I must caution against reading too much into the results of the vote. The voters did not approve of me per se, so much as they disapproved of the complainants, the complaint itself, or the act of throwing someone out. It is not so much a vindication for me personally, as a repudiation of the complainants. Paul is the only person I've heard bringing up the vote, apart from where I used it as a reference to discuss how secretaries might resolve conflicts in future (https://groups.google.com/d/msg/php-fig/-Z6IYjcVRxo/EP99ji_OBwAJ). As far as I'm concerned, the matter is settled. I'm open to being shown where a voting member is still dwelling on the vote and/or verdict. So, you see /u/Airhead2016, I disagree with the majority of things Paul has said. It appears (in my personal opinion) that he is far too obsessed with conspiracy and with the desire to fight against things like the proposed FIG restructure, the roles of secretaries, and codes of conduct in this case. [Edits for spelling and grammar]
Just a site that generates some Dockerfiles. At least from what I can tell.
I like where FIG started, but this is really coming across as `AbstractFizzBuzzFactoryFactory`-level of overengineering. I'd be interested to see an actual example of where this is a real problem, since both the standard proposal and the accompanying "meta" document fail to provide this information. Perhaps this is just a documentation problem.
As far as "assigning motivations to people without any supporting evidence whatsoever", I've addressed the article [in a comment above](https://www.reddit.com/r/PHP/comments/4xtvqm/fig_follies_part_1/d6irr4d). I do not believe the points he makes are factually accurate, despite the things he links to. It's a misrepresentation of my opinions and motivations. I can't speak for the opinions and motivations of all the other named complainants, but I would be surprised if the other 7 agreed with much of what Paul has said here.
There were a total of three links in the post at the time I read it. The first link is to a discussion thread from June, with 180 individual posts. The second link is directly to the vote result. Not really relevant to anyone's motivations. The third a gist where he predicts what people will say about the CoC post-vote - not a link to anything people have *actually* said about the CoC post-vote. I'm not reading 180 messages in an attempt to find Paul's supporting evidence for him, no do I think the other two support any of the claims made. I think my perspective is a reasonable one.
The randomly generated bytes will randomly repeat at random spaced intervals. 
If 16 bytes doesn't give you a warm and fuzzy, then double or quadruple it. 64 bytes is not unmanageable. It is more combinations than all the grains of sand in the universe, plus all the grains of sand in all the universes within the multiverse. That being said, I always use auto-incrementing primary keys.
Have you tried [contacting](http://php.net/contact.php) them and asking?
What's a "templated link"?
I think there's a separate fig for URI.
The current design is mainly due to /u/MorrisonLevi.
It's for cases like https://github.com/blongden/hal (A HAL library for PHP) or https://github.com/Crell/HtmlModel/ (which models HTML as a REST format). You may want to read off links from some internal domain object to put onto a REST format object like those, or from those objects onto a PSR-7 response. It's a bit niche compared to many of FIG's specs, I agree, but relevant and useful for its niche.
And what's wrong with #80? Just use reliable random number generator.
"Evolvable" is the least-bad name we could come up with for "that with*() stuff that PSR-7 does". :-) It was an open discussion thread on the list for a while, and that's the one we ended up settling on. The withHref() method accepts an object implementing __toString(), which PSR-7's URI object is. That means you can just pass a URI object to it and it will be fine. If you want to manipulate the URI somehow after it's set on the link (which I find unlikely, but technically possible), getHref() gives you a string, you can parse that with a PSR-7 library and create a Uri object, do whatever you want to it, and then call withHref(). That keeps the spec nice and small and builds on work already done elsewhere in a compatible fashion, but without a hard dependency on PSR-7. So yes, they are cooperating, by design. (Side note: It's separate PSR. FIG is the organization, PSRs are the specs it publishes.)
&gt; A user can change their email as well. Yes of course. But they remain unique in your system. With name... you can have two different people with same name which makes name pretty bed identity. There are always some assumptions that we have to make. &gt; (as OOP systems do, e.g. ===) Well... you can check equality of two value objects but not entities. OO systems usually use some methods like `isTheSame` or anything like this. 
I like raw sql when the queries get a bit complex because thats what i know and i dont want to learn a new api every time.
I tried to build a feature around SMS previously and it's just way too limiting. The fact that SMS has no metadata makes it impossible to properly manage any kind of two way communication with more than a single party. Thumbs up to Twilio though, they were definitely never the problem.
Personally, I find it a tad classless to come out the other end of the FIG vote and then use that to fuel multiple slam-pieces on the very group that you fought to be a part of and intend on standing for nomination to secretary in. If, in fact there is some 'conspiracy' to have Paul removed, then maybe instead of using your survival of this vote to poke the bear more, you should consider a more moderated approach lest the 'conspirators' try and 'clear the decks' again. Finally, I'm glad I'm not the only one who appreciates the irony of the 'anti-drama' advocate going out of his way to keep the drama-ball rolling.
Hello, designer here. I don't really have any other design work. I definitely prefer to do back-end work. There are still a lot of things that bother about the PHP.net website but it's miles ahead of where it was. Thank you for the compliment.
Your designs on my life are appreciated. Glad to know I'm worth a felony conviction for. As noted below, the link and collection objects are immutable. Therefore, calling them "mutable" interfaces would be, well, wrong. We discussed on the mailing list what to call them instead. Evolvable isn't a great name, but it's the least-bad option that was suggested. If you had a better name, I wish you would have shared it earlier.
Now I know who to complain to/blame!
Well. I think we process the same in sense of making pulling data independent of the api/framework/whatever. My real motivation for doing more in SQL instead of PHP (my most used language) is to have the database engine process the data as much as possible. If I'm not mistaken that's what they are good at, so the language/user side process does not have to work as hard.
Oh snap! Til! 
Working in an office: people come to your desk to say they slacked, skyped or emailed you. Working remote in a separate, closed room, office: your in-laws find you anti-social. Working remote in living room: kids, dog, in-laws, mailman, Salvation Army and a whole line of other people like to chat with you because you're at home "playing" on the computer. Working remote in coffee shop, city park: too many distractions!!! I prefer separate, closed off office in or next to the house. 
Just want to nitpick here, Eloquent is not the same thing as a query builder. It's an ORM that has seamless transitions to the query builder if needed, but the purpose of Eloquent is to *fully* abstract away the notion of accessing data with queries, and instead interface with data as "pure" PHP. Both approaches have their pros and cons. If your application makes use of lots of entity-like objects with very specific APIs (e.g. `$user-&gt;getName()` or `$banService-&gt;suspend($user)`) then ultimately that means you'll want to be re-mapping data from the database, into named entities that your domain understands. Turning raw SQL into such entities becomes very tedious and very silly, very quickly, hence why ORMs exist. On the other hand, if your app is largely data-driven, and it's a simple matter of translating or moving around complex data, then raw queries are a better choice. It's likely going to be more performant, and given wrapping that data into an entity is not going to be beneficial, there's not much point to using an ORM. Now, regarding the Query Builder (the intermediary between ORM and raw SQL), I personally never use it (or only very sparingly in conjunction with the ORM) when I need to conditionalize relations and what not. I don't find that a query builder offers any meaningful advantage over raw SQL, and in many ways the API is *MORE* cumbersome than raw SQL (not just speaking of Laravel btw, just all query builders in general). If I need data mapped to objects, I'll use the ORM. Else I'm happy to work with plain array structures with maybe some light mapping into value objects as needed. I've always viewed query builder APIs as training wheels, not productivity enhancements.
Maybe now would be a good time for some self-reflection. These grandiose conspiracies about FIG 3.0 and the Contributor Covenant aren't passing the sniff test. Aura represents all of 1/40th the FIG and wasn't losing its voting power anyway and the Contributor Covenant proposal wasn't even for the FIG, it was for PHP Internals.
I like it. I would like to see more libraries like this and less Java-like.
I use to write everything RAW then when I got into frameworks I started with Doctrine in Symfony. I thought there was a bit of a learning curve but can also blame some of that on using Symfony as my first PHP framework (aside from WordPress which I guess you could throw in that category). After using Symfony on 2 projects I started using CodeIgniter and their built in ActiveRecord based query builder and I really like it. I've found a few annoying things about it but it's really easy to just throw any SQL at it and that will work in those odd cases. One reason I like it is that it really helps keep my stupid mistakes at a bare minimum. When writing straight up PDO queries I often times misplace something or lose my train of thought. Using something like $this-&gt;db-&gt;get('table') in codeigniter makes for little room for mistakes. In addition coming back later and adding / subtracting from a query seems really easy but that's just because of my comfort level. Also I've found some helpful tools in CI for binding, having multiple DB connections (which I rarely have to do) or spitting out a specially formatted result (ie. object vs array vs single, etc..). I was a bit nervous about the "overhead" in CI (not sure why) but following their boards a bit helped to reassure me that there were some big players using it and I'm one of those... "If it works for them..." kind of guys.
It looks like shit...troll.
and benchmarks. I get it. :)
Thanks for putting the work into this. The previous version looked so dated, it made the language look bad. This one is practical and elegant.
I wrote my own query builder, which plugs into a data object with basic CRUD built on top of it. That takes care of about 90% of what I need to do, and I can drop to a raw() method when I need to do something more exotic. I prefer using this because I think mapping relational data into objects is a flawed approach. Using an ORM is all well and good if you're keeping it simple, but as soon as you start to scale up, or do more complex operations with your data, an ORM will get in the way purely because treating your relational data as objects all the time places too many constraints on it. I'm frequently building apps that involve complex, large-scale data-driven logic. I also sometimes have strange requirements, like needing to interact with multiple databases where the schema is not known ahead of time, and I'm frequently running through cycles of rapid development where data needs to be refactored or normalized, or the schema needs to be substantially changed on the fly as new requirements come in. I need a pretty granular level of control over the database as a result, and the query builder is tailored to that. (I did try a few ORMs but none really worked well for my needs.) So why a query builder but not raw SQL all the time? Because PHPStorm autocompletes class methods. Writing this: $results = $this-&gt;source -&gt;select() -&gt;table('tablename') -&gt;where(['last_name LIKE' =&gt; $searchstring]) -&gt;orderBy('last_name') -&gt;many(); is faster than writing this: $sql = "SELECT * FROM tablename WHERE last_name LIKE ? ORDER BY last_name"; $this-&gt;source-&gt;prepare($sql, [$searchstring]); $results = $this-&gt;source-&gt;fetchAll(); because of autocomplete. I have other stuff in there as well, like extra diagnostics and a few things that give me more flexibility, but it's mostly about the speed.
Hmm I don't know. It's pretty easy to copy and paste the boilerplate code, in this case: $sql = ""; $this-&gt;source-&gt;prepare($sql, []); $results = $this-&gt;source-&gt;fetchAll(); From there all you need to do is copy and paste in the SQL query from MySQL Workbench (and pass in any parameter variables if needed) and you're good to go.
So the designer is into PHP, prefers back end than design, yet is a good basic designer, and is on reddit... TIL I designed the php.net website.
I prefer loading the entire record or record set. I would rather make developing code easier by having simpler code to extend and maintain than complex code and more of it. There are obviously a few exceptions. For instance where I am intentionally dealing with complex queries, a big data set or tables which columns with lots of data, such as binary blobs.
Well, it's been my experience that having to write out the queries every time is slower. Make of it what you will. Besides, I find that having the query builder means I can take advantage of PHP's logic in a clear and obvious manner. The query builder only compiles and executes the query when a termination method is called, and prior to that, all of its individual parts are mutable. So I can have a method that adds or removes where clauses on the fly, or selectively adds ordering, or whatever else I need. I've done this manually, by writing out the query in chunks, and it gets very tiring and frustrating for me and it turns my code into nonsense. The query builder abstracts all that away, and takes care of binding, preparation and sanitization, so I'm left with a cleaner and less stressful workflow. I always have the option of writing and debugging complex queries in Workbench, which I then transfer to PHPStorm and insert into a raw() call along with any required parameters. I have to do this every once in a while for something very out of the ordinary, or for queries where I'm aggregating data and it would be inconvenient or inefficient to do it in PHP. But there's no need to go to all that trouble for every query.
Yeah it is, more or less. To each their own, as long as it works securely, but I found that it didn't suit me. I much prefer using either the builder's methods, if I have to do conditional logic, or executing a specific, complex query through raw() that's been vetted in Workbench. Another thing I found, and this could just be me, is that there's a mental overhead involved in switching between languages and IDEs. Like, I get into a 'flow', when I'm building something, and suddenly having to move over to Workbench to do something with the database gets me out of my groove. If I'm using the query builder, then I can happily stay in PHPStorm and work with nothing but PHP. It's not much but I do notice it.
Thanks :) Well, if you take out interfaces and replace them with functions, and change `Site` constructor's first with from `Extract` to `array` it would be even less Java-like :D
I've found that issues with mapped data only really apply when you're actually mapping database records into objects. If you're not building your application that way, then by and large you don't have that kind of problem at all. Here's an example: my current application has a table called 'notifications' and each record has a UNIX timestamp for 'created'. What I DON'T have in the app itself is an object called Notification. Instead I have an object called NotificationData, which is purely an interaction layer between the business domain and the notifications table. So it's got some basic inherited CRUD, and then I have other custom methods to get information in whatever form the domain needs. Sometimes I'm converting the timestamp to a formatted date, sometimes I'm doing logic on it, sometimes I need to include both it and a converted date, sometimes I don't need it at all. I have total flexibility and I'm only ever working with the minimum required dataset. The mapping is irrelevant because it doesn't exist; the data is always just data, being processed by objects in the business domain. This is just another approach, of course. It's got its own challenges and issues that you trade off, specifically where you have to pay much closer attention to the contents of the dataset. I've been whacked upside the head more than a few times with variables not existing, for example. 
Apparently it was.
&gt; Also the purple isn't really doing it for us. I wrote some code back in the days and I know you can just set the color in the code, so if you could just set it to "red" we really think that would pop more. That's honestly just ridiculous. What about the people that like the purple? There should be a setting for it. Or it should alternate between the colors every few seconds. That would look nice. And who doesn't like flashy things?
I haven't looked through all of these but your password generator is using `rand()` and should be swapped out for a CSPRNG. Sane implementation for random string generation can be found at: https://paragonie.com/blog/2015/07/common-uses-for-csprngs-cryptographically-secure-pseudo-random-number-generators
Can't you organise by the phone number that you sent to the time you sent and received each text message?
Yes, that's why I wonder what other people think)
Great, thanks for responding and, of course, thanks for your great work on the site - it's quite impressive.
The main pro of orms in my opinion is security. Sql injection is phps number 1 enemy. When writing raw SQL you're reinventing the wheel. Having said that, SQL is usually a lot more flexible than most orms. Also, I already know how to do statistical queries over multiple tables where dates are between last week and tomorrow in SQL. There's no orm for which I know how to do this. I'm sure it's possible, but I'll be stuck in documentation for half an hour before I get it. So yeah, pros and cons. I ended up writing my own orm I reuse on most projects. The only real advantage of that is I know how it works because I made it. 
[Oh you](http://theoatmeal.com/comics/design_hell)
http://vignette2.wikia.nocookie.net/creation/images/9/9a/Triggered.gif/revision/latest?cb=20160306005747
apt-get install php5-curl
If you want to use fall-through conditions, it's quite useful - although they are usually a good indicator for bad code, they do have their uses. function test($i) { $a = 0; $b = 0; switch($i) { case 0: $a = 2; case 1: $b = 5; break; case 2: $b = 9; } return $a + $b; } echo test(0); // 7 echo test(1); // 5 echo test(2); // 9
thanks for the example. truly it just makes code harder to comprehend. especially if the code in the case blocks is more than a couple of lines it will make things complicated.
Yes but that's not very flexible. Say from the server I want to send a text message to two groups of users, and there's overlap... If an overlapping user replies, then I will have no good way of knowing which group they meant to reply to. I can kinda guess by the most recent group but that's not ideal. Another case, if the user is in a group and was sent a message directly, then the reply might end up in either the group history when it has no relevance there. It just didn't work for me.
Yeah. If the code in the case block is more than 2-3 lines long, I wouldn't actually recommend putting all of that in the statement.
Just because PHP parses something does not mean that it is a PHP script. PHP scripts are initialized with `&lt;?php` or with `&lt;?`.
it's also less likely for people to write sql injection bugs using sql builder then raw sql ``` $stmt = $db-&gt;select('table',['col'],['where'],['options'])-&gt;fetch(); ``` vs ``` $sql = "SELECT cols table where options"; ```
More people should upvote this.
Yeah this just comes across as arrogant and reaks of self promotion. You make claims against people but cant answer the most basic of questions: Why is it ok for you to block one project's FIG entry on grounds of conflict of interest, and then not have the same rule applied to yourself? Clearly you've got no chance of keeping the peace and acting in a professional manor to your peers. Why hinder things by even being there. As I've said before - a bigger man would've stepped aside and let the FIG get on with it for better or worse a long time ago. For someone who claims they hate drama you sure do an amazing job at shit stirring.
Since I'm the author of [Agile Data](http://git.io/ad) I wanted to share my reasons for creating it. (In short: I think there is a better way than those 3 options and I'm prepared to be down-voted for thinking that). For a long time it was coupled with [Agile Toolkit](http://agiletoolkit.org), but I thought that people using other MVC frameworks should be able to get their hands on this unique DAL, hence the rewrite. DISCLAIMER: Agile Data is not a typical ORM. It has some similarities, and it is built on top of it's own [Query Builder](http://git.io/dsql), but it attempts to go a few steps beyond. I don't want to boast about the individual features, even though I am really tempted, so I'll just say there is this [really good quick-start guide..](http://agile-data.readthedocs.io/en/develop/quickstart.html). -------------------------------------------------- **1. Built-in vs External Database Abstraction Framework** Some frameworks are "married" with their DAL. CakePHP has their own builder. Laravel has Eloquent. CI has several options. When creating Agile Data I thought - can I create a good data framework not for a specific MVC need, but for all of them, in general? Without having any specific "UI" layer in mind, I wanted to create a sophisticated and elegant solution that could be used in any circumstance. This way you can take your "business logic" migrate to a next major release of your framework. Additionally you are no longer reliant on the same framework if you wish to create API or command-line tools. While there are ways to use Eloquent without Laravel and Laravel without Eloquent that usually means cutting them out with a knife. **2. Writing vs Building vs Mapping** This is an endless debate and developers have their preferences. I think none of those should be used and I explain my reasoning below: - Writing queries - ability to tweak and optimize them as well as using expressions. - Query Builder - more "object-oriented" but sucks at quirky stuff - Mapping - allow you to easily refactor your queries, cross-vendor goodness. With Agile data my goal was to make all 3 patterns possible without downsides. If you want to use "IFNULL" inside your model criteria or if you want to include 10 joins for your model or if you want to single out a specific field query of your "Country" entity and use it as a sub-query inside VALUES of your INSERT - relying on a single approach is not enough. I've made sure that all those use-cases are possible in Agile Data. Additionally I wanted to make sure that your Entities could be stored not only in SQL but also in RestAPI, MongoDB or Memcache just as easily and without much refactoring. ORM in Cake and Eloquent are quite restricting which leaves Doctrine as the only option if you want to go fancy with multiple persistences. **3. Assumptions** What I've found is that when you show a code containing `$m-&gt;load(123)` to some developers they will assume that they deal with ORM with all it's inherent n+1 scaling issues. It is quite difficult to get past the assumptions and convince newcomers that it's possible to avoid a classical ORM issues with a different underlying design. So as you read through the further sections, avoid jumping into assumptions. **Why should you stop writing your queries** PHP calls for elegancy. Query Builders try to make your queries more elegant, but they are limiting. I have even [made a Wiki page](https://github.com/atk4/dsql/wiki/Awesome-Queries) where I collect questions from StackOverflow users that ask "how do I do X in query builder Y" and the answer is "you can't". With Agile Data my first task was to implement great support for composeable expressions in my underlying query builder, simply because I haven't seen any other query builder to do this successfully. Now, because my query builder can use expressions (or subqueries) as any part of query and can handle updates/deletes and other operation while taking care of parametric values, there is no longer an argument for writing raw queries anymore. Query Builder in Agile data has no "you can't"s. **Why should you stop using general purpose ORMs** ORM concept has been great when you work with individual records. It does fall short when you need to work with multiple records. You get all sorts of lazy-loading nastiness that complicate things. If you traverse one-to-many record with a traditional / lightweight ORM where you have over 1,000,000 related records most of those ORMs will just die right away. This probably is the major problem that holds people away from using ORMs: they don't scale well with large amount of data. The other big problem is that ORM prevent developers from being expressive or using some advanced features of their database engine. For example in most ORMs you can only load full records at the same time, you can't use selective field loading. You can't derive queries from Models or include your custom SQL as part of the query. If only they were using a better Query Building... People do use ORM for two good reasons. Firstly it allow you to refactor your queries easily, should your database change. Add a new field and all the code that deals with the database updates automatically. ORM also can add certain patterns on top of your definition such as Orderable, SoftDelete, so that you don't have to constantly think about those when accessing data. The other good reason why ORMs are used is because they offer query abstraction and can be implemented by NoSQL back-ends. With Agile Data I have found a way how to keep the benefits and avoid the problems. Agile Data contains a set of concepts that allow you to work with "DataSets" - addressing groups of records without actually loading them (or their IDs). This concept completely changes the way how One-to-Many and Many-to-Many relationships are handled. It enables deep traversal and live aggregate fields (based on sub-queries) without you even needing to write the query yourself. Another internal limitation in many ORMs is their difficulty when dealing with complex queries. As soon as you start building a more complex query you run into problems where you need to alias tables, expressions, sub-queries and joins. This took me quite some time to get right, especially with the entity contains a self-referencing sub-query. Most ORMs especially the lightweight ones place limitations on what can you do with the database and that's probably a good reason why you shouldn't use them - they restrict you. **Why you shouldn't use Query Builders**. Well, not "exclusively" anyway. In my older projects I've been using query builder and I end up copy-pasting soft-delete conditions as well as some other "where" clauses from one place to another. Yet I couldn't use the ORM because I wanted to aggregate and customise my queries. In Agile Data I have made Query Builder work in tandem with Object Mapping. Suppose you want to produce a fancy GROUP BY query based around your model. Use the mapping logic in Agile Data to get the base query, modify the "query in progress" through my Query Builder and you end up with endless posibilities. From the established ORMs Eloquent probably comes quite close with their implementation to achieving this, but this functionality is mostly hidden "under the hood" **Conclusion** So if Database Access library would keep the benefits of all the 3 database interaction approaches without the downsides, would you give it a try? Sadly most people wouldn't. That's just my experience with PHP community - new developers look for "hip" and "lightweight" that can be understood and learned in under 30 minutes. There have been many other posts about open-source authors like me being constantly discouraged to share new stuff. I do want that to change, but Agile Data has only reached its first stable release weeks ago and it still needs more polishing. Although I have some good contributors, there are still ways to go before I could even dream about large community. Still - Feel free to try Agile Data and hopefully you won't be writing SQL ever again. Oh and here is that really good guide again: http://agile-data.readthedocs.io/en/develop/quickstart.html. 
\#bringbackbevelandextrudebuttonsfrom1900 edit: and gifs, animated gifs.
Not really sure if insulting the developer community is the best way to get them to try your product. But good luck anyways.
I'd hope we'd all be using PDO and prepared statements by now ;)
&gt; Sql injection is phps number 1 enemy PDO prepared statements ftw?
&gt; conditional query building is the ugliest sight in the world when making it with raw SQL That doesn't have to be the case. I mentioned in another comment that it's pretty easy to make $select, $from, $join, $where, $group_by, $order_by, and $limit variables that mimic the appearance of the query builder methods. The main difference is instead of doing function calls you're just doing string concatenation, but the overall style/formatting can look quite similar.
&gt; Like, I get into a 'flow', when I'm building something, and suddenly having to move over to Workbench to do something with the database gets me out of my groove. The context switch is a very real concern. That being said If I'm developing a database-driven application then I accept the fact I'm going to have to deal with SQL. It's just like if I'm building a SPA and only using PHP on the backend, I accept the fact I'm going to have to switch to JavaScript, CSS, and HTML for the frontend. It's just the nature of the beast. I've found it helps to try to group tasks based on the context being used. So when I'm in PHP mode, I try to stay there until it's time to take a break (lunch, walk, sleep, etc.), and the same is true for SQL, JavaScript, etc.
Indeed, I have contributed very little to the *content* of the site, just the design. Good work documentation team!
We will not tolerate this kind of hate on this subreddit.
It's sad, but this is almost exactly what happened to me once. I was a Linux admin at a hosting company, so rather then paying someone to make our new website they had me do it. I'm not a designer but I made a nice looking site with WordPress and a paid theme. Over the course of the next few weeks I was forced to make change after change that slowly turned the nice design into garbage. :(
I know one guy who points to the various Java 0-days as reason for not running JavaScript...
I suggest people take a look at the hexagonal architecture approach, which aims to decouple all external components from business logic. This article is not far off the concept, but little loose on details. 
It's like spot the vegan.
It's a tool to generate dev environments using Docker and docker-compose.
Why stop there: switch ($state) {{{ case static::STATE_RUNNING: {{{ break; }}} case static::STATE_PAUSED: {{{ break; }}} case static::STATE_DEAD: {{{ break; }}} }}} This communicates I really mean it. 
You love a bit of drama, don't ya? 
Yes, it works perfectly fine, nobody says the opposite. But the code for the conditional query building with raw SQL looks a total mess, especially compared to a query builder-based approach. The only source of confusion I can think of is that you don't quite understand what a conditional query is. It is not about adding a static $where or $limit - it's all about writing $where part manually, with lots of conditions.
I guess I still don't understand what you mean by mapping. I've never used it before so the ['bar' =&gt; 10] makes no sense to me :( I'm assuming bar is mapped to foo somewhere, so if you change foo to foo2 I'd expect you'd still have to update some code. Otherwise how would your code know that bar now maps to foo2 instead of foo?
I'm not really sure what you're trying to accomplish with these blogposts.. Maybe the third (and final?) post will tell.
[removed]
A snippet of code is worth a thousand words. Here is an example of what I am talking about if($gender != -1){ $filter[] = "gender = :gender"; $values[] = $gender; } if($religion != -1){ $filter[] = "religion = :religion"; $values[] = $religion; } $query .= " WHERE 1 AND " . implode(' AND ', $filter); $stmt = $connection-&gt;prepare($query); $stmt-&gt;execute($values); Imagine there is only one condition using OR instead of AND and this mess turns into a nightmare.
Hmm, this: if ( $some_condition ) { $this-&gt;db-&gt;where('some condition ish'); } doesn't look a whole lot different than: if ( $some_condition ) { $where .= ' AND some condition ish'; } Granted it gets a little bit trickier with nested AND's and OR's, but if you format and comment your code it doesn't have to be as messy as you're making it sound.
Remember you have to add a value into a separate array as well. And you have to assemble the final query with various precautions (against empty where, etc.) afterwards
Ok, it's a religious matter for you, so any discussion will be a waste of time. 
Yep I think the term re-inventing the wheel (and making it square in this case) rings true here more than anything I've seen in the last 12 months 
[removed]
Although I agree in general with your statement here, a password generator isn't aimed to be cryptographic secure, it's to simply generate a pseudo random string of x amount of characters. rand() is fine for this use. Here is what I have done in the past.... substr(hash('sha512', microtime()),rand(0,26),20);
which ones are great? which ones improve on whats already available? 
Isn't calling something a total mess also subjective? You went on to provide sample code of your own, on which I readily commented :) I can only assume the code you provided was an attempt to prove your own point. Perhaps it's your own subjectivity leading you to believe your code sample is a total mess? Has that thought crossed your mind :)
Right, they should just clutter the entire site with some shitty Bootstrap theme.
From the very beginning mate! http://code.tutsplus.com/courses/php-fundamentals This course is amazing at teaching you the basics of PHP, OOP, also touches package management with composer (Node has npm) and relational databases (MySQL). 
if they are not morons they should enable js for php.net
The idea is that you have, say, a $schema. It enumerates the tables in your db, and that fields there are in each table. Then that $schema also says "when PHP asks for field foo, you select bar in the database, and when bar comes back, you should call it foo in the PHP object/array". This $schema configuration is defined just once. And then you can use it for every query you build: $qb = new QueryBuilder($schema); Now when your input, when your output, when your query builder parameters have "foo" in them, the schema automatically transforms this to "bar". And if I change the mapping in $schema to "bar2", in **one place**, then all places throughout my code, all input, all output, all query builder parameters, will map "foo" to "bar2" without additional code changes. So there is a code change, but just one, instead of, say, 20-30 changes throughout the code. This matters over time.
[php.net](https://secure.php.net/) is a surprisingly good API resource for you. Just try not to read the comments on the pages, as there are some truly awful ideas in there. The language itself is a fairly straight-forward OO language with C-like syntax, so it should be very easy to pick up if you know any other mainline OO languages. JavaScript is an odd duck, though, so it may be an interesting ride for you. Know that once you've learned PHP a lot of the ideas are portable to other languages. Java, for instance, is very similar in syntax and OO concepts and should be simple to pick up after you know PHP.
I agree with Paul here. I'm not sure about 3.0's goals of becoming THE php standards body, however FIG is the defacto userland standards body. And I'm not sure it's a role the FIG is up to. Not because I question their technical abilities, but I don't think it's the goal of the fig. The fig and its APIs focus on frameworks not end users. In his post [Why PHP-FIG Matters](https://evertpot.com/why-php-fig-matters/), Evert Pot lays out this distinction. He suggests that the Logging PSR should have just contained 1 method: public function log($level, $message, array $context = array()); He continues that libraries, such as Monolog, should feel fine to provide a robust logging interface with multiple logging methods. However the purpose of the fig is to design the plumbing, not the library directly exposed by the framework. This is the crux of the situation. It's hard to design a good API when you're unclear who your target users is. Are they deisgning for framework maintainers or for end users? I'm of the opinion that it might be better to have a separate group adopt the existing PSRs and aim to create better developer experiences through a set of common standards aimed at end users not frameworks.
Thanks to you I have a carrer in programing :) 
I'd hope an engineer could make something other engineers could use like an engineer would... 
It is possible to care about security and privacy and still have Javascript turned on if you have proper programs installed. Not even hard, I'm pretty sure an anti-virus with real time scan and a firewall that is properly configured will do the trick. Just getting these two things dramatically reduces your chances of attack (since crackers can usually detect their presence as it isn't really hidden and will avoid you as long as they don't have the ability, time and desire to defeat your defenses, which is probably you unless you are a big deal) and they are relatively easy to set up. Don't fear the script...people can just attack through other avenues. Shutting yourself off from the world is not the key, just having an effective system for filtering that world.
apparently it is now. 
As an average mid-level dev, I really have no idea how some of these heavily involved PHP "community" members have time for any extra-curricular activities, let alone wasting countless hours involved in this kind of, sometimes seemingly willfully obtuse, drama filled slogfest.
[removed]
How kind
Thank you! Really appreciate it! 
In fairness, using Google is a "skill" you will frequently rely on, so OP's point is actually useful. 
Undoubtedly Paul is a very smart programmer, his github repositories, blog posts and comments on Reddit have proved enough of that. And smart people usually have strong egos, sometimes they can respect/compromise each other and work it out, sometimes they just dont. I am not saying whose fault this entire drama is, but clearly the voting didnt solve any problem, only brought more hatred and contentions. I have a bad feeling about the direction FIG is going. The voting is clearly in Paul's favor, but put me in his shoes, Id wonder myself. Is it really worth staying in a group that 3/8 of people dont want me to stay? If so, is there anything I can do, to change their minds. If the opponents are not cynical haters but professionals with civil attitude, can I make up with them? Sure you cannot satisfy everyone, but its still always better to have one less foe, and one more friend, at anytime of the day. 
Very true, should have wrote "documentation" not "web documentation" :) I'm fully aware the designer can make a good documentation site only if the documentation itself is already amazing. So ... what I said above applys to everyone in the stack that in the end leads to me actually having fun while coding :)
Thanks man! 
[removed]
&gt; You can't codify respect That is true. I think codes of conduct work the other way though - by reducing disrespect through well-defined boundaries, mediation steps, and ultimately how much disrespect will be tolerated before someone is ejected from a community. Some codes of conduct over step, some don't have teeth. I feel the general idea is good though.
I like ircmaxell's RandomLib for password generation. You get a few choices for how strong they can be: https://github.com/ircmaxell/RandomLib
Derek Banas has a decent video on his youtube channel here https://www.youtube.com/watch?v=7TF00hJI78Y
I know you mentioned that you're looking for a setup with bitbucket, but it could be worth checking out gitlab, as it's got Gitlab CI support built in, and even has free runner you can use on private projects. I wrote an article about it [here ](http://alanmonger.co.uk/php/continuous/integration/gitlab/ci/docker/2015/08/13/continuous-integration-with-gitlab-ci.html). There are a few other alternatives if you want to stick with Bitbucket though, the most popular CI SaaS is Travis, then you have others like [Buildkite](https://buildkite.com/) and [PHP CI](https://www.phptesting.org/).
The Oatmeal just called, he wants his joke back. /s
I was basically directly referencing it, figured most people would have read it. [Source for those who haven't read it.](http://theoatmeal.com/comics/design_hell) It's pretty great.
Fucking Chad.
Yup, the whole world is stupid *except for you*.
http://someonewhocares.org/hosts/ helps a lot too.
We use varying combinations of gerrit, gocd, opsworks. It works well but needs a lot of configuration and doc reading. 
I saw a few functions like this: public static function validateEmail($address) { if (isset($address) &amp;&amp; filter_var($address, FILTER_VALIDATE_EMAIL)) { return true; } return false; } which is a bit verbose, how about this: public static function validateEmail($address) { return filter_var($address, FILTER_VALIDATE_EMAIL); } * filter_var already returns true or false * isset() would only fail if: * the caller passes null, in which case filter_var will handle it * the caller calls without a param - which should possibly throw an Exception * if you want it to work without a param passed in, give it a default value At this point its a wrapper for filter_var ... so why do you need it?
Hey @Msplash9. I'm working on a new data access library implementing some new patterns and combining all 3 principles - ORM, Query Building and Raw Queries. It's really powerful and user-friendly. It solves the problem of eager-loading like this: $book-&gt;getRef('author')-&gt;addTitle(); $data = $book-&gt;export(); This would now contain new column "author" corresponding to the name of the author defined in a related model. The actual query gains a new column that's expressed as a subquery into the "author". If you prefer to use JOIN, it's also possible: $book-&gt;leftJoin('author')-&gt;addField('author', 'name'); $data = $book-&gt;export(); In both cases only a single query is executed. Finally there is a third option: $query = $book-&gt;action('select'); $query-&gt;join('author', 'author_id'); $query-&gt;addField('author.name', 'name'); $data = $query-&gt;get(); In this data mapper generates a Query object which you can further tweak. I hope this is helpful. http://git.io/ad
Have you considered [Bitbucket Pipelines](https://bitbucket.org/product/features/pipelines)?
empty only accepts expressions since earlier php versions, so for an old fart like me using empty in this case looks wrong. The only difference I can think of with empty versus ! is that empty also implies isset. But I usually use !, because in many cases I just want to know If a variable is "falsy" (aka empty). If it throws a notice because the variable is undefined I know there is a mistake in my code. In that sense I'd like to debate if empty is even outdated.
I think my biggest problem/fear is that it goes from 10/month to 800/month with no other in-between prices. I have no idea how to recommend that to my cto. Maybe the 10/mo is fine but will there be a day when we need to jump and it means a price increase of $790? Not sure how to explain it. Maybe I'm wrong though. 
Thanks ill check them out. Not afraid to spend time to learn a system as long as the docs are good. That my beef with Jenkins, you want to make a change or you're having an issue you're better off starting at Google than at the docs.
&gt;Does knowing [X] lessen my chances of matching a good company? Knowing something rarely ever reduces your chances of getting a job. However, NOT knowing something often does. &gt; Looking at phptherightway, it mentions under Windows Setup " Web Platform Installer, XAMPP, EasyPHP, OpenServer and WAMP" Why do I have to choose one! You don't need to know any of these but each thing you do know will say something about your experience: * Web Platform Installer = You know how to install things the wrong way and screw up your web server. * XAMPP = You know how to get a local development environment running. * EasyPHP = I Never used this but it looks like another alternative to setting up another local dev environment. * WAMP = Instead of using some 1 click install VM you actually know how to set up and configure a webserver from scratch. &gt; I mean, how do you keep up to date on Docker, Vagrant, Puppet, Chef etc You don't, you use the tools that fit the workflow and environment you are writing code for. The more experience you have the more of these tools you will be exposed to. You don't worry about keeping all of the skills you currently aren't using current, if you ever need to use those skills again then you brush up on the current version and start using it.
I've had a ton of success with Jenkins. I mostly just have it run composer and a [RoboFile](http://robo.li/). The robo file handles testing and report generation then generating a package with [FPM](https://github.com/jordansissel/fpm/wiki) and updating our local repo so our linux server's regular package updating process handles deployments. Works great as when the package gets installed or updated the OS will run a simple php script for database migrations for us. If there is a problem we can just rollback the package to an older version, but for the most part we fail forward since a manual update can have a new production version out in about 10 minutes. I really really need to start a professional blog and write up some how-to on this stuff. I've got a complete redo of the process using docker and rancher in development right now so we can do push deployments as fast as the test suite runs.
do you need it to be hosted by them? I paid $10 once and that's it. I host it on my server. Do you need more than 10 build jobs? (that's 10 different projects)
We've just moved from Jenkins to BitBucket Pipelines for our automated deployment setup. Since we host our app on Google App Engine, we had to build our own integration setup. I really like how integrated BitBucket Pipelines is into our source control process to the point of it just works in the background as needed and doesn't require any thought. The downside is, that given it is still more or less beta software, there are things like lack of Slack notifications and no docker image caching causing slow startup times that can be a real bother. for those who are curious or who are stuck with the same problem: https://github.com/Shruubi/google-app-engine-for-pipelines
I second this - I'm using Jenkins with both php and python projects and its really not tied into Java too badly. You just tell it the repo to check out, what branch, and the post build tasks (e.g. phpunit tests to run) and it runs and if it's an exit status of 0 it's good or if its 1 it fails and emails. You can get a lot more customized but that'll get anyone started.
That's not the DB agnosticism I was talking about or specifically referenced in my original and follow on post. I was referencing swapping RDBMs at a schema level. In terms of domain models, that's just the programming layer. It's also not impossible to accomplish this with Eloquent in the mix. Eloquent doesn't suddenly obviate this approach.
that's exactly what i'm saying, in this example the one who learned Chef was trying to learn new things, even though my fictional company uses Ansible, the fact that he learned more things gives him some advantage over a equally capable and experienced candidate
 $notEmpty = array_filter($values, 'strlen'); https://3v4l.org/InEng
I wasn't a big fan of jenkins either. I adopted [Drone](https://github.com/drone/drone) as a software that I run on my own vps and I've been happy with it so far!
Yep we use it with PHP and C++ projects on OS X, Windows, Linux, and FreeBSD. No issues with Java, I hardly remember it's being used.
Nobody here is against you rolling your own components. There's no need to be an insufferable tool about it.
I toy and play when I have time. Back in October, I knew nothing about docker other than it's a thing. Now, it's one of my favorite tools. Just last week, another dev on my team had to take a crash course through Ansible to get one of our server back up.
Can you give me an example using [Common Table Expressions](https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL#Common_table_expression) with Agile Data?
Forge and Envoyer assuming tests pass and no deployment hooks fail.
If you are requiring php7 might as well go with strict_types and use return types when possible. PSR-2 and PSR-12 say no prefixing with _ and it's good to follow standards. You are missing doc blocks from classes and properties explaining the types and purpose of things. Your router should probably not have defaults nor handle errors automatically by defining default routes and urls for them. You have typos in code (overrideDefaulRoute). You are still exposing several symfony objects, maybe defining a clear strict interface as a contract would help you see more. Why are you even wrapping the route if it's not really exposed or meant to be used? Just because you don't like the ordering of the default default parameters? You are constructing it and then immediately get the symfony route out of it. Did you want a factory instead?
I've been having fun with TravisCI, which is very popular in the open source community and nails a lot of things just perfectly. Where I think Travis is limited is when you have very complex CI pipelines and complex software infrastructure. If you are working on simple projects, like a single Laravel app, then Travis is perfect. It will spin up a docker image based on the configuration you provide in your travis.yml file (version of PHP etc), run all the things you need to set up the project (composer deps, migrations, seeding, etc) and then running your tests (and deployments if you go the extra mile). Everything is nice and simple to set up and your build process is part of your repo (unlike Jenkins). The problem comes when you have a very complex software stack and rigorous CI pipeline. Jenkins does the job but is crap in a lot of ways. One CI tool in looking into right now is ConcourseCI. It was built for complex CI pipelines and also retains the other benefits of Travis and the pipeline visualisation is very cool and understandable. It's also more complicated than travis but much less so than if you were to do the same in Jenkins. I would suggest checking it out. It's also open source, so you can self host it. Heck, the homepage will show you how to get up and started with a vagrant machine to play around with it quickly. I'm hoping to replace our crappy Jenkins CI process with this. Jenkins works well for simple stuff but gets unwieldy very quickly.
Yes, this is correct. That's what I meant. No need to downvote.
You mean a union query or two separate queries to potentially different tables? Both are possible
For people using Jenkins or other tool you manage - how do you provision vagrant boxes for testing? i.e. do you add a "vagrant up" step to the jenkins build config, and then tear it down the end of the test?
I switched to gitlab to have a good built in CI, but I had to run a self hosted version to get all my required needs. Even though I like gitlab a lot, I would prefer using Bitbucket, just because I want less risk (self hosted). I am currently trying Bitbucket pipelines (beta CI service within bitbucket), but it isn't as good as it is with gitlab currently. For example you can only use one docker image, you can only setup one step, you can't set cache directories, you can't mount files, ... Anyway in Gitlab my procedure is as follows: - on each commit, tests are ran on multiple PHP versions - if the commit is a tag/master branch, then capistrano will run to deploy a new release.
Sure. You would be looking for something like this: WITH t1 AS ( SELECT ..bunch of fields.. FROM article INNER JOIN userinfo ON userinfo.id = article.owner_id INNER JOIN category ON article.category_id= category.id WHERE article.article_isdeleted = 0 ) SELECT t1.* FROM t1 ORDER BY t1.article_date DESC LIMIT 1, 3 Where the t1 query needs to be dynamically constructed by mapping a Model, then: $m = new Model_Article($db); // init() will set joins and define fields $m-&gt;addCondition('article_isdeleted', 0); $q = $db-&gt;expr("WITH t1 AS [article] SELECT t1.* FROM t1 ORDER BY {ord} DESC LIMIT [], []", [ 'article'=&gt;$m-&gt;onlyFields($fields_you_want)-&gt;action('select'), 'article_desc', // {} will escape identifier for you. 1, 3 // will be added to other parameters ]); foreach($q as $row) { .. } This can be further tweaked to fit the purpose. If you wish to use Query Builder with non-standard SQL syntax, documentation is here: http://dsql.readthedocs.io/en/develop/advanced.html?highlight=template#adding-new-query-modes
I didn't say impossible. I said ORM can be restrictive of those things making you jump though the hoops. Please do not confuse Cake ORM with Cake Query Builder (which is pretty flexible btw!)
In fact this community is *fiercely* against new libraries/frameworks, and voting on recent posts is a proof.
Give [Symfony Form Component](http://symfony.com/doc/current/forms.html) a try. It looks scary at first but if you 'll be able to overcome the fear, you'll start liking it
Thanks. I found [Nette forms](https://doc.nette.org/en/2.4/forms) which also looks good. Simfony form doesn't look too scary I might use it for some more serious project, but i was looking for something that is already complete. I want to build 1 or 2 forms containing 5-10 fields and store the data locally, then be able to search it.
Already complete? Symfony forms is complete.
It is of course. By complete I meant something that does not require any coding. Just install, setup and forget is what I was looking for. Sorry for not clearing that out.
I know about google forms, but i need something that stores the data on a local mysql server.
Separate RUN statements on the dockerfile end up in massive images. You should concatenate as much as possible.
Laravel FormBuilder is a very handy and easy-to-use formbuilder package for Laravel. It's inspired by Symphony Form Component. Have a look: https://github.com/kristijanhusak/laravel-form-builder
Not sure why people who are posting topics about their new libraries and cannot seem to understand why they are given all these negative criticism OR no recognition at all. * It already exists. There are many library out there that solves the exact same thing; expecting something without any sell points (performance, this new X functionality that will rock you world, etc) won't give you any recognition. * It's badly documented - if there are no documentation people can't learn about it quickly. * It's in poor quality (no tests, not following the EXPECTED standards of the modern PHP community, i.e. lack of namespaces, PSR-1/2 coding standard, Composer, tight coupled code etc) 
I made an update (PHP) script that calls a bunch of commands and reads their output to determine if all went well. Does a git pull, puts the site into maintenance mode, runs migrations, installs dependencies, and sends notifications to Slack (most notably the error if something goes wrong, but also a changelog for my colleagues). I don't run tests because I trust running these locally is sufficient, but if that was needed all I would have to add would be a simple `$this-&gt;runTask('codecept tests');` or the likes. Connected that to a Git Webhook listener so it runs this automatically whenever something was pushed to the branch the server is listening to. All in all a server update this way takes about 40 seconds (most of the time going to npm install/npm run build for my React frontend). I could probably easily make the downtime much less than 40 seconds by doing the update except database migrations on a mirror of the project and then moving the files, but 40 seconds hasn't been worth the time, effort and added complexity yet. And the production server doesn't update that often, and 40 seconds downtime per week while there aren't (m)any users active isn't an issue. While this solution doesn't satisfy your third requirement, it doesn't really need a ton of documentation because it's extremely simple and the total (excluding my independent Slack lib) is less than 300 LOC.
why? IMHO, a `const` like in C/C++ is way better than `immutable` because `const` works on objects while immutable works on `class`
It doesn't make sense to have a native feature that makes whole classes immutable. We only need a mechanism to make specific properties read-only. Methods are already read-only (you can't assign a new method on an object), so we're covered there.
&gt; The field formats are passed statically as classes, instead of as objects, precluding configuration &amp; DI for the types. It is this: add('dueDate', DateType::class), but it should be this: add('dueDate', new DateType()) You are allowed to pass a FormTypeInterface object: https://github.com/symfony/form/blob/v3.1.3/FormBuilder.php#L78 
We're using buildkite and it's great, I'd recommend it for sure. 
`DateTime` also has pretty good support for doing arithmetics with dates which weren't there before the extension was introduced. Plus, there are some classes around `DateTime` like `DateInterval` and `DatePeriod` (which, btw, is `Traversable`).
You might find real user reviews for Oracle SQL Developer on IT Central Station to be helpful. As an example, this user writes that one feature he finds particularly valuable is, "Oracle SQL Developer Data Modeler. No PL/SQL IDE has such modelling capabilities, as far as I know. This is a killer feature for me." You can read the rest of his review here: https://www.itcentralstation.com/product_reviews/oracle-sql-developer-review-38481-by-stefan-oravec.
Ok... What's your supporting arguments to your opinion?
Thank you very much for your suggestions, I have updated isNumberOdd &amp; isNumberEven methods per your suggestion. It is greatly appreciated.
I am using [DeployBot](https://deploybot.com/) to deploy a SaaS I'm working on, it allows you to deploy to multiple environments (dev, prod, testing etc) on different servers, allows you to connect your bitbucket, github or gitlab(i think) account, you can upload config files that will be deployed as well as your code, and you can configure scripts to run before and after a deployment (composer install etc). 
&gt; DateTime also has pretty good support for doing arithmetics with dates which weren't there before the extension was introduced. It is true that DateTime and DateInterval makes it easier to do arithmetic, play with timezones, and PHP supports some operator directly on them which is very handy. But it is incorrect to say that PHP didn't support the same arithmetic before, [strtotime() has pretty much the same capability](http://php.net/manual/en/function.strtotime.php#refsect1-function.strtotime-examples) in a slightly more convoluted way (eg have to build strings to modify date instead of calling -&gt;modify()).
Thanks!
Carbon is even cooler than that!
I just setup bitbucket &gt; circleci &gt; envoyer for a client and it works great. Bitbucket support for circleci is public beta right now but it seems to work fine.
Does anyone know a good therapist that can work with the entire FIG and help them out? Maybe they can get a group rate? As a long time (and barely vocal) PHP community member, I'm pretty fucking tired of reading about this bullshit. 
&gt; It is a person that does both, at least in every project that I've worked on. I know and that it bothers me. It bothers me because they are not proficient in either field and if something goes south and is not documented somewhere internally, they are lost. Many times I had to call an ops friend to receive solid answers, because the "devops" guy from location raised his/her shoulders. &amp;nbsp; Although I'm a programmer, I know how to setup a machine and reboot a farm, but I prefer to leave this tasks to an ops, because (s)he can do it better and faster than me. &amp;nbsp; As a programmer I want a real ops guy next to me, which can resuscitate _that old bsd machine_ or patch _the mad cluster_ even if you wake him in the middle of the night, not someone who needs to search for a solution on the internal wiki.
We are using Jenkins with the [Build Pipeline](https://wiki.jenkins-ci.org/display/JENKINS/Build+Pipeline+Plugin) plugin. We have jobs set up which point to a Jenkinsfile - this is a Groovy script which lists each stage a job has to go through like commit checks, unit tests etc.
I think it's neat that you are rolling your own components and sharing them. It is always a good exercise to solicit 3rd party validation and feedback. You might get more feedback if you approached things from a place of growth. People generally find humility and humbleness a very endearing quality. So here's an example. You said this. &gt; What arrogance and ego I have, right? Who am I to even say what age this is who's age it is. I have no stars on github and no followers on twitter, just another voice in a wind full of "wanna be programmers". What a glorious age. Why am I here wasting you time? I think there is some humour in here, it's just kind of laced with satire which makes it a little jarring. Instead, consider saying something like this: &gt; I have been rolling some of my own components, wrappers around Symfony packages and things like that. Most of these are not new concepts but I am finding inspiration as I write these and understanding more and more as I go. I don't have many Github stars or Twitter followers (yet, lol), but I am trying to expand my network and reach out to some people. So in the spirit of continuous improvement and to try and be a better programmer, I'm very curious as to what you think of these. Just my 0.02.
Not sure if this is what they mean, but if you are resolving a dependency of a which then depends on a, most containers explode. It's pretty easy to catch and render a nice error instead. Edit: [This container](https://github.com/njasm/container/blob/master/README.md) is the only one I've seen that catches circular dependencies. 
&gt; Carbon is even cooler than that! [This is DateTime](http://i.imgur.com/ejOGqhN.jpg). [This is Carbon](http://www.xavierhufkens.com/thumbs/wurm-023c-300-2c73f97fe494a59d55cf99819fb4bc82.jpg). 
Just amazing what a decent developer needs to go through just to have a few people look at their work. Discovery thread has no exposure at all. An this thread has 20% up-vote rate. Sad reality. @SavishSalacious, just the other day I've wrote this check-list, I think anyone should read before posting. https://www.reddit.com/r/PHP/comments/4x2hkq/discouraged_to_build_anything_new_its_already/d6gxlmo 
We're on Codeship at my shop. Standard integrations for notification and cheap enough if you need multiple runners. They have integration with BitBucket now too, so you'll see build statuses with your commits. I chose this until BitBucket releases their setup. I also tried Distelli, which was more difficult to configure and didn't have a great interface despite working well. Choose this if you need free.
QAs that I work with spend their time writing gherkin and bombing the staging environment with exploratory tests...
Looks pretty promising. I love the idea of the image compare. I don't think even [Intervention Image](http://image.intervention.io/) has that.
Yeah I know I've used it a few times in personal projects but there is no way I would get the sign off in work with anything that has the word dev or beta against it, wouldn't pass the auditing, I guess the OP doesn't have this issue and can use any dev/beta software they want. I'm awaiting tentatively for the official release.
The goal isn't for every RFC to pass. At least the internals people will see some early high level thoughts from non-internals people and maybe get some ideas early on.
He's not bashing on PHP what so ever and the point he makes is actually quite valid. Most of our internal API's are written in PHP or NodeJS because that's what our team is most comfortable with, sure I love GO and GO *does* deliver better performance like for like but if there isn't a full team to work on it and bug fix then it has no value.
Looks like some templating engine code? I am not familiar with it though.
Can you tell me where I can find out more about this? Edit. [Found it](https://bitbucket.org/product/features/pipelines).
&gt; Indeed, no need to maintain your own box for this stuff. If only that were true. Where I work we're not allowed to use anything externally, and have to host anything ourselves. It makes it really difficult to find a solution. Especially since we can only host PHP applications. I haven't been able to find a complete solution that will work for us.
Any chance you could share some of your jobs? I have GitLab CI available to me but between setting up the worker and then defining a deployment job, I haven't had a chance to get much working on it.
This seems to be from a custom template engine for [IPS Community Suite](https://invisionpower.com/). I'd recommend checking their documentation or their development community for more information about how their templating syntax works.
&gt; The goal isn't for every RFC to pass. My goal isn't for them to pass. My goal is to have RFCs polished and presented in the best possible way, so that there is the minimum amount of confusion about what they seek to do, and what their justifications are, even if I don't fully agree with the RFC. &gt; At least the internals people will see some early high level thoughts Yes, because i) internals people care so much about this sub-reddit which has people thread-shitting in it on a weekly basis. ii) There aren't already enough feature requests coming through bugs.php.net for the internals people to read. /s Seriously though - PHP doesn't need people throwing high level thoughts around - it needs more people writing documentation and contributing low level code. &gt; maybe get some ideas early on. Maybe some people are already working with the guy to make polish his RFCs read better? 
It'll be released next week at Laracon in Europe. I've already been using it for a month.
My original intention is not of keywords but of concept. In c/c++, `const` will set turn an object to immutable. Thus allowing you to reuse a class for both immutable and non-immutable purpose. And drop immutability to old libraries. But using immutable on class will result in duplication of code and restrict it to new classes.
This is what happens when ego becomes more important than the programming language.
I have been casually building one... No official release yet, but should do the job for basic forms. https://github.com/geggleto/form-builder
Actually this article looks like author encountered several people who did bad things with fluent interfaces, function overcalls etc. And some personal experience on those cases. Anyway, highly opinionated article.
Final on the class level in Java is the same: Class cannot be extended. To make an immutable class, you would simply declare all its properties to be final.
Jenkins with webhooks. We are backing it with Phing to run all our code quality tools and drop it off in the web directory. When production happens it packages it up and sends it out to EBS right now. Currently looking for a sexier replacement, though, for some of our smaller sites. Our main stack runs through EBS simply because it is a very simple but large legacy project, with few dependencies. After jenkins builds or fails it packages up the results for us nicely and sends a ping to our production channel on glip so we can see it happened. I do currently have a full setup in Puppet for our servers but we haven't had the opportunity to use them just yet in our pipeline. We are probably going to be moving over to a new setup very shortly. Jenkins is great and I enjoyed my time with it but i think we can do better. 
Try out with Spress: written in PHP and it is very flexible: http://spress.yosymfony.com/
Yeah, this is not great. Yoda typing isn't suddenly irrelevant, I still fix accidental assignments in conditionals here and there. There's something to be said about not using a service locator, but not what the article is saying, using a DI container correctly cleans up so much code. And worst case you can always do /** @var \My\Class $variable */ $variable = ServiceLocator.get('thingy'); which will be picked up by any good IDE.
I really need something like Envoyer that can be self-hosted, but I haven't seen a similar solution. Really sucks talking to other developers that get to use all the latest and greatest SaaS products.
Thanks, that helps a bit. I've actually got a runner set up and running tests successfully. I actually made a script on the runner server that I just trigger in my .gitlab-ci.yml file instead of adding all the details into it. I think all of my projects would need the same steps anyway. I'll probably do the same with a deployment script on the runner server, just need to figure out an easy way to pass in the correct server credentials and whatnot.
Hah, I wish it was like that when I joined those projects. Yes, I also do contracting like that, and it is indeed that situation as well :-P
It's purely hypothetical at this point, but I will be experimenting with using a query builder to allow modular pieces of our system to apply search filters to a query. For example, sometimes users want to get all users that have one or more services assigned (email, web hosting, etc). Rather than having the search tool know how to determine whether a user has email or web, the idea is to do this sort of thing instead: if ($emailFilterWanted) { $emailService-&gt;addSearchFilter($query) } ... $query-&gt;execute() 
Sounds like you are just offended by things he wrote about. Individuals have opinions, deal with it.
The documentation isn't that easy to find things in. https://www.invisionpower.com/support/guides/_/advanced-and-developers/hooks/template-hooks-r105 "If statements separate the hook point identifier with :|: while foreach loops separate the hook point identifier with a simple colon ( : )." 
Heh, quite the coincidence.. I recently stumbled upon a similar concept with [gostatic](https://github.com/piranha/gostatic) (written in Go). It's a bit more end-user friendly in that you don't *have* to write code yourself. Maybe have a look at the available processors or Go code for some inspiration :)
I can agree with a lot of points there. But I don't use IDEs for various reasons. Believe it or not, but typehinting classes is not everyones style either. Generally I am heavily opposed to it, unless you use interfaces correctly. The latter isn't always the case, so typehints usually give me more headache then warm feelings. Keeping an IDE working everywhere is a case of personal quirks too.
Really! Thats an eye-opener. I've never been given that chance to be hired and crash coursed through anything new. I've always been rejected so maybe I'm doing something wrong. 
Good point. Your input eases the mind!
Thanks! Yeah their documentation is pretty bad :|
RC was tagged a few hours ago FYI. So very soon. If work needs to sign-off from the start then maybe still a no-go, otherwise it shouldn't be too long now at all.
It's more than that. With a DateTime, you can represent the same value in many different formats. A class that relies on (or provides) time information can typehint a DateTime instead of hoping a correctly formatted string gets passed in. This approach to the code reduces the need for documentation, which is always a good thing.
For continuos deployment I'd say take a look at ansible. It practically has the only requirement that the server can ssh. Is uses yaml as dsl, so it is rather easy to learn. It is completely up to you how you deploy your app and there is almost no dogma about it.
Having large numbers of ~~constructor~~ function arguments usually stems from underlying architectural problems, like missing objects.
&gt; It's badly documented - if there are no documentation people can't learn about it quickly. I do not think thats the case with mine, but I could be wrong. Point out some issues and I can fix them. &gt; It's in poor quality (no tests, not following the EXPECTED standards of the modern PHP community, i.e. lack of namespaces, PSR-1/2 coding standard, Composer, tight coupled code etc) Mine are PSR-2 compliant and use Composer as well as have 100% test coverage. (If you don't have 100% you are doing it wrong). 
&gt; PSR-2 and PSR-12 say no prefixing with _ and it's good to follow standards. oooo I didn't know that. thanks for that. &gt; strict_types and use return types when possible. I assumed I did this? Am I missing a place where strict types are not being used and I am not returning specifically where I can? &gt; You have typos in code (overrideDefaulRoute). &gt;.&gt; Thanks for that. &gt; You are still exposing several symfony objects. Can you give some examples? &gt; Why are you even wrapping the route if it's not really exposed or meant to be used? Abstraction. I didn't think it would look nice if I was doing `new Route()` every time in the `post`, `get`, `put`, `delete` Is there a better way to do this?
I believe there is still place for personal quirks if they don't hurt anyone and don't break any standards. And yes, mine is: if (null !== ...) {
What industries/sizes of business do you anticipate as customers?
Don't go crazy adding features you may not need, the "enterprise" world is all about testing and support. The more features you add the more you have to test and support so don't add anything you do not have a business case for. Make sure you have a solid, automated, test set - I write enterprise PHP apps and tests are an utter lifesaver. If at all possible do test driven development and constantly revisit them to make sure you have good coverage.
&gt; and ImageMagick &gt;= 6.5.3 I'd strongly recommending a recent (within the last year) release of ImageMagick. There have been a significant number of image corrupting bugs that i've isolated and then the ImageMagick guys have fixed.
Is this typically the case with open source software too?
Yes. It was Janice who was fucking Chad. 
The most important thing to me (as a persons who selects SaaS solutions for their business) is support for sign in via Google (Google Apps for Work).
Oh, nice. Yeah, I probably should've take some insperation ~~**cough** **cough** *brutally steal* idea **cough** **cough**~~ :) I saw yesterday a static website generator called [metalsmith](http://www.metalsmith.io). Interestingly that its concept looks pretty similar to mine (however it generates JSON, and then operates from it). By the way, I actually had an idea of making configurable generator version, in which you just define the config, list in config all the data fields that plugins can accept, and plugins are registered with special global singleton (`\crystal\edge\PluginRepository` for example), and grab those plugins from there and inject them into `$site-&gt;plugins` in the same order as in config.
Ah someone who knows libpuzzle :) Probably not in a good way, libpuzzle is a C extension, while Grafika is PHP code calling GD (already slow by itself). But that would require some benchmarks to know how much slower Grafika is.
There was a similar topic last week, specifically referring to Magneto that you may find useful: https://www.reddit.com/r/PHP/comments/4wv9w6/what_makes_magento_enterprise_that_the_others/
It's not so difficult to depend on 2-3 other objects, just for the basic functionality. Also add a config instance, a mailer instance, and things grow pretty quickly. The two ways I've seen to still do dependency injection and avoid writting 6 lines each time are: containers (i.e. service locators) or creating instances of some objects as "default" values if the dependency is not provided (IIRC league/oauth2client did that). But yes, I agree, too many dependencies is often a code smell, suggesting that this object might be trying to accomplish too much.
I have downvoted this post, since you were unwilling to respond to feedback. 
In my experience some "enterprises" are ok with the lack of paid support as long there's an active community behind the project. Because you know, the community will fix stuff and come up with new features.
&gt; It's not so difficult to depend on 2-3 other objects, just for the basic functionality. Also add a config instance, a mailer instance, and things grow pretty quickly. There is virtually never a case where the scenario you're describing is not revealing an underlying architectural flaw in your application. It's unfortunately extremely easy to fall into this trap, because - let's face it - it's much easier to simply inject another dependency than rethink swaths of your application design. As business needs and scope grow over time, this problem compounds. These problems aren't initially severe, mind you; it's just technical debt. As long as you pay down that debt over time (by periodically refactoring), they won't amount to any practical problems. &gt; The two ways I've seen to still do dependency injection and avoid writting 6 lines each time are: containers (i.e. service locators) or creating instances of some objects as "default" values if the dependency is not provided (IIRC league/oauth2client did that). The best way is to simply avoid creating classes with 6 dependencies. Service location hides dependencies, removes the benefits of typehinting, and generally leads to all kinds of nastiness. Don't do it. Using a DIC is okay, as long as you're not passing the DIC itself around (since that's just service location). Personally, I don't like containers, and find that the cases where people have deemed them the most useful are the same cases outlined above that are revealing underlying architectural problems. Using them for these cases makes it less annoying to deal with your technical debt, and subsequently less likely to pay it down.
The right language for the job is 90% of the time the language you know. Actually knowing the language will lead you to the 10% that another is truly better. It's a catch 22 of sorts.
I have 20+ years of DB experience. If the basic model structure in Eloquent doesn't do it, I write a raw query.
Can you give an example of a real application (not a tutorial or example "app") on github where no classes anywhere have 2-3 dependencies? I would be interested to see something of any real-world complexity satisfy both SRP and 2-3 dependencies is an architectural flaw. 
&gt; In our office there are roughly 13 developers, out of which there are 5 with some degree of C# experience, and of those 5 I had the most. Alternatively, all 13 of us had PHP experience If you start switching to C# you're not gonna have 13 devs - you'll have 5 devs. The other 7 will be out looking for other jobs and some of the remaining 5 might as well depending on their comfort level with C#. Sure, they could learn C#, but would that even be that good for their career? Do you want to be a jack of all trades / master of none developer or do you want to be a true master of one trade? If you're an awesome PHP dev you'll get any PHP jobs you want. If you're a mediocre PHP dev and a mediocre C# dev... you might not be able to get dev jobs in either language.
On an vaguely related note, reading some basic guides on regex and experimenting heavily using regexr.com is a good way to get people to self-teach regex in my experience.
On a sort of related topic, do you know of any library that can figure out the crop dimensions from two different images where one is a resized crop of the other?
Starred because I know I will need to use this one day. I like the API a lot, well done
&gt; You may also want to consider adding the ability for the user to request an updated email and link. I think this is the best solution, better than the random question. People have a bad tendency of choosing an easy question with an easy answer. And never forget to encrypt the password between client and server ;)
The problem is that I do not know php but do have some C, C++ and Pascal background from many years ago. I use curl to grab the page. At this point I need to parse and find each of the "Callsign Last TX Source Date-Time PST" from the site I got back from curl. what is a good way to extract that? 2) What is a good way to watch the site for changes without stressing out the server with repeated page loads? 
First of all, check out DOMDocument. It was built for this kind of thing. Curl the page, toss the HTML string into DOMDocument, and now you get to go hunting through the nodes for the table you want. Then you want to get DOMXPath, which will let you query the table node and pull out the rows into an array. Then loop through the rows and toss that info into your database. To keep your server load down, set up a cron job to run, say, once every 5 mins. That's unlikely to stress any modern server if all you're pulling is one page like this at a time.
I would consider regular password reset intervals to be a detriment to password security. Just encourages bad password choices from users. Much better to enforce a stricter password spec and attempt to educate your users not to reuse passwords from other sites.
"Good code".
Indeed -- as a user all you do is change from: Hard-Password1, Hard-Password2, Hard-Password3 and so on. There's http://php.net/crack which may help.
You should definitely look into Goutte, written by the great fabpot (creator of Symfony and much more). It's built for exactly the type of scraping you're doing. You can feed in CSS selectors and loop through the matching HTML elements to get at the data you need. https://github.com/FriendsOfPHP/Goutte
Could you explain what you meant by "encrypt the password between client and server"? Shouldn't _emails_ be sent over TLS? 
Automated tests prevent feature creep. I usually find several bugs in my code when writing tests, and tend to keep the number features low, but test them to the oblivion. 
If you really want to use regex, try this: $str = preg_replace('~&lt;.+?&gt;~', '', $str); .+? = any character occurring one or more times but don't be greedy, stop when you hit the next character instead of just including it in the capture set (I'm on mobile, so that was really time-consuming to type and it may have typos)
Here's some recent research also indicating that forcing frequent password changes might be harmful: http://arstechnica.com/security/2016/08/frequent-password-changes-are-the-enemy-of-security-ftc-technologist-says/
Why don't you prompt the user to change the password on the next login after it's expired? 
OP Here. I did setup DKIM and SPF, but DMARC is new to me and it has been sometime since I used mail-tester. I'll have to look at both those items. The easiest approach is definitely to fix that damn email. P.s. The user must authenticate and at that point they are notified the password has expired and to check their inbox. Thanks for the detailed response!
Your email delivery problem should probably be fixed. Doesn't it affect actual human to human communications too, not just password reset messages? Have you considered moving to a hosted email solution... Google, Rackspace, Microsoft, GoDaddy, etc.? Startups shouldn't be running their own email servers... it's a waste of staff time to debug deliverability issues and combat spam policies and blacklist errors, etc. Let one of the big companies take care of that. We'll used to spend a dozen hours a month figuring out email problems to different destinations. Moved to Google and never had a problem with it again. Moving your password reset system from email to security questions weakens it, as an attacker no longer needs access to the user's email account. Fixing the email is a better approach... Also, have you considered cloud identity services that handle login for you? At the simplest it's just log in through Google / Facebook, or it can be fancier and include multiple social options in addition to email login, all handled by the third party provider via a token system. Examples are oneall, gigya, and a few others. "identity as a service" or "federated single sign on" I think they're called. 
I agree and we use Mandrill (very widely used), not our own hosted solution. This wasn't always the case, but it has been since about 3 months after I took over. We have zero problems with communications going out to standard consumer addresses such as Gmail, Yahoo, Hotmail, etc... It's these weird corporate email servers that give us trouble. I'm definitely going to look at this again before doing anything else.
Or make passwords non expiring but require 2-factor. User logs in with username/password and they get a text on their phone. Simple, way more secure and doesn't annoy the shit out of people so much.
&gt; TLS is for HTTP, not email. Explaining your downvotes, [There's a thing called StartTLS](https://en.wikipedia.org/wiki/Opportunistic_TLS) which is used for email that lets it elect to use TLS. It does suffer from a flaw that means an active MITM attack can strip it, but it will prevent anyone who is eavesdropping on the route from reading the contents.
Yeah if you're running a banks internal systems you shouldn't send 2FA tokens through SMS, but for most other applications its just fine. If OP is really worried, they can go with something like Authy which does both the app based TOTP and sms as a fallback.
I know exactly what its for, it does nothing the docker cli can't do, reinventing the wheel for the sake of it
&gt; docker-compose I never said docker-compose was pointless, I said this website is pointless as it offers nothing extra over what the cli offers.
Yeah work need the sign off from the get-go, its a pretty pointless system in my eyes as the version is technically 'finished' but rules are rules in a corporate environment 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
yes, that was a /s post.
Symfony does nothing plain PHP can't do. What is your point?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
But how to feed central process. You just have two options. One is run two processes in the same container and the second is write from PHP process to the central process . 
DateTime is 403 Forbidden?
[removed]
Well.... MS .NET Core v1 is a good lesson. It is "RC" yet is still going to undergo major breaking changes before stable release. So, corporate does have a decent-enough justification here. Sad in this instance since we are so sure about things, but they are justified. Have fun with work regardless!
&gt;non-existing variables won't issue a warning when wrapped in isset(). Yes, that is what `isset()` is about. You give this function a variable and it checks if the variable exists or not. Why should it cause an error?
have to agree, reinvent the wheel and make it slower.... seems about right for a PHP project lately 
https://www.wired.com/2016/03/want-safer-passwords-dont-change-often/
lol the hoops you have to jump through just to use cgroups. Just use the native cgroups on your system, okay it doesn't have a 'cool' logo, a 'hey dude totally hip name' or a '.io' web address but its still more than capable and has been around a lot longer and stood the test of time 
Here is what I did on my last project. - password strength based on entropy rather than patterns - mobile phone mandatory for all users. - if password is changed sent text through Trello as well as email. - never expire passwords, many users use random passwords and store them in lastpass - when user logs in successfully , generate token and store on device and DB. - if no token present or it does not match , send text message. When entered store a token. - do not permit certain secure (withdraw) actions if token is less than 1 day old I hope this helps. Edit: the previous solution used security question. I ran a statistics on answer diversity which ended up being - more than 30% of users had guessable questions (population names and locations)
It's not a function, by the way.
\*pressing hands against my ears\* IT IS! I don't listen to your language construct talking ... LALALALALALA! :D
Yeah, I get that. Sorry for my snark, I've been having a bad day and I saw your uncharitable comment. Kinda took my bad mood out on you... :(
Not really sure what you are trying to accomplish. But I think you just need to add a volume to your container, which will be mounted on the host. Then you will have this file available in the container and outside the container. For example: docker run -v &lt;host_dir&gt;:&lt;container_dir&gt; image So if you were running a PHP container for example like: docker run -v /path/to/host/folder:/var/log/php/ php:7.0-fpm Your can write your log in your container to /var/log/php, and you can see them in your host machine in /path/to/host/folder 
It's the internet, its cool, no worries
Unless you are using HTTPS on your page, then when user type their password/new password on the site, the password goes to your server without any kind of protection. Any snooper can capture it. So either use a SSL server, or encript manually the password before sending it over
a map is not a bad idea. Storing the full class name doesn't seem wrong too
An application programming interface (API) is a source code based specification intended to be used as an interface by software components to communicate with each other. An API may include specifications for routines, data structures, object classes, and variables.
More importantly than anything. Make sure you are protecting yourself from Local File Inclusion. Aka, make sure your script securely checks for the type of file being uploaded 
This is not enough. You should also be checking the MIME type also, again, against an array of allowed types. Using both of these together is still not perfect, and you'll need to put into place measures to make sure nothing that's uploaded can be executed by remote users. In regard to your initial question, you could check if a file with the same name exist, and if it does, notify the user. Your idea of renaming the file would also work, however I would do something like appending a random number to the end of the file name, before the extension. That way, the informative portion of the filename stays intact, so it's still easily recognizable.
You can store the original filename of the file in your database and let the file on your filesystem be unique.
Thanks im checking it out right now
Oh this idea was given to me just a second ago by a friend of mine, since a while ago we used an Random Id generator we found online; Now this confirms it Thank you so much.
Are you using a database to store your information?
Yes im using a database
Thanks for your quick answer:)
There are some pretty good ideas for how to actually do that here. I particularly like the file hash as filename solution, if done correctly, which isn't necessarily easy... but a very simple solution is to just create a directory for each "bulletin", so that it has it's own filename space. bulletinfiles/1234/image.jpg bulletinfiles/5678/image.jpg Now there is no chance of one bulletin's files overwriting or conflicting with another one.
Utilize an SQL Injection Cheat Sheet - No just use PDO That was enough for me, not only is most of this wrong or bad advice the level of English is that of a 5 year old, really hard to follow with the grammar used 
no idea but it looks cool
You can't control if they get the reset emails or not - that's on their side. Trying to fix that problem on your side is probably not the best use of your time. I know it sounds a bit harsh and not super user-friendly but you're not going to be able to please all the servers all the time. If you're considering going the route of security questions, here's a few thing to consider: - Making the questions based on publicly available data (and there's *lots* of it out there) is a bad idea. - As mentioned in other posts, people are really bad at picking answers for these questions. You'll need to do extra validation on the answers to ensure they're not stupid things like "asdf" or "1234" among others. - The answers would need to be stored hashed or encrypted. This is a security control we're talking about here. Out of band solutions like emails are a much better route here though. That provides another external factor to help prove the user on the other end of the line. The more factors you can add in the better, especially when it comes to something that's as notoriously weak as passwords. Two-factor is another good option here to help prove identity but even that comes with issues. If you make two-factor an enforced part of the login/verification process, you're requiring everyone to have access to a device that can receive SMSes and be approved for corporate use (there's liability otherwise). SMS two-factor isn't really recommended anymore, though. Something like a push notification or a TOTP client is a better option. Security questions should probably be at the bottom of the list of things to implement. They're often misused and provide an attacker with another potential attack point.
Nineteen hours late but this helped me understand "enterprise" better. Maybe I read it here; maybe somewhere else. &gt; Enterprise is how the project is sold - not how it is built. What other people have said is also true but it's also true for any development. Larger companies just typically have more requirements. My employer is going through this right now. Our enterprise companies love us but we have trouble getting more work. I guess we had some very frank discussions and while they did love our work we just didn't know the corporate/enterprise processes and workflow.
PHP has a function [for creating a unique file name](http://php.net/manual/en/function.tempnam.php) Storing the file with a unique file name is easier (no need to create/delete directories, worry about filename-related vulnerabilities or error). When the user want to access the file (through its id), just take its original name from the DB for the download headers. Also, you might want to create thumbnails for images/pdf.
&gt; If PHP cannot create a file in the specified dir parameter, it falls back on the system default. That behavior makes this a pretty bad way to create permanent files. If a permission gets changed accidentally, you'll start writing all your user uploaded files to `/tmp/` instead of an exception being thrown.
Use a recursive function with a filename check using `file_exists` after building out path name. The recursive function will keep trying to create a unique filename until one is found. A loose workaround (not advisable if you are uploading a lot of files over a short period of time) is to just assign the file to date-specific directory structure (i.e. 2016/08/16/filename.extension).
I think my predecessor was highly paranoid. Frankly its a dumb policy and his security prowess was lacking given the amount SQL injection, XSS, and CSRF I had to fix in the early days. It's not health related and we're small still :-)
As a regex power user, I'm noticing the interface adds verbosity and weight, while hiding or not implementing some features of PCRE that are exposed in PHP. Nice experiment, but I think it can be improved upon. For example, I don't think the result has to be an object. If there are no results for single-match functions, return null. If there are no results for multiple-match functions, return an empty array. And PHP is optimized for preg_match() when you don't get back the results, but only care if you have a match or not (validation for ex.). It just never fills them in, saving CPU and RAM. As written, this library always fetches the results, even if the user never uses them afterwards. To fix the above, the API can be changed from this: Regex::match('/a/', 'abc')-&gt;hasMatch() Regex::match('/a/', 'abc')-&gt;result() To this: Regex::hasMatch('/a/', 'abc') // Returns true or false Regex::match('/a/', 'abc') // Returns array of matches or null
I think this license would scare off most of the potential users of this library.
OP said "with each bulletin containing many files", so he should probably stick with the file hash idea since there'd be a chance multiple image.jpg files being uploaded to a single bulletin.
No recursion needed: do { $filename = unique_file_function(); } while (file_exists($filename));
I generate unique filenames and store the original in the database. When someone downloads the file I send a `Content-Disposition` response header with the original filename. I would probably generate a filename like`&lt;board_id&gt;/&lt;year&gt;/&lt;month&gt;/&lt;day&gt;&lt;hour&gt;&lt;minute&gt;&lt;second&gt;_&lt;sha1 of content&gt;_&lt;random value&gt;` or something to that effect. I would also strip away some characters from the original filename - for example everything that is not visible characters. Definitely strip away linebreaks and `"` to avoid HTTP header injection attacks, but best is to keep a list of allowed characters and remove everything else. The last time I solved this problem was [here](https://smoothcomp.com/event/45/image/swedish-open-bjj-2016-cover-b5c871bd58a0.jpeg?w=851&amp;h=315&amp;fit=crop&amp;s=a5f059da641ede97e358c49fe943821c). The filename is based on the event it belongs to and a content hash. We store it on disk as `event-media/45/swedish-open-bjj-2016-cover-b5c871bd58a0.jpeg`. The hash here is necessary for browser caching (we want to cache as long as possible but still being able to invalidate the cache when the user uploads a new file). If you look at the HTTP headers we send a somewhat nicer filename in the Content-Disposition header. Your download script can be just a bunch of `header()` calls and a `readfile()` call.
Split the MIT license in lines of a specific length &amp; the first letter on each line says "m u s t s e n d P O S T C A R D".
that would kill all the SJW's he is afraid of.
considering the other two articles were basically smear articles and stuff, this one is pleasantly different. The only thing I don't agree with is when you talk about how Drupal and phpBB would be founding members of the new group. Having two established projects coming on board immediately would give the new group some backing. That was the problem with PHP-CDS. It was community driven, which is great, but it didn't have enough community support. I feel that Drupal and phpBB would help remedy that in the start of the new group. Should that happen.
calling /u/assertchris
I use it for development work. Being able to spin up and tear down clean frontend/backend servers with all their databases and dependencies in a few seconds is great. I couldn't go back to doing things the way I did in the past.
.. huh, and here I was, thinking that OSS is all about the "we" and not the "me me me". Seriously Paul, this constant badgering that "you did this" is very counter productive to general OSS, we celebrate the achievements of a project, and we strive to make everyone a non-critical piece of that project, this is how we eliminate the "Bus Factor" and also how we ensure the project follows the will of the community and not the desires of the BDFS. The FIG is not about you, its about the community and honestly, I do not care who is "founding" and "past glories", I care about work getting done.
Let me get this straight... * You just finished a fight to stay in the FIG while a large group of members fought to show you the door. * You disclaim upfront that you have no plans to voluntarily abandon the "original FIG" *in this very article*. * You vehemently oppose the "new FIG" reorg. * You call for the "original FIG" to be abolished, and replaced by the "new FIG" with a different name. This is quite possibly the most blatant example of "take your ball and go home" that I've seen since grade school.
I would be curious to know how the holders of the "grand" vision would plan to make their "standards" authoritative in the eyes of the PHP masses? The "founding" vision is much easier to implement because it's, in theory, member projects working together to define a shared interface for some component / idea. Again, my understanding is that it attempts to solve a very **well-defined** problem. Namely, N number of member projects need to solve the same problem and we want to define a shared interface so that perhaps we could share an implementation as well. The wider PHP world doesn't even necessarily have to be made aware of the situation. The "grand" vision requires a lot of pride to pitch your standard as the binding, end-all standard for the entire PHP world. I don't see how it would ever be accepted by the wider PHP community. IMO, the "grand" vision holders already overestimate their influence and reach - the PHP world is a **big** world.
You've got the wrong end of the stick.
You can use finfo to check the mime of the file and then compare it against an array of safe types for validation. As an additional step you could use Imagik's stripImage() method to remove any EXIF data that may contain unwanted text/code and then save the file outside the webroot.
&gt; Wouldn't you say the existing PSRs have already been accepted as the binding, end-all standards? Nope. PSR-7 for example, is pretty goddamn opinionated in ways that certain codebases will not accept (I know we ditched it after realizing it's only immutable in name only) and the cache PSR is so generic as to be useless. For a lot of people, FIG was good for PSR-0/PSR-4 and that's about it.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I appreciate the amount of time you took to put this together, but what you are doing is terribly out of date and dangerous. You should never, ever put unfiltered, unsanitized user-entered data straight from POST into a database query!!! You also appear to be storing passwords in your database in plaintext. Please, please go read "PHP: The Right Way" before trying to teach people the language. You should really be using PDO over mysqli. (Also, when making these kinds of videos, if helps if you have a script made ahead of time, so there is less fumbling about with errors.)
We use it for both development and production. In dev we have a docker compose file that spins up a complete dev environment with all the services required (Postgres, Elasticsearch, Redis, RabbitMQ, etc.) Spinning up a complete dev environment is as simple as "docker-compose up" For production it gives us a number of advantages: - Easy and reliable deployment. Our CI server (Gitlab CI) automatically builds and deploys docker images to our ECS cluster. Deploying a new release, which we do multiple times a day, is handled by ECS by running the new docker images, adding them to the load balancer, draining the connections from the old containers and then terminating the old containers. - Rollback is super straightforward - just run the old image - Makes managing multiple microservices a breeze and allows flexibility in terms of scaling. Need more of X service? Then just increase the number of running containers on the cluster. - If we need to start using some new software then as long as it has a docker image we don't really need to worry about deployment.
It's a joke right? I'd sooner pay a fee than have to go to the effort of sending a postcard across the continent.
I'd love to know about a video where some nerd (like myself except knowledgeable about nginx &amp; php 7 containerized) just does an audible brain dump while screen sharing setting up the relationship.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I like the idea of OOP interface (despite added verbosity) but I agree with you that it unnecessary populates `$matches` every time. One improvement that came to my mind is that `preg_*` functions are called not when MatchResult is created but when certain functions on that object is called (eg. `Regex::match('/a/', 'abc')-&gt;hasMatch()` will call `$result = preg_match($pattern, $subject)` - notice the absence of `$matches`) EDIT: Also [this file](https://github.com/spatie/regex/blob/master/src/Helpers/Arr.php) (except for `transpose`) makes no sense to me
You are the man!! Thank you so so much for this! I shall not use Regex for Markup lanaguage, I promise!
What could the FIG do to warrant you coming back? I personally think there needs to be a president of sorts leading the group to keep things in line.
&gt; One improvement that came to my mind is that preg_* functions are called not when MatchResult is created but when certain functions on that object is called This occurred to me, but then if the user wants to check if there are matches, and then use the matches, they'll probably run the regex twice by accident. Plus it's still an extra class to load and object to create for literally no reason, other than to look cool, because it's more OOP, as if. I think... *it's ok to keep things simple*. Not everything needs to be fancy and over-engineered. There's a simple way for the user to communicate what they want from the start. When a library tries to get smart just so it *appears* more sophisticated and elegant, then its user is the loser.
I do agree that it's a over-engineered easy-to-understand api on top of simple not-too-easy-to-understand api. The only real value I see in this library is that it converts errors to exceptions. As for &gt; if the user wants to check if there are matches, and then use the matches, they'll probably run the regex twice by accident How is this different from using `preg_match` on its own? And anyway, you can't protect any library from improper usage but you can write good docs which will prevent the said wrong usage. Also looking over the code I see that it has no description on docblocks whatsoever... This isn't PHPUnit that has billion files and methods, it can be easily documented. I'm not using it until I can read what each function does without digging inside the code. Another thing I would like to see is benchmarks. No way I'm using something that eats speed just for nice OOP-based syntax TL; DR: I like the idea, but it definitely needs more work
&gt; How is this different from using preg_match on its own? And anyway, you can't protect any library from improper usage but you can write good docs which will prevent the said wrong usage. The difference comes from the "principle of least astonishment". The assumed contract for hasFoo(), isFoo() and getFoo() instance methods is that they are simple getters that don't perform any complicated on-demand computation in the getter itself. They just provide read-only views into existing object state. So it's very natural to invoke hasMatch() and then obtain the result on success, but you'll be running the regex twice. In the alternative formulation, a static class has no state, and the static variation of hasMatch() accepts pattern and string to check for matches, so it obviously performs the regex calculation when called. Likewise when you invoke match() you pass regex and string again, so it obviously recalculates the match. So a user would likely do this: $matches = Regex::match(...); if ($matches) { var_dump($matches); } But when you have an object with getters, the user assumes there's no recalculation happening, so the most natural interaction would be: $results = Regex::match(...); if ($results-&gt;hasMatch()) { var_dump($results-&gt;result()); } And we just executed the regex twice here.
Author here, I'll share some context. This package isn't intended for power users, but for people like me that occasionally write a regex and don't want to deal with the confusing (at least, if you're not consistently using them) preg_* functions. Adding verbosity is intended to improve clarity. If you're doing heavy lifting that requires CPU and RAM optimizations, or need some of the more advanced features, you're definitely better off using the preg_* functions directly. Feature parity isn't my intention, this package will probably be able to handle most, if not all, of my personal use cases.
If I knew what I wanted to learn, I wouldn't need a mentor, I'd go learn it myself. The hardest part about learning is knowing what you have to learn in the first place.
We need to make "being great" great again first. It's currently not worth the effort.
I find it incredibly unintuitive. There's a dozen tools for each OS, each superseding the other, none explained in a final "okay do it like this" chain, each described in a different, now outdated, tutorial. Then there's the 1000 different ways to debug, none reliable, and the thousands of different base images which end up consuming 10 times more disk space than Vagrant, and the awful search engine on the hub which doesn't let you filter by base image, coupled with the fact that deployment is in no way straightforward or simple, I find Docker just a bunch of hoops to jump through, resulting in almost no real benefit. If your app needs "micro services" in "containers" and is better off passing messages through 100 ports of 100 containers than just being deployed as a decent whole on a $5 droplet and have better performance by default, then by all means, Docker is (maybe?) a good idea. But for me, it offers no real advantage, not until the toolchain stabilizes, because right now it's as much as a convoluted self-parody as JavaScript's is.
Some of you might remember this from a while ago, but I have been working on a project called [Sqon](https://github.com/Sqon/sqon). It is intended to be an alternative to using self-extracting PHARs. I have recently released [a command line application](https://github.com/Sqon/app) (built using itself) that makes building Sqons as easy as creating a YAML file. There's still a lot of work to be done, but a pre-release version is available for those interested. Feedback is more than appreciated! You should write some benchmarks yourself to get a better idea, but I'm able to package an entire Symfony 3 application with GZIP compression enabled in around 10 seconds at ~12MB. [You can find the build configuration file I used for this test in the wiki.](https://github.com/Sqon/app/wiki/Symfony-3) You can find other configuration files for projects like Box and Composer. Both projects (Sqon the library and the app) are still in their pre-release stage, so expect breaking changes when new updates are released. I use semantic versioning, once 1.0.0 lands, you can safely use either project.
... implies that the author is not opinionated!
Regarding tooling, have there been noticeable improvements over time?
when was regex not great?
I'm really getting the feeling that it is beneficial in very specific cases, but no one knows if they apply until they've decided if it works for them or not.
I do a lot of work for a web-development bootcamp, and while we don't teach PHP, it's the kind of thing that can be really useful for a group of students. When everyone's coming in as a non-dev, it's really handy to have everyone on the same platform. The same reasoning applies to teams with lots of junior devs.
This is very smart. I've been wondering about Docker as a better alternative to MAMP/WAMP, for my shop's fontend people.
Oh sure, there is a hipness to it, but it seems to be the most popular and portable container solution. Do you find it to be mature enough for multiple deployments of a smallish application (CRMs, CMSs, etc) ?
Cool. I'd suggest at least adding these, for consistency: ::quote() // I'd rather call it escape() or encode(), though. ::grep()
Circle it and send it back, duh.
People still use Lighttpd?
I would recommend never using preg_replace whether through this interface or not because of this "feature": &gt; replacement may contain references of the form \\n or (since PHP 4.0.4) $n, with the latter form being the preferred one. Every such reference will be replaced by the text captured by the n'th parenthesized pattern. n can be from 0 to 99, and \\0 or $0 refers to the text matched by the whole pattern. Opening parentheses are counted from left to right (starting from 1) to obtain the number of the capturing subpattern. To use backslash in replacement, it must be doubled ("\\\\" PHP string). I once spent a few days tracking down a bug in some code that hadn't been touched in 5 years because a user finally inputted a string that had some money values in it. My mind was blown to find that this was intentionally added to this function.
Yes, the last six months have seen massive leaps on docker itself for orchestration via swarm and docker compose, as well as kubernetes, rancher... The gaps are being filled fast.
Use mime_content_type to get the MIME type of a file: https://secure.php.net/manual/fr/function.mime-content-type.php This is using magic numbers to get the file MIME type. This one you can trust, but remember to never store a file with the name supplied by the user. For example a JPEG file can show up as image/jpeg and be a perfectly valid JPEG file, but it can contain PHP code and if its name is image.php or even image.php.jpeg it can be executed by the server!