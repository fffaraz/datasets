I am finding it hard to understand what advantages there are to using your framework. My main advice would be; by all means make a framework - and put effort into it - you'll learn an absolute ton. Maybe that's what you're trying to do even. But don't try to release it as anything other than that unless it's in a really good state, and has some genuinely unique ideas that make life easier vs. other frameworks. If you want some feedback: * When developing / maintaining an open source project you should always try to keep your code clean and consistent as possible, by that I mean the little things, more to do with code style. For example; not mixing tabs and spaces ([the first file I opened had this issue](https://github.com/theprestig3/Skeleton/blob/master/skeleton/core/Config.php)). * You should try and adopt standards that are used by the core of the community, or that the audience of your product will use. The go-to standards are the PSR standards. Use Composer. Put your framework on Packagist. Add namespaces. Set up autoloading. Make your code conform to the standards defined in PSR-1 and 2. * Your concept of endpoints is realistically no different to controllers. I'd also add that you saying there are no views could be said about any framework you can make APIs in - if you take that to mean there are no templates (?). * You should try test driven development (TDD). I notice that you've said on your to-do list that you want to write unit tests for the framework. Those tests will now have to cover the code you have already written, and at this point you have already reduced the effectiveness of your tests. If you write the tests before you write your code then you have a clear set of instructions for you to write to fulfil the requirements of what you're writing. You know exactly when you're done, and it's less likely you'll be testing the implementation itself and will be testing that the input and output are what you wanted. * You'll need a wealth of documentation too.
Yeah like I said.... sketchy
You on Ubuntu? The (broken) upstart jobs log to `/var/log/upstart/` regardless of your config. Fun! Edit: I skimmed too quickly. Apache can't set php configuration flags if you're running FPM! That's mod_php stuff.
&gt; Colin's scrypt paper suggests 100ms as a an appropriate time taken for a secure password storage I think it worth to emphasise that the 100 ms (for interactive logins) is the traditional *upper bound*. In my opinion, PHP's default 10 is indeed a good generic default. Ie. many virtual servers might be less capable (bcrypt with cost 10 takes longer than 100 ms on them). And if there are concurrent logins, the server starts to suffer quite easily (not not mention spikes). Proper password hashing is one part of the "whole process", but it is not the only thing that needs to be done. Password quality is the biggest "single thing" that affects how easy it is to crack the password. Password policy enforcement should be done to make the users use better passwords (passphrases). Then in addition to proper password policy and password hashing, using separate device (with unreadable "local parameter" or key) to encrypt the password hashes makes a good "password handling" practice. That said, I think it is not reasonable to try to absolutely maximize the password hashing cost, but instead (as you said) find a good cost value which your system can afford. I previously blogged something about this http://timoh6.github.io/2013/11/26/Aggressive-password-stretching.html
&gt; http://www Thank you I cant believe I missed that 
The code is added into the php file that controls the footer of the website most website that are built with cms's have these files and are one of the easiest things to edit thats why I do it this way
I've never seen Silex before, but it looks exactly what I was looking for before I started writing Skeleton.
A *lot* of people have properties like `$this-&gt;foo` and getters/setters like `$this-&gt;foo()`. Because of that, "fixing" it would be a massive BC break. Also, the case-sensitivity is different: properties are case-sensitive, methods are case-insensitive (for historical reasons).
Do you know how php works? Like, really works - zvals and all that? How does PHP create the $_GET super global? What about $_FILES? Using a framework lets you add more things into the "I'm glad that works, and that I don't have to reimplement it" pile of features. Soon enough you'll need to dig down into it anyway, and as long as you understand inheritance, interfaces and abstract classes then you'll see what's going on anyway.
No, I meant I know how PHP works from the language level, not the implementation. Although, I would love too, but that is not on my list right not. However, even knowing OOP is not enough to understand symphony for example, because there are way too many abstractions and design patterns involved, which is something you don't usually see/do when making web application, it can be quite hard. 
PHP 7 will not change this.
HMVC is a huge antipattern since it allows your controllers to get data from other controllers. Controllers should be slim and only act as glue code between your domain and your router. HMVC structure emerges only in those architectures that have an anemic domain model and fat controllers. Then developers ask the question: *How can I reuse one controller from a different one?* when what they should be asking is: *How do I extract code from the controller to the model so that I can reuse it?* 
I ninja-edited it; you probably loaded the page in seconds after I posted it.
you don't use php_flag to set non-boolean values. [You use php_value](http://php.net/manual/en/configuration.changes.php). The people who mention you need to configure it in your FPM pool are also correct.
It's a good argument, I will give you that. But I don't to say PHP and Symfony have the same importance is the same thing. 
Wow! I'm genuinely surprised I have finally found a person on reddit who takes criticism well!
Read the docs? I mean, seriously it all their in the docs.
The doc is the tutorial, it talks about how to *build* something with Symfony. But, not about the architecture ... 
If you want to understand how to use something, read the docs, if you want to understand how it does it, read the code, there isn't really anything more to it. It's not a requirement to understand how something works behind the scenes, to utilize the benefits it provides (unless you mean that in the sense that this is a goal you set for yourself).
I don't think there is anything you are missing (or we are both missing it), understanding code is hard, especially foreign code. It will never go like reading a book. Basically, there are two factors here: a) your experience in programming b) how well the code is written The more and more experience you have, the easier it will be to recognize things, like common design patterns, eg. if all the public methods in a class start with something like $this-&gt;loadProperties(), you can safely assume that this is a lazy loaded object. As for b, things like following best practices, having a coding standard, using common language idioms, these all help other people who will read your code.
Check out Laravel... Its a great framework and is written REALLY well with some amazing documentation. Also there are some great videos on Laracasts that really dive into HOW Laravel works. Don't listen to most of these guys who tell you that you don't need to know how it works and that's the point of a framework. You're doing the right thing by wanting to know how these frameworks work behind the scenes, this will make you a much much better developer.
Hey, *fuck you*. I hope everything goes back to normal now.
I was asking myself how such thing was managed in PHP, as you can have classes that you do not expect/want others to use. I'll add `@api` awareness to the list of things the library should consider. [Issue](https://github.com/tomzx/php-semver-checker/issues/8) Thanks!
SVG is very well supported in browsers. http://caniuse.com/#feat=svg All the charting JS libraries worth using are doing it via SVG. You can export SVG to PDF or like other people in the thread suggested you can export to PNG via phantomjs (or similar). Create a API wrapper for this service to make it easier on yourself. http://www.pdflib.com/pdflib-cookbook/graphics/starter-svg/ If you are building something with charts for the web, SVG &gt; Images all day long. If you are building something for native mobile devices there are other libraries for that. 
It's not clear if you're looking for a tool to inspect existing code, or even new. If you want it for your own new code, I've been working a configuration file that can contain all of the dependency configurations of an application. It is an array that can be split up over multiple files. The core dependencies can be seen in [config/service.php](https://github.com/mvc5/framework/blob/master/config/service.php). The configuration can also have actual values to use, the configuration objects are resolved by the system. At some point something may turn up to visualize them graphically and maybe even manage them. What I like about it, is that once the class name reference is there, in the ide you can click through to the class and see its constructor. Which helps to figure out how to wire it up. 
Exactly, that is how I see it. Furthermore, this tool can help you do that analysis yourself. Say some framework/library you depend upon said they released a small patch release, but upon running this tool against it, you realize they are in fact breaking a few methods which you depend upon. Obviously you generally want to have tests that will alert you of such problem, but this tool can help the "less fortunate" (aka those with little to no tests).
How many of these questions did you try and solve yourself using the PHP documentation? If the answer is "none" please do so first. If after the documentation, you still can't get it to work, post here with the code you tried, and any errors you got. Please use specific details when writing your next question. Also, please refer to /r/phphelp not /r/php for support.
I'm not 100% convinced myself to be honest! :) 
&gt; 1) It forces your project (and sometimes organization or individual) into an arbitrary set of rules that may be completely wrong for that entity. Only inasmuch as you want to be part of a community that has settled on the practice. Internally or privately you are free to disregard it. If you're providing a PaaS and have CI or even CD, for instance, semver makes very little sense for your product. Generally, semver makes less sense for applications than libraries. &gt; 2) It provides false guarantees about the relative stability from one version to the next. [...] The BC guarantee always comes at an implied waiver in the case of implementation bugs. The *intention* is to break nothing, and any break is accidental and itself subject to a future -- ideally critical -- patch. Hopefully the library vendor has testing in place to reduce the likelihood of this, and if you're lucky, you have testing in place so you can verify your product still works. It's not a free pass to say, "fuck it" -- you still have to be a responsible software developer. &gt; 3) I feel it "makes an excuse" to be lazy [...] It's not an excuse -- it's *entirely* lazy, and that's the point. The only purpose of semver is to automate as much as possible a tedious process that can actually have considerable, if indirect, value to your product. Critical releases are especially good examples of this. But you still aren't magically freed of responsibility just by consuming and/or following semver. In particular, if you claim to observe semver but clearly don't, or regularly bump the major version (and maybe cease maintenance of old versions), the community will turn on you soon enough. &gt; I'm going to be pissed off when my next `npm install` breaks everything because some numskull released a "patch" that broke something silly. And rightfully so -- they violated their own contract. Semver isn't free. Incidentally, `npm` itself has a history of irresponsible development, which is curious for an application that so helped to popularise semver in the first place.
Question: does it work like it is? If yes: do you get paid to make it "more elegant"? If yes: do it.
You didn't really give any examples of what exactly you don't understand, so I may be way off the mark here but this is my 2c. If you really want to understand what the framework is doing you're going to have to pick it apart one step at a time. Don't know how the routing in Symfony works but feel like you need to know? Build a basic router yourself. If you can't manage to do that alone, then look at the other open source routers for inspiration (there are really basic ones out there). Once you've implemented it you'll have a good understanding of the concepts, then it should be a breeze to glance through any specific implementation (eg Symfony's) and understand it. You should be able to take this approach with any [component](http://symfony.com/components). I would imagine that once you've built a few things this way that you will start to approach the problems differently, and hopefully lead you to being able to skip the 'build' step completely.
Check out Lionframe - http://lakion.com/lionframe - I haven't used it yet but looks simple and powerful. Yes, it uses FOSRestBundle but I think in a cleaner way because of SyliusResourceBundle.
I haven't used it but the output could be aligned better so its not so confusing.
http://learnxinyminutes.com/docs/php/
When is php-fig going to have a cache interface...
Found a form: http://195.251.166.130/challenge7/login.php
I'm surprised xe.com isn't one of the provider options? I always assumed xe.com was pretty much the defacto standard for online exchange rate info.
Thanks, I'm going to review them. Sure it will be helpful.
They have a Data Feed but it costs 540$ per year for 1 computer per base currency (http://www.xe.com/datafeed/specifications.php). Parsing values from their tables is not an option, they display a warning in the code "&lt;!-- WARNING: Automated extraction of rates is prohibited under the Terms of Use. --&gt;".
How are you planning on storing the state? In a database? In a flat file? Yes its possible. Also, this is the wrong sub for this.
So, I'm not sure what you need help with. How to use a database with PHP or...? Because there are plenty of resources online for just about anything you could want to do.
Of potential note: php -r "echo md5('admin');" 21232f297a57a5a743894a0e4a801fc3 ...but probably just convenience.
Depends on how critical the application is. Hobby? Maybe unit tests. Enterprise App with large enough budget? All of the above. The answer is almost always "it depends".
Before the console, we had to type javascript.void(document.cookie=document.cookie+";phpsessid=v07ls240d2bm07m6e0eiilafe3"); manually into our address bars to forge cookies. Fun times.
reminds me of this: http://www.whitewashing.de/2014/10/26/symfony_all_the_things_web.html
Why do you say "should technically"? Is that not implemented yet? 
Firstly, I'd like to point out that running your unit tests is the same thing as running regression tests. Secondly, the reasoning why you _should_ write at least unit and acceptance tests is that unit tests will tell you if you've broken something. If the codebase is larger than 10 lines and you get an impromptu change request from your product owner, you'll either find yourself (if you don't have unit/acceptance tests) wanting to say "you can't have that, I've already created your beautiful snowflake and I'm afraid your request might break it" -- in the case where you do have unit tests you can simply make the change, run the tests, and know instantly whether or not you've a.) broken anything and b.) broken any previous features in the product. I'm in operations, now, and I still write unit + acceptance tests. Its a bit more difficult, but very necessary.
Write as many tests as you need to in order to not be afraid of changing things. On a small hobby app this threshold might be quite low because you don't mind if the service goes down. If you're building an enterprise application and getting paid for it then you'll want to have high confidence that everything still works after any change, and you should write as many tests as it takes to give you that reassurance.
Use codeception do ,whitebox testing, just test your http api and you'll be fine.Don't bother with all the crap that is only meant for large teams.You shouldn't be spending more than 1/3 of your time testing stuff,when you need to write docs,manage clients and coding at the same time.
Nice work!
I've used HMVC in previous jobs (within Codeigniter), and I've found it useful. Just like any tool it can be abused in ways that have mentioned before, but I don't think that in and of itself it's inherently bad. That said, I'm interested in "I don't think an HMVC package can be framework agnostic" I looked over your code in that repo, and other than the service provider and using a few of the Illuminate helper classes, I don't see anything that implicitly ties to to L5. Did you attempt to make a framework agnostic package? What issues did you come across that made it impossible? Just asking because I'm curious. 
&gt;As a single developer i feel that making so much tests is really time consuming and i spend like 4x making the tests rather than the functionality This is normal. Good programmers spend a lot more time doing all kinds of other things than they do writing code. Planning and testing are huge components of any good software.
W have multiple websites with hundreds of millions of views a month. You bet we test the shit out of it. From phpcs to phpmd to phpunit to selenium to log profiling to nagios monitoring. And that's just the back end part.
+1, totally depends on how long you plan to maintain the application. This blog article is extremely interesting: http://verraes.net/2015/01/economy-of-tests/
Testing takes less time, not more. That is the whole point.
Did you hear about the Italian chef that died? He pasta way. 
When does using output buffers make the most difference?
Do you want a template, using `echo` etc, but keeping its output and doing stuff with it before rendering it? This is where output buffers shine.
Please note: the work the PHP FIG is doing is amazing and I appreciate their hard work. I expect to have this blog post torn apart.
Why don't you install a Symfony2 standard and use it's CLI tool to generate an entity and u CRUD for it? then you can inspect it and check how it's done. symfony2 install: http://symfony.com/doc/current/book/installation.html generate an entity: http://symfony.com/doc/current/bundles/SensioGeneratorBundle/commands/generate_doctrine_entity.html generate crud: http://symfony.com/doc/current/bundles/SensioGeneratorBundle/commands/generate_doctrine_crud.html
&gt;&gt; i spend like 4x making the tests rather than the functionality You have to look at the overall picture. How much time do you spend navigating code and finding where something is? How much time do you spend reading and trying to understand the code of your team members, or even code you've written 6 months ago? How much time do you spend triaging bugs, researching them, fixing them, testing them, and making sure you didn't break anything else? How much work is spent by others on non-development tasks: project management, issue tracking, manual testing, ... In my experience, with good testing, you'll need less of all these activities. Bugs not only become fewer in number, but they tend to become more "superficial". They're easier to resolve, because they're often about some edge case you've overlooked. Add a test for that case, to prove to bug, commit, fix the bug, commit, refactor if needed, commit. Some people will tell you to test everything, but that is a waste of time. Writing tests has costs and benefits, and your job is to balance those. There's a point of diminishing returns. To learn how to balance, ironically, I advise you to test everything -- at least at first, until you develop a feel for it. I wrote about that here: http://verraes.net/2014/12/how-much-testing-is-too-much/ 
As far as I know, $this is then set to that object. So if you do this: class foo { public $name = "foo"; public function bar() { return function() { return $this-&gt;name; }; } } class fooz { public $name = "fooz"; public function __call($name, array $args) { if (isset($this-&gt;$name)) { return call_user_func_array($this-&gt;$name, $args); } throw new \BadMethodCallException(); } } $foo = new foo(); $fooz = new fooz(); $fooz-&gt;bar = $foo-&gt;bar(); echo $fooz-&gt;bar(); It will print 'foo' instead of 'fooz'.
its not a big deal for coding - no, you just have to find workaround for some few useful new methods, and you might not be able to use some libraries/packages that have requirements of php 5.4 or newer but despite that fact, that specific php 5.3 version is so outdated, it SHOULD be updated at least to newest php 5.3.x version (afaik 5.3.29) for security reasons
PHP 5.3 is no longer supported by the PHP developers. Some distros backport patches from newer versions to 5.3, but you're now almost completely reliant on the distro packagers searching for, finding and fixing (without breaking other things) vulnerabilities and bugs. PHP 5.4 is also due to [exit support later this year](http://php.net/supported-versions.php), so by the time you're considering upgrading, it's likely 5.6 will be the recommended stable version, with PHP 7 just around the corner. Will having to work on 5.3 make your life more difficult? Yes. There are new language features and changes that you will not be able to use (improvements to the DateTime extension, for example). Many third party libraries and frameworks will also be unavailable to you because their developers no longer test against 5.3 or use language features only available in more recent versions (the new array declaration syntax is a popular example, along with namespaces). Where you can find versions of libraries for PHP 5.3, it's much more likely that they're no longer maintained and may well contain known bugs or vulnerabilities. You also may run into bugs which have been fixed in more recent versions. Delaying upgrading will also mean that the task of upgrading for 7 (or even just 5.6) is going to be much larger. I would recommend that even if your production servers don't run the current stable PHP version, you regularly test against it to avoid major issues when you do upgrade.
Is there any way of have two PHP installs alongside one another? I'm configuring a local server for me and the other web developer to use for development which is currently on the latest PHP, though I'm now planning to downgrade it to match the server. If I could have them next to each other somehow that would be very handy for testing against newer versions as you said.
Fully agreed on the mutability situation. An immutable API would be a much better / cleaner solution and would encourage people to write better code.
You should probably look for a more professional shop, unless you're really desperate for a job or you need the experience. Fwiw, even if they don't have one, you could set up a virtual machine for your own use on your workstation.
I've heard good things about http://virtphp.org that might be able to help you run different php versions side by side 
Looks good. Might potentially use it for an up coming project. One thing I would suggest is remove the hard coded providers in the Builder class and replace that with a public facing addProvider method where the user can add providers manually.
You have to realize this can be a daunting job if you have hundreds of applications running. Looking at my company we have about 600 php sites / applications running for our clients. While it is is true that testing and fixing a single application for a new php version usually doesn't take too long. But now multiply that time by 600 and you have a gigantic job. The dev team (+/- 15 devs) is all busy working on projects, it's not like we can just stop doing that for say a month and upgrade and test everything. So in practice we have to reserve some time continuously to keep stuff fairly up to date. Just recently we have managed to get all our php 5.2 servers replaced. Now we are running new stuff on php 5.5. But we still have some 5.3 servers running. Also something to keep in mind we need some form of long term support on our server installs. That's for example why we upgraded to 5.5 and not 5.6. That. As sound odd, but we are running the new servers on Ubuntu 14.04 lts. They supply 5.5 with long term support. This will create a much more realistic time frame for us to get apps updated for newer versions. The 5.3 servers we have running are using debian with Zend Server. There we still have support until 2017. So in practice we are now just about starting the migration process of these servers to php 5.5. Should be done around the end of 2015. With 14.04 php 5.5 we'll have support until 2019. So as you can see upgrading is not always just a simplistic process. We simply can't just upgrade a server and hope everything keeps working. It will require at least a rigorous testing procedure. 
Hi /u/ClutchHunter, You could talk to your employers about continuous integration. This requires a set of functional (i.e. browser) tests covering your application (and ideally some unit tests also, but they are less important to get you started). You can then run these tests over various versions of PHP in the same build. I'm using Travis these days, and every time I push from Git, my PHPUnit-based unit and browser tests spring into action remotely, and it does a build on 5.4, 5.5. and 5.6. If any fail I can check the reason why, and see if it is a build hiccup, or a genuine problem on a specific version of PHP. 
(Aside: Principal -&gt; Principle, twice). 
I've been in that situation (and failed to convince people that writing unit/functional tests from scratch, for a huge application, was worthwhile). Now that I know more about testing, I'd have handled it differently. Why not set up a functional test for each of the pages in your app _just to display_? That already is a better level of testing than none at all. All you do is make a request for the page (e.g. PHPUnit/Selenium) and check an item of text on the page (usually using a CSS selector). Maybe that would take you a couple of hours/days? You can then build on that. You'll then find that when you start developing on a new feature, one of your tests will break. This is a good thing - it means that either your test is wrong, or more likely, your new feature is wrong. This is the basic principle of testing - it gives you (increasing) confidence that you haven't broken something. 
How do projects decide which PHP ~~minor~~ patch version to support? For example password_compat requires 5.3.7, Wordpress requires 5.2.4, etc. Why the .7 or .4? Were there specific bugs fixed in those releases? And do you look at all those changes on your own projects, or just say "PHP 5.3" then add a point-version if some issues crop up?
I will chime in on a couple of things, since your question has been answered by other folks. 1. Several security releases have been folded in since this version of PHP. This is usually my go-to for getting a client/employer to upgrade, along with some guess as to what is the cost to upgrade. 2. If you're consulting or hop jobs frequently, you're going to find that a lot of employers have legacy code that require certain versions of software. It sucks, but commonplace, so this is something you're going to have to get used to. 
I'm considering a combination of Gitlab and PHPCI. Any glaring issues with that idea?
PHPUnit also fits in nicely for integration tests.
The minor version is 5.2, 5.3, 5.4. The patch version is 5.2.0, 5.2.1, etc. password_compat requires 5.3.7 because a security vulnerability in the bcrypt implementation was fixed in that version. Another consideration is what version is provided by common distros. Many distros will just keep shipping with the same patch version and backport a small fraction of security fixes from newer versions.
When is the best time to use traits? I tend to use them as a way to add attributes to a class (like the doctrine extras). Are there other places they work well?
It works out well in the end, especially when you have any more than trivial logic in your view (and logic that belongs there). I think escaping each field looks elegant and works really well. Plus, you get the added benefit of Twig caching the templates so they render very fast. I know it looks awkward at first, but if you consider your JSON no different than your XML no different than your HTML, I think it'll make a bit more sense.
This bundle of 3 books is pretty tempting https://leanpub.com/b/non-webphp
I guess this can mock global user functions as well, not only built-in functions, right? Because that's what I need to test a legacy project.
What you actually should do in those cases is wrap them into classes. E.g. I have a class that manages sockets for me and is a thin wrapper over PHP built-in socket function. Testing tthat class itself is a bit more tricky but basically you do it like this: class A { public function a() { $this-&gt;b(4); } protected function b($c) { return native_b($c); } } There's no need to test ::b() since it's just a proxy call. To test ::a() you get a mock of the class A, mock its ::b() method and run your tests against the mock. Voila $mock = $this-&gt;getMock('A', array('b')); // mock only ::b() $mock-&gt;expects($this-&gt;once())-&gt;method('b')-&gt;with(4)-&gt;will($this-&gt;returnValue('stuff')); $this-&gt;assertEquals('stuff', $mock-&gt;a());
Why do people abstract HTTP in PHP? Other than the superglobals (GET, POST, etc), what is needed? Thanks! Also, separate question. Why is this common: new App (new Request(), new Response()); I can understand Request (again, as a simple superglobal wrapper - as you can see, I might have an old school view on this), but not Response. How can the Response even be nearly created at this point? Or is it just creating the object to be used later in execution? Please link to code as well, if you can. Thanks!!
The simplest way to define objects - **Objects are initialized classes**. **Classes are blueprints for objects**. A good example would be of a car. Imagine building a car, the first thing you need to do is to create a blueprint for the car. The blueprint for a car contains the building blocks of how it is made. The object is the final product or the vehicle that you purchase. The object encompasses the blueprints and has it all wrapped up in one object. Now lets take a look at some code or a real world example. Creating a class to handle breadcrumbs in your web application. &lt;?php namespace Test\Core\Lib; class Breadcrumbs { private $_breadcrumbs = array(); public function __construct() { $this-&gt;_breadcrumbs[] = array( 'title' =&gt; 'Home', 'link' =&gt; '/' ); } public function add($title, $link = NULL) { if ($link !== NULL) $link = '/' . $link; $this-&gt;_breadcrumbs[] = array( 'title' =&gt; $title, 'link' =&gt; $link ); } public function getBreadcrumbs() { return $this-&gt;_breadcrumbs; } } This is a blueprint of the a simple Breadcrumbs class. It defines a private variable $_breadcrumbs, a default constructor that runs automatically when the class is initialized, and two public methods. In order to create the object I can do the following - $breadcrumbs = new \Test\Core\Lib\Breadcrumbs(); This initializes the class and allows us to use methods from the object. In this scenario the object would be breadcrumbs. It contains the methods add() and getBreadcrumbs(). These methods are characteristics of the class. We can add multiple breadcrumbs to the array by using - $breadcrumbs-&gt;add('Contact','/contact'); or grab the breadcrumbs and return them - $breadcrumbs-&gt;getBreadcrumbs(); //Return array of breadcrumbs from my object. In summary an object is an initialized class. Questions?
Response to your second question - This common approach of code (passing in the request and response object) allows for the use of middleware, where you can layer code to do a "thing" based on the request and possibly adjust the response. One middleware might read a cookie from a request, and decide a user is not logged in, and adjust the response to redirect a user to a login page, for example. With a middleware approach, you often have small bits of HTTP implementatd in each middleware, such as a authentication (cookie/session) middleware, a http cache middleware, a content negotiation middleware, all sorts of stuff. Essentially you get a request and build up a response as needed. Based on your questions, I think it would be beneficial for you to read the spec on HTTP - http://www.w3.org/Protocols/rfc2616/rfc2616.html - and definitely check out the concepts of Middlewares and perhaps the Decorator design pattern, which can be used in a similar fashion to adjust or add behavior/content and build up a response to a request.
I use them for when a class should share functionality, but shouldn't necessarily extend from a common parent, or if both classes already have a parent (PHP is single inheritance). For example, you have a set of methods that have functionality related to roles in a trait called "RoleTrait". You have a set of classes that extend Entity: User, Team, Group. Users and teams have the functionality of role modification but Groups don't. So users and teams "use RoleTrait". Of course this could also be solved with a different architecture, but the ability to choose between a very complex OO solution and a bit of composition via traits is powerful IMHO. Traits should be used sparingly though. They enable weak multiple inheritance, and multiple inheritance systems get complex fast.
&gt; Testing takes less time, not more. That is the whole point. For many reasons. But mostly because in a very very short amount of time (thousands if not more times faster than human testing) you can test hundreds, thousands, or more points of code to make sure things don't break. without testing, you can get to "90%" or what feels like 90% really really really fast. Then that last "10%" often takes longer to do than the first 90% did. with testing, you get to 99.9% not as fast as the 90, but really close. And you get to the 100% WAY faster than without testing.
The other thing here is that they're using Dependency Injection, making the whole thing more isolated and easier to test.
Found at least 2 books I had not already heard of, that address my current concerns. Thanks for this!
Why do we need a database? This seems to be a nice chance to ask a question I was thinking about. I wonder why our environments are so complicated. We have the Webserver, our application, our database server. Then we scale horizontally and have multiple versions of all of that. Why don't we have a database which is capable of being a platform for our applications or an application that has a database built in?
The suggestions about Immutable interfaces are largely based around theory, but so far I haven't seen an implementation that features Immutable request / response objects that actually works well in Web frameworks, in any language. Regardless, the post is weird, because the author refers to `IncomingRequestInterface` and `OutgoingRequestInterface`. 1. The reason there are two interfaces, is _because_ it allows for an Immutable incoming request, and a Mutable outgoing request. 2. The Immutable features are going to be removed in the next iteration of the spec (and so is `IncomingRequest/OutgoingRequest`), but the actual spec the author is referring to, still have Immutable interfaces. 3. Combining these two interfaces would not have been possible, as you need a mutable object, when you construct a HTTP response. The next iteration _will_ be fully mutable and have 1 `RequestInterface`. As an aside... A HTTP message needs to be able to represent streams. Working with in-memory strings is only really usable for simple cases, but if we're defining a 'better SAPI for PHP', we also need streams support. A stream can per definition not be immutable.
You may find this article useful in understanding the benefits of abstracting HTTP http://www.makegoodcode.com/2014/11/25/removing-http-from-web-apps/
so what helped in the end, if any?
I suppose you could, though I'm not sure how it would work if you're not using namespaces. Certainly worth a try.
I'm a fan of these packages as well as the league, and this seems like a good fit for them. It's cool to see that the route strategy stuff is more generalized now, symfony/http-foundation may be used directly as opposed to the orno/http dependency in the past, and the caching responsibility having been removed from the container. Just felt like sharing.
Thanks for the suggestion. I'm going to remove the Builder in favor of manual construction because it is not as handy as I initially thought.
Does anyone maintain aptana? :S
I think that you want to build a ORM. I would suggest that you read what an ORM system is, and use a ready made solution. It is much to complicated to make a good ORM system by yourself. Possible ORM systems I would advice: **doctrine** Zend Frameworks default ORM http://www.doctrine-project.org/ **Eloquent** Laravel's ORM, my personal favorite http://laravel.com/docs/4.2/eloquent
I have not tried yet. But for an unknown reason a HMVC package which is framework agnostic sounds a kind of weird for me. Don't figured yet why :) However, the current repo it's mostly like a test package. My target is making package which can be used by everyone, no matter what framework. Thanks! You question made me to rethink about it. I'm already working on a new version! One question. What package have you used for HMVC in codeigniter? Have you any thoughts about it?
Use Vagrant. This way you don't have to mangle packages/configs on your actual development machine, and it is far easier to experiment on.
Why do you need a mutable object when you construct a request? If you want to build it gradually you can use a Builder.
Then the PSR might as well be changed scope from defining a useful request/response object, to something that builds those objects. A large point of this proposal is to allow middleware/libraries to be built that can operate on common API's. What if I want to create a utility that adds amazon aws authentication headers to a HTTP request? I understand that a possible answer to that question is to either clone the original request information in a new request, or to decorate the request with something that returns an authorization header from all the relevant methods as well as its 'inner' headers, but that was not the design pattern that was chosen. The PSR reflects real-world usage. I would rather follow the examples that are out there, instead of an untested academic argument. This _is_ gonna work. It will not be perfect, and not everyone will praise its textbook design, but it will work well for most users.
&gt; Why do we need a database? For fast, long-term data storage and retention. &gt; I wonder why our environments are so complicated. We have the Webserver, our application, our database server. Sounds like a very basic environment to me. &gt; Why don't we have a database which is capable of being a platform for our applications or an application that has a database built in? Do you mean something like Microsoft Access? Or applications which use internal storage engines like XML files or sqlite? In either case, they're incredibly slow (relatively speaking), difficult to customize, and nearly impossible to scale. You'd really want to use a specialized database engine for anything that's going to be used by multiple users.
I don't have experience with MS Access and not really with SQLite. Do you need to load SQLite databases from disk for each request? I thought about a server that can run PHP code or something like that. The environment isn't very complicated. But there are always those different units to configure. I would like more "decoupled" packages for PHP. I dream to just run one command and have a new application instance up and running. Or copy a folder and have a complete development version of a CMS installation... Simply some way to get rid of the copy all stuff, database export, import, make changes for dev environment. 
Of course one could achieve a lot with puppet and co, but to me this seems more like a workaround than a solution for the main problem. 
I go as far as I need to. If my bad habits come in I am glad that tests show me I did something wrong. I even went as far to create myself a symfony bundle that takes care of setting up an environment with fixtures before I run automated tests. Behavior tests, functional tests or unit tests. I can run them whenever I need without trouble if I might broke my data.
I like to perform static analysis of code, but when there's that much magic going on, it makes it too difficult. I tried a bit of debugging with xdebug but in the end it was all too much.
We're actually in the process of rewriting large chunks of the code, and making the switch to PDO. A lot of the code is totally crap, as you've mentioned, but we're working on it :)
You can declare multiple namespaces in the same file. 
http://www.opensourcecms.com/ provide test installs of the cms. They reset the demos every 30 minutes or something
I appreciate all your comments. I agree with many of them. After watching a video recently on /r/php with Rasmus talking about speed being critical, I recall he worked at Yahoo and said if you cannot return a result in 100ms then you need to fix what ever you were doing. They really echoed with me as a benchmark baseline for app performance and it made me want to build an app that was fast (not a discussion about architecture so much). Thanks heaps for that link, but I think to my point, all those posts are over a year old. So I could quickly argue that Phalcon hasn't taken off. 
Well, to be fair, he is. :)
That's a very open ended question, but rather than cheat and say "it depends", I'd say, Building Secure PHP Apps, something we should all learn all we can about.
I used orno/di along with league/events in a lot of my small console projects and one-off applications, so internally this is a really logical fit. But damn, the League is becoming a powerhouse organization.
Try using `-k`. Some apache set ups don't show you the real performance if you don't use `-k` http://serverfault.com/questions/254765/apache-benchmark-keep-alive
Just for the record, I'm not saying that performance isn't important, [it absolutely is](https://blog.kissmetrics.com/wp-content/uploads/2011/04/loading-time-lrg.jpg). I'm saying that there are lots of factors which warrant optimisation before code execution time ever becomes relevant. ([Though, you're probably better off optimising the front-end first](https://developer.yahoo.com/performance/rules.html)). &gt; it made me want to build an app that was fast (not a discussion about architecture so much). Having a solid architecture is how you are going to achieve performance. It's in how your application is written that the bottlenecks lie, and not so much on what it runs on. If you put proper care and attention into forming your architecture, it'll benefit you more than phalcon ever could.
The testing phase is done, everything works the way it should. The problem is I probably won't get access to this third-parties MySQL server, to add this login table, for this site I added onto their file server (which I do have access too). So, I didn't know if anyone had any helpful advice for me.
local
Well you're going to need them to add the table for you or have them give you access.
You have access to the ftp server? Then that means that you have access to their config files. Find the db config file and get the mysql credentials.
Locally 
Duh. Thank you, I'm an idiot. 
Also take into account: I'm reading from the post that he's the junior person there, and not going to be accepted as the one pushing this sort of thing.
PHP framework Yii 2.0.2 released. This version is a patch release which contains about 40 minor new features and bug fixes.
you could put your code on github and demonstrate you understand basic concepts like good naming conventions and folder structure, that you can maintain your projects. you don't need to be an inventor of great software, just able to fit in and do the job.
If you're at the point where you have to worry about the speed of the executing code, you should probably move away from scripting languages to one of the compiled ones. As others have pointed out here, code execution speed should be way down your optimization priority list (unless the code written is particularly bad). 
Unfortunately, after teaching yourself programming for a month, you'll have a pretty slim chance of impressing anyone, unless you are some kind of savant. But, to answer your question. I would either: * Build a small, well written library. Maybe around an interest or hobby. I would be more impressed by a rhythmic gymnastics scoring library than by yet another validation library. * Build a small but nice looking web app on something like Symfony or Laravel. While it won't exactly show off your coding skills, it shows that you can read documentation and be somewhat productive in a team. When I'm looking at candidates, people who spent a lot of time learning stuff on their own without the guidance of a framework are hard to judge. It's less risky to pick someone who might know less of the language, but are familiar with one or more of the common frameworks.
You could check [https://github.com/samayo/fastcrud](fastcrud) it is very simple, and does basic crud. 
not really related to your question, but are you hashing your users' passwords?
Unfortunately, if it requires an extension, it's almost certainly useless to me.
Hi, thanks for your feedback. I'm using Laravel's built-in mail-sending library actually. But problem remains even if I use phpmailer or simplesmtp: sending email increase the server response time dramastically. That's why I want to put the tasks into queue in the future, and results in the above code.
Ha. Yeah that response is the first I was expecting. The second is some muppet linking to https://philsturgeon.uk/php/2014/10/20/php-wars-attack-of-the-clones/ and laughing that "we're making another router," which of course "we" are not. Too much dumb for me to handle. Luckily this is nothing to do with me.
This is a more useful link to this same "event." https://groups.google.com/forum/#!topic/thephpleague/xmyyUE-oLak
Just no
Why? VPS are as cheap as shared hosting these days.
Can you repreduce the segfault and submit an issue on github ?
Thank you for your reply. I'll split them up in these two I think. Tests are usually omitted where I work but it feels really stupid when you got a lot of db-queries. They (sql-queries) are not even validated (got the correct table name? etc) so it will probably be a lot of problems without integration tests. In my case thought, wouldn't I need the "correct" `wpdb`-class to not fail the tests? When I run integration tests (have to say it will be my first time) the $wpdb object needs to function properly, doesn't it? How does it work? Thanks again!
I will mock it all then, and then run integration tests to really validate the queries. 
The the database hitting time might be very important and you should remove that to compare the frameworks. The absolute difference will not change but the relative one will. 
wow. Now that is what I wanted to see, so it really looks like I am not get the same speed on my server. Is the the Invo application? I gotta look at something if this is the case!
Another tack would be to contribute to open-source projects that have open issues. The projects benefit, and the projects and contributions make for good portfolio pieces.
I have a repository on which I've rejected a majority of PR's. Most of them are along the lines of "change application behaviour" and, believe it or not, the way it behaves now is actually how it's meant to. Things like "change return value on failure from -1 to 0", on a documented API that was going to break people's code. No explanation other than "here's a PR". And really nonsensical things like "here's a patch that makes it only work on Windows", when my readme says I never even tested Windows. Github has improved the Open Source culture greatly but simplified it along the way until people no are no longer encouraged to ask "does this actually make sense for mainline?" 
Wrong sub, post it to /r/getemployed
&gt; No explanation other than "here's a PR". And really nonsensical things like "here's a patch that makes it only work on Windows", when my readme says I never even tested Windows. If you ever close a PR because it seems pointless or the description is VAGUE (Void of All Good and Useful Explanation), link them to https://quickleft.com/blog/pull-request-templates-make-code-review-easier/ It's a great little template that someone can use that makes it much easier to give better PRs.
Is this a joke?
It's possible, sure. But I have a hard time imagining what kind of project someone with a month of programming experience could make a meaningful (enough to work in a portfolio) contribution to. One month of PHP experience, sure. But one month of total programming experience?
In addition to the other answers try to collaborate to existing projects. Technical stuff shouldn't be a blocker, every project needs better documentation, more tests, typos fixed,  Showing that you can collaborate with other people is good.
Thanks :)
I have used the uopz extension in my tests for a while, but now have successfully worked around those cases and don't use it anymore. The drawbacks are: * You can't run your tests on HHVM * The restoring can REALLY screw you up at times, its just much easier to wrap stuf into classes and use mocks of those
Thank you all. I don't expect to be able to find a job a month in, maybe by 6. I was more looking ahead for when I was ready and what type of projects potential employees look to see. As for the frameworks, I will dive into those when I get more knowledge of core php and programming. Btw, thoughts on WordPress? Seems like a lot of employers prefer knowledge in it. Thanks again. More comments welcome. 
If you're inclined to organize everything first, you could go with something along these lines: $interactions = array(); foreach ($all as $row) { if (!isset($interactions[$row['EmailAddress']])) { $interactions[$row['EmailAddress']] = array( 'TransactionDate' =&gt; $row['TransactionDate'], 'EmailAddress' =&gt; $row['EmailAddress'], ); } $interactions[$row['EmailAddress']]['Products'][] = array( 'Name' =&gt; $row['Name'], 'ProductID' =&gt; $row['ProductID'], ); } Then you loop over $interactions accordingly, with a nested foreach.
Depending on the function they can be shorter and cleaner. For basic stuff like links I wouldn't bother but for larger elements it's useful. You can pass an array into a list/table/select function instead of having to write the foreach loop yourself.
Primarily, it's used to enforce consistency and allow for common output filtering. For instance, if you have a schema where URIs correspond directly with their controllers and methods, eg: */user/$id/profile* You could do something to the effect of: $profileLink = html::anchor([ 'text' =&gt; 'Profile', 'uri' =&gt; '/', 'class' =&gt; 'profile_link', 'controller' =&gt; [ 'name' =&gt; 'user', 'method' =&gt; 'profile', 'id' =&gt; $userID ] ]); echo $profileLink; Result: *&lt;a href="/user/profile/1" class="profile_link"&gt;Profile&lt;/a&gt;* Or even: $profileLink = html::anchor('Profile', 'user', 'profile', $userID); echo $profileLink; Result: *&lt;a href="/user/profile/1"&gt;Profile&lt;/a&gt;* I personally prefer templates over passing HTML around, especially if its done client-side. 
The main advantage is that your application become hard-coupled the a specific framework. Gives awesome job security. It's especially important for the worst PHP frameworks, like Yii and CakePHP.
&gt; The restoring can REALLY screw you up at times What exactly is the problem? Just curious.
I haven't written the code for it yet, because it isn't live. That's just via PHP right? Whether I get it in a MySQL table or end up using an array?
I'm trying Netbeans now since it seems to have a similar layout to phpStorm in terms of XDebug. If I don't like it I'll downgrade even though I don't like that idea.
What's wrong with CakePHP ? 
So, I found the mysql credentials, but have no idea where to use them. I tried going to the host, but that doesn't load. It looks like they have a local server, development server, and then a production server.
One advantage of abstracting out the HTML rendering is to handle formatting quirks between the different HTML doctypes. For a good majority of websites, this probably won't be that big of a deal - how often does a website actually change doctypes? - but for CMS apps, this might be a pretty useful feature, but then again, it might not. The biggest downside to this approach is it makes reading the HTML that much more difficult. What I mean by that is that anybody who needs to modify the HTML will need to have a fundamental understanding of how the framework you're using generates its HTML. For us programmers, that can be a non-issue, but if you want your designers to work on the HTML, then either they have to learn to program, and/or they generate straight HTML and you massage it into your abstracted format. YMMV, but for me I try to stay away from that sort of thing as much as I reasonably can, and instead I break out my HTML into reasonable views that can be mixed-and-matched in various layouts.
Absolutely.
&gt; I personally prefer templates over passing HTML around, especially if its done client-side. Ditto. The generation stuff feels all mature and big-pants when you start using it, but it gets really tedious. You find yourself looking at the code inspector in the browser to figure out what really got generated and you are debugging in two places at once. I find it a lot simpler to use something like Twig.
I did this and found it to work very well. In particular I find using the Validator component to really help with constructing error messages when a PUT or POST of data isn't well formed. It all sort of grew out of that need.
http://api.cakephp.org/2.1/class-HtmlHelper.html#_link It seems to do a fair amount. It will parse and make a routed URL for you automatically, has options to escape the html and to create a javascript "confirm" popup. Whether you actually want all these or not is a different story, but it's offering more than 'just making an a tag'.
Not sure what you mean by "going to the host"... Are you using phpMyAdmin or something? You might need to create a migration file. 
ah, sorry! i've totally misunderstood what your problem was. apparently, when i was bargaining with god before i was born i traded reading comprehension of math skills and good hair. although it's not technically a queue for delayed execution, one potential solution may be to fork() your script and do your emailing in the child process. note, however, that this will only really work if you are running your script on some sort of unix-style system (linux or whatnot). if you're not familiar with forking, the theory is that your script can spawn a copy of itself into a completely different 'child' process. after calling fork your script splits into two different processes (it's called 'forking' because it's like the execution of your script comes a fork in the road, with two different paths to follow). the original process is called the 'parent' process and the new one is the 'child' process. you can write code that runs in the parent process to return data to your end user so they don't have to wait for the email call to finish. in the child process you can do your email magic, safe in the knowledge that the user isn't waiting. the command to use for this is called [pcntl_fork](http://php.net/manual/en/function.pcntl-fork.php). pcntl_fork() causes the fork to happen and retuns an integer, which is the 'id' of the process (called the 'pid', for 'process id'). a -1 pid means the fork didn't work, a 0 pid means that the code you're executing is the parent process, and any whole positive integer pid that's not zero is the child pid. you can then use if() blocks to seperate out which code to run in the child and which code to run in the parent. here's a quick example i cooked up to illustrate the example. the child just writes to file after a short sleep to simulate your email code that takes a long time. &lt;?php // this variable is here to prove that variables set outside of the // child process' 'if' block can be accessed $outsideVariable = "i'm from outside"; // fork starts a copy of this script $pid = pcntl_fork(); // if the return from pcntl_fork() is -1, things have gone awry if($pid == -1){ die("could not spawn child process. do some error handling"; } // this is the code that gets executed in the original 'parent' // process. you do html output here so the user doesn't have to // wait for the email to be set. else if($pid == 0){ print "return to user and stop execution"; return true; } // this is the child process, the copy of the process that is // spawned seperately. you can do email or other time intensive // stuff here. else { sleep(10); // simluating execution lag // let's write to file to confirm the child process is doing // stuff. we use $outsideVariable to show that this process // can access stuff from the scope of the parent. $fp = fopen("/tmp/foo","a"); fwrite($fp, "chil pid $pid $outsideVariable \n"); } ?&gt; some notes: * this probably won't work on windows. i'm not 100% sure of the statement, though. * i know jack about laravel, so this may prove to be incompatible with your framework * forking on unix-y systems is speedy and efficient but is still heavier on your host than just running a single process with a blocking call. if you are running near the top of your hosts cpu or ram, this may cause problems * this is not a queue, but it can potentially address the core issue you mention, which is delayed reponse time to the end user because of waiting for the email process to finish. **edit**: multiple edits to try to get reddit's markdown to play nice with [automatic syntax colouring](https://support.codebasehq.com/articles/tips-tricks/syntax-highlighting-in-markdown)... but apparently reddit doesn't support it. 
It depends on a number of factors, not just the language. Only a tiny bit if that speed is actually Phalcon. I would say that efficient programming and infrastructure have more of an impact than phalcon will. What type of application are you running as a test?
Its been asked before.
I would add a set of options to control wether or not it's currently possible to upload files and other "dangerous" features. And my demo mode would have all these options set to off. Out of curiosity, is your CMS open already ? *Edit: Accidentally a word*
Keep learning, keep trying. It'll happen eventually. Build up your network - i.e., Meetup.com, join open-source projects on github, etc - and keep your eyes and ears peeled. 
Ahhh ok, looks like an external db. You probably can't access it via phpMyAdmin easily. 2 choices: 1) Ask for access to their db (imo, what you should've done from the beginning). 2) Write a migration file. That is, write a .php script to create the tables, upload it, and then run it. Hackish but works.
&gt; 1) Ask for access to their db (imo, what you should've done from the beginning). I have. One reason I was brought in to replace them is because they are absolutely terrible at communication. Sometimes it takes a week or more for them to respond to emails, and I'm getting hounded for this. I actually learned how to create databases and tables and such via phpmyadmin, which was a victory for me personally, but less so when I realized it was literally a waste since I can't use it. I'm looking at some web pages talking about writing a migration file, and it seems pretty complicated and outside my current skill range... :/ 
So does your company know that you're trying to steal software on their behalf?
yeah, on the code side, before whatever storage you stick it in. sorry if you'd already thought of that piece :)
You make a valid point. So long as the HTML library allows DI for the localization library, then that is a reasonable solution. 
Don't forget the escaping of the supplied content. If your URL or the displayed text contains user input, you must escape it to not allow cross-site scripting attacks. The framework should do that for you. Otherwise you have to use htmlentities() a lot...
Depends on what you want to do. My work uses Symfony 2.
Seconded. Get started with laracasts and dive straight into Laravel. Then explore the official documentation, which should shed light on how everything works. That, or you could explore Symfony too. 
Thank you - have some gold - that works perfectly on my local machine - which is running version 5.5.12 But - the server I need this to work on is running 5.3.3 &amp; this gives me no output &amp; no errors. Any ideas?
Well in that case you need to try Sphinx or some other dedicated text search engine to do that. You really can't speed up LIKE statements. If you really don't want to go with a dedicated engine I guess you could optimize it this way: Create an additional table with pieces (id, text) and pieces_part_numbers table which is a many to many relationship between pieces and part_numbers. Every time you add a new part_number to the database add searchable fragments to pieces, eg.: part_number: 74005302, pieces: 740, 400, 005, 053, 530, 302, 7400 .... this way when someone searches for piece 740 you just make a simple join to get all part_numbers that are linked to that piece This is only feasible if your searches have a minimum length of at least 3. Because if you can search for like '7' the pieces table will quickly be huuuuge That probably the only option yo u have if you don't want to go with sphynx or the like
Aside from the coverage, what differentiates this from other common ORMs? Such as Doctrine, Eloquent, Paris, Yii, Redbean, the list goes on...
I can't comment on the GC functions, but from experience, that value will be rendered useless. Since the function is "return"ing a value, and there is nothing to capture it, it's just a waste of resources. My 2 cents.
I cant really fault your logic. In real world terms I think a 10% gain is pretty good. But I dont really want to spend weeks/months learning the intricacies of a new framework. I have to way the cost of that lost productivity with the smallish gains. At the moment my plan is. 1. Build 2 apps on the server one in Phalcon and one with Silex. 2. Test the speed and weigh up the pros can cons. 3. If Phalcon is 2-3x quicker I think I would start using it. My other options is to run HHVM and see how that performs or start looking at some PHP7 betas and see how well this is working. Right now I dont actually have a problem. But it might be time to look at some new PHP solutions and one of my criteria is that is should be super fast as the code base increases. 
See http://php.net/passthru
I'd imagine the refCounter to the value is never incremented. Very much in the same way as having an unsigned literal in your code. &lt;?php 'hello World'; 
IIRC passthru has a return status argument: $status = 0; passthru("./check", $status); if ($status !== 0) { echo "Failed"; } if it's just the onscreen output you care about you could always just do something like: passthru(".check &amp;&amp; echo 'OK' || echo 'Nope'"); or I think this would work (backticks will do a similar thing to passthru): if (`./check` === 0) { echo 'OK'; } else { echo 'Nope'; } 
Conversely, OP has the opportunity to help set the standard for the company. Write the guidelines and best practices, create the well-tested internal libraries, etc. The sole issue of technical debt doesn't necessarily make the place unprofessional. ;-)
Thanks for the gold! Its the short array syntax which was only added in 5.4.0. $query = array( array('TransactionDate'=&gt;'31/12/2014 14:17', 'ExternalId'=&gt;'PRODUCT1', 'Name'=&gt;'Lawn Darts', 'EmailAddress'=&gt;'rshackleford@gmail.com'), array('TransactionDate'=&gt;'31/12/2014 14:17', 'ExternalId'=&gt;'PRODUCT2', 'Name'=&gt;'Disguises', 'EmailAddress'=&gt;'rshackleford@gmail.com'), array('TransactionDate'=&gt;'31/12/2014 13:17', 'ExternalId'=&gt;'PRODUCT3', 'Name'=&gt;'Kinder Egg', 'EmailAddress'=&gt;'bhill@ymail.com'), array('TransactionDate'=&gt;'31/12/2014 13:17', 'ExternalId'=&gt;'PRODUCT4', 'Name'=&gt;'Propane', 'EmailAddress'=&gt;'hhill@excite.com'), array('TransactionDate'=&gt;'31/12/2014 14:17', 'ExternalId'=&gt;'PRODUCT4', 'Name'=&gt;'Propane', 'EmailAddress'=&gt;'hhill@excite.com'), array('TransactionDate'=&gt;'31/12/2014 14:17', 'ExternalId'=&gt;'PRODUCT5', 'Name'=&gt;'Fuel Filters', 'EmailAddress'=&gt;'hhill@excite.com'), ); $map = array(); array_walk($query, function($value) use(&amp;$map){ $ID = "{$value['EmailAddress']}-{$value['TransactionDate']}"; $map[$ID]['TransactionDate'] = $value['TransactionDate']; $map[$ID]['EmailAddress'] = $value['EmailAddress']; $map[$ID]['Products'][] = array( 'Name'=&gt;$value['Name'], 'ExternalId'=&gt;$value['ExternalId'] ); }); $dom = new SimpleXMLElement('&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Interactions&gt;&lt;/Interactions&gt;'); foreach($map as $ID =&gt; $row){ $int = $dom-&gt;addChild('Interation'); $int-&gt;addChild('TransactionDate', $row['TransactionDate']); $int-&gt;addChild('EmailAddress', $row['EmailAddress']); $products = $int-&gt;addChild('Products'); foreach($row['Products'] as $product){ $p = $products-&gt;addChild('Product'); $p-&gt;addChild('Name', $product['Name']); $p-&gt;addChild('ExternalId', $product['ExternalId']); } } echo $dom-&gt;asXML(); Tested in 5.3.29.
yes
It varies depending on your framework, or templating engine, or whatever. There are a number of reasons mentioned here, all right, but the main and most common one is (arguably) being able to extend whatever method you used to change it everywhere. Let's say you use a method anchor('my/route') instead of &lt;a href="/my/route"&gt;. What happens if you want to move your site to a subdirectory? You'll need to update every single link in your site... Or just extend/change the method. Or maybe you want to force SSL (yes, yes you can do this several other ways), you can just extend the method, simples! Lots of other reasons too, but the one above is the most used instance in my experience.
vendor/ can have your own library as well. If you're adopting micro-services, you will likely to see your own library inside there. Personally, I will not modify other vendor's code, but I will modify my library. Composer allows you to check for local changes with composer status. You can also override a 3rd party package with your own. It's a bit tricky to do, but you can tell composer to fetch your source instead of the 3rd party source. I dont recommend this, unless your changes are valid and that you're anticipating the owner to accept your pull request.
A full-text index on part_number combined with something like: SELECT part_number, MATCH (part_number) AGAINST ('{$query}' IN BOOLEAN MODE) AS score FROM parts WHERE MATCH (part_number) AGAINST ('{$query}' IN BOOLEAN MODE) ORDER BY score DESC Should be good for many, many millions of rows, though if you have a decent search volume it would be prudent to cache the results as well, or even pre-compute them.
@mwop (the spec author) has done some work on an immutable version, which makes me happy: https://groups.google.com/forum/m/#!msg/php-fig/9gK8vX8iYZ8/5PZ9rx8UvXYJ
Okay, but how did it affect memory usage?
I'm not disagreeing with you, but you're complaining about the pattern. The problem with Eloquent is that it's an active record pattern...
Ugh... don't even get me started! I absolutely *hate* when markup is generated by code... it always results in markup that is a "snapshot of best practices at the time the framework was written" (at best). The front-end is changing SO fast now (way faster than back-end technologies) that you always end up with frustrating workarounds to get things looking exactly the way you want. But I'm a big fan of front-end development and design, so I can kinda understand how back-end programmers who hate HTML/CSS want to abstract it away and not have to keep writing it over and over again. I think this issue is a big "cultural difference" between various systems, and it's something that people talk over each other about. The back-end guys don't "get it" that having custom markup is critical for good design. And the front-end guys don't "get it" that rewriting the same damn markup every time chafes as the soul of "DRY"-ness and good engineering practices. I recently discovered this "form helper" library that is my new favorite: https://github.com/4d47/php-form-helper -- it does NOT generate any markup for you... instead it just helps manage the annoying "does this data exist or does it come from the database or from $_POST?" and "give me my error messages" problems. But all the markup is up to you. It is so liberating! 
Which... honestly... is fine for a hell of a lot of usecases.
Not true actually. It's much more than plain ActiveRecord. Quote: &gt; The active record pattern is an approach to accessing data in a database. A database table or view is wrapped into a class. Thus, an object instance is tied to a single row in the table. After creation of an object, a new row is added to the table upon save. Any object loaded gets its information from the database. When an object is updated the corresponding row in the table is also updated. The wrapper class implements accessor methods or properties for each column in the table or view. The pattern has nothing to do with actual querying. Actually having queries separate from Entities turns Entities into pure ActiveRecord patterns 
Yes, eBay owns Magento, but eBay itself is a Java/C# app as far as I know. Look at their job postings for evidence. Facebook is a tough example because although their code is written in the PHP language, they don't use the PHP engine at all. Of course you can (maybe) run your project in HHVM like they do, but then you're talking about HHVM, not PHP. Wikipedia now uses HHVM also.
Not entirely what you asked for but: For me an API should be quite lightweight so if you intend to use Symfony, I would try to make it as small as possible. This post is a good example of how light you can go with Symfony [whitewashing!](http://www.whitewashing.de/2014/10/26/symfony_all_the_things_web.html). The only missing part for me in this project would be **Sensio\Bundle\FrameworkExtraBundle\Configuration** (Route / Method / ParamConverter) Therefor if you only want to build an API and nothing else I would create my **own** with Silex, I know you don't want to hear a about it :D, but maybe you/your team should consider it. I don't think you need bundles or libraries to build an API, ultimately what you (I) want for a basic API is: - Handling security - Handling route - Handling validation If somehow you start to build more than an API, it's really easy to port your code to Symfony later on. Anyhow I hope you find the best solution for your needs ;)
All I see when hipster devs talk shit on PHP is dollar signs, (the bank kind, not the variable kind). PHP is everywhere in the real world and usage is increasing not decreasing. I love Python, C# is expressive, the node echo system is impressive and cool but I make my money with PHP.
This is a new submission, because it's a significant revision with a new approach. This way, I get to have strict type-checking, *including for extension and built-in PHP functions*. But all the people who don't want it don't have to use it, so hopefully they won't be pissed off by it (well, that's the plan anyway). And it doesn't break backwards-compatibility. It's not a perfect solution, but it avoids most of the problems of just adding strict hints, and most of the problems of just adding weak hints, yet I get to have strict typing. :)
You do know that HHVM is a virtual machine that executes PHP code right? It isn't a language, it is a JIT compiler. [hhvm](http://hhvm.com/)
No, because we don't do that for extension/built-in PHP functions. Honestly, perhaps they should, but I really don't want inconsistency there.
Yeah ... the "only" thing in common between HHVM PHP and Zend PHP is the language. Which is like the most important point. To rephrase your point with correct emphasis: The only difference between HHVM PHP and Zend PHP is the performance profile. There's little difference from the security perspective as the vast majority of "PHP vulnerabilities" are in application code. And those that aren't are, usually either in shared library code (libmagic) or non-exploitable in any practical sense of the word.
My point is that it is unfair to point to Facebook or Wikipedia and say "PHP has intrinsically great performance and security" when those sites use a JIT virtual machine that doesn't guarantee 100% compatibility across all usages of PHP and when their security issues are predominantly within the applications themselves, which would be true regardless of the language used. I work for Wayfair.com, we are a PHP shop, we don't use HHVM, we have had a lot of success with it, and I am not bashing PHP at all. I simply wanted to point out that it is fallacious to make claims about PHP itself on the basis of sites using HHVM.
We're talking about the *language* not the runtime. Why does the runtime only seem to matter when it comes to PHP? Nobody is sitting there complaining that you're "not really using the ruby engine" because you used JRuby instead of MRI, or you're "not really using the .NET engine" because you're using Mono. Also: First job that came up for "PHP" on [ebays job site](http://jobs.ebaycareers.com/tr/turkey/engineering/jobid6481119-software-engineer-ebay-jobs?ss=paid&amp;&amp;+utm_source=JobSearchWidget&amp;utm_medium=CareerSite&amp;utm_campaign=TBWidgets)  yes, Java too, nothing wrong with that. Just like this says: right tool for the job.
I think this is a compromise in the right direction :) Thanks. The declare syntax reads a little poorly (declare(strict) would be enough for my taste, not sure if that's even possible...), but a minor issue. Out of curiosity, why the change of heart? Your new RFC suggests that you now prefer the idea of strict hinting, though previous posts by you *implied* you did not. Not that I'm complaining, I think this is a great step forward..hope the vote comes down favourably.
&gt; I think this is a compromise in the right direction :) Thanks. The declare syntax reads a little poorly (declare(strict) would be enough for my taste, not sure if that's even possible...), but a minor issue. Yeah, it's a bit long. The Open Issues section mentions it for that reason. If in the end it doesn't become shorter, I don't think it'll be *that* bad. It's only as long as most function calls, and IDEs might do it for you. &gt; Out of curiosity, why the change of heart? Your new RFC suggests that you now prefer the idea of strict hinting, though previous posts by you implied you did not. Hmm, my position is rather nuanced, really. Ultimately, I'd be happy with scalar type hints in PHP, weak, strict or otherwise, so long as we finally get them. I don't like having to use a docblock or comments or something to specify a parameter's type. But I think both behaviours have their issues. I'm not a huge fan of PHP's weak parameter typing behaviour and I'd prefer if it was stricter. But the stricter you make it, the more you break things. The previous Scalar Type Hinting with Casts and Safe Casting Functions RFCs (the former contributed to by me, the latter authored by me) show the problems with that. It's so unclear whether, for example, 12.5 should be accepted for an int, should whitespace be allowed, how do you define a boolean, etc. Strict typing mostly works and it's great for error-checking, but there are a few areas it would cause problems. In particular, all PHP's operators are weakly-typed ($a / $b is variously an integer, float or boolean). That's a feature I actually like: I think PHP is one of the few languages that defines the division operator sensibly, along with Python 3. Similarly, virtually all built-in/extension functions have multiple return types, though I'm not sure how much I like that. I don't like the idea of people using explicit casts like `(int)` to avoid type hint errors, because explicit casts can't fail and will convert virtually anything to the type you ask for, whether it makes sense or not. Implicit casts are somewhat better in that they fail if the conversion doesn't make sense, most of the time. But blindly passing something from one function to another and relying on implicit conversion doesn't really feel right. If I was to make a new language today and it had optional type hints, it'd probably have strict ones. In PHP, I'm not sure. I'm leaning towards strict hints, but they have some problems. &gt; Not that I'm complaining, I think this is a great step forward..hope the vote comes down favourably. Yeah, I'm not sure how this'll go.
Ha yeah that makes sense :)
&gt; I think PHP is one of the few languages that defines the division operator sensibly You clearly haven't divided by zero recently. :p
Posting to get the opinion of other people on this: I'm not a huge fan of coupling Symfony and developer's applications to Twig just to save a few ms (really, how many?) by including 50 less files Of course I can understand the reasons, but I don't think it's the best option to make the extreme performance requirements more important than decoupling **as the default for everyone**. Project with specific needs (where 50 files included matter) should resort to optimized/less abstracted solutions.
Well, aside from that *specific* case. That should produce `INF` (RFCs welcome)! I mean its handling of fractions. There are three different mainstream approaches: * Make division have the type of its arguments, so if both arguments are integers, do a floor/integer division, if both are floats, do a float division, if they differ do something ridiculous. I hate this. `(double)a / b` looks horrible. More importantly, you need to know the types to understand the behaviour. This is a very common approach. :( * Have a float-division operator and an integer-division operator. Pascal and Visual Basic do this. A reasonable approach for statically-typed languages, Visual Basic and Pascal do this. * If it won't divide without a remainder, do a float division. Otherwise, do an integer division. PHP and Python 3 do this, I think it's the most intuitive: `3 / 2` should be `2.5` :)
My point also suffers from the fact that few people who want to build a dynamic website as quickly as possible will want to try to stand up HHVM; it's complicated and not broadly supported across available web hosts, which means you're struggling with configuration and monitoring on your own. So yes, the comic itself is very true, and you are right about Wikipedia implementing HHVM recently. That said, HHVM has 97% compatibility across their currently tested open source projects, which means that 3% of code run in it behaves differently or doesn't run at all. If 3% of open source code doesn't run correctly in HHVM, that means, to me, that there are opportunities for security vulnerabilities to exist in HHVM that do not exist in the Zend engine as well. My point is simply that using HHVM as a basis for comparison of PHP to other languages is sometimes unfair.
Oh, I realise, but I couldn't resist talking about that specific issue. :p
I think your work is excellent, @dracony. Keep it up.
I like this. I've whined in the past about **insisting** on strict type hinting only. But I've realised from this RFC that it's not actually the weak type checking I've had a problem with. It's the casting. This does the things I want without doing to things I don't. I think it's a compromise in the right sense - everyone wins. Rather than the sense it's often used, where everyone loses. Good work!
Well, this still casts in the weak mode. "Type checking" is probably a poor name for it for it given the weak mode still converts. But yes, this means you get strict types if you want them, and people who don't want them don't have to use them. :)
Yeah, there are a bunch of things that might be worth adding at some point, here are a few I've heard: * `object` - an object * `number` (`num`? `numeric`?) - int or float * `scalar` - anything that's not an object, array or resource * `void` - a return type only, ensures no value is returned I don't think these should go into this RFC, but it'd be worth future consideration. We've added extra type hints like these before: `array` (5.1) and `callable` (5.4), as the RFC mentions.
i would much rather it be the other way around.... But, step in the right direction.
 declare(strict_typehints=TRUE); Fuck. Yes.
i'd like to see how difficult/easy it would be to not use twig, with this setup.
any chance to not to make declare(strict_typehints=TRUE); per file. Would like to have that thing declared on the autoload file so that other files can benifit from that. hate to add that to every file. (+1) to the rfc though!!
But...this is the SECOND patch release. 
Oh look, [a wild rigorous PHP language spec appears](https://github.com/php/php-langspec) :) We've had this for 6 months, and it is now part of the standard process to keep it up to date with new feature additions. It was written by a guy who actually [knows what he's doing](http://www.rexjaeschke.com/standards.html) thanks to Facebook.
TIL [imgur is powered by PHP](http://imgur.com/blog/2013/06/04/tech-tuesday-our-technology-stack/). The people who whine about PHP come across to me as misinformed. PHP 5.6 + Composer pushed PHP into the future, along with HHVM and the upcoming PHP 7 release. I just assume that these people aren't aware of the changes being made.
&gt; bakuretsu &lt;-- Some colleges do offer cs courses fo free.. do those.. seems to me that you dont have a formal cs education.
Academically, PHP is a *crap* language. But it is an enabling language. It scales better than any other language... but I don't mean technically, it scales for wet-ware. Beginners can get into it more easily than any other language, and experienced developers can use it to handle even the most demanding tasks (though some things it is unsuited for).
I found this because I just want to simply cache a cURL script. If you took a look at any examples in there, could you tell me how to cache this code I found which is for seeing where a URL redirects to: $url="http://libero-news.it.feedsportal.com/c/34068/f/618095/s/2e34796f/l/0L0Sliberoquotidiano0Bit0Cnews0C12735670CI0Esaggi0Eper0Ele0Eriforme0Ecostituzionali0EChiaccherano0Ee0Eascoltano0Bhtml/story01.htm"; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, true); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); // Must be set to true so that PHP follows any "Location:" header curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $a = curl_exec($ch); // $a will contain all headers $url = curl_getinfo($ch, CURLINFO_EFFECTIVE_URL); // This is what you need, it will return you the last effective URL // Uncomment to see all headers /* echo "&lt;pre&gt;"; print_r($a);echo"&lt;br&gt;"; echo "&lt;/pre&gt;"; */ echo $url; The examples given for this plugin are a little short I guess, and I didn't know how I could apply the caching method to this script. 
The behavior of a class file shouldn't vary depending on how it was included. I think it makes sense for it to be file-specific.
&gt; any chance to not to make declare(strict_typehints=TRUE); per file. Would like to have that thing declared on the autoload file so that other files can benifit from that. &gt; hate to add that to every file. That wouldn't really work due to how it's implemented, it's completely compile-time and can't work with includes. If it was done at runtime, then you might have problems where files infect other files unintentionally. Having it be in every file means you should be able to tell, at a glance, which mode is in use, which is probably a good thing. Code's behaviour really shouldn't completely change because of some global setting. Unfortunately, it will have to be per-file, much like JavaScript's `"use strict"`. The main consolation I can offer you is that it could be shortened a bit, and that IDEs could hopefully do it for you. That or you can define some sort of shortcut in your editor, maybe tab-complete it. 
Heh, why not put it in the php.ini file! Then you could have it enabled site wide. &lt;/sarcasm&gt; 
&gt; It's so unclear whether, for example, 12.5 should be accepted for an int, should whitespace be allowed, how do you define a boolean, etc. What? Is there some argument that `12.5` should accepted as an `int`? I don't get it, clearly it's not an integer -- it fails the goddamn dictionary definition. Whitespace should not be allowed. Booleans might take some thought but it's not rocket science. The PHP internals list has always been filled with so many opinions, most of them entirely unqualified, that of course it's impossible to get consensus. But you don't want an unqualified consensus either. This RFC now contains the worst possible choice, by not making one -- twice as much confusion, twice as much documentation, twice as much code, etc. 
&gt; What? Is there some argument that 12.5 should accepted as an int? I don't get it, clearly it's not an integer If you're doing weak typing, you allow some conversions. &gt; This RFC now contains the worst possible choice, by not making one -- twice as much confusion, twice as much documentation, etc. It does make a choice: the one that allows strict types for both userland *and* extension/built-in functions, the one that allows the gradual migration of codebases, the one that doesn't massively break backwards-compatibility. Sure, it allows two modes. So does Hack.
&gt; If you're doing weak typing, you allow some conversions. You should never ever allow lossy conversions. So 12.5 should never become 12. But "12" can become 12 and 12 can become 12.0. It's a simple rule. Apply that across all type conversions in PHP and you have a simple sane solution. Again, it's not rocket science. Just because PHP currently does lossy and downright weird conversions doesn't mean that (a) we have do that or (b) the only alternative is strict typing. Microsoft figured out lose/weak typing in Visual Basic decades ago; PHP could copy them wholesale and it would work great. &gt; It does make a choice No, you make the programmer make the choice (over and over). You're just throwing up your hands and saying, "we can't decide how a fundamental feature will work so you decide". And while that sounds good in theory, giving choices is bad in practice. We already had decades of these issues with the PHP.INI file and I can't imagine going through that sort of thing again. The best thing is to just be opinionated. 
I assume your use of sarcasm means this is not a good idea, can you elaborate on why? I'm not too familiar with this but it seems like something that is appropriate for php.ini.
It wouldnt be a BC break though, as you dont NEED to use the typehints.
Sweet! One small idea -if it's not too late- please drop the boolean `declare ` in favor of a constant-based. It will allow the inclusion of other values in the future. declare (hints=STRICT | RETURN | FOO | BAZ | ... ) 
In the far past and the recent past, many language features of PHP were configured by options in the PHP.INI file. This included whether or not input values were automatically quoted, whether buffering was enabled by default, whether certain language features were available, etc. The result was code that would work on one installation but fail on another. Or code that expected one option but couldn't be mixed with code that expected another. It was a nightmare and most of those options have since been deprecated and removed. 
Remove TwigBundle and continue using "templating" service?
Sounds to me like it's just another service you can optionally use to avoid the templating abstraction. The templating service will continue to work as is, no?
&gt; PHP is designed so all internal functions and operators only care about type of the value not the type of the variable. It doesn't care anywhere that an integer is represented by twos-compliment binary value, an ASCII string, or an IEEE 754 floating point value. In all operators, functions, and comparisons it's merely an implementation detail. In theory, what you're saying is sort of true. In practice the language doesn't quite do this well. PHP's implicit conversions are incredibly inconsistent and don't always work properly. If this were Perl, what you were saying might be true. But this isn't in PHP, where values do have types and we sometimes, inconsistently and with bizarre rules convert between them, but not always. &gt; Because PHP isn't strongly typed or strictly typed, you will have properties and variables come from all over the application with no guarantee about their variable type. So any form of strict type hinting will require developers to litter their code with casts or safe-conversions in order for hinted function calls to succeed. And casts will completely neuter any form of type hint (because they always succeed). True to an extent, but a rather limited one. It is true that you do have to use casts more than usual with strict types. But the scope of PHP's weak typing is quite limited. The types produced by operators are fairly predictable: numeric operators always produce an integer or a float, string operators always produce a string. Internal functions, while they can return multiple values, typically produce either a specific type or NULL on failure. Furthermore, the more of your code base that uses type hints, the less problems you have. &gt; Loose scalar type hinting has all the value of strict type hinting (you always get what you intended) Yes, you always get what you ask for. That's not the only benefit of strict typing, though. It is hard to detect errors *in the caller* when virtually anything is accepted for a boolean type hint. &gt; but without the extra overhead of ensuring the binary representation of the value exactly matches the hint type As an actual internals developer: weak type checks have just as much overhead as strict ones. Well, they have more, actually, because you need to do the conversion.
Were you using a limit? I tested it on a table of 1.1 million news articles and never went over 100ms. Getting rid of the score column will also speed it up a lot, IDK why I added that, wasn't thinking.
I love how he says that /u/nikic "doesn't know how PHP works" and how he is "surely not competent enough to be changing the language" :D
Changing the behaviour of extension and built-in PHP functions *would* be a BC break. Unless you also make that an option.
Doctrine repositories?
At the scale of Facebook and Wikipedia no matter what language was used it would still require some custom platform modifications to make it perform adequately.
That sounds pretty easy, actually.
Only if the behavior changed in a non-bc compatible way... I don't think it would
Where's your source on LinkedIn using PHP? Pretty sure they mostly use Java and Scala.
This is a *major* improvement, so kudos for that. But: The fact that I cannot enforce strict types to the *consumers* of my API is a huge letdown. If I `declare(strict=true)` at the top of a file, everything inside should *always* be strict, regarless of where they are called from. Thoughts, /u/StiltonOnStilts?
awesome! That's really cool to hear. I'm not even sure it IS possible, but I think it's always worth trying. We used this package: https://bitbucket.org/wiredesignz/codeigniter-modular-extensions-hmvc To be quite honest I have no idea how it works, because we never looked under the hood. As far as how it worked, it was really easy to use, after initial installation. 
If only he would invest the same amount of time he invested in the writing the post in to in to converting his constructors, this wouldn't be an issue for him.
It's like music instruments, or tennis rackets: A mediocre player (or team) with a top-notch tool still puts down a mediocre performance. Lately doing more python but imo both languages share some a certain versatility (which is quite important in this agile world) and have a good number of quality frameworks and libraries to choose from. So... great tools.
The design was chosen specifically so you don't force the consumers of your API to do things your way. I don't want to have to use weak typing because an API I use was written by someone who likes that. Nor does someone who likes weak typing want to have to use strict typing because an API they use was written by someone who likes that. This design forces nothing on nobody, and it also means you only have to deal with one mode or the other, not both, at least within the same file. Also, the weak types convert their arguments, so it really shouldn't worry you much as an API author. If you have an integer type hint, you will always get an integer.
&gt; Well, we kinda do unless we don't want to break existing applications. We can't break any existing applications because none of them have any scalar type hints right now. I assume you imagine that the built-in functions would automatically opt-in to this but that's not necessary. &gt; For the benefit of everyone who is not a Visual Basic user, myself included, what exactly does it do? Basically it allows all lossless conversions but prevents any lossy conversions. Visual Basic has both loose typing and strict typing (you can optionally declare the types of variables and parameters). In some ways, VB is probably the best model for what PHP is trying to do -- they're very similar in audience, usage, and language feature set. Untyped variables in VB are handled almost exactly like PHP but without all the weird issues that PHP has. Microsoft's design in this way is nearly perfect. I can't help but think PHP is reinventing the wheel and making it an oval. &gt; Programmers will most likely make the choice once and stick with it for all of their code. Two things: you're making them specify that choice in every file and secondly everyone will make a different choice. So for every piece of PHP code that exists there are now two interpretations. One which might run without error and one which might not. &gt; Global, environment-dependent settings like in INI files are hardly comparable to per-file declarations. Yet, what we had with PHP.INI settings is configuration options that change the nature of the language. You're creating different versions of PHP (with albeit just a small difference) and having the developer choose which language per file. 
To publically call out someone he does not and never will know and address them as "bungling amateur" and "pipsqueak" speaks volumes about the person he is. Be sure to read other enthralling tales such as [4+ Reasons Why All PHP Frameworks Suck - Except RADICORE](http://www.tonymarston.net/php-mysql/4-reasons-why-all-php-frameworks-suck-except-RADICORE.html)
It's open source, file tickets, write patches - we'd appreciate either. Hell, bitch in Twitter if its constructive feedback!
&gt; In theory, what you're saying is sort of true. In practice the language doesn't quite do this well. PHP's implicit conversions are incredibly inconsistent and don't always work properly. Yes, but we don't have to use PHP's existing rules for this. Your proposal doesn't even use PHP's full rules on this; you're limiting yourself to the subset that exists only for internal functions and extensions. Why not just constrain the subset further until it is Perl or VB or any other language where implicit conversions do the right thing? Strict typing is just an even further subset than that. I'd be all for removing all the bizarre implicit conversions from all of PHP. There has even been an RFC proposed to that affect. I don't even imagine that it's much of a backwards compatibility issue because any code relying on these unexpected conversions is probably incorrect anyway. &gt; But the scope of PHP's weak typing is quite limited. I disagree. Imagine you load an integer from a file, it's a string. You assign it to an object property, still a string. You pass that object around and it's 7 levels deep in a framework somewhere. Maybe it gets serialized to the session and loaded on another page. That property is passed to a function expecting a strict type. Crash. Finding out where that object originally came from might not be easy. I hardly call that limited. So you need to fix this crash, so you cast. The value is an integer, your function expects an integer, problem solved. Now you load an integer from the file, but some idiot typed a comma instead of decimal. Same exact process. Now you don't get a crash at all. That type hinted function received an integer as expected (because of the cast) but now the value is a zero or maybe some other entirely different number. This is way worse. That file contains your price list and you're giving stuff away. Ideally, you'd say, you'd convert that integer from the start. But there is no requirement that you do that, properties are untyped. But even if we did convert that integer, we'd have to that same thing everywhere for every value coming from nearly every source. Talk about overhead. And it better be a conversion and not a cast! Or you could just have loose-strict typing instead and get the benefit of correct results without the overhead of manual conversions. &gt; Yes, you always get what you ask for. That's not the only benefit of strict typing, though. It is hard to detect errors in the caller when virtually anything is accepted for a boolean type hint. I don't see why virtually anything needs to be accepted for a boolean type hint. Is "hello" a boolean? No, it's a string. An `if` statement converts everything to a bool by necessity but that doesn't mean type hints have to do the same thing. &gt; As an actual internals developer: weak type checks have just as much overhead as strict ones. Well, they have more, actually, because you need to do the conversion. I meant programmer mental/code overhead, not the overhead of the type check itself. 
Well, your argument makes sense but I still don't agree with it. Could you maybe add a "per-tree" equivalent of `declare(strict)`, e.g consider the following `require` tree: a.php -&gt; b.php -&gt; c.php Maybe I could have `declare(recursive_strict=true)` in `a.php` and everything that gets included/autoloaded after that uses strict hints?
The website have been suspended. So your try to get trafic failed.
&gt; Yes, but we don't have to use PHP's existing rules for this. Your proposal doesn't even use PHP's full rules on this; you're limiting yourself to the subset that exists only for internal functions and extensions. Why not just constrain the subset further until it is Perl or VB or any other language where implicit conversions do the right thing? Strict typing is just an even further subset than that. Inconsistency. &gt; I'd be all for removing all the bizarre implicit conversions from all of PHP. There has even been an RFC proposed to that affect. I don't even imagine that it's much of a backwards compatibility issue because any code relying on these unexpected conversions is probably incorrect anyway. Incorrect or not, such code exists and would be broken. Bad. &gt; I disagree. Imagine you load an integer from a file, it's a string. You assign it to an object property, still a string. You pass that object around and it's 7 levels deep in a framework somewhere. Maybe it gets serialized to the session and loaded on another page. That property is passed to a function expecting a strict type. Crash. Finding out where that object originally came from might not be easy. I hardly call that limited. &gt; So you need to fix this crash, so you cast. The value is an integer, your function expects an integer, problem solved. Now you load an integer from the file, but some idiot typed a comma instead of decimal. Same exact process. Now you don't get a crash at all. That type hinted function received an integer as expected (because of the cast) but now the value is a zero or maybe some other entirely different number. This is way worse. That file contains your price list and you're giving stuff away. Ideally, you'd say, you'd convert that integer from the start. But there is no requirement that you do that, properties are untyped. But even if we did convert that integer, we'd have to that same thing everywhere for every value coming from nearly every source. Talk about overhead. And it better be a conversion and not a cast! Or you could just have loose-strict typing instead and get the benefit of correct results without the overhead of manual conversions. Yes, explicit casts have issues. I am well aware of that. This is also an issue that largely goes away the more you use scalar type hints because things are validated and converted earlier on. Also, converting earlier *reduces* overhead as any time you try to do anything useful with a numeric string it gets converted to an integer or float. Repeating that conversion over and over again is inefficient. &gt; I don't see why virtually anything needs to be accepted for a boolean type hint. Is "hello" a boolean? No, it's a string. An if statement converts everything to a bool by necessity but that doesn't mean type hints have to do the same thing. It's our existing behaviour, but also, there's always a case to be made. Allowing bitwise op results to work is good, for example. &gt; I meant programmer mental/code overhead, not the overhead of the type check itself. It's not necessarily less overhead. Especially when you have to handle all the cases where implicit type conversions don't work.
Or just make arrays implement `Traversable` ;)
I am a frequent language spec contributor, don't you worry :)
&gt; What other way round? Strict be default? If that's what you mean, it'd be a pretty big BC break How do we have a bc break atm.. At present no codebase has scalar type hinting.. and that will continue to work in php 7 (because it doesnt have any type hints for scalars yet) "Changing the behaviour of extension and built-in PHP functions would be a BC break. " &lt;-- like ?? atm the codebase is mostly like function add($a,$b) {return $a+$b;} How does this code break on php 7 (if we have scalar typing hintsin that version) ??
&gt; I don't want to have to use weak typing because an API I use was written by someone who likes that. can even be thought on the other way around!! 
&gt; We can't break any existing applications because none of them have any scalar type hints right now. I assume you imagine that the built-in functions would automatically opt-in to this but that's not necessary. Well, yes. We still have to add a per-file choice if we want to fix internal functions without breaking every PHP application ever. &gt; Basically it allows all lossless conversions but prevents any lossy conversions. Visual Basic has both loose typing and strict typing (you can optionally declare the types of variables and parameters). In some ways, VB is probably the best model for what PHP is trying to do -- they're very similar in audience, usage, and language feature set. Untyped variables in VB are handled almost exactly like PHP but without all the weird issues that PHP has. Microsoft's design in this way is nearly perfect. I can't help but think PHP is reinventing the wheel and making it an oval. Defining what is a lossless conversion is surprisingly difficult in practice, and I dare say that you are nave for thinking VB has necessarily achieved perfection. For you, maybe. Someone else probably hates VB's behaviour. &gt; Two things: you're making them specify that choice in every file and secondly everyone will make a different choice. Quite possibly. I expect strict hints would be the most popular, but weak hints may have significant traction. &gt; So for every piece of PHP code that exists there are now two interpretations. One which might run without error and one which might not. "Two interpretations"? No, one. Only one. Code written for one environment only needs to and only will run in one environment. &gt; Yet, what we had with PHP.INI settings is configuration options that change the nature of the language. You're creating different versions of PHP (with albeit just a small difference) and having the developer choose which language per file. Not really. It's the same language. It's slightly more strict in its type checking if you choose, but it's still the same language. Does turning off Hack's type checking make it a different language? Does using a PHP error handler make it a different language? Does turning on `-Wall` in C make it a different language?
OK: I deliberately do not want to allow any further options in future. Having just one choice is bad enough. Having multiple choices is chaos.
Why is it crap academically?
OK, but once you introduce this "flag" you open for somebody behind you to introduce another in the folowing rfc, and then 10 rfc later we are in a chaos of declare's hell I'd say introduce a clean, extendable syntax, or don't introduce at all &gt; please don't get me wrong: the work done is really impressive. &gt; I really want this rfc merged, as much as the return's type ;)
&gt; Defining what is a lossless conversion is surprisingly difficult in practice, and I dare say that you are nave for thinking VB has necessarily achieved perfection. You should never ever allow lossy conversions. So 12.5 should never become 12. But "12" can become 12 and 12 can become 12.0. It's a simple rule. Apply that across all type conversions in PHP and you have a simple sane solution. 
Got to agree with this. If you're going to ask someone to do some work because of their expertise in an area, then you should let them decide the best tool / platform for the job. Forcing inappropriate technologies on developers will result in a subpar product and annoyed developers.
 sin("1"); This is not currently an error and works fine, always has done. With strict type checking it does not work.
I'm in no way an expert in language design or floating point arithmetic but 3 / 2 should probably be 1.5 :-)
Yeah, it's the most intuitive behaviour, that's why I like it. :) If you really want to get the quotient (integer division), there's always `intdiv`.
And here I am, stuck with a system written in rypo3 - aversion that's at least 3 years old, and php on the server is 5.2.9 My boss just told me that we'll outsource the rewrite of our system, because he thinks it'll take me too long to develop on my own. Instead I should focus on selling away, developing new features for the old system. 
I've been coding in PHP since PHP 3.x, i've never had any issues with it. It may have its inconsistencies, but what language doesn't? They also keep improving it's features and performance every single year.
Because OOP was quite a late addition to the language and none of the basic types are objects. I think they probably should implement it, though.
Wordpress is a blogging platform, which is almost adequate as a blog. This doesn't sound much like a blog. It's also routinely misused as a CMS, so a content driven site can be created. This doesn't sound like a content driven site. What it sounds like is a custom web application. That makes PHP a good choice.
I grant you indeed it's not active record. I just want to point out though that repositories definitely allow to define custom queries (that's the whole point of repositories).
Yup,but as you see my orm does have its differences and ia not a rehash )
All have differences, but I think most of the goals are similar (if not the same) Which makes it a bit sad considering the huge amount of times that requires creating an ORM.
www.whitehouse.gov even uses PHP.
It is indeed a shame the PHP specific implementations are, well, poor quality. Data encryption, random number generation, XSS handling, password hashing, random password generation and many more...are all (looking purely from a security point of view) bad implementations. It was a few years ago @ircmaxell throw an idea about such generic security library, *because the poor state of OWASP PHP ESAPI*, and we were brainstorming it and had some details on "paper". But due to lack of time it kind of halted. I have lately become to conclusion that bundling "all the security features" in one big package may not be the best idea after all (whoever is doing it). It surely has upsides (just a single although big dependency to your app), but indeed it would be most of the time better to have small, decoupled and good quality independent packages to do just one thing (and do it good). Just like pretty much everything else in good library/package design.
Well all I can say is wait till its done and then tell me if it was worth the effort =) I'd really like to get some opinions =)
I kinda hate this notation: -&gt;where(['id !=' =&gt; 1])
I really disagree. PHP and other languages have its own design and best features, of course, but when you say PHP is not designed to do (and I thing you refer to async, callback paradigma) you are thinking inside the box APACHE/NGINX + PHP (or python, or CGI's using other languages) and not PHP itself(again, or pyhton, etc). If a language has http://php.net/manual/pt_BR/class.closure.php , and http://php.net/manual/en/language.pseudo-types.php#language.types.callback, and http://php.net/manual/en/functions.arguments.php and etc this language is clearly capable of handle async behavior, or in other words, this language is capable of handle Event driven design. Well, there is not a lot of code with this paradigm in PHP but it still valid and the general purpose of PHP can handle this challenge. But, if you are asking about if is better use PHP or NODEJS for event driven applications? The answer is NodeJS, at least for the moment, because you need the code has maturity to bring this to production environments and PHP Event Driven is a ongoing idea.
I think what these people are trying to imply is that there is no consistency and therefore leading design to the language. It's just a bunch of randomly added features. Which, after using PHP for 10 years, is kind of the feeling I get as well. Classes like DateTime are really promising though.
Honestly, this is the most asinine argument I've seen. Everything from his website to his attitude reeks of a person from 1997. Nothing has improved, nothing has advanced since then. Needs more blink tag. Anyway, the point is all of this is hugely dumb. The argument isn't that PHP4 constructors are going to be retroactively removed from all versions of PHP5. It's the latest and greatest version that won't support them. If you have 15 year old code that you honestly just expect to spin up on a brand new bleeding edge server without issue then you're wildly optimistic to the point where professionals should be called. If you have a 15 year old app that is working fine, just leave it the hell alone. No one is making you update it. Just let it keep doing its thing. Constructor Elves aren't going to sneak in at night. This stood out to me &gt; How long will it be before some bright spark notices that there are two ways of iterating through an array - for and foreach - and decides that one of them must be redundant and can therefore be removed? Um... no. There aren't. For and foreach do **completely different things**. For does not by any standard be described as "iterating through an array". It is for running a loop for a given amount of time. That it's sometimes (mis)used for accessing arrays during that loop doesn't make it intended for that purpose.
The fact that GCM mode requires a different interface, in that it requires an authentication tag be supplied/checked, suggests that if PHP's bindings weren't updated for it, the feature just hasn't been implemented. By "other valid options", would CTR + HMAC be a valid option?
I think LeviM is holding that back until this RFC is dealt with.
Well, that's entirely a matter of taste. I hate the other option as I have to write more and it is impossible to encode conditions in a single array without resorting to calling more methods constantly or creating an awkward looking array structure. But in the end those are really small details, whereas the philosophy of the library and the overall features is what matters at the end.
the 1997ness of his attitude isn't limited to his site design or this article... many of his other articles fly in the face of commonly accepted best practices.... ORMs? evil. OO? evil (and while we're at it, advocates should be called 'nazis'). SOLID principles? evil. Specific shout out to Dependency Injection? evil. He even makes suggestions that big design up front is the correct way to design software despite mountains of evidence to the contrary. The worst part is not his outmoded ideas. It is the manner in which he argues. Immense amounts of his posts are dedicated to calling people who hold different opinions to him "idiots", "morons", "nazis", "pipsqueaks" and whatnot. The linked article could have been an opinion piece about why PHP4 constructors read better and are more consistent with other languages - which would have been a valid point to make. But instead its a rant about how internals are a bunch of immature, unprofessional dicks (and some of them may well be, but it isn't helpful to his argument). Add to that there's not a single way on his site-from-1997 to strike up a conversation with him (even geocities sites had guest books ffs)... Anyway, irrelevant internet dickhead is an irrelevant internet dickhead...
Awesome sauce, right?
These all would be great things to fix in the a major release like PHP 7. You know the one thing I would like to see the most? Semantic array usage. Something like: $array = array(); $array::push('value'); Rather than the array_push($array, 'value'); That we have now.... 
I wonder if strict mode will/would be used in the future for other stuff :)
Either build-in functions and libraries would not get type hints, or code that called functions will start failing in a non-bc way if they relied on coercion.
I'm all for a modern PHP e-commerce solution, but the response times in the [demo](http://demo.sylius.org/) seem pretty high. I wasn't able to get a page to load in under 500ms, and the average was more like 850ms. Any idea what kind of load is this expected to handle?
Gonna have a look this evening. Thanks :)
It's a draft RFC that lacks a patch. I'm sure Levi will work on it (perhaps with help from others, he has very limited time) after return types passes.
I can't wait to replace public function hasRoom(/* string */ $roomName) /* : bool */ with public function hasRoom(string $roomName): bool in my code. Well, I hope I'll be able to...
Look at his homepage, and then try to take him seriously: http://www.tonymarston.co.uk
In that case you won't be able to use those query scopes you mentioned. But the problem is that you can do all that in the Model itself. which makes it act as Entity. Query and Repository at the time time. I don't like that. 
Add nullable types to this list and I'd never have to go through the frustration of trying to install hhvm on osx again.
To add extra awesomesauce to the current 9-1 in favour, this is the same syntax that Hack uses: function foo(): array { return []; } Demo: http://3v4l.org/TE6ZI 
Eloquent can do the "favorite" thing you says it doesn't do. :)
Does someone have an example of the syntax when using an anonymous function with a 'use' declaration? ie: $something = 'blah'; $func = function() use ($something) { echo "Something value: $something\n"; } I didn't see any examples...
Sigh. When will people understand that PHP is a dynamically-typed language and stop trying to make it statically-typed? Edit: I expect I'll be heavily down-voted of course because strong typing is the awezome because professional
http://i.stack.imgur.com/rcITW.jpg
It's very *hard* to look past the writing style and insulting words. It is also very *hard* to give the guy any credibility given some of his other opinion pieces. His article (and indeed most of his articles) would be a little easier to read and his opinions a little easier to accept if his style wasn't so obnoxious but honestly it is *so obnoxious* that any amount of point he had is totally lost. Now, he could have made arguments for BC (which many, myself included, would disagree with - but this really just boils down to which side of the fence you sit on), he could have even made arugments that __construct() does not read as well as the php4 style (and he'd get a lot of support for that I would imagine, especially if your experience is with other languages) but instead he decides to call people who are doing the work all sorts of names, call their professionalism into question and run off on some diatribe about how his existing functioning code should continue to function forever irrespective of the language version number or problems with maintenance, readability, comprehensibility etc. Is there a useful opinion piece buried somewhere in the article? Maybe, sure, ok. But until it is presented in a way which isn't loaded with personal attacks and self importance then it should be taken for the rant that it is. 
No. I've always seen these things as over complicated solutions to non existential problems. Consider this: You waste a lot of your time learning new syntax, you implement it in one of your projects, suddenly a colleague has to step into the project and all he can think is "wtf". 
JVMS are "scalable"! And let's not forget the wonderful support from Oracle. /s
Works fine for me, and considering they don't have any caching or CDN configured you can't really expect much.
Yes I knew this would resurface It had to
&gt; But look past that. He has a point that's at least worth considering. &gt; &gt; &gt; What level of BC is good? &gt; &gt; He argues that total BC is good. Well, we know that's impossible since bug fixes and security fixes break BC all the time. So that means there's a line between total BC and no BC where we want to be. &gt; &gt; The PHP4 constructors RFC is an interesting one to examine. What's the gain. The OP argues that there is none. That it's breaking things for "purity". And in a sense he's correct. However, that ignores that having multiple ways of doing Honestly, you're right. There is very little to gain other than consistency between global/non-namespaced code vs. namespaced code, which essentially benefits programmers that have embraced the modern in that they can write quick and dirty classes in the global namespace that work the same as their namespaced classes (with regards to ctor). The more important change happened in 2010 though, when we decided that php4 ctors would not apply in namespaced classes (b/c FilterNs\Filter::filter()). This allowed a clear delineation point for those that decided to embrace new features vs those who "embrace BC" to the fullest. But at some point, like now - 5 years later, consistency becomes more important than keeping a particular feature BC. Stas summed it up nicely (http://news.php.net/php.internals/47713): &gt; I would propose to have "class-named ctor" apply only to non-namespaced classes. Yes, that'd mean when you namespace a class you'd have to convert class-named ctor to __ctor, but if you want namespaces, you'd have to abandon your php 4 habits :) 
... as I said. :P
A League of Extraordinary PHP Security Packages? ;) Seriously, though, I'm all for gathering the recommended tools into the right place and making that a de-facto source for those wanting to know about the best packages out there, but I'm not sure if a "meta-project" is the right approach here. I like what The League has done with their packages, but I'm not in favor of the move of the project under their namespace. Instead I'd much rather take the work that's already been done to make these packages and gather them in a space where people can reference them easily. I've sort of started doing that on the [Securing PHP](http://securingphp.com) main page, but I'd rather see it as a more curated list with "proven" packages voted in by members of the group or something similar. I think having a resource like this could go a long way to help things. I've been approached about a "reboot" of the PHP Security Consortium - maybe that's what this needs to be? 
Example: a method that returns a user's first comment. What do you return if the user doesn't have a first comment?
This looks great!! I wonder why the `int` vs `integer`distinction given that the Scalars' rfc allows them both syntaxes?
Yes I've used Hack. And?
Actually.... $array = []; $array-&gt;push('value'); $array-&gt;keys();
&gt; Our main system isn't even that complicated when push comes to shove, it's just CRUD and a ton of formatting. 95% of the things I've worked on all the way back to the desktop fall in that category and the 5% I usually imported someone elses library. 
What are your objections to return typehints (or this particular implementation of it)?
I don't get this: &gt; A third approach has also been suggested, which is to add separate weakly- and strictly-checked type hints with different syntax. It would present its own set of issues: &gt; - People who do not like weak or strict type checking would be forced to deal with strictly or weakly type-checked libraries, respectively. But doesn't the declare directive do exactly this? If I add that in my own code that's forcing strict type checking upon others. &gt; - Like adding strict hints, this would also be inconsistent with extension and built-in PHP functions, which are uniformly weak. This is also nonsense. If both strict and weak hints were added, built-in PHP functions can use the weak type hints, right?
i take people less seriously when they mention coffeescript
yall stay getting null when no return explicitly defined. yall stay KIM when returned value gets no assignment. 
I feel this is the David Mark http://www.cinsoft.net/mylib.html of the PHP world. Though David actually had some valid points, he went about it in all the wrong ways. https://news.ycombinator.com/item?id=993441 
+1 for a serious discussion. &gt; I think I'd feel like someone who never uses it is likely a scriptkiddie who hasn't dabbled in other language like C#. That's perfectly fine, everyone starts somewhere. I do however at the same time believe anyone who wants to become part of the big boys will sooner or later have to start considering to write statically (in PHP that would be type hinting (almost) everywhere). I won't deny there are skriptkiddies. God knows there's a lot of them... and they write a shit ton of awful crap! But doing something like passing a session object to a function that does string processing is a rare offense. It's been my experience they're more apt to do stupid things like trusting user input, not properly initializing variables, and writing general spaghetti code. It's attention at that level of detail that reflects competence and professionalism, and a professional is going to be aware enough of his code to know what's returned from a method. &gt; Type safety allows for IDE error checking. Type safety allows for sanity. ("1a2b3c" + 1) giving a result is not sane. I don't have an issue with static/strong/strict/whatever-they-want-to-call-it typing. What do I find obnoxious is the perception that people have that it somehow magically makes for better code. I find the close-minded, judgemental attitude that has emerged in the PHP community in the past 5 years or so obnoxious. It's obnoxious to not respect the value that different paradigms bring to the table, to fail to understand everything has its strengths and weaknesses, and to force everything to conform to some collective archetype. PHP is a flexible, dynamically-typed language, and that's not respected. There seems to be a sentiment that the only for it to grow and improve is for it to change to be more like Java and C#. This is all rather ironic by the way, considering a slew of OOP concepts have evolved to circumvent the restrictions and weaknesses of such statically/strong/whatever typed languages, and features have been added to such languages to make them less ridged: generics, interface-driven polymoprhism, boxing, etc. Even in the database world there's SQL vs NoSQL. The Dynamic is becoming more ridged and the ridged is becoming more dynamic. &gt;&gt; And not even doing so in an elegant way. &gt; I feel this is just an opinion, and I'd probably agree. My feeling has been for a while that the PHP language is basically fucked due to its roots and for it to be really improved, a new language has been started. Luckily that has happened with Hack, it just has to mature more. Sure, it's opinion. Beauty is in the eye of the beholder. Any type enforcement added to PHP has been explicit declaration, very much in the vein of C, Java, etc. Even in Hack, types are explicitly defined. Perhaps people think this is pretty, or like typing obvious and redundant keywords when the majority of typing can be inferred from the operations performed on the values. C# and Go do this with the var keyword. OCaml takes this much further with Hindley-Milner typing. Would not something like that be more elegant? It shifts the burden onto the compiler instead of the developer and reduces line noise in the source code. It certainly would have been less intrusive in PHP.
I am not going to downvote as everyone is entitled to their opinion. Do you not find this useful when working with other peoples code? For example.. public function update(UserRecord $user) Seems infinitely more helpful than it not being type hinted. Here you know a UserRecord object is expected. Without this you would have no idea what to pass in without looking into the method. Even then it could be unclear. Type hinting also gives clear errors when you put the wrong thing into a method. The return value hinting is a logical extension of this. 
&gt;I think I'd feel like someone who never uses it is likely a scriptkiddie who hasn't dabbled in other language like C#. That's perfectly fine, everyone starts somewhere. I do however at the same time believe anyone who wants to become part of the big boys will sooner or later have to start considering to write statically This attitude is the problem. This idea that 'real coders have started with/used compiled langs' is elitist bullshit. There are people doing amazing work everyday that have never used anything but scripting langs. Are you not a good coder because you don't just do assembly instead of that hand holding C#? Ive been programming a while and used both loosely and strongly typed langs and typing has never been the major source of bugs and poor code quality in anything I've seen. 
Why is this RFC kicking so much ass on the vote (currently 19-1)? It's a very disruptive proposal (in terms of the "java-ification of PHP") which I would've assumed would get shot down by the usual suspects (whose opinions are valid and have won their voting rights). So - what is it about this RFC? Or is it simply that RFC proponents get in there early with their 'Yes' votes? 
I've done a fair bit of hiring for php interns and php dev 1's ...simply having completed projects of your own (in any language) sets you apart from most other candidates. A portfolio website of your own is a fantastic start, contributing to open source projects on github would be a double-fantastic start...prove that you love to code and have the skills to do it. As for the projects themselves... a simple calculator is what you make of it, if you built a calculator and unit-tested it as a way to teach yourself PHPUnit I would be impressed. 
I often run into the opposite problem - I have an idea for a *thing* that would improve the quality of my code, testing or otherwise, but I'm not 100% sure what to call it. Unfortunately, Google isn't very helpful here. Searching "design pattern that turns a specification into relevant template data" makes for poor results. 
It's likely the demo server. In a production environment non-cached product pages are around ~225ms for me. Without too much effort the site average can be brought down to ~100ms
&gt; I do however at the same time believe anyone who wants to become part of the big boys will sooner or later have to start considering to write statically I really disagree with this. There are amazing professionals writing excellent code in languages like Ruby that don't support anything like type-hinting.
&gt; But doing something like passing a session object to a function that does string processing is a rare offense. It's been my experience they're more apt to do stupid things like trusting user input, not properly initializing variables, and writing general spaghetti code. It's attention at that level of detail that reflects competence and professionalism, and a professional is going to be aware enough of his code to know what's returned from a method. I could not agree more! &gt; I don't have an issue with static/strong/strict/whatever-they-want-to-call-it typing. What do I find obnoxious is the perception that people have that it somehow magically makes for better code. PHP is a flexible, dynamically-typed language, and that's not respected. There seems to be a sentiment that the only for it to grow and improve is for it to change to be more like Java and C#. Exactly. Like you, I'm extremely sick of this idea that taking advantage of the dynamic features in PHP makes you less of a professional than writing it like Java or C#. All of my education in programming was in C, C++, Java, and C#, but I'm a script-kiddie if I still prefer to write code that takes advantage of the dynamic nature of PHP.
Sarcasm? try { $comment = $user-&gt;getFirstComment(); // show comment } catch (CommentNotFound $ex){} vs if (null !== ($comment = $user-&gt;getFirstComment())) { // show comment } 
I should also note that I need PayPal integration.
I didn't. That didn't stop me from trying ~20 times though.
ferrari.com - just kidding I'm running several stores with sylius but they are all b2b, sorry.
http://docs.hhvm.com/manual/en/hack.modes.strict.php
&gt; it was written by a guy who publicly stated that he is not a language designer That hasn't been true for many years, since the language was taken over and modified by a more responsible organization (that still includes Rasmus). &gt; I will stand by my position that a language and its runtime environment are separate and have different performance and security characteristics. That is correct. The wild downvotes in PHP can be disregarded, since the /r/php crowd barely comprehends many subtleties.
Yes but you could say the same for anything. For example if Symfony couples itself to Monolog by default -&gt; just register a logger abstraction yourself. In that case every abstraction could go away, everything has to be re-decoupled manually. Symfony is supposed to be a decoupled framework.
I stood against type hinting when it was proposed as well and on the same basis I argued in other posts in the thread. I may not hold a popular opinion, but at least I'm consistent :)
TIL: expressing a differing opinion is unprofessional. 
It's the continuation of a process that adds strict features to a dynamic language based on the belief they're important to write solid code and thus perpetuates the belief.
My goodness you have some GIANT security holes. Read this *immediately*: http://www.phptherightway.com/#databases
&gt; But doesn't the declare directive do exactly this? The declare directive moves the strictness level to the *caller* instead of having the *callee* declare strictness. That's a huge difference in functionality. Everyone can safely add typehints to their functions and methods and only developers that actually *care* can then insist that their code error out instead of issue a warning when there's a type error. I think the directive is uglier from a syntax point of view, but a far, far superior solution overall.
Never touching Drupal again, ever. 
I think its like this: $something = 'blah'; $func = function() use ($something): returnType { echo "Something value: $something\n"; }
Haha. Well be happy that its optional and doesn't have any effect on scalar types. I don't want my Foo getting thrown into something that wants a Bar, even if I am perfectly happy with "1" being 1. :)
That sounds like you object to the doctrine of "everything must be strictly typed", not the actual RFC.
&gt; ll really don't think type hints are in any way a substitute for understanding the code base you are working on. The less I need to trust myself and the more I can trust the interpreter/compiler the better. Also, you don't always understand the codebased, especially when you first start with it.
Uh... $array = new ArrayObject(); $array-&gt;append('value');
I've put "java-ification of PHP" in quotes because it's supposed to be a little derisive to those who use that term. I'm personally all for scalar type hints, return type hints, I also liked the arrayof RFC. However, but sometimes it seems like forward-thinking changes - even opt-in behaviour - gets voted down. I'm just curious to know what makes this different and some previous failed attempts.
that is what is confusing... http://tonyarcieri.com/all-the-crypto-code-youve-ever-written-is-probably-broken
You don't need your PHP 4 code to run on PHP 7. It's time you put in tiny amount of work in. Or throw me $500 and I'll fix it for you.
Ok, so looking at the docs we have "append" which is "push" but the PHP team that developed this decided that you don't need pop or shift functions, and decided to give things really weird names. Granted, from what I see the one nice thing about them calling it "ArrayObject" is that you can create your own class "Array" and just extend ArrayObject, but honestly that isn't something that a developer should have to do on their own....
That was on source of inspiration. :) One of the things I don't like about Hack is that type hints go unenforced in some cases. This RFC's type hints would *always* be enforced, but you have the stricter approach as an optional flag.
Generally it's things like BC-breaks, or poorly accounted for edge cases, or issues with implementation details that cause votes to fail. It's not necessarily because internals disagrees with the idea/concept, they might just disagree with some of the specifics of the RFC. Save for a few people, I think the majority are on board with PHP maturing into a "grown up" language instead of remaining a hobby language.
This isn't at all what I wanted to imply. I am absolutely sure there are way smarter and better programmers than me that write purely dynamically. No question about it. The thing is, if I'm looking for a good PHP programmer then I want someone that tries different things to see for himself what he thinks is best. If you only stick with the 1 language you know (PHP) and the code you make (e.g. WordPress websites) then I think you will have less good innovative contributions then when you tried many different languages and frameworks and design patterns to find what suits you best. I wrote it as a way how I select applicants for a programmer position that needs to be able to think outside his box, to innovate. If he tells me he dabbled in such languages and still didn't like it then I'd love nothing more then to hear why and if it's a good argument I'd definitely favor this candidate over someone who just agrees with my views.
http://www.reddit.com/r/PHP/comments/2sdxlm/php7_return_types_rfc_ongoing_vote/cnp63hw
What would resources be replaced with, exactly?
Part of the problem, dear reader, is your lack of charitability. You are all-too-ready to dismiss, excuse, or otherwise ignore inflammatory or injudicious language that *supports* an opinion you already hold. "Oh, that's just X being X; he doesn't mean anything when he calls people stupid, he's just being colorful." You are simultaneously all-to-ready to condemn *the exact same kind of language* that *opposes* an opinion you already hold. Hell, you're eager to pile on with insults yourself even when an opposing opinion is presented in rational, judicious, and measured language. You'll nitpick it to death and find meanings where none is intended. The problem here, folks, is not Tony Marston's presentation. It is your unwillingness to be charitable to opposing views.
Not at all, but you are acting childish. Not for expressing a differing opinion, but for going around and claiming that (A) we're wrong for wanting the option for typing and (B) claiming that you'll be mocked for not wanting to use typing, playing a victim card despite no-one having said a thing about it. If you're going to cry wolf, at least wait for the wolf to show up. That's why you're not acting professionally. 
I did not really get it working after your response, but that code was a great help in the right direction! Thank you for taking your time! :D
I don't think there has ever been a particular resistance to return type hints on internals - apart from some syntax squabbles maybe. IIRC earlier RFCs conflated return types with scalar type hinting and we know *that*'s a controversial issue...
But it wouldn't break BC because obviously all old code wouldn't have that flag, only new code would -- exactly like the flag you are proposing. The generated byte code could be very different in "PHP7 mode" (fixing "lolphp" issues) but still freely mixed with legacy code. 
Isn't it defeatist to say that your questions cannot be solved? Most other languages have solved them consistently. An argument can be made for all those questions one way or the other, pick the best or most pragmatic one, and move on. You actually still need to have these rules. Strict type hinting doesn't eliminate the need to safely convert values from one type or the other -- in fact, it requires it. You're still going to need, somewhere, a function that converts strings to ints. Does it care about whitespace? Is losing a .0 a loss? It all has to be decided. &gt; PHP doesn't have them and never will. It could have them, or something close, for type hints. 
I wish I could vote YES on this myself Looks like I wont need to though :) 
Ooh, I didn't think of that. Thanks for the suggestion.
So if I have class A with type hinted functions and add the declare to my A.php, that doesn't enforce strict type hints?
This isn't a support subreddit. Try /r/phphelp
Oh. Okay thank you very much!
I can't imagine I would ever want to use a free form processing service with something that requires PayPal integration. Yuck.
Looking forward to it! I have been enjoying the ease of use of phpixie 
I'm going to guess that you're going to change your $500 estimate after seeing his code base.
Could you go into detail about how lossless conversion is hard to define? It seems to me that lossless is pretty cut and dry - either you lose data in the conversion (e.g. you can't possibly get it back), or you don't, no?
I feel bad for anyone who has to work with that guy's code :/ I don't know about you, but I *love* working on software that follows conventions so outdated they now only live in the minds of their creators.
&gt; It could have them, or something close, for type hints. No, it couldn't. This has been tried, and rejected. &gt; You actually still need to have these rules. Strict type hinting doesn't eliminate the need to safely convert values from one type or the other -- in fact, it requires it. You're still going to need, somewhere, a function that converts strings to ints. Rejected.
It wouldn't break BC if the flag isn't set. If you set the flag, you break your code. If the differences are too great to migrate, people won't bother. Simply hiding BC-breaking changes behind a flag does not make the fact they break BC cease to be a problem.
I can't really say which is better, but I really like the fact that with Piwik, I hold all my data in my own SQL database. It also gives you more info that Google would keep private, such as user IPs for example. You can view the full browsing history of each specific IP, and see which stats apply to specific users etc. Fuck... just checked my Piwik installation and noticed I fucked up a nginx config file for it, so I'm missing stats between now and Sept 2014. So I guess that's the downside, you need to maintain it properly, or you might miss data. But that's my own fault really.
Nice work! Personally, this is by far my #1 most favourite framework-to-watch in PHP. I really like what you've done with it. I forked it ages ago with the intention of contributing but I just haven't got around to it yet. Rest assured I watch the repo and check in on it frequently. I'll get off my duff and see if there's an issue or two I can tackle one of these days! Thanks for all your hard work!
I think we might mean different things when we say "dynamically typed" or "statically typed". Ruby is dynamically typed but 5 + "5" is an error, that's not dynamic typing, that's weird behaviour that some people call "weak typing" although that term has no universally agreed upon definition. Dynamic type checking is about evaluating whether an object is suitable for a particular operation at run time. If I try to send an object a message and it understands it, the type system is happy. Suitability is based on an objects ability to respond to a message, rather than on an objects underlying type. Type hints are suitability enforcement based on type, rather than interface. This isn't a static typing "feature" so much as a necessity due to how static type systems in compiled languages need to work. They force me to extend a class or implement an explicit interface, even if my object responds to all the same messages as the object a function is expecting. This forces me to create pointless wrappers, or manually implement all the methods in an interface when maybe I just wanted to use __call to delegate to another object my object is holding. Interfaces as an actual *language construct* only exist in languages like Java to trick the type system into letting you use polymorphism between types that share no real ancestry. PHP is a dynamically typed language that supports duck typing. That's why all of this type hinting stuff feels bass ackwards to me. We're adding "features" that other languages treat as unfortunate necessities. Type hints in PHP give a false sense of security that people aren't going to "use your code wrong", but I've found in that practice that is mostly paranoia. It's executable documentation of what type a function is agreeing to work with, and that's the only benefit to it I'll buy. Besides that, I find it introduces unnecessary coupling and cripples the ability to take advantage of dynamic features, like using magic methods to simplify delegation in a decorator for example. That and I just find PHP a lot more fun when I write it more like Ruby :) Still love you Phil, I think all this stuff is just personal taste, no right or wrong. It would be nice if we could accept that as a community though, because I do feel like preferring to write PHP like a dynamic language leads to being looked at as an amateur by the "professionals".
I agree with the general sentiment of your article but I have never heard of TDA before and the example refactoring just seemed to turn one poorly organized piece of code into another poorly organized piece of code that used a property. I kind of got the point, kind of, but not really. But that's the fly not the ointment. Properties can stink a little.
My sed command doesn't care how long it runs. 
I'll add a link to read more. I didn't want the article to focus on TDA. It's a pretty simple concept. In essence, you tell objects what to do instead of asking them. For example, instead of asking for a value, you might tell it to get/set the value itself. Asking: $var = getVar(); Telling: loadVar(); // this one gets a var, but sets it to a property
Duck typing is fun, and you can do that in PHP if you like. It still doesn't really effect weak/strong typing which pretty much always refers to scalars as far as I've heard it. &gt; Interfaces as an actual language construct only exist in languages like Java to trick the type system into letting you use polymorphism between types that share no real ancestry. I dont know if thats true. It's just a way to see if the class is gonna do the stuff that you think its gonna do. Composition is nice, beats the tits off of deep extension. &gt; Type hints in PHP give a false sense of security that people aren't going to "use your code wrong" Nobody ever said that. Even if you consider it a self documenting feature its handy. "No dude, we want a Foo not a Bar." Oh, thanks PHP! &gt; They force me to extend a class or implement an explicit interface, even if my object responds to all the same messages as the object a function is expecting. Yeah you might have methods, but do you have all the right arguments and types for those methods? That can be an arse to keep up to date with. &gt; It's executable documentation of what type a function is agreeing to work with, and that's the only benefit to it I'll buy. That and the performance improvements that come with knowing exactly what type of data is gonna be in a variable. They've been fairly huge since 5.3. &gt; Besides that, I find it introduces unnecessary coupling Well if you NEED to know its going to be a certain type of class, then that sounds like necessary coupling. Coupling should be used sparingly of course. &gt; cripples the ability to take advantage of dynamic features, like using magic methods to simplify delegation in a decorator for example. You can totally do that. &gt; That and I just find PHP a lot more fun when I write it more like Ruby :) Type hinting is optional, which is the awesome thing of PHP. Try writing Go where EVERY SINGLE argument and method response HAS TO BE specified. That can be a right pain. That said about Ruby, it can be nice that it can return a list or a collection or whatever and nobody knows the difference, but its bitten me in the ass a few times. Today alone I was passing in the wrong object and it was working surprisingly well considering. Took me about an hour to realise the wrong damn model was going in. A type hint would have fixed that. If these "other languages" are so much better for not having type hinting, why did [Python just add it to 3.5](http://sdtimes.com/python-3-5-include-type-hinting/)? I am exceedingly happy that type hinting exists in the way it does, as the PSR interfaces would have been a major ballache without it. Duck typing is fun for those that know how, but its a bit more loosey goosey (HA!) than I'd want it to be for the "average" type of folk writing PHP. PHP is a language for a wide range of people. It's used by absolute muppets and computer science geniuses all the way through. The fact that all of this is optional is lovely, and the fact that you CAN use if it you like, and CAN ignore it if you like is excellent. Type hinting - like it or not - is _obviously_ here to stay. Return types is just making outputs have the same abilities as inputs, which is just logical and awesome. &gt; Still love you Phil, Dunno why people gotta stay stuff like this just because we're having a chat. Do people really think im sat here screaming at my keyboard? I'm just waiting for the latest Archer to download and it's taking a while. :)
Thank you for the link! Yes I'm aware of these.. They are the next things I'm going to be taking care of.. It's very difficult being one person thus why I went opensource so people can help and also take advantage of the neat features like multi-site in one admin.. I have a list of things that need to get done! Hopefully I can get some help quick to move things along faster :)
&gt; If you set the flag, you break your code. No, because very little code exists relies on "lolphp" behavior. Anyone still working on their code (and thus both willing and able to set such a flag) is unlikely to have any problems. 
But it's a simple problem with a simple solution if you don't add artificial complexity by introducing the concept of "meaningful" data loss. That's of course going to be totally subjective, and everyone will have differing opinions on what's meaningful or not. So, let's just simplify things by considering *any* data loss unacceptable. If you can't cast a scalar to another scalar type, and back again and maintain strict equality, then your casts lost data. It's really as simple as that.
Frankly, no.
Your shoe example introduces temporal coupling. Don't think I'm sold on the concept if it creates more state and race conditions.
I don't think that's the point of *Tell, Don't Ask*. A better description may be: &gt; ... you should endeavor to tell objects what you want them to do; do not ask them questions about their state, make a decision, and then tell them what to do. &amp;mdash;[The Pragmatic Bookshelf | Tell, Don&amp;#x27;t Ask](https://pragprog.com/articles/tell-dont-ask) There's a [laracast on Tell, Don't Ask](https://laracasts.com/lessons/tell-dont-ask) 
The first answer here is a bit more thorough and better discussion: http://stackoverflow.com/questions/5863870/how-should-a-model-be-structured-in-mvc
Yep, I agree. I'm not sure where we differ. EDIT: I guess your point is about TDA applying to objects? I don't see why we can't apply it to the molecules that make up the object as well. No need to coin a new term for an old idea.
Do...do you not use docblocks??? /** * @param string $roomName * @return bool */
It is one of many ways to do it. That code is not very good (it's terribly verbose in a completely unnecessary way), but if it helps your understanding then sure. But I'd also look for some other tutorials as well. 
Probably uses PHP4-style constructors or something.
Meh, everything worth doing is worth doing prematurely.
I thought they were pretty clearly stating it that way as a "this is how they often see/phrase it" rather than as an actual criticism of PHP's growth/improvement.
Sometimes people can have a different view without being an "asshat". Often people vote no on these things because they feel there are edgecases or questions that are not fully implemented, or there are implementation details or implications not properly addressed. It's often not because they hate the whole idea, they just think it should be done right.
I'd argue that if there's lots of code required for tests then (in addition to your tests) the SUT needs refactoring. Your tests are examples for how to run your SUT. By having (big) abstract test cases, test setup methods, test helper methods and test helper classes you're saying that to fully use your SUT you have to write a lot more code. At best, you've just got duplication and your extra test code is reimplementing other parts of your application code. This still means you probably have high coupling where you shouldn't. At worst, all you test helper classes don't have tests and work differently to your application. This means you're probably not even testing large parts of your application. If you find yourself writing extra code like complex builders into your tests then extract them as a class and put them in your application. You can then write tests for them. You'll probably find that they're actually useful for your application too. If you find yourself writing helper methods to construct objects then your objects are probably to difficult to construct (likely a SRP violation)! Refactor them so they don't require many dependencies. This applies to setting up mocks too. If you find yourself writing custom assertations then think about whether that check is actually part of your domain instead. Obviously these aren't hard and fast rules, but generally if your tests seem like they need a real factor then it's likely that it's actually the SUT that needs a refactor. This in no way means you should refactor and look after your tests. Tests should be clean code too, just keep them light (like controllers).
That's dirty code. 
That's.. kind of bad. Queries present in the 'actions' and json that's written by hand aren't even in the same league as "good practices".
An alternative solution would be using the null object pattern: http://en.m.wikipedia.org/wiki/Null_Object_pattern
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Null Object pattern**](https://en.wikipedia.org/wiki/Null%20Object%20pattern): [](#sfw) --- &gt; &gt;In [object-oriented](https://en.wikipedia.org/wiki/Object-oriented) [computer programming](https://en.wikipedia.org/wiki/Computer_programming), a __Null Object__ is an object with defined neutral ("null") behavior. The Null Object [design pattern](https://en.wikipedia.org/wiki/Design_pattern) describes the uses of such objects and their behavior (or lack thereof). It was first published in the [*Pattern Languages of Program Design* book series](https://en.wikipedia.org/wiki/Pattern_Languages_of_Programs#Publications). &gt; --- ^Interesting: [^Behavioral ^pattern](https://en.wikipedia.org/wiki/Behavioral_pattern) ^| [^Nullable ^type](https://en.wikipedia.org/wiki/Nullable_type) ^| [^Option ^type](https://en.wikipedia.org/wiki/Option_type) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnpncq6) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnpncq6)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I'd say they *help* understanding the code base you're working on, especially if you inherit it from someone else somehow.
Sounds pretty much like Propel2.
micro framework doesn't mean it not allowed to has db access, auth, templating and the structure, it only aim to keep the core simple but still extensible. you can decide what templating engine you use, db access, etc take a look at https://github.com/xsanisty/SlimStarter , the core is Slim, templating engine using Twig, db access using Eloquent, auth using Sentry, etc
I fully agree with dadkab0ns and dracony. The term "Model" should refer to the Model layer in MVC. The class that holds data should be referred to as Entity, and should have no business logic aside from how to set and unset its properties and virtual properties. The example given in the link you provide is the Active Record Design Pattern, which is now days considered an anti-pattern and it does not follow SOLID. It basically maps one single class to a table AND at the same time to a row of data in that Table. Currently ppl mostly use the Repository design pattern in the Model layer, in which you have a Repository class that maps to a Table. That Repository class has methods which each will have a query inside it, and spits out an Entity or Collection of Entities, where each Entity represent one data row in the Table. So the Entity has no knowledge whatsoever of the persistence layer. For Business Logic you would have Service classes, which are stateless, they receive Entities, perform some logic with them and spit something out (or not). For example, you can have a NumberEntity, and a CalculatorService. The CalculatorService will have a method called sum(NumberEntity $e1, NumberEntity $e2). This sum() method makes the calculation and spits a resulting Entity back.
Return Types for the win, but I dislike the latter position :(
&gt; I think having a resource like this could go a long way to help things. I've been approached about a "reboot" of the PHP Security Consortium - maybe that's what this needs to be? Something like this seems a good approach to me. I think we should take a "be open" attitude, like public GitHub organization etc. It would be great if we managed to wrap up such a set of security libraries as soon as possible, but it requires a lot of job and time. Maybe things needed for this should be set up in parallel, like register the GitHub organization, think about those "security related packages", maybe co-operate with phptherightway.com and in general think about what kind of material should be made available. At start, we could hand pick some free online reading resources and libraries/tools and link to them (under the GitHub organization maybe), like you have done in securingphp.com. This is a good start about useful material: http://phpsecurity.readthedocs.org/en/latest/
&gt; Duck typing is fun, and you can do that in PHP if you like. It still doesn't really effect weak/strong typing which pretty much always refers to scalars as far as I've heard it. Yeah this is what I'm saying. Duck typing *is* about dynamic/static typing, the scalar stuff you mentioned is "strong/weak typing". I'd happily have the ability to add `5 + "5"` removed from PHP :) &gt; I dont know if thats true. It's just a way to see if the class is gonna do the stuff that you think its gonna do. Composition is nice, beats the tits off of deep extension. It is true though. In Java, every type has to be declared everywhere. So as soon as they run into a situation where "hmm shit, it would be nice to pass in cache A instead of cache B sometimes, but cache A doesn't have any types in common with cache B. Oh I know! Let's introduce this new concept of pseudo types that both of them can have, and we'll specify that type in the parameter list instead!". In PHP, you just don't specify a type, *or* create an interface, and everything will work. Just like Ruby, Python and Smalltalk. The desire to identify all the types everywhere just feels like unjustified paranoia to me. Yay we can type more code to accomplish nothing extra now, what a great advancement in PHP. &gt; Yeah you might have methods, but do you have all the right arguments and types for those methods? That can be an arse to keep up to date with. You still have to keep it up to date if you're using type hints though, that doesn't really buy you anything. And surely we're all at least *running* our code right? So we should notice if something like that is broken. Better still if we can run a comprehensive set of tests. You wouldn't notice a broken type-hint without running your code either, since you still don't get those errors until run time. &gt; That and the performance improvements that come with knowing exactly what type of data is gonna be in a variable. They've been fairly huge since 5.3. Type hinting actually adds overhead in PHP and doesn't improve performance. PHP has to test the type hierarchy of every object that hits a type hint, and it has to do it at run time since it's a dynamic language. Without type hints, PHP just tries to call the method and blows up if it's not there. http://stackoverflow.com/questions/3580628/is-type-hinting-helping-the-performance-of-php-scripts &gt; Well if you NEED to know its going to be a certain type of class, then that sounds like necessary coupling. Coupling should be used sparingly of course. I've found in practice you pretty much never*need* to know it's going to be a certain type of anything. You need to know it can respond to the methods you're going to try to call, that's it. Someone should be able to pass in anything they want if it can play the role. This is why test double libraries in PHP are such a nightmare to write. &gt; You can totally do that. *(using magic methods to simplify delegation)* No you can't: https://gist.github.com/adamwathan/fa47bed488b3cc2be6da &gt; The fact that all of this is optional is lovely, and the fact that you CAN use if it you like, and CAN ignore it if you like is excellent. You're right, I'm glad it's optional. This thread itself is proof though that if I choose not to use them, I'm a "script kiddie" and people assume I've never written code in a "real language". I've written plenty of statically typed code and enjoy writing PHP because I don't have to type any of that extra shit! :) &gt; Type hinting - like it or not - is obviously here to stay. Return types is just making outputs have the same abilities as inputs, which is just logical and awesome. This is fair. If we're going to have it for parameters, it is sort of weird to not also have it for return types. I still hate it all though :) &gt; Dunno why people gotta stay stuff like this just because we're having a chat. Do people really think im sat here screaming at my keyboard? I'm just waiting for the latest Archer to download and it's taking a while. :) Haha, nah... Discussions on the internet have the tendency to spiral into raging BS a lot faster than they would in person. I know you're a smart, talented, experienced programmer and I enjoy reading your blog, books, etc. Since we've never met and are just avatars on the internet, I'd rather be explicit that you're still my e-friend and will happily buy you a pint whenever I finally bump into you at a conference :) 
The problem: you're not answering the question. Pretend for a moment that the person asking the question has valid reasons for asking the question. For example: "I need to have charts embedded as PNGs in my emails, and my client doesn't want embedded anything-else. Also, because it's server-side only, no clicking to save on the server." Honestly, there are plenty of reasons for this solution, probably the most common being "my customer said so."
Not for parameter types, no. I prefer using the style above. Using docblocks here feels wrong. Why should I have to use a docblock for basic type information that should be part of the language syntax?
&gt; No, because very little code exists relies on "lolphp" behavior. Depends what you think is "lolphp" behaviour. Is weak typing lolphp? Are specific aspects of weak typing lolphp? Are the separate symbol tables lolphp? Is case-insensitivity lolphp? Changing any of these things breaks so much existing code. 
Thanks for the reply. I don't think I disagree with any of the points in the blog post but I think the focus should be on the SUT, rather than the tests. There's a balance of course (and I'm often more idealistic than pragmatic). &gt; Production code usually only has to create objects in one or two places and they usually have all the information they need at that time Makes sense. The problem is if they need a lot of information to create objects. If they need a small amount then you can easily create/mock it in tests. If they need lots of information to construct objects and there's lots of work needed to test then I'd (generally) favour refactoring the production code rather than the test. At times this isn't possible but I think it should be the first port of call. &gt; When a user registers in the production code, they have supplied the necessary information as input. When you need this in a test, you have to create this data, preferably in a way that doesn't detract from the intentions of the test. Perhaps for integration tests, yes. For unit tests you ideally shouldn't need all this data. Requiring lots of data from different objects shows strong coupling and likely Law of Demeter violations. Eg your NotificationPreferencesTest shouldn't be required to have a User object with a BillingAddress object. Looking forward to the next post :-)
Maybe. I don't use an IDE most of the time. That may be a good thing, keeps me aware of how painful the language is to use without an IDE (it isn't terribly, but argument order is a pain).
any live newbie-friendly example? I just need a simple one. 
Unfortunately, I knew as far as what I read, that it may not be a true representation of a model. But, it was easy, at-least, I understood what the author meant, or was trying to mean. If you have a simple and understandable example as the one offered, please let me know.
Thx, I was to write the same comment. Very confusing comments here.
Yeah, there'd still need to be some kind of standards set on what libraries were included, though..at the very least, a quick review of the code for good practices and any obvious problems. Since it's a more curated list, there still needs to be some kind of moderation to it whether that comes from the organizers of the group itself or from a community "vote" as to what packages are included. I'd thought a while back about a possible list of things that could define a "secure PHP package" as a sort of checklist people could use to ensure their security tool/library was good to go. I wonder if maybe something like this along with a site to submit libraries would be beneficial.
"Post" as in a the $_POST global or a blog post?
You're doing yourself a major disservice. If I could go back a decade and give myself one tip it would be to start using professional development tools sooner.
Clunky in what sense?
Thanks for the nice words at the bottom there. Poke me when we're in the same place. I'm gonna skip some bits because its a biggy and I'm at work, but: &gt; In PHP, you just don't specify a type, or create an interface, and everything will work. Just like Ruby, Python and Smalltalk. The desire to identify all the types everywhere just feels like unjustified paranoia to me. Yay we can type more code to accomplish nothing extra now, what a great advancement in PHP. 1. Everywhere? No, only when it matters. that is the point. 1. It is not accomplishing nothing extra, it is checking to see if the types are what you expect. That is the explicit goal, so it is not nothing. 1. You missed the bit where I said Python is implementing type hinting: http://sdtimes.com/python-3-5-include-type-hinting/ Ruby doesn't have type hinting, but boy do I wish it did sometimes. Manually going back and checking docblocks (if that Ruby bro even bothered to use them - hint: they don't) is a horrendous way to get things done. Whilst I understand the flexibility argument - this whole conversation is about code flexibility vrs being specific, this all only works if your tests are good enough to catch problems instead. Often they are not. &gt; Type hinting actually adds overhead in PHP and doesn't improve performance. PHP has to test the type hierarchy of every object that hits a type hint, and it has to do it at run time since it's a dynamic language. Without type hints, PHP just tries to call the method and blows up if it's not there. &gt; http://stackoverflow.com/questions/3580628/is-type-hinting-helping-the-performance-of-php-scripts Is your best source for that really some random stackoverflow answer? I double-checked with Anthony Ferrera and he said "neither, it has such a negligible benefit on performance that it's basically identical." so I'll eat my hat there. I could have sworn I read about this from one of the core team, but I'm wrong. You're wrong too, so 0:0 on that round. :) &gt; This thread itself is proof though that if I choose not to use them, I'm a "script kiddie" and people assume I've never written code in a "real language". Nobody said that. &gt; This is fair. If we're going to have it for parameters, it is sort of weird to not also have it for return types. Yaaay. Yeah thats kinda the point here. This thread, the OP, or the RFC are not really the place for people to argue whether they like type hinting or not. I don't really care if anyone likes type hinting or not, I've been involved here to say that whilst I am a fan, I like consistency even more. Being able to define return types as well as inputs in PSR interfaces is gonna be awesome. I'll PR the existing PSRs when PHP 7 is out in alpha and add these return types. Its gonna be hawt.
Well, this is what I understood after reading your comment. * something that represents a blog post &lt;?php // the post class // app/model/PostEntity.php class PostEntity{ protected $id; protected $title; protected $author; } * something that gets (and sets) posts &lt;?php // app/model/Post.php class Post { public function getId(){ return $this-&gt;id; } public function getTitle(){ return $this-&gt;title; } public function getAuthor(){ return $this-&gt;author; } public function setId($id){ $this-&gt;id = $id; } public function setTitle($title){ $this-&gt;title = $title; } public function setAuthor($author){ $this-&gt;author = $author; } } So, if I am correct, this can be called a model? 
What /u/hgraca is doing is referencing a lot of design patterns. Developers do this as a way to describe complex ideas without always having to explain them in great detail. The design patterns referenced are: 1. MVC 1. Entity 1. Active Record 1. Table 1. Repository 1. Iterator (in reference to Collection) 1. Service I would strongly recommend spending the money and getting yourself a copy of Martin Fowler's [Patterns of Enterprise Application Architecture](http://www.martinfowler.com/books/eaa.html). This is not intended to be a straight read-through from beginning to end. Think of it more as a dictionary of patterns that you reference directly. Some of these patterns are referenced online in Martin's [Catalog of Patterns of Enterprise Application Architecture](http://martinfowler.com/eaaCatalog/). If you can familiarize yourself with some of the more common patterns and how they work, then you won't have to consider yourself such a "newbie" anymore. :)
Well what you posted looks like it should be all in one class. It looks like all you did is split the properties from getters/setters. Here, let me try: class PostEntity { protected $id; protected $title; protected $author; public function getId(){ return $this-&gt;id; } public function getTitle(){ return $this-&gt;title; } public function getAuthor(){ return $this-&gt;author; } public function setId($id){ $this-&gt;id = $id; } public function setTitle($title){ $this-&gt;title = $title; } public function setAuthor($author){ $this-&gt;author = $author; } } class PostRepository { public function savePost(Post $post) { } public function deletePost(Post $post) { } public function getPost($id) { } }
Slow. More importantly, I'm familiar with vim's key bindings \^^
A great CMS build on top of Zend Framework. I've been using it for about 1.5 years now, and I like it very much.
Thanks, I think I am closer to understanding the model now, I just have yes/no question to sum it up. So, the `PostEntity` class should basically map the Post table. As in all columns should have properties, gettters and setters inside the class. the `PostRepository` does the database queries, like ... public function getPost($id) { $foo = DB::query('SELECT slug, title, body from blog where id = ?', [$id]); return $foo; } ...
The shoe example is the method/class that was removed. The article is better for the removal, but I see how it could be confusing.
I've written a symmetric encryption library that uses mcrypt, though I'm going to be rewriting it to use openssl internally soon. (mcrypt hasn't been patched since '07, and AES-NI support in openssl is sexy) https://github.com/resonantcore/lib/blob/master/src/Security/SAFE.php Basically: * AES-CBC with 128-bit keys (might upgrade to 192-bit keys as a default; the key schedule attacks on AES-256 make me nervous) * IVs provided by a CSPRNG * Encrypt-Then-MAC construction * MAC function is currently HMAC-SHA256 * MACs compared in constant-time (via `hash_equals()`) * AES and HMAC keys are separate (both are derived from the supplied key via PBKDF2) 
All you need to get libsodium running is: # as root: apt-get install php5-dev pecl install channel://pecl.php.net/libsodium-0.1.1 echo "extension=libsodium.so" &gt;&gt; /etc/php5/mods-available/libsodium.ini php5enmod libsodium # restart webserver If you cannot because of your hosting environment, I recommend looking into a cheap VPS (e.g. lowendbox.com).
So, I skimmed the documentation as a courtesy before throwing out the usual "How is this different from Symfony and Laravel" question. I have to say, the ability to define routes as YML is pretty cool, and something that would make a current project of mine significantly simpler. I also like the flexibility of your DI container and the ability to use it without relying on Reflection. I'll definitely be watching this. Good work!
Nope, I have my own crud. So, I will use these tree ways to handle the model for now. thanks
Ha!
&gt; He has a point that's at least worth considering He would have a point if he didn't seriously believe that PHP shouldn't evolve past PHP4. [Look at the list of things he thinks are fully optional for OOP](http://www.tonymarston.net/php-mysql/minimalist-approach-to-oop-with-php.html). There's such lines as: &gt; In decades of programming I have never written any code which would benefit from being rewritten using a generator, so I consider this feature to be a worthless addition to the language. Which if we applied that to the language as a whole, then it'd just be the basic logical constructs. I'm sure there's people that have never written code that uses mcrypt or openssl. I'm sure there's people that have never written code that uses mssql, or postgresql, or mbstring or reflection... should we remove those too? His note about Anonymous Functions, Lambdas and Closures: &gt; This may look clever to you, but if I can achieve the same result with bog standard plain vanilla code then why should I use a previously-unknown alternative that did not exist until recently? This guy is stuck in a rut! He refuses to move forward, and thus wants to drag the whole language backwards to him. He's guilty of NIH Syndrome. If he finds no use for it, it must be useless. If you change the way PHP has worked since PHP4, then he screams at you for doing it. If he can't work out why PHP4 constructors are a bad thing, and can't see why they need removing, then he's clearly never coded anything modern. For example, 5.6 changed mcrypt_encrypt to no longer accept invalid key and IV sizes. This is a BC break, but if you're getting errors due to invalid key or IV sizes, chances are you're doing it wrong. This is BC for the sake of progress. This is good BC. Removing PHP4 namespaces is BC for the sake of progress. This is also good BC, but the guy doesn't seem to see that due to the large rut he's stuck in.
I'm not sure I understand what you are wondering about? Could you restate it, please?
Really? Would they have methods, or would they just be drop-in replacements for the resource? How would they respond to things like `is_resource`?
Ah, yeah, apologies. I removed it because it seemed to confuse more than help. I glossed over TDA which was unhelpful to those who didn't understand TDA, and pointless to those who did. I should have just chosen a road. Thanks for the idea to write a follow-up. I may just refresh this tutorial with some further expositions.
We can be "the better man", so to speak. He does actually have good points in his article but when I first looked at this topic I saw only negative responses. Sure, there are bad arguments in there too, but we need to try to see the good despite the bad.
I agree. It makes it possible to incorporate API docs into your narrative (Markdown-based) docs as well, which is my desired use-case.
I want my 2 minute back.
Think of a `BlogPostModel`. Maybe this model holds all the blog posts in the database. But, it doesn't really hold them--it just knows how to get them. This is "a model" An example of a function you might find in this `BlogPostModel` class: class BlogPostModel { public function getBlogPostById($id) { // Query the database and return the data as an object or array. } } "Model" in MVC represents all the logic and data in your application. It houses them. You could have a directory called Model and inside you would have `BlogPostModel`, `AuthorModel`, `MarkdownHtmlConverter`, etc. Notice the last one is not "a model", but a Class that converts Markdown to HTML. This is still a part of the M in MVC because it is simply manipulating data, or applying logic to data.
When he refers to you, MorrisonLevi, and the rest of us as "minor nonentities" he is asking for a fight, and now he has one. That is one of a raft of insults hurled, it would seem, at everyone but himself in those narcissistic rants he publishes. When he stoops to address the PHP community with some basic human decency, then he will deserve some himself, in my opinion. 
So, now we end up with a lot of projects with just one test in them? 
Jeez, Phil, you really do find the negative where none is intended. I think this is a nice idea.
Only if the PR is accepted.
I'm not talking about him, or about Reddit. I'm talking about *you*. At no point does he say "Ha look this developer sucks". You're putting negative words in his mouth. You do it on a regular basis, with me and with others. At the risk of sounding demanding, you may wish to consider only quoting the words people actually say, instead of quoting the the things they don't actually say.
And yet if this had been the post ... &gt; I just had a cool idea of what we can all do today &gt; &gt; 1) Got to packagist &gt; &gt; 2) Find a League project &gt; &gt; 3) Contribute a single unit test &gt; &gt; 4) Post here to say how you helped improve a League project, that should help them get some exposure &gt; &gt; By contributing a single test to the League we help the League become better! ... you'd've been a lot less pessimistic.
I didn't say he did say "Ha look this developer sucks." I'm saying this is going to be the affect of his movement. I'll find another way to grammatically denote "This is essentially what is being said/done/implied." if quotation marks make it seem like I'm literally quoting, but without those words literally existing directly in his paragraph I had thought it would be fairly damn obvious that is not what is happening.
It what *you think* he is saying. You need to specify that it is *only your opinion* and *you might be wrong*.
The League is far more used to random PRs from people, and we have advertised we're welcoming to input. Random Johnny Sproggs over there might not be so used to it and having somebody slap you for not writing tests is patronising and potentially insulting. It's at the very least presumptuous. Regardless of that, once you know you've been put on a "this developer doesn't know how to test" board you're gonna feel pretty low about yourself. It's the last part I don't like. Anyway: 1. No reason to bring the League into this 2. All League projects have unit tests 3. None of what you said has anything to do with my concerns 4. Take your assumptions about what I want, think or like for a long walk off a short pier 
Well, I guess you might have a point here
Slim: Small, Sexy, Sophisticated.
cakePHP (1.3 at least): full of arrays ;) 
Silex - easy yet powerful. FuelPHP - good ORM, hardly used.
Thanks!
YoloPHP: bEst FrameW0rK Ev4r
[Nice](http://docs.niceframework.com) is nice.
I wouldn't be one of em :) Silex is fantastic
Symfony: George Costanza's wallet
ZF2: ServiceManager is god
Frameworks - stop chasing the dragon
All frameworks suck? :v
Ohh. And put that markdown through http://couscous.io then and voil :p
Okay, I'll grab your stuff, then you grab that guy's stuff, and so on. 
how is silex not easy....
Laravel: I'm in love!
Although I personally would **love** scalar type checks in PHP, I noticed that the survey doesn't have an option for "Would prefer to not have strict types" or even an option for "Doesn't make a difference to me"/"Could care less". Lacking those options means that someone might vote for one of the available options due to lack of choice, and skew the numbers. ... Just a thought.
laravel - fun with namespaces codeigniter - feels old, tired Yii - made in china 
&gt;Especially when there is something as convenient as rails. I just picked up PHP and I think it's incredibly convenient. Can't comment on rails though
concrete5: Just make pagelists Drupal:Sharp Learning Curve Codeigniter:Simple, libraries, classic
Aura: [Aura](http://auraphp.com/), [Aura](http://auraphp.com/), [Aura](http://auraphp.com/) (sorry couldn't resist)
Do everything ugly
Symfony2 : Dependency inject everything Silex: strong simple backbone
Well, let's see, in exactly 2 words (one of which is common to them all): * *Symfony*: Overcomplicate Everything * *Laravel*: Misname Everything * *ZF2*: Do Everything * *CodeIgniter*: 1999 Everything * *CakePHP*: Misunderstand Everything * *Aura*: Abstract Everything * *Silex*: Route Everything * *Slim*: Compactify Everything * *PhalconPHP*: C-ify Everything * *WordPress*: Blogify Everything * *Drupal*: Contentify Everything * *YoloPHP*: Enjoy Everything
VanillaPHP. best evar. 
Typo3 flow : Flow Flow Flow
CakePHP - "Fucking hate Cake!" (actual quote, from a RoR developer who recommended Cake at the shop we were working at, because of its similarity to Rails)
Laravel: get paid fast.
Yeah, that example *was* less than stellar. If at some point down the road I encounter `getFirstComment`, `getSecondComment`, or anything similar I'll have to blame myself. Can you explain why you consider avoiding `null` a good thing? I agree if you're expecting a collection of objects returning an empty array would be appropriate. However, if you will never need to return more than a single object, what would be better than `null` if no object was found? Thanks for your rfcs btw  if they (and scalar type hints) pass, PHP7 is going to be freakin' sweet.
You forgot Kohana: Static Everything
Codeigniter: sad history here Wordpress: Stop. Just stop.
I'm reading more and more, and I honestly can't believe this guy is a functioning software developer in society. &gt; This latter update required the use of the VI command line editor with which I was not familiar. If you have only ever used a text editor on Windows which has a GUI then a Linux command line editor with its illogical and unintuitive syntax can be quite a culture shock, so I had to ask for assistance which was provided by one of the other developers. He has been a software developer since the 1970s, and has used Linux extensively and cannot manage his way around VIM without help. 
This isn't really constructive dude...
Yii2: my first love
Love it, absolutely spot on!
"Help, I'm fat" - zf2 "Yo, I'm hip" - Laravel "I'm pretty standard" - Symfony "I have arthritis" - CakePHP "Me go zoom" - Phalcon 
perfect! lmao
I have a real issue of not allowing null on the typed functions, espically on class return types.
For using Symfony I would suggest doing the Starting with Symfony series on https://knpuniversity.com/, this gets you a great understanding of how to use Symfony. Once you have that understanding you can start diving deeper into the inner workings, e.g. when using a controller method jump into the base controller, find the name of the service you are ultimately returning, search the vendor folder for where that service is defined (would be in a Resources/config folder), from there you can find the class/es that make up the functionality you are trying to understand. Its a long job getting to understand the inner workings of symfony, and maybe with knp university you might be satisfied with a level of ignorance to it. Alternatively you could checkout Laravel, it is much easier to understand the inner workings of, e.g. start in public/app.php, work through the various included files and dive into the Foundation/Application class. Most facades are easy to find their base class, and if not, look in their facade class for the facades actual name (some facades are alias's) and look in your App class for what class relates to that facade name. Symfony inner workings are very complex, exploring Laravels inner working really helped me understand what symfony was doing.
That was a whole lot of nothing.
Hooray the same old clickbait as last months/years top frameworks post. When the fuck do people wake up and realize there is more to PHP then frameworks and CMS systems. 
ZF2 - fool me once shame on you, fool me twice shame on me Laravel - we don't need no code completion, cause we got some nice facades (you need Pink Floyd background for this)
Most frameworks: Collective wisdom
This is kind of a tough problem. It is for sure that "community in general" can not be let to vote, because voters need to be "qualified" to cast their votes. But here comes the another problem, who judges who are qualified to vote. Maybe the best way to go with this is open discussion about whether a package should be considered "secure". I'm sort of against any checklists, since they can sure catch errors and bugs and vulnerabilities, but they by no means can tell if the software is actually secure. That said I'm all open to suggestions and discussions and I'll try to give as much input as I can (whether it counts anything or not). As for the start, I'd bug @ircmaxell to finalize https://github.com/ircmaxell/RandomLib (with few modifications, i.e. drop the different strength generators and just offer only one which is urandom or alike and drop as many lines of code as possible to achieve "as simple as possible" approach). This library would be a good addition to the list, especially since unfortunately PHP lacks such features.
&gt; [George Costanza's wallet](https://www.youtube.com/watch?v=yoPf98i8A0g) For the lazy!
Off-topic, but what did you use to create that .gif? Could do with something like that for some docs I'm writing.
Guess he's writing less/sass style css?
I hate that too... I'm writing margin and changes it to -max-resolution, wtf?
Try Licecap
Sometimes `null` is the best option; I don't want to give the idea that I think `null` should be avoided *at all costs*. Experience has just shown me that consciously avoiding `null` seems to result in fewer bugs and better APIs.
The concept is interesting, but I'm concerned it runs against the [Inversion of Control](http://en.wikipedia.org/wiki/Inversion_of_control) principle the same way that a Container-Aware class does. An object shouldn't have access to the entire config system, the application should determine what information the object needs and inject it into said object. For example: class ConfigurationAwareFooService { /* snip */ public function __construct(Configuration $config) { $this-&gt;directory = $this-&gt;config['foo.base_dir']; $this-&gt;fileType = $this-&gt;config['foo.default_file_type']; } } Contrast with: class DependencyInjectedFooService { /* snip */ public function __construct($baseDirectory, $defaultFileType) { $this-&gt;baseDirectory = $baseDirectory; $this-&gt;defaultFileType = $defaultFileType; } } In addition to the fact that the values in the Configuration interface may change between the object instantiation and when the object is actually used, it's a lot harder to look at the public API of the class and understand what dependencies.
Used quicktime to record into mov file and then an online converter to go from mov to gif.
Heh, yeah. To be honest, I'm sympathetic to the general problem - maybe the company was badly organised. However the poster's irascible nature doesn't inspire confidence - it may be a case of "it's everyone's fault but my own". 
yes
Emmet and different packages for the framework I use
Vintage mode is a must for me
I had this same problem with IntelliJ IDEA too. I can't remember exactly what my search terms were to find out what was causing it, but I remember that it was an issue with the "Code Completion" portion in my settings. I don't experience this issue anymore, so hopefully these settings might help you out: http://i.imgur.com/V7sLoLC.png 
old school op
I primeraly use PHPStorm since they have an [free student licence](https://www.jetbrains.com/student/). But for little scripts I use Sublime text 3 with 2 packages * Ofcourse the Package Control * [SFTP](http://wbond.net/sublime_packages/sftp) (ftp download / edit and push on save)
No, if `$foo` had not been defined the `if ($foo)` will trigger an error: php &gt; if (!empty($foo)){} php &gt; if ($foo) {} PHP Notice: Undefined variable: foo in php shell code on line 1 PHP Stack trace: PHP 1. {main}() php shell code:0 Notice: Undefined variable: foo in php shell code on line 1 Call Stack: 12.2399 223768 1. {main}() php shell code:0
I hear Silentcast is decent
Holy shit I thought that happened only to me
Pick up something lower level like C/C++ first, honestly. If you pick a base level language like that up, it gives you the understanding you need for literally every other compiled and scripting language out there.
Hm, ok, thanksI read similar advice online all the time, but didn't know if it was worth it to learn another language that I don't think I currently have a specific use for and don't foresee needing in the future. Thought it might be best to dive right in with something that I can get started on right away!
they are not exactly the same and don't forget about isset($foo) :p
Thanks for the answer. Then I might look into creating a database to prepare for the future.
Pay or pirate Snagit. Great software so I recommended paying if you like it.
Why phpstorm?
Great! I will try all 
The recommendation against php as a FIRST language is based on how it will effect your ability to think about all programming problems. To quote one the most influential founding fathers of computer science (Dijkstra): &gt; It is not only the violin that shapes the violinist, we are all shaped by the tools we train ourselves to use, and in this respect programming languages have a devious influence: they shape our thinking habits. This circumstance makes the choice of first programming language so important.
Don't misunderstand me, I love C, so freakin' much ... however ... Start with something that is relevant, C/C++ are not useful for tinkering around with company websites, it's much easier to learn when you have something to aim for, and OP does seem to have something to aim for.
Refactoring tools, and almost as customizable as Sublime text.
It should be fairly trivial to implement a compatibility layer that translates mysql_ to mysqli_ or even PDO covering most (if not all) of mysql_ completely in userland. As long as PHP 7 doesn't reserve/hijack these function names to error a message "Those functions were removed, please use mysqli_..."
When I was getting my bachelors, I first learned C++. Then I learned Java. Java was a pretty nice language to start on since its entirely OOP and we had MVC beat into our heads constantly. Naturally, Java as a web language is pretty small (I have only run into a handful of JSP pages in my lifetime) and there's also some other things like JavaFX but it helped me understand threading and general OOP practices.
Ah, I think I have a better understanding of what's going on now. The Configuration parameter isn't a single *application-wide* collection of configuration data, it's a flexible container. The application still decides what goes into said container, so it doesn't violate the IoC principle (as long as you don't get lazy and just show the app-wide config into it). I'm a big fan of having class constructors clearly lay out dependencies, so I'd still use one. But I'd also have a static factory method that uses the container interface. For example: class FooService { /* snip */ public function __construct($baseDirectory, $defaultFileType) { $this-&gt;baseDirectory = $baseDirectory; $this-&gt;defaultFileType = $defaultFileType; } public static function fromConfiguration(Configuration $config) { return new static( $config-&gt;get('base_dir'), $config-&gt;get('default_file_type') ); } } And have the application's DI config would just call the static method: 'Foo' =&gt; FooService::fromConfiguration( new Config([ /* etc */ ]) ); 
@ is also dangerous as it will silence virtually any error, not just nonexistance.
Numbers (3 rounds averaged): if (@$foo) {$a = 1;} 10000000x = 7.33828 seconds if (empty($foo)) {$a = 1;} 10000000x = 0.897775 seconds if (isset($foo) &amp;&amp; $foo) {$a = 1;} 10000000x = 0.706004 seconds
Hmm. What other error, other than undefined notice, could occur from if (@$foo) ?
You'll never know.
Joomla: Fuck Everything
Yeah if you use it like a dweeb. Laravel has full dependency injection whenever and where ever you need it. Or if you're building a super quick prototype app, go ahead and static it up to get it done in no time.
There's only so many errors that can occur in php, on an if statement
And you're absolutely sure that none will be introduced in the future?
 &gt;quicktime lol
Fair. But it's going to be a year before PHP 7 is released, and another few years before PHP 5.6 is in EOL, so that gives anyone plenty of time to switch from ext/mysql to ext/mysqli or ext/pdo. It's really not all that unreasonable to expect people to upgrade over the next few years, and as others mention, it _has_ been deprecated a long time already. Here is a migration guide from 2011: http://www.sitepoint.com/migrate-from-the-mysql-extension-to-pdo/
Hijacking first comment (sorry!) to say that I found why it expands this way and how to disable it: http://www.reddit.com/r/PHP/comments/2smbvb/php_storm_annoyance_why_does_it_change_this_when/cnr6mp8
Yes, thanks for this. I can find so many recommendations and advice all over the place online, but haven't been able to narrow down exactly what would be the most beneficial to me professionally, in my current position, for the next several years. I'm never going to be a programmer (unfortunately....wish I would have taken my college and early career in a different direction, but I'm not sure how feasible that is now...), but just want to learn something new that can help me with things I'm actually interested in spending more time on at work now to help me there in the future.
You have got a point there. Personally I'm not affected, the business i am working for isn't affected, too. Maybe I still have an ereg call in a very old app on my server, but that's not an issue ;)
&gt; Oh, and once you've learned PHP, assuming you want to proceed to something considerably nicer, I recommend Laravel. Laravel is PHP, in its simplest form, but it is much more than that. Using Laravel is like floating in PHP Heaven. hmm. This whole piece just irks me. Honestly /u/lionvsheep, i'd say learn java first... Pretty good intro into programming, and OOP. It can also be used for web development.
it does all of the stuff above, by default. The time you save using PHPStorm is crazy. Its a godsend. For simple text editing though, it can be a bit much. I actually prefer atom over ST
Omg, I can't possibly fix the hundreds of mysql\_* references to mysqli\_* . I mean, even if I was comfortable with mysqli\_* functions and could successfully fix 1 per minute, that would take me FOUR hours. Do you think my precious time here on earth developing sites for clients paying money for my services has ANY room for updating my legacy code and adopting better practices? Pfft..
I don't hear anything from Silentcast
Thank you!! This needs to be at the top, let's do it people!
I recommend against PHP. It's a messy language and languages like Java and C# will aid you understanding common patterns for code quality. 
Example: For some unknown reason, instances of SplFileInfo can't be evaluated as booleans. No idea why, it throws a fatal error. So if `$foo` is an instance of `SplFileInfo` that may or may not exist: if(mt_rand(1, 2) === 1) { $foo = new SplFileInfo('some/file'); } if(@$foo) { //this will never execute } An edge case? Sure. But if ensuring a variable is declared requires more than a trivial amount of effort, you're doing something wrong.
I really don't know if you're serious or joking :D
You forgot the [ba-dum-tss](https://www.youtube.com/watch?v=6zXDo4dL7SU)
yes! 
Yeah, you could say phpstorm is good. If you're building applications with only 3 files, you can use sublime, Simple and fast. But if you're working on an project with a lot of classes I should suggest an good IDE. You could use netbeans, or for the sake of it even Eclipse. But they are both very bloated. The guys of jetbrains have taken care of phpstorm in an good way. Just an nice IDE with isn't to bloated, is quick and not buggy at all. If you have problems with the license, you can pm me, maybe I can help you with it. 
Yes, surveys *are* hard. Also, I deliberately only announced this on StackOverflow Chat... if I was going to publish it other places I'd use something more sophisticated. The poll was pretty useless anyway. Please remove this, /u/salathe.
Isn't it enter to autocomplete, not tab? I'm sure I always press enter... Edit: Checked it because it was bugging me. It is enter.
Pretty unanimous there. Good. I can't believe some of these were @depreicated since 5.3 and STILL existent in 5.6... I was under the impression @depreicated features would have been dropped in the next major version (in PHP's case, that is a +.1 release).
I love how dmitry's only qualifier on what should be accepted is "does it in any way, no matter how small, break BC". Voting against removing support for # comments in ini config files is just ludicrous.
This may be a stupid point, I'm not sure because I'm not really a professional but: Wouldn't writing a compatibility layer for mysql_ to PDO sort of defeat the purpose? Seems to me they're trying to push people toward more secure prepared statements, and if people are just appending raw variables to strings instead of using those prepared statements, I'm not sure what happens. Plus you'd have to enable multi queries for max compatibility because I'm sure somebody somewhere is doing it, which leads to more problems potentially. I might be wrong because I truthfully haven't tried to SQL inject PDO using straight string concatenation, but I don't think there's any barriers if you aren't using the prepared statements.
Shouldn't that be if (!empty($foo))
Ooh, __cast($type) exposed to userland would be nice! We could do lots of fun and dangerous things with it like BoolWithReason or convert numeric Value Objects to native scalars. 
If you chose to move to a version of PHP that doesn't support what you need then you have to *find* the time to refactor.
I think removing features would *require* bumping the major version number (according to SemVer which I'm sure PHP follows) because it's a backwards incompatible change.
There have been plenty backwards compatibility breaks through the 5.x code line. If I recall right, 5.3 hurt a lot of people with older code.
It's the only one that doesn't suck!
I have been writing raw queries since I started learning PHP and I enjoy it for the sake of learning the language. However, I am looking to start learning a full web framework. The only thing is I haven't been able to locate a proper book source/tutorial on using Laravel or Django (the obvious choices for me) for windows. Most resources are focused on unix. Do you have any recommendations? 
&gt; I think removing features would require bumping the major version number That idea has been around way before semver, fyi. It's a good one that semver incorporated and formalised.
Well, you might not like to hear it, but you should really learn to do stuff on Linux! I've actually never seen a PHP or Python gig looking for someone with Windows experience and no Linux experience... The vast majority of the web world runs on it. I used to do everything on Windows as well when I was younger, thinking that Linux was really complicated. But the truth is that it's not. The Unix way of doing things actually makes a lot of sense - much more sense than the "Windows" way does. The easiest way to go about doing this is to grab the free version of either VMWare of VMBox along with an ISO of whatever distribution of Linux strikes your fancy. It's extremely to get this all set up on Windows. Ubuntu is usually a good distribution to start with - they have great documentation and include a lot of stuff out of the box so you can get straight to writing code instead of futzing with the system(but that hardcore nitty-gritty stuff is there when you're ready for it). You also don't need to mess with dual-booting or having a dedicated machine by doing it this way. If you can get over that hurdle, the(web development) world is your oyster. Seriously, becoming comfortable on Linux is a great tool to have on your belt and there's no reason not to give it a whirl these days.
No. Go with python/ java. Python is more at solving problems. Java is mostly at d3sign patte4ns and yeah.. solving problems.
I definitely recommend PHP, and laravel is a beautiful framework to help you along in proper programming practices and familiarizing yourself with the MVC model as well as templating. For the rest of you talking against PHP I think you need to get real and look at what the OP is looking for. He wants a web language and you guys are recommending C# and Java which are great languages, but not really what the OP is asking for. Also PHP doesn't have to be messy anymore, 5.6 has brought it up to par. Hacklang and HHVM also adds more ability. With PHP 7 on the way this language isn't going anywhere. 
Do you need shampoo after using or what?
ninja?
To the question in the title: almost certainly not. PHP is good at a certain narrow slice of problems, and "educating a new programmer" is not one of its strengths. For a variety of reasons that it's a bit late in the day for me to enumerate right now. The best introduction to programming (and maybe more importantly, to *computational thinking*) that I've found so far is [How to Design Programs](http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html), which is sort of the spiritual successor to the much-beloved [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sicp/). Despite (or, perhaps, thanks to) being presented in dialects of Scheme, which is little used in industry, the lessons of HtDP are applicable to programming in every language. It's the introduction I wish I'd had at the beginning of my career.
&gt; We could do lots of  dangerous things Like emulate Perl, and have an object that's 0 but true? No thanks.
Exactly. If you can't do it now, you won't be able to do it at some vague point in the future. Code maintenance is problematic to get past management in a lot of places, especially if you're developing stuff for external parties. 
5.4 as well. Call-time pass-by-reference being dumped doesn't sit well with some of the code bases I'm working with...
phpstorm is a very good ide for php. i use that for php programming at work. sublime text is a text editor for all kinds of languages. for general scripting/programming, i use sublime text.
Exactly, ~4 hours for a relatively trivial, future proofing update is nothing. Hell spending 10 minutes at the end of a working day revisiting debt is less than some do regularly
I use it, and a bunch of packages. The problem is at least one of them is broken at any one time, causing oddities. I've run through and uninstalled/reinstalled - eventually the fuckups come back. It's silly things like randomly deciding not to indent when I hit enter, randomly autofilling method names with what it thinks you were looking for, etc. Right now I've got the following installed: - Bracket Highlighter - Dockblockr (Buggy as hell but the alternatives are worse) - Gitgutter - PHPCS - Sass (Broken on ST3 as of the last update/release) - Sidebar Enhancements - Sublime Lint - Appealr color cheme - Flatland dark theme I've been meaning to try out PHPStorm as people keep raving about it and I don't want to yet again be that idiot that dismisses it based on stupid (and inaccurate) thoughts on what it does / how it works / etc. 
PHP's backward compatibility policy as defined by the [release process](https://wiki.php.net/rfc/releaseprocess) only took effect starting with PHP 5.5.
Time to see if a perl regex script can fix that.
The advice in the article is not wrong - copying a pre-made sqlite file is often quicker than running a bunch of sql commands every time, even in memory - but it really is the wrong approach to take when you have a problem with slow tests. You should look into phpunit's @group annotation, which lets you exclude particular groups of tests that are slow and don't need to be ran often. Alternatively, use the @small, @medium and @large annotations which work the same way. PHPUnit also has a --filter option which you can use to run specific methods, and you can pass the path to a .php test file to run only that test. phpunit tests/MyTest.php phpunit --filter=testSomethingSpecific In a bigger perspective, consider not using PHPUnit at all for acceptance testing - it is primarily a unit testing framework. Do you really need to re-create the database for each acceptance test? The rules of purity that apply for unit tests don't apply here. &gt; Unit testing just got a whole lot more accessible, and sane, for me. If your test requires a database it's really not unit testing.
Oracle made a pretty complete [mysqli conversion tool](https://wikis.oracle.com/display/mysql/Converting+to+MySQLi) for that. But do yourself a favour and don't. Switching to mysqli is pointless, unless you also introduce parameter binding - which is completely bonkers with mysqli. It'll just be another dead end. Alternatively consider [pdo_query()](http://stackoverflow.com/a/20767765); which is easy to switch to with a simple search+replace, as it provides a nearly 100% mysql_function-compatible interface. And it laters allows to switch to plain PDO step by step.
I'll start with saying I've got a lot to learn still with unit testing, so thanks for the tips I guess I should have mentioned that since I'm not anal about my testing, I use gulp to automatically run all my tests for me as soon as I save a file, so I can just use that to let me know if I've busted something. Otherwise I know I'll forget to run my tests for days on end, then realise I've broken something!
that's exactly what this article is suggesting ;)
Yeah, I'm kinda new. I tried a few times working with arrays but I didn't get it to work. :P Anyway, thanks! I'll try out your code and make it fit the way I like it!
I don't know Laravel at all, but surely there's a way to use actual database fixtures rather than using system level cp and rm commands to manipulate SQLite files, right? Also, your functional and integration tests (because thats what these are, not unit tests) should probably be using the same database that your dev/production environments use.
&gt; surely there's a way to use actual database fixtures rather than using system level cp and rm commands - http://php.net/manual/en/function.copy.php - http://php.net/manual/en/function.unlink.php 
Fair enough. A simple app is exactly the kind of thing we'd be excited about. Also monetisation isn't our primary goal, just want to fill a niche/do something original. 
Make a site you'd enjoy using, that's all. That's challenge enough.
It just surprises me that for laravel people it is normal to run all migrations up and down for each test. No wonder why this article is a breakthrough to them.
Cheers for the snarkiest comment yet. 
Working with arrays (and objects if you do any javascript) is going to be one of the cornerstones of web development work. If you aren't comfortable with them, you need to practice every chance you get.
Sure. You can choose a single type of API, persay... RESTful. Then build a client and show the students [Programmable Web](http://www.programmableweb.com/) and have a project that reads API data and displays it in HTML. 
Didn't say I minded at all.
Touch
Not in the US, and this is a university project, so involving a third party with be inappropriate. 
Maybe a place to start is writing some documentation about what the libraries/projects are exactly supposed to do. If you want your open source applications to take off, documentation is the most important thing.
Well, that's why we have CI tools that automatically run the test suite every time you push, and why you don't merge a pull request unless it's passing CI and has new tests (and docs and metrics and alerts) as necessary.
I tried PHPStorm for just the refactoring tools but none of it seems to work. If you know of any good tutorials then please... The kind of refactoring I'm looking for is moving a class from one namespace to another and that all references to that class are then updated along with it, you know, like Java Eclipse has been able to do since 2001. 
I know it is, but its not finished yet. ...edit....and pligg uses sql, which im trying to avoid, also dont ask why im trying to avoid it, as there will be an eerie silence
+1. Also tests. Flicking through some repos, I don't see any tests. They are absolutely important, and are great documentation by themselves.
Inappropriate? Working with a client is one of the most useful educational experiences you can have, and is *incredibly* appropriate for any project-based course.
Your post. 'it sucks'
What is the are the main difference between Active Record and Data Mapper? I will deffentlywill have a look at other ORM and how they work.I wish to build the whole thing by myself because its really something i don't understand wish i could.
Don't use sqlite, it has scaling limitations. Mysql is super easy to setup, what issues are you having?
You failed at a simple task.
LOL, mostly dependencies errors on apt-get, still fixing those.
Title is misleading. I've been using that trick for a while (well, http://php.net/manual/en/function.copy.php). You can also save some time by writing sqlite db file in RAM via mounted ramfs. When it still wasn't enough speedup for me I also used `fastest` to run functional tests in parallel and cut down again 3/4 testing time: https://github.com/liuggio/fastest But application still grows and I had to start writing more unit and integration tests instead. Full functional test only when its necessary.
Yeah at least those would be faster than spawning 2 processes every time.
Also, consider MariaDB. I'm assuming you're running Ubuntu from your package manager (apt-get). It's a drop-in MySQL replacement. Have you considered a Red Hat derivative like Centos or Fedora? MariaDB is default in Fedora and easily configurable in Centos by adding the repo.
It's generally a bad idea to admonish everyone else before they've said anything. If anything, it shows that you *know* your project sucks, and are being defensive about it.
Even though I don't want to agree, until i fix all the bugs, it does 'suck'
The session locking is needed if you don't want to lose data when 2 concurrent request (from the same user) needs to write the session. Back in the day, everyone used the native PHP session driver which locks the file and will cause the 2nd request to wait the 1st one freed the session file lock. With modern framework now all having abstractions to change where the session is stored (file, db, redis, memcached, whatever...) they need to emulate this lock to prevent data loss issue. A lot of of them didn't implemented it and have had this problem at some point. Hopefully they all work fine now.
Just letting you know.
Then, thanks, I knew it was super buggy, which is why, earlier, while doing some other stuff, I thought, "XSS" 
It's stupid to avoid SQL in this situation, unless you have a very good reason for it (and I can only think of very few ever, none which apply to you). So please enlighten us?
as a label to what? 
Try defining a() outside the class ( it will work) . or add an additional : so it's Foo::a() and you'll get an undefined static method error
What do you mean by loose data? Data that isn't tight?
Don't help nonprofits for free...
Really like the RFC voting system, but I would be interested to read the reasoning when voting "no". Not to start the discussion but to understand the reasoning of those people.
For all that it does PHPStorm is lightning fast. It's also regularly updated. The refactoring tools are amazing, as are the analysis tools - how they reason so deeply about a dynamic language is mind blowing. On an old code base, find duplicates, then refactor to extract duplicates is almost like magic it works so well.
I am not having problems with other calls though. Why would this one be different from the others?
Every time someone shows you how it can be better - learn. I have been programming for over 15 years and (like pan069 said) still learn from other people's solutions. Make sure to fully understand the "better" solution. Not just the code, but the thought process behind it. Definitely the most important thing in programming in my opinion.
Nobody is downvoting you because you're wrong, they're downvoting you because you're a dick persay
Okay, thank you kind sir! 
I think it's supposed to be "lose data"
I tried using PHPStorm, but found it to be too heavy. For that reason, I stick with Sublime Text. Granted, I need more memory on my 2011 MBP with 4 GB.
I wonder if locking the whole session is too much? Could each session write merge the session actions (add/update/delete data items) into the current session instead? It's not foolproof, but I would think would result in less lost data. 
Should be fine with redis as the issue is due to file locking. You can resolve it pretty easily even with file sessions. In Silex you can just: $app-&gt;before(function (Request $request) use ($app) { $app['session.storage']-&gt;save(); }); I guess something similar can be done in Symfony
I totally agree with the author that constructs should be left as they are 
[`echo yolisp(y('.', 'lisp ', y('.', 'is ', 'fun')));`](http://yolophp.computer)
great article about a problem I never thought of :D
SpiffyFramework: Who are you?
I don't know how much experience with PHP you had back then, but if it was a lot, the changelog of the last few big versions of PHP may be a good place to start: http://php.net/ChangeLog-5.php Just check what kind of big things have changed, and go and do research from there. For all the non language specific stuff of PHP (composer and stuff) I suggest you start by reading http://www.phptherightway.com/. It gives you a good overview about what tools are used frequently nowadays
Darcula
Same here! 
&gt; Make sure to fully understand the "better" solution. Not just the code, but the thought process behind it. Definitely the most important thing in programming in my opinion. Oh man, that's so critical. When someone comes and shows a better way, *do not let them leave your desk* until you fully have what you need to do it that way next time.
I use a slightly adjusted version of Twilight. 
Yup, I use the Dracula theme with intelliJ Idea
Laracasts.com highly recommended. It focusses on laravel, however most of the principles are true for every modern php application. Also jeffrey is an amazing teacher.
Try Twilio.Com
&gt; http://php.net/ChangeLog-5.php That's mostly just bugfixes. The migration guides are more useful, particularly their "New features" sections which give a nice summary of stuff each version added: * [Migrating from PHP 4 to PHP 5.0.x](http://php.net/migration5) * [Migrating from PHP 5.0.x to PHP 5.1.x](http://php.net/migration51) * [Migrating from PHP 5.1.x to PHP 5.2.x](http://php.net/migration52) * [Migrating from PHP 5.2.x to PHP 5.3.x](http://php.net/migration53) * [Migrating from PHP 5.3.x to PHP 5.4.x](http://php.net/migration54) * [Migrating from PHP 5.4.x to PHP 5.5.x](http://php.net/migration55) * [Migrating from PHP 5.5.x to PHP 5.6.x](http://php.net/migration56)
Which is fine. I would rather be a dick than a teacher that doesn't know what the hell they are talking about. My confusion is with the other people who think that I should sugar coat my disdain for an idiot teacher. I just forgot which subreddit I was on.
peacocks in space https://github.com/daylerees/colour-schemes
Looks like a solid, professional, serious deployment tool. If you need something much simpler, and you're on a VPS, check out the one I've wrote: [Simple PHP Git deploy script](https://github.com/markomarkovic/simple-php-git-deploy/blob/master/deploy.php) .
Do not listen to other posters. It is true that if you want to scale you'll need SQL. But it is absolutely false that your website will implode if you have as little as a couple thousands visits per day. If done correctly! So I'll focus on improving your technique instead of pushing you to rewrite: * Make sure your flat files are outside the public tree. An htaccess is nice, but it's not necessarily portable. Don't be afraid to serialize everything, it most cases it will be faster than custom format. * If you can't put the files outside the public tree then I think the next best thing is to add &lt;?php die() ?&gt; on top and give them the .php extension to make sure they can never be read directly. * You'll need to implement some sorting functions yourself, try to make them generic and try to make them work on multi-dimentional arrays (I think PHP.net has some examples in the array sorting functions pages). * Take care of the XSS issues, I don't know how you render your files but it can be as simple as buffering the output with ob_start then inject a token on all forms with str_replace('&lt;/form&gt;', '&lt;input type="hidden" value="' . $token . "'&gt;&lt;/forml&gt;', ob_get_clean()); Then, again put very simply, it can be a simple matter of if ($_POST &amp;&amp; $_POST['token'] !== $token) die('XSS'); on top of your main include. * For presentation you have two choices: Use a well known PHP markdown parser or accept html directly and sanitize it (at this point I'd recommand against implementing it yourself, even if it's fun) * Again don't listen to people going against SQLite. It's a learning project and if you master sqlite, you'll master mysql when the time comes. Really I wouldn't bother about scaling issues for now, we have a client receiving 20k page views and 1.5k posts per day running a forum powered by sqlite on a cheap VPS. Nothing extraordinary, but leagues ahead of your intended traffic. SQlite is way more powerful than people think.
PHP has came a long way in that time. Tools such as [Composer](https://getcomposer.org/) have brought a lot of legitimacy to the PHP scene and this has made it much more viable as a platform. I have used [Symfony2](http://symfony.com/) professionally for a couple years now. It's a framework that is steep to learn but highly valuable to know. There's lots of open-source functionality "bundles" that can also be used to bootstrap a new application. Symfony is great for learning concepts such as routing, dependency injection, separation of concerns, passing data with services, and using an ORM (such as [Doctrine](http://www.doctrine-project.org/)) instead of doing database work by hand.
i accept html directly and sanitize it. bold, center, works fine some of my flat files are in the public tree BUT those are only the posts, which is fine. xss is killed by htmlentities sorting is done via alphabetical and date so that works, but its biased, new posts beginning with the letter 'a' will be first in the list, while 'z' will be last it has a sort of broken, but working search feature.
Just how exactly? They tell you the type... That is it! you then need to lookup the type as you would have had to without. It's not exactly doing the heavy lifting for you. Also your argument for junior programmers to be involved in code they do not understsnd is inclusive, but possibly ill-advised
Thats not a rebuttal as docblocks do not affect the information or interpretation of code by a compiler. Typehinting and Docblocks solve different problems
The quote I posted was from Dijkstra's response to the budget committee's decision to force Java unto his comp sci students. He was worried that if they learned Java as their first language they would be beyond redemption ;P
I don't agree with this at all. PHP has changed **significantly** over the last 8 years. Trying to say that it hasn't means you've either not looked, or you've forgotten what PHP was like 8 years ago.
Horrible pattern, null in most langs is too non-descript. Object constructors should always return objects, just like getLatest should nearly-always return an object of the correct type. If you are searching for comments and none are found try having a searchResult object with a count of results and an array of objects, or returning a blank comment object with exists method or similar method for testing. Makes code easier to test &amp; use IMHO. $user = new User(); if ( ( $comment = $user-&gt;getFirstComment() ) &amp;&amp; $comment-&gt;exists() ) { // echo "We have comments&lt;br&gt;\n"; } else { // echo "No comments&lt;br&gt;\n"; } 
I have just tried peacocks in space, for some reason the font is way too small.. that does not match peacocks in space screenshot.. any idea? 
Learn to use Symfony, and figure out how the components work. Comb through its source code and understand it. Just being able to apply those alone in your work projects will be more than enough to make you a lead engineer in most places.
I thought scalar types were not being included...
There's a chance.
It really hasn't. Lots of new capabilities that lend well to large scale projects. Namespacing (one day someone will fix the brain-dead syntax), Composer, Traits, closures, lambdas, closures, and the shortcuts! Like the simple array syntax $a = []; That hasn't changed PHP so much at all, just made it easier. As an aside, individuals from reddit and many bloggers, claiming that PHP has really changed, are the same people promoting every new practice as the latest and greatest thing that you should be using wherever possible. It's poisonous and immature. 
I tweak Monokai (to make files with VCS changes more visible) and use the Color IDE plugin to make all tree / tool windows the same colour background. 
I have to agree, I came back to PHP after a 5 year break. The new features while nice are still bolt ons which you can ignore if you want, still if you use them they will make your life much more pleasant.
I want to add [PHP Objects, Patterns and Practice](http://www.apress.com/9781430260318).
I'm loving sublime text, but I'm probably not using half the more advanced features...
its not a curve if it never changes the sharpness. Drupal learning curve looks like / | / / | / / | / / | / / | / new version 
CMade Yii::in CChina
Though mentioned Phalcon. I've been keeping my eye on it as well. The team is getting ready for version 2, and there is a beta package available. However, I haven't found any docs for the new version. My advice on this front is to hold off Phalcon until v2 hits
And old guy eh? Heads up! PHP4 constructors are going to be deprecated...
&gt; I'm self-thought if that makes any difference. So am I. And so are a lot of other people here. **NEVER** let yourself think of this as anything less than a badge-of-honor that you wear. Don't use it as an excuse (especially to yourself), because it's not. You can learn literally anything you want if you simply put yourself to it. The only thing holding you back is, well, you. &gt; I write code every day, and always think "how can this be better?". That's *why* you are self-taught. Because you have the drive to improve yourself. **NEVER** lose this. Always question, always look to improve. &gt; I make it "better" and then somebody else comes along and gives me a solution for what I wrote that is 10x better and a lot cleaner. It's frustrating. Good. It should be frustrating. If this didn't happen, I'd be worried. As you learn, thinks will be difficult. Then in what seems like an all-of-a-sudden moment, everything will "click" and you'll make a big step forward. Frustration is usually a sign that you're about to get one of those moments. The reason is that you realize the problem (which is 90% of the way there) you just don't get how to solve it (the easy part). Realizing and understanding the problem is the hardest thing we will ever do. And it's frustrating. But that frustration is the price we pay to get to the next level. If you weren't getting frustrated (after a while at the same level), that would mean that: either you don't recognize that a problem exists (there's always something you can improve, so this would be bad) or that you don't understand the problem. Both are signs that you're not growing enough. So take that frustration and wear it with pride. &gt; just started about ~3 months ago **AWESOME**. Enjoy it! It will take a lot of time to get "good". Don't worry about that, just enjoy the ride. Some people quote 10,000 hours to become an "expert". I think that number is a bit low in our industry, but it's a decent benchmark. At 40 hours per week, that would put you in 4.8% of the way. Don't worry about it at all. Getting better takes time. And it takes commitment. It takes passion, and drive. And most of all, it takes dedication. Stay with it, it'll pay off in the long run. It's hard, but it's rewarding.
I've seen this complaint a couple of times now, but never seen it explained. What's wrong with PHP's namespace syntax?
&gt; Oracle made a pretty complete mysqli conversion tool for that. But do yourself a favour and don't. Switching to mysqli is pointless, unless you also introduce parameter binding - which is completely bonkers with mysqli. It'll just be another dead end. mysqli is in some ways better than PDO. I've pointed this out in the past, but nobody ever seems to get it. Notably, if you are doing asynchronous queries you simply cannot use PDO since it doesn't support it. As of PHP 5.6 the mysqli API is also easier to use because of `...` (see http://stackoverflow.com/a/23641033/538216 for an example). 
Highly recommend tuts plus tutorials and make a cheatsheet for the first month 
So, essentially /r/PHPHelp or just discussion with more people. This sounds like a stupid theory, or I might not be catching up with the times if this turns out to be common sense knowledge. This isn't exclusively a PHP question but also could apply to most other server-side languages, but nonetheless 1. Assume a file Y exists. 2. Y has files included/required/etcwhathaveyou on certain if else statements being the case. 3. Assume another file Z exists. 4. Instead of the desired action being embedded in another file, they are in Z. Question: Would Y load faster than Z in all situations, assuming Y and Z are PHP files? Edit: also it's still Sunday here lol
You might have better luck on /r/PHPhelp 
$_SESSION is just an array like the others and should act in exactly the same manner. I suspect you're doing something wrong, but I couldn't tell you what exactly. 
You need to use [`session_start()`](http://us.php.net/manual/en/function.session-start.php) before `$_SESSION` will respond to anything.
Thank you for correcting me on the effort to bring the app to its current state. I didn't realize the amount of effort you put in to bring it to its current revenue. In any case, well done. It's inspiring.
I believe they are referring to the changes found here: https://wiki.php.net/rfc/uniform_variable_syntax https://wiki.php.net/rfc/abstract_syntax_tree
Well, okay, generally I agree here. You're expanding the shortcut I took in that sentence, for the most part. See my comments other places in this thread. I don't mean he needs to comply and regurgitate solutions by rote (which is probably physically impossible without actually understanding the solutions anyway, so...). His job is to learn, and learning means *learning*, not just copying and pasting solutions. The part I'm not sure I agree with is: your job IS to do it the way you're told. I had a team lead one time come to me with an issue with a junior developer who kept delivering things that were like 80% to spec. He said something like, "I don't want to squash his creativity...". To which my answer was: I do! I absolutely want to squash his creativity. Or, you know, he has my permission to be as creative as he likes, provided he delivers on precisely what the Business Analyst and Technical Analyst have designed, in precisely the way that they have designed it. Because they have a vantage point he doesn't have, and significant amounts of experience he doesn't have, and what Seems Best from his perspective is only Actually Best if it fits with what the team is producing, which isn't a decision that gets made at his desk. And not because he's junior, per se, just because there's a project design that it's important to adhere to unless there's a darn good reason not to, and there are channels for communicating when that's the case. A lone maverick developer's "creativity" costs us time, money, and team satisfaction.
No, I mean his tendency to feel bad rather than to learn. That's what I'm talking about. We all have that "OMG I'm the dumbest thing on the planet" reaction. Ideally that is a blip on the radar and then you can move on to something useful.
I have used Silex + Eloquent + Twig and it worked pretty well.
Twilio for sure. Not perfect, but I can't think of anything else that's going to get you what you're looking for in short order. 
Thanks, d1str0! Didn't know about that sub, I appreciate the link =)
Create a setter method in your service named setDoctrine() , then pass the doctrine service to your service via the service definition and configuration . From here, your update() method can call $this-&gt;getDoctrine() and do whatever you need to with the user object
Yes, I look forward to putting a -1 on many code reviews with these in them! :)
One a side note, I agree with most of the uniform syntax changes, besides code that makes use of the class + method array syntax, like this. [$obj, 'method']() Even though it represents a method of an object, it's awful looking since it's an array. PHP should really add a new function like Hack did, `fun()`, which pipes the method call, or a completely new construct.
Most of what you need to know is right here http://www.phptherightway.com I would not recommend Phalcon. Laravel is easy to get started in due to it being opinionated and catering to newer developers, but Symfony is a demonstrably better choice for the long haul. It is extremely flexible and this hurts the learning curve a bit, but you can reference the [best practices](http://symfony.com/doc/current/best_practices/index.html) when the docs don't tell you, e.g. to use annotations, yml, php, or xml for routing.
Hm. That's interesting. Seems strange that's the goal of a new major version. What are the updates? What's changed in the framework api? I have loads of questions and I'm not ready to sign up yet. I'm certainly interested in it, however.
Currently using Fat Free Framework + Vue.js for a project I'm updating, and I'm loving it!
$halp()()w()u()()()t("'s happening");
I have used Aura.Web_Project + a few other aura components + knplabs/github-api to build http://ghdocs.herokuapp.com . Have also worked with Silex + doctrine dbal. Silex security component is a bit hard to learn, and it do some good magics :-/ . Lately I have been playing with https://github.com/phly/conduit a middleware for PHP. As PSR-7 is not yet done, I could not recommend it for serious projects for the API can change. You can also see a skelton project ( https://github.com/harikt/conduit-skelton ) which makes use of 0.8 version of conduit with twig + pdo + and a few aura components. The latest version of PSR is moving towards immutability and 0.9 of conduit towards the same goal for which I have a few issues with :-/ . I hope I will be able to update the code when I get some time.
I don't think I'm going to trust anything written by a developer who believes minifying server-side code is a worthwhile endeavor.
well, theres a version for development - http://medoo.in/download
&gt; They tell you the type... That is it! you then need to lookup the type as you would have had to without. Once. After that you'll know what FooType is, while evey $foo could still be something different. Doesn't have to be, but could be, and you'd have to to treat it as such. No, it's not doing the heavy lifting for me, but it's making the load a little lighter. And obviously you don't want your juniors to rearchitect the whole thing, but at some point they'll need to get their feet wet.
He already has an entity manager in his service. It's just that his user entity doesn't have any setters.
I think it's time to start marking these posts as spam. It seems like every other month it gets a reposing. And every time it's canned for the minified PHP distribution option (as it should be). 
That's somewhat the point of $_SESSION[] it abstracts away the need for locking semantics with sessions. If long polling is needed - maybe better to offload to Node.js or React/etc. 
I once had an error of a php database updating twice per page load instead of one. I spent ridiculous amounts of time trying to deconstruct was fairly complicated application. Turns out chrome loaded the page twice because it couldn't find a favicon image. That really blew my nut. #myweirdestproblem
Add a wrapper yourself? Or use Facebook's `libphutil` which already has several of this kind of thing.
With all due respect, you have no idea what you are doing. * WP is a CMS, it is not meant to be a framework for building web applications. * Leveraging a framework like Symfony reduces technical debt, and increases security * Libraries are not code bloat * No modern framework encourages fat models (Symfony doesn't even deal with the concept) * If you don't want REST and CRUD then you probably shouldn't be even using PHP &gt; I just want to be able to iterate on design and content quickly Specifically, how does a decent framework like Symfony prevent this?
At my work, were able to iterate quickly *because* we use Symfony. Many things cone prepackaged as a library, and I never need to think about how I'm going to write my boilerplate, just pop all the pieces in (route, view, controller. In some cases add a form type or two or pull some logic out into a special handler function) and you're good to go. Everyone understands everything that's going on, and Symfony docs will explain any confusion. In our legacy codebase, you need to spend 20 minutes figuring out just how the include train works before you can even start to look at the functionality or how to improve it. With SF, as long as a developer has read through the docs and understands how the framework works, our business-specific code is very lean and what we're doing is pretty clear.
It's a contrived example to show that the syntax is flexible. You no longer need to pull arbitrary values into their own variables or add random parentheses due to parser limitations.
I've been using this [Slim Skeleton Bootstrap](https://github.com/jswhetstone/Slim-Skeleton-Bootstrap) thing, and it has been working great for me. I can get an application up and running very quickly and it's very flexible  i can orgenize my project how I want to and to how it suits the project itself.
What you said is correct, I think he misinterpreted the original example.
Yeah sorry, I grabbed the wrong snippet. Thanks for pointing it out, now I feel dumb!
Do yourself a favor, just switch to silex, it has all that stuff in it, and doesn't try to re-invent the wheel. 
I would use queues as a way to trigger the conversion job. A user uploads a video, you push the queue job. The job comes back - you could then use something like symfony/process to shell out to whichever command line conversion tool you're using. I doubt there's any good native PHP video conversion tooling.
**Stack traces for fatal errors** where possible (particularly Out of Memory, which often occurs in not particularly useful code such as the frameworks database driver, making the actual cause difficult to track down) **PDO uses exceptions by default** - PDO has several error modes. I think exceptions should be default because most people use PDO in an OOP fashion and it makes it that much more difficult to not properly handle errors and miss (potential) issues. **Consistency fixes** - A lot of work has already been done here, but a new major version is a great place to fix language inconsistencies (TIL sometimes "new &lt;Class&gt;" [doesn't always result in an object or an exception](http://article.gmane.org/gmane.comp.php.devel/93547))
I'm specifically asking someone to name a situation where it is inappropriate, and explain why. If you can't do that, then saying it is inappropriate is a baseless assertion.
&gt; The number one design goal though is to have something that requires as low an overhead as possible; I want to be able to clone it into a new folder and start making design changes instantly, and throw it up on Heroku as quickly as possible for review. Can you elaborate? Do you have a concrete example? What do you mean by overhead? &gt;Check it out at https://github.com/dthtvwls/HeroPress The problem is that myself, and thousands of others, already know how to use Symfony (and/or Slim). But you now have your own custom framework that just gets in the way of me being productive: &gt;HeroPress is really a thin layer over the Slim framework It's great that you know it, and you like it, but if you want to work with others then you are digging a hole that will end up costing $$$$.
From your readme &gt;with a focus on developer freedom of choice, configuration over convention and the right mix of rapid/pleasant development and sturdy application architecture. This is just the Symfony manifesto. What do you like about your framework aside from the fact you built it? 
&gt;I can get an application up and running very quickly Quicker than this? $ symfony new my_project_name &gt;and it's very flexible  i can orgenize my project how I want to These are core goals of Symfony. Not a single person in this thread has offered anything more than "I built it" as to a reason to use some custom framework. It's all just heresay and baseless assertions about bloat and lack of freedom.
Looks more like [this](http://ninjago.wikia.com/wiki/Double-Bladed_Dagger) than a spaceship...
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Double-Bladed Dagger**](https://ninjago.wikia.com/wiki/Double-Bladed%20Dagger): [](#sfw) --- &gt; &gt;The __Double-Bladed Dagger__ is a weapon from Ninjago, associated with the Ninja. It is a silver dagger with large, triangular blades on both ends, described as being a useful weapon for inexperienced fighters to use. &gt;In *LEGO Universe*, a weapon known as the "Imagination Spinjitzu Double-Bladed Dagger" appears. It is identical to the Double-Bladed Dagger, but it allows the user to perform "Imagination Spinjitzu", a unique Spinjitzu that appears to be a mixture of Ice and Lightning. ^Interesting: [^Double-Bladed ^Bone ^Dagger](https://ninjago.wikia.com/wiki/double-bladed bone dagger) ^| [^Golden ^Double-Bladed ^Sword](https://ninjago.wikia.com/wiki/golden double-bladed sword) ^| [^Double-Bladed ^Scythe](https://ninjago.wikia.com/wiki/double-bladed scythe) ^| [^Golden ^Double-Bladed ^Bone ^Axe](https://ninjago.wikia.com/wiki/golden double-bladed bone axe) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikiabot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cntpf0o) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikiabot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cntpf0o)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikiabot/wiki/index) ^| [^Source](https://github.com/Timidger/autowikiabot-py) ^(Please note this bot is in testing. Any help would be greatly appreciated, even if it is just a bug report! Please checkout the) [^source ^code](https://github.com/Timidger/autowikiabot-py) ^(to submit bugs)
&gt;Symfony is in the way of me being productive. Because It's easier to write code than learn your way around existing code. The Symfony documentation is it's biggest enemy. They hold no opinions and provide an extremely flexible framework, meaning learning comes at the cost of making a lot of choices based on little experience and often heading down the wrong path. If you can get past this you will be pleasantly surprised.
I don't have an axe to grind, I genuinely don't understand what is better about a "slim" framework. I keep asking for examples, but I get nothing. Why shouldn't you build a simple website with Symfony? The only case I could think of would be if you had to disable basic out of the box functionality like mysql in order to get your website working. But if that's the case, then PHP shouldn't even be on the playlist, you're just building a static site.
Unlike Symfony, I don't require tens of lines of code added/changed in multiple files for simple configurations - especially in terms of dependency injection, which uses reflection by default to aid rapid prototyping similar to Laravel. Other than that it's really just a lot of small minor improvements.
I started reading that a few days ago actually. Still in the process of finishing it, but it's a very good book.
You understood it wrong. I don't feel "stupid" when seeing how other people do it, I only feel that I could do better but the information is...fuzzy?, I guess. Odds are I don't understand some concepts as well as I'd want, hence the reason I made this post. I wanted something to challenge myself with or simply read for the sake of knowing new thing.
A big ***yes*** to the strict version in "future scope" please!
I've done something like this before for a data export feature I was working on, it does work quite well.
What am I missing with this whole command bus craze? http://www.reddit.com/r/PHP/comments/29a6qz/what_am_i_missing_with_this_whole_command_bus/ Tactician, a small, pluggable command bus. Still in active development https://github.com/thephpleague/tactician A wave of command buses http://php-and-symfony.matthiasnoback.nl/2015/01/a-wave-of-command-buses/ PHPNW13 Track 2 Talk 5: Ross Tuck - Models and Service Layers; Hemoglobin and Hobgoblins https://www.youtube.com/watch?v=3uV3ngl1Z8g How to Configure empty Data for a Form Class http://symfony.com/doc/current/cookbook/form/use_empty_data.html
For it to be called PHP 6. trolololol (Seriously though, why it wasn't called 6.1 or 6.5 is beyond me.)
&gt; A T_SPACESHIP constant for use with ext/tokenizer has been added. This sounds like it's going to be `T_PAAMAYIM_NEKUDOTAYIM` all over again!
I can see how this can be useful, but _please_ don't name it `T_SPACESHIP`. [Lingo is bad](https://medium.com/@frankdejonge/a-case-against-coding-lingo-8ffae1a4fa4e), imho.
**Trait requirements** like [HACK has](http://docs.hhvm.com/manual/en/hack.traits.requirements.php) P.S. For the one to tell me to switch to hack: No, I am stuck with PHP on many projects.
language inconsistencies in function names and parameters. 
I created a "startup" repo I use a lot, based on Slim+Twig+Redbean http://github.com/napolux/helloslim
It sounds *awesome* though. And "spaceship operator" is a common name for it.
https://en.wikipedia.org/wiki/Spaceship_operator
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Spaceship operator**](https://en.wikipedia.org/wiki/Spaceship%20operator): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), a __three-way comparison__ takes two values A and B belonging to a type with a [total order](https://en.wikipedia.org/wiki/Total_order) and determines whether A &lt; B, A = B, or A &gt; B in a single operation, in accordance with the mathematical [law of trichotomy](https://en.wikipedia.org/wiki/Trichotomy_(mathematics\)). &gt; --- ^Interesting: [^Three-way ^comparison](https://en.wikipedia.org/wiki/Three-way_comparison) ^| [^Less-than ^sign](https://en.wikipedia.org/wiki/Less-than_sign) ^| [^Greater-than ^sign](https://en.wikipedia.org/wiki/Greater-than_sign) ^| [^Relational ^operator](https://en.wikipedia.org/wiki/Relational_operator) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cntrib0) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cntrib0)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It wouldn't change copy &amp; paste. It would just checked where it is pasting first. When human is pasting something, he first looks at where he is pasting too. And it is not true it is just copy &amp; paste, you can require [methods to be implemented](http://php.net/manual/en/language.oop5.traits.php#language.oop5.traits.abstract) So **it is ok to require 10 methods** , but **require existing interface with those 10 methods is bad**?
Not as good as trait requirements, but PHP allows you to create abstract methods in traits that the using class must implement. I wrote a [blog post](http://createopen.com/design/php/2014/12/15/trait-tip.html) about this.
&gt; "Spaceship operator" is not an uncommon name for this operator I hadn't heard of it before today (the RFC only lists 3 languages that have it so I wouldn't call that common by any means). &gt; if you google it, you'll get helpful results That's also true of `T_PAAMAYIM_NEKUDOTAYIM` so a completely irrelevant argument. Actually it looks like PHP now outputs the actual symbol when those errors occur so the error would be something like "unexpected '&lt;=&gt;' (T_SPACESHIP) ..." which is fine.
Was this removed? There doesn't seem to be a reference to it now. Would that be a `&lt;==&gt;`?
And this could be 6.1 or 6.5. Your comment makes no sense.
Yes, I wrote comment about it a minute before you commented :) Will check your blog post though. Thanks for the link!
If possible, I'd like to do it on my own machines. However if that is discouraged then I'll look into aws for sure
baked-in stable sort could save me lots of ms edit: right now I decorate/undecorate my array (Schwartzian transform) which is a part of my code that really reminds me that php doesn't always want to be a programming language. I can provide a gist when I get to the office edit2: [this](https://gist.github.com/ryaan-anthony/2459f0a4a56695398500) is an example of sort not working as expected, and [this](https://gist.github.com/ryaan-anthony/9009ab479f65065588c2) is how i solve it.
&gt; That's *why* you are self-taught. Because you have the drive to improve yourself. **NEVER** lose this. Always question, always look to improve. I second this a billion times over.
https://github.com/xsanisty/SlimStarter Slim, Eloquent, and Twig
+1 for stack traces. Would be dead handy.
They will, of course, have to implement `&lt;==&gt;` as well for strict comparisons. (Edit: I said this kind of as a joke! But I am curious about whether strict combined comparison operators would be an option.)
It's still against the spirit of it. When you're getting to the place where you're needing to check if the trait fits at compile-time, traits aren't what you need.
Well, what would this echo: var_dump("" &lt;=&gt; 0); // ? Does it use strict comparisons or not?
OK. It doesn't actually say that in the RFC, but I agree that'd be the case. So, I was thinking of situations where like this for example: $arr = [0, "", 0, 0, ""]; usort($arr, function($a, $b) { return $a &lt;=&gt; $b; }); // $a is unchanged
Fully custom. Only way to get exactly what you want :)
I realize it is probably infeasible to fix all the inconsistencies in this release. But at least take a step forward and send a message that these will be cleaned up eventually. 
I was wondering if anyone had a good way to explain what is going on when using static variables. Using a singleton example like the one used on [PHP The Right Way](http://www.phptherightway.com/pages/Design-Patterns.html#singleton) class Singleton { public static function getInstance() { static $instance = null; if (null === $instance) { $instance = new static(); } return $instance; } } I don't understand the mechanism that allows you to call it more than once and get the same instance. $singleton1 = Singleton::getInstance(); $singleton2 = Singleton::getInstance(); I understand that static variables persist, but it seems strange that leading off the method with an instantiation that sets it to null does not continually reset it. The only things I could come up with after doing some research would be: * Once you declare a static variable it won't allow you redeclare it. So in essence when you call `static $instance = null` it is parsed as `static $instance` (but then why doesn't it throw a warning/notice). * When the code is parsed the first time, it replaces the analysis/cache that says there is an assignment and instead fills in the value it was set to. So subsequent calls to `Singleton::getInstance()` would be the equivalent of `static $instance = {instance of Singleton}` * Magic 
Static Typing anyone?
In that case it'd function exactly the same as `sort`.
Except with `sort`, you can specify what type you want the variables compared as. (Well, to a certain extent.)
`return (double)$a &lt;=&gt; (double)$b;` `return strcmp($a, $b);` `return strcasecmp($a, $b);`
`&lt;==` wouldn't really work I think, strict greater-than/less-than comparison wouldn't make much sense. There's not any reasonable behaviour for it.
Yes, yes. I'm not arguing the name. :)
&gt; That's not the case for less-than, say. If the types don't match, what is it? Always smaller? Always greater? I don't think it'd matter, as long as it was consistent. In the sorting example: $arr = [0, "", 0, 0, ""]; usort($arr, function() { return $a &lt;=&gt; $b; }); I would much rather have empty strings grouped with 0s, than just get the input array back - seems more useful to me. It's essentially the same as the arbitrary decision you get in this bit of code: usort($arr, function($a, $b) { if ($a === $b) return 0; return $a &gt; $b ? 1 : -1; }); You can switch the `&gt;` line to `$a &lt; $b ? -1 : 1` there to change precedence for loosely-equivalent values, but in the end you at least get a *sorted* array back (rather than unsorted). I feel a bit like I'm arguing this too strongly, so I'll bow out now. I don't actually care as much as the amount I've typed might indicate. :)
I'm so looking forward to something like that. Even though using PHPStorm helps (it automatically adds imports for you)
A stable sort option would be useful, but I feel it's worth pointing out that as neither of your comparators ever return 0, a stable sorting function wouldn't work anyway.
Do you have any sample code exhibiting this `$_SESSION` problem you could toss into a gist for review?
+1 I'm definitely for stack traces!
I actually really like the look of this. I don't hate on Symfony or Silex (and their components), its just the syntax gets to me and sometimes I feel like they overcomplicate simple things. 
Thanks, man! This helps a lot!
Namespaces in PHP are basically compiler assisted copy-paste and the engine doesn't know what exactly is *in* a namespace at any given time. So I don't think this can be implemented without some massive changes.
If this turns in to another "moronic monday" type thing that pops up once a month I'm going to go ahead and disagree that it's a good idea. The usefulness of these threads is questionable to begin with. Selecting links for the sidebar should be something that is manually vetted. It should be done as they come up, not once a month. Automoderator is just plain lazy, and doesn't encourage quality content.
It's not like moronic monday, as such. I imagine it would be a discussion thread so that each month of the year, on an important topic, we can establish what the state-of-the-art is (in the opinion of the community, anyways). Tools and methods fall into and out of popularity/usefulness. Having a resource updated each year for each area where we see repetitive questions can only be a good thing, imo. It's better than constantly having threads about these things.
On a related note, what good libraries exist for using enum classes? I tend to just roll my own.
Never found a good library for enums. Every one I've seen was just too clunky. I've just ended up using define.
&gt; If this turns in to another "moronic monday" type thing that pops up once a month I'm going to go ahead and disagree that it's a good idea. The usefulness of these threads is questionable to begin with. I like those threads. You might be more advanced than them, but I'll freely admit I'm still a moron. It's nice to have just a 'general PHP' discussion once in a while.
The FOSUserBundle has setters on its entities. I am not sure but making sure my entities are always in a valid state seems kind of important to me and with setters it is pretty easy to violate that.
I've tried it in the past, and just plain didn't like it. I think I'll try it again, though.
&gt; it's not the reason I started writing my own framework :) What is the reason? That's what I'm asking. &gt;my framework's dependency injection would be able to handle that I'm sure it does, but I already know Symfony, Laravel, and Silex. I don't want to learn your custom way of doing things. What problem are you solving that the others aren't?
**Speed** and yes, enums would be cool
I think you are too worried about something or someone changing your user entities. In the example of the FOSUserBundle, all updates are supposed to go through the user manager, and it takes care of properly encoding values, hashing passwords, etc. &amp;nbsp; Technically a different programmer on the team can get the user entity, change the email, and persist it through an entity manager, but they should be educated enough to not do that. I don't know why you are trying to go to great lengths to stop that. &amp;nbsp; Don't get me wrong, immutability is an awesome thing to try to achieve with value objects and such, but the doctrine ORM is not built for immutable models.
This was encouraging and informative and motivational...cheers!
&gt;Just wanted to add, as important as it is to improve the core skills, you should look at improving your soft skills as well. For that I recommend http://theseniorsoftwareengineer.com/ Not much in the way of programming examples. A lot of political and management of a team advice however. permalinksaveparentreportgive goldreply nice book, thanks!
By any chance any of you guys have a coupon for laracasts?
I don't know Symfony, but with the skeleton I linked you do this too: php composer.phar create-project jswhetstone/slim-skeleton-bootstrap [my-app-name] Then I'm up and running, I go add routes, I can just use the Symfony components as I wish. There are reasons to use frameworks like Symfony, Yii and Laravel, but every app doesn't need it.
That's correct, I removed it. You can't really do "strict" less-than or greater-than with meaningful semantics. You could sort by type I suppose, but we don't have internal support for this and I don't want to add it with this RFC.
Unfortunately certain errors can't have stack traces because the engine state is unstable. Others ought to, though.
That wouldn't work, you don't know what's in another namespace at compile-time. Also anyone reading your code will hate you.
That's correct, namespaces essentially just prefix the names of classes, functions and constants with the name of the current namespace.
Hack certainly has some good ideas that PHP should copy. It also has some awful ideas.
PHP 7 already has `??`, the null coalesce operator (it does an isset). &gt; Removing `&lt;?php` and `?&gt;` from PHP only files. Sounds good on paper but causes so many problems and too much added complexity in practice. You don't need a trailing `?&gt;` anyway.
Why not just use `private static $instance = null;` instead? It would accomplish the same thing, right?
[Here you go](http://i.imgur.com/RHd9EGn.png?1)
Yes, I had tried it with the other super globals and it is the same, but the others were just purly regular arrays, albeit accessible from global scope, $_SESSION however can write or delete sessions, so I tought it would be different. Besides, I am passing the SESSION itself to the class, so any change made to the local name should have had an impact on the session itself. 
I also tried to add the ampersand in the constructor, as seen in the image, and still no effect
The $_SESSION global variable is nothing more than an array. There are functions behind the scenes that take care of reading and writing the session, but all it's doing is serializing/unserializing an array. You're passing the *value* of $_SESSION to the class, not the $_SESSION variable itself. To do that you would need to pass the [reference](http://php.net/manual/en/language.references.pass.php) to $_SESSION.
&gt; Besides, I am passing the SESSION itself to the class You're passing the $_SESSION superglobal array to a class. Which, like any other array, will result in it being copied and the new copy being manipulated by the class. You need to add an ampersand before the parameter in order to reference the array instead of copying it.
You mean as `public function __construct(array &amp;$session = []){}` ?
Might be a crazy idea, but some sort of sandboxed eval() would be great: function test($n) { echo $n; } $sand = new PhpSandbox(); $foo = "hello"; $sand-&gt;addToScope('test','foo'); $code = 'test($foo); system(\'rm -rf /\');'; try { $sand-&gt;exec($code); } catch (Exception $e) { //file access raises an exception here at system call after "hello" is output }
There's no practical difference between $_SESSION and $_POST or $_GET, they're seriously just arrays. The only thing that makes them special is where their data is **from**. 
&gt; Why not just use private static $instance = null; instead? The variable is declared within the method's scope, not the class's scope. In a method's scope, you can't declare variable visibility: it'd be meaningless as the variable is only available within the method. If you're thinking of something like this instead: class Singleton { private static $instance = null; public static function getInstance() { if (null === self::$instance) { self::$instance = new static(); } return self::$instance; } } It's not the same because `$instance` is available to all methods within the `Singleton` class, not just `Singleton::getInstance()`.
This has nothing to do with any particular quirks with `$_SESSION`: the problem is that, by default, array assignment is done by copying the value, not by passing the reference. In the constructor, `$session` is a copy of `$_SESSION`'s content, not `$_SESSION` itself. And when you assign that value to `foo::$session`, you're making another copy. So when you call `foo::set()`, you're only modifying `foo::$session`, not `$_SESSION`. You either need to do: $_SESSION['name'] = $foo-&gt;get("name") Or you need to pass `$_SESSION` by reference in the constructor and assign the parameter by reference to `foo::$session`: public function __construct(array &amp;$session = []) { $this-&gt;session = &amp;$session; }
Check out /u/JamesB41 's answer. You have to use ampersand twice, or it won't work
Yeah, but I only used one ampersand then, after some minutes, I tried to add another and it works
Does it work with 1 ampersand if you do no default value: aka: _construct(array &amp;$session){} 
Nope.
One ampersand won't work because all array assignment is done by copying values. While `$session` would be a reference to `$_SESSION`, it'd be copied as soon as it's assigned to `foo::$session`. The second ampersand on: $this-&gt;session = &amp;$session; ensures `$session` is also passed by reference when assigned to `foo::$session`.
There's this new IDE i've been using called Atom. Basically, its like a free, open source version of SublimeText. The only changes I made are to the theme, and I'm really starting to prefer Atom over SublimeText. Here is the link: https://atom.io/ 
I don't know any language that passes array by reference by default. Especially a simple variable assignment (`$array = $anotherArray`). It's like saying "arf, a division by 0 throws an error, I know why people hate PHP".
&gt; What kind of problems does it cause? Lots. In order to have tag-free code-only files, you have two options. The first is to introduce new include and require statements, doubling the number we have to eight. This would work, but you've just added four more statements, the files visited directly would leak source code, it'd be easily to accidentally use the wrong statement, etc. It's not really workable. The second is to introduce a new file extension. But PHP, like virtually every other language, doesn't use file extensions to determine file type. Sure, you may configure Apache to only use the PHP interpreter for files ending in `.php`, but PHP doesn't care about that, so there'd be some sort of weird flag you'd need to set. You'd have compatibility issues, because if you ran PHP 7 code on a PHP 5 or poorly-configured web server by mistake, the entire source tree would be leaked to the user. You'd be introducing unnecessary complexity and confusion. Existing infrastructure that deals with `.php` files won't work with your new tag-free files. Typing `&lt;?php\n\n` at the start of each file isn't really a problem.
&gt; I know there will definitely be people who disagree and think that the larger frameworks are just as quick and easy to get up and running Not just disagree, it's demonstrable. Symfony is a one line install, the only other things you need to do to be 100% up and running are: fix cache/log permissions, and enter db credentials. But you highlight a valid point, they are in fact too difficult for new comers to get up to speed with to the point they understand this. 
&gt;It also has some awful ideas. Like generics.
If I want Java, I'll switch to Java, thanks.
There is one sitting in draft from 2013 which follows the hack syntax if you wanted to run it up the flag pole again ;) https://wiki.php.net/rfc/constructor-promotion 
They're noise. They don't do anything useful in a dynamically typed language. If I want to code in Java, I'll switch to Java, thanks. EDIT: And hey, thanks for the down votes rather than trying to make any sort of point. PHP is a nice loose messy language. If you don't like that, pick a different language that more closely matches your ideals. There are plenty of them out there.
The challenge, and wanting full control of all my codebase. Like I said in the original reply: &gt; which really is the only way to get total freedom and full control over your application's code Again, like I said, it's mostly just a lot of small improvements based on my preferences. I'm not going to claim it's objectively superior to anything. I'd describe the framework as similar to Silex with a less bloated router, less Symfony-component-opinionated structure, and with a more powerful Laravel-inspired dependency injection container.
With the last comment being from over half a year ago, I'm in doubt that someone "is looking into it".
Maybe they could allow the constructor return type to be hinted as !null.
I would like to see php-cli shipped by default on distros.
Oh right, we are in 2015
Yeah -- to rephrase, I wish PHP 7 will improve things to the point it is perceived as as common as Python for all those utility scripts doing tasks beyond basic bash.
Can you just have a stickied post in the sidebar that's always open? The once monthly thing will just turn into the same thing every month, in the stickied post someone can make a summary edit of recent changes and links to comments - and people can have continued conversation about previous topics and see the trend and communication breakdown overtime. I think that would be nifty Edit.. also https://github.com/ziadoz/awesome-php is a great resource you should add in the sidebar.
Thanks for your opinion.
&gt; The challenge Totally understand that. Re-inventing the wheel is so much fun, but it should stay there - this is educational only. &gt;wanting full control of all my codebase Totally understand that too, but it's not even slightly possible. You're using Aura, you've already lost control. &gt;with a more powerful Laravel-inspired dependency injection container Totally scared by that one :P 
&gt; They're noise. They don't do anything useful in a dynamically typed language. Respectfully, I disagree. They improve readability and convey developer intent much better than the alternative (which is a pile of instanceof operations). They also allow the code to be statically analysed by tools such as IDEs and reduce the occurrence of runtime errors. &gt; If I want to code in Java, I'll switch to Java, thanks. Seriously, this meme needs to die. Everytime anyone suggests PHP pick up features from other langauges which happen to exist in Java, someone invariably makes a puerile simplification that we want PHP to be Java. Adding features from one language does not suddenly transform the language into that other language. &gt; PHP is a nice loose messy language. PHP can be a nice loose language without being messy. The messy is *not* nice. And adding generics does not suddenly make it not loose (like many of the 'stricter' typed features it would be entirely opt in and not make the language as a whole strongly typed. This is distinctly different to something like Java or C# which requires you to declare types for everything, perform explicit casting and so forth. That is to say, adding useful features from another, statically typed language does not immediately make php a statically typed language... it will remain a nice loose language. &gt; If you don't like that, pick a different language that more closely matches your ideals. Nobody is saying we don't *like* PHP.. the entire point of this thread was to put forward things you would like to see changed in PHP7... You know, offer what we think might be improvements to the language... It's not as if anybody is under any obligation whatsoever to actually implement the suggestions. 
How about a switch to the PHP CLI that's a shortcut for "don't require preceding `&lt;?php`"?
Git is not a deployment tool. You should use rsync. Rsync can give you an itemised list of everything that will change with the synchronisation, and you never run the risk of someone finding your commit history on your server. It also lets you immediately find out if a hacker has snuck a file onto your server, which git will not do.
What about the inverse of the proposal? leave existing behaviour as it is, introduce a .phps file which contain no tags... although you still have the issue of the file name carrying special meaning... For mine (and having just spent a day refactoring a pile of code that did this), the actual thing that needs to be prevented is side effects in files which are defined as classes... The tag isn't a problem, it's the fact that you can at any point in a class drop out and go ?&gt;&lt;div&gt;stuff&lt;/div&gt;&lt;?php It *shouldn't* happen, and style guides prevent it from happening but it would be nice if the language could somehow enforce the fact that a file should cause side effects or declare symbols but not both..Just thinking outloud... could it be introduced with new tags? &lt;?php = current behaviour, nothing changes &lt;?phpt = a template file, specifically declaring that side effects are going to be caused...disallow class/function/etc &lt;?phps = a source file, after it has occurred ignore any further ?&gt; or &lt;?php symbols
Good thing the suggestion wasn't "turn php into java", hey?
1.) Since you're using AWS, you might consider elastic beanstalk. If you're running servers in a cluster, you can set up rolling updates, which will take a percentage of your servers offline at any given time during the update until all the servers are updated. This can be tricky to manage if you aren't versioning your data sources. #2 below can help with this, allowing for potentially faster deployment per server. 2.) Docker is by far the most popular (at least in the "up to date" developers world). Elastic Beanstalk supports Docker out of the box. Docker allows you to create a Dockerfile which lays out the entire server environment in one file, from the OS distribution you are using all the way down to how your log files are managed. From there, Elastic Beanstalk allows you to do a git push deployment, and EB will hook into the update and run the deltas in your Dockerfile. As for images, S3 is the best option for you'd I'd wager. It becomes necessary to have a CDN once you have a cluster of servers, so starting early isn't a bad idea (especially when the overhead of getting it running is so low.)
I am with cyancynic. If you want static typing do not use PHP.
Git deployments are working great for A LOT of people. Not doing something because of hackers is a bit of a lame excuse. If a hacker gets into your server you're almost always fucked anyway.
For the code look at deployment tools. [Capifony](http://capifony.org/) is specific for Symfony2 apps and use Capistrano 2. [Capistrano](http://capistranorb.com/) is currently at version 3 and can be used to deploy any type of app, not just Rails. The way it works is that it will pull your repo in the remote server, perform any tasks you need (composer, migrations, configuration, etc) and update the symlink to the live folder (think /var/www/your_app/current). In case of problem you can rollback as easily. There are also tools coded in PHP, Python (Fabric) etc that may be more suited to your workflow (like building locally and rsync/upload your app). I haven't tested them but search in this subreddit about them. For hardware &amp; instances I would check specific tools like Ansible, Salt, Puppet etc. Then update your C.V and put devops in it ;)
&gt; **A shuffle round of PHP Core devs**: Thank you for the work you do and the time that you sacrifice, please do not think that I do not appreciate the effort you expend. But the organisational structure is falling apart due to the 'core in-group' issue. Would you care to elaborate on what you believe the "'core in-group' issue" to be? Who would replace these largely *volunteer* developers who have spent so much valuable time making the language what it is today (and on all the awesome changes going into PHP 7)? &gt; **Abandon the stupid backwards compatibility ideals**: We are sick and tired of having to hear "We can not do that because of BC". If you implement a bug/inconsistency - fix it damnit! If someone's code relies on a bug then they are responsible. Personally, I think the developers take a well-balanced approach to BC-breaks. There's already many BC-breaking changes in PHP 7, with more to come. Yes, some changes have been argued against or rejected as breaking BC too much, but this is a good thing. We already have enough problems in the PHP community with hosts refusing to keep up with current versions (often for stupid reasons). Keeping BC-breaks in PHP 7 at a manageable level will greatly help adoption. Also, I expect that we may see a PHP 8 in a shorter time frame than it took us to go from 5.0 to 7. From what I've seen lessons were learned from PHP 6 and the 5.x series in general in terms of managing major changes.
Capistrano also supports a maintenance page. +1 for Capifony. Since it uses Capistrano 2 it still has this feature with the web:disable task. https://github.com/everzet/capifony/issues/363#issuecomment-70246426 This has been removed from Capistrano 3 but there is a new gem for it: https://github.com/capistrano/maintenance 
Just to let you know that I did read your reply, cheers for taking the time. I am at work at the moment but if I get time during the day I will pop back on.
Well, exactly that. :) Most CLI scripts don't have any use for the standard behaviour of outputting untagged source to stdout, so it would just be a shortcut for removing the first `&lt;?php`. (And yeah, it's just a shortcut - but there's already plenty of existing command line options that are shortcuts that I'd say were less-used.) Perhaps making `php -r` accept stdin by default (or with "-" as the argument) as a flag for "standard input" would be more useful. Then you could do `php -r &lt; sourcefile` (or `php -r - &lt; sourcefile`)?
&gt; Type annotations are NOT required for static analysis. Perhaps, but they certainly help. &gt; Smalltalk does not have type annotations and that is where the original refactoring editor was invented. PHPStorm gets on fine without type annotations too ... but that's not to say additional safety cannot be had by leveraging them. Also we're not talking about Smalltalk here. Short of actually executing the code (which some IDEs may do, I don't write IDEs so I don't know), there is no way that they can tell you that you are going to have a runtime problem. If I want a Collection object that accepts objects of a given type I have 2 choices... I can write some faux-generic code using string typenames and instanceof to check at runtime that objects of the correct type are being passed in, or I can write a specific collection class that only accepts objects of a type. Neither of these are particularly appealing - the first option leads to brittle code that I get no forewarning of potential mishaps despite static analysis, or I end up with a large number of very specific Collection objects which deal with very narrow cases but are largely the same as each other. &gt; Readability is largely a matter of opinion but I maintain that sprinkling &lt;T&gt; all over the code Good thing I am not suggesting "sprinkling &lt;T&gt; all over the code". I'm suggesting using it where it is appropriate and useful. Readability is a matter of opinion, but being able to see that a class is a generic by looking at the first line of the class instead of reading comments, or looking for instanceof in the body of the class seems to me to be a step in the right direction. It also immediately conveys developer intent which is not a matter of opinion. Class Collection&lt;T&gt; { } is dead obvious that it is a generic class. &gt; and no I don't need instanceof either - I just trust that the parameters are the right type or accept that I'll get a runtime error. That's wonderful for you. Many of us do not have that luxury. And in order to gain a small level of safety we currently have to resort to awkward workarounds. For what it's worth, the addition of this as a feature would not alter the way that you work with the language one bit - you could continue using the language the way that you like to. &gt; OK, you know what? I mostly write mobile apps and use PHP for REST/JSON services. Its just a scripting language to write database glue for me. Awesome - how does that fact change by adding features that those of us who write complex applications *in* PHP to write them with greater ease change the way that you would use it? &gt; In the iOS world, we've just been threatened with the replacement of the lovely Smalltalk inspired dynamic Objective C with a new language called Swift that has all of the same nonsensical features I'm seeing requested in here. The same ones. I think Swift is stupid too. You are just outright dismissing features that other people find wonderfully useful as "nonsensical" and you seem very mad about it... I'm not sure why. The parallels you are drawing with swift/objc are odd to me so I'm going to leave that alone. &gt; Generics (only useful in statically typed languages of which PHP and Objective C are NOT) I still disagree. They are incredibly useful. I know they are incredibly useful because many people are already working around their lack of existence with awkward workarounds precisely because they are useful. &gt; optionals/nullables/etc (relax - its nothing) Er.. right. &gt; static typing for "safety" (which I find highly impractical and obstructive) Which **you** find. You. For your particular use case. They are entirely optional, you can completely forget that they even exist if you want. Their addition does you no harm whatsoever. &gt; There is a set of language "features" that are all the rage these days that every language is running around trying to adopt the same fad Or, another way to look at it, there are a set of features which users of languages have found broadly useful. Their addition does not reduce the "flavour" of the language they are introduced to. And in PHP's case you can just flatly ignore their addition if they are not useful to you. &gt; it sounds like the same lies I heard from the C++ crowd about "type safety" (total lie) Right. &gt; and "compile time checking" (mostly useless) Right. &gt; and "provable correctness" and I was there and onboard with all that stuff in 1992. Right. Also stealth "i've been coding for over 20 years" which I can only assume is some strange appeal to authority? &gt; It didn't pan out. At all. As in it didn't help me write better code - just more of it to do less. Awesome for you. It didn't work out. It doesn't help you write better code. GREAT. Good for you. It does help me and my colleagues write better code. It helps plenty of businesses that I have been affiliated with write better code. More readable code. More expressive code. Code that is less prone to breakage. That isn't to say that what you are doing doesn't work for you. If it works for you then that is wonderful. Carry on doing whatever you are doing. I'll say it again, you can pretend that any new features in the language simply don't exist.. your code will still work. &gt; Java repeated all the same mistakes. Generics/templates were a feature invented by Stroustrup as a bandaid to work around his poorly conceived stupid type checking system that didn't work in C++. Java repeated the type system mistake and adopted the same fix. That's as far as it needs to go. Right. &gt; PHP uses duck typing and does not have static type checking (praise Jesus) and thus does NOT NEED something as stupid as generics. Right. &gt; Less is more. On this we agree. Less is more. I would write less boilerplate code if PHP supported generics. My code would be far more readable and far more expressive. That's before any possible benefit from design-time analysis. &gt; Sorry for the rant Sure. I was attempting to be reasonable... I've tried to find the reasoning in your post and I'm struggling. You seem to be very mad that a language might add features that you don't have to use? &gt; but seriously - if all languages adopt the same features then we are converging on one language and it sucks. On this point I, respectfully, disagree. Languages can safely borrow concepts from other languages without giving up their particular flavour. Were PHP to adopt generics (for example), PHP would remain a weakly typed language that gives you all the flexibility you need, and all the junior dev's on as much rope as they need to hang themselves. PHP would still retain it's mostly unique Edit-&gt;Save-&gt;Refresh workflow. It would still be built on the concept of shared nothing. And for those reasons it would still occupy the niche of being a dedicated *web* language. All we're suggesting with these "new fads" is some additional language constructs which would act as a bit of sugar for those of us who are using the language for more complicated tasks than perhaps it was originally intended, but that it has shown itself to be very good at doing.... 
Nobody is suggesting anything of the sort. Nobody is suggesting turning it into C++ or C# or Java or any other language you can think up. I believe /u/woecip was probably referring to the addition of scalar type hints, which are entirely optional and would make PHP nothing like the aforementioned languages...in spirit or otherwise. 
This looks extremely promising as I'm going to buy a tablet soon that would run a dashboard as a control for my smarthomesystem. Yes, I could just use a browser, but that's just not the same as a real app.
Git can show you the diff as well. Also if you type git status, you'll see all changed files, so you'll see if a file was snuck in, no?
Regular users accessing the server through port 80 are not necessarily the only party to be worried about. The server may be hacked. The client may have access to the server as well, and may decide to randomly invite third parties to access the server too without telling you. Ensuring your git history does not get pushed around to random servers all around the globe is not just about protecting your development history, it's about protecting your employees. I know I certainly wouldn't want my git logs being read by anyone outside of the company I work for.
&gt;PHPStorm gets on fine without type annotations too ... but that's not to say additional safety cannot be had by leveraging them...I don't write IDEs so I don't know Right. You don't know. But it turns out that people who do know have found they don't actually help writing IDEs. &gt;I end up with a large number of very specific Collection objects which deal with very narrow cases but are largely the same as each other. Wait. We are still talking about PHP, right? A language that uses one collection - array of anything keyed by anything - for everything. There is no good reason to write a collection in PHP. &gt;I would write less boilerplate code if PHP supported generics. No, you will write more and you will discover the inherent and intractable problems that arise from confusing type with protocol. &gt;Languages can safely borrow concepts from other languages without giving up their particular flavour. I do not agree at all, however I will concede that optional type annotations can prove useful and I'm ok with that so long as it remains optional. Thanks for your reply, I can see that you put a lot of effort into it. 
Since you're on AWS already, take a look at OpsWorks. It brings chef-based deployment to your app for no additional cost. Of course you'd have to learn Chef but that's a small learning curve. Of course if your app is simple it has some sensible defaults so you may be able to get away with not having to write any Chef code at all.
Whichever way you go I strongly recommend using a CMDB. I personally use Ansible and love it, other people swear by Chef and Puppet.
do a reset() before the second foreach
Sorry. I'm not sure I understand what you mean to have happen by "overwrite the reference." But this isn't something I'd ever run into so I poked around for an answer.. mostly for myself. :) After the end of the first foreach loop, $item is a by reference variable to $array[1] so in the second loop you are assigning each value of $array to essentially to $array[1]. That's probably not technically what happens, but I think it illustrates the point. (maybe?) It's easy to see what's going on with this: &lt;?php $array = array( 0 =&gt; "item1", 1 =&gt; "item2" ); foreach($array as &amp;$item){ } //unset($item); var_export($array); $array2 = array(1, 2); foreach($array2 as $item){ var_export($array); } http://php.net/manual/en/control-structures.foreach.php (see the apart about assigning by reference) And having never had to unset a reference before, this was new to me too! http://php.net/manual/en/language.references.unset.php
1 - //unset($item); This line is commented out, therefore it will be ignored when PHP processes the page. Remove the // from the line. 2 - unset($item) is in the wrong place Right now it's outside of the foreach loop. You need to move it inside, like this: foreach($array as &amp;$item) { unset($item); }
Correct.
I don't fully understand it either, but if you're interested in the internals of PHP, [this answer](http://stackoverflow.com/a/14854568) might help.
Now you're just making shit up, lol.
Most deployment scripts Rollback on a failed deploy so while you won't be able to push a new feature live, it *shouldn't* break. Out of curiosity, how would you go about deploy a site with composer based plugins? You seem to disagree, saying the main way AFAIK (pull from git and doing a composer install, like capistrano) is bad. Obviously committing the Vendor directory is a big no-no, everyone should know that. So unless I'm mistaken that leaves either doing a composer install during a deploy (which you disagree with) or having some custom deploy to Pull from Git on to a development location to composer install to then push the site live. Is there an option I've missed?
There are times when i need to manipulate the contents of an array. and its quicker than doing foreach($array as $key =&gt; $item){ $ref =&amp; $array[$key]; }
What's preventing you to delete your .git folder once the code is pulled (like Capistrano does out of the box IIRC) ?
Need to work on the responsiveness of it, it's just that I have a pretty big screen so to me the header is not that big but to other people it is :p
That's not what he's saying though, I think he's just implying that a hacker seeing your git folders is not the worst thing given they can already seen all your files and no doubt now have access to your database as well. If you're lucky it will be just that one site / account they have access to but god forbid they have access to an entire server and potentially able to take down all your sites / clients / whatever. Yeah, a hacker seeing your git folders / log in that scenario really isn't anything that would concern me. 
We've been using [Deployer](http://deployer.org/). I haven't heard much about it from the community but it is serving us well. Take a look at some of the prebuild recipes for solid examples.
He mentions including the /vendor/ directory and built assets in the deployable tar.gz
These gifs will be burned into my retina for always
FWIW, with some large sites I've dealt with at my job, I've never had an issue with duration of a deploy even during busy times of the day. Then again I could have just been lucky and always avoided github slowdowns / down time when it comes to deploying. Where does the build stage actually happen then? As mentioned in a previous comment, i've only ever used capistrano so just trying to get my head round it. Obviously with capistrano, I use terminal to navigate to my project folder and run the cap deploy. Do you do a similar thing? Navigate to your project folder on your machine run deploy which then builds it and saves to your machine temporarily before pushing to the server.
Have you ever run 'git status' or 'git diff'? If anything, git is more powerful for determining if files have changed than rsync. rsync can tell you if a file has been added/removed/changed, but it certainly can't tell you to what extent an existing file is changed. git can do those things, including discerning file differences. Development dogma is for the dogs. What works well for you might not work well for others. Besides, if you're relying solely on rsync to determine if your server/website has been hacked, you're going to have a bad time. 
My experience with C++ and later Java is that it just increases cognitive load overall making programming more mentally exhausting. I then moved on to Smalltalk (the original minimal OO dynamically typed language with closures) and found I could write equally good code with much less effort. That's how I got to my current set of beliefs. All that "static stuff" was all drag, no lift.
Yeah. Granted, we can't see the bigger picture...but the entire approach just seems like a bad idea. $_SESSION is your (the general you, not you specifically) pointer in the first place...why not just use it directly?
SitePoint, as per usual, choosing sensationalism over detailing all the facts. The 5.7 RFC was rejected at voting, however it's notable that a number of those voting no mentioned that they didn't think there was currently enough changes (in PHP 7) to warrant a 5.7 (purely with the deprecation notices laid out in the RFC). The RFC could well be resurrected at a later date if there's enough support. On the removal of features, the article only very briefly glances at in passing the [remove deprecated functionality RFC](https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7) (and even then, oddly links to an older version), the voting on which closed later the same date with all votes successful. On the extension API changes, the article completely neglected to mention that a week later, [Sara started a discussion](http://article.gmane.org/gmane.comp.php.devel/93164) on a new, documented API for extensions that would be compatible with both HHVM and PHP
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Web scraping**](https://en.wikipedia.org/wiki/Web%20scraping): [](#sfw) --- &gt; &gt;__Web scraping__ (__web harvesting__ or __web data extraction__) is a computer software technique of [extracting information](https://en.wikipedia.org/wiki/Data_scraping) from [websites](https://en.wikipedia.org/wiki/Website). Usually, such software programs simulate human exploration of the [World Wide Web](https://en.wikipedia.org/wiki/World_Wide_Web) by either implementing low-level [Hypertext Transfer Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) (HTTP), or embedding a fully-fledged web browser, such as [Internet Explorer](https://en.wikipedia.org/wiki/Internet_Explorer) or [Mozilla Firefox](https://en.wikipedia.org/wiki/Mozilla_Firefox). &gt;Web scraping is closely related to [web indexing](https://en.wikipedia.org/wiki/Web_indexing), which indexes information on the web using a [bot](https://en.wikipedia.org/wiki/Internet_bot) or [web crawler](https://en.wikipedia.org/wiki/Web_crawler) and is a universal technique adopted by most search engines. In contrast, web scraping focuses more on the transformation of unstructured data on the web, typically in [HTML](https://en.wikipedia.org/wiki/HTML) format, into structured data that can be stored and analyzed in a central local database or spreadsheet. Web scraping is also related to web automation, which simulates human browsing using computer software. Uses of web scraping include online price comparison, [contact scraping](https://en.wikipedia.org/wiki/Contact_scraping), weather data monitoring, [website change detection](https://en.wikipedia.org/wiki/Change_detection_and_notification), research, [web mashup](https://en.wikipedia.org/wiki/Web_mashup) and web data integration. &gt;Web scraping related traffic has increased during recent years. In average 23% of all traffic was scraping-related in 2013. [*[unreliable source?](https://en.wikipedia.org/wiki/Wikipedia:Identifying_reliable_sources)*] &gt; --- ^Interesting: [^SimpleTest](https://en.wikipedia.org/wiki/SimpleTest) ^| [^Apache ^Camel](https://en.wikipedia.org/wiki/Apache_Camel) ^| [^Yahoo! ^Query ^Language](https://en.wikipedia.org/wiki/Yahoo!_Query_Language) ^| [^Data ^scraping](https://en.wikipedia.org/wiki/Data_scraping) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnv1ffv) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnv1ffv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Well that's a bit like saying you might as well store your user passwords in plaintext...because if they dumped your database, you're screwed anyway. Limiting attack vectors is always a good idea.
Simplest way is to use https://import.io/ to handle the scraping and then grab the data via their API.
Cross platform without the weight of Java.
If you do then start on PHP 5.4 or later.
Writing more secure code is harder. 
It's not actually really like that unless rsync is going to hash my files. ;)
A good point indeed. I'm not saying it's perfect, and perhaps there are better solutions - but the likelihood of a failure during deployment caused by git is minimal I think. Again I'm speaking mostly from an AWS EB point of view - which will automatically fallback to the last working configuration if the deployment happens to fail.
I'm looking for the one the causes the least eyestrain over many hours of use....is this the one?
It's just the mentality in general though. Why open yourself to something you don't need to? Servers are compromised constantly. Having any type of data (even a git history) available to an attacker for no other reason than a mild convenience just seems lazy.
[CallFire](https://callfire.com) is good for this. Very easy voice broadcasting.
I spent a while thinking about this idea in the past wondering if there was a neat way to do it with traits or reflection but in the end I came to the conclusion that it's better to just write them out rather than do something magic.
Very similar to https://wiki.php.net/rfc/automatic_property_initialization Although I think a lot of people would like it, it's just not a good enough feature to actually include as it fails one simple test; does it allow you to do something that currently can't be done? Saving a bit of writing text is just not that strong of a reason to add a feature to a language. And in this case, it (imho) it makes it harder to read what properties a class has. 
In the chance that the constructor does something more.
Using this also. Does the job for our needs.
If you do it with the key yes. I was talking about `unset($item);`
I spend about 5% of my time writing code, and about 95% of my time reading it. This makes writing easier, but reading harder. In the end, I don't think it's a good idea.
I prefer [NW.js](https://github.com/nwjs/nw.js) myself. Previously called node-webkit. I ran into TideSDK first but it has been "abandoned" for it's succesor TideKit which is currently locked behind a paywall from what I can tell. Granted NW.js doesn't support making mobile apps but I didn't need that feature so you and other's options may very. Just thought I'd toss another similar-ish project out there.
I never said it was the most important thing. Goodness. I just said it was important.
So I'm only allowed to worry about one particular thing when my server is compromised? No, obviously not. There are varying degrees of importance, and exposing your git tree is somewhere on that scale.
 &gt;Given that swagger is a well defined spec, if someone wrote something that read swagger JSON and output a proper set of classes, I'm sure it would get used. I'm actually surprised nobody has taken this on. Agreed. I would encourage anybody to take on that challenge. 
sounds great! what if the db migrations are breaking, like dropping a column. do the deployment tools have anything to help with that?
like i guess code updates would work with that, but for db upgrades the site might have to go offline for a second
I guess I prefer a tool that handles the whole process of files, db migrations, cache warming, assets, configuration files, rollback, environments. I guess you can do most of that within your CI server though. 
Just add a custom task that puts the site in maintenance only if there is a db migration. And yes if the migration fails you can plug your db rollback in the capistrano rollback. 
are you getting this error? http://stackoverflow.com/questions/16765158/date-it-is-not-safe-to-rely-on-the-systems-timezone-settings-in-codeigniter try setting your timezone, and datediff() might just work like you expect
When I click "What is hook" I see a blank screen and the video doesn't play. I don't know what hook is.
The [Carbon](https://github.com/briannesbitt/Carbon) library may do what you need.
+1 for Carbon. It's amazing!
I had to deal manipulate dates daily for my job, and I only ever trusted UNIX timestamps with [mktime()](http://php.net/manual/en/function.mktime.php) and [date()](http://php.net/manual/en/function.date.php). Use the two together to achieve whatever you need, accurately. For example, // you opened in 1972 on St. Paddy's Day $start = mktime(0,0,0, 03, 17, 1972); // today (you could use time() too because it's not like getting it exactly // at midnight matters, but I wanted to show how to do that if you were to) $today = mktime(0, 0, 0, date("m") , date("d"), date("Y")); // find out how many years that is $years = floor(($today - $start) / 60*60*24*365); Edit: note that I'd use a DST-friendly method for mission critical things, but that's good enough for government work.
thank you! tested this here: http://writecodeonline.com/php/ and it failed but I think that site might be kinda anal. it looks clean/right 
This website is completely broken on mobile for me. I also don't know what hook is. 
floor ( ( unix_timestamp() - unix_timestamp() ) / ( 86400 * 365.36 ) ); If you want messy ;) 
"hook is a restful, extendable backend as a service that provides instant backend to develop sites and apps faster, with dead-simple integration with ios, android, javascript and more." The video is a really annoying full-screen background of a bunch of people fawning over coffee cups and macs. I don't think you're missing much.
Those people running this project are HORRIBLY, HORRIBLY arrogant and totally stupid. Their installer just destroys existing installations - no questions asked, overwriting or renaming as it sees fit. I get it. Hook is *AWWWWEESOME* and when you're awesome you simply don't need to ask permission because ... *AWWWWEESOME*. And btw. The installation failed. /rant I'm sure this is a great project and I'm likely going to check it out but it's not acceptable to destroy existing installations.
+1
That test you talk about pretty much describes any language feature, no?
At no point was it said that you can only worry about one thing. The whole point is that if a hacker gained access worrying about him seeing you git folders is way down on your priority list. That's all we've been trying to convey, you seemed caught up in the fact a hacker might gain access to your git folders and you seemed to see this as a massive security issue, when really there is more important things to worry about in that situation.
That's a better experience than on Firefox. I can't really describe how bad it looks.
Hi @Synes_Godt_Om, could you provide more information about what does it "destroyed"? What OS are you using? We take developer experience very seriously. It really shouldn't cause you any trouble. Sorry for that.
I unfortunately missed the talk this evening, but keep an eye open here for when the slides are put up: http://phpne.org.uk/2015/01/20/rabbitmq-i-show-you-how-deep-the-rabbit-hole-goes.html
&gt; Not the best choice if you are limited with older PHP version. That's concerning. Upgrade your servers people.
We use Beanstalkd. It's very fast and lightweight, so much so it barely registers on CPU usage. Persistence works by writing to file when it's told to shut down, I don't believe it's writing to file all the time - it's still an in-memory queue. All in all, very pleased.
You have "can manage workers" listed as a pro for Gearman....that was one of the things I liked least about it. Instead of the code for workers just picking a task up off the queue and processing it, the code had to know about Gearman and it was just a bit yucky to code. Managing workers can be done much more nicely through [Supervisor.d](http://supervisord.org/), and that gives a much cleaner separation between the management of workers, and the work that the workers need to do. If you don't need advanced queueing stuff (like having re-configurable routing of queue items) then I'd recommend seriously looking at just rolling your own queue in redis. It's incredibly simple, you just need to serialize (or json_encode) the data for the call, push it into redis, and then every worker just sits waiting for a job via [blpop](http://redis.io/commands/BLPOP). Or you could use https://github.com/chrisboulton/php-resque to avoid having to write that bit. Pretty obviously you should also code it so that it's easy to switch between queueing technologies...it shouldn't be a decision that has a massive cost to change later. 
Do you rsync from the staging server? Or how do you do it?
For RabbitMQ I always use Supervisor [1] to manage by publishers/consumers. [1] http://supervisord.org 
+1 with managing workers yourself with Supervisord as mentioned elsewhere, this is very simple and solid. If you have simple needs, Beanstalkd or Redis will be good enough. RabbitMQ has more features but it's way more complex to use I didn't like it at all :p Simply pushing tasks to Beanstalk was much more pleasant! My experience with Gearman was very poor, especially because installing the extension was messy and buggy, finding the correct version that has bug X and Y fixed and compatible with your PHP version was quite hard. And the documentation is terrible I think it's abandoned too. And why not using an abstraction that let's you switch provider any time? It's especially useful for tests and local environments. An example: [MyClabs\Work](http://myclabs.github.io/Work/), but there are plenty others very good.
Beanstalkd, but I'd suggest using a different language such as Python or Go to implement consumer producer to distribute php processes. It's well worth the effort in the long run.
The downside of SQS beyond the always awful vendor lock in is the tiny max message size, 256kb. Gearman's max message size is 4gb and we commonly throw a couple megs of JSON at it at a time in a single message. Depends on how you use it but this is a deal breaker for us.
As several others have reported, I've been very happy with the beanstalkd+supervisor setup. Both are lightweight and quite solid. I've been using that combination for ~2 years to manage jobs/workers that pull/push order data in a multi-tenant multi-channel online-retail ERP system. Both components have been very stable, performant, are well documented, easy to configure, and easy to monitor. If the supervisorctl command could do wild-card-y things, I'd be delighted, but that's seriously my only complaint. 
Easier said than done.
Build it yourself? I had it running on my Mac back in 2.2 or whatever. The directions here are pretty much the same as building for a mac. http://coderoncode.com/2013/07/27/first-steps-on-hhvm.html Otherwise, you could just install it in Vagrant.
A little self promotion, but if you want to get a proper server with HHVM up and running in a few minutes, check out my project https://puphpet.com
It's not that I don't like the features per se, but rather I don't like the 1/2-assed implementation of them in a language that's supposed to be dynamic.
Runs quite an [outdated version](http://www.sitepoint.com/3-ways-develop-cross-platform-desktop-apps-php/) of PHP, but seems like a fine option for those simple things. Supposedly, [TideKit is coming](https://blog.tidekit.com/post/from-a-desktop-perspective-tidekit-for-tidesdk-developers) as a commercial and maintained alternative to the defunct TideSDK
As with all things OOP, it depends. You're going to want to consider things like the [single responsibility principle](http://en.wikipedia.org/wiki/Single_responsibility_principle) and [The Magical Number Seven, Plus or Minus Two](http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two). You don't want to build your classes to do too much, so that you're scrolling up and down over fifty huge functions. And you also don't want to flog yourself by ending up with 30 classes that each have a single two-line function. Generally, I'll group things together that make sense or have similar parameters. I wouldn't put roman numeral conversion with slug generation, as they're not related except tangentially because they're both strings. I could see image cropping and thumbnail making together, especially if you're simply wrapping another library that actually does the work. 
My only experience here is with Gearman, and I have a lot of it^[1]. If you have a stupid implementation it'll be nothing but problems, but when used right it'll treat you quite well. Should you go with it, I have a library published that you're more than welcome to use. My own documentation and examples are a little out of date as well, but if you decide to use it and need help ping me and I'll help you out (it's one of those things that works fine in prod so I haven't needed to touch it in quite a long time) ^[1] As in, I've manually implemented the protocol as both a client and a server for debugging. The degree to which the documentation is out of date is... impressive.
Good read. I rarely venture outside of doctrine because I'm a stickler for DDD and need my data mappers. So, it's interesting to see the other options. One thing I noticed is that Doctrine doesn't require 5.4, and so you'll do just fine on 5.3. I'd also argue that you don't *have* to learn DQL. I kind of wish the code examples showed the same code, achieved using the different orms, would be neat to compare the same task being done. Thanks for sharing. 
Hardly. A large portion of the cleanup would be making the signatures more consistent, meaning that order of parameters would change, and unexpected by-reference parameters (`sort`, anyone?) will go away. It could certainly be done by defining an official convention as part of the language spec and adding the per-spec function names, eventually deprecating what we currently have. But what about libraries that support both procedural and OOP use (such as `DateTime`)? There's a lot to consider here.
Unfortunately that's just because of limitations in userland code, such as no operator overloading and such. While the `define` approach is vastly simpler, you lose out on the most important benefit of an enum type: the type information. With a first-class data type, you can typehint parameters (and annotate the return value, as that RFC looks to pass). How do you know your `3` getting tossed around is the state from your User model and not your Group model?
Do yourself a favour and just use Symfony. The Symfony HttpKernel and Routing component combined with your custom config make this trivial. You just need a custom "ControllerResolver" class that wraps the default resolver and has your config injected. If you detect a controller being resolved that matches your config, replace the controller with the correct one. The rest of the framework is blissfully unaware, and you can go home smiling. 
I'm not attempting to play a victim - Perhaps you're reading too much emphasis into the word "mocked". I am however stating the expectation of the professional PHP community will be to use them and those who don't will be outside of the norms of that group. Groups/societies/communities/etc. have a way of self-correcting and rewarding desired behavior. Isn't that one of the underpinning beliefs for self-organizing teams in agile development? We can police ourselves. Of course this is good when the desired behavior is good. But things that don't conform to mainstream thought are typically dismissed, sometimes working against the benefit of the group. We see this all the time in the scientific community! Human nature is human nature. If I'm not acting professionally then if anything I'm cynical, not childish.
Could you explain why DDD requires a data mapper verse an active record ORM?
https://github.com/brianlmoon/GearmanManager
The warnings come from not defining a default timezone, for an accuracy of one year just using UTC should be fine to get rid of warnings. Or you can use the one where your service is located. date_default_timezone_set('UTC'); echo date_diff(date_create('1970-01-01'), date_create('today'))-&gt;y; 
I've had a positive experience with Beanstalkd on symfony2 via LeezyPheanstalkBundle. Workers were managed by supervisord. Extremely lightweight and simple, easy to set up and use. To be fair, i didn't use other listed alternatives.
Yes, totally agree on this. Makes it very difficult to batch data, but works for the majority of cases.
I think "Requires learning Doctrine Query Language (DQL)" is an overstatement. 90% is plain old SQL.
I haven't used Supervisord, but isn't it similar to monit?
php documentation about gearman is very unreliable..i once posted a question on stackoverflow with bounty on it and no one can give me definite answer
&gt; Also, doesn't it make more sense to have the important bits as well tested vendor libraries? Just because it's a vendor library doesn't necessarily mean it's well tested. I can also write tests for my own code, of course... &gt; I think, like everyone else, you suffer from "code is easier to write than read" syndrome, and just haven't learnt enough about a full stack framework to be able to competently use it. I've written full apps in Slim, Laravel, Silex and Symfony, I think I have a good grasp of how to use all of them. In fact I'd say that my experience using them and knowledge of how they work were essential to knowing exactly how I wanted to improve on them. As for my dependencies, all of these packages have a very well defined purpose and a small responsibility. - symfony/http-kernel: I only use the HttpKernelInterface and the names of some events, to provide compatibility with other libraries. - symfony/http-foundation: I only use the request/response classes for similar reasons as above. - symfony/browser-kit: Not used by the framework at all, used by framework users for functional testing. - symfony/console: It only serves as a routing/presentation layer for the console. - stack/builder: Simply a slightly sophisticated stack of middleware for HttpKernelInterfaces. - nikic/fast-route is really just a pattern matcher for URLs. All the important logic of orchestrating routing is done inside my own classes. - Twig is a templating engine and does a very good job at being **only** that. - psr/log is just a package of an interface.
If you are interested in sharing your knowledge: https://github.com/bzikarsky/react-gearman is a working Client and a partially working Worker (as in "there is a major refactoring" in progress). Server is planned but not started yet. There is probably a lot to be refined from a protocol-point-of-view. :-)
how about everything managed $9/mo on webfaction. why is someone who's proficient enough to even know what an ORM is, stuck with shared hosts? $10 a month for managed, updated hosts is a negligible cost. even a wordpress theme ninja would know that. i don't get the shard hosting limitation thing at all. do feel free to enlighten me. 
&gt; Would you care to elaborate on what you believe the "'core in-group' issue" to be? Who would replace these largely volunteer developers who have spent so much valuable time making the language what it is today (and on all the awesome changes going into PHP 7)? as someone who watches internals (for a long time) i can say that most of them are just wanna-be language designers, c programmers. There are few good ones like *nikita* (may be just him) and couple of others.. rest are not capable of pushing this language forward.
&gt; We already have enough problems in the PHP community with hosts refusing to keep up with current versions and issules like startups are not using php to build their products anymore!!
I have tried to build it many times, over the last year. Through most of that I was using a Macbook Air, which makes using VM's impractical. I have never been able to install it on a Mac, following every set of instructions I could find. There's always some error. Always some dependency it can't install. I really want to play with HHVM and Hack, but until it is easy to install, natively, on a Mac...
In addition to this lovely async client, there's also [this](https://github.com/revolvephp/assistant) which aims to abstract concurrent async processing.
People can be at different points financially and learning. Someone could have clients on shared hosting who don't want to move. There are a number of reasons why this situation could happen. It amazes me how developers who are trained to think can't understand.
I'm in the opposite situation- I work with higher-level programming languages, but I've got a new job for a web development company and could do with making some simple Windows apps that web devs can debug and maintain. This looks useful!
Hasn't built since 3.2 or something IIRC :(
Any comments on Symfony2 (mainly Doctrine, Assetic and Twig) issues? I've read old hhvm's weren't very compatible, has anything changed?
Afaik, the only ORM in PHP that implements data mapper is Doctrine2 so that's your only choice (not a bad thing, it's very mature and stable), I have a few articles at http://ihaveabackup.net/2014/06/26/a-few-years-with-doctrine2/ if you are interested. The article mentions Fat Free as also being data mapper, but I've never heard about it, YMMV.
I shouldn't develop on a Mac because I can't install HHVM? I develop non-mac software every day and it works brilliantly for that...
The case-insensitive default filesystem suckkkssss
SOLD!
That makes a lot more sense now. Thanks!
No it doesn't scale well and it's incredibly slow. I've worked on a site (now failed social network that at peak had ~40m users and processed a couple of thousand messages a second) that had some legacy systems that were built using SQS. These were the hardest parts of the system to maintain and the first parts to be migrated to Kestrel (a few Twitter devs were working on the project at the time, not a good choice now). The main problem was that (at the time) you couldn't send multiple jobs to SQS over a single connection and the connection is very expensive to create. When you deal with scale and thousands of jobs a second, a few milliseconds on top of every job absolutely does matter. OP work out what you need to achieve before looking for a tool. There is a difference between job queues and messages queues. Both try and achieve similar things but focus on different areas for performance or reliability. Does it matter if a single job is processed more than once, do you need status of jobs, do you need to be able to set priority, how many jobs per second are you likely needed to process etc etc etc? I've implemented systems with all queues you have mentioned. Each are good. Each have different strengths. Don't worry if there is an existing Symphony bundle. Any decent job queue will have number of client implementations in various languages. The more the better. If you really do need to scale you may need to be able to process jobs in more than one language. If there is no bundle, write one. You will learn more about the queue and in my experience bundles you find out there for Symphony are generally pretty poorly written. A solid PHP client for the queue is more important than a configure and forget Symphony implementation. To summarise let your needs choose your tool, not the other way around.
I don't know if you're trolling or not, but I'm going to assume no. Laravel and CodeIgniter have nothing to do with Notepad++. That's a (borderline adequate) text editor. Laravel and CodeIgniter are PHP frameworks. They're not even remotely related. You would use an editor like Notepad++ or Sublime to edit Laravel or CI projects.
I'm guessing that even if it wasn't the theme before, after /u/saramg or other HHVM contribs see this they'll say it was =P
You think that I don't know that? That is why I have been clamoring for a frikkin' enum type! I am sure that the enum type is likely one of the most simple to implement, but they never did it! What I don't care for in the enum types that are add-ons implemented by classes is that you must specify the class every time you use it. In C, the compiler knows the type and it matches what you are doing or an error is generated. And happy cake day by the way! :)
This works, when it shouldn't. Deploy to your Linux server, REKT. // index.php require 'someFile.php'; // somefile.php echo 'Hello, World!'; Trivial example, but you can also have problems just trying to rename a file that's the wrong case. You can do what I do though, and create a case-sensitive partition to keep all your code on.
Although I haven't used it I've heard good things about [zeromq](http://zeromq.org/) Also this resource: http://queues.io/
See: http://codex.wordpress.org/Moving_WordPress I might recommend a plugin such as Backup Buddy. Migrating sites can be challenging, especially if you're making any changes to the domain name or directory structure. Also would recommend a host that uses CPanel and phpMyAdmin AND provides shell access.
Yeah - I read that. I don't understand a bit of what they are saying...
Yeah. I give up. I'm gonna get drunk.
So I've just discovered http://gitter.im and set up a chat to offer help to PHP newcomers. I'm online pretty much all day ( I'm GMT+1 ) and will eagerly help you with some PHP-related stuff. I have experience with pretty much every framework apart from Laravel, and of course am really experienced in my PHPixie =) Although I prefer questions which are not framework specific. I can also help you with data structures, algorithms, advanced Linux stuff, patterns etc. Aaaand D&amp;D, mythology and stuff like that =)) **Since some people complained about having to have a github account I recreated the chatroom here: http://tlk.io/phpixie**
Assetic and Twig both have a 100% compatibility with HHVM. 98.95% of the tests of Doctrine pass currently. See: http://hhvm.com/frameworks/
Yeah.....you should really look at Supervisor.d. Having the management of workers separate from the technology that implements the queue, means that you can switch between different queues a lot more easily than if the queue tech is also managing the workers. Additionally, Supervisor.d is just awesome. I looked at the GearmanManager briefly, and it seems to be lacking basic things like being able to log output, worker restarts easily, but it also lacks advanced stuff like a dashboard for the jobs which supervisor.d has built in, or you can use a shiny version: https://github.com/mlazarov/supervisord-monitor 
It is running on a different directory to other scripts using this include (created by me and others). Searching my servers file manager it has no trace of Socket.php. It just seems weird to all of a sudden not work here whilst a almost identical script is working
Thank you! I've had a hard time finding resources on scalable architecture and haven't heard of supervisord. I'll take a look into it!
Just had a quick look at the Adminer site, and it looks like Adminer is a competitor to phpMyAdmin rather than a rebrand.
I use MySql workbench. It's pretty straight-forward. Heres a link to some info: http://www.inmotionhosting.com/support/website/database-connections/connect-database-remotely-mysql-workbench heres a link to the download: http://dev.mysql.com/downloads/workbench/ 
Yeah.. It looks like that's the way I'll be going with Supervisord. I'm leaning towards Beanstalkd, but I want to try it out before making a decision (I already got Gearman installed and ran into a lot of the same issues on CentOS). Do you use the persistent/durable queue options with Beanstalkd? One of the things I'm worried about (along with some other people in the company that we take advice from) is losing information if the program crashes. In our situation, it would be a difficult task to rebuild the queue without a lot of API calls to see where it failed.
Are you making the same exact call to `include()` in both scripts? If yes, then it probably has something to do with the the location of Socket.php.
Nice link, it seems they made a lot of progress over the past year or so when I last checked. I am super curious to play with hhvm now. thanks!
At first SQS looked like a great solution, but I'm rethinking that the more I learn about it. Since we're dealing with data uploads, we have to transform then bulk upload a lot of data. Our upper limit (admittedly, set a little arbitrarily) is 1,000,000 parent rows where each parent row can have any number of children rows. From what I can understand, adding a million items at one time will be much easier and more reliable using a self-hosted queue manager.