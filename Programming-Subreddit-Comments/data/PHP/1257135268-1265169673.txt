Sure! And for that matter, I suggest learning Haskell with a little Scala, too.
You could build a module to connect to your database layer and use hook_menu to present it back if you absolutely have to go this route. That's a lot of overhead just to use Drupal's routing.... It seems much more appropriate to use Symfony, Recess or even TinyMVC for something like this.
Upvoted and seconded.
Use imagemagick.
I've looked at imagemagick in the passed. I'm not sure how that solves the problems I'm having. Can you please elaborate? 
I would suggest [CakePHP](http://cakephp.org/) rather than Drupal.
+1 There is also a very nice SOAP datasource available for Cake that allows you to use SOAP web services as a model.
Thanks - I'll read the case-study on them a second time.
As mentioned, the reasons are mostly of non-technical nature, but I do hope to benefit from the theming system. The backend is a fair bit more complicated than just a couple of rss feeds.
What in particular caused the most problems, and what worked out good?
Thanks. That is exactly the kind of information I was after. Could you add a bit more details about using the menu system as a router?
This is more or less my plan. Do you have any links to case-studies/details on how to best do this?
Thanks for all the suggestions. I should probably have been clearer about this, but I'm not really interested in alternatives - I know there are better choices than Drupal, and I agree on a more general framework being better fitting for something like this. As I mentioned, the reasons for using Drupal are non-technical and they are a bit outside my control. What I'm interested in is not whether Drupal is the best possible choice, but rather in how it could be made to work.
Read the book "Drupal Pro Development" to learn how the API works. If you commit to going Drupal, a Lullabot module development course can help get you up to speed. I've used Drupal as a framework for a portion of a Drupal site. It worked fine. The only annoyance is Drupal tends to make changes its API every year or two, so upgrading isn't fun.
That is called *mail merging* -- Gives you something to google for. If you don't mind depending on an external service, you can use [LiveDocx](http://www.livedocx.com/) - there's a [PHP client component](http://www.phplivedocx.org/) for it too.
Amy Winebox was never hot. Neither was OSC.
agreed. cake has been our company's framework since 1.1. has really matured and is fantastic for general framework needs. keep in mind cake is not some prebaked cms like drupal. be prepared to actually write some code.
If done "correctly" you can change any of the pieces (m,v, or c) without having to muck around with the others. I put it in quotes because I've only dealt with it in theory, never changed out a part.
well, it promotes the "classic" divide of data / business logic / presentation. Three distinct, yet interrelated parts to any application. Incidentally, MFC has a similar structure, called "model, document, view" and was in use long before rails made MVC *de regeur* on the web. As you work on larger projects with more developers, you'll realize the benefit of having a logical architecture. When diving into someone else's bug, or extending someone else's functionality, you'll just "know" where to look for various bits of functionality. Additionally, it provides a clean division of labor. Your backend developers will primarily be concerned with your model and controller code. Your front-end guys will be *primarily* concerned with working up view templates, and **some** of them may also dabble in controller code. Why is this pattern better than any other? I can't say that it necessarily is intrinsically better, but it is a *good* pattern that is well understood in the industry and holds up well for most mid-sized to large projects. EDIT: format
Hasn't this been covered a million times? http://www.google.com/search?hl=en&amp;rlz=1C1GGLS_enUS313US313&amp;q=why+use+mvc&amp;aq=f&amp;oq=&amp;aqi=g1
If you are developing things alone, and you're pretty darn sure that they'll never be touched by anyone else - you're kind of save not using an MVC. I'll give all of the MVC zealots a second to throw things at me now... MVC really is a great way to go because it separates "code" from "design"... but I think people are a little bit too hardcore about saying "all things must be done with MVC!" It's frankly a personal preference... it's not necessarily always "better"... there's really two main benefits: First is that by separating code from presentation, you can divide tasks amongst developers / HTML producers more easily... Second is that if you were to decide you wanted to, say, use a totally different database or business logic engine - you could, in theory, swap them out without mucking with any of the presentation side of things. Vice versa should also be true - you can change presentation without ever touching business logic. In practice, this is often not the case. Just because you use an MVC framework doesn't mean you'll use it CORRECTLY. As a result, lots of people use the frameworks just because they were told to, and believed it would be good. In reality, they've sort of let the different layers spill over into each other a bit - thus defeating most of the purpose in the first place. At the end of the day, while I love the concept of MVC, I am not an evangelist for it because it's just not always the best/easiest way to get a project done. Sometimes it even adds more complexity than is necessary, depending on the project.
&gt;If you are developing things alone, and you're pretty darn sure that they'll never be touched by anyone else - you're kind of save not using an MVC. I used to work this way ... I don't anymore. I also used to be very *anti* framework ... I'm not anymore. Even for small projects a lot of benefit is gained from a framework like CakePHP. I've belted out simple projects in a day simply by making sure the database followed the right format and conventions and then using the Bake functionality to crank out the models, controllers, and even generic view code. A few hours tweaking the view code and it's out the door. It avoids the 'reinvent the wheel' syndrome that is so common with most hand-coded projects. All your database connections and even all your basic queries are just "done" and you don't need to even think about it. Things like form validation, data sanitization, session handling etc... are all handled nicely for you too. So, even on small projects the productivity boost is a boon. It also puts you in the "habit" of working with the framework, so that when you need to do larger projects you're already in the framework "state of mind" and you can get right down to nuts and bolts quickly.
I'm hoping this is not considered self promotion/blog spam. I've worked on this for quite some time. I'm hoping some redditors will find this useful as well :)
mcantelon has it right. If you're new to Drupal I would read up on [hook_menu](http://api.drupal.org/api/function/hook_menu) and get a skeleton module from Lullabot. hook_menu let's you tie a callback function to a path so you can output content. It's similar to other routing systems in other frameworks. There's no real case study here since the only thing you can do here is take URL arguments and output a page. You'll have to tie write all the functions that access your web services and pass that to the hook_menu callback to generate the page. Good Luck!
Well put. If I may elaborate a bit on that, I'd say that MVC has two really big things going for it. The first is that it's *a* structure, which makes it better than *no* structure. The other is that it has become de facto standard, and this adds a value on its own. I don't particularly think that MVC is the best possible way to organise most web applications, but there is great power in using something that is well understood by most people.
Thanks - `hook_menu` and lullabot looks like good places to start.
By separating the model from the view and controller, you could have multiple views/controllers all sharing the same model. For instance: a retail application might have a web front end, a simplified mobile-web front end, a call center terminal interface for accepting sales by phone, a point-of-sale terminal interface, and an administrative interface for the folks in the back office. All would use the same business logic -- inventory tracking, pricing, fulfillment, etc. -- yet look completely different, be geared for different types of user, and enable different capabilities. One model, multiple views, little or no duplicated code.
From the brief read, I noticed that *mail merging* depends on the template being ready. It seems as though this type of service is geared towards a *printing* solution. I'm already able to print just fine. I need something to automate the initial *template* creation from PDF *to* something. I only looked it over briefly, but it doesn't seem as though mail merging deals with template creation. Thank you for responding. If my assumption is incorrect, please let me know.
&gt; Even for small projects a lot of benefit is gained from a framework like CakePHP. Of course. Many of the big projects out there started off as little projects, so you might as well start by thinking big from the offset.
yup, but you get your own personal answer on reddit, it's better than asking on stack overflow or super user :P, no karma whoring
Yes as with nearly everything in this world, if you use it incorrectly, it won't work well.
What would you consider the best?
&gt;Many of the big projects out there started off as little projects... This!
Are there any online demos available? It would be nice to be able to just go to a URL and take it for a test-drive. Do you see this primarily for user/application interaction, or machine/machine APIs? Just curious, because DAV is supported as an underlying protocol in a number of applications and operating systems, but what you can actually do over that protocol varies widely.
I would also like to add that most of the good frameworks bring so much labor-saving functionality to the table. It's great having the database abstracted away for most common CRUD tasks. It's also awesome having "standardized" method calls for bringing in things like stylesheets, javascripts, etc... Handlers for dealing with AJAX... It brings together so many of the various things I used to just cobble together "in my own way", and standardizes and simplifies things so that they're done the same way every time. So much simpler when I have to go back and do maintenance.
MVC is just a "way of doing things".... Basic advantages are: 1. works *really* well with a OOP setup 2. a lot of people know it 3. several frameworks like codeignighter use it 4. it's better than coming up with some hacked-up implementation that you constantly have to tweak.
A testdrive site is a good idea. So far I've hosted everything on googlecode, where there's no way to run any PHP code, but perhaps I can put something together. I think the primary reason people would want to adopt this, is to integrate end-users' filesystems with web applications. I would personally almost always pick a simpler protocol for web service development (which I presume you mean with machine-machine api). I'm also working on CalDAV integration, but that's more of a future thing as of right now. 
Let me break it down pretty easy for you: - C (Controller) -- has two parts usually on a website: one front controller and multiple page controllers. The front controller is your index.php usually. Send all your page traffic there and it gets routed out to the page controllers where are separate page files often under something like a folder called Controllers. The page controllers push/pull data to/from the models and then push/pull data to/from the views. - M (Model) -- basically two things: your collection of useful classes, and your classes that abstract your database calls as class methods. - V (View) -- your page template of XHTML with inserted variables It helps in these ways: 1. Your page routes are managed in a logical way. If you can see a URL, you will know where to find the file to edit to change something, often times. 2. When you extend the application, you often have less duplication of effort because you'll have many of the models created and may only need a few more. Therefore, you just add some more page controllers and some more views, tie it to your existing models and some other models you might create, and *poof*, you whip out a new feature fairly fast. 3. By using a View, or template, you separate your PHP from your XHTML. In a nutshell, you separate your PHP from your SQL from your XHTML, making it easier to read, and you can extend the app faster through models and routes. It's also a team-friendly gameplan, where one team member, say, may only work on a small set of models and not disturb your work too much.
Unless something has changed, ImageMagick imports pdf as an image file. So it would not be what you are looking for.
Thanks for your responses. I think I am understanding it's use a little better in PHP, but still seems like it might be over complicating things. As one diagram showed ( need to try and find it again ), one of the three were responsible for handling $_GET, $_POST, etc, while the other handled $_SESSION and so on. I think I am still having a time understanding what and how the business logic differ. I understand separating the presentation, but also have problems with that on some levels. Oh well, guess I will have to try and get my hands dirty with some working examples to see what it's all about. 
Take a look at this [link](http://www.symfony-project.org/book/1_2/02-Exploring-Symfony-s-Code).
IMHO, as long as you do not mix PHP with HTML you're ok. You wouldn't do it with XML or other output, right?
Good article to get started with Zend_Form. If you don't know it can be a bit of a bummer for newbies.
I love Zend_Form but there is a way easier way to do the view script with setElementDecorators. `// all elements added then...` `$this-&gt;clearDecorators();` ` $this-&gt;addDecorator('FormElements')` ` -&gt;addDecorator('HtmlTag')` ` -&gt;addDecorator('Form');` `// above gets rid of dl dd dt nonsense` `// sets decorators for all elements` `$this-&gt;setElementDecorators(array(` `array('ViewHelper'),` `array('Errors'),` `array('Description'),` `array('Label', array('separator'=&gt;' ')),` `array('HtmlTag', array('tag' =&gt; 'div', 'class'=&gt;'element_group'))` ` ));` `//sets decorators for single element (being $submit in this case)` ` $submit-&gt;setDecorators(array(` `array('ViewHelper'),` `array('Description'),` `array('HtmlTag', array('tag' =&gt; 'div', 'class'=&gt;'submit_group'))` ` ));` Then in the view you just do `&lt;?php echo $form;?&gt;` Then you don't have to type out the html and seriously short php tags?
It seems difficult and overcomplicated at first. But once you understand it, you will probably love it. The Controller is basically for handling GET, POST(, PUT, etc) and the SESSION stuff. It decides which data should be loaded/maniuplated via the models and decides which view is loaded and which data is passed to it (the view). The model is your access to data. The reason this is taken away from the controller is mostly clarity and (very important!) independence on data sources. Your controller shouldn't care where your model gets the data or stores it. The model does all the work. You can for example have a model for a generic user. This user can be stored in a database, text files or xml files or any other medium/service/whatever. Thusly you can have different models for accessing the generic user from the different sources. Now you could just set a config variable to tell the model which data source to use and don't have to change anything in the controller to switch between sources. The views are your templates... Not much more to it mostly. In some variations they may access models, in some they may not. All of this is however left for the developer to decide. There are vast amounts of variations of the MVC pattern. Have fun exploring the possibilities. :)
Symphony is one of the more complicated frameworks out there. For one that's a little more accessible from square 1, take a look at [CakePHP](http://cakephp.org). Specifically, go through the [Create a Blog tutorial](http://book.cakephp.org/view/219/Blog), as that tutorial shows just how easily you can go from nothing to a fully functioning (though basic) web app in about 15 minutes. The tutorial touches upon all of the major aspects of the framework and gives you something to continue to play around with as you add on more functionality either out of your own head, or follow the[ ACL Tutorial](http://book.cakephp.org/view/641/Simple-Acl-controlled-Application) which adds in access control functionality.
I think the MVC Song does a good job of explaining it: http://www.youtube.com/watch?v=YYvOGPMLVDo
Thanks, both links help. The Symphony link made things a little easier as well. It's sort of along the lines of what I do generally, as long as it's not a large project. I originally asked because I am working on a CMS, and in the future I would probably just give the code out freely. It is fairly extensible now ( allowing plugins and all ), but wasn't sure if I did release it, if MVC would be the way to go to ease development for others. Thanks for the links.
Honestly, I HATE the whole concept of decorators. Sure they work ok (I guess) for simple forms but if you have a complicated layout you're going to spend way too much time trying to get it to work it's just not worth it. For example, how would you lay this the blow form out using decorators? To me, you can't without giving up your soul and sanity. http://blog.ericlamb.net/wp-content/uploads/2008/12/I-Am-Legend_1253650807253.png 
That is totally a job for display groups [link](http://framework.zend.com/manual/en/zend.form.forms.html#zend.form.forms.displaygroups) and css. I understand that they aren't for everyone, but I find them very usefull. I've done some with them as complicated (for backend stuff). It's a little steep to use them the first time or two, but after that it gets better. Note: this was on a site using the whole framework, not just using Zend_Form.
Isn't the storage medium another, deeper, layer than the model? I always get the impression the model is a little more subtle than just "fetch data from a stored".
I think we are well beyond hobby scripts here. Application development requires a decent methodology to ease maintainability.
Basically the solution was sold on being Drupal. There are all sorts of thing wrong with that, but it's a little too late to do anything about for this particular project. For now, the best thing to do is just go Mac Gyver on it.
I wouldn't call anything the best. There are situations where a strict MVC separation is in order. For example, if you need to allow user/data driven views. Or if you have an organisation where view and controller are implemented by different companies. For most web applications, I prefer a much tighter integration between view and controller, to the point where calling them *view* and *controller* is a misnomer. On the other hand, I often find it useful to segment the presentation layer (view+controller) into a hierarchy of smaller components. We can call them *widgets* in lack of a better term.
I wouldn't worry too much about MVC just yet; I would focus on understanding why one ought to separate code into different layers. MVC will come naturally after that--the MVC frameworks you may be looking offer an Implementation of an MVC architecture and usually pile a lot more on (this is neither good or bad). I think of it like this: Model Layer * Data Transfer Objects (ex: a Person class with $id, $firstname, $lastName and $email properties with setters/getters for each). * Data Access Objects (Ex. a class with Create, Read, Update, Delete methods interacting with a datasource). * Business Objects (Ex: A class allowing you to disable/enable a user). View * Layout Templates (Ex: HTML wrapper stuff) * View (Ex: Add/Edit User form, Search User form, Search Result, Details page) Controller * Takes a request (The get and post parameters, interacts with the model and pumps the result into the view/layout). Those different types of classes in the model can be merged together--I'd recommend always keeping your data access separate: Person { $_id; $_firstName; $_lastName; $_email; $_activeIndicator; public function __call($method, array $args) { $accessor = substr($method, 0, 3)); $property = substr($method, 3); switch($accessor) { case 'set': if(count($args) &lt; 1) { throw new Exception(sprintf('%1$s() says "learn to code".', __METHOD__')); } $this-&gt;_$property = $args[0]; break; case 'get': return $this-&gt;_$property; break; default: throw new Exception(sprintf('%1$s() says "learn to code part Deux".', __METHOD__')); } } } public static function load($id) { $person = new Person(); $person-&gt;setId(1); $person-&gt;setFirstName('John'); $person-&gt;setLastName('Doe'); $person-&gt;setEmail('john@doe.com'); return $person; } public function save() { //dispatches to DAO class} public function isActive() { return $this-&gt;getActiveIndicator() ? TRUE : FALSE; } /** * Convenience Method returning the Person's full name. * * return string */ public function getFullName() { return rtrim($this-&gt;getFirstName() . ' ' . $this-&gt;getLastName()); } } 
That's interesting; I'll have to look into it :) And yes, short php tags. Loud and proud dammit. I don't need no sticking standards. Nah, just kidding; obviously it was laziness dude. I know better.
Ok, sounds like a deal. I'm in.
If you're parsing bbcode or html, you'll also want to account for any tag attributes, such as [tag=option]value[/tag]
I always turn off the short tags in php.ini just so I don't use them. It kills me to work on other peoples' code when used.
Your link doesn't work. :-(
Most people don't speak of the actual storage medium in terms of MVC. Your model gathers data and forms the structure of what that data should be, whether it be from a db or another source. Eg, I use a four tier system. The models, which gather specific data about a class of information. The controller/router, which takes the data from input and sends it to the correct place. Modules, which simply gather data from the controller and the models and prepare it with the logic. They then send it to the templates which display the data. You could also say the database and the style would be two additional tiers if you wanted to.
Well I was not praising for symfony. OP wanted a sample example of MVC and the first portion of that page has a good demonstration of making a normal php code to MVC.
Here some old blog post of mine:- http://www.k4ml.com/node/188 That's for 4.7 though, a lot has changed since then but you can always look at the API doc.
Good question. Yes, most MVC approaches do abstract the storage medium even further than just the models. (some even with 2+ layers below the model. like model-&gt;table-mapper-&gt;specific db engine) However for a beginner that may be a little too much. (it sure was for me, when I began learning about MVC)
...and I'm not knocking Symfony. It's a great framework and I know of some high-volume sites that were built upon it. [RueLaLa.com](http://www.ruelala.com/) is one example. However, this framework basically *requires* command-line access and there are significant (but resolvable) issues if you need to use it in a shared hosting environment. It's a great and powerful framework, but not well suited to someone who wants to get their feet wet in MVC, or create something for wide distribution due to the hosting requirements. CakePHP isn't perfect either, I just think it's a little more accessible for a beginner. NOTE: I hadn't followed your link, I just hovered it and saw that it went to Symfony. The discussion on that link is a decent one. 
&gt; listen to the live recordings /in ralph voice: That's unpossible but hanks for the link :)
That's what I get for blindly copying &amp; pasting descriptions from the Zend website. I have been suitably chastened and will read my titles more carefully before I submit them. Glad you enjoyed the link though.
Yes, I guess the next step from here is to actually read through some documentation. This has given a bit of an idea about what to look for, so thanks.
When did John Hodgman start presenting at Apple conferences?
All I hear are owl**s** hooting.
Depends on the site, some sites will allow you to provide a URL which they will (typically) send POSTs to when a transaction/similar occurs, allowing you to update your site accordingly.
It looks like all those sessions are from 2007 and 2008. Are the 2009 ones hidden?
Well, facebook uses memcached to cache database calls and can detect a database change to know when it needs to reget the info. Memcached, in turn, uses libevent to do that. It's not push, though. Memcached is just notified when the data it has cached is no longer valid, then next time it has to use the info, it goes back and gets it again. However, if you wanted to do it yourself, libevent would be the place to start. It basically runs on your server, can detect an event, then do *something*. However, like you said, websites are stateless, so there's only so much you could do. It's not like you could send unsolicited info down to the user's browser. Even if you could magically access a specific user's session and direct the traffic across the Internet to the user's machine, browsers are also pull-based programs. It wouldn't even be listening for the traffic unless it initiated the request. But I guess it really just depends on what you want to happen when some event occurs. As long as it's not sending info all the way to the end user (without a client they install, anyway), you could do just about anything. EDIT: Dunno why I'm being downvoted... AJAX is *not* push, which are the other suggestions in the thread. libevent is the closest to pushing data to a user, and it still wouldn't be able to be done via a web browser.
polling with ajax.
You're after the likes of Juggernaut - http://juggernaut.rubyforge.org/ - you can easily adapt the flash side of things to work with a PHP server. There's lots of push technology out there - it's just not used all that much, just yet - it all revolves around using flash (or java, urgh) as a bridge to javascript.
There are a lot of methods to doing this, but there is no true "push to browser" functionality anywhere. If there were some way to make javascript multi-threaded, this might be possible. But until then, you'll have to stick with the old fashioned way of doing things. There is one "pseudo-push" method that a lot of ajax apps use, like FaceBook and GMail. This is done by sending a AJAX request to a script that 'sleeps' until data in available. This can be done in PHP rather easily by setting the max execution time to 0, and using a few sleep() calls to check your DB for new information every second, half second, or how often you need. Once new data is available, the ajax request returns the data, then you set up the same ajax call again, and so on recursively. This means there is always some AJAX call running in the background looking for new data. If javascript were multi-threaded, you could theoretically have multiple AJAX calls going on at once, so this main AJAX request won't interfere with the rest of your script, but unfortunately it is not. So the downside of doing this method is you can't call multiple AJAX requests at once (some browsers handle this differently), which could interfere with other code or javascript running on the same page. I have yet to find a easy way to implement this kind of a "pseudo-push" system, but it is the best option out there right now.
Also look at: * [Orbited](http://orbited.org/) * [Comet](http://is.gd/4NvB6) * [HTTP Streaming](http://ajaxpatterns.org/HTTP_Streaming) edit: Wikipedia URL's ending with a right parenthesis breaks the reddit link system... Thus the is.gd url in point 2.
This has nothing to do with PHP, and everything to do with HTTP. It's a stateless protocol. The only way to do this is to poll your server every X seconds, AJAX is probably the way to go.
\\)
Is that owl you've got?
Recommend you read http://roy.gbiv.com/untangled/2008/paper-tigers-and-hidden-dragons
I really like SabreDAV, it seems to be the best way to provide WebDAV via PHP. Thank you for that piece of software! :)
I worked with Drupal twice and thought it was a terrible codebase. Maybe it was my lack of experience using it, but I always thought I could code it better myself in less time than integrating new things into Drupal. Especially modules like Views and CCK, who are praised by the Drupal community, were very annoying to work with. edit: I do have a small framework of classes (Authentication, User management, Locale, Database, ...), which I only have to configure to the requirements of a new project. That saves a lot of time in my case.
Google "comet connection". Things like jQuery have it built in. 
an idea: * set up ajax listener on a subdomain (ajax.example.com) * send sleepy request to that subdomain * i wonder if the browser would then allow another ajax request to the main subdomain (www.example.com) * i wonder if the same origin policy allows data from ajax.example.com to be passed to www.example.com
This is known as '[long-polling](http://en.wikipedia.org/wiki/Long_polling#Long_polling)' and it most definitely is what 99% (I can't say 100% for obvious reasons) of websites use for their pushing purposes.
I know you're using PHP, but I'd like to suggest you at least take a look at [icefaces](http://www.icefaces.org/main/home/) for next time. It's Java, but it does the bulk of the work for you and they'll be coming out with a new version soon.
Thank you all for the responses...I obviously got some reading to do. Feel free to continue contributing though, I've got lots of spare time. :)
no need to wonder, run an experiment. 
great, I'll just tell my boss I can't do any work for a few hours while I slap together a few test scripts for this :P
A-Fucking-men. Frameworks are to performance like lead balloons are to flying. Prove me wrong.
There are two performance metrics that *really* count, at least on high traffic or high revenue sites: a) The time it takes for expensive programmers to complete projects and b) the time it takes for users to go from page to page on a site. Frameworks help with a), and cheap hardware can help with b) if there are actual, measurable bottlenecks. Code-wise, there's (pretty much) always going to be a less memory intensive and CPU intensive way to deliver content than by using PHP. But it's often substantially cheaper to just throw another server at the problem.
When people started using interpreted languages.
Kohana.. -Originally- a fork of CodeIgniter, its evolved far beyond CI and no longer shares a single line of code. If you want a framework that simply doesn't get in your way, has clean, readable code and takes full advantage of PHP5 OO (unlike CI which refuses any advancement in order to continue supporting PHP4 - a version of PHP that is no longer supported!)
You beat me to what I was thinking, but I want to add Joel's wonderful quote "Programmers are expensive, hardware is cheap"
CI is a great beginners framework, but - Kohana is just as well suited to both beginners, and pros IMO..
**[Kohana](http://www.kohanaphp.com/)** — MVC / OOP / PHP5 / Based on CI / OSS
**[Cake](http://cakephp.org/)** — MVC / PHP4&amp;5 / OSS
**[CodeIgniter](http://codeigniter.com/)** — MVC / OOP / PHP4&amp;5 / OSS
I like the extensibility, how you can override things at the application, level, module level. It's OO. It's the only framework I know so far when it comes to PHP but it is a good one. Although it doesn't have the form abilities of django, but not many do.
**[Symfony](http://www.symfony-project.org/)** — MVC / OOP / PHP5 / OSS / PDO
I just love it. Pure PHP5 and still really flexible. Every known thing that isn't PHP5 can still be implemented for example. Easy to deploy et cetera.
**[PRADO](http://www.pradosoft.com/)** — MVC / OOP / PHP5 / OSS
**[Zend Framework](http://framework.zend.com/)** — OOP / PHP5 / OSS
It's huge (has a ton of functionality). Documentation is pretty thorough, though it could use more/better examples. High quality code. PEAR channel available. Very actively developed. Wide open models.
this is by far the best. Also, most importantly the most promising framework.
Should be "Zend Framework" -- Zend produces many other projects that are less than useful and are not Frameworks.
Fixed.
My experience is it works fine if you use it exactly for what it was built for - any deviation from that and it loses its value quickly. Also the zend forums are not very helpful, but they were getting better last time I checked.
[Solar](http://www.solarphp.com/) -- MVC / OOP / PHP5 / OSS
[Agavi](http://www.agavi.org/) -- OOP / PHP5 / OSS
[Yii](http://www.yiiframework.com/) -- MVC / OOP / PHP5 / OSS
[Akelos](http://www.akelos.org/) -- MVC / OOP / PHP4&amp;5 / OSS
[BareBones MVC](http://code.google.com/p/barebonesmvc-php/) -- MVC / OOP / PHP5 / OSS
You can't say there's any bloat in that one.
I'm curious as to why people would say they don't like PRADO. I've personally never used it, but I appears to be a pretty solid framework. What am I missing?
I can't imagine this framework getting many votes, but I like it because it reminds me to use just what I need and that there is beauty in simplicity.
[Seagull](http://seagullproject.org/) — OOP / PHP4&amp;5 / OSS
You forgot MVC. In my experience it's a very diverse framework, easily applied to projects that are already well developed, or can be used as a base around which an entire project can be built. Zend tool is excellent for starting new Zend MVC projects, and the Autoloader that Zend Tool employs by default makes using Zend components as easy as simply calling the class. Documentation is probably my biggest gripe. There's a lot of user-generated stuff out there, but new releases have such huge additions, you end up having to search though a lot of how-to's for older releases to find one for the release you're using. I've noticed this a lot with 1.9 since it's pretty new... there is a lot of stuff out there for 1.7 and 1.8.
It's bloated and slow as hell. The author basically tried to port ASP.NET to PHP, which is not good. There is huge viewstate that can be up to a megabyte in size, or more. No one uses it, either. The community is very small compared to everywhere else.
I'd just like to express my love for Kohana. I just did a benchmark to see if it was faster then Yii. Here are my results running on a dual core with 3gb ram running ubuntu. APC was enabled. This benchmark only shows the overhead of the bootstrapping time (ie, hello world). The only reason I did this is because Yii claims to be a speed demon. Yii requests per second: 980 Yiilite requests per second: 780 (im guessing it preloads classes I dont need for "hello world") Kohana requests per second: 800 Explicitly including common classes in index.php (like controller, request, logger, config, etc): 980 Disabling logging and profiling: 1200
I downed this, so i guess I'll give a reason: I find I always end up having to hack up the core libraries, or write my own. I do not find it easy to extend, and sometimes I find they way it loads helpers/libraries, I have a tougher time breaking up my logic. In short, I feel like I'm doing the same amount of work as if I just started out with a bootstrap/url router.
I think this is the best framework for someone who might be a little new to OO in PHP and frameworks in general to cut their teeth on. They have really good documentation and it's easy to use to create a small to medium sized application quickly, while still sticking to MVC and OO whenever possible. Sort of "bridge" between procedural and OO, IMO.
could you do CI as well?
When hardware became cheaper than developer time. Personally, I've seen more website problems caused by unmaintainable code than by server load. At least, I have on properly configured servers. And if your server isn't properly configured, then the fastest code base in the world isn't going to help much.
I installed CI and edited the welcome controller to simply echo "hello world", instead of loading a view like it was doing. I did this because neither kohana nor yii loaded views for my other benchmarks, theirs was an echo too. Base install, with above modification: 900 I don't know of any tweaks to do. If anyone knows of any, chime in.
[Twitto](http://twitto.org/) — Less than 140 characters / PHP5.3 / Not secure require __DIR__.'/c.php'; if (!is_callable($c = @$_GET['c'] ?: function() { echo 'Woah!'; })) throw new Exception('Error'); $c(); 
Cake is also OOP, please revise. Cake is a fairly easy to use and flexible framework with an active developer community.
I learned Zend Framework about 6 months ago. I can't say I'm a fan of how they architecture their MVC, but it works--there's way too much magic going on for my tastes. There's a lot of good code in there and great concepts, however. I can't agree enough that deviating from Zend's intentions causes a huge loss in productivity.
I don't know, i'm not a hardcore programmer, but I can see CI fitting my needs for a loooong time. Whats the big piece that kohana has that CI doesnt, that I can look into to sway myself? edit: im not trying to be fanboy-ish, i've only used CI for about a month now :P
You are doing it wrong. Spent some more time with codeigniter, I have found it to be the best framework in every sense.
What exactly was it built for? Considering it's built to be flexible it doesn't really make sense to say it works fine if you use it exactly for what it was build for. What are you trying to do that is such a massive deviation? 
It gets my point for quick/well organized/hands on documentation.
I have used this in a few projects. Very easy to use and understand, but also very powerful. Also has a very active development team that will try to accommodate most feature requests and fix bugs very quickly.
[Maintainable Framework](http://framework.maintainable.com/) -- MVC / OOP / PHP5 / Based on rails / OSS
lol no it doesn't
There are multiple arguments for and against the "hello world" benchmark. I did [some of my own](http://tjwallace.ca/blog/2009/05/frameworks-and-web-servers-benchmarked/) a while back and found that out of the box Yii was on top. It's nice that you don't have to muck with stuff to get the best performance (although you could probably tune Yii even more, disable debugging, removing the logger for example). I took a quick look at the Kohana docs and immediately found something I don't like. To access the session (in a controller for example), you have [explicitly get the session instance](http://docs.kohanaphp.com/general/controllers#construct). Same goes for [using the database inside of models](http://docs.kohanaphp.com/general/models#usage). Yii takes care of this all for you. The controllers already have direct access to the session, and the models already have access to the database (well actually the user hardly ever has to deal with the DB class at all, the active record class take care of all of it). Yii has also just added a [testing framework](http://www.yiiframework.com/doc/guide/test.unit).
doesn't get on your way, active community
Using it outside of the bounds of what is expected. I agree that it is very flexible and that's one of the reasons why I like to use it, but on a couple of occasions it was clear to me that only limited testing/use was made of certain components. Take for example the lucene search component. I used this to make a search for a forum/ecommerce site. When running with a few thousands indexed records, the performance was reasonable. But when I added the full 700K+ it took 18+ hours to index on a dual core xeon with plenty of ram. It built a 400MB+ index and a simply query took over 256MB memory and well beyond 30 seconds. When I later decided to switch to solr, the index time was just a few hours and the query time was about 1 to 1 1/2 seconds. Obviously some of those limitations are because of php, not just the framework, so I'll give another example once again found in lucene. The search highlighting. A really nifty feature of the zend implementation is that you can highlight the search terms in the results. This is very helpful, but if you want to change it from the ugly default colors, you're in for some pain. The color values are hard-coded (as of 1.8) as well as the html used to wrap the text. I found no convenient methods to override either and it was too intertwined with the query parser's logic for me to simply extend and modify. So my point is this - if faced with a small task (such as pulling events from a google calendar) I would totally use the zend framework to quickly put something together, but if something more involved was needed, I personally would build out something custom using php's wonderful builtins.
cake is also based on rails
I'll weigh in on Symfony. I was forced to learn it for a job and thought it was the framework for Java developers who hated Java. Later I softened and just concluded it was just too much for most web projects. Sympal is great but Drupal is easier. Doctrine is pretty much a masterpiece... except that I like writing SQL. Symfony is brilliant but I prefer simplicity over power and Symfony is the opposite of simple.
My first framework, used it on 3 sites now. A few gripes: a couple of the built-in functions are somewhat buggy (the form helper stuff can be unpredictable when working with select boxes / radio buttons, and the validations seems to require you to set 'empty' rules if you want a field's value to be repopulated after (invalid) submissions). Its url\_title() function for turning strings into URL components makes some odd default choices - strings will Look\_like\_this, and not look-like-this, which I guess is personal preference, but I think the latter is way more attractive for a URL. Some of the time I've found myself spending hours working around the inbuilt limits of CI (eg URLs, no $_GET access, etc) but once you figure this out, it's worth it. That said though, it's helped me move much more quickly with my application, and adding new components is way easier due to not having to spend hours writing form processing code etc. I might try CakePHP next, but I'm overall pretty pleased with CI. Great community and documentation too.
I started using framework with ZF so my experiences with the other is very limited. ZF is a brillant piece of work. It covers lots of thing and is well thought and maintained. There is almost too much releases. Here is my grips about ZF : documentation : looks complete at first but somehow seems written for people who already know what they read the doc for (is it clear ?) and sometimes you sadly have to look the code or find a tutorial by someone who lost hours doing that. For exemple Zend Application : one day your boostrap is fine, the next day you have to use Zend_Application branded as the new miracle thing, except it breaks your autoloading mechanisms along your naming for models, application stuff in your boostrap etc, so you end up reading that fantastic doc ... so fun :) tutorials : be prepare to find outdated tutorials everywhere because ZF evolve too quickly for the last two years. Even their Quick Start used to change a lot month after month. components : lots of it :) Good thing, they are more and more integrated to each other. Hard part is, you'll find that eventually you will have to read the documentation of more ones than you thought at start. There is so much components that when I test other frameworks (I sometimes want to find a simplier framework) I'm always like "that's it ?". Zend Form : good idea etc, but the guy who designed decorators must be only half-human (the hilarious removeDecorator('DtDdWrapper')). jQuery vs Dojo : because they have an agreement with Dojo (that no one cares about) they keep the jQuery integration outside the main branch, so you get less support for it and for each new version you have to download the full package just to get jQuery. Autoloading : great concept, but I sometimes get lost to where put my files and get them loaded ... "framework" ? zend_tool works to generate a basic project but it could be more complete for a good start (no "forms" subfolder for exemple or a decent Boostrap (no autoloading ?) ).
Lucene requires a lot of memory to manage its index caches, to make it even reasonably efficient. For that reason, only a daemon makes sense, so that caches can be kept from one request to another. The Zend Lucene library, written in PHP, effectively starts from scratch on every request. solr is the dog's (a good thing). I juts wish there was more information available on setting up practical indexes, i.e. how best to handle different types of data and structures wrt multi-faceted searching.
Well, adding $this-&gt;db = DB::instance(); isn't really that much work to do once in a project. (same goes for session of course) And you don't have to touch the DB that much in Kohana either, since ORM takes care of all of it. ;) edit: Also, the database documentation part is a little pointless. (creating a constructor that does nothing but call the parent::_constructor) Thus you don't have to do manually load the db instance in a model.
&gt; My real goal was to ripped off jQuery Validator as shamelessly as possible. now make a quick javascript function that uses ajax to call your PHP validator. This way we can write our validation rules once in the PHP and the same logic can be used on the front-end too. Nice script. Add ukphone and ukpostcode please :0)
&gt; I would rather see something done with classes no, [KISS](http://en.wikipedia.org/wiki/KISS_principle).
Thanks for the analysis. 
I think he forgot the link.
Awesomesauce. It made it to the top.
To be able to access the session and database variables straight from the controller on every request, all you have to do is this: class Controller extends Kohana_Controller { protected $session = Session::instance(); } Here's an example of it in use: class Login_Controller extends Controller { public function login($username) { $this-&gt;session -&gt;set('username', $username) -&gt;set('login_time', time()); } } I didn't include the database because you don't have to get an instance of it to do queries, they're all static methods. To use this, you simply put the new controller definition in a file called controller.php in your application/classes folder. This also shows the excellent extensibility of the Kohana Framework - I am able to use a custom controller that overrides the default one, yet I can still refer to it by "Controller", because Kohana will look for my class in the Application folder before looking in the System folder. Now in reference to you saying "Hello World" benchmarks don't matter - they do in some cases. In this case I probably wouldn't make my decision about whether or not to use Kohana over Yii simply for a 20% increase in speed (that's not that much), but you can bet your ass that when Symfony only gets 125 requests per second and Kohana gets 10x more it means something. I understand the argument that no one writes a Hello World application, but what this is measuring is the baseline performance of the frameworks. If symfony PEAKS at 125 requests per second without even adding any application logic, then I'm going to stay the hell away from it. Plus too, it's safe to assume that if the bootstrapping process is that slow then the rest of the classes are that bloated, too.
It's just a concept framework, I can't imagine anybody using it in it's raw form.
It's not that you're wrong, it's that the alternative is a disgusting convoluted mess of tangled home-grown code that adheres to no standard, no documentation and, after the constant winding road of scope creep, has become just as slow as an unoptimized framework. It's easy to recover speed out of a framework. It's hard to refactor an entire codebase.
This framework is very good and my company has used it for many projects. Unfortunately the documentation is ass, which makes the learning curve very steep, which explains all the downvotes.
That all depends on your programmer(s), personally I've never seen my PHP code bloat as much as it does when you use a framework. And you can write home-grown code that is well documented, follows a standard and performs well. If anything I'd say frameworks are harder to work with, since any significant changes to it make updating to newer versions much harder, especially when the framework itself consists of a few hundred KB of files. I understand that for a pretty sizeable percentage of people frameworks do make their jobs easier, but not in any way that experience or spending time reading the php function documentation won't fix.
http://twitter.com/zeldman/status/1470855033
Have you tried many other frameworks? Like someone above said, the form library is rather buggy. And it's rather ugly making their Upload class work for multiple files.. Does better to just write your own. CI is for sure easy to get into, easy to learn the MVC pattern and OOP, but when it comes to writing a little more complicated apps, it does not greatly speed up development.
I am aware of that principal. However, I could argue that a class approach would in fact be simpler.
Also, if you are looking for performance, [DooPHP](http://doophp.com/benchmark) might be something to look at.
See, and that all depends on your framework(s). While it is possible to write home-grown code that is "well documented, follows standards and performs well" it is rare when that happens in the real world. So when they move on to the next job, they leave behind this one-off that, while they feel is perfect and they know inside and out, is an upkeep nightmare. As for updating, you're doing it wrong. You don't touch the framework's libraries/core, at least you shouldn't have to with a good framework.
Why don't you add that to the list of frameworks?
**[recess](http://www.recessframework.org/) - I've only played with it, but it looks good - thought it should be included. I'm a Kohana dev.
A world of this. I'll take something that people can write/extend/maintain easily over something designed just to be fast any day of the week and twice on Saturday. Hardware keeps getting faster; it is not clear that developers do.
Here is a PHP framework that I wrote and evolved over the past 3 years: [Serenity Application Platform](http://kinderism.net/projects/serenity-application-platform) Pros: It's pretty fast, and extremely easy to setup and use Doesn't force you to use it just for MVC web apps Cons: I did some documentation, but not a lot :( I don't do the whole company thing anymore, so Serenity has become a stale personal project. If there was interest in it, I would pick up development again. It's running quite a few intranet setups for various companies, including the federal contractor that I work for right now.
I had to learn symfony for my current job. It was easy to pick up the basics and I was writing new features for the site within a few weeks of starting. That was 2 years ago, and I'm still learning new things about symfony. It's not hard to learn the basics and go, but if you want or need a very powerful framework, symfony doesn't hold back. There seems to be a pretty active community for support. Plus there are many great (and some not-so-great) plug-ins that you can install in to your projects to help.
What does "best" mean?
I used to be alone all the time, wandering the world like the lost soul that I was... looking for a home - in every sense of the word. Flowers had no color and a baby's laughter made no sound. Then I found Kohana, and all that changed.
[DooPHP](http://www.doophp.com) -- MVC / OOP / PHP5 / OSS
Done.
Awesomely silly, I say.
Whoa so this is what's caused the spike in traffic to my google code project today! Thanks everybody for the interest and kind words. I will say though, that I actually got to use this in its raw form, for Cisco, on an embedded device, where size and performance of course matter very much.
I've tried Digital Point and rentacoder. I never made a lot and really only visit to see what's around, if anything is interesting and worth doing as a learning experience. My last project was found on DigitalPoint and while it was horrible pay ( I accepted someones request of $25 to bridge their site with Vbulletin ), I got to learn a lot and actually have some work to show that was completed quite nicely on an existing site with thousands of members. Nothing went wrong and the integration went well. Gained a lot from it that wasn't monetary, but nothing to make a living off of. Aside from that I will see some designs I will put together in about 20 minutes for around $50 each. That seems to go over well ( not well enough to make a living from ).
One more thing. I have been playing with MVC and actually am starting to like it. One thing I do not like though is the URL structure; doesn't look to good for SEO purposes. Is it possible to rewrite these values so you can achieve a working MVC but end up with something like... site.com/content/this-is-page ? I am not asking for an answer or a complete guide to doing so, just some pointers in what to check for, etc.
Whatever you want it to mean.
You realise that means that everybody will have different ideas about what they're voting on and thus the result of the vote says absolutely nothing about anything?
I'm not sure that that's true. With widely divergent criteria, if one option still comes out at the top, that means that people who would otherwise disagree, agree that the top option is the best. That says even more than if we had strict criteria for voting. In any case, this wasn't meant to be scientific, I just wanted to get an idea of what some of the better PHP frameworks out there are.
Why don't you just try submitting it again?
&gt; I'm not sure that that's true. With widely divergent criteria, if one option still comes out at the top, that means that people who would otherwise disagree, agree that the top option is the best. That says even more than if we had strict criteria for voting. So you're betting on the wisdom of crowds. I guess there's some truth in that, but there's certainly some pitfalls too. [McDonalds serves about 52 million meals a day](http://wiki.answers.com/Q/World_wide_how_many_people_served_daily_at_Mcdonald%27_s) - Does that make it good food? &gt; In any case, this wasn't meant to be scientific, I just wanted to get an idea of what some of the better PHP frameworks out there are. That's an absurd sentence. You want to know something, but you don't want that knowledge to be based on facts. What then? Emotions?
(BTW, I just got done working on a project that was taken from the old developers because they didn't deliver on time. It was a freaking nightmare which used the Akelos PHP framework. So I'm a little jaded right now.) It's odd that no one has mentioned the obvious issue of crappy developers writing crappy code regardless of a framework or not. Yes, using a framework adds a familiar environment but that's all. In essence a framework is just an extension on the language and it's not like a crappy developer was writing good code to begin with; a framework just gives more opportunity to screw up the project not less IMHO. So what if we all know where to look for files? Big. Fucking. Deal. Modern IDE's can handle that for us or. And, you know you could always, you know, look for them like in olden times right? So, what happens when you have a crappy developer use a framework? Well, you get fat controllers with crappy code. You get views with the entire HTML page in EACH VIEW. You get models that look 80% identical. You get the same copy-paste nonsense you would have gotten without a framework. You get reinvention of as much as possible, and duplication of that again. (But at least I didn't have to look for the code?) And then there's the learning curve required to use a framework. Every time I encounter a project that uses a framework I'm not familiar with, so much time is spent learning a new framework and not completing the project. This get's way, WAY, old. No, a framework is really only beneficial when you have a good developer who plays by the frameworks rules. Without that, a framework is freaking useless and adds to the problem more than it solves.
&gt; So you're betting on the wisdom of crowds. I guess there's some truth in that, but there's certainly some pitfalls too. McDonalds serves about 52 million meals a day - Does that make it good food? It makes it popular food that fits the requirements of a great many people — price, accessibility, taste, speed, etc. &gt; That's an absurd sentence. You want to know something, but you don't want that knowledge to be based on facts. What then? Emotions? This is based on facts, it's just not a strictly scientific gathering and evaluation of data. Think of this more as brainstorming for good frameworks rather than a definitive ranking of one person's specific idea of "best".
I wish you could tell me how this compared to Zend Framework
You can go from PDF to SVG to whatever you want with IM - we use it for assembly of photo books based on user provided content posted as an SVG from flex.
You're stretching the meaning of the word "facts". If they are undefined, then they can hardly be called facts. &gt; Think of this more as brainstorming for good frameworks rather than a definitive ranking of one person's specific idea of "best". OK - the discussion below each framework are interesting enough. Perhaps I'm being over critical, but it's just that this whole *vote-for-the-best premise* really smacks of popularity contest to me, and I think that is unfortunate.
URLs have nothing to do with MVC. Most MVC frameworks have a way to set up routing rules. [CodeIgniter](http://codeigniter.com/user_guide/general/urls.html), [Symfony](http://www.symfony-project.org/book/1_2/09-Links-and-the-Routing-System), [CakePHP](http://book.cakephp.org/view/46/Routes-Configuration) It really depends on how you design your app. You can use mod_rewrite and a .htaccess file to do pretty much anything you want with the URLs if you're not using those frameworks, but they make things easier.
Well according to [this](http://www.yiiframework.com/performance), Zend is 1.66x faster than symfony. I benched symfony at 125 r/s, so on my system Zend should be about 210 requests per second. Zend and symfony are both very clunky, but they also have a huge following. You win some and you lose some.
I started with CI. It was my first ever framework. I loved it, especially its documentation. Looking at Kohana's source, it just feels so much cleaner and friendly. It's also much easier to extend. It's pure PHP5. It has autoloading. CI however has a much larger community, has many more modules for it, and has much better docs. But if you like CI, I HIGHLY suggest checking out Kohana. I tried it and never looked back.
Well, I guess thats next on my list. CI is also my first framework of any sort, and I'm loving it. Maybe I'll wait to get really used to the MVC idea before I move on. Thanks!
Is your boss really that uptight? Why?
Ok, all the MVC tutorials I've seen ( MVC ground up, no frameworks ) have started by gathering values from the URL and determining the controller / method to call based on this. Guess I can work my own thing in here. Thanks, I was really hoping this wasn't a required part of MVC.
How are Sympal and Drupal related? From what I can see, Sympal has the idea of content types, and two-space indentation, but that's about it... (I hadn't heard of Sympal and just took a quick look at its code.)
From a code level they're not, Sympal was created as a Symfony based CMS loosely using some ideas from Drupal. [See transcript item/Slide 8](http://www.slideshare.net/jwage/sympal-a-cmf-based-on-symfony) &gt; 8. Sympal - a CMS based on Symfony The name Sympal was coined by my friend and ex co-worker Josh Reynolds a few years ago while brainstorming. Sympal was born that day and I began recording notes and collecting code from old projects. Symfony + Drupal = Sympal Jonathan H. Wage: Sympal a CMS Based on Symfony
With the learning curve I understand the downvotes. Stick with it and you will find out why it is possibly the best and fastest out there. Not to mention it is so well decoupled that you can add components to other frameworks.
If you are using jQuery: [jquery-longpolling](http://code.google.com/p/jquery-longpolling/) There is also an example in php in there.
Have you tried using the controllers statically?
inb4 PHP sucks, learn python, ruby, etc. [Here's some info on design patterns and OO](http://www.fluffycat.com/PHP-Design-Patterns/) I've also see some decent tutorials from nettuts.com. Other than that if you know the basics maybe look into some advanced topics on security, caching and frameworks. I've been messing with [Kohana](http://kohanaphp.com) (an MVC framework) for a bit and it gives you a sense of what working with "proper" PHP seems to be like. I'm actually interested in seeing some good blog suggestions myself. 
Go to [StackOverflow](http://stackoverflow.com) or any PHP forum and just read through people's problems and the solutions for those problems. This way you can choose which topics you'd like to learn about and even further your skills by helping people out.
any info about multithreaded scripts and sockets would be cool reading
Strongly recommend picking up [Code Complete](http://cc2e.com/). It's not about PHP, it's about software engineering, but it made me a better programmer in all the languages I know. [The Pragmatic Programmer](http://www.pragprog.com/the-pragmatic-programmer) is another good read.
For PHP programming books, I personally enjoyed [PHP Objects, Patterns, and Practice](http://www.amazon.com/gp/product/1590599098/ref=pd_lpo_k2_dp_sr_1?pf_rd_p=486539851&amp;pf_rd_s=lpo-top-stripe-1&amp;pf_rd_t=201&amp;pf_rd_i=1590593804&amp;pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_r=09ZSF1GESJ4FRCNE2A6Q) by Matt Zandstra
Sounds neat, but there are *sooo* many PHP Frameworks to choose from. While competition is certainly a good thing, I can't help but wonder if we wouldn't be better off if more resources were concentrated on improving existing Frameworks rather than starting over from scratch building new ones.
PHP doesn't have that much that makes it really different from other languages, these days. PHP 5.3 included functions as first-order objects, and we've had a real OO system since PHP 5 came out. So read blogs by programmers you like, regardless of language. For all people bash it sometimes, /r/programming is full of good links.
You can't write multi threaded code in php.
Learn to fork. You have to decide how you are going to operate on stateful mutexes. This could be a database, or a separate state machine. Most php developers use an ORM and fork() (or start using java) for multi threading, in my experience. I think there's nothing wrong with erlang, other than most people don't understand how it works...and the online docs/community is of little help. I prefer using Java to serve Flex and use an erlang app for statefulness, as I hate dealing with Java/PHP threads, in general.
Any book by Apress on PHP is fantastic.
Not sure if there is any code re-use, but Lithium appears to be heavily inspired by CakePHP. Their own site is powered by Cake, and reading some of the Wiki, the inspiration is mentioned. Even looking at the structure, I see some similarities. Also, there are not _AS_ many PHP frameworks taking advantage of PHP 5.3 features(like namespaces). EDIT: Well fuck, the article states that some contributers were CakePHP devs
[Planet PHP](http://planet-php.org/) has a good collection of advanced PHP blogs.
There are alot of knowledgeable PHP OOP and application designers at [devnetwork forums](http://forums.devnetwork.net). The [SitePoint PHP application design forum](http://www.sitepoint.com/forums/forumdisplay.php?f=147) used to be pretty good, although I haven't contributed to that site in awhile (got too commercial for my taste). Otherwise, most blogs or tutorials are either too quickly out-of-date, or contain too many errors or just bad design.
Its not a blog, but check this out - http://www.tuxradar.com/practicalphp
Here are a couple of promising looking blogs that I just found: * http://techportal.ibuildings.com/ * http://immike.net/blog/ * http://www.brandonsavage.net/
To improve your programming, learn a language other than PHP.
&gt; (or start using java) I
http://giorgiosironi.blogspot.com/ This guy was on a roll with two series about SOLID and TDD. The rest of his stuff isn't bad, but not good enough to read religiously IMHO.
It's sortof a fork of CakePHP. Cake is trying to get rid of the PHP4 dependency. They were going about it two ways: refractoring the main branch and creating an experimental rewrite (called Cake3). I'm sure there was some behind-the-scenes drama about it, but basically those involved felt Cake3 would be best served as an independent project. So Garrett Woodworth and Nate Abele left CakePHP to launch the Lithium framework. And though there are several CakePHP developers also working on Lithium, they are both open source projects with loose associations. Expect devs to drift back and forth.
Techportal is worth it's metaphysical weight gold, Ivo and the whole iBuildings crowd is awesome (So sad to see Cal Evans leaving as the editor-in-chief, but Lorna will be amazing). Check out http://devzone.zend.com/ which is currently being run by Eli White (formerly Cal Evans, watch out for Cal, if you can't tell by now he's a cyborg). Also, no-one has brought this up yet, but the number one place the community goes to for news is http://phpdeveloper.org (which is run by Chris Cornutt). He aggregates just about every blog that posts on PHP, but he does a manual filtering (unlike Planet PHP which is just a massive feed dump). Seriously, start with http://phpdeveloper.org and it will take you everwhere within the core PHP community (and surrounding areas). Also if you want to start getting in touch with the community aspect of things, come hang out with us on freenode.net at #phpc (tip: not a help channel, it's a social channel). Pretty much everyone from regular joes to conference circuit regulars hangs out there. Anywhere else you'd like to know I'd be glad to point you in a great direction! A word of warning: Books are a crap-shoot and unless they are small and specialized are either so generic as to it doesn't matter what language it's written for, or it's out of date, or just plain bad (PHP 6 Bible anyone?). However if you DO want to get PHP specific books, check out PHP Architect's line of books (by the way, they have a great magazine) which include small focused books by PHP experts (like an entire book dedicated to Date/Time programming by the guy who maintains the Date/Time functions, Derick Rethans). **EDIT** My friends are bitching me out: 1. It's "Derick" not "Derik" as I had it previously spelled. 2. Check out http://blueparabola.com/ (Run by Marco Tabini and Keith Casey, joined by Matthew Turland. By the way, ask Matthew about Magento, he loves it) 3. http://daveyshafik.com/ Wrote the ZCE study guide. LOVES Canadians, seriously, it's like a fetish.
http://phpdeveloper.org Not a blog, but a human-filtered aggregate that's great for discovering new articles.
Seconded, that and [PHP Architect's line of books](http://www.phparch.com/c/phpa/books/index) are great given Marco's closeness and involvement with the community.
Though it seems like "just another PHP framework," there is one interesting feature that sets it apart, at least for now. Back during ZendCon, when several developers from various frameworks got together, one of the things they discussed (in private, not during their talks) was the fact that so much of their code is solving the same problems over and over again. &gt;The result of that meeting was a set of naming and organizational standards that would allow developers to very easily integrate components from each framework or library in any other. This is a very big deal, and I'm proud to say that Lithium is the first framework to implement this naming standard. [Source](http://rad-dev.org/lithium/wiki/blog/and-were-baaaack) The Google group for the [PHP Standards Working Group](http://groups.google.com/group/php-standards/web/phpdeveloper-org-blog-post) has a list of projects working on and implementing the standards.
 (-) Awesome, another cakephp spin off. (-) Currently in development status, (-) no release date set. (-) Lithium is not currently ready for production sites. (+) NoSQL support (+) Built for 5.3 
Stack Overflow is good to have your questions answered but not one of the best places for PHP best practices information. The crowds work both for good and for bad, and I've seen some horrible PHP answers voted up while great ones slashed to oblivion (to be fair it's not the majority, but far too often for a new/relatively new programmer to trust). Definitely a "it's a great tool" but be very careful about which answers you read.
PHP Architect's book on Smarty (templating engine) is fantastic.
This is *not* a bad idea. I think the downvoters read that as "**use** a language other than PHP **instead** of PHP". You don't have to *switch* programming languages, but especially if PHP is your starting point, learning another language can really help. I'm a bit old-school; I say there's nothing like solid C skills to lay a foundation for the modern programmer (people who rarely *need* to touch C). A big part of the reason to learn another language is that PHP has a low entry barrier, so there's 10 (100?) times as much horrible PHP as there is PHP-to-aspire-to. In other words, not a lot of role models. However, downloading tons of the most popular PHP web app frameworks and CMSes and studying their code is another good idea. For CMSes, example one is Drupal. Drupal is an engineering marvel, if you ask me. It's not everybody's style, but it's insanely powerful, modular, and extensible. There's just nothing like it that I've seen; look up some Views/CCK/Panels/Context/drush etc. screencasts and writeups, read the [API docs](http://api.drupal.org) and try to take in some of the source (the /modules folder and some of the simpler contrib modules) to start to get an idea. On the pure-framework side, Kohana and Cake are great examples. (Again, investigate them, play around....) Once you research a system enough that it calls to you, you're in for loads of fun, you'll learn like crazy, and you won't have to look far for motivation anymore. **Edit:** Why the downvote? I'm not advocating the most *direct* approach (suggesting C), but it is akin to suggesting a budding alt-rock musician learn some jazz, blues, classical (or theory), which often helps modern-style musicians add depth to their music.
I am not sure how many other spinoffs there have been, but I think this one is slightly different ;) There are a few sample apps that help show the current potential of building apps. One of the big advantages is flexibility. For example, add http://pastium.org/view/23a2644922b1d45b43ed4d28dd3e2f30 to your config/bootstrap.php you can easily autoload Zend classes. One of the examples uses Doctrine 1 and there is a lot of work being done on a plugin to support Doctrine 2. Another nice feature to me is the intergrated test suite which provides a simple way to do TDD with code coverage, cyclomatic complexity, and profiling filters. I could go on about some of the other features, like multiple output support, method filters, and speed. Anyway, thanks for checking it out. The response has been really good and bunch of people hang out in #li3 on irc.freenode.net. Also, you can join the core discussions in #li3-core and let everyone know what you are interested in and maybe even contribute some code. :) 
Yup. This post http://rad-dev.org/lithium/wiki/blog/on-transition does it's best to describe the spinoff.
I don't see why they go to so much effort to make sure there's no white-space after the closing PHP tag, when it's perfectly valid to just omit it and guarantee there is no trailing white space :-/ 
attention to detail ;)
“Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot.” — Eric Raymond
And opening tags just ask to be closed.
Annnnnd the link seems to be working correctly once again. I wonder what happened?
http://www.php.net/manual/en/function.pcntl-fork.php
i think ObfuscatedPerlParadx and bikko are right. finding articles about a certain modus operandi in php is easy. the hard thing is finding the technique in the first place. so don't focus too much.
also, it abbreviates to SAP, bringing a hint of big business flavour into it. i always name my apps so they abbreviate to U.S.A, because then i can show videos of people shouting "USA! USA! USA!" to my clients, claiming those were happy customers.
Nothing cryptic about that error. You can't write to a function call/return value.
In my study of PHP, I've read a number of different books and authors. I find some authors and publishers have explicit expertise. Sams publishing for instance is decidedly intermediate and I often learn best practices from their books. On the other hand New Riders is pointed toward beginners. They work to bring other disciplines into web development and read easily. For this try [Safari Books Online](http://my.safaribooksonline.com/?portal=oreilly). Xtian //EDIT: corrext url syntax
I usually just use the method you use, only rather then write it after, any time I make a change, even if its not ready to update, I will add it to updates.php in a switch with the version to update it from and too. that way I won't have to go over it to find all the changes and it feels like less of a hassle because i am not doing it all at once.
It's pretty easy to get up and running quickly, but customizing the site to your liking can be a pain depending on how deep you want to go. Their template system is a nightmare. That being said, if you want something that looks good out of the box, has a ton of features, has a great back-end, built-in compatibility for all the major payment gateways, and even a built-in API (which I have used to import thousands of products from an existing eCommerce site with great success), you're going to be very happy. But if your client or whoever wants it to look way different than all the other Magento sites out there, you may have your work really cut out for you.
A forked process is not a thread.
really fucking hard to customize
[Adminer](http://www.adminer.org/)
Its hard to customize, its template system sucks, its documentation is awful. Don't even get me started about trying to update it to a new version. Imagine if OSCommerce was built with the zend framework and you get the general idea.
I'd rather use [Prestashop.](http://prestashop.com/)
its been 7 months that magento dev has became my profession, at start it seems so hard and complex, but after a while you'd wish that every other PHP apps had such a great structure. because it's highly extendable and scalable. of course it needs tune up of databse and web server, and execution cycles are too much because of its eav-based database desing. but i can assure you that you can build up your whole company business plan on it.
Professor X could totally take him in a fight.
I have customized a few Magento stores, making a custom template is very hard at first, but you get the hang of it. Making it function differently than it is intended is pretty hard, but doable. My major gripe is that every time I need an answer to something, I check the Magento forum, several people have asked the same question, and most of the time there are no answers, just a thread of "Me too!" Make sure you have a lot of system resources available, it will use them all. I would not host this on a shared host, anyone would be better of going to Slicehost or something like that. That said, Magento is probably the best solution for a larger store, it has a lot of options, and once you have hacked it apart once, it gets easier from there.
+1 It's the worst piece of code I've ever had to customize. Ever. It's like a bunch of people looked at OSCommerce, said "Hey, how can we REALLY make this unmanageable?", and then did it. Twice.
If you've used Magento and Prestashop, would you mind giving a quick rundown of why you prefer Prestashop over Magento? Both of these are on a shortlist of options that I'm going to end up working on soon. Would be nice to get some insight. Cheers!
Yes please, expound on PrestaShop if you would be so kind. What do you like about it, how does it compare to Magento (presuming you've used that), and how easy is the customization?
And it's really, really, REALLY slow.
Magento was a fucking nightmare to make a theme for. First of all, there is only like 15 *free* magento themes to study out there, and all but one or two are mediocre. Nothing makes me hate life more than working with magento.
As far as PHP programmers go, it separates the men from the boys. It's the first well designed large application I've ever worked with in PHP.
Why the downvotes? I'm in the process of learning Yii at the moment and it doesn't seem bad at all.
It's a piece of shit. The code is 1000 times too complicated for what it does and impossible to figure out without understanding almost the entire system. This makes it very counterproductive when the whole point of using it is to get the basics and only modify slightly. I made an extension for a client and figured I'd package it and sell it afterwards. I changed my mind pretty quick. Not going to have to polish an support anything for this crap software! They basically wrote an overly complicated open source system, did not document it and expected its technical users to prop up the documentation in its wiki. The documentation is a pile of crap. Almost the only way to figure things out is to look in the forums for people who had the same problem. And too often it involves writing code for even the simplest things. Very little useful stuff out of the box. And slooooooow! Although they say that with a Magento-approved host you're fine. This means tough luck if you already have your hosting environment.
IT Web - Q Solutions is a software development company, providing web solutions for open source communities.
Nuh uh. Magneto's wearing his helmet. What now, smart guy?
Honestly, I thought Prestashop was harder initially than Magento. I agree with the other comments that if you are proficient in an MVC PHP environment, Magento is pretty rich. But you're talking about a REALLY high learning curve for non-PHP people. That being said, Prestashop definitely seems faster and much less resource-intensive.
All these people saying it is hard to customise, are really just complaining that the documentation is lacking (which it it is). Once you get into it, you realise just how structured the system is. You can customise *anything* at any level - including core scripts - and still leave an install totally upgrade-proof. The theme problem is down to the theme creation being a one-way affair. You can build up a theme from the ground up, and it all makes sense. But reverse-engineering an existing theme is a nightmare. There is no documentation that describes all the links between the application and the theme - there is no list, for example, of all the places that the core code calls up a template. For functionality, you really cannot beat it.
Splitting every data type of the dynamic data into a separate table was a huge mistake IMO. It makes database queries immensely inefficient and slow. Luckily the data management is in a layer of its own, and there are plugins that completely replace the structure with fewer, and flatter, tables.
Really fucking hard *to work out how to* customise. Once you "get it", it makes a lot of sense and is dead easy.
It is certainly *rigorously* designed, but I would say they took the academic theory of database design just a little too far, and ended up making some poor real-world design decisions. Having said that, I would **never** go back to OSC or it's ilk.
I would agree with this - there is very little interaction with the Magento devs. They simply don't respond to bug reports or issues. That lowers the confidence in using the product a lot.
You joke about it, but Google now always seems to return X-Men results when searching for e-commerce applications.
I've read that comic. Nightcrawler teleports it off just in time.
It's because they offer a paid enterprise support option. Their general policy is "the open source users have to fend for themselves, direct dev response is reserved for those who have paid for it."
Hmm, we we're on the verge of using it and leaving OSCommerce, but our big shopping cart contract fell through, and only had blog projects so we started to mess with Joomla (CMS), which did the job nicely and I understand half decently, Joomla also has a shopping cart module called Virtuemart, professionally made, I will be trying eventually. Has anyone tried _this_ combo before?
you're rite, but as you know, they have flat tables for three general models that are being used more often, we use magento in 4 huge projects and after some routine optimizations its been working great.
Please do not associate Zend Framework to Magento. Sure they consume some of it but they do not fully use it. Their entire dispatch system is completely homegrown. Trying to figure out it's flow is mind-numbing. Someone posted a PDF of this once but that was during the beta phase.
Magento is very, very slow, but looks pretty and has some nice functionality.
Yes, Virtuemart has its issues, as does Joomla. Depends if you need the extra features / headaches of Joomla over software thats is specifically a cart...
Wow, this is awesome.
internal server error, doh
determining the controller/method from the url is one way, the other is routing by regexp. my homebrew microframework handles it like this: &lt;?php echo RoughBird::create('../path_of_my_app') // matches http://mydomain/, controller is IndexController -&gt;route('', 'Index') // matches http://mydomain/shop/XYZ -&gt;route('shop/(?P&lt;productId&gt;[a-zA-Z0-9_\-\(\)]+)', 'ShopProduct') // matches http://mydomain/shop/XYZ/image/123 -&gt;route('shop/(?P&lt;productId&gt;[a-zA-Z0-9_\-\(\)]+)/image/(?P&lt;imageid&gt;[0-9]*)', 'ShopImage') // matches http://mydomain/XYZ -&gt;route('(?P&lt;pagename&gt;[a-zA-Z0-9_\-\(\)]+)', 'Page') // no matching route found -&gt;route(404, 'Error404') // somewhere, an exception was thrown -&gt;route(500, 'Error500') // go! -&gt;dispatch($_REQUEST['url']); // example controller class ShopController { public function GET($productId) { return 'hello world'; } } ?&gt; this way the controller structure doesn't interfere with url mappings. the drawback is, i have to explicitly specify a route, while the other approach implies the route by the existence of a controller/action matching the name. the mod_rewrite rules for this would be: RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)$ /index.php?url=$1 [L,QSA] good luck.
Some feedback I have received: - MLS integration is via something called IDX (Internet Data eXchange), and it's reserved for members or is not cheap to access. But cannot confirm until I do more research. - At least if the project were done in Euros for a European client, the pricing I heard was that it would be about 3000 Euros or $4500 USD, best guess.
I would suggest learning programming from a deisgn pov. Learn how to pseudo code and learn how to deisgn objects. Great programming can be translated into any language
AgentPress: "The CSS, XHTML and design of these theme are released under GPL license and are in total compliance to standards set forth by the authors of that license as well as with WordPress. Theme support will only be given to those who purchase a theme package." Why clone? You can just fork AgentPress by the look of it.
Good catch. Ah, because I'm faster at cloning and doing it *my way*, integrating with Pods Plugin because I prefer that, than to do it the AgentPress way. However, I like some of its layout and concepts, so I may borrow ideas and re-implement from scratch. 
In my 2 weeks of working with it, it seems that doing anything to it causes it to break and redirect to /report. The forums are hopeless, I've rarely received a reply. Googling your problem takes you back to the forums to look at yet another unanswered thread. I don't like Magento any more.
Abomination.
Performance stopped being important when performance stopped being a problem.
Presta is much easier to customize, especially the modules. Documentation isn't much better, but the forums are way more helpful. The code is pretty well written and logical, making it easy to get into. Uses much less resources than Magenta. Downside is it's still a young app. Payment and shipping apis are not all there yet. There are quite a few user modules for them submitted, but some need polish. I prefer Presta, but if you use a smaller payment gateway, you may have to write your own module for it.
Presta is much easier to customize, especially the modules. Documentation isn't much better, but the forums are way more helpful. The code is pretty well written and logical, making it easy to get into. Uses much less resources than Magenta. Downside is it's still a young app. Payment and shipping apis are not all there yet. There are quite a few user modules for them submitted, but some need polish. I prefer Presta, but if you use a smaller payment gateway, you may have to write your own module for it.
http://zend.codephp.co.uk A PHP Wiki, based on the Zend PHP 5 Certification. But I would say that..
um, clicky not fail. any sort of special help you need to make the internet happen, i'm happy to provide... lesson the 1st: [click](http://dev.kohanaphp.com/projects/kohana3/files) 
I'd say it's a more global target. It's easy to set up for a US only site. If you want to use multiple countries it does that well and is set up for it. The things it is short on it is just short on. They don't have Euro gateways and not American. They just don't have many at all, though there are quite a few user contributed ones of varying quality. I think the main part of the app is very nice. It's still a young app and they are mainly cleaning up obscure bugs, but their svn is always active.
The php.net manual is certainly a great place to start. * [Introduction to Object-Oriented Programming in PHP5](http://www.php.net/manual/en/oop5.intro.php) * [What exceptions are with respect to PHP development (you should understand why throwing exceptions is better than triggering errors)](http://www.php.net/manual/en/language.exceptions.php) * [A new way to access the database: PDO](http://www.php.net/manual/en/intro.pdo.php) (Also, [MySQLi](http://ca3.php.net/manual/en/intro.mysqli.php)) * [Why magic_quotes was bad](http://www.php.net/manual/en/security.magicquotes.whynot.php) * [The filter extension provides a better way to handle data coming from the user (rather than the $_GET and $_POST)](http://ca3.php.net/manual/en/intro.filter.php) (namely [filter_input](http://ca3.php.net/manual/en/function.filter-input.php)) And when you're familiar with the above topics: * [Namespaces, the next big thing in PHP development](http://www.php.net/manual/en/language.namespaces.rationale.php) * Zend Framework general guidelines: * * [Good practices with regards to loading classes](http://framework.zend.com/manual/en/performance.classloading.html) * * [Coding Standards](http://framework.zend.com/manual/en/coding-standard.html) * IBM developerWorks: * * [Advanced PHP V5 objects](http://www.ibm.com/developerworks/opensource/library/os-advphpobj/) * * [Five common PHP design patterns](http://www.ibm.com/developerworks/library/os-php-designptrns/) * * [Five more PHP design patterns](http://www.ibm.com/developerworks/opensource/library/os-php-designpatterns/)
I'll pass on ZF. I want a framework, not the bastard offspring of CPAN and the *notion* of a framework.
Writing your own core functions and having a minimal routing MVC system. Cons * Fast as fuck. * Completely adaptable. * Does anything you want it to do.
.htaccess rewrite rules. So /articles/1234/my-article-name-is-awesome.html can actually go to: index.php?route=articles/view/id:1234 or whatnot. Proper SEO is never going to be done generically, so why bother trying?
I find it is good to have an abstract model class with things like load, save, etc, but then inside the model class itself you'd have custom methods with sql that do stuff specific to that model. Cross-model interaction is done purely through the others' model, though.
I'm a fan of Cake. It handles the lower-level nuts and bolts so that I don't have to. I especially like the schema-reading and bake features.
/s tags would help. If that isn't sarcasm, I would love to see a boss who doesn't care that his employees aren't working.
That's not to say there's no value in asking it again, in a different place.
I haven't met any _competent_ bosses in the technical realm who can't get their heads around the notion of research, but perhaps your mileage varies.
It definately has a STEEP learning curve, but once you learn it, it does make sense. The design isn't perfect, but it's LIGHT YEARS better than OSCommerce. The Magento Team needs to step back and start cleaning/simplifying a bit though. If for no other reason than performance issues.
http://www.tizag.com/phpT/ Run down the list on the left side. these are good too: http://www.w3schools.com/php/default.asp
The [PHP manual](http://www.php.net) is incredible as a reference; the user comments on the function pages are usually quite helpful.
If you want to check out how a specific function works, try php.net/XXXXX. I've been developing on PHP for the past 8+ years and use it almost every day.
[XAMPP](http://www.apachefriends.org/en/xampp.html) is an easy way to get started. It gives you apache, php and mysql configured enough to have play around with on your desktop. Nothing is better than hands on experience
I read O'Reilly's "Learning PHP5" [1] and PHP Architect's "Zend PHP 5 Certification Study Guide" [2] when I began using PHP. Both were excellent, and would give you a head start. Alternatively, write a To-Do list app in PHP, and store the entries in a MySQL database. [1] http://oreilly.com/catalog/9780596005603 [2] http://www.phparch.com/books/isbn/0973862149 
I can't really agree with either of these tutorial sites as good resources. Both provides tutorials that are filled with incredibly insecure code. One's best bet, as mentioned below, is published books from reputable sources (as there are PHP books with the insecure code in them as well!) and the PHP manual.
Phpfreaks.com
http://www.php.net/manual/en/tutorial.firstpage.php The PHP site will ultimately be your destination for most of the information you need. The link above is a link to PHP.net's "Your first PHP-enabled page," and is definitely a warm introduction to the language.
tizag.com taught me the basics!
Absolutely, I learned 90% of the PHP I didn't figure out myself from the manual.
I'm wondering how long until the PHP haters show up.
http://lmgtfy.com/?q=php+tutorial Seriously, just php.net and a goal is all you really need if you have any programming experience at all. 
where else would you learn it, from the postman?
Keep in mind there's a lot of outdated (or just plain crappy) tutorials out there, too.
I HATE PHP!!! No wait...I hate PCP. That stuff'll mess you up.
You could probably learn PHP in a couple of weeks if you started now. Forget the course
Anyone care to comment on what they would hope to see from a beginning PHP class? OOP over procedural? PDO or mysqli over basic mysql function? How would you start someone off on the right foot?
Take something that interests you and try to make something in PHP for that. This is what I did and I picked it up quickly. I made a Character Generator for D&amp;D. Go ahead and laugh but this made use of TONS of php functions and stuff. Just Think of a web program that you would use yourself to simplify something you do and you'll get it quickly. php.net is a great place to get started.
You just learn the basics by following the many tutorials out there, but how would one learn advanced PHP? I've tried downloading open source scripts and try to understand it, but it's too complex.
teach them OOP and how to gather and display data from forms, them move on from there.
This and perhaps sanitizing, database connecting, insert/updating/changing MySQL/DB information.
I like to hang around TalkPHP.com. It's not over whelmingly active, but there are a lot of people who really know their shit. It's mainly a forum site, but they do have plenty of tutorial like articles and so on. I've also found it to be an invaluable place to turn with questions due to the expertise there. Aside from that, I like to download open source products and just browse around the code, checking out what they are doing ( or I did back when I was learning more rather than doing more ). Other tutorial sites are ok to check out from time to time, but a lot of the tutorials I find a written poorly or are seriously amateur. The only other suggestion I have is to check out some O'Reilly books or something.
Still need a credit card, btw
I'm with you. Isn't the point of MVC to be able to create YOUR OWN reusable code? Y'know, so you know exactly what's going on and don't have to sift through tons of heavy modules.
Is there even a market for web based RSS readers in 2009?
The only solution to reading at home and at work that I know of
i just dove head-first into it, mostly used the php manual on the run (that was over 10 years ago, still in school) and read the occasional random tutorial. though i had experience with several languages (basic, pascal, asm, java, c/c++, ...), the concept *and ease* of web programming was new and exciting! what i recommend (or at least, i suppose i'd learn it this way today): * get wamp or xamp running. if you don't have experience with linux/freebsd/*nixes, go for wamp - but keep in mind to get comfortable with *nix as soon as possible! * learn about the basics and $_REQUEST to get data from url parameters and forms * learn by doing. if you get stuck, google for tutorials (even if they're crap). don't get too proud - you'll have to forget/revise almost anything you're doing right now soon. * learn how to use mysql. i'd recommend to ignore the ancient mysql functions and go straight for pdo, if you're familiar with oop. if the course prefers the old mysql functions over pdo, it's not worth your time. the mysql functions are outdated and *dangerous* (they probably hurt kittens!). * write a simple guestbook application * then, improve your guestbook application with features (archives, formatting, whatever ...) * then, play around with oop until you get the basics. * until now, you possibly mixed php and html in one file. that's bad! separate them. there are powerful template engines like smarty, but php itself works great. learn about separating code (php) and presentation (html) * next, rewrite your guestbook app using the [nicedog](http://github.com/bastos/nicedog) or [glue](http://gluephp.com/) microframework (or something comparable. they're really easy to learn and will introduce you to MVC before it's too late) * with php, it's extremely easy to mess up your programming style for good, if you're not careful. be self-disciplined; don't succumb to the old ways of quick and dirty hacks! they'll cause you a lot of pain, if you don't get rid of em as early as possible * be sure to understand what HTTP is and how it works * learn the security basics (cross site scripting, sql injection, ...). you now should be able to f**k your guestbook up badly (from the webbrowser). rewrite it to be modestly secure. security is *very hard*, and you'll most likely never fully understand it. that's normal, almost nobody does, even the people personally interested in it. the most important thing is to know that you know nothing. * learn about unit tests (and, i forgot, exception handling). the sooner you start to get comfortable with them, the better. write tests for your guestbook (and fail). rewrite your guestbook to being testable. * learn about [unicode and UTF](http://www.joelonsoftware.com/articles/Unicode.html). that's VERY important. php and unicode didn't mix well for a long time, so be sure to understand at least the basics and how to use unicode before you move on! * there are a lot of libraries for php, like GD, SimpleXML and countless others. get to know at least some of them * learn the differences between running php in it's native environment (apache module/cgi) and running it as cli * understand the problems with concurrency. it's ... complicated. php is a very popular language, because it's very easy to learn and easy to deploy. the problem is, it's also very easy to write bad code. **always keep in mind to not write bad code.** (it's harder than it sounds). i continually ask myself: *if a programmer whos exactly as good as i am saw my code, would i have to be ashamed?* if you (get a php shop job and) find yourself to be unable to escape the php world (as i do), **don't concentrate on php**! most of "php's best practices" come from the outside (because most of them are universal). php programmers become better programmers by learning other languages (though i suppose that's true for all languages besides lisp ^^)! be sure to understand FP and learn at least one functional programming language like haskell (best before you become too comfortable with PHP). good luck! \* update: originally i wrote CGI instead of CLI - made no sense
*\*doesn't laugh\** character generators can get very complex. now please go and write a decent town map generator. canvas or svg would be preferred ;)
Can't upmod the awesome.
You wouldn't be wishes from nekonet, would you?
http://www.theserverpages.com/articles/webmasters/php/performance/Performance_of_OOP_PHP_versus_non-OOP.html Or any other article that tells you to just use regular PHP instead of OOPHP. It's a big mess, maybe it will be better in PHP6.
 $dom = new DomDocument(); $dom-&gt;load("http://www.reddit.com/r/PHP/comments/a7gfr/tiny_tiny_rss_an_open_source_php_and_ajax_feed/.rss"); 
No, sorry.
I'm trying to learn more about PHP and OOP so I'm curious about this. The article is over 5 years old. Does that make a difference?
[Student Suspended Over Suspected Use of PHP](http://www.bbspot.com/news/2000/6/php_suspend.html) &gt; "A teacher overheard him say that he was using PHP, and as part of our Zero-Tolerance policy against drug use, he was immediately suspended. No questions asked," said Principal Clyde Thurlow. 
Yes. First off, that's a highly artificial example, secondly it's php4. OO was overhauled quite a bit in php5, not to mention that things like opcode-caches are a dime a dozen these days. I wouldn't be surprised if the example would still show that OO id slightly slower at incrementing a number 100000 times, but in the real world that's not what we do when we write webapps, now is it?
Even for big websites you needn't be worried about this kind of optimization or performance issues. If your site is running slow the reason would be much rather a poorly indexed database, fs, etc than this. So I wouldn't worry about the above. 
And now that I got home I had to try it out, and the comparison still stands: Non-OOP: 0.251184940338 Instanced class: 0.272353887558 Static calls: 0.283890962601 But like sibling pointed out (and, well, me), that's not an issue. Your application will NEVER suffer from these kinds of problems (if they do, you're using the wrong tool for the job). (it actually took me a bit by surprise that the static calls were slower than the instanced ones, but I suppose there's some sort of reason for that somewhere)
Here's a general response on the idear of using procedural code over OOP for a website of any reasonable size: don't. Using OOP has far more logical benefits than procedural does that it only makes sense to use OOP for a site (or like me, 95% OOP, 5% random functions). But this is really part of a larger issue called premature optimization, and why it's a terrible idea. I currently have been developing a website from the ground up which is roughly 15,000 lines of code. Most of this code is indeed object oriented, and because of that, has simplified the development process immensely. While I cannot claim I am as good and diligent at OOP and stuff like many other people (I tend to view my work as a craftsmanship, not something that's done by thorough engineering, but I digress.) do, but it still runs quite fast, with average page performance at .05 ms with my own optimizations: file-based caching for mostly static data, eaccelerator, and memcache (&lt;3!) for queries that don't need to be executed /too/ often. If this site were written in procedural code, development time would be significantly higher while only saving a couple of milliseconds per page load, which isn't warranted because .05ms is pretty fucking fast, and adding more servers to the mix would be a better idea than switching the entire codebase. It's safe for me to conclude that anyone who can possibly agree with this idea in the scope of PHP is a lunatic. Sure, there are definitely arguments of C vs. C++, or C vs. Python and the like. But that's not just "procedural code = superfast, oop = slowballs." Simply put, there's a lot more to procedural vs. object oriented in terms of performance (both in development and runtime). In the scope of PHP, your site attached to a database (or even other files, as in file operations) will be your bottlenecks over the code you write (generally speaking). I would be interested in seeing another language that offers both paradigms (procedural and object oriented) and seeing if the same remains true: object oriented code is "slower."
fancy
....and then you leave a clusterfuck of code behind for the next guy to deal with when updates or changes need to be made.
 http://www.diveintopython.org/
I totally agree with you, dude. I've been working on a small framework for about a year now, adding a lot of stuff, like data management (reorganizing arrays, generating codes, etc.), user management, role/permission system, etc. It makes my life 10 times easier when I have to write a new administrative system, or something that requires a login system, etc. As far as Drupal goes, I agree with you on that, as well. Drupal is not easily extendable. Trying to write a plug-in for the first time was one of the biggest pains in the ass. We got it to work, but I could've written a plugin for my system probably in 10 times less time. I will give Drupal this much: it's easy for designers and non-programmers to create well functioning websites.
I've been using Zend Framework for a few months and I have to say that I have learned a lot more about coding using objects/classes since then. I've used that knowledge toward other projects and the more I learn, the more fun I have.
relevant research, sure. otherwise i'd just watch youtube videos all day and call it research
What the crap is this? A horrible regex for email validation and then... foreach ($myvars as $var){ if (isset($_POST[$var])){ $$var=$_POST[$var]; } } It is no longer 1998. Don't *do* that!
In all fairness, I'll take well structured procedural code over half-bakes object oriented. But picking it because of performance is completely missing the point.
Its extremely functional and it blocks a lot of the spammers messages.....so I don't entirely understand why you say its crap. The article is geared toward new php users because it is simple and easy to use. The "horrible" regex you mentioned combined with the other validation blocks most spam attempts....but I guess you are entitled to your own opinion.
That horrible regex blocks numerous valid email addresses, such as the entire .museum TLD and any email addresses with non-alphanumeric characters in the local part. You should use the built-in [filter\_input](http://us3.php.net/manual/en/function.filter-input.php) function using FILTER\_VALIDATE\_EMAIL, or one of the fantastic and free [RFC-compliant email validators](http://www.dominicsayers.com/isemail/) available. Your abuse of variable variables [duplicates built-in functionality](http://us3.php.net/extract). Additionally, extracting POST/GET vars has been considered bad practice since PHP4. Oh yeah, and $myvars is never actually declared anywhere. Seems you're also developing without setting the error_level, or you're suppressing errors. In short, your code is crap. You shouldn't be posting crap and claiming it's "extremely functional" and "geared toward new users". New users do not deserve to learn the wrong way to do things, as it only sets them up to shoot themselves in the foot later. You're teaching them how to do it wrong.
I guess I will take the higher road and say "Thanks for looking at my code. I will review what you said here and see if I can implement it for future uses." 
This looks nice, but what if I'm on a shared server and can't modify the current php installation (install a plugin). Is there a library I can import and use?
Spyc is a fairly complete pure php yaml library. http://code.google.com/p/spyc/ Our application had realtime constraints that needed the speed of a "real" parser. Regular expressions are flexible and powerful, but seldom fast.
Somebody is eventually going to come along and say that there is a more established [php yaml pecl extension](http://pecl.php.net/package/syck). I had a couple of reasons for seeking out an alternative to syck. The first was that I was experiencing segfaults on my development and production servers during the php teardown phase which I eventually isolated to syck. I wasn't ever able to definitively determine if the memory corruption was caused by the syck library itself or the pecl bindings, but it was 100% reproducible that when the syck extension was loaded the app would crash and that when spyc was used instead it would not. The second reason was that syck was maintained by _why and I could not find a new primary repository and/or maintainer of his library. Since our application needed the performance of a c-based yaml parser and the one we had been using for a couple of years had a hard to isolate bug and no apparent upstream maintainer I started looking for something new.
If anyone knows how to get in touch with the original maintainer (rsky), I'd love to talk with him. I've sent a couple of emails to the address that was in the code, but have received no response. I've seen messages in other forums indicating that he has not responded to others interested in patching the extension as well, so I decided to scratch my itch and start a fork of the project, but if he is interested in contributing to my efforts or merging the projects I'd be more than willing to talk to him.
I was pretty skeptic about using PHP frameworks since my applications were always about speed (many requests per second). I decided to try out Zend Framework and although it had some great solutions like Zend_Form, it was very resource-consuming before I optimized my server, but after optimization it was able to handle 8 times more requests per second. If you ask me, the only reason people don't user Zend more is because of its relatively bad documentation, making it pretty hard to master. I've seen many blogs about it with writers following wrong programming patterns, but that is also MVC related. [This book](http://www.packtpub.com/zend-framework-1-8-web-application-development/book) really saved my life.
Brilliant.
I think it is, but you have to work very hard - probably harder than you'd have to for a "regular job". 
I've never been able to find a OOPHP project to examine that wasn't half-baked. Suggestions very welcome.
any excuse for female nudity is a good excuse
damn lucky elephant.
How come it needs a password to export, checkout or even browse? I don't get that.
Cause I am an idiot, change the URL's to http and it should work fine for you.
I'll take my programming with a little less "side of whore" please.
It's fine, I'll have akinder's.
So they deprecated ereg functions, but not mb_ereg?
It's part of the multibyte extension, outside of core, which probably explains the difference...
Simple and lightweight - CodeIgniter, I'd recommend it for most websites. Harder to master with massive library and built-in Dojo (and partial jQuery) support - Zend (takes full advantage of PHP 5, but version 5.2.4 is minimum requirement). Although its only about half as fast as CI, it's benefits reflect on large projects, where, IMO, CI would lose most of it advantages. Also if you are looking to get a job in a large, serious web-dev oriented company, go for Zend. Edit: you might find [this link](http://avnetlabs.com/php/php-frameworks-revisited-codeigniter-vs-zend-framework) useful
You sir, are obviously homosexual.
Yes, because not being interested in some attention whores posing with a programming "mascot" makes me a homosexual. You sir are a dumbfuck.
Why is it that all these blogs that are clearly designed to post code don't bother with trying to format it for readability? Jeez, put some effort into it.
Feel better? Mr. Internet tough guy.
Indeed, that's actually a clever idea. Look for it in an upcoming commit. I'd be happy to add ukphone and ukpostcode, can you describe the validation rules for me?
Anybody care to explain their down vote? It seemed to be pretty well received on the pecl-dev list.
&gt; can you describe the validation rules for me not authoritatively, no. Wikipedia is probably the best bet. I know there's a huge postcode regex there.
downvoted just for thinking of using Drupal in that way.
it's the internet, so, yes.
This doesn't have to do with anything mvc. The idea just to start some instance of apache/lighttpd to serve the specified document root. I did the same thing for apache2 with some bash script to generate the config file and launch the apache process on different port. http://bitbucket.org/k4ml/devserver/src/ 
Drupal is an awful, awful framework. It's codebase is bloated, badly designed, and left me feeling 'Man, I could do this better.' Unfortunately, I have to respect my client's requirements and work with them. 
That's called a proxy. There is dedicated software for that specific task. What exactly are you trying to accomplish by this?
[Kohana](http://kohanaphp.com)
Judging from the information on the home page, that looks really interesting, I'm going to have to take a close look at it because besides looking for good examples of OO, I'm also checking out frameworks and just recently started learning the Zend Framework. Thanks.
You've said it in other comments, but Zend Framework is very well done. Some components aren't as good as the others but you can get a feel for some really good, and tested, patterns though Zend. In particular, pay attention to how Zend handles setting configuration options for objects (passing a single associative array to a constructor that calls setKEY($VALUE) functions), which is a very good practice to use when you start looking into dependency injection, etc.
No, I've set up proxies before, I'm trying to get all this integrated into my nagios. If you look at the bottom left you'll see the extra's section I've added, and i'm trying to get everything displayed http://imgur.com/3tCyW.jpg (Nagios start page) http://imgur.com/PH24o.jpg (PHPsysinfo being grabbed from the NAS exactly how I want it, but the images are being hosted on my gateway...)
It might be more beneficial to look at the source code of Kohana 3. http://github.com/kohana/
Nice, I can see a lot of parallels between their code and mine, which makes me happy because they are probably better than me. Definitely going to take some ideas from them. Kohana looks sexy. Far from finished, but this is my core. Has a sample inside it: http://github.com/radiosilence/core Basically to start a new app, I (scriptably) make a folder for the project, checkout core into the core dir, then copy the contents of core/sample/ into the root, then init the root (the sample has a .gitignore that will ignore core/) and commit it.
If you ever feel the need to learn from someone else's mistakes instead, I recommend browsing the source code for the Horde framework. Its a complete fucking train wreck.
Maybe ob_start(); will work for you, something like this: ob_start(); include_once 'PATH_TO_PHP_FILE'; $output = ob_get_contents(); ob_end_clean(); echo $output;
I've seen too much horrible trainwreck code, and work with it on a daily basis (Java), I don't think I can handle anymore horrendous code without switching careers. But this is PHP you're talking about, 90% of the code out there is a train wreck. I hope that this thread grows and the newcomers to PHP catch on.
Probably because the core PHP community uses [XDebug's](http://pecl.php.net/package/xdebug) profiling, not only because it's been around for so long (1.2 released around 2003), it uses the standardized cachegrind format, Derick is very active in the community and maintaining XDebug updates (as well as being the resident Date/Time guru), and the remote debugging facilities give XDebug a 1-2 punch over the extremely new XHProf.
I've said this before, but after using Zend Framework for a few months, I've learned so much more about OO programing in PHP. One of the things that I like the most is how they use the __call magic method in many classes. It's a great way to add additional functionality to classes without having to create massive libraries.
\_\_call() is nice but be careful of over-using it. It makes sense for an object that should be extended by plugins, e.g. the Zend_View objects. But use it too much and you have a large number of objects with methods that can be used that are not documented and extremely hard to trace down.
&gt; [...] I hope that this thread grows and the newcomers to PHP catch on. Follow industry standards and only produce horrible train wrecks in PHP. Got it. To start the newbies off, let's make a list of industry standards. I'll start by sharing my vast wisdom gleaned from industry standard PHP. * Always use global variables * Avoid writing “functions”—they complicate code by reducing sequentiality * Use copy and paste functionality to increase code girth (and thus manliness) * Create a new .php file for each page of your site * Insert database connection code, along with root MySQL password, into each of said .php files in order to facilitate using the database * Save time with register_globals—let PHP create your globals for you! * Using a popular CMS but can't figure out how to change one page's layout? Tsk tsk, CMSes are for sissies. But just this once we'll help: Copy-paste the generated HTML for the home page into a new .php file and put your new layout HTML straight in there!
&gt; # Create a new .php file for each page of your site This is hardly horrible. It might be good design actually. 
In case a newbie comes in here and can't tell, bikko is being sarcastic.
I'm curious to hear about cases where it might be a good idea. Besides a potentially very repetitive laundry list of includes in each file, my main concern: This practice makes converting your app to use "clean URLs" later pretty impossible, right?
&gt;This practice makes converting your app to use "clean URLs" later pretty impossible, right? Hardly. Enter the world of request handlers and mod-rewrite.
True, I guess you can use a RewriteRule to direct to your request handler *after the fact* and have your handler run the PHP file corresponding with the request. Just seems strange to me not to design around a single entry point from the start. I was thinking about apps I've seen that use the many-PHP-files approach and have output and logic combined in merciless spaghetti-code-global-clusterfsck fashion. Hmm, I believe I'm unnecessarily associating an approach with bad implementations I've seen using it. (Edit: Clarity)
XDebug is great but it solves a different problem IMO, namely profiling / debugging in a development environment. The size of files produced by XDebug when profiling is prohibitive when it comes to using it to sample execution regularly on live servers. The file format used by XHProf is just a serialized PHP array. Experience from using it on local.ch where we use [this framework](http://okapi.liip.ch/) is the uncompressed profiling output is typically ~110Kb for a single execution - much smaller than XDebug which range from 900Kb up to 10Mb. Also haven't benchmarked but XDebug has a *visible* impact on performance which XHProf doesn't.
I wish i could give you bazillion upvotes. \_\_call() is a great piece of magic, along with \_\_set()/\_\_get(), but it makes it pure hell for the poor bastard who has to inherit and maintain the code after you leave. If you *know* the code, it's the best thing ever, if you're trying to grok the code - it's a nightmare. (especially when you do all that \_\_call()-magic in a standardized place, and every method-call returns the whole, global God-object, making a var_dump impossible because apache spits out 100M+ of html and dies. Yes. I'm looking at you, Magento.)
&gt;RewriteEngine On &gt; &gt;RewriteCond %{REQUEST_FILENAME} !-f &gt; &gt;RewriteRule .* /entrypoint.php [L] The start of any good project :p
Lithium: http://rad-dev.org/lithium/ It's 5.3+ only, but it'll blow your mind.
Oh jeez... wow. I was going to suggest looking at ExpressionEngine (it's got some issues), but I don't think you're exaggerating about Horde. So instead I'll suggest, after browsing Horde's code, compare it with Drupal. 
&gt;Note: XHProf uses the RDTSC instruction (time stamp counter) to implement a really low overhead timer for elapsed time. So at the moment xhprof only works on x86 architecture. Well, that's a dealbreaker for me then, go XDebug!
[Symfony](http://www.symfony-project.org/)
[Reddit markdown primer](http://www.reddit.com/r/reddit.com/comments/6ewgt/reddit_markdown_primer_or_how_do_you_do_all_that/)
Aha, thar we go. Thank you :)
Any idea why the code uses back-slashes for its include paths?
SwiftMailer is one of the best codebases I've ever seen.
If this is a joke - good one :P If not: namespace separator.
Yes, I had forgotten that they're so busy writing awesome code in KO3, the site and docs are completely neglected.
x86 only and your screencast didn't play on my computer. Also, I haven't heard of it.
Then by all means blog and bring awareness to the community. But flamebaiting your posts in the way you did ("Is this a reflection on the state of the PHP community?") is only going to garner negative attention and attach that negative attention, rightly or wrongly, to XHProf, making it even harder for the PHP community to accept. The generally accepted practice in the PHP community is build your application first, then test for correctness, profile for accuracy, publish, log fatal errors, wash, rinse, and repeat. If you feel having performance logs running on a production server has merit, blog about it and submit to phpdeveloper.org (it will be read there by the people who need read it). If you feel XHProf offers things that XDebug doesn't or cannot, blog about the differences and submit to phpdeveloper.org (Derick will catch the post there, though I'm willing to bet you he already knows about XHProf). But please don't belittle the community for not summarily accepting everything that walks out of Facebook at first notice (remember, XHProf is barely 6 months old), and don't belittle the people who run PHP sites that see so much traffic that (a) any new feature or extension is potential instability, which is unacceptable, and (b) are so high traffic much of their heavy lifting is in custom PHP modules (see: Yahoo). **tldr** Don't rant on reddit, many of the core PHP audience are not redditors. Do a comprehensive feature analysis blog, do a feature comparison blog, or do a case-study blog and send an email to [phpdeveloper.org](http://phpdeveloper.org/contact) with a link to your post and a brief summary of what it's about. It'll get posted and you'll get the attention you think XHProf deserves.
This is [my project](http://code.google.com/p/sabredav/source/browse/trunk#trunk/lib), curious what PHP redditors think.. 
Can't comment on the architecture of the solution, but from a stylistic / implementation perspective, it looks way above the norm in PHP-land. The only things that appears a bit suspect to me, is that you have some concrete class dependencies in form of typhints and classes instantiated in other classes. Could you perhaps use dependency injection / ioc here? Also, `Sabre_PHP_Exception` is duplicating the built-in [`ErrorException`](http://php.net/manual/en/class.errorexception.php).
Great comments! thank you. I'm regretting quite a bit I didn't use dependency injection, but there was already a bit of a userbase, so I was scared of making any more significant changes. If I have enough time to do a 2.0, I'm hoping I can make these changes and during the same time also switch to using namespaces. I never knew about the ErrorException. Thank you for that as well
If you want a gradual transition, you can extend constructors to have optional parameters and just fall back on the current mechanism for default. In my experience, that's usually doable and offers abit of the best of both worlds (You *can* inject dependencies, but you're not required to).
eZPublish - the best CMS IMO, it's not easy to get your head around it, but the code is very good. http://ez.no/ezpublish/content_management_system FLOW3 - not done yet, looks promising if it ever gets released http://forge.typo3.org/projects/show/flow3-overview
This is because everything else that Nagios uses (IE css/images/frames..) are still pointing to 10.0.0.18 when there rendering out http://outsidedomain.com/ so they get 404's and you get ugly html. you need to do a str_replace("10.0.0.18","outsidedomain.com",file(...)) but this will require those static files on that root aswell. so you may wanna do something like ...file('10...8'.$_GET[f]) and change the urls to work like getres.php?f=/style.css feel free to ask questions
The fact that I'm downvoted and your drivel is up a few points points out perfectly why most of you are fat fuck virgins that will never be able to get a girl. You think I'm an "Internet Tough Guy" just because I called you a dumbfuck? Get some thicker skin.
Rhetorical question.
Keep going, I'm listening.
It does because I custom tailored the scripts for a few of the popular frameworks, and I will eventually get around to Zend framework when I have to deal with it again. update: The goal for me was to provide some sort of comparable service to what RoR's script/serve or paster serve provides to their respective frameworks.
thanks for this
Surprised no one said this one yet: [Doctrine](http://www.doctrine-project.org/) Fully unit tested, and he even [lists](http://www.doctrine-project.org/documentation/manual/1_2/en/technology) the design patterns used. Although one may say that this is overengineered.
You think that's bad? Try working on any variation of oscommerce.
I came here to mention osCommerce too. ExpressionEngine's pretty lame too, though.
I loved the case studies page: http://www.boonex.com/about/case_studies/ "Asien LadyBoys Datingsite", sold! :D
I've been using CMS Made Simple for small business websites and I am happy with it so far. Designers and clients like it and I can make it do what I want to most of the time. I have lots of complaints about it too of course, but a good stable OS solution that works for clients.
I thought Dolphin was just for making Russian mail-order bride sites? I remember getting elbow deep in it back in 04, it was shitty and backwards even then.
SwiftMailer
osCommerce? Try eCommerce templates. There's a 6000 line procedural mess of PHP, JS, HTML and ASP which makes up "inccart.php". First time I ever saw that I stroked out.
Just thinking of osCommerce makes me wince!
Drupal + UberCart kicks a lot of ass. Theming most of UberCart is identical to general Drupal theming. There is some learning curve with Drupal, but it has my favorite API by far of any CMS or eCommerce package I've looked at. And Drupal's usually ranked one of the best, documentation wise. And there are tons of great books ("Front End Drupal" comes to mind.)
wow... just... wow...
Ack - I keep hearing Prince in my head now - Tonight we're gonna code like.... STOP - MAKE THE MADNESS STOP!
Hate it. Very slow and the upgrades are a nightmare.
I wanted to get back to you all after providing such great input. I've read up on longpolling which seems to be all the rage, however I am concerned about occupying a thread for each request as mentioned here: http://stackoverflow.com/questions/333664/simple-long-polling-example-code. Is it a real problem that one has to take into consideration or is it just facebook and such sites that need to be concerned?
That is actually exactly what happened.
I didn't get far before I saw this: mysql_connect(... Don't do that, it kills the soul of many programmers. Utilize PDO! An introduction to PDO can be fund here: [PHP PDO introduction](http://www.kitebird.com/articles/php-pdo.html) 
[HeavyMetal](http://getheavy.info) - MVC/OOP/Written by people who hate PHP. +1 for the logo. Developed to build [massify.com](http://massify.com)
Here's something I've been messing with for awhile: http://github.com/huberry/phuby I've been wanting to actually get some feedback about it - especially from people that also use ruby.
tl;dr: Don't use unserialize() on user input. Don't do ANYTHING on user-input. Treat it like the plague, and sanitize it five times over before looking at it. This is old news.
I use serialized arrays quite a bit (at least when it's necessary) but I would never think to pass it to a user via cookies or forms... that's just stupid.
Just sanitize all user data, doesn't matter how you contain it. Do not trust any user modifiable data.
That includes cookies too - SQL injection exploits on cookie content is something that many people miss, where they use the cookie data in SQL and forget that end users have the ability to set arbitrary cookie data.
Yes, but this is a specific problem concerning what you do with the data before the data within it gets sanitised. So the point is not to deserialize user-supplied data *ever*.
This is why [prepared](http://ca3.php.net/manual/en/pdo.prepared-statements.php) [statements](http://ca3.php.net/manual/en/mysqli.prepare.php) should always be used.
Great, I used this function for the first time yesterday. :( God hates me.
PHPFUSE - http://www.phpfuse.net/
How about using json_decode and basically treating that object as if it is already compromised. Not that there is any reason to actually do this. I'd use it to store session data in the database however (I use my own session object that has more specific criteria to meet than PHPSESSID). Json_decode is actually fast and tasty, too!
That's beside the point. You should never never never NEVER NEVER **NEVER NEVER EVER** store anything on the client side. Not doing this negates the whole issue. If all they send is a user_id (along with a session-token), then there is no issue in the first place. If there is no object to parse, there is no need to consider it compromised. It's as simple as that. What you do behind closed doors in internal systems and what you do on the intertubes, they are two completely different things. Sorry if i sound harsh, but "How about..." followed by something that goes down the same wrong track, that's just not right either.
MySQL and MySQLi are abominations; use PDO.
Didn't see that when going from 5.2.11 to 5.3.0
Well yeah, but there are some low security applications that don't need that sort of stress, and can benefit by using the client's browser and cookies to store no-threat data. Personally I don't, I use a session ID and a token (based on a sha-1 of some basic things about the client and a salt etc). You're always at risk from a modified header.
Isn't this due to your mysql (not mysqld) being out of date? IE the client mysql software that should come as part of your whole package?
I have found out the hard way that the easiest way to appreciate MVC is to spend any amount of time working on a big, monolithic, non-MVC web app with 5 or more other developers. 
But seriously, use PDO, and prepared statements.
Mysqli is great with mysqlnd in 5.3, nothing to be afraid of.
I came here to say the same thing, but then I noticed the article is from early 2006. 5.1 (the first version with bundled PDO) came out in very late 2005. At least there's an excuse.
I would like to think that PDO is still much better.
PDO takes care of the mysqlnd backend as well.
With PDO you aren't tied to a particular database type. You can prototype in a quick sqlite and then move to a mysql (or whatever) without altering anything except the PDO connection. Also, prepared statements stop little Bobby Tables from breaking things.
I'm aware of all the advantages PDO has! In some development environments PDO is not available to use though and when that is the case Mysqli is perfectly fine as far as I'm concerned. Mysqli has prepared statements too.
You could just use an abstraction layer to handle that like [Zend_Db](http://framework.zend.com/manual/en/zend.db.html).
Won't help. PDO will in turn use mysqlnd, which is what is blocking the connection attempt. Solution: Don't use the ancient MySQL auth method unless you absolutely have to.
Is it faster? prepared statements are almost always slower...
You can use STRAIGHT_JOIN in any db?
Scalability relies on an application being built in such a way that database usage is minimised anyway. Enjoy your extra nanoseconds and SQL injections, I guess.
Its bindParams method is fucking awful.
With PDO, you don't really need to, and the abstraction is written in C as opposed to PHP.
I was referring to how he was talking about switching between databases (sqlite for prototyping -&gt; whatever else for actual use). Zend_db is good for that, you just change one line in an .ini file and it does the rest.
Aye, that is neat. I just have a handy method in my controller class that returns a PDO object with the default database config by default, but can have other things passed to it as arguments (alternate config files, alternative config parameters, database types, etc) http://github.com/radiosilence/core/blob/master/controller.php#L16
Lol. yeah, that's what mysqli\_real\_escape\_string() is for... and those nano seconds add up really fast when you're doing hundreds of queries per second all day long. In any case, PDO is an extra layer on top that will result in slower queries.
Hail Satan indeed. 
Escaping everything is irritating and time consuming, and doesn't always work.
:D
&gt;doesn't always work. Actually it does. You find it annoying, I see it as being part of making fast and effective code.
This is why you're a bad PHP programmer; all (and I mean _all_) modern programming languages that interact with databases have a means to utilize prepared statements, and anything else (ie: manual escaping) is just insufficient
Nice. So because prepared statements are available for use, I am required to use them if I am a good programmer? What kind of retarded generalization is that? You want me to duplicate all my string values into an array, then hand them off to a prepared statement, which is then plugged in to my query through string replacement.. all instead of just using the standard escape string function that does THE EXACT SAME THING, WITH HALF THE INSTRUCTIONS. Yeah.. *i'm* the bad programmer for wanting to be more efficient. You fucking tool. So tell me, what projects have you done? I'd love to see all the work you've done in PHP that far surpasses everything I've done.
I bet you still use it daily. What a champ.
&gt; You want me to duplicate all my string values into an array, then hand them off to a prepared statement, which is then plugged in to my query through string replacement.. all instead of just using the standard escape string function that does THE EXACT SAME THING, WITH HALF THE INSTRUCTIONS. Right, because you want to always remember to perform magic on *every single thing* you're going to stick in the database every single time and have to deal with string concatenation, versus having it happen *automatically* with *zero effort* because someone else already wrote all the code to do it? Because we have to micro-optimize every single thing we do otherwise performance sucks, right? If you are, in 2009, willingly using string concatenation and manually calling your database's escape function rather than using a non-fucktarded API involving prepared statements, you are either a newbie that requires education or someone so stuck in his ways that he can't see the world has moved on. Or worse, stuck using a fucktarded API. Oh, and for the e-peen, I maintain a multi-hundred-thousand-line custom-coded PHP-based ERP+CRM+CMS for a $25M/year company (boo recession). It's a steaming pile of shit, but even *it* gets this right.
Wow, really? 100,000 lines? That's a lot. Did you write it? I actually wrote my own CMS, it's 50,000 lines of code. Took me 3 years to complete. I use it on all my websites, and it works great. and yes I concatenate each variable into the query, not only is it way easier to read, but it's also significantly faster since I'm dealing directly with mysqli and not though multiple wrappers. Enjoy your shielded life where you think all programmers that don't code exactly like you, are "bad". Fucking retard.
Wow, a CMS. Great for you, who *hasn't* written one at some point or another? All *your* websites? What about professionally? What about your co-workers? You do work in a team, right? What are your code reviews like? You do review each other's code before it gets pushed into the stable branch, right? No, I don't think you're on a team. You're probably a solo coder. Probably even a contractor, I'd bet. I was like you, once. Five years professionally, just me with nobody else to code with. I thought I was hot shit, but then I switched jobs and realized how little I really knew. Code quality matters in our team. It's not just "works", it's not just "easy to read", it's not just "easy to follow", it's not just "well designed", it's not just "fast", it's not just "best practices", it's not just "style guidelines". It's all of the above, or it doesn't get released. If one of my team members was to submit code that bypassed placeholders in favor of string concats and individual escapes, he'd get beaten to death by the rest of the team. No, actually, he'd get told to fix it, because down that path lies insanity. Prepared statements using placeholders have been the preferred way of working with SQL *on a cross-language basis* since forever. Hell, they've been in Perl's DBI since 199-fucking-4. That's before Java even existed, before Ruby was even released to the public, and way before Python became popular. PHP's omission of them was a horrible mistake that they remedied in mysqli. The very extension you now use. I shudder to think of the horrors that are in a 50kloc application built by someone that intentionally doesn't use prepared statements/placeholders in favor of individual escaping and string concatenation. I may be a fucking retard, but I'm at least a fucking retard that knows the difference between awful code and decent code. I should know, I get to deal with both varieties all day long. (Ask me about how I made PHP fucking segfault on the line "global $user;" for a hoot. Goddamn, I hate PHP sometimes.)
PDO is in C, MDB2 is pure PHP. There's very likely to be a small performance hit using MDB2 in comparison, but it's not likely to add up unless you're doing hundreds or thousands of queries per request. (When PDO was first released, it was also benchmarked as slower than the specific interfaces. I don't know if this is still the case.) PDO's documentation can be occasionally lacking. Quick, how do you ask it to return another class for statement handlers instead of PDO::Statement? (Hint: Attributes! Attributes?!) PDO lacks a handful of convenience methods that MDB2 has in the "Extended" module, but those shouldn't be hard to add to PDO with your own class if you wish. Don't count out other interfaces, such as Zend_Db (which in turn can use PDO or a DB-specific interface). FWIW, Lukas Smith is behind much of PDO, works on the Zend Framwork, and was a developer on MDB2. The three share not-dissimilar interfaces.
&gt;I shudder to think of the horrors that are in a 50kloc application built by someone that intentionally doesn't use prepared statements/placeholders in favor of individual escaping and string concatenation. The horror, easily readable code that makes sense.. the horror.. WTF is wrong with you? and yeah, I use my framework on the job, I have 3 programmers working under me (on my team). I've used it on about 60 websites and it works great (no I will not list them all for you in order to win a fucking internet argument with a retard). What's hilarious is that you're attacking me, telling me I'm a bad programmer, when you know next to nothing about me or my experience in the field. Keep making bullshit assumptions about me, it makes you look retarded.
You really are a pathetic childish person if you have to add things like: &gt; You fucking tool. &gt; Fucking retard. After your at best mediocre posts. A nanosecond or two saved on a query is not going to make your application faster, premature optimisation is useless even in C now, let alone a high level language. Computers get faster, people don't.
You argue like a fucking child.
You realise that prepared statements are actually faster in real world applications because they allow MySQL to cache the logic? http://dev.mysql.com/tech-resources/articles/4.1/prepared-statements.html # Why use prepared statements? &gt; There are numerous advantages to using prepared statements in your applications, both for security and performance reasons. &gt; Prepared statements can help increase security by separating SQL logic from the data being supplied. This separation of logic and data can help prevent a very common type of vulnerability called an SQL injection attack. Normally when you are dealing with an ad hoc query, you need to be very careful when handling the data that you received from the user. This entails using functions that escape all of the necessary trouble characters, such as the single quote, double quote, and backslash characters. This is unnecessary when dealing with prepared statements. The separation of the data allows MySQL to automatically take into account these characters and they do not need to be escaped using any special function. &gt; The increase in performance in prepared statements can come from a few different features. First is the need to only parse the query a single time. When you initially prepare the statement, MySQL will parse the statement to check the syntax and set up the query to be run. Then if you execute the query many times, it will no longer have that overhead. This pre-parsing can lead to a speed increase if you need to run the same query many times, such as when doing many INSERT statements. &gt; (Note: While it will not happen with MySQL 4.1, future versions will also cache the execution plan for prepared statements, eliminating another bit of overhead you currently pay for each query execution.) &gt; The second place where performance may increase is through the use of the new binary protocol that prepared statements can use. The traditional protocol in MySQL always converts everything into strings before sending them across the network. This means that the client converts the data into strings, which are often larger than the original data, sends it over the network (or other transport) to the server, which finally decodes the string into the correct datatype. The binary protocol removes this conversion overhead. All types are sent in a native binary form, which saves the conversion CPU usage, and can also cut down on network usage. So not only do you act like a dick, you're completely wrong.
&gt;You really are a pathetic childish person if you have to add things like I'm childish for being pissed off when someone opens with this: &gt;This is why you're a bad PHP programmer; Right. How about I try it on you: You're a bad programmer. (a completely unfounded claim being thrown at you) I'm sure you're more than willing to accept that claim and not take it in any way personally because you're low on oxygen (up there on your high horse). &gt;A nanosecond or two saved on a query is not going to make your application faster, premature optimisation is useless even in C now, let alone a high level language. Computers get faster, people don't. Nice, it's the "lets not bother making thing efficient because computers will get faster argument. Let me guess, it's alright to use: $var = "$string1"; Because hey, who needs to bother using concatenation when PHP will handle my lazy code..
Thanks for your irrelevant opinion.
Nice, so basically if I can summarize this block of text that you likely didn't read: If you write poor/repetitive code that has many queries in loops, then you will gain a speed boost from mysql's parsing of the query. Fan-fucking-tastic. Learn how to write more efficient queries and you'll never need to execute the same query over and over in a given script in the first place. Bad/Lazy programmers will do a select, then while looping through the results, will do smaller queries for related info.. this should almost always be done in a single query with subqueries. When dealing with escaping of variables, I know better than a prepared statement as to what needs to be escaped and what doesn't. If the var (that has been asserted as such) is an int or float, I don't need to apply standard escaping, if it's a string, I do. &gt;you act like a dick Nice to see you're just as childish as me, douche.
Yeah, but "$string" is just lazy, anyone who has read anything will be using concatenation. PDO is a newer, nicer way of working with the database with many benefits (as I quoted somewhere). &gt; You're a bad programmer. (a completely unfounded claim being thrown at you) I honestly don't care, I know I'm not, and I don't have to throw a hissy fit in order to assert this.
Calling you out for acting like a tosser is vastly different from throwing insults at someone for insulting your enlarged coding ego. I'm criticising your actions, not you as a person. For all I know you could be charming and just having an off-day, but that doesn't excuse throwing a tantrum because someone argued against your decision to defend an old extension. What on earth made you think that because hey, your database software may do the same thing more than once, I'm clearly using poorly written code that doesn't use an efficient amount of queries? MySQL will be doing the same query lots of you get more than one visitor to your site...A lot of the things mentioned there are optimisations aren't necessarily on a per-request basis. And if you're writing efficient code, the minute speed benefits of using PDO won't even really matter anyway.
&gt;Calling you out for acting like a tosser is vastly different from throwing insults at someone for insulting your enlarged coding ego. I'm criticising your actions, not you as a person. For all I know you could be charming and just having an off-day, but that doesn't excuse throwing a tantrum because someone argued against your decision to defend an old extension. Go back and re-read exactly what he wrote. He called me a bad programmer because of my opinion on prepared statements. That's the kind of trash I hear from python programmers who trash talk PHP and say anyone that uses PHP is a noob that should ever be called a programmer. *If* I'm wrong about prepared statements, then fine, I'm wrong.. THAT DOES NOT MAKE ME A BAD PROGRAMMER. If you make such a statement, be ready for me to be fucking pissed off. It's a goddamn insult for someone to bash your abilities as a professional. I spend at least 70 hours a week doing PHP coding. I don't like being insulted for one of my favorite pastimes and being called incompetent. Do you? &gt;What on earth made you think that because hey, your database software may do the same thing more than once, I'm clearly using poorly written code that doesn't use an efficient amount of queries? MySQL will be doing the same query lots of you get more than one visitor to your site...A lot of the things mentioned there are optimisations aren't necessarily on a per-request basis. Example of bad code: $users = $sql-&gt;query(" SELECT id, username FROM users "); while($user = $users-&gt;fetch_object()) { $session_info = $sql-&gt;query(" SELECT session_id FROM users_sessions WHERE user_id = '".intval($user-&gt;id)."' ") } Can you not see how a simple join would make this far better? You can almost always do smaller queries in a loop and merge it into the main query through a simple and *very fast* inner join. Sure, if you're only working with a few rows it wont be that much slower, but if you do 1000 rows, suddenly you're looking at up to a second or two delay, even if the looped query is very simple.
Well that is obviously bad code, and something I wouldn't write. I fail to see how an example of some bad code that could use *any* library is an argument against prepared statements. If you have lots of users, MySQL is going to be doing lots of work, even if if is only in the script once per request. I too am a PHP professional with lots of experience working with various code-bases, so I do know what I'm talking about. I can also tell you that there have been people that work doing this stuff full time, and have done for a long time, and still utterly suck at it. &gt; Go back and re-read exactly what he wrote. He called me a bad programmer because of my opinion on prepared statements. That's the kind of trash I hear from python programmers who trash talk PHP and say anyone that uses PHP is a noob that should ever be called a programmer. But if you know you're not, take the higher ground and don't descend into petty insults. Either way, PDO and mysqli have such small speed differences (from what I can see, PDO is faster at some things, and mysqli is faster at others), that it doesn't matter. Even if you don't want to use prepared statements, you can use PDO::query instead of PDO::prepare.
&gt;But if you know you're not, take the higher ground and don't descend into petty insults. This is the internet. That never works. I had two choices, ignore it and move on, or retaliate, calling his non-sense out and hitting him back. I'm not Ghandi. If someone hits me, I don't sit there and take it. &gt;Either way, PDO and mysqli have such small speed differences (from what I can see, PDO is faster at some things, and mysqli is faster at others), that it doesn't matter. Even if you don't want to use prepared statements, you can use PDO::query instead of PDO::prepare. Great, *if* that's true, then I was mistaken with my OP comment about it being slower.. that does not however make me wrong or stupid for using standard escape functions. It safe, it's easy to use and it's effective. What's wrong with that?
&gt;PDO is a newer, nicer way of working with the database with many benefits (as I quoted somewhere). Well that's nice.. If python had great variable handling like Python, I'd be far more inclined to want to use PDO's prepared statements.. The last time I ever bothered reading up on prepared statements (prior to my learning Python-Mysql, was when I was still using mysqli in a procedural fashion, and it was immediately obvious why I didn't want to use that, because it was clearly slower.
Nothing much, I just try and have variables and strings seperated as much as possible, much like you separate system logic and template. This is why I use sprintf more than concatenation. PDO just has a lot of advantages, of which only one have you talked about.
Kohana, based of Code Igniter is a PHP 5 MVC framework worth looking into. Even CI is great, although not PHP 5. 
What's with the 2005 articles lately?
Kohana is hands down the best framework IMO. It holds your hand, but it doesn't push you off a cliff. It's lightweight, extensible, and all that other good stuff. It's really fast, instead of being a bloating pig like symfony or zend. If you try it out though, make sure you go to the forums and download the 3.* series (the "download" link is to 2.6 - 3.* isn't on there yet because the docs aren't finished).
True, it does have docs, but they aren't complete. To be honest though - and this is what I did - you can learn how to use the framework by reading the source. It's very clean and commented well. This wiki is the best 3.0 doc source: http://kerkness.ca/wiki/doku.php
PHPizabi is far worse than Dophin CMS.
"it also probably wont work on windows" i got a chuckle from that part of the documentation
Doesn't seem to be functioning at the moment. Looks potentially cool though.
oh, you must have caught the server reboot. Hopefully it's working better now.
It looks trendy although not very clear, it seems to work reasonably fast, but mostly I didn't find any distinguishing or attractive features. Why would I use this instead of redmine or trac other existing solutions? (not that I mind competition). Also, the fixed position of the header gave me the feeling of frames.
This article is outdated (2006). It's basically a regurgitation of the PHP documentation, without covering the newer and more important features, like prepared statements.
`mysqli_real_escape_string()` is not thorough enough to protect your code from SQL injection. There are proven multi-byte vulnerabilities in that function. Prepared statements are the only way to guarantee safe queries.
i built it mainly because redmine and trac were too hard to install and customize. This made them just as hard to maintain and when trac went to 0.11 and my themes were broken, I decided to start something in php. 
Citation definitely required.
I prefer Kohana. No annoying class names, and their "layered filesystem" thing is very cool. That being said, both are tried and tested frameworks. If you find Yii easier, then use it.
Kohana all the way. Yii is made by the guy who made Prado, which is a mess. Basically, the problem is that Yii tries to be like ASP.NET - it's an event driven framework. Instead of checking $_POST and all that, you instead register onClick events, for example. That's nice, but it completely abstracts away the concept of post and HTTP. I'm a man; I can handle that stuff myself. Yii is new (not even a year old), and it is not really used by that many people. It's just too different and tries to mold PHP into something its not. Kohana, on the other hand, is simplistic and beautiful. If you want a framework that does everything for you, choose Zend or Symfony. If you want a framework that does JUST ENOUGH, but not too much, choose Kohana.
The cascading filesystem has got to be one of the most awesome features.
Tried git clone git@thechaw.com:chaw.git -- It hung up on me. You did say it is open source, right? 
Anyone know some good learning resources for Kohana since they are in the middle of releasing the next version the documentation is all for the old version and a lot has changed since then =\ -Chris
I don't suppose it works without git/svn on the server?
It was me. I am sorry...
It looks like the line endings have been removed. Are you running it through some kind of optimizer that would turn &lt;?php require_once( to &lt;?phprequire_once(...
:(
FileZilla was set on binary only...
To make sure you were on your toes.
Judging from the screenshot (at the bottom right, note the word 'MAC' in the status bar) Notepad++ has your line-ending characters setting configured for Macs (line-ending characters are carriage-returns) and Facebook strips them all out in favour of line-feeds for line-ending characters. Format -&gt; Convert to Windows Format This will change Notepad++ to use carriage-returns AND line feeds in that file. You can see what line-endings Notepad++ is using by going to View -&gt; Show All Characters (or if you're using the most recent version of Notepad++, View -&gt; Show Symbol -&gt; Show All Characters) to make sure. Carriage-returns will show up as CR and line-feeds will show up as LF -- and both will show up as CRLF.
This comment is unbelievably unhelpful -- what does pre- and post- include mean? Do you mean Facebook is 'include'ing the file to see what it does (for whatever reason) and then 'include'ing it again to gather the output? Please be more specific. Also, your snideness doesn't fit well with this sub-reddit. How rude.
@IvanRedBear http://thechaw.com/wiki/guides/setup You have to setup and account with ssh key.
@rmccue you would not be able to use the source/commits views, but all the other features should work fine.
well all I can say is we've all been there, stay strong.
http://v3.kohanaphp.com/guide/about.kohana
But his server is running unix, so that wouldn't really make a difference.
I smell Gremlins ... TextWrangle (mac application) has a "Zap Gremlins" feature which I've found very helpful in the past when faced with issues like this (weird compile issues, or strange runtime errors). I'm sure Notepad++ must have the same.
I found Kohana much easier to learn and work with, although my opinion might be a bit biased since I haven't messed with Yii as much (in part because the Kohana docs are much easier to get started with than Yii's). Performance wise I've heard Yii is faster, but also that KohanaLite is faster in a Hello World benchmark than Yii. One thing I dislike about Kohana though is that it isn't exactly super fast (although quicker than most frameworks). I don't like their database support and have wrote a custom library for using PDO within Kohana. On a side note too, I have also started writing my own super tiny framework. I've always been against the idea of what Kohana and most frameworks do; they take every bit of learning PHP from experience away from development. It handles most all security checks for you, cleaning data, and so on. I try to encourage everyone that is not as experienced with PHP to skip frameworks until they are comfortable writing their own code.
I concur. A project built on Kohana 3.0 will have a very clean an easy-to-understand filesystem. It's one of those features that make me think "I wish *I* thought of that!"
Is it a shared host? Maybe the function is disabled in php.ini disable_functions?
yes it would. edit: because he uploads the file as a stream of binary, and the server isn't going to go in and rewrite all his line endings. So unless he opens the file on the server in vi and re-saves, the line endings aren't going to get converted over.
[http://kerkness.ca/wiki/doku.php](http://kerkness.ca/wiki/doku.php)
To address your segfaulting issue: you shouldn't be trying to access global variables from within functions. If this isn't clear to you then you truly are a bad programmer in general. It is a basic scoping issue that should be handled by providing the proper inputs at the function-definition level (the 'global' keyword is yet another relic from the days of PHP4, just like magic\_quotes and register\_globals). So, do you always blame your tools because of your inability to utilize them properly? I'm sure PHP is barfing at the troublesome idea of trying to reach variables outside of a particular scope for good reason. I have yet to find any other language that provides such a ridiculous capability.
Easy solution? put a space after the &lt;?php But I'd listen to ihsw, he knows what he's talking about.
Yeah, K3's documentation is just [awesome](http://v3.kohanaphp.com/guide/security.validation).
So it seems the FTP God was messing w/you. 
Can someone tell me what is wrong? Is it the double-line spacing?
There are three types of line-end characters: * Mac: CR ("\r") * Windows: CRLF ("\r\n") * Unix: LF ("\n") If the web-server is Unix, it will expect to see a LF character when parsing the PHP source file. A CR character will be completely ignored, which means either Windows or Unix-style line-ending characters would suffice. Since his source code was using Mac-style line-endings, PHP parsed its contents as such: &lt;?phprequire_once('fb/facebook.php'); Normally, `&lt;?php` would be considered the starting block for PHP, but since the CR between "php" and "require" was ignored, the interpreter falls back to using just `&lt;?` as the starting block for PHP (which is permitted by the "short-open tags" config option). "phprequire_once" is then picked up as a consecutive string of characters and treated as a function name.
Facebook apps are not processed on the facebook servers. The error message is just the output from my app being displayed through facebook.
The only thing I can think of other than line endings is that perhaps Facebook is trying to `exec()` your file after somehow parsing it (presumably to remove anything that might be dangerous), and that parsing is screwing it up.
After seeing how Kohana3 is really well-made, I fail to understand why anyone would use Cake or Symfony over it.
&gt; Performance wise I've heard Yii is faster, but also that KohanaLite is faster in a Hello World benchmark than Yii. Benchmarking frameworks is really one of the most pointless comparisons to make. I don't blame you - there's a lot of fuzz about it, but don't waste your time with that.
haha, his last name is "Butts".
If you haven't yet, read up on design patterns.
Perhaps you should define what you mean with "advanced programming". As in, what are you doing NOW, what do you want to do in the future that you a) can't do now, b) know that you're really doing in an ugly way now.
Try your hand at different data structures and search patterns. Use it as an academic exercise to understand the complex data types beyond a simple array. Try to make merge sort, quicksort, insertion sort, and figure out ways to improve the design of them. Compare the speeds too. Make a binary tree or ternary tree and then try your hand at some sort of AI algorithm.
Or at the very least use the mysqli extension instead of the mysql extension, especially if you're interested in learning OO principles. mysqli offers * an OO interface (you're trying to learn OO principles, right?) * prepared statements (much more secure) * transactions PDO offers all of the above, plus a much easier path to supporting additional rdbms. More details in the [mysqli overview](http://ca3.php.net/manual/en/mysqli.overview.php). 
Talk about making assumptions without anything to base it on ...
Short tags ftl.
Try writing your own framework. I'm not saying write the next symfony/kohana but just something for personal use. Think in advance what features you want, I took the best bits (IMO) of various frameworks. I wanted a PHP framework with Django style URL routing and an ORM that has backend support for both Mysql and Mongodb (I know Mongo ain't relational) as well as a Web2py like admin. While writing the framework I learnt a whole heap about regular expressions, need for factory, singleton and observer patterns, abstract classes, writing efficient code, pecl and compiling PHP (for 5.3 support). I also learnt about the neccessity of planning large projects and writing documentation. Your not going to get it right first time. I'm on my 4th large refactor and it still isn't in an open source-able condition.
Heh, already doing this. I started with Kohana and stripped it down rewriting it. Got it fully working already and working on trimming it up a bit. Ran some stats and have it using .065 MB of memory with about 10 included files for most pages. Damn quick so far and still has most of the bells and whistles ( minus the cascading file system and several other resource intensive lookups ). I actually learned about factory from Kohana and chaining methods this way, which I think is pretty awesome. I do not know anything about the observer you mentioned above. As far as documentation goes, I am awesome at this ;)
than
No.
i learn php mostly by trying to implement interesting things i found on the net. that includes not only the usual things ([code kata](http://codekata.pragprog.com/) or [project euler](http://projecteuler.net/)), but ... uhm, some examples: * i once wrote a tcp socket client (a cli app) that created [sodarace creatures](http://sodarace.net/) designed with evolutionary algorithms and pushed them to the sodarace app. it didn't work very well, but i learned a bit about socket programming and evolutionary algorithms. and it was fun to look at. * not finished (yet, probably never): a very simple, easy-to-use couchdb-like document storage ORM (querying by first class functions). * one of my biggest side projects was an [urban dead](http://www.urbandead.com/)-like morpg in a fantasy setting (but with graphics and NPCs). i invested a lot of time in it, but it was surprisingly hard and never made it out of private beta. * try implementing simple browser games (multiplayer!). basically they're just like ordinary websites, but there are a lot of interesting problems to solve: balancing, security, algorithms (pathfinding), performance, concurrency, ... * learn and understand javascript to grasp closures and anonymous functions. in php they're 5.3 only, but to know them will pay off soon enough (also, js is quite a nice language - don't forget to learn to do oo by prototyping). it will never hurt a web programmer to know javascript well. * learn a functional language like haskell to understand recursion. i *(thought i)* understood and used recursion before learning haskell, but i didn't get *just how fundamental* recursions are until using FPs. * maybe throw some prolog or [dlv](http://www.dbai.tuwien.ac.at/proj/dlv/) in the mix (logic programming) * if you want to be a better php programmer, don't focus on php - to the contrary: get away from it to get motivation! php isn't exactly "teh hot sh1t!" anymore, so many motivated and resourceful programmers switch to more fashionable languages and invent funky things *over there*. still, you can use or port a lot of that stuff to php, and learn a lot in the process. browse github &amp; co for inspiration. * some random algorithm and exercise suggestions to explore and implement: * A\* pathfinding including an efficient priority queue (splay tree?) * markov chains * fractals * raytracers - simple raytracers are not that complex, but you need to know math (maybe my next side project) * wikis * a rock, paper, scissors "AI" (simple pattern matching) good luck.
It is based on information from Facebook. Should we rather ask you about the Facebook architecture?
He assumes that some particular code is more efficient if written in C++, but how would he know, when it hasn't been done. That's an assumption, and yes, you might as well take my word for it as anybody else' since it's wild speculations in any case.
Thanks, a lot of nice suggestions. I have tried learning something other than PHP, so I started with C++ (no C knowledge). I figured since it was close in syntax but more system oriented it would help, and it has. I don't know enough to write programs using the Wind32 API ( I think that's what it is atleast ), but I can do the small terminal-esqe programs that everyone starts out on. It seems to have helped a bit. I want to move onto javascript, since they kinda go hand in hand with web development. I've also noticed by reading through a lot of javascript they handle object oriented related stuff differently, which might help me. I have also learned Game Maker Language ( for Game Maker ) which is C like as well, with really no object oriented handling. It was quite interesting because every game I've done relies heavily on math, which I am not that great at. Thanks again.
This is closer to half-assed head-hurty traits/roles than multiple inheritance. 
something i've been doing lately is tring to write as tiny as possible apps, blogs, wiki's. start with a wiki. see if u can make one in 5 lines no longer that 80chars long
There's a particular catch here that may not be obvious: Storing multiple-item basic site preferences in a cookie (e.g. preferred background color, text size, etc.) that don't require logging in. It is tempting to store the preference settings in an array and serialize that array into a cookie. In fact, it's still unclear to me whether this creates an attack vector. Can they feed an object with a `__wakeup()` or `__desctruct()` call that does something instead?
as a fellow intermediate php programmer, i'd say its best we think of where the language is going. lithium... mentioned previously in [/r/php](http://www.reddit.com/r/PHP/comments/a2m3v/lithium_the_new_php_framework_on_the_block/) is an interesting framework to run through a debugger to muss with php 5.3 features (clusures, namespaces, etc) in a cogent example. edit: the [OAuth plugin](http://rad-dev.org/li3_oauth) is interesting ...
But multiple inheritance is insanity; just look at C++.
What about CodeIgniter? I find it much simpler and more no-nonsense than Kohana, despite the fact that it still caters to PHP4.
These aren't specific to PHP, but can really help you. http://www.ajaxian.com/ http://www.highscalability.com/ 
Tell me exactly why I have to set up an account to clone an open source package's repository? 
Wow, if you look closely enough you can almost see what looks like children bursting into flame inside the code. Perfect example of doing something insane just because you can. I pity the maintainer.
As someone pointed out, this is similar to roles/traits. Even closer to delegation, another OO pattern.
What you can do, is that you can reference any object that already exists in the application. So all you need to do, is to find a class that implements `__destruct` and does something that you can exploit (Such as writing to a file). Read the slides - There's an example.
This is a nice, simple explanation. Unfortunately, that's not a hard thing to do because it's such a simple topic. I'm not sure why this article is on Proggit. Oh, and don't use strings to build XML. It's error-prone and unmaintainable. SimpleXMLElement is classy and does the job well.
Include handling for IfNotModifiedSince too and it would be perfect.
So is there any way to work around this while still using unserialize()? Something like this: 1. Unserialize a user-supplied string. 2. Check if string is an object. 3. If it's an object, kill it without triggering __destruct()
?: is going to fucking rock my world.
quite close to "||" used in assignments :?
Fuck, I took this to mean support for .mp3 and powerpoint.
Even 1. would be dangerous, since an object could have something in the `__wakeup` method. Perhaps it's harder to exploit, but in theory it's a hole. And 2. would be impossible as far as I know. Bottom line is that you can't use unserialize on code from an untrusted source.
I used Zend Studio for a few years. Once it moved to an Eclipse platform, I began to really dislike it. Netbeans can do everything that Zend Studio can do. And the price point is pretty darn attractive.
Check out Doctrine and/or Propel Also, if you know C, take a crack at writing an extension to the language. It's not trivial, but nonetheless a pretty straightforward process. Also, check out the PHP/Java bridge. Also...that's it.
I really don't see the point of these abstractions. HTML isn't all that hard to write.
I can see the benefit from a template Engine like [Smarty](http://www.smarty.net/), it's a bit slow but the next version is said to fix that and it cleans up your code really nice. HAML appears to be written by someone who wanted to make and improvement on a system he can't replace. It's just HTML which I already know written in a way I don't know. What's the benefit?
I know - smarty is sort of understandable until you realise that PHP *is* a templating system in itself, and Smarty is just a simple syntax abstraction. HAML is ridiculous because most people have never seen it before - even designers and many management types can manipulate HTML with at least some ability, who the fuck wants to be teaching people HAML?
 &lt;?php $message = ""; $file_path = "/path I want to upload to/"; if($_SERVER["REQUEST_METHOD"] == "POST") { $target_path = $file_path.basename($_FILES['uploadedfile']['name']); if (move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) $message = "The file ". basename( $_FILES['uploadedfile']['name']). " has been uploaded"; else $message = "There was an error uploading the file, please try again!"; } echo $message; ?&gt; &lt;form enctype="multipart/form-data" action="&lt;?= $_SERVER['PHP_SELF']?&gt;" method="POST"&gt; &lt;input type="hidden" name="MAX_FILE_SIZE" value="100000" /&gt; Choose a file to upload: &lt;input name="uploadedfile" type="file" /&gt; &lt;br /&gt; &lt;input type="submit" value="Upload File" /&gt; &lt;/form&gt;
It seems like you're in a rush, so maybe you don't have the time to do this the "right" way... but... wouldn't it make sense to make the ZIP and SIT files automatically on the server side if they're just archives that contain the compressed PDF? Better yet - unless these PDFs are expected to be really large all the time - why have zip/sit archives at all? At the very least, I would think Mac users can all open a zip file nowadays... though I'm not a Mac user, so that's just an assumption... All that said - Using OrangePlus's response to save the file, it shouldn't be hard to automatically make a zip. [PHP has a library for it](http://php.net/manual/en/book.zip.php), though you may need it enabled if it isn't on the web server you're using.
 // schema.sql drop table if exists files; create table files( id int unsigned not null primary key, f_name varchar(25) not null, f_data blob not null ); &lt;?php // upload.php if(!empty($_FILES['file_name'])) { $conn = // connect to db using mysqli $stmt = $conn-&gt;stmt_init(); $stmt-&gt;prepare("insert into files values(null,?,?)"); $name = $_FILES['file_name']['name']; $contents = file_get_contents($_FILES['file_name']['tmp_name']); $stmt-&gt;bind_param("sb",$name,$contents); $stmt-&gt;execute(); } else { ?&gt; &lt;form enctype="multipart/form-data" action="index.php" method="post"&gt; &lt;input type="hidden" name="MAX_FILE_SIZE" value="900000000" /&gt; &lt;input type="file" name="file_name" /&gt; &lt;input type="submit" value="Upload File" /&gt; &lt;/form&gt; &lt;?php } ?&gt; Completely untested. Please, don't use this code as is. There are many things you need to do to secure it. I would also hope you have something to separate your logic from presentation code. Anyway, good luck.
Sorry, I think you misunderstood or I explained it wrong. The reason I have to provide a pdf, zip, and sit file is because it is for a franchise website where we don't expect franchisees to know much about computers. We have to provide several file types or they'll complain. The zip and sit files don't need to be compiled server side. They are all done before uploading.
Thanks OrangePlus. I'll try this out tomorrow and let you know how it goes. Let's say I successfully upload a file and it is stored in '/uploads'. Are the file names automatically generated and stored in the database? If so how would I call to it for display?
 $files = "&lt;ul&gt;\n"; // open directory and parse file list if (is_dir($file_path)) { if ($dh = opendir($file_path)) { // iterate over file list // print filenames while (($filename = readdir($dh)) !== false) { if (($filename != ".") &amp;&amp; ($filename != "..")) { $files .= '&lt;li&gt;&lt;a target = "_blank" href="/uploads/'.$filename.'"&gt;&lt;strong&gt;$filename&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;'."\n"; } } // close directory closedir($dh); } } $files = "&lt;/ul&gt;\n"; Then just print $filelist wherever you want to display the directory.
first let me note that thesevn's if statement: if(!empty($_FILES['file_name'])) is a better check than my: if($_SERVER["REQUEST_METHOD"] == "POST") if /uploads/ is in the root of your webserver, be sure to make $file_path: $file_path = $_SERVER["DOCUMENT_ROOT"] . "/uploads/"; the filename on the server will be the same as the filename of the uploaded file.
Check your line endings and character encoding. It has to be one or the other. Also, a proper IDE like Netbeans would detect line endings cross platform.
Dude, you rock. Thank you so much.
I see this a lot, why do people use opendir() and friends instead of glob()? Have I missed something somewhere?
It's a relatively new function. Also, if I recall correctly, it's platform dependent.
Ok, the script works great but I really need for the files to be posted and not listed. For instance: Upload: Title: (title box) Thumb: (uploadbox) PDF: (uploadbox) ZIP: (uploadbox) SIT: (uploadbox) and then Displayed in the same order (with the ability to style) THIS IS THE TITLE (THUMBNAIL) CLICK HERE TO DOWNLOAD THE PDF CLICK HERE TO DOWNLOAD THE ZIP CLICK HERE TO DOWNLOAD THE SIT Is this even possible? I know that I'd have to store the names in the database to reference the links right?
It's been in PHP since 4.3.0 (dec 2002), so I wouldn't exactly call it "new". But yes, it has some dependencies on the underlying system, but none that would bite your average developer (as in, if you're doing PHP on Sun OS, you have yourself to blame). But to each his own, I guess. I then assume there was nothing big I had missed :p
Habit. Glob is better, I'm just used to using opendir.
Another reason might be that it's using a lesser known regexp syntax. But I agree that it's an overlooked function.
mysqlnd is a really bad idea, and this shows why. Why anybody could think that it's a good idea to re-implement a stable and well-supported driver from scratch, just to save a few clock cycles, is beyond me.
i have not setup git daemon and probably won't. I don't have server administrators to maintain this stuff for me. I also figured the setup process was simple enough that maybe people who wanted to clone the code I spent many hours writing would not mind creating an account.
 echo lithium\action\Dispatcher::run(); is giving me an error.. is that because of my php version? yepp--namespaces were introduced in 5.3 and i'm running 5.2.3
I think it's funny that, at the bottom-right of their page, I found a "CakePHP powered" button. I've not used Lithium, but is it that far from usable?
rad-dev.org runs on http://thechaw.com which is powered by CakePHP. It is not easy to build a source code and project management system. So, in this case it was better to take something that was already built. Many projects are powered by TRAC or JIRA or even github, so I don't really see a problem with it.
http://rad-dev.org/lithium_bin powers http://pastium.org http://rad-dev.org/lithium_anologue powers http://anologue.com Both of these applications store data CouchDB. Checkout http://rad-dev.org/lithium/wiki/drafts/blog-tutorial for Mongo support. 
namespaces make the code a lot more extensible and flexible. In addition, plugins/modules become very simple to implement and share. 5.3 is faster and has so many nice features that it is more than worth the effort to upgrade.
Help me out on this: http://github.com/huberry/phuby - "rubyisms in php". It's been an awesome learning experience so far and makes you really appreciate the ruby language.
My Zeitgeist: 2000-2010: PHP classes is still an ugly website which missed most of their listed trends.
Is PHPClasses a legit web site? It looks like the kind of site I'd want to visit more, but I'm always afraid to spend too much time there.
I'd like to see the most often looked up php.net pages. I'm guessing strpos is way up there.
date
Ah yes, probably so. strftime was too good for 'em I guess. :)
I've been developping in PHP for 5 years, and I still can't remember strpos' parameters order :(
It looks like shit, but there is a lot of useful stuff on there.
Why do you need to remember that when you can use an IDE?
&gt; Looking for a PHP Job? Looking for a PHP Job? Looking for a PHP Job? Looking for a PHP Job? &gt; Need to announce a PHP Job? Need to announce a PHP Job? Need to announce a PHP Job? Need to announce a PHP Job? Ehh... yes... but I'm sure as hell am not going to click on that. It might be infectious.
They are going to change their design. Last month they had a design contest and even the [top voted designs suck](http://www.phpclasses.org/design/)
&gt; 1 Using double quotes when you want to output a basic string micro-optimisation that's honestly not worth doing. Also dubious whether it even saves a few microseconds [anyway](http://www.phpbench.com/) &gt; 3 Calling a method just because method_exists() returned true who uses `method_exists()`? If you're not sure if a method exists then something's wrong with your code in the first place &gt; 4 Using of uninitialized arrays will cause notice errors, but it's hardly the most heinous of crimes. You should really be developing with all errors showing anyway, so you'll fix these as they occur anyway. right? or are you just brushing notice errors under the carpet? tut tut. &gt; 5 include(“pages/” . $_GET["pg1"]); The mistake here is using $_GET in an include at all, santised or not. &gt; 6 Using mysql\_escape\_string() instead of mysql\_real\_escape\_string(). why? because it's deprecated? &gt; 7 Unquoted array indexes see #4. &gt; 8 Incorrect using of strpos / stripos this kind of example would never have worked in the first place, so it's not really likely to be a "common" mistake.
tl;dr in more detail: unserialize can unserialize() objects and will call __wakeup() on unserialized objects, so unserializ()ing user data can easily lead to remote code execution. or something like that. read from slide 33 onwards. I'm having trouble putting a poc together though.
Hmmm well, indeed. I don't use an IDE, I'm using jEdit which has no text completion for standard functions. Using an IDE makes me feel I'm less hardcore :D
It's kind of an embarrassment to the PHP community. It has a lot of resources on how to do stuff wrong.
I've yet to find an IDE that is as convenient, low-hassle, and fast as vim.
Go lithium!
Is it hardcore to look up strpos in the manual every time you use it?
It's the PHP equivalent to DynamicDrive... mostly crap, but there are some hidden gems.
One of my classes won an Innovation Award there once, (great prizes too), I look at that class now-a-days, and am simply ashamed of the bloat. :(
You shouldn't spend *any* time there.
&gt;I know about the singleton and factory pattern, they are the two I use most often. The singleton is the most often abused pattern. If you really find yourself using it a lot I suggest doing some further reading on it and design patterns in general. I often recommend the book [Advanced PHP Programming](http://www.amazon.com/Advanced-PHP-Programming-George-Schlossnagle/dp/0672325616/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1262935716&amp;sr=1-1) to people serious about getting into PHP. It covers a wide range of topics, and does it well.
[Vanilla (forum software)](http://vanillaforums.org/) is very well engineered. It's a rare example of software that looks great inside and out. 
I will use this posthaste. Awesome, thank you.
It trains my documentation lookup ability. By the time your IDE shows the parameters list, I had thrice the time to Alt+Tab-Ctrl+T-php.net/functionname-enter-read-Alt+Tab. Beat that.
MySQL Full-text is OK for the small time but it's not that good: slow to index, not that much advanced query syntax, harder to do things like "similar items". You really want to be looking at another engine for anything larger than a medium sized app, especially if traffic/scaling is an issue. Take a look at [xapian](http://xapian.org/) or [sphinx](http://www.sphinxsearch.com/): both have PHP bindings as far as I know; both index data from MySQL and both support advanced stemming (a search for boating would return results for boats, boat etc) along with a host of other handy functions. Also reduces the load for poor old MySQL, it wasn't really built as a search engine.
How hard can it be? http://lmgtfy.com/?q=php+upload+multiple+files Especially first hit: http://www.phpeasystep.com/workshopview.php?id=2
Plus using MyISAM means you can't have any foreign keys :(
Just in case someone comes and reads this and gets confused: guitarromantic is talking about FK constraints, you can still link tables relationally with MyISAM, they just won't have constraints.
Hopefully never.
Problem with Kohana is the rewrites and sparse documentation (haven't checked in a while though).
\o/ Unicode! 
...plus Fulltext doesn't play nice with utf8_bin in the case of case sensitiveness.
How slow do you think my IDE is? Granted, I use Netbeans so it's written in Java, but the params still pop up in about as much time as it takes to switch windows. I'm mostly pulling your chain anyway. I've used lots of great editors that don't have completion. I'm using Netbeans more because of its debugger and because I'm writing on a custom framework that isn't particularly well documented, so I want completion for that more than for PHP's built-ins.
Sphinx is excellent and I highly recommend it for any site search engine. MySQL fulltext works really well if search isn't too important or for specific uses, such as searching by tags. For example, if you have a tags field with space-delimited tags you can write a query to match the tags like this: MATCH (tags)", "AGAINST", "('linux mysql -perl' IN BOOLEAN MODE) Where it will return all records that include the linux and mysql tags, but not any that also include perl. It's quite powerful in that regard. Granted, Sphinx can do the same thing, but unless you're also using sphinx for other searches it's probably not worth setting up for this.
Yeah well indeed, the lack of a proper debugger is the main feature I miss. I'm still relying on ghetto-style var_dumps. I may try some IDEs when I'll have the time :)
/agree. When you're doing exact matches it's wicked. Just don't expect it to return Google quality results when you chuck raw blobs of content at it.
Relational links are useless in-practice without constraints.
I wouldn't say useless, annoying/impossible to maintain but not useless.
probably not so soon. that's why they put all the good stuff (clojures) into 5.3.
I got nearly everyone at work hooked on xdebug + Netbeans. Stepping over your code is far better than var_dumps. You can use standalone gdbp clients with xdebug, such as [gtk-xdebug-client](http://freshmeat.net/projects/gtk-xdebug-client), [macgdbp](http://www.bluestatic.org/software/macgdbp/) or [Spectator](http://code.google.com/p/spectator/). Of those, I've only tried macgdbp and I don't like it nearly as much as Netbeans' debugger.
Pretty much sums up my *toolbox* too.
notepad.
you're right about coming back to editplus.. if only they would add the feature where i can ctrl+click on function names / filenames (the "goto definition" thing) to EP i think i'd never try looking for another IDE again
That's my absolute favorite feature of Eclipse. Seriously, it sucks not using Eclipse because of that. I could live without everything else but the ctrl+click.
IDE for PHP? Never understood that.
Why?
How about for debugging? None of the standalone gbdp clients I've used work as well as the best built-in debuggers. When working on a large app it's also highly useful to have auto-completion(both for PHP's built-in functions and for your app's classes and methods).
try aptana
Check out my submission which asks for similar information. http://www.reddit.com/r/programming/comments/altyk/which_linux_php_or_c_ide_do_you_use_do_any_have_a/ I'm currently testing Komodo Edit on Windows and Linux and so far it's working very well for PHP. I have yet to check out the C++ suggestions.
notepad++ (not truly an IDE though)
The title seems to suggest that the hidden feature of PHP being touted is that it supports "stack overflows". I'm pretty sure it's always had that feature.
yep... if you're a registered ep user you can shoot an email to Sangil Kim [ sangil at editplus ] requesting the same.. i guess if enough users ask for it, maybe they'll implement it one day :D
I liked the one about variable variables, although there is never really a good reason to use them.
netbeans. best code completion I've seen
thats what i was going to say first (its what i use) but any "notepad" i guess
There's always a reason why using them is not not a good reason.
I use them all the time. I forget what for, but I'll find some in code somewhere and re-respond. Edit: I can't find any of the code, but I use them a lot in loops. i.e. if I want var1, var2, var3, etc.
What is this "built-in" debugger you are using? What if the code doesn't have classes or methods? This is PHP we are talking about (I'm not saying you, reader, have horrible code, but it is prevelant in PHP). Whenever I see these "Best IDE for PHP?" questions, there is never any definitive answer. Eclipse plugins, Aptana (based on Eclipse), and Komodo.
Why? Why what? IDEs are sensible for some languages such as Java or C#; I find `&lt;?php ?&gt;` boilerplate code to be in bad taste. Too much time spent chasing some grail, and not enough stuff getting done. I dont understand why certain people spend so much time tweaking their desktop either.
Variable variables are usually poor technique and will often result in calling variables that do not exist, thereby throwing a NOTICE.
I tried many solutions and I stick with Komodo Edit (not IDE). It's build with Mozzila Application Framework, with all plugin-extension things support. It's damn smart editor.
Integrating a good debbudder into an IDE to set breakpoints and step through code makes life easy... throw in a bit of code completion and helpful tooltips to display phpdoc info and i say a good IDE is essential. like most cheapskate php developers, i could flip a coin between Eclipse PDT and Netbeans and remain happy. i currently use Eclipse for access to other plugins.
Good to know how to go around it, but this is not the correct behavior. "Next month" means "next month", not "thirty days", the same way "next day" means "next day", not "24 hours". Returning the last day of February would be correct behavior; returning an error would also be correct behavior; returning March is not.
I think it would be more appropriate for 2010-01-31-&gt;"next month" to return 2010-02-01. That way if you did something like 2010-01-31-&gt;"next month"-&gt;"next month" you wouldn't end up with 2010-03-28. It would force the programmer to consider what specific date he or she wants, if one is even desired.
Netbeans, Eclipse, Komodo IDE, Zend, and others all have built-in debuggers. They let you step through your code and set breakpoints and watches while viewing the call stack and values of variables by attaching to the Apache process as it loads a page. I use Netbeans along with the xdebug PHP extension to support attaching a debugger to PHP. Regardless if you're doing OO programming or not, most IDEs will read your code and complete your functions and in-scope variables. Many will also do this for Javascript, including 3rd party libraries like JQuery. Netbeans also lets you setup a db connection and autocompletes tables and fields while you're writing SQL by detecting SQL in a string. I currently work with a very large custom framework and I love Netbeans' ability to command (or ctrl)-click on any function/method/class/variable to go to its definition, even if it's in another file. Viewing the call stack during debugging mode is similarly useful since a lot of the calls go to code I'm not familiar with. I found several serious bugs while using the debugger that weren't even related to the bugs I was looking for. I don't bounce from IDE-to-IDE very often so I can only really speak for Netbeans' features. I also used Komodo previously and it does most of the same things.
In reference to http://groups.google.com/group/php-standards/web/psr-0-final-proposal
That too would be correct although I believe it would be less appropriate. 2010-01-31-&gt;"next month"-&gt;"next month" would return 2010-03-01 which is further away from the obvious date than 2010-03-28.
I couldn't believe the author was defending that algorithm. *Look, the behaviour is correct because it implements this non-sensible and downright wrong algorithm.* "next month" by any real-world definition means "the next page of the calendar".
I've run into this problem in the last, and here's how I solved it: date('d.m.Y', strtotime(date('1.m.Y.', strtotime('now')) . ' +1 month')) 
The term "next month" doesn't really infer a specific day. I would think it's up to the individual to determine the day, if any. A better implementation would probably be to just increment the month and set the day to 1. Or at the very least include a php_ini setting which determines this behavior.
Using strtotime twice there is excessive... you can accomplish the same thing by simply doing... date('01.m.Y', strtotime('+1 month'))
Why not just use mktime? $time = mktime(0, 0, 0, date('n')+1, 1, date('Y')); $date = date('...', $time); 
From memory, the reason why I do strtotime twice is because your code has exactly the same problem as the OPs on the 31st
Agreed. If you need an exact date you shouldn't let your code depend on a vague human string like "next month". Same reason nobody writes: $expires = strtotime('in a few days or so');
o great, there are TWO of them.
A great challenge you can have is to write a storage abstraction layer that supports multiple storage engines, and most of their functionalities. You have to start off a very featured database engine (e.g.: PostgreSQL) and implement its features (db-side scripting, custom datatypes, etc.) and then create other drivers for less-featured storage engines (e.g.: SQLite, Solr). It requires a **lot** of brainpower to achieve that. A quick example of how it could work: $db = new StorageEngine('pgsql://user@localhost'); $query = $db-&gt;prepare(); $query-&gt;addCondition('field', StorageEngine::IS_NOT, 'value'); $result = $db-&gt;execute($query); $table = $db-&gt;prepareTable(); $table-&gt;addColumn('mycolumn') -&gt;setType(StorageEngine::TYPE_VARCHAR, 11) -&gt;setPrimaryKey(); $db-&gt;createTable($table); ... So basically the idea is that you should be able to reuse this code when using Mysql or even MSSQL, just by changing the connection string. All of this without stripping down (or as less as possible) the storage-engine features (datatypes are a real challenge here). It will challenge you architecture-wise and also improve your knowledge on multiple database engines.
&gt; Instead, I prefer EditPlus for all my text editing needs. Why? For one killer feature; a right click context menu item. Right click over any file and choose EditPlus to open the file for editing; it makes working very fluid and continuous. It even handles files in the hundreds of MBs with ease. With a bit of fiddling with the registry, you can put anything in the contextmenu: http://www.emacswiki.org/emacs/MsWindowsGlobalContextMenu
The fact that it "works with [...] private methods, too", makes no sense.
They can be useful when used properly, e.g.: templating. class Template { protected $vars = array('var1'=&gt;'value'); protected $file = 'template.php'; public function display() { foreach ($this-&gt;vars as $__var =&gt; $__value) { $$__var = $__value; } include $this-&gt;file; } } This way in your template you can do echo $var1; instead of echo $this-&gt;vars['var1'];... it's cleaner in my opinion. 
This awfully looks like register_globals. You should not inject POST, GET, session or cookie variables in your code like this, never.
PHP 5.3 was supposed to be PHP 6.. so.. you'll be waiting a really long time if you want PHP6..
You mean closures.
&gt; Instead of checking $_POST and all that, you instead register onClick events, for example. Could you give an example in the Yii documentation where this is specified (using an event instead of checking the $_POST variable)? This is an example from the [Yii definitive guide](http://www.yiiframework.com/doc/guide/form.action) public function actionLogin() { $form=new LoginForm; if(isset($_POST['LoginForm'])) { // collects user input data $form-&gt;attributes=$_POST['LoginForm']; // validates user input and redirect to previous page if validated if($form-&gt;validate()) $this-&gt;redirect(Yii::app()-&gt;user-&gt;returnUrl); } // displays the login form $this-&gt;render('login',array('user'=&gt;$form)); } As you can see very straight forward. The login logic/validation is handled by the LoginForm model. I find the event driven nature of the framework to be extremely helpful. For example you can attach classes to models that respond to 'beforeSave', 'beforeDelete', 'beforeFind', etc events (or you can override the event methods directly in the model class). I used this technique to create models that have all of their changes logged to a separate table by only writing one 'LogableBehavior' class and attaching it to the models I wished to keep track of. Getting back to your comment about not touching the $_POST variable, I think you will find that is not the case at all. In fact you are encouraged to use the $_POST and $_GET variables in controller actions. When [creating user-friendly URL's](http://www.yiiframework.com/doc/guide/topics.url), Yii will put named parameters into the $_GET variable for you.
It seems 6 is a bad luck indicator. PHP 6, Perl 6, and the sixth Duke Nukem (if we omit the N64-exclusive) were all announced a while ago, but still unreleased. Just hope PHP 6 and Perl 6 won't get the same fate as DNF did.
Nothing beats [this](http://highcharts.com/).
Zend Studio is imho the best &amp; I've tried a lot of the available options such as Aptana, Netbeans, Eclipse, Notepad, Dreamweaver, etc. Shame its not free, but I feel its worth the price if you will use it professionally.
Go ahead - that's already supported.
Lol, I wrote open flash chart :) thanks for the kind words.
It's nice, but it's not free(dom). Good luck getting your bug fixes into the main branch.
When about you get to December? date('n')+1 will give you 13, which won't be a valid month..
Only if you're new to the internet.
perhaps the examples were bad, but are the graphs open flash chart produces really that much "prettier" than the graphs jpGraph produces? apart from a little anti-aliasing, the effect is pretty similar.
personally, I like this more: http://raphaeljs.com/
Me too. At least it doesn't need any damn Flash.
Did you try it before commenting? If you put 13 for the month, it will return January of the next year.
I dig OFS man; I've used it for a crapton of projects. And, yes, it is MUCH better than jpGraph. Kudos to you man.
I suggest you take a look at Dwoo (http://www.dwoo.org). It is based on Smarty and aims to address issues in the latest. It is compatible with Smarty (95%), and is extendable in the same way (even more). It supports template inheritance, fix a lot issues. I'm not sure if it fixes the infamous memory leaks though, I didn't have the time to dig up in the code yet. It is a problem in most templating engines in PHP: Included files are released from memory only when the script ends, so creating a generator with Smarty is tricky, as it will include the same file a zillion times instead of storing it somewhere in memory. So this: while (true) $output = $smarty-&gt;fetch(); ... will eat up all your memory in no time, even if the $output variable is released after each iteration (theoratically it should just be fetching and releasing infinitely). Maybe the garbage collector in 5.3 can fix that... Anyway, Dwoo is definitely worth looking into if you are familiar with Smarty (or not).
I totally agree with you. 2010-01-31+1month should be 2010-02-28 (not 2010-03-03). 2010-01-31+3months should be 2010-04-30 (not 2010-05-01). Unfortunately, there is no way of doing that yet in PHP without conditional statements. You could create your own DateTime object to compute that automatically for you though (but it will still contain if statements). On top of that, using the DateTime object in this case seems overkill, considering it probably just wraps strtotime() function for that call and return the exact same result as strtotime() would, so you could use this function instead of instantiating an object.
Can someone explain the benefit of a template engine like smarty? To be more specific, what benefits does it provide over a simple php class that allows the MVC pattern?
Have they never seen [Roadsend](http://www.roadsend.com/home/index.php), he doesn't mention it in TFA.
This guy obviously isn't very experienced but some of his examples have more relevant applications, such as using braces to define the variable name can be used for characters which would not work because of syntax such as ${'@attribute'}. If you've worked with simplexml you'll know why this is useful.
I was briefly excited by the title... Until I read 8 things about PHP that I already knew :-(
I liked the variable composition tip, didn't know that and it seems it could replace just about every function i've ever used eval for.
This is true. For clarity, I set the composed variable name in another variable first: $setter = 'set' . $variable; $this-&gt;$setter($value);
&gt; You don’t need to store IP addresses as strings. &gt; They can be stored as integers using the ip2long(). \*\*_cough_\*\*ipv6\*\*_cough_\*\*
Instead of &lt;?php ?&gt; I can use { }. That's the main I use smarty. But I am really sad about performance of smarty.
&gt;I don't think there's any question that Stanford is the number one CS &gt;department in the world. I'm sure nobody at MIT, Berkeley, or Carnegie-Mellon would question that at all.
 $a = ‘value 1′; $b = ‘value 2′; list($a, $b) = array($b, $a); echo $a; // it will outputs value 2 echo $b; // it will outputs value 1 Have you ever seen better code for swapping two variables’ values !? Yes. Python: &gt; a, b = b, a
Surely it can't be as good as it says, otherwise everyone would use it :S
The manual comments have someone who [made their own](http://php.net/manual/en/function.ip2long.php). I'd say PHP will include something like this soonish.
Good to know.
See also [call\_user\_func](http://php.net/manual/en/function.call-user-func.php)
Isn't APC supposed to do it at runtime? I'm confused...
One might say (usually a HTML integrator) it is cleaner and easier to edit because instead of doing... &lt;?php foreach ($vars as $var =&gt; $value): ?&gt; &lt;li&gt;&lt;?php echo $var; ?&gt;: &lt;?php echo $value; ?&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; You'd do: {foreach from=$vars item=value key=var} &lt;li&gt;{$var}: {$value}&lt;/li&gt; {/foreach} The shorthand syntax &lt;?=$value; ?&gt; is usually a bad idea anyway, and will crash XML parsers (e.g.: when using XHTML per example), and is still uglier than Smarty syntax. EDIT: I meant it will crash the PHP parser (not the XML parser) when used with XML documents. Also, it provides some helpers and modifiers that can be useful for someone who has no programming experience, by automatically generating some business logic in your templates (section tags, etc.). It can be used within the MVC pattern as well. I am not pro-Smarty, but like everything, it has its advantages.
One of the most awesome things since PHP 5.2 that a lot of people don't know about is [Data Filtering](http://php.net/filter). Allows you to parse, extract and validate a lot of things (emails, URLs, phone numbers, etc.) without using regular expressions.
Don't forget Waterloo
I can see the rationale behind this. Crack is so cheap.
She's probably going to have a hard time staying anonymous if she signed the reporter in as her guest.
The standard per-request execution pipeline for PHP looks like this: Parse → Compile (bytecode) → Execute (interpret bytecode) Opcode caches like APC turn it into: cached(Parse → Compile (bytecode)) → Execute (interpret bytecode) What's being suggested here is to statically compile to code that runs directly on the CPU, so: cached(Parse → Compile (machine code)) → Execute (run machine code) For deployment you could even move the entire parse/compile stage to a build step, so it only happens once.
To be fair, IPv6 is basically vaporware. I'd be surprised if more than a tenth of a percent of end-user hosts are capable of sending real IPv6 packets through their ISP.
Your are right and contrary to IPv6 don' t exist I seen\ heard about a couple. 
Unfortunately this article carries with it the "smart quote" curse, so you can't copy-paste any of the examples that have quotes.
And mentioned that she did some questionable things like look at people's profiles she shouldn't have. I have always wondered if people at google did that... Ie looked into gmail to stalk exes or look at competitors analytics stats... 
upmodded for the pythonic goodness, but this is the PHP subreddit.
&gt;Things anyone who uses PHP should know about PHP FTFY
If the ability exists for employees to gain access to this kind of stuff. You can be almost certain that some of them have done so.
&gt;a security guard handed me a non-disclosure contract to fill out, a requirement to enter the building. “Just making sure you’re not a Twitter spy,” he said. really? Is social network really that big of deal? Isn't facebook just another fad?
That sounds like a very silly reason to use smarty. You can just change short tags to {}.
There are ISPs with many, many more end devices than can fit in a single RFC-1918 subnet. Many of these are using IPv6 internally today. Many Asian companies are deploying IPv6 internally as well as they have a proportionally smaller share of worldwide IPv4 address space. It may be years before you have to remember where all the ::s go on your desktop but IPv6 is already in production. 
The __autoload() tip, while very handy, would be better implemented like so: my_autoloader($class_name) { # Magic that include()s a class. } class autoloader { public function load($class_name) { # Magic! } } spl_autoload_register('my_autoloader'); spl_autoload_register(array('autoloader', 'load')); This will allow you to use your own autoloader for your own classes and any packages you download to use their own. Obviously, you can't define multiple `__autoload()` functions, but you can register multiple functions with `spl_autoload_*`.
EDIT: Thank you for the response... Hopefully I don't sound like I'm attacking. Just trying to understand. &lt;?php foreach($vars as $var =&gt; $value) ?&gt; &lt;li&gt;&lt;?="$var : $value"?&gt;&lt;/li&gt; Here's the flow of that kind of template in php: Turn on buffer. Execute code. Get buffer contents. simplexml_load_string(). Modify DOM if needed. The reason &lt;?= doesn't affect my xml parser is because it's executed before it gets to the parser (I don't understand a situation where you would need php in an xml parser). What simplxml_load_string gets is purely xhtml. Instead of concerning myself with the possible flexibilities of some template engine, I concern myself with the possible flexibilities of *php*. The things you mention do not seem like advantages. They seem like a different way of doing what's already possible in php. Only it's slower and adds complexity (in that there's now a separation between the language used in templates and the language used everywhere else). My templates look like: &lt;ol&gt; &lt;?php foreach($arr as $val =&gt; $valu) { ?&gt; &lt;li&gt;&lt;?="$val : $valu"?&gt;&lt;/li&gt; &lt;?php } ?&gt; &lt;/ol&gt; &lt;form method="post" action="&lt;?=$action?&gt;"&gt; ... I'm sure you get the picture. The difference in the code is that mine has php tags, executes faster, and has only the bugs php might have (to be fair, there can also be bugs in my "template engine", but it's a single class that i can easily edit). Is the code you posted that much more readable? PHP is like a third language to me, so I dont really see the tags as less readable. They pop out when I look at the code (that and they are red in my syntax highlighting...). PS. How is &lt;?= a bad idea?
 $array = array_filter(explode(',', "One,three,three,,four"));
Nice explanation! 
&gt; ...if more than a tenth of a percent of end-user hosts... That's greater than zero, so it probably needs repeating: *\*\*cough\*\*ipv6\*\*cough\*\** 
Or even just in PHP: $a = 1; $b = 2; $a ~= $b ~= $a ~= $b; echo $a; // will output 2 echo $b; // will output 1 Which is far easier to read and understand than the list/array method.
Or even just: $a = 'b'; $b = 'c'; $c = 'a'; echo $$$a; // will output 'a'
not invented here!
My bad, I meant the other way around. XHTML (or XML) documents must start with a XML declaration to be valid: &lt;?xml version="1.0" ?&gt; Now if you put that in a PHP file, and have the short tags enabled, you get a parse error: Parse error: syntax error, unexpected T_STRING in test.php on line 1 You can work around it, but personally, and by the majority of my fellow developers, it is usually discouraged. The point being that semantically it makes more sense to tell the parser what language you are using (i.e.: &lt;? is vague, it can be a lot of things). Also, it seems it is actually discouraged by the community itself, for portability reasons. In php.ini you can find: NOTE: Using short tags should be avoided when developing applications or libraries that are meant for redistribution, or deployment on PHP servers which are not under your control, because short tags may not be supported on the target server. For portable, redistributable code, be sure not to use short tags. EDIT: As for template engines in general, I totally agree with you, I don't like putting a templating engine over an already good templating engine, even if it is less complex and less ugly than what PHP can do. I don't use Smarty unless I'm forced to (at work), but there are advantages you can't deny. Still, I personally think Smarty has cleaner output, but there is the performance drawback which is not really worth it. It's a matter of personal choice I guess. 
I think the whole site could be optimized. Yes it is an assumption, since I haven't seen the code. But it is frequent for large-scale sites or software to keep some unoptimized, slow or useless code because they don't have the time to fix it, and eventually just forget about it. Also, I think MySQL as the database engine is also an issue. The obvious replacement in my opinion is PostgreSQL. Facebook could, without a doubt, benefit from partial indexing, expression indexing, RAM storage and database-side scripting.
Funny that I actually edited the .ini to enable short tags and never noticed that NOTE. I have to be honest, I've never put an xml doc type into a php document as text. I can see how that would simplify things (by not needing to use DOMImplementation), though. Makes sense that short tags should be disabled. The only thing I use short tags for is the quick echo (&lt;?=). (which looks like a smiley face with a party hat) Thanks for your point of view.
That's a parse error. You mean: $a ^= $b ^= $a ^= $b; But this will not work perfectly with strings (they will need to be the same size), and you can't mix datatypes. The list() method is safer.
I don't know if it's a good thing to encourage programmers to _not_ use RE. If you dumb everything down too far you'll encourage people to live in insulated worlds and encourage monotony, as opposed to just having them learn RE and have them think of what they can do with something that's that generally useful.
I certainly not discourage anybody from using RegEx. I encourage simple and readable code. If a regular expression is the simplest way of achieving something, then I say you should use that. But filter is indeed useful. A regular expression that matches even parts of the RFC of an email address is way longer than a simple filter_var call. If a programmer doesn't want to learn regular expressions, it's his/her loss, because it is part of the skillset of a good coder.
I know. The entire post was sarcasm. lol
The way I see it, PHPLinq is just a default implementation of the ActiveRecord pattern, over a simplistic read-only database abstraction layer. Most frameworks I worked with (e.g.: CodeIgniter) supports that in read-write. *AC* with either database or data-access abstraction is not very hard to make, and I usually use my own libraries for that, with extensive support of PostgreSQL features. As for reflection, considering the fact that the OOP implementation in .NET and PHP are different, I don't see any issues with it. It still allows you to extract **all** the information you may actually need from your classes/functions declarations.
I personally go for Apache Solr, based on Lucene, for searching. Even with the REST call overhead, I can obtain responses in milliseconds when querying an index of 5 millions documents. It also has integrated support for spell checking and document similarity, as well as a pretty good out-of-the-box scoring system. All of this can be tweaked with configuration files, and extended by developing additional handlers. It's open-source, has enterprise-level support and can be up and running in a few minutes.
pecl link http://pecl.php.net/package/xhprof
1. but remember you won't be able to search those strings 2. but that'll entail a performance hit and I've heard that it sometimes doesn't work (eg network timeout, odd email servers) 3. nice, but very rarely useful 4. but who cares anyway? it's not like a 15 char string takes up that much space. clarity &gt; micro-optimisation imo. 5. meh, solves a problem that really doesn't exist 6. I don’t how it can be useful either 7. yes __autoload is very useful 8. well, ok
&gt;I encourage simple and readable code Which, in this context, is judged by people who can't read regexp. Sort of becomes a self-fulfilling prophecy. &gt;A regular expression that matches even parts of the RFC of an email address is way longer than a simple filter_var call More characters but not much more. It also gives them something they can reuse, unless, of course regexp are those things that they don't have to use because someone's put some smaller part of the functionality they're after into a function for them, and they have convinced themselves that it's easier to remember a million and one different functions and arguments rather than just teach themselves surface level RE.
&gt; More characters but not much more. This just invalidates your whole argument. It is a documented fact that a regular expression to match email RFCs are very long and complex and may actually not even exist. It seems that you just don't know what you are talking about. To stay on the same ridiculous and pointless line of thoughts... then you shouldn't be doing PHP, you should be doing C, and even then, it's a little high-level, no? Regular expressions are too, you should learn Assembly. And why not just spend hours in your basement to program a microprocessor that sole purpose is to render your website? Looks like you're just in need of attention to me.
have you used it?
Very interesting article..
little immature, no? And yes, if I'm advocating regexp whereas you're advocating a "do it for me" method, then obviously I'm the n00b. At any rate, I think we need to continue this conversation after you get out of college.
I agree. Arguing just for arguing is very immature on your part. So is trying to guess my education from reddit comments. But hey, this is the Internets, I didn't expect much more from you.
my habit is to always return the string and output it as late as possible in the function call stack
Blogspam. [The official PHP changelog](http://php.net/changelog) has better, complete information.
and 5.3.1 has been out for a while
You should return as much as possible, unless your function is specifically designed for output. Examples: function getCurrentPage() { return basename($_SERVER['REQUEST_URI']); } if (getCurrentPage() == 'index.php') echo 'Welcome to the Homepage!'; function generateHtmlInput() { echo '&lt;input type="text"/&gt;'; } The reason why echo 2 + a() returns 3, is because you are using an arithmetic operator (+), so PHP will cast your return value to an integer. If you use the concatenation operator: echo (2).a(); // outputs 21 It all will make more sense when you get into OOP. EDIT: And by the way, this is not PHP specific, it's a general practice among programming languages.
&gt; You can't reuse a result from a function that echoes in a larger piece of code without making it echo too. The other way around works without problems. JFI: you can go through hoops and wrap it into using output buffering (ob_start() etc).
It's posts like this that make me want to leave the PHP world; I have no doubt some of my developers would ask a question like this... *sigh*
Who the hell is upvoting this? Have some members of /r/php/ been under a rock for several months?
That would be a kludge, and something you'd only want to get into doing if somebody was echoing results from within a function.
This is seriously elementary level. I can't believe he would even debate with a guy about it. We all have to start somewhere though I guess.
A function should have no knowledge of what you want to DO with the results it generates. Unless the function is something like PrintMyResults($inStr) ... it should just return. If it echos its results to the screen on every call, you limit its ability to be reused in other contexts. 
Neither of them 'fails'. They both do exactly what they were written to do.
You should nearly always return instead of echo. Additionally, for most applications, you should avoid echoing until the last minute. Collect the output of the functions and piece them together at the end. This will allow you to use the header() function throughout the request, without having to worry about that "Can't send header because output already started" message, and will make it easier to test each function's results independently. I think the only time echoing directly is reasonable is if you have a function that is designed to display the computed results.
If you manage developers that could ask that kind of questions, I might suggest you reconsider them as professionals. You can do pretty advanced stuff in PHP and there still is a lot of advanced PHP coders out there. Even BASIC had return statements...
&gt; EDIT: And by the way, this is not PHP specific BS? What other mainstream languages use a dedicated concatenation operator?
I know that, I work in the industry - I have done for a while now. I was merely asking as a method of gaining other people's opinions. 
I meant the return stuff is not PHP specific, not the operators.
Hey, which is right: apples plus bananas or apples plus oranges?
Exactly. To me this is not a question that has a simple answer. If someone asked me that question in the workplace, I would be asking them why they even framed such a question - what is it about functions and return values that is stumping them so much that they are asking such irrelevant questions while the elephant is shitting piles in the corner of the room.
At least he's seeking knowledge.
JFI: no, we won't be doing that. Seriously, no. Output buffering is not for performing arithmetic. Don't even suggest it, please.
Perhaps strangely enough, I do use MVC and I have done for a long time. This question was not asked for the benefit of myself, as you seem to believe - I made this topic for my friend to read, as he is starting off in the industry. For some reason, asking - admittedly a simple question - automatically makes me a lesser being, someone who has no idea what he is doing. It saddens me somewhat that someone else doing the same type of work as I do finds new people looking for help as somewhat as a threat. Is it a bad thing that I start a new learner off by giving them good advice which they will be able to use in future careers?
Now you are reading all sorts of things into the comments. Just admit it was a shit question and move on. You should have told your friend: the answer depends on what you are trying to do, but first, learn what a function actually is, and you will never need to ask this question. It's like asking of a bunch of garage mechanics: my car won't start; when it happens to you, do you replace the battery or change the engine for a new one? I'm not sure which is the accepted approach.
Now that's just ugly.
I just saw this post and thought I would chime in. My suggestions for becoming a better php programmer are more to do with making real world apps run better. Try some of these to improve your skill set: * perform a structured security audit * implement memcached into an existing app * implement load-balancing/failover for an existing app * try making an existing site fully i18n * how about a code audit ;-) * create a failover database infrastructure, with an admin interface to switch on/ off instances and enable/disable active master/slaves * audit some code! &gt;:( I have found that these are things which, when approaching an existing app, are challenging due to the inconsistency of programmers when scripting in php. The results will be apps with a chance of scalability in them, and you will get knowledge that will make you attractive as an employee in the future for obvious reasons. HTH
Is there any advantage to this over a static class?
I have a class called Database. A function called get_database_connection (or gd()) which takes 1 string parameter. This function look at a configuration array i have and creates the database connection based on that so gd('read')-&gt;query('select 1') gd() holds a static array and if the db associated with 'read' has been initialized, it returns it, if not then makes a config using the config for that key 
In that case, you can simply make mysqli\_database inherit from mysqli and redefine the constructor, __clone() and getInstance() methods: class mysqli_database extends mysqli { private static $instance; private function __construct() { parent::__construct(); } private function __clone() { ... } public static function getInstance() { ... self::$instance = new self; ... } } I don't see why one would want to create wrappers of all the mysqli methods and properties since you can just extend the class instead.
This is dumb. If you want to speed up PHP, you just learn seven things: * How to normalize or denormalize a database design based on the needs at hand. * How to implement compression and caching in your code. * How to use APC. * How to find system bottlenecks using Munin. * How to find code bottlenecks in PHP with various tools. * How to implement a web farm. * How to rewrite slower components in C as a PHP module and load them into PHP. And especially -- how to outsource this (as long as you get the C source and dare to try to understand it). Problem solved. I mean, I wouldn't go so far as to rewrite the entire thing in compiled PHP because then you lose your flexibility on time. I mean -- what if there's an emergency at the old Facebook plant and they need to hustle out a fix at blazing speeds? Are they going to want to link and compile HyperPHP, and then debug iteratively until they get it right, or just edit a simple PHP script and forget about it?
The shorthand syntax is implemented on 100% of all the web hosts I have worked with for my clients in the past 3 years. The shorthand syntax will not crash the PHP parser on XHTML documents, even if I prefix with the typical XML doctype at the top. Never has, never will. Let's say I create constants for my variables, and then use an include() call to load my XHTML page template. And inside I use the shorthand syntax to pull those constants into the source with things like &lt;?= MY_CONSTANT ?&gt;. This will never fry the PHP parser. I've done this on gazillions of projects.
I use [CCAPS](http://en.wikibooks.org/wiki/CCAPS).
&gt; I don't see why one would want to create wrappers of all the mysqli methods and properties since you can just extend the class instead. Might be that it has the potential to create an overly-tight coupling between the application and database layers.
Perhaps to create an adapter, so as to have a common database interface. Imagine being able to use Mysqli, Pdo, and others, but having the same methods and arguments. This is what the adapter pattern is for (to abstract away the implementation by creating a wrapper class for each implementation).
I agree but my point is that this article is to demonstrate an implementation of the singleton pattern, and it could lead some to believe that the singleton pattern and the adapter pattern are the same thing, which is not the case. If the adapter pattern was used, "mysqli\_database" would be a bad choice for the class name. So in my book, if this is an example of the singleton pattern, it is overly complicated. And if it is an example of the adapter pattern, it is badly implemented.
Try that: netcoder@quotient:~$ echo "&lt;?xml version=\"1.0\" ?&gt;&lt;?=\"hello world\" ?&gt;" &gt; test.php netcoder@quotient:~$ php test.php PHP Parse error: syntax error, unexpected T_STRING in /home/netcoder/test.php on line 1 Parse error: syntax error, unexpected T_STRING in /home/netcoder/test.php on line 1 And not all the web hosts support short\_open\_tags. I am my own web host, and I don't support it, so that can't be 100%.
Static class?
Well I mean a class with static methods: class DB { /** * Connect on construct * */ function __construct() { connect(); } /** * Connect to the db * */ static public function connect() { $dbhost = DBHOST; $dbuser = DBUSER; $dbpass = DBPASS; $dbname = DBNAME; $conn = mysql_connect($dbhost, $dbuser, $dbpass) or die ('Error connecting to mysql'); mysql_select_db($dbname) or die ('Error connecting to database:'.$dbname); } /** * Run SQL Query * * Returns true if successful * * @param SQL $sql * @return boolean */ static public function query($sql) { $res = mysql_query($sql) or die (mysql_errno() . ": " . mysql_error()); if($res) return true; else return false; } [...more methods like this...] } Accessed: DB::query($sql); Just an example. 
Singleton avoids problems like connecting twice. For example in yours you could do: DB::connect(); DB::connect(); /* Superfluous connections */ 
This seems like overkill for what it's worth. Could just have a subversion checkout of WP in a common directory and sym-link everything but the wp-config to each virtual host directory. Having a ruby framework to deploy a php framework seems a little silly.
Hmm. How about if $conn was declared as a static var? Wouldn't that prevent multiple connections?
Why would I be creating a web page like that? My doc looks like this: &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; ...and so on... ...with short open tags for constant var insertion. It loads just fine with short open tags. I suppose if I wanted to send SOAP data back and forth, yeah, I'd use full tags. As for your web host -- why would you be disabling short open tags? What purpose does that serve you? I have worked with countless web hosting companies for my clients over 3 years and not a single one has disabled short open tags.
I won't deny your points, but I was addressing the points at the bottom of your message, namely: &gt; I don't see why one would want to create wrappers of all the mysqli methods and properties since you can just extend the class instead.
"An XML declaration is not required in all XML documents; however XHTML document authors are strongly encouraged to use XML declarations in all their documents." - [XHTML™ 1.0 The Extensible HyperText Markup Language (Second Edition)](http://www.w3.org/TR/xhtml1/#strict) As for disabling short\_open\_tag, think about it the other way around. From what I can see, 5.2.10 has short\_open\_tag enabled by default in php.ini, while my current version, 5.3.1, has it disabled. So the thing is: I'm not disabling it, I am just not enabling it.
I use Smarty, and happen to like it. For me, it's not about the syntax, even though I prefer less typing all the time. But it's more about mental abstraction. .php files are just code, and .tpl (I actually use the .html ending) are presentations. Sort of part of MVC workflow. 
dude, thanks for pointing me at that, never saw it before, looks fascinating.
Posted this to the article, posting here for posterity: The fix for this is detailed here: http://rabaix.net/en/articles/2009/09/21/php5-3-and-mysqlnd-authentication-issue and here: http://dev.mysql.com/doc/refman/5.1/en/old-client.html The short version is to reset your password using the PASSWORD() function and make sure it's not the OLD_PASSWORD() function. Only possibly gotcha is if you've got clients connecting to the database from both old and new, in which case you might have to set up a new user.
I like this article. It is an easy to read intro
this was an extremely hand-wavy introduction to complexity theory, and that on its own is fine. i mean, its like watching mythbusters to try to learn how science works; a lot of sugar coating will eventually just rot your teeth. my only problem is the way the author sprinted over topics of combining complexities. like saying that using an associative array makes an algorithm operate in constant time. many implementations of associative arrays optimise insertion such that both lookup and insertion end up being logarithmic in size. perhaps explaining how a O(n) algorithm inside a loop variant on the size of the dataset becomes a O(n^2) algorithm, things like that.
Thanks for your comments. Since i'm pretty new in actually blogging about a bit more complex area's of software development/engineering, it's sometimes hard to try to focus on the big pictures. I'll try to incorporate some more examples or elaborate some things better. I'm not trying to make a step-by-step manual on how to optimize or modify your code, so I hope readers don't think that "moving everything to associative arrays will make code faster"... Just like mythbusters I try to let people take a look into the kitchen, but the actual discoveries you have to do on your own (and no, i won't do a shark or pirate-special)
i dont suppose that you would want to write a manual on optimisation any more than anyone else would want to read it. im just suggesting that if you are going to write a little report on algorithmic analysis, start with "why is this relevant to me". what youve written tells the layperson very little about why this topic is important. maybe just less details about bad examples of algorithms, and more details about why someone should care.
&gt; O(log N) Logaritmic time. The function time will increase rapidly in the beginning, but after a while they don’t have much impact. These are good when you know you always have a lot of items (like sorting users, articles, comments etc). I'm guessing you meant O(N log N), since sub-linearithmic comparison based sorting is infeasible.
not really sure what the relevance of PHP is in your article. It's more like a general article on Big O..
That's what updates are for. That bug is like 5 years old. 
It scares the bajeezus out of me that you'd ever be sorting 40,000 database records (let alone any) with PHP alone. I envision a `SELECT * FROM 'users';` statement and then some horrific function that allows you to sort based on column or some other such utterly terrifying thing. Interesting article, but I am really spooked now.
You really wouldn't do that of course. But I do see it on occasion. For example: fetched items to be parsed into xml data just to name something. Those items can grow pretty large in numbers and depending on the complexity of your functions it becomes pretty time/cpu sensitive to convert them. Tests with real life data and sizes should be done before deployment, but people tend to be happy with testing say 10 items which will always be fast enough no matter how complex functions are. With an introduction like this I try to let users thing about what would happen when your site actually reaches those numbers. Instead of rebuilding all the bottlenecks you encounter (after added the neccesary caching strategies), you can plan and build better code upfront. 
I was more thinking about binary searches which are O(log N). Maybe the sorting users etc is a bit wrong in this context. I'm actually refering to searching for users or articles instead of sorting..
Would be much better if Kohana was thrown into this. Although it's documentation isn't great, it works wonderfully as a framework.
ExpressionEngine is built on CodeIgniter, which prettymuch sways it for me.
As usual, [Agavi](http://www.agavi.org) eats them all for dinner.
Interesting + Thanks. I'm only newish to frameworks, however I've had the best luck with Kohana. It's challenging, however I'm still more productive with it and I'm enjoying it. Maybe once I've got a bit more experience with MVC and frameworks I'll give Agavi a shot.
Not very much content, really. Some vague mention about Codeigniter is "faster "and CakePHP has "more strict MVC", and that the communities are great.
It looks interesting but the documentation didn't offer me any compelling reason to switch from Kohana. 
It's a pure application framework, agnostic to input and output conditions of your application - runs just as well from command line and WAP/XMLRPC/serial line invocations as it does over the web. It doesn't have nonsense like captchas, ORM, templating engine, tag clouds and other bullshit which is only relevant to public web 2.0 projects. Not event based - that's just silly in the context of PHP execution model. *Company* and not community driven - the people who wrote it know their shit, patches aren't accepted from just anyone. Runs on [mtv.de](http://www.mtv.de) and [sevenload](http://www.sevenload.com). Designed for massive scale-up and API interaction. And, of course, correctly implements MVC. Kohana models are database wrappers. Agavi models are empty classes. Edit: I wrote most of Agavi documentation. I would be interested to hear in how it can be improved.
I'm with you on Kohana. It's fast, robust and not overly complicated once you get your head wrapped around MVC. I'm gonna check out Agavi too now.
Cake has "strict MVC"? Hilarious, considering Cake has its own custom database layer and its models are tightly coupled into it. What if you need to render a PDF, encrypt it and send it over email? In an MVC application, this is supposed to be done in a Model. In Cake, there isn't even a place where you would stick this that doesn't break all the benefits MVC gives you.
Sorry, but neither Cake nor Kohana implement MVC correctly.
How do they not implement MVC correctly? And why are you bashing Kohana for having things like an ORM, templating engine, etc? You don't have to use them if you don't want to. It's not like they're preloaded. Bashing free functionality is stupid. And Kohana's models can be whatever you want. They aren't even REMOTELY coupled to the framework itself. Models are just classes. They don't have to extend anything if you don't want them to. I really think you need to look at Kohana again. At it's core, it's basically just a collection of classes. The ONLY coupling is with the Router, Controller, and the Request object. You'd be using all of these anyways. Looking at Agavi, I would **NEVER** use it just because it's configured using XML. That's just brain damaged in PHP. Configuring routing using xml sucks, but I could live with it. Configuring *validators* using xml is just wrong. It's too verbose and it's just another file to create.
&gt; How do they not implement MVC correctly? &gt; And Kohana's models can be whatever you want. They aren't even REMOTELY coupled to the framework itself. Models are just classes. They don't have to extend anything if you don't want them to. http://api.kohanaphp.com/class_model___core.html &gt;Protected Attributes &gt; $db That's the definition of "tightly coupled." Now please let me explain what I mean by broken MVC. Rails arbitrarily and without any justification decided that the Model part of MVC has something to do with the database. 90% of "MVC" framework copy Rails architecture mindlessly. This leads to architectural disasters when your application grows. This is not, in the slightest, a case with Agavi. &gt; And why are you bashing Kohana for having things like an ORM, templating engine, etc? Because using these will save you time and make your project cheaper, but completely unmaintenable in the long term. What if I am porting a project which relies on Propel, and during port switch from MySQL to PostgreSQL? Agavi is an integration framework. It is designed to connect with foreign components via an adapter infrastructure and configuration glue (do you know any other PHP framework which allows you to apply XSLT/XPath/XPointer/XInclude to system configuration?) Besides, I am not bashing Kohana. Or Cake. They are toy frameworks which are basically clones of Rails. I simply find them unacceptable for the type of projects I do - the ones that *better be maintenable* three years from now on, and *have* to behave consistently in various environments. &gt; I really think you need to look at Kohana again. At it's core, it's basically just a collection of classes. The ONLY coupling is with the Router, Controller, and the Request object. You'd be using all of these anyways. I have looked at most of them. And I have flamed their authors at PHP London 08 because apparently none of them have any idea what MVC *means*. &gt; edit: And xml based configuration? That's a terrible idea. No, it isn't. In production mode, the configuration is scanned once and rendered into PHP code that performs class initialization. Since that point of time, XML configuration is never touched again. You get free benefits of XML: namespaces, schema comformance, validation, includes, translation, processor includes etc. Every developer can configure their own instance of the application in many environments and contexts, all without messing up other people's setups. You have the infrastructure to write custom config handlers and you can do some pretty wicked things with e.g. layout manager and caching - which you absolutely *will* need to do in extremely large projects like mtv.de (which as I said runs on Agavi). Edit: on configuring validators with XML: Most of your actions will have similar, if not identical, sets of arguments and validators. XML helps you because you create templates, and then reference these templates from per-action configuration. And, you can also set up validation manually in code if you want to - sometimes XML just doesn't cut it. 
This must be old as fuck because CI definitely has basic DB abstraction. Kohana should have been chosen anyway.
You have to realize that there really is no concept of a model in Kohana. That model class is there if you want to use it. It is not coupled at all to anything. Kohana does not expect a model object anywhere, and therefore you are not obligated to use the model object. I have never used it, because I don't use Kohana's database class. True, rails does put the idea in everyone's head that models = db, but as I said above, *you can use whatever you want for a model*. No one said it has to have anything to do with the database. You don't even have to use views if you don't want to. I don't understand what Agavi has to do with something like Propel. If you switch from Mysql to Postgres, the abstraction should be handled by Propel itself, not whatever framework you're using. In addition, what you said still doesn't sound like a valid argument against "captchas, templating frameworks, or tag clouds". On XML: What can be done here that *can't* be done with straight php? And seriously - look at the length and verbosity of this. Do you really think it's ok to use _60_ lines of XML to validate only 3 fields of a post object? Sure, you get XML based validation, but how hard is it for PHP itself to validate your validators or routes or whatever when it runs? It seems to me that Agavi was designed by someone who came from the Java realm of things. There *is* such a thing as over abstraction.
Well I didn't write the article, I should have put those statements in quotes.
&gt; Kohana does not expect a model object anywhere, and therefore you are not obligated to use the model object. So what do controllers and views interact with, then? Because in MVC applications, the *domain logic* is meant to be in the *models*. Only the UI glue may go to controllers and views. Here's an example why: you have two API frontends; one receives encrypted parameters and an authentication token, another receives plain text parameters only. Both fundamentally serve the same purpose, but the former has to amend the output with the security token and return the output in XML, and the other one in JSON. The former one may also respond with HTTP redirects, when the latter has to respond with 500 errors. All of the code that handles these special conditions goes to the controllers and the views, *but all the code that retrieves the actual data does not*. &gt; No one said it has to have anything to do with the database. You don't even have to use views if you don't want to. Fact remains that the core class of the framework that implements a model (which, by the way, is XML-configurable in Agavi and may or may not be a singleton) is tightly coupled into the database layer. It may seem a minor problem until your application grows ten times its present size and you pay ten times more for correcting every small problem like this (for example, what would happen to the code that initializes the models if I undeclared the $db property? Would it throw notices? Would it waste resources on isset() or reflection? The correct answer is it must not have been there in first place) &gt; I don't understand what Agavi has to do with something like Propel. If you switch from Mysql to Postgres, the abstraction should be handled by Propel itself, not whatever framework you're using. But I am not talking about the *abstraction*; I am talking about the fact that, if MVC is followed properly, Agavi-style, the only places in your application where you will need to perform changes will be the Models and configuration. If not, you will also have to edit controllers, views, plugins/helpers, etc. &gt; In addition, what you said still doesn't sound like a valid argument against "captchas, templating frameworks, or tag clouds". The argument is that these are specific tools which many people would find unneeded and therefore they have no place in the codebase of a *framework*. They should be grouped into an external library. A *framework* provides architectural infrastructure. ORM or captchas can not be a part of it. &gt; Do you really think it's ok to use 60 lines of XML to validate only 3 fields of a post object? In such a simple case, you can use validation templates. It will take you exactly 10 seconds to configure action validation after you get used to it; the real benefits shine when validators have complicated relations (e.g. IF this checkbox AND this checkbox AND this field larger than sixty BUT NOT IF it's night in Amsterdam OR the third subelement of the second element of this array is divisible by two). &gt; Sure, you get XML based validation, but how hard is it for PHP itself to validate your validators or routes or whatever when it runs? What you probably don't realize is that 10 lines of XML code can easily expand into 50+ lines of initialization code - boilerplate code that you *really* dont wanna write - and which is *guaranteed to be valid*. &gt; It seems to me that Agavi was designed by someone who came from the Java realm of things. There is such a thing as over abstraction. It is heavily inspired by the demands of architectural consistency that are present in large scale applications in Java world. What might seem an overabstraction to you on a public web site that has a blog and a forum is an absolutely vital necessity when you operate e.g. an affiliate program where small delays and technical mistakes cost you hundreds of thousands of dollars.b
I agree with most of what you said, but... how is ORM and templating engines only relevant to public web 2.0 projects?
Imagine that your application absolutely does *not* have blog posts and user accounts but instead operates on statistical time series, non-flat or unstructured data, LDAP, streams, feeds, enthropy etc as its primary data source? What if your data is deeply self-referential to the point you can't even normalize it so that it can be kept in an RDBMS efficiently? ORM can't solve any of these problems. Why should I pick up a framework which, instead of concentrating on its core components, concentrates on ones that are pretty unusable for my use case? (And, in most cases, also very poorly implemented; Cake's DAL is a joke, for example). Same for templating engines. What use do I have for template engines if my application is purely a web service with its backend controlled by a serial console and cron invocation? 
That's the exact problem. Most people who write about MVC do not understand MVC, and never even bothered to read the MVC whitepapers.
ORM is a solution to a problem, which you don't seem to have. So, it's not bad just because *you* don't have to use it. Templating engines can be used for a lot more than just outputting HTML. XML outputs (e.g.: webservice responses) can also be generated through templating engines, for example. Your answer makes no sense to me. It's not because *you* don't use it, or need it, that it is only useful to web 2.0 projects. Also, LDAP has unstructured data, really?
&gt; ORM is a solution to a problem, which you don't seem to have. So, it's not bad just because you don't have to use it. ORM is a solution to a specific class of problems, typically unfit for large scale, production, mission critical applications. Its benefit is shorter time to deployment in small projects at the expense of long term viability. &gt; Templating engines can be used for a lot more than just outputting HTML. XML outputs (e.g.: webservice responses) can also be generated through templating engines, for example. But not JSON, tabular data, time series formats like RRD etc. &gt; Your answer makes no sense to me. It's not because you don't use it, or need it, that it is only useful to web 2.0 projects. Well, apparently what I do is one grade above what most PHP developers do, and so my requirements are also one grade above the common. &gt; Also, LDAP has unstructured data, really? No, but that's not the poiint (and yes, you can query LDAP to return structured information as unstructured output) 
For MySQL admin I love SQLyog: http://code.google.com/p/sqlyog/ sqlyog + ssh tunneling = local admin of remote databases
From what I understand, you need two tables in your schema. One that contains all the different blocks infos (A to G) without a start/end time, and one that contains the schedule itself, something like: day | block | startTime | endTime ------------------------------------------------ Monday | A | 08:00 | 10:00 Monday | B | 10:00 | 12:00 Then you can execute simple queries like: SELECT block FROM schedule WHERE day = 'Monday' AND startTime &lt; CURRENT_TIME AND endTime &gt; CURRENT_TIME 
Sorry, but Agavi looks like bloated shit. Well, that's a kind of answer bastards like you get when you pretend to know things better than others. And I don't see Agavi MVC any more correct or incorrect than any of the frameworks you compare it to. Agavi models are just as shit as all ORMs are.
There isn't single truth what MVC is. In fact most of the web frameworks implement MVC with "Model 2" approach. It's not the only way (or even "the best" way, :-)) to implement it.
I already posted this comment in the blog, but Mike Seth is stealing the show here with his incompetence, so I cross post the comment here too: All the MVC frameworks are basically the same. Some of the frameworks tend to “own” the codebase by forcing user to use framework’s base classes, its style, or its database layer, or its (command line) tools, like CakePHP is. Some of the frameworks are more like a class libraries that you can use if you like, Zend Framework is a little bit like that (Zend Framework has also base classes, but you can use most of ZF components by their own (in any framework or code) without extending its classes). Some frameworks leave the hard decisions to user (for example how the data should be persisted or how the user should be authenticated and authorized, or how the urls should be routed, or data validated), CodeIgniter is in many ways in this camp. And then there are frameworks that want everything to be pluggable, configurable, etc. These frameworks generally end up using some IoC/DI container to manage the life cycle of the objects and their dependencies. Usually they end up being everything for everyone, and that's why nothing for nobody. This is a class of frameworks I see works the least in PHP's somewhat stateless environment. Some frameworks enforce naming conventions, directory layout etc. Some don’t. Some frameworks tend to solve every problem their users are hitting, but many are just providing clean and simple base for users to extend (you can extend the framework, or you can just plug your code without thinking about the framework at all, depending on framework). With some frameworks you really feel their presence, with some you don’t. Object relation mapping for example really is a Vietnam of computer science (http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx). It doesn’t matter how clever you think you are when you are writing/using ORM, the impedance mismatch stays. ORM problem cannot be solved, period. So, why to fight against it? That’s why ORMs will always end up failing (or at least getting too much bloat, that it isn’t funny anymore). Of course there are use cases for ORM, and it can give you productivity gains in some cases. The same story with ORM applies (in some extend) to authentication and authorization scenarios too, and the other harder problems that are more of a problems of actual deliverable. That’s why they should be solved case by case. The more the frameworks develop, the more they tend to make decisions. Sometimes these decisions fit well, but sometimes they don’t, and that’s when you start hating the framework. Usually sooner than later. And that’s why its less common to hate CodeIgniter than it is to hate for example Cake (CodeIgniter makes less decisions on behalf of the user). PHP itself is a framework for web development. PHP is like a glue, and it works really well as a glue. Less PHP code, more the glue, the better. By glue I mean using PHP extensions. If the problem can be nicely solved outside PHP, in these extensions, the better you are at using PHP. But PHP doesn’t (currently) have extensions for ORM problem, or MVC problem. That’s why people are trying to solve these problems in PHP, and that leads to all kind of problems. Huge bloated class libraries are one symptom of that. And what is this ‘all PHP code should be object oriented’ movement? I really hate when people are solving all the problems with objects, when there is more obvious ways to solve them with pure procedural approach (with functions and anonymous functions if needed) that PHP supports even better (compared to object oriented approach). If you understand PHP and it’s execution model, you find out that PHP is not a good language to write class libraries. For every request, you need to reload all the classes you need. I know, you can use byte code caches like APC and load files with __autoload. These help, but doesn’t cure the problem. Extensions do cure, but with them you have problems in hosting environments. PHP is shared nothing approach. For every request you are allocating memory and other resources. Requests don’t share anything. Good example of that, is that you cannot really write a singleton with PHP like you can with Java or .NET (singletons in PHP are singletons only at request scope). Real singletons in PHP are provided with extensions, like with mysql_pconnect that can be used to open a connection to database, and which can be shared with other requests made to the server (this is actually a pool of resources, but you got the idea). These are the reasons, why I really suggest people to take a more straightforward approach to PHP coding. Sometimes spaghetti code is just the right way to get something done, and done fast. For larger codebases spaghetti code leads to many problems, and that’s why you should use at least some minimal MVC framework, just to get a nice and clean structure for your project, but don’t feel forced to solve every problem with that. A little bit of spaghetti here and there doesn’t really hurt anyone, if you know that it’s just a right thing to do in the case you are solving (eg. huge loads on single function that your site is providing). Now, all the academic purist will hate what I just said, but that said, I think they hate the PHP even more. Be pragmatic and think by yourself… the guys who write frameworks aren’t any blessed authorities that know the right answers (good coders, I admit, but not Gods), challenge them and don’t just blindly follow them.
Jesus, you again... &gt; "Cake has its own custom database layer and its models are tightly coupled into it" // This model does not use a database table class Example extends AppModel { var $useTable = false; } &gt; render a PDF View &gt; encrypt it Model. There are even behaviors out there that do this automatically for you. &gt; send it over email Controller. Cause maybe I send it over email, or write it to disk, or shove it up your ass. 
Would't the View be in charge of rendering the PDF just like it does with HTML? The issue of how it sends it to the user seems secondary
I get what you say but I build sites in CakePHP every day and do come across a few situations where I think "this should really be in a model" but Cake doesn't allow me to (easily). Equally, for my purposes the RAD aspects usually outweigh these issues. And as long as you keep within the parameters that Cake defines it won't affect long-term maintainability. 
I've been using it since the early 1.1 days. Out of curiosity, can you recall what it was you were doing that you couldn't easily put in a model that you thought should?
&gt; How is this an improvement over using the DateTime::modify() method? It improves on it in one specific way: it’s object-oriented. Rather than passing a string you have the ability to pass an object. I'm honestly not sure whether or not he's intentionally trying to mock the mindless use of OOP.
You must go to Christ School in Asheville, NC. http://www.christschool.org 
If you wanted to make it student specific you could create another table (or 5) that holds the student ID number along with a numeric reference to each class (for each day). Then you would be able to print out a schedule for any number of days with the classes, start/end times, and other class data (Room number, teacher...).
I don't think he is, though I'd do it this way without instantiating any objects, echo date('n/j/Y', time() + (86400 * 7 * 3)); However, the DateTime::diff() method does look handy. In the past, when wanting to print output such as the amount of time remaining in an auction ("3 days 9 hours 27 minutes and 8 seconds"), I've always rolled my own. DateTime gives you that for free, apparently.
netcoder's answer is correct. However, it's worth noting the existence of the [switch statement](http://us3.php.net/manual/en/control-structures.switch.php), which is capable of cleaning up sections with lots of ifs and elses.
It's usually sending a notification or confirmation email. To me, a "thank you for your order" email belongs in the Order model. But if I want to use the Email component it'll have to be in the controller.
*any* flavor of regex in php is computationally expensive. i tend to use a few php precompiled functions instead of regex when possible... profiling and load testing tells me that this is good idea, but its all just crazy voo-doo to me *shrug*.
of all the thing regex can be defined as, readability just ain't one of them. sorry mate.
no no , you're totally wrong, there is also a regex html parser.... really.
i can't really help you with the details, but my hosting provider allows 2 methods of changing php versions on my *nix account: the one is via web admin panel (affects vhosts, works instantly), the other via .htaccess (affects directory trees). so there may be a more convenient way to do this for you: by creating multiple vhosts, each with his own alias/php version, but all with the same webroot. note: my hoster uses php-cgi, i doubt this works with mod_php. i'd try to define the f/cgi options per-vhost, maybe that works.
Come on. Don't you see it? It's object oriented, man!
really, i'm not sure if it is really necessary. the minified version of jquery isn't that big and it should be in the browser cache after the first hit. if you use the version hosted by jquery/google, it may very well be in your cache already. i know there's parsing overhead ... but is it that bad?
Gentoo has some documentation about PHP4 and 5: http://www.gentoo.org/proj/en/php/php4-php5-configuration.xml#doc_chap4
Any idea if you an do that with multiple PHP 5 versions instead? It just upgrades when I attempt it.
No. The view would either configure and invoke a rendering mechanism for the PDF: $renderer = $framework-&gt;getRenderer('pdf', $arguments); return $renderer-&gt;execute() Or it would use an MVC Model because that's how you integrate third party libraries: $m = $fw-&gt;getModel('PdfOutput'); $m-&gt;setArguments($args); return $m-&gt;render(); What is absolutely unacceptable is that the view itself would start talking to the PDF library directly: $pdf = new PDF_Renderer($args); $body = $pdf-&gt;render(); $this-&gt;setResponse($body) Same is true with HTML. Your views are *not* templates. They must not be tightly coupled with templates, and they must not contain any HTML. 
&gt; var $useTable = false; So it is tightly coupled. &gt; View No. View invoking a model or a framework facility. No PDF generation code is acceptable inside the view itself. &gt; Model. There are even behaviors out there that do this automatically for you. I would argue that a framework has no business to provide such facilities and those should be left out for 3rd party integration library, for the same reason PHP should never have had the mail() function. &gt; Controller. Cause maybe I send it over email, or write it to disk, or shove it up your ass. No. Controller must invoke a model or a framework facility that does that. It may not do so itself. 
&gt; Sorry, but Agavi looks like bloated shit. Well, that's a kind of answer bastards like you get when you pretend to know things better than others. Uhm let's see. &gt; Agavi models are just as shit as all ORMs are. Agavi models are empty classes. Oops.
&gt; Agavi models are empty classes. Oops. Why are they then called Agavi models? Oops.
Because, genius, MVC defines models as application-specific wrappers for domain logic - NOT AS FUCKING DATABASE ORM. That's just something stupid most frameworks copied from rails - and rails did it this way because they wanted any inexperienced moron to be able to produce working applications cheap and fast. Go to wikipedia and read, for dog's sake.
I was actually going somewhere with that line of discussion before netcoder had his meltdown.
I'm not sure, but running PHP as a CGI binary rather than Apache module could be a solution. http://php.net/manual/en/security.cgi-bin.php
That's your puristic definition. There isn't a single truth! From Agavi documentation: "Both models extend the BlogPostsBaseModel class that was created when we created the module." It seems, Agavi's models aren't empty classes, like you said. They seem to extend base classes. Here is an empty class: class Model {} And then, look at here: http://trac.agavi.org/browser/trunk/samples/app/lib/model/AgaviSampleAppBaseModel.class.php and, when you understand that, go to here: http://trac.agavi.org/browser/trunk/src/model/AgaviModel.class.php You are so full of bullshit! That's nowhere near EMPTY model. And most importantly, you are tightly coupling to Agavi!
&gt; That's your definition. There isn't a single truth! No, that's the definition of MVC, as it applies to request-response model of HTTP. &gt; From Agavi documentation: "Both models extend the BlogPostsBaseModel class that was created when we created the module." You didn't think this through very well and so your argument fails miserably. When Agavi build manager creates an application, it creates two distinct sets of base classes for views, models and actions - a global one and a number of per-module ones. This is so that you can put shared code into base models without having to go over every model and correct parent relationships by hand. In toy frameworks, models are direct descendants of the base ORM class. In Agavi, models are descendants of module-specific base class, which is in turn a descendant of the global model base class, which in turn is a descendant of a framework base class. In the framework base class, an interface is declared to enable initialization of models from application configuration. This might not have occured to you yet, but I am the author of most of the Agavi documentation and it's sample Bloggie application. &gt; You are so full of bullshit! That's nowhere near EMPTY model. You of course have no idea what you're talking about. A newly spawned model, which, again, has at least three parent classes (two if it's a global model), is an empty class. It's called architecture. You should try it. 
&gt; A newly spawned model, which, again, has at least three parent classes (two if it's a global model), is an empty class. If class extends anything other than stdClass in PHP, it's no an empty class, period.
Sigh. I don't think it occurs to you that loosely coupled supporting code does not mean tightly coupled application code. Just screw it. Go play in your sandbox and I'll go play in mine.
Yep, we got it, your view of things is totally puristic. But purism leads to other problems like: 1. exhaustive configuration 2. frameworks for object life cycle and dependency management 3. abstractions beyond the understanding (deep inheritance chain for example) 4. framework driven development (framework makes decisions on behalf of user of how the things should be build or where the files should be placed) 5. tightly coupling to a framework, and its support (how easy is it to throw Agavi in a toilet in a project?) 6. rigid development process and reliance on framework's tools. 7. unknown future of the framework (and lousy support). But you are right, there are some positive sides too.
You've pretty much got the best solution right there. Going beyond that and trying to consolidate in to your main OS is a lesson in aggravation. And you can get Linux installs down pretty small if you go without a graphical environment so by having mulitple VMs you really don't lose much space. 
&gt; loosely coupled supporting code I don't see Agavi as loosely coupled supporting code. I see it as tightly coupled inheritance based framework. You even say that: *" However, you'll loose a couple of benefits that the framework has to offer, so consider carefully whether you'll ever have the need to use your models in a context without using Agavi. Unless you have a very specific reason we recommend that your models extend the applications BaseModel which has been created by the project wizard"* And this is very important. Without inheriting (and thus tightly coupling your code to Agavi), you end up loosing the benefits (part by part) of the whole framework.
Okay, gotcha. So what we should have instead is a Factory generator generator that creates generic interfaces to widgets that create xml wrapped messages that flip the wizbangs and maybe eventually get what you want done. Tomorrow. After you write your 3rd party facilities that shouldn't be in the frame work to begin with because consistency and utility pale in the harsh light of your view of what MVC should be. Are you sure you aren't a Java troll?
So we can have a meaningful discussion? Yay! &gt; exhaustive configuration In PHP, the extensive configuration of a large application is a solution, not a problem. PHP execution does not persist. You have to either load configuration data on every invocation, cache them with external service (like memcached) or write an abstraction that compiles PHP code which then can be cached with native PHP tools (eg APC). So, for a statically compiled Java application extensive configuration makes no sense; for a dynamic, single invocation language like PHP it is the only solution. &gt; frameworks for object life cycle and dependency management Outside of scope of persistence, managing object lifecycle in PHP is pointless, and if dependence management is needed, it *best* not be controlled by wagons of manually written boilerplate code. For framework-level services, Agavi provides a factory mechanism complete with configuration and DI. You do not normally touch any of these until you want to extend the framework (e.g. if you want to replace the stock security model with something unique - which you can do without editing Agavi source code). For application-level components, no such functionality is provided beyond access to application configuration. &gt; abstractions beyond the understanding (deep inheritance for example) What I described with the case of models is *not* deep inheritance. As you develop, you discover patterns in your model code. For instance, a *part* of your models may turn out behaving exactly like an ORM class; Agavi provides venue for you to move the shared functionality up the inheritance chain without having to remap dependencies between classes. You *can* use bare classes as models, it's just inconvenient to do so. &gt; framework driven development (framework makes decisions on behalf of user of how the things should be build) This is not really the case with Agavi. If anything, the restrictions it imposes on you are architectural so that your application is consistent across large volumes of code. &gt; tightly coupling to a framework, and its support (how easy is it to throw Agavi in a toilet in a project?) Very easy. Move all the model code aside and delete the project. A side effect of proper MVC implementations is that the entire application sans the UI is contained *entirely* in models. If you followed good practices recommended by Agavi core developers (and these are folks way, way smarter and more experienced than I), you should be able to either write a simple wrapper that simulates access to Agavi core services on which your model depends, or refactor your model code statically. &gt; rigid development process and reliance on framework's tools. Absolutely not my experience with Agavi. Sometimes I lay out the UI first, then write the supporting JS code, then a mock model, then actions, views, model implementation. Sometimes I begin with tests, then model implementation, then actions and views. There's no rigidity. As of framework tools, Agavi provides way, way less tools than other frameworks. Whenever an application-specific service is exposed, it's done through adapters. Example: in Agavi, you can freely mix Smarty, eztemplate, raw PHP and *any other* templating engines and templates in *any* combination, because framework has a set of template engine adapters and a layout manager that is abstract enough to be able to compose the output of anything (even if the templates are not physical files). What it does *not* have is any templating *engines* or a strong preference to a specific one. A stock Agavi application ships preconfigured with raw PHP renderer by default because it does not require any external dependencies. What I do is take the stock project, remove the raw PHP renderer and replace it with Dwoo. The build system allows management of projects in this fashion, so the next project I create will come preconfigured with Dwoo. Agavi uses PHP not only as base language, but also as a DSL and an intermediary initialization language. 
&gt; So what we should have instead is a Factory generator generator that creates generic interfaces to widgets that create xml wrapped messages that flip the wizbangs and maybe eventually get what you want done. Tomorrow. Umm, no. Not at all. For a project with very rich UI, you may want (have) to define some sort of higher level abstraction (HMVC style etc). For a project with multi-tiered architecture, like [sevenload's backend](http://developer.sevenload.com/api/1.0/docs), you may want some additional formalization. But, you don't *have* to. You do not write tons and tons of XML and very little code to get the application to do something. In Agavi, code generation is involved only when translating the configuration XML into boilerplate initialization code. It does *not* magically create e.g. CRUD scaffolds for you out of configuration. 
I was referring to the specific bits of the model code in the [base class](http://trac.agavi.org/browser/branches/1.0/src/model/AgaviModel.class.php). Agavi defines a model interface and provides a stock implementation from which you inherit. This stock implementation carries only the methods to inject, save and restore the application's context object, which you will need in *every* model that wishes to accept the framework services. *These* are the things that you inherit. The access to framework services is abstracted. For example: $adapter = $this-&gt;getContext()-&gt;getDatabaseManager()-&gt;getDatabase('stats'); $pdo = $adapter-&gt;getConnection()-&gt;getResource(); getContext() is implemented in the base class and returns an instance of framework context - that's the only code you have to *inherit*. From there you query the database manager, which reads the database configuration, initializes the adapter[s] appropriately; and getDatabase() call retrieves an instance of such an adapter. All of this decoupled and configurable. 
Yes, you could use (Fast)CGI and use another binary/wrapper depending on the hostname for example (e.g. test52.local would use PHP 5.2 then). Another option might be to make everything covered by tests and then run different binaries via command line on the test suite.
I just realized something: You're the [crazy guy](http://pookey.co.uk/wordpress/archives/44-phplondon08-the-crazy-guy-mail), aren't you? If so, I just lost all respect. No one cares that MVC is not MVC as it was originally defined. When everyone in the web community knows MVC as it is today, then that is its new definition. Shit like that happens all the time. For example, look at the word AJAX..many people use it as a catch-all phrase for when javascript is used to change a page in real time, even if it's not doing a remote call. To me, Agavi is a solution in search of a problem. No one here "gets" what you're saying, just like no one "got" what you were saying at the conference.
&gt; I just realized something: You're the crazy guy, aren't you? If so, I just lost all respect. I am. Too bad. &gt; No one cares that MVC is not MVC as it was originally defined. That's incompetence. &gt; When everyone in the web community knows MVC as it is today, then that is its new definition. Shit like that happens all the time. For example, look at the word AJAX..many people use it as a catch-all phrase for when javascript is used to change a page in real time, even if it's not doing a remote call. People are retards and write shit code. What else is new? &gt; To me, Agavi is a solution in search of a problem. No one here "gets" what you're saying, just like no one "got" what you were saying at the conference. Some people did. They remained smart after the conference was over. 
Use WAMP/XAMP/MAMP. MAMP, at least, comes with versions of PHP 5 and PHP 4 installed. A simple Apache configuration change, followed by a server restart, will switch between them.
&gt; People are retards and write shit code. What else is new? The same retards write software that actually works. Those same retards understand very well, that OOP is mostly syntactic sugar that only tries to bound data with functionality. These people understand also very well what is wrong with this. Whether or not Agavi implements OOP and MVC concepts correctly, it still leaves me wondering, if the whole OOP is wrong way to do it after all.
I don't remember having to work with PHP in an environment where I didn't control the php version, so staging/testing and production have always been the same. That said, as long as your tests are runnable from the command line, it should be relatively easy to run them through different versions. Trouble ensues if you need a web server for it, since `mod_php` can only be installed once. What kind of application are you building? What kind of tests do you have?
In all honesty, I am mostly too lazy, and I get away with it because I work on in-house software and I get to dictate the conditions of its deployment. Now that I think about it, the prospect that scares me more than variations between PHP 5 releases (should any of our PHP code ever see release into the wild) is dealing with multiple PHP _configurations_.
I thought you were going to go play in your sandbox?
I have PHP4 as a CGI and PHP5 as a module, and have them activated on a per-virtualhost basis.
I'd love to find out how you did this, as I run on Windows 7 at the moment, with my main Apache/PHP installation for development (the rest are mainly for testing).
Agreed, though I have a normalising function which handles much of it (thankfully).
extract($this-&gt;vars); include $this-&gt;file;
For that specific example, yes, you're right, extract() does the job. This was provided as a quick example, I usually will manipulate $__var before assigning the variable. Good point though.
What's the rush, really? Tons of stuff out there still hasn't fully embraced php 5 yet. (Code Ignitor, CakePHP ... I'm looking at you) PHP 5 addressed a LOT of complaints that people had PHP 4, and their point releases of PHP5 have been doing a good job of keeping abreast of emerging web technologies. Yes, we should move toward PHP6, but let's first get people away from php4 ([it has been end-of-lifed for almost 2 years for crissake!](http://www.php.net/archive/2008.php#id2008-08-07-1)) Once everyone's on 5, and PHP4 is just a memory (as was php3 when php5 started hitting the scene), then we should be saying "where's PHP6?". Slow evolution in a programming language is a good thing. Changes should be introduced slowly and after careful consideration. I, for one, am happy with the pace of development in PHP5, and, while I like new toys, am content to wait for PHP6 for as long as it takes.
utf-8
Point taken on that score, but what about [mbstring](http://us3.php.net/manual/en/book.mbstring.php)?
Good god, do not do this.
I recommend using PHP built in iterator interface to instead: http://php.net/manual/en/class.iterator.php You can then easily loop through your objects with PHP foreach loop
I don't get it... Why the fuck don't you use a simple foreach and output the shit you want? All I see there is a candidate for some obfuscated-code-contest.
Because it's Ruby!!LOLOMGWTFBBQ!111
Of course with regular arrays (like in the code) you can simply use foreach ($array as $index =&gt; $value) { // etc }
From the article's comments: &gt; The purpose of making this stuff is not with the intentions of people using it, it is just to help with expanding your thoughts. And the author to reply: &gt; [...] you got it exactly right, thanks! We do some stuff just because we can, and it looks fun to. My thoughts on this: [Just because you can, doesn't mean you should](http://fakeposters.com.s3.amazonaws.com/results/2009/07/27/ocfz7gfzvm.jpg) (especially if it is going to give people some such bad ideas).
Out of curiosity how many /r/php'ers have upgraded to 5.3? Do you write all new code to be backwards compatible with 5.X? Or do you use 5.3+ features such as namespaces and LSB? All of my boxes run 5.3.1 and all of my code is namespaced. 
I adopted 5.3.0 as soon as it came out, for development use only, and it wasn't so bad. Since my code was already backwards compatible with it (e.g.: not using array functions on objects), I didn't have much problems, except for known bugs (like the ini parser bugs). However, now that I upgraded to 5.3.1, I can stay it is pretty stable, and I wouldn't hesitate to use it in production. I encourage everyone to upgrade as well, because it has huge improvements in terms of both performance and functionnality.
Installing services via httpd isn't very hard. httpd.exe -k install -n "Apache2.2 PHP4" -f "C:\Path\To\NewConfig.conf" This command has allowed me to run two instances of Apache2.2 from the same folder; They just use different configs. Apache doesn't have to be "installed," meaning if you get it in zip form it'll be fine! And the above command for sure works with Apache 2.0 and 2.2. I have yet to get PHP4 work with Apache2.2, hence why im using 2.0 for it. IIS 7.5 is pretty easy to setup on Win7, do it from Programs &amp; Features (start &gt; run &gt; appwiz.cpl -&gt; add/remove windows components and add in IIS) and using the IIS Web Launcher thing-a-ma-jig ( http://php.iis.net/ ) will auto install and configure PHP for use with IIS (it's actually pretty nifty) Getting to change ports isn't too hard, go to the default site and change the default port from 80 to another one. Also, I centralized all the htdocs locations into one place (more on this later). All these daemons should listen on their own ports (obviously) and not so obvious, they should be bound to different ip addresses (hence 127.0.0.x being available). I named my computer "Beryl" as a shortened name of Beryllium; however you can name your hosts however you please, for my example we'll call it foobar.local (.local so you don't override outside dns by accident). So for your HOSTS ( %windir%\system32\drivers\etc\hosts ) file: 127.0.0.1 foobar.local 127.0.0.1 www.foobar.local 127.0.0.2 php5.foobar.local 127.0.0.3 php4.foobar.local 127.0.0.4 redmine.foobar.local 127.0.0.5 iis.foobar.local As for my Directory Structure: H:\\Server (root dir) H:\\Server\\Database\\MySQL\\Version 5.1\\ (daemon location) H:\\Server\\Database\\MySQL Datafiles\\Version 5.1\\ (innodb datafiles) H:\\Server\\HTTPd\\Apache\Version 2.x\ H:\\Server\\Lang\\PHP-&lt;version&gt;\ I like my web services having their own dirs for sessions &amp; temp (file uploads etc.) H:\\Server\\Stor\\Sessions\ H:\\Server\\Stor\\TEMP\ H:\\Server\\Webroot\\www\ H:\\Server\\Webroot\\php4\ H:\\Server\\Webroot\\php5\ H:\\Server\\Webroot\\iis\ H:\\Server\\Webroot\\redmine\ I downloaded Bitnami for the hope of it providing a better installation of Ruby &amp; Redmine, and it turned out to do indeed have a better one, however it also installs its own apache, mysql, and other nonsense which i had to uninstall from my services for. Safe to say that Redmine all around is a pain in the ass to install. Anyway, [here](http://privatepaste.com/dfb260e4ce) is my vhosts config file, which should help you out.
I wrote an internal framework with 5.3 in mind that is running in production. I take advantage of LSB as well as anonymous functions quite a lot, I'm a big fan of the ternary operator in 5.3 whereby you only have to specify the false outcome i.e. $somethingfalse?:$somethingelse;. Using 5.3.1 in production.
I have not, simply because I'm primarily using drupal and many contributed modules aren't 5.3 ready.
The problem I found was not with running multiple copies of Apache, but rather with PHP. It seemed to alter some registry entry somewhere.
It really depends. For instance, as far as I can tell once a company goes public it has to go through audits etc. and demonstrate that for instance live database access is not available to the same people that write the code. I worked at gateway and worked on the B2B website and had no access to the live web or db servers. We had a separate team called "Change Management" which pushed a code release, ran scripts on the DB, etc. At my current company it would be relatively easy for me to snoop on certain things but I really have no desire to. Some companies have very severe penalties (termination, criminal investigations, etc.) for doing what you say and others don't. 
All my public software is written for 5.2+
The default packages on both gentoo and ubuntu (and debian, I think?) are still 5.2. It is fucking ridiculous and annoying and I wish they'd sort it out.
We run 5.3.0 since September (with php-fpm, apc and nginx) and it's great.
Your code was backwards compatible with an unreleased product? Neat. Can I borrow your time machine?
I believe the gentoo repos have worse problems than upgrading php. 
Err, I meant forward compatible. ^_^
I upgraded to 5.3 a few months ago with no problems. I compiled from source.
PHP shouldn't be able to even touch the registry. Don't use the installer
An article of pure speculation along with a poorly written submission title. 
The author even rescinds the very point of the article in an update: &gt; UPDATE: After sifting through the comments here and elsewhere, I'm inclined to agree with the folks who are saying that Facebook will be introducing some sort of compiler for PHP. This sounds highly plausible, and fits into what I've heard. Obviously, I don't have absolute specifics. Thanks for the extra info, readers. 
Oh, hurp durp. Forgot I installed it. Thanks :)
Note that bcompiler just compiles php sources to php opcodes. That's the same thing that an opcode-cache (Such as apc) does, and it doesn't improve the run time performance of php.
bcompiler and APC both improve the run-time performance of PHP. In both cases, compilation from symbolic source to bytecode is performed in advance of program execution, which by itself leads to a 30% improvement in run-time performance, and also allows for thorough optimization in advance of program execution. I imagine you are trying to point out how an additional just-in-time compilation step must be performed to execute the bytecode, while a full-on source-to-binary-executable compiler would avoid this step completely.
I just wanted to make clear that bcompiler is probably something different from what Facebook are doing. bcompiler is simply an optimisation of the normal php execution pipeline, where a php-to-binary compiler (Which it appears that Facebook are doing) would be fundamentally different.
s/too/to/
That's just *to* good *too* be true.
&gt; Now, I don't personally consider PHP slow: it is simply not a language designed for the sorts of workloads that Java and .NET are. I see we have an expert in our midst. /sarcasm
There was a similar "interview" posted a couple weeks ago that called it "HyperPHP." Most of the commentors seemed to think it was bogus as well.
I had a similar question. Did you ever come up with a solution?
Ah, I see what you're getting at. I'll just delete that remark implying that bcompiler is related to this project.
Just rolled my own but there are some out there if I recall correctly.
I've spent a good portion of the day looking for something that had a good administrative feature but that didn't have to come with it's own CMS as I've got one already. I've found none. I've finally settled on OpenCart for the time being because the backend is easy enough for the people I'm designing the site for and the templating system is flexible enough to do most of what I want but this would have been easier if I could use the CMS I've designed in it's stead.
Anyone have statistics/benchmarks as to how this stacks up compared to a "afterburner" or similar caching system?
I don't think anyone has time to do that, this was released 31 mins ago. But according to the FB post: &gt;With HipHop we've reduced the CPU usage on our Web servers on average by about fifty percent, depending on the page. Which sounds huge. But there is a trade off: &gt; HipHop programmatically transforms your PHP source code into highly optimized C++ and then uses g++ to compile it. HipHop executes the source code in a semantically equivalent manner and **sacrifices some rarely used features — such as eval()** — in exchange for improved performance. (*emphasis added*) So, being a drupal dev, it will be awhile before I can make use of this (since drupal uses eval() pretty much all over the contrib world). But they will likely release some of the info you are looking for at the ustream even tonight at 7:30 Pacific. EDIT: by "released 30 mins ago" I mean the announcement, it doesn't appear that the code has been released to the public yet.
i'm excited to see what these "rarely used features — such as eval()" are. php has so many quirks that are almost impossible to do in a static typed language: $name = 'Bob'; $myvar = 'name'; echo $$myvar; // echoes 'Bob' $myObj-&gt;$methodname(); $myObj = new $className(); Afaik c++ doesn't offer something like the reflection in java, which could be used to implement these examples.
&gt; drupal uses eval() pretty much all over the contrib world This makes me sad. Necessary evil?
Necessary evil for some of the more popular modules. It's why a non-coder can build a complete copy of basecamp in 48 hours - only editing a single css file.
Okay, understandable. I wasn't certain if they had done any performance benchmarking against other methods. I can't imagine they would waste development time on something that gave no benefit. 
Exactly. `eval` is just one out of a whole class of features, that is fairly commonly used in php applications.
After all the hype there was around this, I think it is fairly disappointing. Compiling PHP into something else isn't exactly new stuff. They say it themselves: &gt; Even compiling PHP isn't a new idea, open source projects like Roadsend and phc compile PHP to C, Quercus compiles PHP to Java, and Phalanger compiles PHP to .Net. First it was about rewriting the runtime, then rumors said they had rewritten the language, then a JIT compiler that would compile pages on-the-fly, and finally this... :( They talk about HPHPi, but also mention it's only for development, in order to pre-test code to see if it would work with HipHop. EDIT: Typo
Why announce it now and only release the code later?
The performance increase sounds enticing, and if it's possible to get ICC to work with it instead of GCC, I'd be even more interested. With that said, I'm also pretty concerned about which PHP features it's not compatible with.
Necessary evil in that they made the mistake of providing eval in the first place and now have to maintain it? Yes. Necessary evil in that the Drupal modules have to use it? No. If you're coding and you find yourself using eval() to solve a problem, your solution is wrong and you need to step back and rethink your approach.
However, method calls via variables are simply implemented in C++ via some indirect function call, with a static switch generated at compile/convert time, or a dynamic lookup (some form of reflection maybe?) could be added at convert time just for these classes. Because PHP uses the $GLOBALS superglobal array to store variables, I'm guessing they're just using that to handle variable variables. Also, just 50% increase shows that most of their workload is already heavily I/O bound, so these small variable/function lookups, or even running the VM is relatively cheap, compared to DB queries and other operations resulting in cache misses. (Plus, I wonder how good their optimizer is.)
This makes the most sense for a robust, multiple machine deployment based site/system. Unfortunately, JIT compilers are not as good as they could be, maybe in a few years the core PHP team will do it. (As for PHP that makes more sense, than this hiphop thing.)
All I can say is that if performance is your goal, converting your code using an automated algorithm to a more efficient language seems clunky at best. You could achieve way more performance increase by recoding the whole thing using human brains, like Twitter did (who also had enormous scaling problems), when they rewrote their backend in Scala.
I guess you missed the part of being able to enable NON-CODERS to build sophisticated interfaces and applications on the web without having to go into the guts or deal with CHMOD and other "abstract" ideas. It's a tool, that is all. Some people own shitty hammers but they still can hang a picture.
As in a few hours later? Uhm.. press cycle?
&gt; If you're coding and you find yourself using eval() to solve a problem, your solution is wrong Often repeated, not true. Simply stated, how would you design an eval() testing harness, without using eval()?