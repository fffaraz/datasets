What kind of "system stuff" are you talking about? Got a few examples?
yet another blogspam list
You could almost say........ (•_•) / ( •_•)&gt;⌐■-■ / (⌐■_■) A facade
I'll probably do once support for windows 7 starts dropping, until then I'm fine with having my Ubuntu catch dust in the VMWare.
thumbs.db
Yes, but the mixed signals are exactly that, mixed. There are many cases of men who wear women's clothing who are fully heterosexual and would be offended to be considered transgender. Just like encountering an interstellar warlord, the typical person would not be terribly sure of what exactly they are looking at and will be forced to awkwardly address the issue without trying to cause offense.
Darn. There goes my favorite rant. It is by far the most widely used 3rd party bundle in the Symfony ecosystem but took over 5 years to develop and release. Oh well. Still glad it is finally out.
Question: Isn't 'hash' a misnomer in this library? I was under the impression that by definition hashing is a one-way process to map some data of an arbitrary length to data of a fixed length, but this library touts the ability to decode the hash. This is an encoding library, yea?
Yes, you're absolutely right. This is briefly mentioned in #5 too. In retrospect I should've totally named the library something else. However, it's also kind of nice the way it turned out as far as "marketing". When people google for "hash" or "id", they might not have a full idea of what they need (should it be reversible? does it matter for their use-case? etc), so the site ended up ranking higher because of that. But once they're on the site and reading about it, I do mention this in the documentation: http://hashids.org/#why-hashids
That had crossed my mind as well, Hashid is much catchier and unique than Encodeid... actually Encodeid can be pronounced as encoded. Brb starting a project.
The [docs for Mockery](http://docs.mockery.io/en/latest/) are pretty good. Using a mocking framework has really helped me understand how to test classes in isolation, rather than always integration testing (which is slower to run and more brittle). 
Thanks for these tips on starting an open source project! Didn't look at the project itself though, because it solves a problem i don't have. But thanks again for your insights. Edit: "hashids" sounds way cooler than "obfuscate an int/array to a string that looks like a hash" (or something like that). Naming things is hard. Naming things in a marketable way is even harder. So thumbs up for not having sleepless nights that "hash" in the name isn't factually right. 
But I'm not passing in anything. I think you've misunderstood the purpose of what `method_exists`, interfaces have nothing to do with that function. They're two completely different pieces of functionality for two very different concepts. `method_exists` is for when you do not know if the method will exist or not. If you have 500+ Classes that you want to loop through and run a series of methods inside them, you can use `method_exists` to prevent errors, that is its whole purpose. Interfaces are intended when you want to make a custom file that the system will understand because it always expects the methods to exist, they cannot be optional. The purpose of interfaces are to ensure the class **garauntees the methods exist**, `method_exists` allows you to make methods **optional**. My example is not flawed, it is a clear real world example.
The [official docs of the PHPunit testing framework](https://phpunit.de/manual/current/en/index.html) provide a lot of information for getting started on unit testing. PHPUnit is the most used testing framework for php. 
I can see [you've had quite the discussion](https://disqus.com/by/tony_marston/) with him already.
Legacy code that uses mysql_query, sql that is built by complex concatenated strings and baby steps. 
Ah yeah I remember having that same gotcha many years ago, it'll sure get me again one day
Using a package like Chronos would solve this more elegantly.
I know Carbon suffers this same problem (because it uses DateTime under the hood). Does Chronis handle it differently to Carbon?
I think I had this and never figured out what it was. Will have to take another look.
The first step towards fixing performance problems is to determine where the problem is. That means profiling. There are many resources online on how to do this, but for a small site like this (presumably without a large technology budget), I'd probably start with a few simple and rough things: * Record the current time in milliseconds at various points in the script, and dump those to a log. This'll help you narrow down where the time is being spent. * Run your queries manually through the SQL client and observe the times. * Run your queries through the SQL `explain` statement. * Observe system load on your database and web machines (if they're separate). My bets would be on queries that aren't using indexes, or the db machine not having enough memory to keep the entire db in memory, so it sometimes has to pull data off disk. But these are wild guesses.
I've narrowed it down to only large results. For instance, if I refresh the page on a query that returns only 10 lines, it loads immediately. However, if it returns 100 lines or more, it sometimes loads immediately and then sometimes loads after 5 seconds. SQL Queries directly in the SSMS are instant returns. 
After a little bit of searching around on SO, it seemed that mysqli was actually faster, but less convenient, because you have to pass in each individual property to the methods.
getenv(). it's just like any other env var.
Depends on what level of dev you're looking for, at my work we always ask few sql questions, familiarity with frameworks, few about cache and optimisation. After that we give task to code. If in the end candidate does the task at least mostly good and we feel "chemistry", that he can think and ask/answer questions then we hire
I'd call it method chaining, or a fluent interface.
I'm not sure how immutables solves this? If the date is `31-03-2017` and you do `subMonth()` - what do you expect? 31-02-2017 is invalid. So should it be `28-02-2017`, or `02-03-2017`
But the definition that I've worked with is that it can map data of an arbitrary length to data of a fixed length. I'm not sure how such a function could promise reversibility without the use of something like a rainbow table. You simply lose information when you map data longer than the resulting hash. A reversible hash is just encryption. 
I don't think you understand the problem. :) The issue is how you handle `subMonth()` or `addMonth()` when your current day is not present in the preceding (or following) month. In PHP the default is the linked behaviour; for compatibility reasons Carbon does the same, but provides `subMonthNoOverflow() methods for people who want the more obvious behaviour that OP expected. Chronos originally worked the same way, but [changed their behaviour](https://github.com/cakephp/chronos/issues/10) to try and be more intuitive. None of this has *anything* to do with immutability or immutable dates, however. Instead it's a conscious design decision to try and intuit whether Mar 30th minus one month is *actually* Feb 28th, or is *actually* Mar 2nd. Both are valid choices, and the latter is the *de facto* standard in the PHP world. Even if it does cause a ton of bugs. :)
I made a hotel booking system years ago and the uk time going back/forward an hour caused me issues.
Interesting. I knew of the `subMonthNoOverflow()` - but I didnt know Chronos set that to default. I might have to play around with it a bit more... thanks...
I made a core framework years ago and I use it for all my projects very good I think I just can't seem to get into big frameworks. folder structure like this... login =&gt; init =&gt; route=dashboard/dashboard od_libraries ( classes, libraries like PDF, PHP Mailer / functions / db_access ) od_views ( the folders / pages ) od_assets ( img / css / js ) so when the users logs in, it goes to root like this... od?route=dashboard/dashboard which loads the following.... firstly it checks if logged in, then it loads od_views/dashboard/switches.php ( this tells what the page needs, like which js, css or php library or if headers and footers needed ) od_views/dashboard/dashboard.php it also logs the event if told to by the switch file typical switch file $header = true; $footer = true; $log_description = 'dashboard'; $classes[] = 'charts'; $classes[] = 'pdf_export'; $user_level = 5; It's very fast. 
i have always found these very reliable... strtotime('last month'); strtotime('this month'); strtotime('next month');
Install xdebug and enable the profiler. You can view the results with kcachegrind or webgrind. It will give you a detailed breakdown of everything in your application and how much time it is using. Enable the performance scheme for MySQL and look for expensive queries.
great read
hard code in php now is not as tough as back then, * create composer.json * pick up container, router, orm and the libraries needed * start writing your project * ....? * profit! 
Try adding a flush/ob_flush every 10 loops or something. I'd look at your query, and maybe chunk it too, if it's just for you, you could load more into the table via Ajax without too much hassle too :)
Just jump into a framework. I'd suggest Laravel. Take a look at some of the free lessons on https://laracasts.com and I think you will be hooked.
You can use reactPHP to build out components for the virtualdom, but then you'll need to use react native for the front end. Technically it's achievable to build android apps using PHP to power the backend by having it preload the necessary components and handle some of the state/CRUD of the app. It's obviously more efficient to code in Java or Swift, so it really depends in the situation. I.E. you have a CMS like drupal, WordPress or magneto and you need to use what is published there power your Android app. We've gone over a few iterations of this lately and we decided to implement a separate decoupled the backend powered by PHP which provides json objects that React Native can use to make components with. Not my choice, I really wanted to try React PHP, but I was outvoted by our JS guys. Edit: I was on the subway earlier and my stop came up. Meant to include these: https://github.com/reactjs/react-php-v8js https://facebook.github.io/react-native/
At that point you've compiled an a la carte framework. I don't think it's what OP meant.
&gt; the web is it's own paradigm. *cough* [Action-Domain-Responder](http://pmjones.io/adr) *cough cough*
The docs made a whole lot more sense to me after https://www.youtube.com/watch?v=84j61_aI0q8 . Installing is pretty easy. Getting a file structure setup and bootstrapping the stuff is fairly important to get sooner than later. This kind of gets you to a good starting point. Then you can work on the actual task at hand... creating the tests and ensuring that you don't break your code with updates.
I've seen them called Demeter chains
Or header(), or setcookie(), etc. code.
Law of Demeter applies when one object knows too much about the things it delegates to, whereas this example is (seemingly, as we haven't seen `methodOne()`'s code to see what it returns) all working of the same object. What you are talking about would apply to something like this: `$obj-&gt;foo-&gt;bar-&gt;baz()` where `foo` and `bar` are both objects. This violates the Law of Demeter because `$obj` can know about `foo`, but it shouldn't know about `foo`'s properties and such. The "proper" way to write that is something like // this is on Obj public function foo() { return $this-&gt;foo-&gt;someFooImplementation(); } // this is on the Foo object public function someFooImplementation() { return $this-&gt;bar-&gt;foo(); }
Is that a Roman numeral for the month?
$this-&gt;methodOne() is just a function that returns an object, an instance of a class, which has a member function methodTwo(). But I'm glad to hear what it's called ;) 
Thanks, appreciate it. I'll try to write with a more regular schedule in the future :)
*Before* you get started, read [this](http://shop.oreilly.com/product/9780994182647.do).
thanks for the link :-) the problem with any "three state" paradigm is that the modern web has dissolved the boundary between the view and controller, or the action and the responder if you prefer... where in any web application do you see the boundary between the view and controller? yet we allow this thinking to dictate how our frameworks are written. 
You'll be disappointed then. 
I had my WTF moment with the `foreach (range(0, $count) as $i)` :)
That won't help you when it comes time to debug an issue with the framework you're using. Frameworks are great but at some point having at least a basic understanding of the internals can be pretty handy. Also a lot of jobs will ask that you know how to perform a task without using a framework. Shows good understanding of the language itself. 
Yep. Files: bitnami.css, applications.html, favicon.ico. Folders: img/, xampp/, dashboard/
Not sure how to check Xampp version, when opening it it says: XAMPP control panel v.3.2.2 [compiled Nov 12th 2015] So I guess it's fairly recent
Thanks for sharing. I only started to use it only a few days back (I don't think my installations counted for the 1M), and it's a truly nice library to work with. Most of the criticism towards the library is from those who didn't understand the use case. It's a terrible library to encrypt, one-way hashing, or to use as a UUID (partitioned databases, etc), but gets the job done really well to obfuscate the serial database IDs.
Doesn't always have to be `$this`, other objects work too (usually seen in service locators).
https://continuouspipe.io has launched recently, that might do the trick.
Thanks. Platform.sh was the one I was looking at as well. After work, or tomorrow, I'll take a look at the video. Thank you! :)
Thank you! When I go to the features it even has a GitHub integration. Nice. I'll have a look
It is. &gt;// Copyright 2003-2005 by A J Marston &lt;http://www.tonymarston.net&gt; &gt;// Copyright 2006-2014 by Radicore Software Limited &lt;http://www.radicore.org&gt;
Give the candidate a small (part of an) issue of you current project and ask him to write code for it. 
Ha, we had the exact same problem in our product! Fixed it by using "first day of last month" which was appropriate enough for us.
But that's not how PHP works. $test1 = DateTimeImmutable::createFromFormat('d-m-Y', '31-03-2017'); $test2 = $test1-&gt;sub(new DateInterval('P1M')); echo $test2-&gt;format('d-m-Y'); // prints 03-03-2017 Edit: Obviously a library can wrap the underlying DateTimeImmutable instances and expose a different API. But most don't. 
Yes like the web is it's own thing. It's barely related to computers (there's a big misconception that it is). It's much more relevant to spiders. 
Yep i agree, it doesn't have to be $this. But according to the example that he shown, i said $this.
Not the best cost-effective option, but platform.sh has this feature. Pantheon.io also has it, but the its far less customizable. 
Surely its beneficial in some areas? Like Query Builders, Routing, etc?
We used to do exactly this when we had Atlassian Bamboo. Then we realised we could just give the testers a script to pull down the relevant branch to their local machine and run `docker-compose`and a few build commands, so now they can just test locally.
Thank you all for the replies. I have a lot to catch up :)
Symfony + FOSUserBundle + FOSOAuthServerBundle + FOSRestBundle + NelmioApiDocBundle
Let me tell you my asking when conducting an interview for PHP. First of all I ask for "How does internet works? Explain from point A to point Z" just to know how deeply he/she understands things (being a developer he/she should know) then I continue with OOP concepts then database problem and their solutions, what will the steps to secure an application. ask about continuous integration or his/her development work-flow and I also prefer not to give them code with syntax error because only a few of the developers have the interpreter installed in their mind so do not expect them to solve syntax problem out of your snippet (some may disagree with this statement) but this is my thought.
Maybe ask in /r/docker
&gt; a few months for ~350 lines of code I too have found this out. It's fine smashing out 350lines of code in a personal project that no one will ever see but when you have to start thinking about portability, flexibility and code quality if your code/package is going to be used by someone else the time frame quickly escalates 
I don't think it was him who did the port but someone else in the community 
Cough, same thing by another name, cough cough.
&gt; where in any web application do you see the boundary between the view and controller? The view emits UI events, the controller handles them, modifies the model, and the view is updated based on the model. That's a pretty darn specific boundary. You have to know the rules before you can break the rules.
I thought this would be about the problem of libraries and their Packagist repositories disappearing or being replaced by something else, making your application flaky and hard to maintain. I thought it might even be about debugging code in /vendor which should be considered read-only and not part of your project, making highly modular applications hard to maintain. But nope. It's about some kid who just found out about "Composer" yesterday, and is glad they don't have to manually unzip shit in their project /source directory anymore.
Wow, just skimmed through the docs, this looks great. I wanted to build something similar but looking at the feature-set and how extensible it is I don't think I'd get close to how well they've designed this. Could you talk more about your experience with it, any roadblocks you encountered?
It's a bad article that repeats several things you can find better described on Composer's own site. If you have used Composer for more than a few hours, you'll learn **nothing** by reading this article. Do I *have* to love it? You have your opinion, I have mine.
&gt; How does internet works? Man, that would trip me up so hard. I mean, where do you start? The OSI model? Or keep things abstract and only talk about the upper layers. It's a PHP Job, so keep it to just client-server interactions, or do you go in to client to client interactions or even name resolution? Open ended questions like that are... ugh. It would kind of make me question if the job is worth it...
Thank you. Thanks you really. Would look them up this weekend and plan...
As a user I prefer a text message, as long as it makes it to me very fast.
Thanks for the input !
I love you, Tanks, but you know better. ;-)
/r/lolphp
I'd rather use a facebook / google login (developer here). If I have to make an account, I use a password manager, so I don't mind having to use a password. The downside of using the passwordless method is that emails aren't always instant / sometimes go to spam. Why do you want to do this, by the way ? Is it just to delegate the password storage responsibility ?
That's why the smart frameworks and people wrap it with https://github.com/cakephp/chronos :) It fixes those problems for you, so you dont have to care about it (because you dont want and shouldnt need to). And it also provides other useful shims the PHP core itself implemented badly. It is really worth checking out - never rely directly on DateTime IMO. The most important addition on top is the immutability by the way!
&gt; Content headers no, command headers yes. Cookies yes. It's a complicated topic. Under ADR, it's not complicated at all. All headers, cookies, etc. get set in the Responder, not the Action or the Domain.
Well, I set you up for that one. :-) Meanwhile, since I do believe you have lot of good knowledge to share, I continue to nag at you to start blogging, and/or publish for your coding work. I am sure it would be instructive.
This is something I've spent a great deal of time thinking about. Most password based mechanics are incredibly dated or difficult to deal with to begin with. What alternatives aren't very easy to find, or if you do find one it's difficult to know whether or not it's secure. I would say that as a whole Email based 2FA is frowned upon and defeats the purpose of your "passwordless" mechanic to begin with because the login URI is still behind a password (password for email). Passwordless login works best when it's backed by hardware, like a cellphone or dedicated authentication device. Google has a very interesting 2FA login procedure--once a user attempts to log in they're sent a notification on their primary cell phone asking if they're attempting to log in. Click yes to approve the login and no to deny the login attempt. It seems to be a pretty novel attempt to rectify the inconvenience of using 2FA. I won't speak to how secure I believe it to be, but I do think it could be used as a drop-in for passwordless login. Enter a username or email address and receive a notification on your device. Click yes to login no to deny the login attempt.
How about something like Google authenticator? I log into a website, my phone beebs, I click "ok" and I'm logged in. I hate passwords, but they are a thousand times better than tokens over email or SMS. Both email and SMS are broken, unreliable, shitty systems from the long long ago that should stop existing. Email don't arrive, arrive in spam, arrive next week, etc. Same for text messages. Oh you're in another country? Fuck you then, no login for you. But if you're lucky the text message will reach you about 30 minutes after the session has expired. Of course on top of all of this, both email and text messages are NOT SECURE in any way. Now if I have your email password, I also have the password for your services. Or if I'm close to your email server or happen to be collecting information on the net, or whatever. Don't rely on emails or text messages for anything ever. The sooner these things are a distant memory the better. 
Using both seems like a better idea. Personally as an end user it would be inconvenient as I use a password manager so logging in for me is simple. I do not always have my phone in my office or my email client up. Also how long do you want the token? Is it something you will have to click a link for or will it be a 4 digit code? 
I want to do this to explore other methods than regular authentication: for some websites, I don't use a password manager, and always manage to forget my credentials, hence the idea of « passwordless ».
I don't like that at all. Here's why. My email is generally on my phone. Even if I have outlook open it regularly takes longer (5 seconds to a minute even with refreshing outlook) for the email to download to outlook vs my phone. So this login process is now taking several minutes to get into your site. 
That's pretty interesting, I'll try to dig a bit on this subject, and report back, if you're interested.
Depends on the website too. Our website doesn't have payment or other security requiring features, that's why we let the login session live for longer periods. Honestly this system is very easy to use, also to implement.
Same here. If you want performance with docker, you must switch on linux
Just go for facebook and/or google login. It's easier to use, just needs one click. https://blog.damirmiladinov.com/laravel/laravel-5.2-socialite-facebook-login.html
I am on Docker for Mac, and with regards to PHP performance specifically, this has worked for me.. With the standard php 7.1 php.ini, my laravel based application (in development/local environment) clocks a request with the laravel debug bar at around ~800ms. This is expected in this environment (sharing the project folder with the container in rw mode, ability to run composer commands in the container and have that code shared back. Keep in mind, lots of files loading from vendor/). You can get pretty massive improvements if you lean on opcache to speed up the loading of files from your vendor/ directory, which is where a significant cost is to php. Run with `opcache.enabled=1`, but also ensure that `opcache.validate_timestamps=1` and I change `opcache.revalidate_freq=60`. I also have a blacklist file specific to my project structure that is loaded: `opcache.blacklist_filename=/etc/php/7.1/opcache-blacklist.txt`. This file looks like this for a laravel application: /app/app /app/bootstrap /app/config /app/public /app/resources /app/routes /app/storage This setup allows you to hack on files in the above listed directories, while your /vendor directory will get opcached (most importantly not touched/stat()'d) for at least 60 seconds before their timestamp is checked for invalidation. This reduces the time it takes laravel to produce a page request from 800ms down to about ~150ms on my machine, which for me is pretty acceptable for dev.
For OSX get rid of the native build, and use docker-machine configured to mount everything using NFS mounts. It's still relatively slow, but 10x faster than the native clients.
Get the fuck over yourself. Not everyone is advanced. Many starting out probably find this article very helpful. No you don't _have_ to love it, but you also don't have to be a dick in the comments. Just move on.
A password manager w/o two-step auth? Living dangerously, eh!
Really? I always thought of these messages like "Screw you, no system is getting my phone number, even temporarily"
I personally want to be able to authenticate via my phone by pressing a button. Something along the lines of enter email/mobile# -&gt; receive notification on your phone and you press "authenticate/fabricated" which then pings the server to verify your authenticated session that was generated when you submitted the form. Which also dies after say 2 minutes. Would make logging in nice and all that jazz. Not sure about how to make that secure, but I'd definitely love something like that.
Sure!
I think oauth2 is what you are looking for. facebook/google/medium along with a gazillion other sites all support it. Plenty of libraries out there that implement it. However, there is one big gotcha. On a public computer the user actually ends up logging to the media account. There is no way to explicitly log them out. So if they leave the browser open when they leave the public computer then someone else now has access to their media account.
I think it fits well for a very specific situation. So specific that I cannot think of an example. In most cases, you can get by with just simplifying your current login process or using SSO.
Many thanks. Very good feedback :)
You'd at least get notified (and would be aware next time you tried to login) that your password has been changed. Having email as a standard way of logging in is just silly.
What about Laravel + Dingo https://github.com/dingo/api
Just to make it simpler, here is the code https://github.com/pinpie/pinpie/tree/stable/src Please, provide me some feedback.
Oh I have two step on the password manager but once I'm logged in I'm logged in on the desktop haha. 
I'll take it with myself to the grave.
What would happen if half of the internet just tried to log into an account? This is fine for 2 step auth but you have to password check first as there would be no way to determine if the user should actually get an email/text. You would also only need to alter the account email to hijack it. 
Well, as we've discussed this before, it does actually make *some* things more complicated. Say, automatic cookie-based sessions are out the window, because now you have to open the session in the Action, but emit the cookie in the Responder. So you have to be explicit that every Action using sessions might want its Responders to be writing a session cookie. As opposed to this: &gt; session_start(); Now which seems more complicated?
Sure; it's the same difference as, say, creating an object inside the object that needs it, as vs injecting it from the outside. So yeah, it's more complicated, in the sense that *some* of the conveniences that PHP provides, are revealed as a combining-of-concerns; in this case, between data-source reads &amp; writes, and *presentation* of that data. There are no solutions, only tradeoffs; if that's the biggest negative, then I'm satisified with that tradeoff.
To me it's the best security. If it's a site I trust and use they probably already have my phone number anyway.
What's complicated about `http_build_query($params)` ?
&gt; Headers serve a wildly different set of purposes. Yes, and *all* of them are "presentation" concerns. This is because, on the web, the "view" is the entirety of the HTTP response. On that basis, putting header()/setcookie()/etc. work in anything other than the presentation layer, is just as bad as building HTML in anything other than the presentation layer. In ADR, that presentation layer is the Responder; in server-side MVC-ish systems, that presentation layer ends up getting split between the View and the Controller, which strikes me as combining concerns inappropriately.
&gt; Yes, and all of them are "presentation" concerns. This is because, on the web, the "view" is the entirety of the HTTP response. No, emulating stateful connections by keeping bits of state on the client is **not** a presentation concern. That's what the entirety of my comment was about. Don't focus on the technicality "it's all bytes sent to the browser" think about what those bytes mean and how they're used. No presentation ever is tasked with keeping *domain or application state*. The reason browsers do, is because of flaws in HTTP. It was designed to be stateless, then that idea turned out stupid in practice, ergo - cookies. This is why sessions are messed up in your ~~ADR~~ MVC.
Nothing? but complicated queries can make long parameters which most servers deny on a certain length. 
For those starting out, there's already [this](https://getcomposer.org/), genius. We don't need the manual of PHP and Composer poorly replicated as blog posts all over the web.
I've always wondered how you could possibly run into that problem. If you're sending whole documents (XML, JSON, ...), then POST is indeed the more appropriate way. But again, to me that smells like there's a more fundamental problem in the API layout.
Who's your audience? It doesn't look very friendly to either developers or front end designers. I would say it's dangerous for newbies but far too limiting to for anyone else that isn't. It makes use of memcache? But then doesn't produce 302's/405's? There isn't anyway to easily to extend it and it doesn't play well with others. * SOLID * PSR 
You're not making even an attempt to understand what I'm talking about. If you keep focusing on trees, you'll be missing the forest. If you keep focusing on "the response as a bunch of bytes" you'll miss why it's an amalgamation of completely orthogonal concerns, that are important to different parts of your service architecture and should be handled differently.
In case of passwordless auth - to log in with facebook or github looks very attractive. One don't have to remember too many passwords. But. If you have some private content, that have to be protected - the password will be must have. Example: assuming someone have some private code repository. And there is button - delete the repo. That is very important button and it's action can lead to some very dramatic consequences. Because someone can reach your computer while you didn't lock it (like if you went to the bathroom) - that can happen in a single minute. So, for everyday interaction - passwordless auth is OK. But that kind of actions have to be protected somehow with additional auth step. Password can be that step. Or it may be a text message to the phone. May be you could find some other solution. 
There are a lot of things wrong with your code from a object oriented programming/clean code perspective, too much to cover here. I highly recommend that you grab a copy of Clean Code by Robert C. Martin and read it cover to cover. 
Sigh. Let me try this another way. Do you agree that the architectural boundary "separating content from presentation" is often mechanically dumbed down by beginners to be "separating imperative code from HTML markup"? The complete presentation is not just the HTML, so it's not keeping HTML separate, but keeping presentation separate, that counts. The shape of something isn't what matters, its responsibility within an architecture is what matters. Agree or disagree?
This, pretty much. Why try learning something without the basics? Syntax is something you need to get down, so you might as well have them vibrant and stuff.
Thanks, man! I'll do my homework and come back.
Indeed, asking for a password for critique actions seems to be necessary. Thanks for the input. :)
You could limit the amount of attempts to 3 per hour. However, what could be interesting would be stocking IP/Device, and if the requesting person has these stored, you could leverage the limitation, so normal users wouldn't be blocked if they had a problem and had to login several time. It's not really clear, but do you get what I mean ?
It could be used as an alternative, not as the main login.
That's an interesting point, thanks for the input.
+1 for Laracasts, especially [these videos](https://laracasts.com/series/lets-build-a-forum-with-laravel). They're a great starting point to testing, and Jeffrey Way is an awesome teacher.
&gt; because to say "if it's transported to the browser, it's presentation" Ah, but I am *not* saying that. I am saying "if it's emitted from the server, it's presentation." That is, the server is presenting that response as its output. What the receivers of that output do with it, is up to them. &gt; cookies are a model /me furrows brow Again, we disagree here. A Request cookie is *input*; that is, input from the client received by the server. A Response cookie is *output*; that is, output from the server sent to the client.
Cat and mouse, and while you are doing that your legitimate users are locked out/receiving spam. If someone wanted to be malicious they would write a script that spins up a new server on aws/do/etc try it a few times, destroy the server and repeat. 
Ah, the mention of "signals" brings back memories: https://github.com/auraphp/Aura.Signal
I'd agree on other subreddits as well since vast majority of the front-end are still HTML/Javascript apps, and that's how HTML submit a collection of items (e.g.: set of checkboxes).
Right, but they're *HTTP* status codes, not *API* status codes. They should reflect the status of the HTTP request, not what the API has to say.
I think I see what you're getting at, but I think variadic functions screw it all up. If there was a one-to-one mapping between the named arguments and what you pass in, I'd agree with you, but when you have function foo(bar, ...baz) Then I think trailing commas should be allowed because many values go into `baz`.
&gt; And I can't find any links by "Unix signal slot" search query in a Google. That's weird. I got over six hundred thousand. You sure we're using the same google? You have, actually, heard about it in unix. `sigkill` is the `kill signal`. `sigabort` is the `abort signal`. You've probably also heard `sighup`, `sigabrt`, `sigterm`, maybe `sigsegv`, `sigpipe`, `sigint`, and so on. They were added to POSIX in 1970. I'll leave tracking down slots to you, because it's actually very easy, and I don't think you should give up on looking so quickly.
Tell me, what should each of these two requests return: - `GET /users/5` where user 5 does not exist in the database - `GET /uzers/5` where user 5 *does* exist in the database, but the client misspelled the URI
I agree that they're different in nature, and you can argue that there's no inconsistency because of this, but I still think trailing commas should be allowed for the same reason for both.
That's up to the server, but if you want to make distinction, you could send a `404 Not Found` for the first and a `400 Bad Request` for the 2nd one. The first meaning, "I understand, but there is no user 5", and the 2nd "I don't understand what you want from me", because there is no "uzers" resource. You may as well send a 404 for both, if you deem that difference not important enough.
Here's a link to the location: https://www.reddit.com/r/place#x=38&amp;y=353
That's very interesting, thanks for the link !
&gt; he made an incorrect history claim No, he didn't. His readme even says &gt; This library is inspired by Qt "Signals and slots" mechanism so it's pretty similar. I gave two links to support his claim. If you look at [QT's documentation on signals and slots](http://doc.qt.io/qt-4.8/signalsandslots.html), it's pretty obvious where he got the idea from. You can stop trolling now. 
You have to remember, "real" MVC is a client-side in-memory graphical *user interface* pattern. In that situation, the controller receives the keypresses/mouseclicks/etc as input, and tells the model and view to start talking back-and-forth to start updating other. You don't "save" it anywhere, it gets passed directly through. That's one of the reasons MVC is not an appropriate pattern for client-server over-the-network interactions, where the user interface is not GUI elements and mouseclicks/keypresses; it is the Request and Response. &gt; I have to conclude you're either not reading what I'm writing, or you're so predetermined on rejecting whatever I say, what I'm telling you is going straight over your head. Again, Tanks, you're great, but I could say the same thing about you at this point.
&gt; You have to remember, "real" MVC is a client-side in-memory graphical user interface pattern. In that situation, the controller receives the keypresses/mouseclicks/etc as input, and tells the model and view to start talking back-and-forth to start updating other. You don't "save" it anywhere, it gets passed directly through. It gets passed "directly through" to what. You're kind of saying it there, but you don't want to say it. You're picking on words again. Don't like "saved"? Let's call it "remembered". In which MVC component does the application "remember" which user last logged in? Tell me. 
Buddy, go fight the good fight somewhere else. Yes, his readme makes the same claim he made in here. It's incorrect. You gave a link of him saying the same thing somewhere else that he said here. That's not evidence, that's showing that he believed the same thing at an earlier date too. I had a polite conversation with that guy, and he's not angry. I'm not sure why you're angry on his behalf, or trying to prove him right. Probably don't say "Bob is right, because as evidence, here's Bob talking in a different place, which confirms Bob." Have a nice night. I'm not really interested in further steps in this conversation.
No, you run shell_exec with specific command. The worst thing is get error, if you run ffmpeg command with verbose options and get some personal info about hardware/software (just not good practice). When you run shell_exec with dynamic commands, especially written by user inputs - that's dangerous use of shell_exec :)
&gt; Seems it would be the Model component Finally, breakthrough... &gt; though, in MVC, there's are MVC triads for each element of the GUI. So it's tough to say; your phrasing makes it sound like you think MVC is an overall application architecture, instead of a UI pattern. That's another debate, but it doesn't matter for the purposes of this question, because whether it's an "overall architecture" or per-widget pattern, any non-MVC logic in the application would be exposed to the triads as models. Which means the answer is still "a model". ------------------- So next step. When, in your Responder, you have to emit cookies, which as a session/user state persistence mechanism are more appropriately a Model concern, this is probably done for a purpose. And when I say "purpose", let's remember why we have Abstraction in software at all: it's not to stress on the implementation details of a feature. It's to provide an interface, whose mental model is simpler, and more fit to the problem at hand, than the hairy complicated underlying implementation underneath. Agree/disagree? So, say, C's unsafe pointers don't make a good abstraction simply because "that's how memory allocation works down under". Hence why modern languages largely do away with unsafe pointers. So cookies as part of the Responder, which are typically part of the Model, don't make a good abstraction simply because "that's how HTTP works down under". There has to be a reason why this abstraction is appropriate. - In terms of a mental model, it's bad: models are not presentation. - In terms of simplicity, it's also bad: you admit sessions become more complicated with ADR. So what is that reason to place cookies in the Responder, aside from low-level implementation mechanics?
Of course I've heard about sigkill. Just was confused if it's the same mechanism. Thanks for clarification.
Ok thanks, I hope their will be improvements, especcially for MacOS!
Thanks, that sounds good. Since we are using Laravel to, it may help a lot!
Yeah... But I need to talk to PHP Developers with Docker environments. I guess I can find the most helpfull responses in this channel ;)
Yeah, I love Linux but switching the OS is no option atm.
Thanks, this could help :) We will add @ralphschindler advice too :)
At the moment no option. :/
Thanks for these advices :) If we found a good soultion, I'll present it here!
[phptherightway.com](http://www.phptherightway.com/) is a good resource that covers a lot of topics and popular PHP design patterns, from beginner to advanced.
Build the release from your development environment, which should already have cached all the necessary files. Either that or follow /u/geggleto's advice :)
&gt; Having some external microservice for resolving mutual friends would probably be another solution. Why do you think so? &gt; In such case I would like to paginate the list shown in the user interface and there's no point to load all the 5000 users at once. First of all, why do you ever want to retrieve all friends? If you just need all of them and you want to navigate through data you should use cursor-based pagination. And then you could just return an iterator which will handle load-by-chunks logic. Your interface still will be something like `resolve($first, $second): \iterable`. But if you want to display some kind of list, and UI requires you to use pagination, then you need to change interface to `resolve($first, $second, $cursor): \iterable`.
"If you need to trigger some "slot", you should call it directly" No, you shouldn't. You shouldn't think in your code "aha, looks like here time to call slot...". WHEN is right time to call slot decides emitter. An object who emit signals. "hide this in some connector." Same point for event dispatcher that you mentioned - hide in some dispatcher ("bind your stuff"). Isn't? "However, your library prevents usage even for that use case, because when "connecting", it requires you to specify both the sender and receiving object." Could you clarify this point a bit? Yes, it requires. It means you can have as many "event dispatchers" as you want. That's​ why you should directly specify sender. Think about objects as standalone ones than CAN EMIT some signals just like in real life. And some other objects can react on that signals. As for event dispatcher - it's a bit other thing. I see it as early central place in a system that can notify listeners about some events. Sounds pretty similar to "signals and slots", but uses on an application level in general. Not on object level.
Maybe this can help you out to optimize shared data: https://sourcemaking.com/design_patterns
Sorry, was supposed to link https://sourcemaking.com/design_patterns/flyweight
&gt; Doctrine: please visit [3v4l.org/doctrine4!](https://ocrami.us/) and share your thoughts in the comments section below! Haha Good one!
I'm glad this is an April fools' joke, I almost had an heart attack seing an ORM (which is the first thing I hate in the world) becomming a part of Laravel's facades (which is the second thing I hate the most in the world).
Looks promising. Thanks!
automod probably derping as usual. we have weeks where the general discussion thread wasn't stickied and two library discover threads lol
I'll check that out. Thanks!
You simply include sub.php on the php pages u wish to call the "sub" from. Php does distinguish between sub and function. A function either returns a value or it does not. 
Were Doctrine 1 and 2 announced on April 1 as well? ^/s
Thing is, using both is pretty much the de facto standard for all large scale systems. So your "peanut butter jelly" theory is correct.
If I were you'd not add any arguments, but create a reusable "result set" object, like so: $resultSet = $resolver-&gt;resolve($friend1, $friend2); $resultSet-&gt;range($offset, $count); $arrayOfUsers = $resultSet-&gt;fetchAll(); Or in short: $arrayOfUsers = $resolver-&gt;resolve($friend1, $friend2)-&gt;range($offset, $count)-&gt;fetchAll(); This way you save yourself reading and documenting the same parameters over, and over and over again.
&gt; WHEN is right time to call slot decides emitter. An object who emit signals. If that was true, you wouldn't need to call $this-&gt;emit(). Any time you use this function, you expect "slots" which are "connected" to be called. You use it any other way and you will end up with an clusterfuck, which this pattern is anyway. You debug something, you will get up to the point when emit() happens and now you are lost in deep shit. That wouldn't happen if you just injected those "slot" objects into caller and called them directly. You nicely see the dependencies and flow of the program. &gt; hide in some dispatcher ("bind your stuff"). Isn't? Yes, event dispatchers are also useful for frameworks only. In your business domain code, you have full control over what should be called when and you must not assume it's fine when some event doesn't propagate to an object which handles it. &gt; It means you can have as many "event dispatchers" as you want. You can have it with normal dispatchers too? You just create new instance. But why would you. You would loose connection to framework, which dispatches events to original instance only. &gt; Could you clarify this point a bit? When framework is coded, it doesn't know about your application code, therefore it can't specify what object is a slot. On the other hand, if you try to initiate connection to framework in an application part, you might not have an access to an object which emits the stuff you want.
`require` / `require_once`
The real joke is in the details. /** @Doctrine\Id */ public $id;
[Object-Oriented Bootcamp - Not Free](https://laracasts.com/series/object-oriented-bootcamp-in-php) [Design Patterns for Humans](https://github.com/kamranahmedse/design-patterns-for-humans) [Laravel 5.4 From Scratch](https://laracasts.com/series/laravel-from-scratch-2017) Extra, [Learn Vue 2: Step By Step](https://laracasts.com/series/learn-vue-2-step-by-step) Good Luck
Shots are being fired https://twitter.com/taylorotwell/status/848138196072443906
&gt;clusterfuck, deep shit Calm down, buddy. &gt;That wouldn't happen if you just injected those "slot" objects into caller and called them directly. You nicely see the dependencies and flow of the program. Yes, I agree that you can replace emit() with direct slot() call, but for that you will HAVE TO INJECT receiver object into signal object. Try to think about this: there are two objects - phone and you. Phone can ring and you can answer. So you suggest to inject yourself into a phone in order to make phone be able to answer through..you. Something like this: class Phone { function ring(You) { You-&gt;answer(); } } instead of emitting signals from phone that you can connect to. Isn't weird? This library is just another look at communcation between objects that sometimes is REALLY weird (logically). I can imagine a car class that contains wheel objects or engine object. And it's logically to make direct calls of injected objects methods INSIDE of a car object. But signals and slots it's all about OUTSIDE communication between objects. I'm not owner of this point of view. I'm trying to bring this idea [from Qt](http://doc.qt.io/qt-5/signalsandslots.html) into php. &gt;You can have it with normal dispatchers too? You just create new instance. But why would you. You would loose connection to framework, which dispatches events to original instance only. You don't listen to me. That's the difference. You should't have many EventDispatchers. Usually it should be only one in a framework - it will notify about all EVENTS that happens in a FRAMEWORK. Signals and slots works on an object level but not on framework level. It's a way objects communicate between each other but not with framework core.
this man's ego make ints overflow.
Sorry about that, but I use that casually, nobody is angry here :-) To me it seems you don't listen, because I said patterns like this are useful in framework only. You admitted it's not designed for a framework, therefore I don't see any proper use case left for this. Now, I don't see the point with your example. When you need to make a call, you need a) phone b) knowledge who you want to call. So you specify who you want to call when using that phone. Of course it doesn't make sense to call yourself, but you can try to do it. You still need to specify yourself when making a call, though. Sorry that you are the one who I question about usefulness of this pattern, since you didn't invent it. Unfortunately I don't program in qt. It's perfectly fine to bring it into php if you find it useful. Personally, I don't see how it's useful, so thank you for trying to explain it to me.
Nice wording at the end of the article. I liked it. :)
I would love to get in your thought process here. Can you explain how a one sentence joke is more egotistical than their entire paragraphs and webpage dedicated to poking fun at Laravel / Eloquent? I'm genuinely curious to get inside the thought process of people who think this way. 
Sounds like someone who is jalous :')
I think this is the best way to do it. But offset-based pagination could have very strange behaviour is data is updated often.
I agree. Do a soft delete with a column in the comment table and when it is marked, the loaded html will render a place holder that just says "delete comment. by deleted" instead of whats stored in the db. Redit does this.
April Fool's is a day that needs to stop existing is what it is.
[Gettext](http://php.net/manual/en/function.gettext.php) works great, no point in rewriting a json localization engine for that. Generally, you only need to maintain your .po (with Poedit, for example) and generate a binary (.mo) to use for [Gettext](https://www.gnu.org/software/gettext/).
Ting is better.
I agree. Although I think this entire battle between the two patterns is pointless. No one who opposes AR and vice versa are going to come to an agreement. I personally love AR but I can see why others don't. 
I never knew about inline aliases, thanks!
Then as long as you can handle different plural forms for different languages easily - go for it.
https://symfony.com/april_fools_2017
I will have to disagree with you and I think you should reconsider. Give it a try. "Custom software"? You make it sound really bad. It's just poedit. I explained to computer illiterate people how it works in a 5 lines email and they got it immediately. Another advantage is that you can just send the .pot file to a translator and he can send back their translation to you. No code skills needed no tinkering with the source code 
We use Symfony Tranlation most of the times, with YAML files and keys (like homepage.headline): http://symfony.com/doc/current/translation.html - Handles placeholders - Handles plural forms in different languages - Keys: Because using the original english strings can get you into trouble as a term can have multiple meanings depending on the context. Example: "Abort it." - It is very well integrated in Twig templates. More i18n is very well handled with Twigs intl extension: http://twig-extensions.readthedocs.io/en/latest/intl.html - Numbers via localizednumber (german: 1.000, english: 1,000) - Dates via localizeddate (german: 02.04.2017, english: 04/02/2017) - Currencies via localizedcurrency (german: 1.000€, us: $1,000) Workflow: - We only take care about a source language in the repository, usually english - Then we use some translation portal like http://phraseapp.com/ to handle the other languages - We download the finished translations from there and put them into the repository - On bigger projects, this download is part of the build process happening in our CI/CD server (a Jenkins)
Oh jeez, someone even replied saying the link is wrong...
Um yes lol ... I literally thought about the whole thing for roughly 30 seconds today haha
Definitely this!
We should remake it.
Slack offers this feature and I find it very useful on mobile when you don't have access to your password manager or don't fancy typing out 20 arbitrary characters which is finicky on a mobile device.
Why do people recommend gettext when it doesn't solve the readability problem at all. Its the same fucking thing. He needs a solution for readability. Why is everyone so fucking ignorant here?
The suggestions are the same mess. Everybody is just so anxious to chime in with something moronic without reading OPs request. Gettext is not a solution - its the same kind of problem.
&gt; Then to use a branch I would simply change it to: &gt; "kizu514/package": "dev-BRANCH_NAME as 1.0.9", &gt; Where BRANCH_NAME is a branch that exists on GitHub and 1.0.9 is unambiguous. If you're paranoid about accidentally checking that change in along with the rest of the `composer.json`, you can override the `COMPOSER` environment variable to point at an alternate copy that you've customized. You can see an example of this strategy with [composer-haydn](https://github.com/DHager/composer-haydn), which "patches" the `composer.json` file and then runs composer against the temporary result.
Sure enough.
&gt; I literally thought about the whole thing for roughly 30 seconds today haha After presumably reading the joke article... then tweeting about it this morning... and then replying to reddit comments every few hours after that... Butt. Hurt.
Wasn't that you that just said he was off to a great start? First sentence, second paragraph.
You can deal with this in a reasonably short time. Just search and replace the easy stuff : short tags to long and mysql_ to mysqli library on a separate branch in git. Then you can get a chance to retest more precisely when you start doing the tedious work of sanitizing inputs and preparing the statements. Definitely don't go too deep into that if the app still works well, at one point if this represents many days of migration work to put PDO just because it's better, might as well take the opportunity to move your app to proper framework ORM tools like doctrine or eloquent where you will get the added bonus of improving your architecture on top of fixing your problems 
Implement a work flow with version control and code review of all code so everything is seen by another developer before it goes into production. That'll help prevent the codebase getting worse from here. 
Do you want me to host a demo for you?
I am planning on doing it next week. Thanks for the offer though :)
If you mean "readability problem" because you now have tags instead of actual text in your source files and it makes it hard to see what everything does or says, then have a look at jms/translation-bundle and how they use annotations for tags, maybe it is adaptable to your situation. In their case you can use tags, but define a default text in an annotation, so you basically have both. You could also implement this in a different way, so you have both tags and text, just so as a developer you know what is going on in source files and templates.
Looks nice, I'll definitely check this out!
I also suggest moving to `mysqli_` instead of `PDO`. `PDO` may be nicer to use but it will be significantly less risky to switch to `mysqli_` given how much closer its API is to `mysql_`. However I don't recommend the second part. Absolutely don't move to an ORM without more test cases and experience with the project or you will likely cause worse issues than you fix.
How to use it?
Thanx, fixed
Nah, we had fun with it.
Very likely!
https://github.com/zeeshanu/opus/blob/master/app/Http/Controllers/PageController.php Nah... thank you.
No tests?
Unlike you, a lot of people don't understand humour :)
So what exactly is the point of contention here. PHPDoc [already has a way to document exceptions](https://phpdoc.org/docs/latest/references/phpdoc/tags/throws.html), and yes they should ideally be documented, like anything else.
If it's already thrown, then simply adding it in PHPDoc itself is not a breaking change.
It's a breaking change, because you could have already used an implementation which don't throw exception and you don't know exception was allowed. If we allow that, we'll never now if an exception don't throw exception or if PHPDoc is missing.
&gt; interfaces don't throw exceptions in PHP (obviously), implementations do. You could say the same thing for return ;) And of course FetchException is the part of contract. It's an output. Input and output is the part of contract.
If an interface is expected to throw a given exception in given circumstances, obviously it's part of the contract, even when the type system can't express this part of the contract. Even in languages with amazing type systems, the type itself can never cover the full contract, i.e. how would you, say, describe in an interface a constraint like "returns an array of **prime** numbers". In most languages you can describe "returns an array of numbers", but the **prime** part is still a part of the contract, if it's *documented as such*.
Just what I needed to keep the tree structure in place, regardless of position in the nest. Thanks!
That's the point they're making. Opus is the name of a well-known audio codec, which makes searching for posts related to this project more difficult. 
Hmm I don't have time to watch a video. Have you enabled mod rewrite? sudo a2enmod rewrite sudo service apache2 restart 
What about exceptions from underlying implementations? Eg implementation A can throw X and X is part of the interface. But A uses implementation B (of another interface) that throws Y. 1) Should A catch Y and basically convert it to X? 2) Should Y be included in the interface that A implements? Both seems like bad options to me. Which means that invoking A can lead to exceptions other than X (other than those mentioned in the interface). What am I missing?
1 and 2 are valid.
In many specific cases I agree. Catching an exception, possibly adding information and turning it into another exception is trivial. But options 1) and 2) are far from valid in general IMHO. What if A uses B that uses C and D and D uses F etc? An exception from F should be allowed to propagate freely and be catched for specific purposes only. But you can't add exception Z (that F throws) into the interface that A implements. It quickly becomes insane. What if A doesn't know that B uses C that's ultimately uses F? **Sure you can add to the interface that A throws X**. But I don't see how you can or should add that no other exception than X will emerge by invoking A. Maybe the point *isn't* to say that "no other exception will emerge"? Please enlighten me.
In part this maybe comes down to having a well designed structure of exceptions. Eg if interface of A says "X can be thrown", then it doesn't necessarily mean that A will throw X - it can also be B that throws X.
Especially with all the work that went in to making it believable. I mean, the translated thread actually dates back to almost a decade ago. Not that hard to do, but an impressive detail nonetheless.
Elaborate?
everything in controller maybe? like html inline with php code, why not render it with blade if the base framework is laravel? 
everything in controller maybe? like html inline with php code, why not render it with blade if the base framework is laravel? 
take a look at the code. i'm just exhausted working with projects for which somebody thought putting everything in the controllers is a good idea. 
There are CURLINFO_REDIRECT_COUNT that you can get with curl_getinfo(). Don't know about array.
[removed]
[removed]
You might want to work on filling [the tests directory](https://github.com/zeeshanu/opus/tree/master/tests) out a bit more to tackle some of the issues you have
You can *also* manually edit .po files, no special software. Also here you have a link to [good reasons to use gettext](http://stackoverflow.com/questions/1415661/what-is-so-good-about-gettext-for-language-files). 
Hey guys. Thank you for all of your inputs in my first job. It seems like my coworker will most likely refuse to use Laravel or a framework (he's also an outsourced guy working remotely in Southern Asia area) and probably already started on the new project... I feel like I really need to get him to not use old PHP4 syntax with short hand notation, old mysql_connect, and start using preparedstatements or else it'll be another rinse repeat for me I guess... I don't see the new project on Git anyways. I guess it would be easier to convert mysql_connect to mysqli_connect, but the database code is wrapped in a class with its own query method so I feel like I can change it to PDO in those classes and add a method for prepare statements instead without too much issues. 
&gt; Gettext is old. Older than Moses - kind of part of the problem Why is that a bad thing? It's easy to use, reliable and efficient. That's why it's still around and actively used (and not only in php). Parsing JSON files and replacing text will be much slower than using native gettext, especially for large project with many translations, and require more work from you. JSON files are more difficult to read and much more error prone than raw .po files, and there are special tools for user friendly po editing/updating/converting/merging. You are asking for suggestions, but dismissing the obvious answer, thus reinventing a problem that's solved long time ago. I'm from a country where most websites use 2 or 3 languages, so I have worked on dozens of multilingual websites, and tried many different approaches when I started webdev, but I have never looked back since I discovered gettext.
I recently moved my hobby project from mysqli to PDO and it was quite okay. I already had prepared statements but it was mainly just deleting unnecessary code. PDO is more compact and better for readability. 
Someone wiped it out :( There's space in the red section close by tho
&gt; You could say the same thing for return ;) No, because since PHP7 you can typehint them in your interface. You can't in PHP as you can in Java.
Makes sense, it's something I often think about as I'm not sure the 'recommended' thing to do in cases like these.
Interesting for sure, thanks for sharing! I wonder why comments are disabled on these videos...
I think it's a bad habit, so for lots of user, exception is not a part of interface contract. But of course it's wrong, i'm agree with your post.
From my experience, you seem to be doing everything right. If you're not displaying the $id back to the user, you don't need to use htmlentities. The prepared query will protect you from SQL injection either way.
Since we don't have checked/unchecked exceptions in PHP, and the entire point of exceptions is that they can bubble up to any layer that feels like it should handle an exception, it's rather pointless to PHPDoc them, since you have no guarantee anywhere in your calling code that whatever interface has the docblock, is _actually_ the one that is throwing the exception.
As other have said, it looks fine. Make sure the `ini` file is outside of the webroot though (unsure if that's what you meant by "deep inside"). Also, there is an issue with your query; $sql = "SELECT id, name, email, phone_number WHERE id = id=?"; `id = id=?` is wrong. Just have `id=?`
ok cool, will sort that out. Thanks. 
`As other have said, it looks fine. Make sure the ini file is outside of the webroot though (unsure if that's what you meant by "deep inside").` Yeah sorry, thats what I meant. Couldn't think of the correct terminology to explain where I was putting the file. As for the query, i wrote that up quickly as an example which ended up with the mistake. Thanks :)
Yeah, I assumed so, I just wanted to make sure :D
sorry mate. i'm asking for help. it seem i miss some security header so it becomes forbidden 403. please help enlightening me
And generally it is better to escape output instead of input. Keep the data intact and *usable for any format*, escape on the fly.
I don't want some tools setting configuration options for me. I want to know exactly what configuration items are going into my application so that I can review them and change. This feels like it makes the whole process too magical and opaque.
/r/phphelp is the correct place for that. I don't want to encourage people posting in the wrong subreddit for php help by answering, so if you could re-ask over there, that would be great. &gt;/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). 
It doesn't look like anything is stopping you from knowing or changing the default configuration options for a bundle.
Never use htmlentities for data being saved in the database. Data should be saved 'as-is' and then escaped in a context-sensitive manner depending how you're displaying it. i.e. you'd need to escape it differently for HTML, CSV and JSON so it makes no sense to store it pre-escaped for just a single medium.
A simple git diff would show you all changes which you could easily review and modify. Its not like it would change arbitrary values in your database. You are still in control of your site. 
You can easily run into these issues with adavanced queries using solr, which supports post request because of this and elasticsearch uses the body because of this.
Question: Is Fabien still the sole "owner" of Symfony or just the head of the repo and project? 
You will be able to see and edit all the config files as before. They will be regular files in the new `etc/` directory of your app. The difference is that when using "Symfony Flex" and installing/removing bundles, their config files will be added/removed from you.
Firt of all i suggest you get a better IDE to make it easier for yourself. I personally use PHPStorm witch i got from my school for free, but there are other ways to get it. Also a way i like to learn things like this is to just start building an application for yourself. Like a webshop or some kind of control center or erp (enterprise resource planning). Alternatively you can try to find some tutorials but i prefer to find out myself using the documentation. Although this will not always tell you the best possible ways of doing serthen things. For the awnsers the those questions you best check StackOverflow or something like that.
Thanks! Exactly what I was looking for (but didn't think of).
Missing informations in here. I guess you are talking about some school/uni exam, not a certification program. What level of an exam ? PHP 101 entry course, or Modern OOP in PHP with composer and all ? (does Object oriented programming even ring a bell or you never heard of it ? Functional programming ? Closures ? Or old and stronk imperative programming) Is it a PHP exam, or a computer science exam happening to use PHP ? Did you learn algorythm theory ? It's like asking what ressource can I use to learn chinese. For basic conversation with friendly native speakers (hello/when do we eat ?) or for learning quantum mecanics in chinese language ?
Lots of magic : * - Hard to debug * - More time to refactor when you need to do it * - Slow runtime * + Less code I'm partisan to avoid all kind of magic. Magic is only to write less code but you lose lots of thing only to write less code. Write code generator if you want write less code for some specific case. Anyway I like immutable objects. Other thing : don't write code to block user to hack your code. It's useless.
I think 'immutability' belongs into the language core. This RFC looks promising (but not perfect): https://wiki.php.net/rfc/immutability
You sanitize based on the destination which is why the steps you take for storing in the database will be different to the ones you take to protect your filesystem etc. In this case the destination is your processing script, so you'll want to perhaps check: 1. Is the url provided valid 2. Does the url image provide a valid image that GD can work with. 3. Is the size of the images within the valid ranges I want to deal with. 4. For the image upload provided, is it of the mime types that you want to deal with (and actually check the mime not the file extension) and perhaps: 5. Who is the user, do I need to throttle their requests to prevent DoS style attacks where my server is overrun. There's also some security considerations with storing user supplied images. When saving them it's essential that they are kept outside the web root, it's also advisable to rename the file to use a random string so that no user can guess what the file will be called. Finally don't forget to make sure that users can only retrieve or see their own images unless yours is a case when the upload is meant to be public and users are aware of this. Reference here for other good security advice: https://www.owasp.org/index.php/Unrestricted_File_Upload
[removed]
Certainly anecdotal but almost all production Laravel apps I've seen or audited (and certainly all I've personally worked on) have tests, to varying degrees of thoroughness. So as far as "Laravel professionals" goes, I've seen as much testing (honestly a lot more) than with other frameworks I've encountered in my job. Zend being the worst for lacking tests, with Symfony definitely trailing Laravel, although on the whole the Symfony apps tend to be older than the Laravel ones, from a time when there was less emphasis on testing in the PHP community. When it comes to random open source projects though, you're right, but then they don't tend to be written by professionals. I don't think this is particularly a Laravel problem, only that Laravel is the hot new thing that's got a lot of new people into the community recently.
Does this authorization specify the user context?
Yes, it does belong at a lang level, but presently, it doesn't exist. If it did then I could've written one short article :)
&gt; Lots of magic. I'm partisan to avoid all kind of magic. Anyway I like immutable objects. Sounds like the first section of the article is for you then. Ignore the rest and do it all manually. &gt; Write code generator if you want write less code for some specific case. This would be an interesting project. Where is your github account so we can keep an eye out for your code? &gt; Other thing : don't write code to block user to hack your code. It's useless. This seems like a blanket statement. Who are the users you're talking about? Are you saying make your code insecure - like allowing SQL injection? Are you railing against the use of `private` in code? Are you talking about code in open source libraries or in application code? Either way it is difficult to find any part of the argument that can be agreed with. Code defensively.
Thanks for your constructive critisism! ;-)
Could I recommend using the builder pattern instead? It can provide a much simplified solution. class Bike {/*...*/} class BikeBuilder { protected $engineSize; protected $brakes; protected $tractionControl; public function withBike(Bike $bike): self { $this-&gt;engineSize = $bike-&gt;getEngineSize(); $this-&gt;brakes = $bike-&gt;getBrakes(); $this-&gt;tractionControl = $bike-&gt;getTractionControl(); return $this; } public function withEngineSize($engineSize): self { $this-&gt;engineSize = $engineSize; return $this; } public function withBrakes($brakes): self { $this-&gt;brakes = $brakes; return $this; } public function withTractionControl($tractionControl): self { $this-&gt;tractionControl = $tractionControl; return $this; } public function build(): Bike { return new Bike($this-&gt;engineSize, $this-&gt;brakes, $this-&gt;tractionControl); } } // ... $zx10r = $bikeBuilder -&gt;withBike($zx9r) -&gt;withEngineSize(1000) -&gt;withTractionControl(true) -&gt;build();
&gt; I don't have any good solutions to this Me either. 1. Start a profitable business 2. Donate to open source projects you use Hmm. If only I could get past step one.
Can't think of anything open source globally, but related to PHP we could create a "donate" composer.json key with an output similar to the "suggest" option. This, at least, might help to spread awareness. But this should be limited to projects &gt; XX installs, activity index or whatever - and in that case it's on the packagist side to evaluate it. Just an idea, did not think it through.
Whenever the 'donate' concept is bought up, it reminds me of this thread on HN by patio11. Short is that it's almost impossible for companies (outside of the owners) to donate money, but most engineers can comfortably expense several thousand a year if it's invoiceable. &gt; We don't donate to OSS software which we use, because we're legally not allowed to. I routinely send key projects, particularly smaller projects, a request to quote me a commercial license of their project, with the explanation that I would accept a quote of $1,000 and that the commercial license can be their existing OSS license plus an invoice. &gt; My books suggest we've spent $3k on this in 2015. My bookkeeper, accountant, and the IRS/NTA are united on this issue: they don't care whether a software license is OSS or not. A $1k invoice is a $1k invoice; as a software company, I have virtually carte blanche to expense any software I think is reasonably required, and I think our OSS is reasonably required. &gt; I would do this more often if OSS projects made it easier for me to do so. Getting me to pay $1,000 for software is easy; committing me to doing lots of admin work over the course of a week is less easy. Take a look at what e.g. http://sidekiq.org/ , which is an OSS project with a commercial model, does. Two clicks gets me to a credit card form. If I actually used Sidekiq, Mike would have had my credit card on file the day that form went up.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
My blogger Questions and Answers http://www.allinonescript.com/search/label/PHP
Supposed source for those interested: https://news.ycombinator.com/item?id=10863939.
Can you expand on why a mutable generator itself is bad? A builder doesn't need to be fluent but it does need to be mutable by definition. It's how the pattern works. There are some strong advantages to using a builder here. - Type hinting and static analysis are available - Code is greatly simplified making it easier to learn and debug - Separation of concerns for generators and data objects I'd also add that I tend to use data objects over arrays as much as possible. I find using arrays as data structures easily leads to a quagmire of type checking.
I've recently got into [OpenCollective](https://opencollective.com/) and started funding projects that way. Full transparency of how funds are used. You can do a one-off, monthly, or yearly reoccurring payments, processed through Stripe. Perhaps this platform will help companies sway their mind to supporting projects. 
Wanting to know what is the best way to start learning PHP. Website then embed from there ?Or is PHP used in other ways for a complete novice to start to learn and understand PHP
Honestly this is crap. Bad code and bad practices.
I like the [SQLite](https://sqlite.org/prosupport.html) version. The "SQLite License" option is interesting, because SQLite is already in the public domain. But for $6000 you can also get a signed [piece of paper](http://www.hwaci.com/sw/sqlite/sample_license.html) that states that it is indeed in public domain.
In such a situation I prefer to perform authorization checks at the application layer. That way you can secure each business function independent of the method that was used to access it.
Objects are not passed at all - their identifiers are (passed by value)
Haha this is brilliant!
Does this mean they can eventually "merge" Symfony and Silex? (then they have less maintenance since they don't need to maintain both Silex providers and Symfony bundles)
That's kinda how I'm seeing it, too.
JavaScript is crushing everything right now. I still use php for writing web services because Laravel makes it easy and performs well enough.
"let's build this in node with mongo" the youngsters just want to use the latest grill without knowing what they're doing
But I. Why would you create a table and then immediately alter it. 
This is not for a person to use on a production site, this is just for a beginner to understand how the login system works. And if someone takes Symfony to understand the login system, he will spend a couple of days at least to understand it. 
That's a quick one to insert a user for testing, not really intended to use anywhere
I think PHP's market share will decline slightly as developers move into other, newer languages. But I don't see the PHP ecosystem itself declining anytime soon. Look at the Packagist stats: https://packagist.org/statistics The number of available packages and releases is constantly growing - there's no stagnation or decline. As you've noted, PHP 7.x has introduced major improvements to the language, and that momentum is continuing. Major frameworks and projects like Symfony and Laravel are gearing up for future major versions with significant improvements. It seems there are more PHP conferences and meetups than ever before. Based on all of this, I'd argue that PHP is not stagnating or declining. I can't predict how long this will continue for, but I think it's safe to say that PHP will continue to be relevant for many more years.
I wish I had only a half of your expertise in throwing the shit on the fan.
Things have changed there. They have at least one full time best practices Hitler now.
&gt; The fact that I open a node_modules directly and see thousands of folders, each with tiny little javascript files inside is a massive red flag. I've been messing with React using create-react-app and node_modules is over 19k files and almost 100mb. I installed a different front-end js package the other day and it was over 50k files and 600mb. Insane.
Thanks for sharing!
I own a company that provides SaaS products. We have the talent/capacity to build out products/services in Node or PHP. It can really depend on the project/product/service you are building, in-house talent, etc... but for us, with both as an option, PHP (7 in particular) is the proper choice.
Learn go yes, but why stop using php? There is still a lot of stuff have to handle yourself (this list is decreasing everyday). You can quickly knock up a few static routes in go and kill anything written in php but anything complex will need extra work to make use of concurrency and if you don't know what your doing your application is going to run worse than it would if you did it in php. Not sure why you are comparing SQL to NoSQL - oranges to apples. For a start noSQL doesn't have transactions so if data integrity is a big deal then noSQL is out. 
I installed a clean php Symfony framework project. The vendor directory has 9000 files, 130MB. Is that insane also? Personally, I don't really care about the number of supporting files as long as they stay invisible. That is why we have package managers.
Whenever everyone in the PHP world wants to move forward but the framework stagnates because the framework authors don't. See what happened to EllisLab and CodeIgniter; Laravel *literally* exists because of this. Seeing Taylor's plans for Laravel 5.5 (and beyond), I have high hopes that Laravel will keep being a prominent framework in the PHP community for years to come. Same reason why Symfony is still going strong after 11+ years. The PHP world isn't standing still and they know it. &gt; Genuine question, not a flame You might want to consider a less provocative thread title next time.
I am not particularly a fan of Laravel or Taylor Otwell, but this thread is absolutely intended to be inflammatory and does not belong here.
Sorry but you should spend more time and write a multi-part tutorial which includes better practices. Lazy tutorials like this just poison the ecosystem.
And any variation thereof.
True, the second performance does become an issue it's easier/cheaper to just throw additional servers at it.
&gt; IMHO PHP needs async/await ASAP to avoid losing too much to node. This. PHP is also a pain for scheduling and distributing work. Languages like Go and Elixir come out of the box with an easy way to spawn up long running jobs. With PHP you have to set up something like Supervisor and that gets messy/annoying to scale.
Drupal 8 is kicking ass.
&gt; The problem is porting or replacing our codebase Tech is changing so fast that any application of decent size is going to have aspects that are passe by the time it is ready for production. The best thing you can do in that respect is choose tech that has shown it has staying power, like PHP. I think you would be much more exposed going with one of these flavor-of-the-month languages, even if today it seems to be the hottest thing.
I agree with most of what you said, but the biggest issue is: &gt; PHP developers are available everywhere I think that's not true. It's really hard to find a good PHP developer. We have interviewed so many that write procedural code, think frameworks are the devil, don't know security at all, use deprecated functions, have never touched virtual machines, used deployment software or written unit tests. Yet they say they are a senior level and demand a 6 figure salary. That's where PHP gets a bad rap from. Yes they will say they get work done, but I'd be terrified to let them touch our code base. Besides that, learn as many languages as you can. Years ago, I'd want to write everything with PHP. Now I only find I use it for APIs and some I even write now in Go because of the response time, easier scalability and cost. We recently replaced our front facing API in PHP (PHP7 written in Slim) with one in Go and we went from using ~50 ec2 instances at peak to 6. 
That's not half as bad as the asynchronous callbacks. I'm working on a project now where someone didn't know Node when he started on the project, and he was the only developer, and there's one place where he literally passes a callback through 14 functions.
the money is definitely not in javascript. If you want money you learn cobol, abap, hell even java devs earn more than php or javascript devs.
What about pthreads? If multithreading is what's needed, PHP can already do that pretty well.
I'd say it's fair to say it's losing relative market share, but it's in no way dying. 
OS threads are expensive. You can also use http://reactphp.org/ for example, but that doesn't replace a native implementation IMHO.
So you don't give a shit about the quality of the underlying libraries, you just want them to work and deliver the end result they promise? You sound exactly like my project manager. And I don't mean that as a compliment.
That's basically my opinion. I think JavaScript is probably the fist language to come around in a while that will really eat in to PHP's market share, since it shares the same advantage of a low barrier of entry with a community highly geared towards to the web as as a central focus. But JavaScript has enough of it's own flaws that I personally believe that as far as back-end servers go it'll settle down as bigger than RoR or Django, but not quite threatening PHP. I think it'll continue strong as a front-end language, with Node.JS as more of a slightly larger niche. There's been some really nice improvements in the language and ecosystem, but most of them are most suited for front-end in my opinion. I think that PHP and JS will simply learn to co-exist, sharing the same space for a while.
According to your own benchmark site: - Ok, PHP is slower than Go - But PHP is still faster than Python, Ruby and sometimes Node.js Your comparison is interpreted against compiled, not PHP vs Go.
I imagine I'll get downvoted, but PHP seems to have just grown complicated. (Not just complicated, but more complicated than other platforms). A big advantage of PHP, back in the day, was that you could just upload PHP to the server, and not have to worry about anything else. No building. No dependency problems. No restarting of servers. No web server/database to run locally. No environmental differences to worry about. You didn't even need a local installation of PHP. You could get started with server-file access and IDE (well, the IDE wasn't really required). Now-a-days, not only is that development pretty much impossible/discouraged, but it reveals how complicated a PHP development environment actually is, compared to other platforms. In comparison to Python, Node, Go, and Rust; modern PHP: * Does not have proper installers for common desktop systems (pkg and msi). * Does not have a bundled dependency manager (installation is separate, and per-project) * Low documentation for using the built in web server (often suggesting Homestead, instead). * Frameworks suggest installing their *own* installers, in addition to composer/php. * Rather frequent breaking changes, at the language level Other development environments require less setup, fewer system dependencies, fewer random scripts to run, and offer better compatibility between versions. I love PHP, but by the time we have a good deployment practice and environment set up for modern PHP-- there aren't many advantages anymore. It just makes sense to use something else (faster, more consistent, less breaking changes, more tooling). The number of reasons to use PHP over anything else seems to be dwindling.
I would agree. I'm a web host and I continue to use PHP for my LAMP servers because it's streamlined to install and requires minimal effort to configure and maintain it. I'll switch when something better comes along, but that hasn't happened for me yet.
There was a time when I wrote Flash AS3 8 hours a day and built some really cool interfaces, then Flash died and I moved the fuck on. These are all just tools - so do yourself a favor and learn how to step back and look at a project for what it really is, then pick the right tool for the job. Personally, I love seeing new languages and techniques because it challenges what we think we know. It's that science part of computer science that so many people skipped over during their bootcamp to become a web dev as fast as possible. You should be aware of lots of different languages and lots of different methods for solving problems. I love PHP and how great it is for creating an MVP, but I will drop it in a millisecond when something better emerges. For now "better" hasn't shown itself so I'll continue supporting PHP and the developers that make it better.
I don't know if you understand how ironic this whole comment reads. This is why most successful companies don't have a business model where they give out all the goods for free and expect people will give them money back with zero incentive. 
Just updated that script :)
Absolutely. It's no doubt the biggest problem with PHP. But it's up to the lead developers to A.) Set hiring standards in the industry and B.) For the experienced in the community to continue pushing PHP standards. Unfortunately there's no nuke button to blast all the old tutorials off the inter webs. 
You are close with the number of files, but way of on the size: It's 7386 files and 48 MB. &gt; ➜ ~ symfony new test &gt; &gt; .... &gt; &gt; ✔ Symfony 3.2.4 was successfully installed. Now you can: &gt; ... &gt; &gt; ➜ ~ du -ksh test/vendor &gt; 48M test/vendor &gt; &gt; ➜ ~ find test/vendor -type f |wc -l &gt; 7386 
[removed]
So a bad piece of code discredits JS/Node? 
Most frameworks come with a job schedule and a Queue built in but I do agree that having that in the core language would be awesome.
You forgot /s.
FTW , Closures wrapped in closures wrapped in closures wrapped in closures.
*checks my bank statement* Nope, it's still alive.
Still a better love story than class inheritance. It's easier to conceptualize if you think of every exported function which returns an object literal as a class constructor and each of its parameters as one of that object's private member variables.
There are a lot of packages in the standard library.. Much more than you would ever need but the language is kind of boring.. I have written enough for loops to last me a lifetime in the past 2 months.
Have you seriously worked with PHP for the last 15 years, and you and that acquaintance of yours are asking this question? You got to be kidding me. Yes, PHP has a future for another 15 years. I'm sorry, but questions like this just shows how many incompetent "PHP developers" there are and why we get so much shit from other clueless developers. 
How is that related to the topic at hand?
In my opinion, this plug&amp;play mentality promotes laziness and breeds bad programmers. We've seen the results of it in the past with the whole left-pad drama and npm packages like isArray. Frameworks and libraries are great, but using them blindly without understanding them is just bad practice imo. 
Well, no i'm serious. I mean if you're a really strong ux developer, with strong javascript and css skills and you need a simple backend CRUD system, node.js would be a great solution w/o having to learn python or php. Of course the BETTER solution would be to actually go ahead and learn an actual backend language.
At the Bleeding Edge Web Tech meetup here in town everyone has a hard-on for Node.js. But the truth is, Node.js sucks donkey dick compared to PHP. For example... hello, world in PHP: hello, world hello, world in Node.js: // Load the http module to create an http server. var http = require('http'); // Configure our HTTP server to respond with Hello World to all requests. var server = http.createServer(function (request, response) { response.writeHead(200, {"Content-Type": "text/plain"}); response.end("Hello World\n"); }); // Listen on port 8000, IP defaults to 127.0.0.1 server.listen(8000); // Put a friendly message on the terminal console.log("Server running at http://127.0.0.1:8000/"); Why anyone would want to use Node.js over PHP is mind boggling to me. If a language's hello, world is 4 times more complicated than your current language, I've found that everything else is going to be 4 times as complicated as hello. And that's what I have to say about that.
Make PHP Great Again
The paying for membership is another one. Eg Linux Foundation: https://www.linuxfoundation.org/members/join (has membership for both individuals and corporations)
&gt; Now-a-days, not only is that development pretty much impossible Not even close. It's exactly as you described it - just upload a file and it works. Yes doing it that way is discouraged - for good reasons - but most other languages are still not that easy. &gt; Rather frequent breaking changes, at the language level Patently false 
The behavior you're describing is only typical for amateurs and incompetent professionals. The developer world has plenty of those, because a college degree is not required for you to start programming, and then a degree itself is not a guarantee that you know what you're doing in practice. This means that doing what seems popular right now, is a sure-fire way to follow the newbies in their OCD-driven adventure to finding the mythical silver bullet.
I keep hearing this argument, but I cant seem to find any positions in my local area for COBOL devs. Or at least ones with 3 years of experience. Indeed has less than 200 jobs in all of California for COBOL developers. 
Hey, in the industry it's called 'result oriented'.
What I'm saying is, PHP is presented as an old purple elephant, no wonder people think it's going to die. PHP new versions with improvements should be highlighted and presented in a more attractive, modern way. The main website should be improved etc. It's a small thing but it's what makes the feeling. Just my opinion though.
One thing that keeps bugging me about the `with*` notation is that you lose expressiveness in the different ways the clone will be mutated. Setters are not the only kind of mutation methods: setFoo($foo) addFoo($foo) removeFoo($foo) pushFoo($foo) shiftFoo($foo) How would those look in `with*` notation: withFoo($foo) withFoo($foo) withoutFoo($foo) withFoo($foo) withFoo($foo) I mean... that's not clear at all.
"Smart" is different than "experienced" and it's different than "professional". Being smart can help you deal with high complexity, it can help you learn new things quickly. You can still be absolutely terrible at making good decisions for projects, because you think your job assignment is your personal playground to experiment on and try things. One can't learn to be "smart". But they can gain experience and can learn how to act professionally.
It takes all of 15 minutes to set up a new php web server. Even if it didn't most simple hosts come with it pre installed and ready to go. Many UVPS providers also provide one click setups.
That is why I offer commercial licenses for the projects I publish through my employer (free license: GPL, commercial license: MIT). Guess how many takers I've gotten in two years? Zero. Patio11's ideas are good in theory, but reality isn't so simple.
Any dev shop considering a CMS for client work who does not first consider the maintainability by the client of the CMS they choose has the wrong priorities.
Yes. I'm aware of this. Others aren't. That's what I'm saying. Node is deceptively difficult, especially for those who already code in JS.
Well, I think that Silex is still good for (small) things like "write and forget" (and maybe fix some bugs in future) - usually some simple API etc. (and that is why microframeworks exists). And if you're starting with Symfony (even micro kernel) you have it on the back of your head that someday you will add more layers to your app and you will keep on maintaining it for long time. As I understand (based on this announcement) Symfony Flex is about simpler organization of packages and other parts won't change (that's why I think Silex still has future :P).
The ones that end up mattering to the people in their circle of influence do.
Not even close. Most JS jobs are not much more than PHP jobs. Java and .Net used at most enterprise will bring in $20k-$40k more a year. If you know JS and Java... $$$. But I also second cobal. Most Cobal devs retired, but most financial apps of yesterday still run on it. I have heard of guys making Upwards of $200/hr as cobal devs.
Yep, Put a resume on LinkedIn with COBOL and switch jobs to Looking. See how many recruiters hit you up. Job boards are 10 years ago.
Then you press F12 and Chrome/FF goes... https://youtu.be/SVi3-PrQ0pY?t=28 And an hour later you go "oh, there it is".
xpost: My point is that the MEAN Stack, Django, and Ruby on Rails are all significantly more complicated than PHP. PHP is the simplest option for server side web development, second to none.
Fact is you can not make parallel requests to services with PHP. You can fuck up code way easier in PHP the way it includes stuff right into the actual context. You are leaving out all the Apache and PHP config stuff that is needed to really serve your hello world with PHP in the comparison. Node integrates natively into the OS as a process not an Apache thread. I could go on but you are right. In the rare case someone needs a quick hello world as a website I would also choose PHP. 
"consider using a ~~**using**~~ logger for screen output"
&gt; I've also seen this in guys that are extremely smart, no doubt about that. And handle coding far deeper than I am able to, and in more languages. They are still highly attracted to the new, things that are maybe looking to change the world but haven't done any of that yet. Immature technologies. Beats me why. I know what you mean. I've always put it down to a personality thing, perhaps it's some kind of blind optimism. A new stack offers hope (fix all the legacy problems), but an old stack offers confidence (tried and true) - these people are presumably chasing hope. Until experience breaks them and destroys their hope (if ever), they'll simply continue jumping from stack to stack (or they'll find the *perfect* stack, except such a beast will never exist).
Drupal is a joke, and not a funny one.
Fixed. Thanks!
As someone who started with PHP in 1999, this sounds incredibly familiar. HTML guys saw PHP as an extension of HTML, putting it in *their* wheelhouse. I kindof see it playing out similarly from another angle as well. PHP was an open-ended language that you could use creatively. We've since embraced the frameworks that watered it down and made a correct way of doing things. To me, PHP is now no different than C# or Java. It's gotten so much better, but it's boring now. When I code in Node, it feels like the early PHP days where I have to figure things out and get creative with how I use the language. Anyway, I think both languages have similarities in their beginnings, and being simple and accessible on the surface is a prime example.
&gt; Yes doing it that way is discouraged - for good reasons - but most other languages are still not that easy. The encouraged ways are more complicated than other languages-- unless you want to shun composer and the likes. &gt; Patently false Might I point you to the "Incompatible Changes" section in every minor PHP release? As the guy yelling at people to upgrade their shit, I can't disagree more.
*dying or declining* - not dead.
Today I learn, and yeah I read about cobol and financing applications. Less dev's and they need to keep maintenance which probs means you could get more depending on who contracts you :). No plans to learn cobol anytime soon though lol.
There's one-click installers for the other platforms as well-- and they'll be far easier to get a development environment set up, than PHP is. The barrier to entry, for "good" PHP, is much higher than it was 10 years ago. At the moment, I'd say its higher than the other platforms. You can get a good Go/Python/Ruby deployment going for less effort, and with more benefits than you can with PHP. It doesn't *have* to be that way, but that's just the way its become. 
Have you tried the PHP subreddit?
https://Meetup.com r/programmingbuddies
I use Vue on my non Node projects even. Vue basically changed everything for me when it comes to front end design. I don't render it server side yet though. Mostly pass the data over websockets. 
I can't think of any at the moment but you can google or talk to devs in your area.
Another thing that works for me is talking through the process with someone or some thing, even if it's in-animate. It's called rubber duck debugging 
This is my approach. My main stack at work is Django centric, but support and secondary parts of the ecosystem (well, my little part of the ecosystem) are written in whatever stack I want (though there is an unspoken ban on malbolge). I tend to stick with Python as that's what I'm best at by far, but hey SOAP is a solved thing, let's use asyncio. 
Of course, nobody does that. They all pull enough more than enough complicated PHP framework code to rival anything from any other platform. 
PHP has never been better but PHP has never been less relevant. I honestly don't see that turning around. PHP is on a very long and very slow decline.
I perform percussive maintenance on my system. 
Where is 'round here may I ask?
I don't think I spoke about time to get running. I mentioned the lack of polished installers, things the installer doesn't include, how the tooling makes deployments more complicated, how its increasingly common for frames to require their own commands to start-- rather than just use composer/standard php tools, how there's a lot of different components you need to get working correctly to even get started. Compared to other environments where you use the standard tooling to get started, and then you not only have a (development) web server running on basic framework code, but you probably also have a clear path to SASS/Typescript/etc; deploying with the same tools, and more. What do you do, for PHP deployment? How does that compare to how you think deployment should be?
Not contributing here as I am new to PHP and programming in general (4 months since I start learning from scratch), but thanks for bringing this up as I learn a lot in this
Go is a relatively new language. If an when php dies, something better than Go will be out :)
Processing a 2GB file I would probably choose R. Thankfully I have been able to trim my tools down to Node, R, and PHP. PHP still is a great way to make money quickly for small projects. Large projects too, I just have been under contract for years with a client so am hesitant taking on large projects due to time constraints. 
apt-get install php7.0 git php7.0-curl cd /var/www mkdir project cd project curl -sS https://getcomposer.org/installer | php Pretty much it.
Yep! Saying it out loud works wonders. 
Depending on how much I can't figure it out I'll either not be able to sleep or I'll sleep really lightly while my brain goes on autopilot and works on it in a very convoluted way that makes sense until I wake up and realize it was all nonsense.
Fuck it, why not just go to C, its way quicker than GO... or ASM!! Perhaps PHP is just a better web utility?
What you say is correct, and it's not what I meant. To many times developers suggest to use certain technologies to their clients or employers because of "their" interest in that certain technology regardless if that choice actually helps their client or employer. E.g. I'm currently salvaging a project in which a previous dev decided it was a good idea to use Parse as a database backend when obviously a MySQL database would have been perfectly suitable. That's what I mean with subsidised hobby, dev's using a project or problem they are solving on the behalf of someone else as an opportunity to tinker with the things "they" find interesting. I should have been more clear and I'm not suggesting that PHP is the best solution all the time. I also use NodeJS where it makes sense, e.g. websockets and smart proxies but I'm not going to build business applications in it. 
If you stumble across anything, I would greatly appreciate the info! ;)
That's true. If you start using frameworks and whatnot, you might as well use Ruby on Rails or the MEAN Stack or something.
Yeah that's a pretty bad attitude to have. "I wrote code back when it was super hard! Now kids just have to use a framework and it does it all for them, what losers!"
The reason PHP is in a good state right now is because of the frameworks, libraries and composer. It's 2017, unless you are writing a small script or a very small website, you *should* be using a framework.
rubber ducking and walking is best
I haven't had it happen in a long time. Probably cause I don't care about things so much anymore.
How so
And because you suck at it, sorry you couldn't get over the learning curve and Sorry I am not mentioning mongo/rust/mustache/angulanode (insert hip framework here) https://www.reddit.com/r/drupal/comments/2aok5w/why_do_other_devs_love_to_hate_drupal_especially/ go ahead take twice as long to write your crappy custom CMS, reinvent the wheel while you're at it. Be proud after too that no one can maintain it. 
With downvotes already, I don't have high hopes for him.
I also met him in person several times and worked with him together on a project. He's a very nice guy to talk to / be with. ;)
If I do that I usually wake up in the night with the problem and the internal iPod fighting for attention.
I'm a C# programmer and several months ago started to write a web app for personal use in PHP. One of the biggest advantages of PHP I found is - PHP is scripting language. I have a feeling I would never achieve same speed of development in C#.
Too often a simple solution is hidden by your consciousness assuming a complex solution. Sleeping on it helps get all that crap out of the way, so the blocks kinda just fall into place on their own (if you get me). 
That's simillar way I go to for solve things that aren't coming up instantly. For example: When I need 1-5 minutes to think and still can't find a solution, I will simply do something completly else.. Youtube.. Reddit.. 9gag etc. and then come back. If you activly thinking on something, your brain is working much slower than usual. If start thinking and then stop doing it.. your brain will automatically do the rest for you with a way higher speed that you could archieve. I also trained my self in the past years, that I will allow EVERY theory.. no matter how STUPID it is. Problem: I want to put the Square into the Sphere whole. It can't because the form doesn't fit into. 1. How about.. cuttin the square into an sphere. ("Dude what? Are you stup- .. wait,.. actually that is possible") Well this of course doesn't go always good. You will ofc ask a lot of bullshit questions. As an IT guy, I have to ask EVERY question, no matter how obvious/self-evident something is.. often the most stupid things are the solution to the problems. It can lead that some people not taking you for serious, but when you just drop the perfect solution for something pretty hard, everyone is like "Dude, wow! Holy shit, I am stunned! Awesome idea!". I for myself see that as following: You are in a room with bunch of persons that can think too.. you won't be such a bigger advantage if you just think like them.. that won't speed up things by a big amount. But if you split and do the thinking about the unnatural things.. you can be way more effective! Either someone else finds a "normal" solution or the problem is harder than you think and the solutions that are uncommon are the right way, where you will success. Actually that helps a lot. The normal solutions are found easily by your self, but start "thinking different" (and I don't mean the Apple way!), you will find more quality solutions!
I've had a loooooot of experience with Apache/PHP and only a little with nginx/php-fpm in a dockerized environment, and I've definitely found that nginx is simpler, I like the config file more and generally just makes more sense. However, if I was asked to deploy a large application and maintain it, I'd probably use Apache just because of my familiarity with it and I know I can make it do what I want, whereas with nginx the first time it falls down I would be Googling the error messages. Honestly I would go with whatever you're more comfortable with. They both can scale quite well and if you're using a cdn there is a lot you don't have to worry about. 
Eek my inner grammar nazi is screaming. 
Too long :-(
Walking always helps me, though I sometimes find myself forgetting the solution by the time I get back to a computer. I get too distracted by the walk.
If this is not a spam.....
If you don't care for your money, then well, make it Apache for more load to balance and to pay for
In the age of composer, this site has no reason to exist anymore. &gt;This website has a lot of awesome class I disagree, or at least, the good ones exists on composer too.
Just let it die.
IMHO, php_fpm has a lot of config/tuning which I'd like to avoid.
Dont scale, cache. You need to give more info on the type of site, resource demands, caching that will be in use etc. Short of a site that cant be cached (heavy logged in use for forums of something like that) you can handle stupid traffic with nginx +php-fpm+varnish
About php code itself - pretty much no difference if you will use apache with mod_php or nginx with php-fpm. But nginx improves really much static files requests.
Just remove any way to connect your database remote and allow only connection from local, then even if someone would have password and login it will be useless.
I don't like this annotation, there will be option to just extends something like ActiveRecord?
That's horrible. Brings back some bad memories from my codeigniter days... A controller should only control things, not do any application logic. Usually that comes down to passing the input to a service, getting a response from the service and then returning it in the appropriate format (like HTML or JSON). So in your case you want to move all the application logic (validation etc) into an application layer service and then the domain/business logic (your "models" etc) into its own separate layer. But honestly I wouldn't even know where to start with refactoring that with codeigniter. That frameworks is one big mess. If you can, see if you can find a way to use plain old PHP classes for your services and use those in the controller.
"Smart" for me has always seemed like the pitfall where you can spend an entire day working on the perfect solution for a single problem, while the slower guy across the room has implemented a "just good enough" solution to five. The one thing I learned which helped me with efficiency greatly is knowing when to leave the smarts at the door and do "what works".
That was always my problem. Though I general do give in and do it or I have trouble sleeping again.
\&gt;debug \&gt;production server ಠ_ಠ
You need to work on organisation, this code is very untidy and difficult to read but the good thing is it's something that will come with time, experience and study. Get your employer to buy you this: https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882 It focuses on Java examples but it really is a fantastic book on how to write cleaner and more self-documenting code.
An alternative, if you can't get hold of a copy of a book would be to go on GitHub and read the code for some open-source software. I'd suggest Monolog or Symfony's code: https://github.com/Seldaek/monolog https://github.com/symfony/symfony Symfony is fairly complex, but you don't need to understand what it's doing, you just need to see the coding style. Take a look through at how small each method is (though the odd one is rather large), everything has a single responsibility, method names are descriptive.
Life :)
Just a word of advice/caution about looking forward to a promotion in a company where the manager doesn't know about git: don't look to climb the ladder in this kind of company. Record all the improvements you made, deprecated code you've refactored, things you've implemented (like git) and then move on after a year or two. My company is having a hard time finding jr php devs and we pay top dollar, the place you work for doesn't sound like it has a solid dev team in place and therefore will not have good growth prospects / will not pull in investors.
You'll get help/advice here but it is hard to do anything with so little information. Is this some fun personal project or are you selling lawn mowers? One of those will bore most people away. I'm sure you'll find some people willing to contribute here
I'd say Apache is fine if that's what you prefer... as long as you aren't using htacess. It's really slow. I started out with Apache but I use nginx for everything nowadays. Apache has since caught up performance wise as long as you set it up properly. But it's still much easier to get nginx set up optimally than Apache if you have no experience with either.
It's the same process I have when I try to remember a word. I'd think of what the word is about and ask someone "do you know the word that describes blah" and right before I finish describing the word I was thinking it just instantly pops in my head, it's weird. Works though.
yeah, this one's weird. I dreamt a solution once and woke up instantly to write it down. Then slept like a baby. I don't have those too often, but man when you have them it's so relieving 
Sometimes we have weird issues on production. It is very hard to debug what is wrong especially when your application is connected to few others and you have not impact what is going on inside others. Sometimes is just easier to make snapshot of current variables and store them in database.
I needed to store easy to read dump of variable without browser (without html) to read it later, VarDumper from Symfony is very cool, but it wasn't good in my case
My cats don't speak but they have all been great problem solvers.
&gt; this would be better done in separate classes rather than in the controller. Where would the separate classes go? Into a library?
Derek Banas is great too! Check him out on Youtube
We're using PHP to replace a lot of things like classic ASP, Oracle Reports and Crystal Reports -- I don't think it's going anywhere soon.
You've linked me to a code example that is massively downvoted and 5 years old. Way to make a weak, irrelevant point...
100% Nginx with PHP FPM. I understand that you're going to auto scale but you're doing things for performance reasons so you should choose a more performant solution.
While old tutorials are one of the bigger problems, I think it's a necessary side-effect of the biggest *advantage* of PHP. People talk about PHP's low barrier of entry as a bad thing, but realistically it's probably one of the only reasons PHP got so massive to begin with. It's why PHP is what it is, and it's why it'll continue to be so great. It's what makes it so easy for businesses to start in PHP, for new projects and new websites to sprout up in PHP. The downside of that is that you'll always have a large section of low-skill developers who don't know how to address security concerns, or how to spot that there are concerns in the first place. And those low skilled developers will write tutorials, answer questions, help others and generally contribute. This may be bad, but that's what people do. I don't believe that you can have the low barrier of entry without the deluge of lower quality code and tutorials. And I don't believe PHP would be half as good as it is without the low barrier of entry.
I haven't had to do much tuning at all. I run the default conf and it runs just as well as, if not better than, apache+mod_php.
My favorite parts: - [no more bootstrap file](https://tldrify.com/mre), and no more bundles (at least, no more forcing you to use them - recommended structure will be bundle-less apps).
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
https://hastebin.com/hurizevimu.cs
The bootstrap file was very useful before php7.0 era but after 7.0 it's just unnecessary. And from previous blogpost we know that Symfony 4.0 will require PHP &gt;= 7.0. So probably that's why it's being just removed.
Yea, which is why no one uses active record any more.
Sorry, no meme posts. While most senior devs are fans of Sebastian, please try to post something with a little more meat to it.
Local meetups, or join us on Freenode #phpmentoring
&gt; This is an unfair comparison. Programs written to perform the same tasks, using different language implementations, were measured in the same way and the measurements compared. You say that is "unfair" but instead of giving some reason why that might be "unfair", you explain why the difference in the measurements is **unsurprising**. &gt; PHP is "slow" if you make it slow. Please show that those PHP programs are *being made slow* -- that sounds unfair.
Yeah, basically as I've understood you'll have an "App" namespace of some sort where your application code will live in.
&gt; we're comparing different things We're comparing the run times of different programs, written to solve the same tasks using different programming language implementations, on the same computer and operating system.
https://github.com/symfony/symfony/issues/20668 tl;dr composer optimised autoloader, opcache and 7.0 speed makes bootstrap cache obsolete.
I'd go with php-fpm over mod_php. Although mod_php is often faster, php-fpm will let you scale your app runtime (PHP) more independently of the webserver. Ie, your demand to serve static assets &amp; whatever else you're doing with apache or nginx isn't going to need to grow at the same rate as your PHP runtime demand. Apache vs nginx; they're both very capable. I've recently been leaning on nginx more lately - but there isn't really a right or wrong answer. My own decision making on this is generally; use nginx until I need to do something that it can't do, then swap to apache. I've never swapped from nginx to apache. 
I guess it's a good thing that bitching and whining solves that problem. The application doesn't need to run as long as it's someone else's fault. Smart thinking. /S
It was a little discouraging for sure. I knew the target audience was going to be Java and .NET developers so I geared the entire talk to cater to that demographic. It was also my first talk but I kept my cool and actually cracked a joke about it.
Thanks, that is really interesting! 
There's many Bulletin Boards on GitHub (check their license though): https://github.com/search?l=PHP&amp;q=bulletin+board&amp;type=Repositories&amp;utf8=%E2%9C%93 When you say "chat" do you mean voice or text chat?
I love those mornings.
Thanks for that!
Apache is easier to setup, although Nginx isn't that much more difficult. Nginx is faster but Apache can be just as fast, you just have to configure it to be so. Also, disabling .htaccess in Apache can make it faster as well. Do all the configuration in the apache config.
Hm, an interesting question! I would probably stick with `add() ` and `subtract()` in this instance for clarity, as you would say: &gt;10 multiplied by 5 &gt;10 divided by 5 &gt;10 add 5 &gt;10 subtract 5 Definitely not `addedBy()`. 
its currently like a very decomposed zombie.
You are looking in the wrong array -- in your code, $users is an array of $user arrays, not an array of user names. $users = [ ['userName' =&gt; 'clau'] ];
Oh yeah, there is certainly a upper limit on thinking clearly with the human mind. Many many many times I've had trouble figuring something out only to sleep and see how dumb I was the previous night. This applies to everything in life, so remember when you are tired not to make any logical decisions that have an impact on your life.
There isnt significant difference between the two versions, PHP 7 adds some nice new features but doesnt introduce much breaking changes from PHP 5. For 99% of the time, whatever works on PHP 5 should still work on PHP 7. I would recommend that you practice/learn with PHP 7 already, even if PHP 5 is still more widely used where you live. PHP 7 is the future, major frameworks such as Symfony and Laravel will only support PHP 7 in next major releases. Just be aware of what features are exclusive in PHP 7 and you will be fine. 
Just make sure that the version it's going off of is at least 5.5. If it's like 5.2 that's literally 10+ years old. There isn't too much of a difference between 5.5 and 7.0. Also make sure you aren't learning things like mysql_ functions, etc.
It was not recommended to use bundle like structure for application code since long ago. I have no idea why the hell people are still doing this, it just increases a number of directories you have in your path and always adds a Bundle word everywhere. Also using bundles for integrating libraries into your infrastructure instead of directly using those libraries registering them in container manually, makes it so much harder to do something that this bundle doesn't support. You have to write compiler passes almost every time this happens.
Not quite sure I understand. What is the fix?
This is one thing I miss after I quit smoking. Smoking a cigarette wound up being a mandatory break every hour or two. It's really easy to get stuck in a rut and not realize it's better to just drop it for a moment and reset your thought process. I came back from many of those 5 minute breaks with a better plan of attack than I left with.
To be fair, you get pretty decent settings out of the box with FPM. The only thing you're likely to even look at for quite a while is worker count. Agreed completely that the flexibility and tuning are necessary to maximize performance, though.
If you're just learning, I'd recommend learning on PHP 7. While most PHP 5 code will work on PHP 7 without issues, there are some important differences (most can be found on the [Backwards incompatible changes migration page](https://secure.php.net/manual/en/migration70.incompatible.php)): * Changes to error handling (many errors can now be caught like Exceptions) * Changed handling of variable variables * random_* functions make generating secure random values trivial * Several old extensions were removed, including the mysql_* functions and mcrypt. Many older tutorials that use bad practices use these extensions, so finding tutorials which teach you the newer ways of doing things will help you. Also, many libraries (which you use via Composer / Packagist) are heading towards being 7.x+ only because of the beneficial features these versions added. There are also beneficial features such as strict(er) type handling / scalar type declarations which will help you to write better code. In general you should always use the latest version of PHP if possible because there are ongoing security and bug fixes (for example, the latest version of 7.1 fixed several issues in date/time handling - because 5.6 is now in "security fixes only" phase, it will never receive these fixes)
Scaling has the same problem caching does in that if you write a shit application caching wont be a cureall. Scaling horizontally isn't easy and scaling vertically hits a limit pretty quickly. In an "im a newbie help" type situation caching is the best bang for your buck. OP Cant even give enough information to give a reasonable answer, thinking they can manage multiple servers is a stretch. They just asked "wut type of vehicle do I need to use to move stuff?"
Var dump is the classic way of debugging. Why not to use Xdebug debugger instead? I do it all the time, even on production or clone live environment with just Xdebug installed. I can't imagine using var_dump anymore. 
Not really. [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) states it's a superset of [PSR-1](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md), which contains: &gt; Class names MUST be declared in StudlyCaps. Which they are clearly not following.
I agree that it appears OP is in over their head here, but still feel that caching is going off in the wrong direction. Granted, I don't think either will make a big difference in this situation, so the advice I gave is geared toward other people that may come across this thread in the future with a better idea of what they're doing. Scaling horizontally in PHP basically comes down to "don't use the local filesystem for anything other than your source files", which for most people means sessions and user uploaded files. Obviously getting into proper devops automation and cloud autoscalers is going to be way off the mark in terms of what's useful to OP, and that all says nothing for horizontally scaling the database which actually is difficult.
It's recommended for gettext to use the original language text as the translation key. It's based upon decades of good practise. What duplication has you concerned? Why? 
Heh sounds about right. Spam filter has them now :) Ruby on Rails has around 1,047 jobs posted in CA vs 130 COBOL, so its safe to say more companies are looking for Ruby on Rails devs. The higher end paying jobs are definitely the COBOL ones though. I wonder if its also the area the developer is located in? Im not in the silicon valley, just the central valley. 
I love your explanation. This is how my brain works, but it's so hard to articulate.
I use [my cat for that](https://www.quora.com/Why-are-some-programmers-obsessed-with-cats/answer/Bruno-Skvorc).
A services layer could become a library, a helper or can be a another controller. The controller way is to extend your controller class (you would do this from the /application/core/) with an additional controller that only does logic. If you do this make sure prefix your custom controller with _ so that it and its methods do not get routed. Helpers are often just a set of functions that have uses across all the MVC flow. EG I often run a debugging helper that has functions like is_folder_writeable, etc. Libraries are classes that are only active when instanced and require OOP structure.
[removed]
This. I think the idea of a "universal bundle for everything" made to Symfony more evil than good. Even the phrase "there is a bundle for that" is mostly wrong because you don't need a bundle to add a library to your app, just register the service manually. I've learned that a long time ago and in my latest projects the number of "unnecessary" packages is much less than earlier. And when you write a code which can just be a standalone library, but you call it a symfony bundle then it's just totally wrong. Who knows, but with that Flex' autodiscovery a Bundle thing may be obsolete totally. The concept will still be there, but not under the name of a bundle.
Using var_dump is a cost. As you waste your time. You can always spin up t1.micro with the same code, same configuration as your live node then you're going to reproduce the issue at almost no cost. 
&gt; with the same code, same configuration as your live node then you're going to reproduce the issue at almost no cost https://www.reddit.com/r/PHP/comments/63ky5c/lightweight_var_dumper/dfvkhbw/ https://www.reddit.com/r/PHP/comments/63ky5c/lightweight_var_dumper/dfuybmz/
I build my infrastructure on AWS Elastic Beanstalk. We were able to get our app running on PHP 7 and by default beanstalk runs Apache PHP We were able to setup a robust and scalable server infrastructure and launch it into production within a few months and there are only 2 of us webdevs. It probably is better than any AWS "do it yourself" configuration we could have built on our own in the same amount of time.
&gt; In most cases 'model layer' means 'domain logic' as well as 'storage logic'. That's the Active Record way of thinking about the world. It's also the reason why Active Record sucks for anything beyond trivial use cases. Domain logic goes in Services. Services should be decoupled from your web-tier. 
Is there a specific use case? I'm having trouble seeing one. Since we're faking a mutable collection the basic methods would be ```add``` and ```remove``` which line up nicely with ```with``` and ```without```. We don't need ```set``` since it's a collection, we don't need ```push``` since it's redundant with ```add```, and we don't need ```shift``` because the methods are generators for a new object, not returning a value.
5.5 is EOL and 5.6 is already only receiving security updates. You can learn from tutorials in 5.5 &gt; but I wouldn't recommend actually coding in anything less than 5.6.
Dries BuyTert has created a blog pots entitled Living our Values http://buytaert.net/living-our-values TLDR: Dries believes that it is encumbant upon him to ask Larry to leave because in his words "The Gorean philosophy promoted by Larry is based on the principle that women are evolutionarily predisposed to serve men and that the natural order is for men to dominate and lead." and that this is not in line with Drupal's Community values. The above statement is not validated in any way and the comments on the blog would indicate that it is in fact not true. But even if it were... There are many Christians who believe it is a womans job to serve their husband. It is taught in their bible. I think that if Dries wants to stand by his decision we should start by interrogating every member as to whether they identify as Christian and if they do, ban them from Drupal. 
You can do that but I don't think it is legal.
I've never seen this and can't seem to find it?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'll check it out. Haven't looked at AEB before. 
You should learn how to ask in the first place. If it says you shouldn't ask here, you should pay attention to that. 
&gt; it seems that it make Silex a bit redundant. Silex is redundant since symfony introduced micro-kernel trait in 2.8 
You're confused, when I say 'model' I mean different types of model not just database classes. I mean everything that encompasses storage and domain logic. &gt; The model is the central component of the pattern. It expresses the application's behavior in terms of the problem domain, independent of the user interface.[6] It directly manages the data, logic and rules of the application. This is what wikipedia says about the model, which fits my thinking more.
I will as long as you go back to trying to convince people that factual statistics are wrong ;) Have a flick through and take a look for yourself. https://w3techs.com/technologies
Ya'll gonna need some validation: https://laravel.com/docs/5.4/validation Also things like: -&gt;with('page_title','Top Questions') You should really be a section inside your views. For example: &lt;title&gt;@yield('page_title', config('app.name', 'Laravel'))&lt;/title&gt; Then inside your views: @section('page_title', 'Top Questions')
Tarantool is a NoSQL database and LUA application server. It has nothing to do with php. But if you mean php bindings for it, then yes, both pecl and pure php clients support php7: https://github.com/tarantool-php/queue/blob/master/.travis.yml#L9-L16
This isn't really a PHP question but a hardware one. It also depends on what you mean *by scale*. Even on modest/low end hardware (4 core server, 8GB ram, 200Mb/s bandwidth) you can easily achieve over 600 req/s on PHP 7. Turning on OPcaching, placing something like Varnish in front of the stack you can easily double even triple this number of HTTP requests. Is your application pushing over 2000 requests per second?
You seem to be talking not about collections in general, but a specific type of collection: a set. You can `add` and `remove` from a set, sure. But there are all kinds of collection types: list, map, multimap, set, multiset, tree, graph, stack, queue... Take a very common, for PHP, example of a multimap, a headers collection. Sometimes you need one of a header (say `Content-Type`) so then you would use `setHeader`, but sometimes you need multiple of a header (say `Set-Cookie`) so then you would use `addHeader`. You can express both as `withHeader` and have some boolean option that changes "set" to an "add" but that's clunky. Here's what PSR-7 does: withHeader() &lt;- setHeader withAddedHeader() &lt;- addHeader That's also clunky, though less so. And if the collection is a list, then you don't need `add` per se, but then `shift`, `unshift`, `push`, `pop`, `set`, `splice`, `slice` and so on all become necessary for flexible operation. Functional languages don't follow the `with` notation, they have their own terms, like `head`, and `tail`, but there is no ambiguity there, because their collections are never mutable, they might as well go with the mutable terms. I'd probably go with the mutable terms, as well, because when an object is 100% immutable, the only ambiguity is with surrounding objects, not the interface of the object itself, i.e.: $newCollection = $oldCollection-&gt;addHeader('Foo-Bar', 'Baz'); 
Thanks - that's actually quite insightful. I think I'm going to have to just do that for a certain PHP extension.....I bet it will cause some people to complain about 'principles', but principles don't put food on the table...
I work a lot with webhooks of various kinds and this is proving pretty valuable when needing to debug them. It's easy enough to spin up an Ngrok instance with a logger behind it, sure, but this makes things even simpler.
There isn't detailed information about describing a "collection of resources" in a resource, because REST is **not a spec, it's a style**. After so many years of otherwise intelligent people not being able to make the heads or tails of basic situations in REST and HTTP, I've come to the conclusion they'll never figure out what "REST" is. The title says "embedding in REST, and HTTP/2" and the article completely bypasses what HTTP/1.x has to say about this issue: https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html Ta-da collections! Need more collections? Register more mixed MIME types at IANA then! Help us keep HTTP being REST! It stopped being REST long time ago, anyway, but let's keep the illusion going. That said, most REST APIs don't bother to specify even their individual resources as MIME types, so why does it matter how they describe collections? It's all untyped JSON blobs, so it's not as if you're doing "REST", anyway. In REST content-types should be specific to the content delivered and "JSON" is not nearly specific enough. The JSON-LD (and co) schema annotations are an alternative to MIME, but most APIs don't bother to specify full schema for their responses either. We just have schema-in-the-schema situation with JSON-LD, and both schemas are incomplete and nobody bothers doing it right, unless it's JSON blobs in HTML pages, because Google reads those. So the solution that everyone uses right now and that will eventually continue to be viable is: keep returning untyped collections. People won't stop reading docs of your proprietary APIs anyway.
&gt; it's continuing to grow and mature Do you have any figures to back this? In my location its definitely not dying but its certainly in decline as far as jobs go
I am actually not a native English speaker, but I do consider myself proficient enough. My suggestions for `add()` and `subtract()` would be `addedWith()` and `subtractedWith()`. 
In cases such as these I try to build an English sentence and see what sounds best. "10 multiplyBy 3 is thisNewObject". Bad. "10 multipliedBy 3 is thisNewObject". Good. So you are onto something there. "10 add 5 is thisNewObject" ... hmmm ... sounds bad. "10 added 5 is thisNewObject". Still not great. "10 plus 5 is thisNewObject" sounds better imho. Same for substraction. Go from "substract" to "minus" and it sounds good. On the other hand you are now moving quite a bit from the interface of your mutable object, so the question is if you really want that. 
[Are you too busy to improve?](http://i.imgur.com/KcvbKTU.png) ;)
Interesting example. Thanks. It does seem like somewhat of an edge case caused by the idiosyncrasies of the HTTP spec. We end up with a data structure that's trying to be both a map and a list at the same time. It's also an example of why immutability wasn't necessarily a great fit for the Response object. &gt;And if the collection is a list, then you don't need `add` per se, but then `shift`, `unshift`, `push`, `pop`, `set`, `splice`, `slice` and so on all become necessary for flexible operation. I'm missing the connection here. Immutable objects are incompatible with functions that both mutate the data and return a value.
That's fair enough, for as long as you realise you're incurring in a great deal of technical debt you'll have to address if the product takes off. 
&gt; I'm missing the connection here. Immutable objects are incompatible with functions that both mutate the data and return a value. They're the same operations, you just refactor the "effects" as part of the return result: // Mutable version. Returns $item, removes it from $stack. $item = $stack-&gt;pop(); // Immutable version. Returns the item, and a clone of $stack without the item. [$item, $stack] = $stack-&gt;pop(); The use cases are identical. As I said, some of those operations have "functional programming"-specific terms, say the above would be `$list-&gt;tail()`. Some don't. But either way if you're using `withSomething()` convention, you can't name the operation you're doing. `withTail()` is just nonsense. My point is the `with` convention is a bad idea.
Jeffrey Way is amazing. However I suggest you to take a look at his earlier course at Tuts+. PHP fundamentals is the name. That's how I learned it. I watched the PHP practitioner series also and I think it just isn't as good. I think he delves into OOP a little too early in that series and I would not suggest that to a newcomer. 
Hello, theres not a demo yet but heres where iv been testing: https://dev.tomrouse.me/serverstats/ Thanks for your feedback im gonna look into your points!
Oh of course, I was having a brain fart and thinking the javascript console within a browser... heh. Not sure what benefit that would even have, hence my questioning!
How does this differ from Postman? Do you actually provide a public endpoint for other services to hook into?
hi, just glanced over your project there. some words of advice: * you should never use the @ for error suppression; learn why: http://www.phptherightway.com/#errors_and_exceptions * you should consider using an object instead of pulluting the main scope or use namespaces * you should consider what happens, if you do not have permissions to read /proc * and you should not hardcode &amp;nbsp; in there, guess whats happen, if i want to use it for an cli application
I thought about other postpositions, but while `addedWith()` does sound a little better than `addedBy()` to me, I felt that a native speaker wouldn't say "5 subtracted *with* 5" but rather "5 subtracted *by* 5" (which a quick google result count comparing seems to confirm). If that's the case than only `addedBy()` would be the odd one out that doesn't work for some reason.
It is pretty amazing, took a lil bit to figure out... But now that's my server infrastructure of choice, even for small projects. I can set one up in 2-4 hours. With a CI pipeline, been using codeship at work, but I don't really like codeship. I use a local Jenkins on Docker for other stuff.
Breaking it up as you did certainly helps to make the main method more readable. My advice though applies specifically to this array, and a couple others like it. All of the student-related fields are a prime example. See if you can change the createBooking method to accept this: $booking = $this-&gt;Book_model-&gt;createBooking($student, $data); This makes calling the method far easier, since: * you don't have to curate all the student fields - the model has them * the method is easier to re-use - its declaration now makes it more clear what needs to be passed in * you can do much less preparation before calling it - just load your model &amp; pass it in As a first step, the declaration can be: public function createBooking(Student_model $student, $data) {
PHP 7 is more beginner-friendly because it fixes various quirks of PHP 5 and earlier. If you choose 7 you'll be faced with less puzzling T_PAAMAYIM_NEKUDOTAYIM errors, for instance.
Some issues might only appear with a certain load.
The answer is Al Gore for the lazy
What programming experience do you have?
Honest blogging like this makes me more likely to use their services, not less. It is transparent, does not dodge responsibility, and shows they are striving to do better. In contrast, the company that runs my accounting let their SSL certificate lapse recently, the digital equivalent of forgetting to pay an electricity bill. They fixed it 17 hours after it would have first been exhibited, but as far as I can tell, there is now no honest record of it having happened, nor how they would prevent such a clumsy mistake happening again. 
Haha that poor engineer! I bet he's in the cone of shame for a week! Now he ranks amongst the pros though! He's earned his wings ;) 
Figure out a need of yours and build a tool to fill that need. It will help you stay motivated to finish it and improve it and you will learn a ton along the way. Years later you'll look back and think about how terrible the coding was, but that's just part of getting better
I may have had a different experience than most but I honestly found the performance to be the same. Yes, the same. Shitty code is shitty code (and frivolous ORM calls), and changing from php-fpm to mod_php didn't fix that. That being said, I prefer nginx style configurations. That is really the only reason I use it. I do not use it with Wordpress installations though, as the .htaccess files seem to be more prevalent there with some SEO plugins (or perhaps I'm just unlucky). But why not just cut out all the hosting to begin with and use Elastic Beanstalk and have Jenkins ship to it automatically? If it's just PHP that will work completely fine out of the box. I recommend hopping over to /r/devops for suggestions.
Only if you're sharing production data across all of your environments, which you damn well better not be doing. 
I sure like your Expert advice.
I'd guess that it'd be by writing the back end of a website or some sort of other server side application in php 
If you are learning PHP to make websites, learn HTTP and HTML first. It is totally baffling to me that beginners seem to always overlooks this. It's like learning to drive without knowing what a road is. If you have mastered that, you will be way, way ahead of your classmates. 
My experience is that sooner or later your API becomes heavily dependent on it being known *who is calling the API*. It may be for reasons of security, or safety (so you don't fire a dangerous command by accident), or for reasons of data segregation (multi-tenant architectures) and so on. But you shouldn't have an API where authentication is some afterthought, that you implement in your HTTP layer, for ex. It should be a part of your domain, deeply integrated. If you want your CLI to not require login details, you can still do that, by simply embedding a login (or better an API/user key) within your CLI shell script. I don't mean directly in the code, but through whatever configuration approach you may use for the rest of your deployment configuration. But there should always be a user IMHO. Makes things simpler and more reliable.
I've learned HTML and CSS only but I want to go a bit further and more in depth thats why i chose PHP
I learned HTML and CSS, HTTP not so much but I can try that first, thanks.
God, I can just hear the lip smacking and snark from here as you wrote this reply. You've lost my interest entirely because you just come off as rude and obnoxious. 
&gt; Within three minutes of the initial alerts, we discovered that our primary database had been deleted. Ummmmmmm that's not good.
I remember in the aftermath of Hurricane Sandy reading through the status updates from Peer1 hosting on their forum about how they had kept a bucket brigade going for what seemed like a few days since their pumps had failed and the second fuel tank in the basement was underwater so they had to manually replenish the generator on the roof by hand. Yeah... If I needed hosting that was local to New York they'd be first on my list to check out.
Human errors causing production databases to be deleted (when the goal was to reset a test database) is quickly becoming the top #1 reason for things going down in cloud services. There has to be something to make such events less likely.
No problem, and I am serious about this, learn HTTP, even if you only learn the basics really well for starters it will help you immensely.
Man, we need generics really badly.
Javascript (nodejs for serverside) is a better choice. Tou can do everything you can do with PHP, and much more, with better performance and it won't be completely abandoned by the time you learn it. I mastered it 10 years ago, but haven't used it for at least 3 years, except for maintaining some old code. 
You're right, I was fed up on the morning I wrote that. I didn't like the way in which the original comment was written and given I was already feeling irascible I reflected that in my response.
&gt; Immutable class don't need more code than that Whilst I disagree, thanks for the direct link - I can see what you're getting at. &gt; You can still hack the class with reflection to make it mutable. Immutability is impossible to achieve in PHP when you add reflection, runkit, et. al as you state. I still think it's worthwhile and important to protect people from themselves where possible, however. When someone picks up reflection to implement a task, though, they know they're pulling out the sledgehammer. It is feasible that the constructor could be called twice accidentally and I want to prevent that from happening. This is what I was calling defensive coding in an earlier comment.
you know the one thing nodejs is really really bad at? preparing you for an upcoming php-course, as stated by OP.
assuming the course you are facing is a classic basic php one and probably doesn't share the same views on best practices and modern coding standards this community largely shares, I'd recommend going for [w3schools tutorial](https://www.w3schools.com/php/default.asp). People here usually hate on it because it gives a simplified view of coding that mostly teaches practices that are more than a decade outdated. But in general that's what php-courses teach. Basic IO, loops, arrays, functions. It's probably not the best source if you want to become a perfect coder on your own, but for working ahead for a course, it's most likely exactly what you will need. If you can't set up a local environment to develop (Xampp for example), you can go to [phpfiddle](http://phpfiddle.org/) and use their online editor. It should be more than enough for your basic needs. ("code-space" register top left to enter your code. "Run F9" button to execute it. "code-space" to get back, repeat)
Sadly, many educational facilities these days are not what they should be. But I agree, building a REST service, preferably with OOPhp and implementing an API will probably get you better job offers than a bad php class. 
Yes. But that wouldn't solve this need since generics (traditionally) only applies to classes, which arrays are not. And the inevitable array-like `class TypedArray&lt;T&gt;` doesn't have array passing semantics since, as a class, it's passed by reference rather than by value, resulting in unexpected change propagation. So we *also* need structs (basically a class that passes by value instead of reference), which is what a `TypedArray` needs to be. One day...
Honestly, the best thing is probably exactly what Digital Ocean did to fix the problem. Massively restrict access to the main system, maybe requiring most engineers go through a simple request process to gain temporary access if needed. Luckily, extensive backups saved them all but a few hours of downtime, so pretty decent result regardless. Alternatively, maybe a kind of [Two-man rule](https://en.wikipedia.org/wiki/Two-man_rule) for destructive database operations which require two different people to confirm the operation?
similar with 'theplanet' back... 12 years ago? Their data center was in Texas, where a hurricane (rita?) was going through. I'd had a drive go bad, and I'd called for support. They apologized for being slow in responding (took a couple hours) and explained there was a hurricane going on, and they were operating on a skeleton crew. I was impressed.
I personally set 'exception breakpoints' for notices/warnings, but this is a cool little Chrome add-on nonetheless.
Would be nice to have non-human friendly values. For example, show the raw bytes instead of converting it. The use case would be to ship the values elsewhere at set intervals, let's say elasticsearch, so you could analyze/chart/alert based on numeric values. Lots of potential for a pretty handy utility.
&gt; At 3:20 PM EDT the primary database was completely restored, and no data was lost.
This issue is especially true of behaviour that is, thankfully, now deprecated: final class get { private $val; public function get($val) { $this-&gt;val = $val; } public function getVal() { return $this-&gt;val; } } $x = new get('test'); echo $x-&gt;getVal() . "\n"; // test echo $x-&gt;get('foo') . "\n"; // whoops - typo! echo $x-&gt;getVal() . "\n"; // foo When using the `__construct` constructor style it is less likely, but of course, still very possible without reflection: final class Get { private $val; public function __construct($val = '') { $this-&gt;val = $val; } public function getVal() { return $this-&gt;val; } } $x = new Get('test'); echo $x-&gt;getVal() . "\n"; // test $allValues = array_map(function($z) use ($x) { return $x-&gt;$z(); }, get_class_methods($x)); var_dump($x-&gt;getVal()); // string(0) "" If I am attempting to state that something is immutable I'd rather that it doesn't allow mutations - especially where it is very easily preventable. I can't do anything about someone going at an immutable with runkit, but I can prevent a double `__construct` call so I do. You're of course welcome to ignore my hints or dismiss them; that's your prerogative. I think this topic has gone as far as it can go now - it would appear you prefer a mutable masquerading as an immutable and I don't. Nothing either of us is going say looks like it will change that.
This.
You forget that : "they're absolutely no case when you need to do that." (to do that = call manually __construct) 
I'd go a bit further, even and propose array types are structural. This would allow you to accept array data from $_GET, $_POST, databases, files, and so on, and not have to "hydrate" it to typed arrays, but treat it typed in the form it already is. Typehints will then not only check an array's type (unless it's already the same), but validate and coerce any untyped (or differently typed) array to the type required, as long as it matches the same structure as required.
Large objects and recursion will own `var_dump`.
Lovely implementation! :) I think many PHP programmers have been there. Myself included. Your README could use an example of the output, though. I did a very similar implementation, but with more details and data exposed, e.g. property and method visibility (private, protected, public), and much more. Feel free to check it out and snatch bits and pieces: https://github.com/kafoso/tools There are 3 different formatters: - Plain text (good for error logs). - JSON (good for e.g. RESTful APIs). - HTML. The latter includes syntax highlighting, largely adheres to PSR-1 and PSR-2, and prevents cluttering by hiding content after a certain indentation level, which is stored in a cookie. Very good for "What the hell is going on in this class?" debugging. EDIT I see now that I got the interface in the README file wrong for the HTML dumper (copy-paste was too strong). It is, of course: `Kafoso\Tools\Debug\Dumper::dumpHtml($myLittleClass, 10)`, and not `dumpJson`.
I always feel like instead of integrating something heavy weight and complex like FOSUserBunduru or any translation Bunduru in every application, most of the time one is better off with a micro architecture having separate applications for user administration, translation and other things. Bunduru oriented programming always leads to huge monoliths and make your application seem incoherent. I also don't like the name "Bundle", it just implies heaviness. And then all the stateful lifecycle heavy loading each application needs to perform. And everything breaks with each new major or minor symfony version....
I have never had an issue with simply pressing f5...
Sorry but I can't agree on part of the point 1 and 2. It makes no sense to say "the resource is there but I can't find a record in the database". The record in the database IS the resource. My position is that thinking about the resource as the "route+controllar" system that manage a specific endpoint is a self-deception. Again, if you try to reach for a file which is not in a directory accessible in the docroot, like `GET /mydir/notexistentfile.meh`, would you return 200 since the directory and the virtualhost configuration are there, but the file is not? The application serving your resources is NOT the resource in my opinion, the database record (if that's what you are trying to reach for) is.
If the database connection is not there, it is a server error: 50x! The full stack fails to deliver the resource, the server *does not even know* if the resource is there or not. The client has to be informed of this, it may retry in a while. Giving back a 404 in that case informs the client that there is no such resource... that can be false, the resource is there but something went wrong. See the difference? 
404 means `folder/sub-folder2` as a resource representation does not exists. That's all. Don't be fooled in thinking that status codes should give deep knowledge of what's behind a request management failure or that "the subfolder is the resource"... that's why we use the term "Universal Resource Identifier": you don't have to break it down in components and grind your brain over it from a client perspective. 
I'm so glad I use a framework that is written in PHP.
Latest CE version of Docker for mac has an implementation for the `cached` flag, so this should be redundant now. Just specify `-v /your/volume:/container/path:cached` in docker-compose.yml and read performance on osxfs should greatly increase. See https://github.com/docker/for-mac/issues/77#issuecomment-292192768.
I use my browsers console to edit CSS in a live view way, then replicate the change to my code. It works quite well. Considering I write SCSS I have to wait for compile time anyway. So doing it live in the browser is much faster and I don't have to remove a bunch of dev library junk before I can commit and publish code. Eh, works for me. 
I did that just so that you could just use the folder for what ever you wanted to use normal or the auto version.
Really only the core library is written in C, its hybrid between the 2 languages which seems strange. If I need anything high performance (C is a great choice here) then look at something like KORE, there are others but KORE is my favourite. It seems silly that you like your framework in C but then write project logic in PHP
http://lmgtfy.com/?t=i&amp;q=elephpant
I added stats for `:cached`: file | docker | docker | docker | lsyncd ad-hoc | 17.03.0-ce | 17.04.0-ce | 17.04.0-ce | container | | | :cached) | ------------------------------------------------------------------------ app_dev.php | 319ms/req | 312ms/req | 84ms/req | 46ms/req app.php | 86ms/req | 83ms/req | 21ms/req | 9ms/req looks good!
Invested too many hours to get a stable environment on Docker that could be used on Linux/OSX/Windows. I tried every solution I found, including the solutions mentioned in the article references. Will have to try this one, and I hope it fixes some of the issues. Currently the best setup I had was: - Linux: just native docker, performance on shared volumes is great - OSX: Docker-machine with an NFS share (currently using dinghy, which I liked more than docker-osx-dev, and the performance was the same) - Windows: best option we found was to develop inside a VM, running Linux/Docker, and run a browser in Windows itself on a secondary monitor 
Yeah, so we've reached a definite dead end here and I don't think you're even reading my replies so this is my last.
That doesn't really make sense. You could download the auto folder and just include statsy.php if you don't want the auto features. 
Id I'm not mistaken, you still write in PHP. The code is compiled to C and loaded in the RAM so that it performs way faster then all the other frameworks. Its not that strange
There are a lot of PHP simple courses on YouTube ...You have to read books also....
Yeah I reckon this is the best way to learn most computer stuff. I find it very hard to retain stuff unless I have a reason to use it right now.
I've never really seriously used Phalcon, but what advantages does it have? It doesn't make PHP faster, just the framework components itself. It obvious it doesn't have as many features as something like Symfony, but I'd be curious on a benchmark of Phalcon vs just a DIY "framework" just grabbing say FastRoute, DBAL, Twig and a lightweight container.
 &lt;?php foreach ($xml-&gt;channel-&gt;item as $news) { ?&gt; &lt;article&gt; &lt;a href="#"&gt;&lt;img src="&lt;?php echo $news-&gt;children('media', true)-&gt;content['url']; ?&gt;" alt=""/&gt;&lt;/a&gt; &lt;h1&gt;&lt;?php echo $news-&gt;title; ?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $news-&gt;description; ?&gt;&lt;/p&gt; &lt;a href="&lt;?php echo $news-&gt;link; ?&gt;" class="readmore"&gt;Read more&lt;/a&gt; &lt;p style="color:blue;"&gt;&lt;?php echo $news-&gt;pubDate; ?&gt;&lt;/p&gt; &lt;/article&gt; &lt;?php } ?&gt;
 $ns = $xml-&gt;getNamespaces(true); foreach ($xml-&gt;channel-&gt;item as $news) { ?&gt; &lt;article&gt; &lt;a href="#"&gt;&lt;img src="&lt;?php $attrs = $news-&gt;children($ns['media'])-&gt;content-&gt;attributes(); echo $attrs['url']; ?&gt;" alt=""/&gt;&lt;/a&gt; &lt;h1&gt;&lt;?php echo $news-&gt;title; ?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $news-&gt;description; ?&gt;&lt;/p&gt; &lt;a href="&lt;?php echo $news-&gt;link; ?&gt;" class="readmore"&gt;Read more&lt;/a&gt; &lt;p style="color:blue;"&gt;&lt;?php echo $news-&gt;pubDate; ?&gt;&lt;/p&gt; &lt;/article&gt; &lt;?php } ?&gt;
Shouldn't you build a server/backend for your application (which uses ORM for communicating with db and provides a REST API that your Android app consumes) instead of using a "MySQL frontend"? Or am I misunderstanding your question? 
This works perfectly, I really appreciate that. How would I incorporate an if statement into this that would say "if that node exists, print it, if not, print something else"?
The issue is that PHP has arrays as a separate data type, and they are not objects. Hopefully in future arrays will just become objects of 'Array' class, Arrays are objects in most OO languages anyway. 
I'd also like to know some real-world reasons for serializing closures. I've never seen this done before.
performace of compiled C is about the same as assembly. Well written C anyways. However the compiler really makes the difference. As for Kore, have you read the sources? Pretty clean really and small as hell too. Makes me wonder why it wasn't here a decade ago. 
that's totally not what the caption suggested... 
A little skeptical on makefiles. Why not go with something more user friendly like Ansible, and kill two birds with one stone? Knowing a tool like Ansible really well will bring huge benefits to any developer's career later on, too - provisioning is a nasty step, but I've yet to see a tool that makes it as easy as Ansible.
Yes. I write SCSS... Chrome isn't so good at that
 $ns = $xml-&gt;getNamespaces(true); foreach ($xml-&gt;channel-&gt;item as $news) { ?&gt; &lt;article&gt; &lt;?php if($news-&gt;children($ns['media'])-&gt;content) { ?&gt; &lt;a href="#"&gt;&lt;img src="&lt;?php $attrs = $news-&gt;children($ns['media'])-&gt;content-&gt;attributes(); echo $attrs['url']; ?&gt;" alt=""/&gt;&lt;/a&gt; &lt;?php } else { ?&gt; FOO GOES HERE &lt;?php }?&gt; &lt;h1&gt;&lt;?php echo $news-&gt;title; ?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $news-&gt;description; ?&gt;&lt;/p&gt; &lt;a href="&lt;?php echo $news-&gt;link; ?&gt;" class="readmore"&gt;Read more&lt;/a&gt; &lt;p style="color:blue;"&gt;&lt;?php echo $news-&gt;pubDate; ?&gt;&lt;/p&gt; &lt;/article&gt; &lt;?php } ?&gt;
&gt; Why not go with something more user friendly like Ansible Because `make` is intalled pretty much everywhere? Vs. having to install Python and Ansible and learn an entirely new set of tooling to do python deps.
1. -You don't understand what a decimal type is and why does it exist along with double. And why decimal should be never represented as double but as a string only- 2. There is no benefit from having this placeholder type. "An extra memory allocation" just for a couple of bytes, really? 3. You apparently don't have a code for this RFC so someone have to waste their precious life to fulfill your ridiculous demands.
It's not clear to me what exactly is meant by Makefiles being a "feature" of Symfony 4 or how they're going to be integrated into the framework components. The examples provided are things you can do with Makefiles, but you could seemingly use those same Makefiles on a current Symfony 3.x app as well. Perhaps this just represents a "best practice" recommendation and nothing else, but it's stated as a "feature coming to Symfony 4", so I'm not so sure.
Extending `ArrayIterator` is a neat trick to reduce the amount of code you have to write. (Though personally, extending any internal PHP class makes me a little uneasy…)
I prefer a bash script over a Makefile though.
For a cache clear Ansible feels a bit overkill...
For a cache clear even Make is overkill. I assume they mean to handle some super complex tasks with Make, else it would have bene easier to do execs from PHP, or just shell scripts.
Yeah, f5 works pretty well for many users. But switching back and forth to see updates in browser gets really irritating I would say. This library/tool will make sure that your updates are there when you switch from code editor to browser by automatically refreshing it. It's kind of *watch* for browsers.
Phalcon is OK. Performs well and has a decent architecture. Downside is that you need a bit of devops skills to master it.
As an aside to all the comments here, [please use the alternative syntax for inline control structures](http://php.net/manual/en/control-structures.alternative-syntax.php)
I kind of like such generalized statements, like "why bother introducing optimisations" or "so the data type might have some significance". But I prefer to stick with concrete issue in question. How much optimization would you expect from introducing this binding type? In numbers.
Thanks for explaining
It's indeed meant as a "best practice change" coming in Symfony 4.
I see, yeah I agree with what you are saying. A better idea/compromise here is to create struct types, kinda like C#/Swift. Both Struct and Class types are objects, but Struct types are passed by value while Class types are passed by reference. The scalars and arrays will be struct types, this enables OO interface for every type in PHP(for string and array, it will be very useful). We can even allow custom struct types that a developer can define in Userland, or through PECL extensions. Right now, Nikita Popov made a scalar objects C extension that allows OO interface for PHP primitive types. I already use it in production, and it works like a charm. The PHP 7 compatible version is even more powerful, I definitely recommend PHP programmers to give it a try.
I have everything that i need for my applications basically + big performance improvement compared to symfony.
It's very useful when you want to send php objects or commands to for example a job queue or redis. They can only store strings, so they have to be converted to something that can be restored to a previous state from a string. 
Float is a data type which is deliberately "not correct" so to say. When using a float, one signs terms of use that say "values you are working with are but rough approximations so you shouldn expect the exact match. If you need one use another type. "
I don't think it is overkill, though. Makefiles are also documentation. Need to know how to clear a cache? Look in the makefile, the command is documented right there if you want to learn how it really works. Same story for using simple bash scripts (eg `bin/clearcache` or whatever). But with ansible that command is a lot more opaque (unless you do everything with [shell](http://docs.ansible.com/ansible/shell_module.html)). Same story with doing execs from PHP.
It can be the same application. But usually you have a backend that provides an API to your mobile client. This is not a generic thing but a custom written backend. ORM can help you with easy database access. 
Yeah possibly... Let's wait an see. Also Fabien doesn't seem settle on it yet, looks like he couldn't really find something satisfying him so it's possible he'll have a change of mind until then.
Probably the use of one of the most standard tools with the least dependencies? Make is a part of POSIX, Ansible is not. Though I wish they'd stuck with composer for better Windows compatibility. Composer is a tool that's easy to install on Windows, and you'll have it for PHP development anyway. With make you either need the Bash For Windows (Which I have anyway), or install it through Cygwin or something similar
Quick Question, is there any particular reason you link to the medium articles as opposed to the originals?
Not really, I link to the version I encounter first, it just happened to be Medium. 
&gt; Yeah, but Windows users might have a harder time getting up and running with Make than with Ansible. PHP development on Windows really takes the piss. I've tried Docker, Vagrant and running completely local with PHP Windows binaries. The only way I can legitmately get anything done on Windows is with Vagrant, no shares, and having PHPStorm "deploy" the files to the vagrant/virtualbox.
Use PHP's get_headers() in a conditional like so: $headers = get_headers($url, true); if ($headers['Content-Length'] &lt; 100000) { // do curl }
&gt; which isn't enough time to download the 100MB target file Ehhh. I feel this is a poor solution
It might also include a default Makefile for new projects.
I'm encouraged by the direction Symfony 4 is taking. While Laravel is continuing to build its walls, Symfony is stripping itself of redundancies and opening itself up, embracing established developer tool sets (not everything has to be done in PHP), and composer.
That is not true! You can see in the example that make is calling "bin/console cache:clear --no-warmup" to actually clear the cache.
Can you explain how it compares to SuperClosure?
You should go ahead and make those mistakes. For me the best way to avoid mistakes is first to make them and then to learn from them. As long as this is not your profession I would not worry to much about security (not saying you should not look into these topics).
Is this still going on? I thought the updated opcode caching already killed Phalcon.
Ah, yes, I remember these problems. Symfony definitely wasn't Vagrant friendly 
I don't think header checking will work, because it is technically possible for the request to return more or less data than what the `Content-length` header indicated. Besides, some requests do not send this header at all. The only viable a sure-shot way I see is taking control over the `write` operation. Curl has an option `CURLOPT_WRITEFUNCTION` that you set a closure that writes the data (instead of writing to `stdout` or return it). You can create one that checks the total data written, and throw an exception or something when the file size is larger than the desired value. Combine this with the header checking to fail early. Edit: `CURLOPT_PROGRESSFUNCTION` is the better way. See below.
`Content-Length` can be faked/incorrect.
Recently right? Forgot about that.
Like NPM / Gulp / etc. ?
Have you tried the [Vagrant WinNFSd plugin](https://github.com/winnfsd/vagrant-winnfsd)? I've found it helps speed immensely on big Symfony projects.
Side question: Is there a way to just limit curl to "Only download 10KB, give me those, and then stop" ?
Unless you happen to be playing in the very small subset of web applications that require very heavy real time data processing, your big performance improvement is likely due to some other factor (or it's imaginary). For most applications (unless architected in some vastly inefficient manner ie Magento), there just isn't enough time to be saved in processing to make a huge difference when compared to network and IO latency. 
I believe so. GNU (So, Ubuntu minus the Kernel), so it includes all the utilities that you'd expect (or, 90% of them). I *believe* it comes with it, but if not you can always do `apt install make`, and it'll install `make`, just as if you were on Ubuntu
You're always angry when posting in this subreddit. Sometimes you're so busy being angry, you do it at the expense of being wrong. It's not a nice trait. Having a PDO float type would allow a more efficient representations of floats in queries. In many cases *more* accurate. Here's why: - If the source value is a float, encoding it as a float would skip the redundant float-&gt;string-&gt;float conversion that has to happen between PHP and the SQL server. - In prepared statements, floats are encoded in their native binary format, which in typical cases would be at least twice smaller than sending a string over TCP. - Not many know this, but the `precision` PHP.INI setting, which is supposed to be for display purposes only, actually affects PDO serialization (and other DB extensions). And because in most cases `precision` is set too low to represent the number correctly (it should be 17), it means going through string always results in precision loss. So. In a nutshell. It's best to encode floats as floats, when possible. This is not for the DECIMAL type, which one can encode as a string, still.
That's really impressive, congrats. It seems your are using the token approach yet you support what the AST approach can do, how did you achieve that?
I want to kill `precision` with fire.
It should be killed with fire. ECMAScript specifications describe an algorithm which always serializes floats with the *right* amount of digits so that conversion back and forth is lossless, but there's no noise tacked onto the end. The PHP precision in contrast is a fixed-length serialization, the only thing that gets hidden is trailing zeroes. The problem is that when serializing IEEE 64-bit binary floats, you need 16 digits of decimal precision in roughly 98% of values. But for 2% of values you need 17 digits. This means if you set precision to 17, you have precision, but also the resulting serializations are very, very noisy, with a false 17th digit. But in 2% of cases, the 17th digit is necessary. This is especially annoying when serializing JSON (which... again, yes... is affected by `precision`). It's just a shitty serialization algorithm. The `precision` setting has to go, and PHP should adopt the ECMAScript algorithm. 
I use `Makefile`s in some of my PHP projects, but I don't use phony targets like this. Using `make` to run arbitrary commands like some sort of playbook just feels *weird* but not necessarily *bad*.
This. You can't trust `Content-length`. But a better method would be using the `CURLOPT_PROGRESSFUNCTION` option.
Sometimes no matter how hard we try, we will still fail. Because we're human. That's what we do.
PHPStorm with Docker on Windows? Might experiment with this: https://github.com/DHager/docker-php-library-demo Hopefully it'll at least help as a "reference implementation" for getting all the goodies like debugging, unit tests, and phpmd/phpcs working.
I didn't say compared to Symfony. I said compared to just basic packages that I would need for a web application that I could just throw into composer.
I think the definition between running PHP on windows vs developing on windows needs to be made aware, they are two very different things. You mention Vagrant and Docker, if both are running Linux OS then running "make" is no issue... Doing it with binary or IIS, then would be difficult.
oh, sorry for some reason i read it as git for windows even though i definitely wrote bash for windows. I meant the git download for windows that includes bash. I'd be surprised if symfony required the linux subsystem for windows just to make php apps.
This is a poor solution, but is perhaps something you'd want to set anyway. If you have a queued system, you don't want a hanging download to stay in the processes for minutes at a time, better kill it early, and then try again later. This will help in DNS outages etc.
Story of my life. I develop and deploy on Windows / IIS. I've been doing it long enough where any annoyances or workarounds are second nature to me. 
&gt; dang thing out the door without too much technical debt. That can't be true, you can't have both. So you're telling me you're going to create something really quickly, with no technical debt, yet it's the "wrong way"? Why isn't it the "right" way then? Using standards and patterns is the way to avoid technical debt, not quick hacks and code that is every which style and variation. Yeah that's a way to get something quickly out the door but without technical debt sounds dead wrong. Maybe it's the size or function of some of the apps you have developed, but I've had to come in and scrap Laravel monoliths and turn them into Symfony/Go/Node services because they became a headache to maintain. Every which style and no standards.
heh https://www.reddit.com/r/programming/comments/63zg6f/what_unpopular_opinions_do_you_have_about/dfy8j2a/ &gt; Using PHP for serious projects is reckless and dangerous. Not because PHP is broken (which it is), or because it has ridiculous security issues (which it does); those can and will eventually be fixed. **But because writing software that is actually good (see first bullet point) is so incredibly difficult that it practically never happens**, and when it does, the eventual effort dwarfs what you would have needed in virtually any other language. Meaning that, as a professional developer, you either deliver bad software, or overpriced software, or you're seriously underselling yourself. Goodness. 
Doesn't cURL support `CURLOPT_NOBODY` in PHP? Could use that if you want to keep using cURL, else the rest of the responses here are good alternative solutions.
&gt; Symfony 4 won’t have the equivalent of app/config/parameters.yml. Use environment variables instead. From that Factor 12 website: &gt; Apps sometimes store config as constants in the code. This is a violation of twelve-factor, which requires strict separation of config from code. Config varies substantially across deploys, code does not. &gt; A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials. So. As with other frameworks (looking at you Laravel), where do you define the requirements for your environment variables? In some `.env` file? Right. Lets give those variables in there some default values, oops they turned out to be real credentials that are now being commited into source control. In Symfony, the parameters.yml should simply be able to access environment variables. Removing parameters.yml in favour of environment variables won't solve anything. Idiots will always find a way to commit credentials into source control one way or another. 
&gt; Opis Closure can serialize-unserialized a closure an infinite amount of times, while SuperClosure will fail. This interests me - could you provide some code to explain how/why this happens?
My hot take is that it converts closures to callable classes, and then deserialization creates instances of those classes. Which would be actually pretty neat, compared to `eval()` which other libraries use.
It's used by flex for auto configuring the bundles. It avoids you to edit the AppKernel and the config file, flex just runs the makefile to install the bundle.
What's your point ? In Symfony &lt; 4, parameters.yml is ignored by the default .gitignore. You have to be careless (and stupid) if you defines your real credentials in parameters.yml.dist. It's easy to do the same with the proposed way in Symfony 4, they will have to add .env to .gitignore and you can still keep a .env.dist in your versionning. I honestly think using ENV variables is right way to go. 
I guess I'm fortunate in that I have not yet had the pleasure of Docker outside Linux. I heard plenty of horror stories about performance issues - particularly from Mac users - when using Docker. In my experience though, as you say, performance on Linux is amazing. I typically used Ansible-managed VM's for running a Symfony stack, and would see ~100-280ms performance in dev. With Docker, that was slashed down to 20ms. 
Due to unrelated reasons I use Windows as my main OS, but Cygwin has made the development process quite comfortable. I tried most of the other alternatives to get the best of both worlds without rebooting (Win10 bash, Wine, etc) but using Cygwin within ConEmu is my current best practice.
A weird question: My next side project will use Symfony as a framwork, as opposed to a patchwork of different packages for my current project which already uses doctrine and twig. I will probably start during the summer, but I'm flexible. Does it make sense to wait until 4.0 to start the side project or will switching from 3.* to 4.* be a piece of cake? As I see it now, there will be less to learn if I skip version 3. But maybe I'm overestimating the changes and proposed simplifications.
Totally agree with you..one thing is to quickly start and put together an app..a different thing is to support it and build upon it..Laravel is perfectly fine for small webs and eshops you just deliver to the client and will not ever come back to it :) ..it is not really about Laravel but how people are used to approach it though..if you want a maintainable, scalable and reusable codebase..the Symfony way looks really promissing..can't wait for version 4 :)
Why not use composer scripts for this purposes? For example I have `start` script which runs docker-compose and prepares environment for me. I also have `build` script which build docker image of application. 
&gt; As for Kore, have you read the sources Yeah its pretty much my go to framework now, I love it
Do you really need the interface? Seems like too much boilerplate... I also commented on the blog itself, but the reply hasn't been approved yet. Since you're working with iterators already, why not try something along the following lines: https://gist.github.com/haampie/474bcdc4a6de09e8eceafc82712e5607 A Collection class, a specialized UserCollection class (if only we had generics), and you can type-safely construct a UserCollection via User instances, or unsafe via Iterators. Retrieving the current item from the iterator is again type safe via the return type. This way you could easily use it with Generators, LimitIterator, CallbackFilterIterator and the like :).
They don't.
I'd argue that your narrow mindedness makes you a worse programmer and are probably worse in teams because of your attitude. How dumb to teach a programming language used by companies like Facebook, Wikipedia, Tumblr and Mailchimp and that also has countless jobs in the web industry... Is php a good language? Absolutely not but it's still widely used and can be very useful. 
What is their POS system?
Wynward I believe
I integrated magento 1.9.x with Micros RES 3700. It sucked.
Bonus link: PHP vs Ruby: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=php&amp;lang2=yarv PHP vs Python: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=php&amp;lang2=python3
Looks like [Envato Tuts+](https://www.youtube.com/channel/UC8lxnUR_CzruT2KA6cb7p0Q) already has access to the `localhost/Sessions` directory. He's rebuilding that directory but with the path `localhost/membershipSite` -- because he's on windows the case sensitivity is ignored so his directory `Sessions` that he shows earlier in the video is browsed (on his browser) is `localhost/sessions`. The errors he's receiving are PHP generated. These can be enabled a number of ways. &gt; https://secure.php.net/manual/en/function.error-reporting.php * `php.ini` system wide * [`display_errors = On`](https://secure.php.net/manual/en/errorfunc.configuration.php#ini.display-errors) : the line you want in your `php.ini` wherever PHP is installed - https://secure.php.net/manual/en/errorfunc.configuration.php * In code * [`error_reporting(E_ALL);`](https://secure.php.net/manual/en/function.error-reporting.php) - or whatever setting you want that to be - https://secure.php.net/manual/en/function.error-reporting.php
I have been supporting a large Laravel 4 system for over a year and it has been a dream to work with. On the other hand, I have seen entire Symfony projects trashed by companies because they were too expensive to maintain. Every developer who joined the project got lost in the pursuit of perfectly abstracted reusable code, and ended up with tens of thousands of expensive to maintain and useless lines of code, since hardly anything ended up getting reused at all. I have also seen Symfony projects which are successful, as well as Laravel projects filled with cowboy code. Bad developers produce bad code. The correct framework for any use case, is the framework that gives you what you need without adding too much overhead. To illustrate my experiences with both frameworks: Laravel gives you bricks to build with, but Symfony gives you cement, sand and gravel to make bricks with. Both can build a wall, and the Laravel bricks might not be quite what you need, but at the end of the day it's difficult to explain to your manager why after months of development you are still mixing cement. 
I'm not an expert at all, but the way I see it, docker itself isn't really the problem. The bottleneck is just the way shared volumes/containers can work on the OS that is used. On linux it is native, and on mac/windows there is a virtual machine in place wether it is Virtualbox, Xhyve, HyperV, Parallels, ... This means that for example when I want to run a container that needs to access thousands of shared files, there is a huge delay. But when you run a container with these same files, but not shared, the performance is perfectly fine. Therefore we need things like NFS shares, sambda shares, rsync, unison, ... Which actually means it looks like you are back to using vagrant to me.
Use Square for POS, and use any of the numerous plugins to sync Square POS with Magento.
That analogy works well too. I remember fighting to use Laravel over Symfony at my last company because our team literally produced cookie cutter PHP apps. Instead one strong-minded elitist convinced everyone that Laravel sucks and Symfony is the best framework for every situation. It turns out he was only pushing for it because he wanted to weed out the "bad" developers on the team who, in his mind, were too dumb to learn it. In the end he was the only one that left the team once we moved to Symfony. His project timeline kept getting longer and longer until he finally freaked out and quit. The other devs on the team (including me) enjoyed learning the new framework, but did not enjoy telling our clients that things now take 3 times as long as before, with no tangible benefits on their end. Even supporting the projects became a pain, since the most basic single page app became an over-engineered salad of unnecessary best practices. A 200 line controller became a mess of services and singletons because "that's the right way to do it". It was a real headache. From what I recall, there was only one project we worked on which benefitted from those best practices, and it could have been done just as easily in Laravel. Edit: In short, Laravel is the framework for 80% of PHP projects. When all you need are some models, views, controllers, services, unit tests, migrations and a simple ORM. Symfony is for the other 20%. The real nitty gritty stuff where you need to have granular control over everything.
IIRC RES 3700 was the precursor to Simphony. RES 3700 sucks terribly.
I would say that Symfoby, Laravel, Zend, Phalcon are pretty much all on equal terms as of quality..and it really depends on the developers..the things you described are not best practices but rather missing knowledge of best practices :) ..I tried actually all of the mentioned frameworks and they could do the job in the same time and with the same quality..Symfony is my personal preference but I use Lumen for API's..but the thing is..that if you know your framework of choice you will be productive..and quality, maintainability does not really depend on the framework..but it takes time and a few projects to learn it properly..each of these frameworks promote best practices..and their approach is pretty much similar..
Are you trying to connect through the browser? 
&gt; Any recommendations? Sure: use [adminer](https://www.adminer.org/) instead of phpMyAdmin. **Edit:** So I'm getting downvoted for this, and looking back I think I might have downvoted if I'd seen someone else say that. So let me explain for /u/gearvrabc's benefit *why* I'm recommending adminer and I will try to be objective, because I didn't actually mean to bash phpMyAdmin or to disregard OP's question, but that's the way my comment sounds as it is. OP clearly has trouble configuring phpMyAdmin, and if you don't know what you're doing it can be daunting. I haven't used phpMyAdmin in a while but I am willing to bet that the obtuse config PHP file is still there. I don't like phpMyAdmin because it has become slow and bloated over the years. It's become a full fledged AJAX application and I think it has outgrown itself for that reason. This is my personal opinion and it shuld be noted that many people really like phpMyAdmin. Adminer on the other hand is a single PHP file, and if you only need MySQL and English, you can download very lightweight versions of it (and lots of CSS skins!). The only two things adminer doesn't do as well IMO is filtering tables, where you type and the table list slims down, and users/permissions, which phpMyAdmin is arguably better at. In all other respects, I like adminer better than phpMyAdmin. It does what it needs to do and it does it quickly and intuitively, and the reason I am recommending adminer to OP is, **you don't have to configure it**, you just drop it in and it works. Many people really like phpMyAdmin for good reason, it's certainly not bad, but for me personally and I think for OP, adminer is the better bet.
A point for consideration: Why do you want to protect admin *routes*, and not admin *functionality*? I ask because this seems like something that the underlying application logic should handle (i.e., the Domain), not the user-interface logic (i.e., front controller / routing / etc.)
You can, but they weren't really made for that. For example Sage 9, a starter theme for WordPress, uses Laravel's Blade templating engine. I've seen the ORM used in WordPress sites as well. Laravel's components are broken down similarly to Symfony so it's possible but Laravel isn't marketed towards that. 
In symfony your "real" credentials are either in `parameters_dev.yml` or `parameters_prod.yml` not in `parameters.yml`. In fact, `parameters.yml` should be committed since it acts as a template for the available parameters. It's the `parameters_dev.yml` and `parameters_prod.yml` that should be ignored. This means you only have to define everything once, in `config.yml` and `parameters.yml`, after that you override what you need in either the `_dev` or `_prod` versions. The point is that changing a very elegant and flexible configuration system that works on the principle of overriding defaults to use environment variables sounds like a massive step backwards. Like I said earlier, Idiots will still find way to commit theirs credentials, which seems to be the key motivator for this change. 
Don't forget you're still running virtualisation to run the whole Linux stack required to run your app. 
&gt;Personally I have never really been sure of it's purpose. It's inert and not used by anything. Maybe you should take the time to be sure of its purpose before attempting to explain it to others? This blog post describes it perfectly: http://symfony.com/blog/new-in-symfony-2-3-interactive-management-of-the-parameters-yml-file You define your application parameters in this file, and default values, if any. ~~~She~~~ When you run `composer install` a script will prompt you for their values. edit: I need to stop posting from my ipad
[Maxwell's daemon](http://maxwells-daemon.io/) -&gt; Kafka Use any MySQL client/ORM. There are no good options for directly producing/consuming Kafka from PHP, unfortunately.
As someone who works for a Micros dealer, it was 9700, not 3700 that was the precursor or Simphony.
I think some of the advantages are also some of the disadvantages. - Requests are self contained (no memory issues or crashing killing everything, but can't cache connections, share variables) - Single threaded. (Everything is procedural, but can't make call backs/promises or spawn multiple processes as easy)
Wow. That sucks. 
This is exactly why I don't recommend doing docker "the right way" during development. Instead of helping you quickly set up, it immediately becomes your problem, and stops you from quickly getting to your real problem -- writing code for your application.
Lol. I get your point but if you plan on using docker during production you'll still face the same problem then so I think it'll be better to face the problem before you even start the project.
In fairness to the Node ecosystem, the developer base at large don't want complete-solution frameworks like laravel or symfony. So if you heavily rely on these kinds of framework, Node is not for you. With regards to it being slow when business logic is added, I would say that it's still faster than PHP considering you don't have to build up your entire application on every request. The big set back is in dealing with the asynchronous/callback-based approach in your application logic. This can still cause confusion even to veterans. When it comes to dealing with complicated code, this is more of an issue with the person who wrote the code, than with node itself. Each tool set will have its ups and downs, and whichever one you choose entirely depends on your team. You can deliver equally capable applications in both.
I mentioned magento initially but I can replace it...Do you know a free opensource ERP module for It?
I can't even consider a language without type hints and interfaces for serious work any more. It's just not possible to follow clean code guidelines without those language features.
Check the folder and file permissions. I have no idea what the laravel command does, but you could try to run the command inside the docker machine (`docker-compose exec web bash`) if you haven't already done that.
I would add mature ecosystem to the PHP side (at least in comparision with node and JS in general). I'm surely subjective in that matter but having so big fragmentation, crappy packages registry (and manager, if we're talking about npm), dozens of packages doing same thing and each of these packages with dozen of dependencies... Jeez, it just repels me. Naturally, PHP has its own issues, but to me ecosystem of JavaScript looks like ours 5-10 years ago :/
Many projects are written in PHP, not nodejs.
I'm really struggling to follow his logic. Edit: reading the rest of his posts he just sounds like a bitter retiree who ran across a problem pre-2000.
Thank you for that thorough answer! As someone working alone without any colleagues to ask these simple questions, I am glad for all insights into how things are done on a more professional level.
Opcode is opcode, it has nothing to do to code running on C.
Node has yet to give me a good overall experience. NPM is barely functional by package manager standards and I think is responsible for most of the problems I've had. My success rate of getting packages installed correctly without some sort of cryptic version conflict must be under 50%. Yarn is supposed to fix this but isn't widely used yet. I also fail to see the appeal of using JavaScript anywhere that I don't absolutely have to, but that's obviously a matter of personal preference. To it's credit, the latest versions allow writing code that isn't awful, but it's still far, uh, quirkier than PHP. 
PHP is mature, stable, easy to scale, easy to reason about, and has an enormous ecosystem of stable, tested, functioning code. Also, PHP as of 7.1 is a pretty solid language. Node.js is a lot less mature, a lot less stable (both in terms of bugs and crashes, but also the frustrating speed that the entire ecosystem changes), and has npm which right now definitely favours quantity over quality. Plus, Javascript as a language is not great; even if you've gone all in on Babel and are using all the stage 0 transforms (which has its own drawbacks), it's a profoundly unlovely language. Breaking it down more concretely: * Language: I think, as of today, PHP 7.1 is better than whatever version of JS you want to compare it to. (The fact that it's almost impossible to even *define* what version of JS you're trying to compare it to is half the problem.) * Ecosystem: Overwhelmingly favours PHP. Just try and find a good ORM/entitymapper for node.js. * Execution model: For REST APIs, CMSes, basic web apps, etc., PHP is more suitable. The main thing that would make me reach for node is if I wanted to do something with websockets, and even then I'd question if writing the whole app in node is the right answer. We have both PHP and Node.js code in production, and both have their strengths and weaknesses. Asking which one is "better" without saying "for what" doesn't make much sense. But for *most* things, for us, the answer is "php". And that's despite the fact that we are very familiar with node.js and have node.js code in production.
Lol, that guy should see the code I wrote years ago in VB.NET and Java. I've written far more good code with PHP. 
Thanks for making this point. OP's question suggests that it's a contest with a clear winner. I think the question is akin to asking, why is detergent better than vinegar? Well detergent's better at getting rid of grease, but it can't do calcium as well as vinegar. They're not mutually exclusive or anything.
It's working out pretty well for me so far on my current project. Took me a while to get everything set up (first time using docker), but now it's running smoothly. But I am not using a framework. Maybe the problem is more with laravel than with docker? Especially since you mentioned all other PHP things worked...
Can you kindly share steps on how you made it work?
This is copyright material - I expect you'll be getting a Take down notice very soon. 
That makes sense but does laravel need to have write permission on that storage folder before it works at all?
I would like to start using docker for production that's why I'm trying to use it during development too so that I can get used to the workflow. The virtualhost part is not important though.
I always use `CURL_PROGRESSFUNCTION` callback to check size limit strictly. $sizeLimit = 100000; curl_setopt($ch, CURL_PROGRESSFUNCTION, function ($ch, $totalBytes, $receivedBytes) use ($sizeLimit) { if ($totalBytes &gt; $sizeLimit) { return 1; // return non-zero value to abort transfer } }); And check the error (using `curl_errno()`) for `CURLE_ABORTED_BY_CALLBACK`, if i want to know the reason is size limit.
For the same kind of requirements but without needing to spin up a separate service, there is https://github.com/php-vcr/php-vcr, though in my exprience it has some issues with curl_multi.
PHP objects have things like __get, __call, and __set. Typing arguments. 
Ah, good find, and thanks! I'd have never thought to search for "VCR" `:-)` I'll give this a go. 
If you're using Laravel, check out [Laradock](https://github.com/laradock/laradock), it's basically a pre prepared set of docker containers targeted towards Laravel development. You may not want to use it but it might help give you some pointers for your specific use case.
they are both single threaded by default. also, php does have multithreading support (http://php.net/manual/en/intro.pthreads.php) which nodejs doesn't. also the exact same thing nodejs does, including "call bakcs/promises" can be done in PHP (see for example reactphp) EDIT: noticed link was german, switched for english link.
Guzzle is an HTTP client I use frequently and they have support for middleware. I found this package for Guzzle: https://packagist.org/packages/middlewares/proxy This should allow you to set up an HTTP proxy. Although you could also really easily use a caching middleware to achieve much of the same, with this you leave the HTTP proxy to specialized software. 
It's a different tool for a different job. 
Came here to suggest this as well. It's easy and did the job for me. 
It's not a proxy server, but rather a wrapper around Guzzle that I made for almost this very purpose. Check out my package, [`HttpPlayback`](https://github.com/Garethp/HttpPlayback) to see if it suits your needs. I'd be interested to see what differences your idea would have. It doesn't have much in the way of documentation, but you can take a look at how I use it in my other package, [`php-ews`](https://github.com/Garethp/php-ews), by looking at the tests and [where I integrate it in to SOAP](https://github.com/Garethp/php-ews/blob/master/src/API/NTLMSoapClient.php#L209)
I like PHP's namespaces and class system. It's not as messy or ad-hoc as JavaScript's and requires less configuration.
You can find hosting for PHP much easier than for node.js. 
Yeah me too Has been using docker for php development, and it works fine so far 
So I decided to use https://github.com/weiboad/kafka-php. I'll just have to give it a baptism of fire lol, to see how durable it is. I'm able to have a persistent connection and it seems much faster than arnaud-lb and much easier to install. Can be installed via composer. Creating the accompanying zookeeper library for it was difficult, but I got there in the end. I have the .so files and now it's just a case of distributing them when a web server is spun-up. I now can produce and send messages using php via zookeeper or a broker on 0.10.2. Will probably update this when it goes fully into production.
PHP Composer has "--prefer-source" option, [NPM does not](https://github.com/npm/npm/issues/7375).
Apples and Oranges
I get paid to develop in PHP and node is my current hobby language. There are definitely things that node is better at: 1. Node can retain state across requests which improves performance when there's a lot of common data that needs to be loaded for every request. 2. I can limit static files to a certain directory, so it's possible to respond to other requests without even touching the disk. 2. With node you control the entire server, so you can skip processing you don't need for a request, or defer until needed. 4. Node threads can process multiple requests at once, whereas in PHP every request generally needs it's own thread or process. 5. Node is unquestionably better for web sockets. 6. You can share libraries across client and server. Node had it's flaws too, but it *can* do things that PHP can't. It's a different architecture with different goals.
What in your opinion makes dentists better than orthopedist?
FYI, you can write Node.js apps in TypeScript which has a much better type system (e.g. Tuple, Enum, Intersection, Union, Index, nested types) than PHP. I still use PHP for most server-side stuff, but have completely replaced JavaScript with TypeScript on the front end.
is not based in javascript.
Can you please provide an example of how you see it implemented?
There is no error, this line print_r($_FILES); die; is printing out the values of $_FILES, which is populated with the information about any uploaded files. It is then stopping the execution of the script. It is a cheap any easy way of debugging the code.
You do not need to close the connection. When your script ends, it will close the connection automatically. Your endless loading is some other issue. Note that _ext/mysql_ (the mysql\_\* functions) is deprecated and you should use mysqli or PDO instead. _ext/mysql_ has been removed from PHP 7.
This looks like a problem for stackoverflow
Matter of opinion I guess, but having a setter not actually set a property is not just unnecessary ambiguity but a lie to me. A method name should reflect what it does as best as possible. On top of that it produces better readable code that is almost plain English e.g. "$average_price equals $total_price divided by $item_count".
Should be fixed now, sorry!
First, you almost never, ever want to put a DB query in a for loop. I don't really have time to look at what you have going on in here, but it almost certainly could be done with a single SQL query. Also, wrong sub.
Lack of `left-pad` npm package. 
Then don't use setters. [Tell, don't ask](https://martinfowler.com/bliki/TellDontAsk.html). I think that's the root of your problem. Instead of calling multiple methods on your object (like `add` etc are suggesting), move the logic into your object instead. 
Sorry but what's `BE development`?
 $mysqli-&gt;real_escape_string('untitled/images/'.$_FILES['avatar']['name']); The destination path you put in there doesn't exist. Since you are executing the file from "/Applications/XAMPP/xamppfiles/htdocs/untitled/", then the path needed would be relative to that. I.E. remove "untitled/" from the path, like it was in the first version of the code.
Is this a thing outside of Reddit though? I haven't heard a single bad thing said about Laravel in the real world. 
Sounds like you'll have to use an older version of the ODBC driver, but that might not be compatible with PHP7.
^ This
Because it's 99% magic and 1% trash
I don't like it for using statics/magic "facades" for everything, how it's mostly dominated by 1 person which causes it to be very opinionated. I don't mind anyone having a good time with the framework, it's just the Taylor has made a fool out of himself on multiple occasions trying to prove stuff with false evidence and has the constant need to defend his choices.
Debugging PHP is precisely as difficult in general terms. If you want sane debugging, go with a statically typed language. However, in PHP you are working with a monolithic framework, so you are debugging exceptions that the framework is throwing, which makes it much more complex. I switched from PHP to Node.js three years ago, and I haven't found one single reason to even consider going back. However, Node embraces the anti-framework micromodule idea, and that sits really well with me. So I guess it comes down to personal preference.
Thanks for the response. In my opinition, that's not the best option. First, it's not the *read* permission but rather a *view* one. One action can display multiple entities, and for each of them you'll create separate *read* permissions, which will be useless if the *view* isn't allowed. Each permission should be responsible for a certain action made by user (admin) over a certain entity. As @pmjones noted, routes, as well as controllers, do not belong to the application logic, but rather technical necessities, so creating permissions for controller actions don't make much sense. Second, in real life it's too easy to miss a permission check for a particular action, potentially displaying something you don't want anybody but admins to see. Protected routes would not allow that to happen, and I'd rather be safe than sorry.
I use a docker setup for local dev and AWS stage on all project. I use the docker as a submodule: https://github.com/uar-daniel-gafitescu/docker-dev If you are interested
thanks for your ideas! for me it's kinda hard to think back where a bloody beginner would start. I'm not a huge fan of teaching basics about something as I for myself would rather do a learning by doing type of thing. If that does take longer per step thats fine in my eyes as you are for sure remembering the stuff better than if someone just told you "XXXX" is what you use to do "XXXX" kinda style
That issue about the removal of a feature in the core library is just hilarious :D
Just incase anyone is looking for a solid example of a nodejs MVC framework, here's an adonis + vue (includes server-side-render), it's pretty much laravel/rails for nodejs. https://github.com/nuxt/adonuxt Also a PHP version of Nodejs, great for websockets: http://reactphp.org/
Personally, i don't hate hammers or screwdrivers. But i don't like people hammering a nail into a wall with a scewdriver, or people hitting a screw into a wall with a hammer. Want to build something quick that is not solving your core business? Probably use Laravel. Want to solve a small part of your core business? Probably Laravel as well. Want to build an application that has to be maintained for several years? You might not want to be locked-in to "the Laravel way of doing things", facades, etc cetera. Don't be a "laravel programmer", "wordpress programmer" or a "magento programmer". Just be a programmer using the right tools for the job. Double thumbs up for Taylor creating Laravel. It is a great tool in my toolbox. But if i need a hammer, don't go ape-shit when i don't pick the screwdriver (Laravel). 
Cool, thanks. Am I right in thinking this package needs to be put into a specific play or record mode? That was [a thing with WireMock](https://stackoverflow.com/questions/40743569/can-wiremock-play-and-record-be-used-at-the-same-time) that I wanted to avoid for my use case, since if I run my scrapers against the proxy, I want them to play or record depending on what's in the cache, rather than having to switch modes explicitly. 
&gt; Node is unquestionably better for web sockets. Yup, but you can still use reactphp anyways!
It is, but it shouldn't be that hard to make it dynamic switching. My use-case here was that I just wanted to record in one whole go (So I run my tests in record mode based off of an ENV var), and then playback for CI, or have someone record their API calls when they have a bug and send me the recording, so I could debug with the data they have. In my use-case I simply didn't have the need for an auto-detecting mock
Backend :) ..everyone around me uses BE..but they are all Java devs :)
Thanks for the reply. That looks interesting, and a network spy like Wireshark is an excellent idea I'd not thought of. However, there's a couple of things that I think would be blockers for me: * Not being able to record HTTPS traffic * Discrete modes for playback and record (I'd want to feed site data to my cache using a simple site spider, and then run my real crawlers on the cached data, but if a real crawler was to access something not in the cache, I'd like it to record _and_ playback at the same time). 
Can you give any examples?
If you have php on the page it will be a php file - filename.php Then you can, say have a normal HTML page, but in the body put : &lt;?Php echo 'hello!'; ?&gt; Also you need to have the page on a server or something locally like xampp, where php is installed.
I need to ask, totally honestly without a trace of wanting to start a flame war or anything: why is a thing working like magic seen as bad? I don't know how the remote for my TV works, outside those buttons, but I stil use the remote. Same goes for pretty much every piece of technology I use I guess: I have an understanding of it's working, but it doesn't make the stuff _bad_.
Maybe because you're working in a small shop doing agency websites and not enterprise systems? I'm not a Laravel fan, but I can see it being used in that situation, since once it's deployed, it's not touched again. I've worked/been in plenty of places where they dislike Laravel or even PHP with justified arguments.
I dont think u have taken the time to understand my post.
I want to make changes in wordpress site because I have already created one and I also have enough time to learn, I just want to build a site where users can also participate by posting images
Hmm, most people in my professional circle avoid Laravel. Most of them work on larger projects, maybe that's the reason.
You have the form on login.html and the form action sends the data from the form as a POST to login.php In your links the HTML form only has username and password fields, but the php is trying to get an 'email' variable.
Because when something breaks which inevitably will or if you have a use case which the authors didn't think about, you will have to look at how it works, and if it's too much magic it becomes really hard to understand. Also, when there's too much magic going on, you never really have confidence that something will work like you expect it to. 
Not only are they testable, but you don't even have to use facades. 
I'm curious to see what your final solution will be. Recording requests can be a really valuable asset for a number of reasons. I know a payment provider that is able to replay all their requests since their company began years and years back. It's great for ensuring stability in an API.
&gt; Things like this (3000+ lines), I'd be laughed at if I wrote a class this long: From what I see about 40% of the file is just comments. Is this really that bad?
Still worth to use Laravel without facades, eloquent etc.?
You can find some people hating any and everything on the internet. I think you are giving it too much of a significance. Laravel is a wonderful framework, as is Symfony - for me, only these two are top notch contenders in the PHP world nowadays. I've developed applications from very small to very large with Laravel without any issues whatsoever. It's a tool, of course it's a bit too opinionated if you come from the Symfony world (I did), but no one is taking that control from you, as you can customize a whole lot of how the framework works.
Yes. I disagree with most of the above points except the breaking changes point for the same reasons cited by the dude above. 
Not when you need a cast.
Right, I get your point, totally valid yes. I still think that we'll have to start trusting the tools we have at some point (knowing we're not there yet, of course).
&gt; People seem to have distaste for Otwell, granted not all of the time. But he is a man who has worked long and hard and has some defensive qualities about his work as you would yours. I think this is the core of it. I think you're right, he's worked very hard on something that users get for free, and he is undoubtedly an extremely capable engineer. However, there's been some ALL CAPS SHOUTING MATCHES with other high-profile community members that may have had a long-term perception impact. It has been said here that people will always snap if provoked hard enough, and that in the above-mentioned cases there was a provocation from other high-profile developers - I don't know the truth of it. It is unfortunate that for Laravel, the internet never forgets, even though the good significantly outweighs the bad. 
Gotcha! I was thinking there it was something like TDD or BDD :D
If some of the core features of Laravel can just be commented out and not used and substituted with a real DI container or ORM, why no just use Symfony or another framework? 
I dont' use laravel for similiar reasons as the parent poster, but that doesn't mean I don't see value in it. It's really nice to have a whole suite of tools that just work together, like the built in queue functionality. It takes a lot of decision making out of the process when you're just trying to get something going to prove that a prototype does the job.
Ah yes, recording on the serving side is reassuring from an auditing perspective, as well as having the ability to feed that into testing scenarios. I'll have a play around with the things suggested on this page, it's great to have had so many suggestions (didn't find any of them when I first looked, perhaps I was focussed too much on a proxy-based solution). While I quite like using a proxy, as it means this part of the app can live in a separate microservice, I'd drop my approach if a middleware recorder presents a more mature/tested alternative. 
It doesn't seem it was that obvious to OP
What about Laravel's ORM or DI container make it not "real"? As for using Other frameworks, I like Laravel for the particular way it glues its components together, quick setup time, and relatively low barrier of entry. I haven't had the opportunity to battle-test Symfony with a large project but I've also had previous experience with CogeIgniter (ugh), Silex, and Slim.
Thing is that people are using the wrong tools for the wrong project. Laravel is great for developing something quickly, especially if it requires quality a bit of functionality If you are building an enterprise level site that will have years of development for features, then it you shouldn't be using it. It's like a carpenter complaining that a hammer isn't good at cutting wood. 
Oh man I just commented almost the same thing on another comment. Exactly my thing. Carpenters are complaining that their hammer sucks at cutting wood. 
It's just weird. It's like having an amazing car that has an auto start. If it breaks you take it to the mechanic and the he has no idea how to fix it since it is not a mechanical issue. So he has to learn how basic circuitry work to get it going...or tell you to take it to an electrician. 
I meant more along the lines that Facades isn't DI. Although Eloquent isn't an ORM, it's AR.
It's also harder to step through with a debugger and doesn't have great code inspection/completion with an IDE.
I'm not sure I'd say it's "hated". I would note that: 1. Like any package it has its strengths and weaknesses, it's good for some things, and less good for others. 2. It's got a very small number unusually vocal, enthusiastic supporters, many of whom seem unable to see the weaknesses and try and recommend it for every purpose The relentless promotion tends to push people who *aren't* in the Laravel fan club away from the package, just to try and form a sort of counterbalance to the cheerleading. &gt; Its a framework that helps you to rapidly get applications out the door. Ive used it from financial applications (huge) to my own site (small). Yes. But you could say the same of any PHP framework. Getting applications out the door fast is what PHP is good at; the people who pick Symfony or Bullet or CI or any other PHP framework did it so they could get code out the door rapidly. That alone doesn't set Laravel apart or differentiate it. &gt; People seem to have distaste for Otwell, granted not all of the time. But he is a man who has worked long and hard and has some defensive qualities about his work as you would yours. Otwell is significantly *more* defensive than most creators. He's well within his rights to be so, I certainly understand his reasons, but there are very concrete reasons why Otwell is viewed the way he is on this sub (which tends to be very sceptical of overly vigorous self-promotion). &gt; So I ask the community, if its not about hating or disliking a framework, why the fuss? if only sometimes? For the same reason that you posted this thread I suspect: Because people *keep talking* about Laravel. :)
&gt; Facades, Eloquent, global helper functions, blade template injection - all of those things are optional. So after you remove all of that, what makes Laravel Laravel still? Why not just use Symfony at that point?
Routing, Request Validation, Blade, DI Container, Authentication, Access Control, DBAL, Migrations, Events, Queues, Testing, etc. Sure I could pull that all in separately, define my own application structure, etc, but why go through the extra effort? The entire point of a framework is to avoid that.
This thread again... People have their reasons. End of the day it's personal preference. If you like it and it solves your problems, use it. If either of those isn't true, don't. Some devs are really, really against opinionated frameworks, preferring to make an individual choice and judgement call on every single thing their app does. Others love opinions because it helps them ship features faster. Different strokes. Not everyone has to love or hate a thing. Just wish people on both sides would stop ramming their opinion down everyone else's throats. 
Because as mentioned above just because a tool has something doesn't mean I need to use it. Likewise just because Laravel has something doesn't mean you should used it if it doesn't suite your needs or preference. And for a class to be really long... it's length in no way effects me as I never extend or modify or tie into it at the base level. I can rely on the abstractions above and let it do its thing behind the wall without caring. As long as it's doing its thing as advertised then it's fine by be. At least that's how I see it. Again to me it comes down to personal preference. And using what you like done use what you don't like. 
At some point, yes. I need to do work on the main project as well, but life has been in the way for a bit... If you'd like to use it, and like the dynamic switching, log a Github issue and I'll be able to remember to get around to it. A good solution I suppose would be extracting the decision of what mode to be in into its own class with an interface to allow for injection of custom logic...
&gt; So after you remove all of that, what makes Laravel Laravel still? Literally every other part of the framework. I don't understand the perception that Laravel is purely Eloquent + Facades + Symfony.
You obviously haven't even seen the content there if you honestly believe this.
I understand that you can not use Eloquent, the helpers, or blade, but how can you not use facades? It's a design pattern that the framework uses, not a feature? Edit: ignore this, didn't realise [Laravel has a feature for creating facades to injected classes!](https://laravel.com/docs/5.4/facades)
Eh there's not really *that* much magic in Laravel tbh (PHP doesn't really allow for that much magic). Most stuff still has to be explicitly declared. Work with Rails for a bit and you'll see "magic" (in the worst possible way)
I don't think so, that mostly comes down to your machines read speed and the network speed. In the future you may get more/faster answers if you just ask about Apache instead of WAMP/XAMP. Those programs are just wrappers
You can talk to your colleagues, right? I mean, they are grownups? You can have a tech meeting to establish ground rules about what should or shouldn't be done? You can enforce those rules via code review? 
I'm using https://github.com/arnaud-lb/php-rdkafka/ and it's badass. It's really about the C library underneath that the extension wraps (https://github.com/edenhill/librdkafka). It's an amazing piece of work by a very supportive and helpful guy that's helped me immensely. Using a C library isn't slower than using a PHP library (as indicated above). It's about your configuration and how you configure the setup. I've configured the C library and let me tell you it's blazing fast. I'm working on a system where I'm transferring 600million payloads.
I personally dislike it because of the grotesque SQL heresy that Eloquent seems to specialize in. Laravel isn't Eloquent, obviously... But they're packaged together and Laravel is guilty by association. Other than that, it seems like a fine framework. Source: am a grouchy and elitist DBA
Magic by its nature isn't understand. So that's fine as long as it works, but if something breaks it can potentially be an odyssey to understand why and fix the problem.
remove nginx, leave just built in php server for first few weeks at least.
There's little point in using a framework if you don't use the very features that are there to make your life easier. 
I don't see any reference to you including the file. Put include (connect file path); at the top 
I'm not understand what is target audience. From your list it's has nothing about programming. You could just skip first 4 steps. Don't force new devs to use phpstorm as just simple notepad. The only reason to use phpstorm for them is xdebug and I can't find it in your list. As for VM, apache+mysql and so on... Just skip it. 1. build int PHP server is enough 2. don't use SQL for now, use plain files. Let's devs understood that database is not so important. 3. SQL should be learned independently from PHP. At least first steps should be done just to learn concepts of RDBMS, SQL, normalization, ACID and so on. 
You fucking heathen! DIE() FOR LIFE!
&gt; Because as mentioned above just because a tool has something doesn't mean I need to use it. But it allows it, so that's why people don't like Laravel. It would make it hard on our team especially with some junior developers to make sure they don't use some of these hacks. Where are they calling these global functions? Where are they injecting these variables from? Why are they injecting a repository here and querying it? &gt; And for a class to be really long... it's length in no way effects me as I never extend or modify or tie into it at the base level It may "work", but why not do it a better way and abstract the different validators or have another design pattern? It makes me worry that someone that thought this is acceptable, what other bad designs, god classes, shortcuts were taken? The code our juniors do all "work", but do we want to commit and have to maintain all that code?
Some features make your life easier now but harder later. It's a tool with trade offs. In my judgement they're not worth the convenience for me.
Hum, in that view it still boils down to the basic (and admittedly poor) example I made earlier: we normally don't have trouble making specialized repairs, or going to a specialist to make them on things we don't understand or can't control, I find it weird that people gets fussy about it when it come to Laravel (or other framework that works magic I guess). If someone do want to work with that magic, and if something breaks, he either has to accept the fact that he's going to work harder to resolve it by himself, or find someone who can do it for him that understands the "magic". I can't be _that_ bad if you know what you're working with! (**edit** I mean, knowing the downside of your tools.) I mean, I get all of your (redditors who answered to my original question) point, and honestly as a Laravel user, those answers did make me think of my usage of the framework in relation to it's magic. And I agree with most of the stuff that has been said otherwise in this thread, but I still can't bring me to think that the "magic" of it all is a bad thing. I see it's possible failures, but I can't hate the framework for it.
Yes! But why would you hate the framework for it? It's not _all_ magic, and if someone don't know the downside of working with magic, that's their problem, and not to blame one the framework, no?
It's like the mysql_* functions have been bad for awhile and they deprecated them in 5.5 and totally removed them in 7.0, in a new version, not a release.
I'm not saying it is bad, it just requires a specialized knowledge. Laravel in itself is awesome. But if you aren't using it correctly, then it is on you as a developer not the framework. 
Yeah, I'm with you with that. (And sorry about me implying _you_ where saying it's bad, I was more reacting in line of OP's question here!)
Thanks for your point of view on that, I like how you've put it here, the framework being an enabler! I could rally on that! ;-)
But he's making it sound like that's the only resource. Having the stance of avoiding a framework because a random resource merely *exists* seems a bit illogical.
Bingo. Plus it's duct taped together... Oh god I'd hate to work in that codebase.
This this this. There's so much more to Laravel than Facades and Eloquent and it works very well for me.
You don't sound very open minded. So are you the idiot or the amateur?
Well it sounds like download speed would be the bottle neck then. If you are doing this over the web you should also keep in mind that ISPs are also limiting your upload speed. Apache isn't limiting download speeds.
Not sure why you'd be down voted for this... Seems like a valid question Edit: a word
That's the same shit C++ lovers like to say: jut because the feature doesn't mean you have to use it. Then you have to mantain code you did not write yourself and reality hits you right in the face.
If you die in the real world, do you die in Reddit?
This has to be one of the dumbest replies I've ever read. Delete your account. 
Why don't you just use dependency injection in Laravel? You act like that isn't possible.
This isn't strictly a php question (I am using symfony though). I have a form where the user searches for something. They will be brought to anothe page and choose one of the results and submit another form. They then go to another page where they submit a third form. They cannot go to form 2 without submitting form 1 and they cannot go to form 3 without submitting form 2. At any page they may go back to the previous page and make changes. Nothing is stored in a database (on my end). I receive the results from an API call. I store the previous results in the user's session. This works well decently well. If somebody leaves the process and goes to other pages, but then goes back to one of pages such as the second page they already have the results from their previous search. I don't want this to happen. I would like to remove their results from the session and send them to the first page for them to start the search over. I am unsure how to properly delete the results. There are two ways I can think of. First would be to delete anything unneeded in every action that is not related to the search. This would be tedious and error prone as I have quite a few pages. The second way I can think of is to wipe it out in a kernel event (in which case I would have to "whitelist" the routes related to the search so it doesn't wipe the session results for them). Neither solution seems right to me. Any suggestions would be appreciated.
&gt; The framework is enabling you to do it Life enables me to do heroin and meth, but I still avoid it because I was told that was bad for my health... Just like you can tell a dev "Hey, Laravel allows Facades but we prefer not to use them. Use DI instead. If I see any Facades in your PR's during code review, I'll have your head." Boom, you're done. If you have a dev who's itchin to use them facades after being told that you don't use them in your code base, then fire the dev for not following policy, or apply a better communication plan for your team. Stop putting your blame on your framework.
Because 90% of people that use the framework probably use Facades which tightly couples you to the framework. It's a really core feature if the language, what type of apps don't use a dependency injection container or database abstraction?
dd() would be like dying without clearing one's browser history.
Video is never a good format for code.
We almost the same setup apart from the fact that you use environment variables. Are those gotten from bash environment variables or from the .env file?
You realize Laravel is just a some new custom packages on top of Symfony components? It also would not be duct taped together, there's tons of documentation and interfaces between these components because they follow PSR standards. We recently took one of our Symfony APIs and wanted to make it faster/use less resources. Just composer installed FastRoute, http-foundation, Doctrine and a container. Within an hour we could have deployed.
&gt; You might not want to be locked-in to "the Laravel way of doing things", facades, etc cetera Using facades and the like isn't "the Laravel way of doing things" any more than using procedural code in one-off files is the PHP way of doing things. There are good ways and bad ways to use Laravel just as there are good ways and bad ways to write PHP. And those good ways and bad ways to write PHP can manifest themselves in a Laravel app even without touching any aspects of Laravel. Using or not using Laravel matters fuck-all if you don't know how to write good code.
*If* those packages are the exact ones the person uses. I've been in many situations where the person strung together a custom framework using obscure packages that their friends made. "Everything else would just be in Models/Views/Controllers/Services." That's really broad. Sure, maybe we can assume an MVC pattern. Knowing the pattern is a small part of the battle. Like someone above me said, you need to initialize all these things you're combining, configure them, etc. Look, I do see your point as well. And I don't think you're wrong by any means, Laravel is not always the right answer. But I also think using a custom framework is more rarely the answer. I've been in so many situations over the years where I wished the person had just used SOMETHING that I could easily Google answers to questions for. Also, most frustratingly, there are a few legitimate things people could bring up against Laravel, and yet the majority of this thread is filled with the same old debunked BS. Seriously, are we still complaining about facades in Laravel??
I've figured out the problem. The problem with laravel not working on my setup is because laravel needs to create caches and logs but since the webserver doesn't have the necessary file permission it couldn't do it. When I set www-data:www-data as the owner of app/storage everything started working. Thanks to y'all for your help.
Thanks. I'll watch those videos in the morning when I fully wake up. My host operating system is Arch Linux.
Can't emphasize this enough. Support went EOL 4 years ago. It's a totally insecure server now. 
&gt; So, I started to look around for an open-source playback/record solution, possibly implemented as an HTTP proxy, which I could customise to my needs. I started building this in Docker with WireMock, but I wasn't comfortable working in Java, and there was some drawbacks I didn't like, so I decided to switch the listener to PHP. I had the same experience. The specific drawback I had was that "proxyBaseUrl" is limited to a fixed URL, but I wanted it to vary depending on the request. I'm also not very comfortable with Java, but I decided to look to see if I could make an extension with my limited skills, [and it turned out to be really easy to have Wiremock set "proxyBaseUrl" from a designated request header](https://github.com/MasonM/wiremock-dynamic-proxy). After making the extension, I figured I'd try to get that functionality in Wiremock proper, [so I opened a PR and it was accepted a few days ago](https://github.com/tomakehurst/wiremock/pull/641). It's been released in Wiremock 2.6.0. /u/tomakehurst has done a great job making Wiremock easy to work with, so writing an extension may not be as difficult as you think. edit: The limitation of having discrete modes for playback and recording is not something you can fix with an extension, unfortunately. [There's an issue to fix it](https://github.com/tomakehurst/wiremock/issues/546), but I don't know the status.
I hear this retarded argument all the time, I feel like people just regurgitate it because they don't know any better. Laravel is perfectly suited for large-scale, scalable, "enterprise" applications. I know because I work on one everyday at work.
I'm currently going to start a big project whereby many of our "local" websites are merged into one giant global website for the charity I work at. I want to do it professionally and so i thought its high time I learned a framework. Out of the two most popular, symfony or laravel, i thought laravel would be the best. Now people are taking about the right tool for the job and I have no idea what to think. My website will need use login, multiple payment gateways /online shops for different countries, pages translated into different languages depending on where the user came from etc. So far I've been using my own "framework" (if you can call it that, it's not MVC) but I thought It's high time I learn something different. Now I don't know what to think. 
Sorry I don't understand
using pthreads shouldn't cause more windows.. but hell do i know what it is doing on windows OS =)
Shortest correct answer in the form of an analogy: it's a hammer, which is a great general purpose tool for a lot of things here on Earth, and my job mainly consists of analyzing rock samples on Mars. I'm sure I could use it to do my job, but a specialized tool is better.
Same, I'm working on an enterprise application and haven't come into any issues. I'm genuinely trying to find out why using laravel was a bad idea. 
yes, and we do. And 99% of the time there is nothing wrong. It's the 1% of the cases where someone made a "script to be only ran once", a "small prototype" or a shortcut because he/she was out of time. And yes, we have code reviews to catch those things but from time to time they slip through and you have to maintain that little bit of code that should not have been there in the first place. If the framework has me defining less of these ground rules that is a big pre in my book, less time doing reviews, less time maintaining code that does not follow the rules. And to me, Laravel has too many of these ground rules you need to enforce over something like Symfony.
&gt; remove apache
But would it not be better if you didn't even have the option to do so? You cannot even make he mistake. Saves you the effort of telling it to new people and enforcing the procedures. Like I said, we have a lot of people with even more code. Having less rules to define just makes it easier for everyone involved.
But if you're not using the shortcuts a framework provides, then what is the point of using that framework?
I need to use multi-threading for my code in Windows. I don't know how to applying this in PHP correctly. Usually i use PHP cli parent and child. Parent.php can call child.php multiple time without care to waiting once curl request done and loop. It can run unlimited cli window in the same time depend on the memory and processor of the PC. For example this code below will loop curl request one-by-one (it depend on connection and server request for each curl get request to be done). What i want is requesting it 20 at once in the same time: &amp;nbsp; &gt; ... &gt; &gt; &gt; &gt; include 'model.php'; &gt; &gt; &gt; &gt; $model = new Model(); &gt; &gt; &gt; &gt; for ($x = 0; $x &lt;= 20; $x++) { &gt; &gt; &gt; &gt; $page = $model-&gt;curldah("https://www.example.com/api/place/pixel.json?x=".$x."&amp;y=280","","","","",""); &gt; &gt; &gt; &gt; } &gt; &gt; &gt; ... &amp;nbsp; should i use Python for this case? i hear Python faster than PHP for this.
At least Symfony has it's own subreddit but you don't find tons of questions like in the one from Laravel, mostly news.
If the framework permits those kind of errors and code reviews fail to catch them, I definitely blame the framework. When I use a framework like Symfony, I don't have to worry about terrible code in reviews, I don't have to worry about static calls or service location in templates, simply because it's not in the framework. Not being able to use "bad" design patterns reduces load of code reviews, it has nothing to do with laziness or bad team communication. I always recommend people to read this: http://ocramius.github.io/extremely-defensive-php/#/ and I'm sure there's a presentation of it online as well.
For "only run once", I wouldn't give a damn. If it's going to be genuinely run once and thrown out, it really doesn't matter. Likewise for genuine prototypes. If it's right 99% of the time, you're doing fine. 
I've supplied a .env.example file, I rename that one tot .env for it to work. I was under the impression that that naming convention was sort of the standard.
It makes it rather time consuming. When you have a whole bunch of technologies to evaluate for some project, it's easier to just be choosing between those for which you can quickly access information.
I know you rename it to .env what I want to know is if docker-compose automatically loads .env files 'cos you didn't add env_file: .env like I saw in the documentation.
Laracasts is not a resources for comparisons with other frameworks. It's meant for people wanting to learn about building things with Laravel (specifically) and PHP/JS (generally). Perhaps you've tried to use it for comparisons, but that's not the problem is was made to address. You wouldn't read a Deep Dive into Astrophysics if you wanted to know who you should buy your next rocket ship from.
https://github.com/docker/compose/issues/4223#issuecomment-280077263 Just confirmed that .env file is automatically loaded. Thanks.
&gt; It's meant for people wanting to learn about building things with Laravel How else do you compare frameworks other than looking at the nuts and bolts of exactly that? &gt; Perhaps you've tried to use it for comparisons, but that's not the problem is was made to address. ehh? You've misunderstood. I need to find a tool for a job. I look at the tools to see their form, see how they actually work, I might be required to investigate rather deeply into certain aspects of their use. &gt; You wouldn't read a Deep Dive into Astrophysics if you wanted to know who you should buy your next rocket ship from. I might... I like to know how things work, have answers for all my questions. I can scan Deep Dive into Astrophysics in a night, I can't do that with Laracasts. 
&gt; ehh? You've misunderstood. I must have. I can't understand how you think that video is never a good format to learn code, or why the existence of a single educational platform should be enough to put someone off from learning the framework. Stupid me, I guess...
Does the lack of LTS versions bother you at all? How about the lack of semantic versioning of releases?
Why?
Not sure why this gets so many downvotes. I'm severely against video tutorials as well - I can't copy paste. - I can't simply read when I want a what speed I want. - I have to endure accents which aren't always as good. - I have to endure people's desktop habits. Sure people can like it, but I agree that this can be a big turnoff.
Same goes for video tutorials
Because some of us are still stuck with legacy apps maybe :-s
And here you are, whining about people whining over twitter. You took a tweet out of context, built an argumentation around it, and clumsily labelled the entire PHP "community" as toxic. How is that supposed to be constructive?
Where did I label the entire PHP community as toxic? I said that there is some toxicity in the PHP community that is frustrating a lot of people. I think I praise most of the things our community has achieved over the last 10 years and I strongly believe we could achieve even more if we would stop criticising each other's work so often.
&gt; On toxicity in the &lt;insert name of open source project&gt; community You could do a series of these posts. Every community has conflict and trolls. 
How did I know, before clicking, this would have references to Laravel or it's creator...
Some are alright if well paced. Laracasts and Udemy mostly.
Maybe better to write a slightly longer bit about toxicity in tech communities in general. Highlight negative consequences, show alternatives. It's just sad really.
I agree with you there (and your article itself). It would be nice if leaders took the high road and ignored the trolls rather than throw lighter fluid. It's enabling vs curtailing. He and his framework are more than successful enough to speak for themselves without engaging with the toxic minority.
Probably, yes. There's no point in singling out one community as it makes it look worse than it is. 
Ahh, got it! Yeah, as you already found out the `.env` file gets loaded automagically if it's placed in the same directory as your `docker-compose.yml`
To me, the community is not toxic at all. You shouldn't listen to a noisy minority and focus on people willing to discuss calmly about their point of view.
Why not reset it on the first page of your process? You could put that action in between, so you link to a url that resets and then it goes to the actual first page. That way it won't be reset by going back.
Well, the php subreddit is particularly toxic.
Wow what a fantastic article! You really got deep into the heart of the issues in the PHP community while singling out two individuals and singing the virtues of the unfaltering FIG committee. Bravo.
Particularly? More so than others? Perhaps some but less so than others. It'll happen.
how does the amount of stars even prove any point? I've never starred a project but I've used symfony in many professional apps at work... also, the bulk of projects on github *are* tiny, small, hobby projects... so if stars had the meaning he implies, he's actually confirming what reddit said?
Throw enough people together in a virtual room on the internet and toxicity *will* ensue regardless of context or subject. It's always been like that and will continue to be so on the current state of the internet. I think not giving such negativity an audience and focusing instead on the positive things are good methods to handle this situation.
Can you elaborate? With preferably comparison to other, tech-related and/or (web) development-related communities?
Did you mean to reply to my comment? I was trying to ask for what brought him to post this tweet/picture You can read /r/php almost every day and be told framework x sucks, use framework y. I was just curious what specifically prompted him to tweet this. Surely there was some poop flinging going on somewhere in the interwebs
I don't think it'll go away. It might lessen at best. But I think that here, and pretty much anywhere, would be a better place if we stopped focusing so much on the negative aspects of it and instead look on the positive things that we have in common. Unique opinions, experiences and stories. Live and let live.
Taylor bit the troll bait on Twitter there, but I don't think it's all that bad if you don't overexaggerate with a large ego and feed trolls all the time. I have respect for Taylor how he engages with his audience, even on responding trolls like this. I've seen too many parties that are completely silent to their userbase, only to do as they please. We're all only human after all.
I'll have to give it another look, because when I read through it yesterday it was 90% "Laravel sucks for large projects, but I won't cite reasons, examples, etc."
&gt; Let’s not applaud people who are actively contributing to belittling the hard work of others and &gt; It seems like we have already forgotten that Laravel was originally inspired by CodeIgniter and has used various Symfony packages since version 4 Both statements written by the same another in the same article..... Contradiction much? **Although I agree with the general tone of the article** you can't moan about belittling of projects then say Laravel is just using various Symfony components 
I completely agree, it's a complete bag of **** but unfortunately some of us (myself included) are stuck with huge monolith code bases with over 100,000 lines of code which we simply can not switch to a new framework without extensive time and money investment which customers are simply not willing to pay for. If anyone is interested I wrote an article about getting blade templating into CI, it might help a few others out who want to start using some more modern techniques http://mstd.eu/index.php/2017/03/02/using-the-laravel-blade-templating-engine-in-codeigniter-3/ Also started a series about getting webpack integration in for modern build techniques. http://mstd.eu/index.php/2017/03/02/using-webpack-in-codeigniter-3-step-1-set-up/ 
Thanks for your response, that's great info!
&gt; Every request is self-contained, and cleaned up when it's done For me this is one of the things PHP got correct when it was originally conceived
Well, it doesn't happen that often but, comparing with Ruby, Java or Python, the PHP subreddit IS toxic.
&gt; Node can retain state across requests I'm not sure this is a good feature in a web based application. The web (HTTP) is designed to be stateless and finding ways to maintain state doesn't feel like a good feature for a web based platform. Although its now (mostly) essential to maintain state on web based applications maybe HTTP being stateless makes it not the best protocol for the modern web?
This x100. Since writing Laravel, I have had the opportunity to meet a lot of PHP developers and the *vast majority* are totally unaware of everything that happens on /r/php and the PHP twitter-verse. People that tweet routinely about PHP and that on this sub-reddit would be considered "community leaders" are totally unheard of by a large portion of PHP developers.
More things are written in C, should we drop node and PHP and write only in C? /s
Great. What does that have to do with Laravel? You hate Laravel because one website offers Laravel video tutorials?? I encourage you not to visit Lynda.com, or you'll find reasons to hate lots and lots of tools and frameworks. 
Overall interesting points. &gt; not the user-interface logic (i.e., front controller / routing / etc.) With your above statement, how best would you introduce a global authentication across an entire application? I.E the application is a dashboard and every single page and action should be authenticated? An application I inherited had this logic in the front controller (in an MVC* style framework) to handle this at a global level. I moved this out into a parent class which every other class inherited from. What would be a better option?
Read it again. I don't think there's any contradiction. He's not belittling Laravel by saying it's "just using various Symfony components." He's drawing attention to the fact that people trash Symfony, but Laravel has it's roots in Symfony. There's a difference between saying something "has used various Symfony packages" and "is just using various Symfony components." One states that Symfony packages were used at some point, the other implies that that's ALL that's ever been used. To be clear, I love and have used both Symfony and Laravel. 
&gt; Given that PHP 5.6 will be officially supported until 2019 and that many hosts and businesses are slow to upgrade, it will be years until PHP's libraries, packaged applications, and frameworks can depend on features present PHP 7.2 or higher. With such actions, it will take longer... :/
AFAIK you can serve PHP files with Apache Tomcat. This should allow you to run your PHP app on Android, but there is no reason to do that. You are probably better off writing a PHP API, run it on a public webserver and write the client app using PhoneGap or something similar. Depending on what is your use case and target audience, you may be better of doing a mobile friendly web page or learning about Android/iOS programming. Also worth mentioning the Qt, which is a cross platform GUI framework and Unity which is a cross platform game development framework. What ever you do, just make sure you try to choose the right tool for the right job, even if it means you have to learn something new. Don't try to use &lt;insert your favourite language here&gt; for everything.
&gt; For the dumb of us... what was the context He's replying to the many people who say Laravel is just a toy framework and is no good for enterprise/high volume applications. Although Github stars isn't a great measure its certainly doe's seem absurd that people keep referring to Laravel as a small time player in the PHP landscape.
The internet gives everyone a voice, for better or worse. I feel like this kind of negativity will always be there.
Is there some function / interface my class can implement so that there's custom comparing going on with the spaceship operator? For example, I have a class `Review` with the properties `rating`, `from`, `to`. Imagine 2 instances: $review1 = new Review(); $review1-&gt;rating = 2; $review1-&gt;from = "Peter"; $review1-&gt;to = "Claire"; $review2 = new Review(); $review2-&gt;rating = 2; $review2-&gt;from = "Peter"; $review2-&gt;to = "Claire"; $compareResult = $review1 &lt;=&gt; $review2; // Should be the result of: $review1-&gt;rating &lt;=&gt; $review2-&gt;rating 
Yup, I felt like this article embodied the exact thing it was talking against. He says Taylor uses a "flaky statistic like github stars". OK, it's not like he was using it to back up a specific fact. He was trying to generally point out the popularity of Laravel, which Github stars are a pretty good metric of. Then he says he's using it to "promote his own work and belittle the work of two other major frameworks that drive our language". First of all, calling this a "promotion" is a bit drastic. But even if he was using github stars to promote, who cares? Plenty of open source projects proudly talk about their github stars. And like you said, how is he belittling the other frameworks? Laravel is built on symfony components, why the hell would he belittle them? He speaks highly of symfony all the time. I'm sure we'll be written off as Laravel fan boys, and I am a fan of Laravel. But I also recognize Laravel has a few flaws. I just wish people would come up with better arguments and not make a blog complaining about toxicity while comparing people to monkeys throwing shit. It's just a bad look.
&gt; It seems like we have already forgotten That does seem belittling to me, but each to their own
&gt; grotesque SQL heresy that Eloquent seems to specialize in Can you elaborate?
Whether ADR or MVC, you should be able to create a Service Layer object (or Application Service object, or Use Case implementation, whatever) that handles admin functionality. You controller method, or your action class, then calls that service. Some options off the cuff: A base Admin Service object (if you have one) calls "isCurrentUserAdAdmin()" early in its invocation. You can build either a family of Admin Service objects that work that way. Or you can build a single Admin Service with multiple methods that way, where each one invokes a similar method. Or you can write an intercessory service that does the authn/authz checking, and only passes on to the "real" service if the auth check passes. (Or an intercessory method, like `__call()`.) That's a little less direct, and doesn't deal well with typehinting/auto-completion, but does makes it easy to centralize authn/authz in the domain (or in parts of a domain). With a mature ADR system, the return is always a Payload, so the return typehint might not be such a big deal. There are other ways as well; I hope these brief suggestions serve to spark your imagination. :-) 
On toxicity of X -&gt; continues to write toxic blog posts. Checks up, thanks /u/jonasdrieghe To clarify, I agree, PHP reddit is one of the places where you should not come for PHP related discussions, but giving same "tone" as you said about Taylors tweet to your blog post is not going to help anyone.
&gt; Think about this for a second. This is a community leader who is the main driving force behind one of the biggest PHP frameworks today, using a flaky statistic like Github Stars to not just promote his own work, but to belittle the work of two other major frameworks that drive our language. And one of the frameworks he belittles (Symfony), powers his own framework (Laravel). He never understand why this is so ugly. It's like mocking PHP while promoting a PHP framework you made in it.
lol
Further, you might want to have your domain logic only return entities that the current user is allowed to read. You would do your authorization checks for read permissions in the domain, and return only the ones that the user has access to. Then in the view, if there's no entity to display, there's nothing to click on, and thus no route to protect. ;-)
He is stating his opinion about Laravel, which I can see why he thinks of Laravel what he does. I don't see anything wrong with that.
Reading is hard for some and those authors take advantage of that
I use Docker for PHP development and production(corporate intranet, so I can't speak on internet-facing applications) and it works great. I used [docker-symfony](https://github.com/maxpou/docker-symfony) project as a reference when setting up my servers. I don't have experience with Laravel in a Docker container so I can't comment there either.
After creating my thread asking why [Laravel is hated or disliked](https://www.reddit.com/r/PHP/comments/64e4ji/why_is_laravel_disliked_or_hated/?utm_content=title&amp;utm_medium=user&amp;utm_source=reddit) And then seeing [Taylor's make a poor choice in words and flaunt his framework](https://twitter.com/taylorotwell/status/851243875649806336) I can understand how there is this sense of elitism in this community, maybe not just this one but all communities. Its become more prevalent here with the way people handle things. PHP use to be known for ugly, spaghetti code, and to this day it gets made fun of, even with 7.1 out. Instead of creating deplorable tweets as the one I linked, why not contribute in a positive way instead of acting like a big baby? This blog post points out the hypocracicy some members have in this community and the High horses they ride on. Some one told Taylor to get off reddit, I really think he should, especially with that kind of attitude. The replies ranged from "How is github a way of measuring" to "stfu" (not exactly, but essentially). Github is a pathetic way of measuring the success of something, IMO. It is used as a popularity contest. "Oh my project has more stars, it's better then your puny 8 star project with one fork." It's elitism at its best and it breeds stupidity in project creators. This whole thing is really sad. It makes me look at Laravel differently, especially its creator who I have more and more distaste for. You don't see symfony acting this way. What he doesn't realize is that his actions, the way he speaks to people, paints him in a not so glamorous light for the rest of his career. God knows what it's actually like to work for a man of this nature. We as software developers re-invent the wheel over and over again, perfecting the bumps and the edges. We get yelled at in the community for re-inventing the wheel, even if it's for learning. We do it any ways. Most of us do it for learning and we do not flaunt it as aggressively or as rudely as this "man" does. I really hope he grows up, because this kind of attitude only further divides the community. We already have one DHH in the world of OSS and we even have a Zed Shaw. We don't need another.
- **PHP as a platform is huge**. It run's everywhere: from cheap shared webspace to cloud services. - **The language maintainers are extremely aware of BC breaks**. That's why you can find code samples from 2007 that still work. You probably should not use them, but you could. - **PHP does not re-invent the wheel every couple weeks**. We now got PHP-FIG, Composer, the Symfony Components, and so on. - **PHP is easy**. (Most of the time) You don't have to worry about Garbage Collection, State or Concurrency (read [Taking PHP Seriously ](https://slack.engineering/taking-php-seriously-cf7a60065329) from Slack). 
Is this really a valid concern in 2017? You can get entire VMs now for $3-$5/mth that you can run anything you'd like on. The days of having to SFTP code to a dedicated server outside of your control are sortof over no?
Javascript has getter and setter methods, and you can use ES6 proxies if you really want __call like traps.
It's just anecdotal evidence in my case. I notice it when reading responses to anything Laravel related or whenever Taylor posts. There are some hard core "best practise justice warriors" in here that likes to bash anything that goes against the grain.
That may be true. A native implementation will perform better anyway and React Native now makes it possible to make one without learning Java or Swift. 
yeah buy damn near nobody is over at /r/phphelp There's damn near nobody anywhere except framework specific places like larachat. Now, I might suck at google, but I've been looking around recently and that's what I've found.
Looks great. Its a shame it does not seem to support Discord natively.
&gt; you can already feel this community is set up for greatness. I think this phrasing belies a fundamental misunderstanding. There is no single PHP "community", in the sense that everyone who uses PHP in any way "communes" with everyone else who uses PHP. There's a Symfony community, a Zend community, a Laravel one, a Code Igniter one, a WordPress one, a Drupal one, dare I say an Aura one, dozens of others, and thousands of otherwise unaffiliated developers. Some of them gather in multiple online spaces, and some of them gather *nowhere*. I opine that if you think of it more as patchwork of overlapping interests, you'll have a more-applicable model.
"On toxicity in the PHP community" - A toxic article by a member of PHP community, 2017
Reading between the lines, I get the feeling the author is jealous of Taylor's success.
Looks great! Was looking for something like this. For some members in my team i message to telegram, but others don't use telegram. So was looking for something that can send messages to each member, whatever platform they use. Everyone uses slack, so i should probably just use slack for everyone. But where's the fun in that 😉 Edit: wow, the NLP intergration is a really nice feature. It supports Dutch (my native language) so playing with this will definately going to be my next pet project! Thanks, really nice person, for creating this package 👍👍👍 
I'd very much like to see a concrete example of this, it seems to have lots of magic behind, maybe I'm mistaken but the bundles.php file seems something like very magical: having a kernel registering its own configuration and bundles was pretty much straight-forward and very explicit (and easy to step debug into). Aside of that, all the directory name a the flattened folder structure makes much sense to me.
The author clearly doesn't understand the meaning of irony.
As someone who uses Silex extensively, I'm looking forward to Symfony 4 and it's emphasis on starting small and adding components as you go.
Feel free to do a PR ;)
&gt;&gt; 3) Can we stop acting like babies and embrace each other’s work? &gt; I think I like this strategy more. Jonas, I agree. I think I like this strategy more as well.
&gt;Using facades the like isn't "the Laravel way of doing things" any more than [...] I know facades are not "Laravel", but a design pattern, and you are totally right. But --as you might have noticed-- a lot of Laravel-bashing on this sub is about the way Laravel uses them. This was just an example. Not about me (dis)agreeing with facades in Laravel.
Some good changes here, but ... &gt; The new etc/ directory is the equivalent of the current app/config/ directory. &gt; &gt; Web files under web/ ... it might be nice if Symfony 4 adopted more existing common practices, used by [roughly 70% of Packagist packages](https://github.com/php-pds/skeleton_research#addendum): "config/" for top-level config directory, and "public/" for top-level document-root directory. Cf. [`pds/skeleton`](https://github.com/php-pds/skeleton/tree/1.0.0). EDIT: Further review of the research reveals: - `config/` is used ~10x more than `etc/` ([ref](https://github.com/php-pds/skeleton_research/blob/1.x/results/addendum-dirs.txt#L76)) - `public/` is used ~2x more than `web/` ([ref](https://github.com/php-pds/skeleton_research/blob/1.x/results/addendum-dirs.txt#L36))
no. curl has been around longer than PHP. PHP just provides an extension to bridge the libraries. 
I honestly don't think that's possible. No offense to taylor, and I do disagree w/ the article, but time and time again there hasn't been a time when he hasn't been reactionary to drama involving him or laravel. I think that's why he's a target since people know he's going to respond. I do agree though, he should start ignoring this shit. 
Thank you for the non-medium link &lt;3
I would. We're different programmers with different goals. Let me give you an example. Say I wanted to use PHP objects to write Groovy (something I've done before): &lt;?php class PHPGroovy { public $stack = array(); public function __get($field){ $this-&gt;stack[] = new Arribute($field); return $this; } public function __call($name, array $ags = array()){ $this-&gt;stack[] = new Function($name, $args); return $this; } ... } $g = new PHPGroovy(); $g-&gt;V()-&gt;has('id', 15)-&gt;name; echo str($g); // g.V().has('id', 15).name Now I couldn't do the same thing with JS objects because Proxy can't capture a non-existant method and attribute call at the same time
&gt; By writing their own framework, a developer can truly separate themselves from their competition gold
It's not javascript.
Slightly off-topic since it doesn't involve apache, but if you're using PHPStorm, here's a simple demo for a PHP project that spins up a docker container for its unit tests and interactive debugging. https://github.com/DHager/docker-php-library-demo
It really annoys me when somebody asks some very basic beginner question, and all the answers are "you should use pdo/laravel/oop/nodejs" instead of helping with the problem.
Not making fun of PHP = not getting any upvotes here
During last three or so years I've helped Spiral with reviews of both code and design and can say it definitely deserves attention.
I was just trying to provide a helpful answer to you and other readers; there's no need to be an asshole.
Complaining doesn't solve problems either. Be a positive role model if you want to inspire change in others.
"All great developers write their own frameworks." Don't we all write our own frameworks!?