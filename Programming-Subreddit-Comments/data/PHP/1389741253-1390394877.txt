If possible, go with jquery(javascript framework) for client side code(will save you a truck load of time). And for your Question, It doesnt matter!!. i did php for 1 whole year (didnt know much javascript back then) when my client had a requirement which had a ton of javascript, i had to learn that then. PS:: Object system is based on prototype in js (unlike php/java/c#) (you might have some trouble for the first time(but, you'll get used to it / you wont have to deal with that much)). 
All this is available only internally right now? Is there any way in userland to detect `RETURN_VALUE_USED`?
try global $mysqli; after function RegAccount($Username,$Firstname,$Prefix,$Lastname,$Company,$Password){
This is exactly what I was thinking. I'd just write my functions to ALWAYS take params by reference, and only modify it based on `RETURN_VALUE_USED`
It might be more appropriate in Perl where you can detect if the return value is a scalar or an array. In that case it's much more appropriate, but not relevant in PHP because we don't differentiate between the two.
Honestly, I don't even know how to respond to that. I'll just assume you're a total noob, which we all were at one point, and kindly explain that you're talking nonsense (no offense!). Arrays aren't scalars, you can't multiply them by a number or take their square root. Scalars aren't called scalars in PHP, and they are treated fundamentally and wildly different from arrays, because they are. A scalar, by definition, is a single value, whereas you can think of an array as having zero or more values. An [array](http://www.php.net/manual/en/language.types.array.php) is like a collection, a sort of list of values, if you will, just to keep it simple. Each of those values can be a number, a string, an object, or itself an array. *edit: or a closure!*
&gt;Um, you're saying frameworks are bad because you may want to use a different router implementation for different projects? No, I was telling that frameworks should not bother about implementation of a concept. The router was just an example. By telling that any well designed router could handle any project, you seem to miss the point of my argument, which is, frameworks should not bother about implementations. May be I should have chosen a better example. Say, configuration management. For a simple project/prototype you may just want to use a configuration manager that let you write configuration options in a key,value format. But for a big project with lots of nested configuration options, you might want to use a configuration manager that supports YAML configuration files.
&gt; In other news, you should use PDO instead of mysqli. I really don't want to flame - but mysqli is perfectly usable in PHP, it's not just a simple "you **should** use PDO"
&gt; Open source library for managing email with PHP IMAP API Thank you for contributing. Your application is not a library and it is not usable outside of the context of your specific yii application. Your Remote class is hard to read, the formatting is off and you have function calls in weird locations that make it difficult to follow at a glance, you use single character variable identifiers instead of descriptive ones (ex: $s instead of $sender). There is more but you might consider reading an OOP book, and the PHP-FIG might be interesting on improving your code readability. 
It may be perfectly usable, but personally, I've not seen mysqli used in many years. The standard is pretty much PDO now a days, doesn't hurt to learn it instead.
First off, it sounds like you're building one big honkin' regular expression to check for a bunch of different things. Don't do that. It's cumbersome, confusing, and error prone. Do each validation separately. The performance difference (if any) will be insignificant. To check for lowercase letters: &gt;`preg_match('/[a-z]/', $foo);` To check for uppercase letters: &gt; `preg_match('/[A-Z]/', $foo);` To check for numbers: &gt; `preg_match('/[0-9]/', $foo);` or `preg_match('/\d/', $foo);` Now, you don't explain what "special characters" are exactly. I'd say it's better to be inclusive rather than exclusive, so define what are *not* special characters and check for those. Maybe something like `preg_match('/[^a-z0-9_-]/', $foo)` which would return true if `$foo` contains anything that's not a letter, number, underscore, or hyphen. Make sense?
It is pretty clear there are a couple of fan boys, but for the most part, the community seems open and friendly. 
I think the most helpful thing missing is a 'view all games' link.
That's a good point, I was thinking the main use would be people who already know the game in their head that they want to go to. But as this is a game database, a full games list / search implementation would probably be an important feature. Thanks!
Looks clean! Did you use any particular frameworks such as CodeIgniter, Bootstrap, JQuery (those are my go to frameworks at the moment)?
If OP does this, he'll be left with two problems.
The design is nice and clean, which I like. The search button doesn't do anything by itself though; I have to search for something that exists and select it from the dropdown. To make the database more useful, I think it'd help to create more ways to navigate games as well, e.g. searching by genre, platform, year, maybe a "similar titles" or "people who like this also like...", although the latter would probably require a social aspect. I think you also want to reconsider letting anyone edit like this, with no approval process, otherwise, sooner or later, somebody's going to just start wiping games.
A "most popular" type link would be cool too!
Hi. Thanks for your comments :) Yeah I need to look at the search functionality of the site I guess. Definitely need to look into having a more full fledged search feature (like you said, with genre/platform searches). As for new games / edits etc., they all go through a pending queue which I accept or reject. Hopefully if I eventually create users I can reward users for contributing and give them some kind of status where they don't have to go through the approval queue. Thanks again for your comments :)
It's alpha, I guess I forgot to take out some old dev messages though :p Can I ask what you were doing? I think that only shows if you try to direct URL a game ID that doesn't exist, right?
I'd forgotten about the validator, I'll add it as an issue on github and start working through it tomorrow. Fixed the gitignore. RE: Class getters, I think I had an idea of how they were going to work at the start, and then I didn't. I need to go through all of the old stuff again so it's a valid point. Will look into making select statements more specific. Thanks!
I'm actually gonna break from the mold and say it does matter, but only if you want to learn other languages and this is your first language ever. In that case, go with PHP. PHP is a **lot** more like other procedural/object oriented languages. The things you find in PHP will be in Java, Python, and Ruby (Interfaces, real Classes, Traits/Mixins, real inheritance). PHP might be less predictable than those languages, but its a lot more like them than JS. JS sort of stands alone in how it works. Nothing to my knowledge uses the prototypal model (but I'd really love to know if I'm wrong, always been too lazy to research that) and JS doesn't have traditional classes, inheritance, and OO support (e.g., Interfaces). It also pretends to run async with a lot of the code you write, but is fully synchronous. Then there's supporting multiple browsers, which is a total shit show. The event architecture and manipulating the DOM are not only pure JS things, but they're 60% of what you do in JS and are not transferable skills. So, JS skills aren't easily extrapolated on if you're new to programming. That being said, if you know a programming language pretty well already or are good at picking them up, it doesn't matter. Once you know one, you can learn and transition between many of them pretty easily (Google always has your back), so JS or PHP is moot.
I lol'd. To that end, some graceful exception handling would be nice.
&gt; The performance difference (if any) will be insignificant this is not true. regular expression searches can potentially take up a ton of resources depending on where they're used. if I am reading what you're saying correctly, you're going to be traversing every single character the same string multiple times. having said that, the number of multiple positive lookahead expressions in Iceline's example is bad and should really be accomplished some other way. Iceline, would it be possible to provide an example string you're searching from and what you want to capture exactly?
I can't upvote this enough. It's *crucial* to learn the client/server paradigm very early in the process.
I'd guess he was reading your code, since you linked it.
Other developers will likely hate you for this; don't do it.
Very nice critique, thanks very much. I'll get started on this tomorrow :) Edit: I think the main thing people have picked up on is the lack of search, I guess in my aim to make it simplistic I neglected a lot of UX. For YouTube videos, you're right. It was pretty lazy of me to force them to enter 8 characters. I should just perhaps let them enter a URL, select the video type from a dropdown (YouTube,Vimeo perhaps), and then do some server-side validation to trim the bit I need. Your ideas are welcomed, and some I have already worked on / considered, so I expect I'll get working them when I get all these initial things fixed :) Thanks again.
Viewing the source code, I see that you do at least use JQuery. 1) I'm curious about the routing code. Your site has nice clean URLs, do you redirect everything to an index.php file using .htaccess? 2) As for the database layer, do you use an ORM (e.g. Eloquent, Doctrine, Redbean) or just regular PDO? 3) At the time of this writing, your github link returns a 404.
You are wrapping the article content of the database in a &lt;pre&gt; tag to preserve paragraphs. While that works, I think it's not semantic html: text paragraphs should be wrapped in &lt;p&gt; tags. Maybe a possible solution could be to use a regular expression to match anything between new line characters and wrap it in &lt;p&gt; tags. There is probably a standard way of doing it, but I'm learning PHP myself and I have no experience doing it, it's just something I noticed inspecting the code. I hope someone improves this answer!
You're right, there are better ways to do it. But this was my lazy workaround for the moment. As I said, I never release anything so I'm OK with workarounds for the early stages providing I actually get something out there, but it's something I will come back to fix.
Or why not just a configuration manager that supports both? Perhaps through a nice OO pattern where you could supply a different driver per configuration you want to handle? Frameworks are meant to make life easier. You have one router and one configurator etc that exposes a consistent API and you don't have to think about routing or configuration ever again - or at worst case you have to build a new driver for some unique config requirement.
Doesn't matter. And you'll know more than the people that just know Javascript!
Creating the suggested "indexes" will also help with search engine rankings (this is SEO). Put a site index on the main page that has direct links to the indexes to make it easy for the engines to pick it up. Make sure you use well formed structures for navigation too!
Gonna have to agree with you on this one. I started programming in ActionScript 3. Everything I learned about Object Inheritence, Polymorphism, and Encapsulation carried across a multitude of languages except for Javascript. It's not that Javascript is *bad*..... it's just that in order to get it to follow the standard patterns and behaviors of Object-Oriented languages, you can only kind of do it, and it doesn't always work that well. Nobody should start with the exception to the rule if it can be avoided.
[ಠ_ಠ](http://pbs.twimg.com/media/A_-wgVtCIAAgJlV.jpg:large)
I enjoy a good challenge. * Maximum length (If I fill in a number after the 6, the string is still validated, even if it's longer than that. Example: {6,32} still validates a string longer than 32 characters ): (?=\^\S{6,32}$) * No lowercase letters allowed: (?=\^[\^a-z]*$) * No uppercase letters allowed: (?=\^[\^A-Z]*$) * No digits allowed: (?=\^\D*$) * No special characters allowed: (?=\^\w*$) Just knowing these two special operators would've allowed you to solve the problem yourself: ^ = start of input, $ = end of input. EDIT: I noticed you're using $ as your delimiter. Try using something else (as $ is a special character in regular expressions!) I generally go with @, #, or / based on my pattern content. EDIT EDIT: Wrote you a function! function validate_password($password,$rules,$length=Array()){ $restrictions = Array( 'lowercase'=&gt;Array('[a-z]','[^a-z]'), 'uppercase'=&gt;Array('[A-Z]','[^A-Z]'), 'digits'=&gt;Array('\d','\D'), 'special'=&gt;Array('\W','\w'), ); $regex = ""; foreach($rules as $rule){ $invert=0; if($rule[0]=="!") { $invert=1; $rule=substr($rule,1); } if($restrictions[$rule]) { $regex.=($invert?'(?=^':'(?=\S*'). $restrictions[$rule][$invert]. ($invert?'*$)':')'); } } if(!empty($length)) { $regex.='(?=^\S{'.$length['min'].','.$length['max'].'}$)'; } return preg_match('@'.$regex.'@',$password); } **Usage:** //Password must contain lowercase and uppercase letters, special characters, and no digits allowed, with a minimum length of 6, max of 8 characters $valid=validate_password('AbCDE$F', Array('lowercase','uppercase','!digits','special'), Array('min'=&gt;6,'max'=&gt;8) ); Happy coding!
Here is the error in the console, in Chrome on MacOS: Update In Chrome on MacOS, here's the error in the Console: Uncaught SyntaxError: Unexpected token &lt; On Line #13, which is the &lt;?php line. 
Well, the PHP doesn't resolve itself. In the source code for the PHP embedded in the HTML, the PHP code shows up as is. But, I've checked the commas etc, it's all good.
I can see some place something like this could be used. But I am not sure how pretty the result will be. It is when magic methods like __set and __get is used, it can return an object, for method/access chaining or a scalar, depending on the context. So for example, if $obj holds some nested structure like XML $name = $obj-&gt;name will return a string and '$obj-&gt;name' part in $obj-&gt;name-&gt;initials = 'cr' will return an object so that further processing can be done. In the example, it is used to add a new node, 'initials' with value 'cr' to the xml. 
You, sir, have my thanks. Job done.
When it comes to learning anything, not just webdev, you need to learn through doing in addition to learning through formal means. 
Thanks - I misspoke in using the term library - but it can be used as an open source platform to build new email features: like [Do Not Disturb](https://medium.com/the-age-of-conversation/eaeb4efdad13), [Encryption Folders](http://jeffreifman.com/2014/01/09/how-to-encrypt-selected-messages-in-gmail/) and whitelisting - just as examples. 
Please don't suggest global, I would like to think we should promote good practice here.
If you're parsing whole books at once then yes, it might make a difference. Otherwise it's premature optimization. Sure, you might save a fraction of a fraction of a fraction of a millisecond of cheap processor time but you'll spend expensive developer time trying to fix and maintain it.
I'm not sure I want functions to behave differently based on how the function is called. 
W3schools does give you a steady point to start with. As long as you don't take these lessons as "This is all there is to know about this particular language/concept". It does help you out in building up more advanced functions and introducing you to them. It's best however to not let you guide or be limited by this idea. As long as you know what you're looking for; using StackOverflow or PHP.net itself are your best resources to learn everything about specific PHP related subjects.
actually, I think in this case, PDO would have some tangible benefits, especially in providing named parameters.
You were saying that in PHP there is no difference between a scalar and an array, I realize that much. I also realize that both of those terms have meaning outside of Perl, and outside of programming in general. Finally I realize that we are in the wrong subreddit for Perl discussion. I may not know as much about Perl as you do, but trying to fool me into thinking I don't understand what you were saying, won't work in this instance. Maybe I don't know what you *meant*. But I am not a psychic so I will stick to what you say instead.
What is the point of using this? $type=1; $UserN = $Username; $FirstN = $Firstname; $Pre = $Prefix; $LastN = $Lastname; $Pass = $Password; $Com = $Company; Why redeclare all the variables? If you used PDO (which is preferable anyway) you would have access to the following functionality. $sql = "INSERT INTO accounts(Username, Firstname, Prefix, Lastname, Password, RegDat, Type, Company) VALUES (:username, :firstname, :prefix, :lastname, password, :regdat, :type, :company)"; if($stmt = $database-&gt;prepare($sql)){ $stmt-&gt;execute($inputs); } All you'd need is an array with logical keys, even if it was just $_POST. The actual issue here, of course, is one of "scope". The database variable $mysqli is not available in the function scope. There are a couple of solutions to this. It is only available in the global scope. Your function is also in the global scope - it's a global function. But the inside of it is a different scope. Global scopes of things (such as functions) are bad. If you have this sort of functionality you should consider putting it in to a class, at least. Another user, SeerUD has already said how to do that. 
I think OP was referring to strong typing. If php was strongly typed, then a variable of a scalar type wont be able to hold a value of type array. So if $x is a scalar variable and a function is called as $x = func() it can be infered that func() is expected to return a scalar value. But in reality this is not possible because php is not strongly typed and $x can accept any type of value. I think this is what OP meant, when he says "in PHP because we don't differentiate between the two". In perl, if you check here http://perldoc.perl.org/functions/wantarray.html, you can see that it has an @ prefixed to the variable name to indicate that it is a list variable. So the expected return type can be inferred.
Look, this is all very interesting, but it doesn't answer the core question: when people say Wordpress is a framework, am I or am I not allowed to punch them in the genitals. Seriously, though, this is an interesting topic. I tried to write an article like this once, but I got thoroughly bogged down in "what the hell IS a Framework" as a question. Defining it becomes almost impossible. How do you advocate people using a framework when there are idiots saying that Wordpress is a framework, or Drupal is a framework, or that shit you've been copying and pasting into new projects since 1997 is a framework? The definitions seem to either needlessly vague (allowing the above) or needlessly restrictive, getting either false negatives or false positives. This is not a criticism of your work, of course, Phil. It's just an acknowledgement of the fact that some words are hard. Religion. Art. Practically undefinable without being circular. One thing I think is spectacularly unhelpful in this sort of discussion is the dictionary. There are people in these comment pulling out a Mirriam-Webster like there is some actual usefulness to providing a dictionary definition to a generalised word, when it's being used in a specific technical sense. I wonder if those same people describe their model as a "a three-dimensional representation of a person or thing or of a proposed structure, typically on a smaller scale than the original". Hardly useful. Thanks for bringing up this discussion.
Thank you for the response and explanation. But I now get this error: Fatal error: Call to undefined function register() in. I get this error in the form page where I call the function. this is the code: include("functions/functions.php"); register($Username,$Firstname,$Prefix,$Lastname,$Company,$Password); And this is my class with the functions now: &lt;?php require('../connection.php'); class UserRegistration{ private $mysqli; public function __construct(mysqli $mysql) { $this-&gt;mysqli = $mysqli; } public function register($Username,$Firstname,$Prefix,$Lastname,$Company,$Password){ $sql = "INSERT INTO accounts(ID, Username, Firstname, Prefix, Lastname, Password, RegDat, Type , Company) VALUES (?,?,?,?,?,?,?,?,?)"; if($stmt = $this-&gt;mysqli-&gt;prepare($sql)){ $stmt-&gt;bind_param(NULL,$UserN, $FirstN, $Pre, $LastN, $Pass, NOW(), $type, $Com); $type=1; $UserN = $Username; $FirstN = $Firstname; $Pre = $Prefix; $LastN = $Lastname; $Pass = $Password; $Com = $Company; if($stmt-&gt;execute()){ echo'succes'; }else{ echo 'Niet toegevoed: '.$stmt-&gt;error. ' in de query '.$sql; } $stmt-&gt;close(); }else{ echo"fout"; } } } //function RegAccount($Username,$Firstname,$Prefix,$Lastname,$Company,$Password){ //} 
That makes a lot of sense out of OP's comment, thanks for this! However, where he's concerned, I do think he (probably a he, right?) needs to say what he means, if he ever wants to have any meaningful discussion with anyone. I personally much prefer a "real" (for lack of a better term, sorry) strongly typed language paradigm where the return type as well as the arguments have a specified type. Sometimes the language will allow overloads with different signatures but the return type will be specified in each one. I guess I can see instances where you can be more efficient in Perl if you know you don't have to return a value, but the `print_r` thing is probably precisely not what the Perl people had in mind when they included that language feature.
`[X] The name of your language makes it impossible to find on Google` http://colinm.org/language_checklist.html
Where do you live? Could be based on your geographic location. I live in Flanders,Belgium yet I sometimes get to dig through the french php.net. I'm just glad they don't translate function names!
It's not in French. You've probably changed the language settings on the right. 
&gt; There are people in these comment pulling out a Mirriam-Webster like there is some actual usefulness to providing a dictionary definition to a generalised word, when it's being used in a specific technical sense. Then why are you interested in finding the meaning of the word 'Framework?
My point is not that defining things is useless. My point is that **applying generic dictionary definitions to technical terms** is useless. Defining the word as used in the context of software architecture is highly useful. Defining the word as stated in the dictionary... hardly helpful.
I'm just stopping by so I'll have to try it later, but that looks awesome, thanks! I'll let you know how it works (though I'm assuming it'll work perfectly!)
The idea is to put some short user input (like a username or password) into and, based on some variables check on a couple of things, like: Has a capital letter, has no special character. So it doesn't necessarily check on all those parameters.
With special characters I meant non alphanumeric characters like !, @, # and $, which should be \W if I'm not mistaken?
I am sorry, which incident are you referring to?
http://www.reddit.com/r/PHP/comments/1v54bv/the_framework_is_dead_long_live_the_framework/ceotlpp That for a start, but it's not an uncommon thing to do.
ha ha, yea. That was getting a bit out of hand!
i hate it when sites use geolocation to determine language. Use the Accept-language header, dammit. Don't send me a French site because some people in Belgium speak French.
Well, some time opened up unexpectedly and I tried your code, it works like a charm, thanks a lot!
Dunno, but they must have put some dodgy auto-detection code in there or something. I've had the same issue a few times recently in various languages.
I have the 4th edition and it definitely has a section on traits. From the Amazon description: &gt; This edition introduces new object relevant features such as traits, reflection extension additions, callable type hinting, improvements to exception handling, and many smaller language enhancements.
&gt;i hate it when sites use geolocation to determine language. Use the Accept-language header, dammit. Amen to that. Language selection should be done as follows: User-specified language &gt; Accept-language &gt; default language I'm not convinced geolocation for language selection should even be used at all, but if you're going to leverage it, it should be the last step in trying to determine the user's language before defaulting to, say, english. 
&gt; What do you do to prevent a security breach? Review code (historic and new) and fix security issues. It's not a quick fix, but it seems like the only real solution to the problem. A consistent application structure and/or a framework can help by making it more difficult for problems to hide, but these things don't stop bad code being written in the first place. I was going to suggest PDO as a more fool-proof alternative to the mysql(i)_ functions, but it's not; it merely uses a pattern that doesn't have the same pitfalls as building SQL from strings. Neither option is better if the person using them doesn't understand the implications of how they work. Code review can really help to iron these kinds of issues out, provided enough joint expertise.
Congratulations on releasing, then. It's often the most difficult step, one that I still have to take.
London here, usually german too.
Right, I also see it focuses on Git instead of Subversion like previous editions, which is nice. But leaving out Composer is still weird IMO. EDIT: Also, the code samples don't follow PSR-1 ... yeah, it looks like the author didn't really bother to catch up with what has happened with PHP in the last 3+ years.
You see the second bit of code in my post, you need to do it like that. You need to create a new instance of the UserRegistration class: $userReg = new UserRegistration($mysqli); And then, when you would use the register method, you'd call it by doing this: $userReg-&gt;register($username, $firstname, $lastname // etc); So, that file may end up looking something like: require('functions/functions.php'); // (I'm guessing your registration class is in here?) $userReg = new UserRegistration($mysqli); $userReg-&gt;register($username, $firstname, $lastname // etc); Then it should be fine :)
Well, previous editions were really good, this just seems half-assed. 
I think there is a cookie that gets set when you visit a page with a specific language. You probably clicked a link somewhere that set the language, happens to me all the time. You can control the language settings by going to php.net/my.php
PHP always amazes me. I definitely didn't know of 'ctype_alnum' ... 
infoq is pretty good
I don't know what the original comment was since it's been deleted but to be fair, I'm subscribed to /r/javascript and I hate it *deeply* the thing is, it's part of my job and it's important to keep myself updated; that's mostly the reason I'm subscribed here as well.
It was `generic php is shit comment #3`
PHP frameworks are really useful. they make life much quicker, But i share your desire to know how code works. When i started to learn PHP I went through all the normal lesson, but somehow failed to learn Object Orientated PHP. It sounds like you may have doe the same thing. I suggest you work through these, It will really understand how PHP frameworks (and OO languages) work :) http://net.tutsplus.com/tutorials/php/object-oriented-php-for-beginners/ http://www.killerphp.com/tutorials/object-oriented-php/ Nothing wrong with doing it yourself. Its good to learn, but beware, if you publish a site yourself. And its the first one you've done, I can guarantee someone will be able hack it. PHP is one of thoes languages thats very easy to make mistakes in. Even Wordpress has vulnerabilities... and its currently (for many) the 'go-to' cms... even if it shouldnt be ^grumble ^^grumble ^^^grumble 
Quoting [this answer on Stack Overflow](http://stackoverflow.com/a/1851925/250259): &gt; Framework abstracts you from low level details, makes you more productive, and protects you from low level error ( such as preventing SQL injection attacks). &gt;A good PHP framework forces you to separate your concern and implements the proven architecture, which in the end improves your design, and makes your code much easier to read and maintain and unit test. &gt;Here are [some references](http://web2.0entrepreneur.com/7/why-you-should-use-a-web-application-framework.html) on why [you should use framework](http://www.joshsharp.com.au/blog/view/why_you_should_be_using_a_framework).
&gt; Once I download a framework, I have NO IDEA what the hell to do next. When I code my own files it's just... create a .php file and start typing. Where you start kind of depends on the framework, you kind of have to get into the documentation and look at examples. Usually the first thing I do is create a Controller, and map a request to it. I think most of the popular frameworks have a "getting started" walk through somewhere. &gt; I have a problem with not controlling and writing everything myself, because that is one of the things I like most about coding, to create. (but I said the same thing about CSS Frameworks and now Im rockin' Foundation without any regrets. NIH syndrome, it's a bad thing. The thing that frameworks and libraries do is to keep you from sweating the small stuff. Do you really want to rewrite a file system queue algorithms every time you want to read a file? Probably not, you don't need to worry about that as it's taken care of for you already. You wouldn't do it there, why would you want to do it at the web application level? The thing about frameworks is they provide an architecture for you to start on, so you can stop sweating the small stuff like architecture and get to making things functional. And the end result will be more maintainable, testable, etc... than what you would have done yourself. That being said Reinventing the wheel is fine in a couple scenarios: * You want to learn how the wheel works. * The wheel doesn't *quite* fit your car. (If you need something more clearer than those analogies I'll provide it). Now about the site. There are probably literally millions of CMS systems out there, it's kind of hard to imagine one that doesn't fit your needs. That being said, there are reasons I mentioned you would want to reinvent the wheel. As far as login though I have a different attitude. Login and authentication and anything to do with security you WILL screw it up and it WILL be unsecure unless you know what you're doing, and knowing what you are doing will take atleast doing it wrong 10 times... my suggestion is to at least not reinvent the wheel there.
All 12 parts. http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1 I've used this comment a few times. But that series really does a great job of explaining frameworks from the ground up.
No you do not "need" to use a framework. Frameworks just really help speed up the development process since a lot of commonly used features are built into it. I've been using Laravel (http://laravel.com/) for a while now and really doubt I'll ever code another site without it. Take for example your bonus question website. 2,000 unique visitors is pretty good for a starting website. Sounds like you would need some kind of caching to help keep the site up and fast. With Laravel, it's literally 1 line of code that attaches to your query. Article::find($id)-&gt;remember(60); There's nothing wrong with not using a framework though. But I promise once you find one you like, it will greatly speed up your development process. You can still enjoy coding and adding your own code into it, but you won't be bogged down by common tasks.
&gt; Do I REALLY need to use a framework? No. A framework exists to ease your development, to come pre-packaged with a set of desired tools and documentation to help speed up development and have a community to answer questions. A lot of sites use frameworks, but there's nothing stopping you from doing your own thing. I've been tasked with bringing our old custom framework out of legacy 5.2/5.3 code, and into the bright 5.5 future. My inital reactions were to simply impliment a framework and be done with it. Shortly after prototyping basic login / logout and backend functionality, little things began to irk me about each framework I used. My solution was simple, roll my own and take the parts I like. You are able to impliment components from big frameworks like laravel and symfony in your simple .php files. I know have my small MVC solution that incorperats other libraries and what ever I think looks cool on [packagist](http://packagist.org/). - You should, understand a framework. Full-stack frameworks like Laravel and Symfony do it all, and learning how they approach problems helps figure out solutions to yours. Understand how a request gets routed through your application. There's a few articles out there about creating your own framework ontop of popular components, but it all comes down to what you do and don't like. - Bonus answer: Building your own site over would be a great reason to work on a larger project and practice the above. You'll need to worry about the $_SESSION, user permissions, comments, static pages, categories, and the articles. Writing your own back end to handle database interaction isn't a very challenging task, and a great learning experience. The first thing I do in any potential framework is try to create a simple markdown based CMS, so I look forward to seeing what you make!
"In mother Russia, framework uses you." In all seriousness though, that's often a realistic approach. With libraries, you use their code; With frameworks, its code uses yours.
So, &gt;Once I download a framework, I have NO IDEA what the hell to do next. When I code my own files it's just... create a &gt;.php file and start typing. + &gt;Bonus question: Im going to remake a website, it's a small website with around 1500-2000 daily unique visitors. This &gt;website contains a little big of a news/blog feed and some small static pages. I do want to write a "cms" kind of thing, &gt;or... rather maybe my own admin login panels, and yet again when I google around I hear people say "dont reivent &gt;the wheel" but... What is so hard about doing this? A simple login (secure) where I can update news and put them into &gt;categories? Once you just installed your framework, why dont you start with an Article class ? Then in your controller you can create actions that correspond to some url, like I dont know: /article/list will list all the articles present in your database, then it returns the result to the view, in the view you list them. Then you can continue with a Create action and an update. I dont know which framework you want to use, but the Symfony cookbook is really amazing
Just an fyi but your Bullet link is broken.
Well this is still a new conversation from our previous conversation. You are saying that the Front Controller pattern is bad. Every major framework out there (not just in PHP, but Ruby, Python and Node) all use the Front Controller pattern.
&gt;Once I download a framework, I have NO IDEA what the hell to do next. The manual for the framework is usually a pretty good place to start. Seriously man, programming 101.
Oh there are a million TYPES of framework. Content Management Frameworks are the fucking worst. I'm just saying we can't all go around using "PHP MVC Framework" to apply to completely different things, and if we DO go around doing that then people need to know that is the case. Polar usages of "frameworks are good/bad/ugly/slow" are fucking dangerous if used without the end user understanding the differences of the various usages of the word, even when in the context of "PHP Frameworks".
Still not an answer on the cock/cunt punch, Phil. WHY ARE YOU EVADING THE CORE ISSUE?! I do agree, though. It would be useful to have some sort of (at very least) shared language around this issue. The following conversation should never happen: **Me:** You should consider using an MVC Framework for this sort of thing. It would really speed up development and make a more stable and testable base. **Some Guy:** Yeah, I am. I have one I made in 2003. *points to spaghetti nest* Without clear language, this is an inevitable conversation, and one that keeps coming up here on /r/php. 
Gonna second you here on Laravel. I had a lot of reservations going into the framework world after something like 6.5 years of using PHP, but the combination of Laravel and Laracasts has gotten me really excited about a few of the new projects I'm working on.
Any framework of repute is making heavy use of [design patterns](http://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list). Having a rudimentary understanding of these will help frameworks make much more sense to you. In a custom php website, your index page is index.php. Maybe it includes some other files for a reusable header/footer, or queries a DB for some extra info. But for the most part, all the code in index.php controls what you see on your index page. But in a framework that's using MVC, index.php's job is to load the framework. A Controller will be responsible for the routing, a Model would control access to the DB, and a View will create the front-end. Your index code will almost certainly be in a different place from the actual index.php. You can find a lot of getting started tutorials for most frameworks, but the thing that will help you the most is understanding WHY the framework is designed the way it is. The reason is almost certainly design patterns.
I can also vouch for Laravel, their documentation is amazing and there are a lot of great resources out there for getting started with it. Also, in regards to you saying you wanted a cms, Laravel has packages that can give you most of this functionality out of the box but with the power to override and customise it to your taste. 
Not a a solution, but Have you tried installing wamp(www.wampserver.com/en) . I too did had few issues when installing 5.5 on windows, but the wamp version(php 5.4 i guess) was able to setup without any trouble. Now, go ahead (downvote me :-) )
no solution either: set up a vm, maybe using vagrant and [puphpet](https://puphpet.com/).
I'd quote you, but I'm on mobile. Every time the question of "Why use a frame work?" comes up, I always cite form processing. Do you really want to write *another* form processor? Or do you want to actually do stuffs with that data? Honestly, all other benefits aside, not having to write a form validator is enough reason for me to use a frame work. Most I've used and tested make it easy to both create and validate forms (some easier/more elegant than others) by subclassing or passing in arguments.
To be honest I'm a bit confused by what you're asking for. Do you mean tokens to prevent CSRF or Captcha forms to help fight spam?
&gt; Once I download a framework, I have NO IDEA what the hell to do next. When I code my own files it's just... create a .php file and start typing. It seems to me that the problem is more that you aren't actually sure what you're trying to achieve than anything else. My approach is to basically start off asking "so... what are my things". My entities, my models, what are the parts of my system. In your case it might be something like "posts". Then you need to build some sort of basic system to save and retrieve these. This means creating a model, controllers, views. All that. Migrations, possibly, depending on the framework. If you break the task down into bits, you'll be in a good place to handle each bit of functionality. Then all you need to do is take the requirements and make a nice list, then check them off one at a time. Learn. Implement. The thing about reinventing the wheel is valid, but it as other people have said, it doesn't apply to learning things.
What you do next is start learning. Read the framework's documentation, then look at sample code, etc., and with each step try something simple using the concepts you're learning about. Read, code, read, code, repeat. When I started learning Laravel I went through cycles of "oh my gosh this all is all too much, I'll never understand all of this" to "oh this is really easy, I'll be able to do this in no time", and then back to feeling overwhelmed again. Just keep on plodding your way through it, and eventually it will all make sense. I went through the process with the notion that I may or may not use the framework for all parts of the project, but once I understood it, I really wanted to use it for everything. If you're using Laravel, I definitely recommend https://laracasts.com. It's simply the best video tutorial series I've seen on any subject (well, aside from maybe Khan Academy). Laracasts has a "Starting from Scratch" series. But one warning, don't watch a ton of videos in a row and think you got it. You don't really understand it until you actually write the code yourself and get it to work.
&gt;One of the layers needed is to use tokens in the HTML form. That's for CSRF protection, a method of preventing requests made to the website via the browser which the user did not initiate. A spambot could just make a request directly, read the HTML source and extract the token. Here's how you protect yourself against CSRF: Upon each request, you should generate a random token and insert that into a hidden input field and store it in a session. Upon the next POST request, you compare the submitted token with that stored in the session. If they match, it's a valid request and you can proceed with the action. Example pseudo-code: if (isset($_POST['token']) &amp;&amp; $_POST['token'] == $_SESSION['token']) { //valid request } $token = generate_token(); $_SESSION['token'] = $token; //insert $token into the view
Ok that makes sense now. And now that it does, it looks like its not even worth an effort to implement. Seeing how it could be exploited easily in different ways. Other than a Captcha element, any other recommendations for preventing form spam?
&gt;And now that it does, it looks like its not even worth an effort to implement It's definitely worth the effort to implement, just not for the sake of preventing spam. &gt;Other than a Captcha element, any other recommendations for preventing form spam? There are many ways of fighting spam. There are spam filtering services such as akismet, there are honeypot captchas, there are logic puzzles, there are heuristic checks etc. There are also white-, grey-, and blacklisting, which are useful in combating spam. 
good idea, weird name. Unless I'm missing something, these are pretty much (strongly) typed collections, no?
Yeah this is what Im starting to think aswell. I think I need to grasp OOP alot better and MVC it seems? Do you have any suggestions for a really simple php (kind of OOP) folder structure? Im having a trouble of what kind of classes I really need (read my lack of complete knowledge of OOP)... Would be really nice if there just was a file structure guide or anything so I can get what kind of files I need. For example if I need a file for posts and what class should handle input to database and all that. :/
you're looking for an excuse to justify the decision you've already made but you're wrong :) so either fail and realize your mistake or do what you're being told and see the difference. nothing will come from asking because you don't care about the answer.
Will consider tokens. I dont like the looks of captcha's, to me it looks kinda dirty with a website, but ill find a way to work it out. My logic of just not using captcha because it looks bad, is just retarded. Thanks for the inputs.
If you're installing things separately, did you install MySQL? You can test whether PHP is working by creating a page, say, index.php in the root folder and see if your browser will display it.
Collections are usually objects. This has nothing to do with objects. It is saying "This argument must be an array of Foo's", therefore: "Array Of".
I am active on [Stack Overflow](http://stackoverflow.com/users/250259/john-conde). Answering questions and seeing alternative solutions is a great way to stay sharp. I also keep on up blogs and such but I don't follow any in particular. Instead I rely on [Hacker News](https://news.ycombinator.com), [Planet PHP](http://www.planet-php.net/), and other aggregators to filter out the nonsense and promote the good stuff. I am a full time Enterprise PHP Developer so I get to work on advanced stuff regularly which is of course helpful, too.
They aren't really "typed arrays." That would insinuate that you couldn't push other types onto the array. It's just a type*hint* for an **array of** some type.
Maybe some practical examples can help... You could write seperate .php files for everything and it would be page1.php and page2.php, etc. You could then use mod_rewrite to ensure things get nice pretty addresses in the browser. Or you could use a framework, and then, for instance (in the LightVC framework), when you create a function actionEdit($person_id) in a file called person.php (that likely holds a class called PersonController, the framework would automatically ensure that site.com/person/edit/5 would call function edit with parameter 5. It's just an example, but it gives an idea of the work a framework can do for you. You could write a login system from scratch, with an option to stay logged in (with it's own security concerns...), avoiding all pittfalls like which algorithm to use, salting, brute force protection, where to store things, session hijacking, etcetera. Or you could use a framework like Symfony which has this functionality pretty much built-in. My point is, yes, unless your PHP project comprises a few files and won't get any bigger, you need a framework. You're just wasting a lot of time otherwise, and likely aren't doing things any better than those frameworks are. As a coding exercise, sure! But if you have to quickly churn out varied websites for clients, it's just not a good idea to try and do everything yourself. It's like... building a house and refusing to use any tools.
- Read /r/PHP - Read Hacker News - Read Planet PHP - Try out new frameworks, libs, classes, design patterns, methodologies, environments, anything that looks interesting basically. - Always have a quick look under the bonnet to see if they've done anything cool / interesting. - Contribute to open source stuff / roll my own. - Code, code &amp; code.
&gt; Do you really want to write another form processor Literally the most boring programming task, and at the same time, one you have to get right or the user will absolutely notice. Ugh. I do some development now on a cloud platform called ServiceNow and one of its strongest points is the way it lets you create forms and views, it makes all of this such a breeze. When I have to go back and work on forms to my PHP apps it's always my least favourite part of the day...
Looks good, makes sense for PHP to support this considering it is available in quite a few other languages. Does this have any performance impact if you attempt to pass an array containing a large number of classes?
Yes, the typehint will iterate through the whole array and check the type of each elements. So this is an O(n) typehint, which could - depending on context - cause serious performance issues. That's the reason why I'm not sure I like this.
Do a website all by yourself with plain PHP first, you'll then have a proper appreciatation for frameworks when you start using them. I started looking into frameworks seriously after creating a ~35,000 line of code website using my own code (Had OOP data abstraction for the core data but nothing like a full framework) and my first reaction was "Oh my god I don't have to code that myself? I don't have to code that by myself either? Or that? Form validation is all done for me? Holy crap" If you're making a small site &lt; 1000 lines of code it might not be as necessary, but the bigger your code gets, the more likely it is you should be using a framework.
Can we get some performance tests on the patch? It would be interesting to see.
Very good point. It took a little bit to get my first forms running with Symfony2, yet once I did I'm so glad I don't need to worry about csrf let alone the repetitive markup. That saved so much time in the long run at work, any time a new field needs to happen, done. Not to mention using FOSUserBundle which already worked with MongoDB, just had to change some *.html.twig files and I had a working login/logout within the first day of starting the project that already handled forgotten passwords as well.
Is this where the YouTube shit is coming these days? 
I said the same thing once I read the post too!
I try to attend conferences / talks / local UG's when possible and read as much as I can from developers I respect like Anthony Ferrara, Fabien Potencier etc. Of course, the thing that keeps me the most sharp is actually coding and solving everyday issues at work with the things I've learned. That right there is probably the biggest help in keeping me on my game.
Symfony is massive overkill for a site like this.
Could you point me at some of these packages, because that sounds like what might get me in the Laravel door. Thanks in advance... edit: nm -- http://bundles.laravel.com/search/tag/cms
I wouldn't call it a typed array, I would call it an array of contents with a specific type. That's probably the same thing, but if they are the same thing then it means the name isn't wrong and its just an A or B decision. Either way, I won't be changing it now, and its the name of the branch Joe decided to use - so I am not too scared that it is confusing. People definitely shouldn't be deciding how they feel about an RFC without reading it anyway, so... :)
It makes total sense. I like it! Others have pointed out that this would require PHP to examine the array, perhaps leading to a performance hit, but I guess if you're building such huge arrays that the performance hit of stepping through a list of pointers becomes noticeable, then maybe an array isn't the best way to handle things. In such a case some kind of class would probably be a better idea, and then one could just type hint that. So I guess it's probably a non-issue for most people.
Flask-WTForms is this for me. I think it comes with support for SQLAlchemy so I can build forms from my models directly. Thank Guido. Adding logic - beyond basic validation - is painless. Plus it'll generate the forms for me. I remember writing some just shit form code when I was 15/16 (so ten, eleven years ago) and wishing for a better way. I'm so happy now. Automate all the HTML! Honestly, since my girlfriend took a web design class, I - in complete theory - don't need to write any more HTML. If only, though. :(
Switch to a better framework, bro. Or steal some form validators from someone. 
http://fatfreeframework.com extend your models with a ORM for profit 
&gt; arrayof sounds 
You should start your practicing and studies in PHP without a framework. Learn how to code in PHP first. Later, once you want to start learning how to make commercial websites, jump into a framework - the only reason to use them is to take care of the repetitive tasks and leave you to just do the custom stuff tailored to each site/application. That really is the only benefit to framework, but it turns out that for a professional developer, that is a huge help. For you starting out, just learn the language, dont bother with frameworks until you are comfortable, and especially until you know what situations they are intended to benefit. FYI - I highly recommend (when you are ready, not before) checking out Symfony 1.4 - not 2.x. This will really divide the community, but Symfony 1.4 was in my opinion (and still is) the epitome of PHP framework perfection.
Well that answers that question then. It seems that it's right on par with foreach + instanceof. I don't see any downside now.
Haven't played with Flask yet. In the Python world I've mostly used Django, which doesn't feel like I'm programming anything at all, just feels like everything is a config file. I'm open to play with Flask, most of the other frameworks I've used are on the slimmer side, e.g. Perl's Dancer and NodeJS's Express building more API related tasks as opposed to web interfaces. So what kind of cool things does Flask bring to the table? Edit: My company and coworkers are all quite pleased with Symfony2 though, frontend I did with Backbone.js and Require.js which work very well together.
This is great - not forced upon the user either - if you didn't know this landed in 5.6 you wouldn't even care - lets do it! Performance concerns I guess are always going to be there, since we aren't strictly typed with PHP it's somewhat unavoidable. One thing looking at the RFC (and I'm not on my dev machine at the moment to test), is it currently possible with PHP 5.5 to type hint an array in a function/method parameter list using a "[]" style syntax? I can't say I have ever tried... E.g. function method([] $itemList) {} rather than function method(array $itemList) {} If not, worth adding as well? (I know this isn't entirely related to this RFC). **Edit:** scrap this, too early in the work day to be suggesting things like this - even downvoted myself :)
That is not covered in this RFC and I wouldn't like to see it covered in any RFC. :)
&gt; https://gist.github.com/krakjoe/8444591 The performance implications are not huge. It does not proactively scan the entire array before iterating through so it is only checking each time as it goes, which is what you'd be doing if you wanted to implement these checks in userland anyway.
Really? Curious to know why you feel that way about it Phil :D?
Reddit PHP, RSS feeds, Twitter, reviewing PHP release changelogs for new features/additions.
Understandable; but in cases where it's a profiled performance problem, you can just swap the typehint back to `array` if you want, no? Seems like a no-brainer to me.
I have a fine framework and excellent validators. I said it was bad compared to ServiceNow, not bad in general or in comparison to all other systems / platforms / frameworks.
Thanks for that. Looks negligible to me. If there were a real performance hit then it would become much more pronounced each the number of elements goes up an order of magnitude, looks like that's not the case.
This cost is also going to be incurred every time the array is passed onto another method. When we have something like: function banana(Foo $bar) Foo is actually a concept that exists - an instance of Foo. However, in the new syntax: function apples(Woo[] $zar) There is no such thing as a Woo[] - i.e. $zar is actually just an array. If this were changed so that there actually were such a thing as a typed array which only accepted the addition of objects of say class Woo (and complained if you tried to add something else) then this type-check cost would be a one off thing and there would be no performance hit for each additional method call which involved the typed array.
Oh, I get you. I misunderstood what you were saying. Long day.
Now all we need is for all array related functions and operations to respect Traversable.
&gt;Willingness to introduce BC breakage Not going to happen. Look at what happened to Python with the 2/3 switch. Heck, look at what happened with PHP and 4/5.
Could you elaborate on that? Where would this be cached (storage location) and how do you ensure that the cache stays valid without incurring larger overheads in the rest of the engine?
`[]` is an array creation mechanism. For what you are proposing the equivalent regular array type hint would be function foo(array() $arg) {}
To be honest the name made me think it was a proposal for a feature in the same vein of "instanceof"
Aliasing something that is verbose with something that is not verbose is an odd thing to go about doing. The way type hinting should be going is allowing "int", "string", etc and I wouldn't want to see type names removed and syntax added for no reason. ``` function (string $foo) {} ``` I'll be happy to see that. ``` function ("" $foo) {} ``` I don't want to see that.
for me personally, the turning point was writing my own template system. At that point I started understanding view and controller (separation of action logic from display logic) and then the grouping of objects into models completed mvc in my head. New frameworks are mostly a breeze once you learn those concepts. 
I have been working with CodeIgniter, then Yii and a custom company made framework. I have started to build by own and just came across laravel. How does it compare against Yii? I like a really separate sql and php files so no custom queries in my controller for instance. Would it be wise to step over to laravel or continue with my own framework?
This is absolutely not useful in this situation. If all their infrastructure is in Windows/IIS, he should continue using IIS in dev.
This is absolutely not useful in this situation. If all their infrastructure is in Windows/IIS, he should continue using IIS in dev.
According to the discussions going in the internal mailing list, it seems a Traversable wouldn't be compatible with such a type-hint. Only real arrays would be accepted.
&gt; The only issue with a typed array is that now you are going to incur the same performance cost regardless of if you call any functions which use this new type hinting. Sure, but if you're not going to pass it somewhere, then surely you could settle for a normal array since you don't need any assurances - you already know what sort of things are in the array since you put them there? In my head this discussion then goes "but maybe I don't - maybe I am doing something like $myArray[] = someFunction(), so bad things might get into my array", which then leads me to: It would also be nice if we could hint return types! &gt; I'm not sure this is really any optimal solution to this problem in a language that does not use static type checking. [Phil's post below](http://www.reddit.com/r/PHP/comments/1vai6q/php_rfcarrayof_under_discussion/ceqgkym) has a link to some benchmarks which show that the type check cost is pretty negligible, but yeah - since PHP is interpreted I think there will always be a cost to this sort of thing.
Tokens only make sense when you have a multi-step process, to avoid a bot skipping to the last step right away, or to prevent sending a form multiple times. If you're worried about spam, I'd recommend using CAPTCHA. Now I hate using "distorted text" captchas, seeing how even myself sometimes have trouble reading them, I can only imagine what an average user must feel :/ There are other alternatives, my favorite being random trivial questions, as I feel like puzzles are a pain on mobile devices (eg. textcaptcha.com) Without knowing what kind of application you're developing it's hard to give precise advice. If the potential spam can be seen by others (eg. comments on a blog, reviews), or you're talking about account creation, a mandatory captcha seems like the best practice. If you're worried about flooding, then logging IPs and asking for a captcha past a threshold works well, as most users won't see it anyway. If the spams aren't publicly visible, then most of the time I feel like a centralized reviewing interface works best. Add an "approved" field, show unapproved stuff on a list with accept and dedlete buttons. This way you can cleanup hundreds in just a couple minutes. You can use that for publicly visible stuff aswell, and can choose to display unvalidated stuff or not (whitelist/blacklist)
True.
The default limit is 100K. Not 100K of text, but 100K of memory.
Those are for Laravel 3, I would recommend looking into Laravel 4 as it uses Composer 
I think returning an array and using list is fine for two, maybe three return values. I do prefer that typehinting and autocomplete function better, and for that reason alone I might create a simple data class to represent the return value, with properties (and maybe getters, sorry) for each value
Yea, I think list might be my favorite, but I'm not sure. Yea, for any data that makes sense to have multiple instances of or needs a more complex structure, I agree that it would make sense to create a class for the data and then return the instance. Thanks!
For the most part, you should never have multiple values returned from a function. If this is happening, then your function should be broken up more, or should be an internal only function. If it's an internal function, say to generate/prepare data, I usually return an indexed array.
It's a pretty good learning tool, though. The thing really is to learn the MVC theory before you dive into a framework so you can see it used in practice and start to learn from the framework you're using. I personally had read up on MVC and the 'main' design patterns before I used a frameworks properly, and in so doing the framework made a lot more sense and I was able to work with and extend it far more easily. That's unlike me as well - to read up on something in a fair bit of detail before I get stuck in - but I really do think that it helped in this case. Personally I don't think I'd have been able to figure out what was going on in an MVC framework without knowing roughly what I was looking for. If you want to learn a framework just to help get an idea on how they work in general, or how MVC can be implemented, pick a simple framework to start off with, so that you're not neck-deep in more complex code than you need to begin with. My personal choice there is CakePHP because it's so easy to pick up and run with, but it's not for everyone. 
"Because some people might want to" is the leading use-case so far. I've yet to see any particular use cases for, but the against is rather clear: $possibleNullObj-&gt;something(); // fatal error! If you want instances or null then just use `foo(array $bar)`.
Honestly, I love this syntax - I already use it regularly when documenting my code and for type hinting in PhpStorm. On allowing null values: **Nope.** Honestly, I'd prefer to use this language construct to enforce srict typing and be confident that I'm calling a method on a certain type of object rather than be paranoid of potential fatal errors and having to do extra coding anyway to eliminate the nulls. 
I'm in the same boat as you, started a few years ago, and just do it as a hobby now and in my copious amounts of downtime at work, but everything I've seen online the past few weeks says not to bother with a framework until you have a firm grasp of the language itself, As far as reinventing the wheel, maybe your wheel will be rounder than the previous guys, also that reinvention leads to the better grasp, in my opinion. Thus I'm giving up on CodeIgniter, Laravel, and CakePhP and going back to my roots, SSH and VIM and banging out what I need, until I'm comfortable enough in my own abilities. Maybe I'll revisit them in a couple of weeks before I start my own major project. 
Agree with /u/iLukey. As you work through these posts, you do not end up with a full-stack Symfony2, you'll actually end up with a framework resembling Silex. You also get lightly introduced to the Symfony ecosystem, which isn't a bad thing.
If it's a public method then I'd strive to use a value object - i.e. an instance of a simple immutable class (constructor + getters). It gives more assurances about exactly what is being returned and also as a bonus code completes nicely with the editor. I might let myself get away with an array for methods used internally by a class.
An array (numeric indexes if few values, named indexes if more complex) usually works for me. If something more involved, might choose to return an object instance holding the returned data.
Man, the grammar and spelling in this article are atrocious, and there was nothing of value added to the conversation that couldn't have been a reddit comment. I feel like this was specifically made as a blatant attempt at marketing by joining a conversation people actually care about, not because there was anything important to say.
I don't think your script is actually being parsed and executed by the php interpreter. The browser is trying to make sense of the who,e thing as if it was HTML. are you using Apache or ngingx as your web server? Check to ensure you've properly configured PHP.
Possibly, the web server is not set up to parse PHP on html files. Either change the extension or change the web server config to add PHP on .html files (eg. AddType/AddHandler on apache)
I like the idea, but having to iterate through the whole array for type check seems like a hack to me. How does other languages like java and python implement this? Wouldn't it be possible to check the type when an element is added to the array? Another thing is that the same functionality can be obtained by using a collection class. Like, if you want an list of User entities, wrap the array in an UserCollection object and type hint it in function declarations. Then you can type check each element at the time it is added to the collection in the add() method or something. You just need a abstract base Collection class that implements the iterator interface, which you can extend to make different Collection class for different entities by implementing the add() method where the type check happens. It is also cleaner to use collection objects that it makes removing and replacing particular entities much easier than using an array. So I think that should be encouraged. 
IMO that document is possibly too terse and technical for someone who doesn't yet have a solid grasp on OOP -- let alone writing PHP (or even namespacing and other modern programming concepts/patterns in general?).
Forcing the requirement of a collection sounds nice in theory, and could certainly be a good approach if you are in full control of the code both inside and outside of the method you are type-hinting. If you are not the same developer both inside and outside of that method, then forcing the use of a collection is shitty. I would like to make a method which says: &gt; This argument will be an array, which contains only Foo's Your suggestion would be: &gt; This argument will be an array, which contains only Foo's, and to make sure it is only Foo's they will have to instantiate some extra class which they may or may not have noticed listed in documentation somewhere, pass their array into the constructor I guess, then shove that whole object into that method they were trying to use in the first place. Improving function declarations and restricting the limits should not force the users of that same method to change the way they code.
Things I do: 1. Identify my bad habits, and practice fixing them (writing doc comments, consistency in naming conventions etc) 2. Refactor old code 3. Pick a pattern, and use it to death (even if it's not really appropriate), to really learn it. 4. Write a quick app and treat myself like the worst client in the world, making feature request changes, additions, "potentiallys", and force myself to make my code flexible and maintainable. 5. Pick something I don't currently do that I should do, and again, do it to death. A while back I wanted to really "get" thinking in terms of objects, so I made everything an object. Everything. Not a single array (other than a collection of objects) existed in my code for about 10 months - everything that was an array could also have been an object, so I that's what I did. 6. Learn how various components of a framework work, by rolling my own. For a while I had no clue what a dependency injection container was or why it was useful, so I used Pimple to get my feet wet, then I rolled my own. Then I turned it into a proper DiC framework with automatic dependency resolution. Currently working on rolling my own recursive ORM just to get an idea of how it works. 7. Practice regex for the hell of it 8. Pick something that sounds daunting and totally out of my comfort zone and just go for it. My next venture will be setting up a continuous integration server and automated test suite for PHP. 9. 3rd party API integration is a big one I practice a lot. Basically, practice practice practice, and tackling tough problems. Sadly at my job, I spend more time fiddling around with wordpress/drupal/joomla than I do writing code, let alone doing proper software architecture. Writing good, clean code for fun is the only reason I'm still a web developer.
&gt;This argument will be an array, which contains only Foo's, and to make sure it is only Foo's they will have to instantiate some extra class which they may or may not have noticed listed in documentation somewhere, pass their array into the constructor I guess, then shove that whole object into that method they were trying to use in the first place. In the scope of the project, if you want a list of Foos, you will use a Foo collection every where, not an array. You will start with an empty FooCollection and will add Foos along the way. &gt; Improving function declarations and restricting the limits should not force the users of that same method to change the way they code. isn't this like asking to use arrays everywhere instead of entity objects. So when you want to work with a user entity you are suggesting that the method takes an array that contain the user details, instead of the user object, so that the users of the method can keep using arrays. But I am not user we are on the same page. I am talking from the perspective of a business application, not sure your are.
http://php.net/manual/en/migration54.new-features.php "Class member access on instantiation has been added"
That is the single greatest thing ever. Thank you!
OP, with frameworks you really need to get a grasp on MVC style code to proceed. Most of your code will live in these places: 1. A router.php file. This will resolve URL's to your controller classes and methods. For example, /article/{id} might point to ArticleController-&gt;loadArticle 2. Controllers folder - these contain all of the classes that handle the actual business logic. A typical simple controller does something like this: - retrieve GET or POST parameters - create a new object based on your models by using either a repository or an active record handle ( Article::find($id);, etc) - load a view template and pass in that object &amp; any other data you need to display it 3. Models folder - contains the blueprints for those objects we mentioned in #2. They basically define what properties the object has (article id, title, date, content, etc). With things like Eloquent you can use these models in an automatic fashion to perform CRUD operations. 4. Views/templates folder - just has simple templates where you can echo in object data from the controllers to spit everything out Hope that kind of helps break things down. I just started to attempt to use Laravel myself. The first few days I was REALLY frustrated, because you have to entirely relearn pretty much all of your syntax to do it the laravel way. Fortunately I have been receiving some mentoring and created my own MVC style site with a custom front controller, repositories, etc, which really helped me understand what a framework was doing behind the scenes. I'd be happy to help you out and pay forward the knowledge a very generous mentor has given me. My first impressions from using Laravel/routing: - routing is much easier - you don't want to deal with writing your own front controller - Eloquent is quicker than writing your own repo code for CRUD operations, but it's still not as simple as I expected it to be with a framework. You'll also have to fight through some magical assumptions it makes (mass updates, special database columns for migrations, assumed column names, etc) - Documentation, while some claim is good, is still pretty crappy IMO. Plenty of times they show you a quick line of code, but give you no clue at all where it belongs. Overall I'm basically surprised that frameworks haven't made CRUD a dead simple operation. Is it easier? Yes, but I still don't feel like I should have to manually create all of these create/update forms and controllers just for handling the models.
Not the components themselves. They're great for throwing together a customized cms.
Yup, along with namespace :)
&gt; I like the idea, but having to iterate through the whole array for type check seems like a hack to me. How does other languages like java and python implement this? Wouldn't it be possible to check the type when an element is added to the array? This has been invented - it's call static typing - PHP is **not** one of those languages. Hence why this RFC is a good idea for PHP. &gt; Another thing is that the same functionality can be obtained by using a collection class. This is true, but having to write collection classes for every "array of objects" type you are dealing with soon ends up being a boilerplate nightmare - when all you want to do is pass a collection of objects around your application.
&gt; already use it regularly when documenting my code and for type hinting in PhpStorm. So currently you can define functions/methods this way with current stable PHP releases (e.g. 5.5.x) without throwing compile/syntax errors and give hinting to your IDE? If so - cool..
&gt;This is true, but having to write collection classes for every "array of objects" type you are dealing with soon ends up being a boilerplate nightmare - when all you want to do is pass a collection of objects around your application. let us see class UserCollection extends BaseCollection { public function add(\Entities\User $user) { parent::add($user); } } Was that so bad? You just need to implement iterator interface, and may be ArrayAccess interface for your BaseCollection, once.
[PHP Cookbook](http://shop.oreilly.com/product/9780596101015.do) I found it to be fantastic.
Nice try Fabien. Ask a question, then link to your site. ;) OP &gt;But, I hear, everywhere people say "Dont reinvent the wheel" and how good frameworks are Website &gt;If you look around, everybody will tell you that it's a bad thing to reinvent the wheel and that you'd better choose an existing framework
How have I survived until now without this in my life?
Bitch please
Return an object.
Do you have links? Except HHVM and PHPPHP (which is a POC), I've never seen an alternative engine (i.e. non-POC).
Granted, but look where we are now! I'm glad there was this BC break for PHP4/5.
You can use it in docblocks and PhpStorm will pick it up. /** * @param SomeClass[] $args * @return SomeOtherClass[] */ Or what's pretty cool is using `@var` in code to help the IDE. For example in view scripts. /** @var SomeClass[] $objects */ foreach ($objects as $o...
1. If you have no idea how wheel's work, by all means, reinvent the wheel. 2. Creating is awesome, but if your creating a production level site and are still new to PHP, you should not be trying to create your own framework. It's difficult and will be insecure. For now, go with a pre-made framework. If it's a 'for fun' project, and you don't care if you leave your server, or host open to attack then by all means, create your own framework or router. 3. Bonus: No CMS needed, instead, look up for an intelligent way to employ a templating engine such as [twig](https://github.com/fabpot/Twig). Flat-files would be very simple; json would probably be better, though. 
Maybe I'm misunderstanding, but just move the lines echoing out the starting and ending table tags into the while loop? Also, you have the error message at the beginning if the connection fails, but the code after it will still run if you don't connect to the database. You probably want all that code in an else {} statement. 
I bet you also think humans never landed on the moon and Hitler lived in Argentina after WWII. Anyway, [here's a good movie for you](http://www.imdb.com/title/tt0118883/?ref_=nm_flmg_act_19).
Cool, tkx for the reply.
This. They shouldn't need separating as they shouldn't be in the same place to begin with. 
Wow how did I not think of that! Thanks so much!
That's great, if you are happy to write that - but it's something limited use (the need for a collection of object instances) or internal to a class only, i'll happily take what this RFC is offering.
At last! Object type hints have been there, like, forever. Still took a lifetime to get to this =\
Ah right - docblocks, I was thinking you are somehow using this within the code itself. Yep, good point.
Yep - I would put my money on this theory.
you must use the https://oauth.reddit.com/api/v1 endpoint for all oauth calls
&lt;3 PHPStorm. Thanks for the tip!
I was asking specifically how do you name those directory. Thanks.
[GitHub Resource Collection](https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#php) It's pretty comprehensive and has plenty of free resources. Link points to the PHP section.
I don't know about you, but when I set up a new project I always put things like that into an assets folder. If you use something like Laravel, stick the folder in the public folder. If not, why not? Assets |- CSS |-- Less/SASS |- JS |-- Libs |- IMG Keep in mind, PHP and JS shouldn't be intermixed.
Like I said, the javascript cannot be in the public folder because it gets compiled there by Grunt, so I was just checking if there was a naming convention for the JavaScript directory. So far this is what I have: Project |- javascripts? |- public |- src (php) 
It's like any other static typed language
Well damn. Now I have to find another use for this half-bucket of popcorn. Couldn't you guys have kept it going for another 3 exchanges? Kids these days...
I'm currently looking at Uncle Bob's stuff which I find very helpful, although that's more general-OOP rather than being PHP-specific: http://cleancoders.com/
really excited about all the implemented RFCs, and the ones under discussion like this one. i just hope we don't get to the old java/j2ee over-engineering days, where every simple app you need to deploy requires thousands of dollars.
View source and you'll see that the raw code of your script was sent to the browser. The server did not execute it as PHP. Did you use a .php filename extension, and are you sure that your server supports PHP? If doing this locally, are you viewing it through the server and not through the filesystem? That is, a file:// URL will never give you processed PHP.
You could instead use a CMS which have elements of a framework built in... I Often use Concrete5 (which uses elements of Zend) for small/mid sites, ExpressionEngine for mid/large uses CodeIgniter I believe. With the CMSs having to update all the time they're generally secure and deals with connecting to databases etc in a secure way. So that's an option if you don't want to jump in at the deep end.
http://bulletphp.com/
tell that to Stas.
If you want that feature in pre-5.4, just do this: function id($x) { return $x; } $generator = id(new \RandomLib\Factory())-&gt;getMediumStrengthGenerator(); 
I think the implementation you're referring to is typed arrays, where you can only add objects of a specified type to an array. I can see use cases for typed arrays beyond just type hinting a method signature.
Just based on the client-side crypto bit, please read [Javascript Crypto Considered Harmful](http://www.matasano.com/articles/javascript-cryptography/)
&gt;I have a problem with not controlling and writing everything myself, because that is one of the things I like most about coding, to create. Better get over that, if you want a job.
It makes perfect sense to configure your container using PHP instead of a structured array, json or yaml, due simply to the overhead. The parsing overhead is one of the reasons we haven't yet added the ability to externally configure the Joomla DI Container.
In PHP-DI, every definition source is cached (reflection, annotations, yaml, php, …), so there is no overhead. And in 4.1, there will be a container compiler (compiles to pure PHP code, skips reflection). So the configuration format has really no impact.
I say, learn to code from scratch, then learn one or more frameworks, then start working on your own framework. I'm not impliying that a self coded framework will be better than other popular frameworks, but once you understand the MVC model and PHP objects, well, coding your own framework won't be hard, and you will re use that code a zillion times, it will be familiar to you and it will be faster to debug.
you have the tag "Don't listen to me"? ;D
&gt; every definition source is cached It looks like you're using closures, which aren't cacheable (well, at least with default caching stuff I've tried). It's an annoyance I found out about hard last fall using ZF2 - many of the tutorial examples show closures in the configs. When we hit performance issues, I tried to cache the configs: no dice, because we had closures everywhere. :/ Maybe you're dealing with them differently somehow?
&gt; Then you can say the same thing about this RFC - you already know what it expects, so you don't need to type-hint it. No - I am thinking of it more as I am providing a class, and other code (written by others) is calling the methods on it, so I need to check that the caller is providing the correct type of data. I just figured that in the scenario that the previous poster mentioned, whereby the typed-array is made but never passed anywhere (thus incurring the overhead to no benefit), the code would be procedural and so written by me, and so I would have only just made the array and so I would know exactly what was in it (vs interacting with other people's code which I don't trust nearly as much). However thinking about it a bit more, I think that for me is that such procedural code would be a very rare case. &gt; If you're going to type-hint it, then you're also going to ensure that the data is in the format expected. Never said you wouldn't need to. 
Yes, frameworks, libraries, and not-reinventing everything under the sun will let you solve bigger, more interesting problems.
I think you're correct, although there are situations where you deviate from this. Methods/functions should do one thing, per separation of concerns. If your method is doing many things, then it is not a good method, since maintenance and testing are going to suffer.
While I wholesomely agree with the power that the Value Object pattern provides, I don't always find it to be appropriate. Although I mostly live in PHP's object oriented land, I appreciate its somewhat terse functional abilities too. In which case, I'd say using a value object would feel misplaced.
You should try Laravel. I think it's excellent for beginners. They have a great community and a simple documentation.
&gt; Collections are usually objects. Usually, but doesn't have to be. A simple array can still be a collection, since a collection is nothing more than a group of like-objects (either of the same type, or sharing a superclass or interface). More full-featured collections may have helper methods, but that's not a requirement of collections. The primary purpose of collections is to support a container (array-like) datatype that allows you to guarantee that each member in the structure is of the same type -- which just so happens to be exactly what this proposed feature does. &gt; This has nothing to do with objects. Huh....you're not hinting **object** types? The proposed feature is definitely designed to support collections, which don't get me wrong, is awesome (I've often toyed with generating a _collections_ RFC, likely for SPL)...but it has everything to do with objects! This is all neither here nor there though, as it doesn't really change anything and amounts to a disagreement on definitions perhaps, but as a staunch believer in collections, I don't see how you could propose this feature and then say it has nothing to do with collections at all; IMO it just sounds like you're unfamiliar with collections (or maybe I'm being dense in some way).
The proposed feature would support collections yes, but I don't think the feature name itself would be collections. IMO it should definitely reference collections somewhere in it's documentation, though.
Yes, but compiling the container comes even before caching the definitions. With a compiled container, you don't even need a cache anymore, since definitions are compiled to raw PHP code. So that's why I'm not too worried about this (once I have compilation in PHP-DI).
&gt; scope You return a new instance every time? Or you store them (singletons)? &gt; named parameters rather than positional ones I've been forth and back on this, and finally I'm allowing both (even though the examples show only position-based).
Yes, I'm still very disappointed nothing (better) exists to handle that. You are welcome to play with it, though keep in mind the current status of this is: "it works", nothing more :). I'd love to find time to make a real, stable and feature-rich version in plain PHP. That would be much more practical to maintain and evolve.
Quercus (Java), IBM has one in WebSphere, Phalanger (CIL), etc
Thank you!
This kickstarter has already reached it's goal, and well beyond. If you've ever wanted your own elePHPant, now's your chance to get one in php[architect] orange.
Yes objects are involved in the conversation, but not in the context of what I was saying. Object types are used for the type hints of the array contents, but arrays are a requirement for the feature - so **that** has nothing to do with objects. I'm not familiar with collections being plain old arrays no. In PHP land they're just arrays. In Ruby or Python land they'd be lists. In all of those, any time I've heard talk of a collection its been an object, so I answered as such. :)
Yeah I'm mostly looking for input and feedback, even on ideas I fucking hate. Trying to be impartial has the downside of making me look like a flip-flopper with no idea what I'm "suggesting". The Hack language (and others suggesting crazy amounts of Perl-like operators for everything) are mostly trying to highlight the difference between: * null being passed as the argument * no argument being passed * an array being passed with only the correct type * an array being passed with the shit you want and some other shit maybe I personally don't want to see 100 different combinations of syntax used, but it's something we'll have to discuss.
No idea. Tried sneaking an answer out of people on the latest [town hall](http://www.youtube.com/watch?v=ufnGydu58os) but didn't get far.
Definitely not.
&gt; You return a new instance every time? Or you store them (singletons)? Aura.Di does both, but differently. If you want a new instance of something, you call $di-&gt;newInstance('ClassName'). If you want a shared service (singleton), you call $di-&gt;set('service_name', $di-&gt;XXX), where XXX is: - newInstance('ClassName'), creating a new instance at the moment of *setting* - lazyNew('ClassName'), creating a new instance at the moment of *getting* - lazy(callable), which invokes a callable to create a new instance at the moment of *getting*; this one is good for calling on factories Regardless, the set() service is stored as a singleton. More in the [readme](https://github.com/auraphp/Aura.Di/tree/develop-2) if you have the time and inclination.
https://github.com/php-loep/monga is a pretty good one. Personally, I use https://github.com/jenssegers/Laravel-MongoDB since it integrates with Laravel (at the moment I don't really care about switching to a framework agnostic package).
Yeah, it's pretty awesome, especially when using @return since then when you iterate over the array of objects, it already knows the type for you and hints the methods and properties.
Quite a few people, apparently. They reached their kickstarter goal in 20 minutes, and haven't slowed down. Almost over $10K in funding now.
This is great because it addresses some key up-and-coming technologies like Dependency Injection and Test Driven Development in PHP. Plus it's pretty compact.
&gt; Trying to be impartial has the downside of making me look like a flip-flopper with no idea what I'm "suggesting". And if you do it on Twitter, you don't have room to explain that this is the opinion of some of a group of people, not necessarily your own. I just hope accepted RFC's in the future will favor simplicity and a good benefit/added-complexity tradeoff over flexibility and is-this-cool-or-what-ness. Namespaces are in one end of that spectrum, not requiring the "function" keyword for method declarations in the other. Not sure how to explain that more, but if I'm right about where you stand, you'll probably get what I'm saying.
Agreed. The only instance that comes to mind for returning multiple values, is something like this: https://github.com/titon/utility/blob/master/src/Titon/Utility/Crypt.php#L166 Both IV and key are used to create each other, and both values are required in the return. But for the most part, separation of concerns.
&gt; Well that answers that question then. I don't see how this does answer the question? The question is not relative performance compared to doing the same thing manually -- of course those will be roughly equivalent. The problem (which -- unless addressed -- will be a major component of a "NO" vote on my part) is a built-in O(n) typehint. This is a serious performance WTF. Manually type-checking at input time in your own userland collection is a *much* better solution performance-wise. Including this in the language is providing a ready-made performance sinkhole for people who don't know better *and* adding (unnecessary?) complexity to the typing system at the same time. After getting over the initial "oooooooh shiny!!11" reaction that we all naturally have to potential new features I started thinking about the consequences and to me this is not a good solution. Real generics maybe, but unless some changes are made I have a hard time feeling comfortable about this patch. *edited for spelling
What you just described is almost exactly what a [Git Submodule](http://git-scm.com/docs/git-submodule) is. It allows you to reference outside repositories. The real power comes where you can reference specific commits or tags, as to guarantee that updates will not break the site.
Having done a bunch of configurations in a bunch of languages, I have found HOCON (https://github.com/typesafehub/config#json-superset) to be the clearest. It also has rules for merging which would be great if you have many configs in different /vendor/project subdirs that you need to combine. I'd love to see a PHP port of it, but I do not have the time atm. Edit: full spec - https://github.com/typesafehub/config/blob/master/HOCON.md
OMG YES. Thanks, collegeBro. Now when I make my argument to move to repository-based development I can include this.
No problem :) A live example on Github of what this looks like can be found [here](https://github.com/partkeepr/PartKeepr/tree/master/3rdparty). Notice that it points to a specific commit.
Check out Assetic.
Super-duper **+1** for using a fluid object-based configuration API. If you're writing a PHP application this is by far the best solution IMHO. It's ultra-readable and it's *dead simple* to understand what's happening regardless of your familiarity with the given library. How many people *really* need language-agnostic config? Not very many, and for them you can always implement an alternative parser.
Have a look at [MetaYaml](https://github.com/romaricdrigon/MetaYaml).
It's shown in the gist that it is equivalent to doing the same thing in user land code, so I'm not sure how you can say it's a performance sinkhole. I'm genuinely confused by your stance on this. Also, as you stated, getting over the initial "ooh shiny" reaction has allowed me to think about it more objectively. I'm thinking now that this is actually a good case for core support of typed arrays. You can implement pseudo "typed arrays" in user land code as well, by doing something like this - https://gist.github.com/dongilbert/8462216 I should use the benchmarks from earlier and compare against that rough implementation.
Good stuff Taylor. I really appreciate how you're responding to all this facade criticism. You've remained positive, and have offered some helpful blog posts, including this screencast. You've even tweaked Laravel to make the manual injection of (the underlying facade) classes simpler. Keep up the great work. It's this type of stuff that gives me, as a developer and also as the senior developer at my work, the confidence to use Laravel for both personal and business projects.
They most definitely are. They of course, referring to the *type*hint. Considering that it's the topic of the RFC, not to mention that it's pretty much all that PHP supports, I'm not even sure why there would be any confusion as to what I'm referring to. Also, as far as the function is concerned, no, you couldn't just pass other types to the function. I mean that's what the proposal is about. So yes, as far as the proposal goes, this would introduce typed arrays to PHP's type hinting. Pass in anything else and you get an exception.
I wonder how many people are completely confused as to why folks can't just call it "Design Patterns"...
Thank you sir. Check out: http://rsangole.wordpress.com/2014/01/15/ardudash-a-dashboard-for-my-ardustat/
The error was gaugetrial.html, instead of the correct way -&gt; gaugetrial.php. Check out: http://rsangole.wordpress.com/2014/01/15/ardudash-a-dashboard-for-my-ardustat/
I suppose you're right. Though anyway, as long as the feature gets approved I don't really care what it ends up being called. Would be a welcome feature to PHP and one that would be useful right away. So cheers for the proposal. :)
I sincerely hope posting kickstarter campaigns here doesn't become a trend.
As long as it's PHP related, and benefits the community at large, I'm pretty sure it's OK.
This is nice, really nice. I too appreciate your dedication and your response to criticism, Taylor. In the last days I've seen a lot of (valid) criticism of Laravel extensive use of Facades, and I really like that you stood by your convictions but still changed your project accordingly, considering we are talking about probably *the* PHP framework. It really talks wonders about your drive to respond to feedback even if it's mean-spirited by some people. By the way, I wonder what's the next app-wrecker feature Laravel's detractors will complain about next
New syntax additions are always nice. (Except for that one time, with the odd operator being introduced due to parser constraints.) However this one is too early. It impairs forward compatibility. Surely supporting an array of object types is only half the feature. It's constrained to lists of the array primitive. And that's odd, since there's an insistence on constraining object classes, but you're not allowing the container to be an ArrayInterface or Traversable object itself. - Which was only feasible in a much later PHP version when method result type-hinting was also there. It's also uneeded in my book, since it can be done already with a one-liner: function test($spl) { assert(["SplFileObject"] === array_unique(array_map("get_class", $spl))); Which is easier to extend onto iterators, and can also be disabled once you've ironed out development-stage-mostly parameter flow issues. Not sure that RFC exists for supporting better autocompletion and variadic APIs, or it's just about compiled language simulation over contracts again.
Thanks for watching!
You're assuming it's _me_ raising money this way, which it's not. That would be Eli White, whom I've actually never met in my life. Also, I'm not so sure he's making money on this, but rather simply providing a service to the community to have access to the ever popular plush elePHPant. But I may be wrong, he's probably making a killing.
Here's what I mean ... &lt;?php class MyWidgetProcessor { // O(n) once for the typehint function processWidgets(Widget[] $w) { // O(n) again here $w = $this-&gt;modify($w); // O(n) again here $w = $this-&gt;modifySomethingElse($w); } private function modify(Widget[] $w) { ... } private function modifySomethingElse(Widget[] $w) { ... } } After the first usage this typehint becomes a big potential performance liability. If you're dealing with any non-trivial number of array elements you have two options: 1. Eat the major slowdown each time the typehint is encountered (most people will do this without realizing why it's bad) 2. Always remember that you should *never* use the typehint more than once on the same data if you can help it A typehint that you can't always use isn't a feature -- it's a liability. The right solution should be able to execute basically in constant time. So while I'm very much in favor of the idea I'm hesitant to say this is the right solution. There may be some ways to work around this but we'll just have to see ...
&gt; You're assuming it's me raising money this way, which it's not. I was, but I apologise for my error. In any case, I hate it when people crowd fund things for profit that they could have funded themselves out of pocket with virtually no risk.
Thanks for the screencast Taylor! I did learn some new stuff about Laravel. But, I do have some concerns about the "automagic" dependency injection into the controller. It looks like you are using Reflection for that and that sounds like it could be a performance issue with hundreds of controllers. I'm on mobile so can't test it right now, but if you have some numbers (or thoughts even) I'd be really interested in hearing them!
Typically, only one controller would be instantiated per web request. But, yes, have done tests. PHP reflection is actually faster than one would think!
That looks great! Thanks!
I can see that now, thanks for writing up a clear example. I wonder if this can be solved by PHP allowing you to declare the type of data that is contained in an array upon array initialization. Doing something like: $fooArray = Foo []; // Or similar to my gist above $fooArray = arrayof('Foo'); In both examples, you would only be allowed to add a value to the array if it is has the type of `Foo`. My gist above accomplishes this by using an abstract base class and implementing Iterator. The upside of this is that it doesn't change the syntax at all of regular type hinting, but that's the downside as well, meaning you can't look at the type hint and _immediately_ know that it's expecting an array which contains only `Foo` values. *Hope that makes sense, I started rambling near the end
your real question should be "what is mvc programing? "
Any reason you implemented a Facade instead of simply using a singleton?
Well ... declaring the type at initialization like that is not that different from what would happen with true generics. So if we go that route we might as well go all the way :) I know that Joe is working on an experimental generics implementation -- whether or not it goes somewhere has yet to be seen. I think most people want to see a solution for this (well, *I would*). It's just important to get the right solution and not rush into something that we end up regretting later or have to change to implement a better solution down the road.
Oh, cut it out. No one was being mean and I'm sure his feelings weren't hurt by valid criticisms [0]. Many developers pointed out something that could have (should have) been done better, and the creator responded to it. I still have other gripes about the framework, but I'm not going around being a bleeding heart about it - it's a fairly solid app and it speaks volumes that there are specific issues some people have with it, and not a "jesus christ this whole thing is shit" type of complaint. [0] If you see negative criticism (jerks being jerks) please point it out by using the *report* link and we'll take care of it. We really do want /r/PHP to be a professional-level sub.
Because the singleton pattern is considered to be an anti-pattern (still debated but that is the stand I am taking). I don't want to have a singleton that you get from a factory class (or service locator). The intention of the facades is to take the way we load up classes (new LeagueWrap\Api) and make it easier to access. Api::whatever() is not a singleton, it's just a simpler facade for the actual LeagueWrap\Api class. Each time you can setKey() or fresh() method you remove the current api class for a new one or null.
Hey, that's pretty rad!
I'm not a PHP internals developer, however the following might work: Let a new array have an internal "homogenous" bit that is set to 1 by default. On each push to an array whether at array creation or later dynamically, ONLY if the bit is still 1, check the type of the new element against the type of the last element. If they aren't equal, then set the homogenous bit to 0. This should be quite fast in C. Though I'm not sure if the engine allows this implementation.
 The risk of using array+list is that you might need to return a third, fourth or fifth value later on. Those values are *unnamed*, so you'll need to remember their *positions* carefully -- you lay a trap for yourself and others at every single call site of the function! Value objects on the other hand can grow as your application grows. You add a few properties, remove a few. It doesn't matter, they're all named. PHP will NOTICE it when the object is mistreated.
What's wrong with your site? Why is it slowing my Chrome browser to a crawl?
I've seen people do that too. Not sure where it started. I kinda think it's a little funky. If you're using Eloquent I would just make a fresh Eloquent query in every repo method. You can ping me on IRC if you have more questions on that.
It's slow-ish compared to php's other features. However we use it all the time in factory classes. The slowest part of your application, usually the database, is always a few orders of magnitude slower.
Foo is coupled to the DB manager. The repository is coupled to Foo, or so you think! Often times the repository needs the DB manager to perform tasks, like start DB transactions or get DB locks. So the dependency might as well be direct. Both solutions encapsulate the instantiation of (new) Foo, thus that issue is solved either way.
Thanks!
Does anyone know of a reliable source to get the normal blue one? 
And when did I say the criticism was in /r/php? I was talking about some stuff I've seen on twitter. No need to get defensive
Second this. I'd like to order a normal one.
Reliable... no Supposedly [this](http://elephpant.com) became the official home and ordering location for them but they haven't updated the page since 2012.
That site looks pretty dodgy. 
Taylor, not that I think the IoC's current performance is a huge concern, but have you considered caching the reflection results into a config that the container reads from, rather than reflecting through the entire graph object graph every time?
Well... kinda. As the RFC explains, the type system is due for an overhaul, and currently hinting `function (array Foo)` is already _only_ going to allow actual arrays, not traversable or anything else. Adding this RFC does not make that better or worse, it just allows an existing issue to remain the same. A follow up RFC to work out how arrays and objects that want to pretend to be arrays can be type hinted as one can still be made later on, and this will not worsen that. Also that one liner looks fucking awful. That is clearly not an alternative. :)
great! but someone can explain me in simple words why is this a better approach than use Facades all the time? thanks.
"Pretty dodgy" is what I like to identify as an understatement. It has been a while but I seem to remember that page was linked to from the old page where PUGs used to order theirs from.
PHParch doesn't sell these as far as I know, they give them away at conferences. The kickstarter is to raise enough money to make enough for future conferences. People funding it aren't buying an elephant, they're funding the campaign and getting an elephant in return.
I'm reading "PHP Objects, Patterns, and Practice 4th edition" (2013), looks very good
&gt; The problem with this website is that there are so many hands on it, and the Linux based server permissions are all screwey so it's almost impossible to edit a pre-existing file without asking someone else to chown that file to you. Once you can move all this into a VCS (Git or otherwise) - look at maybe then doing your deployments via Git hooks to avoid this permissions madness.
Facades are basically pseudo singletons, and are pretty anti-pattern themselves. Was just curious as to the reasoning. Library looks solid though.
Facades (in the style of Laravel/this) behave like singletons (and do affect global scope) but unlike singletons allow the instance behind the facade to be mocked. There are other legitimate concerns with using facades including Global State, and tightly coupling your domain code to the facades themselves - but they do to a certain degree address one of the major shortfalls of Singletons - mocking for testing, which is one of the biggest concerns with singletons in modern development. DI eliminates these other concerns - however many developers find it easier to deal with essentially global (albeit Namespaced I hope!) objects. 
It would look even more awful if it fully matched joeys implementation and actually checked for interfaces/heritage. (So I'll make an exception here and not demand an userland reference shim. Just this once ;) And you're totally right. The array primitive hint requirement was already there; this is only a minor but useful syntax progression. As for now, I'll just keep a pre-asserted WhateverContainer as needed; explicites the method signature a bit more.
What you're looking for is "array_intersect". As long as your data is in the exact same structure for both arrays, matching is perfect. The result will be all matching items. Or if you don't like that method, you can do it the way you suggest, which should only be necessary if you start to get fancy with more intersection options. However, I'd probably use array_map, pass the arrays, and have the callback iterate on array1, and check for !empty on the inversed array2. Probably slightly better speed improvement over array_search you are doing.
I wonder, if someday we can get this on laptops using things that directly project an image into our eyes. something like google glass.
I've always done DDD using Doctrine, but in my case it's Doctrine that fetches the associations of the object. So I'd say data mapper.
I picked up mine at a php con in Amsterdam a couple of years ago. I don't think I've ever seen anywhere online that you could order them from though (I haven't really looked to be fair). The kickstarter seems like an ideal way to get your hands on one, if you like the orange colour over blue.
It really sounds like youre reinventing the wheel here. Just use Doctrine, you wont regret it.
Have a look at Dependency Injection or at Service Containers. If you gave multiple objects that all need the same object, the DI container will give it to them.
Answering your question, what coming out of the repository should be fully 'hydrated' entities, ideally. So the layers above can just do the processing using fully populated entities. By that requirement and considering the single responsibility principle, I think injecting the factory and builder into the repository is the only way to do this. I have written about this [here](http://imakesnowflakes.com/programming-an-architecture-for-php-applications.html), in the 'Repository' section. It is much better to use something like Doctrine to do this, as there are [many issues](http://thatextramile.be/blog/2009/08/build-your-own-data-access-layer-series/) not really obvious, which needs to be solved when using a repository. 
I think you solved it in your first sentence "obtain aggregate root objects", its responsibility is to obtain an object, not to build it. The repository would use a factory service to actually build the object appropriately. Doctrine has a learning curve, but its worth it.
From a external behaviour point of view, it doesn't matter how it does it, as long as the aggregate roots come out with the necessary means to complete their tasks. If you use doctrine behind the scenes, there's a good chance the child/related entities wont actually be fetched and hydrated until they are required, but the aggregate root doesn't really know that. If you're not using doctrine, you might hydrate the full object graph, or you may implement your own proxy type objects to do the lazy loading. Internally, if you're not using a data mapper like doctrine, you probably don't want to handle all of the querying and mapping in you repository, separating the code will help you maintain it in the long run.
Regrading other comments, Singleton and Factory pattern are incredibly different in what they accomplish. For example, if your program requires a long-live object and be initialized once and will be shared across all members of your program, singleton pattern might be the right choice for you. As it stands, some people just make bad design decisions and says it's an anti-pattern. I'm not sure how many softwares require this contract for an object. As for IoC containers (will it be DI or a service locator or a global array list with all your objects) those are good to know, use, and many time will simplify your program in many ways. Testing, readability and such. (clarification edit: Those will not necessarily share the injected object, but mostly create a new one. You can mark the object as singleton/shared/etc or make this the default behavior. That is not part of the patten itself.) The Factory pattern is a whole other beast in my opinion. It is designed to create NEW objects of an abstract type X, where the callee does not 'need' to know the exact type of the object, but only it's interface. Hopefully this helped a bit.
If you are new I don't think that you can use frameworks. After some point learn OOP. Then do some things with OOP. After that you can read framework documentations and understand how to use them.
It's 39". 
Basically, all this DI/Containers stuff boils down to having an array somewhere which contains instances of classes. I found this a lot easier to understand once I'd realised this. Here's a simple example that keeps a single named instance: function container($name, $instance = null) { static $container = array(); if (!is_null($instance)) { // We're trying to get an instance of $className return isset($container[$name]) ? $container[$name] : null; } else { $container[$name] = $instance; return $container[$name]; } } // Put a validator in the container container('validator', new Validator()); // later on, get that same instance out again $validator = container('validator'); Obviously you can get a lot more advanced with this - most of the time I end up creating an interface and one or more implementations. Then I tell the container to give me one of those implementations when I ask for the interface (which makes it dead easy to switch out one implementation for another - a case I used today, swapping a user-loader that uses a database for a loader that uses the session (for guests)). Some frameworks go further and dynamically inject items from the container based on the type-hints in your code. For example, with this function, `inject` will look at the arguments of the function and pick a Validator from the container if one is set, before calling the function: inject(function (Validator $validator) { // ... });
This is a cool article about dependency injection by Fabien Potencier. http://fabien.potencier.org/article/11/what-is-dependency-injection It's worth a read and it may well answer your question.
As I see it, he's not reinventing the wheel, he's asking a question pertaining to a design pattern. "Just use Doctrine" is not a helpful response.
&gt; Some frameworks go further and dynamically inject items from the container Well, that's the definition of a DI container. Everything you wrote above is the Service Locator Pattern. - Service locator: getting dependencies from a container - Dependency Injection Container: having dependencies injected by a container 
Yeah but with factory i will create a new object everytime?
That's going to be one of my points when I try to sell Git to the IT guys.
I'm pretty sure it stores the compiled version internally. I may just run some benchmarks on this. 
[So go suggest it](https://wiki.php.net/rfc/howto)?
if it's going to be done, it has to be made cacheable/serializable, not a resource so it doesn't die after cleanup.
Show us a code example where having this functionality makes life much easier. I'll refactor it for you.
This. If you need access to object somewhere, just "inject" it. 
jesus christ!!! that sounds liek a TV
Good point, I changed a bunch of file names to be more descriptive of the actual function of the class, such as abstract. This also allowed me to make better use out of the 'use' functionality, which is very nice. thanks :)
great talk, I'm not a fan of PHP even that I'm relatively competent with it but this made me want to try Hack. I'm not a fan of static typing either but because most of the time it restricts you unnecesarily however I do appreciate type checking because it saves you from some errors, even on dynamic languages I'm not changing types arbitrarily, I don't even create lists of mixed types. I think the best implementation of types and type checking would be one that prevented you from mixing strings and ints but allowed you to mix ints and longs by example so you don't have silly type errors that are not bugs. Python does this kind of conversion (you can mix different numeric types but can't mix int and str) but it's not typed and does not do any type checking.
The annotations are optional, you can use other formats to specify the mappings.
Singleton is basically a global variable which is bad. What's even worse it's hard to tell it's a global. But one way to make it better maybe give it more explicit name like $db_singleton or something.
PHP does not compile the regex on each call to `preg_*`. It internally will cache the regex for the lifetime of the interpreter. So each call to `preg_*` with the same regex (same exact text, but can be from different variables) will result in using the compiled pattern. [Proof](http://lxr.php.net/xref/PHP_TRUNK/ext/pcre/php_pcre.c#260) Currently, PHP will cache up to [4096 Regexes](http://lxr.php.net/xref/PHP_TRUNK/ext/pcre/php_pcre.c#44). So it compiles once per request (basically)... so: $a = "/f/"; $b = "/f/"; $c = "#f#"; Both `$a` and `$b` will use the same compiled regex internally (because the strings are identical, even though that point to different memory addresses), but `$c` will be different (because even though the regex is the same, it's a different block of text)...
We don't - as Ircmaxwell has stated below - there is an internal PHP cache for this. It's also covered in the PCRE docs in the manual. 
Items is **not** an array. It is an iterator. In fact, it's a [SimpleXMLIterator](http://php.net/simplexmliterator). This means that it looks like an element, behaves like one, but has a "next" method. This is just bad design. As proof, it you check, `$items` will be equal to `$item` in the loop: foreach ($items as $item) { var_dump($items === $item); // should be true }
/u/ircmaxell 's [answer](http://www.reddit.com/r/PHP/comments/1vga9s/php_54_print_r_an_array_is_only_outputting_the/cery3jp) is more correct &amp; complete than mine
Sorry - dug - not "due" - stupid iPhone autocorrect. 
Micro frameworks. 
Thank you for this post. I've been thinking about the best way to do this, but I like the way you approached it. I think I will try and structure a project I'm working on this way. One this to note is that migration classes can't have namespaces or the artisan migrate command will error with a class not found. I took a peek at the source and it looks like it infers the class name by the file name generated for the migration. Since a file can't have a backslash in it's name, I haven't been able to figure out a way around that issue.
I'd just like some first-class support for regex, e.g.: $regex = /^foo.*/; If Perl can do it, we can too... right? :)
It *should* be shared for each context. What that means, is if you've compiled PHP with thread safety (ZTS), then each thread will have its own cache. Otherwise, each process will have a cache. So with fastcgi (FPM), each worker process would have its own cache. But since each worker can run more than one request in its lifetime, they don't die after each request. So the only answer is "sort-of"
I know I'll be shat on by a thousand people, but sometimes, a global is just the ticket.
For downvoters, any particular reason? Any constructive criticism is greatly appreciated. Thanks!
Separate your code a little. When all the lines are squashed together like that, readability is low.
What constitutes a "Micro Framework" is highly subjective. For me it's more about footprint and flexibility than lines of PHP code or [lack of] functionality. Phalcon do provide some benchmarks of their own but they are out of date and it would be nice to see truly unbiased benches: http://docs.phalconphp.com/en/latest/reference/benchmark/micro.html
Are we still building new routers? Also try using docblocks.
How about a database table that relates each SKU to every other SKU it's compatible with? When you add a SKU to the cart, look up that SKU in the table and retrieve a list of all other compatible SKUs.
I like it that it allows an explicit specification of the route.
I didn't bother trying to benchmark Phalcon. Personally, I consider it untouchable in terms of performance. As for the "micro framework" classification, yes it is entirely subjective. For me, I consider something micro if it tries to keep the levels of abstraction on top of PHP very minimal, thus giving you performance at the cost of having to write more code.
Ahhh!! Gotcha!! Thanks for all your help.
Still waiting on type hinting or named arguments. Variadic arguments look nice, but who really writes code like that? The second argument would simply be an array.
One does not currently exist, sorry. I started this project just a few days ago :(
Also, banks don't make unsecured loans to &lt; 2 year old companies, which musketeers.me, the owner of php[architect], is. (I'm also a partner.)
There's multiple ways to go about it, it really depends on context and implementation. Definition of "bad" differs between project and developer. Use whichever pattern makes more sense. - Singleton - One instance no matter what - Multiton - Multiple instances defined by key - Registry / Service Locators - Store an instance that can be retrieved and re-used - Dependency Containers / IoC - Create an instance and set dependencies automatically - Facades - A combination of singleton/multiton depending on implementation I prefer registry or multiton systems myself. My simple implementations can be found in the following classes: https://github.com/titon/common/blob/master/src/Titon/Common/Traits/Instanceable.php - A trait that provides single/multiton support https://github.com/titon/common/blob/master/src/Titon/Common/Registry.php - A static registry class that can factory other classes or get/store manually
That is the site. I ordered two of the blue 'phants from there early last year. It does seem iffy, and I did check my bank statements quite throughly after ordering, but they came a couple of weeks later. Basically you make an order to Nexen(?), a French PHP shop, through that site (I remember having difficulty finding the form), and you get an even less reassuring email confirmation :) It is legit however.
On a side note, I've written a class that will convert XML to array and vice versa. Helps with the tedious bullshit involved. https://github.com/titon/utility/blob/master/src/Titon/Utility/Converter.php Examples of usage can be found in the tests. https://github.com/titon/utility/blob/master/tests/Titon/Utility/ConverterTest.php#L422
It really doesn't surprise me that Silex is the slowest.
Crowdsourcing also serves to vet ideas to see if there is an interest. Especially art or niche things like this.
&gt;Also, banks don't make unsecured loans to &lt; 2 year old companies Then I'm a little confused, since the kickstarter page says: "I'm one of the owners of php[architect], the longest running PHP magazine in the world (11 years now)" So which is it, are you an 11 year old company, or a &lt; 2 year old company? Do you really need an unsecured loan? You have no assets at all? A car in reasonable condition is probably enough to secure something that small. Even assuming all that failed, most people could put that small an amount on their credit card if they really had to.
List is missing argument unpacking, as it landed around the same time as this was written.
The kickstarter is specifically selling elephants. I don't see anywhere where it says "the proceeds are for conferences". Also, it claims it's expensive, even though they're buying them from china which probably produces them at a cost of pennies per unit. This is definitely a for-profit thing. &gt; People funding it aren't buying an elephant Yes, they most certainly are. All funding goals except the first one include elephants.
Named params will likely be postponed to the next release, sorry. I've been too busy with other work to finish that up.
You will be.
Stop running your marketing campaign in this subreddit.
100% agree with everything about this.
&gt; Facades - A combination of singleton/multiton depending on implementation Not really. Facade pattern does not manage dependencies. It's just a way to represent a solid API and a testable code without the knowledge of the internal work it does. It does reduce dependencies in a way that you do not need to know about and include the dependencies facade is using, but it does not mean it has something to do with handling dependancies in your code.
Thanks for pointing this out! [Here's the doc](http://www.php.net/manual/en/reflectionclass.newinstancewithoutconstructor.php). I noticed it when doing research for the post, it caught me by surprise. Still, the trick from the post can be useful if you're forced into using an environment &lt;5.4. Maybe I'll do a follow-up post to explore some ReflectionClass use cases...
This is awesome. Tricky tricky.
I wonder what the performance difference is between the two methods.
[Will we have them this year?](http://i.imgur.com/neq3q2d.gif)
I'm wondering that myself... I'm thinking about doing some benchmarking and writing a follow-up post. Will keep you posted!
It's actually quite astounding that the ReflectionClass method is much faster the more iterations you do - https://gist.github.com/dongilbert/8480612
So the gist shows the results for 100,000 iterations. If you bump that to 10,000,000 iterations, it's even more drastic. ReflectionClass::newInstanceWithoutConstructor: 1.9422609806061 unserialize: 10.180104970932
&gt; I don't see anywhere where it says "the proceeds are for conferences". From the kickstarter: &gt; Secondly, we are hoping (though the production house says that the timeline will be tight) to have these available in time for our big annual conference php[tek] in Chicago in May. Anyone who has ever been to these conferences knows that these elephants are given away. It isn't explicitly stated because it is implied. &gt; it claims it's expensive, even though they're buying them from china which probably produces them at a cost of pennies per unit The factory is in china, the company that produces them is french. Just because chinese manufacturing is cheap doesn't mean products from companies that use chinese manufacturing are cheap. The china connection was only mentioned because it impacts their turn time. &gt; Yes, they most certainly are. All funding goals except the first one include elephants. It's a philosophical difference. Kickstarter makes it very clear that they are not a store, you are not buying something through them. The vast majority of kickstarters do not use the entirety of their funding to provide the pledge rewards, and there is no guarantee that you will even get the reward. The rewards are merely an incentive to get people to front money. It's the same way giving money to PBS isn't buying that piece of shit tote bag they give away.
The magazine is 11 years old, the company that owns it is &lt; 2 years old. [musketeers.me acquired the magazine January 1st, 2013.](http://www.phparch.com/2012/12/musketeers-me-to-acquire-phparchitects-brand-and-products-effective-january-1st/)
Well it's not really about dependencies is it? Facades are simply a wrapper for instantiating a class in a static context, ala single/multiton pattern. Guess it really depends on what class is being wrapped in a facade.
First, performance shouldn't really be the driving force here, the ability to write and document correct and precise API's should be. But we cannot ignore the facts of the matter, essentially this is an O(n) type-hint, if you were to use it everywhere in an application that doesn't bother to check the type of array elements you are operating on, you could well be able to measure the impact. However, the tests also show that in an application that has to undertake that same logic in userland in order to operate correctly, there is a benefit to having the check done by the engine. Generics do solve the problem of the O(n) typehint, while writing to a collection you would incur the cost of type checking O(n), however upon access, or passing of the collection the typehint is 0(1) just like all other type hints. They are however, vastly complicated both for us to write and, maybe more importantly, for new comers to learn. They introduce alien concepts, and I very much disagree with trying to use the syntax here: I want to hint for generics when we can program with generics. Will we ever get generics: well, it's been discussed before: http://comments.gmane.org/gmane.comp.php.devel/76495 There's been much discussion about it today ... I think if we were voting on it tomorrow, the outcome would be "no". That won't stop me writing it. There are many of us that like the idea, those of us that are used to generics in other languages (you pretty much cannot write a java application without employing generics) see the benefits they provide and are not worried about the complexity, there are many more that don't want to see PHP become that rigid, that shy away from the complexity in what is meant to be a simple scripting language. With that in mind, and with the fact in mind that we are discussing a typehint, not a new programming paradigm or the implementation of it, lets try to keep the conversation focused on this RFC in particular, please... That's all I have to say about that ...
Testing hasn't become second nature to me yet, and I don't test as much as I should at my day job working with PHP and the Joomla CMS, but only because the boss hasn't made it a requirement. However, when I contribute to OSS, I always try to have 100% coverage of the code I am adding or modifying, and it's very rewarding to be able to give that to a project.
Link to more information about it?
I don't enjoy testing, it's rather tedious and lengthy. The result however is empowering. 
Do you write them beforehand, BDD style or afterwards? 
Getting into the habit of testing is hard work. I've found following test driven development helps. Generally when I need to do any code changes, I try to write my test FIRST. I've found this helps me narrow down what I'm actually trying to do as I think of tests for the code. Generally, I code like this. 1) Find a problem that you need to solve. 2) Write a test for it (which is going to fail since you haven't written the code that the test uses) 3) write code until test passes 4) commit! Of course, if what I'm coding is hard to test I sometimes skip the test, but what can you do.
I'll write most of the functionality within the class layer, like 75%, before testing. I don't like context switching between implementation and testing. I prefer basic TDD style also.
Writing tests first, for bugs I have to fix sounds like a good place to start for me. Thank you.
Does it take you long to create a test for new code? Is the same amount of time needed for writing tests as the new code do you think?
Absolutely, especially when you write a test that reproduces the bug, you know exactly when you fixed it :)
This is really cool. I made a fun [trait](https://gist.github.com/mattwellss/8481338) to use in *all* your new classes!
Twice as long. I'll have to give myself a little more time from now on when fixing. 
&gt;who really writes code like that C++ programmers. 
You can read [the article](http://programmingarehard.com/2014/01/11/stop-using-facades.html) i posted about some of the downsides of Laravel's facades. I think it was the start of the tipping point for the changes to be implemented. Kudos to Taylor.
It becomes as second nature as writing regular code does. I mean, it still takes time and effort, but in the end, it's worth it to me and my coworkers.
I agree with the abuse of comments thing. Its a junky solution to the problem of how to define schema data in a single file. First time I saw it I recoiled in horror, and still do.
I guess you can argue 'micro' in terms of your application code since you don't bring along a tonne of bolierplate/base classes - since they are contained in the Phalcon module itself. But to counter it does involve a more complex install (compile of the module, addition to the php runtime/ini.
Thanks Anthony, exactly what I thought - so a little nicer than having to compile expressions on *every* request passed to a warm FPM child.
Variadic templates in C++11 certainly do rock ;)
Check the docs. When a SXE is cast as a string, it prints its text. When used as an array, it prints an attribute. As an object, child elements. SXE uses magic methods __toString and the ArrayAccess Iterface, iirc. That's what I think is going on. 
It's also a thing in Python, and it's quite useful in that language. Glad PHP is becoming such a mature language now!
So a router == micro framework now? 
I haven't ever done much with iterators, but it looks like there is definitely a lot of cool things you can do with them. I did some RTFM and saw some examples. I don't know why I've never run into this before though. There is a first for everything i guess. Thanks for your explanation, it definitely makes more sense now. 
Writing testable code becomes second nature. Writing tests is always deliberate. 
Wow - this is **great** news.
Named parameters will change the paradigm of php so much. I can't wait. 
Do you mean typehinting for intrinsic types? There's already typehinting for classes. 
C programmers. dat va_list.
Yes. There's been an RFC of it for years and it still hasn't been agreed upon yet. https://wiki.php.net/rfc/typechecking
*Sigh* ... This is completely useless. Why? Because you should *NEVER* use the builtin PHP server to benchmark anything. It can't use persistent keep-alive connections. This means that you aren't benchmarking the frameworks; you're benchmarking the OS's ability to open and close TCP connections. Also: `ab` is a terrible benchmarking tool. If you see someone using it you can instantly discount the results because if you really know what you're doing in terms of HTTP performance you won't be using `ab` ... Finally: 3 iterations? 1000 requests with 50 concurrency? The only benchmark of any consequence is *at least* 1,000 concurrent clients over 100,000 requests. Anything short of that is a waste of time. 
and you honestly think the scores will be different relative to each other if you deploy and do these benchmarks on a full nginx/apache setup? PHP's ramp up and clean up cycle happens on every request. using PHP's built-in server will give you at least an idea of each framework's performance relative to each other.
 &lt;?php function my_printf($message, $args = null) { $args = func_get_args(); if ($args &amp;&amp; ($message = array_shift($args))) { echo vsprintf($message, $args); } } function my_printf($message, ...$args) { echo vsprintf($message, $args); } ?&gt; Which one is easier to understand, which one more precisely conveys what the function actually accepts ...
I was wondering the same thing, I'm very attached to using Xdebug's remote debugging with PHPStorm, I'm dubious about moving away from it!
Haven't tried it myself but would be interested in hearing how it measures up to XDebug, it would have to be something special to get me to change debuggers.
So in other words this is a micro-optimization?
That is in my opinion incorrect. Here's the Wikipedia article which explains it better the I could, I just read it again. pretty straight forward and small. http://en.m.wikipedia.org/wiki/Facade_pattern
*Here's a bit from linked Wikipedia article about* [***Facade pattern***](http://en.wikipedia.org/wiki/Facade%20pattern) : --- &gt; &gt;The **facade pattern** (or **façade pattern**) is a software design pattern commonly used with object-oriented programming. The name is by analogy to an architectural facade. &gt;A facade is an object that provides a simplified interface to a larger body of code, such as a class library. A facade can: --- [^(**Picture**)](http://i.imgur.com/T7Hh8Xt.png) [^(image source)](http://commons.wikimedia.org/wiki/File:FacadeDesignPattern.png) ^| [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/idanh can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**Summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/PHP/comments/1vfqm0/singleton_alternative/cesndkk)
In a strange, sick kind of way that's almost beautiful. 
Then don't. :)
What's wrong with Symfony's router for example?
Agreed, which is why I prefer YAML to define my schema. I'm not a big fan of cluttering the comments
Oh god my eyes are bleeding
The problem with this logic is that the TCP connection overhead is the biggest bottleneck in this test. The time it takes to open and close connections can vary widely depending on the current state of your OS, how many file descriptors are currently open on your machine, how many descriptors you're allowed to have open at once, etc. This means that "no," you cannot depend on the relative merits of the individual frameworks because framework performance is not the only variable in play in your benchmark.
It looks like a spaceship
I'm not good at writing articles and what not, but someone asked me pretty much the same question on IRC and I answered it (I think) ... here is the conversation verbatim: [13:40] &lt;m6w6&gt; hey joe, does phpdbg support attaching in background? i.e. run a script with as with php(-cgi) and later attach to that process while running? [13:41] &lt;krakjoe&gt; m6w6 no, you have to execute the script with phpdbg itself [13:42] &lt;m6w6&gt; you know, that would be awesome to debug CGI PHPTs [13:45] &lt;krakjoe&gt; you don't need to attach to another process, you can debug a script targtted at the web using phpdbginit and setting your superglobals sensibly such that the code thinks it is being executed by cli [13:45] &lt;krakjoe&gt; cgi* [13:45] &lt;krakjoe&gt; a cgi/apache environment is only an environment with some specific super globals set, so set them :) [13:48] &lt;m6w6&gt; sure, but I don't explicitly need phpdbg for that [13:48] &lt;krakjoe&gt; I admit, it would be cool to be able to attach to another process, but there's no infrastructure for that anywhere in PHP, so you can assume that any infrasturcture introduced would be unstable for a considerable time, there are of course ways to go behind the back of Zend, but do we want to do that, probably not, not if we want to be able to actually control Zend once we are in, it just didn't seem like a good idea to pursue that route ... [13:48] &lt;-- rdohms has left this server (Ping timeout: 606 seconds). [13:48] &lt;krakjoe&gt; well if the idea is to actually debug, then you do need phpdbg for that, you can fool a script in cli to thinking it's in cgi, but you cannot access any of the features of a debugger still [13:50] &lt;m6w6&gt; I'm not sure why I'd use phpdbg over IDE+xdebug, though? [13:52] &lt;krakjoe&gt; well if you want to use an ide you have to use xdebug right now, and there's no particular reason to choose one over the other really ... they are quite different, xdebug has an impact on everything you execute and phpdbg does not, if you don't use any of the features of the debugger it executes the same code you wrote at the same speed as cli, xdebug cannot do that, it changes the instructions as they are being compiled ... I don't like that, it's [13:52] &lt;krakjoe&gt; intrusive and unnecessary [13:53] &lt;m6w6&gt; I cannot access phpdbg.com, so do you plan to support dbgp in the future? [13:54] &lt;krakjoe&gt; there's no plans currently to do that, no ... that's not to say that we won't ever, but nobody started ... [14:03] &lt;bwoebi&gt; the problem I have with dbgp is… xml :x [14:06] &lt;m6w6&gt; Yeah, well, I'm no XML fanboy either... but maybe I'm just a dumbass, but what can phpdbg really do for me? Everybody and his dog seems to have understood that it's cool, just not me... :-/ [14:08] &lt;bwoebi&gt; you mean what it can do better than xdebug? [14:10] &lt;m6w6&gt; Not sure I mean "better", but yeah, let's start with that POV [14:12] &lt;m6w6&gt; I guess it would help if phpdbg.com was online... [14:12] &lt;krakjoe&gt; it was earlier, think reddit took it down [14:12] &lt;krakjoe&gt; can't get hold of chap taking care of it ... [14:14] &lt;m6w6&gt; :) [14:16] &lt;krakjoe&gt; ok well, I'll try and answer the question I guess ... the design of the things aside, firstly I see the requirement of a whole IDE just to debug some code as a hinderance rather than a help, I know xdebug has a command line client for windows, no doubt there are others, but a debugger that I cannot easily interact with is as good as useless, to me, if you are someone that spends their life at a shell prompt, you might not want to use any ide at all, I'm [14:16] &lt;krakjoe&gt; one of those ... [14:18] &lt;krakjoe&gt; being without an ide can surely be a pain for some, it provides things, the most basic of which - access to actual code in a comfortable environment, you can do r/o at the console, and we're all pretty used to that ... code browsers are a bit hard, and we're a bit more zend than php here, being able to actually see what the vm is executing without glossing anything over or simplifying things is powerful for both php users and us developers ... I don't know [14:18] &lt;krakjoe&gt; what features xdebug has in this area [14:20] &lt;krakjoe&gt; breakpoints ... the main thing that you actually want to do with a debugger ... [14:21] &lt;krakjoe&gt; I think I'm right in saying we provide more options here than xdebug is able to, looking at the dbgp doxs we couldn't cover everything we support with just those limited options ... [14:22] --&gt; [[zzz]] has joined this channel (~zz]]@node-63m.pool-125-25.dynamic.totbb.net). [14:28] &lt;krakjoe&gt; the console itself ... I should be able to debug code in php like I can in C/C++, using one console window that provides everything I need, phpdbg is good at that, you don't need to switch windows to do anything: look at code, inspect instructions, see the output of what you are executing, view stacktraces, and actually do debugging (break/step/etc) ... for super complicated applications/frameworks (I imagine) you can register commands written in php to [14:28] &lt;krakjoe&gt; use at the console, to help specifically with your codebase ... think you'd need an IDE and the skills of an eclispe plugin developer to really do that with xdebug [14:29] &lt;krakjoe&gt; and you still have access to the console underneath phpdbg (- or shell command) so you really never need to switch even if you crash a service .... [14:34] &lt;krakjoe&gt; you can do remote debugging, but just not in the same way as xdebug does it, and when you're remote debugging, the same things I just said are still true, you still don't need an IDE, you don't need anything other than a remote installation of phpdbg and a ui ... I put an example one out there, probably better ones will come along ... [14:35] &lt;krakjoe&gt; https://github.com/krakjoe/phpdbg-ui (incase you're wondering where it's gone, we didn't want to merge java into the php source tree) [14:36] &lt;krakjoe&gt; thats about all I got to say about that ... hope i answered the question in some sense ... 
"if" considered harmful; banned from all programming languages!
There are so many things wrong with this, it's not even funny.
it's not too bad to get wired up. Off the top of my head you have to enable it in the php.ini settings. You can verify it's enabled with phpinfo() (you should see a full table of settings, not just one or two mentions). Then hop into IDEA, go to PHP Settings, dig into the Interpreter settings, and I believe there's a Validate button that will confirm that it can talk to XDebug. When you run with debugging it'll pop open a browser for you with a querystring parameter something like "&amp;XDEBUG_SESSION_ID=12345" and that should connect to the listening IDE.
You're clearly missing the point as it has nothing to do with hardware and everything to do with a terrifically unscientific "benchmark." I'm not sure how I can explain it any clearer other than to say: please re-read my last comment.
I have old code where I did that haha. Never again.
TCP connection overhead, maximum fds open, how your OS manages to hold, etc -- these are all dictated by your hardware's capacity, which in any benchmark, is the controlled environment.
&gt; You can unfold the nested ifs into a series of conditions Let's say you're checking a user-submitted value for 8 different criteria, but each depends on the previous one being validated before checking (e.g. you wouldn't check if a username exists if the username provided is empty). I often end up with a lot of if / else in this case and it feels messy, what's the cleanest way to do this?
Throw exceptions on failure and keep going. `if(!succeeded()) throw; if(!succeeded()) throw; ... return true;` Then `try catch` the thing.
That might work for a series of sequential conditions, but how would you use switch/case for nested conditions?
Exceptions can be used in the function for meaningful failure exists. And then use the exception message for display. But exceptions can be used for A LOT of things. There's no definitive recipe for use. The fact that they end a `try catch` block gives more power then an `if` soup. PS: Invalid input is an invalid state.
With IDEA or phpStorm?
ulimit is set to unlimited. ab's limits apply to every test. you think using seige instead would change the results? like silex's score would magically move up? every machine/OS you run that on will have it's "current state". the benchmark is far from perfect but it is representative of each one's performance with respect to each other.
Ok, I have now published that article, I would be really greatful if you could let me know if it helps you or not. http://www.irving-swift.com/2014/01/setting-up-xdebugs-remote-debug-with-phpstorm/
Really great post. I didn't went deep into all details but could you elaborate more on factories, why is bad to create entities using "new"?
&gt; every machine/OS you run that on will have it's "current state" Wrong. The state changes after each benchmark. I don't have time to explain how sockets and HTTP work to you and you're clearly only interested in arguing something you know nothing about. If you understood these things you never would have published such an impossibly pointless benchmark. Just please either spend some time researching these things or stop publishing harmful information and everyone will get along just fine.
How would you do the redirect only if uncaught? 
oh wow. i guess that proves your point well then, since you know i don't know anything about http and sockets, and you do. thanks.
Oh my.
I inherited a whole bunch of projects where the original developer did almost exactly that. The first six months of my job was filled with nothing but rage.
You want to advise the inverse of that !? If you have your environment just so and don't find xdebug lacking or a problem in any other sense, then why would you change. They are very different animals, and there's nothing about the existence of phpdbg that will break anyone's ability to continue using xdebug. Do whatever you are comfortable with, of course you should ...
I find it to be one of the more satisfying uses of testing. Setting up the environment to replicate the bug which should result in a broken build, fixing it and then watching it turn green! 
with PHPStorm, I simply had to add a few lines to my php.ini, and I added some javascript bookmarks to my browsers. I click the bookmark, reload the page and xdebug connects to phpstorm (which is listening for connections to it). I aso set it up so that it doesn't break on code start, so it'll run un-interrupted if I don't set a breakpoint.
That's exactly what I do. It's pretty manageable but the exception technique described above looks like it could end up being cleaner.
You're first example is completely wrong, it's a pretty bad example. Why would you be overwriting $message with the first index in the $args array? Especially since it's its own argument. function my_printf($message, array $args) { echo vsprintf($message, $args); } Yeah... variadic arguments aren't much cleaner for function definitions, only calling functions, but even then it's not much of a change. my_sprintf($message, [$arg1, $arg2, $arg3]); my_sprintf($message, $arg1, $arg2, $arg3);
You should always validate your input on the server side.
I suppose you'd want it both client AND serverside. Considering disabling javascript would be a quite easy step to be able to input not-so-good data.
1\. While Testing: Suppose you have an entity, User and a service UserService. In you UserService you have a method that calls the isValid() method in the User Entity in some way, may be something like ... function addUser($data) { ... ... $user = new User; //assign data to User attributes from $data ... ... if($user-&gt;isValid()) { //some action you need to test. } ... ... } ... So when you want to test the 'if' block in UserService, the isValid() method should return true. You can do this by providing the values passed in $data in such a way that the isValid() method returns true BY CURRENT IMPLEMENTATION OF isValid() METHOD IN USER ENTITY. See how the test which is supposed to test the behavior of TestService end up getting dependent on the implementation of isValid() method in User entity? What if some additional logic got added in isValid() method, and the data we are using in this test no longer returns true? So you want the $user with mock user for the purpose of this test. One which returns true for isValid() call no matter what. If you are using new keyword, you wont be able to replace the generated user with a mock user at the time of testing. But if you have instead used a factory object, we can replace the factory object at runtime to return a mock User entity. 2\. It is easier to track the dependency. When you open the class file for a service and see the list of services in the properties, you can immediately know what all entities are getting generated from this service. If you are using new keyword everywhere, you will have no idea what all entities are getting created from this class. 3\. Easy to rewire stuff. Factory classes can abstract away configuration steps for an entity. Suppose you have 3 types of user. Enterprise User, Business User and Economy User. And suppose these three users only differ in the value of attributes only, but have same logic in their methods. It does not makes much sense to make 3 different child domain entities just so that they can have different set of default values. If we use factory methods, then we can make 3 factory classes, and in each of them we can do the different configuration for each of the 3 types. It is actually hard to give examples of why you should do these stuff in a certain way. But the core objective is to reduce tight coupling, so that when you have to make a change, you have more options regarding how to proceed. Using factory methods is a very efficient way, efficient in the sense that using factories is not as much more difficult than just using new, when you consider the benefits of doing so, even though those are not readily apparent. 
Yeah, this takes me back!
This code actually has high readability. I don't think anyone reading it is actually confused about what it's doing at any point. If you can return to code you wrote a few months after and still know what it's trying to do that counts for something.
http://3.bp.blogspot.com/-brY9XpZqADo/T17lDzRbUAI/AAAAAAAACDM/YD_Th3WpayY/s1600/image4.jpg
The point of this code is not if it is right or wrong, but we must see it as ART. See how each instructions are all well indented. Coming from Python point of view, it 100% readable. Of course no one should never write something like that. But this right here, is beautiful. 
Truly the greatest standard code can aspire to. "It work!" "Yeah, but does it look like a space ship?"
Of course. When you validate data, you expect it to eventually reach an expected state. Like when you register a user, you expect to get an ID from the database. And you'll obviously listen for that to inform the to-be-user of the registration outcome.
A little clearer, separate out the simple validation (does it exist, strlen, etc) then do business logic. function validate($username, $password, $repeat){ if (([validation condition]) { // do work } else { return "The email entered is invalid"; } ... }
I agree completely. My code isn't done until it looks like an X-Wing.
While I agree, if you want to change validation you have to dig deep here. I would leave most of this alone, other than replacing the raw post vars with a pre-filtered (even if that filter is currently empty) variable substitution. $username = sanitize($_POST['username']); and the preg_match is duplicating min/max strlen check.
I think it will be just another debugging type option just as Zend Debugger currently is. I am pretty sure IDE vendors have already put a top priority on implementing phpdbg debugging as it is built in PHP core. PHPStorm will be first to support phpdbg given their track record of implementing new features in a very quick manner. Now from a first glance of the project I see at least two major benefits of using phpdbg over Xdebug, Configuration: Configuration of Xdebug can be confusing for new users. While On Linux Xdebug is bundled as deb/rpm, On Windows it is different situation, you have to check VC++ version, ts/nts version to make it work correctly. Then you have to fiddle around php.ini to enable Xdebug. Then you have to do IDE specific configuration work with IDE's. But with phpdbg there is no such overhead as it is just a console interface which has no relation apache/nginx PHP module. The only configuration the user may have to set is IP and port of remote phpdbg server instance which should have default settings for local development environment. Performance: Xdebug is also a profiler. To gather profiling information it adds extra hook as Zend extension to running process which is very much resource/performance hog. On Linux/OSX you may not feel the difference. But on Windows the increase of execution time is very noticeable. For testing just run a base Laravel/Symfony2 installation with Xdebug enabled and disabled On windows. In this case also phpdbg has no such overhead because it does not interfere with HTTP request processing as it is a console implementation. Also with phpdbg now you can debug pages in your live server without any performance issue. Besides these two points there are other benefits such as debugging from any environment that at least have a functional console, able to debug in other lightweight editors which is matter of personal preference actually. Overall I think phpdbg is a valuable addition in PHP ecosystem. Edit: typo
I use something like this for an ORM class I built for creating a default factory method for classes that extend it (we're at 5.3 at work an can't use ReflectionClass::newInstanceWithoutConstructor). If I remember correctly the purpose was so that the child's class could have a different number of arguments as the parent and have the factory method still work. So I would create an object as you did with unserialize and then manually call the object's __constructor with the arguments from func_get_args. 
True. But even then, "part 1" doesn't really have any content in it :(
As a noob I have to ask. This should be done with "if and" not "if if if if if" right? Or is there a better way? 
That's pretty clean
&gt; Not sure why email needs to be less than 65 characters. One of the systems I work on, I had to enforce a 40 char limit to emails because of some downstream systems. It's rarely a problem in NA, but with some Indian names you can easily get way past that.
I think we all do.
Yeh I agree.
When I first started I did it client + server side, but more recently have been doing server-side only. We have a CRM-type application, and so I think it's totally acceptable to lose a few milliseconds of responsiveness to only have to write the code once (and in the one place that it really has to be done, on the server side). If speed is an issue and / or if the validation is a very frequent part of your application I think doing it in both places makes sense.
45 comments and still not a consensus for what the 'right' solution is. That says a lot about why code like this exists in the first place.
What is the right way to validate / register / login?
Oh god. Seriously, read up on exceptions, and why what you are suggesting is bad. Hell, it's worse than the mess the OP linked to. At least that is clear and obvious. Edit: Just read your nick. Yes, if that is what you are trying to do, then you are succeeding.
Oh, that's equally terrible. I'd -2 that shit in code review so fast... Granted, maybe in this case beggers can't be choosers.
High readibility? Trying to figure out which statements match w/ which errors and the deep nesting are horrendous. Much more readable to just make ifs with returns if you want to follow a similar pattern.
They can work well as a shortcut when your object deals with arbitrary data. There was a simple template class someone posted a few months ago that worked something like this: &lt;?php class Template { private $template; private $vars = array(); public function __construct($template) { $this-&gt;template = $template; } public function __get($key) { if (!isset($this-&gt;vars[$key])) throw new \Exception; else return $this-&gt;vars[$key]; } public function __set($key, $value) { $this-&gt;vars[$key] = $value; } public function __toString() { extract($this-&gt;vars); require 'templates/'.$this-&gt;template.'.tpl'; } } $something = new Template('hamburgers'); $something-&gt;title = 'Hamburger Party'; $something-&gt;hamburgers_eaten = 9; $something-&gt;how_sick = 'very'; echo $something; /* where templates/hamburgers.tpl looks like: &lt;h1&gt;&lt;?= $title ?&gt;&lt;/h1&gt; &lt;p&gt;I have eaten &lt;?= $hamburgers_eaten ?&gt; hamburgers and I am &lt;?= $how_sick ?&gt; sick.&lt;/p&gt; */ You can also use __get and __set on a private property in order to do stuff to it, or use it to generate new properties altogether. For instance, if you were to rewrite DateInterval you might use __get to generate the d/m/y/etc. properties so that you only calculated them when you needed to.
According to the MSDN, in C#, [Properties vs. Methods](http://msdn.microsoft.com/en-us/library/bzwdh01d%28VS.71%29.aspx#cpconpropertyusageguidelinesanchor1) explains when you should consider using a property (accessor) instead of a method. This can be extrapolated to determine whether to use a field (variable) or not. MSDN also describes what fields should be used for in [Fields (C# Programming Guide)](http://msdn.microsoft.com/en-us/library/ms173118.aspx). &gt; **Generally, you should use fields only for variables that have private or protected accessibility.** &gt; Data that your class exposes to client code should be provided through `methods`, `properties` and `indexers`. &gt; By using these constructs for indirect access to internal fields, you can guard against invalid input values. &gt; A private field that stores the data exposed by a public property is called a *backing store* or *backing field*. PHP describes the same usage in their documentation. [`__set()`](http://us3.php.net/manual/en/language.oop5.overloading.php#object.set) &gt; `__set()` is run when writing data to inaccessible properties. [`__get()`](http://us3.php.net/manual/en/language.oop5.overloading.php#object.get) &gt; `__get()` is utilized for reading data from inaccessible properties. To elaborate: Use a property setter when you need to expose a method of altering a private field for which you need to ensure data validity. Use a property getter when you need to expose the value of the backing field for the property/accessor. You can also use either method to create read or write-only fields. Unfortunately, the PHP internals developers shot down the [RFC](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2) for proper properties/accessors in PHP, so following these guidelines with `__get()` and `__set()` requires that both methods are aware of the inaccessible properties you wish to expose. It's a little awkward, and means you will probably have a bunch of `if`/`if else` statements.
When I see a lot of if statements, I see an opportunity to apply a design pattern of some sort.
Ok.. your template example is good. But for your following paragraph.. accessing private properties .. isn't that what you write public getters and setters for? Using magic methods just seems lazy.
Most mocking libraries use eval() to extend the SUT and to override the constructor. See Phake for example. In a way it's still feels cleaner than unserialize(). Beware that unserialize() still calls the *destructor* when the object goes out of scope. 
&gt;To elaborate: Use a property setter when you need to expose a method of altering a private field for which you need to ensure data validity. Use a property getter when you need to expose the value of the backing field for the property/accessor. You can also use either method to create read or write-only fields. Sure. But why not use an explicit public getter or setter method, as opposed to __get or __set? Why not write a public getPrivateFoo() method? Wouldn't that make the code more readable?
Read the first link, [Properties vs. Methods](http://msdn.microsoft.com/en-us/library/bzwdh01d%28VS.71%29.aspx#cpconpropertyusageguidelinesanchor1). It's explained there. Edit: In PHP, it's likely more readable not to use `__get()` and `__set()` in a lot of cases. What I've done in the past is created protected methods that `__get()` and `__set()` call to. Here's an [example](https://gist.github.com/aholmes/8498916). Here's an [example](https://gist.github.com/aholmes/8498953) of something similar in a C# service I'm writing for GitHub. Because WebExceptions might not be the result of an error HTTP status code, if I want to look up what the status code is, I have to run through a couple checks. I use a getter for that with the `public int HTTPStatusCode` property. 
There are several cases i can think of. You want to wrap some legacy/third-party stuff. this allows for Decorators on other objects. And it works for basic operators... $obj-&gt;amount += 2 looks cleaner than $obj-&gt;setAmount(2 + $obj-&gt;getAmount()) Then there is lazy loading. And abstraction. You want an object that hides a redis-hash? easy. of course you can write 20 get* and set* functions for your properties. or have some complicated __call()-function that replaces those, but __get() and __set() seem convenient...
You are right in saying that these should never be used in a normal project. But these are useful in libraries that deal with some very specific cases. For example, XML manipulation libraries. By using __set and __get methods, one can create an object that will convert this $obj-&gt;person-&gt;name-&gt;firstName = "John" to this, &lt;person&gt; &lt;name&gt; &lt;firstName&gt;John&lt;/firstName&gt; &lt;/name&gt; &lt;/person&gt; 
Hmm. Not sure you understand my question, since you have linked to a .net page. I understand when something should be a property vs a method. I understand when a property should be a private property vs a publicly accessible property. I understand that some people even would say that *all* of your properties should be private and only accessible via public getter or setter methods. But I don't understand why you would use PHP's _get($foo) magic method as opposed to writing your own specific getFoo() method. I searched for "_get" and "_set". Your page does not seem to mention magic methods at all.
Ok. Would it be safe to say these are pretty rarely used "in the wild"?
In C# a 'property' is a property that uses a getter and/or setter. You won't find _get or _set because c# doesn't use those. Or magic methods at all. It has accessor syntax.
To challenge your statement of magic methods being lazy, how would you re-write this toy class without using `__get()`? https://gist.github.com/aholmes/8319662
[quick search on github](https://github.com/search?l=PHP&amp;p=7&amp;q=__get&amp;ref=cmdform&amp;type=Code) suggests it appears quite often. If you have your own project, you can avoid these by using getters and setters, but once you have to deal with other people's mess, it really helps being familiar with how magic methods (__call() too!) work. And dont let anyone tell you its about accessing protected variables. They are protected for a reason ;)
Oh god. What scares me is that he got upvotes for that shit, and he clearly doesn't get why it's so bad. Try unit testing that shit. Nope, not gonna happen.
Whoa. Thanks for your time. I think maybe just your initial post and other post were a bit over my head. After all, what use is comparing it to C# when you don't know if I know C#? (I don't) When I first looked at this code example it wasn't clear at all either. Too abstract. But I knuckled down and tried to suss out what was going on. I can see that an inputted array is getting assigned to $container, and that $container is a protected property (although I am not sure why it wouldn't just be called $array?).. .. so from that point on, if you wanted to access the array keys, you wouldn't be able to write discrete getters for them, since you have no idea what they might be called. So they are to be accessed through the __get method, which then "digs in" to the array and returns them. So the Traverse class really just wraps an array in a OOP class? It seems a bit silly. But then I continued to the JSONTraverse class and see that it casts JSON as an array before passing it into the constructor, allowing it to be accessed the same way. But I don't understand the offsetGet method, which checks for an instance of StdClass in the array? I'm not sure how JSON, casted as an array, would end up having a StdClass object in there? So .. thanks .. I think I can see the sense of them now. And I think this is probably the most complicated/abstract bit of code I have seen and actually been able to suss out what is going on fairly quickly .. so +2 points for me. I think that at my level I am probably not going to be coming across use for these magic methods yet .. but it's not such a mystery anymore. I'm still not sure why you wouldn't just work with an array though? And why call everything "offsets"? It seems that what is being referred to are "keys". You said this is a "toy class".. am I looking too hard for it to make sense?
Hey, at least it's indented.
In other words, Reflection is generally thought of as being horribly slow, and it's surprising that in this instance, it's actually faster than the other "accepted way" to accomplish this. It boils down to this: if you need to create an object and not fire it's constructor on PHP &lt; 5.4, then use the unserialize method, otherwise use the newInstanceWithoutConstructor method.
If a construct is difficult (for humans) to parse in English, it’s likely going to be difficult to (for humans) to parse in code: This is the house that Jack built. This is the house the malt lay in that Jack built. This is the house the malt the rat ate lay in that Jack built. This is house the malt the rat the cat worried ate lay in that Jack built. This is the house the malt the rat the cat the dog worried killed ate lay in that Jack built. This is the house the malt the rat the cat the dog the cow with the crumpled horn tossed worried killed ate lay in that Jack built. This is the house the malt the rat the cat the dog the cow with the crumpled horn the maiden all forlorn milked tossed worried killed ate lay in that Jack built. This is the house the malt the rat the cat the dog the cow with the crumpled horn the maiden all forlorn the man all tattered and torn kissed milked tossed worried killed ate lay in that Jack built. This is the house the malt the rat the cat the dog the cow with the crumpled horn the maiden all forlorn the man all tattered and torn the priest all shaven and shorn married kissed milked tossed worried killed ate lay in that Jack built. This is the house the malt the rat the cat the dog the cow with the crumpled horn the maiden all forlorn the man all tattered and torn the priest all shaven and shorn the cock that crowed the morn the farmer sowing his corn kept woke married kissed milked tossed worried killed ate lay in that Jack built. This is the house the malt the rat the cat the dog the cow with the crumpled horn the maiden all forlorn the man all tattered and torn the priest all shaven and shorn the cock that crowed the morn the farmer sowing his corn that owned the horse and the hound and the horn kept woke married kissed milked tossed worried killed ate lay in that Jack built.
sorry. I did this to someone. I was in the Air Force as a linguist, but had a slight understanding of programming. I took initiative to improve some of our processes by making a site that aggregates certain types of data and I taught myself PHP to do so. In the thousands of lines of code (most of which existed in a single, giant static class) you could see the evolution of my coding ability. I am now a full-time PHP developer for a private company.
As a new coder, what is it specifically that makes this bad? Just that it's statements within statements?
This code can be better but the same can be said for just about any code. It's clear enough that it can be tested and refactored without much doubt about what it's supposed to do. &gt; Any fool can write code that a computer can understand. Good programmers write code that humans can understand. -Martin Fowler In addition to it's readability I'd also argue that it's good because the function (even if poorly named) almost only does 1 thing which is validation.
Not really. The whole point of this thing is to validate data. You should expect the functions to either return true or false as well as an interface to retrieve messages about the errors. That's it. There are a whack of existing packages out there to handle validation, most do a good job, and none of the good ones throw exceptions when validation fails. An exception is used to interrupt flow when your program encounters a situation it... Edit: Argh, mobile. Will type more later.
The same way you validate anything else. Check out the existing validation libraries on Packagist like Respect. See how they work. Look at Symfony and Laravels validation as well.
This is my usual approach too. 
*xD*
One thing you can use __get and __set and __call for is creating immutable classes in php. Since php automatically creates member variables on class instances when you first access them if they dont exist, you can implement __set and throw an exception to prevent this if a class has member variables that are supposed to be immutable. They are also commonly use in Active Record ORM implementations such as Eloquent (laravel) where the actual data for a model is stored in a member variable that is an hash/array in order to implement setters. I prefer explicit setters/getters (which are also possible with many of these ORMs but many use __set by default).
You can write an activerecord-like class where you set properties on an object and when you set the properties the values are automatically also saved to the database, or disk, or something.
I was thinking of it as an aid to prevent people from adding the multiple copies of the games with slightly different names. Furthermore, when a user thinks "I have a game I want to add", it would be nice to quickly find out which games are already there. Keep building, ideas will flow once you get better and better with the true power of SQL.
As I'm still learning PHP, I sincerely appreciate you taking the time for this explanation.
This one: `&lt;a href="/mission/" id="photo3"&gt; &lt;img src="mission2.png" alt="" title="MISSION"&gt;&lt;/a&gt;` First is relative *(bad idea, things can easily go awry)*, second is external absolute. You should use internal absolute *(no protocol and host, starts with / at root of site)* to make sure you don't f anything up with the host name *(as in www vs www-less)*.
Good God! You should use an exit-first strategy, not else the return. `if(!validation_condition()){ return ""; }`. That's it. If the following code is executed, you know the condition succeeded.
Hey, atleast the indentation looks good. Take that same code and mess up the indents lol
Seems like that guy switched to PHP from Lisp
I am bit confused by what you wrote , do I use this one ../mission/index.php or http://www.baseball-starz.com/mission/ as for best for the web crawler to see and list on google ?
[See this StackOverflow question](http://stackoverflow.com/questions/1418069/seo-relative-url-vs-absolute-url). Short answer: relative is fine because spiders are smarter than you think. Long answer: Your site map should include absolute links with full URL paths. If you're concerned that someone might steal your content then an absolute link may send their visitors back to your site. Google only cares that your URLs resolve and that you properly label links.
Exactly! It should be written "log in" in this case.
I understand now , thanks.
didn't think that was gonna work but it did , thanks.
false **!==** error, why do you assume that? The result from validation is either `true` or `false`, not *success* and *error*, thus *"using exceptions to handle errors"* does not apply here.
At least it can be unlearned. The problem are the people that confuse good looking or easy to use code with good quality code. It's what made CI so damn popular for some reason, and its offspring doesn't fill me with hope.
FTFY: function validate_register($POST, $UserRepository) { if(!$POST['user_name']) { return 'Username cannot be empty'; } if(!$POST['user_password_new']) { return 'Password cannot be empty'; } if($POST['user_password_new'] !== $POST['user_password_repeat']) { return 'Passwords do not match'; } if(strlen($POST['user_password_new']) &lt;= 5) { return 'Passwords must be at least 6 characters'; } if(strlen($POST['user_name']) &gt;= 65 || strlen($POST['user_name']) &lt;= 1) { return 'Username must be between 2 and 64 characters'; } if(false === preg_match('/^[A-z0-9]{2,64}$/', $POST['user_name'])) { return 'Username must only contain alphanumeric (a-z, A-Z, 0-9) characters'; } if(!$POST['user_email']) { // personally, I disagree with this one. return 'Email cannot be empty'; } if(strlen($POST['user_email']) &gt;= 65) { return 'Email must be less than 64 characters'; } if(false === filter_var($POST['user_email']), FILTER_VALIDATE_EMAIL)) { // this is probably over-exclusive. return 'You must provide a valid email address'; } // UserRepository is smart enough to return FALSE when user creation failed $user = $UserRepository-&gt;create($POST['user_email'], $POST['user_name'], $POST['user_password_new']); if ($user === FALSE) { $return = 'Username already exists'; } return $return; } function register($POST, $PHP_SELF, $UserRepository, $Session) { $result = validate_register($POST, $UserRepository); if (is_string($result)) { $Session-&gt;set('msg', $result); } else { $Session-&gt;set('msg', 'You are now registered so please log in'); redirect($PHP_SELF); } }
Julien's slides are always really well thought out, and easy to understand even after the talk that he made them for has taken place and he is no longer talking .... he's very good at that .... I have no idea how he plans it out in his head, wish I knew ...
Impressed they let you do that. I know someone in the UK military police, he took the initiative to made a simple web front end to search their DB better and got in massive trouble.
I always find showcasing websites to sell a server-side framework a bit silly. Server-side frameworks never limit what you can do on the client side, and all these showcases really do is show off design and UX work.
This is the same as the "pyramid of doom" that amateur JavaScript devs get into with callback onto callback - and hence why Promises are being added to ES6 and a tonne of pollyfill libs exist. The idea of a promises lib for PHP now there is a strong anon function solution in play makes more and more sense to me as a side project...
I take it by CI you mean Codeigniter, and not Continuous Integration?
These two magic methods together with `__call()` and `__callStatic()` are mostly to add syntactic sugar for later development. Even the example /u/i_make_snow_flakes gave can be done without magic operations. However, when you think about it, `$html-&gt;head-&gt;title` is much nicer to read than `$html-&gt;get('head')-&gt;get('title')`. The template example /u/Aquatakat provided, can equally be done without magic: class Template { // code public function get($key) { return $this-&gt;vars[$key]; } } When you write the class itself, it may add complexity to the class, however, reading code later on that is based on these classes, I find them to be more readable. In my opinion, generally if feel free to add these four methods, but if without them the class wouldn't function properly, then you're doing something wrong.
Yeah i'd have a field =&gt; message array and foreach it. Check and push the message on fail into an output array. Implode and echo! 
Wouldn't it be better to throw an exception rather than returning an array with the error message?
Great slides! Easy to understand and highly educative for internals beginners like me. I particularly enjoyed the object memory consumption and object lifetime / shutdown sequence stuff. Also, slide #2 links to [PHP Internals Book](http://www.phpinternalsbook.com/) which looks like a worthy read if you are interested in internals.
Yeah, in all fairness if you turn the clock back five, six or seven years, before OOP was quite so widely adopted and procedural code was the norm, this wouldn't have looked so bad. These days of course, you'd have some form object that handles the validation and messages, and then 'hydrates' a user object (yes, I use Zend). In fact, you'd probably hydrate with an array or something so that you're not directly accessing post data, allowing you to create users in different ways, such as API calls and so on. But yeah, I see the funny side of looking at this code now, but if it's legacy code, I suspect that whatever application it originated from is also all procedural, so either refactor the lot, or yell 'yolo' and go balls-deep in legacy. 
Registry pattern is a good example of using those magic methods.
tldr 
Testing *is* coding.
Of course.
I may get flamed , but https://tutsplus.com/courses/ has some great courses.
thank you.
thats actually a good one.
I'm actually pretty surprised they let us keep it. We did most of the initial development on our own time with none of the higher ups being informed. We showed it to them in time for them to take credit.
Simpler: https://github.com/myclabs/php-enum
Very verbose
What joe said.
HHVM seems great, but seeing that it's not yet passing 100% of the unit tests provided by some of the major frameworks (Zend and SF2) makes me want to stay away from it until it's up to par with the "official" interpreter. Don't get me started on weird products, like SugarCRM and whatnot, it's already kind of broken on the classic interpreter, imagine that on HHVM.
Still; this is a situation where an error is a normal thing to occur. Just because it's named an error does not make it suitable for exception usage. An exception should be something that must be handled specifically by the application, and something which is not supposed to happen during normal operation. If you're using exceptions to signify user not found, an invalid password and stuff like that, you're using exceptions as a flow control. In general people tend to overuse exceptions. Exceptions are not "The login operation wasn't an success as the username / password didn't match", an exception would be "the database wasn't even there, there is nothing I can do. This code does not do anything useful as long as we're in this state."
I agree with you. I myself in my code check for the success of the login action, but in `treycook`'s example he's exiting the application when an error is found. In his example I still think he should be using an exception.
I use a git based deployment hosting service called Pagodabox - the PHP equivalent of Heroku. After the initial configuration and defining any jobs you want to run on deployment, its a breeze. All I need do is git push to my Pagoda remote and the rest is taken care of. With regards to asset minification, I use Grunt.js (well worth learning)
Take a look at Beyond Compare, it's the best in its class for uploading changes. Also, learn git.. it has countless commands, but you don't need a lot for basic versioning and it instantly adds quality to your life.
**I use command line FTP.** *I'm that awesome!*
&gt; Also, learn git.. it has countless commands, but you don't need a lot for basic versioning and it instantly adds quality to your life. I dunno, reading about it suggests that its easy to screw things up with git unless properly learnt. I am considering other vcs (mercurial) though, will have to use a vcs eventually, but not git.
I use git to manage files using a variant of [this article](http://joemaller.com/990/a-web-focused-git-workflow/). I end up with quite a few useless commits but it makes it easy to manage large projects with multiple people working on it. Git has a steep learning curve but is great after you get the hang of it. There are also many GUI's out there for it you could use. Given how prevalent git is, it's good to know it whether you use it or not. As far as keeping the DB in sync, I typically create a deploy.php file is run every time I push to the server. It runs any DB changes I want to do. For larger applications, I often use Laravel and their migration system. In regards to minification, I personally use [Grunt](http://gruntjs.com/). I have a task to setup to minify css, js, and imgs. I also run it every time I push. Changing settings depending on your environment is easy. Just need to create a script to read the hostname or server address and change the settings accordingly. All of these are tied to git hooks to run automatically.
Writing tests in behat/cucumber and gherkin has become so second nature, I dislike diving into code without it. BDD provides a good focusing agent so I have a better feeling of what I'm coding toward. Then I use phpunit to build unit tests *while* I'm developing, so that when I refactor, I can check to make sure things are all still working. Once you get into this habit, it feels weird not to do it.
No, he is right. Git is the way to go. Sure you can screw things, but git restores almost everything probably. You really need to know what you're doing to delete sth. forever. git is wildly adopted and it's a breeze to setup your own remote-repository. Bonus: A lot of [useful git-hooks](https://github.com/greg0ire/git_template) are out there.
Its the 'feels wierd not to' that I'm hoping for. I'm not there yet. I still think about what makes a good test and is there some case im not thinking of that will slip through. 
This is one I highly recommend http://knpuniversity.com/
"I have given up on learning git" This is the problem. GIT was developed for this exact purpose. You should definitely learn it because it solves the exact problem you are facing. 
We use Capistrano to pull code from our Git repositories. It's ruby but works great with PHP. Running "cap deploy" on our staging server via SSH deploys the latest code from our staging branch and on our production server it pulls the latest code from our master branch. Very simple. 
I'm also going to ignore you and recommend git. It is so worth it, and is perfect for deploying to your server. If you don't deploy out of git, you will never know what files have been modified by that hacker that may or may not have gotten in, for example. You will never know the joys of experimental feature branches that are instantly deployed and instantly rolled back when you realize it didn't work how you thought. Git. Learn it. It's not an option. It's not even hard. add, commit, push, pull. That's all you need to get started. Get a free private bitbucket repo and start pushing files to it, and then pull those files to your server. There are tons of great git GUIs for windows. Please, learn it for your own sanity. Edit just to say that you should also look into Grunt for stuff like file concat and min'ing. Yes, another command line tool. Windows is not my favorite OS for Web Dev.
The big thing missing from this and every other userland enum implementation for PHP that I've come across is automatic value enumeration. Traditionally, it goes something like this: enum Foo { A = 42, B, // 43 C, // 44 // etc... }; If I were to try and solve that problem, I would use private static properties for the enumerators, instead of class constants: class DayOfWeek extends Enum { private static $MONDAY = 1, // ISO-8601 $TUESDAY, $WEDNESDAY, $THURSDAY, $FRIDAY, $SATURDAY, $SUNDAY; } ...and expose them through the de facto static method call interface that most libraries use: $day = DayOfWeek::WEDNESDAY()-&gt;getValue(); // int(3)
This looks pretty solid =D! I wish you made the github account a organization though considering you have what looks like a handful of repos for the RedKite CMS.
I have a Dev server that is a mirror image of the production box. When I make changes on Dev I use Beyond Compare to move them to production. This works well for me since I am the only developer. When there were two of us things got a little wonky especially since he coded on his local machine instead of the Dev box. He wouldn't get all my changes or I wouldn't get all his. Spent a lot of time bickering with him about it. But I don't have to deal with him any longer. 
Having used both: Mercurial is not really that much easier to learn than Git. Neither is any other VCS I've ever come across. It's a steep learning curve, but once you've got it figured out, you won't want to go back. I'd recommend giving [the book](http://git-scm.com/book) a try.
I've began using jenkins for deployment. Fits my needs and is easy to setup. I have a main and development branch which both have a job associated with them, which are polled by jenkins to track for changes (you can use hooks, but my company gets a bit funny about security). After a commit is pushed into the development branch, jenkins will pick this up, run tests and if the tests are successful then it will push to the development server. Prior to actually pushing to the server, jenkins will create a symbolic link to a "maintenance mode" page which is removed once the files have been uploaded. When development is periodically merged with main the same thing happens, but with the live server.
I spent about a month learnning gitolite and have now the perfect "launcher" for all my projects. I have setup a gitolite server at home where I store all projects that need remote access. I can now with a couple of commands pull projects anywhere I need them, for production or just to work on them on another machine etc. Git and friends are nothing short of amazing.
[Proof of concept](https://github.com/drrcknlsn/enum).
No problem. I wrote this a while back as a fun exercise in OOP to create an OOP version of the `get_in()` method on [https://igor.io](https://igor.io/2014/01/08/functional-library-traversal.html). I called it a "toy class" because you wouldn't use it in production. It has way too much overhead for what it accomplishes. However, it does demonstrate how `implements`, `ArrayAccess`, `extends`, `__get()` and inheritance work. I understand how linking to the MSDN documentation was too much, but again, the question you asked relates directly to OOP, so I figured I'd challenge you a bit, and show you some information from developers that know a hell of a lot more about programming than most people. Check out the php documentation for [`ArrayAccess`](http://us1.php.net/arrayaccess). I think that should answer your questions about `$container`, why I'm not just using an array, and why I called the indexes `$offset`. To be a bit more specific, the class makes it so you can access an offset of an array whose parent offset might not exist. There are other solutions to do this, but again, this was just an exercise. Here's the problem it solves. $data = array( 'foo' =&gt; array( 'bar' =&gt; array( 'baz' =&gt; 'qux' ) ) ); echo $data['foo']['bar']['baz']; // qux // case-sensitive echo $data['foo']['BAR']['baz']; // Notice: Undefined index: BAR // get around NOTICE with a check if (isset($data['foo']) &amp;&amp; isset($data['foo']['BAR']) &amp;&amp; isset($data['foo']['BAR']['baz'])) { echo $data['foo']['BAR']['baz']; } else { echo 'not set'; // this is output } Now with `Traverse`: $data = array( 'foo' =&gt; array( 'bar' =&gt; array( 'baz' =&gt; 'qux' ) ) ); $t = new Traverse($data); echo $t['foo']['bar']['baz']; // qux echo $t['foo']['BAR']['baz']; // null I use `$offset` because, to me, `$key` is a non-integer value. That is, "foo" in the above example. I use `$key` for hashes, dictionaries, etc. I use `$index` for integer values, which are used in arrays, i.e., `$array[0]`. I use `$offset` when I don't know what the incoming values are. `$offset` also makes it clear the the value represents the position of some sort of data. In `JSONTraverse`, I check whether the data is `stdClass` because casting the result of `json_decode()` to an array does not cast all offsets to an array. So, when `JSONTraverse` needs to get the value of an offset, if that offset hasn't already been cast to an array, it does so (overwriting the `stdClass` value), and then delegates to the Traverse class. `JSONTraverse` essentially exists just to ensure that the data making it to `Traverse` will work. I use `$container` because, as far as `ArrayAccess` goes, the data its implementer is working with might not be an array. In fact, in `JSONTraverse`, it's a bunch of `stdClass`es! `$container` is arguably more accurate. In addition, philosophically, I usually don't like to name my variables after constructs. I'd rather call an array `$data` than `$array`, for example. I hope that answers your questions!
Did you read the entire introduction?
Yes. The effort is nice, but i don't see using something like that on daily basis. TBH i don't think that's the question of implementation, but nature of the language.
Capistrano has made my life so much easier. Especially when deploying rails apps. 
Looks promising... one thing I did notice is you're using the Symfony default favicon, might want to change that :)
Cool site, thank you 
i either use WinSCP if its testing and a single server, or if its a real project with a webfarm, we use jenkinsCI http://jenkins-ci.org/ [with SVN, we dont care about git much, theres no huge benefit for us]
Pushing development websites to production servers was never really Linus's aim when developing Git - the story why Git came about is well documented elsewhere (I'm sure the Git Wikipedia page has it covered). But yes, it can be used as a Git remote/hook for easier deployments.
We use Capistrano to deploy code and manage migrations (among other things). 1. `develop` branch goes to staging, `master` branch goes to production 2. Capistrano recipe runs migration command from Laravel to handle database changes 3. Use Chef plugin to auto-discover all servers in a specific environment that needs the code 4. For worker servers, the Capistrano recipe also restarts our Supervisor processes to refresh the workers with the new code 5. Also integrates with NewRelic deployments, HipChat alerts, etc. so we know when deployments go out (also tags each release to build a changelog). I *highly* (can't stress it enough) you learn git and either use BitBucket or Github (we prefer Github) to store your code and just setup http://dploy.io/ to deploy. It's ridiculously easy to setup.
This seems good, but why another? What is wrong with Twig or even Smarty? I am not against it, but I tend to prefer having cooperating developers on high quality projects, not having project duplication. Related: http://stackoverflow.com/questions/3646290/razor-syntax-php-equivalent
I personally like making both A/B suggested dependencies and throw an error if neither is installed, though your documentation should make it very clear you have to add the others. Although I understand having extra code in the `vendor` directory doesn't matter if it's never loaded, I hate having to install many dependencies that I would never use. That's just my personal preference. Though my second option would be requiring both and including them both.
Class names in PHP are case-insensitive. :) &lt;?php class My_Class { function __construct() { $this-&gt;name = __CLASS__; } } var_dump(new My_Class()); var_dump(new my_class()); Outputs: object(My_Class)#1 (1) { ["name"]=&gt; string(8) "My_Class" } object(My_Class)#1 (1) { ["name"]=&gt; string(8) "My_Class" } It's good that you are questioning the use of these pieces of functionality. They aren't right in all cases. I like to follow a guideline of "if you need to justify the use of something, don't use it." That's general, but it keeps me grounded sometimes. Now you know about these details, so when you find yourself in a situation where they will help you, you will think "Ah ha! That's what this is for!"
Nice tutorial and good code examples, though you may want to get someone to go over the text and double check it.
Sorry... I was on mobile and my ADD flared up while responding. I was more specifically addressing the problems with syncing files. While git was not developed for this purpose specifically, it can easily be extended with hooks or other third party tools that can accomplish the other tasks. 
Remember private $type needs to be protected $type Or else the abstract will always return null in the method getType
nested statements.
100% correct sir, thanks for the correction. The change is now applied.
Smarty was the most powerful engine in its glorious days, but it was replaced by Twig’s approach of template extensibility and other engine functionalities like [embedded templates](http://twig.sensiolabs.org/doc/tags/embed.html). Razr does not seem to path the way to any new paradigms and it seems it is a strict subset of Twig despite arguably a cleaner syntax. My point is that it seems to be reinventing the wheel while Twig is very mature, widely adopted, but still in need of help: https://github.com/fabpot/Twig/issues It is a bit like LESS and SCSS, I really don’t understand how these two very similar and open-source libraries haven’t merged yet. It seems you (or the author) are very competent at writing quality libraries, writing a lexer/parser is not something you do in the morning while eating your cereals. I am sure your help would be greatly appreciated.
Love it!
We use Git and a Fabric, which is a Python lib for running arbitrary tasks on remote servers.
Please keep in mind that I used simple examples to try to demonstrate the concept rather than giving you a full blown implementation. Now on your example https://gist.github.com/aholmes/8512551 there is a problem now your controller is 'involved' in the logic that creates the product objects. While this code will work is not the best practice since the controller **'knows too much about the products'**. Check the [SOLID principles](http://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)) for more information What happens if there another 10 places where code needs to instantiate the products in a similar way ? The code starts becoming harder to maintain and you would have to update all the places where that logic is implemented, or what would happen if you want to change how a specific class work ? You would have to search and **modify every single line** where called: $product = new Product_table('sku','name'); There are some interesting factory method implementations in the wild too, Magento for example, has a unique one that also allows it to do class overrides. Also keep in mind that the point of using design patterns is make our life as developers easier there are going to be cases where is a good idea to use and cases that they will add **unnecessary complexity**. 
How generic are the design pattern videos? Do they have a heavy Laravel slant? How in depth do they go?
Sure, all of this makes sense. The part that never clicked for me (until I sussed it out in my comment above) was why it mattered to have a separate method to act as a constructor. I was framing the problem incorrectly. Factories are not replacements for constructors. They are "constructors for constructors." They are the details of how to get a class, and then the class can construct itself. At least that's what makes sense to me now.
Correct, there are complex usages that involve factories using factories. And some variations on this pattern like the Abstract Factory, if you ever want to learn more about design patterns I highly recommend http://www.amazon.ca/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1390177688&amp;sr=1-1&amp;keywords=design+patterns Unfortunately there aren't many examples of design patterns in PHP so I been working on this article series to provide more content and examples of how design patterns can and are used in PHP.
The page list is really fast getting clumsy - some kind of grouping is needed. Searchable selects would also be a nice touch
I'd say that there's a pretty heavy Laravel slant to them. If you're not already familiar with the concepts, it might be a bit difficult to pull out the information and apply it outside of the framework. That said, if you're going to use Laravel and you're looking for a great resource, laracasts.com is the place to go. 
This was a good example.
The one I noticed was that &gt; without necessarily knowing what type of object is actually creating. Should be: &gt; without necessarily knowing what type of object is actually being created. Other than that, good article 
&gt; without necessarily knowing what type of object is actually Changed and thank you. 
They should be suggested. I ran into this issue when I wrote a DBAL, as each driver was a dependency, but one was needed for functionality. In the DBAL package, I simply did a composer suggest for mysql/pgsql/sqlite/mongodb and allowed them to choose. Probably the easiest approach.
It seems good, but what does Razr bring to the table that is missing in the other templating engines (Twig, Smarty etc...) ? For an alternative, checkout [Handlebars.php](https://github.com/mardix/Handlebars). It allows template portability, where that same template can be used with PHP, Javascript, Python, Ruby etc..
Add Composer and Vagrant to your workflow. 
This is inaccurate, since the $type property was used in the abstract class, when it is declared. Here is a quick example to show it to you: abstract class Test { private $type; public function __construct($type) { $this-&gt;type = $type; } public function getType() { return $this-&gt;type; } } final class OtherTest extends Test { public function __construct($type) { parent::__construct($type); } } $otherTest = new OtherTest('mytype'); echo $otherTest-&gt;getType(); This renders: &gt; mytype ... not null. **EDIT** I just saw the [OP's comment reply](http://www.reddit.com/r/PHP/comments/1vm1kk/design_patterns_in_php_using_factories/cetqwvr). Maybe I didn't see the problem you mentioned because OP's changed his article? Am I missing something? **EDIT** Thanks for [the explanation](http://www.reddit.com/r/PHP/comments/1vm1kk/design_patterns_in_php_using_factories/cetx2k1) [wvenable](/u/wvenable)
I love twig. But I thought Blade and Twig similar in capabilities. So can you explain a bit why you think blade is not as good?
Your example code here is correct. The author's code is very strange as it declares a new private $type property in each subclass which would be inaccessible from the parent class. I honestly don't think the author's code is going to run correctly. You're example here makes much more sense and is the more logical way to approach this pattern. 
Oh, you are right. I just didn't see those $type properties in mother classes. My bad. And you are right. OP's code is horrible.
Hey, this is pretty nice! Are you the author? Would like to put this up on puphpet.com!
As someone who is somewhat of a php newbie,(I mean I've created a few php applications but never anything passed the basics of reading and storing data to a database) what does this provide to us? 
&gt; The previous example is not only messy but hard to maintain too, what would a happen if we suddenly added a new parameter to our __construct() function? You guessed right; that would mean updating every single instance where we call new on any of the product classes; that would mean a few hundred lines changed on our example controller function. Not really. I can always add the new parameter as optional. right? Just for the sake of argument. And I am not sure you should be advising use of static factory methods. May be you want to keep it short and simple. 
I think that is pretty similar to Blade. Always thought that Blade was inspired by razor since TO is a .NET developer also
You should definitely have to try Rocketeer. Cleanest way to deploy php apps. With capistrano it is a little akward IMO
Hey thanks! Yes of couse, RedKite CMS is fully hosted on github! You can find sources here https://github.com/redkite-labs, while blocks are hosted here https://github.com/redkite-blocks and themes here https://github.com/redkite-themes/. This last one is quite poor at the moment but I'm working on a new theme now and hope to get some contributions. Thanks
Hello, when the project started, the Symfoy CMF was just started so it was not appliable. Now it's something to evaluate. yes it is production ready
Yes I missed that detail :-) Thanks!
Good point! I will open an issue for that
So many template engines and frameworks. Why should anyone learn a whole new system? Even if it's marginally better, it isn't worth leaving the big ones with grounding and are tried and true.
https://help.github.com/articles/what-s-the-difference-between-user-and-organization-accounts
Since you are a windows user you probably need a GUI so you can understand git. Take a look at source tree. Honestly I don't know how you can be a developer today without learning git. Once you learn git, there is a project git deploy that will let you deploy you project with a push. 
hi all. another exercise with lambdas. had fun coming up with the names/functions for this.
Out of curiosity, why is Blade useless compared to Twig? I like Blade because of its ease of use in Laravel, but I'm not married to it and having its babies. I'm just wondering why you draw that distinction between brilliant and useless with two products I (in my ignorance) see as being relatively similar?
Oh. I asked the same question. I should have just upvoted yours :D
Yep, that's exactly the case. Blade/Razor/Razr. Not hard to see the logic here. I'm not sure if Blade can be used outside Laravel, so maybe if you're used to Laravel's templating but not working in Laravel this has something to offer?
I won't actually use this. But I did laugh. :)
it's partly done its job then :)
&gt; I probably will sound like a dick here, but if this is true then you should just give up PHP too I have already mastered php and I should give that up just because I won't use a tool to sync files that takes a month to learn. They told me the git crowd was arrogant and loud, I didn't realize how right they were.
I use more comprehensive tools, but *slow clap*. Have an upvote, I am only sorry I have but one to give.
Smarty was godawful. I hated it. At the time I wasn't a big fan of template engines anyway, but I always thought its syntax was needlessly obtuse. Twig was better. Why Blade instead of Twig? It's built into Laravel. :) 
The code will run fine http://codepad.org/exu0GbcH
Is there anything that can be added to post to clarify whats the point behind the factory pattern ? Or where did you felt the explanation was lacking?
Sure, let me add some details. I wasn't sure if my post earlier in the day clarified what I felt was missing. * I felt the use of a switch-statement in example 1, and then refactoring that in example 2 detracted from the purpose of the factory pattern. Since that particular design decision doesn't relate to whether, how, or why to use the factory pattern, it muddled my expectations of the post. * Explaining why it makes sense to have not only a separate method, but also a separate class would be valuable. Stating that the factory pattern "encapsulates the logic for instantiating complex objects" isn't very clear because there are many ways to do this. Why abstract it with a separate class, and pull related logic out into something else? * Explain why `Product` is abstract. That caught me off-guard, knowing what abstract classes are for in general. I'd never before considered that preventing instantiation of that class is a way of enforcing the factory pattern, to some extent. * Maybe this one is only useful to me because of how it clicked, but explaining that the factory class and method are a way of "constructing what `Product` is," and using the `Product_*` constructor to build the instance of what is returned may provide clarity. This could be paired with an example of swapping the factory with a test class. I think my only gripe is that you showed us an example, but the "why" (and the "why this way") wasn't very clear. Still, with some effort, your post made factories finally click for me.
&gt;For an alternative, checkout Handlebars.php. It allows template portability, where that same template can be used with PHP, Javascript, Python, Ruby etc.. This is just about the only benefit a meta-language template engine offers, IMO. Meta-language template engines are mostly comparable to PHP templates with the exception of this one point. Common arguments such as meta-language template engines provide security is moot. First of all, who in their right mind would blindly accept code from an untrusted source? Secondly, even with a "security layer", a template author can wreck a lot of havoc to your site without the need to inject code into PHP. We implement XSS protection into our comment forms for the same reason. 
I would suggest not using static factories so you don't statically couple your code and make it as testable as you can.
I am one of the official contributors, check the project page for full author list. Please go ahead and place on your site. Let me know if you need any help from us.
It looks good! I've just been searching for a symfony based cms!! :) How powerful is the user/role management system?
From the way it started out, I thought this was going to be a Mongo article. Somewhat disappoint.
The _ function is never defined in any of the examples.
Because Blade does 80% of what Twig does, and most of the features are obviously inspired by Twig. It doesn't really add anything: it feels like it's the product of NIH.
No, it's also much clearer and readable.
Think of it this way. When you write code, you need to test that it works. You can either do it once manually, or forever automatically. Writing automatic tests takes more time than refreshing a browser (or typing "php somefile.php" in a console. Ergo, you should just write automatic tests. It bears repeating because it adds motivation :). Does testing become second nature? Yes, it can. I can't imagine writing code without unit tests anymore. It just requires commitment and patience when you're starting out. Believe me, when you write something that demonstrates fewer bugs and never regresses (i.e. breaks backwards compatibility or sees the same bug re-emerge from hibernation), you'll feel damn good about your work. BilgeXA below says testing is coding. He forgot to mention that everything else is prototyping. While there are certainly prototypes that have been hammered on long enough to not break every day, they rely on having hundreds of users wielding a hammer to detect flaws, i.e. they've substituted manual testing on a massive scale for unit tests.
it is readable but not followable.
it is readable but not followable. Do you remember on the 4th line what happened on the first? Because without that you have no context for the next line.
This is funny. However I find the lack of extensibility disturbing (especially for a validation library): https://github.com/noodlehaus/darth/blob/master/darth.php#L30
Hey, I didn't mention Git once (aside from quoting you), I used the term VCS (aka SCM). These aren't tools to sync files, that's just a nice side effect they have, they are basic tools that all programmers use to manage code. Mastering PHP is just a tiny part of the ecosystem that is web development. Please try not to take offence, but a VCS like Git is a basic part of any web development, if you can get there, then you can move on to things like deployment scripts, migrations, CI, etc. 
This made me smile. Have an upvote.
github hook. &gt; I have given up on learning git (WAYY too unintuitive for me ) why? because it uses the command line? If you cant see the beauty of it then you have a problem.
Hello, RedKite does not add nothing to Symfony2 security layer: it just provides an ajax powered interface to handle users and roles at db level. I suppose you read this document http://redkite-labs.com/how-to-secure-redkite-cms, don't you? Please notice that RedKite implements a very basic role hierarchy, so if you need something more complex you must deal with sy2 security file, as explained here: http://redkite-labs.com/how-to-secure-redkite-cms#customizing-the-security-for-your-website Thanks for you reply
&gt; I wish you made the github account a organization though considering you have what looks like a handful of repos for the RedKite CMS Ok, sorry, probably I missed the point. :-) No, I don't activate an organization account: the project is not so advanced to require that kind of account at the moment. Anyway, thank you very much for the info ;-)
Are you familiar with using php to make SQL requests to a database? Are you familiar with databases? This is an essential for most user related dynamic content.
No surprises, same as anything run by a committe really.
Why do you think I left ;-). Nothing's changed. It quieted down for a while, but the same old problems still exist...
I was initially pissed at you for leaving (as you were one of the few pushing php forward) but more and more I'm starting to get it and frankly, this doesn't look well for php's future... Can you imagine what will the PHP 6 "discussion" will look like? :)
Why would they have chosen to do this... &gt; public static function say() -&gt; void instead of this? &gt; public static void function say()
I think big changes like these do need as much discussion as possible. I'm actually happy for the RFC team as they are willing to put so much effort into discussing what changes to make or not make for what reasons, to have PHP be as consistent as possible, so I wouldn't have to.
My guess is that terms preceeding the function name describe that function as used in PHP. Putting it after the function name denotes a hint to the code generator (i.e. nothing to do with PHP). FYI - you can hint to class types and multiple types: http://zephir-lang.com/oop.html#return-type-hints. So the purpose is the separate those two concerns cleanly.
&gt; I think big changes like these do need as much discussion as possible Sure, but out of all the posts in that thread there are maybe a handful that are discussing the feature itself, rest is almost completely bullshit.
&gt; Sure, but out of all the posts in that thread there are maybe a handful that are discussing the feature itself, rest is almost completely bullshit. Who are you to judge that? These guys are taking a huge responsibility. Have some respect. And lots of great features got added to php lately. Isn't them all results of such discussions? So it is not like that the progress of php is blocked or anything. 
its a syntax error!
&gt; Who are you to judge that? These guys are taking a huge responsibility. Have some respect. Judge? Consider getting off your high horse. I have simply stated my own opinion and even encouraged people to form their own opinions (first sentence of the post). Respect? Respect is earned, not given. I don't know if you follow internals regularly, but those who do can tell you that there are *several* toxic people there who *always* do this. I strongly recommend reading Anthony's (ircmaxell) [blog post](http://blog.ircmaxell.com/2013/09/rambling-on-internals.html) about why he left internals. &gt; And lots of great features got added to php lately. Indeed and that's only thanks to a handful of people (mostly u/nikic). You should read the discussions of those RFCs (yes, the ones that got accepted) to see how some of the old timers (not gonna name names) react to every single thing...
Reading the discussion, it seems fairly reasonable. The sole red flag was the "crying" email. The discussion looks noisy because PHP doesn't have a strong typing feature at all and it desperately needs a consistent one to frame additions like this RFC and Generics, etc. if ever added. The lack of framing is what is creating the ad-hoc twists and turns in the discussion. Someone needs to put on their strategy cap. Also worth a smile: https://bugs.php.net/bug.php?id=65162 :)
&gt; Someone needs to put on their strategy cap Indeed and that has come up several times in the past and several people (most notably Rasmus himself) has said they prefer the leaderless, visonless development of PHP. So I'm not too hopeful about that :)
I would take it a step further and replace the switch with a dynamic function call. This is actually pretty useful.
Thank you so much for this! Was a bit complicated as I'm using Vagrant, Nginx and FPM but this led me down the right path to getting it working. Cheers!
Personally I like the way the return type is specified. It's worthwhile to mention that a custom type is surrounded by &lt; and &gt; so putting it at the end is much easier to read as well (especially since Zephir uses php style namespaces)
You can try some of the following: ``` pear install SOAP ``` ``` yum install php-soap ``` ``` apt-get install php-soap ``` Package names for yum/apt might also be `php5*-soap` where * is your minor version.
I understand. Thank you for your hard work though.
I've always wanted to create a PHP framework with an API based 100% on the Star Wars universe. Nobody would be able to figure out what anything does, but it would awesome nonetheless.
Wouldn't it be $person[] ? Personally, I'd love the arrayOf operator, I'd use it. But then when I think more about it, I'd like to see it come as part of a much larger, and optional, strong typing system. 
This one is for beginners who are new to PHP
actually, that discussion is easily one of the better ones. though I gotta say the following is rather hilarious to read. internals, where PHP is this incredibly well designed, logical and consistent language that needs to be saved from dirty user patches. *if we want to have language that makes sense and not just a hodgepodge of random syntax constructs pulled from all over the place and hastily bolted on together - we should not put in any syntaxes that do not make sense in the rest of the language.*
so never?
The code was changed. Originally, in the subclasses the $type parameter was declared as private while the $type in the parent class was protected. The protected declaration on the parent class isn't even necessary (see http://codepad.org/RcEpDtyj ) and it's a quirk on how PHP does protected access that this code works in PHP. 
No internals is worse because it's not committee -- it's a public forum. Literally *anyone* no matter how qualified can post their opinion and like any Internet forum those who disagree post more than those who agree. People who like to argue post more than people who don't. 
The internals list is a public mailing list, it's not limited to the RFC team. If it was, there might be less BS discussion going on. 
I'm not the OP but the underscore method _ is declared here: https://github.com/TimeToogo/HIPSTER-Enums/blob/master/src/Enum/Values.php 
&gt; so never? This. No one will accept a giant "strong typing" patchset. It has to come in smaller pieces so *some* people won't get pissy.
&gt; Facebook completely ignoring the patch &amp; rfc and instead saying I'm not her so obviously I can't speak with full confidence, but I'm pretty sure Sara is speaking as a core PHP maintainer (which she's been for many years, even before FB was around), and not as a mouthpiece for Facebook. Besides, you didn't mention what "Etsy" said, or what "Microsoft" said, or what "PyroCMS" said... so why try and call out this one particular poster? ... I think this post is just trying to stir the pot, and effectively does worse for the entire conversation than the conversation is doing for itself; inside, there's a lot of thought-provoking discourse in the long process of hashing out new functionality for a language which preserves BC and moves slowly, and so you're not going to get a lot of pats on the back and ass-kissing but instead a lot of back &amp; forth as these smart people try and reconcile wishful thinking and implementation for a large number of users... it's not going to be quick or painless. However, this post is flamebait and isn't adding anything constructive at all. 
/r/phphelp
Nice idea. I have a few questions whose answers I was unable to glean from the documentation. * Does it allow for inline C? * Are you restricted to only PHP calls or can you invoke the C runtime? * Can you invoke OS calls? Linux Kernel API/Windows API? Thanks, looks interesting.
Maybe have a look at stackphp http://stackphp.com/ and implement the authentication as a middleware that modifies the request to contain an authentication token, or if not authenticated, handle the challenge / login.
&gt; some of the old timers (not gonna name names) react to every single thing They reply.. nay.. not gonna happen 
What are the techniques to incorporate this?
Can we see your model? Does it work when you try saving a single record? I would also suggest using CakePHP's testing suite and the debug bar plugin for trying to analyse whats going wrong. 
I have to disagree with you. Yes there is a lot of noise, and yes there still are "no one would ever use this" and "too much OOP RFCs" (and I hate that), but the point about generics and how HHVM does this is perfectly valid. If I had the choice between: - full generics and scalar type-hint support (`array&lt;int&gt;`) - `Foo[]` I would definitely choose the first option.
As a fellow validation engineer...I know what nickname I'll be using from now on around the office.
These RFCs, HHVM, and the increasing arguments and suggestions for future features seems to signal the growing pains of PHP as it attempts to capture more legitimacy in the world of programming languages. I'm not slamming PHP by any means, but it still has the reputation of a "kiddie script" language. I think PHP is really trying to break away from that legacy, but in doing so, we're introducing poorly defined functionality. I think the true future of PHP lies in an independent organization (like ISO) drafting and ratifying standards for the language and for many different entities to implement their own version of the PHP interpreter that implements the entirety of the standard. I'd like to see the governance of PHP be somewhat similar to the governance of C++.
I don't mind that you're using it for learning, but it bothers me that people write complete and utter crap like this and then try to showcase it like they've done something special. You haven't. You've written code nobody in their right mind will use, and you shouldn't either.
I definitely do not. HHVM has a lot going for it, but it's not the magic that most people claim it to be...
Generics have nothing to do with this. Scalar Type hints definitely need to be taken care of too, but have nothing to do with this. 
I updated this tutorial to work without NodeJS. Feels much better... :)
Why would anyone need this? Beyond the novelty, it seems like a poor idea to develop in some relatively unsupported language abstraction that provides few features over just using native PHP...
Generics would cover "array of" type-hinting, I don't get why you say that it has nothing to do with it. I agree that it covers a much wider scope, but it would still cover it. If we go with `Foo[]`, what happens then when someone brings up generics? Either the proposal would be refused, either we would end up with `Foo[]` and `array&lt;Foo&gt;` for the same thing, which is not ideal.
What do you think? I'd say it's neat and clean compared to raw PHP, but at the same time horribly superfluous. Not sure if I fancy having another abstraction layer between myself and the machine. Not a big fan of the lambda-esque function notation either.
What if I want to set headers? What if I need to tweak SSL settings? Custom header types? Etc. etc. This is not "perfect", but a perhaps a useful boiler plate if it satisfies your needs. Instead: - https://github.com/rmccue/Requests - http://phphttpclient.com/ - http://docs.guzzlephp.org/en/latest/ 
Posting it as a novelty more than anything else. I'm also rather curious to see what people think about this. CoffeeScript did manage to win a decent following after all, though of course there's a vast difference in context.
The syntax is nearly identical and saves, what, a few key strokes? I don't see how this really makes things better, and now you have to cross compile before you can run the php code? Meh.
hmm this could find a small use in templating.
Yes to all three. See: https://github.com/phalcon/zephir/pull/21
Sweet, thanks.
I didn't like the general tone of you response. things like &gt;"Why add a feature to do this in a nice, neat, logical fashion, when you could just throw loads of code at it?!" You paint your solution as nice, neat and logical while trying to put the alternative as stupid and with out any additional merits (Also, it is not "loads of code", as you put it). When you use a collection, then it is more extensible. You can add high level operation/methods on collections and it becomes available every where. You can also have nice methods like "remove" and "contains" methods on collections to remove an entity and to check if the collection contains a certain entity. Now you may tell that "if you want that, then use collections from the start". But if you can know all thing you might need in the future, the concept of "extensibility" wouldn't have mattered. So the point is using collections, though it uses a tad bit more code, is not without merits. So it is not a black/white situation as you put it. 
Collections and "Array Of" are not at all the same thing. One of them requires you to change how code lives and works outside of the definition, meaning the user needs to know a lot more about what is going on. That is what I mean in that comment. Like people who say "why do you want named params? You could just create a ParamBag with getters and setters and make the implementor play around with that, instead of using a really simplistic syntax" So yeah, one is easier than the other - which is just throwing a POC at the solution instead of syntax.
I was walking through the "first extension" tutorial (http://zephir-lang.com/tutorial.html), and it's giving me errors pretty much off the bat. I was able to get the `Utils\Greeting::say()` method to work fine after compiling the extension and adding it to my php.ini. Then, when I moved on to the `Utils\Filter` section, PHP was crapping out on me with this error: dyld: lazy symbol binding failed: Symbol not found: _zephir_Utils_Filter_init Referenced from: /usr/local/Cellar/php55/5.5.6/lib/php/extensions/no-debug-non-zts-20121212/utils.so Expected in: flat namespace So, I think it's fair to say that they have some work to do yet, but overall it's coming along. What I would really like to see here (after it reaches 1.0 stable) is for them to add Zephir support to PHPStorm. Note: edited for grammar
No, even in legacy code, and **certainly 5-7 years ago**, there were still loops, queues, etc. The only excuse for this pattern is lack of experience/knowledge on the part of the programmer.
Generics do not just live inside the method declaration, they require setup too. This imposes more learning on the user, who then has to work out what the hell generics are and how to use them - which does not seem particularly fair or useful. Also from an internal point of view, it's a separate topic because of what it will take to implement generics. It just cannot be done sanely right now. Java has both. PHP could easily have both. But jumping right on the "fuck it lets just do generics" train is not helpful. :)
&gt; &gt; 1. Rasums hates them Am sorry, does Rasmus vote count as 100 instead of 1
Actually his vote counts for about 6 as far as I know. I've spoken to several people who just vote whatever he votes. This last happened in the getter/setter vote. :-/ I actually thought I'd have a go at using two of the most popular arguments for blocking useful interesting features that others like to use. As I said, I personally don't care much about generics. They could be cool, and I know a few people really want them, so great. They can do that, but with there already being a strong "against" group it wont exactly be easy to do. That's the extend of the relevancy of that quote. I'm not suggesting he has a vito-hammer, but he does obviously have some sway. 
This is definitely an improvement. However, I noticed that there still many listings with almost no further explanation or documentation. The tutorial just tells me where to save this file.
&gt; I expect the vote to fail; not because the feature is bad, but because bitter $people[] that didn't get their way will vote against it The OP seems to have missed the point that there are very real concerns about the O(n) nature of the `arrayof` implementation. Internals people aren't just being mean for the sake of being mean. It does no one any favors to adopt an implementation that will be viewed as a serious language WTF a couple of years down the road. There's much more at play here than the convenience of saving a couple of lines of code. This perception that internals is somehow just a bunch of mean people out to ruin the fun for everyone trying write OOP code is seriously misguided and no less harmful to the community than someone trampling feelings on a mailing list.
http://www.youtube.com/watch?v=nJQkQdfruGE
Sorry I misunderstood. The _ function is defined in the trait \Enum\Values. You can see the supplied link given above. 
I'm explaining **to** the sockets code.
&gt; This last happened in the getter/setter vote. :-/ That was something i missed from C# :-P and is there any way to force user(during voting for an rfc) to state his/her reason (as a comment) on why they voted no for a feature.
[PHPSysInfo](http://rk4an.github.io/phpsysinfo/)
How much did you copy and paste? The second implementation of the filter class in that tutorial is missing the namespace declaration before the class.
Sure. Even fourteen years ago, when PHP 4 was around, there was some degree of object-orientation, but that doesn't mean it was widely adopted or even widely accepted as a standard. Just because there are other ways of doing something - even superior ways of doing something - doesn't mean that way is necessarily the most commonly adopted way. The tutorials and teachers of the day hold a lot of sway over coding standards, and if they're still preaching procedural code, then that's what people are going to churn out. Besides, I fail to see how loops or queues are going to help here? You can't reliably dynamically loop through the POST array and apply some arbitrary validation to it - each field is necessarily different, and thus requires different validation. Sure, the fact that here that isn't being done very well is the butt of the joke, but the point stands because what validation there is differs from field to field. Moreover, trying to mass-validate is lazy at best, and that's not great standards-wise, either. If you loop through $_POST, and someone injects some data, then you're parsing that as well, which is a real bad idea. I take your point that there were better methods back then, but I've written code like the above before, when I first started out, and that was five years ago. That code was more or less how I was shown to do it, and to be quite honest, whilst being inextensible and difficult to maintain, works. Now, we can argue principles and best-practice all day long, but there's no substitute for getting the job done and getting paid. If it's secure, and it works okay, then get it done. It's not going to implode, preventing you from refactoring it later. Sure, I'd love to write perfect code all of the time, but human error occurs and the bill payer is often impatient. I'll never cut corners with security, but if I have to fit more stuff into a class than I'd like, or the database structure could be a bit better, or I forget to comment that method to let you know what it does, well, hey, sometimes it happens. It's all fixable in time, and of course the OP was poking fun at the silly stuff we did in years gone by (or at least I hope this is years gone by, or a very new developer to PHP). I don't wanna get neck-deep in arguing standards, because what's the point? I'm gonna write the best code I can at any given moment in time and sure - sometimes it'll be terrible. Because humans.
OK, interesting, but it's always a good idea to learn C if you need to write an extension. It's not that difficult.
[ThinkUp](https://github.com/ginatrapani/ThinkUp)
Huge fan of Gina Trapani, former editor of Lifehacker. I think honestly since she left that site has seriously declined in terms of quality. But I'll give this script a try :)
after the first death by force-choke, nobody questioned Darth Jekiah again.
SabreDAV could be REALLY useful for you. http://code.google.com/p/sabredav/
Look at setting up a [grunt task](http://gruntjs.com) for deployment. It also provides tuns of fun things. You can lint your code and process your CSS/JS with ease. Even live compile and insert your CSS with watchers while you develop.
Does this require I have a mail server setup? I think it does because the activation never gets sent. So duh :) I'll have to set one up.
Sorry if I offended you there. I just meant that coding like this so quickly becomes spaghetti-code that I assumed that experience of maintaining code would quickly cause something like this to be refactored into a readable and extendable system. OOP isn't required in order to re-organize this into more readable systems. Even 20-something years ago, writing C, with this many tests I would set up a loop through a list of variables to be validated, with a data structure to point each variable to it's relevant validation function, and pushing error messages onto a stack or into an array. Of course, this kind of coding happens either through inexpeirience, or through overly tight estimates which force people to leave in chaos like this (happens to us all). 
No, but it has been suggested.
They do but only up to a certain limit then it's super steep prices. 
Learning C is a far steeper climb than learning Zephir. If Zephir actually works (and so far it does) than there's little point in learning C just to write a PHP extension. Then, on top of C, you also need to learn all the macros and internals to get an extension booted up properly. Why incur those costs if they could be avoided?
It implements WebDAV and CalDav, which you can use with common apps (email apps, calendar apps, operating systems) to manage your own personal cloud server. WebDAV is a standard for managing and synchronizing remote folders via web, so you can have a personal dropbox-like service acessible via any browser and mountable in any modern operating system natively. CalDAV provides the same remote managing features for calendar and events and it is also widely spread.
 if ( newAccountSuccess() ) { [DllImport("winmm.dll")] static extern Int32 mciSendString(String command, StringBuilder buffer, Int32 bufferSize, IntPtr hwndCallback); // To open the door mciSendString("set CDAudio door open", null, 0, IntPtr.Zero); // To close the door mciSendString("set CDAudio door closed", null, 0, IntPtr.Zero); } PARTY HATS! ^^I ^^am ^^not ^^a ^^c ^^developer
Oh I've got no affiliation with this project at all nor am I trying to promote it. 
wow wow wow........ (a better php) :-) http://zephir-lang.com/ 
It depends on which package manager you use or even OS, I believe.
Just because it's written in PHP does not mean it belongs in /r/PHP.
One of the benefits of PHP comments is they are not rendered to HTML sent to the browser. So if somebody clicks "View Source" they won't see your "// Not sure what this does" type comments.
Depends on if you want the comments to appear in the HTML source. If you want the comments to appear in the source, you would obviously have to switch to HTML comments. 
Bingo! Exactly why we made this.
Sorry about that. Posted it here since this is the community that would find it useful -- that it's built with Laravel is more of an aside.
that's one good benefit I noticed opposed to using html comments :) for example I'll have something like &lt;?php //Echos test ?&gt; &lt;?php function myfunction(){ echo "test"; } ?&gt; Is this a bad way of doing it? I like it this way because it keeps the comment structure more consistent
I won't say you need to learn C, but it would be very helpful. I'm one of those anal people that like to know how things work under the hood and feel that it helps you make better choices when designing something in PHP or any other language for that matter. 
Fair enough. Oh, one other thing I was going to mention; you say you're using string concatenation for SQL? I'd use PDO for a quickly-hacked project, and still create very simple Model classes. Mostly just wrappers around some SQL calls, but with proper bound parameters. 
 &lt;?php function myFunction() { // does some stuff echo "test"; } ?&gt; 
Knowing c will definitely help when using Zephir. Zephir is like an intermediate language between your brain and the C code needed to write an extension.
Of course I use prepared statements. But for example: public function getBooks($user_id = null){ $sql = 'SELECT * FROM books'; $binds = array(); if($user_id !== null){ $sql .= ' WHERE user_id = ?'; $binds[] = $user_id; } return $this-&gt;query($sql, $binds); }
the only reason I didn't do that was because sometimes I have a bit of long comments and it ends up wrapping. also it's not as consistent when I also use some comments with html blocks. so it would look like &lt;?php //a function to echo hello world! ?&gt; &lt;?php function myfunction(){ echo "hello world!"; } ?&gt; &lt;?php //display a link with dynamic image etc etc ?&gt; &lt;a href="http://google.com&gt;&lt;img src=" . &lt;?php echo $image_url; ?&gt; . "&gt;&lt;/a&gt; opposed to &lt;?php function myfunction(){ // a function to echo hello world! echo "hello world!"; } ?&gt; &lt;?php //display a link with dynamic image etc etc ?&gt; &lt;a href="http://google.com&gt;&lt;img src=" . &lt;?php echo $image_url; ?&gt; . "&gt;&lt;/a&gt; is there any significant difference or is it just down to personal taste?
Nah, no functional difference - whatever you prefer.
&gt;One of them requires you to change how code lives and works outside of the definition, meaning the user needs to know a lot more about what is going on. Lot more? All one needs to know is that you can add an object to collection using the add($object) method. Instead of $users = []; $users[] = $user; you have to write $users = new \Collections\UserCollection; $users-&gt;add($user); Is that more code? Yes, but not a lot. Does the additional code hold additional value. Yes, a lot compared to the amount of extra code. Another thing I dont like is that having this without allowing user to create typed arrays, I mean something like $users = \Entities\User[]; is an instance of leaky abstraction and a hack. I think the proper way to do this would be to enable creation of typed arrays, and use it along the type hinting in place to handle this use case. In that way, I think implementing 'arrayof' will be like taking a step back, to php's hacky roots. 
Roll your own. PHP is a great framework in itself if used properly. My small projects consist of a singleton router and a few classes i homebrew. Also, use PHP as your templating engine. 
For templating, consider either [Twig](http://twig.sensiolabs.org/), or if you're interested in straight PHP templates, try [Plates](http://platesphp.com/). Full disclosure, I wrote Plates.
This is awesome and i might find a use for just for kicks.
They like to say there are no stupid questions, but you've defied all the odds and done it.
See how all of the other comments in this thread are helpful to some degree? Conducive to learning and growing the OP's knowledge of PHP? Try that, and you'll get my upvote.
klein/klein - cool thing, thanks :) pimple/pimple - same doctrine/dbal - imho worst SQL builder I've seen during last couple of days :( too verbose, too much API, too much configuration and too much typing. either I don't understand something or it is indeed a really bad choice. I've seen [Idiorm](https://github.com/j4mie/idiorm) which looked much better even with less functionality twig/twig - has some nice feature, but I still prefer plain PHP for templating respect/validation - definitely not a thing that I would use. couldn't find in its doc or source how to set error message per rule, not per validator and having a ton of v::key() didn't inspire me either. it would be ok to test scalar values, but its hard to imagine such case, I liked [Vlad](https://github.com/gajus/vlad) 
Why get rid of $ in front of variables, only to add them to function calls?
Klein is awesome, but trying to get Eloquent into project drags in almost whole Laravel, so not exactly a good idea if you want to keep project lightweight.
Rolling my own requires time for initial development and testing, later it'll require time for maintance. I bet there are things that already do what I need and they're maintained, well tested and somewhere at packagist :) I had a thought to make up my own bike with square wheels but in the end I don't want another microframework/bunch of own libraries, I want to concentrate on my application.
There's also a library that allows you to use slim and Laravel's "ORM".
Your case is super simple: * no front controller, only one endpoint * super small amount of DB interaction from app (basically you just push everything into UDF and parse results) * no user input (only SOAP stuff) if you wouldn't say about payload validation and test suite I would say that's a "hello world" level app. it is just a transport between a UDF and SOAP.
it is "micro" enough to neglect "framework" :)
I've seen PHPActiveRecord, but its development pace and ammount of issues are alarming. I understand thats not a reason to don't try it out, but still I keep it last on the queue. 
as I wrote below Laravel's ORM "Eloquent" is very heavy, adding it to the project = adding half of Laravel
&gt; What is the name of the collection? Not an issue, as it can be inferred from the type hint in the function definition. If you are using an IDE, i think it will tell you the name of collection it expects. Right? You can argue that a collection needs to be initiated long before the point of the function call. Well, I guess one is expected to know what he intends to do with a collection at the point one decides to create one. &gt; Is it add() or push() push? I don't think anyone would think of 'push' outside the context of a stack. Here too, I think IDE can help. &gt; And typed arrays would be lovely one day, but that is still not a replacement for this functionality. So...? :) Let us assume that day will come. And when that day comes, I think 'arrayof' will stick out like a sore thumb. We cannot remove it, because of chance of breaking BC. And it will just be a redundant hack that we will need to remind people not to use when there are better options (at that time).
Honestly, if I'm going to build something without a framework, I don't use any external libraries until a need comes up for one. I will use various extensions that are packaged with PHP, however. The first thing that stood out to me in your post is that you're looking for a *framework* way of handling routing, filtering and validation, and ORM. Stop right there! You don't need routing, exactly. You don't need a library to handle filtering and validation for you, and you definitely don't need ORM. Get back to the basics. You want to work in a world without frameworks, so get into that mentality. **Routing** Create a single script that all non-resource (scripts, images, stylesheets, etc) requests filter through. In this script, match for whatever URL patterns you need, instantiate your classes, and call the methods you need. If this is truly a small site (maybe just a couple pages), you don't even need this! Configure your server to execute files in a particular path with PHP, and handle your page rendering logic in those files. Keep security in mind, however. Don't allow uploads to this same directory, for example. If you're up for the challenge, write your own class autoloader too! **Data filtering and validation** Easy: http://us2.php.net/filter filter_var("example@example.org", FILTER_VALIDATE_EMAIL); http://us3.php.net/preg_replace $string= preg_replace('/[^a-zA-Z0-9 _-]/', '', $_GET['string']); http://us2.php.net/pdo.prepared-statements **SQL builder** You can safely roll your own SQL queries. You can even use parameterized queries (see link above) when you need to inject values into your queries! This is a great opportunity to become extremely familiar with SQL, how to write efficient queries, and how to design reasonable normalized tables. **Templating** Just use PHP. There's nothing wrong with this example. &lt;span&gt;&lt;?=$name?&gt;&lt;/span&gt; &lt;ul&gt; &lt;? foreach($list as $item) { ?&gt; &lt;li&gt;&lt;?=$item?&gt;&lt;/li&gt; &lt;? } ?&gt; &lt;/ul&gt; When it comes to not using frameworks, F the libraries that exist unless you have specific needs.
Great work on Plates - sensible stuff there, aligns well with my way of thinking about "PHP as the template language". 
It's funny that you said you're "one of those anal people" and your name is Coffee Enemas. I lol'd
I haven't used it, but I recently attended a session on Aura. It's a bunch of components that are completely separate. You could theoretically arrange them into a framework, but each one is stand alone. They have a package for each of your use cases. I don't know how easy it is, but you should check it out: http://auraphp.com/packages/
Can I ask a dumb downvote-bait question? &gt; frameworks look like a canon used against a flee What does this actually mean? I mean, ignoring the typo on both *cannon* and *flea*, in what way is it "too much"? You want a router with a front controller? Laravel gives you that. You want an SQL builder or ORM? Laravel gives you that. You want a templating engine? Laravel gives you that. You want validation? Laravel gives you that. What I don't get is at what point this utility suddenly becomes a **burden**? It seems to me that frameworks like Laravel, especially when used with generators and migrations, are a **faster and easier** way to build. This is particularly in the case of small applications with basic crud functionality. I find that for me, creating a new laravel app, adding the Way Generators, thinking through and scaffolding out my core models and generating models and seeds for the rest... this to me is a highly efficient way to hit the ground running. I don't understand why this is "too much". I'm not trolling here, I'm genuinely confused. I understand that a framework isn't appropriate for all projects. What I don't understand is the actual problem here.
Mixing logic with html. :facepalm:
PHP is not a templating engine. It's a language. God I hate this fucking point. People keep bringing it up. You can use PHP syntax in an actual templating engine, that's fine, but the engine has an actual job to do in MVC terms. 
Take some deep breaths there Internet stranger. PHP is a HTML embedded scripting language. What is a template?
I think this post gave me cancer. I'll need to go to a doctor and get checked for sure, but... there's a definite lump that wasn't there before. I couldn't find a single bit of advice in here that I think is good. I was just going to leave it at that, but let's break this down instead: &gt; Honestly, if I'm going to build something without a framework, I don't use any external libraries until a need comes up for one. I will use various extensions that are packaged with PHP, however. Well obviously. You're not going to just install 12 different libraries that offer features you're not using. Helpful bit of advice. &gt; Stop right there! You don't need routing, exactly. You don't need a library to handle filtering and validation for you, and you definitely don't need ORM. Get back to the basics. You want to work in a world without frameworks, so get into that mentality. Sorry, but IMO that mentality is retarded. The best way to get into that mentality is to fall on your head. Try to hit the corner of a coffee table on the way down. This whole YOLO NO FRAMEWORKS BRO! bullshit happening on this particular thread is bizarre to me, and seems to be an enthusiastic embrace of a style of cowboy programming we have been trying to grow out of. No unit testing. No discipline. Copypasta coding. This is not the work of professionals. Put on your big boy pants and use a goddamn framework like a grown up. And get off my lawn. &gt; Configure your server to execute files in a particular path with PHP, and handle your page rendering logic in those files. Keep security in mind, however. Don't allow uploads to this same directory, for example. It's cool. In two years there's no way you'll have left the company and someone else will have to manage this crazy shit. This is a maintenance nightmare. You know that horrible script you had to manage at your last job that just grew and grew and no one was really sure what it did? This is its seed. This is how it started. This is the fetus of a terrible project. And I say look at it now and **abort, abort, abort**. &gt; $string= preg_replace('/[^a-zA-Z0-9 _-]/', '', $_GET['string']); What?! I think I just through up in my mouth a little. What is this supposed to be doing? Oh, right, it's taking the first "bit" of the url. Why the hell would you not just use a routing... oh yeah, that's right... we're cowboys! YEEEEHAAAW! &gt; You can safely roll your own SQL queries. You can even use parameterized queries (see link above) when you need to inject values into your queries! This is a great opportunity to become extremely familiar with SQL, how to write efficient queries, and how to design reasonable normalized tables. Yes. You can. And you can create a giant bundle of horribly unmaintainable SQL for someone else to look after! Weeeee. SQL is a bitch to manage in a project that gets large. And let's not always assume a small project stays small. They don't. They grow and spread. Like the cancer you gave me. An ORM is a better option. I know. I know we're being cowboys and cowboys don't care about maintainability and not creating someone else's future WTF... YYYYEEEEEEEE HAAAAAWWWWWW! I'M GONNA ROPE ME A STEER! &gt; Just use PHP. NO. JUST NO. NO NO BNO NONONONOHNLNBLONLNONLNLNLNOKNONON No. This is... No. Stop it. There are two issues here. One is what does a templating engine do, what is its function. The other is what syntax does it use. Too many people are conflating those questions and saying "just use PHP! It's a templating engine!". I'm pretty sure those people collected the coffee table on the way down. Right on a corner. The fact is that while PHP is an **entirely reasonable and valid syntax to use within a templating engine**, and one supported by the likes of Laravel's Blade and presumably others, there is a point to using an **actual** templating engine. This point is that it lets you separate out your display logic and your code. A good templating engine provides a separate scope for the view, and will allow inherited and nested templates for terser and more efficient code. This is **regardless** of its syntax. A templating engine can use PHP. PHP is not a templating engine. 
Nope. You don't get out of it by just trying to dodge definitions. What is the **purpose** of a templating engine? It's not just syntax. PHP is the syntax, it can be the syntax, that is not the issue. The point of a templating engine is to be the "v" in MVC, to provide a separate scope and handling of the view portion of your application. PHP isn't that. It can be implemented in PHP. It can use PHP syntax. But "php = templates" is simplistic and in my opinion flatly wrong.
&gt; Well, I guess one is expected to know what he intends to do with a collection at the point one decides to create one. Yeah so as I said you are assuming that the person creating the collection is the same person who created the method that is type-hinting for the collection. They won't always be. &gt; push? I don't think anyone would think of 'push' outside the context of a stack. I've seen both. &gt; Let us assume that day will come. And when that day comes, I think 'arrayof' will stick out like a sore thumb. Java has both. They're different things, so who cares if both are around? There are three ways to do the same thing. You are supporting two of them, and both of those two require items to be set up before it is passed to the method. Only one of them will work without forcing extra knowledge on the implementor, which is clearly a benefit in many situations. I'm not asking you to say "Thanks Phil, I have realized the error of my ways and I should never use Collections!", but I am hoping you can say "I now understand the difference and concede that there are use-cases for both." Because there are.
Why are nested statements bad particularly, what about them breaks the program or makes it run worse?
Literally anyone case post on there. Me, you, anyone. Take from that what you will.
/u/mattaugamer, did you miss the part where /u/thenaquad was asking for advice on components he/she could use to develop applications without a framework?
This is confusing me a little bit. So crypt() outputs the salt, and then the encrypted salt+password combo, as a string, which I store. But then how does it know where the salt ends and the bit I want to check begins?
Yea. Apparently I made a wrong assumption. Apologies everyone!
I'd try not to use PHP, maybe try out angular/node/mongo or something. I mean if you want to crank something production ready out then a framework you know is obviously the best route, if not, then I think really getting out of your comfort zone are what it's all about.
Hold on, let's take a step back, shall we? Why do you have functions in your template, and what do you use them for? Templates are only supposed to contain presentational logic, but it sounds to me like you're mixing presentation with business logic. You shouldn't normally need to have any functions in your template unless you're doing something to do with recursion.
I always thought the same of Coffeescript, to be honest. I never saw the advantage. Still don't.
It depends -- what are you trying to accomplish? A little bit bigger than, "Hello, Internetzz!," doesn't tell me much as that's very subjective. To me, I would assume that you just want to create static HTML with maybe some CSS; however, since you're looking into routers, data validation, and SQL, it's safe to say you're looking for something that's more complex than something that's "a little bit bigger than just echo." If that's the case, just bite the bullet and get a framework. If you're concerned about memory and computational cost, the PHP layer is cheap in the grand scheme of things since your biggest bottleneck is request to your SQL server. Laravel, Symfony, and CakePHP are fairly lightweight. There's no reason to reinvent the wheel.
Whoops. Not sure why I put functions in there. Didn't really think it through when I typed up an example. However I do have if statements. Is that bad practice? For example I have an html template for a WordPress short code I created. Depending on if a certain attribute is passed, certain html elements are displayed using if statements.
&gt; I'm not her so obviously I can't speak with full confidence, but I'm pretty sure Sara is speaking as a core PHP maintainer (which she's been for many years, even before FB was around), and not as a mouthpiece for Facebook. &gt; &gt; Besides, you didn't mention what "Etsy" said, or what "Microsoft" said, or what "PyroCMS" said... so why try and call out this one particular poster? I never accused anyone of being a mouthpiece. However, unlike those other companies you mentioned Facebook (the company, not the developer posting on internals) has an interest in pushing a non-default implementation of PHP. And when someone who works for Facebook doesn't even comment on the RFC itself and proposes something else from their implementation, it leaves a bad taste. But maybe that's just me, and that's fine. &gt; However, this post is flamebait and isn't adding anything constructive at all. If I was going for flaimbait with this, don't you think I would post it on internals? Also, all the bullet points I've mentioned *do exist* on the ML thread. I'm not lying or deceiving anyone. Just look at that thread and point out a single item where I was wrong. &gt; there's a lot of thought-provoking discourse in the long process of hashing out new functionality for a language which preserves BC and moves slowly, and so you're not going to get a lot of pats on the back and ass-kissing but instead a lot of back &amp; forth as these smart people try and reconcile wishful thinking Which is fine. But it is out of scope for *this* RFC.
Typo fixed. Sorry for making you read my English. Now about Laravel: I don't want 80+ megabytes deployment, but Laravel gives me that (and prefer-dist doesn't help), Laravels has its own issues (read P.S.), Laravel has its own way of doing things and indeed you'll have to add something like Way Generators, Ardent and etc... So you end up with lots and lots of stuff. You don't use Java for "hello world", so you don't use Laravel for small sized projects like RESTful interface to 3 tables in DB with complex queries and authentication. The actual problem is related to first of all size and amount of abstractions one needs for dead simple project. One of the problems why I'm not using some particular framework is quiet simple: I plan to delegate this project later. I don't want to start README.txt with something like "1. Learn Laravel 4.". According to input I've presented above everything is not just simple, but super simple. I don't want to reinvent my own bike. One can say that grabbing a bunch of libraries and wiring them all together is basically the same as reinventing own framework, but this is wrong because unlike framework like Laravel, Yii, RoR or whatever you can think of I don't add here any "right way to do things" or any conventions that must be strictly adhered in order to get things done. Also because those are libraries I write my glue where I can do anything I want and write whatever I want, w/o thinking too much is that the right way and will that break something? Summary key difference: framework calls your code while you call libraries. P.S. A bit offtopic IMHO about Laravel: I didn't like when Laravel 4 dragged in Symfony2 components, Laravel 3 was the right direction: small, efficient, easy to read and understand. Now figuring out stuff became a problem because you need to dig through Illumiate component down to some Symfony component and only then figure out how the hell does it all play together, thats apart from size. For trivial things this is not needed, documentation is more than enough. For something more complex when you need to modify the way some component works you'll have to do that and it won't be easy. And one particular thing that kills me in Laravel 4: validation. Validation is incomplete in Laravel 4. There were numerous discussion on this subject and they all boil down to 3 ways: use Ardent which is a classy model handling validation, do filtering and validation in actions and making a separate service that'll handle validation. First way is wrong because it doesn't allow you to add sane authorization and get some request-related info in general: you don't access controller data (user session, current user) from model, even if you do that you'll break SOLID (priciple #1 separation of concerns) and your code will be considered an ugly hack. Second way is wrong by definition because in the end data can go to DB not just from actions but from some background/scheduled jobs, separate interface reusing models (CLI interface). Third way is correct: there should be a service which is a gate between entities and everything else. The Repository pattern implementation. But Laravel doesn't implement it. So in the end framework that claims to solve all your problems with routine stuff makes you reinvent one of the most vital parts: the thing that actually should validate, sanitize and populate your data. This functionality is a **must**, its not a part that should be dragged from plugins it must be a core functionality.
No, I didn't. I even upvoted your response. Did you see the part where I questioned his decision not to use a framework as well? I'm sorry you're offended that I stayed on-topic with his question. My answer was not intended to provide guidance on how to develop PHP applications. It was intended to answer his question. Reddiquette requests that users not **be (intentionally) rude at all**. What did your response contribute to the discussion other than a vile portrayal of your opinion? Your way, my way, or any other person's way of doing anything is not 100% accurate in all circumstances. You could learn a bit of civility and and how to relay your two cents in a friendlier manner.
What I'm doing is a RESTful service that is a gate between RIA and DB. It is responsible for sanitization, validation and authentication. Indeed I can use a framework, but after all cannon and flea and all that stuff... In the end I can always do it with a framework, I'm trying to figure out how to do that w/o it.
[Mean](http://mean.io/) stack is awesome, still I'm giving PHP a try. Plus Node.js is still bad at working with SQL databases. I won't install MongoDB just for one app that doesn't need MapReduce or any kind of benefit that NoSQL and particularly MongoDB provides.
What you're suggesting is using "vanilla" PHP. This works for "hello world", but add here database and you get constant code repetition and issues with scaling. Plain SQL is a pain because 1) it is so f*** ugly to build them via string concatenation (and thats your only option with vanilla PHP) 2) figuring out in a month or two what the hell did you mean by that is a huge a problem. I agree about templating, separate scope to don't mix with actual business logic is enough and you can do templating in PHP.
I wish loose-typing would just die as a paradigm. I enjoy my strongly-typed languages so much better because the behavior is always well defined and predictable...
Very interesting thing! Thank you! Looks that it fits even better than everything else. Full stack frameworks are adding some overhead indeed, but my main problem is that they add such thing as "the right way" and whenever you need or do something not following that way things are getting hardcore. Framework doesn't help you but works against you.
Doesn't matter what versioning software you use, just use something (that is hopefully secure). Learning GIT doesn't hurt as most of its competitors have wrappers for it (SVN and Perforce come to mind). Plus, most open source deployment tools have GIT support. When I develop in Windows, my IDE of choice is Eclipse, which has GIT support (can't remember if you have to install the plugin or not, it was long ago). BTW, I highly recommend Jenkins for continuous integration/source deployment as it can run ANT and Maven scripts, which are just XML, which will handle all the things like DB import, CSS &amp; JS minification, and launching other init scripts.
Well, I have some time to think about it. Writing whole my app with Laravel or Yii won't take longer than 2-3 hours, so I have time to think about other ways. About inventing my own framework: see my respone to u/mattaugamer .
I suppose I could have gone more in-depth. If I were doing this, I'd end up writing my own library to handle the SQL pieces for me, as well as the filtering and validation, and routing. In general, I'd also follow the common OOP design patterns to structure the application. This way, separation of concerns is still a thing, and newcomers would be able to get the gist of the architecture. The same goes for using PHP as a templating language. Despite /u/mattaugamer's opinion on the matter, you don't need a templating library or a new templating syntax to separate the views from the rest of the application. I think this is what you meant by "separate scope to don't mix with actual business logic." :) Anyway, yes, this is "vanilla" PHP, but it is certainly possible to structure it in a way that is manageable and maintainable. In the end, you would likely end up with your own framework and sets of libraries. I suppose your decision depends on your ultimate end goal. Do you want to make a framework from libraries that already exist, or do you want to build from the ground up?
Like I said, just do it. Besides, you don't want to reinvent the wheel when it comes to authentication, data validation, and other security issues. Whatever framework you choose (assuming it's up-to-date) will have all that right out of the box. Rewriting security code is a guarantee you'll have exploits.
I'm not sure why you would need comments in a template. The presentational logic is supposed to be simple. If you have something like this: &lt;?php if (something): ?&gt; stuff here &lt;?php endif; ?&gt; Then surely you should be able to gauge the meaning from that alone, yes? You're not supposed to comment every line of code in your code base, you're supposed to comment when something is unclear and need explanation. 
I write Titon in my free time. Mainly small lightweight extensible libraries for specific features. https://github.com/titon http://titon.io
Suppose we add 'arrayof' format now, and lots of code gets written using getDocumentsForUser(User[] $users) syntax. These functions are being passed array() of User entities. No say, in some future version of php, we want to add typed arrays. So what signature can we use to indicate an real typed array of Users? Do you think we can use the same getDocumentsForUsers(Users[] $users)? But wont that break existing code, because it is being passed normal arrays now. So we will have to use some way to differentiate a typed array of Users from arrayof Users. So it appears to me that we will have to support two different forms of type hinting when we start supporting typed arrays, which does not look too good to me. 
Anything that can plug-in data into a view file is technically a templating engine, regardless of what syntax it uses. PHP is one of them, as this is the most basic purpose of PHP for web development. What will be missing though is being able to have constraints/restrictions from within the templates (so designers don't need to know PHP, and can just learn a different syntax/subset). Anything that lets you cleanly implement V in MVC should qualify.
Blogspam.
Right on, looking at projects in C# or Java really expose you to a lot of these patterns. Factories are awesome when you have a bunch of stuff todo in order to create your object, and like mentioned, Abstract Factories take it a step further. E.g., A car factory might be an abstract factory where it relies on an separate factory for created the engine, tires, doors, etc Generally speaking a factory usually follows the same steps or path and delivers a finished product. Factories are -excellent- to use with DiC containers and service locators where they can be aliased and created lazily. Also a fun semi-similar pattern is the Builder pattern. Where the creation of your object might take some parameters that can be conditional or an aggregate. Builders are great when you need to pass object creation to something else and may not have a complete thing. Builders are amazing when you've got an event system and you want to create something based on other things happening. Contrived example, go! $builder = HermanMillerChair::builder() -&gt;addUpgrade(AdjustableArm::factory($user-&gt;getHeight())); $statsService-&gt;trackAdjustableArmUpgrades($builder); if ($sexyRollers) { $builder-&gt;addUpgrade(new SexyRollers()); } $chair = $builder-&gt;build();
I don't know what you all are doing, but either a completely bare PHP script with maybe a pear lib or two, or a full on zend framework 2 application will fit my needs. If I'm not doing a quick one-off, then building something in ZF2 is not that much more effort that doing something in some slim framework. Have any of you even used ZF2? It has plenty of tools to do most of the boilerplate for you. You can have an app up and running in 5 minutes using zf tool, and then build whatever plain PHP you want on top of it routing through a web or command line request.
+1 for Aura. There are a lot of well written, well tested packages there.
Can you please elaborate on your thoughts on Doctrine?
I use it for a router and nothing else. Same as one would use just the Hash class from CakePHP for data retrieval.
I'm surprised nobody mentioned [Flourish](http://flourishlib.com/). It's pretty useful when you don't use a framework.
For basic validation I use https://github.com/noodlehaus/darth edit for clarification: For basic validation I began toying with the darth validator when a colleague linked me to it on github (probably after it was linked on this subreddit a few days ago) since then I have included it in some simple projects and it works well for what I wanted - which was a simple input validator, with no bells or whistles. In hind sight my response should have been more along the lines of "For basic validation I would suggest you look at https://github.com/noodlehaus/darth as an example of something that is incredibly bare-bones but works just as well for basic needs as the more complex validaton libs)
I don't believe complexity is the issue. An organization provides grouping. All your red kite repos would belong to the organization.
So ... Silex.
My answer doesn't just relate to Laravel here, but any popular framework. You claim that you don't want people to have to learn Laravel when you delegate the project later, but chances are anyone you delegate it to should already have a fair understanding of working with MVC frameworks. Using a (well known) framework means you get a lot of shared knowledge and a lot of productivity. How exactly is "learn laravel" different to "learn this roll-your-own stuff I just wrote". You are more likely to find someone who knows laravel than knows your own idiosyncratic code. As for deployment size... 80mb. You are worried about this because it is 1990 and storage is at a premium, right? 
&gt;I plan to delegate this project later. So use a popular framework that others already have knowledge with? You are never going to find a guy who has experience with the framework you developed, but you will find people who have experience in Laravel (or any other popular framework).
Although people already said about idiorm, i must say it again. It's pretty awesome for smaller projects as a nice general wrapper.
&gt; doctrine/dbal - imho worst SQL builder I've seen during last couple of days :( too verbose, too much API, too much configuration and too much typing. You should check out [RedbeanPHP](http://www.redbeanphp.com/), it's also available as a composer package I think. For the situation you're talking about, where you want to get a small project up and running, it's streets ahead of anything I've found. Personally I use it for larger projects too - using it's "ORM" rapid prototyping stuff while building the project, then swapping out the ORM-style queries for raw sql when the project's finished / if I need better performance (which is really easy to do with redbean, and continue using the same models.)
Amazon's PHP SDK has a nice, simple, ENUM implementation. https://github.com/aws/aws-sdk-php/blob/master/src/Aws/Common/Enum.php https://github.com/aws/aws-sdk-php/blob/master/src/Aws/Common/Enum/DateFormat.php
Here is my version of a cherry picked package framework you can use for inspiration https://github.com/sinergi/sinergi Basically, with Composer being the standard nowadays, I don't think I'll ever need a full featured framework anymore. I like the approach of choosing and collaborating to specific packages better.
Name spacing.
https://github.com/mikeemoo/ColorJizz-PHP
Its a namespace thing, means $e will be PHPs built in exception class. http://www.php.net/manual/en/language.namespaces.php
[Here are some answers.](http://lmgtfy.com/?q=php+What+does+putting+a+backslash+in+front+of+a+variable+mean%3F)
It's funny, because when I googled it all I got was things about escaping special characters, stripslashes, addslashes, and stack overflow questions about using them for quotes. Thanks, anyway, though.
For the love of everything right, please hope that PHP never implements the Java-style generic programming model. It's horrible in my opinion because it's just cheap type-casting. I enjoy C++'s model for generic programming much more. It makes more sense to clone objects from patterns, than type casting a generic data type. It also ensures some sort of type-safety to use the C++ model as well.
The [ImagickPixel](http://br2.php.net/manual/en/class.imagickpixel.php) class is probably the best choice, once you have imagick installed (which is pretty common). You can use setHSL and getHSL to change the saturation as you want. Working with images and pixels is also straightforward: http://valokuva.org/imagickpixeliterator-is-not-read-only-after-all/
I'm not too fussed which way it goes, as I literally don't care about generics. I just want the proposed feature to avoid getting utterly battered just so we can have some generics-like syntax in the short term, or full-on generics later.
The talk is of adding Generics, which - correct me if I am wrong - are basically typed arrays. There is the proposed HHVM style generic syntax, and the current simple Foo[] syntax, both of which are different, but the two do not have to be different. What this "array of" proposes is considered a weak form of generics, and in languages like C# they are the same syntax. Even a collection is the same syntax. http://www.dotnet-tricks.com/Tutorial/csharp/U08E301212-Difference-between-Generics-and-Collections-with-example.html So PHP could switch to using the HHVM generics syntax, or we could keep the current one and generics could _maybe_ be implemented at a later date, but regardless this feature is not going to hurt the implementation of generics and it is not directly replaceable with collections. :)
[really?](http://www.php.net/manual/en/keyword.parent.php)
the method doesnt matter...
because you googled variable, while it isnt one. Its a class
It's PHP's elegant namespace delimiter :D
I think I understand what you want to say. I'm sorry but I may have mislead you with the formulation of my question. It's more like: "What does __call do if it doesn't get overwritten? Does it simply call parent::_call?"
yes it does. as the code states.
You are a man of many words but thanks anyway :)
fair enough! I've been using Zephir since August. it's pretty solid for how young it is. Also, about adding support to PHPStorm, you can import Textmate bundles into PHPStorm, Zephir provides a Sublime Text bundle which also happens to be a Textmate bundle! Granted, it doesn't give you any code assistance, or inspection info, but you do get highlighting!
Awesome - thanks for the top about Textmate, I was not aware of that.
Try "zephir fullclean" before a new build. I just replicated this on Ubuntu and I think it's something in Zephir's build process. Maybe it needs regular cleaning? FYI - if you skip zephir for compiling and use the normal phpize - make route, it compiles perfectly even right after Zephir reports that error. So not a language problem but a build process issue. P.S. You obviously need to use Zephir to generate the C before switching to phpize/make.
If you don't mid venturing away from php there are some great micro-frameworks for ruby and node: If you have worked with rails and ruby before, maybe try out something like [sinatra.](http://www.sinatrarb.com/) It's great for smaller projects. You can use datamapper as an ORM. Sinatra isn't a biased framework and gives you a lot of flexibility to do things your way. You can also try out [express](http://expressjs.com/) for node.js which is incredibly similar to sinatara. 
It is a class.
&gt; you'll have to add something like Way Generators, Ardent and etc... what? Nope. Most what you just said was crap. You dont have to do it the laravel way, just use DI and you dont have to use Facades, you can also swap any component you like. Also my laravel installation is less than 50mb, and since we live in 2014 disk space means shit. 
Not really...
i'm the author and i haven't really used it anywhere yet. did a few changes since yesterday though, but overall, usage is still the same.
More accurately, it signifies to use the class in the global namespace.
That makes sense. I've been using PHP for a while but only recently have I started using OOP principles with PHP, so it's like a completely different monster. Thanks.
Thank you for all the comments, unfortunately I can't tell any of you if any of your suggestions worked because I was out sick and the sys adm fixed it for me!! Cool but I would've loved to have figured it out myself.
Glad it helped! And thanks for the Gold! :-D
interesting - moving code outside the bundle structure appears to go against Sensio Labs best practice though doesn't it? I may be wrong on that one, and I can certainly see the arguments in favour as that's something that's bothered me before. Nice post if that's yours, nice find if not!
I've gotten to the point of using the Way generators, and those seem awesome, but I don't understand how people learn this stuff. I'm smart enough, I think, and I know my way around a computer better than most people, but I'd like to get off Drupal module development and start developing some custom apps because I know there are better ways to be making the things that I need to be making in my job. Should I buy CodeBright and read through that? It sucks that I'm most familiar and comfortable on Windows. I know how to manipulate my PATH variable and can solve problems on my own almost always, but I feel like I've never fully adopted a framework for development because I just run into too many things that *do* feel like a burden. If I could lay out a super-simple system in reasonable depth — describe entities and fields and how they might be used — is there something that I could go through that would walk me through using a quality IDE (or SublimeText) and explain how to get to the finish line just once so that I could go back and try to do it on my own from scratch and be sure to learn things the right way? This has been a frustrating past few months as a lone developer and I'd like to start to turn things around by learning something I can be enthusiastic about. That usually comes with any small feeling of success, personally. I can snowball from there.
Did you take a look at the C# example I posted, which clearly outlines the use of both generics and collections using the foo[] syntax?
Nobody's mentioned Phalcon. It's a php extension written in c, so it performs at native speeds. It makes deployment more complicated than just copying all your files and db, but it's got what you need, and is technically lightweight, since there's no big framework folder. 
It did when I discovered it. So I started using it for smaller projects. With good success and no bad surprises whatsoever. And when I needed to use it on a bigger project, I spent some time reviewing the code for the modules I was going to use, and find them to be ok for what I needed. Several of these projects are still in production today, with no specific issues coming from Flourish. So I tend to agree with the statement on the [Roadmap](http://flourishlib.com/docs/Roadmap) page : "Please note that Flourish has undergone a good deal of real-world testing, and can generally be considered production ready.". A few more things to know about Flourish : * [Good] The author is the guy who wrote that great package management tool for SublimeText * [Bad] Everything in Flourish is static * [Bad] I think the project has been abandoned... * [Good] ...but it fine in the current state
https://github.com/blackbelt/php-validation
Those are some fairly major negatives! But if it helps you out then keep on trucking. :)
I don't think this will do what you want. `__call` is only called when the method doesn't exist, or isn't accessible from the calling scope (e.g. private), that also means it wasn't inherited. class foo { public function a() { } public function __call() { } } class bar { public function b() { } public function __call() { } } class bat extends foo { public function c() { } } $foo = new Foo(); $foo-&gt;a(); // Foo-&gt;a() called, No __call called $foo-&gt;b(); // Foo::__call() called $bar = new Bar(); $bar-&gt;a(); // Foo-&gt;a() inherited by Bar called, No __call called $bar-&gt;b(); // Bar-&gt;b() called, No __call called $bar-&gt;c(); // Bar::__call called $bat = new Bat(); $bat-&gt;a(); // Foo-&gt;a() inherited by Bat called. No __call called $bat-&gt;b(); // Foo::__call called $bat-&gt;c(); // Bat-&gt;c() called. No __call called Also, one more thing to note: `call_user_func_array` is slow. It's better to do the following: PHP 5.4+: $callback = [$this-&gt;facebook, $method]; switch (sizeof($arguments)) { case 0: return $callback(); break; case 1: return $callback($arguments[0]); break; case 2: return $callback($arguments[0], $arguments[1]); break; case 3: return $callback($arguments[0], $arguments[1], $arguments[2]); break; case 4: return $callback($arguments[0], $arguments[1], $arguments[2], $arguments[4]); break; case 5: return $callback($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]); break; default: return call_user_func_array($callback, $arguments); OR, to be compatible with earlier PHPs, use: return $this-&gt;facebook-&gt;{$method}(...) instead of the `$callback(...)` notation. For PHP 5.6+ you get to use the new unpack! Instead of that whole switch, you can simply use: return $this-&gt;facebook-&gt;{$method}(...$arguments); or: return [$this-&gt;facebook, $method](...$arguments); 
Please don't just tell folks to RTFM. Point out what you're saying, it's not always obvious. Something "See the part about X, it should explain everything you need and if you need more help then feel free to ask questions" will go a long way :)
It's a matter of context, really. I totally recommend using Flourish on non-critical projects. It's definitely useful if you don't use a framework and want to save time on well-known things (DB &amp; ORM, dates, currencies and whatnot). But for more serious stuff, there's &lt;insert-your-framework&gt;.
why? Ive learned it this way with ease and most of my collegues too. (s)He also said (s)he found nothing 
I went into this asking the question "Why should I use this instead of phpsh?", and there's absolutely no answer. Unless it's hidden somewhere in that video.
It pretty much comes down to Doctrine being really heavy. I much prefer lightweight and simple libraries that do that bare minimum of everyday common features, without getting too bloated or complicated. It's how I also feel about Symfony. Sure they are powerful, but they are usually overkill. But jumping back on Doctrine, it's me just being nitpicky. I don't really like their syntax (too PDO style), I hate annotations, much too verbose (defining entities and such), etc, etc.
[PHP Namespaces in 120 Seconds](http://knpuniversity.com/screencast/php-namespaces-in-120-seconds)
I've just got a little script I wrote called deploy.php, which contains settings for all my projects and uses rsync to send stuff to the the live servers. So I just type... deploy projectname ...and it goes up. It also has the ability to run pre and post commands via ssh if a project needs it. Luckily I'm just a solo programmer these days, so my DB schema changes don't need to be merged with anybody. I just make the DB changes on the dev server and use a wrapper I wrote around http://schemasync.org/ to write the dev DB structure to a .sql file and then upgrade the live server's DB based on the differences. I haven't been able to find anything that works as well as schemasync written in PHP. If anybody knows of anything, please let me know. 
standard /r/php down-voting innocent questions, stay classy
Yes. I have read the article. I don't think it answers my question. you proposal is this function getDocuments(User[] $users) // should only accept an array of User entities. Let us assume this got implemented so that we have the following code. $users = array($user1, $user2); // where $user1 and $user2 are User entites $documents = getDocuments($users); // this works fine for now Now in the next version of php, we get typed arrays. function getDocuments(User[] $user) now means it will only accept an array declared as $users = User[]; at this point our old code, which is $users = array($user1, $user2); // where $user1 and $user2 are User entites $documents = getDocuments($users); will no longer work. Because $users is just an array, not a typed array. What am I missing? 
I'm with you man, No sense opening a can of soup with a steamroller. For small API's and simple stuff I just use some classes I've found and tweaked for database access, and some homegrown validation ones. I call it a "framework" in the comments, but its just my own custom crap. 
The debug feature which can be used with existing php scripts and allows you to drop to the psysh shell with the full state of your app loaded and ready for inspection is a nice feature that I don't think boris/phpsh support. phpsh has documentation features I dont think boris or psysh has via: d funcname Seems they all have features that some of the others are missing **UPDATE:** psysh has a documentation feature as well via: doc funcname
psysh has documentation too: http://i.imgur.com/dc1IqG2.png And it's actually quite a bit better than phpsh's.
I'd use it just because it looks like it is maintained. phpsh hasn't been touched for 3 years and has outstanding pull requests just sat there without comment or feedback.
I, too, would like to thank you for Plates - I wrote a small wordpress plugin framework and use Plates to manage the views. It really is a pleasure to work with.
Rock on - this would be awesome for PHP 6.
This conversation has morphed a little from its origins, and so has my opinions on Collections, Generics, and the current "array of" logic, so keeping this conversation consistent is rather tricky. While Generics and "array of" are slightly different in their intentions, array of can be considered as "Weak Generics", which is handy. It means that the same syntax _can_ be used for both, which is something I had initially not thought to be both possible and reasonable. Collections and "array of" also contain a lot of similarities, but comparing collections in C# to collections in PHP is silly, and everything has overlapped far too much. Where progress is at on a private conversation between myself and a few internals people is that the array of syntax should probably change to match Hack generic-syntax, without fully implementing generics. That means you cannot use them to create collection-like arrays, but you can use the generics syntax to type hint arguments - which is a good half-way compramise, without harming implementation of actual generics in the future. That however does suppose that there are enough people in internals who actually want generics ever. If a vote was taken against the idea and everyone said "fuck that" then "array of" syntax would be perfectly acceptable, and "typed arrays" or "generics" will be buried. 
Please stop spamming /r/php with your quiz links. Thanks.
You want Javascript, not PHP.
(I will not listen to you)
Regular expressions will save your life.
I assume PHP has it's own regular expressions. From the googling I just did it appears so.
Great work - good to see someone putting the money where there mouth is and making a start on something like this.
use the preg_* functions.
Nice to be proven wrong.
It has its own regular expression functions, but the regular expression parsing it does is generic. I don't believe you need to learn PHP-specific syntax for regular expressions.
Very nice!
Using Windows is fine if you want to develop in it. I'd recommend using vagrant. It's an easy way to manage a virtual machine which will act as your server. There's even a Github with a pre configured vagrant box (basically this means a vm configured so you just clone the repo and just run "vagrant up" and it creates the vm for you. Then you just type "vagrant ssh" ssh into the vm and you have a full fledged Linux environment from you Windows terminal that is pre-configured with php and Apache and with a fresh laravel project already installed. I'd say you could spend half a day and be up and running and you'll never have to use wamp again. Here's the link https://github.com/bryannielsen/Laravel4-Vagrant For learning laravel, I'd say just Google around and find tutorials. 
Yes please, this would make life much easier!
I would just like to add something here: https://github.com/rossriley/php-scalar-objects#arrays Please, for the love of all things holy, add a method for reindexing an array. It bothers me to no end that a function doesn't even exist at all in current php land. Example: $results = $this-&gt;fetchAll('yadda yadda...'); // Looks like this: // Array [0] =&gt; ... [1] =&gt; ... [2] =&gt; ... What I do almost all the time is this: $results = $this-&gt;query('yadda yadda....'); $new_array = array(); foreach ($results as $result) { $new_array[$result-&gt;id] = $result; } // Should look like this, but a pain in the ass to do it. // Array [321] =&gt; ... [381] =&gt; [409] =&gt; And it isn't just for queries, it's pretty much any time you need to re-index one array, to be easily referenced by some other part of your code. So what I would love to see is this, whereby 'otherField' corresponds to an array key or object field in one of the nested arrays/objects as part of the first level array. $myArray-&gt;reindex('otherField'); Even better, add some kind of recurisve or multi-dimensional support to be able to reference any key N levels deep.
Uses perl regexs which brings up that if you're a sysadmin knowing a small toolbox of perl wouldn't hurt either. 
I'm not saying don't point people to the manual, but you can do so without coming across like a dick :)
&gt;Still you can't read a thread about PHP without some programmers pointing out a lot of the inconsistencies in function names This is mostly because everyone wants to say something, and it's easier to just parrot something than it is to talk about things which actually carry consequence. This is also why you see so many conversations about editors. It's a way to sound smart without actually being very smart.
When writing a script, use a CLI framework. It really makes the differences. I recommend [Cilex](https://github.com/Cilex/Cilex).
Agreed. As for a current implementation, if you are using PHP 5.5, [array_column](http://ca2.php.net/array_column) will work for you. Use null as the second argument. $myArray = array_column($myArray, null, 'otherField'); The only drawback is that it doesn't work with an array of objects. I have a fork somewhere that allows you to pass a callback, but haven't submitted it yet (might need an RFC first). 
Yes, generally I agree, was there just to show chainability, plus in a more long term future we may be able to get operator overloading into the handlers so 12 + 5 would internally call 12-&gt;+(5) or similar syntax.
I hope its not the case that the stand out feature of Laravel is that it has relations that other frameworks have had for at least a decade.
As a sysadmin, you'd be better off using perl and bash scripts to help manage the servers.
security, security, security. As a sysadmin, you will be the last defence unless you have a security guy. You MUST monitor access logs, WAFs and such for XSS, SQL, CSRF etc. I cant stress this enough. Most PHP devs understand SQL injection, but few excel in helping with XSS and CSRF.
Perl, Python, Bash, and common unix commandline tools are arguably more important to a sysadmin than PHP.
Neat, but `__debugInfo` please.
Make it happ'n Capt'n
I miss json! Upgrade destroyed me!
I'm pretty sure that can't be done. Your best bet at that point is to carry on, and fix it with ALTER TABLE afterwards. There's a way to abort the command too (ctrl-c maybe?), which might be a better option if you've screwed up a DELETE, UPDATE or DROP.
Just type `\c &lt;enter&gt;` to cancel the query and start over. Or, as already mentioned take it as a sign that you need to learn ALTER TABLE.
thank you very much
i will do that, thank you
I guess the anonymous functions are specific to Pimple. You can use more complex objects as factories. If your legacy codebase would require a lot of anonymous functions to work, perhaps it's better to arrange the construction of these dependencies in another way. Maybe using an abstract factory, which encapsulates families of factories that have something in common. 
I don't really understand this response. It isn't. This is a basic tutorial for a simple aspect of one feature of Laravel, the Eloquent ORM. Indeed, given the nature of an ORM (and the critical R in there) the ability to do relationships is pretty much fundamental. Laravel has a lot to recommend it. Nothing in this article says "you should totally use Laravel because it has this". It's just... how to do something. I see no reason to be snarky about it.
Interestingly, I stumbled across that repo today! Being a php developer for 16 years now, I would love to see an optional strong type system. Just something as simple as an INI_ALL setting of strong_types=1/0 That would let use do things like specify scalars as parameter types, and even specify return types. It would be nice. And along with the proposed arrayOf operator. It could all be quite enhancing to the language. 
Ah, okay. Yeah, it's harder to read when you write that way so I can understand. ^_^
if you haven't seen it yet. reasons why PHP is the way it is. good to know moving forward.
It's actually worth mentioning that `\? &lt;enter&gt;` will show you more options. For example, when a query retrieves a large amount of columns, or big bits of text, ending the query with `\G` rather than `;` will give you a nicer view. mysql&gt; SELECT * FROM sessions\G *************************** 1. row *************************** uid: 1 sid: E-nC8DEzYEr1w1VIPEXM3ZH7BFPnVBuuoApc6sf2jVw ssid: hostname: 127.0.0.1 timestamp: 1381780282 session: *************************** 2. row *************************** uid: 1 sid: Z2Dfqt16HyLNFcVm_Jn2q0zqMfjArU77Ps5IIg9qkDg ssid: hostname: 127.0.0.1 timestamp: 1381770569 session: 2 rows in set (0.02 sec)
Well said. It's interesting how few people realize that PHP *is* consistent, in its own right (I feel my down-vote sense tingling as I type this). I don't necessarily agree with the API (it IS confusing to remember what's right when and where), but it's important to understand the decisions and to realize where the divides are. Array methods: Needle first, haystack second. [array_search](http://php.net/array_search), [in_array](http://php.net/in_array), [et al](http://php.net/ref.array) String methods: Haystack first, needle second. [strpos](http://php.net/strpos), [strstr](http://php.net/strstr), [et al](http://php.net/ref.strings) C API derivations: strstr(3) SYNOPSIS #include &lt;string.h&gt; char *strstr(const char *haystack, const char *needle); #define _GNU_SOURCE #include &lt;string.h&gt; char *strcasestr(const char *haystack, const char *needle); strlen(3) SYNOPSIS #include &lt;string.h&gt; size_t strlen(const char *s); Most people argue what [PHP: a fractal of bad design](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/) states (search for "c api" for multiple examples). &gt; Do not tell me “that’s how the C API works”. What on Earth is the point of using a high-level language if all it provides are some string helpers and a ton of verbatim C wrappers? Just write C! Here, there’s even a CGI library for it. I argue that this is a moot point. The language was developed to make web applications easier to develop. The author knew C, so it likely made sense to use the same API. Developing in PHP with the same API as C is *not* the same as managing memory in a C application to use the same string methods. Could PHP improve its API? Sure. Does the API make the language bad by default? No.
Because `__toString` and `__callStatic`
Fair enough, though [__set_state](http://php.net/oop5.magic#object.set-state) also exists.
But you can never have enough serialization methods!
There's always going to be a part of your codebase that's responsible for creating and executing the code, to get the ball rolling so to speak. What I've found works well for me is to be entirely 100% DI in my domain / business layer, and be a little more lax in my application layer (which for me, includes the Front Controller and action controllers, plus bootstrap code). I detailed some of this in a blog post a couple weeks ago - http://dongilbert.net/a-case-for-service-location/
That's the thing, people who use PHP to get things done don't even notice. They just wind up remembering how it is through practice (like you'd do with any language) and it becomes a non-issue. They're all still getting things done, even though a bunch of people are running around trying to make it sound like a show stopping problem. There are people out there right now who have been writing software for all of a week that are also getting things done. Granted they're getting them done at a novice level, but if they can figure it out an experienced programmer has no excuse.
might just have devised a method of avoiding this whole method by just sending numeric values over. 
You can hit \e to have it open the current SQL query in your default text editor. Then you can do anything you like with it. Save and exit to get back to the MySQL prompt with your new version of the query ready to go. Of course, this depends on you being familiar with whatever your default text editor is.
&gt; If you need your db results to return a key that is a column value, ensure that the type of object returned implements Iterator In a perfect world, that'd be great. In an imperfect world, php array primitives are pervasive, and the absolute easiest, most minimal effort way of accessing their members in a whole hosts of contexts is to index (or associate, whatever you want to describe it as) the array by something other than zero index. Thus it would be great if there was an equally minimal way of putting array elements into an arrangement that can be used elsewhere by different parts of your code.
In your example the "Item" class in an entity. The question I would ask is; "Does this element of my code need to be dependency injected?" What I mean by that is, yes you can create a factory for your entities but what exactly is the benefit of that? An entity is a very low level component, a simple POPO. Do I need to create an abstraction for this element for the purpose of testing? It would be highly unlikely that this would be the case and more likely that you will test the entity as is within your unit tests. To me DI makes total sense for those components of your application that benefit from an layer of abstraction. E.g. the database layer and the service layer are good examples of that. During tests, do I want to write to an actual database or rather a mock database instead? During testing, do I want to send out real emails or SMS messages or just log those messages to a logger? 
I belived it was an advanced not free for open source feature, but I was wrong. That's a great hint and I will definitively convert my repos into an organization. Thank you very much!
Doh. I should've linked your article instead. Oh well, next time ;)
Regular numeric operators already chain. Didn't operator overloading for C extensions get included recently? 
That's not true as CLI PHP does some nice and nifty things. Oftentimes, if I need to automate some tasks (esp. if they involve GD), I can run my script from the command line, and it's like butter. Then again, Perl can do those things as well, but it's all a matter of preference.
You can always wrap your db results in your own Iterator. :) Write it once and reuse it wherever you need it, and save some memory in the process!
The only thing that bothers me from time to time is Rasmus himself.
Why not contributing to /u/nikic repository directly (https://github.com/nikic/scalar_objects)? From your README: &gt; Once we get some consensus, we can send a pull request up to nikic and hopefully get some discussion going on the internals list You project isn't even a fork. To me, it looks just like duplication of effort. nikic started this, let's send pull requests to his project and let him handle the thing. He is by the way far more qualified to judge of every proposition.
This is a well known article from 2010...
Fair question. Firstly the Scalar Objects extension is really a standalone project and this is simply a separate project that depends on it. Secondly the actual interfaces will need to be reengineered as native PHP classes as opposed to userland code, it's this part that needs to go in the extension as opposed to the userland implementation which is more a RFC in progress. Finally I know that /u/nikic has a load more immediate priorities on core including named parameters etc. The internals list has made it pretty clear that any major change like this would only be considered for a new major version so this is an attempt to get the ball rolling and lots of PHP developers involved.
It needs to be pointed out that this already exists elsewhere: https://github.com/formativ/php-type-handlers Kudos though
&gt; Also, one more thing to note: call_user_func_array is slow I will happily sacrifice performance just to not use that code
I've just pushed up an example implementation. The following code is taken from the unit test which passes nicely. $arr = [ (object)["id"=&gt;5, "val"=&gt;"first"], (object)["id"=&gt;6, "val"=&gt;"second"], (object)["id"=&gt;7, "val"=&gt;"third"] ]; $expected = [ 5=&gt;(object)["id"=&gt;5, "val"=&gt;"first"], 6=&gt;(object)["id"=&gt;6, "val"=&gt;"second"], 7=&gt;(object)["id"=&gt;7, "val"=&gt;"third"] ]; $arr-&gt;reindex(function($row){ return $row-&gt;id; }); Returns: [ 5=&gt;(object)["id"=&gt;5, "val"=&gt;"first"], 6=&gt;(object)["id"=&gt;6, "val"=&gt;"second"], 7=&gt;(object)["id"=&gt;7, "val"=&gt;"third"] ] Does that do the job? 
A few of us in the office saw it and have made use of it in a few personal projects :) I started using it in a Wordpress plugin I am developing and it works really well - nice and simple with only the functionality you really need in a validator.
This is the correct answer. It's also useful for getting you out of the dreaded "'&gt;" prompt: mysql&gt; SELECT * FROM addresses WHERE postcode = ' '&gt; '\c mysql&gt; OP might also find [this list](http://www.bigsmoke.us/readline/shortcuts) useful, it's a list of all the Readline shortcuts that can be used in bash, mysql client, etc. Ctrl-r is a big time-saver when you're struggling to remember a query you typed in a few days ago.
I think they are talking about the work horse scripts in that case. There's more to their application then web facing code. 
I'm passed caring about language snobbery. Like anything online, the most vocal are not necessarily the majority. Good luck to anyone who loves PHP, and good luck to those who don't. 
Why Perl over Python? Not disagreeing, just curious. Personally I just use PHP for server stuff because I know it well and can get things done really quickly. But if I had more time to learn something, I'd probably go for Python, don't seem to hear much about Perl these days.
Fair enough, thanks for the explanations.
There is old Russian saying "плохому танцору всегда ноги мешают" which roughly could be translated "legs are always problem for bad dancer". I think this is very much applicable to software development. Bad developer will produce horrible code even if s/he using the coolest language. Good developer can produce good code in anything. Also, from my experience most of PHP haters don't actually know PHP that well and most certainly not aware of latest improvements in PHP (they most likely don't know much about anything in general...). 
I've always found this industry to be odd for the simple fact that we'll give away hours and hours of work to people that we've never met, but simultaneously rip on other developers for not doing things the same way we do. 
Do you have any links to the discussion surrounding this?
Hell, I wouldn't even be so quick to knock WP. It powers 19% of the web last I checked. It's not suited for everything but i've been pleasantly surprised by just how flexible it can be.
This is a stupid argument. If you're bad at something, you improve by trying different things and tinkering. Playing with frameworks is just the first step of many in learning a new skill. 
I haven't yet encountered a situation in which I preferred cli PHP over my triumvirate of python, ruby and bash, other than when I need to hook into our PHP codebase.
Would make more sense yeah good point. PHP is a tool and not every job needs a hammer.
PHP has indeed evolved a lot in the last two years. Great job has been done by a lot of great people, some of them being regular posters here. But the needs that have been fullfilled, often have been fullfilled for the wrong reasons ("Language X does that and PHP doesn't", "Doing this will bring people back from Language Y", ...). If the community had spent a little more time building great apps and a little less time trying to evangelize the language to people who don't care about it, we would probably already be living the future of PHP. By that, I mean that I don't think PR is what PHP needs. Competition with other languages is worthless. There is a lot of room for PHP, and the proof is it powers a huge number of websites. Focus on make it saner for the people who use it, not for making it sexier for the people who don't use it yet. And do 99.99999% of the PHP websites need generators or variadics anywhere in their code ?
His last comment was more directed at the Wordpress codebase, which is a jumbled, ugly, contrived, hard to test mess that also happens to be easy to use, works on almost all server configurations and is used to power most of the web.
That was 2008 mate
Indeed, Meet your friend named MVC
To make room for the [superior php syntax](http://www.addedbytes.com/blog/if-php-were-british/) ;)