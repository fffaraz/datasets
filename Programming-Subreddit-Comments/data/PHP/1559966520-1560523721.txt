The most interesting part is voting. Both for the article and your comment. Or that comment where the guy says he prefers !empty(). My theory is this is Reddit, with thousands passers by swiping around. They usually have no idea what is discussed here, yet every time a post says isset is variadic appears, such people get excited.
This is very good question to ask. Especially given courses on Udemy are usually of catastrophic quality. I would suggest Laracasts for basic PHP and then drift towards Symfonycasts in order to learn a good framework that will teach you good practices first.
isset(), just like many other basic language elements, is drifting away from the everyday usage nowadays, giving way to higher level instruments, such as valuators. I don't remember when I used it last time. For the outside variables there is Request class and all internal variables are just always set.
Nice joke.
I think you forgot to fix the related code. Since it returns false on NULL it'll short circuit. Did you mean ` || $variable === null` instead of ` &amp;&amp; $variable !== NULL` ?
FIY if you decide to move from Magento 1 to Prestashop, use an automated shopping cart migration tool is the best method to migrate your data. To be more specific, highly recommend you to use [this tool](https://litextension.com/prestashop-migration-tool/magento-to-prestashop.html?utm_source=reddit&amp;utm_medium=seeding&amp;utm_content=huong&amp;utm_campaign=turbo_boost-click2web): excellent performance, reasonable price, professional and responsive people! You can contact their support via live chat on website for further information. P/s: This tool is considered the **world top** in data migration!
It's true, but in my experience it's better set as a guideline over using isset since isset is easier to misunderstand. I've seen lots of mistakes made with it from programmers thinking it's a good alternative to !empty then seeing errors pop up without them realising a null or empty string returns true. Even yourself in the comments here admit to misunderstanding exactly how it works so it just gives you an idea of how easy it is to create bugs.
HOLY FUCK
Struggling to understand why you would do this. It's clearly based on the number of downloads, not the number of projects that use a package. I.e. if package A/A is used by A/F and B/F then it should count as two votes of confidence for package A/A.
I usually set it to something like ^3.2.11 I might get bug fix release on subsequent builds, but no big surprises.
Alright, just read on composer documentation for the meaning `~` tilde shouldn't you be using `~` tilde instead of `^` caret for bug fix release?
JFYI, isset has nothing to do with "true/false-ness of variables".
Valuators? First I've heard that term. Mind elaborating what you mean?
I love exakat! ... But it takes hours for it to run on the project I'm working on currently. A 15 year old legacy monolith app which I've been working to modernize. I have to start a run at the end of the day to get the results the next morning. It also uses so much RAM in the meantime that I need to kill everything else (PHPStorm, browsers, etc) to make sure it doesn't fail part-way. Exakat was amazing to help me find all the PHP version incompatibilities in the project. I was able to fix all those pretty quick. It reported 470k issues on our project, total üò≤. The report HTML file was something like 150MB or more. I don't think I'll be able to run it on CI confidently any time soon, until we do a lot more cleanup on this project.
Umm well. The gap between the usual PHP3-style spaghetti and the modern PHP is huge, but Ill try. You can define a class, setting up some validation rules for it. Then you are creating an instance of this class based on the HTTP request data. And it will tell you immediately if some field doesn't meet the requirement. Or you can define a set of rules for an HTML form, based on which a form is both displayed and validated. So you can write just `if ($form-&gt;isValid())` to see if it was filled correctly. There is a Symfonycasts walk-through: https://symfonycasts.com/screencast/symfony3-forms/beautiful-form-validation. Or a simple example: https://www.tutorialspoint.com/symfony/symfony_validation.htm
&gt; The argument has already been made. Writing an implementation-specific abstraction is an oxymoron It's not, it's something you can use later (which isn't great architecture, but it is practical). Thursday I did it. I wrote a fully tested abstraction of another library with only the thinnest glue code in-between. The interface it provided represented an immediate need. It was also a facade (too large to implement the entire interface cleanly) because the implementation was technically several interfaces. The language I had to use doesn't have first class support for a pure interfaces. It does however have first class functions, strong prototypical inheritance. Was it my finest work? No. Fuck no. Does it solve an immediate problem and avoid new decisions. Yes. Can I change the library I used. Sure thing, it's all in the private parts because there is a layer between the consumer via my thin wrapper and the library. We in-fact already have differences allowing me to null coalesce from two sources (which should purely be 3 implementations of an interface). &gt; It doesn't help you avoid "procedural" or "untested" code, and obviously it's not a separation, because on one side of this port can only be this specific domain, and on the other side, only Doctrine. The problem they may be solving could be as trivial as sources of configuration. Writing a query builder which is not doctrine is a huge undertaking and carries quite a maintenance burden, as does defining a DSL that can accurately represent addressing in SQL &amp; NoSQL systems, let alone custom data stores. If you call Doctrine directly the distance between your consumer and doctrine is zero. Each piece of glue in-between trades a teeny bit of performance for a place to transform data. There is nothing saying you couldn't transform a Doctrine query builder to query redis. It'd be a lot of effort and for-sure I'd say it's not the cleanest solution, but this is PHP. There are a lot worse sins like passing arrays around (specific container format). &gt; Adding more files between domain and Doctrine achieves nothing if you can't put another persistence layer on Doctrine's side. Another work project uses python &amp; requests. Requests is a HTTP specific library. I'm going to assert it's analogous to Doctrine if you squint a bit because it's purpose is to arbitrate between forming communication envelopes to a standard. Again the service code to talk to a HTTP REST service is bound to requests. It's not the cleanest thing, but by isolating the coupling and non-generic data-structures to a single private method for HTTP I felt it was clean enough, and was easy to test. If for some reason we need to use protocol buffers I only need to change a single private method, which I can monkey-patch, which I can control with a third private method. It takes data in plain syntax, transforms it to send over a boundary. It doesn't mix presentation with control flow, it houses none of the business logic. &gt; There are no parts you can replace here. Flexibility not achieved. Reuse not achieved. If this doesn't matter to you, what does? Yes you can do these things and you don't need to turn in your architect badge. It's called trade-off's they are what we should deal in. There are examples of code where I've written an interface for getting time so that various strategies can be put in place to select a time-source. Not every project needs that. It would be a waste of your time to start hello-world divorced from the default output of your program. I've no idea if you are for-real but you certainly have not met my experience of other architects. Mostly we're humans trying to do a job. I met one guy as brash as you were in 2016. He worked for the ministry of Justice and asked if I had any questions about distributing load on a prison system. That dumb fucks solution was to make their system a web-app. What on earth would I ask someone so sure of themself whilst displaying pure undistilled incompetence. Your approach might follow text-books, but it's impractical for all but a very narrow set of organisations. It's wasteful and not pragmatic. Worse still I fear the only clean way to handle such a task is to adopt early Java Stringly interfaces, or couple to another technology, which similarly makes a heap of up-front decisions you'll be bound to, just to spite being bound to doctrine (hilarious I'm defending this I think ORM's are a cancer).
Can you kindly give an example where you would have a lot of `(isset($a) &amp;&amp; isset($b))`? I cannot come up with a plausible use case.
Really? if ( isset( $_POST['username'] ) &amp;&amp; isset( $_POST['password'] ) ) { //do password validation here } else { //fail, both username and password is required. }
Thank you. Personally I wouldn't check text inputs for being set, because they are always set given the form is submitted. An error would mean there is a typo in the name - the exact reason why I need the error message, with isset() being effectively an error suppression operator. I would only use isset() for checkbox type inputs, but in this case I would check them separately.
The coding equivalent of speed holes.
OMG I just noticed. What a weird typo
Assuming semantic versioning, I try to lock dependencies to a minor version as early as I can in development, since I‚Äôm only interested in using features I actually need.
Awesome! Put it on GitHub so we can all check it out!
That's assuming you control the form. Could be an API or someone else building the form. Especially in the case of an API where I may want the error response to come back as json. But that's just a simple example. I have tons of cases where I need to check to confirm that multiple variables are set. Especially right before doing something that might be destructive (like editing the database). Since it's internal, I usually don't care to split them all out and give a verbose error message. I just need to make sure we don't improperly evaluate any missing variables to null (since that's what php will do along with a warning message).
One argument against I didn't see here (or grossly overlooked) is something that is especially true when fluent interfaces are applied to things that perform actions. I've seen stack traces being thrown in production where it couldn't identify the actual line of code that caused the problem, because it was one of the 30 chains in a row and the method name was not unique, so this could not be solved before reproducing it. In the end it had to be explicitly written line by line and deployed to production to get a sense of what caused the failure. I always use this argument against chaining, even if the interface is fluid.
 Notice: Undefined index: username yourcomment.php on line 1 Notice: Undefined index: password yourcomment.php on line 1
I still cannot imagine such a case but I take your word for it. Either way it was long ago since last time I used raw $_GET or $_POST so may be I am indeed missing something.
Exactly what I want. You see, error messages is not like a nagging wife whom you have silence at any cost. They are your friends. If you have such a message (supposed you did check if the form has been submitted at all) it means your form is malformed and it's better to have a look at it.
You should install ea inspections extended, that‚Äôs how I learnt about it and a bunch of other things
 They're messing with you :(
&gt; isset is a variadic function Huh, TIL.
Because you probably didn't know it all...
!remindMe 2days
I will be messaging you on [**2019-06-10 08:55:03 UTC**](http://www.wolframalpha.com/input/?i=2019-06-10 08:55:03 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/bxzvua/i_wrote_a_caller_id_server_with_php_short_useless/eqd5g9y/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/bxzvua/i_wrote_a_caller_id_server_with_php_short_useless/eqd5g9y/]%0A%0ARemindMe! 2 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! eqd5nr9) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
My my, a case of the incompetence? While I wouldn't personally choose to make a wordpress application, I've seen it done quite well a few times, and I've authored and maintain (small M :blush:) a few small and focused plugins, many non-trivial muti-million dollar websites which the owner wanted to centre everything around the CMS for. They were all too [cheap or stupid] sure that consultancy was a scam only idiots pay for. I don't know why you got gold, or why so many people are hating on one of the most successful PHP projects I'm aware of, because they and you struggle to use it, or phase it out without some big-bang toys out of the pram replacement. This is like hating on people that use cheap powertools because they are often not as precise, or well engineered as your preferred brand. Nothing stops you getting the few precision premium brand tools you need; incrementally. Use the cheap tools for the rough cuts, and iterate as precision is required. Anyone worth their salt should be able to pick up a WordPress and shake out a rough path forward. It outputs HTML, CSS &amp; JS, it has routes, a "restful" API controller, a number of features useful for translation, adding routes, modifying values without hacking at code. The same issues you have with WordPress you'll have with any enterprise software or 3rd party SaaS app you have to hack-at to get to work. &gt; Then I become the asshole that has to tell them it is not worth it to "fix" it. It needs to be re-built at twice the original cost. On cost it doesn't matter if it's twice the original cost, or 10x or 50x. Cost is one side of an equation, which the business owner and decision makers should be able to make. Can you do without broken thing? Will cost of replacement make you noncompetitive? I've had to break it to people that they'll pay 10k to replace software they originally paid 0.5k or less for. I've had to break it to people breaking their balls at 20k a year or less on a wage or salary working twice the hours I work that they are doing more work and getting less out of it. Guess it sucks for them that they didn't sit up in class. 10k software is cheap! Cars are about 2k entry and they do way less than entry-level software. As you put more demands on software it costs more and more. Imagine if Tesla made a car that your customers would pay for you having? That's &gt; 100k and it's an expensive piece of shit, so everyone can spare the posturing about software costs. Point is that if they want me to build it, 10k is more or less a starting point. IT won't buy you a Aston Martin. In-fact if you want one, go buy one from a dealer. All the non-valuable shit you could ever want you can buy from a package software dealer and I won't hold it against you. - They exist for that reason. - They dont differentiate for a reason. - They will sell to your competitors for a reason. - They will let you haggle and whinge for a reason. - They have very little value, and in many cases command and control your business for a reason. If someone wants something from a professional they pay for it! WordPress is for whatever you want to use it for. - Don't fall for the guild model of a few numpties walking around destroying things to force their prices. - If you genuinely think WP is the best tool, you use it, sell your wares. - Using a tool other people don't like doesn't make you unprofessional - Others abilities to use the tools you use doesn't reflect on you as a professional
Unless you want years of frustration and inadequacy, while simultaneously thinking you're the shit while everyone else knows you're an idiot (after year 2 or so), seek out a mentor and work for $20/hour if you have to in order to get this. I've successfully trained about 40 people on the job since 2012 and BELIEVE ME! I would have done so much better if I had had that, myself.
Why would you look at Laravel? It's upgrade cycle makes it cost prohibitive for anyone that isn't a startup playing with other peoples money. Look at Symfony for sure. They get it. They are on what version 4.3 now, in 20 years. Go with those people. They are smart and will work to not just force an upgrade because it's convenient commercially for their flea market prices. They provide something of immense value to the valuable. I don't hate startups btw, I just recognise that the desired state is a business making a profit, with customers paying off it's debts, paying into it's bank not jumping through hoops trying to get more credit or under-cut people not following that model. - https://medium.com/@info.subashthapa/upgrading-laravel-5-0-to-5-8-1bfec5c8a0e2 To say Laravel is at 5.8 is an afront to sane software versioning To say that Laravel is better than WordPress because it happens to take on less responsibilities and provide more connectivity is wishful at best. Some of the things it does are as bad as WordPress. Why hasn't Laravel eaten WordPress yet if it's so much better? Symfony probably does power more than WP. It also has a pretty wide curve of what is being done, but I could believe you could implement WP in Symfony even if it's not been done. All the Laravel CMS systems offer less and usually focus on how easy they are to theme, which puts them in competition with other non-PHP solutions which are in-fact easier, faster, more secure, some offer long-running process support, cloud provider integrations so you don't have to roll your own platform(s)
I have a feeling WordPress don't care though. Most of the new stuff is JS. They are on the bandwagon as it were to the js fan-verse, and with articles like this it's no wonder. I'll admit WP core is a special case of self assured and short-sighted clique. That is a mistake I've heard too many parrot to not take notice, but their software is pretty successful and helps people
Not sure if satire anymore
We check json body input (after decode). to our api that way to ensure all required fields were provided before continuing execution.
&gt;I only hear about this now that I literally migrated to another language? It's literally the first line in the documentation for the functions description: `isset (` [`mixed`](https://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed) `$var[,` [`mixed`](https://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed) `$...] ) : bool` [https://www.php.net/manual/en/function.isset.php](https://www.php.net/manual/en/function.isset.php)
What happens if your input is a 0 or empty string? Both of which could potentially be a valid input.
&gt;isset is a variadic function &gt; &gt;Huh, TIL. It's literally the first line in the functions description documentation: `isset ( mixed $var[, mixed $...] ) : bool` https://www.php.net/manual/en/function.isset.php
That's why now I hate myself.
Please be sure to disable xdebug before getting opcode dumps, these are rather misleading.
It is not my post, I just wanted to share it with you guys üòä
Slavery honesty
&gt;That's why now I hate myself. I wouldn't beat yourself up on it, there are loads of others, I've seen people with 10+ years of experience who don't even realise basic functions like var\_dump() are variadic all because they never bothered to read of the docs on what they see as 'basic' functions. You will be surprised how many gaps are in your knowledge by reading the docs. Many courses or tutorials will only cover the very basic function operation without informing you of all the possibilities.
I‚Äôm tryna get a remote job
What is the VOIP system that you use?
Sure, I've just never checked out the docs for isset.
Fixed version and manual update for major versions to avoid breaking any stuff.
Just sign up and forget about it. After all they provide interesting (at least this one) articles and having another account on another platform is not the end of the world. Or just kill all the popups with adblock. Medium can be shitty, but I just don't understand all the hate it's getting
&gt; I use something like this to evaluate if a variable is not null AND not empty AND not zero and doesn't require you the check isset() I use `empty()` for that
You're relying on the browser filling out the form properly, which isn't always the case, and you should never rely on client-side validation. People can skip browser validation and just submit HTTP requests on their own entirely.
Exactly. If the form wasn't submitted correctly, there will be an error - exactly what are you looking for.
Except it's not an error - it's a notice. The flow of execution will still go, just with values that you're not expecting, which could lead to unexpected behaviour. Either way, you really shouldn't be wanting errors to bubble up and throw a 500 - the problem is NOT that it's a server error, it's an error with the client's request.
Typically, no. With the carat you can install a specific version line 3.2.11 and it will allow 3.3.1 to be installed as well as that should be a non-breaking change but will not allow 4.0.0
That's actually a nice short story! Don't hit yourself so hard!
That is true, but the response proposed (200) is not correct either. if you want it proper, the response to this isset should be 400 and it shouldn't involve any user interaction
I don't think anyone proposed that it should be a 200 - you should be able to trigger a 400 with your framework or codebase if the `isset()` check fails. That said, _what_ you do with it is another question entirely (like I'd use a validator class to encapsulate all of that), my point is that you can't just ignore the checks assuming that the client is all fine and dandy.
1e7 is a valid literal in PHP, but it will be a float.
Would love to see how it works!
 **S** THE PERSON ABOVE IS A CONFIRMED SCAMMER! I am the Scarlet Letter Bot. My purpose is to brand scammers with an eternal **S** for 'SCAMMER'. If you have proof that someone that is not on the USL is a scammer, please pm me.'
&gt;fonction
The best thing to do is to build something for yourself. People who are approaching the "improving beginner" stage can solve isolated tasks, but can struggle with breaking down everything required for a whole web project. I used to teach PHP classes for fun, and I built [a tutorial for my students](https://ilovephp.jondh.me.uk). It's mostly raw PHP, so be conscious that non-trivial projects should probably use a framework, but I think there's a lot of useful walk-through in this.
Isn't the main problem with Elance that there's lots of people on there who think they know what they doing, when in fact they do not? `;-)`
To be fair, at least one of the folks moving to alternative projects have a _very_ active history in Open Source.
Wordpress is for low budget sites that should require minimal attention from you. The strong point of it being that the client will make the modifications (like adding images or changing text) not you. If that condition is not met, better build a site with Symfony or Laravel. Typically a site for a small shop like a hair stylist.
Use this: https://chrome.google.com/webstore/detail/make-medium-readable-agai/kljjfejkagofbgklifblndjelgabcmig
Practice, practice, practice. Just like the song Hey Jude, "take a sad song and make it better", find a sad/bad website and make it better from the ground up as a personal project at your own pace. Try it.
Was exactly was you struggling with in terms of language knowledge?
You can call the constructor manually, without any special tricks. I don't think I've ever had a good reason to do it though. This code runs the constructor twice: &lt;?php class SomeClass { public function __construct() { echo "under construction...\n"; } } $x = new SomeClass(); $x-&gt;__construct(); http://sandbox.onlinephpfunctions.com/code/5ea27d97fdefc9a9d86bd57b8fa93b8f03077f3a
If you don't BLPOP , your workers have to sleep between your jobs, blocking the CPU. The in memory driver makes no sense, normally you add to a queue to process it later/on a different server, or to process it in parallel and get your data back, so you have to share the memory between processes.
It's usually better to pass objects around instead of string classnames, but there are good uses for passing classnames around, since in PHP the classes themselves aren't objects. If you use Psalm you can type hint a class name against an interface in a docblock, using e.g. `@param class-string&lt;MyInterface&gt; $myInterface` See https://psalm.dev/r/1f3fc7dd5a . The mistakes that would fail psalm checks are underlined in red.
[removed]
Explainshell integration, that's unexpected
The only use of passing classnames around I can think of is if a classname has to come from some text configuration format (INI, XML, YAML, etc.). But that in itself is a big red flag, because a configuration shouldn't break the encapsulation of the program and contain implementation details like classnames. So frankly in my practice I've seen no good uses for passing classnames around. I used to do this before, but I've gradually learned in most instances I caused it upon myself due to not knowing how to do it better. What good uses have you found for passing classnames?
The one I'm using most at the moment is passing a class name to a serialisation library, to tell it what class it should instantiate when it deserialises the content of an http request sent to an API. I think the fact that it can be typed checked with Psalm may make a big difference to the range of good use cases for this.
I think the key weakness is again, that you can't attach "injected environment" and "config" to a classname. This doesn't matter when deserializing simple value objects. But in those cases, what I do is I implement the deserialization method on the class itself (Foo::unserialize($array)), thus again negating the need to pass the classname around.
The inn memory driver makes sense when considering automated testing.
I agree with BL/BRPOP and think "regular" version (non-blocking POP) fits better in this lib case. The InMemory driver was mainly developed for testing purposes. It allows replacement of let's say SQS implementation to InMemory in some integration-level testing for clients.
Start with a good book, for example [this one](https://www.manning.com/books/php-in-action)
&gt; One of the seniors told me it's like that that I have check every single corner of the website and make sure it doesn't break. I wish there was a way to automatically run such tests
The argument my colleague was putting forward was that majority of searches for each term would come from active developers searching documentation. I find that fairly convincing. A framework being on trend might account for one or two searches from non-users, but the count of searches from active users would make up the bulk. Perhaps there is an argument is that Laravel is much more trending than Symfony, presents itself as more user friendly, and thus gets more attention from folks who never end up putting things into production? This is anecdotal, but my impression the last time I was looking at job posting was that Laravel was listed more often. That is something that could be verifiable too, the frequency of each in posting jobs. I suppose I should see if that has been done, or step up and collect that data myself.
Maybe the great devs you know should take a crash course in salary negotiation. Calling it "disgusting" that some people gets paid what they ask, is rude and only based on feeling envious.
Right, yeah. Tilde will allow just patch releases while carat will allow minor version updates as well. If following semver there should still be no breaking changes, but the less you know about the package the more you might want to lock it down.
Thanks! I'll go for it.
Almost always when I try to do new things that I realize I have not learned yet, which is what has caused me the insecurity of not knowing how well or bad I am. But usually problems related to SQL statements and OOP.
Thanks for the information, I will get involved in that. Just that I was searching for 'Symfonycasts' and didn't found anything about it, what is?
Thank you for the course that you have created, I am sure that I and all of us who started in this area are very grateful to you.
Unfortunately, empty can only accept one variable at a time. So in the above example you would have to duplicate it 3 times.
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 60.0% out of the 5 submissions from /u/codefaculty appear to be for courses, coupons, and things like affiliate marketing links. Don't let spam take over Reddit! Throw it out! *Bee bop*
Well, SQL isn't really PHP. You'd better have another course just about it I guess.
Benchmark? Call a static function vs DI in a for loop. Repeat the process 5-10 times. Take the average execution time between call with facades and DI.
Who are you making it for? If it is you, and you want to do it, do it!!
Do it for fun, never do it for production. Why would you put a burden on your future colleagues to deal with your version of a framework, which, let's admit that, will never reach the quality, ease of use and documentation of an open source one which has eyes of literally hundreds of people reviewing the code.
I don't know. Why do you think it's faster?
It would be nice if you are trying to develop your skills, but production, In my opinion, if your framework does not provide something different like more elegant way to handle with routing, events etc.. You shouldnt.. Because making a fully qualified framework, requires lots of time and work. And if you do what they already done, its gonna be huge waste of time and effort. And also even most common frameworks have dozens of bugs, imagine your own framework how gonna be ? I think best thing to do is making your own php components and integrate them your top frameworks.
People muck with the HTML. Adblockers may remove HTML elements out from under you. Malicious folks don't even use the form and sent arbitrary POST data looking for ways to break your app. The internet is a pretty unforgiving place even for the most innocent of forms.
I'd already gone to bed, but you nailed these responses. Thank you.
Yes, that's why you should be alerted by this, not silently bypass it
Oh. A 60k+ karma-boy descended to a programming conversation. Get back to your memes.
Better to handle the situation in code than have to rely on trolling your logs. Yes, your logs should be clean but what do you think the next step will be after you notice that message? Most would reach for the `isset()` that should have been there in the first place. Your hesitance feels like needlessly cutting corners to me.
60k comment karma is paltry for most karma-whores. Most of my karma comes from OC and participating in conversations just like this one over 9 years. My knowledge of this particular issue comes from over 25 years experience as a webdev who's currently working for a top 50 site as a senior dev. I've been in the programming subs almost a decade now. Who are you to tell me to go away?
Try harder next time
Depends on the definition. If you mean to write and *support* your own components, it will be insane, to say the least. If you mean to create your own set components, bases on some micro-framework such as Symfony 4 or Slim, you are encouraged to. See, it's all about support. New PHP versions come out, new security breaches require patching, new features are waiting to be implemented. Choosing existing components, you have the community to back you up. Writing your own, you'd drown in supporting them soon enough
AGreed ...
If you're going to handle it properly, returning 400, that's fair. I doubt, however, any of those isset advocates ever has such an idea.
I think you'd be surprised. The whole point of using it in a conditional is so you can act on it somehow. If not, they may have hard lessons to learn in the future.
As long as you're not burdening other people with it, absolutely. It's a really great way to learn the ins and outs of handling data.
second this. Do it for your own smallproject and learning. Don't reinvent the wheel if you need to deliver a solition. Doing this and building a framework will make your quality worse.
If you have the knowledge and experience do it. It will be tailored to your needs and very light compare to frameworks like Symfony or Laravel. Writing a framework does not mean you have to do include all the big ones include and it will be evolving and improving over time. You will not be using someone else opinionated decisions, and you will be fully aware of the magic. From my point of view it's insane a Sylius installation for example can take 300mb and 50k files in order to work. Create proper documentation not just for others but for yourself. And of course test it as much as you can.
Pointless, unless it's a fun side project. &amp;#x200B; If you make your own framework, by using components of other proven frameworks, then maybe, if you have a weird architecture.
You're not putting proper HTML. It needs quotes around the value.
You should put double qoutes around the value your echo-ing like: value="var"
Oh perfect it works now :D thanks!
Oh perfect it works now :D thanks!
Many people following semantic versioning will no longer release bug fixes for e.g. 1.1.2 once 1.2.0 is out. Fixed bugs will just be released as 1.2.1.
Makes my life a little bit more easier.
Makes my life a little bit more easier.
Yeah, that‚Äôs true. I‚Äôm not saying my way is perfect, but in general I think it reduces the possibility of transitive dependency introduction to my application, and I prefer to keep my dependency list as small as I can. In a perfect world I would routinely monitor repos of my dependencies for minor version bumps that I might want to step to; honestly, I rarely have the time. I typically do that sort of monitoring when I know there‚Äôs a feature I want and I‚Äôm keeping an eye out for it, or I‚Äôm waiting to see if a pull request of mine is going to be integrated so I can stop using my own dev branch in composer.
What about concurrency bugs?
Sorry , if you don t understand a simple benchmark you must be a retard then. Just don t think about it too much or your brain is gonna fry
&gt;http://sandbox.onlinephpfunctions.com/code/5ea27d97fdefc9a9d86bd57b8fa93b8f03077f3a TIL, thanks.
&gt; One of the seniors told me it's like that that I have check every single corner of the website and make sure it doesn't break Well, full stop here and write tests. &gt; do you guys use specific version for dependencies or dev-master/@stable/@dev? My advice: remove all packages and `composer require` them again, you will get the latest stable release versions in your composer.json automatically. As in: start it from scratch.
Thanks! If you make it to the end, I should be very happy to hear about it `:=)`.
&gt; Method Breakpoints via the gutter Killer feature. Already tried it, very useful üëç
This is rather weird - I congratulated you about using secure coding practices [in this thread](https://old.reddit.com/r/PHP/comments/bvj91m/sales_calculation_using_php_mysqli_ajex_json_part/), as YouTube programming videos often have awful security vulnerabilities. And here is a vide with the SQL injections I tend to worry about _from the same author_. What is going on?
I believe it basis is sipnl (hosted in the cloud). Most logic is in the tiptel phones, they have the option for action URL‚Äôs
i already looked in symfony/eventdispatcher and other similar libraries. If i have choose one of them, i have to write 40-50 classes which is a lot. Is there a good way to solve this problem?
Go for a framework, don't build this from scratch.
If you are working with a framework you got to check out if it has event driven support on it's models. Most of them have, so you could call the notificiation classes and its methods.
It's highly unlikely you'll be able to build something remotely as good as some already established frameworks out there (Laravel, Symfony). So unless you're doing it just to learn, it's a waste of time.
¬Ø\\\\\_(„ÉÑ)\_/¬Ø
whaaaaat?! you mean I *can't* just put !!s on things to make it go fast?
Depends on what you're trying to do and what your problem is.
Not if you have real sendnail configured and available as a socket on the system.
Recently decided to start studying for Zend certification as a personal goal (I'm mostly a front-end guy). Reading through this made me say "no shit" the entire time. Studying for that exam has really helped me debug things in PHP that I wouldn't have gotten before. Lots of minute details to know that really really help.
Just do it, don't listen to people that tell you otherwise.
If you're doing it for fun or just to learn more about how frameworks work, by all means, go ahead. There's even resources like [this course on Laracasts](https://laracasts.com/series/php-for-beginners) that help you through building your own framework for learning purposes. However, if you're doing it because you don't like the existing frameworks and want your own to build actual projects with, it's almost certainly a terrible idea for a multitude of reasons.
Everyone should do it, and then never actually use it.
I am super disappointed with the comments here. First of all, that's how all frameworks started out. One concept of one person. More importantly, I believe everyone should build a framework at least once. And if you know what you are doing, there is no reason to be afraid to also use it in production (in that case, give it at least a year of development on the side, though). Whoever tells you that this should not be done has probably never dared to.
definitively do it, you will learn a lot of stuff about how frameworks work and all the problems it solves for you just don't use it in production
PDO if you want to keep it simple.
I remembered I did try to what you said. But the composer.json doesn't get updated. What were with wildcard `*` and `dev-master`, they still remain the same.
r/phphelp
If you are making a framework - what are the must haves ? Routing ? &amp;#x200B; And ?
Only if you want to receive email. &amp;#x200B; For sending mail you'll need to configure sendmail, depending on your OS / setup you can probably use the wizard with the following command to get it up and running: `sudo sendmailconfig`
Do it despite all the others are saying otherwise. A kite rises high against the wind.
Even better is https://redis.io/commands/brpoplpush which will give some better reliability, avoiding lost jobs in case the job worker dies in the middle of a job for whatever reason.
Or use time limited signed URLs instead, rather than streaming S3 -&gt; your server -&gt; client.
It depends on your agenda, work, fun or making the world a better place? &amp;#x200B; If you're doing it for a specific project, the end project may not be as mature or featureful as the existing mainstream frameworks (Laravel, Symfony etc), you'll be slowing down the release of your project and future code maintainability might be a hassle, especially when the team grows. On the other hand, perhaps you're looking to start something new and exciting that might dominate in years to come, who knows? Writing your own framework can also be super educational and give you a higher appreciation for the existing frameworks that you're already familiar with so go for it!
Start own open-source project on GitHub, and learn for free from the best programmers in the PHP community. https://www.tomasvotruba.cz/blog/2018/08/09/why-is-your-company-losing-money-by-not-open-sourcing-2-code-quality/#get-embodied-know-how-for-free
This came up a few weeks ago, I think on PHP slack, it is a micro optimisation. 8% added to a very small number is still a very small number, and if you benchmarked a function which was more than a handful of opcodes to start with, the one or two lines added to identify the correct function would make a proportionately less noticeable impact. You can make 1000 calls to a non namespaced function, blink (literally, about 0.2 to 0.4 of a second on the average blink), and miss the increased time to run. So, it sounds cool, and amazing, and that you can speed up your code a huge amount, but actually, if you're running thousands of fiction calls per execution to notice the difference, then you probably have bigger problems than namespacing. The suggested time savings are a case of bad statistics and worse analysis. If you're going to namespace everything, do it to lower the cognitive load of future developers, not for the efficiency of the code.
It sounds great, but the conclusions are just bad statistics and interpretation.
Since everything is wildcard, it's of no value anyway. At this point you can even start with a scratch `composer.json` and require all the packages you need.
We use our own framework in production for 10 years already. It requires constant work but I wouldn't change it for anything else. Best decision ever.
I did one and abandoned it. I kept one part that went into production that renders PDF documents from an HTML source, with merge fields and 100% compatibility with CSS3, HTML5 and JavaScript.
It can be a lot of fun, and it can be a great learning experience. ...obviously it'll never be the best or most efficient way to solve whatever problem you're facing is, but if it's a side project or whatever, knock yourself out!
I‚Äôm sorry but ‚Äúit‚Äôs less than *blinking*‚Äù is by far the dumbest way I‚Äôve ever heard to measure the optimization requirements for your code. PHP applications are also multiuser applications. An average website may be visited by thousands of people at any given moment. That‚Äôs a lot of *blinking* to add up.
Er, nice strawman you have there?
Rephrase your argument without ‚Äúblinking‚Äù if you think it‚Äôs a strawman. Also, a modern PHP app will go over a 1000 function calls just to load the framework and configuration. And last, as PHP is preparing to add JIT as part of the core, these semantics slowdowns will have a greater relative impact on performance compared to now, as JIT can‚Äôt optimize for them.
It really depends on the project. Using a framework prevents you from reinventing the wheel. It also adds a shitload of dependencies and overhead. The attack surface on a framework is gigantic. Frameworks are made to solve a bunch of different problems and you may be only solving a specific one. If you're up-to-date with best security practices (and depending) I'd say : write your own framework or use a very minimal one (like Slim, to not reinvent routing). I worked on a game that had a huge server load (more than 10M daily active users, so billions of hits). Any framework would have choked. IMHO frameworks are best to coordinate a team of juniors because they are made to be very opinionated on the way you should work and use them, so they prevent junior profiles from inserting code anywhere in the project (which shouldn't prevent you from doing code reviews anyways). They are also great when doing freelance work and you want to act very fast on a client request. But if you have the time to develop an app from scratch, and the skill to do so, you should go down that road.
??
Maybe I am mis understanding your question. It is not very clear. Perhaps explain in more detail
How do I do that?
Well. What is your problem. What are you trying to solve. What do you mean by forwarding the sendmail port?
I am just trying to send an email with php. I configured sendmail.ini and php.ini, and that‚Äôs all i did. I then used the mail function in php.
I‚Äôd recommend checking out a library. Don‚Äôt DIY. It isn‚Äôt worth it
Ok thanks
That'd require more intentionality
It's not dismissive, it's a perfectly factual statement designed to illustrate the amount of time in a way that anyone can relate to. But if you like you can skip the paragraph just fine and the comment holds together if it offends you that much. Although, there you go again, what framework doesn't namespace everything? You sure do love those scarecrows. I think you'll find I said that they should be NS'd, but not for that reason, if your code is so tightly optimised, and all other bottlenecks closed, then and only then is it worth looking at this sort is thing to speed it up. But this is never going to be the bottleneck that you look at first, premature optimisation and all that. Back to the dismissive: I'm done with this, enjoy the rest of the sub, have a nice remainder of the weekend üòÅ
I don't fully agree with this. I agree with the "do it for fun" part, but if you're not planning on doing something with it, what's the point? Dream big!
I'm surprised by the replies here. Everyone saying "no, don't do it besides from a learning experience". What the hell is the point if you're not going to strive and try to push the bounds? The phrase "don't rebuild the wheel" is a terrible mindset to have.
&gt; It's not dismissive, it's a perfectly factual statement designed to illustrate the amount of time in a way that anyone can relate to. Yes, it's a perfectly factual statement that we blink. Great job. In the time we blink, an app I'm working on should process a hundred requests start to end. Which makes your perfectly factual unit, perfectly useless. Again, you're completely disregarding how PHP is used. If I'm using it for shell scripts 0.4 seconds don't matter. For web apps under load, or complex web apps, 0.4 seconds is a gigantic difference. Hence my statements. &gt; what framework doesn't namespace everything [...] I think you'll find I said that they should be NS'd You've misunderstood the problem. None of this is about whether we put our user functions in namespaces or not. It's about calling PHP's internal functions, which are in the global namespace. It's about whether you use fully qualified names, i.e. `\strpos()` or not `strpos()`. The former is one lookup, the latter is two lookups. &gt; I'm done with this Yeah. You're done with this, dismissing the problem before you even understood it. Typical :P
It's fine to keep PHPStorm config in git repository, there is article about it their help: [https://intellij-support.jetbrains.com/hc/en-us/articles/206544839-How-to-manage-projects-under-Version-Control-Systems](https://intellij-support.jetbrains.com/hc/en-us/articles/206544839-How-to-manage-projects-under-Version-Control-Systems)
&gt;what's the point The point would be learning and practice and better understanding of the concepts involved, necessary tradeoffs, importance of documentation, testing, etc.
I think you only read part of my comment, or misunderstood its meaning. I'm saying do it!
IIRC storm will complain about stuff not matching...
Except for the code style settings. I'm actually about to start pushing up just that bit. The .editorconfig peoe use now a days isn't enough rules to share between imo
Use a standalone tool like CS Fixer which you can run on CI and enforce across the entire team.
I've added based on this feedback in this thread. Thanks for pointing that out though!
Sorry I should have shared more context. PHPStorms Fixer is better than PHP CI in the sense that It will also do the typescript / html / vue code along with PHP. PHP CI only does PHP which is great, but im not trying to run 2-3 formatters ya know? This way team can just check reformat code when pushing up to Git. dont even need to think about it
There is a difference between "IDE settings" (aka colour scheme, plugins) and "Project settings" (aka inspections, run configurations, libraries and etc.). PhpStorm allows to share "Project Settings" so that everyone is on the same page, but a lot of times I tried, developers are very against it, but only because most of them just don't know how this works. &amp;#x200B; I wrote a blurb about it - [https://donis.github.io/phpstorm/the-benefits-of-adding-your-idea-folder-into-vcs/](https://donis.github.io/phpstorm/the-benefits-of-adding-your-idea-folder-into-vcs/#)
It's probably one of the best learning experiences you could get, but you probably don't want to be doing it in production.
We started off by including our entire database scheme in our project - to deal with autocompleting SQL queries. Was a small step, took some getting used to. Then, my next step was to actually include both the Code Style and Inspections. This was a bit difficult, as different Phpstorm versions format those files differently, leading to some weird commits because people weren't paying attention Trailing new lines, a newer setting being turned on/off. Next step is to look at PHP CS, or something along those lines, although I myself am a bit hesitant. I like having guidelines, and I do enforce those during code reviews, but I'm not at all that comfortable having it enforced upon me by a tool, rather than human eyes
The main takeaway from the CI suggestion is the developers don't get to choose if they fix the CS, In our case the build fails if they don't. Having specific linters / checkers usually means they can be way more powerful and specific since they only deal with the one language of interest. You can easily add specific checkers for each language with Docker, adding it to a pre-push Git Hook is then a no brainer. You end up using the exact same setup on your dev's workstations as on CI, this type of setup server my team well.
My issue with it has generally been that not everyone uses the same editor. If I commit my project settings from IDEA, why shouldn't someone else commit theirs for Eclipse, or Sublime, or vim, etc? This just clutters your codebase. It would be better to provide proper tooling to enforce your coding standards and best practices and allow developers to configure their IDE's project settings as they like. If your team has decided to standardize on a single IDE though, I see so no issues with committing project settings.
I never really understood the argument of "clutters your codebase". What does it even mean? It's a bunch of files in a folder that you never even need to look at if you're not using that IDE. It doesn't weigh a lot too and with most smart IDEs it doesn't even show up in search results. Some tooling, like PhpStorm inspections, just can't be automated.
I had a quick look at Rx, but it doesn't seem nearly as mature and widely supported as JSON Schema. Am I somehow misinformed? Wondering of there are systems that already use this and thus warrant inheriting this validation.
The two biggest hurdles in using a custom framework in production are maintenance (both code and documentation - very time consuming) and security (easy to get wrong). If you have the time and experience to do it right then by all means, use it in production, but most people genuinely don't. It's generally faster, safer, and cheaper to leverage third-party frameworks. A better alternative to writing everything yourself is to glue together third-party components into a custom framework - select a router, a DI container, a templating engine, a database layer, etc. and tie them all together as you need. You'll still encounter some of the same hurdles but to a significantly lesser degree.
Yes, do it and put it into production. I'm assuming you know how to code properly with best practices, inheritance and so on. Also that you comment/document the code for anyone else that needs to maintain it. Why? Well, you created it. So you can maintain 100% of it. Try fixing some bug in some other framework you have no control of. Maybe it's fixed in the next major 4.0.0 revision but you have to rewrite a ton of code to upgrade. When using somebody else's framework, they're in control. You use it like a black box. With your own code you can modify anything to your liking. You're in charge of your product's destiny. Also when you need to hire more staff, you put PHP in the job requirements. If you used a framework you need to add PHP, Symfony, Twig, Doctrine etc requirements. Now you're looking for someone much more specialised as there are other frameworks out there and they will be much harder to find. I have no problems using some of the libraries of some of these micro frameworks if you need to get something complicated done.
nice reminder of magic methods behavior an isset(), completely forgot about that I am not using magic in my projects but now I am working with little bit obsolete code-bases where is everything magic so this is my daily problem :D thx for that
I 100% agree with your technical reasons. However, discouraging people to write their own is wrong. This is how monopolies start. It's always good to have a choice of frameworks.
The [documentation](http://rx.codesimply.com/faq.html#why-not-use) on Rx says: &gt; [JSON Schema](http://json-schema.org/) is fairly similar in conception to Rx, but is more complex to implement and is less straightforward to safely extend with more types. It does offer some features that Rx does not, like subclassing and references. I simply disagree with all of that. More complex? It's just slightly different. Less straightforward to extend? Honestly, the documentation on Rx is lacking too much to give that a fair comparison, although that in and of itself makes Rx less straightforward in this case. &amp;#x200B; I'm not here to say you should use one over the other. It just looks like a niche product to me and I'm honestly wondering what need the author of this library had for it.
I was going to make a comment similar to this but judging by the comments I'm seeing this is actually very helpful to quite a lot of people.
I think there are some good cases to use isset, but the amount is definitely shrinking as more and more libraries take over input validation and other lower level stuff. I totally agree on empty though. I avoid that bitch like the plague.
I usually dislike micro optimisations but since this one can actually be automated completely I think it's pretty useful to know and 'enable'.
It's an abstraction.
I'm so glad I use Eloquent.
Wait did I miss the memo that `X-API-Key` is not the default authorization header for every REST API?
Still potentially dangerous here is that you don't want to allow users to fetch hundreds of millions of records at once.
I'm using a few files commited to the repo to be shared with other team members: ``` .idea/ codeStyleSettings.xml codeStyles/ Project.xml codeStyleConfig.xml inspectionProfiles/ Project_Default.xml ``` I believe `codeStyleSettings.xml` is obsolete, need to check this :-) Essentially, only inspections and code styles are shared. Yes, something newer versions or EAP change something =&gt; if not everyone in the team is using the same version, it's an annoying forth/back thing. Better keep team members using PS on a short leash and require them to use the same version ü§∑‚Äç‚ôÄÔ∏è code style is nice but I still recommend a tool which is IDE independent for the "truth of source". Although not free, my team is quite happy with https://styleci.io . It doesn't get better then auto-commiting to your pushed code so the style is fixed automatically. Inspection OTOH are really very very useful and I can't see there's real replacement outside the IDE for this. This way you ensure every team member using PS sees the same warnings/errors. You might argue that takes away individuality (and personally I'm all for individual configurations), but when you see people constantly make small mistakes which could have been avoided with the inspection, you might want to reconsider.
My use case is actually for YAML validation, not JSON, and the documentation is from the original Rx library, I didn‚Äôt write it. The php-rx library is an update of the original PHP code from the Rx library which is/was about 7 years old and doesn‚Äôt support modern PHP coding standards. I suppose I could convert the YAML to JSON and then validate it with JSON-schema, but this library seems to support what I need for now and may work for others too.
The reason the code base is split from the main Rx library is because of packagist restrictions of multi-language repos. Perhaps there‚Äôs a solution to that but I haven‚Äôt found one. Also, I wanted something that could drop into a CI workflow like phpunit without further coding, so it‚Äôs partly a library and partly a tool. The general format of an Rx schema is really straight forward in my opinion. I used https://blog.picnic.nl/how-to-use-yaml-schema-to-validate-your-yaml-files-c82c049c2097 for inspiration when designing the `rx` bin file. I‚Äôll have a look at JSON-schema for comparison when I have time.
I'll try that out. Thanks
&gt; Do it for fun, never do it for production. Why would you put a burden on your future colleagues to deal with your version of a framework, which, let's admit that, will never reach the quality, ease of use and documentation of an open source one which has eyes of literally hundreds of people reviewing the code. I hate this self-defeatist attitude. You may be right for many inexperienced developers, yes. But also all the mainstream frameworks have the same flaw: they're highly monolithic, over their lifetime increasingly overdesigned and bloated, and because "hundreds of people" are working on the code, every new fancy fad gets immediately integrated and slaps some more fat on this framework's ass. I've worked with custom frameworks (from colleagues) before which are NOTHING like what you can get in the FOSS world. Highly advanced, highly modular, and I've had my eyes open that there's more to PHP architecture in this world than the tired flat (and terribly primitive) `/controllers`, `/models` and `/views`, that there's better way for handling persistence than Doctrine-style ORMs and there are better ways to do injection than writing tons of YAML/XML or relying on counter-productive annotations. We need more variety out there. More new ideas. And if we constantly put down everyone willing to try making something, then we'll never get there.
If it's so better, why don't you share some of them and make them open source? Or give some concrete examples? Symfony 4 is highly modular (although I would even call 3 as such). I'm not convinced you actually saw any of the latest frameworks out there or even used them if you think they are "primitive". It's sounds like you hate them because of some personal reasons
I've nothing to prove here. I just said, don't discourage people from trying new approaches. The open source frameworks ARE NOT STATE OF THE ART. To explain and demonstrate why would take a whole presentation and that's not the place for it.
Perhaps you've been lucky, because I've never seen an easier to use, well documented and tested, custom made framework than anything out there. I didn't say they're state of the art, I'm just saying that the amount of effort that's been put by collective thought and dozens of smart and experienced people most likely won't match in house framework built by a team or two. Learn from what's out there, adapt, improve (make it state of the art), contribute back and everyone will benefit.
It's so great, it's so best, it's so amazing, yet you feel so insecure about it, you feel the need to respond to my simple plea for more innovation in the space. What is this, honestly? Are you a Symfony user, or a Symfony groupie?
I would never write a CMS. All CMS'es are shit because it's an impossible trade-off between ease of use and broad functionality. So you end up with either something underpowered or something too complicated.
I can say the same about laravel, slim, zend or other oss components that might form a framework (except codeigniter) Innovation happens with collaboration and contribution. You couldn't come up with a single example to back your statements. I welcome all innovation. Feel free to show some innovative code with your next comment that puts "my favourite" framework into the closet together with mainframes.
I get more joy out of writing plugins for an existing framework since they might actually be used. Making your own or extending one is a fun hobby though, whatever floats your boat!
Learning this just made my day.
Frameworks that we use today were someone's pet project at some point and eventually received community support because of either doing things right or just pure luck. The point is that if you do create a framework please release it as open source. If you'll just use it for internal own projects you're probably better off using an established framework
It seems easier to just not commit the `.idea` directory at all than to nitpick through the gitignore. Also, I think these items should be in the global gitignore instead of the project.
I think everyone should write a crappy framework of the things you want to serve one purpose. Then when you eventually throw it out, you don‚Äôt do it because ‚Äúfuck this‚Äù you have a reason why. You understand the concepts. You get ‚Äúit‚Äù. I challenged myself to make a whole framework from the PHP League components. It was meh, it sucked really. But, I learned a LOT. Kuddos man, good luck!
I mean, I don't intend this to be a *crappy* framework. I've written many "frameworks" and bespoke web applications, but none of them have been actual projects in which I set out to create a *good* framework. I have the experience of finding Laravel after having already "gotten it" for most of what it provided that I'd already painstakingly done myself in many projects. I feel I've already learned all I could learn from creating throwaway projects. The issue I'm having is of having not created many lasting projects with much value, so for this I'm trying to up my game considerably.
Sorry, wasn‚Äôt trying to be a jerk. It‚Äôs just nearly everyone‚Äôs 1.0 framework sucks in some unique way or another. It‚Äôs not personal or an attack. I‚Äôm just a shitty blunt person is all.
I think *every* framework sucks in *some* way, that's why I don't think anyone should be discouraged from creating new ones. No language, framework or library ever seems to turn out perfect for every situation, which is why it's good that there are so many programmers with varied approaches to fill in all the gaps.
Call me when Symfony and Laravel move from a DI container that's functionally identical to a service locator.
It depends on what you're trying to do, and what your motivations are. I think what much of the "build it then throw it away" people are really saying is "most frameworks end up being crap, or clones of crap"..... but that isn't to say yours will be, and a lot of that is going to come down to motivation. If you intend to build for yourself, and only yourself - go for it! If you intend to build something for everyone and you think you have an innovative take on the solution - go for it!, but be aware that inertia is a bitch and adoption may be limited unless you have a really compelling reason for people to switch. If you intend to build something which is a clone of much of what is already out there - and you intend to build it for everyone else.... maybe consider contributing to existing frameworks instead. I say consider.. it's not the law, you can of course do whatever you want. But the you are not likely to get much traction on your idea and the community necessary to sustain a larvel project if it's just another Laravel/Cake/Symfony/Yii/Whatever clone.
Regarding the post itself, I would change it completely. It doesn't work this way - you don't ask a passer by to work on your project just to pass a time. The only way to get issues and pull requests is to make people actually use your library. So a plea to contribute is superfluous. Instead, I would make this post a gospel about your library, especially because the approach is not so familiar to an average PHP user. Some real life examples where you would demonstrate how much your library made your life easier and the code cleaner would serve the best. Self-praise and boasting also seldom bring faithful followers, this part is also better to be omitted. To mention the framework when you want to present a library is also a not so good move, distracting many readers. You will get a lot of automated comments regarding writing your own framework. Regarding the library, it looks pretty solid. I would only split it into several smaller libraries, if possible. Like, could string manipulation be made into a separate package?
The JSON schema validators I know actually work against PHP data structures, so there is no need to convert to JSON as intermediary. That being said, if this works for you, power to you
Don‚Äôt listen to naysayers in this subreddit. Do what you want and learn.
I've only got about 5 years experience with PHP and I'm self taught so I'm aware there are gaps in my knowledge but I liked your post and I would love to contribute to something like this, where I can. I'll have a look over your code and if I can get to grips with how you do things and I think I can be useful, I wouldn't mind giving time to the project.
Just a heads up: they are not asking whether to it do or not, they are looking for collaborators.
Now I found the possibility to sync config like code style or debuging configuration through a specific repo for settings. Maybe I try this or your solution. Many thanks for your advice
Best learning experience for sure. Worst idea and time wasted also. &amp;#x200B; 10 years ago building a CMS was a good idea because all the available ones were shitty. I've personally built a better version of Drupal (was 6/7 at that time) on top of Symfony2 + Propel as ORM. I started building it 6 months after Symfony 2.0 was released. The reason it was created was to support both website and an API for native mobile app. Popular CMS had no API at that time or it was unusable. At its peak my solution powered 50 websites + 10 mobile apps. It was built with a team of 3 devs during 5 years in a web agency in Paris. So that was cutting edge at that time. It was using jQuery for the backend. I was dreaming of a web app framework like angular/react at that time. Played with backboneJS but it sucked so I sticked to clean code jQuery instead. The learning experience is that unless you have the firepower to maintain and keep it up to date on top of running it, it's gonna die eventually and be replaced by something better. I would never try to build a CMS ever again. Now there's better alternative. I would even pick wordpress because as bad as it sounds, it requires 0 dev and everybody knows the backend UX by heart. I've used Sonata CMS a lot too. Was really cool how you could customize it, but compared to the wordpress UX, it was painful to level up Sonata to this level.
&gt; A a tiny example only... call me when Symfony and Laravel move from a DI container that's functionally identical to a service locator. I don't know about Laravel, but for Symfony that's a complete falsehood. They even deprecated the dirty `ContainerAwareController` 1.5 major versions ago, so now the documented way even allows for unit-tested controllers. Your code practically will not ever see the container in a Symfony application, you'll only get injected dependency everywhere, which is perfect!
While injecting the container is particularly bad, not injecting t doesn‚Äôt solve the problem of ‚Äúeverything has access to everything‚Äù. So no, it‚Äôs precisely a service locator. As long as your controller or view can fetch your raw database by just shoving it in its constructor, don‚Äôt talk to me about architecture.
What are you talking about? Yeah, sure, you can build any kind of monstrosity with those frameworks, but that's the same with custom FW too, or even plain code. You, the programmer, are the ultimate authority on your code, and your framework can not stop you from doing bad stuff, it can only guide you so much. And in that regard, Symfony does it kinda well.
I have added File driver and Redis driver and finished all unit tests yesterday. If you meet any problems when using this library, please let me know.
I rolled what I call an "unframework" last year - it's more of an opinionated boilerplate than an actual framework since it's mostly just glue code for some third party packages, but it's been an interesting experience. Whether I'd use it in production or not, I don't know (probably not), but I definitely learned a lot.
Hah, alright, I see you don't really know the difference between two. Sure, you could use a DI container as a service locator, but show me a php di container that is NOT capable of doing that.
Laravel is a framework, WordPress is a cms. Comparing the two is like comparing an apple to a truck.
You really don't get it, and I don't blame you, but this is why I said I'd take an entire presentation to explain the problems of modern frameworks. Point confirmed I guess, to myself. TLDR; if you care: you are using it as a service locator, there's no other way of using it.
No, Symfony dictates certain directory structure and architecture from the get go, and you're fucked for basically using it. Sure, you can just use the components. And then you're fine, if you know what you're doing. But then that's not the framework.
Your point is just a bunch of empty opinionated words, so no, I'm totally not getting what you're claiming. You said your buddies created a better framework and yet I am still waiting to see just a tiny bit of example from it. You're saying there's no proper DI, yet you don't give a single example. Just blabla all over jumping from one thing to another, mansplaining all the way.
You're still talking about "you're fucked" but not saying anything much after. Please back up your statements with, at least, some arguments.
I gave you a "single example". Every component should have access only to the correct components. So for ex. your controller shouldn't be able to inject itself with the raw database connection. This is a blatant lack of architectural constraint. And the result is what I already called "everything depends on everything". There are no clean lines between modules and layers, because everything shoved into the contained and it's a hand's reach away, by asking for it in your constructor. How this became to be acceptable for some frameworks is beyond me. Many have recognized autoinjection as a pattern. PHP's mainstream frameworks are quite a bit behind.
If my example (database connection is accessible from views and controllers) doesn't ring any alarm bells, then there's not anything I can say that would look like "anything" to you. Architecture is about enforcing structure, separation and constraints. A DI container is a flat soup of dependencies accessible to everything with zero discipline. It's the opposite of architecture.
And I've already answered to that: if you inject the DB in the view, it's YOURS fault as a programmer; you normally inject the repository in the controller and pass the result to the view, nothing more. Yeah, with Doctrine you could have some indirect DB access in the view (due to lazy loading) but that's a trade of, nobody said that ORMs are a silver bullet, on the contrary.
The database example is only the most blatant example I can mention to demonstrate the problem. In a big application, in a large team you will have hundreds and hundreds of components, part of different modules and layers. There is no way to either guide your team about what should be used where, nor a way to prevent them from doing the wrong thing, either on accident, or some workaround late at night due to a coming deadline, that then comes to bite you in the ass. Saying ‚Äúit‚Äôs your fault, the programmer‚Äù is terribly hypocritical. Do use type hints? Do use static analysis? Why do you do that, just drop all this stuff and do things ‚Äúright‚Äù. If you don‚Äôt do them right it‚Äôs your fault, the programmer, no? No. Proper architecture helps and guides you to do the right thing, like types and linters do. It doesn‚Äôt just pour the entire application in a single shared container and then whatever happens, happens. Blame and pointing fingers is not a proper architecture.
&gt; In a big application, in a large team you will have hundreds and hundreds of components, part of different modules and layers. There is no way to either guide your team about what should be used where, nor a way to prevent them from doing the wrong thing, either on accident, or some workaround late at night due to a coming deadline, that then comes to bite you in the ass. Yes there is: it's called leading a dev team, doing code review, teaching and mentoring. I'm not saying that noone will ever do mistakes like that, but every dev should know that a shortcut like that has to be paid (or fixed) later. &gt; Blame and pointing fingers is not a proper architecture. It's not about blame. I just think that, at that level, there's nothing you can do to stop a dev to make a mistake. Even if you start doing manual DI, or creating separate containers to avoid putting stuff in the wrong place, you're still just enforcing custom rules, there's no hard limit to what your devs can do. It's not like you're password-protecting pieces of your code!
I like the approach very much, I can't wait to see how will you use the functional paradigm in the framework itself.
You example perhaps was more clear in your head than for me to read. But thanks for clarifying it. AFAIK with the concept of DI in any other language you will have the same result - anything can ask for anything and it'll be satisfied. It's up to a developer to separate layers of an app, not for a DI. Do you have a particular language/framework in mind?
See, this is the difference between proper dependency injection, and this fake shit that your favorite framework does. In proper dependency injection, you are signing a component to be developed by someone, or a team. Right from the get go you tell them: we give you this, this, this, and this interfaces. This is all you have. You don‚Äôt need to give them the original environment of the app, you don‚Äôt need to give them the actual dependencies. You may give them test doubles, or dev configuration. So, it‚Äôs literally like a password protecting your cold. Because there is a very clear contract about what you have available, what you don‚Äôt have available. And everything else is not even part of their codebase. They have perfect clarity about what they can use. They can‚Äôt just grab things from ‚Äúthe environment‚Äù. Because they don‚Äôt know what the production environment is. They‚Äôre not supposed to know what it is. Otherwise you‚Äôre not developing an isolated, decoupled component. You‚Äôre just lying to yourself and writing a big ball of mud.
&gt;Regarding the library itself, it looks pretty solid. Seriously? Pick the best part you've spotted there. For me this code is one of those emotional blackmails. Honest criticising would make you a jerk shattering someone's passion in context of amount of work put into it (no one would care that it was still needless, tunnel vision work), and approval would be polite, but harmful lie.
Did you really inject DB into views? &amp;#x200B; &gt;A DI container is a flat soup of dependencies accessible to everything with zero discipline &amp;#x200B; And how do you think it is even **possible** to prevent people from doing it? Like people who inject DB into views?
In a proper architecture, there is no conceivable way you can inject the DB in your views. You don‚Äôt know where the database is, you don‚Äôt know what type it is, what name it is, you don‚Äôt know if it even exists. And that‚Äôs my point. The database here is just an example not something that either I or anyone sensible would do. But there are many cases where the problem is much less obvious. In an app with hundreds of components in different layers and modules.
I still don't understand the problem. If you say that you don't inject DB into views, what is the actual problem with Symfony? In fact, with Symfony it is very hard to do. &amp;#x200B; &gt; In an app with hundreds of components in different layers and modules. &amp;#x200B; I can't find any sense here. If you work in Symfony, which has **very** clear docs, how can any problem happen if you just follow them? &amp;#x200B; Symfony can't prevent you from doing stupid things, but it surely tries to stop you. Due to compiled container, lots of errors get detected on first page load; any page, not just the one with bug. This is unique in PHP world, no way some custom solution can match it.
what do you mean by "west"? west germany? how many employees does your company have? / is it late stage VC backed?
You will probably need years of time. And even if you succeed and post it here dumb people will downvote you. How I can know? I recently did it: &amp;#x200B; [https://php-ucms.com/features/](https://php-ucms.com/features/) &amp;#x200B; My CMS / Framework has a new revolutionary **Twig++** Template Engine and offers never seen translation capabilities. After I posted it here, I only got insults and bad words! Also from people who have never used a template engine. Imagine that, people with only 5 years of experience who have never used a template engine try to explain to me why my CMS is allegedly garbage. The pople did not like that I used the term *revolutionary*. My post was made hidden without reason. This subreddit is an ideological symfony-fixed echo chamber. Therefore, you should not expect to find qualified people here, especially if you start completely from scratch. The symfony fascists here will now probably down vote me again, because of this comment...
Thanks for the tips, I was definitely more just interested on getting any sort of idea what people might like to see in the library in order to know how to push it forward and have it be something worthwhile to more than just me. I guess classes and functions could be separated into different libraries but I don't see the value in doing it that way as the classes depend on the functions anyway via a `Functional` trait which can be used by the user to have the same methods provided in their own classes. The classes work by simply forwarding the method calls to the functional functions (still feels silly saying that so much, lol). I'm considering changing that method in various ways to allow users to create and assign their own functions to the classes (and trying to weigh the benefits against the possible risks in allowing that), or at least switch it so I assign functions to the classes rather than the classes just forwarding all calls to the functions - that way I can only assign appropriate functions to the relevant classes. Though one of my goals for these libraries is to try to avoid amounts of "magic" which make IDE support a PITA. This is basically the kind of thing I wanted to be able to discuss with others rather than just naively charging on. I'll see about trying to get the usages of the library outlined better with examples of some sort. I was thorough with the documentation in the GitHub README but all the examples are rather minimal.
Warning heeded, lol. Your framework/template engine looks interesting and it seems a shame that I've never seen it before. I think there really need to be more known quality frameworks than just Symfony and Laravel trying things from different approaches. But unfortunately apart from those two the only other basis' for PHP projects for most people seems to be WordPress, Drupal, writing it from scratch and still using PHP as the templating engine, etc.
&gt; Whoever tells you that this should not be done has probably never dared to. Or they've worked somewhere that inherited an opinionated, undocumented framework written by an ex employee, and now they're stuck dealing with it.
Your original post was downvoted because of how obnoxious it was. What you call Twig++ seems to be to have no actual benefits over writing raw PHP. The point of Twig is really to be a simple mid point between writing actual code and simple markup, once you extend it in this way it loses that simplicity and it‚Äôs original use case. You took something simple and usable and made it _worse_. Then the fact that you wanted to charge $1,000 / year until you ‚Äúrecouped development costs‚Äù as though anyone had asked you to do it and we owed you a favour. This is not how open source development works. Then there is the general way you write practically everywhere: your website, here, your previous posts. You act like you‚Äôre the most talented and original developer to ever be, and anyone who disagrees with you is a fool or a liar or part of some secret symfony cabal against you. The reality is that you need to reevaluate the way you look at the world before anyone will trust you enough to use your product. I certainly wouldn‚Äôt. It‚Äôs not an attitude befitting a public contributor, and is a serious red flag. Your posts aren‚Äôt hidden because they‚Äôre uncool, they‚Äôre hidden because you‚Äôre an ass hole. This is harsh critique because previously you haven‚Äôt heeded it, and you really need to. For the record, before you try to straw man me: I don‚Äôt use symfony, so I‚Äôm not part of that group. I contribute to several open source projects. I use Twig at work.
Take their warning with a grain of salt. Their CMS is one that isn't open source, requires a subscription to license, and, frankly, doesn't seem to offer anything I can't get from well-established open-source packages. When you look at things thru this perspective it makes sense why no one would bite for them. Again, why should a community (especially one that's inherently open-source) be super excited about a closed-soruce subscription required CMS solution that no one has heard of? Their CMS could be a rats nest and you won't know it until you pay $1000 euro. Oh but wait, you can get a free license to use it?! Nope, gotta wait until 2021. Yet our community are the jerks for not fawning over their creation.... TL;DR: PHP UCMS: Here's my cool new CMS! Enjoy! r/PHP Community: Chill out with the buzzwords man. Also the price is steep. PHP UCMS: Fine then, you guys are ungrateful. r/PHP Community: [OK....](https://i.redd.it/72vlpj8gg8331.jpg)
&gt; you should not expect to find qualified people here &gt; The symfony fascists here will now probably down vote me again, because of this comment Yep, sounds about right. When you insult people like you have - just because your feelings are hurt - then they certainly will downvote you. Seems like a self-fulfilling prophecy to me.
I think this might have been useful for me way way back in my 5.6 days, but I haven't done any intl work since I was a WHMCS contractor (I made the i18n domain support). I was under the impression that gettext lost the battle and everyone who needed this sort of stuff used the simplier-to-grok language arrays these days. Anyway, I contributed a quick PR so that the library actually installs w/o a warning. https://github.com/delight-im/PHP-I18N/issues/3
As predicted -1 points within minutes... To my down voters: you are hypersensitive crybabys :) &amp;#x200B; Anyway, if time does not matter, and if you want learn a lot about PHP, then build your own framework. &amp;#x200B; The reason why I did it was that I don't like the existing frameworks. I think a framework should not consist of thousands of PHP files and not many megabytes in size. Frameworks also should not depend on countless third-party components. The mainstream frameworks contain so much code that it is difficult to understand - like voodoo. Because there is so much code in these frameworks, there are probably many vulnerabilities in the code as well. Especially Wordpress is unsafe to a very high degree. Almost every week new security holes. &amp;#x200B; Proof: [https://www.cvedetails.com/vulnerability-list/vendor\_id-2337/product\_id-4096/](https://www.cvedetails.com/vulnerability-list/vendor_id-2337/product_id-4096/) But crazy people use this crap anyway... &amp;#x200B; I think, people who compose something do not deserve to be called *programmers*. They should be called *composers*! &amp;#x200B; Think differently! [https://gifer.com/en/OTO3](https://gifer.com/en/OTO3)
It's not that I don't hear you on that point. I think dealing with legacy-spaghetti is something everyone knowns enough stories about. But the assumption that A) OP doesn't know what he/she is doing and B) would leave behind undocumented code Has nothing to do with the general question "Can I built my own framework", leaving out the fact that we know nothing about the expertise, experience and team OP is working with.
Thanks for your feedback, issue and pull request! Given Gettext‚Äôs widespread usage ‚Äì *not just* in the PHP world, or even, *specifically outside* of the PHP world ‚Äì I don‚Äôt think you can say it has lost the battle in any way. Language arrays are certainly easier to grok (for beginners), but probably everyone who has worked on larger projects with thousands of strings to translate can confirm that such arrays are a poor substitute for anything like Gettext. By the way, we strongly prefer Gettext‚Äôs usage of the original strings as keys, as opposed to ‚Äúartificial‚Äù keys, as well as great quantity (plural) support, extraction and tooling, and I‚Äôm sure many others do as well.
I won't insult you but you have to bear in mind that what you did **is not revolutionary**. Yes, you made a huge effort since you invested a lot of time, but you were solving your own problem - not everyone approach translation the same way you think they should, nor is Twig++ revolutionary. You made claims, but in reality - a lot of people use JavaScript + PHP (or Ruby, Go, Python) in their projects and approach building web apps from entirely different perspective - by using web server as router and combining multiple technologies. That's why it's important that framework of the choice doesn't hinder that. &amp;#x200B; But look at the claims you made: * ***UCMS*** *is a new revolutionary PHP framework* (it isn't). False claim. * **Be ahead** of the times - I could use nuxt.js with Vue or next.js with React and entirely bypass your entire twig engine, plus the upside is: the code I'd end up would be tiny, testable with JS frameworks and easy to navigate. Why would I do everything in PHP just to output some javascript? I can output javascript without resorting for PHP at all. I am, by definition, not ahead of times, I'm actually behind if I do it your way. False claim. * Programming without limits - another false claim. You simply can't make such a claim unless you specify the domain of the limits. You talk about being able to call methods. That's really nothing special.. False claim, it's not without limits. * Programming at a higher level - well, this means you, again, use PHP to output JS - which you don't have to do if you go with newer tools. False claim. * Programming like a god - this one sounds way too childish, it doesn't make you look serious * Programming with magic - no one likes magic, that makes the code convoluted, mysterious (which is bad) and incredibly bad to debug &amp;#x200B; Instead of being angry, why don't you take an objective look at what you did, what bothered people and come to realization that they might be right? Sure, insults suck, but looking past insults - why don't you take people's input seriously? Community didn't like it. There's a reason for it.
&gt; *Predicting forgotten files* How does this work, then?
Why just not use swoole?
&gt; Instead of leaving this logic in the controller or putting it in a model, let's move it to a dedicated class. At Spatie, we call these classes "actions". As a matter of using a pre-existing shared vocabulary, these are more accurately called (via POEAA) [Transaction Scripts](https://www.martinfowler.com/eaaCatalog/transactionScript.html) or Services in the [Service Layer](https://www.martinfowler.com/eaaCatalog/serviceLayer.html); alternatively, via DDD, these would better be called Application Services, or perhaps even Use Cases. Aside from the naming, though, nicely done -- it's just the sort of thing I recommend as the Domain portion of [Action Domain Responder](https://github.com/pmjones/adr/blob/master/ADR.md#model-versus-domain).
&gt; To my down voters: you are hypersensitive crybabys :) The only one crying is you &amp;#x200B; &gt; if you want learn a lot about PHP, then build your own framework You could learn C and Zend Engine. That would put you in that realm of "god programmer" you spoke about. &gt; I think a framework should not consist of thousands of PHP files and not many megabytes in size. You never worked for money they. "Many megabytes" is irrelevant if a team of people can achieve the goal within realistic time frame. That concept escapes you. As I type this, I'm waiting for Ansible to finish playing with a server that's got 512 GB of RAM and 4 M.2 SSD's in raid. You still think "megabytes" are important? &amp;#x200B; &gt; Frameworks also should not depend on countless third-party components They don't depend on countless third parties, they depend on **several**. I'm capable of actually finding the exact number, the exact version, the exact location and what the component (colloquially known as library) does. Each of those is there for a reason, that concept seems to escape you. I'm also capable of removing any library from the framework's dependency if I dislike it and rewrite that part or completely disable it. See, it's much easier to be able to swap out a part for your own than to make an entire thing from ground up. &amp;#x200B; &gt; The mainstream frameworks contain so much code that it is difficult to understand - like voodoo. No, it's not difficult to understand. Source: me. Don't judge others if you're incapable of doing so. &amp;#x200B; &gt; Because there is so much code in these frameworks, there are probably many vulnerabilities in the code as well. That's an **assumption.** You have no proof. You're trying to make it a fact. Trying to make an assumption a fact without proof makes you a liar. That's the definition. &amp;#x200B; &gt; Especially Wordpress is unsafe to a very high degree Wordpress isn't a framework, and even they are aware of their vulnerabilities. Wordpress falls into your design philosophy - "do everything inhouse, it's safer that way" - but hey, you got proof it's not. &gt;I think, people who compose something do not deserve to be called *programmers*. They should be called *composers*! You're entitled to opinion, but if the world worked like you described - before even being able to post shit on reddit - each and every one of us would have to invent an AC/DC motor first, then microchip, then produce entire x86 computer along with the OS. &amp;#x200B; You're so full of shit it's not even funny, it's clear you've never worked with a team or to earn money. You'r a level 2 trying to speak to level 100, thinking you're above. Dunning-Kruger at its finest.
Depends on what you are looking for. If you are looking for bare performance swoole will be faster a bit (C vs Go) until you'll hit the bottleneck of the application itself. Note, most of "easy-to-go" swoole integrations are based on blocking worker mode (similar to rr), to use the rest of swoole features you have to do a huge rework of your application and couple to the library (less to rr in some extent). If your goals are not limited only by performance rr will provide a better development environment. It has been designed as easy-to-go application server framework in which you can create fast extensions by your own.
Actually, I'm not sure that's true. At least, it wasn't: * https://github.com/composer/packagist/issues/340
Thanks for sharing! Well explained in this answer: https://github.com/composer/packagist/issues/340#issuecomment-22861081
Could we see the code for this, sounds pretty cool aha
Yeah, it's nice being able to send a .po file to a translation service and get it back translated while still working. Can't say that about PHP files.
Agreed, plus PO files being standardized, supporting plurals and the fuzzy flag, not containing ‚Äúactive‚Äù (executable) content, and being available across languages and platforms.
Why not in production, what the difference? if Taylor Otwel can make laravel to production, why not the new frameworks. There's no limit in what you can do.
I agree you sir. One of the example is codeigniter 4, they write the framework from the scratch with the goal of not just for fun.
&gt;As a matter of using a pre-existing shared vocabulary, these are more accurately called (via POEAA) Transaction Scripts, or Services in the Service Layer; alternatively, via DDD, these would better be called Application Services, or perhaps even Use Cases. Command/Query-Handler is another common term in that context.
Stripe has always been my go to, they make it really easy and straightforward.
For Europe I've been hearing good things about Mollie.
Wordpress
That putty part sound very creepy to one without any knowledge with modems and so on.
That should be part of your domain code and not be framework dependent. That being said, if your PHP code does anything with actual credit card numbers, you're doing things very very wrong
&gt; A DI container is a flat soup of dependencies accessible to everything This is not entirely true for Symfony, especially since 2017 when they made services private by default: https://symfony.com/blog/new-in-symfony-3-4-services-are-private-by-default
That's really good to hear. I hope your project helps tilt the tide more!
Basically working around the problem. I can't see any reason why you'd need to do something on the 30th of each month. I can however see things like doing something on the last day of the month, last working day, or last Friday etc. This date arithmetic is easier because you can just start at the first day of the month afterwards and work backwards: ``` php &gt; $lastDayOfMonth = (new \DateTime('2019-07-01'))-&gt;sub(new \DateInterval('P1D')); php &gt; echo $lastDayOfMonth-&gt;format('Y-m-d'); 2019-06-30 php &gt; $lastDayOfMonth = (new \DateTime('2020-03-01'))-&gt;sub(new \DateInterval('P1D')); php &gt; echo $lastDayOfMonth-&gt;format('Y-m-d'); 2020-02-29 ```
&gt; Wordpress What the literal fuck?
Just to piggyback on this comment. Don't even take the credit card entry on a form that posts to your server either. Use the popovers or redirect to parent provider with templates. Accepting credit cards via POST then sending to the payment provider via API calls means you have credit card info in memory and makes you more of a target. This includes setting up payment tokens, even if done server to server.
I set up a payment portal through Sage and the only thing I had to do was calculate a hash that validated merchant info and API credentials, the rest was handled by a javascript form
Yea, i know this that to take advantage of swoole you need to rewrite your current app to couroutines etc.
Making a service private only means that it‚Äôs accessible via injection, not via get. This literally means nothing. Because it doesn‚Äôt matter how you get a service, the syntax is irrelevant.
The movement of behavior from model to action is a concern to me. The simplicity of the controller side is really good though!
It's not as hard if you use libraries. For the persistence, a library that connects to the database. So, we don't need to reinvent that wheel. For the view, we could use a template library. Again, we don't need to reinvent it. Then, we could add a library for route (a week of code)/security (a week of code)/validation (and a week of code)/log system (a couple of days) and that's it. Everything else could be a service class (that it could be created case-by-case). The advantage of creating your own framework is flexibility and performance. My current project does this: * index.php (and it calls the routers to "reads" the path and determine which controller to call. It also manages the security. * Load some controller * (optional) The controller reads the user input/router * (optional) The controller validates the user-input (if it is not done in a service-class) * (optional) The controller process the information (service class) * (optional) The controller calls to the service class / database-persistence service class * Finally, the controller calls a template system (or redirect if any). Rinse and repeat x 100 times. And it's way easy to debug because it has fewer moving parts.
You have a hundred dependencies. From dependency X, you need to be able to use only dependencies A, B, C, D and E architecturally. How do you enforce this?
* It depends on the project, but routing is quite easy. * Templating is hard (and it requires documentation) but it's easy to integrate a library. * Persistence/Database is also hard (we don't want to PDO/MysqlI directly), but there are libraries that do that. * Validation's tricky. Because validation must work with the template system (unless you want to do it manually =chore). * Log/Error system, it's easy and it's worth. We don't need a library for that!. Why we need a log system?. Let's say our system fails to connect to the database. We could not show it on the screen but we could store on a log file. * Security. It depends on the project, it could be easy or hard as a nail. * And the service class, that are simple POPO classes (Plain old PHP Object).
Is this not the command pattern?
I was just going to post exactly this. Yes it is.
I like how you went with neither option and still sound like a jerk. Nice one!
I started trying out this pattern using this package - https://github.com/lorisleiva/laravel-actions I definitively like how it feels. As a mainly front-end dev I‚Äôm always thinking in components and using this pattern is quite similar. Each action handles its own authorization, validation and execution. They‚Äôre also queueable, and can be instantiated as a regular object when needed.
We (my team) want to do that too. Debug configuration can be finickle, but on our case it could work as everyone uses the same vagrant machine. Though last time (months ago) we checked, exactly the debug configuration still has dependencies on local host system paths. Need to recheck if that changed. debug and phpunit integration set up are the two worst offenders when it comes to a proper dev env in PS; sadly still (PS: not for me, but not all in my team are used to setting these things up).
Latin America: PayuLatam, Europe: Stripe USA: Paypal | Authorize.net
I was just thinking "This sounds like commands with extra steps"
Overall I don't dislike the idea and intention of this library. The issue I have is the current library structure. Personally I'd prefer to see a `src` folder that the code lives within. This would give the project more consistent structure to match the current best practice. Not spending too much time diving into things, so I could be wrong. But I'd also prefer to see most the actual logic implemented in the classes - with a 'helpers' file of sorts to expose the functional access. (Similar to some of the stuff Laravel does.) Just feels like it could be more consistent that way.
Writing code from scratch is a great way to learn and probably the only way to master. No dogma can challenge that benefit. &amp;#x200B; The attitude against new code is destructive and unrealistic. We had dozens of public web frameworks in the PHP economy. Symfony has a huge piece of the cake now and it is highly unlikely to compete with it on the grand scale. It is fine to use packages and frameworks for many reasons (even if it's a reasonable team preference), but god don't try to gag people who don't do.
Looks pretty neat for smaller projects. I'd be a bit concerned about having the authorization logic in the action since you normally wouldn't be authenticated when running an action from an Artisan Command
I always feel like these guys are just dancing around setting up proper DDD.
I think with these questions one sometimes has to read between the lines. I gather OP prolly meant module/package and not framework.
What's DDD?
[removed]
Domain driven design.
Username fits well
&gt; It's so great, it's so best, it's so amazing, yet you feel so insecure about it, you feel the need ... &gt; You really don't get it, Hi LogicUpgrade. Please try to avoid engaging in passive-aggressive comments here. Either disagree happily with folks, while respecting their view, or disengage. There is no value in fighting in this sub.
Yeah, I was going to put it into a `src` folder. The library is part of a framework which *is* all in a `src` folder (so the path here would be `src/Encase/Functional`). I checked into how Symfony manages its components in order to figure out how to handle building a framework with individual libraries and it does exactly what I'm doing now. In order to have the libraries be more independent I'm guessing it would require figuring out some stuff with git hooks and such - not sure what the real benefit would be to justify the complexity though. I have to disagree with going the helper-to-static-class-method route though. It seems like unnecessary overhead atop of what should be basic calls to simple functions that do things as plainly as possible, and I see no real reason to prefer encapsulating every function in a class.
Thanks. I recently started using class-based, object oriented programming in PHP, but I'm only just now starting to learn all of the different styles and types of approaches that people use.
I'll be the first to admit the second part of my comment was fully opinionated. And is certainly more of a personal thing. To be honest I didn't know that's how Symfony structured their packages. I guess it's a pretty interesting approach, but I'm not sure what the benefit of it are. I'm just confused about that aspect since to 'outside' code, your library is all loaded via composer anyway. So the file structure is really all up to you in that sense - which is why I usually opt to keep the projects root a bit cleaner.
West, as in North America. We are early stage and government as well as self funded from my understanding. I am the only software developer then we have a dev ops guy for the servers and a few other staff members.
Convenience. You could (and probably should) have them setup as proper environment variables, but the convenience of having a .env file that just works, without having to know any commands is useful, and the performance hit for many isn't enough to warrant changing the system.
I think Symfony in release configuration caches the config, routes, the service containers etc. for this exact reason. That gets you the best of both worlds.
Why aren‚Äôt these just [Jobs](https://laravelphp.uk/blog/tutorials/job-within-a-job-scheduling-inception-with-laravel-queues)? Jobs are inherently queueable, can be called from the command line even more easily, tested without any extra work and actually have a similar structure (`handle` as opposed to `execute`). Dispatching them synchronously has the same effect as Actions. Turns out Laravel has had Actions all along ü§∑‚Äç‚ôÇÔ∏è
This is true
Both worlds. So the best of the PHP world is that PHP config is fast. What is the best of the other world, again?
You can load environment variables via PHP code, as well, so this doesn't quite explain the use case. $_ENV += ['KEY' =&gt; 'value', ...];
Viewing and editing config values is more appealing.
PHP is not appealing? Why don't you write all your code in something more appealing then? The config is less than 1% of your code. You're not helping yourself much.
&gt; Whoever tells you that this should not be done has probably never dared to. Or they work in places where there are real legal consequences if you get security wrong. Me: "Hey, I want to make a custom framework for everything!" My Boss: "I see. Please sign this document waiving liability for HIPAA for the company when they use your framework." Me: "On second thought... no, let's not use it in production." I've built more than one custom framework. I am not at all confident enough in my security work to accept the liability that would surely follow for me in either a salaried position or for contracted clients. That said, almost half of the places that I have worked have specifically directed me to propose a custom framework *with* the open source solutions so that they could see more about what the limitations of the existing open source solutions are. I've designed three custom frameworks that have ended up in production, and all three were to support a product that was much more of an application than a website. For instance, one was for an application that did music streaming, similar to how Spotify works. Using something like Symfony there, or god forbid Laravel, would have been awful. But in all but the simplest projects, security concerns are a very real issue that should prevent all but the very best application architects from designing a production framework. I wasn't really ready to take on that challenge until I had over a decade of working experience, and had learned more than one other existing framework so that I could compare and contrast what architecture decisions have what impacts. The reality is that writing software is much easier than designing software, and like you just expressed, many developers are disappointed when they realize this.
.env is a convenience and it‚Äôs designed to be cached the way Laravel does it. Just using regular environment variables isn‚Äôt slow.
I just want to start by saying congrats for publishing something and daring to share it with us. We're not always the kindest of people in the feedback department so it takes some guts putting your stuff out there like this. After reading the docs and examples my biggest question is primarily what it really adds to the table? &amp;#x200B; I might have looked a bit too quickly but alot of it seems to be reimplentations or aliases for functions that already exist in PHP with minor adjustments. To me it hews too close to functionality we already have to be worth using. Some of the functions seem nice though. &amp;#x200B; Another gripe which I can't really justify in a good way is that I dislike that you have class methods and functions which do the same things but return different things (IE arrays vs Collection etc). I would personally prefer it if the functions returned boxed objects just like the object methods do. I know I'm enough of an idiot to make the mistake of thinking the function returns a collection if I've been working with the methods alot. There is also a pattern in some frameworks of having functions as shorthands which return an object. Since you're diverging from that it might lead to some confusion. &amp;#x200B; Last but not least there's no sense of direction or purpose in it when viewed as a framework. You've made a library and that's super awesome but what is your thinking around what the framework is going to be? Who is it catering to? What are the most important problems you want to solve with your framework? All the big PHP frameworks have some kind of philosophy behind them which drives their functionality. &amp;#x200B; My interpretation of Laravel for example is that it prioritizes convenience/ease of use. If you look att Symfony console and Laravel artisan it's pretty much the same functionality (since artisan is based on Symfony console) but the way you express yourself when using them differs. In this particular case I'm flabbergasted that the Symfony team didn't just add a little more syntactic sugar to make it easier/faster to work with. &amp;#x200B; It's a personal thing but $output-&gt;writeln('&lt;comment&gt;foo&lt;/comment&gt;'); just makes my eyes bleed every time. Now they have alot more that you can do with the styles in Symfony but I end up writing shorthand methods myself when using Symfony console. But I'm still impressed by all the things Symfony has just solved to the degree that if anyone else is doing something in the same area you can pretty much bet on a Symfony component being a dependency and a base for that thing. &amp;#x200B; I'm sorry if that was rather long winded but what I'm saying is you have to tell us what you want your framework to be. Right now all we know is that you're trying to build one and that you've made a cool library as a start. Tell us what it implies and where you want to go. &amp;#x200B; Also congrats again for getting it out there. You've done a good thing even if it ends up being useless (I'm not saying it's useless) and don't let the naggers convince you otherwise.
YAML is easier to read and write for some people. It‚Äôs a preference. Symfony, for example, supports PHP, YAML, and XML formats for configuration. Feel free to use whatever satisfies your rubber duck.
&gt; And let‚Äôs be honest. For a large number of sites, that speed impact just doesn‚Äôt matter. To be fair, this isn't about speed... it's about requests per second, which is a measure of overall capacity.
&gt;You have a hundred dependencies. &gt; &gt;From dependency X, you need to be able to use only dependencies A, B, C, D and E architecturally. &gt; &gt;How do you enforce this? &gt; &gt;How do you make it obvious in the code that A, B, C, D and E are available for X writers, if all injection is automatic and there's no interface to implement or look at for reference? &amp;#x200B; This literally makes no sense. I don't know what kind of code you write, but I have never had any problems nor was code unreadable at any point. And because of compiler pass, I can typehint interface and Symfony will warn if there is more than one class implementing it. &amp;#x200B; If you write code like that, it is not Symfony fault. &amp;#x200B; &gt;But... most Symfony apps really have no architecture, beyond a gigantic MVC tumor that wraps your entire app. And that's honestly no architecture at all. &amp;#x200B; So you saw most Symfony apps to make such bold claim? &amp;#x200B; \--- Are you familiar with Dunning-Kruger effect?
[https://stitcher.io/blog/laravel-queueable-actions#what's-the-difference-with-jobs?!?](https://stitcher.io/blog/laravel-queueable-actions#what's-the-difference-with-jobs?!?)
For me it is mostly about maintainability and defensive programming. Yes you could do it in PHP and everyone would set up and distribute their configuration in multiple ways and places. When you onboard new people or move onto new projects, you‚Äôd have to dig through it. It would be easier to accidentally version your secret keys in another PHP file. Similarly you have conventions around package.json, composer.json, .lock files, etc. You could do all this in .php and .js files, but creating specific conventions allows for interoperability, ease of onboarding, maintainability, code reuse, etc. So when joining a new project we all know instantly where to look for different configs; we can create automation scripts for different environments targeting the same files; we can version sample configs and know they exists and where to find them in open source projects. Etc. The hugely minor loss of performance can be mitigated through caching and is insignificant compared to the huge gains in clarity and ease of use when collaborating with others. If you are the only one to touch your code forever, feel free to find your own idiosyncratic approach to config. If, as most/all professional software development today, your work is ultimately collaborative, you will often trade off performance for clarity and shared conventions, because you know it will save you time, money and headaches in the long run.
That's exactly what the article says. &gt;You can call the concept and the method whatever you want. We didn't invent this practice. There are a lot of devs using it already. If you're coming from the DDD-world, you probably noticed that an action is just a command and its handler wrapped together.
Laravel does the same, `.env` files shouldn't be read in production.
&gt; Another gripe which I can't really justify in a good way is that I dislike that you have class methods and functions which do the same things but return different things (IE arrays vs Collection etc). I would personally prefer it if the functions returned boxed objects just like the object methods do. I know I'm enough of an idiot to make the mistake of thinking the function returns a collection if I've been working with the methods alot. There is also a pattern in some frameworks of having functions as shorthands which return an object. Since you're diverging from that it might lead to some confusion. I did consider this concern. Perhaps I'm trying to solve too many questions with too few answers so to speak, but I believe I did even write somewhere in the documentation about that being an aim. It might be misguided of me to think, but I've yet to have any reasons to think otherwise, that to solve a lot with a little ("within reason" - of course that is subjective, which is always the hard part) is a good thing. &gt; Last but not least there's no sense of direction or purpose in it when viewed as a framework... And I agree, my biggest mistake or naivest decision is probably sort of "announcing" this as a framework already. I started building a framework for multiple reasons and decided along the way it's probably best to deal in smaller component libraries for the time being. I started building one [component](https://github.com/Deji69/encase/blob/master/tests/Doc/ParserTest.php) I thought could be useful and needed, but then realised I was kind of sick of dealing directly with native PHP functions and figured it would be much nicer if I could use another library to do programming in a way that this Functional library provides, thus I made it. I was naturally proud of it but as I can admit, I have too few ideas of a direction for it as well as the entire framework (you say the "big PHP frameworks" - of which I can count on one hand - have a core philosophy, but I doubt any achieved their actual success and full functionality without input from multiple developers with different insights), so I wanted to make this post largely to gain an idea for things people might be interested in. Unfortunately since the library is a component of the framework, it's hard to just put out the individual library. I think I thought I might be killing two birds with one stone in just going with that, but instead I think I just threw two stones and probably scared a bird off... I have a tendency to chatter and be overly share-y, which is why I try not to post on Reddit at all becaus... uh, yeah, I'm doing it again... With this, at the very least I hope to make a few decent libraries. If it becomes something, which I'm sure is not likely (but it'd be much less likely if I didn't try), then that will be a great achievement personally. If not, it will still be a great portfolio piece for me and source of experience and growth. Since it is open source, I'm hoping nothing will go to waste, unlike the many bespoke websites I've made which are probably just going to end up as irrecoverable data.
And still for a majority of sites, it's still not a problem worth solving.
&gt; This literally makes no sense. [...] Are you familiar with Dunning-Kruger effect? Hmm. Irony.
Requests per second = Cores * 1 / time taken to process request (i.e. speed)
most devs are not going to have thorough enough knowledge, time, and/or dedication to finish and maintain their own framework in a production environment. that's not meant to discourage people from tinkering, building, and learning by trying, but by no means would i ever encourage someone to roll their own framework in a business environment where a) money is at risk or b) security is a concern. there are projects groups of very knowledgable individuals working on them and even they end up with critical bugs, vulnerabilities, security issues, etc. by all means, the best way to learn is to try your own hand, but do not, i repeat, do not think that you can roll your own framework on a business environment and that it's ok, because it's very not ok.
I don't know if it is convenience. For example, by default, every .php file is compiled (i.e. calling web/someclass.php yields nothing) but the .env file could be exposed because it is just a text file. &amp;#x200B; Als, it is not self-explanatory code (unless we know its meaning).
Composer.json is different. It is not executed for each call but only when we call Composer (and it is only when we add/remove/edit dependencies). Also, it could be also exposed to the Internet.
I think you're overestimating how "very knowledgeable" framework authors are. If I could have a nickle for every stupid shit I've seen in FOSS framework's source...
The JS argument is largely based on Node fanboys. Every plugin you get, which is everything everyone cares about, is PHP. Yes, there are some themes with a lot of Javascript. That isn't new, nearly every theme theme ever written used jQuery and that doesn't seem to be going away. Someone bundled React in the frontend and we got dozens of Medium.com articles about how Wordpress is being rewritten in Javascript. For anything that matters, it's not accurate.
Last I checked Gutenberg (default bundled since 5.0 dropped) is React...
That, plus .env packages often tell you not to use them in production for exactly this reason. All of my projects have a check in place to not even try loading them outside of dev environments, since they're set properly in staging/prod.
&gt; It would be easier to accidentally version your secret keys in another PHP file. I don't know why it would be. In both cases you have an ignore rule based on a file location and/or name. It's not any easier to exclude by extension than by directory (config directory for ex.).
Yup, just keeping it "honest"
Mr. Blade, who told you about your sentience? You are forgetting about blocking operations... specifically those abound in file systems. (i.e. sorry about your wrongness)
I think you missed my point. I was not saying they were similar in functionality; I was saying they were similar in being shared conventions that simplify collaboration across a community of practice, like .env files. Following OP‚Äôs original argument you could do pretty much all of these things in PHP, or JS files for your own program, but giving them distinctive and consistent names and data formats allows us to spot them instantly and recognise them, saves us time collaborating and facilitates predictability (and therefore stability), interoperability and reusability. The similarity is not in how these files are executed or even in what they each actually do. The similarity is that all these files and others are distinguished from the rest of the PHP or JS code through a naming and format convention, in a consistent way, even though they could have been done in a less distinctive, more personalised way within the core languages of the application.
The config can be generated and consumed in non-php contexts.
One drag and drop UI component is yes.
Sure that‚Äôs all very well, if we programmers never make mistakes and get confused. But if we each organise our configurations in totally sui generis ways, when a junior comes along, or a new senior, or you two years later sleep deprived, you might accidentally confuse one of the config files or its dependencies and version it, or change its name, or put a secret key in a different config file to the one where the other keys were, or not realise those keys already existed in a weirdly named PHP file. On the contrary, if you see a .env file and know the conventions, you can, before even looking, already guess what that file will contain, how it will be organised, and what likely dependencies it might have. You will already know where to add or modify core configs, in a predictable way, and although you could still mess it up (people do frequently version their .env files by accident or ignorance), the chances are a bit less, than where everyone names their environment config files differently, and maybe spreads different environment variables across multiple uniquely named files. There might be thousands of PHP files in your application. In most cases there will only be one .env file. That‚Äôs handy and fast. I‚Äôm not saying doing it in your own personalised PHP file/s with their own name and content will necessarily result in a worse result. I am saying there are more vectors for error and the possibilities that it does come back to bite you, or that it simply slows down your fellow devs in times to come, are greater, and so there is value in the practice, as there is in many defensive and maintainable practices which are sometimes more verbose or less performant, but reduce (not eliminate) risk and cognitive load.
The main editing experience I think you mean, with a roadmap to become the theme experience last I checked. First it's none, then it's just one thing (misrepresented too). At what point will you capitulate?
That's often cited, but in most cases the config is highly PHP specific, down to including the names of PHP classes, constructor argument names and values and so on. Composer's config is JSON and that's indeed highly useful for IDEs, which parse out what dependencies you have, and provide relevant UI. But what non-PHP context would, say, your DI container config be "consumed" in? None. You just cut yourself from the ability to pass flexible parameters (like closures, or one-off object instances, etc.) at the expense of gaining... what exactly... is a complete mystery.
Because ideally you'd use them on local development, testing and staging environments, like dotenv, but in your production servers you'll have those env vars injected and read from the OS directly from PHP code, so no need to parse.
Real-world scenario. I had to be in a hospital for a week, my project was transferred to two colleagues. The config was in a YAML file. When I'm back, one of the secret keys changed, they didn't touch the YAML file, but hardcoded the new key in the PHP files. So if we are going to compromise our code, and add pointless formats, parsers, cachers and what not, with the blind hope we'll help the "noobs"... just abandon all hope.
The requirements listed to install and run Wordpress are "A supported PHP version" and until that includes the word "Node", Wordpress is not a Javascript application.
&gt;Let me guess, you've never actually written an app with architecture more complicated than "models, controllers, views" have you. And let me also guess, from what you've said so far, your models are directly Doctrine entities, instead of an encapsulated service, and so a good chunk of your business logic is in the controllers (where it shouldn't be), which also directly interact with the ORM. Basically a typical framework user, writing typical framework spaghetti. &amp;#x200B; Literally **every** part of this is wrong. So let me quote the first thing that came to my mind *what you‚Äôve just said is one of the most insanely idiotic things I have ever heard. At no point in your rambling, incoherent response were you even close to anything that could be considered a rational thought. Everyone in this room is now dumber for having listened to it. I award you no points, and may God have mercy on your soul* &amp;#x200B; &gt;You've never architected a proper app in your life. Unfortunately your framework failed you. &amp;#x200B; My clients disagree with you but I guess you also know my work better than them, right? &amp;#x200B; One of the apps works with millions of euros per month, complex app for estimating market prices by taking data from lots of different sources. So it must be some shitty logic in controller, right? &amp;#x200B; &gt;Tell me, what are the modules / components in a typical app your write? Just name a few for me, off the top of your head? Have you even EVER designed a modular app? That's architecture 101. &amp;#x200B; Recent one relevant to your question: &amp;#x200B; app that follows truck drivers by using different (and weird) API's of many GPS providers. All existing data must be converted to my local database. **Bunch** of other stuff, but modularity is the key here: programmer **only** has to implement 1 interface to configure connection (basic auth, jwt, soap, api key... end points) per GPS and write DTO classes to map response for both import and export. Everything else is already handled in code which doesn't even know where it gets its data; interfaces are important. &amp;#x200B; Code is 100% typehinted, green on phpstan-max level. &amp;#x200B; Happy? &amp;#x200B; Or let me guess; it is not correct somehow? Or that it doesn't work? Or there is some magical container injected? Please enlighten me, oh you knowledgeable one. &amp;#x200B; &gt;[https://www.codeproject.com/Articles/1239583/The-IOC-Container-Anti-Pattern](https://www.codeproject.com/Articles/1239583/The-IOC-Container-Anti-Pattern) &amp;#x200B; So... one opinionated article is right, thousand others are wrong? &amp;#x200B; Let me guess; NASA faked moon landing, 9/11 is inside job, Earth is flat... &gt;Notes: a couple of points refer to specific C# implementation details, but the rest are general and apply to PHP's DI containers entirely (including Symfony). &amp;#x200B; Nah... you don't know anything about Symfony and only spew nonsense. You only read some shitty code or wrote one and then you blame SF for that.
Fair points all. That is why I said that having conventions is not fool proof, nor ignoring them is a guarantee of disaster. It just reduces risk and cognitive load, most of the time, for a majority of people. I‚Äôm not saying it‚Äôs a magic bullet, just that these things did not emerge in a vacuum and have not been sustained simply because we like to add stuff. It‚Äôs just a (generally) helpful practice. I should also have added that, as with all good practices, they are rules of thumb and not dogmas to be followed at all costs. They do not suit all use cases, and you‚Äôve identified some good ones there where different approaches could be valid. Having conventions is useful, not just to protect noobs but to reduce cognitive load and speed up or simplify processes. Knowing when not to follow conventions is also a good thing, that takes even more know how and experience. Babies and bath water. Sometimes you need to change the water, of a specific implementation. But there is value in keeping the baby of shared conventions and good practices overall.
Fair points all. That is why I said that having conventions is not fool proof, nor ignoring them is a guarantee of disaster. It just reduces risk and cognitive load, most of the time, for a majority of people. I‚Äôm not saying it‚Äôs a magic bullet, just that these things did not emerge in a vacuum and have not been sustained simply because we like to add stuff. It‚Äôs just a (generally) helpful practice. I should also have added that, as with all good practices, they are rules of thumb and not dogmas to be followed at all costs. They do not suit all use cases, and you‚Äôve identified some good ones there where different approaches could be valid. Having conventions is useful, not just to protect noobs but to reduce cognitive load and speed up or simplify processes. Knowing when not to follow conventions is also a good thing, that takes even more know how and experience. Babies and bath water. Sometimes you need to change the water, of a specific implementation. But there is value in keeping the baby of shared conventions and good practices overall.
The thread is about parsing YAML, which is CPU / Memory bound. Opcache usually handles caching the file data so that doesn't even hit disk. For a more in depth explanation of RPS including profiling blocking calls, see my post here: https://www.reddit.com/r/PHP/comments/auz2il/high_volume_tuning_php_fpm_on_nginx/ehbhaeg/
The question: *Tell me, what are the modules / components in a typical app your write? Just name a few for me, off the top of your head?* The answer, supposedly: *Rambling on and on, includes remarks about PHPStan, API endpoints, including saying "modularity is key", except doesn't name the modules the app is made of.* The question was, what modules is your app made of. Or is it just "the app". Writing an interface for your GPS tracker doesn't magically spawn application modularity. &gt; So... one opinionated article is right, thousand others are wrong? Actually if you ever bothered looking, you'll find plenty of articles with the same opinion. They mostly come from veterans with experience, who have a clue. Like the author in question, who's a senior architect.
A DI container isn‚Äôt a good example of the value of portable configuration because it‚Äôs tightly coupled to the language that uses it. In this case, the value is maintainability and readability. As long as it‚Äôs parsed and cached, there are very little negative tradeoffs. A better example is the .env file. Where I work, the .env file is used in multiple contexts. - It‚Äôs generated by a cli app that fetches the employees development secrets. - It‚Äôs consumed by Docker to parametrize certain aspects of our build process. - It‚Äôs consumed by our Symfony app that contains our API‚Äôs and domain layer. - It‚Äôs consumed by the node.js app that builds are our frontend.
I applaud your concern regarding security. This certainly should not be neglected. However, especially High-Security applications normally require proprietary software without any dependencies (or do you know of an open source license accepting liability?) And as you also stated accurately: not every framework needs to be an all-purpose framework. Recently the Laravel community was concerned with a security issue that in my opinion wasn't one. The gist of it was that the documentation didn't specify enough on when to securely use a particular function. It showed how most developers never even bother to understand what code they are using. Nothing is as unknown to most developers as what is happening in their vendor and node_modules folder. Solving certain problems on your own (e.g. by creating your own framework) will automatically get you to look into existing solutions way deeper than apparently people normally would.
On a completely different note: I'd be interested in your frameworks. Wanna share a GitHub link?
 I know his has been stated a few times already, but it is a matter of better ease of maintenance. JSON and YAML are just easier to red and update than PHP code. But it should always be cached after being parsed into PHP objects/primitives. If you aren't, then of course you are going to have performance issues. The same applies equally to templating languages like Twog and Blade (and Smarty etc) and all good frameworks should do this already.
&gt;The question was, what modules is your app made of. Or is it just "the app: /m /v /c". Writing an interface for your GPS tracker doesn't magically spawn application modularity. I mean I'm not saying any of this is bad, congrats on... writing a SPI... and shit, but it's just not what I asked. &amp;#x200B; What you do want; FQCN? Actual code? DDD vs MVC structure? &amp;#x200B; &gt;I'll be posting one more every time I reply. &amp;#x200B; And I will be replying: [https://wiki.tfes.org/Flat\_Earth\_-\_Frequently\_Asked\_Questions](https://wiki.tfes.org/Flat_Earth_-_Frequently_Asked_Questions) &amp;#x200B; Don't believe the masses and wake up, the Earth is flat!
&gt; What you do want; FQCN? Actual code? DDD vs MVC structure? Honestly it's like we don't even speak the same language. I mean the easiest question for a modular design is "what your modules are called". And maybe "what is their responsibility", but I thought I'd start with the easy stuff. Alas. The only thing this tells me your app is monolithic. You have one module. And it's called "the entire app". That's, sigh, cool I guess. The thing is, monolithic architecture is not bad at all for small to medium apps. But if you ever decide to grow, the framework won't let you. Time for article... And one Reddit comment... https://help.semmle.com/wiki/display/JAVA/Avoid+autowiringhttps://www.reddit.com/r/PHP/comments/6mx206/standalone_autowiring_di_container/dk5qjq9/
AFAIK, Opcache only caches PHP files, not other files or data.
Opcache isn't Omnipresentcache
I suspect I might be thinking back to wincache.
In my current job which is a HIPAA environment we only use things that are HIPAA compliant (most but not all services in AWS for instance), or we do an in house audit of the entire proposed library which is a lengthy process. There are some short cuts though. For instance the AWS SDK is developed and maintained by AWS and is acceptable to use for the services which are themselves compliant. Others, like Monolog, are smaller and very specific in function, so the compliance audit is reasonable. Frameworks are not really possible to do this with in applications that handle PHI. We do try to create smaller applications so that some don't handle PHI at all, or have access to databases with PHI in them. OSS licenses all specifically disclaim liability. All of them. But an audit on one is generally less taxing than constantly reviewing a custom built one (though not always, we have custom ones as well). For links to the custom frameworks I've designed on GitHub, they are all the IP of the employers I created them for, and are not open source. I do have open source projects I created though. The most developed one is Fermat, an arbitrary precision, object oriented math library that includes trig and stats functions. https://github.com/JordanRL/Fermat
That is harder to edit and add stuff to than a dotenv, also, it will only work with your php app. I have a dotenv file with variables used by the build system, apache, and some other places. So a single dotenv instead of having an apache config file, docker config file, and a php config file.
IF you have your raw .env files in production, you definitely shouldn't have them in a publicly accessible folder.
Eh, it's command with *fewer* steps. Pure command pattern just dispatches the command event, which inherently means you need a whole command bus and need to bind command listeners. This just executes like a function. Architecturally, it's night and day different from the command pattern, and this is WAY simpler. Really, this pattern has more in common with functional programming than commands. So one could argue "This sounds like functional programming with extra steps". Clearly the ceremony of defining an entire class that ultimately invokes just one public method is like a more complicated version of a simple function. The one key difference though, is you get the benefits of automatic dependency injection and the inherent testability that comes with it, *without* having to pollute the call signature of the function with its dependencies.
This is very different from command/query handler. Commands don't actually execute anything. Commands are statements that some action is happening, and some other handler(s) bound to the command bus then execute it. This pattern is architecturally very different (and a lot simpler, and more predictable, and easier to trace and debug IMO).
If it's read by other apps in practice (not just in a "nice to have" theory) then yes, makes sense.
What is concerning about it? Data models like Eloquent's should only encapsulate their own state and behavior that relates only to them. It would be exceptionally strange (and sloppy design) if the `Post` model had access to the TwitterAPI and Flash functionality. It's not the model's responsibility to utilize those services. `$post-&gt;markAsPublished();` is perfect encapsulation and thus that's exactly where it belongs. But the other side effects (calling the twitter API and setting the flash message) are context-dependent and should not be baked into the model.
How does using a dotEnv file compromise code? If you are only doing things with php and absolutely nothing else and have no plans to change anything or include infrastructure or shell scripts into your code, then sure, keep a php file. (but you will be bucking convention and cause everyone new who looks at your code to have to lookup where your config stuff goes.) &amp;#x200B; I have a monorepo with my infrastructure as code, server configs, everything in a single top level dotEnv. Additionally, there is a .env.example file with a dummy structure and all .env are gitignored. So they never get pushed into the live repo and can't accidentally be pushed in by other developers. &amp;#x200B; During the build process, my build system generates a .env file based on parameters stored in a secure storage. The build process then runs a simple php script that parses the .env file and creates a .php file that defines all variables as globals and this file is included with every page load. &amp;#x200B; Locally, things can just read dynamically from the .env file because the app knows to fall back to parse the .env if the globals php file is not there. &amp;#x200B; This allows me to have a single config file used by docker, terraform, some shell scripts, and even my makefile. &amp;#x200B; If I need to change a database password, I do it in one place and php picks it up, as does docker and my infrastructure. If I just hardcoded a php file with my config data and secrets, then I would also need a separate dotEnv file for the other stuff and everyone working on the project would have to do the same.
This is a php script I put with my projects. You shouldn't include the .env in your code repository, so mine are generated dynamically from a secrets store. In my case, usually it is mounted as a kubernetes secret on the php container. This script runs either during the build process only or at server reboot, depending on how I want to configure it. The credentials.php file is included on load of anything on the site so I can access the globals as needed. This allows me to have a single .env file for all the different parts of the system. Docker, K8s, Apache, PHP, etc. Some frameworks do this automatically (cache the dotEnv file). `&lt;?php` `//put path to where your credentials file should be stored` `$creds_file = '/var/www/html/credentials.php';` `require_once __DIR__ . '/../../vendor/autoload.php';` `$factory = new Dotenv\Environment\DotenvFactory([` `new Dotenv\Environment\Adapter\ArrayAdapter(),` `]);` `//path of dotEnv file` `$env_path = '/var/secrets';` `$env_file = '.env';` `$dotenv = Dotenv\Dotenv::create($env_path,$env_file,$factory);` `file_put_contents($creds_file,"&lt;?php\n");` `$vars = $dotenv-&gt;load();` `foreach ($vars as $key=&gt;$var) {` `$line = sprintf("\ndefine('%s','%s');",$key,$var);` `file_put_contents($creds_file,$line,FILE_APPEND);` `}`
It's always 'nice to have' for me though, because I assume that eventually, I will have other parts of the growing system that will need that config/secrets data.
Hmm, I dunno. I have problem with nice-to-haves. Because you could easily have your specific configs, and the moment you need to share a secret between them... then those specific configs can read and integrate the shared config. Let's say I have a PHP config: $_ENV += get_env_or_whatever($locationToEnv); $_ENV += [ ... rest of config ... ];
Out of the box, it has stubs for passkey (via headers, POST, field or GET param), X-API-Key headers, OAuth2, and it has support for completely custom auth, too.
Then you are back to editing two separate files if you have a variable that is needed in both places.
I was moreso going for the "That just sounds like x with extra steps" from Rick and Morty, but I do appreciate the insight.
Last time I checked, `const foo='bar'` was quite a bit faster than `define('foo', 'bar')`; you might want to update to that. It's probably a micro-optimization, but there was a time when a significant amount of our startup was spent on calling define.
If you like the feel of it when you‚Äôre using your library then that‚Äôs what you should go for. I don‚Äôt know if the gripe with the functions vs objects is something that would bother me if I actually used it for real. It was just something that caught my eye when I looked at the code and the examples. I seem to remember that Laravel also has/had some idiosyncrasies around when you get a collection back and when you just get an array. Your split is very obvious and consistent in the sense that functions returm simple data structures and object methods return objects/collections. I‚Äôm guilty of rolling my own framework way back in the day and even though I enjoyed using it the biggest benefit was learning what kind of problems you need to solve and how when you build a ‚Äùcomplete‚Äù framework. Building a router for example or trying to build your own ORM is a good exercise and at least for me it helped realize what I like code wise and develop how I express myself in code. My ORM was jquery inspired in the sense that methods could take varying amount of arguments and did different things depending on the type of those arguments. A total travesty in hindsight but man was that fun to build. It also ended up being the thing I had to fix again and again since I baked in so many possibilities which all had their edge cases. Having all these awesome mature frameworks is a luxury but I sometimes miss the old west when these problems weren‚Äôt as solved as they are today. But not really. Good luck building it out and I‚Äôll make sure to check back to see which direction you end up going with it. Have fun and explore. It‚Äôs yours so you get to decide!
You tell us. How do you learn best? Personally I like books but I also watch videos and read tutorials too.
I learned PHP with a book and JavaScript with a video course. I personally would prefer the book, because you can just search for something if you don't remember and learn in your own speed. Maybe if you find a good tutorial on YouTube you can use this, but don't be scared of books with about 1000 sites, PHP is a complex to learn especially if it's the first programming/scripting language you learn.
No one can tell you the best way to learn. What is it you're really asking?
Laravel does it with config files, not envs....
Uh-la-la someone's getting laid in college.
Learn the basics and then start building stuff.
This felt odd to me: &gt; To me, it's a bit dirty that a non-cruddy action lives in a crud controller. CRUD should at best be a starting point for the methods of an API, controller, or whatever. Trying to confine everything to pristine CRUD is the exact opposite of what one should be doing. A domain should be expressive, the words should mean something in human language. I read an article poking fun at how REST APIs try to shove everything in CRUD terms: &gt; Today I updated my CarDriverSeat with my body, and created an EngineIgnition, but the FuelTank deleted itself Other than this, separating the business logic from the controllers should be something we all do now, it should be obvious: don't couple business logic and presentation. While many think only the view is "presentation" in fact the entire MVC pattern is presentational, and the only abstract element of it is the model. The view is the presentation itself, and the controller drives the presentation. So there should be no business logic in "VC". And therefore these "actions" or I just call them services in my apps, are the model, which is where the business logic goes.
If you're worrying about disk access, you're worrying about the wrong thing. That is, if accessing a config file, regardless of its format, cache-status, or whatever, has an actual impact on your application, then you've done something stupid. And I do mean to use the word "stupid." It is a value judgement, not a comment on ignorance or an inconsequential preference like where to put your curly braces. It is an example of an objectively bad decision that should and could be avoided if you would care to do some research. Either you're doing something obviously contrary to technical recommendations, such as hosting your configuration across a network connection, or you're doing something due to hubris, such as insisting on being the sole architect of a system where the scope of the project is outside of your technical ability and experience.
&gt; As a matter of using a pre-existing shared vocabulary, these are more accurately called (via POEAA) Transaction Scripts, or Services in the Service Layer; alternatively, via DDD, these would better be called Application Services, or perhaps even Use Cases. I avoid the term Transaction Scripts, because Martin Fowler and co. have attempted to put some sort of semi-derogatory meaning in it. While those are literally just methods on an object that do a thing. There's literally no other way to interact with a system. The alternatives do the same, but call it in other ways.
I'm not worrying about anything... I'm just agreeing with the point that accessing a cached config file allows for more requests per second than accessing and parsing the raw file. Also, that the speed of individual requests doesn't have a linear effect on overall throughput.
Functional programming, despite the name, isn't categorically defined by the presence of functions, but rather by lazy evalutation, immutable state and high-order composition patterns.
You shouldn't have .env files in production. But let's ignore that. We live in a world where computers are insanely powerful. Also filesystems are quite optimized. And all in all, your average application will be way less popular than you imagine. You should stop worrying about the time and effort it takes for your servers to parse a 10-lines text-file. It's completely irrelevant.
Do we need a package for what's basically is... let's write a class and let's call a method on it?
Even Eric Evans has thrown his hands in the air and declared there's no "proper" DDD in the real world. So let's not be so dogmatic.
Dogma Driven Development /s
That "action" is semantically a part of the model. In fact what is shown as "model" here is just a model of the database record, it's not a domain model, or rather it shouldn't be as it doesn't properly encapsulate the business logic of the domain.
Google. There is an interesting phenomenon can be observed nowadays. Everyone thinks they can use Google. And consider it thrown in their face, if you tell them "learn to use Google", taking it as "learn to wipe your arse". Yet, even for such a frequent question, they run for the community, "wipe my arse", tell me an answer to the question that is asked every day and has 100500 answers already.
Son, I've been coding in PHP for so long that the vast majority of my career, `define()` was the *only* way outside of classes.
&gt;Laravel does the ~~same~~ better ftfy
Yep, they're all compiled to php and cached, so it makes absolutely no difference which method you define things by.
As have I. Back then I used to use [hidef](https://pecl.php.net/package/hidef), then `apc_load_constants`, now I use const. Just offering a tip.
1. Don't use these in production. 2. Any framework worth its salt is generating PHP cache from these, so that OpCache comes into play.
Ooof. Missed that part. Thanks
Thanks for the tip. Will be an easy change either way.
All three are good and google everything, Stackoverflow will be your best friend. What you would use off the top of your head might have 50 upvotes, but usually there is an answer with a 1000 upvotes and often comes with sample code. Concentrate on good quality code rather than writing spaghetti code. Functions and object methods should be very short. Read books on refactoring and try and improve your first efforts before going on. Read TDD by Kent Beck as your first stop, I did it in php though its examples are in Java. Create a broken test, implement (make it work don't worry if it is ugly code), refactor (make the working code better), repeat. The steps in the cyle should be very short. Explore the refactoring functionalities in IDEs like phpstorm. Refactoring to Design Patterns is a great book. Try the factory pattern just to see how they work. If there is something you want to do look up design patterns on wikipedia and see if there is any patterns that you can apply. It also has sample code to get you started. Start using a good methodology with TDD and BDD. When I was learning python I actually wrote tests for the python inbuilt functions to check they were doing what I thought, the watching coder couldn't believe it. Look up https://www.phpspec.net/ Look up the presentations of Adam Culp that will tell you how to analyse your code is in terms of code quality. Practice with php-curl tutorial and then redo it in guzzle to see what libraries do for you. Do small things well before trying to do whole projects as you will get into bad habits. Use a good framework I like Laravel/Lumen, but the new Symphony version looks great. Think APIs for all your code and for wrapping libraries, find all the good practices before trying to write lots of bad code is my point.
Which one do you mean by this?
I thought the most basic definition of functional programming was just when you use functions are arguments or return values. The effect stuff is usually described by pure functional programming and lazy evaluation is not required all.
I did say lazy evaluation is optional. As for the most basic definition, I wouldn't say that's it. What's you're describing is high-order functions (functions that take and return functions). That's certainly an aspect of functional programming, but not sufficient, and also I wouldn't say the actions here are an example of that, per se. I mean we can imagine an object is a "function" because it contains methods, we can pass and return objects from an object, but then by that definition every OOP program is functional programming, and most people would instantly object to that idea.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Take that stick out of your butt
"Give me your boot, your motorcycle, and that stick in your butt." You forgot to say please.
I get your point, but first of all people have been trying to hammer the point home that these files are compiled to PHP and then cached, making your point moot, and second of all, yes the files block io and that's technically not a PHP speed issue, but you are kind of splitting hairs there. Assuming your framework caches/compiles yaml files that leaves .env files, and if the io block of reading a .env file is a significant performance overhead, then you not only have different problems from the average site, but there are easy solutions to these problems such as having environment variables defined at web server level.
South Africa: PayFast üòÅ (disclaimer: I work for them)
Consistency and security. If you‚Äôre using PHP for config, you can also put conditionals, logic, etc in there. This feels like an advantage at the time, but it‚Äôll bite you later. (From experience). It‚Äôd also be a good place for someone acting maliciously to hide things, because it‚Äôs ‚Äújust config‚Äù.
&gt; (i.e. sorry about your wrongness) what a great way to come over as a dick
How ?
If there's any place where malicious code would stick out, it's a config file, so that's an odd argument. You can probably stuff it somewhere in my /vendor dir, I'll never see it.
You're missing the point: SF (and any other sane equivalent) caches the YAML parsing in PHP, which means that the configuration (and even the whole container with its object construction paths) becomes cached in opcache.
And that's why Symfony caches the parsing output in PHP.
Interesting. Will read and digest
Developer salaries in the Netherlands are such a joke. I know a ton of people with the same experience and similar or even lower salaries
by being for Artisans
When you run `artisan config:cache`, Laravel parses each config file, compiling them down to a single file and resolves all `env() ` calls in the config files with the values set in the current `.env` file.
True, but if you do a call to env() inside your container config that won't be cached. So your info can be misleading in some points. Env calls are not cached. Config calls are.
How can your code be highly tested if you only got about 800 tests? At 120k lines that seems pretty low for me... No offense just wondering... My current main project is not even half that size, little bit lower I guess but I've got about 1600 tests - mixed unit tests and framework integration without database and a few database integration tests. And that's mostly only for the new code I touched and not legacy stuff my former coworker left me.
They are very handy to use in development so you can share and build upon the application config as a team but this should be strictly for development. I see this almost 99% of the time in the Laravel community they carry on using .env files on their production server. The configuration should be in environment variables of either the underlying OS or the server (nginx, apache, traefik etc) config. This gives you a number of advantages, speed for one, security as another and thirdly it makes it very difficult to incorrectly overwrite application configuration.
Don't use .env in production, use actual environment variables &amp;#x200B; If using Yaml make sure you're using a framework that parses them ahead of time and caches the result as PHP (e.g. Symfony, I'm sure most of the others do too)
It's not a server-side NodeJS application, but NodeJS and Javascript are different things. Now you're trying to mis-frame my point
Blogspam, entirely bullshit, don't read.
A color is one whole thing and the function rgbToHex performs a transformation on that whole thing, so why do we need 3 different parameters to pass one thing? Why not `rgbToHex(new RgbColor(0, 0, 0))` and validate the rgb values in the constructor of RgbColor?
This sounds rather interesting. I would really like to see how that connection with the com port is made.
&gt;The only thing this tells me your app is monolithic. &amp;#x200B; Of course it is monolithic, I am not someone that falls in microservice hype and end with 10 shitty apps. &amp;#x200B; &gt;You have one module. And it's called "the entire app". That's, sigh, cool I guess. &amp;#x200B; That's cute, oh mighty and knowledgeable one. &amp;#x200B; &gt;Time for article... [https://help.semmle.com/wiki/display/JAVA/Avoid+autowiring](https://help.semmle.com/wiki/display/JAVA/Avoid+autowiring) &gt; &gt;And one Reddit comment... [https://www.reddit.com/r/PHP/comments/6mx206/standalone\_autowiring\_di\_container/dk5qjq9/](https://www.reddit.com/r/PHP/comments/6mx206/standalone_autowiring_di_container/dk5qjq9/) So... you think you are **forced** to use autowiring in Symfony. Where did you get that nonsense? &amp;#x200B; &gt;You start building components as if everything has access to everything - just add it to your constructor, and you get it. Autowiring magic! Thus one of the key benefits of DI, which is outside control of who gets what, is given back to the objects. The objects decide what they want, and they get it. No contracts or interfaces to follow. The constructor arguments become the new StaticRegistry::get('thing') &amp;#x200B; Oh god... It burns my eyes at amount of wrong here. But I see where you get your nonsense opinions; you wrote code like this and think everybody does it. &amp;#x200B; &amp;#x200B; &gt; Autowiring containers can't do that, so that also goes in the trash. &amp;#x200B; Ugh... reddit needs to add facepalm smiley, because that is what I am doing now. Man you need to **actually** try Symfony before spewing nonsense. And try it per docs, and only per docs. I already told you few times; with compiled container in Symfony, you can't make a mistake. &amp;#x200B; Ie. you typehint interface. If there are 2 classes, you will get exception; then you need to manually wire which class you want. &amp;#x200B; Is that so hard to understand? I really don't know how to explain it simpler. &amp;#x200B; Lesson for you: [https://www.youtube.com/watch?v=RywkkwO78m8](https://www.youtube.com/watch?v=RywkkwO78m8) &amp;#x200B; Pilots are also part of conspiracy. Wake up sheeeple!!11!
I partially agree. `RgbColorValue` could be a value object that self validates. `RgbColor` could be a composition of `RgbColorValue` that could transform itself using `RgbToHex` or just use `RgbToHex`. And yes, `RgbToHex` should accept `RgbColor` instead of its values.
Basically these actions are just very slim services in the Domain layer. &amp;#x200B; We use this kind of approach for years already and it works out well.
\`.env\` should only be used in \`dev\` environments. Otherwise, your application should use the container environment.
True. The naming of the used examples could definitely be improved. I also think RgbColor should be one single ValueObject and value. &amp;#x200B; That's another thing I'm missing in the article: The word "value object" is mentioned nowhere in the article although that's exactly the concept explained...
You're right, I could have used better names. Luckily that's not the point of the post though
Like I said, it runs validations, and authorization, can be used as a controller, plain object, dispatchable job, or event listener, and includes some nice dependency injection features. Sure I could build it myself, but that would take time, and this package does everything I need.
[This](https://php.net/manual/de/function.strspn.php) might have helped..
I'd say that the rgbToHex method should be in a `HexColor` value which creates an instance of itself as well
Do it for the satisfaction of demystifying what frameworks do and the satisfaction of proving to yourself that you understand &amp; can implement common design patterns. I did it myself many many years ago just as a demonstration to a junior webdev.l to explain what MVC was and, in the process, realised how much I had progressed as a developer. So, ya, it can be fun and a good exercise, but for heavens sake don't use it for anything important or production worthy. :)
If you treat \`HexColor\` as a value object that only carries information, then I wouldn't do that.
Consider using classes instead of functions. Use namespaces and write some unit tests. &amp;#x200B; Also, use proper file names. &amp;#x200B; Anyway, good job!
&gt; Europe: Stripe I'd never recommend a company that doesn't support the whole EU bloc. Stripe doesn't support Eastern Europe
Thanks for your feedback, I really appreciate it. I will add some PHP Doc and some unit tests. As per namespacing &amp; OOP, I think it's overkill. &amp;#x200B; Besides, what do you mean by "proper file names" ?
After caching config files, the .env file is not loaded anymore. From Laravel docs: &gt;If you execute the config:cache command during your deployment process, you should be sure that you are only calling the env function from within your configuration files. Once the configuration has been cached, the .env file will not be loaded and all calls to the envfunction will return null.
&gt; In an ideal world, the perfect type system would be able to account for all specific categories required by your business. This is impossible to do though, as computers and programming languages only have limited resources to work with. I disagree. Have a look at Rust and Haskell. Relying on static types for value validation just moves some of the workload of a program to its compile time. It is a relatively small amount too. And running it once instead of n times is good when it comes to greenhouse emissions. I really don't know what the author drove to this conclusion.
My personal method: do a video tutorial first to get introduced to the language, then dive into the documentation for the rest
OOP/namespacing wont be an overkill here. &amp;#x200B; If my software already has some colorize function i cant use you lib at all. OOP should be standard. Let normal functions alone be deckared in the core/extensions.
You're right. I'll change it.
What exactly do you disagree about? Do you mean that Rust's and Haskell's type system can account for _all_ specific categories your business requires?
Ok, I haven't test it enough, usually in my local env I avoid cache so I haven't checked it. üëç
The best way is to set a clear and precise path. For example, to say: "I want to know how to connect to the database." Because if you say; "I want to learn PHP" is vague and scattered (and it's anti-SRP). &amp;#x200B; To learn to program is the same than to learn to solve a problem. Now, if you don't have a precise problem, then you could not learn it. It's as simple like that. About this topic: It's funny but because most people don't know what they want. For example, there are a lot of "programmers" that hate to program at all, so why they studied it?. self-ignorance. I can understand somebody that says "I want to study programming because I want a nice salary". Now, that's a clear path!. Of course, he/she could find that studying at a b-school could earn more (and usually it's easy). Other people want to earn money fast but they could earn fast money by following other careers and profession such as heavy machinery drivers could earn well.
its the best
120‚Ç¨/h
Within the boundaries of a specific application that fulfills a special (single) purpose within that business, yes. I'm primarily disagreeing with the notion that to express concepts, things and relationships as types would inherently exceed the limitation of computational resources. You can do a whole lot with thousands and ten thousands of types - which is a realistic number for a business usecase.
I wouldn't say that solid grasp of oop,mvc and design patterns qualifies for a junior dev by any counts. To me, just basic OOP syntax and namespaces to be able to use existing classes (as opposed to creating your own object architecture that is implied under "OOP") is the only item from this list that fits for a junior. I would rather stress on other topics, such as GIT, SQL, basic Linux console, composer, basic understanding of the business logic/display logic separation, some good grasp of HTTP, basic error reporting and basic debugging skills would make a perfect junior dev. Whereas oop,mvc and design patterns will take rather years of books and experience, and no mentor could spent so much time.
&gt;Given you really get to know such things you can safely call yourself a senior. Agreed that this isn't necessary for the junior label, but a senior needs much more than technical knowledge.
I haven't test it in the last one, but in laravel 5.1 doesn't work like this üòú
Thanks a lot for the feedback. It is much appreciated :) I can imagine that 15 years of code history must collect a lot of weird code : don't worry, you'lll remove them all, eventually.
I agree with that. I just implied that you cannot grasp these matters just from the theory, without many trial and error, a lot of practical experience. And as long as you have said experience, it will serve for other requirements as well.
1. /r/phphelp 2. https://www.google.com/search?q=paypal+order+information+php+example
Yes, this. I get my terminology mixed up all the time lol
Payum + Stripe.
I'm always happy to help, but I can't set aside time to teach you things. However, if you're fine with me looking at your code and giving suggestions and tips, maybe structuring my suggestion(s) as a short lesson, then that works for me. If you can communicate via Telegram and Github Repos, then that's even better. :)
Hear, hear.
&gt;What you call Twig++ seems to me to have no actual benefits over writing raw PHP. Anyone who believes that raw PHP is as powerful as a template engine did not properly understand template engines. &amp;#x200B; &gt;Then the fact that you wanted to charge $1,000 / year The update period is now unlimited. &amp;#x200B; &gt;This is not how open source development works. It is not an open source project. It can become open source if.... I am a company and not a communist state enterprise. Development costs money. Either the costs are funded somehow, or the source code remains closed source forever and the rest of the world has to continue to work with a technology that is 10 years old, that's how easy it is. Your problem is that you assume that everything has to be open source. That's why you have to change your perspective, not me. &amp;#x200B; &gt;Your posts aren‚Äôt hidden because they‚Äôre uncool, they‚Äôre hidden because you‚Äôre an ass hole. My post was made hidden before I posted any comment. I do not know what you call it, I call it communism / fascism.
FYI I changed the name to `RgbValue`. To be clear: it's an example to demonstrate the reasoning behind types, the post's aim is not to find the most optimal OO pattern to solve a problem.
You're missing the point: sanity isn't ubiquitous.
&gt; what a great way to come over as a dick what a great way to express your ignorant hypocrisy, dick.
Not everyone is running the latest version of PHP.
This subreddit is for PHP and not for JavaScript. I always program website that work also without JavaScript. And I do that because people from the technical field, like me, for example, use browser plugins like ScriptSafe to filter the javascript. For example, looking at YouTube makes me sick of this javascript junk. It's much slower than my CMS, I hear all the fans start up in my (fast) laptop. I have to allow a lot of Scripts to see something. &amp;#x200B; &gt;***UCMS*** *is a new revolutionary PHP framework* Proof it! Show me a PHP template engine that has the same or more features. &amp;#x200B; The headings contain buzzwords! Maybe you grew up in North Korea and therefore you do not know that in a capitalistic country marketing is done to sell products. &amp;#x200B; &gt;There's no universe in entire multiverse where I'd give $1 for something that is inferior to free and proven tools. Then you just have to continue to use 10-year-old open source technology.
For the people saying you shouldn't be using .env in production, here are some cases for and against env variables: https://gist.github.com/telent/9742059 That said, I personally use .env files on EC2 and env vars only on platforms that support it natively (like Heroku). The speed hit is negligible and you get a centralized config reference as a nice bonus. On smaller projects with simple enough config, I use a git ignored `config.local.php` that declare some constants. It's one of those cases that is hard to find a one-size-fits-all solution, but the .env route is the closest I got to it.
They're referring to the [Command Pattern](https://gameprogrammingpatterns.com/command.html), a popular way to decouple input from output. It's a very good pattern but it's often difficult to find a use for it in server applications.
I know what it is, I use it all the time. But the way they used 'this' in their last sentence 'saying that this is simpler' it is not clear specifically which approach they're talking about.
[Phpdevster in a later comment](https://www.reddit.com/r/PHP/comments/byy01p/refactoring_to_actions/eqqgkoo) provides a nice touch on the reason this isn't identical to the command pattern.
&gt; This subreddit is for PHP and not for JavaScript And? I provide value to people who hire me, I don't really care what you do. That 2001. rationale doesn't work in 2019. if you want to make money. &amp;#x200B; &gt; And I do that because people from the technical field, like me, for example, use browser plugins like ScriptSafe to filter the javascript. For example, looking at YouTube makes me sick of this javascript junk. I use PiHole. Substandard browser plugins don't cut it. JS doesn't matter if it can't do shit. &gt;Proof it! Show me a PHP template engine that has the same or more features. Sure. It's called PHP. It has more features than your template engine. &amp;#x200B; &gt; The headings contain buzzwords! Maybe you grew up in North Korea and therefore you do not know that in a capitalistic country marketing is done to sell products. So, how's it going, selling a product based on false marketing? People you were targeting despise you and your product. &amp;#x200B; &gt; Then you just have to continue to use 10-year-old open source technology. Sad truth is, you are so behind that there's plethora of people here who have forgotten more things that in programming that you'll ever know. &amp;#x200B; Can you do everyone a favor and click logout button? Please, go sell your obsolete half-product to children wanking on buzzwords that don't even apply to that ugliness you created. &amp;#x200B; Bye.
Hey maybe can help on this: I have some datas and associated strings defining their type (INT, FLOAT, etc). Goal is to feed the data well typed via my api: $data = settype($data, "integer"); // echo $data; This looks straightforward, but this doesn't works, anyone has some advises on it?
I agree with you, that other form of two methods which do completely different things based on their parameters? That's exactly the kind of thing that gives overloading a bad reputation. Imagine reading this code: ``` foreach ($dbThing-&gt;get() as $row) { ... } foreach ($dbThing-&gt;get('foo') as $row) { ... } //Fails ``` Very unclear as to why one returns a single item but another returns an array. It's better when you have multiple parameters but still want to do the same thing. For example if you've got a `MoneyValue` object but also want to accept `float` or `string` instead and just do the conversion: ``` class MoneyValue { public function add(MoneyValue $other); public function add(int $a); } ``` As soon as you start having different side-effects it becomes difficult. I honestly can't see a reason why you'd need to do this in a loosely typed language like PHP. In strictly typed languages it makes sense, but in PHP I can't see a use-case which can't just be done with `func_get_args()` instead.
Offtopic. Just a few thoughts about the term `Command`: The DDD community advocates for unambiguous language. And yet even our own terms are heavily overloaded. A CQRS command is not the same as the Gang Of Four Command Pattern. And a console command (cli) is also something totally different. By the way: 15 years ago, the first DDD book was published. Nobody gets the abstract concepts and ideas. To explain it "better", a second book was published and so on and so on... Despite all the heavy books, blogs, conferences, talks etc.. the situation is still confusing. DDD is like an abstract image, anyone who looks at it can interpret their own things into it. Each person will always come to a different result. I think it's a pity that the actual goal hasn't been achieved yet.
PHP doesn't support natively overloading without using some "here-lies-dragons" \_\_get and \_\_set methods, but it supports arguments with a default value. Like everything in the world: "Fools and scissors require good handling.", so it depends on the situation. In your case: &gt;get($id=null) // returns an array (or null) versus &gt;get($id) // returns a single row (or null) If we use a single name for both cases then it breaks the SRP, so contextually it could be wrong. while let's say a function &gt;safeFile($filename,$replace=true) Under CoC (Convention over Configuration) it could be right and it's also SRP friendly.
You're discussing parametric polymorphism, which is quite useful in a wide array of strongly, statically typed languages, a group of languages of which PHP is NOT a member. Since PHP is dynamically typed, it cannot support parametric polymorphism, which relies on selecting the correct function/method at compile time based on type information (that are not available in PHP until runtime as the object holds the type information, not the variable). &amp;#x200B; So I'm not sure how to answer the question as posited with a like/dislike and a stated reason, because I can't see how the question even applies to PHP as a whole. As a programming concept, however, when it comes to strongly typed languages, overloading based on parameter types is invaluable. Like any feature worth its salt, it can and will be misused. That's more of a question of discipline than language design, though.
If carefully controlled and structured, overloaded methods accomplish their purpose. Of course with the potential of misuse, spaghetti code, and general laziness, someone could easily turn a set of overloaded methods into a recipe for disaster. I understand where you're coming from, relying on critical functions to execute implicitly isn't always the most reassuring. But with the right discipline and structure in place to prevent those sorts of problems, they work well.
Mountains are moveable by devs of every level, but the time required is still impressive to be feature complete. And the amount of past and future testing both in project and real world you get will get from existing established projects is a considerable time savings and assurance.
My thought was to do kinda the opposite of what you were thinking: get($ids = []) : object | array // is this plausible yet? or do I need `: mixed` { if (empty($ids) { // return single } } Maybe I fudge it a lil &amp; have another function that would call the above: getSingle($id = null) { return $this-&gt;get([$id])[0]; // maybe a lil more, but the concept is the same }
Nothing of what I have said is PHP version specific.
I wish I could over load the constructor, like Java or C# or even overload some methods. But I dont think PHP people want it. If It's not generics, they don't care.
It is PHP environment specific. Specifically in shared hosting environments which are often crippled. File based configuration is a lowest common denominator solution.
I‚Äôm not really supporting your first example. As far as I know you would always - if possible by any chance - return the same type. Speaking of your example, get() and get(‚Äòfoo‚Äô) would both return an array. The second one would only have one item but nevertheless the code would work just fine. Depending on the use case that makes sense or not.
Is this mainly due to it being an interpreted language? With a compiled language, a compiler could direct an overloaded function to the appropriate function definition without including any extra steps in the compiled program. But with an interpreted language, it would always have to do the extra step of figuring out which function definition to use when an overloaded function is called. Even so, I do write PHP functions that behave differently depending on how many arguments are passed to them. By giving function parameters default values, I can give the function default behavior when some arguments are left out of the function call, and I can give it other behavior when non-default values are passed to the parameters with default values. To use your example, I could write a single get() function with $id set to a default value such as NULL. If passed the NULL value, it could behave as getAll().
That's not a good example of overloading. Let say you want to initialize a color: You'd have : init($string) and init($r, $g, $b, $a) In some languages (swift for example) you can go further and have init(name: String) and init(hexCode: String)
Or write 1 function: function get($row_id = '') { //would want to convert to PDO or intval all of your id's first or something consider this pseudocode that happens to be working PHP if (!is_array($row_id)) { if ($row_id == '') { $where = ''; } else { $where = "id = {$row_id}" } } else { $row_ids = implode(', ', $row_id); $where = "id IN ({$row_ids})"; } //build some SQL with the where clause we have built. } Overloading already sort of exists in php if you accept an array as a parameter.
Was there anything about the ext-ds priority queue that you thought could have been better?
No HexToRGB?
How many constants are you defining that this would make a real-world difference?
&gt; It is PHP environment specific. You were talking about PHP versions, not PHP environments. &gt; Specifically in shared hosting environments which are often crippled. I was talking about ways to inject environment variables into your site. You're bringing up hosters but that's not relevant to my point. Injecting the environment from the web server is a possibility, whether hosters choose to do so or not. &gt; File based configuration is a lowest common denominator solution. Again, not relevant to my points.
My entire point is that your points completely ignore all of the points you claimed to be "not relevant".
On a hypothetical function that receives a hex string and outputs an array of R,G and B, will you also check for string boundaries? And put them on classes too, maybe transforming the input into another thing altogether? If not, then why don't you just check if the values are outside the range inside the function normally? And why haven't you just assumed there should be a "byte" type? Colors are constrained by an 8 bit value that just happen to hold 256 values. Maybe with this thinking it would become evident that we don't include all the C-level integer types because they solve so little edge cases (they are a perfect fit for this problem) and are totally pointless for other range values. In an effort to increase consistency we just use a single numeric value that can be manually checked with ease. With that said, I am sold to the idea of using `Int&lt;min, max&gt;` syntax, it seems very useful and intuitive. Maybe there is a RFC or at least something like babel (transpiler) for PHP?
Please leave the PHP subreddit. You are not wanted. You offer nothing to the conversation, if I was a mod I would ban you so hard your mothers greatest grandmothers bones would feel it.
&gt; Speaking of your example, get() and get(‚Äòfoo‚Äô) would both return an array. You don't know that. That's the point.
The use case is having a strict Interface that doesn‚Äôt rely on func_get_args. Your money example is significantly more clear about what values are allowed. You shouldn‚Äôt have to view the source or run the code to find out if your arguments are in the correct order, correct types, etc.
Overloading is great, especially for constructors, and I use it all the time in C#. For example: ``` class Number { int thousands; int hundreds; int tens; int ones; Number (int number) { ... } Number (double number) { int num = round(number); ... } Number (string number) { int num = Convert.ToInt32(number); ... } } ``` In PHP I would have to either typecheck inside of a single constructor, or have a blank constructor and use some `setFromInt()`, `setFromDouble()` and `setFromString()` methods. It's also useful for reducing the length of constructors. Could be solved with named parameters, though: ``` class Class { int aparam; int bparam; int cparam; int dparam; Class (int a = 0, int b = 0, int c = 0, int d = 0) {} } ``` Say, you want to initialize it with just `a` and `d`. Currently, in PHP you'd have to use ``` Class (1, 0, 0, 1) ``` With overloading, you could create ``` Class (int a, int d) {} ``` And use it with just ``` Class (1, 1) ``` Alternatively, with named parameters, you could use ``` Class(a: 1, d: 1) ``` Alas, PHP has neither and sometimes the code has to look like ``` $o = new Object ( 10, null, null, null, null, null, null, null, null, true ) ```
Fine, let's break it down. 1. you responded to somebody else, making the point that OP was talking about RPM, not speed. 2. I replied that the distinction between RPM and speed is moot, because we're talking about files that are either: - compiled into PHP files which are then possibly cached by an opcode cache, so it would come down to PHP speed after all, or: - very fast to parse as .env files, so the I/O block, which would be detrimental to RPM if significant, is negligible. 3. You replied that not everyone is running the latest version of PHP. 4. I said that none of the above is PHP version specific, which it isn't. All versions of PHP, from at least 5 up, can be opcode cached, and obviously all of them can compile YAML to PHP (because you can always write it yourself). 5. You said it's PHP *environment* specific, that hosting environments are often crippled and file based configuration is a "lowest common denominator solution", whatever that means. 6. I said that the environment is not relevant, which it isn't, because although I admit that I mostly know about Linux and a bit about Mac OS, I highly doubt that Unix, BSD or Windows don't offer opcode cache solutions and PHP works largely the same on all of those platforms. I also said that hosting environments might not offer environment injection but that what hosters offer is not what we are talking about, because it isn't. We're talking about whether or not the distinction between RPM and speed is moot, and however crippled a hoster may be, they will not stop you from compiling YAML files into PHP, which is the entire reason I'm saying there is no practical difference between speed and RPM. Then I said that whether file based configuration is a lowest common denominator solution is not relevant, because *we are talking about file based configuration*, not just in this part but in the entire post, and whether they offer a reduction in speed or in RPM, with me saying there's no difference between the two in practice. 7. You said your entire point is that my points completely ignore yours, but that's not what's happening. What's happening is that I'm making a point to you and you keep changing the subject, where I'm still talking about what you said six or seven comments up.
Of course you know. There are coding principles and standards. And there has to be a documentation. If you don‚Äôt know what a method returns you are very lost.
There's a reason developers can argue over a naming convention for hours... If a method is returning different types, I'd argue that 99% of the time they shouldn't be named the same thing. For instance, in your example I would name one get() and the other find(), which actually gives context as to what is being done.
I tried a function that returns an object/array and it was a mess because I ended with type-juggling &amp;#x200B; example: &gt;echo get(20)-&gt;field; // could works while &gt;echo get(\[20,30\])-&gt;field) // don't (because it returns an array, not an object)
Also, we could use if (isset($_POST['id']) { $id=$_POST['id']; } else { $id=null; } Or we could use $id=@$_POST['id']; I prefer the last one.
Yes - different return types need different names. Same return types - same name. If possible. If it‚Äôs about clear naming I‚Äòd go more by getAll() and getOneById(). But as you said, we could argue for hours. There is never only one way.
Well, if it always returned an array of objects, then that'd work. $x = get([123]); // [{id: 123, name: "first"}] $y = get([456,789]); // [{id: 456, name: "second"}, {id: 789, name: "third"}] // now you can foreach on $x &amp; $y
You can test your code on http://phptester.net if you want. It has 7.0 and 7.1 I thought.
\- [https://github.com/PHPCompatibility/PHPCompatibility](https://github.com/PHPCompatibility/PHPCompatibility)
tyyy
ty
Please, please come back and update us when this is done. I really want to see how this turns out.
This code is so awful, maybe consider rewriting it to be compatible
Is there a tool to make sure you get the same output... Well √† unit test would do ü§î
The safest thing to do is to mirror your live environment locally, copy your code and run it in your computer, change versions and see if t breaks. Or else get some temporary free/extra hosting, mirror your site, and do the changes in a controlled environment. Trouble shoot likely teething problems and when it‚Äôs running perfectly, replicate your fixes in the live site.
Overloading results in more concise and intuitive APIs, because the alternative is often having to add arbitrary and superfluous suffixes to your method names, just so they're different. We need to take a few steps back and consider what's actually a method? It's a "gateway" through which you communicate with the object, optionally giving some information and getting some information back. The gateway needs to be addressed somehow, and so names are an entirely pragmatic solution, there's nothing special about them. And a method is not obligated to just *one thing in the exact same way* every time you call it with different arguments, or even sometimes with the same arguments. Ever had an "if" or a "switch" in a method that branches on arguments? i bet you do. Well you're overloading, just not explicitly. Overloading is natural. If I tell you "play with [ball]" you understand that. You'd also understand if I told you "play with [gamepad, TV, console]". We don't need a separate verb, simply because the number or type of items changed. Also overloading is typically employed in strongly typed languages, where internally the method name also *contains the argument types it accepts*. So every method still has a unique name internally, you just don't have to do the compiler's job for it, you can use the same name as long as the arguments differentiate each instance. The reason we can't have effective overloading in PHP is because it's not strongly typed. There are many situations where we simply can't effectively describe the difference in what we're passing. I'd be happy if we had overloading purely on argument count, maybe. But we don't. This is not a plus. Because as I said, overloaded APIs are much cleaner and more expressive. But implementing them in PHP is like writing getter/setters with __get and __set versus a native syntax. It's slow, error prone and messy.
Best thing to do is create tests for the current code, it could be getpostman.com, then migrate and keep running the tests to verify that it works as it should.
I'd like to be able to overload built-in functions from modules like math, str. &amp;#x200B; For example, I'd like be able to create my own str\_\* functions, my own array\_\* functions, some of them in PHP lack the consistency when it comes to parameters order, other than that, I don't think this is necessary at all in PHP, in C++ it is 100% necessary, but in PHP? Not at all. &amp;#x200B; C++ requires overloading because it has strict typing, let's say you query a result from a database with a function `auto value = mysql("select val from table");` If it's an int: `int getValue(int val){` `//do stuff` `return val` `}` If it's a string `std::string getValue(std::string val){` `//do stuff` `return val` `}` &amp;#x200B; That's quite powerful and useful right there, but in PHP we can simply check its type or whatever the value is `function doStuffWithValue($value){` `if (is_int($value)){` `//do stuff` `}else if (is_string($value) &amp;&amp; ctype_digit($value)){` `//do stuff with string` `}else if(is_null($value)){` `//do null stuff` `}` &amp;#x200B; Now you see why it isn't necessary in PHP? we can simply check types, at least that's what I think, I which we had a simply is\_int or is\_string in C++ and we could simply return an auto value from a function
The point is, we were asked to be honest, and what was said was not entirely truthful. I corrected that. Speed for a single request does not linearly translate to Requests Per Second. That is a simple fact. The fact you would go on and on about that simple fact, one you couldn't possibly disprove, serves as a testament to your understanding of efficiency.
I would begin by looking at *Modernizing Legacy PHP Applications* available at your favorite online bookstore. Focus on one thing at a time. Write unit tests. Create a PHP 3 docker container locally and run your tests in the container. Use git. Use your IDE and `composer` to their full advantage. Make sure to upgrade to current code standards. If you're not using a database package, consider upgrading to either a maintained package or using PDO. Before you modify a single line of code, there must be a test that covers what you're changing. Once you're happy with the modernization, change the PHP container to the current release and make language changes as needed. Resist the urge to modify the HTML output until you're done.
I think a solution would be: 1) record each call. Maybe a simple database table with the columns (input, output, url etc) 2) record for say 1 day 3) you have a lot of data now which you can test against You could then switch versions on a local machine and have a script fire all the inputs against it, checking if the ouput matches. This is basically generating test data for you. Now, the implementation might vary depending on how you go for it but if your new script runs fine against days of testdata.... i think this is a pragmatic solution. Sounds strange, but for this case i would start with that. Of course there are other tools also. Good luck and keep us updated!
Agreed, keep a log of all inbound requests and responses at the http level (you could slap a proxy in front of your current app for this) and log them out as req/response pairs while you work on this. &amp;#x200B; You can then replay all those requests and confirm the responses match. I'd highly suggest you heavily refactor that code so it's testable and not. That call to extract() scares the shit out of me btw, you really shouldn't do that
Thank you for this. I've just finished with a huge crunch time that was completely avoidable, if not for all of the premature optimization that was done. Don't get me wrong, I agree that it's better to cache your .env files, but I certainly wouldn't prioritize it over actual work if I had a deadline looming.
In [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language)), you can reduce range of data types: ```ada subtype RgbValue is Integer range 0 .. 255; ``` In Haskell, even the basic type system allows you to define many interesting constraints. Though sometimes it might be at the cost of readability. There is also third-party refinement types implementation called [LiquidHaskell](https://github.com/ucsd-progsys/liquidhaskell) ([example](https://stackoverflow.com/a/41749649/160386)). On a bit different note, there is property-based testing with [QuickCheck](https://hackage.haskell.org/package/QuickCheck). Finally, there are languages like [Agda](https://agda.readthedocs.io/en/v2.6.0/getting-started/what-is-agda.html) or [Idris](https://www.idris-lang.org/), that offer full-fledged dependent types.
&gt; Speed for a single request does not linearly translate to Requests Per Second. That is a simple fact. I'm not disputing that. What I'm disputing is that having your configuration in YAML is part of where the difference lies. &gt; The fact you would go on and on about that simple fact, one you couldn't possibly disprove The difference between PHP speed and RPM when it comes to performance is where something is blocking IO for whatever reason, because that is where PHP is not executing and therefore PHP speed is not a factor in the response time. That can be processor capacity, network capacity, filesystem throughput, whatever you want, except for executing PHP, because that's what we're comparing all the other things against. This means that I don't have to disprove anything. All I have to do to make my point is to make the observation that for PHP to process a hardcoded array is purely a PHP speed thing. &gt; a testament to your understanding of efficiency Well I happen to agree with the very top comment in this chain: having a small bit of configuration in YAML is not going to have a measurable impact on either PHP speed or RPM. So if YAML is easier to work with than another format people should just go for it and generally don't micro-optimize, and that's me being honest as asked. Efficiency is monitoring your application with a tool like New Relic and fixing the actual performance issues you can measure, because if you try to squeeze every microsecond out of a web application beforehand by seeing if you should store your configuration in YAML or elsewhere, you're not spending your time efficiently.
Just to be clear, are you on PHP 3 or 5? The title says 3 but the post says 5.
Was unit testing even a thing that long ago? Semi serious question.
Oh, thank god, the title was a typo. I almost called Interpol to inform them of an imminent suicide.
I guess you'd just be testing it yourself manually every time you made a change. I was doing that in v4. The fun years haha.
You aren't bright.
Oi. I still work on a massive legacy code base. Not a test in sight.
I didn't attempt to rewrite your code there but a cursory glance doesn't show anything that's immediately jumping out as depreciated from 5-7.
&gt; In PHP I would have to either typecheck inside of a single constructor, or have a blank constructor and use some setFromInt(), setFromDouble() and setFromString() methods. A more prudent alternative to maintain the encapsulation of your object would be having an "exhaustive constructor" and static factory methods that utilize it. For example, I have a Request object, whose constructor has something like 11 arguments. Obviously not intended to be used directly: new Request(protocol, schema, domain, port, path, query, headers, body, ....); Instead I have constructors like: Request::fromRaw($httpRequestText); Request::fromPsr7($psrRequest); ... And so on. The end result is not as direct and neat as overloaded constructors but it's the next best thing.
`extract($_POST)` Burn everything to the ground. In all seriousness though, I doubt there's anything in here that's going to be affected by a switch from 5 to 7. What I would recommend, however, is setting yourself up with a local environment to test this in isolation. There are a number of tools that will allow you to do this fairly easily. Depending on your operating system, you can get set up very quickly with a [WAMP](http://www.wampserver.com/en/) (Windows)/[MAMP](https://www.mamp.info/en/) (OSX) stack. I don't actually recommend using these particular tools, but if you're just starting out and don't really know anything about local webservers, these will do in a pinch. If you're on OSX. [Laravel Valet](https://laravel.com/docs/5.8/valet) or [Valet Plus](https://github.com/weprovide/valet-plus) are also pretty good for spinning up quick local sites. I would highly recommend looking into [Docker](https://www.docker.com/) (preferred) or [Vagrant](https://www.vagrantup.com/) (older, but still solid) to virtualize the specs of your hosting platform. This is the safest way to make sure that what you're running locally will almost certainly work on your remote server. Lastly, you can mitigate instances of this in the future by setting yourself up with Unit Tests. [PHPUnit](https://phpunit.de/) and [Codeception](https://codeception.com/) are your best bets. There will be a pretty significant learning curve, but if you expect to maintain and grow your platform, you will want to make sure that any future changes will yield expected results.
Just a note to you that extract is a very dangerous thing to use ( [https://www.php.net/manual/en/function.extract.php](https://www.php.net/manual/en/function.extract.php) ). You would be better off referencing $\_POST\['creator'\], $\_POST\['owner'\], and $\_POST\['hash'\] &amp;#x200B; I do not believe the behavior of urlencode or md5 has changed for a while, so you should be good there. You could almost get rid of the llEscapeURL and use urlencoderaw except you'd still have to replace underscore and tilde (\~). if you have those in your creator or owner inputs.
i'd guess he is on 5.3. i can't imagine any web provider still supporting 3
I look at Swift the way I'm looking at my neighbor's wife. Dat design. Named arguments eliminate so many problems of designing method signatures.
So would I but I am still hoping. How glorious would that be.
First, this wasn't PHP, so a bit odd to post it here, but OK, all you said applies to OOP, regardless. About this `RgbValue` class... See, it's a matter of priorities. When you change a design, who is impacted positively and who negatively? - With this change I'd say the developer of the library is impacted positively. Less tests, less code, less writing! Yay. - The users are clearly impacted negatively. When using your library they now have to type-juggle basic integer to RgbValues and back to integer (and maybe even other int-like objects) at every step of the way, making their code verbose and cumbersome, not to mention harder on the eyes. So with this in mind, we wanna make the world a better place. This means making this better for as many people as possible. - How many people are working on this library? Let's say 10. - How many people are using it? Probably way more than 10, maybe thousands, maybe tens of thousands. So. Don't push your developer problems down to the user. There are way more users if a thing, than developers making the thing. Take the time and pain to make your API simple, don't complicate your API to make your life easier. Furthermore. You can still easily isolate the "rgbvalue" validation logic separately, test it separately, and then invoke it on an integer in your conversion method. Then you don't have to test validation *again*. It's already tested. This both avoids the problem on your side, and on the user's side. TLDR; Don't "improve" your design in a way that makes for inferior user experience.
If we'll be making a color, you don't need "RgbColor()" anymore. You just need this: $c = new Color(0, 0, 0); [$r, $g, $b] = $c-&gt;toRgb(); $hex = $c-&gt;toHex(); But I'm strongly against "let's totally change this API so we write less tests". That's putting the cart before the horse.
Static methods come with no cost as a workaround for alternative constructors. Sometimes I wish php had `ClassName::new()` for main constructor (especially for bilders, where I avoid immediate method chain only because it looks so ugly).
Seconding for using Docker. It's a bit tricky to learn, but this is just the type of problem it's great to solve.
Unit testing has been around for decades.
At a glance I don't see anything that would functionally break going to 7.x ... However ... I'd suggest a rewrite. I'd be happy to help with that, shouldn't take long.
This was a long time ago on an underpowered server, so I forget the exact numbers. What I can tell you is that we spent more than 100ms per request including a config.php consisting of nothing but defines.
Just glancing at your code, I don't see anything that would cause problems in PHP 7. You can use https://3v4l.org/ to make sure the output is consistent across versions.
Spin up a Digital Ocean LAMP droplet to test it... They are dirt cheap and charge by the hour. As low as $5/mo or $0.007/hr.
I don't know if phpunit was really popular but there was a library called simpletest in 2008-2009 ish that I used
Yes but it hasn't always been as common as it is now. Especially in PHP. And it was non-existent before PHP5 I think.
Hadn‚Äôt even heard of the extract function until this post. Hopefully now I can forget about it.
Is this a shitpost? Honest question.
Just be careful since Digital Ocean is blocked by many networks due to never enforcing any terms of service and allowing their network to be the home of spammers and malicious services. Their abuse department is essentially a black hole.
I have 1 server that still runs 4. It's just too integrated to upgrade and PHP is not widely used on it. I think it's over 20 years old at least.
What u/brendt_gd says is actually a well-accepted limitation of types. This is a very old debate that has been settled, not something controversial we should bicker about. It's not even just a matter of computer resources, but also human resources. Trying to cover all possible categories is a game of diminishing returns for language designers. Declaration exponentially grow in complexity while the accuracy of your expression only grows in logarithmic manner compared to it. You may be underestimating what "all categories required by a domain" means. Let me give you a very bland example, actually: make me a Rust *type* for an integer that should be a prime number. Using only the type system implies you can ensure the type statically, using only type declarations, and without runtime errors.
 If you would like to try out a new PHP platform, I can offer Amezmo for you for you for free. [php.net](https://php.net) lists the backwards incompatible changes between 5 and 7 [https://www.php.net/manual/en/migration73.incompatible.php](https://www.php.net/manual/en/migration73.incompatible.php) \- How big is your existing code base? It shouldn't be too hard to figure out what's broken. You can probably use a static analysis tool at the least.
to be fair that happens with the big providers too. i have issues with some of my ips from OVH.
So why is it being downloaded? Did you also set the package to be a dependency in some other real packages? Or is your malicious package just being downloaded by systems that download everything from NPM?
&gt; ools that will allow you to do this fairly easily. Depending on your operating system, you can get set up very quickly with a WAMP (Windows)/MAMP (OSX) stack. I don't actually recommend using these particular tools, but if you're just starting out and don't really know anything about local webservers, these will do in a pinch. &gt; &gt; If you're on OSX. Laravel Valet or Valet Plus are also pretty good for spinning up quick local sites. 5. I thought it was 3 (that's what the guy on the phone said). but when I went and looked it was 5.4
xD Not gonna lie, when the guy at my Hosting service said I was on 3 and that PHP was now up to 7, I nearly had a heart attack. Out of date is one thing but eek...
OVH is the only one worse than Digital Ocean. Most big providers though take abuse seriously and act on it. These two do not. When I posted on their Facebook page about it they asked me for a ticket number. I had to remind them that I can't haver a ticket number if they refuse to issue any tickets in response to reports.
Get a staging/development environment. Mirror your site to it, then test all functionalities with your LSL script. You can get a LAMP instance from DO or Azure for few bucks to do so, or you can use your local environment.
Technically it's impossible that PHP might support it. PHP is dynamically typed language, function definitions are handled within compile time. meaning that PHP can't select which function during the runtime (which is necessary to overload a function). From conceptual Point of View, I agree with your friend. If a two functions are doing the same thing, then both should be merged into one function. But again, this is PHP.
wow, you probably need to talk to someone. lashing out like that is never a good solution and an indication you might not be in the best place in terms of mental health.
Find an online php 7 compat tool, if nothing‚Äôs deprecated it SHOULD be okay. But you can either make a 2nd script or use postman to hit the script with different variations and check the output is expected
There are also free options, not least AWS who gives you a free tier for a year. It sounds like OP is not a professional programmer so there will be a learning curve to many of these options, but probably a good thing to learn. Also OP, just to say, you _really_ want to upgrade. PHP 3 is ancient, and full of security holes. PHP 5 is a little better but still vulnerable and will be so increasingly now it is unsupported. On the plus side, moving to PHP 7 will not only protect you, but double the speed of your site.
Just to say, if you are vaguely thinking it‚Äôs too much hassle to upgrade... upgrade anyway! PHP 3 is _ancient_ and practically unrecognisable to most PHP devs today, it‚Äôs that different, and _full_ of security holes. A hacker‚Äôs easy sweet. PHP 5 is a little better but still vulnerable and will be so increasingly now it is unsupported. On the plus side, moving to PHP 7 will not only protect you, but double the speed of your site! Worth the pain.
IF they are making money from it why not?
&gt;is there a tool I can use to make sure this code still works the same in 7.x? Yes. It's called PHP 7.x.
`extract($_POST)` &amp; `md5() hashing` &amp; `sleep()`... You have bigger problems than which version you are on. What you're trying to do is obscured. Getting data from $_POST is a thing sure, but its just one place you could get it from (providing another place using interfaces would allow you to integration test this). The hash function and secret number(s) seems very old school. If creator is some form of (G|U)UID surely it has something which generates it's own hash + salt? Delimited values instead of classes. The list really goes on. I see someone defending "Oh but it's such a small code-base". Frankly and? It has the concept of products so this person is making money from it. They could make their lives easier by whipping the code-base into shape and keeping up on minor and major versions, or just doing a quarterly fix-up of the code.
Hello, author of Centrifugo here. Could you please describe which events you expected to be sent to your backend? Do you expect them to be sent over HTTP from Centrifugo to your backend after being received from client over Websocket connection? This was always a very debatable part of Centrifugo design so I appreciate feedback on this.
thanks but no :)
Hello @LonelySavage well actually that's exactly what i need, suggestions mostly. Telegram and Github Repos are also OK. I will DM you :)
Thanks for your feedback :) much appreciated.
Sort of did this when I upgraded from 5.3 to 7.2 recently. Took about a week to fix 10 year old codebase but now I can actually use things and not write them myself.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
[removed]
As an experienced "Python Hypertext Pythonprocessor" Programmer, I am not sure what you want. You may ask here [https://www.reddit.com/r/LearnPython/](https://www.reddit.com/r/LearnPython/)
I imagine this code was written 10 years ago, when standards for development were significantly worse, everyone copied and pasted *mysql_query* code directly from w3schools and no one had heard of BCrypt (BCrypt support was added in 5.3, I think). Trying to judge this old ass code by modern standards is really silly. Yes, this code is terrible, but it's not written to be part of some massive project or used by others, it's clearly a single, standalone script which does a single thnig. I wouldn't want to inherit this, and I would certainly rewrite it if I discovered it, but lets not judge this one random person by the standards of full time professional PHP7 developers.
I have html form in a web server and it requires uploading a file like an image for example and I'm constructing a python app to fill this form but without automation. Some kind of a thing behind the scene working on the background. Finally, thanks for the link.
Nothing in your code will break from php 5.X to 7.X, you don't use any functions that have been removed. * [https://www.php.net/manual/en/function.str-replace.php](https://www.php.net/manual/en/function.str-replace.php) * [https://www.php.net/manual/en/function.urlencode.php](https://www.php.net/manual/en/function.urlencode.php) * [https://www.php.net/manual/en/function.extract.php](https://www.php.net/manual/en/function.extract.php) (look at the warning in that, you do have a security concern, if that matters to your setup). * [https://www.php.net/manual/en/function.sleep.php](https://www.php.net/manual/en/function.sleep.php) * [https://www.php.net/manual/en/function.md5.php](https://www.php.net/manual/en/function.md5.php) The above are all the PHP Functions you use, you can click on each one to see they're all PHP7 supported (it shows versions supported just under the title) How you can test: * [https://3v4l.org/](https://3v4l.org/) * [https://ideone.com/](https://ideone.com/) Both of these will let you run the code in PHP7. Just copy it in and see if you get the expected \`$var\` output. Ignore a lot of the comments saying to switch to a framework, unit tests... etc. I doubt this is an option for you and could be overkill, none of us know your entire setup and it's like saying you need a whole solar panel setup to light a flashlight... For people worried about \`sleep\`, no its fine, its commented out anyway but Im sure you have some reason for it. For people worried about \`md5\` no its fine, this code isn't generating a password, md5 is fine for temporary hashing, its fast. I think some people here need to educate themselves on the context of "bad practice".
Simpletest was around for PHP4
A switch statements probably a good idea. Frankly the goal is to eventually get it hooked into a SQL table though, so I wasn't too worried about optimization in the short term. As for swapping out extract for $_POST['creator'], I'll try that. I don't think there's any danger of bad data.. I'm both the sender and receiver, but safer is always better.
PHP is not Python, so if you want help with Python, this is not the right place.
You're right. I've mistaken this.
I don't care for the example you provided much ezcept for strict typing. If I have a function that does roughly the same thing but accepts a mixed parameter I can't type hint it unless I create some sort of object wrapper for it, so it would be nice then. As for overloading, we have it. I've seen a ton of comme ts against magic methods but fuck it, I like them and use them quite often. I always put them at the top of my class so they are the first visible functions.
There is a demo [http://liveprof.org/](http://liveprof.org/)
move_uploaded_file() checks if the file is really uploaded by http post. copy() can move any file.
The problem with `get('foo')` returning an array with a single element is that the code calling it is always going to have to take the first item of the array as it's expecting a single item back. So you're always doing `$item = reset($getResult);`. And then if `get('foo');` could return an empty array, you have to check the count of the array. You're suddenly doing two checks rather than none for each call to this. Better to have one call which is clearer what it's doing: `getItem('foo')` and `getAll()`. I think overloading can work, but this isn't a good example of it.
Could you be more specific? I have a shop with that extension and didn't know that
I kind of doubt you a bit there. How could OVH have the market share it does if it ignores abuse on its network? I couldn't even get an extra I.P. without explanation. I also had to send them my I.D. and proof of address to get an account in the first place. Sounds like they take it at least slightly seriously to me.
I shy away from your second example, much as I love it for its succinctness. `$id = $_POST['id'] ?? null;` is clearly what we SHOULD be using. I wish I *could* use @ in good conscience, but I can't.
This was many many years ago for M1. They've since patched it. I just remembered it because it was a big deal at the time.
I hope you'll talking only about Magento 2 when saying it is a big pain in the ass to work as a developer. Magento 1 is a solid framework and have a lot of pros. But IMHO the cons are: &amp;#x200B; * Multiple ways of doing the EXACT same thing, as donkey\_is\_wonkey pointed out * No namespaces or any of modern PHP good practices * Maintaining deprecated code in the codebase just for compatibility reasons (I mean, if you want to upgrade your system, you should do it as a whole, right?) * Implemented technology that wasn't explored enough or even forgotten (like testing) * No code styles (okay, that's not necessary but improves consistency) * A bunch of other small stuff &amp;#x200B; They (or someone) could just throw away Magento 2, and build Magento 3 as an modern version of Magento 1, I just don't do it because it is insane to even consider doing all of this alone, also because I'm not a expert programmer xD.
[removed]
I highly recommend using a static analyzer that you can set the target PHP version to 7.x and it will report the 5.x code that needs to be fixed due to breaking changes or deprecations, etc. [Phan](https://github.com/phan/phan), [PHPStan](https://github.com/phpstan/phpstan), and [Psalm](https://github.com/vimeo/psalm) are popular open source options. As for guaranteeing the output, do you have tests? If not, _maybe_ [Scientist](https://github.com/daylerees/scientist) could help. I've not used it personally but it's something I've considered. It would still require some instrumentation
Yes, `env()` should only be used within config files, if you need to use it elsewhere you should install call out to the config and put the `env()` call in the config instead.
You can just namespace functions though - you don't need to make it OOP to support that.
very cool
This is what Golang does. Package `bufio`: type Reader func NewReader(rd io.Reader) *Reader func NewReaderSize(rd io.Reader, size int) *Reader Often, you'll find NewXFromString, ..FromReader, ..FromWhatever in packages that can instantiate objects with different interfaces of arguments given.
I have no experience in languages where this is a proper feature, so perhaps take this with a grain of salt. But from my experience with Laravel, it seems like a feature that would benefit it a lot. Laravel does a lot of sniffing method arguements to determine how to handle them. As an example its query builder's `where` method has this docblock: /** * Add a basic where clause to the query. * * @param string|array|\Closure $column * @param mixed $operator * @param mixed $value * @param string $boolean * @return $this */ and in the documentation lists four different ways it can be called, three of which could be split into their own methods with overloading: With a column, operator, and value: `-&gt;where('votes', '=', 100)` With a column and value: `-&gt;where('votes', 100)` With an array: `-&gt;where([['status', '=', '1'],['subscribed', '&lt;&gt;', '1']])` With a closure: `-&gt;where(function ($query) { ... })`
Yeah, was ready to grab some popcorn and see how you update PHP3 code to PHP7 :D
In Europa it's also illegal!
There‚Äôre probably rules and law per region in the world. A lot of web shops saves your data even without logingin when you try to purchase something, then a day later they send you an email in regards to completing the order. Me personally think that‚Äôs some bullsht move to do.
its also illegal if you target european customers but you are not an european company
Yes. Most people don't realize anything is submitted until they click the submit button. Doing so w/o their consent is unethical.
It is incredibly unethical. One of my old workplaces did this and I insisted they remove it, which they did. Otherwise I would have quit.
That's what they say, but it hasn't been tried in court yet.
I don't really know any legitimate reason for this except to be shady.
If I can pay in EUR, the EU is targeted, so privacy laws apply.
Hello there PHP Reddit -- I've got a random historical question: Does anyone know how PHP came to be bundled in OS X/Mac OS? Was this something that Apple just decided to do because of _The Zeitgeist_ at the time? Or were folks from the PHP project and/or Zend working behind the scenes to make that happen?
Short answer is... YES that's unethical. Since there were no intent to submit.
Today I learned PHP was bundled with OS X. I mean it's not truly necessary as home-brew makes it easy to install anything but interesting factoid.
Just to add to the pile of answers: Yes, and if I‚Äôd see that in the wild, that‚Äôd be the last time I‚Äôve visited your domain
Added a PR exactly for this! Functions are easily namespace-able, no need for classes for these small functions imo.
Probably for same reason it comes bundled with Apache and many other services like an FTP daemon, SSH daemon, etc etc.
also on Io, I believe
This exactly! Also, using something like MAMP or XAMPP for local development might also help if OP is not comfortable posting their code to an external website.
Because IPv4 space is getting very thing and all providers are required to have reasons for assigning extra IP addresses. It's not their policy to ask for explanation, it is required of them. We have to do the same thing on our network and if we don't, the result can be losing IP blocks for such violations. It has absolutely nothing to do with security.
I heard it was introduced in version 10, with PHP5. Maybe Apple thinks it has taken over the JS and Swift community and is now trying to expand its territory?
your argument is on such thin ice. first it was they didn't care. now they only care because they have to. why do i care why they implement security measures? i just care that they are being used. you're coming off as jealous. give me some real technical details about how their network is worse than your own.
What you're describing is essentially spyware.
If you have to ask this question, it sure is
Why? Because its new and fresh :D It was downloaded from the automatic stuff like this here. It was no dependency. That was the plan but i did not need to proceed further.
&gt;In Europa it's also illegal! Probably worth pointing out there is no guarantee the email was entered correctly at this point either so the data could be useless as well as illegal.
&gt;That's what they say, but it hasn't been tried in court yet. It's a fair point however I wouldn't risk it. The EU isn't scared of taking the American based corps to court, ask Google and Microsoft, seems like a new legal case every month coming from the EU. Although it sounds like this is small fry and might be okay, I still wouldn't open myself/my company up to the possibility.
&gt;I mean it's not truly necessary as home-brew makes it easy to install I've never used a Mac so is home-brew the Apple package manager? Similar to apt, pacman, yum etc in the Linux world?
that is not true, we already had the first trials against ICANN 1 month after the GDPR was enacted verdict (though german) https://www.icann.org/de/system/files/files/litigation-icann-v-epag-request-court-order-prelim-injunction-redacted-30may18-de.pdf
I don't know the term package manager but I'm going to say yes? I know how to do what I need to do on the mac command line (via terminal) I don't know linux myself though
Yeah, high level strategy wise I get _why_ it makes sense. It was super useful having it in the early 00s before solutions like MAMP, homebrew, and the entropy/liip packages were around. I'm just wondering if this was something someone at apple just decided to do, or if there was actual lobbying that happened between Apple and -- someone? to include PHP.
&gt; I've never used a Mac so is home-brew the Apple package manager? Yes, more or less. The main difference is homebrew isn't something provided by Apple, it's a stand-alone third party project to get open source software onto your Mac. https://brew.sh/ . Fink and ports were similar projects (that are still around, I think) but homebrew seems to have won over the hearts and minds of a significant sub-section of developers.
Yes, it was definitely more useful back in the day. It was also a great bit of evangelism for PHP -- just having it there and working without the need to understand (or wrestle with) a tool homebrew (or -- gasp -- building PHP yourself!) helped make the Mac a popular platform for web developers.
You would have to use a framework that cared about hiding it's signature characteristics as much as you do. Unfortunately, that does not describe CodeIgniter...
What dies it mean, " people consulting my website"?
Google and Microsoft have EU assets. Entirely different scenario.
Probably web agencies trying to sell their stuff.
And what are they supposed to sell to a php dev using CI?
Why do you want to do this?
Mac is a popular platform for web developers in general (not just PHP me thinks) because of how windows makes command line access difficult. Unless you wanna learn linux (which a lot of people do) mac s a better environ for a variety of things (i write in PHP but I write in ruby/rails as well and macs are better for that than PCS) I should point out that I've been an apple snob since 1982
I don't know the depths they go to detect, but I tried to figure out what was driving it. As far as I can tell, CI is setting a session-cookie named \`ci\_session\`. Here's instructions on how to change the name: [https://www.codeigniter.com/user\_guide/libraries/sessions.html#session-preferences](https://www.codeigniter.com/user_guide/libraries/sessions.html#session-preferences) &amp;#x200B; That's not guaranteed though, there may be other identifiers, but these identifier sites (wappalyzer, builtwith, etc) aren't open source to figure out their algorithms.
Since it also includes a ton of other languages (or will until 10.16) I doubt they had to lobby Apple. My guess is that it's a relic from the xServe days.
* Remove response headers like `Server` and `X-Powered-By`. * Check your cookie names - `phpsessid`, `laravel_session` etc. * Check your URLs, make sure you're not using `.php` anywhere
It's not an official Apple thing, so more like Chocolatey for Windows. But yeah, similar in function to other package managers.
&gt;And what are they supposed to sell to a php dev using CI? It's about selling to the business, not the dev. If they can convince the business owner that a site may be insecure, they might be able to get a security audit contract (depending on the business/industry, of course).
&gt; Trying to judge this old ass code by modern standards is really silly. I'm sorry but that is straight nonsense. Old ass code being used today should match modern standards and practices so that improvements, efficiencies and security can be leveraged. The problem is worse with compiled code as often the attitude you've promoted above is parroted leading to lots of poly-fill code to secure code as it's deployed on the edge or as part of ever more connective systems. &gt; it's not written to be part of some massive project or used by others, it's clearly a single, standalone script which does a single thnig. So we should all save ourselves a lot of effort by only writing single purpose scripts? It has a certain unix philosophy ring to it which I like, but is impractical to reason about because there are no cohesive entities, or a combinatorial explosion of them. &gt; I wouldn't want to inherit this, and I would certainly rewrite it if I discovered it So we agree &gt; lets not judge this one random person by the standards of full time professional PHP7 developers. I wasn't judging them. I was pointing out things I'd be concerned about if I were them paying to host this script. It's okay to introduce a non-professional to the fact that their hobby is a lot easier than doing things with engineering principles. They shouldn't feel judged or attacked.
For this, they have to pentest, not just sniff out the framework name. Either way all these speculations are too far fetched. I would like to hear what the OP actually meant, not some wild guess.
Simple task for you then. Create a index.php file. Just add composer and whatever DotEnv script you want (Symfony's is fine) then parse 50 vars from a .env vs a PHP file with an array ... Let me know what your AB tests return or any other RPS test. I get my request per seconds cut in half . Each of these "who cares" is probably why Laravel slows down PHP 70% out of the box
If parsing your conf file is half of your load, a few hypotheses: * you don't have a performance problem to begin with * your i/o performances are absolute shit * the content of your .env file is unexpectedly big (aka you don't used dotenv the way it's supposed to be used) Then again, you're not supposed to used a dotenv file in production. And the good news is that using *real* environment variables will magically solve that nasty configuration file parsing performance issue. Or if you really feel like using a .env file in production, store it on a ramdisk (/dev/shm or similar) and notice a thousand-fold performance improvement.
Is this tool capable of following \`pcntl\_fork()\` calls? We spawn children to process workloads in parallel batches, and we haven't found a tool yet that can profile children effectively (without starting the profiler over for each child)
It‚Äôs not like we are selling insulin here. If you can get someone to pay you $150/hr why wouldn‚Äôt you take it? It‚Äôs not like it‚Äôs hard to find someone to build a Wordpress site for you for cheaper if you want. If they are hiring them at that price then obviously they think it‚Äôs worth it.
This is the best reply - frameworks are good and you shouldn't want to hide the fact that you use one ...
This is a tutorial I wrote on simple autoloading and the PATH_INFO superglobal constant. Using these, you can structure your PHP applications to have a single point of entry for all of your requests, cutting down on repetitive `require_once`s and having a single, deterministic code path for all of your requests. This is more for just-after-beginner level for people who aren't brand new to PHP but don't have a whole lot of experience. Hopefully you learn something!
Having a test framework built around unit testing was introduced with [SUnit in 1989](https://en.wikipedia.org/wiki/SUnit). Extreme Programming actually implemented it in 1998. PHP 4 was introduced in 2000. So, unit testing pre-dates PHP 4 *and* PHP 5. [PHPUnit was introduced in 2004](https://en.wikipedia.org/wiki/PHPUnit) around the same time that PHP 5 was introduced. So in 5 years we can say unit testing has been around for PHP "for decades". Or, if you're comfortable using plurals when you have fractional bits (*e.g.* "He stood 1.5 meters from me."), then you can say that now.
And have your own CSS rolled from scratch, change order of JS calls CSS and other inclusions in the neaders. It's hard.
According to Apple, PHP and all the other scripting languages (Perl, Python, Ruby) were included in macOS "for compatibility with legacy software". &amp;#x200B; Also, all of them are going to be removed in the next macOS version (number 10.15; codename: "Catalina"). See [https://developer.apple.com/documentation/macos\_release\_notes/macos\_catalina\_10\_15\_beta\_release\_notes#3318257](https://developer.apple.com/documentation/macos_release_notes/macos_catalina_10_15_beta_release_notes#3318257)
Embarrassment from using CodeIgniter.
Lmaoooo
Try a backslash before Illuminate? use \Illuminate\Support\Facades\Auth;
When I went to install PHP on my Mac and found out it was preinstalled I thought exactly the same thing
It seems to be available in my project. What's your code currently look like? Also what editor are you using? Usually the ide can figure it out when pasting in a usage of it like `Auth::guard('guard-super');`
Eh, nothing wrong with it. Older practices but if he's efficient with it then it's the right tool for him/her.
It's an anti-pattern.
Hi, these kind of question should be asked here /r/PHPhelp &amp;#x200B; Since you posted here, well, can you show us the error you get ? Do you load the application autoloader in your isolated script ? Do you use the correct class ? Do you instantiate it the correct way ?
Can you stop posting each and everyone one of the fricking videos here.
Why do I have to give my email to see the demo?
Just FYI, wappalyzer is open source. In the case of CI it seems to be checking for a handful of cookies and the presence of a csfr input element: https://github.com/AliasIO/Wappalyzer/blob/47c1c22712f3108c194444f11c0ca317d5df8b9a/src/apps.json#L1972-L1986
That has no effect. The leading backslash only matters when using code inline with the namespace, where without it, it would be a relative namespace. `use` statements are always absolute.
Atom, what editor would you recommend? Currently I have Illuminate\Support\Facades\Auth; in my json.php in the projectname&gt;app&gt;public folder.
Yeah, this scuttlebutt is part of what prompted me wondering how PHP even got into OS X/MacOS in the first place. Also, it's interesting that PHP is left off that list entirely -- it's hard to tell if that's because PHP has a deprecation plan separate from these languages, or PHP's being left in, or the folks writing those docs didn't give PHP a thought because of standard US Corporate engineering biases. Also worth reading on the subject: https://leancrew.com/all-this/2019/06/deprecating-scripting/
Sorry man, i didnt know. I want to check the name of the current logges in user from the same php file as where I send my data to my database, i need to add what user the data is from. I really hope someone can help me! I don't know if I'm using the correct class. :/
Whoops, just kinda assumed there, haha. Good find!
The only thing I could reasonably think of was an added sense of security. It would be false, of course (security through obscurity isn't really a security), but there will always be people who don't seem to realize it.
No problem, just think about it if you have other questions of that kind in the future :) (and people are more reactive on it than /r/PHP for these questions) &amp;#x200B; Well, tbh I'm not a user of Laravel (I'm assuming this because of Illuminate stuff and facades), but from what I understand; You call this script.php file living in your public directory and send data to it that you would like to know who is sending it ? &amp;#x200B; If that's the case, then you should see Laravel docs to see how it works, public directory should only contain accessible file to the public, if you want to handle request you should make a controller to handle it and then bind a route to it. &amp;#x200B; Like I said, I'm not an user of Laravel framework but I do believe if you want to use Laravel mechanics you have to use it in the Laravel way. This way you'll probably have helpers to get the current user logged in and determine who send data. &amp;#x200B; Don't hesitate to ask more help on Laravel forums, reddit or /r/PHPhelp
The php file is in my public folder btw
Thanks for the reply! I'll have a go at the forum you advised!
I've been using PHPStorm for work and personal projects. It's a full IDE rather than an editor. The big difference is how the IDE can understand your project rather than an editor only knowing you're editing a php file from a project. It also helps with autocompleting class references and all that. But that's a conversation for another time. Either way, does your `json.php`use php opening tags before the use statement for the Auth facade? Kind of like this? &lt;?php use Illuminate\Support\Facades\Auth; if (Auth::check()) { // some php logic for the json.php }
Yes sir! It does! I'm gonna download phpstorm
Free premium student version :d
Thanks, was gonna try both Laravel and Vue yesterday and started setting up the enviroment. Gonna scrap that and give this a chance!
Vanilla php is the best.
Well in this case, I would try to negotiate a contract for a pre-determined time (like 2 or 3 months) to see how company and environment feels, then after this period of time just leave or stay. It depends also on your current situation, do you really need a new job ? Are you currently employed ? This job would be better for you financially ? &amp;#x200B; Vanilla PHP can be really cool and feel fresh to use if people that made the architecture did it the correct way. I would ask how old is the codebase and if the maintenance is a common thing around the project.
Ask why. Do they have version control? Tests? How often did they have to refactor? Which PHP version are they running now? Did they consider a framework and why did they decide against? I would not move on without knowing all this, at least.
I don't know enough about the company to say for sure but based on the info you have provided I would advise against joining them. In my career I always want to be learning and progressing and one of the best ways to do this is to work with people that are also striving to be better. If a company isn't prepared to let its tech team try new technologies and tools then that is a red flag to me that the people who work here are not the sort of people I will be happy to work with, that they are not the sort of people that want to keep progressing in their craft.
A job I was offered didnt use them because they were government based. They weren't allowed to download anything else.
So from the looks of it you'd need to bootstrap that file so that it would know about the application files. I think an easier way would be to create a custom route that serves up what ever json you need. in your `routes.php` add something like this: Route::get('ajax/json', function () { if(Auth::check()) { return json_encode($data); } }); This way laravel handles the route for what ever you need it for. You can then alter that closure function how ever you like, heck you could even get a controller to handle it all like this Route::resource('ajax/json', 'AjaxJsonController'); and your controller could have multiple methods to handle get/post etc.. requests.
If you're wondering whether it'll be an okay job, /u/hagenbuch's answer is absolutely correct. Vanilla PHP can be appropriate or desirable but you need to understand why they chose it and how they use it to weigh the pros and cons. Since you mentioned a "career decision" though, I will say *no*, it's a very bad decision. If you're looking towards the future and want to look more desirable as a candidate for other companies, having a large gap of time where you did not work with a modern framework, let alone a legacy framework will put you behind other applicants in 99% of situations.
I would hire someone who knew PHP very well over someone that knew latest framework X very well. The former would understand the language better and could probably write their own framework X given some time. The latter framework X person would be too ingrained in doing things the framework way and they might not know the language properly.
I'm sure we all would, but how are they going to demonstrate that their PHP knowledge is great enough to overcome that lack of ecosystem knowledge? Furthermore, you're much more likely to find someone with just as much knowledge of PHP *and* framework experience.
This. As a single data point, it doesn't quite paint the whole picture, but it's definitely a red flag. More often than not, not using a framework (or using some sort of homegrown framework) goes hand-in-hand with having a generally poor codebase and engineering practices. You need to grill them hard on this stuff if you want to be sure about whether or not you want to work at this place.
Yes! I‚Äôve worked with many good companies that don‚Äôt use frameworks at all. As long as they follow best practice (OO, PSR, tests, CI, etc) you‚Äôd be foolish to turn down an opportunity to learn and grow your skills. Frameworks are also only appropriate for certain types of projects. Microservice based architectures often need very few dependencies and a framework may be overkill.
Why do you laugh bro
Good find man! thank you !
It's probably because it's a legacy app. My present employer has an 8-9yo vanilla PHP project that is a homebrew framework with lots of stuff that mimic present day frameworks.
Presumably they'd built their own framework though right?
Nope. Lol
How much are you going to be able to change? Will they let you refactor it? Introduce a framework? It could be a great job if they allow you to have a positive impact in a way that is meaningful to you.
it means that they are either extremely good at what they do, or extremely bad at what they do. your gut feeling is probably the right answer of the two.
Definitely ask the above stated questions. I would also inquire about coding standards, style, etc.? Monolith vs micro service. Testing, DevOp and CI/CD processes too. Questions too about project management, sales vs product driven organization might be good to ask here too. Thoughtful questions like these might even edge out any remaining competitors for the role.
There is nothing wrong with really learning how to use the language instead of the framework. It will benefit you in the long run, especially when you return to the land of frameworks. Think of it as a back-to-basics bootcamp :)
Put this at the top of your file &lt;?php require_once ‚Äòpath/to/vendor/autoload.php‚Äô; Make sure the quotes are the right kind, I‚Äôm typing this on my phone
I've worked lots of places without a php framework. Many with a framework. It's rarely an issue, because ultimately, collaboration doesn't work without a common set of practices and conventions (which is a defacto framework). The real problems start when there's no Version Control or task tracking (that persists and you can review, project to project). Now you have a fully dysfunctional organization ruled by blame and rage and everything is an emergency, with the but-oh-dont-worry-we-work-hard-party-hard message. Those are the worst. Should you accept? You might want to consider the worst case. You work there for a week and are fired, or maybe a few months, and quit or whatever. It's just a job and you will have many.
&gt;Maybe Apple thinks it has taken over the JS and Swift community and is now trying to expand its territory? Na, that doesn't make sense. Mac OSX 10.0 is about 20 years old. Mac OS came bundled with (at least) PHP, Perl and also Python, Ruby, Apache and so on long before (modern) JavaScript Communities exploded around 2010'ish with Node/v8/es5/npm. Apple didn't need to take over the Swift community, it was mostly pushed by Apple as a modern alternative to Objective C, these 2 are still the major Programming Languages for OS X/iOS Apps. It might be Open Sourced, not every Swift Programmer (or Swifthipster) is on Mac but last time I checked Swift was still most useful with the Core Libraries from Mac. Apple didn't take over the JS community either, in fact Apple didn't do much for modern JS Developers except Safari Web Development Tools and some useful Features like remote WebView Debugging. It's neither bundled with a working JS Development Toolchain like bundler + node + JS Framework nor does XCode - the major mac IDE - really support modern JS. It seems more like Apple used to bundle the major (Web) Development and scripting tools for ease of use, but will now remove them with the next OS X release since it's not useful anymore - and wasn't for the last 4+ years - and there are better way's to install them like brew, Docker or soon running Linux on Windows in Parallels \[lol\].
Is access to the script authenticated? If so, how strong is the key? If there is any potential whatsoever of anyone else calling your script, you have to assume that someone else could work out a way to exploit a vulnerability in your code, even if it isn't open source
That they don't use a public framework says little by itself; each framework is its own special hell. In my legacy refactoring work, dealing with frameworks has been at least an order of magnitude more difficult than dealing with typical vanilla php; i.e., page-based include-oriented systems have been much more amenable to refactoring. Cf. my book [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp) for more on that topic.
I've been doing web development for 20 years &amp; I've never once used a Mac. I can accomplish everything needed for my job. Chocolatey + cmder (cygwin-esque CLI) &amp; now the addition of WSL (Windows Subsystem for Linux) makes it fully capable. I should point out that I've never owned a single Apple product, never used iTunes. Last Apple product I used with any regularity was the IIe.
I've used CI, so I'm embarrassed for him.
Don't use a (well known) framework? Write your own. :)
Don't put your code in your public folders. Most likely on your server it's configured so that you can't access it.
I agree with this entirely! But I would add that, even if they are in a shietty situation it matters a lot if 1. Do they wanna change for the better? If no, then don't sign for them; 2. When do they wanna change? If they allow u to change things during the probation month stick with them but if they don't, no matter what the reasons are, you should bail out at the end of the probation month.
Why not use mix? It provides Vuejs, typescript, scss, babel all by default. Laravel ships with it so it should be ready to use without a separate template. The same goes for PHPUnit.
Keep in mind Laravel ships with most of this enabled and ready to use out of the box (everything except ESLINT and Jest). Looking at this template it actually changes quite a bit and if you learn with this it will potentially make it harder to move to another Laravel project because everything is in a different place. It will even generate the JS scaffolding for you. Just run `php artisan preset vue`. This template completely removes the resources directory which will also break some of the built in functionality that could cause headaches later. Personally I would recommend you continue down the path of vanilla Laravel and not use this template.
"How do I hide the fact that I used a hammer to build my house"
You‚Äôre an anti pattern.
Because it forces you to keep your front end environment and back end together. This way you can literally pull the front end directory out and still have a working app.
That would explain a lot of things about my life.
So they can sell you something
&gt; In Europa it's also illegal! Europa, the smallest of the four Galilean moons orbiting Jupiter?
I find it amazing you need to ask. Are you an alien who's here to study how humans think and behave?
This, learning vanilla means you can use any framework if you want.
Interesting. I thought PHPUnit was the first unit testing framework for PHP. Never heard of SUnit. I guess you learn something new every day. I would be interested to know the percentage of PHP4 applications that were unit tested. I suspect its less than 0.1%. I would also be interested to know how many PHP5 applications were unit tested as recently as 2010. I worked on quite a few big ones and I think I saw my first PHP unit test around 2013.
What about Apache, MacOS (and previously OSX) have Apache preinstalled, it isn't running, but it is there.
I agree. The bundled PHP and Apache are only problematic for developers.
Pretty standard for commercial offerings. But I dislike it also.
It's not THE Apple package manager. Homebrew is not bundled with OS X, but rather is a community supported package manager. There is also MacPorts, but MacPorts sucks a lot (although it was better than nothing back in the day until Homebrew came along - and, even then, Homebrew has it's issues and is nothing quite so awesome as APT).
Most OSS PHP packages welcome documentation help. Try doing a quick search on GitHub or [Packagist.org](https://Packagist.org) and see if something looks interesting. From there you can also look at issues on GitHub and see if anything pops out for you.
Though using a framework is highly advisable, there are many companies that have legacy codebases dating back pre-PHPFrameworks. I think the most important questions to ask are: Do they treat their devs well? If the codebase is legacy, what do the newer apps look like? Is there a possibility of introducing modern patterns?
What was it alleged that ICANN did?
A home furnishings company here in the states did this with my phone number literally 3 days ago. I was finishing the one page credit application and a text came out of nowhere before I submit and it shocked me so much I had to tell my wife (who couldn‚Äôt give a shit). I was dumbfounded though. Highly immoral....and douchey.
I keep my config in a private repo on GitHub. Does make it easier to maintain across systems.
What do you guys use for profiling ? Xhprof is not compatible with PHP 7.0, there is fork TidyWays which is compatible with PHP 7.2 but it seems like not compatible with PHP 7.3 (at least package is not available for centos7)
It was part of the ‚Äúsharing‚Äù pref pane. One toggle would launch Apache, MySQL, and you could immediately have a local dev environment. Would have been nice if they kept PHP up to date.
Then you really shouldn‚Äôt comment. Take the time to learn before you end up spreading misinformation.
https://github.com/topics/help-wanted?l=php
Well I read your article. I programmed in many frameworks in my life: Kohana3, Zend, Symfony 1.4 (with Propel), Laravel (couple of years), and now I'm back to Symfony 4 with Doctrine 2 again JUST TO UPDATE MY KNOWLEDGE (because I wasn't programming in it for couple of years, and lots have changed)..... I honestly feel sorry for you backing away from IMO the best PHP Framework which currently exists. I try to enlist where you are WRONG about Symfony being BETTER than Laravel: 1. Complaining about MAGIC in many sites of Laravel, Look at Symfony's MAGIC, it's everywhere starting from Doctrine's [MAGIC FINDERS](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/working-with-objects.html#by-simple-conditions), ending on magically transforming DQL into SQL (Oscar for the person who fully understands this process for more complex queries). 2. Complaining about "God Objects" and breaking of SOLID principles... have you ever looked up into the [Doctrine QueryBuilder class](https://github.com/doctrine/orm/blob/master/lib/Doctrine/ORM/QueryBuilder.php) source ? Please do it for me and tell me it has ONE responsibility, and does not break the SOLID rules in those 1500 (!!!) lines of code. Maybe we should ask Uncle Bob about class having 1500 lines what does he think about that ? (and that is not only one class so badly written there). 3. ActiveRecord vs DataMappers. I won't say much about this because it depends on the project what suits your needs in this example, but MOST POPULAR ORM frameworks use ActiveRecord - that should give you some thoughts (Ruby on Rails, Laravel‚Äôs Eloquent, Propel (Symfony), Yii Active Record, Django‚Äôs ORM), DataMappers besides Doctrine 2, are mostly used by corporations like Java Hibernate, do you have more examples of DataMappers widely used ? 4. Facades. As others wrote, you don't need to use them if you don't want to. You can inject every dependency in you constructor if you want. Further more which code is more convenient ? Doctrine QueryBuilder: `$qb-&gt;add('select', new Expr\Select(array('u')))` `-&gt;add('from', new Expr\From('User', 'u'))` `-&gt;add('where', $qb-&gt;expr()-&gt;orX($qb-&gt;expr()-&gt;eq('u.id', '?1'),` `$qb-&gt;expr()-&gt;like('u.nickname', '?2') ))` `-&gt;add('orderBy', new Expr\OrderBy('u.name', 'ASC'));` Or Laravel Query Builder: `DB::table('users')-&gt;select("*")` `-&gt;where(function ($query) {` `$query-&gt;where('id', '=', 100)-&gt;orWhere('nickname', 'like', '%Admin%');` `})-&gt;orderBy('name','ASC');` Which one is more readable and understandable ? Doctrine above [example comes from documentation](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html#the-expr-class) for God's sake! and **encourages** to use this kind of abomination-of-a code in your application! Do you like to read this kind of code ? I don't....
Some of the world's biggest software companies use in-house frameworks, so that's not a useful signal. Look instead at the people at the company - what have they produced with their expertise, what's their velocity?
To expand on this, the php version bundled in the latest macos release doesn't include intl (and who knows what other php extensions), so upgrading my system left me in a situation where many of my local development sites wouldn't work. I've now fully switched to home brew versions of apache and php. It seems apple are gradually stripping back the core os to what THEY consider core essentials. I just hope the homebrew team can keep up with their efforts.
Frameworks in themselves mean Jack all as long as theres a reason to the rhyme.
what would you do with such emails without proper validation? only real and bullet-proof email validation is sending registration/confirmation email with link to confirm that email was received( = confirmed) what might be "ethical" is store the entered email to cookies "onblur" and prefill input when customer is back
Yup! They removed this feature after 10.7 https://www.lifewire.com/use-your-mac-to-share-web-site-2260400
I think that's true in Java and .Net where the tooling there is so complex it requires some specialization. But in PHP world, if you're a *competent* programmer, picking up a framework like Laravel or Symfony is comparatively easy. As such, if I were hiring for a PHP position, I would be testing that the candidate really is a solid programmer, not how well they know framework X. Knowledge of framework X is certainly a bonus, but I want to know that the code you write is going to be simple, obvious, clear, testable, and robust.
Yeah no I agree with you, I'm saying from a resume and interview it's much harder to discern a competent vanilla PHP programmer from a competent PHP programmer that uses frameworks.
+1 to this. Worked with both no framework and with framework, currently on a large legacy ~15 year old monolith. And actually, this project is one of the most rewarding I've worked on yet, because there's actually so much work to do and I feel like I'm making huge progress in improving things, and the people are great and we all share the same vision/goal, we're on the same page. There are tests, not perfect coverage but enough to cover the big parts, many PSRs are used (not perfectly due to tons of legacy cruft, but it's getting there), we have CI, etc. Most new side projects will probably use frameworks, or at least parts of frameworks, because it'll just save time, but it's by no means a definite requirement for a good project or rewarding work.
Why? Why would I come across as a more competent programmer if I have a framework mentioned on my resume? With just a handful of questions you‚Äôre able to get a pretty good gist of someone‚Äôs programming skills. Using a framework has the benefit of development speed, but also brings additional ‚Äúdanger‚Äù of following the ways of that framework blindly. So I would never turn down an offer just because no framework is being used.
you don't have to. click 'login as guest'
(Questions of this kind could probably do with some context and detail. What level are you at? What skills do you have? What other tech features does the company have?)
ea what?
I recommend you big NO.
Because it shows you have experience working with and understanding modern tools. If you are working with PHP and have never touched a framework it says to me that you most likely don't have the initiative to seek out new skills on your own. I've hired around 30 people in my career so far and very few were easy to gauge the skill level of beyond basic competency. Besides that, interview time is an expenditure and using that time to interview someone who's a higher risk of not being useful is generally not a wise idea.
not they but the bloggers using it
Oh, you convinced me. Back to vanilla it is! Thank you
So true. Also, I have seen many many projects where a framework has been integrated _badly_ and where people are forced to use it without a real possibility of changing things. No framework is not necessarily bad and in some cases will give you greater flexibility when fixing things.
Low effort spam
I think you‚Äôre making two assumptions here; that a modern framework is used and that the choice for a framework is constantly reconsidered. Everyone creates their own framework. Just spend a few days on this subreddit. That *a* framework has been used tells nothing about *what* framework. So implicitly you‚Äôre already making a separation between ‚Äúmodern‚Äù frameworks and ‚Äúnot modern‚Äù frameworks. If someone has been using Symfony for 10 years - does Symfony exist 10 years? - is that a sign of initiative? Maybe. It shows loyalty, which is also a nice property for an employee, but nothing about one‚Äôs skills as a developer. An avid Symfony developer might never have used the HTTP foundation from phpfig, but we are using that extensively in our codebase. If someone has been using Slim for a couple of years you could say that a modern framework is used. But Slim is so trimmed down - as the name suggests - that it touches the bare necessities. Does that make this programmer a better candidate than someone that hasn‚Äôt? What I so bluntly try to say is that usage of a framework says nothing about the skills of a developer. I hired a candidate once that had years of Laravel experience and with every piece of code he saw he uttered ‚ÄúLaravel does it like this‚Äù. When I asked him why that would be a better approach no explanation was given. He was get go after his contract expired. I want developers that can reason *why* we should use a certain approach without the argument ‚Äúbecause framework X does it like that‚Äù.
Violate DGPR by showing data of whois publicly without users consent
&gt; having a large gap of time where you did not work with a modern framework [...] will put you behind other applicants in 99% of situations Not in the situation of "possibly being hired by /u/eyebrows360 it won't. If I see a CV with a list of frameworks it's an immediate red flag that they don't actually know anything.
&gt; Because it shows you have experience working with and understanding modern tools. Or to counter that, it shows you don't know how to code yourself and have to rely on gluing together things that other people already coded. Having mistakenly hired a Frameyboi before, who knew a bunch of frameworks *and nothing else*, who's solution to "this framework component has a bug" was "just wait for the component author to fix it and pause the project until then"... *no thanks, homie*.
I'm not saying it's a marker they're definitely good, but I'm saying a PHP developer with zero framework experience in this day and age is *probably* bad.
If you think having experience with modern tools is a sign someone is lacking knowledge, I don't know what to say other than "yikes".
You make a very good point and I'm left thinking that I am not very good at explaining my opinion on reddit at 1am.
That can mean anything from composer with fastroute, to an outsourced mysql_connect PHP 5.2 clusterfuck. Listen to your gut.
Work this also fine with your debug configuration?
Having experienced someone who knew *only* frameworks and could not, *for literal weeks*, figure his way out of a situation where some basic framework component had a bug: yeah, no thanks. A "yikes" from the naive Frameybois Fanclub is a badge of honour. "Only knows frameworks" != "experience with modern tools"
I'd be more inclined to take someone with *no* frameworks than someone with *only* frameworks.
Maybe try to give docker a spin. All my projects are now on docker, preventing the need to pollute my local environment with LAMP.
Depends on the job market. If the jobs where you live are falling off the trees, you can be choody
That depends on your career plans, really. I spent the last 6-7 years at companies with their own frameworks, and I've become really good at debugging and refactoring old code, as well as building new features that are decoupled and can be moved to any future new framework. It's a valued skill set, useful in any context, and it seems to be getting rarer for people not wanting to work outside of frameworks. And honestly it pays well. However, I kind of want to go freelance, and I'm finding that I lack some of the skills people want from freelancers. I'm brushing up on my framework skills now, but it'll take me a year or two to get to a level that I find acceptable. So if you're able to learn a few new tricks *outside* of your working hours, it's a perfectly fine career choice.
2011, but we used to have departments for QA. Look at how those have shrunk. I work at a startup as well as running my own business and it's night and day the difference in quality. There are a few unit tests, mostly integration tests, and virtually no end-to-end tests as "they want to move quickly" which is code for "we have no fucking clue what we are doing"
In the U.S., officially speaking, gender and sex are interchangeable in legal documents, so, you're both right. In the U.S.
You should definitely ask for more information: why don't they use a framework, do they do code reviews / automated tests and so on and so forth. I wrote a whole article about how to find the best company as a developer. Hope it can be helpful: [https://thevaluable.dev/find-best-software-developer-job/](https://thevaluable.dev/find-best-software-developer-job/)
Yep. Software development is always a worst case scenario because you always only deal with the malfunctions :)
Yep. It would be also interesting to know who decides on what exactly (albeit they might not answer to an external). If it's only the boss then uh-oh.
Tideways is compatible with PHP 7.3 since its release. You can find the repo here: [https://github.com/tideways/php-xhprof-extension](https://github.com/tideways/php-xhprof-extension) There are currently no packages for the open-source XHProf extension available, only for our commercial offering that has a cloud backend. You need to compile the open-source extension yourself, but it has minimal dependencies and should work if you have the php-dev package installed. &amp;#x200B; Are there packages for Tideways PHP 7.2 for CentOS 7? I don't know of any. Default PHP on CentOS is still 5.4 afaik. &amp;#x200B; P.S. I work for Tideways company.
Well, any framework is just a tool for developers. By no means it should substitute the language. The sad thing these days that many developers spend years of working with frameworks without actually mastering the language itself. Do frameworks make cooperation in some aspects easier? of course, should all the projects use frameworks? of course not. A good developer to me is the one who can work with the vanilla language without a framework. And switch the framework if necessary for the project or the company. I would never hire a guy who describes himself as a laravel or symphony developer but would hire a PHP developer who can work with different frameworks or with no frameworks if necessary.
Thank you!
Thanks mate!
You are using nginx, right? Remove the "server" response header.
Even if they say they want to change I wouldn't trust them on it. It is a sign that you will have a uphill battle all the time.
Horrific post.
Violates data protection regulations to store and use it without consent (there are other pretexts but I can't imagine this falling into one of them) &amp;#x200B; Hard to argue consent without a submit \_and\_ a 'I am cool with you storing this' checkbox
It is possible to create a php api that would publish something to rabbitmq üêá
I agree, this does seem possible.
I mean that problem is going to exist either way
Why not, it is a job, some time you can work n vanilla and same time learn some good framework. In future you can offer them to choose framework, and say them why is it good.
Sure. Just set up a REST API using your favourite framework, and use something like [php-amqplib/php-amqplib](https://github.com/php-amqplib/php-amqplib) or [jakubkulhan/bunny](https://github.com/jakubkulhan/bunny) to connect your API to RabbitMQ.
PHP-CS-Fixer is really good for learning, you will learn a lot about PHP and testing
Oh yes, testing is a skill that is lagging behind a lot! Saved it, thanks!
IMO the important thing to find out is how agile they are with their tech strategy. Will you be working with new, emergent technologies? Do they regularly trial new technologies or do they work in a monolithic way which is naturally very resistant to changes in technology? The easiest way to gauge this is to find out how many growing technologies they are using. You already know they use PHP, but do they use Python for anything? Do they use React at all? Node.js? Cloud platforms or SaaS services? These aren't the only technologies worth using, but if they can't answer 'yes' to at least two of those techs then it's very unlikely that this is an agile company which is going to help you grow with the industry and learn modern, valuable technical skills.
Check out https://www.virendrachandak.com/techtalk/php-isset-vs-empty-vs-is_null/ for a good explanation
The temptation to create a PHP framework named "Vanilla PHP" is high.
Sorry, I know exactly what it does, I just wondered how you handled it in your code - as you prefer !empty() :)
So, we should use all of them at the same time, or?
You can see and try the demo without sending email, just use 'Sign in as guest' It' s not for commercial offerings
We use [https://github.com/tony2001/xhprof](https://github.com/tony2001/xhprof) But you can try any profiling compatible with xhprof (for instance, TidyWays)
I suppose no, because it's just an aggregator of xhprof (or other similar profiler) results
Leave my scrolling behavior alone.
We don'l have sell purposes. I's an internal tool which is was presented to open source community. In own cases il helped to find some pretty heavy bugs. So I think it will be helpful for other developers with huge projects. Feel free to send feedbacks. I try to make it better.
I'm very interested in docker, but it eats up disk space, I have a very large number of sites I need access to, so I don't know if I could use it for every project.
That 66 minute ping is killer
I believe they're deprecated in Catalina and will be removed in 10.16
And why fullstack dev should do that?
Then try laravel's Homestead its single virtual machine where you can setup different PHP versions for different sites.
Would be terrible to have to code without training wheels. Heavens! /s If you can actually code it is no big deal.
So THAT'S what homestead is! Yeah sounds good, thanks
We may be at very different places, career-wise, but things I would be more concerned with when evaluating a job prospect (in no particular order): * are they open to new ways of doing things, generally? * are current employees happy? how long have they been there? * does the company do something interesting? as a bonus, would it be particularly fulfilling? (e.g. business model is not exploiting its users) * do they use technologies I am excited to use or learn? * how short is the commute? * does your supervisor seem competent? * is the compensation adequate? My advice is don't put too much weight on a single technical decision. Rather than ask them why they didn't use a framework, if you decide to have to address it, I'd probably ask if they'd do the same thing again. It's less accusatory, and might shed more light on where things stand now rather than what it was like in the past.
i\_dont\_like\_pizza, hi How is your experience with Sylius going ? We have Magento 1.9 site and looking for option for future migration (Magento 2 is out of quesiton). Your situation is a bit similar cause you are also coming form Mangeto land. What would you recommend ?
It follows the separation of concerns principle of computer science. More practically it makes for a much nicer experience when your are building the app and debugging becomes much simpler since each part of the app handles it's one job.
It's been done. https://vanillaforums.com/en/software/
Cut the company some slack. All they need is some more of your time.
Wait I'm confused what is a Speaker?
I think the use of a framework is not so important. More important are the answers to the big 12 questions from the [Joel Test](https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/). &gt; * Do you use source control? * Can you make a build in one step? * Do you make daily builds? * Do you have a bug database? * Do you fix bugs before writing new code? * Do you have an up-to-date schedule? * Do you have a spec? * Do programmers have quiet working conditions? * Do you use the best tools money can buy? * Do you have testers? * Do new candidates write code during their interview? * Do you do hallway usability testing?
Who would use a Java-powered Selenium when there are plenty of PHP drivers for Headless Chrome?
Because there are always problems and differences between how chrome "displays" elements in headless and normal mode. Also, you maybe want to test IE and Firefox on Windows/Unix.
Using headless browsers on Ubuntu machines instead of real browsers on Windows and macOS machines is irresponsible and a very bad practice. That's how you end up with bugs in production.
That's a value object, not a DTO.
That's what I thought as well.
If you really need a full blown real test browser test suit to avoid bugs youre working on the wrong software.
But now you have to wait 2 seconds to get the text still to read! More onpage time!
&gt;Reduction in Development Time It is a promise, not a feature. It's the same when some vendor promises a low TOC (while it tries to sell you an expensive package). Sometimes we could save time doing test unit but it is not valid for every situation. **Also, some developers spend A LOT of time doing unit test instead of coding code. It is clearly not saving time.** I have even seen developers that develop thinking in the test rather in functionality. Some people forget that Unit Test doesn't replace QA but it works in tandem with QA. It's also possible to "cheat the system". For example, the so-called "test coverage". Let's say the next example: function sum($n1,$n2) { return $n1+$n2; } // test this.assertEquals(2,sum(1,1)); This code has a 100% coverage. But, is it foolproof?. Of course not. The objective of a true test is to break the functionality (then later patch it), not to fulfill some requirements. It is a valid example: // test this.assertEquals(2,sum(1,1)); // works this.assertEquals(1,sum("hi",1)); // nope this.assertEquals(0,sum(PHP_INT_MAX ,1)); // nope // and maybe other test. However, Unit test works great as "PIVOT TEST". Let's say our code is working and we are doing changes. We don't want to break old functionalities, ergo we pivot our test, so if we break a code, then the pivot test will work as a whistle.
I agree. Technically they are both the same (immutable states) but functionally DTO is also for transport information so it must be serializable. Could VO be a DTO? Well yes, it could.
Does the company have a good culture, and people / environment that you can learn from and contribute to?
I feel comfortable with frameworks, especially with Laravel, and I suggest using frameworks (for lots of various reasons) but there are lots of apps using vanilla PHP. u/levelsio creates at least $20K/month with a single PHP file https://mobile.twitter.com/levelsio/status/938707166508154880
&gt; It would be false, of course (security through obscurity isn't really a security) While I agree with it but the opposite it's not always true. For a hacker is easiest to break a system if he/she has access to read the code.
It is also part of a standard security's checklist.
This will work for the first few pages, but IIRC google will block anything after it because you're a robot. A decade ago you could create easy botnets with the Remote File Inclusion vulnerability this way.
&gt; Looking at this template it actually changes quite a bit and if you learn with this it will potentially make it harder to move to another Laravel project because everything is in a different place. This is really only a concern if you are unfamiliar with operating in a front end environment. The laravel side is left nearly untouched and the only addition is placing the entire front end in the frontend directory. &gt;It will even generate the JS scaffolding for you. Just run php artisan preset vue. But thats what im trying to avoid. Combining the front end and back end into one has been known to be a less than desirable architechture for awhile now. Yes, laravel will do most of this out of the box. But now your build scripts and the entire front end config are living among the back end. &gt;This template completely removes the resources directory which will also break some of the built in functionality that could cause headaches later. It is a template. If you want the resources directory back you are welcome to add it. The structure in the repo allows you to create full stack Vue and Laravel apps using the most modern tools available and following the separation of concerns practice. It is just a template and are welcome and encouraged to modify it to fit your needs. It doesnt need to be looked at as a set in stone structure but rather a good starting place to build from.
I haven't noticed any such impediment so far other than occasionally being presented with a photo-fit anti-robot filter. Was going to use Google's API with Python but everything seemed to lead to paying for the privilege.
I haven't noticed any such impediment so far other than occasionally being presented with a photo-fit anti-robot filter. Was going to use Google's API with Python but everything seemed to lead to paying for the privilege.
&gt; Do modern frameworks still work via /index.php? followed by a query string or is this now legacy? That has been legacy for a long time. Modern frameworks don't show .php files in the URL, they just let the web server route every request to the index.php and parse the url for routing
So would I. I didn't say *only* frameworks anywhere.
No one said "only" frameworks here except you. That wasn't part of my reply, it's something you inserted to argue against.
Which old frameworks/CMSes work with /index.php? Doesn't CodeIgniter? BTW my purpose is marketing website upgrade services.
Can you stop PHP pls
It's illegal but companies store information regardless of it.
Awesome! Excited to see so many interesting and useful RFCs implemented in PHP 7.4.
I don't know about CodeIgniter. My first professional PHP job ~ 10 years back was working on a framework that a then-colleague wrote at the time and even that didn't have a visible index.php in the URL.
What are you doing in this subreddit?
Nice. I think out of everything I am most looking forward to the pre-loading. Bribes in cash or alcohol still available to the person who implements templates for PHP 8 as they would have just saved me about 10 hours of debugging.
Truth. Without version control, you'll always be stepping on each other's toes, body checking each other, etc etc. The only way to survive politically in that environment is to foist blame on others. You don't want to be there.
Well that's good for my purposes as the older the site the more likely it's in dire shape and almost certainly not mobile-ready. The only question remaining is whether the owner has a budget :)
Following latets PHP news. Why?
Best from both worlds: Write it yourself, decouple it, and replace your parts with 3rd party components.
If we get generics in PHP I will cry with happiness
Not really, if you male business with EU-Customers and then something happens, if it's big enough, they will go for you. &amp;#x200B; I knew that there is a whole Team for childabuse (Not a private Team a State. Team in Germany which works with the whole EU, Cannada, the US and more), which are going for hunts, world wide! &amp;#x200B; Also there other thinks, like Data abuse, they need time, but they will come for you, Facebook and there lag of was monitored for about five years, before the EU said, enough! &amp;#x200B; They will come for you and it will be expensive, if you don't play fair, they will need time, but when they come, you will stand in a H-Bomb of laws and Money too defend yourself... &amp;#x200B; You must follow the privacy Laws, which applied to your home country. To keep it simple: 1. Inform the User when you store data from him 2. Make it secure, so you have no data leak 3. Store only necessary Data, crypt it where possible (Passwords should hashed everytime!) 4. No hidden datagrabbing, like this on blur bullshit 5. Be a good guy;)
Have you tried Psalm's [`@template` annotation](https://psalm.dev/docs/annotating_code/templated_annotations/) as a stopgap measure?
Again corporations like Facebook have EU assets. Therefore the EU actually has legal basis for dealing with them directly. For a solely US company which does not have any EU assets, it's still to be determined whether the EU can actually impose it's BS laws.
[https://3v4l.org](https://3v4l.org) already have it enabled for us to play with :) &amp;#x200B; [https://3v4l.org/LL274](https://3v4l.org/LL274)
I've seen it mentioned, but as all of my development is done inside PHPStorm, I'd be lacking a lot of the benefit without it having in-built support.
LMAO
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner) with focused self promotion spam like this that clearly breaks [reddits self promotion rules](https://www.reddit.com/wiki/selfpromotion) See for yourself. Vote and report accordingly.
At the very least it would allow you to encode all template semantics in your codebase. And the more people use it, the more likely PHPStorm is to support it - sort of a chicken &amp; egg scenario.
It's a pattern I'm using for my un-framework: There's also RESTSpeaker and CSVSpeaker. I'm open for another naming convention if you can innovate a better one. I'm not too keen on it, myself. I just figure "I speak English and this class speaks Color Models." Get it?
Every DTO in the project is effortlessly serializable, both via `serialize()` and `json_encode()` as documented in the README: echo json_encode($rgbColor, JSON_PRETTY_PRINT); /** { "red": 123, "green": 111, "blue": 55 } **/ This behavior is from SimpleDTO itself: https://github.com/phpexpertsinc/SimpleDTO
You are half correct: Every DTO is a Value Object. Not all Value Objects are DTOs. The distinctions are: 1. DTOs are effortlessly serializable for Data Transport (these days, that means `json_encode($myDTO);` just works. 2. Can usually be outputted directly as strings, for easy passability throughout 3rd-party code. E.g., $rgbColor = new RGBColor([123, 111, 55]); echo $rgbColor; // rgb(123, 111, 55) The Value Objects of this project are definitely all Data Transfer Objects.
I don't know if Google would index those, but if you manage to find something like PHPSESSID= in the parameters, the site will be really old. It goes back when cookies were often blocked and website used GET variables to transmit session
Thanks. Useful to know.
I would prefer wordpress for this job.
I guess you could also search for "Index of" pages. It was the default apache output when there wasn't any index file to display (directory listing) &amp;#x200B; This particular config was disabled by default in recent versions of Apache so if you find some, it could indicate you're on an old version of Apache
I don't get it at all. When I read your code I get insanely confused. I have no idea what speakers are supposed to do or what css hex codes are? Isn't #FFFFFF just a hexadecimal representation of the colour represented by RGB 255,255,255?
Exact, thank you bro, i have enough arguing with idiots
thank you, others tips ?
i didn't understood bro sorry
As other have mentioned, you should ask about git, issue tracking, code reviews, testing and or why no framework. If they dont have proper answers such as we use this and that and that over there. Get out, get out now. Run. Literally get up from the desk and fucking run! &amp;#x200B; Let me tell you why, gather round kids, this story is gonna be fun. &amp;#x200B; Back in the old days (a couple years ago) when you had to walk butt naked to school in -50 C weather up hill both ways, 8 hour round trip I worked for a company who used a home grown framework, no ORM, no laravel, no symfony, no Zend. God what a nightmare. It was me and one other guy. He was such a douche. &amp;#x200B; I would make recommendations to change things based on current standards at the time, based on what I could see as a good framework to take inspiration from: Zend Framework 1 (remember little boys and girls, this was still php 5.6 thats how old I am, 500.) &amp;#x200B; So with that said, he refused and tried to get the manager involved, I explained all the security issues with his prepared PDO statements, "controllers" and the built in Ajax crap. (I hate Jquery, react for life - Yes I am a fan boy and Yes I am on a mac, deal with it.) So I outlined all the issues and suggested we go with Zend framework or Symfony (which I had just learned about). So here we are, me the manager and the only other developer and his home grown human feces he likes to smear on the walls of the server. &amp;#x200B; He threw the biggest fit you could imagine. I got fired because he recommended it. Said I was threatening his job security with my recommendations and he felt personally attacked. The morale here: Unless they have a very good infrastructure in place and 90+% coverage on tests, run.
&gt; My guess is that it's a relic from the xServe days. That's my feelings now as well, a Twitter follower reminded me that OS X had a server variant for those xServes: https://twitter.com/hardyjohnson/status/1138855541218791424 Given that it's a lot easier to see how all this got into the OS in the first place -- the Server folks trying to add as many environments as possible for their customers. I'm still slightly curious about it though -- Apple generally keeps the PHP version relatively modern (based on OS release date) which means someone keeps working on it -- so there's at least one PHP savvy engineer inside Apple :)
I'm ready.
We're really excited about this release! Thanks for sharing.
I've not tested this. Will try to remember and come back to share experience.
Try freelancer.
/r/forhire
Can I cry with you?
I think you're on the right track. Perhaps include contact, and products as well.
Not *that* up to date. Pre-mojave shipped 5.6. Also, you don't really need to be savy with a language to package it. Source: am homebrew maintainer, help package tons of languages I know nothing about.
Hey, just a heads up - your website's certificate is expired.(https://www.phpexperts.pro/)
When people are trying to say "you *must* have some framework experience and if you don't have any that's bad" then yeah, that might place the idea in some readers' heads that they *have to* work with frameworks. I'm highlighting, via counter example, that no, they do not. This isn't a strawman I inserted just to argue against. It's topic-relevant.
That doesn't explain why you don't use the tools already provided by Laravel. Unless you made a mess of your javascript the default structure allows for that with little effort. Sure you would need to update some paths in `webpack.mix.js`, but even with a complex project that should take no longer than a minute.
&gt; This is really only a concern if you are unfamiliar with operating in a front end environment. Don't underestimate the cognitive load of remembering the different file paths while you're trying to learn something new. If they're following a tutorial or documentation, their files will all be in a different location than whatever they're reading and they'll have to mentally change the paths just to follow along. Not to mention the pain of remembering that every time they switch from project to project. &gt; The laravel side is left nearly untouched and the only addition is placing the entire front end in the frontend directory. The resources is already the the "frontend" directory. Changing it is a needless deviation from the convention provided by the framework. &gt; Combining the front end and back end into one has been known to be a less than desirable architecture for awhile now. The framework generating scaffolding is not combing the frontend and backend in any meaningful way. There is no interdependency created after the scaffolding is generated. You seem to be stuck on the theory of separating concerns, but not really thinking of the practicality of **why** its considered less than desirable. It doesn't mean never let the two systems touch at all costs. The ides is to separate the two so you can modify one without affecting the other. Creating a new separate folder doesn't do anything to get you closer to that goal. It just makes it harder to move from project to project unless they're all created with the same template. &gt; It doesnt need to be looked at as a set in stone structure but rather a good starting place to build from. The Laravel default install is already a good starting place to build from.
I remember seeing some speed comparison tests back when 7.0 was getting released. Does anyone have any comparison tests for later versions like 7.0 or 7.1 compared to 7.3/7.4? Just curious to see if there have been improvements in that realm.
I will be happy if they add native support to annotations for PHP 8.
No, it's not relevant and it is entirely a strawman. No one is going to see "you should have framework experience" and read it as "you should only know how to work with frameworks and fuck understanding the language" except you, specifically. That is an absolutely idiotic inference.
You are quarter correct, sir. DTOs have identities and should be used to be passed between the layers. RgbColor clearly don‚Äôt have an identity and is a value object.
To try it out: https://github.com/devilbox/docker-php-fpm-7.4
Both Travis CI and GitLab-CI are dramatically easier to configure and use.
if you are not testing your code, regardless of size, legacy and so on - you are legit. I mean legit. 100% legit. Doing it wrong.
Come on, [we've been over this](https://www.reddit.com/r/php/comments/bo55i8/_/engujf2) several times on this subreddit now. DTOs are _not_ value objects, under any widely used definition of either term. They are two very different things with well established meanings. What you have here are value objects, in no way, shape or form are they DTOs.
I don't have links to share but I read many times that PHP 7.3 is faster than the previous 7.x versions. Don't know about 7.4, maybe too early to say, let's hope there's speed improvement again.
&amp;#x200B; I need to get this right, and am a little confused. Been using the popular [http://php-di.org/](http://php-di.org/) package for dependency injection, and although I fully understand the concept, I'm quite obviously missing something when it comes to implementation. &amp;#x200B; Many of you know a project I've been working on: [https://github.com/envrin/apex/](https://github.com/envrin/apex/) &amp;#x200B; You guys tore my head off for not using DI, and using too many static methods. Ok, so I've basically got DI implemented now, but it's not really adding up for me &amp;#x200B; The concept of DI is excellent, and I do understand it. My main issue is basically, if you use DI anywhere, then you have ti use it every where 100%, because everything has dependencies of some kind, which means everything has to flow through the container. I'm struggling to see how this is more efficient than just including a class via "use" statement, then calling it via static methods. &amp;#x200B; Will do my best, but take an example order class: &amp;#x200B; \`\`\` namespace myapp; &amp;#x200B; use myapp\\products; use myapp\\utils\\forms; use myapp\\utils\\components; &amp;#x200B; class orders { &amp;#x200B; private $app; &amp;#x200B; public function \_\_construct(app $app) { $this-&gt;app = $app; } &amp;#x200B; public function add($product\_id, $country) { &amp;#x200B; $this-&gt;verify($product\_id); &amp;#x200B; } &amp;#x200B; private function verify($product\_id) { &amp;#x200B; $client = new products(); $client-&gt;lookup($product\_id); &amp;#x200B; } &amp;#x200B; } \`\`\` &amp;#x200B; In Apex right now, I'd either just leave the above class as is without "app" being injected, or create a "lookup" static method within the products class and just use: &amp;#x200B; \`\`\` products::lookup(); \`\`\` &amp;#x200B; We're using DI though, so that's out. In the above class, "app" gets injected, which is our container itself. Now there's no way we can just createa new instance of the "products" class like that, as it will have its own dependencies, hence it either has to get called from the container or injected into the class. We can always call it from the container with: &amp;#x200B; \`\`\` $client = $this-&gt;app-&gt;get(products::class); \`\`\` &amp;#x200B; Not the greatest, so there's always constructor injection same as we did with "app".. That means: &amp;#x200B; \- Define a "$client" property \- Add "products $client" to constructor arguments list \- Define "$this-&gt;client = $client" within constructor \- Use "$this-&gt;products-&gt;lookup()" in that method. &amp;#x200B; Again, not the greatest. We could do parameter injection via annotation with: &amp;#x200B; \`\`\` /\*\* \* @Inject \* @var products \*/ private $client; \`\`\` &amp;#x200B; Then we can just use "$this-&gt;client-&gt;lookup()" within our method. Again, still not great. Then there's always method / setter injection, such as: &amp;#x200B; \`\`\` /\*\* \* Verify the order \* \* @Inject \* @param products $client \*/ private function verify($product\_id, products $client) { &amp;#x200B; $client-&gt;lookup(); &amp;#x200B; } \`\`\` &amp;#x200B; That seems decent enough and workable, except now we can't just call "$this-&gt;verify($product\_id)" within our class anymore, because it has to go through the container instead so injection occurs. Instead, you have to call it with something like: &amp;#x200B; \`\`\` $this-&gt;app-&gt;call(\[orders::class, 'verify'\], \['product\_id' =&gt; $product\_id\]); \`\`\` &amp;#x200B; That's definitely no good. Now put this into context of a larger class with 50 methods that has a total of say 12 dependencies, each of which has their own dependency so everything MUST go through the container, and it creates a real mess. This is especially true when you have say that class with 50 methods, and there's one dependency class used one time in one method, and you're forced to do either: &amp;#x200B; \- Constructor injection \- Parameter injection \- Method injection with annotations, but call the method via the container and not directly. &amp;#x200B; At least from my POV, none of those seem like a good option. I do really like the concept of DI, and that method / setter injection seems to the best, but obviously I'm missing something. Is there maybe some type of "call handler" similar to an error / exception handler, so I can call methods directly within the code and still have injection occur without having to call the methods via the container? &amp;#x200B; I really like the idea of just having everything you need at your fingertips via reflection / injection like this, but not really at the expense of all this extra code. What am I missing here? Could someone please kindly help? I need to get this right.
I just packed it in a Docker image to play a bit around: &amp;#x200B; `$ docker run --rm -it 1maa/php:7.4 sh -l` `28ecc3deb7b8:/# php -v` `PHP 7.4.0alpha1 (cli) (built: Jun 13 2019 21:48:32) ( NTS )` `Copyright (c) The PHP Group` `Zend Engine v3.4.0-dev, Copyright (c) Zend Technologies` `with Zend OPcache v7.4.0alpha1, Copyright (c), by Zend Technologies` &amp;#x200B; The Dockerfile is available: [https://github.com/1ma/dockertronics/blob/master/php/Dockerfile.74](https://github.com/1ma/dockertronics/blob/master/php/Dockerfile.74)
Fun fact: if you compound all the claimed speed improvements across all versions of PHP 7.3 is several billion times faster than PHP 5.3.
here ya go: [https://github.com/composer/composer/issues/7777#issuecomment-440307393](https://github.com/composer/composer/issues/7777#issuecomment-440307393)
Sierra was 5.6, yes, but High Sierra shipped with 7.1 -- but point taken :) . I probably should have said "shipped with a version that made usually made sense for the contract/consulting work I did between 10.2 and 10.11 :)
Can't stress this enough. Ask the right questions and if you like what you hear, take it. I did this about a year ago and have made some of my biggest contributions at any job to date.
username checks out
PHP's response is on point: https://twitter.com/official_php/status/1139308822839926787
Checks out: Solid Platform.
It looks useful. I'll keep this in mind! thanks! :)
I'm sorry for causing some confusion: SUnit isn't a tool for doing unit tests in PHP. PHPUnit was, AFAICT, the first unit testing framework for PHP.
I feel like GitHub completely missed the mark on this one. It's not intuitive, and they use a very niche configuration language (HSL). Other solutions are far easier to manage and understand.
Does this library consider the fake curvature of the earth?.
meh. generics get real messy and cause some very messy and hard to read code.
Please don't
&gt; Then when you eventually throw it out Never did.
[removed]
I was just last week copying down the haversine equation into code. Nice to see something out there for this kind of problem.
Thank you
Thank you for your answer!
can you stop it pls?
Sorry, but are you sure it's compatible with PHP 7 ? [https://github.com/tony2001/xhprof/tree/master/extension](https://github.com/tony2001/xhprof/tree/master/extension) The last commit was done 6 years ago with message: "[fix segfault in execute\_internal with PHP 5.5](https://github.com/tony2001/xhprof/commit/85e3ef901444a2d4881ab4410d9e46502caf8451)" &amp;#x200B; Or do you use that for PHP 5.X version ? Thank you!
Add "ORDER BY matched_results DESC"
At some point, Otwell decided he needed to build Laravel (PHP) At some point, Wathan decided he needed to build Tailwind (CSS) At some point, Google devs decided to use Dart and make Flutter happen (Mobile) At some point, build what you want to build. (Anything) Good luck, and happy coding.
I think this does not solve my problem. There are multiple keyword to search. Maximum matched keywords in a Title would come first the rest in descending order. How can i implement this? May be searching every keyword in a single title and calculate a weight. Or some other efficient way to do this?
Google "full text mysql searches". (Or whatever DB you're using). You don't want to be using LIKE for this.
I believe that [parametric polymorphism](https://en.wikipedia.org/wiki/Parametric_polymorphism) actually refers to something quite different to overloading. Overloading allows a method to have many entirely different signatures, and the implementation that is called depends on what combination of parameters are passed. In cases of PP I believe the method usually only has one implementation, but this implementation can apply to parameters with generic types. Example of overloading (using TypeScript syntax): get(): User[] {...} get(id: int): User {...} Note that the two variants have different accepted parameter lists and different return types. Example of a parametrically polymorphic method: arrayWithOneElement&lt;A&gt;(one: A): A[] {...} In this case, we're declaring that `getAll` works for any type `A` and returns an array of `A`s. There's only one way you can call this method - with one argument - but its one argument can be of any type. The effect of overloading can be achieved in PHP because it is dynamic and has some reflective capabilities. You could write a single function that inspects its arguments and then decides what to do, and what to return, based on their number and type. This doesn't have the syntactic convenience of defining the same function multiple times as in languages like C++ which have language-level support for overloading. PHP can also achieve the effect of parametric polymorphism using OO features like inheritance. I'm not sure if it's typically called PP in dynamic languages; I've heard it referred to as duck-typing. You just don't get the same guarantees/tool assistance as you do in a language with a richer and/or static type system. The choice of when to use overloading, parametric polymorphism, or none of these, is up to the API designer! Personally, I avoid overloading and prefer to use clear names.
**Parametric polymorphism** In programming languages and type theory, parametric polymorphism is a way to make a language more expressive, while still maintaining full static type-safety. Using parametric polymorphism, a function or a data type can be written generically so that it can handle values identically without depending on their type. Such functions and data types are called generic functions and generic datatypes respectively and form the basis of generic programming. For example, a function append that joins two lists can be constructed so that it does not care about the type of elements: it can append lists of integers, lists of real numbers, lists of strings, and so on. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
unlike the laravel comments, I was being serious. you imaginary ordered me out of this subredit and also imaginary banned me so hard my imaginary grandmother felt it. that's not healthy behaviour ... `¬Ø\_(„ÉÑ)_/¬Ø`
Here's a list of what's new: https://stitcher.io/blog/new-in-php-74
I'm the writer of the post, so I find it interesting to see what people are doing with it. I also came to the comment section to address two things. - First, I also made a strongly typed DTO implementation that is used in many actual production projects: https://github.com/spatie/data-transfer-object - Second, the issue regarding DTO/VOs is also thoroughly discussed in that repo: https://github.com/spatie/data-transfer-object/issues/17 it might be an interesting read for some.
Yea manually should be fine.
That feature looks like a hot mess. If they simplify it I might consider using it. 'Til then I'm sticking with Travis.
You write "csv" a few times when you mean (I think) to put "css".
\&gt; currently only supporting annotations as Doctrine got rid of YAML support and XML &amp;#x200B; say what now?
They don't.
In my opinion, [HCL](https://github.com/hashicorp/hcl) is far more reasonable than YML. The problem is that they are using it as a programming language for a CI tool instead of as a configuration tool which it was meant to be.
It's not just a theory, but the ideological battle has been lost, as "using a framework" has become a sign of a "good development practice" and most use a framework the way the manual says (i.e. tightly coupled to the framework).
As someone else has said, this is a use case for full text search - `LIKE` just doesn't cut it for this sort of use case. Postgres has supported that for a long time, and modern versions of MySQL/MariaDB do too. If search is a *really* big part of your application it might even be worth rolling out the big guns and using a dedicated search service like Elasticsearch.
Why not use a full text search as it can already do this
Certainly not readability. Your question is too vague, compared to what ? In which context ? What are you querying ?
None, but this type of code may happen if someone didn't know the shortcut, or after refactoring.
I greatly prefer Human JSON: https://hjson.org/
With expression builder you can break the query building to separate classes/functions, `$filter1 = $qb-&gt;expr()-&gt;eq('u.id', '?1') ;` `$filter2 = $qb-&gt;expr()-&gt;like('u.nickname', '?2') ;` `$qb-&gt;where( $qb-&gt;expr()-&gt;orX( $filter1, $filter2));`
They can.
well yes, I saw that in the docs, but you can do exactly that using \`$qb-&gt;where('[u.id](https://u.id)', '?1') \` so I'm confused as to why they'd suggest the long-winded way over the normal way
In the docs they show both, I don't think they prefer the expressions. Just use what is simpler solution for your task :)
* **Improved Type Variance** is going to improve my life a lot! I've been more or less either avoiding Design By Contract or i've been hacking it by using PHP docblock `@returns` to specify what I really want to enforce but can't: https://github.com/phpexpertsinc/ColorSpeaker/blob/master/src/internal/RGBSpeaker.php#L39 * **Typed Properties:** Man, i'm going to love this! Will improve the language more than anything since return types!
Quite true. The library uses a simple spherical model, not a geoid or even an ellipsoid. The error here will be about 0.06% at full Meridian and about 0.1% at half equator. On smaller segments the error is much smaller and practically suitable for tasks similar to logistics.
I actually like `use ()` for closures. It makes using outer scope values very explicit
As mentioned in the article, I'm no Docker expert and still figuring things out ‚Ä¶ I think I could move the `composer install` and `vendor/bin/phpunit $*` parts back to the Dockerfile by using `RUN composer install`. Would reduce the number of files to maintain from 2 to 1. And I also agree that Travis CI is much easier to setup. I wouldn't use GitHub Actions to run my test suite as Travis or CircleCI are much better at it. I've used it more as an example, as running a test suite is something people are more familiar with.
It's particularly the inclusion of validation in the OP's example that rubs me the wrong way. Their `RGBColour` class is a classic example of a value object, so referring to it as a DTO just seems weird when there's already a widely used and understood term for it. Of course none of this really _matters_, but it does make things a lot less confusing.
Every time I read anything Doctrine specific, I have flashbacks to late-2000s to mid-2010s, and I'm ever so frickin grateful all the projects I've been on since 2015 have been in Eloquent!!
Know what that is? Code reviewer abuse!
This post wins a reward for the least PHP specific article in weeks around here.
...and I'm glad the projects I'm working on are not in eloquent. Once you get to a certain point, eloquent (like the rest of laravel) falls apart as it's just too opionated. Laravel is great for writing blogs though.
I'll be glad if the code comes in handy :)
Why that? it is a struggle I had with PHP FPM for very long time
This seems so unnececary. Is there another programming language with such functionality?
Yes, this feature is copied from Java.
I'm completely in favor of `use ()` on the principle. Closures are functions and there's absolutely no reason a function would magically inherit everything from the outer scope. But I must say that after using typescript for a while... It's really convenient. So IMHO the traditional syntax with use and the short arrow syntax that inherits from the outer scope and can be multiline would be a perfect compromise.
Just don't use it then.
Yes, it's mentioned in the RFC: https://wiki.php.net/rfc/numeric_literal_separator#comparison_to_other_languages For the lazy amongst us: - Ada - C# - C++ - Java - JavaScript and TypeScript - Julia - Kotlin - Perl - Python - Ruby - Rust - Swift
It's necessary when you have to enter the numbers yourself, even though a comment can do the job.
I must have missed it. Also never have seen it in the wild. Still, I really feel there are other things that can be done with PHP core other than syntax sugar.
We use the branch [https://github.com/tony2001/xhprof/tree/badoo-7.0](https://github.com/tony2001/xhprof/tree/badoo-7.0) , but i think TidyWays is good for php7 PHP 7.2
And for this 100% correct statement, you will be downvoted by army of Laravel religion.
It is easier to implement specification pattern. But take a look at criteria; it doesn't offer subqueries but it does have advantages. Most important is that you can use same objects for DB queries and collection filtering.
I would really like to know if this kind of proposals really adds something valuable to the language or just mess up the language for people learning it.
People can do multiple things!
TideWays works good on php 7.3 It the last version added php 7.3 check in the travis [https://travis-ci.org/badoo/liveprof](https://travis-ci.org/badoo/liveprof)
Not at the same time they can't. Now *multiple* people can do multiple things at the same time, obviously, but that's kind of the crux of the issue: there aren't many core php developers, so that argument does not really work.
Doctrine "greatly encourages" you to use expressions based off the 2nd paragraph in the following link https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html#high-level-api-methods I dont use expressions though, I find it more unreadable than using the standard. Even just looking at the converted example 8 in the above link, I much rather see a -from()-&gt;where()-&gt;orderby()...
I cant ever remember an instance where I was forced to use expressions where the where() function couldn't handle it.
Good call. The template example is what I had in mind. I mistakenly conflated templates with how they're often implemented in C++. Still, the point that overloading in a strongly typed language is almost necessary by default is worth making. The fact that it can act as a stepping stone for template implementation and lead to a whole paradigm is nothing to scoff at.
This feature was [implemented two years ago](https://phpinternals.net/articles/implementing_a_digit_separator), but not merged into the language at the time. Features like this don't take any time away from developing other features, as much of the non-funded development on the PHP core works because developers donate their free time. If they weren't implementing features that they want to work on because they think it will improve the language, perhaps they wouldn't donate that time at all?
Honestly, it feels very random (I don't know other languages), but luckily, it seems it's back compatible: &amp;#x200B; \- '1\_2' will stay a string \- 1\_2 could never exist &amp;#x200B; Anything else we should be careful about?
The Simplytest.me platform lacks the ability to install composer dependencies for contributed modules. Would this platform be a suitable replacement for demoing some of the more complex D8 modules?
Informative Share... thanks for the link...
Why using the query builder for simple/non dynamic queries? Use DQL instead, more performance and readability!
It helps if you copy/paste the entire sentence: &gt; currently only supporting annotations as Doctrine got rid of YAML support and XML... no thanks In other words, the author does not like to use xml, and yaml is deprecated.
 Let‚Äôs have a look at what new PHP 7.4 has got to offer and why we can rely on it. * Speed improvement * Argon2 in password hash * Asynchronous programming * Multithreading * New Sodium extension * Abstract syntax improvement * Better performance on WordPress Websites * Deprecation
And need to change it twice? Yikes.
A moment later and i just would have forgotten endtest. Shit.
Downvoted for asking a legit question. Welcome to /r/php
I would turn the question around and ask: why not implement this? If you don't like it, you can 100% continue to use the current style of numeric notation. If you do like it, you can use the new one. It seems like an absolute win for both people who like the idea and people who don't like the idea.
Do travis/circleci stuff in a feature branch, when you finish it up squash the commits to a sensible state. Problem solved :D
I'll forget all about this and then the first time I see this is production code I'm going to stare at the screen wondering if I should have taken dad's advice and gotten a job at the factory.
I came to get some of the downvotes. It's a stupid, half a percent feature I will only use to disqualify programming candidates.
C++ uses a single quote, not an underscore. Seems disingenuous to include all languages that provide ANY mechanism for this as the same. People will still have a learning curve on it.
Ah it's &amp;#x200B; \&gt; currently only supporting annotations as (Doctrine got rid of YAML support) and (XML... no thanks) &amp;#x200B; I read it as &amp;#x200B; \&gt; currently only supporting annotations as (Doctrine got rid of YAML support and XML)... no thanks
Because adding unnecessary things to languages makes them worse almost by default. This will be abused, but only by that guy on the team who always has to use the most clever thing in the toolbox, because he is obsessed with elegance, rather than results.
Why would one load the jQuery library for just a simple if statement? O.o &amp;#x200B; [i.imgur.com/Q3mkcnl.gif](https://i.imgur.com/Q3mkcnl.gif?1) comes to mind when reading the JS file
Keeping that as a reference, might come in handy for me pretty soon.
The `... no thanks` operator has precedence over `and`.
The question: \&gt; Is there another programming language with such functionality? The Linked RFC, under the section clearly labeled "Comparison to other languages": \&gt; Ada: single, between digits [1](http://archive.adaic.com/standards/83lrm/html/lrm-02-04.html#2.4) \&gt; C# (proposal for 7.0): multiple, between digits [2](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/digit-separators.md) \&gt; C++: single, between digits (single quote used as separator) [3](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3781.html) \&gt; Java: multiple, between digits [4](https://docs.oracle.com/javase/7/docs/technotes/guides/language/underscores-literals.html) \&gt; JavaScript and TypeScript: single, between digits [5](https://github.com/tc39/proposal-numeric-separator) \&gt; Julia: single, between digits [6](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/) \&gt; Kotlin: multiple, between digits [7](https://github.com/Kotlin/KEEP/blob/master/proposals/underscores-in-numeric-literals.md) \&gt; Perl: single, between digits [8](https://perldoc.perl.org/perldata.html#Scalar-value-constructors) \&gt; Python: single, between digits [9](https://www.python.org/dev/peps/pep-0515/) \&gt; Ruby: single, between digits [10](http://ruby-doc.org/core-2.6.3/doc/syntax/literals_rdoc.html#label-Numbers) \&gt; Rust: multiple, anywhere [11](https://doc.rust-lang.org/reference/tokens.html#number-literals) \&gt; Swift: multiple, between digits [12](https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID415) It's not downvoted for "asking a legit question". It's downvoted for asking a question that was clearly answered in a linked article they (and likely you as well) didn't bother reading. Welcome to Reddit.
&gt; 1_2 could never exist Why?
Hmm, I'm excited by new PHP 7.4 features, but this one? I find it confusing and pretty useless.
If we're talking legacy code it \*shouldn't\* exist is what they mean I believe.
For example, Java also uses '\_' as a number seperator.
Lol
Sure, if you expect people to read the entire RFC
Paamayim Nekudotayim Agency is the same as Semicolon but with an air of mystery!
my dick is very small web development agency
That's way I read it. We use XML mappings where I'm at, since we've seen some advantages over annotations. I'm in the camp that Annotations shouldn't be used for coding (logic and such). Great for IDE hints though.