I really mean no offense, but it doesn't look like you just didn't make it pretty. It looks like you went out of your way to make it look bad.
The lack of images and 'only CSS' isn't the problem with that site.
I instinctively pressed Commad + 0 to 'revert' the browser zoom to normal simply to try and fix it, cause it looked like I had zoomed way in and broken it. But nope, the site truly is like that
My point is that you can't hold up any one language as a gold seal example of how things are done. You've got bad PHP programmers, and you've got bad Ruby programmers. In either case, bad programmers are not the people who you should be looking towards to see the merits or failings of a language. If it were, every language would be terrible.
I think it's mainly to support PaaS, I imagine this specifically spun out of rails on heroku. The PaaS tend to use environment variables to configure applications as they are portable across languages/platforms, so for each application you define a set of environment variables via a control panel and they will be available to your code. To make this kind of configuration work during development, the dotenv system is used to avoid having to configure environment variables manually for every terminal/web server/whatever.
That clears it up somewhat, thanks.
For the lazy. http://i.imgur.com/l3KlMy1.png
The truth is that most of the people using PHP, are not, and do not consider themselves software/web/developers in the sense people using other languages often do. Actually it might even be possible they dont know they are using PHP (instead they consider themselves Drupal/Joomla/WP/ users or Site Builders etc.). By this i mean no disrespect to the people actually using PHP and building something with it, people knowing what they are doing. The fact that PHP popularity is rooted in the CMS world makes users often having no clue what they are doing, other than just copy and pasting from some blog, or using modules/plugins for the most simple tasks when all they would need is a function or two is a result in the bad PHP code you will find online. I really see no redemption for this, as long as people are not willing to learn some basics, the same problem will always be there. 
COOL!
Factory methods, just like constructors, can accept parameters. But they can "curry" the constructors, providing some dependencies / settings, while leaving some to you. They can also pick a concrete class out of several to satisfy a specific interface, or configure an object after it's created, using its public members. I have a validation library where I can switch "strict mode" globally for all validators, or not, just by initializing their factory with the right switch (versus doing it validator by validator). Much better than global state.
I don't. Feel free.
I knew the joker was a PHP guy :).
Author of original logo knows nothing about this. Looks like those changes of artwork were not permitted
Ignoring the new language features, that's still crazy. 5.2 last received an update nearly five years ago. Even if Wordpress was perfectly secure (hah!), it's still downright negligent of the maintainers to support its users running an EOL'd platform that has known security issues. 
Don't we have enough routing libraries already? 
I don't suppose it will support PSR-7?
My thoughts are in line with the general consensus here, that there's so many shitty devs pushing shitty code, you're not going to be able to petition against it. Perhaps our solution isn't about documentation and code review, but around branding. We've seen a few things become popular recently which I think are indicators that you're probably dealing with good code. Coding style standards, for example: style literally does nothing to the actual execution of the code, but if I know they're following PSR-2, I'll assume the programmer knows what they're doing. Composer packages are another big one: anyone who takes the time to make a proper composer package probably has some idea what they're doing. I never like feeling like I _have_ to use a framework, but I'll admit that if someone understands why symfony or laravel are useful, they know more than the average shitty dev. If we had a way to roll up all these things into a simple brand to represent good-php, we'd have a convenient way for us (including anyone hiring devs) to separate the wheat from the chaff. While things have changed a lot now, there was a time when JavaScript was synonymous with rubbish hackery -- noone would take anyone claiming to be a "JavaScript developer" seriously. Being a JS dev basically meant you wrote HTML and occasionally put an `onclick` attribute in there to hide a menu or turn a button red. Things really started to change with XHR, when everyone realized that you could make interesting, powerful web applications. Suddenly resumes, blogs, tutorials, etc. would pop up with authors listing their skills first as "AJAX". Java devs also had to rebrand themselves for a while, since half the information you'd find on Java would be for writing little applets, not building well-organized, scalable, server-side applications. Even if you never wrote a single line of anything "enterprise", many would list themselves as J2EE devs.
I see, but a new service doesn't have to be in a remote server..you can just host it on the same server..why not? Anyway, the question was about Enum and I'm giving wrong answer here. Good Luck!
Where can I find examples of bad PHP coding habits to avoid? I'm asking for a friend. Ehrm.
/r/TimeToogo unfortunately we have a meme going on where we mock router creators. Folks don't realize yours is one of the "earlier" tree routers in the last few weeks (and this is just announcing v1). Don't take it personally, and thanks for the ~~fast~~ rapid router ;) I've bookmarked it to inspect the source.
&gt; Maybe at least go through the trouble that explains how it achieves that? Instead of just saying its 20% cooler It's an open source project, isn't it a bit rich to say he didn't "go through the trouble" of explaining how he does it? The source is right there.
The problem is that PHP has such a low barrier to entry, that you're always going to have people who don't really understand what they are doing, doing stupid things. All you can really do is just make sure that *you* are doing it correctly and be a good example for others. Keep yourself open to change.
um, there's no reason you can't do autoloading in php 5.2... ???
&gt; Everyone was complaining that my website is ugly They have a point... ( ͝° ͜ʖ͡°)
Funny. Red Hat and Canonical do the same thing under the guise of "long term support", and everyone loves it.
If you can't be bothered to read the code for something you're curious about or skeptical of, that's **your** fault. Nobody is under any obligation to cater to your laziness.
There's a few ways to look at sites that showcase bad code. We can see it s "idiots who post bad code" or we can see it as "people who were inspired to try something they might not have otherwise". I believe the majority of the people who post bad code really do mean well, and want to contribute back to the community in a positive and meaningful way. There's a sort of innocence in it all, even if they are causing damage they don't yet understand. We all spent time writing turds and showing them off at some point, and a lot of us learned important lessons from them. When I was a bad programmer just starting out it was much harder to make my bad software public due to the internet still being in it's infancy at the time. I was also lucky enough to have a mentor as a kid who believed in me enough to teach me what he knew. This training gave me advantages for later on when information became easy to find. I have to believe most people want to do better, and as long as I can believe that, I'll keep trying to show them the way. I hope you will too.
Yeah, this seems like a huge code smell to me :(
My company's been building the new version of our app on 2.7 (currently on Beta-2, started on Beta-1). We're in the medical field, so having an LTS of a framework is the bee's knees for us, and I love me some SF2. That said, the sample blog app that can be instantiated has some questionable (to me) design decisions, including automatically instantiating entities from route parameters, ie magic. Once you start piling on magic, everything starts getting harder and harder to grok. Thankfully everything is completely optional and we can stick with an explicit execution model vs magic/implicit one.
PSR-2 affects more than laravel. im not completely against framework interop standards, but mandating spaces and other code style is overstepping
If you don't at least try to fix it, you become part of the problem (the problem being that people don't know or care to fix it). You'd be in the 2nd category. We need to educate people and improve the quality of the education they receive.
Not sure if you're being facetious here, but there's obviously a big difference between an old "no new features but gets security patches" version and something that's simply unmaintained.
Yeah, you are right, I guess it can be done with a name-spacing pattern in the class names. The classes and locations of the files and names of the files are not consistent enough to make this simple in WP. It is not as though WP has not had the time to get this together.
You missed a step and didn't do a mysql_query. Also, you should stop using the mysql_ functions and use PDO or mysqli because PHP is ending support for the mysql_ functions soon.
&gt; OK... so I think what you're saying (in a lot of words) is that the benchmarks should measure the RAM too Not really - sorry, I can't explain it any simpler than the speed of code running when it is the only thing using the cache varies greatly from when there is contention for the cache.
&gt; The reason it converts is probably that Symfony Request and Response objects are mutable, and the PSR-7 equivalents are immutable That's not a problem, you can bridge that transparently: function withHeader($n, $v) { $clone = clone $this; $clone-&gt;symfonyRequest-&gt;headers-&gt;set($n, $v); return $clone; }
Despite intense scrutiny, I've yet to find any security flaws in the 2.7 branch. This means either there aren't any, or it takes someone smarter than myself to locate them. (Feel free to take this as an endorsement.)
The team at Paragon Initiative (which includes myself) is working on a new CMS platform that emphasizes secure defaults, ease-of-use, and extensibility. We want to capture the flexible nature of Wordpress but with a sane architecture. We plan to launch at FOSSETCON in Orlando (December 2015); it will be based on PHP 7. (We're still not sure if we're going to go with MIT, BSD, or GPL when we open source it.)
&gt; I'm seeing about a 9% speed gain across about 50 routes. Of curiosity, is that speed gain only in the speed at which the route is resolved, or is it the end-to-end speed of the application as a whole? 
Just a random bet: the opcodes in a file.
Sorry but I'm not sure what you would like me to do. The very first paragraph of the readme sums up how that router achieves better performance. There is also an example of the compiled router at the bottom which would hopefully explain why it is fast. 
so, it is similar to java *.class thing? can we distribute the bin instead of the source? just curious :) 
Charge clients $300/hour to build their site in Wordpress, but charge $100/hour to build it on a proper framework. Price Wordpress out of the market.
 echo "&lt;table&gt;“; while ($row = mysqli_fetch_array($result)) { echo "&lt;tr&gt;“; echo "&lt;td&gt;" . $row[0] . "&lt;/td&gt;"; echo "&lt;td&gt;" . $row[1] . "&lt;/td&gt;"; echo "&lt;/tr&gt;"; } echo "&lt;/table&gt;"; Incomplete example, but you get the idea.
just fyi, there's a shit ton of deprecate notices being thrown now. had to go back to 2.6.9 since some of them were caused by silex providers. plus wtf, don't really expect this behavior in a minor release.
EOL versions of PHP (5.1, 5.2, 5.3) are maintained by Red Hat for RHEL users. What are you saying is unmaintained?
It's not maintained by the PHP team.
Deprecation notices are [part of the plan](http://symfony.com/blog/transition-from-symfony-2-7-to-3-0-symfony-2-8-on-its-way) to help make upgrading to 3.0 easier.
Just for the record, the first paragraph of the README states: &gt; This library takes a different approach to uri routing by compiling the router to optimized PHP code, minimizing the need for traditional regular expressions. And if you want some more detail on the compilation, [see the bottom of the README](https://github.com/TimeToogo/RapidRoute/#compilation). Please let me know if you have any other questions, I will be happy to answer.
Environmental variables are defined by the environment - not by a text file. The benefits include writing the app once, and it works everywhere, even though different *environments* work differently (like connecting to a different DB in production). Look at how Heroku uses environmental variables - I thinks its one of the clearest use cases. As an aside, if you have disk-access ocd, having one less file to read of the disk will make your app that tiny bit faster (1-2ms, probably). Finally, usually using a .php config file means committing it to a git (or whatever). This is a bin no no, a. because your credentials are now in git, b. cause it means your code is hardcoded for a given environment. For a small/hobbyist project these might not seem like a big deal, but if you have a team of 200 devs, the last thing you want is all of them being able to run queries on the product DB - y'know, "just to test".
I think they are honestly just trying to make the entry point a little easier to work with... That being said, very excited to upgrade all my 2.6 projects this week.
From semver.org: &gt; Minor version Y (x.Y.z | x &gt; 0) MUST be incremented if new, backwards compatible functionality is introduced to the public API. **It MUST be incremented if any public API functionality is marked as deprecated**. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented. Seems like it shouldnt really be unexpected? Also: &gt; Deprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API. Deprecating is supposed to happen specifically in Minor version changes.
Using a PHP file doesn't mean you have to commit it to git. You can put that file outside the repo directory and... problem solved. By definition the config files are not part of an app. People have a folder like "config" and deployment-specific files can go there. I don't know why using PHP file in a separate folder is different from environment settings (except, of course the environment is way less flexible). Why isn't php.ini in the environment? Why aren't mysql.ini, postgresql.conf in the environment? Why does an entire directory "/etc" exists in *nix for holding environment-specific config files?
Here is a step that would help: allow comments to be added to comments on php.net At the moment each command has a linear list of comments and code samples people have added. They hang around for years, and get out of date. Not being able to add simple points of clarification to them means they stay as stagnant and ageing advice. Adding a whole new comment further up to say, "well, actually, thinging from twenty seven comments down, you need to do it this way now.." just feels like adding noise. For example, just looking up array_diff() to find out if it retains the original keys, and the only reference there was from a comment seven years ago. This is the comment: Here's a little wrapper for array_diff - I found myself needing to iterate through the edited array, and I didn't need to original keys for anything. function arrayDiff($array1, $array2){ # This wrapper for array_diff rekeys the array returned $valid_array = array_diff($array1,$array2); # reinstantiate $array1 variable $array1 = array(); # loop through the validated array and move elements to $array1 # this is necessary because the array_diff function returns arrays that retain their original keys foreach ($valid_array as $valid){ $array1[] = $valid; } return $array1; } It is not totally *wrong*, but just being able to add a note to suggest using array_values($valid_array) instead of that loop, could help simplify some people's code. A SO answer said (roughly): &gt; array array_diff ( array $array1 , array $array2); &gt; Which basically means it will return array1 after it's been stripped of all values which exist in array2. I added a comment to highlight that statement is correct *because* keys are retained. If they weren't, then it would not be returning array1, but returning *the values* from array1. They are tiny, subtle points to understand, but having stuff spelled out IMO really helps understanding.
Sure, that is what https://github.com/Sam-Burns/psr7-symfony-httpfoundation does (or will do). It's trickier.
 $items = [1, 2, 3, 4]; $csv = ""; foreach ($items as $key =&gt; $item) { $csv .= $item; if (key &lt; count($items)-1) { $csv .= ","; } } [/r/shittyprogramming](https://www.reddit.com/r/shittyprogramming)
exactly
It is a file saved by the new, experimental file based opcode cache (it's disabled by default, and enabled by compiling opcache with `--enable-opcache-file`). The idea being as well as, or instead of, the usual in-memory opcode caching, a file (for each PHP file) will get saved containing the opcodes. This makes the cache persistent across reboots, and so on.
Regardless of language, this should've ended up in a library under, say, SomeSortOfUtils::arrayToCsv($array), and so you'd only have to write it once in your life. Once you knew about implode() you would've optimized this in exactly one place (that utils method). The lesson is larger than knowing what PHP can do. It's about knowing what *you* do in terms of organizing your code. The rest are details.
Wow, I must be blind =\
Yes, @laravelphp tweeted about that: https://twitter.com/laravelphp/status/604723421914656769 “Thanks to @symfony’s work in bringing PSR-7 to HTTP Foundation, Laravel and Lumen will also have PSR-7 support in 5.1!”
Its looks like it will be great feature, so the cache warm up process will be lot faster
The mobile version has been a pain point for me as well. Please be patient though. I'm a one man show at this point trying to create great articles/content, designing the site, and all the other stuff. It takes a lot of work to get a blog off the ground. Thanks for your feedback though, I appreciate it!
Not to mention what happens if one of the items is a string containing a ',' or a '"'.
Well I'm chalking this up to "for the sake of a simpler example let's assume it doesn't happen". But even then, if the dev does it wrong, if it's in a library, they can fix it just once, instead of in multiple places.
Hi, just a note. When using PSR standards, you should use PSR-4 instead or in addition to PSR-0 for autloading. Also, if you are using composer (Which is sth. I really recommend) you can use the autoloader by composer, which is far more easy to implement. https://getcomposer.org/doc/01-basic-usage.md#autoloading
Please do feel free to add your own more correct or up to date comments. However, do be aware that a note should stand alone, not make reference to an existing note. Also, the user contributed notes system is deliberately designed and moderated in such a way as to not encourage threaded conversations. One of the key points of the system is for users to provide content for incorporation in to the manual page proper; the moderators of the notes (what few there are) look at the notes with that in mind. TL;DR do provide more up to date notes, don't reference other notes. P.S. If the are any particularly wrong or harmful notes then do feel free to raise a bug report at bugs.php.net or send a mail to the notes mailing list php-notes@lists.php.net 
You've hit on something I enjoy thinking about. MVC seems to have a dozen different interpretations, but what you're saying is that MVC should be (Model View) + (Controller). So the Model is responsible for the view data rather than the domain data? I work with a system that uses MCVM(C), so you have a domain Model, which handles the concept of the object. eg: A car. Then the View Model, which represents that particular presentation of the model. So you could potentially have three different View Models for three different view types of the same Domain Model. From what I think you're saying it sounds like you would still need a Domain Model, so that way of thinking about MVC is essentially MCVM, unless the Model contains both domain and view information?
&gt; You've hit on something I enjoy thinking about. MVC seems to have a dozen different interpretations, but what you're saying is that MVC should be (Model View) + (Controller). So the Model is responsible for the view data rather than the domain data? Those brackets aren't needed, the model is for the view, but it's updated by the controller, so they all play together from "equal distance" so to speak. But yes, the model was always about the view state, and the controller was always about maintaining that model. MVC is a UI pattern, the domain is not part of it. All three parts are pure UI. All sites are more or less organized compliant to MVC, but they simply call the components with the wrong names. Your "viewmodel" is in fact what the model is in classic MVC, so the pattern would ultimately not be MVCMC, it's really just: &gt; Domain + UI Where the UI is MVC, so: &gt; D + MVC The domain logically doesn't belong in with MVC, because you can have one domain layer, an entirely independent module as, say, a set of services providing an API, and then you can expose the API directly as is (to, say, mobile apps), or build multiple independent MVC web sites out of it. In MVC you can have multiple views per controller/model, but you don't have multiple controllers sharing a model. A controller pretty much "owns" its model and is the sole entity updating it, mostly based on events coming from the view. Which maps very well to the view data given to the view (i.e. again, your viewmodel).
http://www.shomoi24.com
Sounds 92% excellent! And the remaining 8% is because I don't understand how to translate the critical last paragraph into PHP. ReactPHP gives me zeromq for free. Can you write PHP pseudocode for the master process? It must be Moronic Monday somewhere... 
not sure how would i tell?
Do you just want to download the most popular packages? Seems like it makes sense to search first then sort. That way you can find the most popular package for what you want to do. 
Awesome, thanks. Did not know about PHP-PM
Semantic Versioning? Yes.... Not sure there is a more widely accepted standard for versioning.
Its kinda nice to see what the most popular packages are?
yep, with this approach you could use anything, PHP, Node.js, Go... But why not PHP? It already have good ready-to-use solutions. p.s. Personally I prefer to use node.js for push notifications. But node.js isn't universal solution.
This is what https://packagist.org/explore/popular was already, a list of stuff by popularity. And popularity is largely equivalent to the number of downloads in last 5days, so you get popular stuff *now*, not just things that had big number of downloads but kinda grew out of fashion. For searches though you can now sort by absolute download count, not sure if that's smart of if we should also order by relative popularity in that case but we'll see. In any case it's a good step forward.
&gt; can we distribute the bin instead of the source? No.
He didn't say he deployed.
who says I pushed these live? still annoying to update from 2.6.9 to 2.7 and see half a dozen notices or more going back as far as 2.2 that I aren't even part of my code (standard silex providers).
If you really don't care about deprecation warnings: ``` error_reporting = E_ALL ^ E_DEPRECATED; ``` Though, i would try and fix them (if you can)
The `+` operator looks at the indexes and doesn't override indexes in arrayA that also exists in arrayB: $arrayA = [1]; is: [ 0 =&gt; 1 ] and: $arrayB = [2, 3, 4, 5]; is: [ 0 =&gt; 2, 1 =&gt; 3, 2 =&gt; 4, 3 =&gt; 5 ] Index `0` already exists in arrayA so it won't be overwritten with the value of arrayB. 
This. I just gave a talk at cakefest about this approach. [Here](https://www.slideshare.net/gmansilla1/behind-the-scenes-of-realtime-notifications/) are the slides. I guess the video will be posted soon.
I don't know how it can be more obvious that the view accesses data from the model than it reading data from a variable literally called $model.
http://www.howtoprogramwithcoldfusion.com/
&gt; Your "viewmodel" is in fact what the model is in classic MVC How come? Is this one of those many interpretation? Can you give us a link or something? I'm curious myself. What about this stuff: http://en.wikipedia.org/wiki/Model_View_ViewModel ?
Like any term, "viewmodel" is overloaded. Many people casually refer to "viewmodel" as the "model of the view" to differentiate it from the "domain model" which the view doesn't read. What I'm talking about above is such casual use. We're talking about *the* model up there. In MVVM it's slightly different, because the viewmodel is often bidirectional, in that the view can mutate the viewmodel and the viewmodel will map this to a model mutation. This is handy for automating GUI widget data binding for stuff like editable data grids. MVVM is in fact the only MVC variation which is *slightly* different than the rest, because the viewmodel is fusing the roles of the model and the controller (and "model" in MVVM is then the domain model). While in MVC the view strictly only reads from the model (acting as a getter) and strictly only sends events/actions to the controller for mutating the model (controller acting as a setter). I.e. in classic MVC, the interaction of a data grid setting a new value for a cell would be, the view reading from $model-&gt;getCellValue($x, $y) and calling (directly or indirectly) $controller-&gt;cellValueChanged($x, $y, $val). In MVVM, the get/set interface is more "symmetric" and both getters and setters are at the same object, like $viewmodel-&gt;getCellValue($x, $y) and $viewmodel-&gt;setCellValue($x, $y, $val).
A blog post is not a dialogue, it's a monologue. Even with the comments section below it.
I wasn't particularly looking for an MVC vs. MVVM comparison. More like "who exactly said that the 'M' in 'MVC' is a _view_ model and not a domain one?". I'm open to amend my point of view - which is the mundane and vulgar interpretation that the model is a domain one -, but I'd love some links or - why not - academic PDFs? You can't just come out of the blue saying that we've all misunderstood MVC until you showed up. Because - you know - you wouldn't be the first one to say this. Why wouldn't we put your interpretation along those other intepretations you tacitly dismiss as well, and call it a day? I don't expect anyone to put too much effort in convincing lil' ol' me. Just saying. Every idiot has an opinion, right? Edit: typos.
Great. It's better, I think. But now we have a "before" without a clear corresponding "after" that shows an improvement.
So because MVC is an UI paradigm and the M is always tied with the V, it therefore follows that M cannot but be a view-related Model. Ok, I can dig it. &gt; I've never seen anyone feed their business logic models in the view yet. I do indeed have problems disproving you with a scenario. Appreciate the effort. PS: I'll upvote you so you'll be back to 1 again. Ha.
&gt; So because MVC is an UI paradigm and the M is always tied with the V, it therefore follows that M cannot but be a view-related Model. Ok, I can dig it. Basically. I'd avoid the word "tied" because someone would point out that the model shouldn't have a reference to the view (and it doesn't), and one model should be able to drive multiple views (and it can). But let's say they're at the same "conceptual level", which is the UI, or more specifically for web: the "page" (page-specific controller, page-specific *model*, page-specific view). &gt; PS: I'll upvote you so you'll be back to 1 again. Ha. I just imagine someone furiously refreshing the page and downvoting all my comments in the thread ಠ_ಠ
Maybe, but blog posts linking back and forth sure are. You should think about it; you have a lot of valuable things to say, and a wider audience for that would only be a positive overall.
I hope you don't mind me asking, but what is an LTS?
(/me shrugs) Do as you wish; I know you will.
&gt; why do you think there's this disparity between "web devs" and "devs" with regards to our grasp of comp-sci concepts I know this is a subject you've been hot on, at least since you joined Reddit last week; why do *you* think it is the case?
I think it's because many web developers aren't computer scientists (ie. have a compsci or equivalent degrees), but are forced to use concepts that fall under general programming and theoretical computer science. Design patterns, data structures, time complexity... all things that I find many web developers to vaguely know about but not enough to apply effectively. I don't think we will ever reach parity, as web developers are not all also engineers.
Is there a way I could show the icons, tables (Earnings and Deductions tables) in the generated PDF with just a small file size? Anyway, it's fine if the font is just Times New Roman. What's important are the icons and the tables. You may click the link of the post title to view the full question at StackOverflow. Hope someone would be of help. 
I prefer the brace on the next line as well. Luckily the PSR-2 standard is just a style guide - no need to follow it if you don't want to. :)
The addition of `@inject` isn't providing anything that a developer can't already do themselves if they choose. I definitely agree that you shouldn't, but the actual implementation here is the same if someone used Laravel's facades. Whether frameworks should provide additional ways for developers to write "worse" code is another debate entirely.
&gt; Whether frameworks should provide additional ways for developers to write "worse" code is another debate entirely. That's exactly the debate here. People mocked PHP for *years* for making it way too easy to shoot yourself in the foot. Writing bad code should be hard.
"This library aims to solve the problem where having many constructor parameters becomes hard to manage" I think you need some practical uses that youre solving, i think i dont get it. Because when i read that line im just thinking, this was solved like 5 years ago by basically every framework out there.. Take symfony f.e.: http://symfony.com/components/DependencyInjection Take a look at types of injection: http://symfony.com/doc/current/components/dependency_injection/types.html Isnt this what you were trying to solve? Its obvious you did your best to deliver quality, but it would be a waste if people miss out on the possible use case. I also see alot of instantiation of "services" prior to creating the container, this gets awkward real fast, because why wouldnt they by depending on other services? Or why would i not want to *not* construct them untill i really need them? Anyway, i think some practical use not solved by other frameworks would be good.. 
You could have a look at http://appserver.io/. I'm not quite sure if this meets your needs, but they built a thread based server in PHP and provide services for queues and database access.
The first give away that your professor probably hasn't used PHP in a long time is the fact that he made a comparison between PHP and Rails (assuming he was referring to Ruby on Rails.) Comparing a framework to a language is a good sign of misinformation on his part and a personal grudge against PHP. Do not be discouraged! I have been using PHP for quite a few years now and I can tell you it has grown! It is true that I have found languages like Python to be nicer but PHP still gets the job done. Just look at the statistics on Packagist, [packagist stats](https://packagist.org/statistics): if no one should use the language anymore as he claims, why are so many libraries being submitted and so many installed on a daily basis? PHP has an active and vibrant community, easy to get started with (with the number of bad practices you'll make and PHP the right way will help avoid and/or fix), an awesome documentation (php.net/[function_name] still amazes me), large support from hosting providers and the many libraries to make your life easy. And that's the highlight. So when someone criticizes a programming, just wonder if they've used the damn thing on anything more than hello world. In fact, have they built anything significant in the programming languages they advocate? Your professor sounds to me like someone who will blame the tool for his own shortcomings! Go PHP!
Just to add to what deadlockgB says, you could also use [fontello.com](http://fontello.com/) to create a font file that only includes the icons that you use which will reduce the file size considerably - fontello has a number of icon font packs available and you can pick and choose which icons from each font that you wish to use.
Attempting to do device detection in this manner is flawed at best (it also doesn't tell you whether the device is a mobile phone, tablet, wearable or something else). You're far better off using a library such as [Mobile-Detect](https://github.com/serbanghita/Mobile-Detect) or Piwik's [device detector](https://github.com/piwik/device-detector) which are well tested, well maintained and as a bonus can provide you with much more information than just "is it a mobile device".
Not sure how the author missed [Mobile-Detect](http://lmgtfy.com/?q=mobile+detect).
Where is the benchmark?
Where is the character development for the story? What are the protagonist's motivations?
And redirecting to m.example.com for your mobile site is even worse. The *last* thing you want to do on mobile is add more HTTP requests, since they're so damn expensive *glares at Wikipedia*
What you say is a popular explanation, but seeing language or network as hard boundaries for architecture is not that much of a platform issue as it is an issue in the mind of the developer. Have you seen a C developer explain confusion in their field with things like "some of my model is in C code, some is in the standard library, some in the OS, some in the compiler and some is in the motherboard and CPU logic, and my state is split in RAM and disk separate from the CPU". If you really consider it, they could propose that explanation, but it's not a popular excuse there, while for us it is somehow. A boundary is where we decide it is. Web sites factor pretty cleanly into two MVC stages (one covering the whole app UI: server and client, and one nested in the client part of the view, for more interactive JS-driven apps). When they don't, when you dig in you see the author reports lack of alignment not between their app and general concepts, but between their app and their misunderstanding of said general concepts. Maybe I'm a one-trick pony, but I use the same patterns no matter the context (desktop GUI, mobile GUI, services, web sites on the server, web site UI on the client-side, heck even game engines) and I never saw this supposed friction when switching from one place to another. Conceptually it's the same, superficial details change. It also doesn't explain our insistence on abusing other terms, like "middleware".
the benchmark is the comparison from blackfire profiler: https://blackfire.io/profiles/compare/6af13ebb-de9c-453f-9d87-681bf416eeac/graph
&gt; This library aims to solve the problem where having many constructor parameters becomes hard to manage Many dependencies may be an indication your class is doing too much, and possibly violating the [Single responsibility principle](http://en.wikipedia.org/wiki/Single_responsibility_principle). Splitting the class into smaller ones maybe the way to solve such problem.
Haha, I think something to that effect is happening, for the record I've been upvoting as this has been a good conversation.
Why won't you place the flash function inside a short namespace, rather than warn users about potential issues? :) edit: I see that the only opened issue you have is covering this already.
&gt; getDB() always creates a new connection regardless of whether or not one already exists Maybe you want to reconsider suggesting to a framework maker that they should hardcode singleton behavior in their DB factory :P &gt; error(): acts differently on dev and production - on production it returns false and code execution continues anyway (probably causing more errors due to the first), but in development it throws an exception, which halts the code (assuming nothing catches it). Technically, that's how assert() works, but I think OP just forgot to put some code in there (notice the comment). Good catch.
Agree, but the "one file" and autoload, yes there are some issues, therefore is still as 0.x version, thanks for your review! 
That's fine, as long as you accept a few items central to your argument that *many of us reject*. 1) That the network boundary doesn't matter 2) That the absence of an element of in the pattern doesn't cast the entire pattern out. On the first point, it wouldn't matter if the connection was continuous, but it's not, so it matters. It matters because at any point in time we can be aware of the application's state at that point in time. We cannot be notified of changes in that state. Everything we are looking at is assumed out of date. On the second point, there are many who would consider the fact that the view is made aware of state changes to be a central component of the formal MVC pattern. Now, you can redraw the boundaries, "zoom out" etc, but the more you do that the less useful the definition becomes. You essentially end up concluding that all apps have state, a means of acting on state, and a means of displaying state, therefore all apps are MVC apps. It's like saying that because a commercial office building has walls, floors and a roof, that a house which shares these components is also a commercial office building. It ignores some very real and important differences in how they are put together and ultimately used. Yes, zoom out far enough, or look at them in 2 dimensions from the top down and they are very similar, but tilt the camera ever so slightly...It becomes a matter of perspective. The point here isn't, and never has been, to redefine things for the sake of doing so. The point is that we're (and this isn't limited to PHP, it's happening across the web development world) observing that there are things about how we work which do not fit the definition. And we're observing that we *like* the way we work. It's useful to us. And we're deciding to attempt to codify the way we work with new definitions which more accurately describe how we work. Every "son of MVC" pattern has a sense of this about it. MVC wasn't *quite* explaining what was happening, what was happening was fine and useful, so what was happening was redefined. Are they related? of course. Are they the same... only if you look at them at a distance, in 2 dimensions, from the top down, and ignore the very real constraints that are in play. You claim to not have suffered the problems of context switching between front end and back end development when the terminology is the same. That must be wonderful for you. The friction is a story I hear *all the time*, with every team I've ever worked with. And it's a story you hear retold by many skilled, knowledgable and grizzled veterans of the web development world. As for "abusing" terms like middleware - terminology is valid if it is useful to the people using it. Coopting a term (and it was probably coopted as a smart branding which stuck) is entirely fine, as long as we all know what we are talking about and the use of that term is more or less agreed upon (implicitly or otherwise). You see this happening everywhere - it's not a particularly unique phenomenon. We tend to find definitions which fit until better, more accurate ones come along and take hold. 
There's also http://browscap.org &amp; the original PHP `get_browser()`
Laravel
Lumen
&gt;This is not exactly a PHP question, but I can't find a better thread to ask because it's about the PHP community: why do you think there's this disparity between "web devs" and "devs" with regards to our grasp of comp-sci concepts, and when are we going to reach parity? I don't necessarily thing that there exists a disparity, but rather that you might be suffering from confirmation bias. 
Is there any package/library that builds SQL queries (I need mostly INSERTs and UPDATEs) from arrays and returns them as a string? I don't even need to connect to a database. I'm writing a script that parses csv files exported from Salesforce and I need to insert and update data to [CartoDB](http://docs.cartodb.com/cartodb-platform/sql-api.html#making-calls-to-the-sql-api). So I just need the written queries to pass as an API call to CartoDB, and I'd rather not do this "manually."
Silex
Ok, so you're saying I'm... deliberately selecting examples where webdevs and devs disagree? What am I trying to confirm precisely?
I know what that bias is. I don't know what you're suggesting I exhibit confirmation bias *about*.
Protip: take an existing library and add create a new class (that extends from the lib) and add a method that prints the string.
You're claiming that there's a disparity between web developers and general developers when it comes to the understanding of concepts in computer science. Since you believe this notion, you're probably (unconsciously) searching for instances to validate that belief rather than looking at the whole. 
"General opinion" states that you should be using PDO to interact with your database from your PHP scripts. And the case you are defining, in my opinion sounds like a good case for prepared statements. I'm on my phone, so I can't write you a solution right now, but I think this SO question will help to understand: http://stackoverflow.com/questions/1457131/php-pdo-prepared-statements So, you can prepare the statement first, and then execute it using the array you mentioned. EDIT: Sorry, I've reread your question and my answer doesn't say anything about that. Sorry :S
so psr7 is shit and slower, great combo. 7ms and more annoying to work with. 
Bubble sort is not recommended as learning material, I think...
Looks like they are building a bridge to solve that: &gt; Because of immutability it is very hard to make HttpFoundation embracing PSR-7 without a huge backward compatibility break impacting existing thousands of existing applications and bundles. However, as first explained by Christophe Coevoet during a Symfony IRC dev meeting, creating a bridge allowing to convert HttpFoundation requests and responses to PSR-7 messages and vice versa will provide a first layer of PSR-7 compliance for Symfony. During the development of that bridge, we established that using PSR-7 messages in HttpKernel controllers will also be possible. Taken from http://dunglas.fr/2015/06/using-psr-7-in-symfony/
I can't think of any which are missing, but I have followed and upvoted a couple. :)
Nicely said.
Yaf which is written by Laruence who has a @php.net mail address,that means he is php core contributer. We chinese jokes he is the best programmer in Asia,because PHP is the best language in galaxy. XD
&gt; If you thought moving Facade was hard, the amount of inertia behind Middleware puts it firmly in the "just go with it" basket I think. Agreed. In a way we got lucky to see "facade" being misused so early and so prominently.
Thanks for the share. How would this layer of abstraction (if used in production) compare to PHP filters (which are already mature and help with a number of validation scenarios)? Have you benchmarked the library? How much overhead does its usage incur?
[**@laravelphp**](https://twitter.com/laravelphp): &gt;[2015-06-01 14:59:20 UTC](https://twitter.com/laravelphp/status/605388164241485825) &gt;Laravel 5.1 will be released on June 9th with LTS, absolutely amazing documentation, and a ton of great new features! :\) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/3836zz%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
When I found about this function, i created a small function which i registered to the shutdown handler and let it send me an e-mail of the last error with debugging details. I've solved many problems without the customer knowing about the problem :).
&gt; It's not exactly a shocking statement that the web dev community has a higher % of non-experts and is insular enough to develop their own jargon for existing concepts. Perhaps. I'm interested to hear about your background and experience, that gives you this outside and longer-term perspective.
What's the deal with this sub and the Aura framework? I keep seeing few guys trying to plug it but they all get downvoted to hell. Does /r/php not like obscure frameworks or is it just Aura? I ask only because I want to eventually plug my own framework here when it's ready.
Hey, now that's a neat idea.
After Pollinate landed in Ubuntu 14.04, it's safe to say that Canonical (at least) makes questionable choices.
I love PHP and I appreciate people like you who are still working to make it better. Thank you. I'm not qualified to comment on your work without more intensive analysis but I like the way you are thinking. Keep it up!
Thanks for the words of encouragement. I have been working with PHP for more than 5 years now, it was time to start giving back to the community :-)
I would say it's a 10 minute upgrade at most.
Why DifficultToReadClassNames instead of Easy_To_Read_Class_Names?
A rundown of the [New Features in 5.1](https://laravel-news.com/2015/04/laravel-5-1/): **Core:** * Long-term Support * Commands folder renamed to Jobs to make it's intended usage more clear (for queued actions) * All code in the `app/` folder and generated code will now be compatible with PSR-2 * Use Laravel's DI container in Blade: `@inject('stats', 'StatisticsService')`, followed by `&lt;div&gt;{{ $stats-&gt;getCustomerCount() }}&lt;/div&gt;` * Custom parameters for middleware: `Route::get('/', ['middleware' =&gt; 'role:admin'], 'uses' =&gt; 'FooController@Bar']` will inject "admin" into any middleware's `handle()` method if there's a parameter named `role` * Broadcast events to JS by specifying an event property on the event via Redis or Pusher. Example: protected $broadcastOn = ['channel-1', 'channel-2'];` * Laracast's [Integrated Testing package](https://github.com/laracasts/integrated) will be included by default * An `$except` property in the CSRF token middleware allows you to exclude it from any specified routes. **Other Components:** * Elixer will be compatible with ECMAScript 6 by default * Envoy will be capable of running local shell scripts
That's about all it took me. Couple find/replaces and folder rename or two and I was done.
[Upgrading to 5.1](http://laravel.com/docs/master/upgrade#upgrade-5.1.0) looks pretty straightforward. The refined documentation is also great.
Oh, I understand. But like I said, these queries are passed as parameters in an API call to CartoDB (example [here.](http://docs.cartodb.com/cartodb-platform/sql-api.html#write-data-to-your-cartodb-account)). I assume they do whatever is necessary on their end, it's not really my responsibility. I think the easiest solution here is to just pass the values as raw values inside single quotes *inside* double quotes. $insert-&gt;set('foo', "'{$data['bar']}'"); Kind of a hack, but works for what I need. What do you think?
Yes, you could totally do that, although formally and professionally I recommend against it. You'll hack yourself right into a security breach that way, but it sounds like you're aware of the dangers involved. EDIT: More specifically, the moment someone adds a single-quote to a value, the game is over and you have lost. :-/
I am working on a project with a file upload section to send the file to an email. I am not as strong with php as I'd like to be so I'm having some difficulty. I am trying to use mail() with no success. I am working in cascade if that helps any and have my page directed to my .php in the same folder. Let me know if I am leaving out important information to help answer this question! Thanks!
https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md StudlyCaps for class names, Underscore_Separated for pseudo namespace class names pre 5.3. It's not that difficult to read once you get used to it though, and personally I find the underscores to be an annoying extra character to constantly be inserting.
Not sure where to ask this but I'm wondering if people have any good resources on how to be better at UI and UX? I've got the backend stuff down but to be a lethal developer I want to also hone in my UI and UX skills.
&gt; language or network as hard boundaries [...] is an issue in the mind of the developer. Have you seen a C developer explain confusion in their field with [...] Your example is utterly irrelevant to your claim, because your example "C developer" is **NOT** dealing with multiple languages, and **NOT** dealing with a big network boundary in the middle. How about you try again, but maybe with a "C developer" (or any language, really) who is building a networked FPS game, where each client has a secondary scripting language operating certain parts of it. 
Your example tries to mirror the original setup. And my example is about realizing that there are just as many moving parts in a seemingly simpler setup.
What about: "'" . pg_escape_string($value) . "'" The docs say their database is PostgreSQL. Edit: tested, and it works fine. Thanks for your help and for your work.
Right on. :-)
Here is what I have been using for years now. It interpolates PDO prepared statements: function interpolateQuery($query, $params) { $keys = array(); # build a regular expression for each parameter foreach ($params as $key =&gt; $value) { if (is_string($key)) { $keys[] = '/:'.$key.'/'; } else { $keys[] = '/[?]/'; } } $query = preg_replace($keys, $params, $query, 1, $count); #trigger_error('replaced '.$count.' keys'); return $query; }
Slim Framework http://www.slimframework.com/
^ Don't use this in production or outside a controlled environment. You'd be at risk of SQL injections. 
Here's hoping the documentation is legit amazing. Having to watch laracasts to jump into the framework has always been a hassle. Outdated and forgotten as it is CodeIgniter had pretty great documentation. The current docs for laravel and digging through source work once you understand it a bit, but it's not incredibly pick-up-and-go friendly right now.
Uh...there's no way I'm writing logic like this: Gatekeeper::createPolicy(array( 'name' =&gt; 'admin-test1', 'expression' =&gt; '"group1" in user.groups.getName() and "perm1" in user.permissions.getName()', 'description' =&gt; 'See if a user has "permission1" and is in "group1"' )); It would be much better if the "expression" was a closure called by the gatekeeper instance, so I could write it using regular PHP code instead of proprietary pseudocode parsed from a string. Gatekeeper::createPolicy('admin-test1', function(User $user) { return $user-&gt;isInGroup('group1') &amp;&amp; $user-&gt;hasPermission('perm1'); }), 'optional description');
(I'm the lead on Aura.) For what it's worth, the project doesn't live or die on Reddit votes. People voting it up or down here does not impact the usefulness or applicability of the packages. So if satisfied users like to vote up Aura-related stuff, cool; if The Usual Suspects prefer to vote it down, it's not especially damaging to the project. People will recognize what they find useful either way.
Speaking of The Usual Suspects ... ;-)
I addressed this topic indirectly when previously I mentioned the More PHP Paradox. So, on top of all that you've written, there is also the risk of dependencies explosion: sometimes you want a small feature of a dependency, that by itself depends on a whole lot of other dependencies. 
I've no joke put 120 hours into the documentation the past 3 weeks. I really think you're going to see a major difference. :)
if it helped you, then there are people out there who could benefit from it as well. Improve it, and see where that gets you
All right. Well, while it's not a long list, this does, in fact, mean that it doesn't follow semver.
Thanks for the response! I have a similar structure for some code I wrote at work - it's an importer class that can transform data before attempting to validate and save it. It can accept an ImportTransformer instance or a callable, so I can write the transformer code like this: class FooImportTransformer { public function transform(array $incomingData) { //do something return $transformed; } } $importer-&gt;setTransformer(new FooImportTransformer); Or like this: $importer-&gt;setTransformer(function(array $incomingData) { //do something return $transformed; }); Sometimes a separate class is overkill and a closure is a better fit.
&gt; Could you at least TRY not to be generally offensive in the way you post comments? The arrogance in your tone is astonishing at times. Trying to win people over to your way of thinking by being generally rude and insulting is not a winning strategy. I'm not being rude, I'm just being direct. If I wanted to "win people over" I'd probably have selected a different username. Opinions are not about picking sides, but about sharing insight. Casting it as a popularity contest is primitive thinking which ends up with the search for insight fading somewhere in the background. If my opinion gives someone insight, great. That's all there is to it. If not, then the whole conversation is pointless. &gt; Every single team I've worked in without fail has suffered issues with communication and context switching which have been put down to issues of defining MVC within their respective domains. This does seemingly attack your own point... that overloaded or context-specific MVC variations are better somehow. If that's better why is "every single team" suffering issues with communication and context switching? This is why I describe how the same *exact* MVC pattern applies in different contexts. Using one pattern is not confusing. There's no context switch if you never switch context. There's zero reason to give the same component name (say, "model") mutually contradicting meanings (view *must* read all its state out of it.... or view *must never* access it, depending on "context"), or have two patterns that overlap 90% except for some trivial detail. Such contradictions and overlaps don't come from necessity, they come out of ignorance.
Thanks, I'll give this more time as soon as I'm done with the semester. Any coding comments? or any approaches I should follow? Thanks
&gt; How many open issues? A handful of issues is alright, but 100+? Scary. &gt; How long before an issue is fixed? Let's apply this metric to PHP itself: 5075 open issues, oldest more than 10 years.
No, the whole thing is one field. If you are at all interested in CSV, then go read the RFC I linked. It is really short and easy to understand.
No, I get what it's supposed to do, I was just wondering what the php function did with the b's that you pass in.
&gt; I ask only because I want to eventually plug my own framework here when it's ready. BTW, I highly recommend using Aura.PlugYourFramework when time comes to plug your framework.
NotDifficultToReadMyAss... I know that's the PSR, I was just wondering why this idiotic choice of convention :(
The output from PHP's function is simply a syntax error according to the syntax defined in the RFC.
I didn't know that was an Aura feature. Well I don't want to be outdone, looks like I need to add a "PlugYourFramework" module to mine
What are you insinuating? 
I insinuate nothing; I note only that your comments indicate a predisposition to vote down Aura-related stuff because "that line [of aggressive self-promotion] has since long been crossed." I enjoy consistency, and so your consistency is appealing in its own way. ;-)
&gt; Building a little SaaS company &amp; want the platform to be PHP. This is not a trap question: why do you want the platform to be PHP?
Perhaps we can collaborate on a PlugYourFramework interface; then we can be standards-compliant as well!
Quit being an asshole, Paul. 
Oh, gotcha. I think it's a combination of being such an old standard for class names that's so widely used in so many languages, and that the Pseudo_Namespace_ClassName convention was common enough in pre 5.3 code that it made sense to get away from it to avoid confusion.
What an excellent contribution to the discussion!
Is it based on Symfony LTS?
PHP is not on the same scale as the dependencies in the blog post. It's several order of magnitude bigger, so it comes with different challenges. Not all 5000 issues are bugs, some are documentation issues, some are requests. I do agree however that the list of issues is massive ... and **scary**.
I would guess it would be easier to hire people with PHP experience than Scala or Haskell
Don't answer for other people, let them answer. You never know when you might learn something. BTW, I think there may be more than three languages suitable for SaaS out there. There might be four. [Even five](http://prosoft.guru/wp/wp-content/uploads/2014/12/progLanguages.jpg).
Developer time &gt; CPU time except when you start scaling... And you don't need to get at Wikipedia level to feel the pain. Well, if developer time &gt; CPU time always, FB wouldn't have done HH. 
Yes. 
Yeah, I could definitely see something like that integrated into the system. It would definitely make things flexible too. Let me think on it...
&gt; If I wanted to "win people over" I'd probably have selected a different username. If you want to bring people along with your point of view and "share insight", being a complete dick is usually not a winning strategy. You immediately get everyone off side with your style - and suddenly it doesn't really matter whether your position is valid or not, nobody wants to engage with you. They just roll their eyes and reach for the down vote button. &gt; Casting it as a popularity contest is primitive thinking I'm not "casting it as a popularity contest". I'm asking you to moderate your "direct" tone. It is entirely possible to have an opinion without being a dick about it. &gt; This does seemingly attack your own point... that overloaded or context-specific MVC variations are better somehow. If that's better why is "every single team" suffering issues with communication and context switching? The issue, in my experience, stems from the context. Better naming alleviates (again, in my experience) the issue. So no. I don't think it attacks my own point. &gt; or have two patterns that overlap 90% except for some trivial detail. Multiple, non-trivial details. But we're never going to see eye to eye on this point, so I'm not going to continue this debate. &gt; Such contradictions and overlaps don't come from necessity, they come out of ignorance. Ahh so your opinion is insight, everyone else's is borne of ignorance. riiiight.
Of course, that goes without saying. This is for debugging purposes only.
I wondered about that myself. BringTheTanks, zen-of-code, and now idiot-with-opinion. I wonder if this account will suddenly stop posting too. (I actually liked BringTheTanks, more so than this current incarnation.)
This is reddit. People answer for others for the same reason you say not to answer for others. And while your word cloud does show a bunch of different languages, a bunch of them are languages i definitely wouldnt use for web development, and several of them aren't even really languages.
Why should I answer you? You're just an idiot with an opinion! Seriously, fantastic question. I'm open to change. However: 1. As [/u/StaffOfJordania](http://www.reddit.com/user/StaffOfJordania) says, it's popular. Tons of people know PHP, which means presumably I will be able to choose the pick of the litter. 2. It can be deployed on just about any host, with minimal configuration. That means if I want to switch hosts I won't have to worry about weird, undocumented features one host has that another one doesn't, and that I didn't know I depended on. 3. Drivers for all popular SQL databases 4. PHP powers most of the web and some of the biggest sites use PHP, so I know it can handle anything my particular app will throw at it. 5. The runtime library is huge and well-documented. My runner-up languages, Haskell and Python, have driven up the price for web developers and yet are still hard to staff for. 
I really do love their documentation and Laracasts. Version 5.1 is also moving in just the direction I want it to.
I'm not entirely familiar with it, but at Symfony Live 2014 in London, Matthias Nobak talked about http://puli.io/ for managing assets across libraries. It sounds like it might be of interest to you.
All right, thanks for indulging an idiot with an opinion ;) I think PHP is always a great choice for a web client. For services, I guess it depends on the services. Just make sure your devs keep your core business logic relatively decoupled from the web client &amp; it'll be all right. [Think like Amazon](http://apievangelist.com/2012/01/12/the-secret-to-amazons-success-internal-apis/).
I hope that guy never needs to use the actual `du` command for anything. 
He must have no disk space problems if he's never used `du`. Oh wait...
This "tutorial" makes things way more complicated than it should be. Docker provides official PHP-Apache, MySQL, etc. images, to the point where it is sometimes not even necessary to have your own Dockerfile (assuming you're only using Docker as a development environment).
I'm pretty much starting a Laravel app this week; will I be okay forking laravel's develop branch in anticipation of the official release?
Just started using laravel and I love it! 
If you don't like it, don't use it.
By leaving your reply vague and... strange, you are definitely insuating something.
How good is the support PHP's support on stormpath api?
Have you known me to be anything other than explicit and blunt? I said he appears predisposed to down-vote Aura stuff, based on his own words. There's nothing to insinuate.
Even PHP7 can't make Magento fast.
No, you said &gt; Speaking of The Usual Suspects ... ;-)
He was asking what you were implying by the comment i quoted. None of the other comments you made matter in this conversation.
I implied nothing. I stated what he said. EDIT: Again, the comment you state is "implying" something is in direct reference to the earlier one I linked you to. There's no "implication" there, only "statement." You can have the last word here if you like; I'm going to bed.
I wish I could upvote you more :D
Can you go into some pitfalls of the way you do it for a noob. I still haven't gotten on the docker train cuz I have my Dev environment setup already as add-apt/apt-get is already incredibly easy to use and I haven't had to set anything new up lately. But I do have a new machine in my near future and if docker is somehow better than a local environment I would like to try it and see. Also, Ubuntu released snap and it seems very similar to docker, should I go with that if I'm already completely Ubuntu based? (Desktop/Servers)
Calling people "a complete dick" is deemed "quite respectful"? Time to [abandon thread](http://i.minus.com/ibcaAlyHDKNVw1.gif).
Yes I'm sure you'll fit right in here. There's nothing we like more than rockstar ninjas.
http://www.reddit.com/r/forhire
https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/ is a nice example based on Symfony+FosRest+JmsSerializer+NelmioApiDoc
&gt; However, Stormpath ID Site is different from traditional from traditional You've repeated yourself here, but this article does look interesting. :)
The "volumes" specified for the nginx &amp; php containers defines a host folder &amp; where to mount it in the docker container. So "./src:/var/www" means; mount the src directory relative to the current folder into the docker container at /var/www. Then on your host you can edit the files under ./src and the changes will show up in /var/www Database persistence is briefly explained in the blog post; but the gist is, data created inside docker containers will disappear when that container dies - which is obviously bad for anything that needs persistence like DBs or logging. The workaround is to have MySQL save it's data to a volume, which similar to how files are copied into the nginx &amp; php containers, let the data persist on the host.
I'd never trust online authentication services and I'll stick to standard libraries.
Are you telling me that you've been programming PHP for over 9 years?
Have a look to: http://restler3.luracast.com/
I guess it's too much effort to put a couple of words in the headline what is the interview about.
The finally shouldn't be executed because the exception occurred outside of the try block. 
What browser are you using out of curiosity. This is the first complaint I've gotten since I changed it a few months ago, but I know the rgba lightening I'm doing might not work in some browsers.
Chrome Version 43.0.2357.81 on Ubuntu 14.04 TLS.
I agree with every word... Also it follows we can make our lives better by being careful with choices. Not everything is cacheable, or in other terms, can be addressed by architectural design. 
Thanks for the link. It seems that puli would be useful if the packages I was writing had the assets saved directly within the package (e.g. vendor/package/resources/js/jquery.js). However in my case, I'm ideally wanting a way to list my front end dependencies in the package's NPM `package.json` file so I don't have to commit the assets to version control, which from what I've read in the Puli docs this morning, is something that Puli wont help with.
Serious. At this point I'm just looking for some decent examples, whether they are truly RESTful or not.
Please don't use the word "rockstar". Or ninja or guru. We're supposed to be professionals, use professional words and not the machinations of recruitment consultants trying to sound kooky. /r/mildlyinfuriating 
 I don't know if it will help, but I had to develop a kind of REST api for an ember app recently, and the docs in the ember site about the expected behaviour of the api were a nice spec definition about how the api should be. And I'm sure that angular, backbone or react will have similar examples, so if you are interested in some opinions about which are the REST API specs this sites are sure worth a look (I've metioned ember because it's the one I know). I'm sorry I'm not able to provide help about the actual implementation, it's not open source because of work rules... :S PD: link to the ember specs (just ignore the ember code an look at the server response examples) http://guides.emberjs.com/v1.12.0/models/the-rest-adapter/
Vagrant actually can use Docker as a provisioner, so you can get best of both. For the DEV enviroment, you really want a Vagrantfile that not only manages your dev box, but also it presists your database and other files. You really don't want to put your database on the host while the server runs inside a container - well, if it's a small project and with small database - it may work well enough. But when you have a 15GB dev database (project is complex, it needs all that data to work properly, and besides, you just can't clean out production data from it, because it will break many things and show incorrect data), it's loading into MySQL takes up to an hour - you really really really do not want a docker container for it. You want Vagrant, so the DB presists. Docker and Vagrant should co-exist for a DEV enviroment. Production is another story ofcourse, but because you can use Docker as vagrant provisioner, it should make no difference.
As an example of a good request authentication mechanism, see Amazon's request signing: http://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html At least in my opinion, this request signing approach is superior to the common "OAuth crap". 
Take a look at the joind.in API: https://github.com/joindin/joindin-api
Yes! Thanks! Added to the list.
If you have Symfony and Symfony2, you should probably have Zend Framework, and Zend Framework 2. I still actively maintain and develop a ZF1 application, and so do many other people too. If not for current user base, atleast include it for completeness and concistency. The same can be said about all previous major versions including CakePHP 1, 2, and 3; and probably Laravel.
Laravel 5.1 documentation will also be awsome and even someone who doesn't know a piece of Laravel, the 5.1 documentation will take care of it.
haha. Thanks for making me aware of this. I've changed the recommended alias to "dockup".
like I hadn't tried that 
[CiiMS](https://github.com/charlesportwoodii/CiiMS) is an open source blogging platform that has a comprehensive JSON REST [API](https://github.com/charlesportwoodii/ciims-modules-api) module that's used for almost every function of the platform. Documentation is available in the README file, but it's a lot easier to read on our [documentation site](https://docs.ciims.io/api.html). Would be happy to answer any questions about it if you have them.
&gt; Docker and Vagrant should co-exist for a DEV environment. Docker compose is much better than Vagrant.
Tell this to the people throwing insults, not to those receiving them. I'm done here. 
Thanks! I will push a fix to that. #MoarCaffeineForMe
&gt; Likewise, changing the signature of an existing method to add an optional parameter is not a BC break either This is not necessarily true. If someone is extending one of your concrete classes and overriding one of the methods, strict standards will throw a non-fatal warning if the method of the parent class contains more ~~methods~~ arguments (fixed) than the child class. class PackageSession { public function validate($timeout = 900) // we updated this package to add $timeout = 900 option { echo 'not valid!'; } } class ExtendedSession extends PackageSession { public function validate() { echo 'definitely not valid!'; } } That will issue a warning *"Strict standards: Declaration of ExtendedSession::validate() should be compatible with PackageSession::validate($timeout = 900)"*
Drupal is showing a great example here. Hopefully more PHP projects will follow. Actually I encourage every OSS projects to consider setting up security bug bounties. Even small bounties (say, $5 for example) can make a difference. Besides possible bounties paid, this will probably encourage the project developers to actually think about security more "ground up" and thus leading to better software. It's a win-win.
Thanks, Enygma! We're investing pretty heavily in the PHP libraries this year, increasing the pre-built functionality and building out tutorials and samples across the frameworks. A number of our larger clients use Laravel and we're seeing large businesses request PHP support, which is pretty exciting. 
&gt; Drupal is showing a great example here. Hopefully more PHP projects will follow. I'll follow it immediately. Are you willing to donate to my project? What you're saying is that every open source project, most of which are free to use, should have a paid quality assurance team (because that's what a paid bug bounty is). It's not due to a lack of *will* that they don't all do this.
....and it's added :) I just tagged a new release (2.2) with support for closure-based policies: http://gatekeeper-auth.readthedocs.org/en/latest/policies
Yeah, Dave Marshall pointed that out on Twitter as well. I've updated the article to reflect that. Thanks for pointing it out!
&gt; What you're saying is that every open source project, most of which are free to use, should have a paid quality assurance team (because that's what a paid bug bounty is). It's not due to a lack of will that they don't all do this. Nope, that's not what I ment. I'm saying you could set a small bug bounty for your project. Be it total of $20, divided into, say, 4 x $5 bounties if you will, that could be enough to make a move. Paid bug bounty program doesn't have to be anything else than rules and the bounties. It can be that simple. I offer security bug bounties for one of my projects and it is actually that simple as it sounds ;) But the donations you mentioned is an idea I was (if I don't recall incorrectly) throwing out here in /r/php some times ago. Something like crowdsourced security bug bounty programs for OSS projects. 
Don't confuse CAD for USD. For me shipping was about $16 USD.
It depends, I agree some may find it insulting if a major security bug in Twig results $5 payment. But for small "one man" projects $5 could be just fine "thank you". Remember $5 is just an example. Some could offer much more higher bounties. And the payment levels could start from $1 and go all the way up to, say, $250 (I mean $1 bounty from Twig could be very acceptable if it is very minor or even kind of cosmetic bug). If you think it closer, I think this is not at all insulting in any way if more small projects starts such small security bounty programs, even with total of $20 payments each (or be it even $5). And the payments are only half the cake. Offering even one bounty worth of $5 could very well increase the project quality. This is something one should consider before calling a security bug bounty program instulting.
https://github.com/WP-API/WP-API
This is very exciting. I hope the katana project receives a lot of love now.
I would take the approach that if it is mentioned in formal documentation, it's covered by BC, and if it's not, it's considered private, and if you extend it you're messing with internals.
Public is public. If it's exposed to me, and you break its API, that's a BC break. It's pretty cut and dry. There is no package visibility in PHP, so let's not pretend.
Yeah, I have to go with /u/drrck2403 here. The only alternative I can think of in PHP would be a "gentlemen's agreement" like PEAR had regarding methods in PHP 4. Underscore-prefixed methods were considered non-public at the time; perhaps underscore-prefixed classes could be considered non-public outside their respective packages. (Probably a bad idea.)
Also, love how the function name is "encrypt", when really it should be called `Tools::notCrytographicallySecureMD5HashSeriouslyDontUseThisForHashingPasswords($string);`
http://docs.sylius.org/en/latest/api/introduction.html These guys are using TDD/BDD too, so should be a good example to follow. Also, http://lakion.com/lionframe
Namespaces are not packages. You'd still have the same problem.
Form/API controller creates a DTO. This may be an stdClass instance, an array. Sometimes you will need to create classes for DTOs. Validate the DTO in the controller and pass it to some factory method of your business objects. Like Comment::createFromDTO. This way you can incapsulate avoid using getters/setters and large constructors. Also what is your Command doing? 
I am not sure if it fits here as I am not into DDD, but perhaps creating a class with set of public fields (like C++ struct) and passing instance of that class to your handler will work? (and will be IDE friendly)
Well i was thinking something like making classes visible only to classes that share the same top level namespace
Yeah, that's similar to what the Command object is. It acts as a DTO (data transfer object) and is sent to a Command Handler that deals with what actually happens to that data. The issue I was having was about having an object that had (at the moment) 19 different public fields. It seems excessive and I felt (and still feel) like there should be a nicer way of dealing with them. Thanks
&gt; Once an interface is published as “stable”, I don’t see how it can be changed at all That's why Java introduced default methods for interfaces. Let's wait 5 years and it's here as well.
With the attributes is that another DTO or a simple array? In this case all attributes are likely going to be needed (since it's a single form to update all 19+ fields on the `User` model). Or would you split this off into a number of different commands that each update a subset of the users details e.g. `UpdateUserContactInformationCommand`, `UpdateUserAccountDetailsCommand`. Could I check, when you mention the event store, these are events that are fired after the user has been saved back to the database, correct? They're not events that actually do the saving (that should be part of the command handler, correct?).
Yes it is, but on the other hand the technology hasn't significantly changed since then. Also: http://williamdurand.fr/2014/07/02/resting-with-symfony-sos/
Oh and concept of DDD is immutability, yes? So I think passing all to constructor is the only ide friendy choice, though I'd use array personally, and throw in constructor if some attribute is not set. It is harder to push data to object when using array, but it is more readable afterwards as you are seeing in code both keys and values, not only list of values. And I personally spend more time reading code than writing it.
The attributes and relationships are just an array's. For you I would do the following 1. Commands; `RegisterAccount` and `UpdateAccount`, where the attributes is for example an array containing `name` and `phone`. 2. The handler checks if the variable are available in the command (null is a valid input it means empty the value). If it is available it calls a function on the aggregate. The aggregate in this case is the Account, and has 3 functions `register($name)`, `rename($name)`, `setPhone($phone)`. `RegisterAccountHandler` calls `Account::register($name)` here $name is a required property and if the `phone attribute is available we allso call `setPhone`. When an update is done via `UpdateAccountHandler` it just checks the command, do you have a name. If yes call rename etc. This is also why an array is important because `null !== key not exists` (although this is more an API thing). 3. You now have three events `AccountRegistered`, `AccountRenamed` and `AccountPhoneSet`. These events you save, could be just an `serialize`. In an event listener you just write to a database you actualy query for your view. A good example could be found here http://buttercup-php.github.io/protects/01-IdentifiesAggregate.html
I would recommend breaking the command up into smaller interactions. Eg: ChangeAccountName, ChangeAccountEmail, etc. It is perfectly okay to issue multiple commands from a single controller action. In fact, I would say it is the responsibility of the controller to do so. Have a read of https://lostechies.com/gabrielschenker/2015/05/11/ddd-special-scenarios-part-2/ the examples are C# but it should be pretty easy to follow. 
You can make it explicit via documentation (e.g. what Symfony does http://symfony.com/doc/current/contributing/code/bc.html#id54)
You could split those fields into multiple DTOs (or VOs), eg: - PersonNameDTO: first_name, middle_name, last_name - PersonDTO: PersonNameDTO, email, phone, date_of_birth, gender - UserDTO: PersonDTO, username, user_level, password
I use Prestashop for clients and it's pretty easy to fix up on a per-site basis with something like bcrypt. The other parts of PS are pretty nice to work with atleast.
PHP is the only programming language I know of that gives warnings for expected behavior. I've spend too much time trying to test a socket connection in order to avoid a warning thrown by fsockopen. Looks like there isn't a way to avoid the warning without suppressing it. Ugh 
php -r "echo trim(0)==''?'True':'False';"
Not bothering to educate themselves better because "I can build everything I want with PHP, and it pays my bills, and (cheap) PHP developers are easy to hire, so why should I waste my time with a fad". I'm surprised on how many times I heard this. About a lot of languages. By older developers, but still, whoah
Indeed. Isn't it a fucking scandal they use plain MD5??
You would need the cookie key which is stored in file so you do need that to get it reduced to a plain md5($pass). A rainbow table is not possible with just a plain dump.
&gt; Oh and concept of DDD is immutability, yes? No, DDD and immutability are 2 unconnected things &gt; So I think passing all to constructor is the only ide friendy choice It's not about IDE friendliness, it's about letting the consumer of the function or class know what it expects, if you just ask for an array, the consumer has no idea what is expected or needed etc...
for the lazy, some martin fowler links: * [CSQR](http://martinfowler.com/bliki/CQRS.html) * [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html)
You've not explained who's paying this money. Opensource projects by their very nature have little to no funding. 
For my own project's security bug bounty, the "funding" is coming from me. I just set up a small bounty program and if anybody finds a security bug applicaple for a bounty, I'll pay it from my own pocket. Also, as said yesterday, we could think something like collecting money as a community for a OSS project we all use day to day. 100 people donating 10 bucks to, say, Twig would make a good start. Another project, another 100 people with their $10, and companies making use of those projects... 
Lets get real here. You'll never realistically get 1 person, let alone 100 people to donate to an OSS project that isn't massive already.
&gt; Validate the DTO in the controller If you're going to use a data-transfer object, validation of that DTO is not specific to HTTP, so validation should be in the domain layer. The controller (or the Action in [ADR](http://pmjones.io/adr) should be doing as little as possible.
Full marks for the opening shot from 2001, and the appropriate font therein.
This is my first composer package. Something I worked on during PHP|tek 2015 to help drive exceptional programming. Methods with OrFail are something I've seen more and more in codebases. Now you can have them in all the things. I'd appreciate your feedback on the package, its features, and if you can, testing with your projects.
It costs you an email address
which is auto-installed to IIS8.5 using their magical web-installer. It is compatible with ADODB PHP drivers no less.
tim@mailinator.com Password: abcd1234 Now you need nothing.
Lazy people in a programming subreddit? Get outta' here
Thanks for the feedback. I'm the editor of php[architect]. Did you check out the ePub or mobi versions? 
Thanks for the comment. Some clarification... are you not happy with the layout? Not enough whitespace? Or is it the digital format (a downloadable file vs. a website)? Or both? I ask, because I'm the designer and want to make the reading experience as nice as possible.
In a way both. When we open a website this is already the reading tool for most of us, whether on a mobile device or a laptop/desktop computer. Having to stop there, download a file, then open the file in our preferred application represents friction and hassle. It feels like work. And the result of that work is an experience that's inferior to the browser session we were already in. Now, after my comment I tried ePub and I'm happier with this one, mostly because the layout adapts to fit the device I run it on and flows in a more predictable way than the columns of the PDF, but on the other side ePub doesn't give you the opportunity to express your brand with design, it's like an annotated .txt file. This is where the pdf comes I suppose. Great colors and line art, it expresses the brand, but: - The line-spacing is too tight, so lines run together and it looks busy. Letter spacing also seems a tad too tight. The columns are also at times too narrow (I suppose to accommodate stuff like code listings). - The text size and multi-column layout suggest a typical magazine layout, but that magazine layout can only be used properly if I print the entire magazine on magazine-sized sheets. On anything else: a mobile screen, a desktop screen, this is too small and the columns, the hard page boundaries represent an impediment not an advantage to the reading experience. - The code example are not in flow with the rest of the text (another choice that I suppose was dictated by the multi-column layout) but are inserted like you would photos in a magazine layout. Again, I see where you're coming from, but a code example should flow with the text. A code example is not a photo and it's far less capable of standing on its own (and the accompanying article copy also is far less capable on standing on its own without its code examples). - This is a more of a subjective thing, but I feel text is a bit too heavy overall, and bold text and section headings are way too bold. For example page 15 in the PDF "Act like a machine", "Consuming APIs" and "Building APIs", they feel so bold and different from the rest, like I need to change my glasses to read those parts (I don't wear glasses, but you get my point). I don't know if it's truly possible to get a great electronic reading experience from a PDF, PDF is after all a format for printed materials, at a specific size etc. Ideally you can take that branding out of the PDF and maybe have a paywalled web version of it so people can comfortably read this on their devices. A web page, love it or hate it, seems to strike that balance of design and usability best right now, and there's no way to reduce friction further than sending people to the website.... and the articles just being there (vs in a file).
thanks!
Why are you using commands and handlers?
Well, if you already have an account (which you would if you went to phptek, phpworld, or any other event they help put on), it doesn't cost you an email address that they don't already have.
I'll be honest, I don't understand what benefit you think you are gaining here. Just pass a plain PHP array of the data you need and move on with your day. I know smart people will tell you that is not the "right way" but they are obsessing over pointless, trivial crap.
How on earth does registering help you in any way, especially of I never come back?
If "conposer.json" was not a typo, that's actually a great way to be compatible with Composer, as well as having your own Composer-like tool. :P
The thing you quoted sounds like a bad abstraction to me anyway. If you need to update all of our layers/apps because you changed their dependency, and you fix that by changing the way you _package_ them, you've got yourself another thing coming. Soon. This is fixing the wrong problem.
But they used a salt! /s
I gotta admit, I love hacks like this, but for real use in a project there are several problems with it: ####✗ Magic You lose IDE support (autocompletion, error checking) and you don't win much value back. // This... $this-&gt;doItOrFail(); // Can also be expressed like this... $this-&gt;doIt() or $this-&gt;fail(); // Or like this... if (!$this-&gt;doIt()) $this-&gt;fail(); // Or if we do it right, like this (because doIt should itself throw an exception // if it fails, not return falsey value). $this-&gt;doIt(); Also magic methods don't work in the rare circumstances your methods take or return references (happens). Magic should be a last resort, not a bullet list feature to brag about in the README. ####✗ Falsey == failure? If you call a method which returns one of these: [], 0, 0.0, "", "0", null and one or more of these are *not* an error, you'll throw anyway. ####✗ Non-specific errors It's always good to actually describe what went wrong in an error, not just flip the table and quit. - If you have functions returning falsey values for errors it means they withhold important context about the situation you can't recover back in your trait. - Your methods provides no way of specifying an error message or exception type either. ---- BTW... and don't get me wrong, tests are important. But this is a **100 line trait**, and you have **4 mock classes** and **10 tests** on it, that test things which can't even fail when using __call. If I have to judge by the packages I see in /r/php/ and elsewhere, I feel we're deep into cargo cult territory with tests. That makes me sad.
The trick is that it becomes very hard to do unless you actually get to talk to "real users", which can be frustrating in some companies.
You can either post the form to the same page and have it "refreshed" with the information, or use an ajax approach to update only part of the page. This one goes over it pretty well. https://scotch.io/tutorials/submitting-ajax-forms-with-jquery
&gt; Methods with OrFail are something I've seen more and more in codebases. Now you can have them in all the things. Really? I'm not quite sure what'd be the purpose of creating method names ending in "OrFail", any method *can* throw and we have @throws for declaring that.
That only really works for a small number of them. It is very very easy to forget to push a change from one of those vendors. Also how do you guarantee that everyone have the same and correct version of each of those dependancies across the multiple applications? You could create symlinks between the vendor folders which would help. Then there is the problem on testing and ensuring that everything is testing against the same version. This is not a problem that everyone will have, open source project should certainly not be using conductor but larger products can. 
Shouldn't it be the other way around? &gt; If it makes sense to continue a test after an assertion failed splitting the tests should've been the choice in the first place?
Deploying as a service is one way of dealing with this problem and it can be the right answer but services have their own problems with overhead due to http which means reduced performance, harder debugging and coordination problems. You need to look at your circumstances and your problems. 
Have you tried this on a large project? We did actually and had all sorts of problems, code that needs to change together should be together but code that can change independently should be kept separate. You right about latest version, but that is only on push. This is super easy, one git pull, one composer install and your entire application is updated.... Also we currently have around 30 packages , each with its own test suite that when run CANNOT use anything not specified in that packages composer.json so you cannot accidentally depend on something. With a git pull model everything is in the same autoloader so you cannot test independently. Anyway, if you don't have a problem that conductor would solve then don't use it but see http://www.whitewashing.de/2015/04/11/monolithic_repositories_with_php_and_composer.html and http://radify.io/blog/refactoring-repositories/ for others with a similar problem.
It is hard to give examples that people would understand given this is a very large marketplace product that has been in development for 8 years and currently has over 500K lines of php code. We use Domain driven design with a ports and adapters architecture. We have what we call packages which is where our domain logic and services are stored, it cannot have any symfony dependancies. We then have bridges which are symfony bundles that provide the infrastructure and integration layer but nothing to do with views i.e our concrete implementations of our repositories are there using pdo, it also has a services.yml file which exposes the domain services to the symfony application. Then there is our symfony application which has our view layer. Each layer has it's own set of tests, we mostly have unit tests in packages, integration tests in bridges and then functional tests in application. Tools and utilities which are not part of our core domain are in separate git repo's. We haven't done the best job of explaining it in the article but it is a difficult problem to grasp unless you have it I think.
If I assert something is not null I should be able to assert something on it. But if I keep going now I have a null pointer exception.
&gt; If I assert something is not null I should be able to assert something on it. But if I keep going now I have a null pointer exception. So the risk is: the test might stop with an exception. And the solution is for assert to: stop the test with an exception. Where's the difference here? A more typical scenario employing plenty of asserts in a single test is testing the separate fields of a return result, and not testing the same value in a pipeline fashion with multiple asserts.
yeah - it would make sense if you could sort the results from the search. The sorting does not care what you enter in the search, it just needs to be non empty. and then it will still sort from top to bottom, without taking search value into account
Probably should be dead. The whole idea is not terribly compelling.
Out of curiosity: is there any project that uses this I could take a look at?
I've never been a fan of yield. It usually makes the code overly terse and obfuscated.
It's just pining for the fjords, that's all.
I don't see why you're getting downvoted, you are making good points. Then again, any well written class shouldn't need too many assertions per test method if it's been following SRP properly, or if there is a pool of inputs with expected outputs, then naturally a dataProvider makes more since. Oh and that reminds me, about the overassertive tool we are talking about here: I think it's rather treating the symptoms than the core issue: the classes are likely not following SRP properly. It would make more sense to refactor the classes. But I appreciate the effort of course!
wild guess? Internet Explorer
I've felt the same "I wish this was one repository" pain, and I've been playing around with a little tools called [Haydn](https://github.com/DHager/composer-haydn), which can selectively "overrides" composer to grab dependencies that have the same branch-name as your main repo. Anywhere you type `composer foo`, you can do `haydn foo` and it creates and operates on a "patched" copy of the `composer.json` file.
Thank you for your feedback. I think you addressed your own point on IDE's. Furthermore, there are all sorts of *mappers* you can set to overcome this issue. Excellent point on `falsey != failure`. In the short lived 1.0.0 version, `null`was the only failure case. However, given the dynamism of PHP, I felt *falsey* was more *commonplace*. Nonetheless, you can override the failure check method to configure your *failure* condition. Fair point on the errors. This is something that may need more consideration once there's more feedback from the wild. Yes, there were a lot of tests. I'll admit a few were indeed overkill. Yet these *physical* mocks were necessary to recreate the context (Inheritance, overriding methods, etc) in which this trait might be used.
Pure convenience. I see a use for it, but can admit a majority of this was learning to create a composer package. In practicality, I would never suggest using `OrFail` for **all the things**. Methods should definite contain their specific exception logic. This is not a replacement, but a convenience for handling *common failure cases*.
&gt;But now I see PHP7 is outrunning other common scripting solutions like Python and Ruby How do you mean?
http://martinfowler.com/bliki/MonolithFirst.html Some interesting thoughts there too.
What? 
I'm glad! I like the idea and project, and I'm glad it's still alive!
Still i would not recommend gui development in PHP, its not worth the risk. Theres better tools/languages for that. 
Performance isn't the issue here.. And garbage collection is still not 100% especially when working with third party libraries.
More/less philosophical questions: 1. Do you expect that users will send invalid data (through forms/whatever)? 2. Do you expect that the payment gateway systems (or any other 3-rd party services) are down? 3. When using a cache system do you expect that a specific item is not in cache? 4. When using multiple `catch`-es isn't that a sign that those specific exception (`\MyLib\Some\Class\Exception`) are somehow... expected?
My personal criteria is like this: if I validate a form and tell the user which fields are invalid I don't use exceptions for that, because this is something that potentially may happen a lot. If I just want to die on invalid input I use exceptions. Following my logic form validation I'd handle without exceptions, but for API validation I might use them ( since I expect the input to be valid 99% times);
Google analytics can give you exactly the same thing. Or Apache logs for that matter.
It's common knowledge. Also Windows 10 is much faster thanks to PHP 7…
It was a typo...
Death and dismemberment, of course!
Mockery, ridicule, banishment, burning at the stake.
Hi, It is nice to see your blog post. I have been thinking to ask what is the advantage of integrating PSR7 to Symfony via a Bridge as Symfony itself can work without it. I understand the bridge can be helpful to convert the symfony response to psr-7 response. Probably it can be used with zend-stratagilty ? I wished to see an example how easy it will be if so. May be like $middleware-&gt;pipe($symfonyApp); Thank you.
Chris - You missed out PPI Framework. http://www.ppi.io
This is a great addition to PHPUnit. A unit test, by definition, should test the functionality of one thing. If you have too many assertions, it's not just the test that might be bad, it's a good indicator that the thing being tested is doing too much. Once there's a stable release on packagist, I'll certainly add it to my projects.
jenkins + sonarqube, but its nothing you want to use for smaller projects, the initial setup isn't that easy. since all of my personal projects are controlled by git, it's easy to write custom bash scripts which have all the necessary steps, like cloning the project into a new folder, building (grunt) &amp; downloading stuff (composer, npm packages, bower packages), running phpunit tests and in the end - if successfull - changing the htdocs-symlink to the new folder. i heard good stuff about rocketeer &amp; capistrano (and capifony for symfony2 projects), but havent used them in production.
Really ugly solution. W3 is ages behind when it comes to the code quality.
Currently we use Jenkins for testing branches and Phing for deployment directly from git master (we use Git Flow to separate out development). While as a starting point Phing is not as solid as Ant, as a PHP developer, it's easier to write plugins for. My intention is to make Jenkins result in a build artefact that is uploaded to cloud storage, and deploy from that artefact. This would make it impossible to deploy a broken build. I'm also planning on moving our monolithic physical server to a varying number of load balanced open stack instances. I haven't quite decided how to do that part of the deployment yet, but I was thinking of using Ansible or Salt Stack to create instances, image itself and pop itself into the cloud for much the same effect. Any thoughts?
&gt; Still i would not recommend gui development in PHP, its not worth the risk. Theres better tools/languages for that. There's a risk in using it, because they may stop maintaining PHP-GTK. And they may stop maintaining it, because people won't use it. And people won't use it, because there's a risk in using it. There's a risk in using it, because they may stop maintaining PHP-GTK... That kind of opinion is reasonable, but this is why it's often said progress is entirely dependent on the unreasonable people ;)
For most projects: https://github.com/MindTwister/pyGitDeploy I made it myself a couple of years ago, and haven't had a reason to update it (it just works)... I hate shared hosting :( On projects where ssh is available I use git and a modify the post_receive hook, about as simple as it gets.
Ansible + Jenkins with the f500 deploy role. Works like a charm, similar to the deploy / release style of Capistrano. We have a custom role that acts like an adaptor, so you can define a YAML dictionary like: wordpress_sites - site: mysite.com envvars: - DB_NAME: wp laravel_sites: - site: lara-site.com envvars: - APP_ENV: prod [...] users: - deploy - sshkey: some key databases: - name: wp Etc... This can be reused for local environments like Vagrant, exported to Packer or used in production seamlessly and with full dev / staging / prod parity. 
W3lessons.info*, not W3.
There's a lot wrong with this article. I'll just pick one: &gt; Why PDO is better than MYSQL? I think they mean MySQLi. MySQL is a database. &gt; The number one reason is security. Eh, you can have security with MySQLi, though it is easier with PDO. The best reason to use PDO is abstraction of databases. You can use the same PHP calls no matter which type of database you use. It makes you a more versatile programmer, and it's easier to use.
FYI, the link is wrong here - its [http://blog.fortrabbit.com/10-pillars-php-dev](http://blog.fortrabbit.com/10-pillars-php-dev).
totally agree, i like the "style products" wording. sometimes it's "dogma over practicality". — i am co-founder of a style product
Spelling mistake. It's spelt phpillars.
Used bash all my life, sill use it. If you actually takwe the time to learn bash as a scripting language then it combined with a pleora of linux CLI tools is going to be your best friend for life.
Ansible is like Fabric plus a full featured CM and server provisioning tool, with built in support for almost everything I've ever needed to do on a server. I'm a little [biased](https://leanpub.com/ansible-for-devops), of course :)
I should clarify I'm referring to extensions and not libraries written natively in PHP. So we all know how the garbage collector works, right? Specifically the cycle detector. It relies on the [zvals get_properties hashtable](https://wiki.php.net/internals/engine/objects#get_properties). This works very well for zval based objects. However, when you start using non-zval objects, such as in third party or even internal extensions things start getting [hacky](http://svn.php.net/viewvc/php/php-src/trunk/ext/spl/spl_observer.c?r1=304700&amp;r2=304723&amp;pathrev=304723). This means that the garbage collection works in some cases when working with extensions and their objects, but only after you apply some odd solutions.. So not 100% working! This may have changed in PHP 7 but last I looked it hadn't.
80% of your time is working on only 20% of the goal.
argh. will delete and post correct URL.
AKA "there's the first 80% of the project, and then the second 80%".
Ansible is phenomenal. It's like a human-readable recipe for making your servers/apps.
Exactly. Took one look at Ansible, saw the O'Reilly book and thought I have better things to do than learn and debug yet another thing that gets in the way of actually writing and shipping code. +1 for dploy.io
I am not suggesting the extension itself is leaky - though I've not checked it myself. The extensions often expose objects. Those objects are for the most part exempt from garbage collection's circular reference checker as they are not zval types, so any object they contain references to are exempt from some collection. See a similar issue to what i am describing on the PHP bug tracker here: https://bugs.php.net/bug.php?id=53803
&gt; Hi, this blog solely reflects company values. Opinions are our own. As opposed to... what? :D
Can someone supply an ELI5 for what the advantages of using tools like these are?
While I'm probably not going to use this myself in the near future, I suspect PHP moving out of the web space will cheese off a lot of those people who absolutely hate it, which amuses me.
We use [deployer.org](http://deployer.org/). It's a bit like capistrano/capifony but written in PHP so the deployment configs/recipes are also written in PHP. Your source is deployed to a new release directory and only once all tasks are successfully completed is the symlink to the "current" switched to the new folder. Release history is retained so rolling back is a single command. I gave a [short talk](https://www.youtube.com/watch?v=XbbtSsgUI_k) about it to the Thailand PHP User Group a few months back. Recently version 3.x was released which sees a number of improvements
Me too, I have been programming for quite some time now, but have never really been exposed to real life projects, or project cycles, and I feel I have great technical knowledge, but lack experience in documenting, version control, rolling out updates, etc.. Which in my opinion is just as important as programming knowledge. I am delighted to hear you would be interested, I have some ideas for some nice projects which I shall disclose soon. I'm in work at the moment, when I get home later I will message you my skype name and we can chat, get to know each others expertise, experience, interests, goals, etc... Hipp04 I am really happy to hear you are interested as I have been looking to start a team just out of sheer love for developing but didn't know where to start. Then I just said, lets try PHP sub-reddit I'm sure there are plenty more like me who frequent /r/php.
Feel free to message me, although I have experience in working in teams, I'm always looking forward to extend it ;)
Even better, someone who has experience in a team, no harm in sharing knowledge que-loco-paranoid
It's not been mentioned yet, but I like using [Magallanes](http://magephp.com). You define a set of tasks and servers in a yaml file per environment (e.g. prod, test, dev). You run **bin/mage deploy:prod** and it'll tar up the configured directories, SCP the tarball, untar it, run composer install and symlink that release. Rollbacks are also supported (by repointing a symlink) so it pretty much fits the bill for me. As a bonus, you can write tasks in PHP if you want. 
you should try talking to /u/dshafik and Ed Finkler. They are both advocates in this topic. 
not php related... but git + codeship CI .. a push to master branch of the repo causes github to fire a webhook to codeship and run unit tests. If everything passes my web server basically `git pull` the repo, runs `npm install &amp;&amp; cd assets &amp;&amp; bower install &amp;&amp; cd ../ &amp;&amp; pm2 restart 0` I know codeship supports other languages and you're basically write bash scripts in their editor so it can do almost anything on a post-receive.
They could have been talking about being better than mysql_ libraries before they were superseded by mysqli_ versions.
Have you seen dploy.io? It's Beanstalk's deployments but for the case when your repos are hosted somewhere else.
FYI, I have experience with the following (in the order it comes to mind): PHP/MySQL/Apache/Linux (development stack) HTML/CSS/JS (web) Git (version control) CodeIgniter/MVC (framework) Puppet (provisions) Vagrant (local environment) CentOS/Ubuntu (linux flavor) Bash/C/C++/Java/Python (general programming knowledge)
I don't think your last example does what you think it does. You need to be careful when using "continue" inside of switch statements because, [as explained on the manual page](http://php.net/continue), switch statements are considered a similar structure to for/foreach/while loops, so continue acts on them (and behaves like break). The example given works, as the code is written, but only incidentally because you have no code inside the foreach loop other than the switch statements. See http://3v4l.org/N7H4n
We use [Rocketeer](http://rocketeer.autopergamene.eu/). After successfull tests in Gitlab CI we run rocketeer deploy, which takes care of everything (symlinks, shared folders, composer, database migrations, ...). In case of something going wrong, we still can run rocketeer from our PCs and do rocketeer rollback for example. Configuration is stored directly in project, so every user needs only rocketeer and access to destination server in order to do deploy. Only thing I've been missing in rocketeer is passing parameters to custom tasks, but we managed to do it using env variables.
Git, Jenkins, Capistrano, DBDeploy. My particular settings only needs a `git push`.
no go read a book :P. Criteria for advantages and disadvantages come from experience and is subjective. An explanation of pros and cons is simply not a substitute for learning and experiencing for yourself.
One guy once coded an app with PHP GTK. The next day, he woke up dead. DEAD !
I would call all of the code on that page bad code. It should be refactored at some point. Generally, I try to avoid breaking out of a loop except when I am scanning a collection (e.g. Array) for a value and I find it. Additionally, I've never found myself in a situation where I have needed to use continue within a switch. It's probably dangerous. 
I'm exploring the ends and outs of creating an n-tier application with PHP/MySQL starting with this article: http://xcodula.com/student-management-app-in-php-part-1/ This isn't the same as what you are talking about, but you could design your own project and follow along the series. Then you could post a link to your code in the comment section to elicit feedback on your progress. Just a couple of ideas to get community engagement.
Nesting that deeply (cyclomatic complexity) is a very strong indication code isn't being separated out properly. That hurts how easy it is to read, debug, extend, and test. I'd recommend checking out [Your Code Sucks, Let's Fix It](https://www.youtube.com/watch?v=GtB5DAfOWMQ) by Rafael Dohms. It's a very good guide to improving code.
I use them sparingly, but I do use them.
Awesome! Thanks!
Just to add a few, at least for tools like [dploy.io](http://dploy.io): * You get integrations, for notifications and things like NewRelic * You can manage permissions * You can get automatic deployments on new pushes, without a hassle * You'll have record of all your deployments, so that you can go back and check what's wrong And generally, you get more transparency in your deployment process.
You simply need to have faith that the packages you are using are follow semantic versioning correctly. If you are only updating minor and patch versions, you should be OK. I'd only double check changelogs against large packages, like Laravel, just to make sure some little BC break wasn't introduced. Of course, most of this will be QA'd at some point (or should at least). However, if you are using dev-master, that's a whole situation in itself. I'd usually re-test those immediately.
I don't understand why people are downvoting you, I apologize for the community. What you're doing is admirable and I wish more people had the gall to be so forward and publicly admit their lack of knowledge and ask for teamups. Whomever you find and whatever the outcome, you can't lose - you'll learn a lot, both about working with people and about planning projects and distributing work. Good luck! Side note - have you tried jumping into some open source projects and contributing that way first? That's a good way to get introduced to teamwork if you're new to it.
At the moment, I don't have a CI server am looking into it, PHPCI Looks interesting, as for pure deployment I use [Capistrano](http://capistranorb.com/)!
&gt; We wanted to be able to perform stand-alone unit tests for the database-backed functionality, so we started testing against SQLite and wrote compatibility functions as necessary. It's still not stand-alone, it uses SQLite. I can't see how using an inaccurate simulation of MySQL via SQLite is an improvement over using MySQL. I realize setting up MySQL on a given port at localhost takes a bit of effort, but that effort is dwarfed by the effort required to maintain this library and all the false positives and false negatives you'll get it with for your tests. And when one day you decide to add performance regression tests to your suite, you'll still have to go to MySQL because they have a vastly different performance profile.
PHP in health industry… that's scary!
Run composer update when there is some downtime (as in amount of critical work to do), run tests, if they pass it's ok.
Perfect example of a site that needs someone to grammar-check it's content.
So you see no value in being able to run unit tests with only a git clone and composer update?
I can still run unit tests with only a git clone and composer update. You should look into [Vagrant](https://www.vagrantup.com/) and similar projects that will set up an environment with MySQL and whatever else you need in a single click. More importantly, though, if you run unit tests against fake MySQL, you're not really running tests against MySQL. I said "false positives and false positives" and you didn't address this. MySQL and SQLite are very different. Beyond functions and syntax. How would you emulate the transaction isolation levels of MySQL with SQLite? Or savepoints? Or schema change commands? You can't. Plus, a big PHP project may depend on many services. MySQL, PostreSQL, Redis, RabbitMQ, MongoDB, etc. Going down this path where you try to simulate them all won't scale at all.
Similar experience: PHP/MySQL/Apache/Windows, with good knowledge of Unix/Linux. HTML/CSS/JS. I mainly use SVN &amp; tortoise for version control. Have used GIT for one project in college. C#/Java/Lua been a while since I touched C/C++ 
They keep saying they're not dead since 2008. Hum.
I use Beanstalk too. It's pretty good functionally, but reliability-wise, it's not the greatest. They have downtime a bit too often, and it's also just a *reeeally* slow service. And don'tcha know their issues are always during critical times when trying to make a deadlined release. However, they do host your git repos and deploy all in one service.
For personal stuff, just plain old git. For work, it's enterprise so none other than a shared folder and remote desktop.
Capistrano; - push to master on GitHub, run `cap production deploy` and job done. Easy to extend and run additional commands e.g. `composer install` or restart services on the server. [I wrote an article a few years ago!](https://www.georgebuckingham.com/blog/php-capistrano-deployment) which should give you an idea of how it works (slightly out-of-date now as newer versions have been released) - the official docs are handy though. 
Shame PHP doesn't have JavaScript's `break`/`continue` labels: while_true: while (true) { switch (foo) { ... case bar: ... break while_true; case baz: ... continue while_true; ... } }
Agreed, I've used manual post hooks, deployhq and beanstalk. Sometimes beanstalk just doesn't work and doesn't show you an error, and when I click redeploy it redeploys the whole repo instead of just the commit I want.
You're missing the point. MySQLite isn't meant for testing transaction isolation levels or other MySQL-specific behaviours. (You have to test those things against MySQL, or maybe with very carefully mocked objects.) MySQLite is *only* about adding MySQL compatibility functions to SQLite. If you have code written and tested against MySQL, and you want to use the code or test it against SQLite but run into missing functions... MySQLite might save you some time and effort. Clearly, MySQLite is not for you. And that's fine.
I make sure I have my package version set correctly. If I don't want to receive updates for a package then use the full version, e.g. 1.0.0. Boom done. However, for most packages I "trust" that minor fixes will not break anything so for most (if not all) packages I use, 1.0.*. End to end integration tests will tell me if something is broken since a package update. 
Oh, yeah. Notifications on Hipchat.
Our servers only run PHP 5.3, so usually I have to dig back through the old versions of packages on packagist before I find one for 5.3. Then I use that one and never upgrade :(
That would be the dream. Sadly, test suite isn't, and will never be, functional enough to ensure that nothing in Sonata/FOS breaks.
That's good discipline. But don't you get an itch to update everything else, while you're at it, too? :)
If it's a minor upgrade, I will check each projects changelog, and migration guide if they have one.
But PHP has [goto](http://php.net/goto), which allows you to achieve the same thing!
It's similar, but not quite the same.
Every time I need an ansible role I look it up first in your github repository list. Thanks for all the work.
There's also Shippo - goshippo.com/docs. Direct EP competitor. Multi-carrier shipping API.
Good point. Yes. Please answer yes for desktop use. 
Same, in terms of roi in time it and requests are amazing!
This would only work if you have integrations tests, unit tests would probably mock out some services.
I feel like you must have something misconfigured. I've found Ansible to be quite zippy, at least after the first provisioning which will naturally be slow (but no slower than your manual yum/apt-get commands)
If that's the case, open an issue requesting a formal 1.0 release. It may sit there and rot for months, but it makes the point and makes the world a better place if they actually do it.
Chmod is mistakenly spelt chomd in part 3. 
If I'm only looking to update one package then I will only update that package.
Awesome. We've set up an irc chan on freenode.net #ormcollab which I'll be on when not in work from now on so jump on. 
Awesome. We've set up an irc chan on freenode.net #ormcollab which I'll be on every moment I get so jump on and see what's going on
You can try to use [ssh pipelining](http://docs.ansible.com/intro_configuration.html#pipelining). As for DSL - is there some tool that have no such problems?
&gt; As PHPUnit follows Semantic Versioning the major version number must be incremented when the minimum required version of PHP is increased. There is some disagreement as to whether this statement is true. The contention is that changing the minimum version does not actually break BC, it just means composer will prevent you from updating. E.g. ZF bumps PHP version requirements in minor versions.
I don't want my composer to make such decisions for me based on the PHP version I run it with. I like to run composer commands from outside my vagrant box which usually tends to have a newer PHP version than what's inside my box.
Yet no mention of namespacing.
So what does version 5 have?
It doesn't have to mean new features. It could just mean cleaner, easier to maintain code.
It's not about the features, [it's about sending a message](http://new2.fjcdn.com/comments/It+s+not+about+the+thumbs+it+s+about+sending+a+message+_3bd82407986560421580e9b86b0fbb62.jpg).
PHP 7 would be a new feature, wouldn't it? &gt; PHPUnit 5.0 is the current alpha release series of PHPUnit. It will become stable on October 2, 2015 and will only be supported on PHP 5.6 and PHP 7. Although... PHPUnit 5 comes out a full month before PHP 7, so that's could be a problem if there are any last minute changes (though I'd expect PHP 7 to be pretty stable by then).
I like that!
That's asking for trouble - anything that defines extensions as requirements (POSIX+PCNTL being a relatively common example) can easily go bonkers. 
It's not integration testing, but I always run [Behat](http://behat.org/) tests against as many things as I can think the user would want to do. The testing server on which this is done is plugged into test services where possible, or secondary accounts where it's not. **Pros:** Tests full functionality as the user would expect it, including integration with databases and third party systems my unit tests don't cover. **Cons:** Very _very_ slow for websites (not so bad for APIs). I'd say I have a little over 50% coverage of all known user behaviours right now and it takes over an hour to run (almost two on my development machine). And that's with switching between Goute (no JS) and Selenium (JS but slow).
Cool, I'll be on later when home from work
In Composer, "dev-master" as a version string always points to your last commit in HEAD, so you don't need to tag everything. While there's nothing wrong in theory to tag everything with a new patch version, UIs everywhere are designed assuming more austere usage of tagging so expect communication problems when people open the tags list and see nothing but 20 patch versions that were produced in the span of an hour. Versioning is best used for coordinating slower rollout across teams and the public. Also call me a skeptic, but I doubt in the span of 10 minutes you had the time to do 4 rounds of running through your test suite and manually test the parts that can't be auto-tested (like UI). You should tag with stable versions only code that you can be at least moderately sure is stable.
You could use Jenkins to automatically tag successful commits when all tests pass. This won't be "quick" but it will be safer.
Yes, I often have that itch, but even if I update a single package, I do it in a new branch. If everything looks OK =&gt; merge, otherwise I can nuke the branch, or transform it in a WIP branch and start fixing. &amp;nbsp; Things will become more time consuming when you don't have integration tests and the vendor doesn't follow semantic versioning, because you need to read the changelog (_if exists, otherwise take a quick look at commit logs_), etc and even then you can't be 100% sure that things will not break. This is the reason for which I will always run `composer update` only in a temporary branch and for vendors that don't follow semver I become more strict (_if I can_) when I require their code: (_ie: `vendor/lib-without-semver: "2.3.1"` or `vendor/lib-without-semver: "dev-master#2633721877cae79ad461f3ca06f3f77fb4fce02e"` instead of `vendor/lib-with-semver: "~2.3"`_).
&gt; Lua &lt;3
I wish someone would review your website design, random padding on sentences is really annoying and hard to read. Apart from that, it's a good, informative article. :) EDIT: I just want to add that I am viewing it at a resolution of 1440x900 which is pretty bad. I moved it over to my surface and it appears fine, I then moved it back over to my monitor screen and it was fine again. Refresh on my monitor and the weird padding comes back. Just thought you should know. :)
Very interesting read. I can relate to a lot of this (I do a lot of code reviewing at work too) and I agree with you in being as descriptive as possible on your commit messages, it does help.
I'm curious if there are any good options for projects that aren't built on a framework that offer migrations like that. We currently have a directory full of SQL files and it becomes a very manual process.
Agreed. Dwitch to dev-master in your composer.json. That clones a copy of the repository in your vendor folder. Do your work on the package while it is sitting inside your product it is a dependency of. When you have it working the way you want, tests are written and passing (tests under vendor/your-package/tests for example), and you're done then cd into vendor/your-package and make your commit there and tag it there. Then you can switch your composer.json for your project to { "vendor/your-package" : "\^2.0.0" } and run composer update. It will eliminate a lot of round trips. I gave a presentation on this at php[tek] this past year but I haven't posted the slides yet.
Hey, thanks for the comment. Yeah, prior to the survey, I didn't realize that depression was as present as it is. I lot of people sounded off in the 'anything we didn't ask about' area on that topic. 
can this thread use the trait ?
That... is a great question. I would assume it does for all practical purposes, though I was at the time assuming there would be some quirkiness. Yeah, forget what I said unless someone can demonstrate it. -1 myself. :p
What distribution?
to the question in the subject: use semver: http://semver.org/. and version contraints in your requires that are not fixed to one exact version as for your development process: if I develop on 2 projects at once (say a website project and a lib i'm using) (and i try to avoid doing that, as developing against tests IMHO is a better practise than developing against code directly), i usually end up having composer check out the libs including vcs, edit the code within vendor/vendorname/libname, and commit/push/release from there, so the main project doesn't need to be constantly updated. a few people here have suggested to switch to dev-master, which is an acceptable thing todo, but carries the risk that you end up releasing with a dev version contraint, which is bad.
Haha, sounds all too familiar.
&gt; but lack experience in documenting, version control, rolling out updates, etc.. Easily solved: have a read through the ["Git Flow"](http://nvie.com/posts/a-successful-git-branching-model/) model and you can start using it on your own projects right away. There's even a handy [git-flow tool](https://github.com/nvie/gitflow) to make life easier when using the model.
I good test should have 1 reason to fail.
Listen to me, I was in your situation, you have two options 1) RUN. 2) Be honest. Don't sugar coat the fact that the code is shit.
I would choose option b, he might end up thinking that a total rewrite could be costly, but slowly moving it into MVC and using composer packages might work out better.
Although I haven't read that book, it's one which has been in my sights for a while now. You're always going to get that one job which is stuck with a mess of code and this book looks like it will definitely help in that situation.
he is bringthetanks.
Harsh. But funny.
Yep. This. 100%. If you see red flags make sure that they form the major part of your response. Don't ignore them at all, you will regret it. "Run" is a very good option. You need to choose what you work on carefully, because this could lead to weeks/ month/ years of stressful battles and problems. It could be detrimental to your health and wellbeing. I'm not joking, I have seen this too many times. If you really want to move forward, be 100% upfront. Make all your concerns known. I have generally found that this approach is - while initially difficult - always respected in the long run. Even if the client is initially pissed off, they will almost certainly respect you for it. If they don't, then you should have "run" anyway. Which is probably what you should do...
I don't know about you but, when my methods take more than 3 parameters I start considering refactoring. I don't know the internals of the logic you are handling but 19 parameters seems like too much, even if you use a stdClass object or an array, you might consider breaking that method into smaller pieces, otherwise it is going to be a nightmare to maintain that method.
&gt; Do NOT rewrite it from scratch. I can't emphasize this enough. This is perhaps the most common mistake in software engineering. You swear everything will be better this time. And maybe it will be. But history is not on your side. Gradual change has a way better track record.
Programmers are always very quick to dismiss older codebases. The important question is, does the code work? If yes, then that's already a great start. Just because it isn't a PSR standard OOP, composer-installed, grunt css pre-processing, bootstrap responsive treasure trove built upon a modern MVC framework doesn't mean it can't be refactored. In fact, I think modernizing an older application can be FUN because you get to write brand new code versus maintaining something that's already done right. You don't need to "criticize" the existing code. Point out its weaknesses, build a strong argument for why it needs to be changed, and present it to your supervisor. Going in with an attitude that all of this code sucks and we should just rewrite everything won't get you anywhere. $.02
funny seeing this. I am in your situation 2 months from now. I accepted a job like that and I'm losing my mind. Thinking of quitting cause of an extremely convoluted prehistoric code base where you need to change 5-10 files all in different places in the folder structure to add a simple button.
**tl;dw** OP wrote an "autoload" package which literally does this: foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator('directory')) as $file) { if ($file-&gt;isFile() &amp;&amp; preg_match('/\.php$/', $file-&gt;getFilename())) require $file-&gt;getPathname(); } Don't use this if you care about performance.
That's very diplomatic. Nicely done.
Our application is 7 years old dinosour. Almost no schema changes. We are planning a small schema change. And we are going to handle it manually throug Navicat because there are several different views for different databases (each representing a company (our customers)). If you mean database shemas by schema.
Instead of focusing on all the work you **HAVE** to do to modernize the project, tell the customer about all the *cool features* you'll **GET** to add to the code, like maintainability, sustainability, etc. Criticizing the existing code is a useless task. It does nothing for you, or the other parties involved. Focus on what you can bring to the table, and figure out if what you bring to the table is concurrent with the goals of your client.
It feels a bit like you're restoring an old classic car.
To add another caveat.... Don't use this autoloader if loading anything other than functions: In the case of class hierarchies, a child class loaded before its parent will trigger a fatal error due to the missing parent class.
Right, and if you've only seen a sample of the codebase then don't cast any stones. In large/enterprise PHP apps, the library files are often full of PHP general functions (i.e. procedural) and the classes/OOP are loaded based on what page you are viewing. Legacy code should be respected for doing what it's supposed to do: work the way the client wants.
Thank you for this, No that's not harsh at all that's exactly what I'm looking for. I'll get through my exams and I'll check every point in your review, Thanks a lot for taking the time to write this.
If you want to have libraries of functions, consider simply using public static methods in "SomethingUtils" classes. Is it an abuse of static classes? Kind of, but they can do the same job functions would, and this is a position the language forces us into. The artificial line between functions and classes doesn't have to be there, but it is there: autoloading, namespace resolution rules, aliasing rules (use ... as ...). When forced to compromise, pick the smaller compromise, which in this case is choosing static classes, instead of manual require() or eager recursive loaders. Manual requires make your codebase a mess (which you know). Eager loaders scale very poorly as you add files. Static methods have neither issues and work with any PSR-4 compatible autoloader.
&gt; Hi, I've looked over the codebase, and the impression I get is that it was written with a goal of being quick-to-market, which seems like it's worked well for the company so far. I am absolutely stealing this line.
I am so using this...
Sometimes you end up with [this](http://i.imgur.com/oFMakXD.jpg), but while it's in progress you [feel like you're working on this](http://i.imgur.com/lbMijRt.jpg).
I sling out code while I'm swinging to the beat. Seriously though, I've used this playlist during crunch time. https://www.youtube.com/watch?v=5nhp6ULk7mE
Depends on what the job requires. But first thing I'd advise is to not lie on your resume. If you're "trying/learning to program" then you're more between 1-3 than a 4, which, if you're going for a junior level position is perfectly fine.
I'm not sure what you hope to accomplish by interviewing for a job for which you are clearly not qualified. And not in a "oh, they want 5 years and I have 3" sense: you don't know how to program. Let's say you fool them in the interview. Then what's the game plan? Hope you figure out how to program professionally before the first day? My advice is to apologize to the company and recuse yourself (bonus points if you admit you lied on your resume, but otherwise come up with an excuse if you want to save face), then remove PHP from your resume and apply to jobs for which you are actually qualified.
The job is not for programming, it's to put together web projects, I was non-coder-founder of a relatively succesfull startup and hired a couple of developers myself for the programming. Im not running my startup anymore but that experience is kinda valuable. The job is to "get stuff done" by organizing a team, not to code myself, PHP was a plus for the job, but not mandatory in any way, my resume says this "PHP (4/10, still learning)". Seems like they just need me to be fluent in English as not many people in my can even maintain a conversation.
I know the job, which is taking care of a team of developers and get things done. They state PHP is a plus, and I'm my resume says I'm learning PHP and rank my self a 4/10, which shows them my desire to learn it in the immediate future. I'm not coding PHP myself in any way here, I'm applying as a coordinator, not as a developer.
What I was trying to say with "junior level"is that I will not code myself. I'm a co-founder of an startup, started as a non-coder and hired a team which I coordinated at the time, I stayed with them and got several awards in a 4 years lapse. As a non-programmer I have coordinated myself well enough and know how to put together developers and graphic designers without any issue. 
&gt; You can't refactor without tests. You can't write tests when you don't know what the code is supposed to be doing. And then it's very, very difficult to test procedural spaghetti.
Opensource under MIT License. https://github.com/yadakhov/torelay 
that pile of wank code base is paying for your and everybody else's employment in that company. you're clearly too awesome to get money from such junk. go try out at facebook or moogle. 
Isn't this the same as the one from OP? 
This sounds EXACTLY like the system I worked with when I first started out. It was a multi site ecommerce CMS that was then turned into a weird franchise company. The code itself was a total mess and incredibly slow (there wasn't really any request rooting, it figured it out with recursive SQL queries). Although the database wrapper was OO, it extended mysqli directly and everything was a static method... At the time I didn't know any better, so I went with the flow. Once I *did* know better I left the company to work solely &amp; exclusively for one of their clients. A year later and I rewrote the whole thing from scratch. Fully OO, MVC &amp; PSR compliant. If you're just starting out it might be a valuable learning experience, otherwise I would tread carefully. Working with crappy code can suck out the enjoyment of coding...
Some of the code bases I worked on were classic bicycles.
I use [vim](/r/vim) (with [Syntastic](https://github.com/scrooloose/syntastic) for linting) but before that I was using SublimeText (with [SublimeLinter](http://www.sublimelinter.com/en/latest/))
What? 
yeah, i'm just putting OP source. 
Don't feed the spam-bots, just downvote and move on...
Totally agree, as long as the client is aware of and willing to pay for this. Back in the day I upgraded a DOS app (in Qbasic) to Windows (VB6). Best project I've ever done. Wasn't proper OO but VB6 didn't do this. I wonder if there's anyone working on it now cussing me out?
This is pretty much the first library I'm creating, so I'd like some feedback from /r/php. [Hawk](https://github.com/hueniverse/hawk) is a authentication protocol similar to OAuth. Mine library is forked from dflydev/dflydev-hawk's port and I'm trying to improve it further. I've tried to clean up the code, added a few missing features and a lot of unit tests. I'm still actively working on it, next on my to-do list is to improve and organise the docs. Thanks!
What? He does not need 10 years experience to realize that frameworkless, procedural, undocumented php code is a big mess that noone would want to touch. He MAY be not good enough to rewrite project to make it perfect modern thing, BUT he would do it better anyway, because everything is better than spaghetti frameworkless projects.
If you could have any one food for the rest of your life, what would it be and why is it spaghetti?
I have used Phantom JS too, and it's really good, however it does not render some things correctly (in this case it was some horrible fancy select boxes and check boxes that, had I written the code base, would never have been allowed in).
Personal advice. I'd talk to them about coding practices having been developed a lot over the fast few years and how far it would be ok to change the existing code-base. Talk about Performance, Security and Extendability. Always make it about the code and the threads and opportunities you see. Never make it personal and never just say "the code is shit". If you present yourself as a skilled developer with the best interest for the company and the code in mind; who knows what he's talking about; you can circumvent the awkwardness of even talking about how you like the code. The company usually has no idea what good code is. if it works and they like the guy, it's good code. All they usually want is avoid problems and make profit. Make sure they know you want that too and it shouldn't really matter what you change. Just don't do it spitting into anyones face. 
Just FYI, using PHP functions is not "functional programming", it's "procedural programming". "Functional programming" is a thing, but it's another thing entirely. Them words. Regarding your habits, I wonder if you can give examples. A big chunk of FIG's standards were selected to match how people already coded, so it's more about consistency and less about cleanliness. While they're generally good, not every exception is automatically bad code. 
I really hate spaghetti :)
just my 2 cents: you should take a look at guzzle (https://github.com/guzzle/guzzle) &amp; the symfony dom crawler (https://github.com/symfony/DomCrawler) how they get the stuff done. i'd love to see some kind of guzzle-sf-dom-crawler-bridge-package, which integrates both in one package.
I don't disagree with this in principle, but I have to say, as someone about to be restarting from scratch, there are indeed reasons that one would do this. This code base that I'm referring to, in particular, grew like a weed, in every direction at once. We had so many ideas, there are branches without leaves or fruit on them, and while it's both an oversimplification as well as a mild insult to my particular idea, instead of having all these tentacles in every direction, our end product ended up being essentially a straight line. Minimum viable products, as well as the code that supports them, can sometimes be simply a learning tool. "Let's knock together a basic shape. But when we've got it, let's knock it down and build it right."
I usually don't use spaces after keywords, e.g. for(), while() etc. I also had a line indent in the next line after opening my PHP tag. And I never used a new line for the { bracket after opening a function, the new line was already my logic.
Thanks, CodeSniffer was what I'm looking for! There's a linter plugin for Atom, if someone's interested: https://atom.io/packages/linter https://atom.io/packages/linter-phpcs
Those are minor things that I wouldn't beat myself too much about. You can fix it with a single "format source" command in the right IDE if you feel you have to. And anyway that's not what makes clean code clean. Focus on the bigger picture, how you design your functions, classes and interfaces, how your application is structured into components and modules. The minor syntax issues will get fixed by themselves as you work with more third party code. FWIW in my team we keep "{" on the same line, because the more PHP evolves, the less it makes sense to differentiate flow statement blocks from symbol declaration blocks (i.e. think closures, now anonymous classes in PHP7 etc.). Never had someone tell us our code is "dirty" because of *that*.
Which advices can you give me for future projects? :) Are there any books or blogs or something? I'm actually trying my first steps with Symfony, since I have less to do (why should I create something what already exists)
It's a long story, but long story short, don't fall into the trap of thinking you're writing a "Symfony app". Think of Symfony as the *UI layer* around your app, the part that provides the "web site" parts. Keep your core domain logic separate (business rules, DB interaction, security, auth) and independent from frameworks and delivery mechanism (mobile client, web site, desktop app, whatever). Check out the "hexagonal architecture" (the name makes no sense, so don't think about it) also called "ports and adapters". It has some good recommendations about how you should think about the architecture of your app and where the component splitting lines could be. Never takes tips and rules absolutely (including what I say), use your knowledge about your app to determine what makes sense for you in that moment.
Yep, that's why I added the second paragraph. It's entirely possible that rewriting from scratch will solve all your problems. But I've seen it fail more often than succeed, and you should factor that in to your calculations.
Hmmm, if you going for proper OOP shouldn't you be using CamelCase method/var names? Using procedural php _ works fine, but it just doesn't feel right ...
gert@dispostable.com I can do this all day :-) 
I have a team of very talented developers in full stack, php, python, golang, postgres, reactjs, nodejs and much more working for/with me. No complex here, we just get the sh!t done and very well actually!
I'm not familiar with Hawk at all. However, IMHO the code shows you're quite a seasoned developer. Anyways: * What are your requirements? If no specific extensions are required, what's your minimum PHP version? Something tells me it's at least 5.3 due namespaces and not 5.4 due not using the short array syntax. * Provide a [.editorconfig](http://editorconfig.org/) file specifying the basics regarding your indentation rules. So many editors support it, it's worth it. * Libraries usually don't require a `composer.lock` file. There's nothing wrong with, but given that you only have one non-dev dependency and the requirements for dev dependencies look quite liberal to me except for `php-test-report` I guess it probably shouldn't be required * You could https://travis-ci.org/ ; integrating github projects is a snap, it's free for open source, you can test multiple PHP versions, etc. Since I see code quality is important to you, unless you've a beef with such services, it may be a good addition * You don't have a release yet but that doesn't mean not to plan ahead and provide already a changelog.md file or similar. I like those most which separate release entries with date and version number followed by bullet lists * I randomly opened `tests/Client/ClientTest.php`, saw three unused aliases. Are you using an IDE? It will probably show you such things, e.g. http://i.imgur.com/4NOFQLi.png . Of course you're using PhpStorm, saw the `.idea` in `.gitignore` ;-) * You almost have PHPDOCS everywhere but event not all the types are specified; I'd suggest to complete them. E.g. \Dragooon\Hawk\Client\Client::createRequest, \Dragooon\Hawk\Client\Client::createBewit and uh \Dragooon\Hawk\Crypto\Artifacts::__construct needs quite some, etc. * I saw your use of trim() and saw e.g. \Dragooon\Hawk\Crypto\Crypto::calculatePayloadHash(). As I said, I don't know Hawk at all, so I just assume all you're dealing with is purely ASCII at this point (maybe base64?) so UTF-8 or other charsets are not an issue? * \Dragooon\Hawk\Server\Server::__construct(): $credentialsProvider has phpdocs to be of a specific interface, but the code reveals it also can be a callable. (phpstorm flagged this one for me :p ). Same with $nonceValidator it seems. This is also flagged in those places where you call that code, e.g. src/Server/ServerBuilder.php:99 * In src/Server/Server.php:266 you use base64_decode but don't check return value and you could also use the strict flag, just in case * \Dragooon\Hawk\Time\TimeProviderInterface::createTimestamp() should probably document it's supposed to be unix timestamp, just in case. * src/Server/UnauthorizedException.php:19 : $this-&gt;attributes = $attributes ?: array() -&gt; you could use use array as default value instead of null * This regex '/^(\/.*)([\?&amp;])bewit\=([^&amp;$]*)(?:&amp;(.+))?$/' in src/Server/Server.php:257 : I know nowadays everyone is a regex guru, still I admire people who take their time, use the /x flag and put in comments to describe not only what but why, etc. In general, I like what I see. It's on the level where I would tell my CTO: "his code would qualify for hiring" ;) [but as I said, didn't check actual logic/implementation]
&gt;What are your requirements? If no specific extensions are required, what's your minimum PHP version? Something tells me it's at least 5.3 due namespaces and not 5.4 due not using the short array syntax. It's 5.4+ actually, I'm converting into short array syntax. I'll mark that in composer. &gt;Provide a .editorconfig[1] file specifying the basics regarding your indentation rules. So many editors support it, it's worth it. Thanks! I wasn't aware of this &gt;Libraries usually don't require a composer.lock file. There's nothing wrong with, but given that you only have one non-dev dependency and the requirements for dev dependencies look quite liberal to me except for php-test-report I guess it probably shouldn't be required I was on the fence whether I should include it or not, quick Googling gave me a result that I probably should. I guess either way is fine? &gt;You could https://travis-ci.org/[2] ; integrating github projects is a snap, it's free for open source, you can test multiple PHP versions, etc. Since I see code quality is important to you, unless you've a beef with such services, it may be a good addition Yes it's on my to-do list, I'll checkout Travis as soon as I can &gt;I randomly opened tests/Client/ClientTest.php, saw three unused aliases. Are you using an IDE? It will probably show you such things, e.g. http://i.imgur.com/4NOFQLi.png[3] . Of course you're using PhpStorm, saw the .idea in .gitignore ;-) Yeah, I'll clean those up &gt;I saw your use of trim() and saw e.g. \Dragooon\Hawk\Crypto\Crypto::calculatePayloadHash(). As I said, I don't know Hawk at all, so I just assume all you're dealing with is purely ASCII at this point (maybe base64?) so UTF-8 or other charsets are not an issue? I merely wanted to get rid of whitespace to reduce some unexpected behaviour, what is the correct way to deal with it? Most of it is base64 so I guess it should be fine? Thanks for your other code pointers, I'll definitely give those a look next time I'm working on it (probably a few hours from now).
Oh man, we have all these amazing debugging tools and here I am using die with var_dump.
You can achieve the same with a simple decorator, without any AOP APIs. The reason why AOP techniques persistently remain unpopular is because they optimize cases that happen exceedingly rarely (logging aspect, auth aspect... aaaand that's it), while encouraging a mess known as the "COMEFROM pattern". You know how "GOTO" is considered harmful? AOP is like [a parody version of GOTO](http://en.wikipedia.org/wiki/COMEFROM) with reverse flow. Instead of saying "go from here to there" you say "come from there to here". I.e. you have statements like COMEFROM BEFORE Foo::bar(). The mess you'll have soon for yourself if you build apps this way...
&gt; You have classes that are basically empty. It's not a hard rule, but by convention, **almost everyone prefixes private variables with an underscore.** [/me spits drink](http://i.perezhilton.com/wp-content/uploads/2014/08/oed-new-word-list-stephen-colbert__iphone_640.jpg) Sir/madam, I think you're in the wrong subreddit. 
Surprised you managed to create an implementation out of the half-assed protocol documentation Well done!
I usually listen to something instrumental whether it be classical or soundtracks or whatnot. I'll sometimes listen to recordings of drum corps shows. Especially the Blue Devils. Lyrical music is just too distracting sometimes.
Justification for creating it: Because it's fun Justification for others using it: That's why I'm seeking feedback for what I've made so far.
&amp;#3232;_&amp;#3232;
I don't claim this to be a universal standard. In fact, I think its uses are pretty limited. It seems best for meta configs, describing schema, etc... which is a bit ironic since the example provided is really variable data. As noted, though, I wrote it for data mapper configs.
&gt; I've worked solely in PHP on a professional level for years. As have I, and in recent years the convention has fallen very much out of vogue. I *believe* it is part of the PEAR standard (long time since I've looked at it, so may be wrong), and I believe it exists because in a bygone era PHP didn't have access modifiers. &gt; PSR-2 advises against it, but it's exceptionally common and to be honest I'm not sure why they opted against it Because it's wholly redundant. You have an access modifier which says "this is private". Every IDE worth it's price tag will correctly inform you of the visibility of variables and methods and squawk errors at you if you try and do something silly. I think it once was common, but these days not so much. One hopes PSR-2 wasn't simply written as a popularity contest and that there was some rationale around determining the rules. &gt; Eloquent doesn't have a single private variable I'm not sure what that has to do with anything? &gt; The more I think of it, I can't come up with a single reason why you wouldn't prepend it Can you come up with a single reason why you **would** prepend it? &gt; It's succinct and can prevent you from making mistakes. I can't see how it prevents you from making mistakes - could you elaborate? 
Fair enough :)
Refer to my response to the other post.
Oh hi! I mostly contacted to know if you're still continuing with the development, if that's the case I'll fork your library as soon as I can and send back a few changes I made that weren't cosmetic.
&gt; Sure. But if you're working on a linux box without a GUI and using VIM without a plethora of plugins why are you developing under that environment? The only place that would exist is in production as best I can tell..and if you are making changes to scripts in production you have bigger problems than the visibility of things. &gt; Just that a commonly used tool that accomplishes the same task the OP set out to address has no need for them. But you're appealing to authority... just because Eloquent doesn't use them doesn't mean OP isn't entitled to feel his architecture requires them. &gt; Aside from the obvious? That it's a trivial determination at a glance that the variable is private, and you won't attempt to use it in a subclass? Why isn't private $foo; considered "trivial determination at a glance" in your eyes... To me it is far more explicit than my brain having to mentally parse "one preceding underscore == private access" 
None taken. And I don't want to sound harsh, but you sound like you work at a small company that doesn't have virtualized environments and dozens of repositories across distributed systems. Someone who likely uses windows. Just a hunch. I'm well aware of modern PHP development, but I appreciate your concern based on the fact that I like to prefix private variables with an underscore.
The legal requirement of making no personal copy of the codebase is met by the company giving you the computer in your office to work on. It's their computer, it stays with them, so the code is not with you.
What? You're missing a chromosome or just so angry that you can't read I guess. I'm done. Enjoy your victory.
&gt; Working at a publicly traded company, we are generally not allowed to have local copies of our codebase on our systems. I'm fairly sure other publically traded companies get around this. By providing equipment, signing of NDAs, and frequent audits. Your requirements seem to be fairly unique... and I feel for you. Sounds like some CTO somewhere with no clue has set up your working conditions in a fairly shitty way. I'm sorry. &gt; We have an entire deployment runway including unit testing, pre-UAT environments, UAT environments, and an entire build suite based around the Atlassian products (bamboo, stash, JIRA, etc.). This is exactly the setup I use..however I don't force people to SSH and use vim... &gt; I'm talking about opening the file and looking at a method that's 50-60 lines from the declaration and just immediately knowing, rather than having to scroll up and determine it. It's clearly a matter of opinion on which we disagree. That's allowed. IDE's just solve this. It's a symptom of the shitty work practices you are being forced to endure. It doesn't make it good practice.
Which was also a "we're not dead post", as was the previous post before it in 2009. That sounds pretty dead to me.
That jin thing looks pretty cool, I may have to steal it! :P
&gt; I'm not talking about eye-balling the declaration. I'm talking about opening the file and looking at a method that's 50-60 lines from the declaration and just immediately knowing, rather than having to scroll up and determine it. BTW that's logically incoherent. - If you see a property used in a method that's 50-60 lines from the declaration, then obviously that property is accessible in that scope. No need to check the declaration. - And if the property is not there you'd need to inspect the declarations and then you'll also see their access level. - There's never a situation where you see a property is used, and you want to use it there and you need to see an underscore in order to determine if you can.
I'm not downvoting you, fwiw. I don't really care about internet points. I even acknowledged I'd relent on the _ bit. I'm just making my case for it. I also don't think it's as unique as you seem to think. NDAs don't solve it. That's clearly a given. Even with encrypted file systems, there are certain things we just can't get around, especially when we have access to millions of dollars of protected IP. It just isn't going to happen. The _ thing I'll even recant completely on. To each his own. And I appreciate you not letting it devolve to the place that the other guy did...shows that you're at least engaging in conversation. I, personally, have no issue working with VIM. I rather enjoy it. And it's not a matter of something I've used for decades that I've grown accustomed to. I've only had a basic need for it in the past 2-3 years and I've found that it does certain things exceptionally well. For my workflow (and I'm not nearly as in-the-minority as you might expect), the command line is home. You'd be surprised at the efficiencies that are available. It's not nearly as archaic as you'd think. I've worked with Visual Studio, IntelliJ, PHPStorm, Netbeans, VIM, nano you name it. All have their strengths. Do I miss certain features? Sure. Aside: I actually upvoted you because you remained civil.
It looks like their terms of use prohibit what you are trying to do.
Why does the cover of your book have a picture of mixing console on it?
Generating configs is fine, but that simply doesn't work for anything you end up needing to customize. The major problem with YAML, specifically as it relates to doctrine configs is that it essentially becomes unreadable. It's just a mash of characters and colons. JSON wouldn't help this as it would just throw quotes into the mix. XML is readable and descriptive but even more verbose. I'm not sure a single one of my YAML configs on a large enough and complex enough project with doctrine could be auto generated from schema info.
I fail to see how PHP arrays can be auto completed. Sure, the structure can be, but keys and values are not. It's useful if you need to execute PHP. I have plenty of configs that are PHP based, my entire framework uses PHP based configs, but these are not large amounts of repeated data structures, they're one offs with lots of comments and unique key values: https://github.com/dotink/inkwell-routing/blob/master/plugin/config/default/routing.php
&gt; NDAs don't solve it. On their own, no. But coupled with policy and audits against that policy they can be quite useful at protecting IP without tying developers' hands behind their backs. &gt; I, personally, have no issue working with VIM. I rather enjoy it. And it's not a matter of something I've used for decades that I've grown accustomed to. I've only had a basic need for it in the past 2-3 years and I've found that it does certain things exceptionally well. I don't either. VIM is a tool that every developer should have in their toolbox. I have a problem with using it exclusively to develop in an environment where you are required to ssh into a remote server and work without the assistance of plugins. That rings awfully close to "edit files on production with VIM" for me and makes me nervous. &gt; For my workflow (and I'm not nearly as in-the-minority as you might expect), the command line is home. For this, I don't think you are in the minority at all. Most (all?) of us use the command line a whole lot. But usually in conjunction with other things. The command line aids productivity in some areas, IDEs in others. Having a toolbox full of a variety of things which make your life easier is a good thing... and again, not something that should be mandated by the company that you work for.... I think that battle has long since been won as well. Let your devs use whatever the hell they want to use in order to get the job done. &gt; Aside: I actually upvoted you because you remained civil. I appreciate it. 
A meta language (a DSL) is suitable in some cases: - When you target non-developers, say end users. Talking about SQL schemas, I doubt it's the case. - When the configuration is cross-platform (say, same schema to be used across PHP, Python, Java and so on versions of a library). Again, not the case. Suggesting "less learned developers" would have a problem creating objects and calling simple methods is troubling. If they can't do that, how are they expected to develop anything? And thinking about how to fit your features in a custom DSL parser is also not going to help your project get off the ground faster. You can implement APIs like the above in minutes. It's not hard to write it down. It's certainly not slower to write a few methods than integrating a parser and a custom language into the pipeline. &gt; Seems as standard at least as INI and JSON, that is INI is standard... JSON is standard. Jin is just a combination of the two. Combining accepted standards into a hybrid mutant doesn't automatically produce a standard... Standards are useful when you bridge different tools and projects, because a standard's wide acceptance and compatibility acts is an interface point between two foreign projects, which isn't the case here. It's a specific project that could use anything it wants with the same end goal. So I'd pick the easiest and most flexible solution for a PHP project: PHP.
Sure. I'm not knocking it at all, just stating that my preference is towards more well-established tools (especially ones that more developers are familiar with). As stated elsewhere, I prefer anything related to my database to be completely machine-generated, so the syntax is irrelevant to me (so, largely, I'll skew towards whatever's the fastest, which almost inherently rules out anything not in a native C extension) I do the same thing with routing whenever possible, too. But that's not going to work in every situation, either.
&gt; Inevitably most data structures (even config APIs) result in the production of an array with respect to PHP. I thought I demonstrated it doesn't have to be the case. &gt; Having done a fairly large application in doctrine, I can't imagine the nightmare that would be maintaining it had we opted to configure everything using the PHP methods. Why? &gt; Fluent APIs have their place, and configuration may be one of them, but for anything remotely complex, they become very difficult to follow very quickly with potentially lots of nested brackets, arbitrary indenting on -&gt;'s, etc. Think about it for a moment. You balk at the idea of indenting "-&gt;" a bit differently than you have so far, yet you don't mind switching to an entire new language just for config. Which is more effort for both you and the people using your API? I don't know if [you've seen PSR-7](https://mwop.net/blog/2015-01-26-psr-7-by-example.html) (check the -&gt;withFoo() code examples), but fluent APIs are not something you can shield yourself away from. And if we'll all be using them, then "it'll be confusing and different" is not a valid argument. But you need neither the indentation, nor the nested brackets: $tableFoo = new Table(); $tableFoo-&gt;col('id', new VarCharCol(128)); $tableFoo-&gt;col('name', new IntCol); $tableFoo-&gt;col('groupId', new BoolCol); $tableFoo-&gt;pk('id'); $tableFoo-&gt;relationOneToOne('groupId', 'id', 'Groups') $tableGroups = new Table(); $tableGroups-&gt;col('id', new BigIntCol()); $tableGroups-&gt;pk('id'); $schema = new Schema(); $schema-&gt;table('Foo', $tableFoo); $schema-&gt;table('Groups', $tableGroups); Better? It's the exact same code. As I said, formatting is up to you. I won't sit down and argue about tabs, spaces and indentation for sure, that's not the point.
Some config libraries like [Zend\Config](https://github.com/zendframework/zend-config) have adapters for many different config languages that can be parsed and merged into a common config object. Then you (and consumers of your orm library) can decide to use any config they want. No need to re-invent the wheel here.
Check if the site you want to scrape offers an API. 
Two quick things. One, you aren't quite following PSR standards with your class naming. Not a big deal, but when building a library it's nice to aim for consistency with recorded best practices, and I noticed your query classes especially don't follow convention by having class names which don't align with the file names and being underscore-separated instead of CamelCase. Two, and more importantly, your ORM is part of the same repository as your application framework. Personally I'd have broken it out more into separate, reusable components--since there's no real need here to link Application and ORM code, you may as well completely detach them so that you can require them in as-needed on a per-project basis. That's something which the Node community actually does rather well, they provide a wide range of simple components which can be required in as needed instead of a few more monolithic projects.
&gt; id('content')/x:div/x:div[1]/x:div[@class='example'] what syntax is this written in? why is it kind of explicit but at the same time implicit?
https://www.mashape.com/community/urban-dictionary
&gt; is because in standard they saying that CacheItem should be portable and do not depend on CacheItemPool. As one of the people who wrote the standard I'm confused as to where you saw that.
&gt; they optimize cases that happen exceedingly rarely (logging aspect, auth aspect... aaaand that's it) You forgot transaction management. And yes, those three are really rare aspects.
AOP belongs to Xerox: http://www.pmg.lcs.mit.edu/~chandra/publications/aop.html … but who cares.
Looks like xpath, a good friend of less-than-ethical scrapers.
You could also use [ParseHub](https://www.parsehub.com/)
Using Apache .htaccess for your application routing 
Like...have all the routes defined in .htaccess or using it as a forwarder for all requests to your router?
What would be a good topic then? REST is more or less the de facto method of building web applications. If you don't want it as an API then just render html instead of json. Or maybe that is what you would like to learn? 
I'd hazard to say most of them didn't involve actual authentication in those REST calls either, did they? If they did, I'd love to see them. The "REST endpoint API" tutorial is just a fancy 'hello world' in most cases, and doesn't show you how to do real world stuff. In no case, have I ever need to expose any sort of endpoint (REST, SOAP, etc) without doing some form of authentication and filtering based on credentials (no, I don't want to see *all* the people records, just people in my organization, etc). Pointers to any framework tutorials that touch on this would be appreciated (while I know how to do all this stuff, I routinely am at a loss for resources to point other people to when I get similar questions). 
Some small mistakes in the list of big mistakes: **Mistake #3:** file_exists() is not sufficient to avoid an error, you should use is_readable(). And you still check a file twice (this is not cached), so sometimes it's actually better to just do @fopen(). In some cases you can't or it's impractical to use is_readable in the first place (like reading from an HTTP stream), so we fall back to @fopen() again. **Mistake #6:** Don't mix "validation" with "encoding". Injection attacks happen due to improperly encoding a piece of data for its medium. Encoding is context-sensitive, validation isn't. Encoding is irrelevant to your domain logic, while validation is *about* your domain logic.
It is also valid on fopen, between a call to file_exists and fopen, the file might have been removed. Neither does file_exists test if the file is readable, is_readable is the function for that. But really I think that any smart developer would be using a library instead of trying to write your own solution from scratch. 
Nothing that has been said is exactly news. The underscore bit I let go. Aside from that, the criticism appears to be using vim, which is not something I'd even want to change. Most people that aren't familiar with it think it's weak and archaic. It couldn't be further from the truth.
I can't find a specific tutorial right now but you should look into Slim Middleware. You can create a middleware class that installs a hook to do authentication.
Oh wait. You said you were looking for other people. Sorry. I'll try to find the tutorial that I used originally
I've reworded this - "maintainability" touches on a lot of future potentials, which may or may not happen on anyone's particular watch. "Confidence" is much more relatable to the current parties. How do they deal with changes right now? Are they in a situation where every time something is changed, other things break? Do the workers have any confidence in their own code changes/updates? Do the other depts of the org have confidence in the tech team? Do the external clients (generally "paying customers") have strong confidence in the service, or are they leaving to competitors? "This will cost a whole lot in the future!" Yeah, right. They've probably heard that for years, and they keep hiring/firing unqualified developers who get in over their heads, panic, continue to add on to the pile of crap, then repeat the same cycle. It never costs them a whole lot because they're never doing it "right" (or "less wrong"). Similarly, if they've always done it this way, the idea that future changes could cost less, be done faster, and not have bugs... likely doesn't register as believable. An overhaul with a focus on giving everyone strong confidence in the process and the outcomes may be an easier sale.
&gt; he is going to have to find everything out himself. One of the counters to this I've found going over legacy codebases is that there's often code that no one knows why it's there, but everyone steps around it, makes sure that part continues to do whatever it's done in the past ("this is always supposed to return '80RT!'") and never bothers to dig deeper. Someone new coming in actually goes up the chain, asks other people involved, and realizes that the particular section of code or UI hasn't been used in 5 years, and was abandoned as a use point by dept X because it never really worked right in the first place. If you can get others beyond just you and another developer involved in a rebuild (like, the actual stakeholders who use the system) you may learn that it's really *not* feasible to do a rebuild, or, indeed, it's something everyone's been *needing* for months or years but hasn't had the political clout to make happen on their own. I've seen both extremes. 
Scripted it up a long time ago. Can't seem to find it. It supported a simple key =&gt; value syntax [cat] subcat = key1: value; key2: value; To be parsed this way, there must be a colon separator and a trailing semi-colon in the correct pattern, to avoid conflict with text strings that contain these characters.
I get that. Maybe I should rephrase the question. I just want to find out how to work with Slim's templating engine.
I used PHP-GTK for one-off GUI scripts back in 2009, and really thought the concept was a good idea. I realize now that I was wrong back then, but right today. PHP7 will mean serious business in the programming world; why should Python and Ruby get all the good GUI bindings?
&gt; Well that settles it then. I'm actually writing something for a reason and you're just coming up with theoretical nonsense. Way to miss the point of the example. &gt; All easily documented, clearly portable to other config languages, able to be easily read/generated by other tools. Then we have your ORM config... which requires you to write a PHP parser if you want to glean the info from anything other than PHP. Oh, so not only you will challenge Doctrine in the PHP landscape, you're already optimizing for a future when your library is ported to N other languages. **/me sips coffee** Good luck with that.
&gt; ...when your library is ported in N other languages. Not what I said or even implied. The config language is portable. Just because an ORM is written in and for PHP doesn't mean that other tools can/won't be used to set up configurations or to use some of the same config information for other purposes. 
Check MINI2, a simple framework built on top of Slim to create web apps &amp; websites https://github.com/panique/mini2
&gt; Once again, if comments could be compiled to parsers, you'd be golden. They can. RFCs and other standards are essentially comments with a formalized language. &gt; There are like a dozen of JSON parsers for Java, say. All of them complete, tested and production ready. There are zero Jin parsers for it. So when JSON was invented, were there a dozen JSON parsers for Java? Or was it something someone did some initial work on, wrote an initial parser, and then developed from there? Everything is new and not widely supported initially. Even if you want to make the argument that JSON comes from JavaScript, Javascript is far more loose with its parsing, formal JSON spec, for example, requires ""'s, JS can contain comments, etc... and EVEN that syntax had to be invented and with limited support for some time. What is your actual argument here? That it's new? Fine, I concede... Jin is a new idea. &gt; That's not a common standard you can lean on as a data interchange format It's not designed to be a data interchange format, and I made that very clear in the OP that it's usages are limited and it was designed specifically for ORM configuration. Data interchange formats are not usually looked at with human eyes, and when they are, they are often times represented by tools which parse them and represent them in a hierarchical nested, expandable, browsable view. You're way off base here. You're just straw manning what I'm claiming it to be and then arguing against the straw man. Let me make this clear: Jin is a combination of INI and JSON which was designed, specifically, for ORM configuration, but is probably useful for other configuration formats with repeated config options that need to be keyed by different values. I'm not "leaning on it" as a data interchange format. I wouldn't even use it as a data interchange format. If someone said "I want to use it as a data interchange format," I'd tell them NOT TO. &gt; So none of what you listed goes against what Doctrine is. Doctrine is far too complex to be approachable by most developers (including me). That's an issue, and one I also intend to solve. I wrote a layer on top of doctrine previously which attempted to do SOME of these things and it was an absolute nightmare due to the complexity. Responsibilities are far too granular, and the documentation at that level is essentially non-existent. There are additionally lots of surprises, and really bad decisions up front, like the entire type system. It's fine to have a class encapsulate a type, but you run into some pretty significant issues when any type outside of that system (even if the data is not used/accessed) blows up the entire thing. BTW, the vast majority of value is subjective. Objective values only arise from facts of existence which often have little to do with Programming (at least at this level). &gt; And yet, you're not contributing to Doctrine, you're making your own. Correct. For reasons cited above. It's an aging codebase with lots of gotchas, difficult to use or extend pieces, and a less than ideal bootstrapping cost for mid-range projects.
My conclusion is not "hideous", I just said he's not ready to give tutorials just yet. "Just yet" suggesting with practice &amp; studying, eventually he will be. If someone started posting legal or medical advice that's misleading we'd correctly inform them they shouldn't give said advice. In the software industry it's suddenly all about emotions and not hurting each other's feelings. Well, I don't see why. When I said I love him for trying, I really do. You do need energy and perseverance to become great at something and he's certainly showing it.
PHP's magic is bad enough for breaking the human-readable flow of execution, but using a plugin that magically diverts program flow even further sounds like a recipe for pain. If you need logging or transactions you can always do it through inherited functions and calls to the parent method without too much pain -- I just have never encountered a use-case where method interception is worth the pain of the confusion you cause.
Well, you always can use another framework. Try Fat-Free Framework http://fatfreeframework.com, very well document and easy to understand. If you choose this one, send PM for any doubs or check their google group.
I do something similar. It's interesting how you define queries: via object fields, or database fields (in case they don't match after mapping).
Agreed. The fact that a new ORM/AR/DM/etc shows up every couple of weeks indicates this is far from a solved problem. I once went through the motions of moving all of the search-related stuff to a secondary tool (Lucene or something to that effect) that would basically return the primary key for the DB/cache lookup, but it was overkill at the time, and waaaaay too much for consideration in a personal project. You can also go down the road of building a massively-indexed DB slave, but that is still mostly crap for any sort of fulltext searches. It's all super-situational. The above was in the context of searching billions of rows of API logs, but I'd be taking a completely different approach if it was a CMS. Hell, the first version of Yahoo! search was grepping flat files. Which could still be viable to a degree in some contexts.
&gt; Can you use YAML? Sure. Can you use JSON? Sure. Can you use XML? Sure. Can you use PHP? Sure. Sure, and you, a one-person-team, would commit to having the same level of documentation for them all as your pet format, and not end up with a Doctrine situation where YAML is in all the examples, and the rest - screw it. You should be thinking about your core concerns. Your core concern is the ORM itself, and not how to configure it. That whole config format subsystem should be a separate package done by someone else. If I were in your place, I'd think like this: "I create and document one lean way of doing it: PHP; if someone wants something else, they can compile to that PHP config, job done". I just eliminated that whole debate, while still allowing those whose hands are itching for a YAML, JIN, XML, whatever configuration to have one. "Do one thing great", "composable tools", "less is more", yadda yadda. It's like I'm talking to a wall, but one day you'll get it.
You gave up reading mid-sentence again didn't you: &gt; "... and not concern yourself with a config format parsing infrastructure" Anyway, I don't suffer fools gladly, so I'm bailing thread. See ya. 
thx
If all developers are aware that the interceptors exist and it's organized clearly, I don't see how much "pain" or "confusion" would exist. That's where good documentation comes in.
[From an interview with Vincent PONTIER](http://7php.com/elephpant/): &gt; In 1998, CGI scripts were one of the only ways to make a ‘first generation’ website a little more interactive with visitors (Forum , guestbook, … ). One evening in November, a developer friend, François BUFFIÈRE, talk to me about this new language called ” PHP “. A language that would, according to him, revolutionize the interaction with visitors in the years to come. In 1998 few French web site talked about PHP. Only Jean-Pierre DEZELUS, site owner of dezelus’page – a personal website that would become the famous PHPinfo.net, spoke of this programming language. While my friend François who came to code at my home to show me what they could do with this “PHP”, in a deep thought, I was having fun drawing the letters “PHP” in capital letters on a white sheet of paper. &gt; By chance – chance sometimes do make good things happen – I suddenly noticed that the letters were forming the shape of an elephant if viewed in a ‘sideways angle’. Look at it well, you’ll see! I sent my first drawing to Jean-pierre Dezelus who I did not know at that time. He was a collector of elephant, this is amazing right? So he asked me to create an elephant in the same style as the true PHP logo. &gt;A blue oval with a black outline gradient. I did what I had to do and we put this “elephant logo” for download on his website. While putting it online, I named the image file as elePHPant to play with the words a little bit (words’ pun). &gt; The rest of the story you know… Over time, the PHP community has grown, PHP has become the most used language in the world on the internet and developers have adopted the elePHPant as a mascot just like the Linux penguin! A plush animal was born 10 years later. It is now known around the world … A beautiful story of chance 😉
interesting. Did not imagine this to be the case. 
&gt; There are probably some good books and other resources out there for specifics. This is a good starting point: http://www.phptherightway.com/ More here: https://github.com/ziadoz/awesome-php#resources
It's possible the team you are joining use Vagrant to fire up their LAMP stack, which means they would be running a headless VM locally, similar to production, with the project files (C:\Project) mounted inside (/var/www/project). This is a good way to work as the development environment closely matches production, can be easily shared with other developers, etc. From there, they would typically use Windows applications to modify the project files on the host machine (e.g. edit in Sublime, Alt+Tab to Chrome, F5 to refresh, etc.) and will only SSH into the guest VM to run CLI tools (such as vim, htop, phpunit, etc.) Although this only gets you half of the way (you don't avoid the Windows GUI), the reason I mention this is running a VM within a VM (although possible) is sub-optimal (.. and if they don't develop this way, you may wish to encourage them to.) While you could run a VM with window manager as you state, I still don't think you will be able to completely avoid Windows as you will possibly need to use the company's email client of choice and some Microsoft/Adobe products at times. You might find it easier to adapt with the help of some nice things, but YMMV: - http://gooseberrycreative.com/cmder (or http://babun.github.io/ if cygwin is a must) - https://github.com/fuhsjr00/bug.n (haven't tried it but looks decent) - https://github.com/guillermooo/Vintageous (or just use vim/gvim)
Uhh...
Version controllable configuration/provisioning files. Pre built images for common stacks (LEMP, LAMP, etc) Downside IMO is that some people will never learn how to put there own stack online with the advent of these tools.
In my experience, the downside is that getting a VM up and running can be a huge hassle. Host machine permission problems, network/IP problems, folder sharing issues, the fact that certain environments (cough, windows) straight up don't allow certain VM features to work unless you run as the root administrator (not a user administrator, THE administrator). Some things like scotchbox say they have display errors and xdebug enabled by default, but they don't. In some instances, you simply cannot get php-fpm to recognize php INI changes in the VM no matter how hard you try... Not once have I ever had a team VM spin up smoothly or just work right out of the box :/ Also, VMs are *slow as balls*. I allocate basically half of my MBP's resources to a VM, and it still takes a good 1-2 seconds for even the simplest of requests to execute. Makes it kind of hard to tell when I've got an actual performance problem, or it's just the VM dragging ass.
Even if you're comfortable setting up your own VMs, I would still recommend vagrant. It takes care of things like networking, port forwarding and shared folders in such a simple fashion. Every time I try to set up a VM from scratch I always spend 10 minutes configuring the same stupid shit every time. Not so with Vagrant. If you want full control over the VM, you can easily create your own VM from scratch, add the vagrant user and SSH key, and convert that into your own personal Vagrant box.
Check out [this link](http://www.whitewashing.de/2013/08/19/speedup_symfony2_on_vagrant_boxes.html). It reduced the load time by a ton for me.
thanks, I'll check it out!
Anyone aboard the docker train yet? I know vagrant and docker are not the same but they are 'similar'
Just a thought ... These seem like questions you should have asked *before applying* for the job, don't they ? A Windows shop that deals with PHP seems a little strange to me, especially if deploying using Windows infrastructure; That would be equal amounts of stupid, and expensive. Not being able to take your hardware into the office is pretty normal, so is the use of virtual machines. I guess you'll just have to get used to that. If you were at home, using your hardware, then you could argue the case for using a proper operating system. They seem to hold all the keys, there is probably no point wasting time arguing the case, your time is probably spent better elsewhere at this point, you have a lot to do ... Someone already mentioned PHP The Right Way ...
How old is you Mac book pro? Did you mistakenly turn off vt-d? Does you mbp have a ssd? You ma be having network issues.
then again, who develops on a non-linux kernel lol. btw, i highly disagree with docker being oriented towards deployment. :P such false information such lies.. !
I do, and I know a lot of others who do too. I personally found using Windows + Vagrant easier than any other combination for the mix of tools. Plenty of other people prefer other combinations. I don't think there is a "right" way to do it, so long as you produce good quality code that runs on the target environment.
What did you imagine? That a serious discussions related to performance and scalability was planned to come up with a mascot?
Do you develop on linux machines? It doesn't work well for me on OSX. The key problem is that you can't seem to have writable directories using boot2docker on VirtualBox. It means that Laravel doesn't work as it can't write to to storage dir
Thanks for the reply, I truly appreciate it. I think much of it was the disappointment in receiving the code, after answering an ad for an PHP OO developer. I was a crappy PHP developer at one time, before I worked hard to grok OO code, classes, objects and design patterns. My main worry was getting a few symfony bundles which I wouldn't understand. What I ended up with was work which I had hoped to stop producing years ago. &gt; your post (probably in an attempt to be humorous) seemed a little over the top re the old code. Agreed. I'll have to keep crappy sarcasm out of my submissions. 
You're using the same paltform combo as me then. I don't suppose you know of any solution to the cripplingly slow file IO with shared folders etc? I don't currently use vagrant, but I do use VirtualBox, and have the linux guest sharing its folders via samba. This leads phpstorm to complain about a "slow networked drive" (and it is indeed quite slow) On the other hand, when I've set it up in the past using a shared folder (so that the files are actually on the windows host), I've seen problems with apache not noticing that files have changed and so continuing to serve the old version (e.g. a stubborn CSS file that will only update when apache is restarted).
Congrats. One thing that turned me off from Hoa components in the past is the versioning scheme. You should really switch to a more common one like Semver. I see versions like "0.15.05.27" and I have no idea how to put a constraint on that. I'm assuming that's supposed to be a date but that's just not working for me, I need a way to ensure that my app won't break on every update but I'll still get bugfixes.
I used it on some packages in the past, was using xdebug + PHPStorm before. Definitely a very nice tool, easy to setup and to use.
&gt; http://hoa-project.net/Source.html#Rush_Release I have never stumbled upon this page before, how did you even get there from the homepage?
That's weird, I saw the menu, I guess "Sources" didn't strike me as where I'd find versioning informations and I msut have skipped it. I think it should be more prominently featured because in an ecosystem where most packages follow Semver it's pretty important to state clearly if you don't, shouldn't be hidden in a page in a small menu on the top left, it should be straight on the homepage (like just a link to it).
Ok, firstly you really need to [get rid of the `mysql_*` functions](http://php.net/manual/en/faq.databases.php#faq.databases.mysql.deprecated). With that out of the way, the error undefined variable means you're trying to use a variable which hasn't been defined yet. For example: $variable = 'hi'; echo $variable; // Will echo hi if ($test == true) // Will throw a notice because $test hasn't been defined yet so PHP doesn't know whether it's true or not echo $variable; Your notice is in relation to `program_ID`, mainly on line 100, if the query on line 90 (and the loop on lines 91-93) doesn't get any results then `$program_ID` will never be set, so the query on line 98 ends up being: SELECT color FROM campaigns c JOIN programs p ON c.campaign_ID = p.campaign_ID WHERE program_ID = Which mysql doesn't like because it just ends, if `$program_ID` was in quotes then the query would look like: SELECT color FROM campaigns c JOIN programs p ON c.campaign_ID = p.campaign_ID WHERE program_ID = "" Which would be fine for mysql. To fix this, give `$program_ID` a default value in line 89: $program_ID = ""; $queryProgram_ID = mysql_query("SELECT generateProgram_ID FROM generate_programs WHERE generateProgram_Name = '$program_Name'"); while ($program_ID_row = mysql_fetch_array($queryProgram_ID)){ $program_ID = $program_ID_row['generateProgram_ID']; } And add quotes on the query incase the value isn't set: $getCampaignColor = mysql_query("SELECT color FROM campaigns c JOIN programs p ON c.campaign_ID = p.campaign_ID WHERE program_ID = '$program_ID'");
no, i though it was rasmus's fav animal or something
Holy schmolies, what a website. How do you get out of the Search box? I'm stuck.. PS: Congrats on the PSR thing. 
I cant seem to find any pricing? It says it is a SaaS? Does anyone know the $?
&gt; if ($test = true) // Will throw a notice because $test hasn't been defined yet so PHP doesn't know whether it's true or not No, it will assign `true` to `$test`.
Haven't really had issues with that, we use OSX and boot2docker too. Here's an example [docker-compose.yml](https://gist.github.com/veloxy/17d91421813856d4cd79) file, some images are custom, here's the code for them https://github.com/yappabe 
escape key works 
lol touche
I don't think is the case. I choose lightweight frameworks such as Slim as it's easy to get started and there are less roadblocks when something new needs to be implemented. You get the flexibility of pairing it with the libraries you like too. 
&gt; typed it up on mobile Impressive :)
Pretty much; it's one of those tools that does something you could cobble together from open source solutions, but puts it all together nicely for you. Disclaimer: I work for Sensio Labs UK, I'm not involved in Blackfire.io directly
Try WinNFS, there's several server options out there... but I've never found one I like that gives me control over who can see the share. This seems to be the fastest, most sensible way of doing it though. I've also seen people use rsync, to copy files between host and vm. This has the highest speed on vagrant but there can be a bit of lag between changes propagating.
PHP is pretty much the [Ship of Theseus](https://en.wikipedia.org/wiki/Ship_of_Theseus) at this point. Here's hoping PHP7 ushers in the next 20 well!
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Ship of Theseus**](https://en.wikipedia.org/wiki/Ship%20of%20Theseus): [](#sfw) --- &gt; &gt;The __ship of Theseus__, also known as __Theseus' paradox__, is a [thought experiment](https://en.wikipedia.org/wiki/Thought_experiment) that raises the question of whether an object which has had all of its components replaced remains fundamentally [the same object](https://en.wikipedia.org/wiki/Identity_(philosophy\)). The paradox is most notably recorded by [Plutarch](https://en.wikipedia.org/wiki/Plutarch) in *[Life of Theseus](https://en.wikipedia.org/wiki/Parallel_Lives)* from the late first century. Plutarch asked whether a ship which was restored by replacing each and every one of its wooden parts remained the same ship. &gt;The paradox had been discussed by more ancient philosophers such as [Heraclitus](https://en.wikipedia.org/wiki/Heraclitus), [Socrates](https://en.wikipedia.org/wiki/Socrates), and [Plato](https://en.wikipedia.org/wiki/Plato) prior to Plutarch's writings; and more recently by [Thomas Hobbes](https://en.wikipedia.org/wiki/Thomas_Hobbes) and [John Locke](https://en.wikipedia.org/wiki/John_Locke). Several variants are known, notably "grandfather's axe". This thought experiment is "a model for the philosophers"; some say, "it remained the same," some saying, "it did not remain the same". &gt;==== &gt;[**Image**](https://i.imgur.com/R8BEF2r.png) [^(i)](https://commons.wikimedia.org/wiki/File:Pinocchio_paradox.png) --- ^Interesting: [^Ship ^of ^Theseus ^\(film)](https://en.wikipedia.org/wiki/Ship_of_Theseus_\(film\)) ^| [^Identity ^and ^change](https://en.wikipedia.org/wiki/Identity_and_change) ^| [^Anand ^Gandhi](https://en.wikipedia.org/wiki/Anand_Gandhi) ^| [^Paradox](https://en.wikipedia.org/wiki/Paradox) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+crze829) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+crze829)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
What are some good books about dealing with legacy code using PHP? 
Modernizing Legacy Applications In PHP by Paul M. Jones https://leanpub.com/mlaphp
Thanks!
Thank you.
Thanks :)
What is the actual metric that you guys use to claim you're minimal, performant and "fat-free"?
This in my Vagrantfile helped a lot on OSX. The default way of mounting shares was very very slow for me on OSX. config.vm.synced_folder ".", "/srv/web", type: "nfs", :mount_options =&gt; ['nolock,vers=3,udp,noatime,actimeo=1']
Not referring to full implementation, but the command bus is a fairly simple pattern that takes, say: $service-&gt;playPiano("song name", 140); and turns it into: $cmd = new PlayPianoCommand("song name", 140); $service-&gt;execute($cmd); The purpose being now you have the call encapsulated (notice the command encapsulates the action to carry out, "PlayPiano" and its parameters) and pass it easily through pipes and filters. PHP being PHP, and not Java, you can implement a command bus in a more implicit, dynamic way: $cmd = ["playPiano", ["song name", 140]]; $service-&gt;execute($cmd); // Inside execute(): $this-&gt;{$cmd[0]}(...$cmd[1]); You don't need a class for every command in order to gain the command bus benefits. What you do is up to you.
Awesome. Thanks - I'll try that out when I get some spare time :D
All you need is a good IDE and some google-foo. That is, if you're lucky to work with a relatively modern stack.
I propose a new rule for package writers. If it takes you more time to google up a logo for your new package, than it took you time to write the package, then probably it doesn't need to be a package. **OK, EDIT**: BTW, Paul, your Pipeline doesn't actually implement the Pipeline pattern.
Check out PSR-2.
I do actually like most of your comments, even this one. :-) EDIT: Although you do keep editing as you go without indicating as such.
Can we make this into something on github, or at least not using that website?
GPL for a framework, when there are so many more permissive licensed alternatives out there? Thanks, but no thanks.
&gt; PhpStorm Long-time vim/Sublime user, but this series finally convinced me to make the jump a while back: https://laracasts.com/series/how-to-be-awesome-in-phpstorm
That's a great idea. I can even have a TV show. On Fox News. It'll be fair &amp; balanced. I'll reach millions. BTW, I'm very aware you're not responding to my remarks about Pipeline. Not that you *have* to, but at least don't change the topic. 
How long is the study/questionnaire going on for?
&gt; If the name is your only complaint, I may change it to something more suitable -- it's only tree-and-a-haff days old, after all. Is it your only complaint? Think of it this way: if you fix the name, it enables you do add actual pipeline metaphor later when you realize nesting everything is silly.
Here's to the next 20! \*raises glass\*
Ooh, a pioneer! It must have been so awesome to create dynamic web pages in a world where you'd usually need to create static html.
&gt; Think of it this way: if you fix the name, it enables you do add actual pipeline metaphor later when you realize nesting everything is silly. So, the name is your only complaint?
No.
If you are hoping to get people to help write stuff to gain adoption for your project (like you eluded to with /u/idiot-with-opinion), you should follow a common standard. 
The discrepancy between implementation and communication is my complaint. If you care, you have two ways to solve it: 1. Change the name, keep the architecture. 2. Fix the architecture, keep the name. Emulating sort-of-pipeline by decoration has clear drawbacks as I already listed (piles state on the stack, the functions redundantly handle "$next" convention when they don't have to), so I know I'd personally pick option 2 (while still allowing stage decoration via "middleware"), but do whatever you want, just stop "semantically diffusing" everything you talk about. Here's an overly detailed pipeline description: http://www.cise.ufl.edu/research/ParallelPatterns/PatternLanguage/AlgorithmStructure/Pipeline.htm Check it out, it has interesting insights (like the fact stages may process series of I/O in parallel, which is relevant when implementing an async pipeline, say React.PHP).
I get you; I've been reading up on it since you brought it up earlier. But again, just so we're clear, if it gets renamed to something else more appropriate, that will satisfy you?
There's a simpler way to do a pipeline with "$next" than what you did - without nesting. Google "trampoline" for an example. If I were to use your component, I'd prefer the simpler, more performant pattern for the use case. But since I'm not using it, I don't care. I just care that you don't mislabel your "M&amp;Ms" as "vitamins". I'm easily satisfied.
We have our 1,000 target responses so we'll wrap it up pretty soon.
If you insist to miss my point you can take it as a "yes". Typically when I converse with a human being I'm not forced to reduce my answers to a boolean value. But you're different.
i love this chain.
&gt; I wonder what happened 1995. The proliferation of website ad banners.
From an article I wrote on PSR-X awhile ago ( full article at http://scriptogr.am/mattsah/post/a-useful-critique-of-psr-x ): PSR-0 was and is a cop out for people who would rather not invest the time in coming up with an actually appropriate solution. As with all of these standards, those of us who disagree understand that we do not have to use them. However, the consequences of not using them are potentially devastating to a library, framework, or simple module. In a world where a huge amount of the software we use is open source and the robustness of various solutions often times depends on the strength of their community, PSR-0 doesn't simply forsake namespace organization for filesystem organization, it creates a divisive and poisonous rift by reducing all developers to the lowest common denominator. ... continuing ... From my previous conclusion I noted that PSR-0 creates a rift. It would seem terrible if such a rift was extended to projects purely based on their coding standards and format. So that's exactly what FIG did when PSR-1 and PSR-2 were drafted and approved. 
OK, thanks. I randomly checked a few module composer.jsons but they don't have the "require" PHP bit (I think they should, for clarity)
Also looks like it relies heavily on a registry - which I instantly dislike.
I'm still liking Silex/Pimple over this though. Would be interesting to see some uh... well anything, I guess. There aren't any benchmarks or that sort of thing.
First, the namespace (Business) may not be related to the package name on packagist (florianv/business). I could have used florianv/biz as package name and Business as namespace. If you use multiple libraries with the same namespace, there should not be any conflict but it will be a source of big issues. If two classes exist with the same fully qualified name, only one will be loaded. It will be the one supported by the earliest registered autoloader.
&gt;The purpose being now you have the call encapsulated (notice the command encapsulates the action to carry out, "PlayPiano" and its parameters) and pass it easily through pipes and filters. And makes it super easy to serialize and put on a queue.
'Zactly.
pretty sure XSS attacks can't write to your file system, so an XSS exploit wouldn't have been able to create this file. 
I got my first internet account in 1995. By then I think I had started seeing lots of ads for "visit our website at http://www.xxxxxx.com" and figured it was probably time to check it out. I was using a 56k modem and Windows 3.1. I didn't use Windows for anything but internet access, because Windows was soooo slow on my machine. Windows 95 was so much more usable. But that came out in August, so not sure if it had a direct link to the new programming languages, but definitely helped make the internet more usable beyond 1995. AOL starting connecting to internet e-mail in 1992. And probably shortly thereafter was allowing access to limited internet sites. Still doesn't answer your question as to whether something specific happened in 1995 to inspire those languages.
&gt; you should follow a common standard. My comment here made no mention of PSR-2. Only the original one did.
Not for me. XUbuntu 14.04 + Chrome 43.0.2357.65 (64-bit) 
Try [BPMN](http://en.wikipedia.org/wiki/Business_Process_Model_and_Notation). There's even a [PHP implementation](http://www.processmaker.com/product-overview), but I wouldn't recommend that.
thanks all
&gt;Please take the time to read through the entire article – I realize it’s a wall of text, but it’s an important wall of text. By following the advice within, you’ll be doing not only yourself one hell of a favor, but you’ll be benefitting[sic] countless other developers in the future as well. I don't think it's an important wall of text, I think it's an unnecessary wall of text that can be ignored safely, and still write great code. Again, I do not agree with the benefiting countless other developers thing. Coercing them towards a herd mentality perhaps, but benefiting them, I seriously doubt it. Also, the article has so many inconsistencies that it's not even funny, and I don't have the time to point each of them out. If you can't see them, maybe you should reread the article.
Is there an agreed upon standard for naming Interfaces? I want to go with "IWhatever" but I get the distinct feeling someone will tell me it's wrong.
Interesting, hadn't thought of that. So the scenario here is: any form that can write to the file system is vulnerable to XSS, correct? 
Saved for future use, thanks. 
Uhm... Drop-downs? If you can't think of *some* positive spin to put on their choice of priority or architecture, you're going to have a bad time... Either socially or because the code really is that bad.
- In general it takes care (or at least tries to) of some security risk by escaping output. - Because template engine have very few logic operators/keywords you are gently forced to keep your views 'dumb' (i.e. without any logic) which means you move the processing of the logic to a more suited location. - It can in some cases make it easier for people not used to php to still be able to create workable templates using the usually simpler tempate engine language (dsl).
The standard is common. It's common across every repo I have, a number of projects which my employer has, was employed by the original flourish library and is used by a significant number of PHP developers still.
To answer your question directly, no. It isn't the form that writes to the file system that is vulnerable to XSS. It is other parts of your site that allow a malicious users to assume admin privileges via XSS, thereby being able to use any admin features for malicious purposes.
As you're free to do. Needless to say, I obviously disagree -- unlike you, I've provided sound and well explained reasons for my disagreement. Now the prediction I made years ago with respect to PSR-1 and PSR-2 acting as a buttress for people to ignore or belittle otherwise well written, reliable, and open source code is coming true. Congratulations, you've succeeded in reducing the number of libraries, frameworks, etc, that you deem worthy of attention by a significant degree for something that amounts to little more the aesthetics.
NCSA Mosaic browser, "Internet in a box"...
Holy shit dude, you shouldn't be anywhere near production code if you haven't touched PHP in 8 years. Why in the hell would they hire you as a PHP dev with pretty much 0 experience?!
So if I log in as admin and run some xss js loaded from a comment submission, the next step for the hack would be to submit a password reset form (in that one scenario)? This would require them to know the url of the reset form and get past any bot detectors, correct? Just trying to get a better understanding of how this works in a quick read (though I guess I need to do some longer reads now). Thanks very much for your explanation. 
Well, my opinion is that virtualbox is slower than vmware, which is what I use, on windows &amp; vmware fusion on osx. vagrant has a plugin which you can purchase and it's pretty good.
The next 20!
There can be many attack vectors. The point is that you don't want to let users run JavaScript from a browser with a valid PHP session that has admin privileges. They can do all sorts of things, for example just imagine all they did was pop up a dialog that asks you to re-login. Probably 50% of people would fill out their username and password in this situation. 
But that's what OP actually asked for, he said Command-**Bus**. Insofar as "Commands" exist in a command-bus, they [are not the same as the GoF version](http://www.reddit.com/r/programming/comments/377drs/cqrs_command_gof_command/crktt40).
Probably learning a dedicated template engine is not required then. The only rule to remember is this. Create (well, paste) this function for yourself: function esc($str) { return htmlentities($str, ENT_QUOTES, 'UTF-8'); } Now any time you want to echo a string in your page, wrap it in esc(), &lt;?= esc($foo['bar']['baz']) ?&gt; to ensure it's encoded as a plain text literal for HTML, so you don't collide with HTML's special characters. Prefer to specify any HTML tags inline (i.e. outside a PHP block) instead of assembling it and echoing it in variables. i.e. instead of: &lt;?= '&lt;b&gt;Hi there&lt;b&gt;' ?&gt; prefer: &lt;b&gt;&lt;?= esc('Hi there') ?&gt;&lt;/b&gt;
People got sick of platform-dependent coding.
Step 1: install Windows for Workgroups 3.11 on the box
Show me projects that you do not work on that use it. And show me the stats of how many people use that standard, vs say.... PSR-2. 
Hi, thank you so much for your help. While the error is gone, i can't still insert any data into generate_programs, but I have no problem inserting data into generate_campaigns.
Have you deleted your original question or can I just not see it any more? I'm on alien blue.
You might want to consider using Twig as your templating engine. I believe Slim is designed with the expectation that you'll use a more full-featured templating engine, rather than their basic View class. In fact, the guys who created Slim also created [Slim-Views](https://github.com/slimphp/Slim-Views), which make it easy to integrate either of the major PHP templating engines.
There are some options. I would use phpdoc to create a reference for your entire site (would track functions/classes/methods/whatever and not just variables) Also what kind of naming conventions do you use for your variables?
Python was released in 1991, although Guido started writing it in 1989.
Several, ranging from those real estate freebies to full newspapers. Among them (and an early one) was the *St. Thomas Source*, which was the first online newspaper to be recognized by a judge as a newspaper of record in the United States (the first online location where you could satisfy the legal requirements that you published a public notice). That was on PHP, so it can claim that as well.
JSON can be [all kinds of values](http://tools.ietf.org/html/rfc7158#section-2) other than arrays or objects. Edit: Also, I would get rid of all the array/object call time checks and use polymorphism instead.
Disable JS and reload the page in your browser. Sorry I didnt see this till now.
Yeah, I tried to support most of them. Here's some of my unit tests: See the testPassingXXXXToContructor() https://github.com/yadakhov/json/blob/master/tests/JsonTest.php
ah of course :) sooo to secure a php session, is that some kind of ssl / token requirement?
I'm working on this one and if you don't need it to production tomorrow, look that. https://github.com/onlab/BalnoWorkflow ezWorkflow as mentioned is a good workflow too but has some downsides.
Definitely stay on top of updates, and be very selective of what plugins you use. Most wordpress exploits for example have come from plugins. Security 
Should've been smothered at birth.
http://www.techempower.com/benchmarks/#section=data-r10&amp;hw=peak&amp;test=json&amp;l=sg&amp;p=w-0 
We use [Phinx](https://phinx.org/) for migrations on our non-framework project - it's a great tool. You'd need to do a bit of conversion on your raw SQL files to turn them into Phinx migrations, but that would really just be a bit of copy &amp; pasting. Alternatively, as migration files are just PHP, you could make your first migration read your legacy SQL files one-by-one and run them against the database. From there on you'd just create normal Phinx migrations.
1. Just start adding Unit Tests as you change any piece of code. It's not that much work, but it will safe you a lot of headache as the project grows 2. I would instead opt to add some info in the README. Composer should be something everyone uses. 3. The problem with a committed config file is that whenever you release a new version it will overwrite any changes I made to the config file. 4. While an ORM layer can be useful, it was not what I was referring to. Doctrine has a standalone DBAL abstraction ontop of which the ORM layer is build on, that basically does exactly what you're trying to do now. http://www.doctrine-project.org/projects/dbal.html 5. Just add Monolog, default to file based logging, add a line about database logging if writing to the file system is a problem (although, how do you even deploy your code then?) You have a good starting point, but there are many third-party components that you might benefit from. As mentioned: [doctrine-dbal](http://www.doctrine-project.org/projects/dbal.html), [monolog](https://github.com/Seldaek/monolog), [translation](http://symfony.com/doc/current/components/translation/introduction.html), [mailer](https://packagist.org/packages/swiftmailer/swiftmailer) Remember: every component you pull in means _less_ maintenance for you, which in turn means more time for you to focus on your actual project
After implementing this, how did feel about having to call $next($req, $res) ? I still find it uneasy and troublesome. For example, how would you manage priorities?
This feels so wrong on so many levels.
Can you give me a scenario this will be a better solution than what's currently available?
Trumpet Winsock?
Even without this, examples there are so wrong.. // UserController public function showFinances() { return view('user.finances') -&gt;with('analytics', App::make('App\Services\Analytics')); } // user/finances.blade.php // Template content... @include('user.partials.finances-graph', ['analytics' =&gt; $analytics]) // Template content... // user/partials/finances-graph.blade.php &lt;h3&gt;Finances&lt;/h3&gt; &lt;div class="finances-display"&gt; {{ $analytics-&gt;getBalance() }} / {{ $analytics-&gt;getBudget() }} &lt;/div&gt;
Honestly, I don't know what's currently available, I don't really use Laravel. I was just pushing back on the doom and gloom a little. I'm more used to the Symfony ecosystem and if I were trying to do what the author is doing in the example, I'd probably use ESI. I'm happy doing that, as I know that system fairly well, but I feel it's quite a heavy solution for something so simple. 
I'd stick with `int $foo` as it seems more in line with how you would define a variable's type in another language - or even PHP7.
The word "best" is forbidden. Don't use it.
Jeffrey's way is similar, but I think he explains it better. https://laracasts.com/series/whats-new-in-laravel-5-1/episodes/2 I think this is a paid for video, so sorry to the people who can't view it. Hopefully he'll turn the free switch on soon. :)
&gt; Calling this injection is just plain wrong. "As you can see, the first parameter is the variable name, and the second parameter is the class or interface name or alias." That appears to be the same as when a function has a parameter that has a name and a type, and the appropriate dependency gets injected from the outside. You're comparing it to Service Location - which definitely isn't dependency injection, but the first code example given in the article does appear to be DI.
http://leanpub.com has some nice digital books on there and because they're digital, they get updated. :)
Why? If you think of the template as just DSL then it's just like a function asking for a parameter of a certain type. I'll agree the actual code example isn't terribly nice, but the concept of a template declaring what dependencies it needs to have injected, seems, to me, to be a sound one. *Edit* Why? Because it's been implemented as a service locator. Which can mean that the template fails in the middle of rendering rather than having the dependencies injected up front. Which means that you have to inspect every line of code in a template to test it thoroughly (to make sure you haven't missed any special cases where a dependency is only rarely needed) rather than having the dependencies enforced before the template rendering starts.
Hey now I can pitch Laravel to my boss!
&gt; PHP 5.5.9+ That's bold, but I feel it's the right decision for an LTS supported for 3 years.
&gt; how did feel about having to call $next($req, $res) ? Overall, it felt like a tradeoff. The previous alternative was a loop like Silex does, and having to used a shared request and response, and returning a flag to indicate "early exit." There's another alternative, mentioned by idiot-with-opinion, that keeps the loop but returns a triple of [$request, $response, $next] instead of just returning $response, and the loop calls $next (this looks interesting but I have not played with it). &gt; how would you manage priorities? I'm guessing that you mean "priorities in middleware" as in "which goes first, next, last" etc. If so: the $queue is just an array, you can order it any way you like. Alternatively, you can write a queue-manager object that lets you prioritize, and get an array copy from that object with the final properly-ordered $queue array.
Here is a post covering some of the new features and an interview with Taylor - https://laravel-news.com/2015/06/laravel-5-1-released/
&gt; In previous versions of Laravel, encryption was handled by the `mcrypt` PHP extension. However, beginning in Laravel 5.1, encryption is handled by the `openssl` extension, which is more actively maintained. I don't know if this decision was at all influenced by my advice for developers to [stop using mcrypt](https://paragonie.com/blog/2015/05/if-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong), but the fact that they made this decision (independently?) makes me happy.
This looks horrible. Surely coupling the view to the model is a very, very bad idea? I understand that this could simplify code in some respects, but it can also cause some serious complication in other aspects. Another place where services could be introduced will make things more difficult to debug. How does this affect testing? Can you unit test views like you can controllers? I'm really struggling to see anything good about this being an option, at the very least, over the alternatives that seem to be available. (Note: not a Laravel user)
 &gt; The retrieval of the service is controlled by the view that it is in. No it's not, the difference is subtle but the controller sets up the DI, but it does not perform the DI. &gt; It looks to me like it's service location To me, it looks like DI done across multi-level code, aka known as architecture. $controllerCallable = $injector-&gt;execute($dispatcher); if ($controllerCallable == null) { // do a 404 error. } list($viewCallable, $newDIConfig) = $injector-&gt;execute($controllerCallable); $injector-&gt;addConfig($newDIConfig); $injector-&gt;execute($viewCallable); So the controller callable returns two pieces of information - what viewCallable should be executed, and some more information about what stuff is available to be DI'd. Trying to cram everything inside a single layer is what most PHP applications do, but you just fundamentally cannot do DI across multiple tiers, as it is impossible for all of the dependencies to be resolvable at the start of the application. 
&gt; Can you unit test views like you can controllers? Sure why not? And listing the dependencies explicitly in the view makes it easy to test, as for the view in the example given, you know exactly what class needs to be mocked to satisfy the views dependencies. Which is much better than just having an array of 'stuff' that most views need. 
We will be starting to use Laravel at my workplace. It's going to be great.
How would you go about unit testing a view? Are there unit testing frameworks available for blade? Keep in mind here, I'm not talking about functional / acceptance tests here.
Thanks. I'll incorporate it in. https://github.com/yadakhov/json/issues/2
Check list: * `[ ]` Fat models (we'll deal with that in another release) * `[x]` Skinny controllers - sorted! (we moved everything to the view)
Fair warning here, I've never actually used Laravel. &gt; No it's not, the difference is subtle but the controller sets up the DI, but it does not perform the DI. Where does the controller set up the DI? From the examples in that blog post, with this new method, the controller knows nothing about the dependencies that the view has? &gt; To me, it looks like DI done across multi-level code, aka known as architecture. Unfortunately, what happens in your code example is not what happens. I've just taken a look through the Laravel source code. In the compiler for Blade templates, there's a method that converts the inject statements into regular PHP. This makes the call in the template go from: ``` @inject("foo", "bar") ``` To the following PHP: ``` &lt;?php $foo = app("bar"); ?&gt; ``` What `app()` then does is directly lookup the service in the container. There is no injection going on there. The view is going into the container, and picking out the service it wants. That to me seems like the definition of service location, and is at the very least definitely _not_ dependency injection. In other words, as I originally feared, the retrieval of the service is controlled by the view that it is in. For reference: https://github.com/laravel/framework/blob/5.1/src/Illuminate/View/Compilers/BladeCompiler.php#L369 https://github.com/laravel/framework/blob/5.1/src/Illuminate/Foundation/helpers.php#L53
I just check my Ubuntu 14.04 LTS server and it's $ php -v PHP 5.5.9-1ubuntu4.9 (cli) (built: Apr 17 2015 11:44:57) 
Congratulations. My company will be riding 5.1 LTS for the next 3 years. 
Is there any more info on the websocket-based events yet? I'm curious to know what the underlying tech is and what it looks like from the Javascript side. 
Docs: http://laravel.com/docs/5.1/events#broadcasting-events Laracast video: https://laracasts.com/lessons/broadcasting-events-in-laravel-5-1
Another option is to have a payload object where you can get/set the response and request objects if you have changed them
Thought about that too, and that might help with the return signature for the trampoline approach. But even with the payload object you have the problem of indicating an early-exit. And really, does the previous middleware actually need the modified request? etc etc.
don't
&gt; Artisan commands may now be defined using a simple, route-like "signature" &gt; protected $signature = 'email:send {user} {--force}'; I don't know if it was inspired by [Silly](http://mnapoli.fr/silly/) or not (if yes then I'm happy :)) but too bad it's not the same syntax, e.g. `email:send [user] [--force]` (the choice of `[]` was to be consistent with the help syntax of the Symfony console).
*Why?* Can someone give a good example of why this is so bad instead of spouting FUD?
&gt; How would you go about unit testing a view? For my templating library I have an equivalent syntax, but it actually does DI and so is unit testable, apparently unlike the way the Blade injection has been implemented. e.g. I have a template SomePage.tpl: &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; {inject name='bottomAd' value='Adverts\BottomBanner'} {$bottomAd-&gt;render() | nofilter} &lt;/div&gt; &lt;/div&gt; and that gets converted into the PHP code. class SomePageTemplate { private $bottomAd; function __construct(Adverts\BottomBanner $bottomAd) { $this-&gt;bottomAd = $bottomAd; } function render() { echo '&lt;div class="row"&gt; &lt;div class="col-md-12"&gt;'; echo $bottomAd-&gt;render(); echo ' &lt;/div&gt; &lt;/div&gt;'; } } The Adverts\BottomBanner parameter can be mocked just like any other class and so the template class can either be tested by calling it directly or going through the template renderer. &gt;Are there unit testing frameworks available for blade? No idea. 
https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md
In a nutshell, it burdens the template with inappropriate responsibilities, making it less replaceable, more "aware" of app context (which it shouldn't be) and instrumental to the app logic. Clean architecture is about limiting the scope of every component so you can - think about it easier, - change it easier, - replace it easier, - test it easier. And component scope is defined by: - what is this component responsible for doing, - who does this component know about (and its interface details) and how far removed are they from you conceptually, - who knows about this component and how far removed are they from you conceptually The way the IoC is implemented in Laravel, there's one IoC per app (it's global to the app, which is bad in itself), you need knowledge of which interfaces are available and configured in IoC in order to request them, and this means the template has some knowledge of global app state (the IoC) and the IoC needs to be aware and maintain a configuration compatible with what that template needs (bi-directional coupling across separate layers). Further, by depending on IoC services, your template now needs knowledge of how to interrogate that service, whose interface is typically not focused on communicating with templates, so now even if the needed result of the interrogation is stable, if the service changes due to unrelated concern, all your templates using it are broken. In a properly architected template, the result is delivered from the controller, or via a dedicated read model, which is stable and contains all the template needs and nothing BUT what the template needs. If the service interface changes, you only update the one read model mapping, and not N templates. Mix responsibilities and introduce global knowledge into specific components a few times across your app and you have yourself a big ball of mud. Does it sound great when you tweak your IoC to remove a seemingly unneeded component and suddenly 3 *templates* in your app break? Do you unit test your templates in order to detect such breakage, BTW? Well, precisely.
Great list! Just a couple of notes. For your standards, I *highly* recommend just going with PSR-2/4. You can spend extra time trying to get your standards written up in PHPCS to check it, or you can use the prebuilt PHPCS standard, and just select the PSR-2 formatter in PHPStorm or use php-cs-fixer to fix issues. It's just so much easier when people write the tools for you. If you're using github or bitbucket or something similar it's easy enough to do reviews there, but I found a solid new process dedicated to it helped people make the transition. [Phabricator](http://phabricator.org/) was fantastic for us. It comes with a command line utility that can run things like unit tests and linters before code gets submitted for reviews, and will report all of the test reports and standard violations if they're not fixed.
It's a part of PSR-2, that's most likely the only reason. And.. what's wrong with spaces? 
&gt; I actually highly recommend not having a prefix/suffix for interfaces in PHP. Just call it "Whatever". So much this, except I do not believe it is a subjective opinion. Writing code that is dependent on interfaces is objectively better than writing code that is dependent on a class/implementation. Affixing some special marker to interface types makes it harder to read that code. When a function requires 2 or more parameters, having something like 'Interface' appended makes it far more like for the function signature to spill over to the next line. Having anything prepended always makes the type harder to read. 
I was surprised `mcrypt` was still part of Laravel 5.0 This is good news. *Edit: Formatting.*
why do you need to pass the whole stats "service" instead of just the "count"?
*But the component has to be resolved anyway in order to pass its data to the view.* It doesn't matter where it's referenced: it could be from within the controller, a view composer or the view itself. If it's removed from the IoC then the application will *still break*. Why is there such a hang up on potential breakage being caused by the view rather than some other part of the system? I get what you're saying about templates being fed only what they are needed (personally I'm not a fan of giving them objects that aren't DTOs) but really, why does it matter? I'm not going to make some sweeping criticism of the framework for the risk of allowing otherwise. What next, should &lt;?php ... ?&gt; tags be disabled in Blade to prevent someone from using them incorrectly?
MBA = Masters, Business Administration An MBA is not part of general programming knowledge. However, if you own a small boutique web development outfit, it could be useful. 
This site needs automated spellcheck &amp; grammar audit. Badly. The marketing copy is vague and lacking in details, which I found frustrating. As a developer I don't want to be told repeatedly "our product is great". I want to know why it's great. The details matter. The only thing I cared about from all of it was this image: http://www.exakat.io/wp-content/uploads/2015/05/Exakat_More100Rules.jpg And it's so small in the site, I had to fish out the URL and open it in a new tab so I can read what the rules say. **tl;dr** It's a static analysis tool sort of like PHP_CodeSniffer.
Similar to [ralfTn](/user/ralfTn), but more constructively: give it a go first. Make sure it's what you want to use. A lot of people love it, a lot of people (myself included) hate it. Personally I think they do Facades and IoC incorrectly. The fact you have to [install hacks to make it work with IDE's](https://github.com/barryvdh/laravel-ide-helper) is a bad sign. However, I am using Laravel 4 and perhaps things have changed since then.
No, it's not lack of experience talking, don't patronise me please. I know *exactly* how ludicrous this argument is. If you want to play a game of high-horse then let me remind you that the idea behind view service injection was lifted from ASP.NET MVC 6. Guess those guys don't understand monolith software architecture either.
I am glad I followed till the end.
you forgot its biggest feature: collecting email addresses for marketing purposes
The links doesn't work anymore since you followed /u/idiot-with-opinion's feedback and renamed to Relay.
Nice, thanks for pointing out Symfony's translation module. I like that it supports pluralization, which my translation module does not. Monolog looks promising, too. You make a good point about the config file, and this is something I actually have to manually change on my dev environment before I commit (which is really annoying). I'll check out phpdotenv, then I can just `.gitignore` the .env file. Maybe I can write some unit tests as I write the documentation. It seems like PHPUnit is the standard for writing test classes?
Thanks! Yeah I was checking out Eloquent earlier. I actually really like the way it does lazy loading of objects in collections.
The view must be spectacular from up there.
This is exactly what I felt laravel was lacking. Awesome stuff. Now I wonder how hard it is to upgrade from 4.2.. Edit: And documentation improvements also? Wow. Well I think that's convinced me not to jump ship.
Oh, thanks for clarifying that, misspelled the term. I mean degree in computer sciences.
I am just learning PHP from the beginning. For now, I just re-code from scratch everything I do for the practice. I've looked at the Laravel site to figure out what it does, but can't figure it out. ELI5: What does Laravel do?
The facades misunderstanding just won't die no matter how many times it's explained. What Laravel calls "facades" is not supposed to be the same thing as the facade development pattern. He just happened to use the same word, but it's not intended to be same thing. I don't think I've heard an argument that it does IoC "incorrectly". What do you mean by that?
I know some here do not always appreciate your opinions, but I generally do, even when I disagree with them. On this one, I had to agree.
Heh.
One graph in particular gives a good summary of performance on PHP 5, PHP 7 and HHVM with the results after performance lockdown: http://hhvm.com/wp-content/uploads/2015/06/engines-fixed.png As part of the lockdown there were patches to some of the software they tested; it is a bit unclear if PHP 5 includes those patches but PHP 7 and HHVM are using them.
Watch all these videos and you will be a 5 year old that know what Laravel does. https://laracasts.com/series/laravel-5-fundamentals
The patches were applied for all engines in that graph. Sorry if that was confusing!
Yep - exact configuration is here: https://gist.github.com/fredemmott/42209dc4907e54b846e8#file-batch-run- config-json If you have the same builds of HHVM and PHP, that can be piped into https://github.com/hhvm/oss-performance/blob/master/batch-run.php to reproduce our results. We chose this configuration to make the engine comparisons independent of the lockdown results.
To add to the encapsulated logic portion of this, you also want to abstract things into method calls. I don't think I can even think of something that I've ever had to build where I would need to reference 300 different variables at any given time, because my code is broken down into smaller and smaller functions that take care of all the grunt work.
I use Vim, I wouldn't recommend that unless you're already intimately familiar with the toolset. I've heard great things about PHPStorm, my coworkers use it, it has all the features you need in a PHP IDE from what I've seen. If you are familiar with vim my setup is https://github.com/shawncplus/dotfiles tl;dr Vim with [phpcomplete.vim](https://github.com/shawncplus/phpcomplete.vim), VDebug, and fugitive coupled with tmux/tmuxinator. Looks like this http://i.imgur.com/L9Z6LhG.png
Why can't you stick with JS forever? With NodeJS and something like Express (as an example), you can do Javascript on the server-side as well. I'd highly recommend looking into deployment tools like Ansible, though, and version control like git if you're not already using it. Editing directly on the server, especially a production server, is usually a no-no for professional software development. Anyway, to answer your original question, I've used both Vim and PHPStorm for debugging PHP applications using the xdebug PHP extension. You can also look into [Codebug](http://codebugapp.com/) for a dedicated debugging environment.
I'm assuming Taylor didn't know about the Facade programming design pattern, but knew what the word facade meant. At that point he said "hey this class is a facade"
Now it's time to try and sort out a plan with my boss to upgrade to 5.1. Can't imagine we'll be able to for several months unfortunately. Still rocking 4.2.
Which framework do you prefer? I looked at Laravel initially, but instead went with Symfony and Silex for my last couple of projects. 
To add to this; this is how you could see an elephant in the letters "PHP": http://i.imgur.com/s5xWV1W.png (Courtesy of [Brands of the world](http://www.brandsoftheworld.com/logo/php-elephant-0))
I am not quite sure of your background, but IDE fixes/tweaks/tooling are not an uncommon practice. Some Java packages can require fooling IDEA quite often. Gradle and IDEA don't even agree regarding a project's folder structure, and for complex build sequences, that can result in a good bit of modification.
&gt; Holy shit It's not like I have 0 development experience, I can write PHP code, I just haven't worked with PHP in a long time, but I have worked with other programming languages for a very long time.
They write code in Sublime Text and use Windows for their desktops. Their servers are Linux.
https://laracasts.com/series/how-to-be-awesome-in-phpstorm
&gt; possible They use Sublime Text to write code on Windows and they use WAMP on their Windows desktops. They push the code via FTP from Sublime to their Linux servers. They use Linux for servers and Windows for desktops. 
Notepad++, but currently I'm using a trial version of PHPStorm. Seems good so far.
You have to type 4-6 times space instead of 1 time tab. It is also hard when navigating in space.
Come on now folks we've all heard the downvote-isnt-dislike thing a million times It's a valid wonder, is there a doc anywhere that goes into the why of the standards - why use tabs over spaces, why 4 of them, why have open curly brace on its own line It's probably second nature to most and "because that's just how it's done" for many but it's easier to play by the rules if there's a clear reasoning behind them Edit: Found another thread [over here](https://np.reddit.com/r/PHP/comments/2loyem/psr2_why_mixed_brace_positions/) that goes in to it a bit, looks like it's a combo of because there was a sort of vote and the majority won and that's how it's done in older languages Basically if it's your own project (you call the shots, your company, etc) do it however you want. If you're a part of a team of significant size just do it how PSR-2 says to do it to avoid arguing over the nothing part of a project 
&gt;N.b.: Using only spaces, and not mixing spaces with tabs, helps to avoid problems with diffs, patches, history, and annotations. The use of spaces also makes it easy to insert fine-grained sub-indentation for inter-line alignment. Oh, so this is why. I have never had such problems using diff tools such as Notepad++, WinMerge, Git, Bitbucket, AraxisMerge, Github. On the other hand this will rise problems such as on the programmer's side.
Tried several different ones. I like NetBeans the most.
PHPStorm is the best one
What about IoC does it do incorrectly? Also, what your IDE can and can't autocomplete ***should in absolutely no way influence your framework architecture***. No sane framework is designed around the static analysis capabilities of Netbeans, Eclipse or PHPStorm... "Oops, better not do it that way, else Eclipse won't understand what I'm doing!" Yeah no.
PhpStorm is by far the best I've used between Netbeans, PhpStorm, Dreamweaver, Notepad++, TextMate, and Sublime. Take a look at how many people here recommend it. Every time someone asks on here the response consistently leans towards PhpStorm. There are a number of things that make it the best. It's just a really innovative IDE and I'm able to work significantly faster than any IDE I've ever used. Hope you try it out!
If you've got the patience, try going to Help &gt; Productivity guide, and do everything at least once. I'm grateful I did.
I think they're both slow. I recently got an SSD for my home computer (laptop at work with normal HDD). Java _or_ Komodo in my opinion are 1000% more _pleasureable_ to work with when running an SSD.
I go back and forth between Netbeans and Brackets. I like both, but Brackets is much faster on my laptop. :)
+1 for sticking to JS. I work with the PHP / js stack and increasingly, I'm becoming fond of the idea of "isomorphic apps," where the client and server share parts of the code. I often find myself reimplementing the same logic in JavaScript and PHP. Sticking to one language would be valuable. In any case, one should weigh the options. PHP has a pretty strong and well established ecosystem that can't be dismissed. EDIT: isomorphic not isometric 
I have installed it right now. It shows changes in the editor! It is very nice! Note that I installed Komde Editor, not the IDE version.
I feel there might be paid brigades intentionally pushing this rinky dink (Java! - no less) - based IDE. Honestly - try using it vs proper c++ or c ide - you'll see the difference.
I would take a look at SitePoint http://www.sitepoint.com It has a great section on PHP and covers other languages. I subscribe to their newsletter and I am always picking up on things programming related that I haven't seen elsewhere. As a resource for exposing yourself to many different facets of different programming languages, I think it's excellent. Especially if you are focused primarily on web based programming like Laravel. Also Learnable (part of SitePoint) https://learnable.com which is a library of courses and books that you can download, has proved very useful.
How about we get a mini-thread going about what should standalone projects namespace themselves like. It should be Vendor\Project\Thing, but if it'll be just one project by definition, maybe it's ok to be just Project\Thing... That's what I think but I'm not big on following formal standards 100% strictly, anyway. *"Break any of these rules sooner than say anything outright barbarous."* ~George Orwell
&gt; The fact is, IDEs make coding easier and faster So does a developer-friendly API, which Laravel provides.
Really awesome. Looking forward to running my own benchmarks and comparing 3.8 vs 3.5. :)
The alternative I propose is an array of strings: ['foo', 'bar', 'baz'] This doesn't need to be parsed. And dot notation is a useful convenience syntax for typical cases (i.e without dot in the key), which is easily converted to the array above: if (is_string($path)) $path = explode('.', $path); But the JSON Pointer, which has reasons to be the way it is (should be a string, should handle any characters in a key, should be usable in URLs etc.) is more complicated than dot syntax, and has to be parsed char by char to follow escaping rules and what not. **tl;dr** JSON pointer has different goals, it's not designed to be a quick convenience syntax, so it's a poor match as one.
How would you recommend thread sharing it? Caching the auto loader objects? Just curious for future testing. 
... which C++ or C-powered PHP IDE do you recommend?
&gt; Thank you for taking the time to write to us, but this is not a bug. Please double-check the documentation available at http://www.php.net/manual/ and the instructions on how to report a bug at http://bugs.php.net/how-to-report.php &gt; "output call" does not refer to echo/print but to a call to the SAPI's module ub_write function. You can use this instead: ob_start('ob_logstdout', 2); via: http://php.net/ob_implicit_flush
I think you mean isomporphic
Thanks for mentionning phpcomplete.vim ! I've been using vim for a while now , and never really looked to improve php autocomplete. Will try it at work tomorrow :) (Just saw your username, I started using vim after watching your videos on youtube! Thanks too for that hah!)
Normal is boring. Seriously though, all of those are valid solutions to the problem. What's wrong with sharing other solutions? My favorite aspect (heh) of programming is that you can be creative by solving problems in new and interesting ways.
Refactoring with this IDE kicks ass. Added proper namespaces to our code base in one night, with all tests still passing.
PHPStorm is a phenomenal tool, but incredibly slow. I feel like Java performance hasn't improved at all in years. Can't Oracle do for the JVM what Facebook did for the PHP interpreter? 
Laravel's API docs are certainly not that helpful, if at all. 
2nded. I've had to dig through code many times to discover undocumented features.
second that, using geany for years now. as addition to the list above: very easy to extend for new file formats/languages and nice support for customizing the ui (themes etc)
You can make your tab key use spaces for indentation in notepad++ http://stackoverflow.com/a/8197841/2066155
Either PHPUnit or PHPSpec are pretty good for unit tests, just go with the one that best suits your needs. You could also take a look at Behat which is unit testing, but you write it out as a story.
yeap going to be a pain to do ... but needs to be done!
Reading through the doc it feels like it. Problem for me is that 4.2 is not supported anymore... 
See the [Upgrade Guide](http://laravel.com/docs/5.1/upgrade).
I don't build entire websites on the backend so personally I like [Angular JS](https://angularjs.org/) for MVVM. I then built my own simple Api framework to feed it information. I usually build my own small factories for IoC, grouping together common elements. Facades so far haven't been necessary.
Facades in Laravel are adapters and i hate it. There is facades in laravel, which hides complexity of underlying components, but this isn't `FooBar::get()`. I don't think that something wrong with IoC in Laravel, this is just one of implementation and i like it, but i prefer to inject dependencies instead of global access to it with "facades", that's it. But what i hate is active record... I'm good with Laravel5 + Doctrine. In fact i'll prefer my own framework ontop of HttpFoundation + PSR7 + Doctrine + PHP-DI.
Something like [BowerPHP](http://bowerphp.org/) ?
4 to 5 is tedious.. took me about 2hours to do the work and the rest of the day to put out fires, and to trust that it wasn't completely broken. 5 to 5.1 was about 5 minutes work, and 4 minutes of that was waiting for composer to update.
This is a great list. I'd like to add a couple of things: * Make sure you have a build server such as [Jenkins](https://jenkins-ci.org/). I suggest Jenkins because it's pretty standard across all software disciplines. It is a beast however, and runs on Java, so if it's not right, there are alternatives, however there's a good guide on using Jenkins for PHP projects here: http://jenkins-php.org/ * If you want to move to continuous deployment, you absolutely must be sure a given snapshot of your code will work. The best way to do this is have your CI server create a build artefact of the code it just tested. This is a great way to prevent any accidental altering of code between it being tested and it being deployed. * Separate development responsibilities. Have a look at [Git Flow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow/). Even if you don't use git, if you have the ability to branch and merge, this is a great way of separating and managing each new feature.
Any good tutorial recommended for the upgrade from 4.2 to 5.0 or just google it or use the official docs? 3years is a long time thought a lot will change and become outdated by then... refreshes are not so bad but as you said it takes a lot of ressources to have a full upgrade
There's a reason why PHPStorm and Sublime don't have a save button and that's because it automatically saves your work. :)
MVC can be tricky, because there's a lot of steps that aren't straightforward just to get started. I highly recommend following a guide to build "your first website".
That's really good to know, thank you. My general approach to non-critical optimisation has always been "CPUs are cheaper than the developers it will take to fix this". However, if these tools can speed up discovery of these sorts of issues, it'll really help me turn that around.
It is an awesome list, but I would like to say as long as you are doing as many as the team can cope with things will always improve, which is good, and is a low-risk strategy. There is a company I used to CTO for where they had an off-shore Indian dev team, who would copy and paste chunks of code, edit the files of libraries meaning a rewrite, bug-fix etc would take days, weeks, months. After much todo I simply built a minature MVC, and told the Indian dev team all future work had to use the framework. All bug-fixed code must be updated! I wanted to see testing of modules built with evidence! Code immediately saw a more productive output (in terms of less testing), and was easier to fix. I would love to have got them to produce unit tests etc, or replace the team, because they were that bad; but the owner could not afford, or accept the risk, so they stayed, and gradual improvement happened. Soon we had new rules for them, don't modify libraries in any language, extend them, build wrappers and sub-classes etc. This is all n00b stuff, but they didn't have a scooby-doo of what the hell they were doing. The business owner had a more productive team, and the Indians got to improve their skills to meet newer standards. Just in-case anyone thinks I was picking on them, they had been programming for over 8 years with the guy when I came along. It's basically long-term larceny to be copying and pasting code for that long. One thing I did also see missing from the list was tooling. No matter how great git etc is, you need your own tooling to compliament. Don't re-invent Git, but maybe integrating issue reporting with Git is a good idea. Maybe building a report from that data is an awesome idea, and maybe, because stakeholders can be given access, it will be easier to evidence team improvement metrics the big-wigs will want to know about!
When I hear lighter I'm assuming it can do something faster and will less memory than other similar components. Are there any benchmarks?
&gt; It requires an extension or a library that implicitly analyzes and rewrites your code. Many application uses libraries, for example, doctrine annotations, symfony routing, etc. So it's ok for developers just to add library as a requirement. &gt; It's highly, highly implicit in its action, and if you start at the source of the affected class you'd never see an aspect applied. It may apply or may not apply. This one may apply or the other one may apply. Who knows what's really running? You can apply a rule literally anywhere in your codebase. I'm working on plugin for PhpStorm IDE (https://plugins.jetbrains.com/plugin/7785), so it will just show you all advices, applied to the concrete method with ability to navigate to advice/from advice. This should be displayed in the gutter similar to override/implement icons. Plugin will also highlight syntax for pointcut expressions (already done) and provide basic autocompletion of class names, annotations and pointcuts. Working with aspects in PhpStorm will be the same as working with interfaces and concrete classes. &gt; It's static. The AOP rules apply to classes statically and globally which encourages monolithic big balls of mud apps. It's rarely the case I want to apply an aspect to ALL INSTANCES EVER of class X. Wrong, with dynamic types of joinpoints you will be able to check if advice should be applied to the concrete instance with concrete parameters. However this is more expensive. For pro-gicks, it's evene possible to "unbox" the scope of original class for concrete instance and then just call the concrete method (internally framework uses this technique to call an original method body) &gt; So I'm still curious. Why would we go for this type of elaborate contraptions and not just use a simple decorator. Simple decorator can be applied for one concrete class, if you will have thousands of classes (thats typical for enterprise level big app), then you should prepare a lot of decorators that implements specific interfaces or extends concrete classes. Just read the first part of http://go.aopphp.com/blog/2014/10/19/caching-like-a-pro/ for more detailed answer, why traditional ways of solving such issues can be annoying for developers.
IF you think enough about what the variables need to convey to the website, you can probably shrink 300 down quite drastically with some utility classes, or at least section them off a bit. * As an example even on a 32-bit unsigned integer can be used to handle 32 boolean values, via bit toggling. * For distinct values (Rather than bit twiddling), just a single 8-bit character, can be used in constants, as a mnemonic, being able to represent uo to 255 distinct values. Also by representing these things within classes (hopefully namespaces), you automatically gain categorised heirarchy to what you want to access or modify.
&gt; Many application uses libraries, for example, doctrine annotations, symfony routing, etc. So it's ok for developers just to add library as a requirement. Yeaaah... no. It's not ok to just add more annotation dependencies because X did it. Your logic doesn't follow. I'd rather worry about conflicts with two annotation engines reading PHPDocs and rewriting code based on that. &gt; I'm working on plugin for PhpStorm IDE Ok, so more dependencies. Editor plugins so I can understand my codebase. I use Zend Studio, so I guess I don't get to understand my codebase. Oh, well. &gt; Wrong, with dynamic types of joinpoints you will be able to check if advice should be applied to the concrete instance with concrete parameters. However this is more expensive. So I'm "wrong" because, while I'm right, you can check at runtime **on every call** if you want to run the code? Ok... Sounds enticing... &gt; Simple decorator can be applied for one concrete class, if you will have thousands of classes (thats typical for enterprise level big app), then you should prepare a lot of decorators that implements specific interfaces or extends concrete classes. Having "thousands of classes" whose flow isn't homogenic enough for a decorator, proxy or a command bus, so I need AOP to slap the same aspects on *all of them*...? I'm actually incredibly curious to hear the real-world case for this. It doesn't sound "typical for enterprise level big app". It sounds like someone's mistake of a lifetime. &gt; Just read the first part of http://go.aopphp.com/blog/2014/10/19/caching-like-a-pro/ for more detailed answer, why traditional ways of solving such issues can be annoying for developers. Is this an example of "thousands of classes"? You need thousands of services with the same blind caching applied? Even Amazon, Netflix, or Google don't have such a situation. If you know what it takes to have a common caching layer in front of services, you wouldn't point to this article. Let's take HTTP, it has a "caching aspect" to it that you can put in front of every HTTP service, but it doesn't do it blindly, it requires server, intermediaries and clients to understand a common interface with regards to what a URI is, how is it defined, ETag, modified and expires headers etc. The article, in contrast, starts by getting the basic memoization pattern wrong (you need to take into account the arguments of the methods, as pointed out in the comments), and I could stop right here. But I'll keep going on... The aspect knows nothing about which arguments refer to a cacheable unit, and which don't, it doesn't know how to invalidate the cache, and basically this is an all around **toy example** that isn't usable in the real world, posing as a useful solution to a caching problem. I'm noticing this pattern a lot and have since concluded AOP's only real-world use cases include 1) AOP presentations and 2) AOP blog posts. Most of the reasoning in this article is constructed entirely artificially. You don't go out of your way to design code *against your intent*, so you can demonstrate AOP obliterates the language's design constraints. "See, you can't decorate because what if that class has no interface and is final and now *I typehint for that final class*". Doesn't sound like a healthy environment, does it: service provider John declares everything final with no interface to spite Bob, and Bob waving his middle-finger, screaming "Well, FU, John, I'll use AOP". You still don't need AOP, though: if the original class is final, I can still write an interface and have an adapter to the interface from the original object. From that point I treat the original class as an implementation detail and I no longer have to hint for its type. This is much better because my typehint doesn't lie about what it needs: it doesn't need final class Foo. It needs FooWithBenefits, so that's what it'll get. In any real-world situation a service would be behind some sort of interface, because you may run it locally in PHP or you may run it remotely (locally exposed via a remoting client). There are many aspects (not just caching) you can add to a service, so you can put the service on a command bus, which is explicit, clear, doesn't need PHP plugins and IDE plugins, and makes AOP unnecessary (I did list command bus at the beginning of this thread, check it out). And it even scales to "thousands of classes"! P.S.: Author uses terms like LSP whose meaning he obviously doesn't understand.
It supports a lot more of MySQL's features. I have no strong preference, but I see a lot of this unexplained bias in favor of PDO, so I thought I'd drop a reply. PDO tries to implement a common subset of all databases, which is useful only if... well... I've never found it useful so far. I suppose because I already have a DBAL in front (similar to Doctrine's DBAL). The ideal situation would be if PDO was an interface that the rest of the libraries would implement, and then each could still extend its interface with DB-specific features. Unfortunately, that's not how it was done, so it's more about thinking carefully and choosing the right compromise.
I agree that in general parlance 'facade' is an appropriate term for what it describes...but from a more holistic programming perspective it can cause issues because it is 'reusing' a term for something else within that same domain. I agree that in day-to-day development the actual term isn't in your code (much)... but the issue isn't the code...its the documentation of facades. It comes into play when someone is searching for something 'facade' related on the internet. With conflated terms this can cause some confusion and wasted time.
Laravel's API docs are generated by [Sami](https://github.com/FriendsOfPHP/Sami). Symfony's API docs are *also* generated by Sami, and are equally useless because of it. Also, Sami was created by Fabien Potencier, the same guy who created and maintains Symfony. So Laravel has precisely *fuck all* to do with why the API docs are shit. Blame Fabien Potencier and disaster that is Sami (which everyone uses for some reason) for that. If you're talking about Laravel's actual documentation, you should actually try clicking the link of this post. &gt; #Documentation Every page of the Laravel documentation has been meticulously reviewed and dramatically improved. All code examples have also been reviewed and expanded to provide more relevance and context. Laravel 5.1 comes with a complete overhaul to its documentation. It's more thorough, and now has search, so the documentation argument is a non-argument. And frankly, it never *was* an argument. Laravel's docs may be incomplete *for edge cases*, but it's API is so simple and user-friendly, and its docs are so skimmable and readable, that you can still learn most of Laravel *significantly faster* than you can learn most of other frameworks. I learned everything I needed to be fully competent with Laravel in one session - 8 hours of just reading the original 4.1 docs like a book. Did I have to dive into source code and the API docs and Stack Overflow to find specific information for edge cases? Yes. So what? I was already up and running using Laravel *the right way* and building apps after a day's worth of learning, and I had a very complete understanding of the framework. Not a "here's how you define a route and a controller and return a view and lazily slap some facades in there" understanding, but full on using all of Laravel's features - dependency injection via its IoC, migrations, artisan commands, complete understanding of Eloquent, configuration, service providers, collections, route filters, blade..... I went from knowing *nothing* about Laravel (or ORM relationships, or migrations, or IoC containers), to fully competent with it, in 8 hours. Why? Skimmable documentation, and a sane, intuitive framework API. And that was 4.1... 5.1 is an order of magnitude better in terms of documentation and framework design.
you can always generate JSON as an endpoint (controller action), and load it via XHR to get settings and live-data as well, which works well for certain rewrites
Best scenario: load startup data inline (like I have explained) and continue to get delta updates via XHR (as you have explained). ;)
As /u/Jonny_Axehandle said, it's possible...but I'm a bit worried as to *why* you would want to do something like this.
I normally work on up to a dozen different projects a day, sometimes swapping between every few mins or fixing multiple code bases at once.. Phpstorm was just too slow. So I use sublime text. Works great. With a few plugins you can make it fairly feature rich for normal development.
damn that was a good sell. now im 90% sure im going to go with Laravel rather than Symfony on my upcoming project. That last 10% is just the fact that Spotify has had good success with Symfony in an enterprise environment, though who knows how many setbacks they had. Why do people say Symfony scales better?
My general rule of thumb is to avoid using facades outside of controllers (since those are tightly-coupled to the framework anyway), and keep my controllers dumb, so they just collect input, call some domain service, and then return an HTTP response. EDIT: dumb, not dump.
Cool, shoot us a mail to support@tideways.io if you have questions setting up.
It's pretty flat between those versions: https://gist.github.com/fredemmott/dd91aa70a027f69e2ef7 3.8 looks promising ;) Edit: scroll to the bottom for the summary CSV instead of the raw JSON output
It's very interesting to see how "real guru" of programming teaches me how should I write my code. And it's even more interesting just to listen to them when they blame AOP/DIC/whatever, attaching "real bad practice"™ to something. What I do in this situation is just ask them to show their real code. And everything becomes clear. So, could you give us a gist/link to the github with *your real code" and transaction handling or caching to prove your words. I have a strong opinion about how to write clean and readable code. Why? Because I've developed a very nice infrastructure for our big company, based on microservices, SOA, event-driven paradigm and many other things that can be described as Distributed Domain Driven Development. I pay attention to the each piece of this big system (our nginx handles 100kreq/s) and know how to make it working. And yes, we don't use AOP yet, because there are some things to do before this decision will be made (IDE plugins). I appreciate the opinion of IT guys, who write their thoughts about cross-cutting issues and highlighting both positive and negative sides of each approach. They are open for testing, researching and listening. And I like when someone just write me: "oh, this library is so cool" or "oh, it's great, we tested it, but it isn't suited for us". This means that they have tried an AOP and can make a decision about future usage in a real project. They *have an experience* with AOP. But I don't like AOP haters that just write their "FU" messages into the topic without any testing. Please notice, that I don't force you to use an AOP/DIC in your project, why you should force someone not to use it? Of course, there are plenty ways of implementing caching layer, but your should not insist on your opinion, because it's a personal decision and someone can choose memcache, someone can choose reverse-proxies, someone can put a files in the cache and serve them as responses. So, there is a paradigm, there is a library that enables it, there will be a special helper tools for integration with IDE. That's it. Everybody can try it and use it, and if you don't like this paradigm, please just don't use it and stop blame it. Thank you. PS. You can try to determine what is stopping your from using an AOP and write an article with both negative and positive moments. 
I would prefer you to use the \PDO API rather than mysqli_
&gt; It's very interesting to see how "real guru" of programming teaches me how should I write my code. A "real guru", huh. As you can tell from my nick, I'm doing the opposite of arguing from a position of authority. I give opinion based on the merit of an argument, and you can reply on the merit of that argument. &gt; I've developed a very nice infrastructure for our big company, based on microservices, SOA, event-driven paradigm and many other things that can be described as Distributed Domain Driven Development. Clap, clap, ok. I really don't know why you're turning this into "who are you, who am I" conversation. Why I also use SOA, DDD, EDA and all them three-letter acronyms (which are completely orthogonal to AOP). This actually brings us closer, I'm starting to feel some connection here. You may be my brother from another mother. Do you have **nothing** to reply with to my specific points, though? With all that experience. &gt; Please notice, that I don't force you to use an AOP/DIC in your project, why you should force someone not to use it? Yeah, why should I? Dunno, I haven't tried it. I'm just posting a comment here, just like you. &gt; You can try to determine what is stopping your from using an AOP and write an article with both negative and positive moments. I just did it... in *this thread*! And you ignored **all** my points and went on a generic rant.
I guess I've been jaded by coming on to a prebuilt project. I'm also OK admitting I have a bias since I have my own (as-yet-unreleased) framework which I obviously prefer. ***Edit Add*** *...coming on to a prebuilt project* that was already filled with Facades, didn't follow FIG standards, had no unit tests and had messy source code with a lack of comments. 
No, there can be more than one video, which is the problem. Otherwise I could just give the var a static name and call it the day. It's used as a bbcode. Here is my entire function: &gt; $text = preg_replace('/\[youtube](.+?)\[\/youtube\]/', '&lt;script&gt;var vid_\1 = \'&lt;iframe width="680" height="420" src="https://www.youtube.com/embed/\1?autoplay=1" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;\';&lt;/script&gt;&lt;div style="background: url('."'".'http://img.youtube.com/vi/\1/hqdefault.jpg'."'".'); background-size: 350px 263px; width: 350px; height: 263px; cursor: pointer;" onclick="document.getElementById(\'vid_\1\').innerHTML = vid_\1; this.style.display = \'none\';"&gt;&lt;center&gt;&lt;img src="imgs/streams_play_hover.png" style="width: 80px; margin: 110px 0 110px 0px; border: none;" alt="play" /&gt;&lt;/center&gt;&lt;/div&gt;&lt;div id="vid_\1"&gt;&lt;/div&gt;', $text); I don't know how many videos someone would decide to share. 
@ezynda3 I like your way of checking all possible ways ) Thank you very much for writing this article and sharing your thoughts about this paradigm. Unfortunately, it isn't easy for me to write a good articles in English (it's not my native language) about AOP, so I'm glad to see each new article which describing possibilities and restrictions of this paradigm.
Thanks for the benchmarks, agreed on 3.8 :)
Or try: php -r 'var_dump(function_exists("utf8_encode"));'
I don't think that's possible anymore. Youtube changed their api and I don't see a slug data. [youtube api v3](https://developers.google.com/youtube/v3/getting-started)
Please consider linking adityagiri to a reason why to using the ~~PDA~~ PDO library over the mysqli class. Here are a couple of relevant links: * http://community.sitepoint.com/t/php-pdo-or-mysqli-which-is-better-more-versatile/108461 * https://www.reddit.com/r/learnphp/comments/2wfwqj/pdo_mysqli_and_security_im_trying_to_choose_a/ * http://tutorialslodge.com/mysqli-vs-pdo/ * http://php.net/manual/en/book.mysqli.php * http://php.net/manual/en/book.pdo.php
I'm launching a robust public/private api soon. After it launches, we won't be close to a million requests per month for a LONG time. Is there some way that your team can provide a no-cost starter package for say, 3 days retention, 250k reqs per month, for the startups of the world? 80% of starter plan companies would almost certainly upgrade to your paid plans immediately after exhausting the starter plan threshold (assuming the product is bulletproof, of course). I'll happily be a beta customer of the starter plan. Pm me ;)
You may also want to consider changing the namespace to something with a more unique, such as BrainBuzzer/blog. You may also considering using [Exceptions](http://php.net/manual/en/language.exceptions.php) and try and catch for more seamless error handling. For example: class someClass { private $_bar; function __construct($foo) { $this-&gt;_bar = $foo; } function someMethod() { if ( isset( $this-&gt;_bar ) ) { // Some procedure } else { throw new Exception("Variable _bar not set."); } } $c = new someClass(); try { $c-&gt;someMethod(); } catch (Exception $e) { echo "&lt;pre&gt;" . $e . "&lt;/pre&gt; } That should throw the Exception "Variable _bar not set."
I used New Relic at a previous job and loved it, I was thinking about trying to get it added and my current job, but Tideways might be a simpler solution as it's cheaper and has most of the key features I used. However, I was looking at the demo accounts and couldn't find some of the data I was looking for. Does Tideways have or is there a plan to add query profiling data beyond the time that shows up in the traces? New Relic has the ability to specifically look at the DB calls, and anonymize and aggregate queries, which made it really easy to spot things like table x should have an index on column y. Even just a tool that could work with the slow query log would be a huge help.
Sounds fair :) Yes, I was thinking more about various graphs (response times etc.) that have 1 minute resolution for the past 3 months. I didn't know traces on New Relic are gone after 7 days, I guess I never needed them after a week :)
This is definitely a case of scale making all the difference. I used it extensively for a stretch at a previous job where we had a code base with over 1.5 million lines of PHP alone, a DB with hundreds of tables, and sites with 100+ pages. We were bogged down trying to keep up with bringing on new clients, updating existing clients, and fixing bugs, but with the help of New Relic I was able to make massive improvements almost completely by myself, even in parts of the system I hadn't worked on at all and wouldn't have known to look at, while the other ~20 developers continued with normal work. Some of the clients saw total average page load times drop to less than half of what they started at, which we knew because New Relic was saving all of the data over the several month optimization effort. It was well worth the money. However, for smaller projects I wouldn't necessarily be able to justify the expense, and I'd never be able to justify it for personal projects.
That's exactly what is not being asked.
I've watched a couple videos that were linked to below. I still don't fully get it, but I'll keep watching. As a new PHP dabbler, it seems like every snippet of code I write has tentacles that go into other parts, and is completely unique. It's hard to imagine how it would be possible to just add pre-written bits to get where I want to go.
If anyone is wondering why there are so many variables had on a single page, it is because I work as part of a large team, each with their own design philosophies as they don't know pho as a first language and there's no communication between us. I work for a company that is not exactly technologically savvy.
[Seriously](http://lmgtfy.com/?q=symfony+doctrine+experts&amp;l=1)
The reaction I get when I tell people I'm a C++ dev is similar to what I feel the reaction would be like if I told my girlfriend's parents that I rode a fridgebike. Shh... Fridgebike.
Just to be clear, I was explaining, not recommending you use Laravel or anything else right away. If you are new to PHP, learn it to a point of being able to explain how you'd do something. Find some code challenges and practice. At some point, a Framework will just help you start something cool because when you've done a login process 12 000 times, you just want to skip to the cool part (aka something new and unique to the project). MVC is totally overkill when you don't understand the necessity (and the implication).
I prefer digitalocean. http://www.digitalocean.com
Ah, also works, I'm used to cpanel for php but ssh for node, so it seems wrong to mix them :D I know I can't buy them, but can I use multiple domains pointing at the same files with the cheapest plan?
You have SSH access to the server so you can configure it to do whatever you want - including hosting as many different sites as you like
I've never used the api, so by 'slug' I meant 'video_id'... I'll have a play later
Ah, so I get full root access? Sounds like my next move! Cheers.
Full Root and they just came out with Team Accounts like... yesterday!
&gt; At some point, a Framework will just help you start something cool because when you've done a login process 12 000 times, you just want to skip to the cool part (aka something new and unique to the project). &gt; MVC is totally overkill when you don't understand the necessity (and the implication). Good info!
Take a gander at http://phptherightway.com/ and see if there's any gaps you might've missed. If you're doing dev with a team on a "medium-sized" application make sure you know * version control (git/svn/rarely mercurial) and how to do branching in a team environment (things like http://nvie.com/posts/a-successful-git-branching-model/) * poke around various ticketing systems to understand how they work (Jira/redmine/github issues/etc.) * Take a look at some of the projects at http://thephpleague.com (see how the project is structured, how testing is setup, how documentation is done, etc)
Well, depending on what kind of job / company you are applying for, you definitely need to step out of the PHP box, especially as a "senior" developer. Senior positions usually require you to be familiar with common software engineering design concepts and principles. You need to be able to not just "code", but to have a long-term plan for the software and possibly create some sort of software development strategies and rules for the younger / less experienced developers that will be working with you. These are skills that should be applicable to any language you may face, not just PHP, and that is really important to grasp and really makes the difference between a "(Junior) Developer" and a "Senior Developer", at least from my point of view / experience. "Soft skills" might also be a buzz word to look into, which are also more important for senior developers than for lower positions, since you will be a person that other people will be referring to in their work. I have to be fair, though, and say that I am German and that we may put more emphasis on proper university education and hierarchy here than it might be the case in the United States or other countries, so naturally I am thinking that these concepts are really what sets apart "self-taught" developers from someone who has studied the subject "properly". Long story short: Don't just focus on PHP, focus on Software Engineering in general with your revisions. Edit: Out of curiosity regarding the definition of "senior", I googled around a bit and found this description to be very nice and fitting: http://programmers.stackexchange.com/a/173107 According to his definition, you would probably more fit into the area of a Junior Developer, and if I am totally honest, I am inclined to agree, though obviously I do not know your set of skills and what the company you are applying at is defining as a senior software developer. However, I think it is important to "keep it real" when evaluating oneself and not aim too high, just because you worked a few years with PHP, does definitely not mean you have acquired software engineering skills or understood advanced concepts, and to me, that is what sets apart these jobs within that naming scheme. And I am totally sorry if this will get you down a bit if you feel a bit helpless after this, I think you should just go in there, show what you got and if it does not work out, you will know what you have to work on. Formal education is definitely recommendable, though, if you intend on going higher up the developer chain, since you will need to learn some theoretical concepts in order to get up there, that's just the way it is in the business.
Do you plan supporting CakePHP?
A ton of my stuff is on 4.1.25 for compatibility with an ADLDAP package that is eol basically.
depends how many users you have as I said, "at some point" perhaps the name is fitting
Brace yourself for noob question but: In this graph is "Drupal 8 cached" slower than "D8 uncached"? Should it not be the other way around? I have used drupal 7 some and when the caching is turned on it is indeed significantly faster.
Thanks for the honest response! I probably didn't provide as much information in my post as I should have (mostly for the sake of brevity) I have taken Computing Science courses to supplement my own learning, just no degree, and have (I think) a solid understanding of data structures, algorithms, runtime complexity and all that jazz. I've also done a fair amount of development in C/++/# among a bunch of other languages, but the job requirements are mostly PHP/SQL based. My past work has been pretty much equal parts architecture and actual programming, since I've ended up being thrust into development lead roles. I think I'm lacking experience in software life-cycle planning/management on larger teams, but have experience in small teams. I think I'll definitely have to do a lot of work to get the job, but we'll see! Thanks again :)
You should really throw the exception from a setter method called in the constructor. Something like this: class someClass { private $foo; public function __construct($foo) { $this-&gt;setFoo($foo); } private function setFoo($foo) { if(!$foo) { throw new InvalidArgumentException('Foo cannot be empty'); } $this-&gt;foo = $foo; } } If the class is missing a dependency it shouldn't be allowed to be instantiated instead of being instantiated but sitting in an invalid state until it gets used.
That's a great resource! I've definitely seen it before, but I'm sure it's lost in my bookmarks bar somewhere haha. Version control on larger teams is something I should get a lot more comfortable with, since I'm mostly used to Git for my own projects where, frankly, I can let myself be a bit lazy with it! Luckily I'm pretty anal about using Github Issues for my own projects, so I've got experience there. The PHP League looks great, I always have trouble finding well-written code to study, so I'll definitely be spending a lot of time on there! Thanks for your reply!
* ORM has made me a bit lax in my actual SQL querying, I'll definitely have to brush up on that! * I probably should have mentioned in my original post, but definitely not! I do a lot of development for fun, so I'm pretty comfortable with quite a few languages! * Ooh, do I ever love Git! I should probably make sure I understand version control workflows for large teams though! * Strengths/weaknesses of different frameworks? Probably not as well as I should, I'll have to read up! * Build and CI is limited to what I've done on work projects, so nothing large scale unfortunately. * PHPStorm is my jam! (also package management is way cool) Thanks for the list! I've definitely spent the last 5 years trying to diversify my experience (probably at the cost of depth), so hopefully that'll help me present well in the interview!
Well, if you have your domain layer decoupled from framework, it isn't important what you use since this is only infrastructure. So yes, it is possible to do pretty things with Laravel.
&gt; Do you have a mental list of standard lib functions you should NEVER use, and the best replacement for them? I don't. Could you please tell me? 
PHPStorm is a joy to work with. Here's some info that may be useful: https://www.jetbrains.com/phpstorm/quickstart/debugger.html
Sounds better than it initially sounded for sure! Good luck with the interview and try to tackle the issues you mentioned.
mysqli is fine. PDO is fine. Anyone who says anything different doesn't understand the different use-cases. PDO does not support async connections, nor does it cover several mysql specific features. I'm really tired of hearing people push PDO over mysqli for *no apparent reason*. Please justify the advocation of one API over the other.
Good Luck! 
WHERE THE FUCK IS CODEIGNITER (╯°□°）╯︵ ┻━┻
For small business websites I really like bluehost.
MDB2 for the win! Unfortunately, it is abandoned, but I used it for years and years. http://pear.php.net/package/MDB2/redirected
We don't know; it's probably a combination of some of these: - different hardware - different configuration - insufficient warmup - different concurrency - different test load: database content or pages being requested We've documented or released scripts for the above, but don't have anything to compare them to. Our configuration is here: https://github.com/hhvm/oss-performance/blob/master/conf/php.ini - if we've missed something, we'll be happy to review pull requests :)
&gt; And your project has been ignored and condemned because of more than just your coding standards. My coding standards are excellent. &gt; I'm happy with php, xml, json, and yaml. Then continue using them.
If you're given coding questions, think it out before you start writing code. Do it outloud. Identify any assumptions you've made and bounce them off the interviewer. In many cases, whiteboarding is about seeing how you solve problems a lot more than about the code.
&gt; My coding standards are excellent. That really didnt have much to do with my comment. And that is really just your opinion lol.
Love this question. I feel like i'm somewhat as in the same situation as OP. Thank you all for your awesome answers as I am reading them and trying to learn from them :)
Thanks for the info!
I like [dreamhost](http://dreamhost.com), their support is solid. edit: formatting
Yeah, it's a pain. I also just `rm -rf vendor &amp;&amp; composer install` ad nauseam. Wrote a bit about it [here](https://leanpub.com/typedphp)...
I am definitely gunna make this one my checklist :D
If you can articulate yourself this well in person, you have nothing to worry about.
I made a Composer plugin (https://github.com/Letudiant/composer-shared-package-plugin) and for tests I just use the class `composer/composer/tests/Composer/TestCase.php` which provides useful methods. So you have to initialize the full Composer stack when you run a test, see https://github.com/Letudiant/composer-shared-package-plugin/blob/master/tests/unit/Test/Unit/LEtudiant/Composer/Installer/SharedPackageInstallerTest.php#L94 for `setUp` example.
I think NASA recommends to ALWAYS use `else` in their C-code. Because you always want to have a reaction when the unexpected happens. Of course, C doesn't have exceptions.
But... this still uses excessive nesting? You want to be able to add new validations without changing old code (just add more lines).
&gt;senior web developer followed by &gt;I've never done an interview with whiteboard questions before You're no senior developer. A senior developer would have encountered this already by now, and he wouldn't be here trying to figure out how to scam his way in to a job he's not qualified for.
Me neither but we have a bot that record Github activity. We will see. We are probably going to present the numbers at Hoa Apex 3rd edition (the community event) in September. You can follow @hoaproject on Twitter to stay tuned :-).
Sounds like you know what issues to work on
IoC means that dependencies are given from the outside of a class. $a = new A(new B()); // or $a-&gt;setB(new B()); // or $a-&gt;doSomething(new B()); as opposed to class A { public function __construct() { $this-&gt;b = new B(); } } Do you see how in the 2nd example you can't easily substitute `B` with something else? `A` is tightly coupled to `B`. That's not good. DI: There's a fridge with all ingredients to make a pizza. Normally you'd go and grab all these ingredients and make a pizza yourself. A DIC is like a fridge that you can tell "Give me a pizza". The fridge will know what ingredients it needs to add to a pizza in what order and so on. public function getPizza() { $pizza = new Pizza($this-&gt;getDough(), $this-&gt;getSalsa()); $pizza-&gt;addTopping($this-&gt;getMozzarella()); $pizza-&gt;addTopping($this-&gt;getAnanas()); return $pizza; } public function getDough() { return new Dough(); } // ... Later on you decide you wanna make the dough yourself as well. So you can teach the DIC/container how to make the dough with other ingredients. But when you make the pizza you'll still just define that you wanna get the dough.
Wait for it...
I don't think he is trying to scam as much as reach for something higher, you big grump ;-)
I'm confused if I should report your post as spam. A link to an anonymous copy of a version of PHP which isn't listed on the official PHP site... Kinda looks like a phishing attempt, not saying it is, but definitely walks and quacks like a duck.
I've started using dreamhost last month and I really like them, they are miles better than my previous service. 
Knowledge of PHP is not the issue here. As others have pointed out the issue is architectural: lack of encapsulation and modularity. Be proactive, arrange a meeting and decide how to split the work (according to responsibility and the logic of your app) into multiple independent classes, each of which has a manageable number of 'variables' that make sense to be put together in one place.
That's a fair enough reason for choosing mysqli over PDO. I haven't come across a situation where I have needed a certain mysql statement which has stopped me from moving forward, so I still prefer PDO, but I suppose it's all down to personal preference and having the right tool for the right job.
I'm not OP, but in general the most framework-neutral part of your project are the domain models/services, because they are not web-specific in the first place and hence don't have anything to benefit from a web-framework. Do you have a well differentiated framework-independent layer of services/models that describe your business logic and DB interaction (or whatever you use for persistence)? Note that "well differentiated" means your controllers are almost empty, no validation, no DB interaction in a controller.
Unfortunately the project I'm talking about doesn't have well differentiated controllers. There is lots of validation and calls to things that should be services and its just generally a mess. The models are very tightly coupled to CI and I'm aware that that's the first step towards moving away but we also have the problem of controllers being 2000 lines long and models being about the same size. This project was inherited from an offshore company and it is what I would consider to be quite sizeable at around 100 database tables. We are planning on upgrading to CI3 at some point so we have things like composer integration to help clean up some old library files, and I'm hoping at some point that we can start to write some far reaching automated tests to help with moving stuff out. The reality is this is a very time-rushed project and I doubt we will ever get time to get those things done (I work for a web agency). I've sort of given up at this point, really.
It might be a good idea to post on Reddit at least only when the official release is ready - just because the tgz is present on github doesn't really help many people.
Ok thanks, your hints put me in the right direction, so I've got it for the script called by Apache :) What if I want to debug script called in CLI ? Like I'm in my docker CLI and I execute a script. How can I tell PhpStorm just by enabling a breakpoint that he has to listen or the php cli has to send something to PhpStorm ? I saw that you could pass some extra parameters to the CLI but what if I want to do it automatically ?
Thanks for the tip. This is something I can use immediately to improve my code.
Validation belongs in a service.
Well yeah, but then I'd assume you wouldn't need to SSH tunnel into it.
It can be done, you need to slowly extract the controller logic into CI-neutral, web-neutral services - simple objects where every method is an action taking simple input (arrays + scalars, or if you will, command objects) and it returns simple output (arrays + scalars, or if you will, result objects) or a list of errors. The controllers are left marshaling data from HTTP request to services, and from services to templates. That's their role. This kind of refactoring can be done piece by piece, and over time, but the effort has to have a clear direction and everyone editing the codebase should know when they refactor what they should strive for. Of course, it's hard to be more specific without checking the codebase.
Remote Development?! It's a miracle
Don't you mean El Capitan obvious?
I started doing this in a long running CodeIgniter project. My strategy is basically replacing all the (Active Record) Models to repositories that have an Interface. Then have a CodeIgniterRepository implement that Interface. (basically dump your entire db_model in here). Now you can replace the DB layer dependancy by implementing the same interface: I used Doctrine and this works quite well. Next stap is wrapping all the rest (non - models) into services. Basically dumping entire content of Controller methods behind a service. Inject the necessary models(repositories) and now we have an abstract solution which is easily unit tested. Finally move the entire view layer to twig (there are options for this). This will result into very Thin Controllers, Fat services, Decoupled Models. class SomeController extends CI_Controller { public function old_show($id) { $this-&gt;load-&gt;model('some_model'); $this-&gt;load-&gt;model('some_other_model'); $data['some_data'] = $this-&gt;some_model-&gt;get($id); $data['some_other_data'] = $this-&gt;some_other_model-&gt;get($id); $this-&gt;load-&gt;view('some_view', $data); } public function new_show($id) { // missing DIC :( // so we use a factory instead that takes care of dependancies $service = SomeServiceFactory::build('some_service'); $data = $service-&gt;getSomeData($id); $this-&gt;twig-&gt;display('twig/some_view.html.twig', $data); } } class SomeService { // injected through the factory public function __construct(SomeRepository $someRepository, OtherRepository $otherRepository) { $this-&gt;someRepository = $someRepository $this-&gt;otherRepository = $otherRepository } public function getSomeData($id) { $data['some_data'] = $this-&gt;someRepository-&gt;findById($id); $data['some_other_data'] = $this-&gt;otherRepository-&gt;findById($id); return $data; } } // create common interface interface SomeRepository { public function findById($id); } // legacy implementation class CodeIgniterSomeRepository implements SomeRepository { public function __construct() { get_instance()-&gt;load-&gt;model('some_model'); $this-&gt;ci_model = get_instance()-&gt;ci_model; } public function findById($id) { return $this-&gt;ci_model-&gt;select()-&gt;from('table')-&gt;where('id', $id)-&gt;result('SomeEntity'); } } // new implementation class DoctrineSomeRepository implements SomeRepository { public function __construct(\Doctrine\Common\Persistence\ObjectRepository $repository) { $this-&gt;repository = $repository } public function findById($id) { return $this-&gt;repository-&gt;find($id); } } Obviously this is just Fase 1, the next step would be getting rid of CodeIgniter all together and moving to a CommandBus like approach with (micro-) services, but all in due time.
Finally, inline debugging!
... uh what. My company values my time greatly and so do I... takes all of 15 minutes to properly provision a production server, and i don't use any auto-config tools.
Hi, can you show me an example of how you would solve general logging or caching with a decorator? Thanks.
Still no Hack support, which is sad but understandable.
It had it for years via the shift+f6 shortcut, but then I tried it and... ooh, shiny!
You enjoy what you do, don't you? --- Also I'm writing libraries with eventual PHP 7 features (return type hinting) in mind. Heck, I'm holding out for Generics support which might be PHP 7.1+ Of course I'm more of a mad scientist than a practical coder.
I've been using the preview for about two weeks. Highly recommended. 
Thank you for the example. Do I understand it right that the decorator and the service must adhere to the same interface? That's the limit of the decorator pattern, is it not? AOP would allow you to create a single "decorator" (or interceptor if I understand the terminology right) for all loggable services, no? Btw great remark about the cache TTL. Whether one uses the Decorator pattern or AOP, which layer should know about the TTL of a single entry?
Does it support HHVM? If not, any plans?
What I mean is I have comments saying "// put :Record here when PHP7 is out". Of course I won't release it as "Version 1.0" until I get those in there for real so close enough =p
&gt; Do I understand it right that the decorator and the service must adhere to the same interface? That's the limit of the decorator pattern, is it not? I'm not sure why you call it a "limit". What is limiting about it? After all that's what interfaces are for: if you do the same thing, make an interface for it, and use it everywhere. AOP tries to tip-toe around this with implicit interfaces via assumptions, like "if method begins with get*() then it's maybe a data read method", but that "maybe" is very fragile and error-prone. If you don't want surprises from your software: use simple, clear interfaces defining simple, clear contracts. &gt; AOP would allow you to create a single "decorator" (or interceptor if I understand the terminology right) for all loggable services, no? My example was applicable to all services, because the idea is you drive commands and queries the same to all your services anyway. Thinking just what happens in PHP may be shortsighted. At some point those services will get split off to other processes (daemon processes), and then at another point they'll be split off to other machines in a distributed architecture. You want a common interface to convert commands and queries for all of them to a stream of bytes sent over a socket. You *will* have a common communication protocol interface for your services *one way or another*. So you can use it to decorate all your concerns right there while the interface is shared &amp; "narrow"; transparently and without AOP. &gt; Btw great remark about the cache TTL. Whether one uses the Decorator pattern or AOP, which layer should know about the TTL of a single entry? The service providing the objects. Which is my point, you can't just add one line of code, and magic: all your things are intelligently cached. No, it takes forethought and cooperation from the service itself, so toy examples aside the service will provide a natural interface points for implementing caching, and you'll have to do some work there and implement an intermediary that understands this interface. You can't just apply solid caching to an arbitrary class with AOP, that only works at the level of depth seen in blog posts and demos. Again, look at how HTTP does it, gets caching (mostly) right, so it's a nice example. Who sets the caching headers? The HTTP server. The server doesn't have to do the caching though. Any intermediary (i.e. "decorator" in our context) can do it, and the end-client can also do it.
They were promising Q1 for hack