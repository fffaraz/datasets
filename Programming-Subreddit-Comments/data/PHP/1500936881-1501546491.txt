&gt; Definitely store it in the DB, but not the same one. Different DB systems use the terminology slightly differently, so I'd like to ask a question about this. Because MySQL is so prominent, I understand "but not in the same DB" to mean, that it can be on the same box, in the same instance of MySQL, but in such a way that it requires multiple users with different permissions to access the different data. Is this accurate?
Once spent hours trying to get xdebug to work with sublime..turns out port 9000 is used by nginx too :)
Started using PHP Storm recently. Definitely helps.
Cool resource. Thanks
Solid info. Thanks.
puny meat humans have to google from time to time
A company whose interview required knowledge of things that any competent IDE can do is not a company I'd want to work for.
I liken using google to look up code related matters to a doctor using a medical dictionary or condition diagnosis book. Its perfectly fine; better than than 8 hours of solo trial and error debugging
This is especially true for me when working with the array functions. Is like the devs intentionally changed the order of arguments for shits and giggles. Quite often I've found myself tempted to create an Array class and just be done with it.
I've gone to conferences and spoken with framework developers. Those guys are really smart. I'll trust their work even if it means I start with a kitchen sink. As a small projects grows to a medium sized one and so on, I find myself eventually needing most of that kitchen sink. Those parts of the framework that I initially found to be over engineered end up solving problems I face that I could never have anticipate 3 years ago when I wrote that first line of code. But hey, it's your application. If you want to use 5, 10, or 20 different modules from somewhere out the wazoo then you can do that. It's just not something I'd advocate at the office.
There is a quote from a developer who says he felt like he's been writing them same application over and over again for the last 20 years. I'm not a drone, but I feel like one when I do CRUD operations and the same thing over and over again on a project. My expertise are in implementing domain logic and doing so in a fast, secure, and scalable manner. I feel like frameworks let me do that. But if what you are doing works for you, then keep doing it. 
I wouldn't worry too much about having to lookup the documentation; that's what it's there for. Now if you want to memorize anything, you should look into common design patterns and algorithms. The nice thing about memorizing those is that they are language agnostic. 
Is it just me or does this question get asked once per week here? Not a diss to the OP, it just shows how dismal the options are.
&gt;Is it just me Probably not
Your ego does not need to be out of control to think you can improve on an existing solution in one or more ways. People do it every day.
Yep. The auto fill and being able to click into calls is huge. 
Well said.
CAKE FOR DINNER!!!
Another release for a fantastic tool that keeps getting better. BTW, please don't forget to update the readme to reflect the new level range (up to 7, instead of 5). It currently still references 5 as the top level. Keep up the great work!
Does that do anything special that php.net/function_name doesn't?
It's shit analogies all the way down. 
Thats a slight twisting of my intent. We could drill down through several layers of pedantry if you want. Or we could just agree that the likelihood of the average programmer replacing an existing solution which has hundreds if not thousands of hours of work put into it is slim to none. Keep in the context of my statement was about about a bug fix or some incremental improvement, its about the "I'm gonna build it from scratch" guy. for every person that is capable of reinventing the wheel, there exist thousands that need to color between the lines. Its the exception to the rule for a reason. Is this a bad thing or an insult? Nope! I belong squarely in that group with the crayons. I understand things at a level of complexity non developers don't. It gives me appreciation bordering on awe to be privileged to use some of the tools those people build, that takes nothing away from me. Usually when I run into the "I'm gonna build it from scratch" guy its painfully obvious that its Dunning Kruger at work with a toxic combination of other factors. Not only that usually the cause is that that person finds it easier to cowboy code some atrocious mess than to learn the current best practice. Maybe that person is lazy, maybe stupid, but neither gives me much confidence they will replace Doctrine. Mr I don't understand ORMs isn't going to innovate. He is going to write some atrocious mess full of injection vulnerabilities all the while feeling great that he didn't need an ORM. I guess dunning kruger is the root of my irritation. I'll grant this nearly makes my rant tautological.
They meant "not in the same table" rather than "not in the same DB". So it shouldn't need a separate user or anything. 
In Chrome you can auto search sites with tab. For example type 'ph' so it auto completes to 'php.net', then tab, then the function name. 
PUDDINNGGGGG!!!!! 
1. Opens the file for reading and writing and puts the pointer at the beginning of the file 2. Reads the first line of the file and saves it in $text 3. Move the pointer to the end of the file 4. Adds $text to the end of the file 5. close the file Though I don't really see what's the point of doing that but ok.
I've worked on that for many years as well. Looking things up constantly is very slow and cumbersome... Once I started using an IDE it really addressed all my issues. I had programmed in vi for a decade before switching to sublime. Sublime was a great improvement, but then I got a free license for phpstorm. It's incredible, provides all the syntax checks and function names, resulting in much faster development time.
Yeah but PHP already provides you with all the tools, so you already have the ingredients, you just need to cut the tomatoes, grate the cheese and make the sandwich. You just learned how to make a sandwich, and more importantly how to use a knife, how to cut a tomato, how to grate cheese. Surely those things will be useful later. Using a framework is more like buying a frozen sandwich, adding already grated cheese on top and putting it in the microwave. Sure it's quick, but it tastes like cardboard and you didn't learn anything in the process.
You don't need to spell the function name correct... off the top of your head does strpos have an underscore in it? I never remember...
Good to know.. I use Firefox with vimperator so I can just press "t !php function_name" which I find very useful.
Well off the top of my head I knew it didn't (honestly probably because I use it at work semi-frequently). Interestingly enough, php.net/str_pos redirects to the manual page for strpos. Just by trying a few DDG queries, it seems like it actually runs the same query as the php.net/query shortcut php.net/arrayslice redirects to http://php.net/manual-lookup.php?pattern=arrayslice&amp;lang=en&amp;scope=404quickref DDG redirects simply to http://php.net/manual-lookup.php?pattern=arrayslice
You can make it a flag: as already mentioned in the issue, we provide full reflection compatibility, so the only change needed is reflection instantiation logic, to be hidden in a factory.
Good observation, and I did not know about php.net/function_name Well in any case I suppose chrome does many things ddg does with its bang operators, but I still find it useful especially with vimperator on Firefox. !a (amazon), !gi (google image) and !gmaps (google maps) are ones I use frequently.
Just remember that arrays start with 1. eheh.
It's showing me how to update a file before teaching how to use pointers
Wasn't the file opened with only binary safe read permissions?
Type it out, don't copy paste it.
Nope. &gt; 'r+' Open for reading and writing; place the file pointer at the beginning of the file. http://php.net/manual/en/function.fopen.php
Repitition. It is the only way to learn to remember things. I use it a lot. Commands. Syntax. Procedures. Steps. I keep repeating things until i can retype them from "muscle"memory. As said already though. It is vital to research and to spend time to make sure that the code you are typing is good valid code and well structured and is based on up to date knowledge.
Hitting space works as well as tab after typing `php.net`. I see how you indent...
Well dang, now I want pudding and it is 11:35pm. Thanks a lot :/
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Needle, haystack. Haystack, needle. Make up your bloody mind, PHP! The top comment talks about letting your IDE do the work for you, which is certainly true to a certain degree. But then you might miss that sense of accomplishment when you're coding one day and realize you knew without looking that `in_array` is needle, haystack and `strpos` is haystack, needle. 
Let's see it! There's a serious lack of secure, concise mail libraries out there ...
Nooooo a good programmer uses vim
I haven't heard of psalm before. How does it compare to phpstan ? Don't they cover the same things ?
Using a file pointer without actually doing anything with it would be pretty boring. 
Why is or die() still a thing? Please throw an exception instead.
Who could be bothered creating custom exception handlers and large try catch blocks for small scripts when or die() works just as effectively?
If it's just example code an exception doesn't need to be caught (you still get a page with your message on albeit with some uncaught message) and better mimics what you should do in real life. I'd hope there was a chapter all about exceptions later on. 
Thanks, Surely we will check the grammar before publishing
You don't. Write wrapper functions, get a better IDE, and get used to googling basic trivial shit. Memory is for computers, not people. Phpstorm, and most ide's allow you to navigate to the actual php docs without a browser. 
The computer has to learn if it doesn't do what it is told the punishment is death.
I'd argue that this is not code as config but rather code as domain specific language to provide a configuration. Which means you get code completion but mostly for the domain specific language part and you clearly miss the type checks when injecting arguments. At least the IDE can't give you hints while you type, which means you either need to reload the app or run your unit tests to see if the configuration is valid. But I like it more than the current approach in Symfony ;)
This repo was mentioned in a conference I attended some time ago. https://github.com/PatrickLouys/no-framework-tutorial You may find it useful.
Nope. You need an IDE plugin for that. A plain XML editor or PhpStorm without the Symfony plugin is not aware of the relationship between the mapping of XML structure and code.
If you do that how do your dependencies - I mean 3rd party code - know about your very own "container"? For a decent amount of interoperability we cannot get rid of a common interface.
100% agree with you comment, but I'm of the kind that like using for example autowiring from time to time, so a DSL is a must-have for me :) I'm also very interested in short-closures being added to PHP, that would help a lot to bridge the gap I think, e.g.: return [ Foo::class =&gt; fn(): new Foo, Bar::class =&gt; fn($c): new Bar($c-&gt;get('foo')), ] (pseudo-code, you see the point)
Space only works if you've typed the whole `php.net` whereas tab can work if you've only typed 'p' and it's autocompleted. Also, Chrome literally tells you to press tab...
A wise man said.. &gt; Never memorize something that you can look up. - Albert Einstein If you doing something over and over again, you will save it up and will be able to do it without looking it up.. but if you not doing it all the time, but here and then.. and it's aviable to easily Google for, then why the heck you should waste brain memory drive (BMD &gt;&gt;&gt;&gt; SSD &gt;&gt; HDD) for it? It doesn't make you really smarter that you can memorize everything useless, maybe it make you feel like it, but that won't help you at all. For example the "PHP header redirect" is something you usually write once as a method and don't touch again.. so just look up for it. I once had a mate that was like "Oh so you are a IT man, tell me the difference between Raid0, 4 and 5". There was a time where I learned it and could tell you every small detail about them, but that's a knowledge that is completly unimportant for like 99% of my life. It's not like I am setting up a Raid every day, so why should I memorize it. Well, at least this is the way my brain works. I sort out everything "useless" or let me call them "not important enough to remember" out and make space for things that seems to be worth to remember. So I can perfectly remember things that I actually want to remember, but am a complete disaster at when you ask me what we did 5 minutes earlier. I just don't know.. can't remember. I am curious if a memory palace is more effective.. I mean sometimes I use techniques similiar to it, but I don't have my own palace. Maybe I should set up one and fill it. Anyone has experience here?
As an alternative, you could try [Devdocs](http://devdocs.io). It has up to date docs of PHP and many other languages/frameworks in an easy to read and clean format. I have it as a pinned tab in Chrome for easy access. 
Zen vs Capitalism 
Death by snu snu!
There isn't any particular difficult. The most important aspect is the php life cycle and how it is different from most other languages in the field. 
Correct. I assumed everyone would know what I meant. Apologies for the ambiguity, thanks for stepping in! 
But why would I throw an exception to simply exit the program, if all that I am creating, for example, is a simple command line tool? *That would be like.. an overkill, man.*
In addition to /u/therealmalios's link, you may find this useful: https://symfony.com/doc/current/create_framework/index.html
Fair enough.
IMVHO, it is more important to know when to use a piece of code than its syntax. That said, practice as much as you can.
Yea, Going by what what other comments have also said, I think the best method to protect our IP is to deploy a SaaS solution. Especially since we have built the application on Phalcon3 so weather we use an obfuscation like ionCube or not, the client would still need to install the Phalcon extension, which is as easy as `apt-get install php7.0-phalcon`but yea, we cant rely that the client knows how|someone to do this. SaaS would also help with licensing as we don't need to develop a robust licence layer, we can just use a standard user account sales model. I did have a meeting yesterday with the team and we did come to an agreement to do a SaaS subscription deployment with an option to buy product for self-hosting. It also allows us the to clients a trial period to use the product. Im not too bothered whether this got upvoted or not, as long as I got the information I needed.
&gt; But then you need to memorise the redirect() syntax Not if you're using a decent IDE, I know the 2 I've used over the last few years, Netbeans and PHPStorm will both auto-complete any functions you have written. They will also pull in any docs attached to them and display what the function expects and what it returns. The same obviously goes for any core PHP function. So I wouldn't say its hard
Just use http://devdocs.io/ Has all your docs then in one place
This book is obviously aimed at someone new to the language, it doesn't really make sense to try and teach them everything in one go. To me, it makes sense to teach the subject at hand and cut all the fluff away from it. Try and remember when you first started, it would be difficult to try and process so many concepts at one time.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
The irony of your question is that if your dependencies know about your container, you failed to benefit from DI. You're not alone, of course, the inability of people to grasp DI is so bad overall, the ContainerInterop interface is "DI done wrong" codified as a standard. So instead of asking me how to do DI wrong, give me your concrete use cases. :) I'll take a guess to move us few steps forward. If a 3rd party component wants to lazily fetch a set of components from the caller, they define an interface, and they ask for it. That interface doesn't have to be one service, it can be a set of getters to all services the component needs. In this way you don't pass containers that contain more than the component needs, and you don't make the component aware of any container at all. Just simple type-safe interfaces.
You need to use prepared statement to bind data and then push it to Mysql database. PDO is easy to learn and you can find lot's of examples on it. If you are taking password inputs use bcrypt or password_hash for it. Properly validate the input type so that raw or bogus data can not be inserted.
Teaching someone to use "or die()" is obviously teaching them *something*, and it's teaching them the wrong thing, that then has to be untaught later on. The "or die()" idiom is unique to PHP and so would feel weird to anyone who's ever worked with another language, only for them to discover later on that actually PHP throws exceptions and errors like many other popular languages, including JavaScript, which these days *happens to be first language most devs learn*, as it's right in their browser to play with. So no need to make up poor excuses for this book's authors. If you see "or die()" the verdict is clear from miles away: either is the book over a decade old, or the authors don't have a fucking clue what they're doing.
More specifically, write why something does what it does, not what it does.
The irony is, that your last statement is not true. You still make your component aware of a container, just a very specific one for the particular component. If you do that, then why not inject the dependencies directly via constructor? For resolving action/controllers or views/responders I do not see any other way of using a dynamic approach like calling -&gt;get($id). Sure I can use call_user_func() to dynamically call a method but that does not really solve the problem. 
It's just a pretty bad example. And using outdated (for over a decade) idioms like "or die()". So being confused is the *proper* reaction to this code.
&gt; The irony is, that your last statement is not true. You still make your component aware of a container, just a very specific one for the particular component. If you do that, then why not inject the dependencies directly via constructor? Because I said "lazily". Constructing them in advance is not "lazily" and wouldn't be practical in a high-level module that takes in lots of dependencies, but needs only a subset of them based on runtime conditions. When people say "container aware" they don't mean "a container specific for the particular component". As I said, DI is a topic many people are confused about. The harm of injecting your *actual root container* are: 1. You make your accepting component dependent on the container interface. 2. You pass in more dependencies than the component needs, potentially making the contract implicit/unclear or allowing the accepting component to use more dependencies than it is expected to use. 3. There's the general problem of "stringly-typed" logic. It's slow, error-prone, and implicit: you are implementing a set of "string" identifiers written in a PHPDoc comment, instead of implementing a set of typed methods with a clear machine-readable contract. I.e. `function getFoo(): Foo; function getBar(): Bar;` is pretty clear even on its own, while `function get($string): whatever;` is not clear at all on its own. When people say "oh no the service locator anti-pattern", the negative effects they refer to are 1 and 2. And 3 is just personal disdain for over-engineered stringly-typed schemes, when the language has the necessary expensiveness to describe the author's intent. When a component asks for an interface with just its own dependencies, it's typically not a "container". It's merely a thin, type-safe adapter for another, much bigger container. And so the "service locator" drawbacks don't apply. &gt; For resolving action/controllers or views/responders I do not see any other way of using a dynamic approach like calling -&gt;get($id). Sure I can use call_user_func() to dynamically call a method but that does not really solve the problem. Take a step back and ask yourself "why am I resolving these dynamically?" I guess you'll say "so I don't have to type hundreds of factory methods!" Then take a few more steps back and ask yourself "why is every controller and view in my project having a different and unique constructor?" I guess you'll say "because they need different dependencies!" Then take a few more steps back and ask yourself "my overall module already depends on an interface that provides these dependencies lazily, why have I decided to suddenly do nuts with reflection on the boundary between module and controller? Can I just pass the same interface to the controllers (or a part of it that they need) and they can manage from there - unified controller constructors" And if you do that, the fact there's a concrete interface for every dependency, and not a soup of `get("string")` calls, is a big benefit all of a sudden. You're falling hard into the footsteps of "best practices" you've read online and seen in frameworks. But actually, a lot of them make no sense. This is why it's important to critique what you see and question it, not just blindly accept it.
The language "call it up in your browser" betrays how old fashioned this reference is. Also, visiting PHP scripts directly in your browser... 
Prestashop is a piece of shit, that's all I can say. Can't believe there's still so much people using it. 
Let me introduce you to a much easier way of reading from and writing to files: * http://php.net/manual/en/function.file-get-contents.php * http://php.net/manual/en/function.file-put-contents.php Will do 99.9% of what the above can do, but in two simple lines.
Thanks, I fixed it!
Try var_dump ($_POST). If its empty then problem is in your JavaScript . And btw for this there's subreddit phphelp or phphelp
Nice easy to read guide - thanks! I like the fact that it is condensed onto one page. Makes finding things with crtl-F a lot easier, than having to look across multiple pages when you don't know the name of the thing you are looking for, but think you know the characters it uses; this is often when search engines fall down, searching for non alphanumeric characters...
In an application i wrote, drafts are stored in a table called "auto_save" because my site auto saves after 1 minute if the user stops typing, the save draft button also saves to this table. The drafts can then be reloaded in any category the user chooses, for instance if a user has written out a 1000 word article and released they are posting to the wrong category, instead of posting it and moving it afterwards, they can save the draft, go the the category they want to post to and reopen the draft. The draft knows nothing of where it was originally was going to be posted but the category does, so if the user needs to go somewhere and come back when they go to the category they can see they have 1+ draft(s) for this category.
Nothing beats www.regular-expressions.info for me.
&gt;Do not forget to grant the correct permissions for the directory /vendor/geekcom/phpjasper/bin/jasperstarter/bin and the file binary jasperstarter why is this an issue? git keeps file modes as they are, change the file mode and you will notice it's a changed in git
This is one of the hardest problems in production operations. I work for a $3 billion run rate e-commerce company and we use PHP for our websites. When we deploy new code (which we do about 8 times per day), we always have a blip of fatals. This is typically due to code being replaced on disk while older code is in memory; references break or expected data structures change. We live with this because it hasn't been demonstrated to impact our bottom line moreso than moving quickly and deploying frequently boosts it. So first I'd ask... Is this really important? 
Whenever possible, we do migrations in steps: * Create the new structure, and "copy" old data there * Adapt code to write both the old and new structure * Change all reads to only access the new structure * Remove the writes to the old structure * Remove the old structure I can't guarantee that this would work with doctrine though, but it has been a life-saver for me.
No, It's not insanely important, it just hurts personally when I break stuff, and my curiosity if I can make it fool-proof ;) Also, my biggest concern is running a "test-migration" + unit tests before running migrations on the production server, and I want fast deployments ;) (But I have a feeling I can't have it all)
A lot of this becomes more reachable when you have good infrastructure automation, which is something my company is still working on. We did not start in the cloud, so we have a lot of legacy architecture to move around. If you can spin up an entire environment, you can do a blue/green deploy, but the tricky part as you noted is avoiding data loss. 
Thanks for this! That would work in 75% of the cases when the database changes (if there is a big change to the database schema, the old application might not be able to write to the new database, and the new won't be able to write to the old, and thereby loosing data :/ ) I think my best case will be to test the migration heavily, put the old version in read-only mode, copy data, migrate, then activate the newest version as fast as possible :)
Personally, I use https://www.clickatell.com It's got a nice easy to use API and pretty cheap, too.
I'm not a big fan on Laravel, but their Collection class is pretty nice! (almost a lodash for PHP)
Yeah, I'm working on moving all our applications into Docker (we are looking at rancher to organize containers and hosts automatically), But I think the best-case scenario is blue/green deploy, with the old version being read-only / maintanenca mode for the shortest amount of time possible...
That is a pattern that can definitely work. Good luck! 
Thanks! :)
Yup we did that a few times too, hard to keep track in time of what you're doing because you'll have to remove outdated legacy code at some point once everything has migrated (it's useless to maintain the old code).
I'm actually coding a major project in Laravel right now. Although I haven't gone deep enough (probably) to form a well formed opinion on it, I really love not needing to create my own framework from scratch. Especially coming from a ZF1 background, Laravel's pretty fun to work with. That being said, I've more or less completely ignored Eloquent except for the User class, opting to give myself access to the PDO object and organizing all my DB logic in Repositories. My major project has a huge DB schema and I'm not in the mood to change my existing workflow (which I guess is called a DataMapper pattern) just so I can simulate FKs and shit in PHP.
I don't say I prefer it, but changing it with a `;` in between doesn't make sense. If you want to change it, I'd go for `foreach (user in users)` or something like that.
From my experience, it's bad teaching examples. Check out this monstrosity from a 2017 university lab book that I shall not name: $query = "SELECT * from USERS" . " WHERE username = ’$username’" . " AND password = SHA(’$password’)"; $result = $conn-&gt;query($query); if ($result-&gt;num_rows === 0) { // Bad username or password } else { // Good - log in } This is actual code that they feel students should use.
I don't think Laravel is bad per se, I just don't like how it's structured. I'd love to use eloquent collection without having to install the whole thing and the kitchen sink. [Doctrine does this right](https://packagist.org/packages/doctrine/collections), but their Collection class is way less useful. 
installing from an archive via composer (as opposed to running with `--prefer-source`) + using a windows machine = potential for perms to go out the window.
He should remove the bonus part some of the regexp gave there are at best wrong or will return false positive , for instance the username regexp is nothing but outdated at best.
The use a rapid development framework like CakePHP ( https://cakephp.org/ ). It is designed to do exactly what you want: A very quick prototype with almost no code required - or at least generated with a few clicks/keystrokes. It enables you faster than you ever could on your own - and guide you through many best practices. And from there, once you got more time, you can easily refactor, you can easily learn some of the underlying PHP things you didnt have to care at the beginning (and you didnt want to for obvious reasons). :) Have fun coding and let us know how it turned out.
but it's under the title **Note for Linux servers** :)
I know you're very security minded (comes with the job title), but is the hmac and and hashing really necessary for *typical* apps (i.e. not CIA top secret stuff or bank app stuff)? What I do for tokens is: 1. User ID (autoincrementing 64-bit uint, i.e. unsigned BIGINT) = 8 bytes 2. Token key (crypto-random 128-bit key) = 16 bytes The user is padded with zeroes on left, so it's fixed 8 bytes always (eases parsing), then: $token = base64_encode($tokenKey . $userId); This results in a string that's exactly 32 printable chars, you can look up the token by user id, and compare the token key outside the DB in a time-attack-safe way as you recommend. Expiration doesn't have to be encoded in the token, as token validity is verified on the server, and the server can unilaterally expire tokens as it pleases (including for other reasons than time passing). Possible weaknesses: 1. You disclose the user id. Risks = I can't think of any for typical apps. The user id can be considered public info. 2. You allow an attacker to build a token, if they steal your tokens database. Risks = I consider this a low risk, especially if tokens don't last too long, and need to be regularly refreshed. For sensitive applications where you don't want to risk login on database leak, you can choose to hash the key using a light algorithm like md5 (which is secure in this context) and use the first 16 raw bytes for the final token, to end up with a 32-char string again. But we can avoid HMAC if we don't need to encode information that's sensitive to tampering (like expiration), and we don't, I believe.
No it's actually not :) sry.. But: if you use OS libraries out there as help, it might come close. Building an app from scratch vanilla PHP code is usually the worst thing you can do ;) No matter how skilled.
&gt; The user id can be considered public info. I'd agree, but some businesses are really paranoid about their competitors being able to measure their customer base. &gt; you can choose to hash the key using a light algorithm like md5 (which is secure in this context) Why would you choose MD5 when SHA256 is available? Just because it's "secure in this context" doesn't mean MD5 should ever be used. Hell, use BLAKE2b, which is more secure than SHA256 and faster than MD5. &gt; But we can avoid HMAC if we don't need to encode information that's sensitive to tampering (like expiration), and we don't, I believe. I don't get what the sudden desire is to avoid HMAC, but okay.
if you're deploying from a windows machine to a linux server :D
Why is this downvoted? It's a good site for Regex info.
No doubt Symfony is most appropriate for it but you can also use laravel. On the CMS side Magento and woocommerce are good candidates. shopify is also there and you can also find independent cart systems to work with.
thanks for the overview!
Shopify does something with zero downtime. https://www.youtube.com/watch?v=HNH7El_BEsw Zero-downtime database migrations can be done if you follow a simple principle: Renaming a column: * Create the new column (no code using it) * Update and deploy code to write to both columns ( the old and the new ). * Write and execute a maintenance task that will update old rows (copying from the old to the new column). * Once you have confirmed the data is present in the new column, update and deploy the code to only update the new column. * Delete the old column Deleting a column: * Update your code to no longer use that column * Delete the column Adding a column: * Migrate your database to contain that new column. * Deploy your code that uses the new column. You shouldn't need to set your database in read-only mode when using something like LHM(https://github.com/soundcloud/lhm or https://github.com/masom/lhm_php) / https://www.percona.com/resources/technical-presentations/zero-downtime-schema-changes-mysql-percona-mysql-webinar You could use CircleCI / Travis / etc. to setup continuous integration on GitHub pull requests.
To prevent blips you could always rsync/git checkout/unzip/etc into a new folder and symlink it once the code is ready. That is how Capistrano and some other deployment tools use to manage deploys. This also allows you to quickly revert to a previous version in case something goes wrong.
Sidenote: I use the regex feature in Find &amp; Replace in my IDE (Sublime). It's so *[expletive]* useful that I've come to use Sublime as my default text editor. Almost anytime I need to work on a body of text, I first copy-paste it into Sublime, then whip up a quick expression. This is **especially** useful when dealing with data in spreadsheets.
practice, practice and practice
That's the D syntax actually. The JS version is nice too, but now I've come to prefer the shorter D syntax. Many D tools on my github account were initially implemented in Node.js btw (Basil, etc).
That is what we do, and it doesn't prevent blips. This is because of actively running code autoloading files that changed after the request began, and the delay before the opcode cache can be cleared. That is a very good pattern for releasing the code, for the reasons you gave, but it won't prevent errors. Edit: I should add that we're doing about 1 million customer visits per day across about 70 web servers, using nginx and php-fpm. If there are actually moments of no activity on a web server, you might get lucky. We do not enjoy that luxury. 
&gt; Why would you choose MD5 when SHA256 is available? Just because it's "secure in this context" doesn't mean MD5 should ever be used. I guess the question is why not? Engineering is about finding the most efficient solution, that still fits within the required parameters. Probably the Eiffel tower could've been built from heavy solid plates of steel instead of a light skeleton of hollow segments, as it is, but why do it, if you can go lighter, and it still stands up to this day? So if it's secure in the context, then it's secure. If it's not, then it can be explained why and the solution can be phased out and replaced. All the hashing algorithms are basically hacks. They're all waiting to be compromised in one way or another. But they're often compromised in ways that's sensitive to context. Vulnerable if, and when. So no need to throw away perfectly good hashing algorithms for the places where they still do the job as advertised. All SHA-256 would do here (unless proven otherwise) is spin the CPU for extra time, to provide extra entropy that I'll then throw away (for a 32-bit token we need only 16 bytes for the key). &gt; I don't get what the sudden desire is to avoid HMAC, but okay. The token is sent with every request, so wasting CPU on pointless operations (again, unless proven point**ful**) is wasted server time when it can be used to serve more request, and reduce latency per request. From security perspective I realize this is not a concern a security-minded expert thinks about, but when you wear multiple hats, and one of them is "business value" this stuff matters. If the token operation is very expensive, RAM cache can be used (say APC) for tokens which are sent over and over over a short period of time, but the complexity of HMAC + SHA is right on the boundary where the overhead of using cache itself about evens out with not using cache at all and doing HMAC + SHA from scratch every time. But you can improve overhead by simplifying the algorithm and removing the need to run HMAC + SHA down to MD5, or no hashing at all, if the application doesn't require the extra effort.
the best tool to test regex online https://regex101.com/
That's interesting. Containers would probably be the way to go then.
That's kind of a strange line to draw though. I count that as editor support. One of IntelliJ's biggest strengths is it's first class plugin support, so by extension the editor supports this feature.
Reflection is kind of slow when performing operations, so I try to avoid it where possible.
I use an error handler to throw exceptions on notice. Fuck unexpected behavior.
Until your content is too big for memory or you need to stream it. Or you want to catch specific errors. Don't get in the habit of using these functions, they only lead to something you have to refactor later when it's just as easy to do it with resources/streams from the start.
[RegexBuddy](http://www.regular-expressions.info/regexbuddy.html) by those folks is pretty nice but IMO isn't worth the $39 price tag when things like [Regex101](https://regex101.com/) exist.
The big blocker right now is not being able to generate PHP servers. They seem to be making progress on the GRPC server for PHP. There is a server included with the extension now that can accept requests and send responses but you can't access the request yet. Here is an example if you want to try it. If you want to use protobuf without going with GRPC the next protobuf release will be able to generate 'generic services' for PHP. That means you can define a RPC service in the proto file and the protobuf compiler will generate an interface for you. There is also a plugin architecture so you could write a plugin to i.e. generate a guzzle HTTP client for any protobuf service.
For those like me that didn't realize PHPStorm and VSCode(probably sublime too) supports capture groups: Find: `^(\w+)\.(\w+)` Replace: `$2.$1` would change `rocky.bullwinkle` To `bullwinkle.rocky` And in PHPStorm [even shows the result](http://i.imgur.com/z05XpVq.png)
Sometimes I don't get this sub. "Or die()" is terrible practice, so is using mysql_* functions, but if the book had that, people would be having a fit. It is a lot easier to write one long sql statement than binding parameters, would people be ok if that was taught first? But it's teaching them something!!!!
Curiously I don't see emacs mentioned a lot here when editor talks pop up, is there a large user base for 'php-mode'? Regardless, best of luck regarding your health.
&gt; Engineering is about finding the most efficient solution, that still fits within the required parameters. In this case, BLAKE2b is more efficient than MD5 or SHA256, so use that instead. &gt; From security perspective I realize this is not a concern a security-minded expert thinks about, but when you wear multiple hats, and one of them is "business value" this stuff matters. If you're concerned with "business value", you should know that sacrificing CPU cycles to make humans more productive is almost always a good trade-off for businesses. Electing to use a secure hash function instead of a severely weakened hash function is optimizing for humans: Nobody is going to either: * Panic, stop what they're doing, and look at the code to make sure it's not a show-stopping vulnerability, OR * Not panic, assume MD5 is perfectly OK, and use it in other contexts. Neither outcome is good.
I bet $username is just taken straight from the user input too
I use regex extensively when coding, but rarely in my code. It is such a powerful tool for find and replace, converting between different formats, restructuring syntax, etc.
Thank you. I also rarely see Emacs mentioned here. However, MELPA, the "package repository" where most people download add-ons like PHP Mode, has slightly over a recorded one-hundred thousand downloads for PHP Mode. So I figured there was a good chance that at least a few people here use it, heh.
What are the benefits over Guzzle?
Instead of using symlinks try changing the nginx/apache vhost to point to the new folder for each release, then do a reload. It should let existing requests finish using the old directory whilst serving new ones from the new directory. I haven't tested whether that would solve what you're talking about, but my intuition tells me it might.
Maybe, maybe not. The php-fpm processes are independent from nginx, as is the opcode cache. Intuition tells me it wouldn't fully solve the problem.
You could use https://symfony.com/doc/current/best_practices/controllers.html#using-the-paramconverter in https://github.com/shahroznawaz/Rest-Api-in-Symfony-3.1/blob/master/src/AppBundle/Controller/DefaultController.php#L38 (and maybe more cases)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [shahroznawaz/Rest-Api-in-Symfony-3.1/.../**DefaultController.php#L38** (master → 6d88fb7)](https://github.com/shahroznawaz/Rest-Api-in-Symfony-3.1/blob/6d88fb78c271d6f1044bd69d6a3d168a2ac60d07/src/AppBundle/Controller/DefaultController.php#L38) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkp4tfn.)^.
I've been working with gRPC clients for the past year or so. I really hated it at first, but as I started to understand it better I've begun to enjoy it. The strictness, often not present in REST APIs makes discovering mistakes easier. The tooling has also begun to improve significantly. I think a lot of the developer experience will depend on the server implementor -- a well designed API will be enjoyable and easy to use. Of course that's always the case, but I think it's particularly so in the context of gRPC services. &gt; php 7 (or up) is not supported This is incorrect. We use gRPC in PHP 7 all the time, and even install it in our Travis-CI builds using pecl with no issues.
Guzzle is a PHP HTTP client &amp; framework for building RESTful web service clients (client-side). This example app is a implementation of a RESTful API (server-side) .
&gt; your own custom CMS No. &gt; Do you go with a popular CMS Maybe depending on the size of the custom modules you're talking about. I prefer make the site with my favorite framework. Laravel at this moment. You can use voyager for example to ease the admin part thing.
Oh sorry, my bad. Looks like you're right. Let me quickly update.
I'm still in the process of learning Symfony, but from what I'm seeing, you have different endpoints for the different actions. Correct? One of the main points of a RESTful API is that the same endpoint results in different actions based on the request method (`GET`, `PUT`, `POST`, `DELETE`, `PATCH`, etc.). This doesn't seem to do that.
I was under the impression that AMP was to be avoided like the plague due to the side effects of the content being loaded under google.com instead of the source domain? Updated with [recent reference](https://www.theregister.co.uk/2017/05/19/open_source_insider_google_amp_bad_bad_bad/)
Guzzle is on the requesting end of things, although you can write some of your own magic using the PSR-7 interfaces. A RESTful API is on the receiving end.
+1 on this. I'm not sure this solves the problem. I'm just thinking more exotic way of doing this for example when you want to upgrade a server take the traffic out with the load balancer and then change/restart services or whatever then redirect traffic again to this server.
How do you work with multilanguage websites with voyager?
This needs to be formatted nicer (looks really bad on github). Also inject your repositories, using container aware stuff is cheating! https://github.com/shahroznawaz/Rest-Api-in-Symfony-3.1/blob/master/src/AppBundle/Controller/UserController.php
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [shahroznawaz/Rest-Api-in-Symfony-3.1/.../**UserController.php** (master → 6d88fb7)](https://github.com/shahroznawaz/Rest-Api-in-Symfony-3.1/blob/6d88fb78c271d6f1044bd69d6a3d168a2ac60d07/src/AppBundle/Controller/UserController.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkp6zjf.)^.
I think they are still on work for the admin panel. But there's something https://github.com/the-control-group/voyager/issues/191 On the front I guess it depends on how you build you database scheme.
What are the benefits of this over Silex (by Fabien Potencier)? https://silex.symfony.com/doc/2.0/cookbook/json_request_body.html
I'm sure there are pros and cons for both technologies. AMP is not an exception. I've found another insightful link on the matter: https://www.searchenginejournal.com/do-i-need-amp/181292/
Found a few errrors: `[T|t] -&gt; [Tt] ` - would match T, |, and t. `(at.)$ -&gt; (at\.)$` - would match anything as opposed to a literal period `\b` - Word boundary, not mentioned. [example](https://regex101.com/r/3bkFmL/1) Also, this is a really useful [tool for visualizing what is happening in your regex](https://regexper.com/#%2Fred%7B2%7Dit%2F)
There are false examples. ar[.] Does not match ara. It matches ar. ar. Matches ara.
Silex is **dying**
!remindme 5 hours
I will be messaging you on [**2017-07-25 21:51:27 UTC**](http://www.wolframalpha.com/input/?i=2017-07-25 21:51:27 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/6pf5rm/detailed_guide_on_regex/dkpapvz) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/6pf5rm/detailed_guide_on_regex/dkpapvz]%0A%0ARemindMe! 5 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dkpaw8q) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I love Sublime. We use PHPStorm at work but I use Sublime on the side, just because its text editor is so extremely powerful it's insane. The whole multiple cursor thing is so great once you know your way around it...
Regex 101 is pretty cool because you can easily switch flavors. I also use [PHP Live Regex](http://www.phpliveregex.com/) a lot.
&gt; In this case, BLAKE2b is more efficient than MD5 or SHA256, so use that instead. When PHP 7.2 with libsodium gets widespread enough, I might. Right now the closest thing is MD5. BTW while Blake2b is faster than SHA256, the fastest Blake2b implementation is merely *on par* with MD5, not faster. If it's more secure, that's still a win, but Blake is not faster than MD5. 
It's like asking what are the benefits of drinking coffee at Starbucks, versus serving coffee at Starbucks.
&gt; the fastest Blake2b implementation is merely on par with MD5, not faster. https://www.blake2.net/skylake.png
https://github.com/maiorano84/shortcodes
Something is definitely odd in this benchmark, SHA-512 is on par with MD5, and SHA-1 is shows as 20% faster than MD5. On my box, a quick PHP benchmark shows SHA-1 50% slower than MD5, and SHA-512 is about 150% slower than MD5. So I guess the concrete implementation matters. TL;DR can't reproduce.
small, cheap, fast, and complex... those words don't all go together. cheap/fast/good [choose two](http://fastgood.cheap/)
That's make sense, thanks for alerting me, I will update the documentation.
Indeed, and in fact the very reason I do releases this way is that the opcache wasn't refreshing with the symlink in the first place (I'll be surprised if that's still an issue though, that was a bug from a few years back). What I think might happen: each release directory will remain untouched so any php-fpm processes still using the old directory won't have any new files at all so the opcache won't be affected. /app/release1/index.php and /app/release2/index.php are independent files and the opcache won't assume they're the same. That means any requests still serving from /app/release1/ can finish their request without the possibility of any cached PHP needing refreshed from disk. Sorry if I'm not explaining my hunch well. But it sounds like something worth experimenting with in my books because it's going to be the laziest way of fixing the issue compared to rolling upgrades or immutable infrastructure or some other non-trivial tactic.
That does make sense, so it actually depends on whether the opcode cache internals dereference symbolic links. With our current method (the symlink method), we forcibly clear opcode cache. I'm not sure if we've ever looked into a method using an nginx update. We use Puppet to manage nginx configurations, and are moving toward SaltStack for orchestration. I think the big challenge for us would be inefficiency in doing the actual config changes and restarts.
The bar graph is on the Skylake-optimized implementations, not whatever PHP provides. &lt;?php define('ITERATIONS', 1 &lt;&lt; 17); // Do our memory allocations first $buf = random_bytes(1024); $tmp = ''; $trials = []; $start = $end = 0.0; $i = 0; // Now let's benchmark: $start = microtime(true); for ($i = 0; $i &lt; ITERATIONS; ++$i) { $tmp = hash('md5', $tmp . $buf, true); } $end = microtime(true); $trials['md5'] = $end - $start; $start = microtime(true); for ($i = 0; $i &lt; ITERATIONS; ++$i) { $tmp = hash('sha256', $tmp . $buf, true); } $end = microtime(true); $trials['sha256'] = $end - $start; $start = microtime(true); for ($i = 0; $i &lt; ITERATIONS; ++$i) { $tmp = hash('sha512', $tmp . $buf, true); } $end = microtime(true); $trials['sha512'] = $end - $start; $start = microtime(true); for ($i = 0; $i &lt; ITERATIONS; ++$i) { $tmp = \Sodium\crypto_generichash($tmp . $buf); } $end = microtime(true); $trials['blake2b'] = $end - $start; var_dump($trials); Output: array(4) { ["md5"]=&gt; float(0.27368211746216) ["sha256"]=&gt; float(1.100576877594) ["sha512"]=&gt; float(0.76916003227234) ["blake2b"]=&gt; float(0.24345088005066) }
So, as I said, MD5 and Blake2b are on par, and the rest are slower.
SHA512 is faster than SHA256 on 64-bit hardware. Try the same benchmarks on a 32-bit machine. Anyway, this is all irrelevant. MD5 collisions are [trivial to generate](https://natmchugh.blogspot.com/2015/02/create-your-own-md5-collisions.html) and should never be used in new software.
That was my reaction after grinding my own burger meat.. the difference was so subtle that A) I wasn't sure if I was just adding my own bias because I wanted it to be better and B) I haven't done it since..
IMHO then [Mastering Regular Expressions](http://shop.oreilly.com/product/9780596528126.do) is *the* best book published on regular expressions. 
You are only echoing one item, try shuffle($array); echo implode($array, PHP_EOL); 
That sounds like a similar path to what I had. I was forcibly clearing the opcache because it wasn't dereferencing symlinks, and was using capistrano at the time so managing the nginx vhost wasn't really part of a typical workflow. Then in the move to ansible I had control over the nginx vhost so I decided to change the document path in each release and do a graceful reload instead. The reason was because we had multiple applications on the same server so clearing opcache for all of them for each release (which would be several per day) wasn't ideal. I've never used SaltStack but this whole infrastructure as configuration thing has opened up a lot of possibilities for me. I believe it supports rolling upgrades as well, and it's honestly not that hard to do in the end with ansible and that's probably true with SaltStack as well so you may find that works better. I haven't used it, but then I've never had to deal with more than 2 simultaneous instances of the same application. 70 sounds like fun :)
You described my last retail job (brick and mortar), but aside from the manufacturing we did our semi-basic retail software did everything just fine. This software was nothing like Magento, or if you've done restaurant work - Micros, with EAVs every where.. which is a necessary evil when you want to be able to customize everything. The hard part with manufacturing was just due to tracking inventory and cost of production - our retail software was not built for this, but damn it if they didn't have me try.. Point being, I'm curious about what *specifically* makes your needs different if you feel like sharing.
Each of the 70+ boxes runs 50 php-fpm processes, too, so things can get nuts. They recycle themselves at ~1,000 requests I believe, so for the time being we just let the blips happen. SaltStack is very interesting, I recommend looking at it, it's catching a lot of spotlight right now. You can do configuration management with it, but it's best not to think of it as a replacement or competitor for Ansible, Puppet, Chef, etc. It's a lot more like Fabric (the Python library), but with client/server communication, host selection, and other smart features baked in. We've only just started playing with it, so, time will tell.
Finally upgraded, thank you guys.
Ha, definitely sounds like fun! Or terrible depending on how smooth things run :) Looking forward to seeing your posts around here as you move to salt. I actually did believe it was basically ansible but just different in a few ways.
https://hashtagfoundation.org/framework/reference/
Regex buddy is for pro users that need to understand their regular expressions. I remember using it to optimize my regex, limit backtracking or some stuff. Regex101 will do just fine for the daily tasks. Edit: I was [optimizing this regex](https://github.com/mlebkowski/poczta-polska-ranges/blob/master/src/RangesParser.php#L7-L21), because it was ran in batch on some 500k records, so I needed it to be as fast as possible.
`fseek()` operates on a file pointer. http://php.net/manual/en/function.fseek.php
AFAIR its called MultiViews in Apache
That was it! Fixed it. Thanks!
This comment has no sense at all, this library is not using exceptions for flow control. Exceptions are only thrown on error conditions :s .
If I had to do one now .... Wordpress : it has loads of plugins and there are loads of designers who know how to deal with it..... thankfully I avoid such work.
You *really* shouldn't use multiviews. Just route all requests besides static files to a front controller and handle routing in PHP.
It sounds like it's a pretty old (legacy) site. Might not be all that easy to rewrite everything to a front controller.
we integrate with a closed source system, using closed source vendor extensions, that handles all of our asset management and shipping. Everything from accounting to the warehouse depends on that system but the tools aren't there for other platforms. 
Just a question on regex101 that anyone might know the answer to... Is there a way to test multiple "test strings" at once? It's annoying having to repeatedly change the "test string" to difference candidates while making changes. My question might only be relevant when using ^ and $ and maybe with multiline enabled. But it would be cool if they just showed separate "test string" input fields to test things separately without having the user having think about multiline settings and stuff. I always want to test my candiates strings in ***exactly*** the same manner that they'll be used in my code. So I usually end up writing some php to loop through an array to do multiple tests at once. I could probably skip having to do that if there were multiple **separate** test strings on this site.
Click "Switch to Unit Tests" that lets you add multiple test strings.
Oh cool, thanks! For some reason I thought that was something else.
it's from [vimeo](https://github.com/vimeo/psalm) they generally do cover the same things, but I've found phpstan catches some things that psalm doesn't, and vice-versa. quite often bugs that exist in one exist in the other too (i.e. bugs related to php returning incorrect info with reflection) **disclaimer**: *I have [more contributions on psalm](https://github.com/vimeo/psalm/graphs/contributors) than I do on [phpstan](https://github.com/phpstan/phpstan/graphs/contributors)* p.s. [here's an example of how I'm using php-cs-fixer, phpstan &amp; psalm](https://github.com/SignpostMarv/PHP-CS-Fixer-Config/blob/e5e8dfaf4c93edb399facff78fd544be95723d4a/composer.json)
Just in case you didn't know: the multiple caret feature works in PHPStorm too, no need to switch to sublime in this instance.
https://Iwouldnt.com/cuz/wordpress/is/shit
Things like `/rest/send/` are just telling us that you are implemented JSON RPC. ``` $re = 'User Added Successfully'; return $re; ``` This doesn't provide client any useful information. Statuscode 201 will be much better. Ok... this is just bunch of code... 
I'm sure Vim can do it too. But somehow with Sublime I'm much more productive than with PHPStorm with multiple cursors. Maybe it's the fact that you can easily switch to mutiple selection mode with Ctrl-L in Sublime. Maybe I'm just used to it. But PHPStorm doesn't do text editing as well as Sublime, and Sublime is not the IDE that PHPStorm is. In my opinion, of course; to each their own.
Try opening the spreadsheet in a text editor, you're likely getting some warnings being output and caught by your output buffering
Wait a second this isn't a CMS In all seriousness though it looks really interesting, though obviously quite opinionated towards Redis
You have a problem. You decide that the solution to your problem is regular expressions. Now you have two problems.
The spreadsheet is empty when I open it with Notepad++.
&gt; Take a step back and ask yourself "why am I resolving these dynamically?" &gt; I guess you'll say "so I don't have to type hundreds of factory methods!" No, because I have to. Because I do not want to create the whole object graph of my application on each and every request. Even if I would lazily instantiate the dependencies all the classes, interfaces, traits used would need to be loaded. That does not make any sense to me. &gt; Then take a few more steps back and ask yourself "my overall module already depends on an interface that provides these dependencies lazily... Are you saying you define one factory/container - however you want to call it - per module and inject that in each and every class of that module? So that each and every class can pull the dependencies it needs whenever it needs them? &gt; And if you do that, the fact there's a concrete interface for every dependency, and not a soup of get("string") calls, is a big benefit all of a sudden. Like creating 200 interfaces - for each dependency in the module one interface - and injecting the factory/container instead of the "real" dependency? I do not get your argument with the soup of get("string") calls. In your application framework you need 3 of those calls, not more. One call to pull the application/middleware from the factory/container, one to dynamically resolve the action/controller for the current request and one for resolving the view/responder to render the domain payload. Since all of that "magic" happens inside your application framework of choice, your application code is completely free from any get("string") calls. What is the problem that needs to be solved?
My "solution" to this problem is to pre-load all of our library files and as much of the adapter layer as possible into opcache to warm it. I detect if a particular file is cached, and if not, I iterate over an array of known files (created by a pre-deploy script) and require_once all of them. I'm then happy to let these files live in cache for as long as they want - My reset mechanism is a comparison between a database / redis flag and a file. My file (version.php) is as such: &lt;?php return 1234; ?&gt; Once I have established my database or REDIS connection (using code which is pretty much static), I test: ` if ((require 'version.php') &lt; $expectedBuildFromDatabase) { opcache_reset() + redirect to self. } ` Because version.php is cached, this provides a means of knowing if the code is out of date. My code execution context does not have write access to itself, so I have a little tool running under different permissions which writes the version.php and updates the database. Leading to a condition where at the click of a button I can simultaneously purge and reload the opcache of a dozen servers at the push of a button. It's effective, even with 5 - 6 hundred requests per second being pushed through 4 FastCGI instances.
He talked about it today at laracon, basically saying redis is the most scalable for this type of thing 
Have you tried putting an exit(); or die(); just before the first header(); line? Sometimes PHP will display notices or warnings, and those notices and warnings will break the file encoding resulting in a corrupt file.
Deleted because I misread the section rules. Moving to phphelp
Mate, never mind php mode. Hope you get your new kidney soon. Take care 👍
There's a bug in the library in php 7 (depending on which version you're using for phpexcel, mine did), sadly I don't recall the details but if you run it locally or somewhere where you can look at logs it should show you. 
&gt; No, because I have to. Because I do not want to create the whole object graph of my application on each and every request. Even if I would lazily instantiate the dependencies all the classes, interfaces, traits used would need to be loaded. That does not make any sense to me. "Lazily" means nothing is loaded until the exact moment it has to be. Unless you don't use autoloading... You do use autoloading, right? &gt; Are you saying you define one factory/container - however you want to call it - per module and inject that in each and every class of that module? So that each and every class can pull the dependencies it needs whenever it needs them? Not each and every class. Many specialized objects have simple needs which can be addressed with classic injection through individual contructor arguments. But controllers are an exception to this: together they form a single cohesive unit, but they have very heterogenous and ad-hoc dependency needs, often dependent on runtime conditions. So controllers do tend to receive either the module "container" (if you want to call it this way), or more typically a subset of it, that contains only services that these controllers (together as a single unit) need. This is very easily achieved through interface segregation, and I can tell you more if you're curious. &gt; Like creating 200 interfaces - for each dependency in the module one interface - and injecting the factory/container instead of the "real" dependency? No I meant there's a concrete typed getter method in the container interface for every dependency the module needs. Which means it's easy to work with it in an IDE, and hard to get wrong (it's type-safe and statically analyzable, unlike "stringly" containers). &gt; I do not get your argument with the soup of get("string") calls. In your application framework you need 3 of those calls, not more. One call to pull the application/middleware from the factory/container, one to dynamically resolve the action/controller for the current request and one for resolving the view/responder to render the domain payload. Since all of that "magic" happens inside your application framework of choice, your application code is completely free from any get("string") calls. What is the problem that needs to be solved? "Magic" leads to poorly architected, amorphous, fragile applications with uncontrolled, implicit interdependencies and hard to analyze object graphs. "But the constructor clearly spells out what the controller depends on" means absolutely nothing if you have a hundred different constructors on a hundred controllers, which you can't keep a check on. It's complete chaos, and the only thing dynamic resolution does is to automate this chaos, thus further enabling it. "Magic" is also slow, especially for PHP applications, which tend to "reboot" on every request (and hence get rewired on every request). And it is unnecessary, as I was trying to explain. That's enough of a case to be made against using magic and "dynamically resolving" things, unless you *have* to. The case to be made here that you *have to*, in face of the simpler non-magic solutions I'm trying to communicate to you is yet to be made. The only thing you have on your side of the argument is the current hype cycle of the community, which has decided to do everything with autowiring and reflection. This will pass, just as it has passed in the Java community, and you'll wake up one day, as if after hangover, and wonder WTF were you thinking slapping all that "magic" all over your code for no reason, when simpler, faster, better solutions have been available in the language since at least PHP 5.0.
You're assigning the value of $Topic['Topic']; to both $first and $last - so all three variables will be the same. Also you should post this stuff in https://www.reddit.com/r/PHPhelp/ instead.
We'll, you are using a book where only a handful have reviewed the quality of the code and approach. Or you could use Google, tutorials and Stack overflow, where thousands have made efforts to rate content via upvotes and more. I've never understood reading code in a book.
Anything aimed at helping the masses get to know queues gets an A+ in my book - it's a context most new programmers shy away from for way too long, and could definitely use earlier. Combining an excellent monitoring approach with a queue manager? Pretty cool approach at tackling that underrepresented corner. Excited to try it out.
Thank you very much :) But every PHP programmer using Emacs for their work uses PHP Mode---mostly, Web Mode is the only other alternative and is also a fantastic project, which I recommend to everyone who dislikes PHP Mode for any reason---so I am not going to let my illness or even death bring PHP Mode to a complete stop. As the maintainer it is my duty to see to it taken care of after I am gone, because Emacs-using PHP developers deserve that. 
 shuffle($array); echo htmlspecialchars(current($array)); :D
Write code. A lot of it. No, I means like... REALLY a whole bunch. Then keep writing.
Nice guide. Looks like the formatting got a little messed up due to a merge mistake around 2.2 Character Set. 
I'm assuming they plan to add other DBs later? Could be a great tool and also a great example app for showing how to build backends properly in Laravel.
Is this similar to the project called Hangfire on the .NET platform? If so, I'd be interested in trying this to do a comparison between them.
It's open source, once it's released later today, so I wouldn't be surprised at all to see some PRs that allow in other DBs.
It won't be long before other drivers show up
The second best, the first is [RegExr](http://regexr.com).
Is this a bot?
No.
Then just delete this shit, it's useless 
Found one too: `[a-z]* -&gt; [a-z\b]*` - The result of the match is incorrect as it's listed ("[a-z]\*" =&gt; T**he car parked in the garage** #21.)
He said **wordpress shortcodes**. Not wordpress itself.
Is redis persistent? I always thought it was just an in-memory store used for caching. It's important not to have queue content disappear if the server goes down. Or am I missing something there?
IIRC you can configure persistence on disk so if the process fails it reloads in memory the snapshot.
Man this is such a fantastic idea. Can't wait to check it out!
Not everyone need the most scalable thing though (especially for queues). Other constraints can come into play, like which services are available on a platform, which queue system has the best tooling (e.g. an infra team might have a preference), is most configurable, or also which one the team has already experience with.
Thanks, I'll check that out. I can see how redis wins with the ability to do blocking reads, which keeps the CPU load down. The MySQL driver, for example, polls the database constantly and puts a base load on the server, though I appreciate the MySQL driver for queues is really just for development. Other queuing systems are are lot more complex and well beyond many small sites.
The link was posted in PHPHelp, and I found it quite interesting, some tricks I didn't know before. That with social networks is a neat one. The guy's other projects are also interesting, Web Security Quiz: Test your knowledge with OWASP exam questions for example.
Could you elaborate on why the masses should adopt this? I'd imagine that those queues offset computation heavy jobs (like cache building) to task-runners instead of endusers, but that does not really fit to my understanding of redis which seems to be a key-value storage in memory =?
while point 3 in their con list relates to the issue I was referring to with content not being loaded under the source domain, one of their cons seems a bit odd: &gt; but requires a different tag, which needs to be implemented on all AMP pages. Obviously, it takes a lot of time to place this tag and be able to collect and analyze data. I've not used AMP, but if you're using a template-driven CMS/static site generator you'd put it in one place, and I'm assuming that if you're already using google analytics that the AMP-fed analytics would feed into the same dashboard ?
&gt; Could you elaborate on why the masses should adopt this? I'd imagine that those queues offset computation heavy jobs (like cache building) to task-runners instead of endusers Anything that users need to wait for, really. It's such a smoother experience when you don't have to stick around and wait looking at a spinner, but can merrily carry on. Plus it helps with server load if all your UI pages are light - leave the email sending / image processing / cache building / backups zipping and uploading to S3 / whatever to the background jobs. It also lends itself nicely to testing - if your system is set up to defer heavy tasks to the background, supplying a mock Queue manager when doing full page tests will let your suite progress much faster, and will let you inspect the built queue separately, without actually executing it. &gt; but that does not really fit to my understanding of redis which seems to be a key-value storage in memory Redis just collects the tasks to be executed and releases them when it's time. Is it the in-memory aspect that worries you? Redis has [persistence](https://redis.io/topics/persistence) which you can turn on. It makes it a little slower, but safer - and there are two types, RDB and AOF, each of which has its pros and cons as described in the link. Basically, it flushes to disk periodically (or frequently) so even if your server goes down and loses RAM, your queues are safe to a reasonable degree, depending on persistence settings.
Looks like it, I don't know hang fire very well but the UI is similar and it seems to do the same job.
It is the right strategy to adapt the app to the scenario. Can highly recommend percona-online-schema-change, makes even large tables almost a no brainer.
I also have that problem from time to time. My strategy: If i have to look up a snippet more than twice I try to memorize it. That means: For the next couple of days I focus really on memorizing that particular snippet exclusivly. I write it down in my snippet collection. And everytime I have to use it, I write it down from memory before looking it up. Even if its wrong on the first tries. It usually improves from time to time. For more complex snippets which I have to use often I use the snippet-function of my IDE. But I actually try to be able to do most of the basic stuff without being depended on my IDE. 
ok, and the message is? what a mess you created?
Not sure why you got down voted. This is a fact not a personal opinion
I've been using MODX Revolution for years now. It can build anything from very simple sites to huge and complex ones. I really like the CMS, although it is in need of a upgrade "under the hood". The manager interface also needs to be revamped, but overall the CMS is awesome. Having only some experience with WP, MODX opened my eyes to ORM, a good OOP-based API, smart handling of templates and good separation between code and markup. I would give it a shot if I were you.
So... who wants to write a RabbitMQ driver ?
Will Amazon SQS driver and Laravel Horizon make sense together? 
Perhaps you can use Grav as a CMS with some home-made extra handy stuff
There's no need to apologize - I genuinely wasn't sure if it was a joke or a genuine misunderstanding.
&gt; Anything aimed at helping the masses get to know queues gets an A+ in my book I guess you'd like https://github.com/queue-interop/queue-interop initiative.
I [opened a PR](https://github.com/laravel/framework/pull/20148) that adds support of 10+ MQ transports (including RabbitMQ an Amazon SQS). It was closed but I still think it would be a great addition to Laravel. Everybody would benefit from it. 
It's seriously great. LHM is essentially just a ruby/php implementation of percona-online-schema-change and automates a few little things while providing a nice language to express the database schema.
&gt; Also inject your repositories Can you elaborate on this a bit more? I havent seen it done in Symfony.
/u/shochdoerfer, you might not be aware, but this is one of Aramaki's recurring themes: the idea of the Encapsulated Context pattern. Pretty much everyone I've seen who comes in contact with the idea (at least as presented by Aramaki) has the same assessment: it is just Service Locator in small, Aramaki's protestations notwithstanding.
I believe the default install is now persistent and you have to opt-out of the persistence if you don't want it.
Surprised /r/php hasn't shit on this yet.
Why "no" to your own?
I guess there some integrations needed https://developers.google.com/analytics/devguides/collection/amp-analytics/ and another most recent article on AMP https://www.seroundtable.com/google-amp-grow-internationally-24188.html
That's good to know, thanks.
RegExr is good fur very simple things, but regex101 is my go to for 90% of the Regex stuff I need to hammer out.
If you get IntelliJ IDEA Ultimate you can enable the features of all the other ones through plugins. I use IntelliJ to edit PHP, Python, Scala, Java, JavaScript and Typescript in a single environment. 
I mean "no" without a framework. I should being clear in that sorry.
I agree. First learn a different language in the OO model, and it will change how you write PHP. Then later learn a functional language (the coursera functional programming in scala course is a good intro), and you'll notice yourself changing your PHP coding style yet again. Essentially, there's a limit to how much you can improve skills vertically without broadening skills horizontally. The foundation must be wider to put a taller spire on it.
I just downloaded Sublime portable to test. Did you rebind ctrl-l? All it does by default is select up to the new line/beginning of the next line. In PHPStorm by default you just double tap ctrl and use arrow up/down to add cursors, alt+click or use the middle mouse button and drag for multi cursor/column select. I think those are default mappings, I may have rebound them. I've honestly been hard pressed to find something I could do in Sublime that I can't do in PHPStorm. The only thing I can think of was using multiple cursors to add digits that increment on each line, but I rarely used that. Not trying to evangelize or anything.
[Relevant xkcd](https://xkcd.com/1171/)
&gt; And using outdated (for over a decade) idioms like "or die()". Weird blanket statement is weird.
Also it's terrible practice *in specific contexts* in other contexts it may make perfect sense. If you get triggered by `or die()` and don't understand that you maybe should not shout as loud. not directed at you but at your OP
In other languages this situation is usually solved with an Option type (Optional in Java, Option in Scala, Maybe in haskell). But to add an Option type to PHP with type hinting you need generics, and generics are stuck in rfc purgatory. https://en.wikipedia.org/wiki/Option_type 
sorry, but I can't think of a single good thing to say about this
"Cheap" is relative, I usually reach for CraftCMS, but there is a license cost that might put it out of the "cheap" category for some.. KirbyCMS is a nice alternative with a slightly lower price tag, and is flat file, which is nice for shared hosts.
Why would anyone shit on it? Looks like a good tool.
Because it's made by the lead developer of Laravel and /r/php loves to shit on both him and Laravel?
Hate that about that subreddit.. really bums me out to see so much hate on Laravel over there. Edit - seems in my morning pre-coffee state I though I was in the Laravel sub.. this must be what dementia is like.
I think I meant Ctrl Shift L, sorry! If you select a few lines, it adds a cursor on each one. Makes quickly adding multiple cursors very easy in my opinion. Me, I'm not trying to evangelize either, I like Sublime a lot but it might not be for everyone. It's saved me a lot of time. I think software developers should know at least one text editor very well, but whether or not that's Sublime or PHPStorm or Vim or something else is not for me to say.
Judging by the example he gave it is likely that he hasn't gotten to exceptions yet.
Ahh yea, I just tried it and I see what you mean now. Visual Studio Code has taken over the 'text editor' spot in my work flow. There's a few things that VSCode still needs IMO but they're adding features at a pretty solid rate so I'm hopeful.
Business logic in controllers is a well-established anti-pattern exhibiting MVC misuse.
"Over there"? You posted this on /r/PHP.
Wow, my mistake. I edited my post.
This is actually really exciting :) I didn't think it would ever happen but I am glad it did!
It's all good, happens to everyone.
What's a good alternative to a whiteboard test? A take-home coding assignment?
I did the free 30-day (or similar) license about a year ago. The problems I had were that the C/C++ plugin was incompatible (old and not updated) with the newer version of the IDE, and there was no support for Haskel or Forth. I could live without Forth (FreeBSD uses it to bootstrap itself from the second-stage bootloader). But there are a lot of libraries/frameworks that put out Eclipse plugins but don't have the manpower to do so for the other popular IDE's (so Netbeans, Jetbrains, Visual Studio get short-shrift). An example is Qt framework for C++ (the KDE desktop is written in it). The $240 a year subscription price turned me off. I'll pay if a tool is better - Photoshop is worth it to me, but I didn't see the advantage in the short trial period. Sometimes people complain about Eclipse being slow, but it's doing a lot. On an 8 core OC'd, 64GB RAM w/ SSD machine it's snappy. Can you share what features you like in Jetbrains IDE's? 
No matter how much I read I am still left asking "Why?"
they are asking stupid questions. Programmers solve problems not fully memorize an API.
well that's b/c the order changes depending on what you are doing. array_filter vs array_map
What kind of anti-pattern is *single-server app*?
I think the closing of the PR simply has to do with how Laravel development is done. They're very close to tagging 5.5, and having observed Taylor for a while now, it's just that they want sort of a clean 'slate' when tagging. (also, a new dependency is always risky, it's quite a big PR and there are no tests at all)
Nice job with getting your project out there. It would take quite a bit of convincing for me to use this. Now for the roasting. I was looking for a quote by someone like "Everyone should make their own framework once in their life, and then throw it away" I'm starting to think we need one of those Slashdot style checklists every time someone comes along with a new alternate syntax, new template system, etc. I started this as a bit of a joke, but I'm not sure I have the skill to complete it. Your new project proposes a: (*) new language syntax (*) introduces a pre-processor approach to changing php. Your idea will not work. Here is why it won't work. (One or more of the following may apply to your particular idea: (*) No editor support ( ) Requires another language to work (javascript, ruby, c, c++, go) and the following philosophical objections may also apply: (*) Another project has the same or similar name (*) This is also a framework (*) Contains yet another templating language ( ) Thematic naming of methods and classes ( ) Lack of static analysis tools ( ) Incompatible with PSR-2 ( ) Ideas similar to yours are easy to come up with, yet none have ever been shown practical ( ) Lack of documentation (examples, tutorials, ( ) Why should we have to trust you and your servers? (*) Incompatibility with open source or open source licenses ( ) Feel-good measures do nothing to solve the problem ( ) Killing us this way is slow and painful Furthermore, this is what I think about you: ( ) Sorry dude, but I don't think it would work. ( ) This is a stupid idea, and you're a stupid person for suggesting it. ( ) Nice try, assh0le! I'm going to find out where you live and burn your house down!
Wordpress.
Good on them. I've long considered Joomla to be the worst of the three, both in code quality and security. But it's also been a long time since I've actually looked. Would there be a reason to take Joomla seriously again? Or is it still just a hot dumpster fire of bad code?
I dislike a lot of things about Laravel, but as _user_ of the software, I don't really care what it's written in, as long as it works well. I hate JavaScript, doesn't mean I hate all the features using JavaScript as _user_ of a website/application
You should be able to send requests through to fpm with something along the lines of: fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT $realpath_root; And symlinks will be resolved prior to being sent to FPM, resulting in FPM's opcache being tied the real file locations, no manual opcache clear required. Apologies if this is what you're already doing and are still experiencing these issues - it's worked flawlessly everywhere I've worked doing multiple code deployments a day.
If the end result is static html, css, and javascript, why requirement for it to be PHP-based?
Well you could just use PHP
The editor itself needs to be PHP because thats what our agency codes with. WE just want a simple CMS that generates static code.
You can emit a save command and the inmemory store gets saved to a file, i use this for cloning the production state into my local dev env to test with real data
I think the white house used Drupal for this... But this was so time ago... 
We use Jigsaw and that works like a charm. http://jigsaw.tighten.co
https://github.com/ziadoz/awesome-php#static-site-generators Although, honestly, I would much rather use [Jekyll](https://jekyllrb.com/) but to each their own.
If I was interviewing someone who refused to take a whiteboard test, I'd immediately move on. The point of a whiteboard test is to watch their thought process, it doesn't matter if they mix up haystack and needle, if the functions are wrong, etc., pseudo code is just fine, just make sure I know what pre/post conditions are for functions that're supposed to be like the std lib functions if it's not obvious. What's important is the problem solving process. The only alternative I can think of is to have them put their IDE on a TV or something, but I'm not sure that that has the same effect. If you do do the whiteboard test and they're basically knocking off points for pedantic stuff like syntax, argument ordering, etc., then that's a red flag for sure.
OP? You ok?
As far as security goes see for yourself with the list of [Joomla! CVEs](https://www.cvedetails.com/vulnerability-list/vendor_id-3496/product_id-16499/Joomla-Joomla-.html). 17 in the past year; execution of files with various .php style extensions, sql injection(2 months ago, a bunch of XSS, and various content permission oversights.
&gt; "Lazily" means nothing is loaded until the exact moment it has to be. For me - and I might be wrong, as you keep telling me over and over again - "lazy" means a proxy instance that is returned right away which will internally instantiate the real dependency when the first method call to the proxy is made. See [ocramius/proxy-manager](https://ocramius.github.io/ProxyManager/docs/lazy-loading-value-holder.html) for an implementation. And that would require to load all the classes right away to be able to build the proxies as they naturally have to extend the classes. &gt; But controllers are an exception to this: together they form a single cohesive unit, but they have very heterogenous and ad-hoc dependency needs, often dependent on runtime conditions. Ad-hoc as you do not want to instantiate the all the required dependencies needed by your controller when constructing it. Simply due to the fact that your controller does too much and needs to many dependencies, right? Sounds like a huge code smell to me. Ever thought about transitioning to the action classes way? That would solve your problem pretty easily, just have a look at the [ADR](https://github.com/pmjones/adr) pattern and thank me later. &gt; "Magic" leads to poorly architected, amorphous, fragile applications with uncontrolled, implicit interdependencies and hard to analyze object graphs. I am sorry for calling it magic. I just meant the logic involved to retrieve the dependency and yes, this implies the get("string") calls which as far as I can tell is no magic at all, just a simple method call. &gt; This will pass, just as it has passed in the Java community [...] Has it? Isn't the Spring Framework a thing any more? Did the Java community really move away from JavaConfig? I might be wrong but those "problems" you mention over and over again with the get() call never existed in Java due to the support of generics.
I recently replaced a Joomla 3 site with Symfony 2.8. The Joomla code wouldn't even run on PHP7. It might have been the add-ons, but, it was definitely a dumpster fire.
A static site generator and a static site CMS aren't quite the same thing. A generator it's covered by a lot of projects. A CMS? Not so many. You could look into converting WordPress into the backend CMS for a static site generator package.
Is WYSIWYG editor a req?
I'll probably live ;)
I used [Sculpin](https://sculpin.io) not too long ago and it worked pretty well. 
&gt; For me - and I might be wrong, as you keep telling me over and over again - "lazy" means a proxy instance that is returned right away which will internally instantiate the real dependency when the first method call to the proxy is made. That's not what "lazy" means. Lazy means just something is executed on-demand, vs. "eagerly" (as early as possible). A proxy can lazy instantiate its delegate, or it might not. These are different concepts that may play together *sometimes*, but aren't the same thing. After all, if I wanted to say "a proxy" I would've said "a proxy". &gt; Ad-hoc as you do not want to instantiate the all the required dependencies needed by your controller when constructing it. Simply due to the fact that your controller does too much and needs to many dependencies, right? Sounds like a huge code smell to me. I very clearly said I treat a group of cohesive controllers as a single unit, so I can unify their constructors, simplify (and speed up) my code considerably, avoid pointless reflection abuse, and maybe most important of all *gain control and overview over what my controllers use together, as a group*. By using reflection you have lost control over what your controllers ask for in their hundreds of unique constructors. I haven't lost that control. And I use it to guide my application architecture. It's funny to call this "a code smell" especially compared to the reflection-driven chaos you seem to prefer. So it's not what about *one controller* does. It's what function they fulfill *together as a unit*. No single controller is a unit on its own. It can't perform anything useful by itself. Also, see the code example below. &gt; Ever thought about transitioning to the action classes way? That would solve your problem pretty easily, just have a look at the ADR pattern and thank me later. It doesn't solve the problem of conditional dependencies, because the condition is not merely "which action is called". For ex. // Eagerly if (!$cache-&gt;has($id)) { $item = $repository-&gt;get($id); } else { $item = $cache-&gt;get($id); } // Lazily if (!$cache-&gt;has($id)) { $repository = $this-&gt;context-&gt;getRepository(); $item = $repository-&gt;get($id); } else { $item = $cache-&gt;get($id); } I didn't instantiate a repository I don't need if the item is in cache. Does ADR solve this problem? **No**. Also does ADR solve the problem of needed slow, fragile, implicit "magic" for your construction calls? **No**. &gt; I am sorry for calling it magic. I just meant the logic involved to retrieve the dependency and yes, this implies the get("string") calls which as far as I can tell is no magic at all, just a simple method call. No I think "magic" is a quite apt name reading constructor arguments at runtime via reflection and resolving parameter blindly by type. And you didn't respond to any part of my comments where I asked you to defend this abuse of reflection. You're instead trying really hard to invent a "code smell" in what I propose, that isn't there.
&gt; Would there be a reason to take Joomla seriously again? Or is it still just a hot dumpster fire of bad code? I previously analyzed the built-in security features of Joomla, WordPress, and Drupal, published [here](https://paragonie.com/blog/2016/08/on-insecurity-popular-open-source-php-cms-platforms). A brief checklist is available [here](https://paragonie.com/blog/2016/08/cms-airship-simply-secure-content-management-now-available-in-aws-marketplace#compare). That was 11 months ago, however. Joomla has moved forward with prepared statements by default, and since 3.5 was already using Defuse's library. There's a lot of different ways to interpret dumpster fire in terms of security. For example: * OpenCart *is* a dumpster fire because their malevolent dictator for life screams loudly and angrily when someone points out a security vulnerability. See the history [here](http://www.openwall.com/lists/oss-security/2016/01/19/16) for a detailed example. * WordPress can be called a dumpster fire because they'll continue to support PHP 5.2 long after I'm dead, they insist on using the misnomer "[responsible disclosure](https://adamcaudill.com/2015/11/19/responsible-disclosure-is-wrong)" (which is a hostile stance to take against security researchers), and Mullenweg has too much say in the direction of the project (and too much ego to boot). I wouldn't be so quick to condemn Joomla, however, given that at least *some* of their core contributors are dedicated to making things better. Michael Babker didn't become a core contributor until [a few years ago](https://github.com/joomla/joomla-cms/graphs/contributors), and the bad code was being written for at least 6 years at the time he joined. I don't know who the other folks are who are trying to push Joomla forward, but the story's likely very similar. I'm not in a hurry to endorse Joomla, either. It's nearly a million lines of code and the extension ecosystem likely needs a purge. There's a lot to dislike. However, I don't believe it's unsalvageable. I would say that there's hope for Joomla, but they need help. Their adoption of Defuse's library, random_compat, and sodium_compat was likely the result of the existing deficits being brought to their attention. A winning strategy for making Joomla better will require fighting on three fronts: 1. Getting core contributors to learn appsec. 2. Getting more security researchers to study Joomla's code. 3. Wide-scale ecosystem cleanup efforts (which includes making sure n00bs find better tutorials). If you're considering going with Joomla or some other product, choose your own adventure. I might be a security consultant, but I'm probably not *your* security consultant.
Thanks for your well put reply.
&gt; Joomla! CVEs. 17 in the past year And Wordpress has 29 this year alone, what's your point? Not sure about Drupal, the only page I could find listed just 1 from 2014 which surely can't be right. 
What's my point? My point is.. Joomla! has 17 CVEs in the last year. That's literally my point. I couldn't give two shits about comparing Joomla! and WordPress either, what's your point? Edit: [Drupal](http://www.cvedetails.com/vendor/1367/Drupal.html) if you're interested
October CMS? Is that considered to generate static files? But with a CMS back end?
I use whatever PHP framework I like to build the site and then turn the site into static HTML by crawling it with wget + a cron job that checks for new content every 30 minutes
&gt; If I was interviewing someone who refused to take a whiteboard test, I'd immediately move on. An interview is not supposed to be a battle of egos. Notice I didn't say "if someone asked me to do a whiteboard test, I'd immediately move on". I said I gently decline and provide *alternatives* that *better represent my skills and day-to-day experience*. I can also explain my position, not merely go psycho on them. The purpose of an interview isn't to bend candidates to your will over trivial matters like "use a whiteboard and a marker, instead of a computer and a keyboard". If you do that, you're just selecting for "I'm desperate and I will kiss ass to get this job" over "I know what I'm doing and I want to show my best". &gt; The point of a whiteboard test is to watch their thought process, it doesn't matter if they mix up haystack and needle, if the functions are wrong, etc., pseudo code is just fine, just make sure I know what pre/post conditions are for functions that're supposed to be like the std lib functions if it's not obvious. What's important is the problem solving process. If what's important is the "problem solving process", then why not give people a computer and maybe some time alone to figure out a solution (you know, the way they'd be spending 90% of their time later on), versus putting them in front of a whiteboard to *draw code* for you with a marker? How is the whiteboard helping you here? All it does it make the candidate slower, more stressed, and unable to perform at their best. First, a whiteboard is not a text editor. - I can't refactor code with a whiteboard. - I can't find and replace. - I can't cut a line and move it elsewhere. - I can't get autocomplete and built-in API reference, code generation etc. - I can't *scroll* a whiteboard. What kind of interesting problem can you really solve with the available real-estate here anyway? Fizz-Buzz? A whiteboard is just about the worst way to write code there is. Second, a whiteboard is not the Internet. - I can't do research. - I can't look up documentation. - I can't reference algorithms, techniques and solutions. - I can't download and use dependencies. All of those are essential tools in the toolbox of a modern engineer. And if you fear "but what if they just go copy some code off StackOverflow like any beginner can do", then maybe the questions you're asking and the problems you're presenting are too basic and trivial to truly demonstrate *thought process* and *problem solving skills*, as you wanted. If someone doesn't know what they're doing, they still will mess up in countless ways, even if you give them access to the Internet and a modern dev toolkit. Or if they produce great code and great solutions when given the Internet and a modern dev toolkit, then you have nothing to complain about. &gt; The only alternative I can think of is to have them put their IDE on a TV or something, but I'm not sure that that has the same effect. And what "effect" is that? A whiteboard is a great tool to discuss architecture, concepts, and draw diagrams. Put me in front of a whiteboard to do that, and I'd happily engage. But not *writing software*. To your credit, you do say you accept pseudo code, and you wouldn't care about the small details, but here's the kicker: the candidate can't possibly *know all this about you*. And so they'll stress about syntax, arguments and function names, and be unable to truly show their problem solving skills, because you're deliberately setting them up in a "fish out of water" setting, and asking them to perform the same way as if they had access to all conveniences a developer enjoys daily. It's just a poor way to judge and interview people, that's all.
I ask people for their GitHub accounts (or to email me any toy project or open-source project they've done). I spend some time with it alone, and write down points of discussion. Then when they come, along with conceptual questions, I ask them to describe an exciting project they've been a part of, what problems they've solved, what they've learned from that experience, and then I bring up their code and my remarks, and they can explain their thought process. In a free conversation you can learn a whole lot about people. And the work they've spent days, weeks, months doing, is a much better way of seeing their capacity, rather than in 10 minutes in front of a whiteboard. Some don't have code to show, then I give them a very well described problem to solve at home. Like a tiny project, described with deliverables, required features, etc. Then they email it to me, and I do the same as I would do with GitHub code. Some people don't make it to an interview once I see their code. If I see something terribly sloppy, it's clear we can't work together. It's also fairly easy to spot plagiarism - nobody can hide from search engines. So it's a good measure. And don't forget, you're not bound for life if you approve someone on an interview. There's a test period (1-3 months) where they'll have all the time to shine or embarass themselves. It's a process...
Unless you're sending this comment from 2003, nope, nothing weird about it. There's no saving grace to "or die()".
We did 2 big sites on Statamic this year - it's loosely laravel based and shares some of the same people
`ob_start();`
Also, the controllers are doing too much. Handler classes can help offload some of the work and allow for dependency injection. https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/examples/RssHandler.php
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [FriendsOfSymfony/FOSRestBundle/.../**RssHandler.php** (master → 6fed261)](https://github.com/FriendsOfSymfony/FOSRestBundle/blob/6fed261f4e41f7dfbe05dda65ce9f3e038ed809f/Resources/doc/examples/RssHandler.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkrp81w.)^.
I tried a lot of them and chose Kirby, it was a good mix of Twig and Yaml.
I found the culprit. It seems the files used to generate the files were corrupted somehow, I fixed it by replacing them with un-corrupted ones. Thanks!
I found the culprit. It seems the files used to generate the files were corrupted somehow, I fixed it by replacing them with un-corrupted ones. Thanks!
They do? This sub used to hail it as the second coming of jesus. 
&gt; &gt; You may also join us on at #phpmentoring on is queue example is when i click send email and it tells me yay we sent it but it actually delayed the sending after i got redirected ? 
The white house uses Drupal directly. Not as a static site generator.
My question is ... how does a library with 9 stars on github rate an article?
There are no errors, just a warning for headers.
Don't output anything before the Location headers.
This appears to be Apache on Windows? Check the Apache conf file and see what modules it's trying to load. One looks to be borked.
I'm planning to start using gRPC/protobufs, and this article got me even more excited. But where do you typically store the .proto file in a microservices-oriented architecture? In the git repo of the gRPC server/microservice? In a shared "protobufs" repository? Because when you create the php/javascript/java/go/... generated code for your new project that calls the microservice, you need to have access to the microservice git repo's proto files...?
&gt; The "or die()" idiom is unique to PHP Perl has die(): http://perldoc.perl.org/functions/die.html 
While it's not a static site generator, PicoCMS is a PHP-based static site CMS that uses Markdown for content management &amp; Twig templating engine for layout. There is more information here - [PicoCMS](http://picocms.org/). Currently using it on a client's build &amp; it's been super simple to dev for. Hope this helps 😀
What's this?
I'd say either Kirby or Statamic. 
When was this framework released?
For some my websites I wrote my own engine. It's not a CMS, because I use IDE to edit content. It's fast and easy to use. I'm happy with it. Really. But. But I don't think everyone should do the same. It's not as simple task as you could think it is after reading tutorials and blogs. I suggest using some popular CMS for a website. I would recommend to use WP or ModX. If your company requires some custom stuff - use a framework and put it on a subdoman. This will allow to maintain a website and edit its content by a single worker with even not so deep html-knowledge. And in the same time, you'll be able to develop a complex custom whatever-you-want on your favorite framework.
Grav has been a real pleasure to work with. [GRAV](https://getgrav.org)
Check out Grav. https://getgrav.org. And Hugo https://gohugo.io/.
Best PHP Developer in Chandigarh
Second jigsaw. Used to be on sculpin, but pace of development slowed. And I really appreciate blade frontend in jigsaw.
Why not just use autoincremented ids?
&gt; Title says it all! No, it's not. Why do want to use static site generator? You want to use static site generator. OK, got it. But. Using a static site generator (SSG) is a solution for some problem you are solving. You decided that SSG will solve the problem, will do the work. But it is your vision and your decision to use SSG as solution. That may be the best solution, or it may not. To understand it and help you really solve your problem you should name the problem. So, what are you trying to do and why did you decided that SSG will solve it? Or maybe you just need some caching solution like properly configured nginx in front of your apache and so on.
https://www.nearlyfreespeech.net Or digitalocean
It can be an example, but not all delays are queues. Could be just their email server spinning up. But the scenario matches, yes.
dll on Ubuntu? But how?
Check Stackoverflow, this issue pops up, every so often. If I recall correctly the issue is, that the Apache process is run under a different user. Check if Apache has the rights to access all the vital files. These should be /etc/odbc.ini, /etc/odbcinst.ini and /etc/freetds.ini. The paths are correct for centos, but should be the same for ubuntu. 
@Delta9Tango is right - you can't echo anything before the `header` function. Also you can configure your Apache's PHP client, disabling any errors or warnings to show up in the `php.ini` file.
Seems like you are doing full page caching. Why not just use Nginx FastCGI cache or Varnish?
If you have a good sysadmin knowledge and know how to create Lamp Stacks then you should go for DigitalOcean or Vultr Servers. Otherwise opt for Cloudways managed PHP 7 hosting, You can Create complete stack with 1 click and All the perks like SSL, GIT, Composer, and PHP services like Memcache, Redis, Elasticsearch etc are already pre-installed. So you don't need to worry about servers. 
A static site generator like jekyll or something more or less converts markdown or some other templates into raw html. PHP/ruby(in case of jekyll) does not play any role in final output. It is only used at compilation time. Now that said there are a couple of ways depending on what you need. **Static assets output** Just build a php site and make wget requests to get all static content from it. This is just a hack and i wonldn't say to use it. **Complete caching** Use varnish for this . and its more about caching in this case as opposed to a static site generator. **Build one** This is the first time i have looked at static site generator in a specific language so not sure about PHP , but the most used is for sure jekyll. You can always build one on your own and rather than using apache mods for output send that to files. Hope this helps you out :)
Grav is not a static site generator. It's an awesome CMS though.
Sorry, but that's no reason for closing. It should stay open and tagged for inclusion in a later version.
I have created one like this in Slim framework that uses a middleware to Cache the generated HTML. It's simple and just works. No need to manually generate the HTML once I write the article.
 ( ) I have made up this checklist and can't wait for the right context to use it.
I was willing to add both tests and doc but after I got an approvement. It adds a dependency to a contract not an implementation of any kind. It is like you are adding a dep to psr/log in your project or framework. Not that risky IMO. Also, I would not consider 300 line of code as a big PR). 
Perl has died. I'm talking about languages that people use to write software, and not just a 5-line CLI script once a year.
redis is better then using database for queue jobs but i would like a proper implementation of amqp, so that i can send jobs from laravel to something else. Im using custom amqp queue because the laravel app needs a way to exchange jobs with other apps writen in other languages. Also i need rpc for some of those things. the problem with laravel was, i havent played with it in a while, is the payload. The body contains all the info needed to execute the job inside laravel but its a problem if you want to consume it from something else then laravel. I want the body to be the body and thats all. 
I guess we'd have to throw `headers_list()` and `http_response_code()` somewhere in there as well ;-)
**P**latform (for) **H**ttp **P**rogramming
https://www.delimiter.com
&gt; OWL Web Language features a JavaScript-like syntax and compiles to PHP, promising more security and safety So instead of writing in JavaScript (Node) or PHP, I can write in JavaScript-like syntax and compile to PHP. I mean I'd be OK with this, if the project had epic IDE support. But there is none. OWL can't compete with JS or PHP at this point... Regarding the security claim, security depends on the APIs the framework exposes. Security is not produced by changing the syntax to "JavaScript-like".
Joomla has a bad reputation when it comes to security. This is a big step forward.
I actually use this for legacy websites that are requiring frameworks, CMS's and PHP versions that are no longer supported. I no longer make websites for small businesses but I still maintain the ones that I built over the past 20 years. When the software that was used for a client site becomes unsupported I give them the choice between having a new site built, or turn the existing one into a static version and move their administration section behind HTTPS basic auth, with the catch that their content changes are going to be delayed. Usually these sites are very old and the content changes rarely so the owners are fine with this.
People don't shit on Laravel, it's mostly a great framework. They shit on some of the ridiculous things done using Laravel. They also don't shit on Taylor in general, they shit on the dumbass things he says and does. Taylor has an issue with criticism, even when it's justified. He also seems to believe that something being testable is the be all and end all of good software engineering. That being said. This looks like a great tool.
Webfaction is good if you just want a hosted account. Otherwise, Digitalocean, Vultr, etc. if you want a VPS. (If you're not sure what you want, Webfaction is a good starting place.)
All the others probably have good modules to add it afterwards.. Never again Joomla for me.. 
It's not streamed in the example, it's stored in `$text`
What book is this from?
The only "interface" between myself and PHP that I'd be willing to use is the one where my thoughts would be wirelessly transferred to the IDE, but I have a feeling that it will not be announced here for quite some time. Until then, `&lt;?php echo "Hello World, what's up?"; ?&gt;`
Kirby still doesn't actually use a template engine though does it? Last time I saw, they suggested using native PHP for rendering templates. 
Digital Ocean($5 / m, you get a $25 free "credit" upon registration, first time) and ServerPilot (Has free plan). This will give you an excellent jumpstart into the modern world of hosting, the time of CPanel and shared hosting is long gone, embrace the future!
However Joomla is still a piece of shit that should be killed off. **Bring the downvotes peasants** 
This is probably the correct strategy, you can eliminate some of the code complexity by using DB triggers for two-way dual-write but adds to the complexity of the DB schema
I've used Sculpin in the past but eventually stopped using it because of compatibility issues with PHP7. I'm not sure if those issues persist, but just thought I would mention it in case anyone's looking in to it as a solution. It is a great tool, otherwise!
&gt; `"$text"` Ugh
I don't see the problem with documenting event names with class constants. This is how Fabien recommends it also. Whether this breaks Open-Closed Principle is an open debate, and I think many people would say this scenario is not applicable. Events should be named something simple and relevant, like 'product_update', or 'comment_insert' , not '\Acme\AppBundle\Event\MyEvent' . 
uhhhhmmm cli script that just dies with an exit code. There is more then just webrequests or wherever it doesn't make sense ya know. Uninformed blanket statement are ridiculous and harmful. And yes shocker. People are writing cli scripts in 2017 too :O Even without this. A book targeted and beginners explaining the bare basic is a good thing. People tend to get scared away otherwise and just lose interest. So please get off your high horse.
Thanks, but I'm talking about anonymous users who haven't yet signed up. 
Did you mean to post this on your alt account?
A small personal project of mine that ended up growing into something much, much bigger is Tapestry, a static site generator for PHP that uses the plates template system: https://www.tapestry.cloud/ I think its the _best_ but I am obviously biased :)
Again with the uninformed nonsense. There are several big sites running on perl. And there are even more where perl is an actual part of their tech stack.
Yep, that's exactly what we are doing. Here's the script we use as post-checkout: #!/bin/bash # https://gist.github.com/gurglet/1780139 # Git post checkout hook. # Reminds you of South migration changes when switching branches. # Can be useful when you are when you are testing out a branch from # someone else that requires migrations. # Put the file in .git/hooks/post-checkout PREVIOUS_HEAD=$1 NEW_HEAD=$2 BRANCH_SWITCH=$3 if [ $PREVIOUS_HEAD != $NEW_HEAD ]; then # Start from the repository root. cd ./$(git rev-parse --show-cdup) # Check if any migrations have changed. CHANGED=`git diff $PREVIOUS_HEAD $NEW_HEAD --name-status | grep "^M.*composer.lock"` if [ $? -eq "0" ]; then echo -e "\033[7;31m Beware. composer.lock is changed. Update by running:" echo -e "\033[7;31m composer install" fi # Check if submodules have been changed MODULES=`git diff $PREVIOUS_HEAD $NEW_HEAD --name-status | grep "\.gitmodules$"` if [ $? -eq "0" ]; then echo -e "\033[7;31m The submodules in this project has changed. Update submodules by running:" echo -e "\033[7;31m git submodule update --init" fi fi 
fluff, fluff, fluff, fluff, fluff etc., fluff with anecdotes &amp; no stats, list of php7 fluff, fluff, fluff. an article on the impact of a major PHP release on a widely-used ecommerce application would preferably be less fluff &amp; more technical details, benchmarks rather than anecdotes etc.
reported this bullshit as SPAM
Too bad their site isn't accessible due to a cert error :S
You can store user sessions in separate table, just make a nullable FK to the user/client table.
Correct but it does run on PHP.
I didn't create this, I just saw an article about it. I just addressed my comment as if the author might at some point come across it, that and the checklist starts with Your. Probably a poor choice on my part, ¯\_(ツ)_/¯
I can't really take credit, super old checklist from Slashdot, I don't even know how old it is anymore, 15 years? 
Mmm cakePHP
We spend _way_ too much time on a 0.1 release, with the result that the changeset is quite large. 3.4, 3.5 will arrive much quicker, and we're already well underway with the work on the big four point oh, too.
Do you know if it can support some sort of multi-lingual structure? 
I think this is pretty common knowledge for most of the "Symfony People" I talk to. The article doesn't mention it but I would recommend doing it for the dependency injection as well. A lot simpler to use: $this-&gt;get(ExampleInterface::class) than trying to name everything.
I'll be testing this later today!
You can do basic things with the firewall and access control: https://github.com/symfony/symfony-demo/blob/master/app/config/security.yml#L46. There is other ways, like the voters, but it's much more advanced and overkill for your case from what I see.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [symfony/symfony-demo/.../**security.yml#L46** (master → d1ad7f5)](https://github.com/symfony/symfony-demo/blob/d1ad7f5a6bd4a9f20492c82aa452525ffc4d4b63/app/config/security.yml#L46) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dksmak8.)^.
Bolt is a pleasure to work with. I'm really looking forward to this update. 
I think it makes most sense to store .proto files together in a separate repository, and generate the gRPC clients into the project repositories. e.g. Repo: Protos - Service1.proto - Service2.proto Repo: MyPHPApp - GrpcClients - - Service1.php - - Service2.php Repo: MyNodeApp - GrpcClients - - Service1.js - - Service2.js
Ubuntu 12.04
CData ODBC driver
I do not understand how anything on Ubuntu could be trying to load a .dll file/module.
What about Listeners? http://symfony.com/doc/current/event_dispatcher/before_after_filters.html
Y U NO COMPOSER
If you are looking for a middleware like think take a look at listeners, it's basically middlewares.
I know that I cannot output anything before headers. I only echoed to see what is going on, what error is coming up. Sadly, no errors occur
Ndiswrapper let's you use a windows driver for wifi on Linux In this case mkbundle lets you run mono apps on Linux
Lot of awesome work, thanks! :D How you guys feel about the looming death of Silex told by some https://www.reddit.com/r/PHP/comments/6mnlkh/silex_is_dead_or_not/dk4ao8g/ ? Maybe there is someone within the Bolt community that wants pick on the maintaince of Silex? :)
`die;`
Why do you not follow the PSRs?
I hadn't seen this before. Looks like it'd be great for intranet type apps, especially.
&gt; i havent played with it in a while It's still the same problem. Personally, I don't mind the payload approach; that is the same how Resque does it. But the current implementation uses native PHP to serialize stuff and has too many code dependencies. It should just be scalar arguments be possible, basically what JSON can encode, for interop. I'm facing this problem next and to make this work, I will have to create a HTTP endpoint for other languages to enqueue jobs I want to run it laravel triggered from the outside :/
Minimalistic post.
You know, just once, I'd love to read one of these comments about any of the PHP projects that people just snarkily comment "kill it with fire" on and understand WHY they think it should be killed with fire. Constructive criticism can go a long way.
Probably the extensions in use on that site. I personally had Joomla core PHP 7 compatible before PHP 7's first alpha release (so in all fairness, if it was a release before Joomla 3.5, odds are it wasn't going to work right). Unfortunately there are still extension vendors who can't or won't update their code for compatibility or there are a plethora of abandoned extensions still in use on sites that will one day break fatally and users will just downgrade their server architecture instead of replacing the bad code.
Symfony had "middlewares" before they were hype, they're called event listeners.
Good question, I'm not too worried about that, for two reasons. On the one hand, I don't see Silex going anywhere, anytime soon. True, development has slowed, but there was a 2.2 release just last week. Also, I'd almost consider Silex "done". If they (and mostly Fabien) kept adding features, it'd no longer be a _Micro Framework_. On the other hand, we should consider the reason why we chose "Silex + Symfony components" over "Full fledged Symfony": That was because Silex allowed us to structure the project the way we thought it was best suited for users with different levels of expertise. With the upcoming [Symfony Flex](https://symfony.fi/entry/symfony-flex-to-enable-rad-rapid-application-development), coming with SF 4, that reason might become invalid, and we might move away from Silex. We'll know more around November, when SF 4 will go in beta. 
Thanks! :-)
You should! Feel free to join us on Slack or IRC, if you have any questions / issues. 
&gt; queues offset computation heavy jobs As /u/bitfalls mentioned, anything that the user has to wait for. And possible doesn't need to see right now. Example: I'm a dev on a product where in-app you can rate things. What needs to be done immediately is to represent the rating (obvious). But there may be other pages showing accumulations of this ratings (e.g. for user profile). You want these things updated, but they don't need to be up2date in the very microsecond. I wouldn't this consider "computation heavy" but it isn't something the user need to *wait for right now*. So I just spawn a background job, `["App\Job\UpdateProfileRatings", 123]` and be done with it. By having multiple "worker" processes for a single queue, you can nicely parallelize these kind of things. &gt; redis which seems to be a key-value storage in memory Yes, and it additionally has good properties for a queue. With RPUSH/LPOP commands and due to it's single threaded nature (regarding processing of connections) it works very well with a) many queues b) big queues and c) many multiple workers fetching jobs from the same queue. Of course it needs more knowledge to handle the failed jobs, don't loose jobs, etc. but the basic infrastructure redis provides is there =&gt; https://www.google.com/search?q=redis+queue
&gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. Same goes for CMS'es. People hate Joomla, people hate Drupal, people hate Wordpress, people hate the crappy CRUD editor they've built themselves. Basically, people are horrible. Don't take it personally, because it'll eat you up. I bet /u/TheHelgeSverre is just parrotting people saying this before, and hasn't taken a proper look at Joomla in the last couple of years. 
Here's part of the problem we have in Joomla. And this isn't to knock on anyone, so I'm clear up front. But when it comes to pure code and architectural related changes, it is actually pretty difficult to get those tested, reviewed, and merged to core. A lot of contributors aren't technically savvy so the things they are testing are things they can see immediately in the UI (either an obvious layout change or a simple "click here and make sure this isn't broken" instruction). So it's a bit more of a painful process to get true code related improvements (i.e. prepared statement support, or the cryptography API additions) worked through the process. I will say though, at least we make the effort, unlike some other projects who are more concerned with their Squarespace knockoff editing experiences. As for taking it seriously, it's all going to boil down to what made you write it off in the first place. For a lot of people, no amount of change is going to matter. For a lot of people, they continue to base their opinion on a release that has been unsupported for over 5 years now and refuse to even look at how things have changed. So, there is no answer to that question that's going to be "good".
We'll see how long this push I've been on can last. Between being a coordinator for 13 different teams, masochistically volunteering to be our 3.8 release lead, and my day job, the burnout factor for me is definitely going to reach a point of no return sooner than later.
&gt; I don't think you can use a single Jetbrains tool to do even just Java, C++, PHP, and Javascript. I've "heard" that with the Ultimate edition you can install any language you want (it's all plugins). But I never tried and read that it may not always be the latest version. I just downloaded the latest Eclise PHP version and gave it a try. The dark theme doesn't look well though: http://imgur.com/a/OA6Zd I tried to use the find method command (shift-cmd-m) but it seem to only work from within the editor window which is a shame. If the focus is in the file view or any other view, it doesn't work. This is especially bad if you just closed your last editor window. I can't make the shortcut work without actually being in an opened editor window :-/ The scrolling in larger files feels a bit choppy. In PS it's very smooth but in Eclipse it feels like it's only 15FPS (or so, sorry for the bad description). One great shortcut I immediately tested because I still remember it: CTRL-m. The single best thing I remember about eclipse. PS doesn't have an equivalent to that. It has Zen mode but it's just not the same. The find method/find resource commands don't seem to support fuzzy search? I type "elbase" and expect it to match "ElasticSearchBase.php" but it doesn't, the order of character have to be exact. I see I can use wildcards but ... I tried the git integration, switched branches forth and back and it seemed to crash, prompted me to send an error report. In PS, when I have a variable ending in `s` and use it in e.g. `foreach` it will suggest to the name without `s`: http://imgur.com/a/7GZ5m This.is.so.useful. I give up now on Eclipse. It immediately gave me back experience for which I left it many years ago (back to vim then; I didn't knew about PS yet 🤷‍♀️). Eclipse looks solid and feature-rich and may have a great technical stack below but my impression is that the IntelliJ platform is years ahead. It's the small details that matter and, I kid you not, those `s` things speed up my development. I hope I don't sound annoying. I tried to be honest but speaking frankly, I'm definitely biased so all I said is probably not worth much. Thank you for mentioning Eclipse though, it was still interesting to try it out!
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/pHdy2vq.png https://i.imgur.com/sNiBVkB.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[state_of_imgur](https://np.reddit.com/r/u_imguralbumbot/comments/6i1huv/imgur_has_gone_to_shit) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dksyw2z) 
https://stovepipe.systems/post/symfony-security-roles-vs-voters
Not using a framework isn't analogous to what this person did at all. Not even close! A framework was a wonderful idea to get things done in the pre-composer, post early-PHP world. The problem is you end up with something like CodeIgniter, or worse Magento, that doesn't just make a chicken sandwich, but adds mayonaise (not everyone likes mayonaise), does so much you don't need out of the box; injects so much under-the-hood complexity that your left wrestling with fluff and nonsense (wading mud from the get-go); alongside the tiny kernel you did want to get tasks done. You can do everything a framework does without a framework, and there is nothing to stop you following the same practices or developing tests to ensure that code follows best practices. There are very few reasons to use a full-fat-framework in 2017. The PSR was basically an admittance that not enough cross-project solutions existed, and that it was harming PHP. The solution thus far has been to bolt several high-profile projects to symfony creating BC, leaving many still running old-builds. This stuff is hard, and it's made a lot harder by people making superficial changes that are heralded as "the way forward", or "best practise" (which framework would you use?). I think the best way forward is to learn to compromise and be less than perfect. Projects like WP and PHPMyAdmin, MediaWiki have weathered many storms, not through best-practices, but through compatibility with previous builds, communities and a long-term view to improvements, not complete rewrites, clean-architecture, or referencing hacker-news.
What's the extension dependency situation like?
I think they're not the same. You should be able to chain your different framework oriented middlewares. In event listeners, this just doesn't work.
Yes, you can make that work. Just create a directory called 'EN', 'ES' etc and put everything in the correct directory. 
You dropped this: \\
That's a quote from a likely disingenuous source, that doesn't take a teenager to de-bunk. someone that wants you to agree to build using their obfuscation method will often throw this nonsense into a debate, it's the equivalent of an octopus squirting ink and running off. I'm really glad they can no longer say "but microsoft doesn't", or "but apple doesn't" because as much as they traditionally had a DIY closed mentality, they now openly admit to using open-source and even create at least semi-open products that are trivial to "hack" to work. A lock on a door isn't an encrypted house, a house underground or in a mine is; living in bank vault is. The problem with living in a mine (besides the practicalities), is you have all that effort keeping the ground above your head. The problem with a bank-vault is people can break-in, and any time you open the door, it's vulnerable. The main solutions in nature to protect against theft, are being lightweight and thrifty, not finding ways to hoard vast resources... There are numerous examples in history of hoarding leading to long-term problems for the hoarder, and sharing leading to successes. Consider this. If nothing else sways you. If the creator of PHP obfuscated and refused to share their code; would you have to worry about people reading your PHP source code? Would an obfuscater even be possible? 
It used the die function to give a basic example of how PHP responds to faulty file creation
By default all distro's we've worked with redis server has had disk-backed persistence turned on by default. What is more of a problem with redis is it's relatively lightweight authentication, meaning you have to take extra measures to ensure nobody messes with the server, or gets access they don't need / deserve.
To be fair, the CVE about the PHP file extension thing wasn't something being actively exploited in itself. Someone had pointed out that in our code that detects PHP files on upload that we weren't being thorough with the list of file extensions to check and we updated it appropriately. The CVE for PHPMailer exposing its version through a header is also something that's probably better suited to be fixed in the library versus leaving it for consumers to work around. The stuff that's really bitten us is the SQLi, privilege escalation, and the information disclosure because we're shipping a Composer vendor directory in our package and the entire package goes into the web space. The first two are signs that we really need to do a proper code/security review on the application, and signs that those of us who are the ones reviewing/merging patches could do with a refresher on scanning for potential issues before merging a major feature. So ya, we've had a more active last 12 months report than there has been in some time. Luckily, only one of those items is a direct result of new code merged in 2017, so a lot of things that could and should have been addressed sooner are getting their due attention. At least it's progress.
Just love Twilio, and feel an SMS will be more lightweight and likely to be read on the way home. Of course mobile as a platform for reading could cause more technical complexity, and getting the link from SMS -&gt; laptop or similar is not a common-case. Nonetheless it's cool, like most things Twilio do.
Isn't this library basically vulnerable to header injection? Do end-user have to prevent it themselves? Is this made clear somewhere?
Usually one only goes for this sort of comment about a *weird* request, or one that's generally a bad idea. Somebody asking how to do something which has a few common and sane reasons to be done (like making a static site, which has far fewer security considerations, is about optimal in terms of scalability and can be hosted without an application server or even a server at all with services like S3) should probably just get a general answer to their question.
Maybe. Maybe not. I prefer to ask a person about what is the final goal and what is the real reason. I see nothing offensive in that.
Hmm. I'm pretty sure you can't use dll on linux.
Wow, you sure put a lot of effort into that blog post.
Just for clarity I didn't mean to come off as implying the number of CVEs or even saying the CVEs noted are out of the ordinary for a CMS like Joomla!. I was actually trying to remember your username to ping you here hoping to have you chime in. I remembered you from [this topic](https://www.reddit.com/r/PHP/comments/59u0be/joomla_from_no_one_to_the_highest_privilege/d9bjmd9/). (I have you tagged as 'Joomla Core Contrib' with that link which is why I have it now that you've replied.) Thanks for the info, happy to see you're still fighting the good fight for Joomla! users.
to extend the example scheduler is some kind of delay too but repeats its self right ?
Not OP, but I quit gaming for the most part for about seven years after becoming a Mac and linux geek left me without many games to choose from. Sure, I spent 20 hours each or so trying out the Bioshock, Fallout, Portal and Elder Scrolls releases, but it left me feeling unfulfilled in a way that only my pet coding projects could oblige. It's anecdotal and it's not for everyone, but certainly coding is what you make it. For me, coding (especially while learning) often feels like a great puzzle game, only without the visuals. Think Myst or maybe puzzle segments of Return to Castle Wolfenstein II or Final Fantasy X. Not great examples of currently relevant games, but good examples of adventure gameplay with a large puzzle solving element. You start out with a problem and work through a number of complex and often heavily interdependent challenges to reach a solution. The sense of satisfaction in achieving your desired end result is immensely gratifying, unless you're working for some soul-sucking job for some evil corporation. In one circumstance, an architect friend of mine was fired from a job designing private prisons. I'd much rather be playing video games all day and wasting my life away. Edit: To be fair, I recently built a PC and I've been gaming again and it is quite distracting from work, but it still lacks the fulfillment. 
I'll be the one to say it openly. We've had more security issues fixed in this 12-month period than any other measurable period in a while. Good or bad is up to the reader, but with a code base as large as Joomla's any progress is good progress.
Finally! *dives in*
Everything you said. In addition, I've always found comments like those from u/TheHelgeSverre laughable especially when posted on /r/PHP of all places. I mean, PHP is the language everyone not using PHP loves to shit on. All said and done, Joomla, Drupal and WordPress must have been doing something right if they are still around, and it's not as if Laravel or Symphony is going to overtake them in the near or far future. It's like staying on the balcony of your glass PHP apartment and throwing stones at your neighbors who live 1 floor above you.
You could even build a Personal Home Page!
possibly wordpress + a static site generator like: https://en-gb.wordpress.org/plugins/static-html-output-plugin/
I've seen things you people wouldn't believe. Including my own code.
A couple of people have mentioned using listeners. Thought I'd flesh that out with a bit of code. I set things up such that I can specify a required role on a route be route basis. For example: game_official_assign_by_assignor: path: /assign/{projectId}/{gameNumber}/{slot} defaults: slot: null _controller: game_official_assign_by_assignor_controller _form: game_official_assign_by_assignor_form _view: game_official_assign_by_assignor_view _role: ROLE_ASSIGNOR So a user needs to have ROLE_ASSIGNOR to assign officials to a game. The actual listener implementation looks like: public function onRequest(GetResponseEvent $event) { $request = $event-&gt;getRequest(); $role = $request-&gt;attributes-&gt;get('_role'); if ($role &amp;&amp; !$this-&gt;authChecker-&gt;isGranted($role)) { // Redirect if page is not accessible $event-&gt;setResponse($this-&gt;redirectToRoute('app_welcome')); $event-&gt;stopPropagation(); return; } } Bit of configuration causes the above code to execute on all requests. Middleware at it's finest. 
I wasn't suggesting I'm in some way incapable of producing errors. What shocked me most was the 23.31% of &gt;500,000 lines being flagged by `phpcpd` (thankfully none that we contributed). It's clear now (nearly 5 years later) that I should have helped these people fix legacy as well as implement new features. Checked for capabilities rather than have separate single-role and capability systems, and taught them how to inject seams so that the database didn't need to be queried and a test environment for code that wasn't from my own business could be implemented... I also thought the conversation could be quite positive from an advice giving point-of-view **Edit** had to exclude `vendors` folder, it's &gt; 30.39% duplicated lines out of 396936 total lines of code. &gt; &gt; Time: 7.6 seconds, Memory: 306.22Mb
TBH that's faaaar from the worst legacy PHP code I have seen
Hey yo that's my speciality (bad code, what patterns?) * Custom number_format implementations that was almost cryptic - seriously could not figure this out * Echoing PHP into JS as a way to control access to certain parts of an application * Consuming raw $_POST filenames because hey fuck security * Why eager load you can foreach everything on earth and murder the database * Doing math for totals in the view layer in large PHP blocks because fuck templates * Inline HTML generation with ternary operators sprinkled here and there because fuck reusability * Let's encrypt these passwords and salt them with time(). All good. * [05ba335] Added token support for API $token = uniqid(mt_rand(), true); * Having a schizo class stored in REDIS thats actual data is stored in $data which is a json_encoded string that will use magic methods to get properties out of $data. But if they aren't loaded and we need them it's ok we'll just query the database and then put it in memory. Also what is serialization? * Bullshit like this $ormThing-&gt;save(); require('admin' . get_class($ormThing)); $test = new AdminThing(); $test-&gt;doThing(); * [07a4bb3] Added Utility Class &lt;?php class F { public static function get(&amp;$param, $default = false) { return (isset($param)) ? $param : $default; } public static function numberToYesOrToNo($number) { if($number) { return "yes"; } else { return "no"; } } public static function isNullDate($date) { return ($date == '0000-00-00' || $date == '-'); } } * GetStatistics.php at root web directory; I'm sure on one will even find this script. All good. * Vendor folder committed into app directory because fuck adding autoloader support * CHMOD 777 (everything) * [DO](http://imgur.com/a/KqhYx) * [YOU](http://imgur.com/pCWAlo8) * [EVEN](http://imgur.com/3Ibay9o) * [LEGACY?](http://imgur.com/GVwOEjA) 
While it's not great, it's basically the same code I've seen for years with just a touch of lipstick.. at least the session itself has been (some what - need to move away from static) encapsulated aka not using $_SESSION. Depending on how often this has been repeated throughout the application I feel like this could be readily refactored.
"As rare as that would be" is almost unfathomably rare. You need to create a billion UUIDs a second for 100 years to have a 50% chance of a UUID collision within those trillions of UUIDs you've generated (assuming a perfectly random source of data, which we don't have, but a good UUID implementation will be close enough). If you're just tracking anonymous users it's not worth handling collisions as they're so incredibly unlikely and it presumably doesn't really matter if there is a collision.
You clearly have seen some shit.
&gt; 30.39% duplicated lines out of 396936 total lines of code. &gt; &gt; Time: 7.6 seconds, Memory: 306.22Mb It's rough AF lol. TBF I may have taken the piece of code that was the least easily identifiable / most impossible to copyright that sucked ;-)
Sometimes when I'm reading code, I think "whoever wrote this is stupid", then find out is mine. I guess it shows that I'm improving, so, it's good?
Link? I'm not familiar with it. TBF though, I'm wondering how horrified I'd be if I looked at my application tests for their code.
 &gt; Link? [Here you go!](https://upload.wikimedia.org/wikipedia/en/3/39/Wakerlink.jpg) --- ^(I am a bot. | )[^Creator](https://www.reddit.com/user/alienpirate5)^( | Unique string: 8188578c91119503)
Btw problems with this * Binding to session class (what if I want an alternative implementation?) * Magic opaque constants (what does it mean to be `getUserAccessLevel() == 2`) * unnecessary `if` and `else` when `return !!(getUserAccessLevel() == ACL::SOME_CONSTANT)` would do * individual fields stored in a session about the user (modify on the session server, break into the app) * More magic opaque constants (how many instances are there of 'SESS_USER_LEVEL' hint it's &gt; 500 and IDK why) * ? Global functions (this one is reaching TBF it's passable, just not with direct binding to session class) **Edit:** Looking at the wider source which I can't share (it's not even all mine), there are ~12000 unique instances of using `sprintf` for SQL... I wouldn't mind but files with an earlier modification date clearly use PDO to `-&gt;prepare($sql)`
Sure thing it's good. If we go back to the 90's when $_GET was $HTTP_GET_VARS or similar I was directly including from query strings lol. Nobody is beyond writing bad code. The explanation I got for why not was "in case the file doesn't exist" so I then moved to wrapping it in a `file_exists($file)` check (which is also bad because `/etc/passwd` might exist). We've all been through some bad stuff to get to where we are
What are you trying to do? Your question doesn't make sense 
That's not a point, it's just a fact. Without context it's completely meaningless.
Okay, if you're just looking to argue semantics, you're on your own.
Bruh..
God, I wish some of the legacy I work on was this clean. Yes, there are some things that can be improved. But the code is easy to understand and refactoring would only take a few minutes. 
&gt; He also seems to believe that something being testable is the be all and end all of good software engineering. Wait...that's not the be all and end all of good software engineering?
Post on Kijiji stating your experience. I posted my own about 5 years ago and got several job offers, one of which I'm still doing today.
you pick a different language
It's not that bad compared to the shit I have seen before...At least the implementation details are hidden inside the functions. &gt; Binding to session class (what if I want an alternative implementation?) It is the `Session` class's responsibility. &gt; Magic opaque constants (what does it mean to be getUserAccessLevel() == 2) Yes this is ugly. But so are many other cases without proper Enum support in PHP. &gt; unnecessary if and else when return !!(getUserAccessLevel() == ACL::SOME_CONSTANT) would do Yep, shitty. &gt; individual fields stored in a session about the user (modify on the session server, break into the app) Well, if your session storage is comprised, the attacker can simply pickup a session ID of an admin user and hijack it. You are pretty much screwed at this stage.
I heard toptal is pretty good. They have a rigorous application process for freelancers, and I believe clients are vetted well too, and prefer long term contracts.
/r/phphelp 
You still haven't answered the question.
Maybe start off as a stable boy and ask the knights if you can have one of their old lances for free? 
Not exactly PHP related, but I can see various test suites adopting this. Super handy as a replacement for PhantomJS and its ilk, and easy to integrate into the build process.
You're drifting into cronjobs now I think. There's a big difference between stuff that "needs to happen ASAP but plz don't crash server or make user wait" and stuff that "needs to execute on a given date and time, potentially repeating itself some time in the future".
An out of field suggestion: Consider building products for marketplaces, like ThemeForest or OctoberCMS. It's a great way to supplement work in between jobs.
oh i see thank you 
Do you mean [Object-Relational Mapping](https://en.wikipedia.org/wiki/Object-relational_mapping)?
**Object-relational mapping** Object-relational mapping (ORM, O/RM, and O/R mapping tool) in computer science is a programming technique for converting data between incompatible type systems using object-oriented programming languages. This creates, in effect, a "virtual object database" that can be used from within the programming language. There are both free and commercial packages available that perform object-relational mapping, although some programmers opt to construct their own ORM tools. In object-oriented programming, data-management tasks act on object-oriented (OO) objects that are almost always non-scalar values. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Failed the application process due to their "project-euler-based" interviews. I heard good things from folks that made it, but you may as well roll a dice when applying.
But which one?
&gt; Well, if your session storage is comprised, the attacker can simply pickup a session ID of an admin user and hijack it. You are pretty much screwed at this stage. What need is there for a session to contain a user row's PK? It'd only be created after a successful login.
If you are based in London or New York then [YunoJuno](https://www.yunojuno.com/) is great for all kinds of freelance opportunities. 
&gt; refactoring would only take a few minutes. Bows I'm still thinking of what it should look like. I'm considering (not based upon the shared code) rewriting in spare time and selling back to the owner.
Originally I was using Eclipse for PHP development, but the inspections and performance were what put phpstorm over the edge. Since then I haven't put the IDE choice into question again, even when moving over to the JVM side of the fence. The jetbrains tools work well, and I'm used to them. I still rely heavily on inspections to catch code problems. I'm always hunting for the elusive green checkmark in the top right corner.
Speaking of unnecessary, why converting to boolean return !!(getUserAccessLevel() == ACL::SOME_CONSTANT); simply write return getUserAccessLevel() == ACL::SOME_CONSTANT;
If you want small,cheap,complex and fast CMS then you can use Wordpress. It's easy to handle and mangae the website
Thanks. I guess firewalls and being careful about what else goes on those servers is key here.
&gt; There is no password set for the database connection, and you're using user 'root'. &gt; That must surely be a mistake, right? &gt; Bolt will stubbornly refuse to run until you've set a password for 'root'. I appreciate the concern, but that's for me to decide, not the software I run on a dev system where there is zero additional risk when root pass is not set. Someone would need to gain physical access, and the system would be owned anyway. Looking forward to checking it out.
agreed, it was late ;)
Approximately 200,000 lines of duplicated code, out of ~1mil total. And that was the 'good' news about the platform I'm currently working on. Most amusing thing I've seen was in the old Moodle 1.9 quiz module, a comment along the lines of "We should really track this, but it was difficult, so we didn't" referring to random question placeholders and which question was actually presented to a user. 
Good.
Why does it need to be PHP if it's going to produce static output anyway?
I wrote a mink driver that can be used to do this in PHP https://packagist.org/packages/dmore/chrome-mink-driver
i looked in the source, you can send an object to queue and it will serialize it, but you can also send an array. so to use it from other languages you only have to keep the same format for the payload. i have done this before and manualy pushed it to queue that laravel lisened. my use case then was that i needed to just push those jobs. now im using rabbitmq for comunicating with other systems. 
You've convinced me to give them another try :) They *are* sleek.
&gt; PhantomJS and its ilk While I'm certainly exploring using headless Chrome eventually, why are people so down on Phantom? It's been easy to use, runs great on remote VMs, and has overall been reliable together with tools like Casper. Certainly far better experience for us than Selenium ever was.
I agree, sorry if my comment came across as negative towards it. I have nothing against it, I'm just _for_ simplification of everything.
That makes sense! I do enjoy when things are easy as well, but at the same time, I realize that the more difficult my job is, the more likely I am to continue to be attractive on the market and get paid well! :D
"Doing math for totals in the view layer in large PHP blocks because fuck templates" So how do you do it now? A loop in twig/blade?
The lead maintainer quit the day chromless was announced. Which is fair enough, but I would begin to remove it from your toolbelt going forward. 
I don't mind an unary version, but using "??" when we have a binary version is really hard on the eyes. And that ambiguity would've also been the source of many bugs, i.e. $b = 5; $a = $b?? + 10; The result should be 15, you think. But, nope, it's 5.
I can only conclude you were on drugs when writing this. Come back and explain what it is you need after the come down
It's a bit of a meaningless distinction, because "architectural pattern" is defined basically as... if you use this pattern a lot, and at the higher levels, then it's an architectural pattern, else it's a design pattern. Well "architecture" is just the overall design of a piece of software. And which pattern ends in the "overall design" and which is at the lower levels is entirely project-specific and contextual. The same patterns **can** be used both as architectural and design patterns. Patterns aren't opinionated about how-level the interactions they describe are. They go as low or as high as you want, and they work the same. The only thing that will result from segregating patterns in two kinds, would be the familiar and pointless arguments like "you're using MVC as an architectural pattern, but it's a design pattern!". It can be used as both. That's up to the project architect. Now if you say "in this project we use MVC as an architectural pattern" that's useful information. It means "you'll see this a lot, and at the higher levels, possibly between modules". But that's, again, specific to *the project*, not specific *to the pattern as used across projects*.
I actually use Symfony for even small things and used it for a trading bot as well..cause it can be very lightweight if needed..I mean you can just throw out everything you will not need..specially with Symfony flex..but if over time more complexity is needed..than you can just easily pull back features. This is specially the case for trading bots. Although I would suggest you to use Phalcon in this case because the trading bot will have to deal with a hell lot of requests per second..so from the PHP world Phalcon would be the best fit..or go for Node
Bold choice for the /r/PHP subreddit... Why are you here?
Have not tried Phantom yet, but I am about to try Cypress, http://cypress.io/ and it looks promising so far. Also, here is the developer giving a talk, https://www.youtube.com/watch?v=yq99BvSe1AQ Edit: a talk from 2016, https://www.youtube.com/watch?v=lK_ihqnQQEM 
Video linked by /u/thousande: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Testing, the way it should be.](https://youtube.com/watch?v=yq99BvSe1AQ)|Nodevember|2015-11-19|1:00:32|51+ (100%)|2,577 &gt; Brian Mann &amp;lt;p&amp;gt;Testing is the essential bedrock of... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/thousande ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dku4gzk\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
So 20%. Is that lack of a bootstrap, or a bowl of copy-&gt;pasta for a night on the town? Old code without a suite. How bad is it? Or is the point that I shouldn't care 
Generally you want to avoid placing logic in your templates at all. The ideal template is just going to output precomputed variables. The sensible way to do this would be to total things up in some form of service class and have the controller request those totals and pass the computed values to the template.
Does eToro provide an API for bots?
No, I'd have to use a different service. That's research I have yet to do. Any advice welcome! 
You drunk, Flanders?
Also, Phalcon has a cool name. I don't get on too well with Node (or any Javascript!). Might consider having a crack at it in Scala but that might just take me too long as I've only done a couple of beginner tutorials and my Java is pretty limited too. All that safety not too relevant anyway as the app is just for me. So assuming I stick with PHP then I'll give Phalcon a look first I reckon. Thanks for the advice :)
Since you have experience with laravel, I would say use [phalcon](https://phalconphp.com/en/), as the trading bot would need to be as fast as possible to make effective trades and not miss a bid.
I think the Bot/Language depends hardly on the API. Maybe a daemon is required, maybe not. Maybe your calls will happen a few times per second or maybe you're overwatching your portfolio twice a day... Maybe you need perfect SOAP/WSDL integration, maybe its REST.
I don't get it, why you're both talking about MVC frameworks when you try to implement a trading bot :-)
Considering that still to this day (3 months ago) they are still riddled with security vulnerabilities. ref: https://blog.sucuri.net/2017/05/sql-injection-vulnerability-joomla-3-7.html
Another vote for Phalcon, cheers.
You don't need to know about pointers in PHP, its not supported and all handled by the zend_engine
I guess because I'll need models, views and controllers ;) Is there another kind of framework you can recommend as an alternative?
Is they a benefit to using this over Phantom or Casper?
Sorry but, is this a --headless alternative? I tried so bad setting it up on a Ubuntu Server + Jenkins + CodeCeption but got nothing working so far.
Why would you need that? All the data comes from your integration. What do you think, you would save on your side, that is not already stored on the partner side?
I work with phalcon daily, and i've been trying to to spread to word of this wonderful framework as much as possible.
I eat breakfast before i go to bed so i don't have to in the morning.
Description removed? although You can use Envoyer or Deployer for automated deployment
Perhaps it was late when the original code was written, too.
Coding as you want? What do you want the coder to do? And what upgrading are you asking about?
Totally, for 12 years they have been up late typing code... never contributed anything until it was late. Totally plausible...
It's quite possible only a portion of the file is stored in `$text`. From http://php.net/fgets: &gt; If no length is specified, it will keep reading from the stream until it reaches the end of the line
So as this is a wrapper around calling Jasper, anyone encountered any strange edges with Jasper? We have our own in-house report server, but would happy to use something we don't have to maintain. Java seems nice as it can be persistent, but it looks like this starts the jre or jdk every time you want a report (any tests on how that compares to solutions like PHPWord?)
Will need a minimal UI for setting up bounds for calibration runs and other such configuration-y things, and also for live logs / monitoring. Also for reviewing results of calibration and test runs. Planning to store substantial historical data and retrain the algorithm automatically and regularly. Will avoid going into too much more detail.
very true!
&gt; why are people so down on Phantom? It has 1896 open issues. Although it might work for you, a significant number of people have had issue with it.....not due to a lack of effort on behalf of the maintainers, but due to the fact that maintaining a browser is a gargantuan task. It's just a better idea to use Chrome (i.e. the same browser as a significant number of users actually use) to do testing, rather than keeping a separate application feature equivalent.
Like most things it's when opaque design happens that it's really difficult to understand. Also non-basic, and particularly multi-level processes can be quite difficult to think about. To give an example, I've recently (today circa noon) started playing with a really cool library `php-di`. In it's demo it maps a number of default Classes that implement Interfaces, or match a string identifier. I'm thinking of using it to upgrade a quite old PHP app to use DI single-ness rather than singleton design pattern, amongst other things. What was confusing was having to go demo-app -&gt; php-di -&gt; silly -&gt; symfony-console, just because symfony console accepts an `OutputInterface` that built-in is programmed to default to null, and if-null use `ConsoleOutput` implementation. I get it, it's a console application framework component, why not default to cli output; it's more the way it's been done, and how many repo's I had to go through to get to answer my "hey what's happening there". Also it can be difficult to fathom out some things. i.e. Do I need to pass around the DI, should I use a middleware to support JSON POST &amp; multi-part forms, or just run separate apps? There are tonnes of examples of this sort of thing, and many ways to remit, it's not all resolving dependencies. Seeing many projects which support just one DB, or type of DB can be frustrating, as can incomplete or overly complex and rigid implementations (you should see the lovely example php-di demo app provides for fulfilling a repository pattern). 
You can join [continue to site](http://i.imgur.com/dcc4Hqy.png)
you any framework, write out templates, write controllers to populate templates. visit the urls, save file as html. I did this in college when they wanted us to make a zoo website in html... I just generated all the pages with laravel in 4 hours. The task was meant to be all week. The tutor marked me down because of the HTML formatting... Like that means anything if the website works.
Well, that depends. The arithmetic operators take precedence over the unary operator, so the expression becomes: $b = 5; $a = $b ?? (NULL + 10); I agree that - when `NULL` is not provided - it does look and behave funky. It's probably a good thing the RFC didn't pass.
Phalcon is fast and seems cool until you run into something and you don't know why it's running so slow. Since the library isn't in PHP, you're going to be looking at compiled code trying to trace why Redis is taking a few milliseconds or queries are super slow. If you want a front end, do that in anything Symfony, Phalcon, Silex, hell... Wordpress. For the actual processing, if you want speed, maybe look for something better than PHP, look at Node/Go since they are pretty easy to get started with. If you are going with PHP the processing scripts that you will be running will be just as fast with any framework once they are up and running.
is this appropriate for running js unit tests as well? Not sure how I could tie it into karma
My understanding is it's an API to make using `--headless` easier.
 &lt;?php for each ($item as $whatever); $total+= $whatever-&gt;total; {? &gt; // Html stuff &lt;?php }? &gt; // Eventually echo total somewhere It should be somewhere else and passed down to the view layer. Controller is OK depending on complexity but if you have sales tax and stuff definitely wrap it, perhaps even in a presenter class if it's real complicated.
I'm not sure I see anti-patterns here. We're too quick to use that word, even when it's not warranted. Maybe the closest thing to an anti-pattern is the fact all of this is static and global. One session, one auth, can't replace implementation. *But, then again,* the actual PHP built-in APIs implement and encourage the same procedural/static approach. So it's not a surprise we might see this crop-up in application code. I could also comment on the seemingly free-floating magic numbers in the last two functions. *But, then again,* we see each number being used exactly once. So whether it's in a constant, or in a "isAdmin()" function isn't much of a difference. It becomes a problem if you repeat a given magic number more than once. So be happy, that's relatively fine. Definitely not how I'd tell someone to write it *today*, but it's fine.
/u/ecstaticcoder Are you guys using this in production or on a team? Would be interested in hearing about that.
I think part of the problem with this post is that I can't share "the worst", but by the time I'd gone through that making notes, and found this that I could post, it was yet more problems in a complete PoS
&gt; JavaScript-like syntax and compiles to PHP As much as PHP gets a bad rep I have never once heard anyone say "oh I wish PHP was more like Javascript"
What a load of shit, It's still using SQL you're just using a library as a query builder and the library is no way near as good as the established ones out there. Completely pointless 
Good point... Maybe it's the right time to learn a new language (Go, Rust or similar). 
This guy fuchs.
Yes design wise, they're not the same. but middlewares don't share data either, they just alter the request/response so you're not really getting any advantage from chaining them and you can achieve the same result with event listeners. I'm not arguing against middlewares here, just that OP's problem has been solved a while ago.
Correct
I'm sorry for not adding to the conversation.. but your comma usage is causing, my eye, to twitch.. 
Oh my god.
Why was this rejected if I may ask?
happens when you work on the other screen and gets interrupted while, writing, sorry.
I may be on my own here, but I think you should look at using a different language. Python, for example, is used a lot for self-learning stuff so has a lot of libraries as well as a lot of stuff written about it.
Right now the compiler has only been used to develop a small company website. The compiler was made especially for that project, and honestly it was a breath of fresh air to use it. So the compiler was already feature-complete and stable for that development. To the point I wonder if there is even a need to add new features to it in the near future, as in practice it already works really well in its current state. I'd like to point out that contrarily to other PHP-generators, there is less risk involved in using Phoenix, because the PHP generation is extremely straightforward, as the language is simply implemented as a preprocessor. This means you can switch back to the generated PHP code at any moment, as it's EXACTLY the same code you would have implemented manually anyway. Check it by yourself : https://github.com/senselogic/PHOENIX/tree/master/SAMPLE/PHP And with Phoenix, debugging is a breeze. Even the line numbers in the generated PHP files are IDENTICAL to those of the Phoenix code. These features were major design goals for Phoenix. Not only do they make the compiler ultra fast, but they allow the generated code to be easily and seamlessly integrated with any other existing PHP code... 
We just switched our acceptance tests from using PhantomJS to headless chrome, not this project exactly, just headless Chrome. The acceptance tests now run over 20% faster. If we were to measure just the time interacting with the browser, the increase would likely be much larger. Most if the time is probably spent waiting on the HTML validation, which is a totally separate thing.
Have you considered using [AmPHP](http://amphp.org/)? It should satisfy the speeds that you need. And you can always build your UI as an external application that communicates with the bot instead of building the bot with an MVC framework.
If you have no experience with rust you'll spend significantly more time developing it in rust than you would debugging phalcon bottlenecks. All you're looking for is a front end. If you want to explore and play with new technologies just find something that interests you and expect to waste time. If you want to get it done in a timely manner then you're already heading in the wrong direction.
 $concated = "{$stuff['somedumbkey']} zzz $php blows"; what's complicated?
Single `?` seems less ambiguous ([example](https://preprocess.io/embed#PD9waHAKCm1hY3JvIHsKICAgILdjaGFpbigKICAgICAgICC3dG9rZW4oVF9WQVJJQUJMRSm3dmFyLAogICAgICAgILdvcGVyYXRvcigiPyIpLAogICAgICAgILdlaXRoZXIoCiAgICAgICAgICAgILdvcGVyYXRvcigiKyIpLAogICAgICAgICAgICC3b3BlcmF0b3IoIi4iKSwKICAgICAgICAgICAgt29wZXJhdG9yKCItPiIpCiAgICAgICAgKbdvcAogICAgKQp9ID4+IHsKICAgICi3dmFyID8/IG51bGwpILdvcAp9CgokYSA9IDU7CiRiID0gJGE/ICsgMTA7CiRjID0gJGQ/ICsgNTsKCiRlID0gJGEgPyAieWVzIiA6ICJubyI7CgpwcmludCAkYiAuIFBIUF9FT0w7CnByaW50ICRjIC4gUEhQX0VPTDsKcHJpbnQgJGUgLiBQSFBfRU9MOwo=), `cmd/ctrl` + `s` to run)...
OT: The word 'ilk' isn't pejorative. It just means kind, type, etc. It's a strangely misunderstood word. https://en.wiktionary.org/wiki/ilk Just saying.
Mock the API and use dependency injection. Guzzle has the middleware layer which you can hook to check requests and responses etc. Also, PHPUnit has some useful mocking abilities, see https://phpunit.de/manual/current/en/test-doubles.html
You dont even need php: 10011011010011111001010010 Then 10011010
Good. That syntax was confusing and hard to explain.
So what's the right direction? Not sure I'm getting your gist. 
You're probably making a lot of sense. I hate doing UI in general so I guess I just want short of tag it on and not have to treat it as too much of a big of a deal. 
I have a little python experience and wasn't wild about it. Also I thought it had a reputation for being quite slow for computation. Generally open to trying something a bit different though as am in no rush and am aware that the more languages you know the better a developer you are. 
&gt; Larry seems to be confusing the idea that just because his relationship is "legal" the Drupal organization must accept him as a leader in their organization. I've heard exactly the same sentiment regarding gay/lesbian relationships. &gt; Him continuing to whine about it like a small child is only making him look worse to future employers. And I've heard exactly the same said of women who report harassment in the workplace and defend their reputation. Same \#Bullshit. Different \#Pretense. Thanks for playing. 
It depends on what you're wanting. If you want it *done* then just use what you're familiar with already. If you're just looking to get experience/enjoyment out of doing it then something new is fine. Picking up a language like Rust/C (depending on how Phalcon pans out) is going to turn a small project into a big one. I understand you said that you don't like Laravel, but make sure that you consider what you actually want to get out of this project first.
Create a free store with shopify or prestashop, watch and learn.
I don't really get it, how can I learn from shopify?
Design choices, UX, UI, best practices, configuration options, product management, cart options, marketing tools, newsletter integrations. PS: It's like: "How do I build a store". I say, go to an actual store, see how it's made, take your little shovel and hammer, have a go !
I forgot to add, I'm quite experienced with HTML, CSS, JS, and WP, especially the design part, so I need to focus on the backend.
Even easier, take a look at https://github.com/PrestaShop/PrestaShop
Do you plan to put this ecommerce site into actual production use?
Because it was an absolute abomination of readability. 
If you get a migraine trying to work out what a simple expression means purely based on syntax... then it's probably a bad syntax. I suggested null casting operators as an alternative such as: (?mixed)$_SESSION['abc'] and (?int)$_SESSION['someintornullkey'] and (?string)$_SESSION['somestring'] etc
If it's a static site generator why does it need to be PHP? There are plenty that aren't PHP such as Hugo. Or you could go with Wordpress and wget --mirror?
in the future, yes. Although it's not urgent so I can take a few months to develop it properly. I like to learn through real projects, and this is a good opportunity
If it's a live API that I did not write, and it has tests, I'm going to assume that it is stable and not test it. It's not my responsibility to test it. PHPUNIT can mock up the class you're using to get data (say PaypalService.php) and you can have the methods return some known data so you can test it, or make sure certain methods are called. Depending on the complexity your mileage may vary. Things get very "it depends" from then on. You mentioned its TDD, but what are you actually using? If it's something further away from unit testing like behavioral testing (integration*, browser automation, etc) then it can get really tricky to actually deal with.
yeah..I am actually not using double quotes..but nice :)
I _strongly_ recommend you don't do that. There are a _lot_ of edge cases you just won't think about, not to mention PCI issues.
I'll start off by saying that I see some major benefits from being able to write to the superglobals array. Indeed what I consider the most beneficial of them is used 3 times in the first 20 lines of my main include file, these are, of course, cleaning up the $_SERVER array. I have a large deployment of IIS servers, they all run behind a load balancer and all have URL re-write rules in place, the very top of my bootstrap does the following: * If the console is running in CLI, it sets HTTP_HOST to a default domain and sets the REMOTE_ADDR to 127.0.0.1 * It parses the X_FORWARDED_FOR header and replaces the REMOTE_ADDR with the correct one. * It cleans up the query string that comes as a result of routing the re-written URL through the query string of a routing file. All of these changes are simply to tidy up and sanitise data from higher up the server stack, and I think they are entirely legitimate changes to make, thus ensuring that they are as-expected from any code location, be it my own or something brought in through composer. There are also, I think, legitimate grounds for re-writing GET/POST etc, such as single-point sanitization, removing invalid UTF strings etc.
What PCI issues? Let the payment service providers deal with it.
&gt;Suggestions include making $_GET, $_POST, $_SERVER etc read only in PHP 8, understood to be a breaking change. This would kill the internet, no way it'll pass. At least, in the foreseeable future.
Why don't you just create your own server options object/array and pass that around your application?
&gt; thus ensuring that they are as-expected from any code location, be it my own or something brought in through composer.
Yeah, I read that. But if there are any packages that just takes those values and not even have manual overrides, they should probably not be used...
&gt; ftr; I'd vote in favor of several BC breaking things to do with autoglobals, among them: &gt; - Make them objects (though ArrayAccess based for less hostile BC breakage) &gt; - Make most of them read-only (offsetGet(), but no offsetSet) &gt; - Make $_SESSION[...] access produce an error or auto-start the session "Hey folks let's make bunch of arbitrary changes to PHP that'll break **all the code**!" I can see from a hundred miles away none of this will pass. If superglobals are such a big thorn in someone's eye, how about we introduce decent OOP APIs for request/response/session/env first, parallel to superglobals, then gradually deprecate and remove superglobals over PHP 8 and 9? At least that'd be the sane approach, instead of "hey how about we turn this read/write array into a read-only object!"
That's a rather simplistic view - One of the most important parts of a bootstrap is to bring the execution context into an expected state prior to passing control to specific domain logic. Many of these keys are defined here: http://php.net/manual/en/reserved.variables.server.php with explicit definitions, such as REMOTE_ADDR, HTTPS, QUERY_STRING etc, and while when they execute they are technically correct based on the higher-stack implementation, they are nonsensical from an application logic PoV. Reading from https://www.yoursite.com/dir/abc.php?hello=world would, under normal circumstances, give HTTPS On, ?hello=world as QUERY_STRING etc. But once they've been passed through re-writing, a load balancer etc, they become completely disconnected from expectation. REMOTE_ADDR will always be the load balancer, HTTPS might be off (because of SSL offloading), the query string might be "?dir/abc.php?hello=world" etc. I'd rather fix them at source, or as close to source as is possible, rather than either a) trying to edit each package + its updates, or b) having to correct them at every usage.
The payment provider only handles _their side_ of the equation. If you have a credit card form on your site that passes through your system, _you_ are responsible for being PCI compliant _too_. Of note, stripe and paypal and braintree all have integrations you can do that fully shift the PCI burden onto them--that doesn't prevent you from hitting edge cases, only PCI scope. 
Yep. If you're worried about PCI then the payment service providers that handle card payments via tokens is the way to go. It's even possible to provide wallet like features (stored cards via tokens) without dealing with PCI. If you want to store card information yourself then you better know PCI otherwise don't even think about doing it.
&gt; One of the most important parts of a bootstrap is to bring the execution context into an expected state prior to passing control to specific domain logic. "Expected" is the keyword here. Mutating that state may very well turn it from expected to unexpected from the point of view of another library (or even other pieces of your own code, or other people on your team, etc.). The behavior of PHP with respect to this state is deterministic, well-documented, and universally understood. The same can't be said of the behavior of /u/Sentient_Blade.
It took the [Commerce Guys](https://drupalcommerce.org/) two years to make Drupal Commerce 2.x, despite experience creating Ubercart, Drupal Commerce 1, and building a zillion or so sites using the platform.
I, for one, would welcome this change. Yes, I understand the implications of existing codebases. However, my first counter argument would be that these codebases will have time to make changes if they wish to remain compatible. My second counter argument is a tale as old as time: read-write global are bad. Why? Because you can never be certain of the state of the value at any given time. Having the super globals be immutable, once the pain of migration is done, would only bolster the stability of apps. And for those who absolutely, positively, just can't live without mutable globals, make your own using a registry. Edit: sppeeeling
You're right, although Chromeless is a bit different than Headless Chrome. Phantom shut down after Headless Chrome released. Chromeless was released a day or two ago.
Unnecessary limitation, no thanks.
Not sure why this is downvoted, it's pretty sensible. Sometimes the attitude of the PHP community baffles me. Why is this change fine, but others with arguably less impact (fixing parameter order, ternary operator etc) apparently not worth doing?
Meh, there were bigger breaking changes going from 5.6 to 7. Also I don't remember ever having to add or modify anything in a superglobal. 
Don't focus on the backend at all. Go through PayPal using their paypal express/legacy documentation. Once you can get through the whole 'sales funnel' development cycle with a big processor start looking at pci compliant SaaS organizations. These companies will give you the back end code and integrations (in the form of an api and software to view your pci secure customer data) to actually manage recurring sales and fulfillment.
Thanks. It's not mean, its the truth, I had a hunch that this would be the case. My first intention was Woocommerce (as I have experience with WP and tbh it wouldn't be a big shop, only a few items), but everyone I asked seem to advise very strongly against it. Do you have any experience with [Sylius](http://sylius.org)? Many sites compare it to Woocommerce and such, but it might be a cool middle ground between a custom backend from scratch and something like Woocommerce, as long as there's not that much opportunity for fucking it up.
My particular issue (the $_SERVER array) is that there's only one place to get the information in question. Once some other component (FCGI, Web Server etc) changes that as its own sort of manipulation, it would mean that short of re-writing the framework to take a $_SERVER clone as a dependency), every module would need to have full knowledge of all possible higher-stack mutations, even for something as simple as building an absolute URL. I think the argument for $_GET and $_POST is easier to make, but is still not open and shut.
I'm a Symfony user, so I'll reference how they abstract away the need to ever use super globals. They have a composer package called [http-foundation](https://github.com/symfony/http-foundation) that provides, among other things, a `Request` object. This `Request` object ties into another object called a `ParameterBag`. For `$_SERVER`, they use a `ServerBag` (for those `$_SERVER`-specific stuff) that extends `ParameterBag`. To use it is pretty simple once you learn the nomenclature: $request = Request::createFromGlobals(); $request-&gt;query-&gt;all(); // Return all from $_GET $request-&gt;query-&gt;has(&lt;key&gt;); // Return true/false if &lt;key&gt; exists $request-&gt;query-&gt;get(&lt;key&gt;[, &lt;default&gt;]); // Return the value of &lt;key&gt; if it exists, or the value of &lt;default&gt; if provided $request-&gt;query-&gt;set(&lt;key&gt;, &lt;value&gt;); // Yup, you can even overwrite stuff if need be (though, this is potentially as bad as writing to the super globals // The others are: $request-&gt;request; // POST/PUT $request-&gt;server; $request-&gt;attributes; // The request attributes (parameters parsed from the PATH_INFO, ...) $request-&gt;files; ... I'd go on, but you get the point. If you are curious, check out their [API documentation](http://api.symfony.com/3.1/Symfony/Component/HttpFoundation/Request.html) for the entire picture. The point is, it's not really as bad as it sounds. Yes, there will be some pain. It sucks. But, in the end, it really is for the better. Hell, even if they vote down the immutable super globals, it might still be worth making the changes. It sounds like you're doing some pretty hairy stuff there to get your code to work, and it probably could be cleaned up a lot using something like Symfony's http-foundation package. :)
I do use something very similar to Symfony's request objects. I'd say 99% of my $_GET / $_POST access is through an ArrayModerator helper which is very similar to ParameterBag::Get, with the exception of implicit type casting of the return value based on the type of the default (i.e. $request-&gt;get('id', 0) will always return an integer type). It seems even if using the Symfony Request object, and assuming any and all third party code used it, it would still need to be mutable, which does somewhat bring us back to step 1.
The Request object is mutable. You can change it to your heart's content. If you're referring to the super globals, no, changing something in the ParameterBag won't affect them. That's the point. As for third-parties, that's not your responsibility. It's the maintainer's job to upgrade their code. Now, if they refuse to for some asinine reason, then you could take matters into your own hands and fork their code. But in this case, I'd call that an unlikely scenario given it'd be to maintain compatibility. If that's not an option, then you have to make a decision: - find a more cooperative library - write your own - cross PHP 8 off of your Christmas list 
I've been itching to build another Composer package. Any interest in a library that will provide this functionality? The only one I could find [appears to be incomplete](https://github.com/robert-horvath/superglobals).
I am honestly in awe of how well thought out that thread is, and the fact it came from \#Twitter. Thank you for sharing.
No, it's closer to being \#Christian or \#Muslim.
&gt; can I trust him to not let it influence his community participation? I don't know. How exactly could he *establish* that trust?
&gt; Dries indicates there are extenuating circumstances. No, he *insinuates* there are extenuating circumstances, like the *possible* abuse of an #Autistic woman, and other post hoc justifications. &gt; are you and the mob here really qualified to be the designated arbiter of right and wrong? Depends. How \#Democratic *is* the \#Drupal community exactly? And the \#UnitedStates legal system believes in mob rule enough that it features the concept of a jury of your peers.
&gt; The choice facing us is not "secret star chambers" versus "mob with pitchforks". No, but they're the inevitable result unless specific action is taken to prevent them.
&gt; the r/php mob has made up their minds without all the facts. And exactly who or what is *keeping* them from having all the facts?
&gt; Gather all facts, then make a decision. Don't make a decision and gather all the facts later. Someone should tell that to the DA.
if it doesnt have to absolutly be php - take a look at MetaTrader and its MQL coding language. the biggest problem with trading bots build on php is the frequency in which you get data, with metatrader you have more than 1 update / second and thus a bot has very reliable data with php pulling data from an external source and having a daemonized loop with more than 1 update per second (i.e. pulling in the external data) is much harder to pull of, and MQL / Metatrader was built for it.
&gt; I was not kicked out. They failed at the attempt; I recall the vote being close to 2:1 against. Ah, so what were the results of the vote to kick Larry out?
Stupid change. For one, it's pointless. If you want a read-only immutable set of input data, you can already achieve that in userland - Symfony does it very well already. Second, while changing a superglobal value is definitely always going to be a hack (with the exception of $_SESSION), sometimes hacks are absolutely needed. Web servers can have bugs leading to malformed data, and some third-party applications rely on the superglobal values and cannot be directly altered to change this. Also, there is a limitation in PHP that you cannot get both the raw HTTP body and the $_POST variable data at once, it only allows you one or the other. So if you need both you have to get PHP to give you the raw and then parse it and save the variables into $_POST manually. You could class this as a hack, but as the PHP toolkit doesn't offer another way to achieve this goal I'd have to say it's an unfortunately legitimate method. A method which would be impossible with the proposed change, thus it definitely breaks the available functionality of PHP in a fundamental way.
Then why are the majority of \#Goreans *women* who voluntarily participate in the community? With all due respect, I don't believe you understand why some women find this sort of thing sexually empowering, nor should you be making that decision for them.
symfony/http-foundation does wonders.
Will take a look, cheers. 
Exactly this. As the owner of your own code, you're free to do whatever the hell you want to do, including making the data from global variables mutable. Outside of your scope however, the implication of immutable super globals means that you literally can't cause a side effect in anyone else's code. So if you want to pass your awesome mutated Request externally, you're going to write an interface/API like a good boy.
It puts the API in the package, or It gets the hose again?
It's either the phpdoc or the whip.
I could see how this behaviour would best be run conditionally, based on a .env setting.
Aaand we just made a micro frame work :P
I'm aware of http-foundation. Problem is, that's a library that's geared towards abstracting away the entire HTTP request. Not just the superglobals: * $_SERVER * $_GET * $_POST * $_FILES * $_COOKIE * $_SESSION * $_REQUEST * $_ENV I'm talking about a much thinner, much simpler, and probably much more naive implementation that only applies read-only capabilities to the above as outlined in Sara's message (save for $_COOKIE and $_SESSION). But fuck me for trying, amirite?
&gt; Do you think his female co workers have a responsibility to ignore that he is sexually exited by the thought of them being murdered? Um, wow, that's... a hell of an accusation to make. I certainly hope nobody believes I'm a rapist who drinks blood just because I play \#VampireTheMasquerade (which coincidentally *also* has a substantial female fanbase). And how is being sexually exited at the thought of women being naked, or covered in fudge, or transforming into an animal, or being eaten, any different here? Making *any* of these relevant in the workplace will be disruptive.
True, I believe the only thing they're missing is the env. I can't recall off the top of my head whether it's in this package or http-kernel or something, but they also have a FrozenParameterBag. btw why the hell are people down voting your simple question, not like they'll be required to use the package if you made one? This topic must have some people wound up. I'd be interested to see what you come up with though!
Jeez just three lines? Microframeworks be crazy these days. 
&gt; all evidence points to him not even holding the beliefs I mentioned. Funny that.
Ooh, an important issue: &gt; Also, there is a limitation in PHP that you cannot get both the raw HTTP body and the $_POST variable data at once, THAT is an important point to address. The rest, are not so much... &gt; For one, it's pointless. The only point, is to protect from unexpected or silent mutation. &gt; If you want a read-only immutable set of input data, you can already achieve that in userland You cannot stop an unknown package or your own application, from modifying the POST data before you get to it at any point in your application because Dev A wrote this cool new thing.
Sorry headless chrome is what I meant to say
**But why? http://gph.is/1gDlF9j** I'm sure it will break shit everywhere, including legacy frameworks. I think the best approach would be to define new global objects with a much cleaner OOP structure, make them read-only, and then slowly deprecate the current super globals as we know them. Paul M Jones has an extension build just for this (https://github.com/pmjones/ext-request). It's not PSR-7, but gets the job done without bloat. 
Lovely example. And the enforcement of the parentheses definitely clears it up. I'm still worried, though, that it could cause readability issues when used together with the ternary operator, `?:`.
Look into Postman. I has excellent support for manual testing. You can also write asserts on responses and even make auotmateable tests with their pro product. 
&gt; but you can also send an array Nice good to know. Any details how you target the specific class with the array approach? I.e. usually I've a) the target class and b) the arguments for the constructor.
I have not known about coding, I want to many thing upgrading firstly Banner I want to Put on page, almost 1000host and 30000visit page, after design page etc. Do you know coding?
&gt; I think the best approach would be to define new global objects with a much cleaner OOP structure Or even better - just functions. Although the data being retrieved is kind of related, there is no need for it to be in a big class/interface that does 'all the things'. Just having functions to retrieve the data would allow them to be maintained or updated more easily than if they were done via OO - for which we'd need to get the class design right first time. 
&gt; After all, if I wanted to say "a proxy" I would've said "a proxy". How should I know what you want to say? Communication is a two way street, if I do not fully understand what you really want - and I still don't do - we cannot discuss things properly. Do you agree? And given I am not not a native speaker with a completely different background as it seems, explaining clearly where you are coming from and where you are heading to would help to clarify a lot of your statements. &gt; I very clearly said I treat a group of cohesive controllers as a single unit, so I can unify their constructors Yes you said that and I still do not get why. And since you clearly stated that "controllers are an exception to this" this clearly shows me that your "solution" is not very well thought of. With an action class you would not need to treat controllers differently, that's the whole point I try to make with the ADR reference. &gt; By using reflection you have lost control over what your controllers ask for in their hundreds of unique constructors. I have no idea why you bring up reflection in the context of injecting dependencies into a controller. But yes, "traditional controllers" as most current frameworks use them are not ideal. That is why I tried to point out to make use of action classes. We use them since 12 years in our own application framework, mostly inspired by Spring 2 back in the days. &gt; So it's not what about one controller does. It's what function they fulfill together as a unit. No single controller is a unit on its own. It can't perform anything useful by itself. Why? Explain please. &gt; I didn't instantiate a repository I don't need if the item is in cache. Does ADR solve this problem? ADR cannot solve this problem as this is not in the problem space of ADR. You can solve that easily by wrapping that logic in a separate object which would be the ideal way, as you probably do not want to duplicate this kind of check in multiple locations in your application, right? &gt; Also does ADR solve the problem of needed slow, fragile, implicit "magic" for your construction calls? Again you do not seem to get the point of ADR. ADR simply proposes a "different" view of MVC, it does not say that you have to deal with DI, IoC, ServiceLocators or whatnot. &gt; No I think "magic" is a quite apt name reading constructor arguments at runtime via reflection and resolving parameter blindly by type. Where have I ever written that? You simply assume a Dependency Injection container needs to make use of reflection all the time. And while some implementations do, quite a few don't. This whole discussion is pretty useless if you keep insisting that all containers rely on reflection. And guess what, there are even service locators out there which make heavy use of the reflection api. &gt; You're instead trying really hard to invent a "code smell" in what I propose, that isn't there. Well for me the code smell is there and I thought it might be a good idea to point that out, in the hopes of clearifing things. 
Before you want to work with a framework, you need to build a project from scratch without a framework to understand how everything works. 
This would look like a reasonable design decision, but at this point I don't know what problem this change is trying to solve.
&gt; &gt; After all, if I wanted to say "a proxy" I would've said "a proxy". &gt; How should I know what you want to say? Again, if I wanted to say "a proxy" I would've said "a proxy". I said "lazy instantiation", which is not a proxy. Of course, it's my fault that I tell you the right terms and you invent meaning that's not there. &gt; But yes, "traditional controllers" as most current frameworks use them are not ideal. That is why I tried to point out to make use of action classes. You're proposing action classes that don't solve the problem I was talking about, but it solves some different kind of problem you want to solve... It's hard to lead a sane discussion this way. &gt; &gt; So it's not what about one controller does. It's what function they fulfill together as a unit. No single controller is a unit on its own. It can't perform anything useful by itself. &gt; Why? Explain please. It's quite important that you understand what a "unit" is, because if you don't, you can't do unit testing properly, you can't analyze dependencies of units properly etc. You have to choose the boundary correctly. There's a very simple rule of thumb: a unit is the smallest part of a code that you can reuse in multiple contexts/projects, without changing the source code. I.e. a unit is unit of code reuse. Here are few examples of units, as seen in a typical web app. - A router is a unit - A request/response "middleware" solving a general problem is a unit. - A template engine is a unit. - A cache store is a unit. - An entire application is a unit (though ideally it can be broken into units it's composed of, as well). Now let's see. Is an individual controller a unit? When would you take an individual controller from an app and reuse it as-is just by reconfiguring it (through injection etc.)? Remember what "code reuse" means: no copy/paste/tweak. The source should stay as-is. I.e. think of it as a small (or not so small) component, library, framework or an app. That's a unit. Well after years of web app development, I have one reusable controller that works on its own, and it's my API resolution controller (takes a service object and exposes it over HTTP JSON API). Everything else is project-specific, and one controller isolated from the rest makes absolutely no sense. They are not, by themselves, a unit. Only *together*, with other controllers (and typically templates) that work towards the same goal, they form a unit. Say you can have a blog unit, where you just configure it, plug it in a router, and it uses a set of controllers, templates and the given services to produce a blog on a site at the given host and path. That's a unit. I realize you probably will just argue with me and tell me this is nonsense, but I'm telling you anyway, so you know maybe 5-10 years with some extra experience what I was talking about. &gt; Well for me the code smell is there and I thought it might be a good idea to point that out, in the hopes of clearifing things. Well just mindlessly repeating "code smell is there" without substantiating it is quite useless as a statement. And it seems after several attemps you still can't articulate why have you arbitrarily decided what I do is a "code smell". A code smell pointing to what? What drawbacks am I experiencing? Is it a secret, because you aren't telling me.
I'm only at the initial stages of looking at potential approaches, but at this stage am wondering if I might (at least initially) use browser automation and eToro for the actual opening of positions. Was a bit overwhelmed by an hour or two of research on other options. Some also come with costs which I am not currently willing to bear. I have some experience with CasperJS so could probably get something rudimentary up and running from there. I'm more interested in the algorithm training side at this stage so would be happy making relatively few trades.
I've been using this on Atom for a while, and I really enjoy it. It's not as full feature as something like PHPStorm, but it's quicker in daily activities and most of all, it's free. Also to be fair I really don't like that Java look which is typical of the Jetbrains family of editors. Atom on the other hand is super customizable, and PHP integrator makes it (almost) an IDE. So thank you! I sent the maintainer a donation recently, I hope everyone who uses this does the same. It's great work, and it's free.
If your main problem is the management of keys, I suggest you use environment variables (and maybe a `.env.dist` file to track them) to store keys and secrets. This way you won't commit them and see them on GitHub, but tools like Travis allow you to set environment variables that can be accessed during builds (make sure sure mark them as private, so they're not shown in the build logs).
This breaks Wordpress.
From elsewhere in this thread: https://github.com/pmjones/ext-request
As with Lincoln, it appears the "ayes" had it.
Why did you opt for static methods? The static setters will get super confusing for people because it means you will have global mutable state. Making the use of the entire lib a flaky experience.
Well damn. No way I can build anything that measures up to something Paul has done.
I think this is an awesome change. Yes, it's not backwards-compatible, but it's relatively simple to check a codebase for instances where you might be writing to superglobals, and add workarounds. As noted elsewhere, PHP 5 -&gt; PHP 7 introduced a number of backward-incompatible changes, not least its treatment of iterators (which required me to rewrite a bunch of bad existing code), and the world didn't implode.
Yeah I actually agree, not too sure why I didn't refactor that before publishing. Guess Friday night is not the most ideal moment :)
Which ones? 
Php Inspections (EA Extended) is a Static Code Analysis tool for PhpStorm/Idea Ultimate. Finds bugs and gives code improvement recommendations on the fly, supports automated code fixes (Quick Fixes).
Hello
Php Inspections (EA extended) is also the best plugin made for PhpStorm. :) edit: sorry I posted from my phone and didn't notice the mistakes! Also why does it seem like everyone is so negative. I'm allowed to not be u/kalessil and appreciate the plugin that he's made.
You skipped the other point: web servers can have bugs, sometimes with no obvious fix. It's very situational, but sometimes you can end up with no choice but to mutate the superglobals directly. 
The PECL [request](https://pecl.php.net/request) extension, by myself and John Boehr, does much of this right now.
&gt; Or even better - just functions. I'd say that properties on an object are even easier than that. 
I am flattered :-) but credit where it's due: John Boehr did the actual C work; I only put together the userland reference implementation.
What, exactly, is Java supposed to *look like* when not in the context of Java code?
To be fair, everything breaks Wordpress.
I'm glad you found it. 
&gt; numberToYesOrToNo lol
Hi there
I don't know what points you're trying to score by necromancing a thread from four months ago, but it's generally not appreciated, and if you want to have it out with me you'll have to do it on a more recent post.
Not sure if you know some of the reasoning behind the decision not to allow extensions to require non-extension composer packages, but after a lot of thought and experimenting we couldn't get a really usable UI install for extensions that didn't involve fairly long dependency resolution times. So to get the original Marketplace launched and usable for beginners we disabled packagist in the extension context. As of this version (3.3) we've introduced an alternative approach for loading extensions called Bundled Extensions which are targeted at more advanced users, instead of being installed via the admin UI they are just added to the main composer.json file, and registered by specifying which extensions you want your app to load. This means that if you're a competent developer as opposed to a site admin/content editor then you are able to install extensions as bundles and these, like any other composer package can define their own dependencies. So hopefully the answer is that it's looking a lot better as long as you're happy requiring your extensions via composer.
There's a _LOT_ of legacy code out there that relies on mutable superglobals. I think the change is a good idea. It'll lead to way less "lolphp" out there, but it needs a transitioning period. Consider enabling/disabling it by an ini setting and/or throw an `E_DEPRECATED` when trying to write to a superglobal for the life of one major version before making them read-only.
I'd rather use the redirect function someone else wrote, instead of writing my own. e.g: new \Symfony\Component\HttpFoundation\RedirectResponse('https://www.reddit.com/r/PHP/comments/6pa4py/i_want_to_be_able_to_code_more_from_memory_does/')-&gt;send(); And of course I don't need to remember the full name of that class, since I can just start typing *new Redi* and let the IDE offer me a list of possible classes.
&gt; I'd rather use the redirect function someone else wrote, instead of writing my own. e.g: Seriously, you'd rather tack on a big slow third party dependency just for the redirect function? I'm not saying Http Foundation isn't worth using, but in this context you're mentioning it it's a bit funny. I mean literally it'll take you less time to write yourself a redirect function than to add and install Http Foundation via Composer. &gt; And of course I don't need to remember the full name of that class, since I can just start typing new Redi and let the IDE offer me a list of possible classes. It's still a much worse discoverability than seeing a short list of methods on a response object that's given to you. - You need to know there's such a class (may be a method or something). - You need to suspect it's called "RedirectSomething" instead of "LocationSomething" or god knows. I mean the word "redirect" isn't in the header name. - Also the little part where you should be using Http Foundation, in a tightly coupled way throughout your project. 
It just feels a bit wrong to code something myself unless it's either to meet a custom requirement or no-one else has already published code with suitable quality and license terms. For something as basic as redirecting I'd find it unlikely that there wasn't an implementation published that's as least as good as anything I'd write myself, and HttpFoundation is the one I'm familiar with. I'm not sure what you mean about being too slow to use 'just for the redirect' - wouldn't it only take up any run time when the application needs to send the a redirect? You're right about composer though, I suppose if I knew I was never going to have to do anything else with HTTP but send redirects I might just write (or paste) a function based on header(). But most applications that do redirects have to do other HTTP related things as well and are likely to have uses for several things from the HttpFoundation component.
OK, what about `???`? $a = $_POST['a'] ??? 'a';
&gt; It just feels a bit wrong to code something myself unless it's either to meet a custom requirement or no-one else has already published code with suitable quality and license terms. Both options can be wrong. Every time you add a third party dependency, now you have the implicit assumption that they behave correctly, won't have B.C. breaks, and will be maintained for as long as you need them. Those assumptions tend towards a 0% likelihood, the more time passes. And then if you have to fork someone else's code and maintain it, you need to maintain not only your concerns that brought you to the code, but also the other interconnected concerns someone *else* added to the package, which you don't benefit from. There's also the added burden of figuring out someone else's code style and intent, without having them around to help in the transition. Symfony is considered to be a top effort in style, documentation and so on in the PHP community, but if you open lots of classes, you'll notice they're poorly documented, and the code is at times slightly non-sense, after years of patching. The Node.JS community is an example of what happens if we decide to always reuse. There's no surprise that every couple of months there's a huge drama there, when someone slightly breaks some one-liner package, and suddenly half the Node ecosystem goes down. Doesn't **that** feel wrong, too? It's actually two extremes we're talking about. Both extremes feel wrong. Reuse reduces the time you need to ship something now, but it increases effort in the future to maintain and customize your project, as you're locked to someone else's work, who doesn't care about you in particular. &gt; For something as basic as redirecting I'd find it unlikely that there wasn't an implementation published that's as least as good as anything I'd write myself, and HttpFoundation is the one I'm familiar with. If you're familiar with it that's one thing. The context was "I need a redirect and write it manually all the time. What's the next step." The next step isn't putting the handbrakes on the project for 3 months to replace raw PHP calls with Http Foundation. &gt; I'm not sure what you mean about being too slow to use 'just for the redirect' - wouldn't it only take up any run time when the application needs to send the a redirect? No I mean it'll be too slow (for you) to integrate if you have an existing project in progress that's not already using it. That said Http Foundation, for all its good sides, is overcomplicated, redundant, and kinda bloated, but hey... Just personal opinion. Keep loving it :-)
I agree there's always trade-offs to be made between writing custom code, depending on third party code, or taking a copy of third party code and treating it as custom, and I agree the situation with the left-pad node package should have been avoided. The projects I've been working on recently have had Http Foundation installed as a dependency of either Drupal or Silex, so I didn't actually explicitly choose to require it. Is there an alternative package you would use to deal with HTTP? Or would you generally prefer to use PHP builtins and custom code for that?
&gt; Is there an alternative package you would use to deal with HTTP? Or would you generally prefer to use PHP builtins and custom code for that? Oh, I'm such a bad example of what should be done, even I realize it. I wrote my own "Http Foundation" basically ;-) In general, having an abstraction for request/response you can replace with another implementation is beneficial, but often not as beneficial as people think, because most PHP projects have rather trivial HTTP needs. I.e. the middleware explosion never took off in a big way, and most PHP apps run in a server, which means abstraction is pointless (you implicitly or explicitly use the built-ins). 
i too would like this question answered. but it's not important. more like a curiosity. 
I am, but then what's the point of the UI at all? End-users and designers shouldn't be installing extensions willy-nilly anyway.
mysql_*
What about the frustration operator "?!?!?" which uses AI code analysis to simply 'work' without knowing why.
Sounds good! OK, here goes another version of mine: &lt;?&gt; We already have three-symbols operator in PHP. Pandora's box is already open and there's no way back. So why not? And honestly, I always had an idea of wtf operator breaking the execution and exiting with just a message and without an error number: $a = $_POST['a'] WTF "Where's the data, man?"; equals if (!isset($_POST['a']) exit "Where's the data, man?"; cause I've met this kind of code so many times in the art of the newbies, that I already decided that it is an inevitable period in a PHP coder's life, just like acne.
looks like cli php is missing or not in your $PATH. use your packet manager to check for the first and if it is installed check where exactly and with that check for the second.
What is a packet manger ? DO you mean a package manager like composer ? How will I check the cli-php if its missing ? I'm really new to configuring php using nginx T_T
ah yes sorry - it's package management. the thing you use to install software on your computer.
It's crazy how PHP is still finding ways to run faster and is even keeping up with HHVM while using an interpreter. Once they switch to a JIT compiler on top of everything else, I predict shit's gonna hit the fan.
You mentioned git bash, so you are using Windows. The question is, how did you install PHP? Egging_McNut is right that php is not in you $PATH.
Yeah I'm on windows. I used laragon, if you don't know it. It's just like xampp but have prettyurls and built in database system and terminal in it.
The warning is literally telling you that it cannot find a file located in a directory on your server: `/var/www/lxVSdb/lx.ua/protected/../tmp/phpSZcWLr` I think it is trying to go to the folder `protected`, then jump out and put something in a folder called `tmp` which no longer exists. How to fix? If you made this site yourself and you have access to the server, try putting a folder called 'tmp' under `/var/www/lxVSdb/lx.ua` and see if the folder can now be accessed by the system.
They are all about the same age iirc
Yes it's actually crazy that a language mainly for the web still doesn't have a proper request / response object.
&gt; I predict shit's gonna hit the fan Are you using that expression to convey a sense of positivity? Is it that you enjoy being blasted by a spray of pneumatic turds?
Nice try u/kalessil.
Why would you code logging or monitoring from scratch?
So that it does exactly what i want it to do.
Yes
Yep. Python '91, PHP '94, Ruby '95
Cmon, at least PhpStorm vs PHPStorm and proper grammar says it's not my comment ;P
Repost. You didn't actually answer any of our questions last time.
I had to clean up a few things. There were two questions that I remember: 1. Why no composer? Well I just added that. 2. Why doesn't it follow the PSR? Because I think they're old fashioned and I prefer to follow the same conventions as I do during .NET Framework development in C#.
My legacy proj I'm working on now is pretty similar :) My favourite was a function called "isFile" which literally wrapped around "is_file". No, they didn't `return is_file($file)`, they returned 'yes' or 'no' after evaluating `is_file` returning true or false. --- Another, the admins wondered why their order status pages were all slow, after some investigation it looks like their last **Cost Cutting Outsource Crew™** decided to bring in some fancy new icons to the pages... but each icon was deterministically chosen by a function which calls the database (fresh new connection using deprecated mysql functions ) to get the icon for each entry of every row in the order table. This means after looping through and calling the database once per loop for each order after downloading the order list, it does it once again to find out which icon is used. If the list had 200 items, it would have used 1 to get the ids, 200 calls (1 for each item), and 200 more to see which icon it needed. Holy hell no wonder why PHP got a bad rap, the bar is so low that this shit was considered fine by someone out there.
1. Nice, but you could have just posted this in your old thread instead of reposting. 2. Ignoring the standards of a language is not a good thing to do and will definitely not help in making your package more popular. The PSRs are not more or less old-fashioned than any standards in C#.
Old-fashioned as in they're more similar to the way of 1970s C than what more modern language developers recommend but it doesn't matter too much. The PHP community has been all over the place when it comes to conventions for many years and as long as you stick to one thing and it's obvious then there shouldn't be a problem. I don't think anybody's going to think "I don't want to use this library because it's Send() and not send()".
&gt; Michael **Larabel** So close! Yet so far!
Yeah. I once caught him hiring bunch of people in Fiverr to rate his plugin 5 stars. 
I know that I will be literally crushed here, but I commented this on Hacker News: I don't think PHP's main problem is speed. It's generally used for websites, and a few milliseconds aren't going to make a difference when pages are so bloated by JavaScript libraries to often be 5-10MB. PHP's problem IMHO is that I wouldn't be able to use it if it wasn't for autocomplete: inconsistent function names, inconsistent parameter order. The ecosystem is fine, there's Composer, PSR, Laravel. The problem is PHP's legacy. I wish someone created a PHP class one could use to namespace sane function names and parameter order: \PHP\html_entities() \PHP\url_encode() EDIT: ...and here it is: https://github.com/nkkollaw/php, discussion here: https://news.ycombinator.com/item?id=14885226. Pull requests welcome :-)
&gt; Fiverr Oh my, why I didn't think of this before xD Thanks, pal :)
Laragon has a built-in Cmder that can add the correct PHP path automatically. It also wraps Git bash.
I think most of us know this and agree. I don't have to support a lot of legacy so I wouldn't mind but a large bc break is the reality for some folks so I get the no argument. I do think this is a tad overblown though. Just use an ide and the occasional look up for how a function works. It can't be more then a few searches a day at worst.
well laravel was Paravel so yeah close in weird way
Wait, what?
I'm a full-stack developer and I don't know any technology exceptionally well, I just know enough of everything (HTML, CSS, JavaScript, PHP, MySQL, devops). I don't use PHP often enough to remember that `strpos` is `int strpos ( string $haystack , mixed $needle [, int $offset= 0 ] )` and `in_array` is `bool in_array ( mixed $needle , array $haystack [, bool $strict ] )`, and for functions that I use rarely I often type them snake_case before realizing they're oneword. If it wasn't for an autocomplete plugin, I'd take forever to write even simple code. Of course, it's not the end of the world, but it _is_ a pain. I think `\PHP\str_pos($needle, $haystack)` and `\PHP\in_array($needle, $haystack)` would make my life easier. I created the https://github.com/nkkollaw/php repo on GitHub mostly as a provocation, but if something similar got popular enough that it would be crazy if I used it I would be much happier.
for my the problem is a bit of ugly syntax i love flyWay() alot than fly_way()
http://jasonlewis.me/article/laravel-the-story-behind-the-name
Sure, but the standard is fly_away() for functions, flyAway() for methods, $fly_away for variables, flyAway for props, FLY_AWAY for constants. If you deviate from that your code becomes a lot less readable.
2 girls, 1 fan
The perfect alibi.
You are right that formatting was all over the place, but now that it is finally not... And yeah, I would not use a library that is not PSR-compliant if there is an equally good alternative, which there definitely is.
I used to get this when I was using Symfony's HttpFoundation component alongside manually using move_uploaded_file(), i.e. one thing would process the file then the other would try to (this may have been fixed since then, as I believe it was symfony ~2.8 at the time.)
Quote from the sidebar: &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help
You have some valid points, but going from 5.6 to 7.x leads to noticable difference to the end user. 7.2 may not be as noticable to the end user, but I bet you'll notice faster response times as a developer. As for JavaScript libraries. It's true, but there are ways to do things that are optimized for speed on the front end too. 5-10mb worth of js libraries? Oh my.
With your current skills, I immediately thought of WooCommerce. Have you looked into WooCommerce? I know that it's popular with WordPress, and is much easier to learn than doing everything from scratch. There's courses on Udemy with lots of reviews to read through. I personally looked into courses on Magento, but it's a juggernaut. I don't mean to discourage personal learning, but you'll be investing a ton of time if you want to learn how to build an ecommerce website. If you have the time, it might be worth it, but you have to be honest about your priorities. Only you can know.
&gt; Once they switch to a JIT compiler On what basis do you think a JIT compiler will make PHP noticeably faster?
Do you not? 
JavaScript seems to be improved by having instrumenting JITs. Does PHP have unique problems compared to JavaScript that makes it unsuitable for JIT compilation?
You don't have to break BC though. Most of the pain comes from dealing with primitives (numbers, strings, arrays). Primitives can't have methods right now, so there is no code that would break if they were added. Figure out a way to do clean method-based API's on the primitives and you take most of the pain out of the language without any BC breaks.
If your code is depending on this: natural selection.
Why does my code become less readable if I don't mix all the naming schemes?
Yeah, actually my first intention was woocommerce but since everyone on Reddit shits on it and tells not to use it, I looked into other solutions. Thanks for your honest approach. You are right, my priority is not to invest like almost a year of learning into this.
As I understand it, forms require custom POST or GET variables, not being able to write to the super global GET or POST would kill everything.
TLDR: - An Architectural Style is the application design at the highest level of abstraction; - An Architectural Pattern is a way to implement an Architectural Style; - A Design Pattern is a way to solve a localized problem. Interesting.
The lead maintainer created a "Phantomium" repository with the purpose of rewriting PhantomJS functionality with headless Chrome, but no work has been done so far.. I wonder if it's dead or what.
They are fixing it. Chris tweeted about it a while ago 
I think this is more of a question for [/r/phphelp] but the top packages in packagist have these capabilities https://packagist.org/search/?tags=ssh
The problem I tend to run into is getting sidetracked with all the learning instead of doing. It's really easy to do when there's so much to know and so little time in the day. 
I thought phphelp was more for code and examples and php was more general discussion.. sorry! However your tag search gave me a great starting point to look at (phpseclib) which wasn't coming up in the ordinary search results for some reason!
I think I'm going to take a look at phpseclib, if that doesn't work out, then I'll to expand my search beyond php. I just want to execute commands against remote, but your mention of having issues getting multi line output back into php is giving me pause. No way to know for sure just yet though. 
Sounds like what you want is less abstraction. But less abstraction, especially for super common things, is more annoying than helpful.
I like slim framework. It's pretty basic. Haven't tried version three yet. Didn't really like the direction they took on the new version. 
Have you looked into microframeworks? The are ment to be easy to pick up and are less bulky on some parts. But you probably wont find such framework. Using a framework practically means giving up control on the "boring" parts. 
I've no problem with giving up "control" in that regard for the boring parts, that's why I need and want a framework, but I want to be able to more straight-forward go through the code that comes with the framework, without the framework abstracting and introducing complex paradigms. If you see the difference? 
Yes I totally understand. Check out php microframeworks, some of them should have pretty down to earth implementations. (i.e. Limonade)
I'll second this. If you need a basic php routing framework with some minimal middleware and dependency injection support, Slim works well and gets out of the way for everything else. If needed, you can add Twig support on top of it for some view abstraction, but it is by no means required.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I can't speak for JavaScript in general, but the situation *is* different with respect to Node. Node utilises the libuv library, which enables for IO to be performed in a non-blocking manner (by using the evented layer of the OS). This means that all IO operations do not block the currently executing process, making Node applications very performant in a web environment (where IO operations are common-place). PHP applications are more commonly IO-bound than CPU-bound, which means that non-blocking IO could have a far greater (positive) impact on the performance of new PHP applications than a JIT compiler, which will have a far greater (positive) impact for applications that make heavy use of algorithms (such as machine learning applications). Still, these performance increases (and in some cases, lower memory consumption too) are very much welcomed because they can positively affect all PHP applications by simply upgrading to the latest PHP version. Introducing asynchronous primitives with non-blocking IO capabilities would be great, but it won't improve the performance of any application currently written in PHP, regardless of whether they upgrade their PHP version or not.
ssh2 is pretty good and pretty easy, but it has one thing that annoyed the hell out of me. It has no configurable timeouts. I was writing something for work, it would ssh to all the boxes in the cluster and grab the results. Would take about 2 seconds. God forbid you typoed one of the addresses, or one of the boxes was down though. Had like a 20 second timeout. Made the application pretty much unusable. The suggested fix on php.net is to ping each box before you ssh to it to make sure it's up, but thats not an end all either. If ssh isn't responding or a firewall issue, you might be able to ping and not ssh
I took a dive into the source and found support for what you mentioned. You can push a json encoded array like this: &lt;?php $r = new Redis(); $r-&gt;connect('localhost'); $r-&gt;select(3); $data = [ 'job' =&gt; Some\Klass::class, 'data' =&gt; [], 'attempts' =&gt; 0, ]; $r-&gt;lPush('queues:yourQueue', json_encode($data)); BUT In my tests, if `Some\Klass` is uses the same approach like Laravel, e.g. the constructor accepts the payload, this won't work. When `\Illuminate\Queue\Jobs\Job::fire` tries to resolve, it can't resolve the class because the information for the constructor isn't there. So I cannot simply re-use the existing job classes but would have to make dedicated ones it seems?
I've used phpseclib for this in the past. It's an oldie but a goodie.
I would always choose the package that's the right fit for the project regardless of coding style. However, with all else being "equal" and the decision came down to one package that followed a common PHP coding standard (PSR2, Symfony, et al) or a package that didn't use any or (followed a different language's style) I would most certainly choose the package that followed a common PHP standard.
can't you just install the public keys on the remote server and just do some execs or run it with https://packagist.org/packages/symfony/process it's a bit easier and safer.
I don't want to touch the remote server, rather have a dashboard on the main server, click a button and connect to the remote and do the configuring that way, rather than log into each remote and pull down a batch file that will need to be customized for each server. That way, I can have all the configurations centralized, tell at a glance what is installed on each, etc. Thinking of like a private Laravel Forge type deal initially, but that can eventually expand beyond that - i.e. have server 1 set up with Ubuntu, PHP7, etc, but then be able to set up Server 2 identically, except Server 2 is Centos, so different routines need to run. Still in idea phase at the moment, but it's all contingent on running and initializing from the single dashboard, without the remote having anything installed but a package manager.
PHP apps aren't more often IO bound. That's yet another variation on the "PHP apps are more often database bound" myth. If it was the case, apps like Drupal and Wordpress wouldn't get a twice speed up on PHP7 after the engine was made twice faster, but the approach to IO has not changed even a little bit. Of course I'd love me some async IO and I understand the benefits, but we have some more work to do on pure execution speed before we start thinking about radically changing IO in PHP. 
Underscores for variables is a bit of a coin toss tbh.
I haven't personally done any benchmarking on this (it was just something I suspected). I think it would be quite interesting to see how much time an application - such as Drupal or Wordpress - spends performing IO operations (DB access, loading files, etc) VS actually executing PHP code on PHP 7.2, though. That way, we could better gauge what sort of optimisations would be more impactful for PHP developers in general.
Of course. But the skinny from my own experience is: if you write your code like it was written in the PHP3 times, you'll likely be IO bound. But if you use a modern framework, or you write code modeled after the best practices of Java and C# (which is what the PHP community imitates these days), the problem will be all the abstraction layers and complexity of your code, before you even reach into a file or call the database. And abstraction isn't necessarily bad (although a lot of what I see is just... sloppy), so this means we have a lot to benefit from a faster PHP engine. A faster PHP engine allows more abstraction, which in turn allows more reuse, simpler high-level APIs, and this saves human developer time. Everybody wins.
Abstraction is still what I want. I'll try to explain: I still want a framework that provides abstraction of boring tasks and solutions. But I want to be able to dig into the framework in a more straight forward way. I do not need layers of paradigms and trendy design patterns. If you get what I mean? 
Definitely need to take that into account, thank you for the pointer!
Do `composer require phpseclib/phpseclib ~2.0` and then do this: &lt;?php require __DIR__ . '/vendor/autoload.php'; use phpseclib\Net\SSH2; $ssh = new SSH2('www.domain.tld'); if (!$ssh-&gt;login('username', 'password')) { exit('Login Failed'); } echo $ssh-&gt;exec('/bin/bash ls -al'); ?&gt; If you want to do multi line output back, line by line (since you mentioned it in another post), check out http://phpseclib.sourceforge.net/ssh/examples.html#callback . The documentation is a bit dated but anonymous functions would probably work as well.
I don't recall mentioning that a faster PHP was ever a bad thing? My original reply was in regards to JIT compilation, which I don't think will be overly useful for typical PHP applications. It won't speed up the use of abstraction layers, just algorithmic code.
Oh, it does speed up the abstraction layers. In fact, sometimes it outright eliminates them (method inlining), and replaces slow hashtable lookups (which are prevalent in PHP) with fast binary tuples. It all depends on the quality of JIT. HHVM is JIT, but don't use it as an example what JIT is capable of, their engine is relatively basic. It takes a lot of top-notch engineering to build something like the JVM or V8. There are no significant reasons why PHP is slower than JS, the language is quite similar to JavaScript (which also used to be a damn slow interpreter in the IE6 times, BTW). It's just the engine.
Sure, I'm just saying that for most websites PHP's speed is not going to make the difference between fast and slow page loading. Any gain that PHP can achieve might easily equal optimizing an image in terms of page loading speed (IMO, of course).
It's unfortunate that you deleted the topic. I think it'd be an interesting discussion if you left it on for a longer time. Of course, you will get the usual share of "just use popular framework X" but there's no way around it.
You're not mixing naming schemes, you're consistently using the standard way of naming variables. It becomes less readable because I can tell that THIS_VARIABLE is a constant because it's snake case and uppercase, ThisVariable is a class because it's camel case with the first letter capitalized, $thisVariable is an instance or a class, $this_variable is a primitive type. Which one is more readable considering that know what type of construct a variable holds is pretty important: THIS_VARIABLE ThisVariable $thisVariable $this_variable or: $thisVariable $thisVariable $thisVariable $thisVariable
Not really, I'm pretty sure it's covered by PSR.
Next time you should know that "being pretty sure" is not a substitute for checking and then knowing. The PSR-s make no recommendation on variable naming. Implicitly, in code examples, they use `$camelCase`, and there are a few (odd) examples of mixing `$camelCase_andUnderscore` like this.
Sorry, I'm more interested in giving my opinion than being right and seem knowledgeable to a stranger on the internet. It was years ago when I did research and decided that that was the most sensitive thing, but I very rarely see anything different so I guess it makes sense. The only thing that makes sense and I often do (even if it's against PSR) is naming property names in snake case when the objects are data containers for REST APIs, to ease converting between PHP and JSON. Everything is an opinion (even whether Earth is older than 6000 years), I just try to follow what most people do so that code is as readable as possible.
You're more than welcome to use any convention you find comfortable. Nobody would hold it against you. But it can't be your *opinion* what *the standard* is and what is *covered by PSR*. Facts are not subject to opinion.
I'm not a Java expert, but I find Java GUIs (I *think* those based on Swing, but I may be wrong) to have that very distinctive look which never match the native OS style, but it's rather their own thing. It's slightly less pronounced on macOS, but it's very noticeable on Windows. I'm not saying it's a real problem, it's just a personal preference.
As documented, you should configure web/ as your document root, making these file inaccessible from the web. Also, there is a default .htaccess in the var/ folder preventing access even when you misconfigure the document root. 
&gt; You're more than welcome to use any convention you find comfortable. Nobody would hold it against you. Thanks. &gt; But it can't be your opinion what the standard is and what is covered by PSR. Facts are not subject to opinion. I didn't say it was a fact, I said "I'm pretty sure".
`stristr` -&gt; `str_i_str` wow you really improved that function name.
404 not found :(
`git add -f .htaccess`
JITs need time to warm up to maximize performance. The problem is that php has a fire and forget model and that is quite different from JS.
Nice idea. One thing I'd suggest is making it $haystack,$needle instead of vice versa. Reason being that in other functions the "subject" comes first - and the haystack is the subject. 
Those semantics aren't in conflict. Just like opcache stores opcodes and data in shared memory, JIT-compiled machine code can be stored in shared memory (and profiled over multiple requests and even processes), while keeping PHP semantics (from the PoV of PHP developers) as-is.
What? No. Forms need GET or POST parameters, the proposed idea is to not allow them to be written, they would just be able to be read from. You shouldn't mutate them anyway...
I see it as: find $needle in $haystack. No, uh?
I'm not looking into changing the name, just give existing functions a consistent naming scheme. By calling stristr str_i_str it's clear what the original function is, you don't need to look it up. Also, it was a pull request ;-)
So why isn't hhvm beating the hell out of php? Facebook has the resources but they are loosing ground again.
Money doesn't make you smarter.
Works for me.
I agree with you on that.
Yup, I was reading it once I found it and it looks perfect. Weird that it wasn't showing on my search results given it's number of installs, etc!
You could always call the `ssh` command-line tool yourself with `system` or `proc_open` or whatever. A bit fiddly, but avoids an extra dependency.
Ah I didn't read the article so I'm assuming they have some sort of array within them, to write your values too?
No. I think you might not be fully aware what they are, so let me try to explain it: Basically, when you fill out a form and send it, your data is sent to the web server. The web server gives it to PHP, which makes it accessible to scripts using `$_GET` and `$_POST` (and sometimes other stuff). The script can then access that data in a key-value fashion (e. g. say you have an input called `username`, you could access the data the client put in using `$_POST["username"]`). So the superglobals simply make that data available to you. Some devs write to those arrays. But they contain the data the client gives to the server, and they should not really be changed - doesn't make sense to manipulate them since the original data will be overwritten then. Say, I give you 5 notes with chores on them which you should do. Would it really make sense for you to just write new stuff on them? At least keep them so you can remember what to do at a given time.
If you don't find anything suitable for PHP, I highly recommend the executor library for python.
ssh2 is a piece of shit. So many breaking bugs over the years. 
Check out Laracasts. Probably the defacto video course for PHP, Vue, etc.
Where should be the business logic?
Maybe check out lumen then.
&gt; Sure, but the standard is [x] &gt; I'm pretty sure it's covered by PSR. You literally tried to state facts and back it up with a source, then backpedal and say it's your opinion. Next time, just say "you're right, I admit I didn't look it up before posting" instead of trying to twist your words and change what you meant to save face.
Are there any downsides (technical or linguistic) to using the null coalescing operator that I should be aware of?
Please dont use phpseclib. Go native: http://php.net/manual/en/book.ssh2.php
I developed this as an alternative to phpMailer and SwiftMailer. My library is more flexible and simpler to use. However, you'd have to use either of the two I mentioned if you require encryption. Maybe I'll add that feature some day but the main purpose of my library is to pass mail from your PHP to your mail server on the same host.
Check out [Laravel Passport](https://laravel.com/docs/5.4/passport) for setting up backend api's with Laravel.
&gt; Its like comparing a carpenter who bought tools, lumber and glue to build a table to a guy that bought his table from Ikea and painted it. Nonsense. What you describe is Using Wordpress, and then throwing a baby into a turbine engine. That's taking it a bit far. It's like comparing a plumber who bought welding equipment, solder, and all the right tools for the job to a circus clown attempting to juggle a bowling ball, three dildos, and a pygmy goat after his wife left him for the next door strongman who also happens to be a midget that's hung like a coffee can. Clearly there is a huge difference there.
Did you use headless chrome with selenium? --headless doesn't provide as much boost as replacing selenium for a direct connection to chrome through the devtools protocol: https://twitter.com/DorianCMore/status/865109382291488768 https://packagist.org/packages/dmore/chrome-mink-driver
I guess you should create your [rest API in Laravel Lumen](https://www.cloudways.com/blog/lumen-rest-api-authentication/). Because Lumen is a micro framework, it is much faster than full laravel framework. 
I've never tried Lumen, but I always hear that it's best for APIs. What if you need some functionality that Laravel has, but Lumen doesn't? Is there an easy way to "copy" that from Laravel and use it in Lumen?
Check this file: https://github.com/laravel/lumen/blob/master/bootstrap/app.php You can use Eloquent or Facades simply by uncommenting these two lines: // $app-&gt;withFacades(); // $app-&gt;withEloquent();
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [laravel/lumen/.../**app.php** (master → 0a1842c)](https://github.com/laravel/lumen/blob/0a1842c5842f08dcc219bb1826aa5a0394e84fcd/bootstrap/app.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkyg7ur.)^.
I like to think of it as a distinction between a "design monolith" (often a big ball of mud) versus a "runtime monolith" (which might be a big ball of mud, or it might be a bunch of exquisitely organized components.)
https://github.com/jasonlewis/website/blob/master/articles/2012-08-28-laravel-the-story-behind-the-name.md
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [jasonlewis/website/.../**2012-08-28-laravel-the-story-behind-the-name.md** (master → 70ba547)](https://github.com/jasonlewis/website/blob/70ba547b3dd8a77d85c08bce11416ca637c5bbc0/articles/2012-08-28-laravel-the-story-behind-the-name.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkyh3tq.)^.
For the people who jumped from ruby, python.etc to php, why do so? I jumped from django python world to php &amp; laravel for example because of Laracasts
Why would you want to do that?
Jesus Christ... I don't need to save face, I wrote "I'm pretty sure"! WTF...
It's much more readable than using a ternary operator, and has much less potential side effects, so I would say no. The only limitation is PHP version support, you're stuck with PHP &gt;=7.0, I still have a few packages I maintain for PHP 5.5 so I cannot use it for those.
Employability or work obligation/opportunity ?
Or maybe some of them just because they are curious and like to learn new languages.
I don't see how any of this makes PHP more unsuited to JIT compilation than Javascript
&gt; I wouldn't be able to use it if it wasn't for autocomplete In Java, Python, Scala and Nodejs I find myself relying on autocomplete and documentation just as much. The only reason I want the function name/parameter order thing fixed is so I don't have to hear people bitching about it anymore. Its such a non-issue.
Press start -&gt; type "environment variables" -&gt; open system environment variables -&gt; select PATH -&gt; click edit -&gt; add the path to your php install directory.
TBH you shouldn't be doing ssh in your PHP app, unless absolutely needed and their is absolutely no other safer method of doing the task you want to perform.
Well, I wrote a project that had to do that, so... It happens. I needed to call a Windows executable remotely, and CygWin+SSH was the only sane option. Phpseclib saved my ass, other options were unreliable or not working at all. 
Can also benefit from multiplexing which iirc phpseclib doesn't
awesome, thanks!
Mink has a built in `wait` functionality
Not directly PHP related but I thought it might be of intrest to some with MySQL/MariaDB being the database of choice in the PHP world
You only see it that way because the parameters are named 'needle' and 'haystack'. Look at it like 'subject', 'keyword' (for example you'd say "search Google for &lt;keyword&gt;"). IMO it's better to have the needle/haystack functions consistent with all the other functions. 
https://github.com/LaravelDaily/Laraquiz-QuickAdminPanel
I see. I think you're right. I was also thinking yesterday that most of the times that's the order, so it's probably easier to make all of them subject, keyword than not the other way around. I will change it, also feel free to send pull requests to the README or actual file if you think anything can be improved. I created the repo as a provocation for the Hacker News post, but who knows if anything will come out of it, might as well do it right.
If we'll be counting sharding and distribution, I can also scale SQLite to 37TiB ;-)
How far do you want to go? I know of many commercial apps in production based on it.
You might end up in this situation when Lumen features is not enough and you reinventing same thing what Laravel already provides. If you API should be lean and small choose Lumen, for bigger APIs I suggest you to choose Laravel.
This, don't auto-start session on $_SESSION access, just add some builtin, decent OOP api, and just on-construct start session if not started.
I don't "see" this with PhpStorm nor any Intellij IDE. But I tried Eclipse a few days ago (PDT) and I know what you mean. It was immediately noticeable (OSX) and not in a good way Also totally ruins the dark theme experience. Dark dialog background and blueish (slightly dark too) buttons but white frame borders between GUI elements. Simply unpleasant to look at.
So write small one file api ant serve from that server to controll it. I'm now moving legacy ssh client to api &lt;-&gt; api communication. WHy? Because i can remove any access to server at all. And only thing can be done on it will be via api. ...security...
But are they webscale?
I get it, you're in cloudways.com's marketing team, you have a spammy article to fill, so you must start by telling us what "CodeIgniter" is, then when "REST" is, I'm actually shocked the article didn't start with what the "web" is and what "PHP" is. Then you need to have an extended and completely irrelevant plug of Cloudways midway through the article, letting us know how to set up a Cloudways account, with lots of screenshots... Thumbs down... Make articles honest. "Creating a REST API with CodeIgniter **on Cloudways**", and keep the fluff away.
Not an option for me, the Windows server doesn't have a web server instance, that would be a big overhead in terms of maintenance compared to the actual solution. Also, I hope to replace in the future the whole executable with a third party software with API, so.. Same end result hopefully. 
This is something that has helped me improve my code recently. I don't follow it to the extreme, but if I have an inline comment then it's a conscious decision to do so. Also, just to clarify I'm talking about inline comments. I'm not saying comments are bad and that you should remove them - instead you can look at replacing them with something else which adds the same (or more) value.
October CMS. Enough said. :)
PHP Debugging is great, for the most part, at giving you files and line numbers for a fatal error, as well as fairly descriptive reasons for it (e.g. expected semi-colon, found T_STRING, or similar). Here's a really good article on it (not mine) http://blog.teamtreehouse.com/how-to-debug-in-php
Thanks sir Alot of. I will try to do it, but I see on server it folder;-(. but following not as you said. i will try to change it.
That number is just the PHP code from the application folder, no JS or CSS included. Largely copy-pasta all over the place. I have (atleast) one 2k line long function which is one long chain of else-if, with three to four repeated lines in each fifteen line block, to populate variables from the post array. Multiple copies of jquery littered around, as well as out of date plugins for same. Inline JS and CSS EVERYWHERE. No single header, JS and CSS files included adhoc over ~1.4k view files, or just written into &lt;script&gt; tags in said views. It is using a framework, but it's a version from 2011 (impressive since initial development only really started in 2013/2014), and 'separation of concerns' is an unknown concept - views have logic, models and controllers echo, and models expect content in the $_POST array. I have four different instances of get_users(), and three copies of the same JS filename (all slightly different content). Oh, and one of our db tables has 180 columns, which I'm fairly sure could have been normalised. This is why we're considering the best way to refactor/replace large swathes of the monster.
This is well and good for comments explaining *what* is being done, but the more useful comments are to share *why* something is being done. 
I personally find it easier explaining the 'why' in a doc block rather than an inline comment that spans multiple lines. Definitely should be treated on a case by case basis though. The aim of the post was to get you to at least think about whether an alternative is applicable. There are cases where it's not.
It's… addictive.
I love the design of the website, it also loads insanely fast. I wish I was able to design simple things like this, it does not feel like a skill you can learn though? Like I learn rules and tips/tricks, but my stuff is always a mess of puke haha.
Thanks :) as a blog I wanted it all about the content so I spent a lot of time making load as quickly as possible. It's important to set that as a goal at the design phase to make sure you don't design anything that could slow your site down. There's no js, so I didn't need to bring in jQuery. There's not much CSS or big hero images either. Also stuck to 1 font, and made sure that the text is visible while the font is loading. It is a WordPress site, but there's also nginx cache ontop of it to help reduce PHP hits. The only way to learn is to keep trying. Set constraints early on. You could even set a performance budget (a quick Google will reveal some useful resources on what these are).
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
Thank you, I will remove my post.
Are you trying to use AES-EAX for interoperability with something else or are you just trying to protect your data? If the later than I think libsodium / libsodium_compat might be the best bet for you. Current best practices dictate that ChaCha20-Poly1305 be used, which libsodium does by default. If the former... I don't think it's currently possible. I think the best bet might be to open up a support ticket with something like phpseclib or something and see if they can provide a userland implementation of it. I just mention phpseclib because, in-so-far as legacy algorithms go, they seem to be the best idk
Anyone know if/when static (abstract final) classes will become a part of php? Or why not if it won't?
I disagree. Comments are important to explain information quickly. While well written code can be read to understand what is going on, comments can do the job faster and better.
I don't envy you your task. The PHP-cpd lines were also of just PHP, but the jQuery is familiar. I hope it goes well for you.
I would also add https://github.com/bamarni/composer-bin-plugin
I personally believe that comments that explain why are still a code smell. Firstly, remember that a smell doesn't mean there's definitely a problem. If you have to explain why something is the way it is then maybe the problem being solved isn't understood enough, or is being solved in a weird way. Maybe that's on purpose but that still counts as a smell in my book. It's not a hard and fast rule, but there's been many cases where I've written a why comment then later became enlightened and was able to refactor the solution to get rid of the comment.
I'm fine with constants, but why variables and properties should use a different naming scheme is beyond me. Even more given there's always a `$this-&gt;` prefix. But the same could be said for constants, you always know whether something is a constant or not without a special naming scheme. 
The thing is that comments can become out-of-date. Only the code completely describes the code.
fair enough... surely *many* comments could/should be replaced by better design or naming, at least.
"Just to be clear," all your hours will be determined by us, we demand experience and your full attention, creative direction and product development guidance as you earn your pittance, but don't forget that you're a completely expendable contractor (even though the structuring of the work does indeed make this a "job" and not a "contract" under US IRS guidelines for distinguishing contractors from employees). But hey, we're good guys, so after 8 months of this enjoyment, take two weeks off, on the house.
Laravel is now split into web and api, web is for frontend and the api is for server interaction. If you wanted, you could get rid of the web part and remove blade templating to use it solely as an API.
Thankss sir, i fixed problem , thanks for help.
So update the comments at the same time you update the code.
If you mean it in its original sense, then sure, that's fine. My impression is that the term "code smell" is coming to be used as code for "bad" as it gets more popular in the lexicon, which is why I replied the way I did. The kind of valuable comments I mean are usually business requirements/knowledge, rather than purely technical justification. For example, "yes, this is pointless, but management demands it" or "this is redundant but we're contractually obligated to do this".
How would I go about doing that? Is there a doc page about that?
Thanks for the tip. Actually we switched from PhantomJS via Selenium via Codeception to using Chrome headless via ChromeDriver via Codeception: https://sites.google.com/a/chromium.org/chromedriver/ http://phptest.club/t/how-to-run-headless-chrome-in-codeception/1544 http://codeception.com/07-11-2017/drive-your-browser-with-codeception.html When I speak of waiting for HTML validation, we are using the Nu Html checker by running it as a local Java server program. Basically we have it setup such that at the end of an acceptance test ran by Codeception, the last displayed page gets validated: https://github.com/validator/validator
For me comments as doc blocks usually complete the short method name and describe in a more human readable way the "why" and additional information that might be "necessary" to know about it. Just repeating the method name is nonsense to me and sure a code smell and not DRY.
I know the 'feel' you're talking about([this?](https://www.codeproject.com/KB/miscctrl/swing/swing.jpg)) and I don't see that anywhere in IntelliJ products.
I feel like too many programmers pride themselves on their ability to read code, and this a foolish mistake. Yes you should descriptive variable names, and method names. That's just part of writing good code, and should be done regardless of commenting practice. However, even extremely well written code takes more brain power to parse than English. There's nothing wrong with comments, even if they add nothing more than explaining the next line of code. I strongly disagree that we should move away from those. I would rather read a comment above every-line than try to parse the code myself - that's how mistakes get made. Also, I don't like excessively breaking code out into methods. I like to keep my class namespace tidy, so I don't want to clutter it with methods that only exist to aid another method. I like my methods to be used more than once by more than one caller, or be public methods. I don't wanna fill the name space with methods that only get used once, for a very specific purpose in another method. Especially if the only reason to do is to avoid comments. I'd rather have cleaner namespace and more comments. Also, comments often explain why things are done, not just how. Although both how and why are equally important.
Not said enough times: avoiding php hits is the secret to deliver really fast pages, when possible. Any cache within your php helps, but nothing like actually not hitting it. Specially when you're behind a fat framework. Nginx caches or Varnish, ESI.. 
Ahahahahaha. I mean, that's a lovely idea, and in an ideal world, everyone would do that, all the time. Sadly, it turns out that people are hasty, stupid and forgetful by turns.
&gt; If you have to explain why something is the way it is Sometimes stuff is complicated and non-obvious. Maybe there's a super weird edge case that people won't intrinsically understand just by reading one line of code.
&gt; I don't think PHP's main problem is speed. Depends on what you're doing. Some software, by which I mean Magento 2, is extremely slow just for routine operations. A modest improvement to PHP speed would make the lives of those users much easier. It would help if it was a better piece of software, but that's hoping for too much.
Well, that's the fault of a bad developer, not comments.
&gt; PHP's problem IMHO is that I wouldn't be able to use it if it wasn't for autocomplete While I agree PHP's standarad lib has inconsistencies that can get in the way; Why is relying on autocomplete a bad thing, **especially** when you're doing full stack? I do a lot of full stack work and I'd consider it a waste of my time to work in various languages without things like intellisense because I'd have to dig around to find that information anyway. Things like LiveTemplates in IntelliJ products are a life saver. Switch to Perl 5.12 to work on some old ass scripts and forget the various ways of iterating arrays/hashes/whatever? &gt; forea[TAB] Boop, there's a foreach loop to refresh your memory. Perl always takes some time for me to get back in the swing of and being able to pull up code snippets with usage examples is a life saver(Shout out to the [Perl5-IDEA plugin by Camelcade](https://github.com/Camelcade/Perl5-IDEA))
That's fine to disagree. We all see different code bases and apply different contexts to this post. For the majority of stuff I've seen, abstracting to methods makes it more readable and easier to read / scan - typically when a method is doing a lot of stuff. Do you have any specific examples or use-cases? Would be useful for me to learn more about when this doesn't apply. Thanks :)
Yes, and there are plenty of bad developers to go round. Processes need to tolerate bad developers.
Check out knpuniversity! https://knpuniversity.com/screencast/php7 
That's totally fine, but it's literally *the definition* of a code smell.
Yes, comments that explain why the code works in some specific manner is a code smell. Write better code and you don't need to explain why you choose an implementation. But that's not the "why" that people are referring to. "Why" explanations should be used to explain why the code is required in the first place. They should only need to be changed when the business requirements change. The technical implementation doesn't affect these. Eg: "checkout is disabled on wednesdays because of &lt;stupid business rule&gt;"
If the implementation needs explanation then it's probably a bad implantation. Clever solutions are stupid solutions. Comments should explain the business rule that requires it. "We do this because Y requirement" is great.
For me "good code" comes down to being easy to change. After building a few large scale apps, I personally find things easier to change with things split out. 
So you're posting your ugly spam again.
This article needs to explain *when* comments are good. Giving a few examples of why they're bad without really taking about *when they're not* isn't that useful. Or ideally it could just link to Clean Code.
Fair comment. I tried to mention a some use cases, but maybe I'll make an edit with some actual examples. Thanks for the feedback
I'm including those ones as well. A few well named methods, constants and config values can sometimes explain it just as well as a comment. Again, it's not a sure thing. If it was then it would be an antipattern, not a code smell.
I wish we could all live in a world where our programs were so simple, but that's often not reality.
it's not spam i was asking suggestions only.
&gt; According to Martin Fowler, "a code smell is a surface indication that usually corresponds to a deeper problem in the system". Doesn't sound like the definition to me.
Magento
Nope, that's called hand holding. I don't want my code to be dumbed down to match the lowest common denominator.
I've worked in a lot of different jobs in programming, and everywhere I have worked, there have been people who have been good and people who have been mediocre at following process - regardless of their programming skill. The simple fact is that on any group project, if the rule is "do A (which is vital to the code working) and do B (which isn't)" then there will be people and situations in which A gets done and B does not.
I have no idea, but sometime I ask myself the same question. You still can implement them by declaring a class as final, and setting a private constructor.
`Order::whereRaw('1=1');` Just write `Order::query();`
If a function is becoming monolithic, I'd rather split it out as it's own class, with it's own namespace for all it's helper methods. It could either be static, or instantiable, but that way its code will live compartmentalized in it's own namespace of like-methods, and it won't needlessly clutter the class it used to live in as a monolithic method.
The article doesn't support its own title. &gt; That is also why we write comments. To make it easier to anyone to work on (i.e. change) the project – or for us coming back to the project later down the line when we need to make changes. [...] But there is another way to achieve this goal without writing inline comments. [...] Treat inline comments as a code smell. And that's it! The rest of the article is basically a "let's remove some inline comments" tutorial. But where does the article prove or even make a solid argument about **why** comments are a "code smell"? There's a severe lack of **why** in this post. "But there's another way..." doesn't automatically mean the first way is a "code smell" and the second way is better. You can't just say "treat comments as a code smell" without explaining why. Let's take a few steps back and go back to basics: - A comment's purpose is to annotate a piece of code. - A method's purpose is to isolate a piece of code for reuse, interfacing and abstraction (common), or to reduce complexity of very large methods by splitting into sub-tasks (less common). From that starting point, we can see some overlap, where sometimes just isolating something as a method makes it clear enough that we don't need to further annotate it. But sometimes the opposite is true: if we isolate a piece of code from its context, now it has input arguments, a return value, and those have to be documented so they make sense *out of their initial call context*. This may result in *more comments* than if you kept the code inline. But none of this leads to the conclusion that we should use method names like shitty inline comments, especially if the code we're isolating isn't going to be reused (i.e. a single call place), and the call place wasn't that complex to begin with before the separation. So... comments, and specifically inline comments are not code smells. I'm sick of blogs making overgeneralized clickbait statements and then not making the smallest effort to support their own thesis.
Yes. Yes they are.
Ooh thanks, I thought there was a way to do this but couldn't seem to find it. Thanks :)
That's an interesting approach, thanks for sharing. Part of the reason why I wrote this post was to start a conversation and see how other people are solving similar issues
so... that's a gross salary of less than 1300 euros (btw how do you pay your income tax when you're paid by Paypal ? I don't even think it's legal to use paypal to pay a salary ?), with no health insurance or anything... but yeah... you get two weeks vacation on the house !
I don't know. Are you bigger than Airbnb and Uber? They both use mysql.
&gt;I would rather read a comment above every-line than try to parse the code myself - that's how mistakes get made. The biggest problem with this is that any code base that has a significant number of contributors *will* have comments that don't correctly pertain to the code they're commenting, whether because the original implementer simply made a mistake when documenting it, or a later developer modified the code but neglected to update the comments once they'd got the tests passing. The code will compile, the tests will pass, but the comment will mislead you. I've seen plenty of examples in legacy code where the comment implies the inverse of what the code actually does, this is very common when it comes to `if` statements. On heavily commented codebases I tend to ignore the comments on my first read through (unless they're obviously explaining why something exists and not what it does), because I've historically encountered enough misleading comments that I'd rather make sure I understand what the code as written actually does, before potentially confusing my mental model of it with the comments.
Thanks for the feedback (even though it's in a slightly hostile tone). This was meant as a quick write-up on something that I have recently found myself doing. Part of writing and sharing it was to start a discussion and get other views on this - so I appreciate you taking the time to share your thoughts. I agree that I could go into more depth into why I consider them code smells. Maybe I'll make an edit. &gt; now it has input arguments, a return value, and those have to be documented so they make sense out of their initial call context Yes, while the do need to make sense outside of their initial call context I'd argue that typehinting can replace the need to document input args and return values under most use cases. In more complex cases (e.g. mixed type input or return values), it may still be better to keep inline comments. I've had some people who couldn't agree more on this, and others who couldn't agree less. Personally it's been useful hearing the arguments against as it'll help me steer my own usage of this going forward &amp; it's up to the reader to decide whether they agree with it or not.
Not with that attitude it's not. Understanding a system as a whole is a complex task, but understanding an individual method should not be. Are there exceptions to this? Certainly. But it's definitely the exception more than the rule. Smaller, well named, methods are not going to be difficult to follow.
Wow, that sounds great! So they can't pay people in the US under minimum wage, so lets find someone in Europe.
That's true, comments do get stale. From my professional experience, every job I've had has people who don't comment at all, or comment in very limited capacity such as "TODO: replace with better method" Usually I'm forced to read code, often which isn't easy to understand. Or it is, but leaves me wondering why it's doing some things that aren't explained. I guess I'd rather live with occasional stale-comments, than none at all. And try to update those that I find that are stale.
I believe the main problem is probably references, which makes reasoning about code be really hard. e.g. function bar($i) { return $i + 1; } function foo(int $i) : int { // The compiler can be sure $i is an integer bar($i); // The compiler can still be pretty sure $i is an integer and so // this can be converted into a noop. $i = (int)$i; return $i; } However in PHP, we could make life be hard for the compiler this: function bar(&amp;$i) { $i = 'why_would_people_do_this'; } function foo(int $i) : int { // The compiler can be sure $i is an integer bar($i); // The compiler can't be sure what type $i is now and so can't optmise out the next couple of lines. $i = (int)$i; return $i; // this needs to do the return type check. } 
&gt; I'd argue that typehinting can replace the need to document input args and return values under most use cases. Tell me what this function does: function _(int $_, string $_): bool { ... } What about this one: function _(array $_): int { ... } QED? Typehinting doesn't give you anything, except most basic and generic information. That's the code PHP sees. It doesn't see the words you write in the identifiers, just like it doesn't see the comments. Identifier names *are for people*, they are *a form of comments*. But they have to be short and succinct, so that's why we have *actual* comments where we can say more. Labeling comments a "smell" makes just as much sense as labeling any other information in code that's targeted at humans a "code smell". Identifiers, whitespace formatting, etc. And even with identifiers and typehints, you'll fall way short of knowing what a function does, in a real-world case. Let me flesh out those functions above a bit: function pushAction(int $priority, string $descriptor): bool { ... } function countViolations(array $source): int { ... } No need for comments, yet? I think you may be subconsciously relying on the knowledge *you* have about the project *you* wrote when extracting functions to think they don't need comments. Or maybe you're quickly glancing at the implementation, and then thinking you didn't. But reading the implementation isn't the fastest or best approach to understanding a codebase. It's the slowest approach, one of last resort, when the documentation (i.e. comments) are crap. And that's unfortunately very often the case, due to poor advice that calls them a "code smell". 
If you keep reading, I say that it's used for websites in 90% of the cases, so speed is definitely not a huge problem since an unoptimized JPEG can slow down a webpage about 1000 more than a slower PHP version.
Sounds like you need code reviews/pull requests. It's a great way to make sure nothing gets merged without someone else looking at it.
Well, I don't know if it's a bad thing, but I can remember all HTML tags, CSS properties, and all JavaScript functions that I need to use by heart, PHP is the only language I use where I have to constantly look things up if I don't have autocomplete.
Sorry, a really bad joke on a really old video/script :( Definitely worth the watch: https://youtu.be/b2F-DItXtZs
yet another article making sweeping generalizations in the clickbait headline. the only real content in this article is "bad comments are bad". I'm astonished how many developers seem to think ALL comments are bad and don't understand the importance of good comments. 
To follow @orokro statement I would like to note that in the case of monolithic function or method refactorized. It should be preferably contained in a dependency injection container and comply with an Interface (Contract) to allow future changes like (Substitute this refactorized module with another or whatever). For example I remember working on a place that had connectors for API's and were so huge that needed to be refactor. I uncoupled first to classes... then applied strategy pattern using an interface, and then added to a DIC with pimple as a Service.
&gt; However, even extremely well written code takes more brain power to parse than English. There's nothing wrong with comments, even if they add nothing more than explaining the next line of code. I strongly disagree that we should move away from those. I agree, mostly. I don't believe we should limit ourselves to the "why" -- it's often appropriate and useful to explain the "what" as well. It's true that a good developer should be able to understand what is going on just from reading the code... but in a large project, especially one that you're not familiar with, that can be very mentally taxing and time-consuming. For example, I was looking at a protocol library the other day, and tracing the bug I was seeing back to its source involved unwinding through something like 20 methods, 6 or 7 classes, and even 2 or 3 different libraries. Yeah, I understood the code, *eventually*, but it took me a fucking hour or two to get comfortable with the library's structure and figure out how all of these different classes and methods were interconnected. A few simple comments explaining "this is where we use x component to handle y case" would have cut that time down dramatically, by allowing me to simply scan over the comments instead of dissecting the code line by line. Then there's the fact that not everyone *is* a good developer (whether at all or in your particular language). Obviously we can't write code based on "the lowest common denominator", as someone here put it, but adding a few "waypoint" comments goes a long way towards helping others engage with it. If the code is welcoming it can help people less familiar with the project to locate bugs and submit fixes/enhancements. Again, I can use myself as an example: I'd like to think I'm very competent in PHP and several other languages, but I know fuck all about Haskell. When I had a problem with a piece of Haskell software a few weeks ago, I found that the code was basically uncommented and therefore impenetrable to me. If that weren't the case I might have been able to find and submit the fix for my own bug. But since it was, and I didn't have the time to teach myself Haskell, all I could do was submit a bug ticket like any random ignorant user might. That's not very helpful to anyone. Of course, I'm not suggesting we explain code that is patently obvious at first glance -- stuff like this is just noise: // Stop if we have no results if ( empty($results) ) { return false; } But I think there's a good balance to be struck between the above and the common practice of never commenting anything ever unless it's meant to explain some crazy esoteric edge case.
its called lumen
WTF suggestions you are talking about? OK, I am suggesting to delete this fucking shit immediately, just like it was [done when it has been posted the other day](https://www.reddit.com/r/PHP/comments/6pveq9/the_impact_of_php_7_on_magento_development/).
&gt; I would rather read a comment above every-line than try to parse the code myself This is also how false assumptions get made.
I agree that "// Stop if we have no results" is a bit much for the workplace. However, I would totally write that in my own code at home :D &gt; Yeah, I understood the code, eventually, but it took me a fucking hour or two to get comfortable with the library's structure and figure out how all of these different classes and methods were interconnected. Yeah, a couple months ago I was working with some libraries and the only way I was able to wrap my head around them was to go in and actually just start commenting them. In my own branch I started commenting files, obvious stuff at first. And then when I got to some stuff I didn't know, I'd have to go and comment that and then go back. Eventually I ended up commenting most of the core classes in the lib. By the end of that, I had a very clear mental model of the code. Now, months later, I barely remember any of the stuff in that lib, but I'll just go back to my saved comments. 
So kinda in a weird place in my life looking for a skill to pursue...network administrator seems played out these days and web development is something ive always been interested in but there doesn't seem to be a degree so how does one get started lol
So it seems to me that what is essentially happening here, is you are moving the information contained in the comment into the method name? I really don't see the advantage here. You've now increased the segmentation of your code, added some method call overhead, and obfuscated the fact that your code can throw exceptions (something I note you do *not* document in your codeblock, but which can be very important information to users of your functions). This does not seem to be costs worth paying to remove a comment that was rather harmless. 
Current job forbids them unless you have a tech debt ticket reference to go with it. Works well and hella PRs go through in time. Tech debt ticket count has a max limit to.
So, what's wrong with Zend Framework 3? Seems like Zend at one point was on top/always talked about being that framework to use, now Symfony seems to have taken its place. Why is that?
If you are looking for an AEAD encryption, AES-GCM is supported in recent PHP versions, and ChaCha20-Poly1305 is good too, as /u/kemmeta suggested. It [looks like](https://3v4l.org/Zb9B3) PHP-openssl does not support EAX mode nor I know much about it. 
&gt; I would rather read a comment above every-line than try to parse the code myself - that's how mistakes get made. I agree with most of what you said, but it should be recognized that comments need to be maintained along with the code. If there are too many, especially ones of little to no value, they will start fading into our mental background as noise, and not get changed as the code changes. Bad/incorrect comments are worse than no comments. edit: after submitting, I see /u/Tetracyclic said basically the same thing. my bad.
Maybe it wasn't clear enough in the article, but you should still have comments in your code. My argument (whether valid or not) was that you're moving important inline comments into the description above your method - and removing bad comments that don't add anything. Regarding typehinting, it should be used with well named variables and methods - where it provides extra information about your variables and what you expect them to be. As an example I took your use-case and applied a little context in the form of high fiving a user: ``` class User { public function highFive(): bool { $totalViolations = 0; foreach ($user-&gt;posts as $post) { // If a post has negative upvotes then it violates subreddit rules if ($post-&gt;upvotes &lt; 1) { $totalViolations++ } } // You only deserve a high-five if you have a positive upvote count on all posts if ($totalViolations &lt; 1) { return false; } return $this-&gt;update(['high_five' &gt; true]); } } ``` This is what I typically see in code-bases, often with more logic around violations or other reasons why a user cannot get a high-five (for example). Below is how I would tweak it: ``` class User { public function highFive(): bool { if (!$this-&gt;deservesHighFive()) { return; } return $this-&gt;update(['high_five' &gt; true]); } /** * You only deserve a high-five if: * - you have a positive upvote count on all posts */ private function deservesHighFive(): bool { return $this-&gt;totalViolations($this-&gt;posts) &lt; 1; } /** * If a post has negative upvotes then it violates subreddit rules */ private function totalViolations(array $posts): int { $totalViolations = 0; foreach ($posts as $post) { if ($post-&gt;upvotes &lt; 1) { $totalViolations++ } } return $totalViolations; } } ``` In my opinion we've make `highFive` easier to scan for a human. If you don't deserve a high-five, you don't get one. If you care about what that means, then you can dive into it. The reasoning here is that you may not always care about what it means when you're in `highFive`, especially if there's a lot going on. There's no inline comments, and I don't think we've lost anything from doing so. I can see an argument which is "Well you haven't really gained anything either". For me, I find the latter more readable and less overwhelming. The isolation means it's easier to re-use some of the code if needed. The knowledge about whether a user deserves a high-five is in one place and (in my opinion) is changed easier. For example: If you needed to add a new rule where posts with a click-bait title are violations too, or users with swear words in their username do not deserve a high-five then you have discrete places to add these rules (in `totalViolations` and `deservesHighFive` respectively). It also means that `highFive` doesn't violate SRP (as it no longer has multiple reasons to change). Maybe `code-smell` is a term that's too loaded and it was too sweeping a comment from me. For me when I see an inline comment I think "is there a better way". Sometimes the answer is yes, and other times it's no. I needed a name for that moment where you see a pattern and stop yourself to think about an alternative; code-smell seemed to fit.
1500 usd = 1270 eur So calculating if you would be employer in Lithuania after all taxes your suggested salary would be 740 EUR in hand. Your offer highly under average here. Have you listened a fairy tales how is development is cheap here? Have you seen our countries official salary statistics? Jokers. Estimated salary "on paper" 970,80 € The salary "in the hands" is € 740.00 (after all taxes) Applied NPD 14,60 € Customized PNPD 0.00 € Income tax of 15% 143.43 € Sodra. Health insurance 6% 58.25 € Sodra. Pensions and Soc. Insurance 3% 29,12 € Employer's fees Sodra 31.18% 302,70 € Total cost of the job is 1 273,50 € 
no it's not legal but it works. Then in your home country u just register as an unemployed. many of those countries dont have tax agreements with US so this works.
Still a good one :)
google uses MariaDB and Facebook MySQL ..so that far :)
Google and Facebook use it :)
Don't defer responsibility to people who make pull requests when you're the one who approves it.
Classic haha. I hadn't thought about it in years, still made me laugh.
You can't understand how a complex system works by reading one method. And it's not worth the time to dig through a bunch of code to figure out why one thing is the way it is, when you can just leave a comment.
I think uber uses it too. They switched from pg
It's not my article so I'm not sure :) just thought it was interesting 
It is really interesting! I watched their video but still not sure - it seems it is NOT actually **real** php but has compatible syntax. Quote from their video: &gt; It is based on PHP and its grammar is compatible with PHP. 
It was a comment here, collected some minuses, but it brought a good point regarding the plugin verbosity: Depends on the code base and team habits, but anyway it's fully customizable: disable what doesn't fit the team culture, commit .idea/inspectionProfiles/* and collaborate further. SCA tools is a long-time investment as CI - the value is your time, your and your colleagues nerves. Php Inspections (EA Extended) is you friend, major ***kups (sorry) are not leaving your IDE, no one makes jokes or hates you because they had to work late or at weekends fixing bugs. That's a major point IMO. 
"Understanding a system as a whole is a complex task, but understanding an individual method should not be." "Understanding a system as a whole is a complex task, but understanding an individual method should not be." No one said you can understand how a system works by reading one method. No one came close to saying that. You're arguing about something else anyways. If the comment is explaining *why* something is the way it is, that's a useful comment. I'm not saying those comments are bad. I'm saying that if your method is so large that you need to document the how the implementation works it's probably a poorly thought out method.
For embedded systems, sure....but have you checked out many programmable IoT devices?
Wow, this is super cool IMHO. I love projects that try to make PHP something more than it is now (backend-only language). I know PHP was not designed for those kind of things but still I hate the fact that PHP is losing popularity. When people want to learn their first programming language, they hear about so many things Python, Java, C# and Javascript allows to make and that PHP can "only" be used for web development, that it is inconsistent, badly designed etc.
&gt; I'm saying that if your method is so large that you need to document the how the implementation works it's probably a poorly thought out method. Agreed, but small comments through out multiple smaller methods is useful too. Less digging and reading is required to understand what is going on in the bigger picture.
I do not know details of Airbnb and Uber, and the point of my post was not to find-out who is the biggest, but to show that MySQL/MariaDB can be serious. 
There is a yegge on that: https://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html
Question for an expert: Which is 'better' (where better = more manageable over time) - lots of databases with few tables, or one database with a lot of tables? Does it matter?
Exactly my thoughts.
Can't claim to be a specific database expert, but this is really a domain question. If you need something that multiple databases can provide better a bit easier (for example, certain access permissions, certain backup schedules for frequently changing vs hot data etc) then go for multiple databases. Otherwise, keep it all in one database. If you're running single-tenant for multiple clients then you usually end up with either prefixed tables, or lots of different databases. Other than that, it doesn't really matter. 
In terms of buzzwords whose hype has made them nearly meaningless, "IoT" is getting right up there with "cloud".
I get where you're coming from but you seem to be focusing on a symptom and saying all comments are bad, refactor. Essentially, we're exchanging comments for docblocks which are a type of commenting. A lot of times if we look in a method and we see comments explaining certain functionality, chances are that piece could be refactor into its own method. Comments can be present in a method and not necessarily have anything that can be moved to its own method. Comments are not really code smells but they lead to code smells. The meat of the article is good but the title is meh.
&gt; [...] there's a super weird edge case that people won't intrinsically understand just by reading one line of code. &gt; [...] a deeper problem in the system Yes, in practice it's unavoidable. Yes, it's still a code smell.
Python is very widely used for IoT at a hobbyist level. I think most commercial grade stuff is C or a variant though (personally I’d love to see rust in the space) Node... less so, but it’s not unheard of either. Again limited mostly to hobbyist stuff. 
Fixing bugs == code smell? Okay.
This is a method in my CSV encoder. How would you write this method in a manner where it's obvious why does it iterate over all of the rows? /** * Collects keys of each row. It iterates over all of them, since * it's not guaranteed first row has same keys as rest of the rows * * @param array $data * * @return array */ private function getHeader(array $data) { $properties = []; foreach ($data as $item) { foreach ($item as $key =&gt; $value) { $properties[$key] = ''; } } return $properties; }
&gt; If you have to explain why something is the way it is then maybe the problem being solved isn't understood enough &gt; [...] &gt; It's not a hard and fast rule, but there's been many cases where I've written a why comment then later became enlightened and was able to refactor the solution to get rid of the comment. For me, the refactoring you describe generates MORE comments. The original approach was *apparently* appealing for some reason (usually obviousness), and I want to ensure the future maintainer doesn't have the same fight. So, I write a brief description of the original approach, and explain why it failed.
While I get what you mean with this sentence : &gt; I know PHP was not designed for those kind of things ...you have to keep in mind that in the end, IoT or websites, or whatever new fancy thing you will want to do, is mostly HTTP requests and responses. So you can use any language that provides access to STDIN and STDOUT, and make something awesome. PHP is getting old, and other languages bring interesting things...but there's not much you can do with them that you can't do with PHP. The cost might be in the code structure you kinda have to put around PHP (compared to event- and callback-heavy languages like JS or modern-ish Java and C#for instance), but if PHP can work at Facebook's scale, I don't see why it wouldn't at any other scale, IoT included. But yeah, hype is a factor here. See /u/original_evanator 's [comment](https://www.reddit.com/r/PHP/comments/6qour5/although_iot_is_mostly_node_and_python_there_is/dkzcr3u/).
You may be well advised to give us logs, like /var/log/mail.err , /var/log/mail.info when you tried send/receive messages? not some password secrets logs, just error message or other useful information.
Maybe if you cast them both to bools first?
I'd suggest you don't host a mail server and use a mail service like [Mailgun](https://www.mailgun.com/) (free for up to 10k emails a month) or [Amazon SES](https://aws.amazon.com/ses/) ($0.10 per 1,000 emails sent).
That salary is laughably low for a full stack developer.
"A willingness to embrace challenge is also something we are looking for". Working with those conditions for that salary would be the hardest challenge to embrace.
Employees are just as expendable. It just takes more paperwork when it's official.
I would have to agree. If OP can't solve (debug) the problem he's facing without posting a question to a forum, I don't think OP would be right person to run their own mail server. No offence.. 
&gt; Although IoT is mostly Node and Python More like C on the device and Java on the backend, tbh.