Learn the array functions. There are plenty of them, and some of them can help you reduce the code bloat and exec time you'd otherwise spend on foreach loops. Take `array_column`, `array_filter`, `array_map` for example.
No.
Unset works similarly. 
i have updated codebase that worked on PHP5.0 to 7.0, the way i did it was first clone the codebase locally and turn on all error reporting, i also run phpcs with PHPCompatibility tests, after making sure the codebase will function on PHP 7.0, i upgraded our local server. then we started taking the codebase piece by piece, we made sure to refactor all related stuff to that "piece", eventually after few months of internal testing we refactored almost all of the codebase to be PHP7.0+ and the only thing left is to refactor the database which is quite frankly not needed if it gets the job done and has no impact on your performance. There is also another way by routing different paths to new framework that you made and eventually you route all your paths to new one, i call this the nuclear option, i only use this method if the codebase is beyond saving and you want 100% rewrites.
This one blew my mind
If I see this in a codebase, I put it automatically in my s**t list. :P
Near complete. The only thing I can think of is "how do you eat an elephant?" One bite at a time. It's tempting to want to just rewrite the entire thing up front. But it's more reasonable to work in stages. Isolate particular bits of logic. If it's really old messy spaghetti code, sometimes it's easier first to move things into functions, then later into classes. Look for easily searchable/replaceable things and don't be afraid to run simultaneous means of access for the period of the refactor, for example, perhaps you're using $_GET everywhere... switch to PSR-7 requests (even if they're initiated sloppily at first and using some global variable) and start replacing all these calls. Move chunks of HTML output into a templating system, again, don't be afraid to use the mixed method or let your template engine hang out globally for a period of time. Just know what state you're at in moving in the new direction so people don't start to duplicate the ways of doing the new stuff.
Or use the "Collection" object like in laravel, same functions but a bit nicer.
&gt; If this RFC passes [...] I feel like I saw this feature in 7.2 or something, but I was unable to find anything about that other than the RFC, so somebody tell me if I've flubbed this one! This has been implemented some time ago and it's been out in 7.1.0 (we're currently at 7.1.7). In the future check the RFC status on top. It clearly says: &gt; Status: Implemented (PHP 7.1) 
Fully agreed. Really cannot imagine why someone would use the new style.
I've always found the PHP documentation to be extremely helpful (unlike other languages I could mention). I try to spend 10-15 minutes a week just poking around; there's usually something that catches my eye. 
Found that out a few weeks ago too and I was suprised that I never saw that part. Was about to using it, but was stopped, because coworkers be like "that is hard to understand and looks worse"... I mean the `isset() &amp;&amp; isset() &amp;&amp; isset()` is IMHO way worse than this, but okey. I am luckly flexible :D
I highly recommend to read this book https://qafoo.com/book/register.html or rather the refactoring parts of it before you start. You can find these on the same page at the bottom. 
Sometimes it can be useful to build a REST API which sits on top of the old spaghetti code. You hook into the important parts of the system which have tried/tested legacy code, then introduce your own code at a later date. Not the ideal solution in all cases, but offers isolation of old code from new as you transition through the project. I inherited a codebase full of spaghetti code (no comments anywhere, no includes, no object orientation etc) and that was the only way forward on a tight timescale. But as others have said, take it one piece at a time. Audit the code, identify the REAL issues (rather than annoyances) and get a game plan together. Understand the workflow of the code, then you can start picking and replacing as necessary. 
I have unit-tests ... I was advised to not run the unit-tests because they apparently permanently change state in the dev database. Also, I'm not sure how useful the unit-tests are. There are literal unit-tests that check if a public static function (that has no business being either public or static) returns a bool. Here's an example of one such function: function isValidMsIsdn($msIsdn) { if ($msIsdn == "0") { return false; } return true; } My desk has already a dent from all the headbumps.
I've rebuilt an online book store a few times. It's probably a lot less complex than what you're dealing with but I personally enjoyed every minute of it. It was like a fresh start, taking what worked well with the old system, and improved or abandoned the rest of it. Sitting down with the team of people who used and operated the website on an almost 24h basis, finding out what they liked, what they didn't like, what they felt could be improved etc. We flow charted out how the old system worked, and created shortcuts and new pathways for the new system, this flowchart became the draft for the new system. We broke the draft up into chunks, set deadlines for each, and slowly but surely week by week replaced huge chunks of the old clunky site. Developing on the new system thereafter was heavenly. I hope your experience can be smooth and rewarding as that!
Could you give it a sqlite :memory: connection?
I honestly has no idea you can do that same thing with unset. When I found that you can pass isset multiple arguments it was life changing
I do like the PHP docs. they are well laid out and the user comments with various use cases for functions or classes is incredibly useful. 
Pretty much what I'm working on now - We're bringing a project in house that has been managed entirely by an outsourced company till now. Upwards of 3000 files and I-don't-know-how-many lines of code, using CodeIgniter, but with business logic in views and post/get requests in the models. We're going to be slowly isolating individual pages and effectively rebuilding them alongside, moving the links over from elsewhere in the system and removing the old code as we go. So, one bit at a time, unless you have a year or so in which you can have a feature freeze.
Really good advise! I have found myself attempting to do something with an array for hours. looks at the docs and there is a much easier solution using a built in function. I've got this in my bookmarks now http://php.net/manual/en/ref.array.php 
That would require a lot more work, currently the schema is not fully reproducible through migrations, and I'm not sure about SQLite compatibility of all our migrations. Basically our current db is produced by running migrations on a legacy db which contains a lot of data, so I was trying to avoid dealing with that before starting to add tests to some queries . 
Found the node-developer
&gt; you should not worry about them at all haha I know, I see people obsessing about milliseconds on function x over function y then go and drop a 200kb uncompressed image on the site..... cool work bro
Do all these composer features work directly from a vagrant cli interpreter?
As it can be seen, such lists aways end up to become a list of superstitions and useless facts or even bad practices. And the worst nightmare is performance "trivia". TIL that x is faster than y!!! I'll make my code run 3000% faster, yay! 
Adviced not to run the tests. If you are the only developer: save the database before and restore it after. Unit tests (even bad ones) have a function. If you are not the only developer: test it local, or on a separate datebase (with restoring it at the end) You will become a Jedi at this. (may the force be with you) ;-)
I will suggest building unit tests for parts that need refactoring, and then refactor a part and test it again. But perhaps a better way, is to make a clean start in a new environment, and rebuild "the house" brick by brick. Which makes it far more maintainable in the near future. (we would first try a big refactoring battle overhere, but decided to go for a rebuild after digging to deep in ancient coding)
why not make it a github page with examples?
That is an excellent idea! I'm gonna get started on that on my lunch break and link it back to this thread. Thanks mate :) 
Hey I was that poster! I'm glad people are doing new benchmarks and Twig seems to be improving with leaps and bounds. I am seeing some mixed results from benchmarks though. It seems some people are still reporting Smarty is faster while others say Twig is. Maybe it depends on what features you use? I'm not sure. And now the industry has almost completely moved away from Smarty I doubt we'll ever find out. I just want to say that even back then when I was touting the performance of Smarty I was already moving to Twig. Why? Because speed is far less important to me than community support and continual development. These days we should all be caching to improve the performance of our front ends. Simply using Cloudflare will do far more for the performance of your site than switching templating languages. Furthermore complex template operations tend to have moved client side with React and Vuejs becoming ubiquitous even amongst session driven (non SPA) sites. So the real intensive operations are being moved away from server side templates anyway. 
To throw another spanner into the works, take a look at CakePHP 3. It has some powerful features for building APIs (Especially combined with things like [CakePHP CRUD](https://github.com/friendsofcake/crud) and [CRUD JSON API](https://github.com/FriendsOfCake/crud-json-api), or [CakeDC API](https://github.com/CakeDC/cakephp-api)) It's quick, easy to develop with and can easily handle large projects. Here's a talk giving a good example: https://www.youtube.com/watch?v=Ig7luSeab0k
As long as Hack has no tooling (at least nothing that even comes close to PHPStorm) I won't touch it. Even though I agree that it fixes many of PHP's flaws.
Plan, over plan, go back and plan again. Map out every user scenario based on role and create a flow chart for each action with specs and requirements. Ask about future state so you can plan expandability. Give yourself twice as much time as you think you need. Create milestones and have client test each one before moving on. 
&gt; For no reason at all, other than to appease some loudmouths on internals at the time scalar hints were introduced. You should include that in the RFC you propose. It's certain to lead to a productive conversation.
PHP gives access to private and protected properties from external scope - http://ideone.com/dORQXA
You could just write stop using php and use java or c#. It would be the same, because hhvm is just similar to php, but we can say it's separated language. Also as i know symfony 4 will no longer care about hhvm support, right?
Your insight has been much appreciated.
I recommend reading this post, written by a dude I work with: http://onstartups.com/tabid/3339/bid/97052/How-To-Survive-a-Ground-Up-Rewrite-Without-Losing-Your-Sanity.aspx The key idea, I think, is *deliver incremental value*. You're fortunate to have some buy-in from the customer on this, but they will be even happier if you deliver a long train of smaller changes, each of which provides some kind of visible value.
It would be great if there was a CSS Zen Garden for markdown
using "empty" should be avoid. It's a bad practice. Is it "null" or empty string or "false" or "0" ?
This comment makes no sense in PHP
https://3v4l.org/JFqS6
In this instance I don't care, I'm Trying to check there is a value, any value. Before I try accessing it
That's the kind of thing I was hoping someone would link :D
`empty` with class properties can be tricky. It can check a public property only. But given a common practice of using only virtual properties, backed by getters and setters, one hardly can find a public property nowadays. So, naturally `empty($foo-&gt;bar)` returns `true`. To make `empty()` work properly with virtual properties, a magic method `__isset()` should be used in the class. See example based on the /u/fredoche 's snippet: https://3v4l.org/MLktX In your case I suppose you can omit `empty()` and test the returned value itself, if (!$model-&gt;relation-&gt;value); // it's empty `empty()` is often misused due to misunderstanding. It is actually a shortcut for `!isset($val) || !$val`. And if you don't want to test whether a variable is set but only if there is any non-empty value, then omit isset and test the value itself : `if (!$val)` 
"false" or "0" : is it a "value" for your context ?
This remains a bad practice
I guess I'm misusing it, typically I would use it to check, for example. An array from a third party api, that has inconsistent data. I might loop though the data and check If in each row the price value existed. At this point I don't care if the price is 0 because I only want to discover the existence of rows with the required fields
`empty` is bad practice for anything except arrays, since they're the only thing you can test with it that have no gotchas. I think it makes perfect sense to just avoid it altogether, though. You never need it, and it's almost always a potential source of headaches. Not worth.
So if isset() is an effective aliase, for empty. Is it right in saying isset can be used to test for values that may or may not exist at all? Without an error being thrown 
first things first: don't blame empty() which is simply a shortcut. So you are telling me that casting a variable to boolean (like `if ($a)`) is a bad practice in PHP? 
Yes. I recently completed a dashboard for survey analytics that was a complete clusterfuck. The job was "prepare it for php7" but it soon became apparent that the only option was a complete rewrite of the backend and a massive overhaul of all the front end stuff. Make requirements. Sit with senior users and have them explain every button of every page. Have managers explain the point of the application in their own words. Understand the problem it's supposed to be solving. Also make sure to understand any 3rd party dependencies (as in systems that look into its database or use some api and whatever api this beast consumes) Then get a working test version you can fuck up as much as you want. Go step by step to rebuild every page. Basically clone every page but with better code. Make sure you have lots of access to senior users for questions. Have every page / module checked by competent testers who understand what it's supposed to do. And please don't go fixed price on this. 
Nope, isset is not an alias for empty. For what it can be used you can read in the documentation. In all, it will help you no more than empty. If value can be not set at all, you're in trouble. you have to implement __isset methods for $model and $relation classes 
As with just about everything, it depends... 
We have a bunch of stuff so old it is written on cuneiform tablets. 7 or 8 different full ecommerce pages. My job is to completely rewrite them, pixel to pixel. The old databases dont line up with new versions of the framework, the damn thing is so old jquery functions arent even deprecated, they're fully removed... Boss, who isnt a tech guy, seems to think I should be pumping a new complete one every week. It's nuts. He asked on friday week one 'how many sites have been upgraded..." how many!!?? 
Oh, I'll blame it all day. It's a shortcut, yes; but it's a shortcut for a very specific combination of functionality that almost always incorporates pieces that you didn't intend for a given context (wrapped up in a semantically misleading name). It's consistent with PHP's falsey concept, but that's not exactly a boon. Which leads me to my answer to your question: unless `$a` is a known boolean, `if ($a)` wouldn't pass a code review anywhere I've ever worked. Cross-your-fingers-and-pray code doesn't fly with me.
&gt; PHP 7.2.0 Beta 1 builds on previous releases with: &gt;- The much anticipated Sodium extension - Opcache improvements - Countable support for DOMNodeList and DOMNamedNodeMap - Improved handling for invalid UTF8 in json_decode() - And many bugfixes... 
I like the syntax of your library, kinda stands out from the rest who all do it in a similar way. Still not enough to make me switch from something like fastroute though 
&gt; It's tempting to want to just rewrite the entire thing up front. But it's more reasonable to work in stages. Can't upvote this enough. These projects tend to take long time during which businesses usually need new functionality. And if you're rewriting it from scratch, this functionality would need to be added to both old and new codebase. Moreover benefits brought by refactoring are delayed until the whole thing is finished.
&gt; If the database of tokens gets leaked, you can just delete all the tokens. Unlike passwords, tokens are unique across services (as passwords should be, but we know people) and disposable. It would make the user have to sign-in again, which is a minor inconvenience. I personally don't hash/encrypt tokens, but if your application is sensitive, you may consider otherwise. If they notice that the database was leaked. I think there is nothing stopping you from hashing your tokens.
Thanks for your feedback :) I know - usually there is not an option to switch to new library in existing project, or switching to new library requires a lot of work, but anyway I'd like to encourage you to try when you will build something new.
&gt; It has nothing to do with your actual domain It depends on the domain.
Too bad that [property type hints](https://wiki.php.net/rfc/typed-properties) feature was not added in this release:( Edit: Fixed link. RFC linked previously wasn't updated in 2 years.
Docker images can be found here: https://hub.docker.com/r/colinodell/php-7.2/
Ah, thanks! I could have sworn it was already implemented but I had a hard time finding it in a glance in the release docs.
We have such old internal application which had md5 stored password, so much sql injection possibilities and other nasty stuff. When i started work in company we tried to rewrite at least 2 times and failed every time because it was too big to do it. This year we started another way. At first we wanted to introduce some framework but just for routing (in old version there was big switch like 5 levels deep and around 2k lines of code). We chose slim for that. And after a month we were able to push it to prod. Right now we're replacing each page from old legacy code with mysql_query and mixed js, css, html, php and sql to pdo, twig and proper classes. And after that we will introduce some proper services like rbac, logger, mailer etc. This way we can push changes to prod much more quickly and we don't have to wait until we finish rewriting whole application.
hey.. hey guys... stop using thing like the thing it is. use something else that isn't thing as thing, that's how you should use thing. makes perfect sense. stop driving your car like it's 2009, get a hovercraft. and overall, kind of ironic, because the benefits of hhvm/hack are becoming less relevant these days than they were in the past when you consider how far standard php has come. so the then vs now point makes even less sense.
&gt; cuneiform tablets lol :)
Fair point in general in most cases. But this seems to indicate that there might not be another option in this situation: &gt; and I don't really have access to httpd.conf so I can't write my own rules Sounds a bit like they don't control the server, and just have a subfolder in an existing vhost.
That's the wrong way to do something you shouldn't ever do.
Yes. Larry clarified to me that I must have misunderstood him during our prior discussion. However, even taking out platonic, when you add: &gt; two autism specialists, a social worker, and three police officers all agreed that nothing illicit, immoral, or illegal was happening, and everything was entirely fine and consensual It sort of makes the relationship status moot.
Well there are couple of things stopping me: - The cost of hashing a password is once per authentication, which can be amortized over the number of times that authentication is used through the token. But if you hash the token, you hash on every request, which depending on the algorithm can slow down your server a lot (good hash algorithms are *designed* and *intended* to be slow). - You run a very "win lottery, while in a tornado and being struck by lightning" type of remote, but still present risk of colliding one hash with another hash.
&gt; It is actually a shortcut for`isset($val) &amp;&amp; $val` Not quite: https://3v4l.org/VqRbd It's equivalent to `!isset($var1) || $var1 == false` as per the [documentation](http://php.net/manual/en/function.empty.php).
The big picture is that this is part of a class that deals with live events. Like dog shows or bike rallies or NFL football games. You may have several of these events a year, and each one also has many official activities associated with it. So, you have the event, which I refer to as 'doms' and then you have related activities, competition classes, pancake breakfasts, etc, which I call the 'subs'. The columns in the respective tables are named so that they cannot collide, so the code adheres to naming variables exactly what the column names are throughout the class. 
Yeah, of course I wrote it inverted, silly me. Indeed it should be `!isset($val) || !$val`. Thanks, fixed in the comment above
Or inevitable, when you commit design sins like negative assertions: "NotBlank". In what world "can be blank" should be the default mode? In my validation library everything must be "non-blank", unless you explicitly make a union with the "blank" validator, i.e. "or(password, blank)"
&gt; Added global optimization passes based on data flow analysis using Single Static Assignment (SSA) form: Sparse Conditional Constant Propagation (SCCP), Dead Code Elimination (DCE), and removal of unused local variables This looks super interesting, and I'd love to learn more about how it works and the benefits it brings. So far all I've found are the [slides from a talk Nikita Popov gave at PHP South Coast 2017](https://www.slideshare.net/nikita_ppv/static-optimization-of-php-bytecode-phpsc-2017).
This resource: https://leanpub.com/mlaphp Is what I'm working through with my legacy application. 
&gt; But if you hash the token, you hash on every request, which depending on the algorithm can slow down your server a lot (good hash algorithms are designed and intended to be slow). Other good hashing algorithms are designed and intended to be fast ;) You don‚Äôt have to use bcrypt or other algo used commonly to hash *passwords*, since your tokens have enough entropy. [A quick search](http://calc.opensecurityresearch.com/) yields a results of 1 septillion years (and 53 days 23 hours 52 minutes and 10 seconds to be precise) to crack a md5-hashed 128bit token.
lost all my settings after the update :(( edit: i copied /.PhpStorm2017.1/config to /.PhpStorm2017.2/config folder. Yeah!! 2 hours saved!
There's more goodness like that coming in Beta 2. :D
For array, I promote $array === [] instead of empty($array) ;)
I'm doing one right now. I am forced to rewrite it from scratch rather than refactor it. It was originally written (badly) in asp and I'm redoing it in PHP. The biggest issues with the old site are database related - the database architecture needs to be extensively redone, so most of the old code would be broken or useless simply because of that. Aside from that it is riddled with security problems. I am unusually familiar with the company's needs because I've worked for them for a long time, and have a good relationship with them. If it were not for that, I would not want to be doing a complete rewrite.
Be careful, it removes `"0"` as well.
Good lord, this RFC is from 2015. Am I reading it correctly that no one has even implemented what the RFC describes? Does that have to happen before it can even be voted on (I've seen other RFCs that have the voting responses displayed)?
Sequel Pro on the Mac
Ha! Actually I put emoji in my Laravel deploy script. I got the idea from fastlane üòç
I'm the dissenting opinion here. If it's possible to refactor it, do it, but sometimes code is too far gone. I spent 3 months rewriting our core API at my current employer. We freezed adding new functionality to the API during development unless it was a bug fix. We're happy with it. We are now rewriting our CRM, we are still scoping this out, but I get the feeling version 2.0 will take about 3-4 months. These are not small applications, but not super large either. 
[SQLyog](https://www.webyog.com/product/sqlyog) is quite frankly, just amazing.
i use it for years, i've try many others, but none come close to sqlyog simplicity, rapidity and rich features
I agree, I recently switched to a Mac for dev and Sequel Pro just doesn't even come close. I ended up buying parallels and a Windows 10 Pro license just so I could keep using SQLyog.
If you're planning on leaving, what you're effectively doing by documenting your code at this point is creating a quasi-document to transfer institutional memory. It's a good thing, it will help the next guy out. So far as the next dev, it depends very much on if it's just basic maintenance they'll be having him or her do, or if it'll be a full time job which could conceivably allow time to re-write the entire thing. I'd suggest just being a good citizen and document it as you can.
RFC's can be approved and awaiting implementation. You can see them in the [Pending Implementation](https://wiki.php.net/rfc#pending_implementation) section. But, if no one is willing to step up to do the work in a timely fashion... I don't know what happens if say an implementation has been wanted for 3 years. At that point is it abandoned and a new RFC required? That's a good question.
I've got to say, I've yet to see BDSM inspired code before ;) On a more serious note, I do think the naming could be better than dom/sub, but at some point we're going to be splitting hairs :P
They've made good strides with native types in function arguments etc, but I admit, I find it somewhat frustrating that I have to rely on /** @var ... */ comments whenever I want to define things like property types, array-of-type returns etc. I'd like to see them moved to the language itself.
yup, SQLyog is so good it makes switching to Postgres a difficult decision. JetBrains have a DB tool now which may remove this problem, but I found it buggy during the beta and haven't tried it since. 
In my experience I am often the "next guy" - even on my own code, so now I have added documentation as part of my standard workflow. Once I've completed a feature and written tests for it I go back and add documentation. Usually it's just basic doc-blocks, but for stuff that uses recursion or I couldn't find a "clean" way to write it I'll add more information as a reminder. What you are doing is great and responsible. Even if the next guy decides to scrap it - your documentation will serve as a sort of road-map for them.
&gt; SQLyog is so good it makes switching to Postgres a difficult decision. I've been wanting to switch to Postgres for the past two years but like you said, it makes switching a very difficult decision which I've yet to make.
It's also in the URL ;)
I had this book recommended to me. Has it been a good read?
&gt; I'm doing one right now. I am forced to rewrite it from scratch rather than refactor it. How are you approaching this project? Are you mapping the system's business logic into a flowchart, and then coding from there? Are you writing automated tests on which both the legacy and the refactored applications must pass to verify that the new code is valid?
&gt; sometimes code is too far gone. I don't understand what you mean. Can you elaborate?
&gt; Sometimes it can be useful to build a REST API which sits on top of the old spaghetti code. That was my first thought too. It has the benefit of being much faster to implement, since testing tends to be very straight-forward; however I feel that there will be a point when a new feature is requested but the underlying layer of this new REST API (which is the old "spaghetti code") is incompatible with the requirements, so the coding will need to be done in the old code. We'll be postponing the problem. Did this happen to you?
[Adminer](https://www.adminer.org/), a simple, one file, web based app for most of my database needs and support all mainstream databases... just drop the `adminer.php` on your project's public dir, and you're ready to roll
Same. This is one of very few tools I use that I haven't found any good alternative for on other platforms and really ties me to the Mac (not that I want to leave)
I will add that article to the list of things I need to read, thanks. Also, yeah, funnily enough I find that sometimes the biggest challenge in my job is to convince the non-tech people to buy in. There's this mindset that everything in IT needs to be measurable and every effort has to be towards adding identifiable value to the company's product. The value of a product refactor, however, is usually not assertable in the short term, and communicating this idea to the business staff can be tricky.
That's one of the plans I have in mind, yes. Mapping the system's business logic into a flowchart, and then coding from there.
Any reason why 5.5.x is not in any of the graphs or report?
Features that are based on composer.json (PSR-0/4 folder detection, PHP level detection) will work with any cli interpreter. Unfortunately, for execution, we support only local PHP CLI for Composer. Please vote for https://youtrack.jetbrains.com/issue/WI-36213
5.5 is in there. Figure 2 is just ordered by usage, so it is below 5.3.
I haven't seen any similar reports, so it's probably either a configuration issue or some interaction with other software. Please try to disable all 3rd party plugins (open Preferences|Plugins and select Custom in Show). If this doesn't help, please contact our support team - Help|New Support Request we would need some info from you.
This is pretty much the course of action I intend to take. Still considering other options. But I believe that this approach is the best from a technical point of view -- it will produce the best possible code. The downside is it seems to be the most time-consuming -- that means expensive. It's difficult to sell *expensive*, and that's why I'm thinking of other ways to achieve what was asked in case this one gets turned down.
this is such a vague article..I mean no real data, statistics or anything..they mention one bug with unserialize stating the application was secure and the bug was in PHP..which isn't really true because the application was storing user cookies via unserialize which shouldn't be done in the first place. But yeas every programming language has security holes but articles about them should be a lot more serious
Many excellent deprecations: * `__autoload()` * `create_function()` * `(unset)` * `each()` * mcrypt extension
I'm glad to report that the issue has been indeed fixed: https://youtrack.jetbrains.com/issue/IDEA-171010
Please try to disable all 3rd party plugins (Preferences|Plugins and there Show: Custom) and if this doesn't help contact our support team (Help|New Support Request).
My hero!
It's less of a read and more of a "do these small steps in this particular order" with examples and explanations. You will pass through the entire code base a number of times, each time making one modernization. The goal of the book is to make incremental steps to your code base while keeping the application in working order. Make a targeted and specific change, (test) store to git, deploy to production. Repeat. The advantages are that instead of recreating your code base, you keep all the institutional knowledge stored in the code. Instead of rewriting to a framework, you modernize the framework that is already created. After modernization, your code will be in a better position to add a templating package, or moving into {sexy new} framework. 
That's false. If there is value, you can articulate it somehow. If you can't articulate it, how do you know there is value? Furthermore, I have the utmost respect for code that is running in production. The moment you change it, you add risk. Just be aware of the real world ROI of refactors and rewrites. Maybe the resulting system is more stable and reliable, but you won't know until you write it, deploy it, and operationalize it, so make certain it won't be a sunk cost. Do this by iterating and limiting risk at each step. 
&gt; I mean no real data, statistics or anything There are statistics about PHP versions in use. &gt; they mention one bug with unserialize stating the application was secure and the bug was in PHP We never wrote that the application was secure. &gt; which isn't really true because the application was storing user cookies via unserialize which shouldn't be done in the first place No, the bug that lead to the command execution was in the core of PHP. Don't believe me? Then read these: * https://bugs.php.net/bug.php?id=72433 * https://bugs.php.net/bug.php?id=72434 I think most people of us here know that passing user input to unserialize is dangerous and should not be done. It was still an unintended memory vulnerability and the Pornhub hack would not have been possible without a bug in the PHP core. Not all memory bugs are in unserialize, as we show in the blog post with some examples. There are way too many vulnerabilities to list them all, that is why we included links like https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/PHP-PHP.html for further information. &gt; But yeas every programming language has security holes but articles about them should be a lot more serious The article does not say nor indicate otherwise. If this is the case we did a bad job at explaining our intention. To be honest, I think the introduction of the blog post is pretty clear though. The article was meant to remind people that your application can be insecure even if your code is good if you (or someone else) uses an outdated PHP version. So upgrade to 7! ;)
i did a diffcheck on our two lists and the only ones i have that you don't is "LaravelPlugin" and ".ignore". Guess I know what I'll try and live without.....for science
I added examples directory, including quick integration with Symfony https://github.com/awesomite/chariot/tree/master/examples
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [awesomite/chariot/.../**examples** (master ‚Üí 97a632d)](https://github.com/awesomite/chariot/tree/97a632df6c1fcffeb3e1266dcf10415bf9d7a176/examples) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkhcd46.)^.
Not the OP, but it's always a balance of time. If you have requirements that if written from scratch would take 1 hour, but for some reason there's 10,000 lines of spaghetti code to try to make into something sensible, then it's going to be more cost-effective to just rewrite. You also may have a situation where the code is conceptually completely wrong, wherein a refactor and a rewrite are in essence the same thing.
Am I old and out of touch because I still exclusively use the CLI for my database work?
My needs are simple enough that I can use the database viewer/manager built into JetBrains' IDEs. I do most of my work on a dev database then use migrations to apply it to production. Anything else I can remote in and use the database's shell(MySQL/MariaDB/PostgreSQL/SQLite)
It's what I do, too, so yes.
Hooray for old farts!
Everyone on this subreddit ought to know they should be running the latest version already. What's really cool for us is that RIPS will drill down into your code and tell you *which PHP interpreter CVEs* affect your code on a given PHP version. Everything else appears to be written for a general audience.
Assuming you're using MySQL, I'd suggest reading [High Performance MySQL](http://shop.oreilly.com/product/0636920022343.do). Also run `EXPLAIN` on your queries to better understand how they're being executed, e.g. `EXPLAIN SELECT * FROM &lt;some table&gt;;`
I very much like the direction PHP is heading. Can't wait to see what the next update is that matches PHP 7 in the language's innovation.
SQLDeveloper, because we're an Oracle shop.
Mostly pgadmin
thk bro should like a great resource 
Mostly using [HeidiSQL](https://www.heidisql.com/) on Windows 10 and [phpMyAdmin](https://www.phpmyadmin.net/) where necessary. [Adminer](https://www.adminer.org/en/) is super useful if nothing else is available for whatever reason.
&gt; Everyone on this subreddit ought to know they should be running the latest version already. Oh, if only this would be true ;) Ought, yes. Fair point though. Somewhat unrelated, but I am a big fan of your crypto related work in PHP, thanks for that!
This. Highly recommending the use of one of the [alternative designs](https://www.adminer.org/en/#extras) though ([favourite](https://www.adminer.org/static/designs/lucas-sandery/screenshot.png)).
It's been without a patch for two years so I guess it can't hurt to wait one more.
Used this when I was still running windows. It was the one thing I actually missed after the switch to linux.
I use Adminer and the CLI, depending on what I'm doing. If I'm writing out joins or anything complex, I'll go CLI. If I'm creating tables, inserting rows, querying single tables, or need to reference the data on screen for a while, I'll use Adminer.
I use Sequel Pro. It's not fantastic, but everything else is worse.
You don't even need a web server: docker run -p 8080:8080 adminer Then [http://localhost:8080](http://localhost:8080)
&gt; But yeas every programming language has security holes but articles about them should be a lot more serious To be honest, PHP has had alot more vulnerabilities than Python, Ruby or Nodejs: * https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/PHP-PHP.html (555 vulnerabilities) * https://www.cvedetails.com/vulnerability-list/vendor_id-12113/Nodejs.html (25 vulnerabilities) * http://www.cvedetails.com/vulnerability-list/vendor_id-7252/product_id-12215/Ruby-lang-Ruby.html (59 vulnerabilities) * http://www.cvedetails.com/vulnerability-list/vendor_id-10210/product_id-18230/Python-Python.html (30 vulnerabilities) Of course it may not be such black and white, but this certainly should give some view point.
That's a shame it only supports MySQL. Do you use the visual query builder at all?
Sqlyog for sync and importing external sources like xls Sqlmaestro crud for views / functions and stored procedures Adminer for daily data work Try it. This is the best method ;) 
A combination of PHPStorm and MyCLI
So basically you want composer and download your own DI classes and other libraries, basically forming a framework of your own? Why not just start on some laravel tutorials ...? Your brother will be better off in the long run
I use Navicat 
Slim should meet your requirements. Very lightweight. Very fast. Strongly recommended.
Its just a framework, its like asking whats a better car to drive to the grocery store, a dodge charger or a bmw sedan, the one with the better driver.
I use HeidiSQL
It really depends on the product features, specific use cases and budget/time constraints. I assume a REST interface will be needed at some point. The trick is ensuring you can code up APIs using responses from legacy code, then implement new code at a later date. Easier said than done. Will you hit a few functions that spider off deep into the legacy code? Probably, but that's why it's important to understand (preferably by documenting) the legacy code FULLY. Once you understand the legacy code, you can see the workflow required to achieve the resolution of an API call. More often than not, you'll need to break apart legacy code into smaller, not bigger chunks. That's where you do your refactoring, then plug it into the REST API. Saying that, it really depends on the system in question. Would I throw it all out and start from scratch in your position? Maybe üòâ
The problem is getting everyone else to give it the same priority. I work on a PHP 5.3 corporate app that, if knocked out, would totally paralyze the company. No new proposals, no new sales, no invoicing, no control over currently-executing work... There's a bit of wiggle room in terms of sending apologies to customers and telling people to temporarily note things down in Word documents, but apparently processing $500,000/day revenue isn't enough to justify a good system for handling it. 
 &gt; However, I have some concern about the security of my website and I don't know how to create clean code without a heavy Framework like Symfony2. Symfony is just some glue to connect your controllers/views/services/models together. It does all of the annoying part like figuring out where to put routing and configuring DI and connections. There is no point to not use it and it's fully documented. Why teach your brother bad coding by doing it yourself and making mistakes. Will your form class have XSS protection? Will your db wrapper have sanitation? Will your view class escape/remove all tags/code from it? Professionals use frameworks for a reason, they are smart enough to roll their own, but like the simplicity, how well tested and documented it is.
Symfony isn't heavy :)
Datagrip is great and feels seamless switching back and forth from PhpStorm. Occasionally fall back to Sequel Pro.
The yaml files are all compiled down to php so no performance impact but it is increasing the ease of use.
I've helped refactor codebases from 5.3 to support 5.6. It's challenging, but actually far less daunting than it will seem at first swing.
I use datagrip or the built in features of phpstorm. For the simple reason that all the other alternatives on Linux all have either strange ways of doing things or are just downright buggy.
Explain me why exactly an optimization process makes it heavy? It only increases performance.
One of the big blockers is that our database text encoding types are fundamentally screwed up in a way that conflicts with newer versions, and we're using several obsolete/discontinued libraries. If it were just a matter of fixing individual pieces of "our" code it would be less painful. Mentally speaking, I'm at the place where I may shrug and mutely points to the backlog of tickets I made years ago. 
And by your logic, Laravel is heavy, I don't need queues, an orm or a view for every project. Every project comes with features I'm not using. Hell, PHP is heavy, why not go straight C/C++ and get 10x the performance? Your argument is pointless. 
CLI, mysql workbench, phpmyadmin, pgadmin. I don't care too much for most tasks - as long as it's allowing me to write queries I can live with it.
Abandoned PEAR libraries, perhaps? I know the pain. HTML_Quickform struck frequently.
Any hints? :D
I second this. I just recently moved from working with vanilla PHP to using the Symfony framework. Their framework is lightweight and their guides are easy to read and learn from.
And overkill for pretty much everything
Says the guy who throws 502s on his blog.
a web framework is a tool , do you want build a car? Use a modern tool for that. 
It hasn't even been voted on. This is a *massive* amount of work to add the syntax in. It should be approved before someone spends their time adding it to the engine.
Studio 3T
The built-in array functions have an *awful* interface. Collections as in Laravel are [things of beauty](https://adamwathan.me/refactoring-to-collections/).
Hey, did this article ever get written? Is it still in the works? Just found myself on SitePoint and I remembered this comment.
There are two property type RFCs, the one that was proposed and declined for PHP 7.1 is https://wiki.php.net/rfc/typed-properties. It has not been resubmitted for PHP 7.2, though there was some progress on implementation issues.
I dont see what makes symfony "heavy" Take symfony as a microframework , add twig, routing, an orm... and you are inching your way closer to symfony anyway. https://symfony.com/doc/master/configuration/micro_kernel_trait.html
static analysis may help to keep syntax clean &amp; help identify bugs / potential fixes (but won't catch everything)
MySQL Workbench (from desk) or CLI (from smartphone) 
Leave a document that describes processes around your code, e.g. how to deploy a new version after changes have been made, server requirements and required extensions etc. Maybe write down a few things in regards to the hairy bits and/or why you choose to do certain things in a certain way. You basically want to give the next person "context" around your code and just documenting/cleaning up code doesn't really do that. Also, leave an email address where the next person can ask a question or two. Instruct them to collect questions rather than firing off an email each time they run into something. Let your former employer know that you're willing to answer questions but that there is a limit to want you can do. 
&gt; Are you mapping the system's business logic into a flowchart, and then coding from there? Sort of, yes. I didn't make a flow chart, but rather a series of checklists. &gt;Are you writing automated tests on which both the legacy and the refactored applications must pass to verify that the new code is valid? i'm not using automated tests at all YET. The site is never really going to be large scale - it serves a fairly small customer base. It mostly revolves around managing a large database. Manual testing is fairly easy, and it's more important to achieve functionality as quickly as possible. I've written most of the code myself, with few third party libraries. Once I get the thing up and running and serving customers, I will have more time to go through it and streamline everything. I'm about two months away from having it fully functional, and I have about 6 months of real work in it. I had to add some features their existing system didn't have, and those are already operational. None of the old code can really be refactored. It was written a decade ago in asp, and is running on IIS with a MSSql db. The old site stores passwords in plain text. If it were written in PHP I would totally refactor it, but I don't know if that would make it any less a job. 
Thanks I will give this a go. Hopefully when enabling plugins I can find out which possible plugins cause this behavior. Might take a while with error and trial
Slim is love, but flight is life.
No, one of them was a dud (Atlantis) and October just blows Pyro out of the water so much it wasn't worth comparing. I don't think I'll write it in this form, maybe compare more mature solutions across the board, not focusing on Laravel based ones, but it's a time issue, so many topics, so few authors.
This article is rather misleading. Many releases that ship with major Linux distributions like RedHat / CentOS do [receive backported security patches](https://access.redhat.com/security/updates/backporting) long after end of life. While I'm certainly not advocating for the use of outdated PHP releases, that does mean that we can't simply determine what vulnerabilities are affecting a given installation of PHP from the version number alone or that "79% of all PHP websites run at the moment on a vulnerable PHP interpreter".
While PHP may indeed have more exposed vulnerabilities, it is a *significantly* bigger attack surface due to the ubiquity of PHP, and has had a lot more eyes on it for longer. That's not to say it isn't comparatively worse, just that as you mention, it's not entirely enlightening to compare those numbers.
Not bad. - +1 for just matching and returning something others can write a resolver around - +1 for custom pattern registration - +1 for basic reverse routing - -1 for inability to transform params - -1 for inability to reverse-transform params Overall: +1 -- I could give it a shot on a smaller project in the future.
How about just don't care about hipster elitism. If you build shit that works and gets the job done the rest is just icing. I've learned and used a variety of things that people heap scorn on but I don't worry myself about it because I know what problem something solves, what tools were available, and how things worked before I used something elitists would consider foul beyond imagining. For example I worked for a company where payroll for 100 people was based on spreadsheets that supervisors individually created and emailed to their supervisor. They were 2MB per team (spreadsheets bloat a lot with overformatting) It took at least 1 hour per team per month. The data source was an intranet. You know where this is going! I automated it with VBA, every month I ran it, compressed the results and sent the bundle on to be used if a supervisor missed work etc. EWW scraping!!!! ewwww VBA what kind of brain damaged moron uses VBA? the kind working in an environment where having python and access to the database was a "no fucking way ever" proposition I got shit done and got people paid, felt good even if elitists are disgusted by my pragmatism. Just like a great musician can make music with [a funnel and a garden hose](https://youtu.be/g3hWdUDi_iA?t=87) a shitty musician doesn't get any better with a Stradivarius. Its more about the person than the tools IMO. No denying that some tools can make things marginally easier, but at the end of the day the tool is generally such a small factor. Its easy to trash php if you just ignore all of the positives. 
FWIW you can use parts of Symfony without using the full stack framework. I typically use: symfony/http-foundation symfony/validator symfony/console filp/whoops nikic/fast-route swiftmailer/swiftmailer As a base set of dependancies. 
Relevant, its easy to be the opposition party... to be against something. Far harder to be on the other side of that equation.
Heidisql user here. (long time user). Free to use, easy too. Works for remote too, I use it with SSH keys without a problem. 
how about looking into how to migrate those servers inconspicuosly from one version to another It's been done before and it's no rocket science.
I love Delight. Very minimal and well-designed. It's spread over a few modules but you can use Composer from the "PHP-Foundation" project to get them all: https://github.com/delight-im
I happily turn down projects if they have unrealistic expectations to start with (and I can't adjust them). There's no point in turning shitty unmaintainable code into slightly less shitty unmaintainable code. 
&gt; It's been done before and it's no rocket science. I get the feeling you haven't worked on large underfunded projects before. It doesn't have to be rocket-science to be impractical. 
Total click bait. The author says: &gt;Often a single missing character... ...opens the gates for an external attacker. And then links to this: https://www.ripstech.com/blog/2016/serendipity-from-file-upload-to-code-execution/ Where is the one missing character? Its not clearly explained at all. You'd think they would know the difference. 
&gt; If this is the case we did a bad job at explaining our intention The article is nonsense, what am I supposed to take away from this? &gt;So upgrade to 7! A whole lotta click bait just for that?
&gt; To be honest, PHP has had alot more vulnerabilities than Python, Ruby or Nodejs?: These numbers do not reflect the number of issues across the languages for all time. Also, Nodejs is not a language anymore than the HHVM is a language. I think that it's unfortunate ppl are downvoting you, but it's important to try to keep proper perspective of the rigor used to maintain these languages. An open-issue list is generally kept for each version of each language and a graphing (of those open-issues) from the internals lists would probably be the most comprehensive picture that could be assembled.
Illegal memory access-in-place without an overflow is a pretty nasty bug.
Are security patches backported to outdated PHP releases?
HeidiSQL. I don't like having a browser based database manager. Much prefer to lock the remote account down to localhost and then have an SSH tunnel to get in.
"goodness like that" as in more perf work. :)
that may be mainly because PHP is used in over a billion websites whilst node is still young and ruby and python are not really wide spread..I do believe that if they war as popular as php the security holes would just open up
PhpStorm has a built-in client that takes some getting used to. It's similar to the standalone DataGrip and will work with just about any RDBMS that has a JDBC driver. We're a Postgres shop, and a lot of devs were using PgAdmin 3 and 4. PgAdmin in any version is a good example of how to not build a database tool.
I really love these two books. https://www.amazon.com/Database-Design-Mere-Mortals-Hands/dp/0321884493/ https://www.amazon.com/SQL-Queries-Mere-Mortals-Hands/dp/0321992474/ 
Like many, I started with pma. Then I used heidisql for a number of years. Now that I've learnt to use the DB features phpstorm/datagrip (same thing, the features of datagrip are already built into phpstorm) - I much prefer it for all the usual reasons that jetbrains IDE rock - i.e. all the get-shit-done-quickly minor touches. And just as a bonus, it's all there in the same IDE I'm writing the php code in. If you already use phpstorm, take the time to figure out its DB functionality. It seemed a bit shit to begin with, but now that I'm used to it, it's way better than everything else I used in the past. Only thing is it doesn't handle creating users with a GUI, but it's awesome at everything else related to actually working on a project. Creating users isn't something you usually need to do that often, so I just use commands for that now.
I tested phalcon/volt on this template and it was 10x slower than smarty. $view-&gt;setVars($data); $view-&gt;start()-&gt;render('index','index')-&gt;finish(); return $view-&gt;getContent(); Maybe I'm doing something wrong?
EMS SQL Manager. It's by far the best client I've ever used.
OP, Where is the github link?!
SQLyog is great. Here you can download the free [SQLyog Community Edition](https://github.com/webyog/sqlyog-community/wiki/Downloads).
A test that uses any kind of infrastructure, like a database or a filesystem, is not a unit test. It's an integration test. We typically don't write unit tests for code that doesn't belong to us, as we'd need to mock third-party classes (look for "Don't mock what you don't own"). This means that for any code using doctrine you need an integration test that would actually hit the database. For this reason it's beneficial to decouple from doctrine - in other words invert the dependencies (look for "Dependency Inversion Principle"). You can achieve this by introducing your own interfaces (for example for repositories), then stub and mock them in your unit tests. You'll then integration test implementations of those interfaces (the adapters). This way much less tests will hit the database. Having said that nothing stops you from stubbing/mocking doctrine (apart from few final classes). You should just be aware of the consequences. Such tests will rely a lot on your assumptions towards how doctrine works. They will also depend a lot on the implementation, therefore will be hard to maintain and change. Bottom line is they won't give you full confidence you're using doctrine correctly. 
Just wanted to clarify naming here. A unit test that hits a database is not a unit test, it's an integration test.
Nice source.
MySQL Workbench
Thanks for pointing out - must've been an oversight.
Sorry guys. The link is: https://github.com/dinnertoast/dykphp Feel free to add some interesting things. I'm going to be adding to it over the next couple of days
Doing this too, well I'm a liar because I'm not doing this exclusively. I also use the phpstorm integrated DB Tool when I'm not yet familiar with the table structures and when I've got a dump of an existing project.
1. /r/phphelp 2. Frankly, ALL your ideas are wrong. 100 files is not even nearly a "massive" codebase. Reasons why you should be using prepared statements are different and your ideas about mysqli_real_escape_string and regexp are just blunders. 3. After all, your question is illogical. If you want to keep the old approach, why on the Earth you are moving to PDO? TL;DR. If you want to keep with insecure queries, just leave everything as is. If you want to be safe than sorry, **DO IT PROPERLY AND DON'T BARGAIN ON SECURITY**
Thanks OP. Very fast response!
MySQL Workbench on Windows
Besides, consider using a **wrapper**. Using raw API is like biulding a car from scratch instead of buying a ready made one. I know, PHP noobs are scared to death by every piece of software that is not described in the basic video tutorials, but just consider the two pieces of code $data = []; $bar = $mysqli-&gt;real_escape_string($bar); $baz = $mysqli-&gt;real_escape_string($baz); $sql = "SELECT * FROM foo WHERE bar='$bar' and baz='$baz'"; $res = mysqli_query($sql) or trigger_|error($mysqli-&gt;error); while ($row = mysqli_fetch_assoc($res)) { $data[] = $row; } and $sql = "SELECT * FROM foo WHERE bar=? and baz=?"; $data = DB:run($sql, $bar, $baz)-&gt;fetchAll(); Do you REALLY need all this stupid stuff with escape, query, fetch and while for the every query you run? 
phpMyAdmin as backup PhpStorm's build in database administration as my primary database client.
what? Why is this even being linked?
He's just *begging* to be reported for spam.
Using exceptions for flow control is a well established anti-pattern.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I admit it's not that pretty, but it's built-in. I don't see the benefits of using another library, just so it looks pretty.
Next step: symfony
The test_input function in this tutorial looks like total nonsense to me. It's just wrong. You should not mix input logic (validation) with output logic. https://www.w3schools.com/php/php_form_validation.asp 
I suppose he honestly thinks that w3fools is a good source and thus it will boost his carma
W3fools are notorious for their awful quality. It's a shame that they are first in the google search, sometimes even topping PHP manual links
Think whatever you like, but in my opinion laravel is a step ahead of Symfony. Maybe even two. Don't get me wrong - I like symfony and use it at work on a daily basis. However everyday there is a moment when I wish the app was built in laravel. 
Funny, exact opposite of my experience :P If you don't mind, what do you think Symfony is lacking and in what aspect is Laravel ahead?
Lack of ~~static~~expressive methods :D Well, Laravel puts up lots of bells and whistles build-in to the framework, it even provides some tools for frontend side too...
With Phalcon SimpleView result is better: Benchmark | Time Taken --- | --- twig | 3.5 seconds twig_reuse | 2.6 seconds mustache | 4.4 seconds mustache_reuse | 3.8 seconds volt | 4.5 seconds smarty | 7.6 seconds Phalcon is slow because of Di/View setup.
This subs never fucking positive and that was a gamble of a post lol. Well done for getting your passion back! Hopefully it brings you some great stuff in the future.
Don't really want to go into technical details, as this could probably be a blog post on its own, but to me it is ahead because they put a lot of work so the code you write can be very simple. Just for simple CRUD app I need to write a lot of boilerplate to get it running. And also the fact that I think active record would have been a better choice (faster and easier to use) for the kind of app we are doing.. I do realise doctrine is not part of symfony core, but it is de facto orm for symfony. I know there are generators and stuff like that which makes all of it easier, but with laravel all of this stuff is available out of the box. 
&gt; reverse-transform params What?
Here's an alternate approach: https://www.sitepoint.com/write-javascript-style-test-watchers-php/
&gt;Lack of staticexpressive methods :D If you want a Laravel facade like thingy it's trivial to do: https://github.com/theofidry/SfContextBundle. FYI Symfony had one similar (the `sfContext()` function) in Symfony1. &gt;Laravel puts up lots of bells and whistles build-in to the framework IMO it's just a big difference of philosophy. Taylor is willing to put a lot of built-in and is ready to maintain it. He's working almost full time for Laravel or Laravel related projects/product so as long as he has enough time for it it's ok. There is no one working full time on Symfony (Sensio backing it just means some employees are free to dedicated some time on it on work time if they are willing to an not too busy). If you look at the issue tracker they barely manage to keep it at an acceptable level with an amazing response rate, there's no way this they could keep that up if you integrate too much of it. Also note that it's way more painful in Symfony because of the BC promises and LTS plans. The only thing I really missed and I find way too complex for what it is in Symfony is the queue system from the third-party bundles (there's nothing built-in at the moment). The User things, front-end tools, nobody uses the same thing and even when I use Laravel I very rarely get to use the built-in ones so it's not really a plus for me. I understand it can be convenient to some people, but that wouldn't put one framework ahead of another IMO :P
I‚Äôm in a hurry so just a quick hint: https://stackoverflow.com/questions/884974/sort-and-display-directory-list-alphabetically-using-opendir-in-php Open dir will not sort the files so what you do is first collect all the filenames and then you sort them before printing them.
&gt;Just for simple CRUD app I need to write a lot of boilerplate to get it running I don't know about you, but I never really write a simple CRUD app. That said for CRUD apps, Symfony had a lot of tooling out of the box: generate doctrine entities from the console, and from it you generate Controllers, templates, routes &amp; co. in one command, not sure what you need more. A lot of boilertemplate code can be removed since 3.3 or 3.4, but that's quite recent. &gt;I think active record would have been a better choice (faster and easier to use) for the kind of app we are doing.. You're playing with fire here :P Kidding I understand some people prefer ActiveRecord although I personally don't like it especially with Eloquent where you put config in the entities themselves and the lack of metadata. But if you want to it's trivial to use Eloquent ORM in Symfony: https://github.com/wouterj/WouterJEloquentBundle. But as you'll notice it's not very popular, I guess most of Symfony folks don't like AR which also explains why Symfony moved from AR with symfony1 to a Data Mapper with Symfony2 as the default choice in the standard edition. &gt;I know there are generators and stuff like that which makes all of it easier, but with laravel all of this stuff is available out of the box. I believe those generators are out of the box as well with the Standard edition.
report -&gt; "This is abusive or harmful"
&gt;I started off as a purely procedural coder (which was the standard 10 years ago) Don't kid yourself.
 mysql&gt;
For the record we use 2.8 at the moment and due to some bundles not being upgraded we are not able to upgrade yet. However we are going to fork some of them and upgrade it by ourselves. I do know that later versions have more features and really looking forward to it. Also looking forward to symfony 4. In regards to eloquent, we cannot switch now simply because it would be too big of job to update the whole codebase, but yes I agree that if starting from scratch it would be trivial to use any other orm. Maybe I said this because I don't really know how to properly use doctrine. But we have some endpoints in our api that would take like 2seconds to return data, while it takes around 200ms with eloquent. Simply because doctrine takes long time to hydrate. We have a lot of relationships on our entities and we need most of them in our endpoints. And we tried many things to make it faster, like eager loading, multi step hydration (as per ocramius blog post), even using array hydration. Only array hydration was as fast as eloquent, but we obviously loose ability to use objects. We now migrated to custom build eager loading which kind of replicates eloquent functionality so we don't have this problem anymore. To each his own, and the fact that I don't consider myself a very good developer, (though I have 10+ years experience with php) laravel is just nicer and simpler to use for me. 
If you have more fun coding than playing videogames, I suggest you pick up new videogames üòâ
No, next step, [Phalcon](https://phalconphp.com/en/).
For SQL injection, look up prepared statements. You do not need to switch to PDO to prevent it. Like PDO, MySQLi also has prepared statements. Just make sure you are using MySQLi and not the deprecated MySQL_* Edit: http://php.net/manual/en/mysqli.prepare.php
Does not help, you probably shouldn't post replies if your only intention is self gratification. 
Neat thanks, I didn't know mysqli had prepared statements.
There are loads of PDO wrappers, it's not that they're scary, it's that PDO requires passing query variables, which will be very tedious to change, hence why I'd only like to change them where necessary. It'd be nice if you'd have just answered my question straight.
&gt;migrate:fresh I usually forget about the new utfmb4 default so the first migration always fails and you can't rollback it from within artisan. I'm happy with this new command.
what a shitty ungrateful bastard :)
I think it depends of what you need. I really like Laravel for it's fast setup, deploy and overall productivity and when I want something done fast with good results. I work with Java Spring with Hibernate, EJB plus other stuff. For huge and complex systems, I prefer and recommend Java. Of course I really don't have any doubt about Symfony's capability to do the same thing but, for what I see, Java ecosystem can scale easier. Horizontally and vertically. And I am loving AdonisJS (basically, Laravel for Node). 
&gt;due to some bundles not being upgraded we are not able to upgrade yet Out of curiosity which bundles is it? Yeah obviously moving from an ORM to another for an existing app doesn't really make sense. However that some stuff takes 2sec with Doctrine and 200ms with Eloquent does sound very fishy to me. We have to hydrates a few dozen sometimes hundreds of entities sometimes but it's rarely that slow, and Eloquent also have the same hydration step. They both are ORMs so in this aspect the performance difference should not be that big. On top of my head however I think the Doctrine fetch equivalent to Eloquent is extra lazy. Eager loading is the opposite as it would hydrate everything earlier on which I don't recall Eloquent to do unless specified so. &gt;To each his own, and the fact that I don't consider myself a very good developer, (though I have 10+ years experience with php) laravel is just nicer and simpler to use for me. I started with Laravel, went to Symfony and then back to Laravel before using between the two depending of the projects. I do get the feeling it's easier to _build something_ with Laravel as well, but it's usually the kind of code I find hard to maintain later on and that I don't want to touch. I also don't like much to write "Laravel code", i.e. if feel like too much of my code is coupled to Laravel and the Laravel ecosystem, I'm like writing a Laravel application, not a PHP one. With Symfony I have easier time to bend the framework to my will to do things the way I want to with coupling only the parts I don't care for the sake of simplicity. In retrospect, a lot of the perceived complexity I had about Symfony was: - The confusion about what was a component doc and how the component was integrated in the Symfony Standard Edition which changes a bit - Lack of understanding of some patterns - The outright complexity of some components provided by default which you don't necessarily need: the Security component is definitely harder but really useful only for more complex scenarios. For simple ones it's overly-complex. Doctrine as well has a certain learning curve if you're not familiar with Data Mapper ORMs (but in all fairness, the other ones are not much simpler) - The lack of guidelines/conventions: not that there is any, but it's far more scares than Laravel where there's a bit more of magic there - The complexity of some bundles (FOSUserBundle, RabbitMqBundle) But now each time I go to a Laravel app I cry as soon as I have a wiring issue because you have no easy way to debug that, or really the duck typing philosophy which I understand some people like but I really find it makes things harder to read/follow/pick up. 
php-vips is a wrapper for the [libvips](https://github.com/jcupitt/libvips) image processing library. It's a bit like imagick, but typically 4x faster and needs 10x less memory. It's API-stable, supports around 300 image-processing operations, and it's in production use on a couple of sites. PECL package: https://pecl.php.net/package/vips There's a benchmark here: https://github.com/jcupitt/php-vips-bench Formatted docs, including a tutorial and full API: https://jcupitt.github.io/php-vips/docs/classes/Jcupitt.Vips.Image.html Any questions? Ask here or open an issue on the php-vips GitHub: https://github.com/jcupitt/php-vips/issues
+1 for the free community edition. I used it for a couple years before I got my company to license me the ultimate edition.
&gt; Am I old How do you effectively build a query when you're jumping from where clauses to select, to joins then back to select, etc?
Hey, give me something to be grateful for, not just a mixture of insults and useless information. I asked a pretty clear cut question in regards to preg_replace and vulnerabilities, it'd be a pretty simple answer for someone with a decent understanding.
No but I do use some of the other ultimate features.
[removed]
Are there any injection vulnerabilities when preg_replacing a string to force alphanumerical values? The more I dig into it, the more I find the answer is no, unless the first and second inputs are user defined. If you have a vulnerability in mind, please share. Otherwise you have no reason to keep posting, oh but you will, as you're here to build your self esteem, not to help.
All very fair points. People call symfony configuration over convention and laravel the opposite. Both have their use cases and when to use which depends on the project. &gt; However that some stuff takes 2sec with Doctrine and 200ms with Eloquent does sound very fishy to me We have a few endpoints where it returns lets say 100 entities, but these entities might have 10s of relationships each and some of them are nested and have even more relationships. Because by default relationships are lazy loaded, some of the endpoints had like 2000+ queries and it's very expensive to hydrate all that data. So we used joins and what not to make it faster but it was still slow because there was a lot of tables to join. Also some of the entities were one to one relationship so it would still have n+1 problem. So in the end as we returning pretty much all relationships to the user we decided that eager loading makes most sense anyway, but it's not the same in doctrine as in laravel. So that's why we copied some of the functionality from it. (We also tried to just recreate that endpoint with eloquent just to check how it compares to doctrine). &gt; I also don't like much to write "Laravel code", i.e. if feel like too much of my code is coupled to Laravel and the Laravel ecosystem, I'm like writing a Laravel application, not a PHP one. I agree, though I probably could say same about symfony. I personally don't care if something is symfony way or laravel way, it's not like you going to switch one for the other anyway. Edit: Having said all that, at work for any new project I would still choose symfony, simply because of pretty much non existing bc breaks and long term support which is a lot better I think.
It may have been standard (to some degree). But it certainly wasn't best practice.10 years ago I was using Code Igniter after having rolled my own OOP frameworks for several years prior. The places I worked at the time would not have hired me if I was strictly procedural.
I just reported the same, with a sub-category of: It's rude, vulgar or offensive
2000+ queries sounds way too much indeed, but IIRC Eloquent strategy is about making a lot of small queries as well no? Also why not paginating the result as well? Another path could also be to rely on a document based DB like ES or simply creating "views" tables to avoid to have too many queries/joins which should speed that up significantly although it does introduce the concern of keeping those views up to date. Well I'm not familiar enough with your code/problem to be able to tell, I'm just putting random thoughts there hoping it can be helpful ^^ &gt;I agree, though I probably could say same about symfony. I personally don't care if something is symfony way or laravel way, it's not like you going to switch one for the other anyway. My take on frameworks is pick whatever is used (avoid to have to rewrite everything just because it's not the framework you're familiar with) and otherwise pick whatever you feel more comfortable with. What I meant by the above is when someone is looking at the code, he should be able to quickly grasp what the application is about. The code should reflect on what the application is doing, not what framework is used. I.e. if you take a glance at an application and the only thing you're able to tell is "oh, it's a {framework} app" and that's it, it's not very helpful. To be fair yeah early Symfony2 was like that as well: bundles, bundles everywhere for everything and nothing. Complete nonsense. Luckily now the trend is more start from the backbone and just add what you need. And bundles are only for third-party code to glue a PHP library to the framework (expose the config, register the services) unless the bundle is tightly coupled to Symfony which makes sense in some cases. In Laravel I see too many "Laravel package" as opposed to PHP libraries with a Laravel bridge. I hope this will change, it took a while for the Symfony community to change that habit as well.
&gt; Java ecosystem can scale easier. Horizontally and vertically. As far as we speak about horizontal scalling, the share nothing between request principle of PHP makes horizontal scaling the easiest thing in the world. Just put session in redis and staic assets in s3, and voila ! Nothing to do... Had way more work to add 1 extra server in Java. For vertical scaling, yes, PHP is less efficient, just because of that sare nothing. Each additional request served will cost more ram than in Java. Disclaimers : I started with Java, might have learnt a lot along the way. Don't hit me if my info is stupid/out of date, just tell me and I'll learn.
You're an examplary PHP user, too narrowminded to think even one move ahead. This is your second problem, next to arrogance. And the last problem is your "massive" site which is the usual outdated shit with sql and HTML intermixed, which makes it hard to maintain. But you you are too stupid even to realize that
I haven't used Laravel yet, but I hate Symfony with passion. Specially how over-engineered it is, which makes it difficult to learn and find a solution for your problems. I have been trying to learn Symfony for years but I always run into problems like this https://github.com/symfony/symfony/issues/2600#issuecomment-271315676. If you can't bother to test your app in Windows just once, to debug a 7 year bug ... eh.. I can't even. I would not be surprised to hear if someone got brain aneurysm from trying to make the framework work. That's why I want to try Laravel out. Who cares about small imperfections when I have my health to think about. 
Yeah, OP was exaggerating. There is no way coding is more fun that videogames. 
As a non-laravel user, could you specify some specifics that make it really nice to work with? I've tried other frameworks in the past and always find them heavy on learning and documentation and light on stuff that actually saves you time when building a project. Thanks
Hi friend, I have just been checking out your SafeMySQL class. Given that you aren't using mysqli_prepare at all (skipping the whole "prepare" step), how is this safe and not any different from just another data cleaning / query simplifying function / class? From what I can see, you have a function called prepareQuery which just cleans the data. Then, in any instance it is utilized, the query is directly executed using mysqli_query. There is no actual "prepare" step whatsoever, where the placeholder containing query is executed in preparation for the variables. Obviously, I must be missing something, as according to your answer to my previous questions, this is not the correct approach? I am an honestly interested in your answer, so please avoid being petty :).
Lots of arrow keys. 
I surely can be
I've had the same feeling with Symfony.
Sorry, but at my job it's really apparent why Laravel loses from Symfony. It's so damn easy to completely mess everything up in Laravel and it'll still work, with Symfony however, that happens a lot less. 
Not sure if Symfony is to blame for those shitty issues really. If very few people get this kind of issue in a very random manner and cannot reproduce it at all, how do you hope this issue to be ever fixed? I mean really, look at Composer. You'll find gems like "try to delete it, if it fails on windows, retry 20ms later". What's the underlying issue? No one knows. Sometimes you find those patches which kind of work, sometimes it's more complex. As for your over-engineer hate, well just don't use Symfony really. Symfony provides component that are meant to be able to tackle complex problems. If it's over-engineered for your over simple issue then don't use that, that's all there is to it. I hate Symfony Security for its complexity, but that complexity is necessary for when tackling complex security cases which I have. What's in Laravel for the equivalent? Roll your own thing, thanks. It's just simpler to just handle simple cases and let people on their own for more complex things. That's just not what Symfony is doing. 
I have more fun in coding than gaming. 
Laravel has the same issue. 
For a moment there, I honestly thought that one of Laravel 5.5's changes was support for more of YouTube's API.
Whatever floats your boat.
Actually what ends up happening is that if the query get's unmanageable I'll pull it into a text editor, and copy and paste. 
As a competitive/esports player whose main games are in pretty bad states, it definitely can be.
Laravel is exactly that. Light on the stuff to learn, heavy on the stuff that saves you time. It makes a lot of things so easy that you can't believe it's so easy. It's almost disappointing sometimes. Like I felt like getting my teeth into it, but then turns out everything is already done for me. Checkout the docs for integrating your backend laravel API with your frontend SPA. https://laravel.com/docs/5.4/passport#consuming-your-api-with-javascript I was like "is that it?" Yes that's it. 
That makes more sense but at that point you may as well just use a dedicated client.
`array_keys(array_count_values($arr))` is faster than `array_values(array_unique($arr))`. If don't do that though.
[removed]
[removed]
Thanks! I'll do this.
SafeMySQL is safe because prepared statement is not what you think. Its main purpose is to ensure that a variable has been formatted properly, simply because formatting is inseparable from the query execution. If you're trying to format your variable for SQL elsewhere, or relying on the result of some distant (and irrelevant) validation, you are calling for a trouble. That's a breach that sooner or later will sink your ship.
I'm not sure if you have ever worked on a real life website before, but often clients can only budget quick fixes. If a site is already functioning, but needs a few patches mended, you mend them. If a client wants a rebuild, you rebuild it. If you have a suggestion which will make a rebuild simple, I would really appreciate it, but if you're just going to continue being petty, you're just reinforcing my previous points. I thought it would be blatantly obvious by my phrasing what the situation is, but by the sounds of it you're lacking some real world experience. Judging by your GitHub you haven't branched out much from PHP and SQL. Anyway I would also appreciate your answer to my below question regarding your SafeMySQL class.
Not to belabour the point, but the reason I stick to the CLI is because I don't have to open up any extra ports when I'm working on a remote server. I already have ssh access, so opening 3306 to allow for external connections from a database tool just adds one more vector for an attacker to get in. 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions. 
I thought it would be blatantly obvious by my phrasing that whenever you start bargaining on security, you're busted. 
&gt; Think whatever you like, but in my opinion laravel is a step ahead of Symfony. Maybe even two. It might be a step ahead if you think anti-patterns are a better solution. I have seen horrible Laravel codebases that we have scrapped because of global functions, so many static methods and allowing direct injection into templates. And you can't blame the coder for doing this, it's right in the documentation to use the framework this way. Laravel also needs better release cycles/deprecations, not direct deletions of classes/methods. It also has terrible support for PHPStorm, every time I have to bring up a project there, there's so much yellow and red errors in the code since it can't auto complete. I'm also not a fan of something where the maintainers and tutorial makers think amazing features like traits, interfaces and type hints are "visual debt". Lol.
Thanks for your feedback. You're right, there is not an option to transform parameters yet (this is my next goal, but I'm not sure how to make this feature cacheable), but actually there is an option how to get the same effect in other way. Please take a look on example: https://github.com/awesomite/chariot/blob/master/examples/months.php#L71-L84 and please take a look on section "hidden parameters" in documentation: https://github.com/awesomite/chariot#hidden-parameters 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [awesomite/chariot/.../**months.php#L71-L84** (master ‚Üí 5c551e1)](https://github.com/awesomite/chariot/blob/5c551e1325c719153f4aec6fbdbf1a1ee9a70fea/examples/months.php#L71-L84) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkirtgp.)^.
The question is a bit confusing, but maybe you don't really mean to use the word "security" here? Are you talking more about common likely bugs/oversights that are relevant to tracking money? That's more in line with mentioning floats and stuff that would be relevant to "balances" etc. "Security" is more general and really applies to any kind of data, and I can't really think of anything balance-specific there. And yeah, of course never use floats for money in your database. 
We are talking comparatively, of course, is that slight change in wording sufficient for you to provide an answer? Or are you still incapable of interpreting the question? Trying to interpret peoples questions / understanding while limiting yourself to a computational mindset is not going to get you very far from a computer.
 &gt; it even provides some tools for frontend side too... Symfony has the whole dev toolbar with benchmarking, stats, number of queries, user/session information. It also has twig built in (and super easy to remove). Adding a front end framework literally takes a second. It's so much more advanced than what's available in Laravel.
&gt; the Security component is definitely harder but really useful only for more complex scenarios and &gt; The complexity of some bundles (FOSUserBundle, RabbitMqBundle) really bit me in the ass when I first started using Symfony. Situation: Writing app for internal intranet. Want to authenticate against the company's LDAP and reference information stored there(first name/sur name, email etc). Don't want to query LDAP every time for that info and I need to have a doctrine entity to represent a user for some relationships. I first tried FOSUserBundle since it seemed to have everything I'd need. But, from what I remember(and keep in mind I still had a lot of learning to do at this point), you had to choose between either LDAP OR database storage. Once I realized this wasn't an easy issue to solve with FOSUserBundle I had to scrap that idea and, and along with it the time I'd spent figuring out the bundle. Then I had to tackle the fun that is the security component, realize that their LDAP component at the time didn't really do what I needed(I think it's still one of their weaker components), figure out how to configure the login process to use LDAP and create/persist a new user entity on first login, and then reference that entity as the 'user' instead of whatever happened during login. At this point I'm extremely happy I went through this. I've now got a bundle that handles this entire process hosted on an internal GitLab server, all I need to do on new apps is `composer require __company_name__/UserBundle`, add the LDAP credentials to parameters.yml(no anonymous binds allowed), and it's good to go. I've now got a much better understanding of the whole process, but I'll be damned if the component wouldn't benefit from a 'usability' pass.
What would I find the source data that shows 93% of sites running php 5? 
I never open up port 3306. All these clients that people have listed will tunnel their connections through SSH.
Really? Well now, this changes everything. 
While colshrapnel can come across as an ass some(most? ;) ) of the time: 1. He's not wrong 2. You'll get that kind of reaction when asking for help in a subreddit that specifically says in the side bar '/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC'
I feel your pain, User management + LDAP + Security is hard enough, it's even harder when you don't master the components. FOSUserBundle is good as long as you don't have to customize it, otherwise it's not worth it: it's too complex because it does too much and is too coupled to the front-end. Same as the Form component really, the whole complexity comes from the UI which is a real pain to handle in a generic way.
Yup, for example here's what the Database SSH/SSL tab for JetBrains' IDE configuration looks like: [pic](http://i.imgur.com/hYSfamX.png)
I wonder how hard that would be to setup with Homestead / Vagrant. 
Haha thanks, I should have posted in phphelp. You're right, but it's hard to be wrong if you keep your replies general, I could write "Use a computer." as an answer, and be "not wrong". Not wrong doesn't count if the answers don't directly address the specifics of the question :p. 
&gt; It might be a step ahead if you think anti-patterns are a better solution. I have seen horrible Laravel codebases that we have scrapped because of global functions, so many static methods and allowing direct injection into templates. And you can't blame the coder for doing this, it's right in the documentation to use the framework this way. As I said, it's my personal opinion. I would choose simpler and easier to use framework over a framework which uses best practices but is not nice to use. &gt; Laravel also needs better release cycles/deprecations, not direct deletions of classes/methods. It also has terrible support for PHPStorm, every time I have to bring up a project there, there's so much yellow and red errors in the code since it can't auto complete. I'm also not a fan of something where the maintainers and tutorial makers think amazing features like traits, interfaces and type hints are "visual debt". Lol. I use vim so I don't really have problems in that regard, but completely agree with everything else you said here.
If Homestead is running on your local machine, then it's already exposing port 33060 as seen here: https://laravel.com/docs/5.4/homestead#ports However, you could connect over SSH if you really wanted to. Here is an example of me connecting to one of my cloud production servers with SQLyog (Sequel Pro will do the same thing): 1: http://imgur.com/BGgZ4Vg 2: http://imgur.com/38ikiuS If you have Pageant (Windows) or ssh-agent (OS X / Linux) running then you don't even have to type your private key passphrase as it'll automatically inject it.
phalcon looks neat, although it reminds me of zf1 for some strange reason. I still get flashbacks from time to time...
You suck at insulting too :)
You don't even need docker: php -S localhost:8080 -t ~/path/to/adminer/ Then http://localhost:8080
When have I insulted you? Why don't you answer questions? Whats 1 + 1/x when x = 0?
Yea, the Form component is another one that took some time, but I'm loving it after the learning pain. One reference resource I wish I'd had at the time is the [en-marche.fr](https://github.com/EnMarche/en-marche.fr). The Symfony Demo app is nice and all, but there's a lot of stuff it doesn't touch that a large app like en-marche.fr does.
I use [datagrip](https://www.jetbrains.com/datagrip/) because i bought the jetbrains complete pack.
container all the things! seriously though, fair enough.
LOL, that would be hilarious.
I sometimes spend hours reading through the [PHP Docs](http://php.net/manual/en/) to refresh my memory and keep up with changes in php.
First tip, follow a coding standard. like [PSR1](http://www.php-fig.org/psr/psr-1/) and get rid of those ghastly tab indents. 
I will try setting this up when I get home. Thanks!
To answer the question from the title: Write a project, upload on github, post a link here. To answer the question body: it's impossible to predict questions through such a vague description. All I can suggest is to improve your understanding of PHP OOP features.
Go read [PHP: The Right Way](http://www.phptherightway.com/). Take what you learn from that and improve your app. This [tutorial](https://github.com/PatrickLouys/no-framework-tutorial) specifically addressing not using frameworks may also be helpful.
It doesn't, don't lie. The maintainers of Laravel are very careful to make things work on all operating systems with the exception of Laravel Valet which was a tool released specifically for OS X though third-party ports exist.
I wish webyog gave me money everytime I said the same.
Is this an ad for that chocolatey application as from the looks of it it isn't free? EDIT: sorry I'm just stupid and missed the free version.
It's built on Symfony components, specifically the same component that clears the cache is used in both frameworks. 
A job interview ;-). Google "php job questions" but if they are asking you questions from there I'd be weary. I try to answer questions on stack overflow. Often times I basically know the answer, but have to dig into the PHP documentation to answer the question 100%. It's a good refresher. Sometimes someone will have a better a solution than mine. Always nice to see a different approach.
Glad to hear! Next up, learn a language that isn't PHP. Either you'll hate it and be happier doing PHP, find it moderately interesting and have some new ideas to bring back into your PHP, or find out that this new language makes you even happier and have a new path forward for your career. No matter what happens, it's a gain.
i get what you mean, but i feel symfony is miles ahead of laravel. if you like to drive a car without knowing how its even driving and does way more than you need, use laravel. if you want full control over how the car drives, which fuel it uses and is from a vendor who promises that this car will still work and be supported in the future, then go with symfony. i'll just drop this in here: https://gist.github.com/anonymous/8565929 it might be old, dont know how the situation is now, but there's a lot wrong (around) laravel imo and the reason why i'm refusing to use it. one of laravel's minor version BC breaks hit me hard in the past and basically burned my house down... laravel is a one man show i'm not going to support. relevant: https://www.reddit.com/r/PHP/comments/3bmclk/why_experienced_developers_consider_laravel_as_a/
I remember reading this some time ago and to be fair some of the issues are still relevant. And I especially agree about BC breaks, which is why I said in one of my comments that despite the fact that I think laravel is a step ahead, at work I would still choose symfony just because of this reason. Though for personal projects or contract work I would definitely choose laravel in a blink of an eye. I just enjoy using it no matter what issues there are around it, and no matter what people say about it. (It's different at work, as what I enjoy personally might not be good for business etc) I hope you didn't mean it burned your house down literally! 
no? https://github.com/laravel/framework/blob/5.4/src/Illuminate/Cache/FileStore.php
Some people move forward slower than others. You would be amazed if I showed you what kind of software I have to deal with sometimes and it was written 10 years ago. I would not even call it procedural that would be too good for it.. 
I'm surprised people still chose to develop on Windows. Never makes sense to me to develop on one platform and deploy to another. Unless you're running ISS servers :S
I suggest to read the Zend PHP certification study guide..not the one for the framework but the one for PHP..if you now everything in the book you are good to go for any position
&gt; Specially how over-engineered It sounds like you just don't need it's features for the projects you build. That doesn't make it a bad framework. Frameworks are tools, use the right one for the right job :)
This looks nice, I have no need for it right now but bookmarked for the future 
Laravel is the shit.
Looking at the pricing it seems to be free for non-commercial use.
&gt; multiple choice but more than one answer can be the correct one. while HTML, JS, CSS and mySQL are all other requirements for the position, this assessment seems to be strictly PHP based. 48 questions with a 2 hour time limit and estimated time limit of an hour. This sounds exactly the same as a test I did a job a few years back. It's online but I can't recall the name of it, you can take 3 practice tests with them before having to pay. It sounds exactly as you describe above do a Google I'm sure it will come up or something similar. 
Same. I haven't played a good game in couple years when I sold my console. I just genuinely enjoy coding more than games.
I will agree that Windows is the "worst" OS to use when developing PHP applications, but it's really not completely awful. Getting Vagrant or Docker set up is easy. I even managed to get Valet working, which is super nice. The hard part is shoehorning in a lot of functionality we're used to using in Bash. I managed to get SSH working in a CMD prompt simply by installing Git for Windows, and adding Git's own binaries to my Paths variable. I mean, it kind of sucks that we have to work around some things, but once it works, it's fine. Except for IIS. That hot dumpster fire of a webserver will never be fine.
"I just want to say a big thank you to all of the guys &amp; gals who make Laravel possible" taylor otwell : keh 
I really don't understand how to work with AR... to my taste it turns my code into spaghetti. Maybe there's something that I do not understand or maybe this is just specifics of my projects... The only place when I could find AR appropriate thing is in read-model, working with projections of data.
Well Imdnt like video games so...
I'm Intrigued, don't get me wrong I'm always interested in better design. Empty for capturing arrays that have unknown values. Isset for checking the value of a model or a sudo model ( such as a relation ) For true checking 1===1 and "false"==="false" How about blackbox functions or contracts where you may not specifically know the return type? Would it not be justifiable to !empty and then capture the type afterwards? Edit: If ($a) is defenitly not acceptable, hence the assumption that empty was better. 
&gt; console Well there's your problem /s 
Any luck your scaffolding repos are available somewhere for perusing? I love to see how ppl organize their work cause mine is a mess. Edit : I hate being french and using a phone 
One of the things I noticed is how toxic some of the responses got, and the whole "symphony versus laravel" concept came up - people realize one is built LITERALLY on top of the other ... right? I think the biggest strength of laravel is how easy (almost in 5 minutes) it is to get going and build something. It is an opinionated "full stack" framework.
I recommend starters should start with a popular framework. But if you're interested on a nice uncoupled stack I would use the following (just pick what you need): Config and DI: Php DI 5 HTTP server stack: zend diactoros or http-interop/http-middleware HTTP server router: Aura router Console command definitions and parsing: docopt.php Console Interactions: CLImate ORM or DBAL: Doctrine Cache: PHP Cache HTTP client: Guzzle or HTTPlug View template engine: Plates or twig Validation: Respect Validation In face just check out https://github.com/ziadoz/awesome-php
Plus global functions, so many static methods and allowing direct injection into templates. No deprecations between versions and no type hints since the that's "visual debt". Sign me up for code from 4+ years ago!
Looking at the slide deck from Nikita, it looks like certain performance improvements are constrained by how PHP executes file-by file without foreknowledge. Can that be taken to mean that certain additional improvements to analysis and performance might require the compiler to be provided more context of the larger application, such as passing it every possible source file? 
Again, spin. You place "legal" in scare quotes as those he's on the edge of some ethical cliff. He's not. The subjects own therapists are willing to verify her mental capacity. You also describe him as whining. This is similarly a mischaracterization. His most recent post has only been a fact dump in response to unsubstantiated accusation from the DA. Accusations that THEY brought forth during a period in which the entire topic had died down. Finally, you describe him as demanding to be recognized as a leader. His statement says literally the opposite. I suggest you take some reading lessons.
[Locomotive](https://www.locomotivecms.com/) has fantastic multi-tenant support, but it's Rails.
While one is built on top of the other, you get completely different experiences using it.
PhpStorm. For me it was PS. I'm currently primarily using it with Laravel and it's a joy. I started with vim in the 90's and carried it on and was happy with using it no matter what I had to edit. But as the complexity of the (PHP) projects grew, using a non-IDE became a real drag. But that was a time where there was no PhpStorm yet and basically all there was, was Eclipse. And it was everything but not really that well integrated, at least with PHP. Could have as well used vim and all the manual configuration inc. xdebug &amp; friends. But when PhpStorm matured enough to be usable, it really brought me back the joy of development because I was finally able to properly work on all the big projects. Finally really use xdebug the way it's meant to be used. I grew up with the printf/var_dump mentality and it's great but there are times when complexity just outgrows this approach. All the automatic parsing, interconnecting of symbols, etc. is such a time saver. I could finally better concentrate on my tasks at hand than fiddle around with my tooling to work the way I need it. Very important: PhpStorm has IdeaVIM and without it, I don't think I could be effective :-)
Yeah that gist is 4 years old and a lot has changed in both procedure and code in that time. Taylor now works on the project full time. I can't remember a real breaking change during a patch version since 5.x came out. The ecosystem around Laravel has matured a lot and the code is quality.
I saw the hidden params thing, which is interesting and nice. I'm not sure I follow how a manual and hard coded map is a viable alternative. I'm not sure exactly what you're caching as I've not dug into the code, but I know with fastroute, it caches really the route map itself. Ideally, when one registers a custom parameter type they'd be able to provide an object transformer with a fromUrl() and toUrl() method that takes the current value and spits out a new value. This would allow for example registering a custom `:date` regex which would then be fed the matching date on the way in which you could then return a `new DateTime()` from the transformer so when you `getParams()` you actually get a date time object. Similar, you could then feed it a `DateTime` object when you generate a link and it would use the `toUrl()` to tranform it back to a string. This is critical IMO for even basic string transformations, i.e. 'This is my title' =&gt; 'this-is-my-title' (does it URL encode all params automatically when generating URLs already?).
If you're going to generate URLs you need to reverse transform parameters. If you transform a date parameter in the URL to a `DateTime` object on the way in, you want to be able to pass a `DateTime` parameter to the link generator and get the proper string on the way back out.
Also, I'd recommend giving a try to PhpStorm + Php Inspections (EA Extended) - static code analysis will guide you in direction of latest PHP features/syntax and new tricks. 
It's not about being pretty as much as easy to write and logical to read. The best you can do with a series of transformations with built-in functions seems to be using a lot of temporary variables and other noise. $array = array_filter($array, function() {}); $array = array_filter($array, function() {}); return array_reduce($array, function() {}, array()); versus return collect($array) -&gt;filter(function() {}) -&gt;filter(function() {}) -&gt;reduce(function() {}, array()); The latter cuts it down to just the behavior (filter, reduce) and implementation.
I feel the same way about Golang. As for laravel, I didn't really understand what was going on. On top of that, it was really difficult to get bootstrapped, although I probably would have gotten the hang of it eventually. I ended up going with CodeIgniter, which I've never had problems with understanding and bootstrapping. 
&gt; It was a bit of a learning curve as I started off as a purely procedural coder... Laravel always seemed a lot more procedural than something like Symfony to me.
Laravel Valet on the dev machine and Laravel Forge + Laravel Envoyer on the production servers.
I haven't enjoyed a videogame since... Pitfall. So yeah... coding is more fun than games. Nope, I tell a lie. Boom Blox was fun. 2008.
Yes, obey have to stitch the parts you want, the other one is done for you. What wrong with that? Nothing, IMO.
&gt; Just put session in redis You can do the same thing for Java, but... what you put in the session needs more attention. 
That's how I'd interpret that. Certainly HHVM gets performance benefits from doing whole-project analysis in HackLang mode.
Best PHP framework ever, period. Symfony is the only one with a proper architecture. People find Symfony difficult to use because they don't know how to code properly. Once you understand how Symfony works you start writing reusable, decoupled and testable code. I feel like Laravel is good for RAD but not for working on big projects with lot of developers. 
It's the absolute opposite. Once you know how to develop properly you use Symfony. Laravel is good for beginners and small projects but not suitable when you work with a big team. 
Active record is an absolute shit on big projects. Not having Dao and making all the queries in the entities is an absolute nightmare to understand and maintain. I know ow it from fact, I've been using Symfony for years until this fucking project based on Yii. I had a fun time learning to code with CodeIgniter but the only serious PHP framework for big applications is Symfony, period. 
I can just type \e and write a query in my favourite editor. (Postgres)
Being a PHP developper for 15 years now, I had a fun time using RoR. 
A `docker-compose.yml` with all the services you need in it, including a container with build tools (where you run phpunit, xdebug, etc). I usually include following containers in the setup: * mailhog * nginx * php-fpm * posgresql * eventual mocked external services * build-tools (has nodejs, php, xdebug, etc) * ngrok (to show my stuff to clients and co-workers) After that, a single `Makefile` to orchestrate the entire thing. These are the basic things you need in it: * `docker-compose up` * `docker-compose run build-tools ./vendor/bin/phpunit` * `docker-compose run build-tools ./vendor/bin/phpcs` * `docker-compose run build-tools ./vendor/bin/behat` * `docker-compose run build-tools ./node_modules/.bin/webpack` * `docker-compose down` Production is usually just Heroku
Relations not persisted to the DB, extremely fat controllers, way too much folders. A ton of black magic (facades, Middleware) makes shit hard to debug and makes developers lazy, doesn't promote proper code
&gt; Why exactly are global functions a bad thing? Same reason global variables are bad. Why don't you just use $_GET, $_POST and $_REQUEST everywhere? You don't haev to initialize an object every time.
This was ~6 months ago that a key feature was just removed (https://github.com/laravel/internals/issues/391) and not deprecated like a sane library/platform would do.
Oh no, lets pretend not using type hints is a good idea. It goes a long way to show how these developers never worked on large or enterprise systems and think their skills on small sites in shops can translate.
My PHP skills improved 10x when I learned Node/Go and Java.
That was made known and was during the transition from 5.3 to 5.4. Laravel does not follow SemVer for the middle number. 
I *love* symfony, but I'm frustrated it's not more popular in the U.S. At least I haven't seen many, if any, job postings for Symfony developers.
Pretty much proof you've ever worked with enterprise code or large code bases with many developers.
Completely agree. Learnt Laravel 5 years ago and it taught me MVC, learnt Symfony 4 years ago and it taught me how to properly structure my code. Laravel felt a lot like Angular to me. A lot of magic in the background but it just works up to a point. Where as Symfony is straight up good programming. Data mapper also wins for me over Active Record too when it comes to dealing with vast amounts of data.
If Laravel didn't exist I would probably move to Ruby or Python.
These do not do the same thing. That runs all tests on save, My version only runs the tests which have been changed. These two methods IMO could be combined, run just the changed files on save. 
How do you suggest dealing with storing currency? I'm currently storing it in pennies or cents then multiplying/diving on input/output.
&gt; Name one enterprise project you work on that doesn't reuse a function in multiple areas. I dependency inject everything to improve testability and mocking. It's a pain in the ass to mock global functions. You won't find any global functions that me or my team creates in any of our PHP/Node/Go/Java projects.
I used to do that, but on the last couple of systems I built that dealt with money on mysql I used decimal(10,2) which seems to be pretty standard.
I'm not talking about that. I'm talking about the countless Laravel developers that think type hints are terrible and cause visual debt. (https://laracasts.com/series/php-bits/episodes/1) Lets remove interfaces and traits and type hints and make our code look like PHP4 code.
That's a reason I prefer not to use it. I'd much rather have deprecations. mysql_* functions were terrible, but they were deprecated for a few versions of PHP and then finally removed in 7, not cut off randomly.
Yeah, but repeating code and not stuffing things in Services or Repository Classes is just plain old stupid. 
I had issues with PHP converting that to floats so if I tried to do arithmetic in PHP I would still end up with floating point errors.
Duplicate requests can certainly an issue. You need to make sure your system is robust enough to prevent duplicate transactions, or at the very least, have a detection system for duplicates. At the bare minimum, be sure that any data changes are happening with POST requests (not GET). Next, it's better to have an asynchronous purchasing flow than a synchronous one. In other words, when a purchase happens, only enqueue a task to purchase, don't actually try to perform the purchase in the user's web request. 
Python (flask especially) would be a great fit
Hypothetically speaking, what would PhpStorm give me that Sublime Text 3 + plugins wouldn't? I've used JetBrains products in the past (Resharper) and loved it, but I currently use Sublime for all my Laravel development. Can you go into more detail about what makes PhpStorm your go to over other IDEs? Just curious about other options honestly.
&gt; Symfony has the whole dev toolbar with benchmarking, stats, number of queries, user/session information Laravel has this too as a third party plugin.
Yes request are sent by POST and I also use database transactions and inside the transaction block I check if the user has enough "balance". Could you elaboratewith the async purchase flow why its safer and how I should do it in php? 
I mean security specifically for website money/balance. I use decimal 10,2 in database and float in php. Are there more measures I could do against attempts to manipulate the funds or bugs you think?
[removed]
[removed]
[removed]
Local install with lots of muscle memory
[removed]
&gt;People like you are such a terrible presence in PHP. Was just about to write this about you. Glad I can just quote you instead.
Phpstorm is engineered to understand your code, your framework and all the tooling around it. That's what an IDE is. Sublime is just a text editor, plugins just can't get it there. There's just no comparison . If you feel storm is too heavy, have a go at vscode, also an IDE. Not as nailed for php development, but still much better than sublime or atom. 
Please show me an example? Are you talking about HttpFoundation module by any chance, or was it HttpKernel, Process, Routing, Vardumper, Finder, Filesystem, DomCrawler, CssSelector or Console?
Seriously, what the fuck?
There are multiple hydration options available to doctrine, array being the fastest. If you must hydrate to entities, there's the simple object hydrator which won't build the orm internal map that slows doctrine down so much. 
And you sound like the average Laravel developer, let's call it even then ;)
The problem of the global namespace is that it kills isolation, and is a lot harder to test. You have all your code tangled together without clear boundaries of functionality. 
I agree, but this is primarily due to LDAP. Personally I prefer to have 1 login server internally and have all applications communicate with that through OAuth2. Then you only have to bother with complicated security once.
The thing is, because you have access to everything from your models in Eloquent, it's easy to write very shitty code that hides even more shitty code. I've spent the past years rewriting applications which all used old propel (AR) and it's so easy to make a really big mess in those modules with static calls to fetch "related" objects and such. To test this, you have to go through hell and back again to get it to work... Or grab a special Laravel package, which already indicates a code smell.
twig &gt; blade, by a long shot. 
Highly recommend you to try a 30 day trial for PhpStorm and compare it with your Sublime workflow to have a better understanding.
&gt; You can also turn off warnings for magic stuff. This should trigger enough alarm bells already
I think it's simply because they are experienced ¬Ø\\_(„ÉÑ)_/¬Ø
You can also nest those function calls. Again, it's not as pretty but it does work. However, making the basics of the basics of your application depend on a collection framework, with the added overhead, is not worth it imo. I rather see php get proper collection tools internally.
[check your ego first](https://www.reddit.com/r/linux/comments/6lakr2/i_give_up_on_this_os/), kthxbye.
&gt; https://gist.github.com/anonymous/8565929 This is pure gold!
Yes docker seems great it's like developing on the server even on the local side before production. Never used Heroku what's good about it? And why is it better then using your own server?
Today in It in France it's almost the first skill looked for. 
Don't use laravel at the moment and probably won't, I enjoy symfony and slim instead. Forge and envoyer looks great but too expensive for me right now, but I'll have them mind for the future.
It can get a little wonky and break with multiple complex joins or database specific functions like postgis, but for simple queries it's great.
What do you mean with muscle memory?
Yeah transactions are a must here, however it does create a bottle neck on your system if they're occurring in user space (e.g. a web request). The async flow isn't strictly necessary but it is good practice to decouple the system.. that way you're in full control of the flow of transactions, and the user would just see a wait screen while it's processing. Generally how you would do it in PHP... well you would need either a queue service or cron job. The queue service would be something like Amazon SQS or RabbitMQ. Your order processing would just be a script that pulls off the queue, processes orders and marks them failed/complete. Then on the user end you'd have an ajax poll to check when the order completes. More advanced use cases could use an open socket and get the order status "pushed" to the user. 
Any chance of getting in on this ? Github name is the same as on here :)
Painfully re-typing everything
There are a lot of great general purpose frameworks and framework component libaries out there. However rolling your own framework is not automatically a bad idea. Some people will immediately reject this. I'll cite two counterpoints: (1) None of the top PHP shops in the world use a general purpose framework. (2) It only takes a few hundred lines of code to have a barebones request router, config, A/B, DI, template library, etc. 
They do CD for you, staging environments, scaling (if needed), monitoring and upgrading PHP versions. The work heroku does for you would require months of work by a DevOps team in comparison. It ain't cheap, but it delivers.
Ok now I see what you mean, it could be an option for me but it feels like a big workaround. I got the advice to lock mysql table row when updating or reading the balance in database to check if user has balance available. What do you think about that?
&gt; Would it not be justifiable to !empty and then capture the type afterwards? Absolutely not. That's how `empty()`-related bugs seep into your codebase. Functions should never return more than one type in non-error conditions, and only one specific other type (if any) in error conditions. So, to use the canonical example, `strpos()` returns an integer in non-error conditions, and `false` in error conditions. If you were to use `!empty()` on the returned value, you would introduce a bug into your code whereby `0` is treated as an error, despite being a perfectly valid string index. &gt; If ($a) is defenitly not acceptable, hence the assumption that empty was better. It may surprise you to find out that, in terms of [truth table](http://php.net/manual/en/types.comparisons.php), `!empty($a)` is identical to `if ($a)`, and falls victim to all the same problems as a result.
In your second part, you're using the `$filesData` array you built, which you gave a key `fileUri`. I think all you need to change is to use `$file['fileUri']` instead of `$file['uri']`.
You're not `echo`ing either variables on line 116. You are looking for these tags (if you're looking for short-tags): `&lt;?= $file['fileUri'] ?&gt;` and `&lt;?= $file['fileName'] ?&gt;` or `&lt;?php echo $file['fileUri']; ?&gt;` and `&lt;?php echo $file['fileName']; ?&gt;` for the longer versions. EDIT: Also /u/RadioManS3 is right - you need to use `$file['fileUri']` and `$file['fileName']` (keys [are case sensitive](https://3v4l.org/4N5lP)). EDIT2: Use /r/PHPhelp for further assistance.
Heh, good call. I've spent too much time wondering why things I forgot to print aren't showing up. üòø
No worries - I overlooked the fact that this was happening within a `foreach` the first go around.
Laravel Valet is not laravel and you can use it for symfony and other things also. Why the heck someone downvoted it?
Then why one of the main faces of Laravel says that type hints, return types, interfaces and traits at "visual debt" and make code dirty? https://laracasts.com/series/php-bits/episodes/1 There was an entire month of conversations here about how the Laravel developers agreed with this and it made their code messy to have all these features. Idiot.
Lol. Like this code from the release less than a year ago: https://github.com/laravel/framework/blob/5.3/src/Illuminate/Validation/Validator.php. I'd be fired if I created a class with almost 3.4K lines, almost 200 methods. That is one of the biggest code smells I've ever seen.
&gt; If I'm re-using a function across multiple controllers and models I'm not going to want to fuck around with initializing an object every time. Ok, so how are you testing or mocking that function. Oh, let me guess you have minimal to no code coverage.
Check [Symfony's remove function](https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Filesystem/Filesystem.php) and [Laravel's delete function](https://github.com/laravel/framework/blob/5.4/src/Illuminate/Filesystem/Filesystem.php) they're functionally the same when it comes to removing files. Besides that, they both use the Symfony Finder component, which spits out bad paths sometimes (mucks up the slashes on windows I guess?) Windows and file permissions are a turd as well and then you have a whole lot of factors where it can go wrong. Slowly getting my point? 
This sounds great. All of our Go/Node/Java code is in docker (basically single services), but we have yet to port the PHP projects over since you need a bunch of containers for prod. Everything is ECS. Do you have some examples or a base package that you use?
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [symfony/symfony/.../**Filesystem.php** (master ‚Üí 9fa3895)](https://github.com/symfony/symfony/blob/9fa38950ec143449b57a942a325b83096fa16244/src/Symfony/Component/Filesystem/Filesystem.php) * [laravel/framework/.../**Filesystem.php** (5.4 ‚Üí a61a234)](https://github.com/laravel/framework/blob/a61a234a69079b9509757b19133c7f4c358b7be1/src/Illuminate/Filesystem/Filesystem.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkjo53y.)^.
[removed]
What type of site uses &gt;200 different sql queries? Seems kind of crazy
Parking here to find out the answer. :)
[removed]
Have you heard of the old adage "horses for fucking courses"? The same is true for OS's. The problem with people like you is that you are apparently ridiculing an os for the alleged fanboyism (according to your comment) but you talk EXACTLY like a budding fanboy. e.g. "I hate Linux because I'm lazy and it doesnt work like Windows with the pointy-clicky boxes. So I'm going to set up a campaign against Linux simply because I don't understand it." Linux literally makes the internet world go 'round. Just because its not equal to a Windows desktop to your liking doesn't make it a terrible desktop OS. I think you need to go back to computing basics to figure out why we have so many OS's to begin with. 
Find one yourself. Googling for the answer on your Windows OS should be fairly straight forward. 
[removed]
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [doctrine/doctrine2/.../**Parser.php** (master ‚Üí fb3ec76)](https://github.com/doctrine/doctrine2/blob/fb3ec7648d9bb4f0cbcb4acb8a90994caaa079c5/lib/Doctrine/ORM/Query/Parser.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkjq3ak.)^.
It says something about their developers if most of them agree that dumbing down their code for the sake of less words on the screen is better than the extendability, error checking and sanity in the future.
[removed]
I‚Äôve been using Laravel since 4.0 and just now learned about -&gt;fresh()
Reuse of a function doesn't mean it has to be global in scope. 
There's a difference between SRP (HTTPFoundation classes) and Laravel's validator and the purposes for each. I'm also injecting the request into every controller/service that needs it, while I'm just creating instances of the validator class. The validation class should have been something more extendable, separated, easier to search and sane like: https://github.com/symfony/validator
&gt;The only people who use it are nerd hobbyist fanboys who would rather type terminal commands than click a gui. Why do people keep pushing this falsehood? You don't need to use the terminal to use Linux at all =/
&gt; Too bad. You lose. Looks like your comment score in this thread is what? -30? Is this a case of everyone is wrong but you? But keep it up, maybe you will make a point that someone actually agrees with eventually.
[removed]
[removed]
Lumen solves a lot of the issues you listed. (Though the controller thing is more on the programmer and not the framework). Also I'm not aware of relations not persisting to the DB, can you elaborate on that? 
Once you learn twig, you already know jinja, and jinja syntax for templating is available almost on every language out there. 
Yeah I'm going to let my team push to production to test code that gets 8,000+ requests a second and generates our clients $750 million in revenue a month. Please stick to Laravel, it will make it easier to weed you out if you ever apply to a place I work at.
You have no idea of what you're talking about. 
I don't think you understand what typehints are for. 
They've done some very bad magic and now there are tables that don't have a relationship in the database itself (no fkeys) but in the code they use columns to match the ID's which are also on in the table. No defined relationship but storing the id in a column. Mostly stuff from inexperienced developers, but Symfony puts more constraints on this, well, doctrine does, but eh. Laravel makes it really easy to write real garbage that still works. 
&gt; $repository = $this-&gt;getDoctrine()-&gt;getRepository('BlogBundle:Post'); Sorry I don't do that, I don't use the injected container in my controllers. I'm injecting the Post repository. &gt; $post = $repository-&gt;find($id); Since we are in to making code clean, I'd just shorten the next two lines. if (!$post = $this-&gt;postRepository-&gt;findOneBy($id)) &gt; throw $this-&gt;createNotFoundException(); I wouldn't do this, I'd have a custom view for errors and report it better to the end user &gt; return $this-&gt;render('BlogBundle:Post:show.html.twig', ['post'=&gt;$post]); Symfony already knows if I put the twig file in the Resources/views folder and it's named the same as the method, I only have to return the array of data I'm passing to the view (which it's all done that way for simplicity). So I'm just doing return ["post" =&gt; $post] Also how do you even begin to test yours? Oh wait, I forgot, you don't have any code coverage, so why are we listening to you? 
Probably doesn't matter what testing tools Laravel has when your typical user doesn't care about tests. Here's literally a quote from OP: &gt; Push to production and let the end-user figure it out! Fuck writing tests!
I inject my services and repositories, not the actual container. Injecting the container is an anti-pattern. But nice try!
There are far worst subs. Tried asking a question about an SSH Server vulnerability on /r/sysadmin once. It was not a noob question. I was just asking if the vulnerability scanner I was using was throwing a false positive. Post was complete with my fix. First response was "wish I could get paid to have someone else do my job". Shit went off the rails from there. /r/sysadmin and /r/politics are horrible, then there is /r/the_donald.... But /r/sysadmin is by far the worst I've encountered. Take the worst sysadmin you've worked with and put hundreds of them in a single sub. This sub is pretty decent.
Hmm. Using the migrations and defining the relationships in the migration files always properly sets them in my DB. Maybe I'm not understanding what you're saying?
Yeah obviously making highly scalable systems, database clusters with hundreds of GB's of ram and hundreds of CPUs, thousands of GB's of caching clusters, processing terabytes of data a day and serving thousands of requests a second is not enjoyable. PHP is only in ~15% of our systems, the rest is Node/Go/Java/Python, but you probably have no interest in learning them and improving yourself as a developer.
I've been using sublime text 3 but always find autocompletion kind of limited. That why i switched recently to phpstorm. I still using st3 for quick stuff but phpstorm his my defualt editor now.
This sub is still pretty bad. I've been thinking about unsubbing, but sometimes there are still useful posts here.
Transactions are not enough to prevent this. You need to send the request to a queue and then lock the tables when processing the request.
He should also lock the tables he's working on.
https://www.reddit.com/r/PHP/comments/1bdln1/symfony2_vs_laravel/c96ohf1
I don't have a base setup, sorry. I really redo it for every project, as every project has different requirements anyway. I attempted using a base setup, but it mostly slows down the project. I also don't use pre-made docker containers, as overrides are extremely hard to perform on `Dockerfile` definitions, so each image usually starts from a clean alpine or ubuntu image. Since I don't deploy docker myself (although I could if I moved to Google Cloud), I don't even have my own docker registry.
I don't know why you find it acceptable to switch to troll mode when you see a comment I made. Here's a rule of thumb: if you feel an urge to end a comment with ";-)" or ":-)" you're probably making a pointless snarky remark, that seems to not be appreciated by any reader here, so you can save it to yourself.
Yeah, I should have been more descriptive. These are both aimed at speeding testing up... :)
The site has heaps of different forms which are accessible to users who have undergone really specific processes. Before a form is provided, they check whether the user is in the right state to be accessing the form. Then a similar check is made when the form is submitted. As they've added more forms they've just copy and pasted stuff, changed the forms and the queries. To be honest, because every process depends on different tables and data, I can't think of a way you could generalize it, even with a rebuild. Do you have any ideas? You could try and store the state of each user with respect to each process, but that would probably end up being nastier.
Sorry I missed this answer, Thanks. This is where I am a little confused. I thought a prepare step was to tell the database to prepare itself for a query, with the exception of the variables, so even if the variables contain some injected code, the database won't execute the it, it'll just store it because it had prepared to perform only that specific task. Is that incorrect?
I really don't get why people would want facades. I mean sure, it's slightly faster to type, but it ruins nearly all benefits of dependency injection. And if you ever need your dependency injection container in your doctrine entities, you've definitely made a huge mistake. With Symfony 3's new autowiring by default, it's not any harder than just type hinting the needed dependency in your constructor. And even if you declare your service manually, the Symfony plugin's fix-it makes it really quick to add the dependency to the declaration.
&gt; ngrok Interesting, thank you for sharing this. This solves a frequent problem I have.
Lock the whole table..? But then you cannot have two distinct users doing separate transactions at the same time.
Best way to view this sub is lurk
Yeah it seems a lot of systems will use floats in PHP, but not in the DB. Does seem a bit dangerous though. I guess that's part of the reason I used to stick to INTs like you are. [Came across this, which basically says don't worry about it](https://stackoverflow.com/questions/4662138/if-dealing-with-money-in-a-float-is-bad-then-why-does-money-format-do-it) unless dealing with tiny fractions. Doesn't seem ideal though. I think I'll reassess next time I'm working on something with money. I wonder what the big systems like Magento do with their numbers in PHP?
They thought that someone with "autism" was literally retarded (e.g., very low IQ) and that they could not possibly "consent" to a BSDM relationship where they are the Bottom. What's curious is that ENTIRE CONTINENTS and countries have average IQs in the range of what the United States deems "borderline intelligent". I guess Drupal thinks no one with an IQ below 80 should participate.
I was using number format which was working fine for output, I only noticed because I tried to do something like if $val - $otherVal == 0 This was returning false, I could have formatted the operation before comparing but I would no doubt forget to do that at some point. I'm considering using a money value object and storing it in ints but then I don't want to have to do arithmetic using the model methods as I don't think it is obvious. It's just a bit annoying really. It'd be nice if you could define the behaviour of arithmetic operations on money objects. I might have a look at how Magento does it, that's a good idea
Not to mention that blade is kinda obscure for frontend designers
Yeah this kind of stuff makes me wonder if it would be useful for them to add a __toInt() magic method or something similar to [__toString()](http://php.net/manual/en/language.oop5.magic.php#object.tostring) - but I guess it's all a bit dangerous to begin with in a loosely typed language unless you're typecasting everywhere manually.
oh sorry didnt mean to clog up this subreddit with ?s thanks! yes u/radiomans3 worked perfectly. Is there any resources out there you recommmend to get a full grasp of PHP? i find myself just googling stuff for specific needs/use cases. Thanks a lot for the help!
&gt; i don't understand criticisms of active record. Lack of separation of concerns is main downside of AR. This is main purpose of AR - ideal for application which doesn't have lots of business logic. For larger applications you could for example move out all business logic to some object model, which will use AR as data model to store its state, but this won't be active record - this approach called row data gateway. The problem with AR is that "its the easiest thing in the universe". It's not always a good thing to use "easiest things" in not so simple projects. This often leads to situation where all application logic is coupled to persistence layer. The best scenario for complex applications which heavily rely on AR from my experience - everything will end up as transactional scripts without clear boundaries.
It looks like what I meant was operator overloading, and there is an RFC for it. https://wiki.php.net/rfc/operator-overloading That could be very handy for money objects
Cool good find!
I'd also like to see an example of that 
That's 4 years old.
You are not supposed to extend it though, you'll be writing validators in case the generic constraints are not good enough for business rules
&gt; I'm currently primarily using it with Laravel and it's a joy. That's interesting, because PhpStorm + Laravel don't really get along. All those facades and magic confuse the fuck out of it.
While class size _can_ be a code smell, it doesn't have to be the case. However, I do know that in Laravel a lot of code has been split in methods just to keep the methods small. This is kinda pointless imo, because it hides the complexity in just another function.
Do you have an example of one of those helper functions? Maybe that could strengthen your argument
You're pretty toxic you know that?
This would be 1 line of code if you did it right in Symfony :)
There's a plugin for that. Though it's kinda counter intuitive to hide the issues.
http://use-the-index-luke.com
I use https://github.com/h2non/imaginary for image processing. It's also rely on vips
I actually built my own accounting system in php/mysql, and obviously in all places you want both your PHP and SQL code to do any types of checks **before** doing the next db operation - so that no bad data/transactions should ever really exist to begin with. And also use constraints wherever possible. I'm moving over to postgres currently, and it has more features here which is nice. However, on top of above... also as a kind of backup/verification system, I have a number of SQL views that basically serve like warning systems. These views are written so that when everything is working properly, they should always return 0 rows. If something is wrong, such as as some balances not matching as they should, then these items will appear in the view. They kind of serve the same purpose as double-entry accounting - i.e. It's a different redundant system that should confirm that it's results match your main system. Their names are prefixed with "warning\_" and basically I have a daily cron job that does "SELECT * FROM" on all the warning_* views. If any rows are returned at all, I get a warning email to alert me that there's a bug in the system somewhere. I also can use these warning_* views for stuff like warning me about domain names that are about to expire etc. It's a nice clean way of doing things in SQL - easier to debug than PHP/app code that serves the same purpose, and can be used in multiple contexts.
Thank you for helping. I was just afraid to make my bro learn Symfony when he doesn't even know what HTML is. I have a question : my website is on a shared hostage and I don't have access to console. I can't use doctrine:schema:update. What should I do ? I was thinking about doing everything on my computer and then just upload the db on my website.
&gt; making all the queries in the entities is an absolute nightmare to understand and maintain This is nothing to do with Eloquent and is entirely up to how you wish to structure it. Using some form of repository pattern or similar entity abstraction is very commonly recommended. I've used Eloquent on projects with hundreds of entities with very complex relationships and reporting requirements and I've used DataMapper in projects of a somewhat similar size (although not quite as large, I don't think I've worked on a DM project with more than 80 or so). They both have advantages and disadvantages, but properly structured we had no major issues that were particularly unique to one or the other. I've also worked with much smaller projects backed with both AR and DM that have been utterly atrocious, where the original developers have managed to tightly couple completely unrelated models together with dodgy services that were a nightmare for maintenance and development. DataMapper won't save you from yourself.
I tried to get into it recently. It's not at all straightforward and pretty low-level and has a weird interface. Image libraries are known to have weird interfaces, but this takes the Cake. Basic functions like thumbnailing work great and easy, but anything beyond that, like watermarking, are not properly covered in docs. I'd like to see that performance tested. Plus it's not very easy to install. I had to open an issue on GitHub and call for help building on Alpine. I also didn't manage to enable text support on Alpine.
i envy you, i always stuck with native because i can't get the hang of using framework, luckily i didn't work for any company so i don't have the chance of being fired because I can't use framework lol
Confusing question, but basically: 1. Every vulnerability that websites in general have 2. A ton of fascinating race conditions, timing attacks, replay attacks, and more 3. An incentive for people to actually look for them and exploit them. 4. A host of horrible issues if you store or manipulate currency values as floats (do not ever do this). So eg, if someone does something to increase their balance, can they send the same request repeatedly and increase their balance multiple times? If they add some funds, and then send multiple independent requests to spend them, will one go through and the rest be rejected? Are you *sure*? Because it's really easy to accidentally make a system where multiple ones will be accepted, putting the balance into the negatives or (even worse) where multiple spends will be accepted but only the last one will actually change the balance. And so on. You'll also want to have a ton of checks for out-of-range values. Eg, people trying to spend negative amounts, or depositing negative amounts. Plus all the normal permission checks you'd expect. You'll also be a lot happier if you build the system around aggregating immutable events. If you want to know what someone's balance is, it's much better to start at 0, then apply all the events which changed it, rather than just have a single "balance" field and hope it never gets bad data entered into it. FInally, you've got all the vanilla XSS attacks, CSRF attacks, session fixation attacks, etc., etc., etc. to worry about.
Yep, that's good. So long as you don't manipulate it as a float, ever, you'll be okay. I quite like the [moneyphp/money](https://github.com/moneyphp/money) library to help support this pattern.
&gt; Came across this, which basically says don't worry about it unless dealing with tiny fractions. That's dangerously wrong. Or at least misleading: &gt; For pure rounding/display purposes, you're safe as long as... Right, but the second you need to calculate a discount, or tax, or do a lot of quite common routine math, you're absolutely screwed. You can use floats for *display* purposes; you can't use them for doing math.
Yeah seemed a bit risky. How do you handle this kind of stuff?
People like facades for the reason you gave: "I want to access this feature anywhere" and I agree with the fact it can lead to bad code. But I could do the same bad code in Symfony injecting the container inside a repository and using the mailer from there "just cause it's simple" (injecting the container should be forbidden). Symfony does this error in the controllers with some methods, for instance the "render" method in the controller does that https://github.com/symfony/framework-bundle/blob/master/Controller/ControllerTrait.php#L219 protected function renderView($view, array $parameters = array()) { // .... return $this-&gt;container-&gt;get('twig')-&gt;render($view, $parameters); } I always wondered why they don't inject an instance of Twig or a RendererInterface into the controller constructor like you would do in a ZendExpressive project for instance. Using injection for the controller would make them Framework Agnostic. My point is : You can do bad code if you are willing too, frameworks are just tools, they won't protect you from writing bad things ;)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [symfony/framework-bundle/.../**ControllerTrait.php#L219** (master ‚Üí 490d02f)](https://github.com/symfony/framework-bundle/blob/490d02fef3f54e008e8360a29d0fffec071494f6/Controller/ControllerTrait.php#L219) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkk9vaj.)^.
TBH, I'm currently rebuilding a 10 year old site with symfony and it has tools for dealing with most of the common problems. Creating and saving a form in Symfony is pretty easy, and organized. Its *much* more complex than a pile of raw php and hundreds of different files, but that complexity is worth it. If I had 200 forms with very complex criteria I'd make a modular system to allow me to control process flow. With no idea what common criteria are its hard to say how hard that would be, as far as it being even nastier to store the state of each user... I doubt it, its already being done in code that is duplicate hundreds of times by the sound of it. With 200 different form each with 200 different sets of criteria, It just sounds like its horrible not because it has to be but because it was poorly designed and needlessly over complicated. I'd point out when I say that any number of reasons exist for that. Bad budget, massive scope creep(poor initial requirements), time constraints(limited to quick and dirty) etc so this isn't an insult, just a statement of fact. Give an example of one form. What does the user enter, and what criteria need to be met? TBH I'd be shocked as hell if, having more information on how the site actually works i couldnt say "oh just do x and you can eliminate half of the code required and do the same thing. At the end of the day I'd be unsurprising to find out its a site like Craigslist with 1 form for each city and the complicated user state boiling down to "is their address in the city of the form they are submitting. I know it wont be that, but I sense some similar antipattern at work here. You can insist that this isn't the case, but if you've already determine what can an cant be done and that is not subject to examination you've already decided that you don't need help. Given the hostility in some of the replies, it seems like you are frustrated/overwhelmed but unlikely to reply with enough information to actually get help. Usually when people are too cagey about providing more information its because they anticipate the answer will be something they don't like.
As of Symfony 3(point something), You can do dependency injection in Controllers the right way by adding a type hinted argument. That reduces the amount of time you need the service container to a minimum: https://symfony.com/doc/current/service_container.html#fetching-and-using-services But you're right, the built-in Controller methods are doing it wrong. I guess that if you really need reusable controllers for some reason, you could just not extend from the base Controller. The huge problem with facades is that it ties your class to your framework / current project. You can't easily reuse that class in a different project anymore, especially not a non-laravel project. Dependency injection would solve this issue. I agree that not all classes will be sharable between projects though, which is why I always found it okay for Symfony controllers to use the service container directly. This is also why I'm absolutely against dependency injection configuration with annotations (docblocks in PHP). The class not constructing itself / containing the instructions for how to construct itself and not adding a dependency to any type of "builder" (or annotation class) seems like it's exactly the point of dependency injection.
My goal here is not to prove a point, just to clarify things if someone reads this comment without knowing what is blade or twig. ------- **Twig** is a template engine with a lots of feature that don't feel like PHP. Twig feels like another langage and is easier to pick up for someone not familiar with PHP (for instance, your front end developer). If a variable, or a key doesn't exists for instance you don't have to check it, twig will simply show nothing. For the developer this engine can be a pain since you have to declare every function / filter available, you can't access directly to your "helpers" and you have to create a TwigExtension for it. This forces you to split your logic and prevent you from writing a ton of PHP into your view "just cause I need it" It looks like this {{ post.created_at | time_ago }} -------- **Blade** on the other hand is a template engine that is quite close to PHP. It translates some keywords but the code you write still has to be valid. This mean you have to write valid PHP inside the {{ }} tags. Inside a blade template you can access anything declared into your application since you are writing PHP (you don't have to create an extension to access a function). It looks like this {{ time_ago($post-&gt;created_at) }} ------ There is no "blade &gt; twig" or "twig &gt; blade". This is two solutions for the problem of templating, choice is better ;). 
Also using docker-compose.yml. * PHP-FPM (7.1) * nginx (1.13) * MariaDB (10.2) (aka MySQL clone) * ElasticSearch (5.5) * Redis (4.0) * RabbitMQ Production usually on DigitalOcean or AWS
What works best for me is: Use the [moneyphp/money](https://github.com/moneyphp/money) library; it tracks values internally as integer numbers of cents, and avoids all floating point math. For storing them in a DB, I use `BIGINT` columns to again store the number of cents (`DECIMAL` would work too, but I'm using [this library](https://github.com/MichaelGooden/mdg-money-doctrine) to integrate with Doctrine, and it chose `BIGINT`.) And then at the very, very end, I'll convert them into floats for display. But anything that isn't a template will get and receive `Money` objects.
Not everyone defines things properly, they don't have a clue how to structure databases 
First "duh," then "pretentious," now "troll"? Aramaki, man, I *do* like your persona here, but you have no cause for complaint when you attempt personal insults. So, if you feel an urge to make personal comments instead of plain and honest technical critique, you're probably making a pointless remark of your own, so you can save it to yourself.
I'll save people the effort - "essential dev tools" are php, composer and PsySH. So, the language &amp; intepreter, the defacto package manager and something I never use. Not really what I would call "essential dev tools" bruv
You should check this: https://www.mindjet.com/mind-mapping-project-management/
&gt; Don't use laravel at the moment and probably won't That's nice. Laravel Valet isn't Laravel.
Build some stuff first, then jump in. 
1. Install PHP and use the built in server to serve simple pages. 2. Use a local development environment toolset like XAMPP. 3. Use a virtualized environment like Vagrant or Docker.
http://php.net/manual/en/features.commandline.webserver.php
plugin name ?
I would not use the &lt;form&gt; tag but rather &lt;div&gt; that has a onclick pointing to Ajax calls thar submit to the same file with different variables.
I would advise learning the basics and foundations of PHP and then go with Laravel, there is a great series on YouTube building a blog with Laravel just search devmarketer
Not necessarily. You can have all the forms functionality in one document and define what function/action should be run depending on what submit button has been clicked f.ex. Let's f.ex. say you have one of your submit buttons named `ok` (or whatever, this is just for the simplicity of the example); &lt;input type="submit" name="ok"/&gt; &amp;nbsp; You can then look for that button-push in your php document; if(isset($_POST['ok'])) { // Some action } &amp;nbsp; This could be used for everyone of your buttons, say an `ok2` perhaps; if(isset($_POST['ok2'])){...} and so forth. I'd say it's a little about preferences how you do it. If the functionality is little, then I'd probably keep it in the same document. Are there gonna be a lot of functionality, which would mean a document with lots of code, then it might be a good idea to break it down into smaller, separate documents.
You also cant have two distinct users doing the same transactions at the same time.
&gt; I really redo it for every project, as every project has different requirements anyway. Doesn't that defeat the purpose of using Docker?
If you want to build a web app as fast as possible, certainly use a framework, I recommend Laravel if you are not looking at something very large scale. If you are expecting a good quality for this application and you have very little PHP experience, try to use libraries and open source plugins instead of writing things from scratch (be wary of what you choose). A good library will always be better than something written from scratch, don't try to reinvent the wheel.
if the forms look the same you would create a form class and reuse it..ideally you will have a controller for every post but you could also have one controller and just pass in the argument like step1,step2 and than have a private method getFormByStep which will return the required form handler based on the step or call a service or whatever else you need to do :)
ideally you would learn proper PHP but if you want to start real fast..our designer got up and running with Symfony in one week without PHP knowledge..she was able to create a nice site with some crud and login and later on a simple e-commerce
Not the same transactions, but separate ones. Locking the table makes it impossible so it is not a solution. Using mutexes is the only correct way.
Awesome answer, thank you very much.
You are very welcome^
Either works. Assuming you have no other framework in play to help you keep your code organized, it might be preferable from an organizational perspective to have different .php files handling different form submissions. I guess I'd name the file with the form WhateverForm.php, and then the different submission handlers WhateverForm-1-ContactInfo.php, WhateverForm-2-ProfileDetails.php, etc. Some naming convention that has them group together in the file listing.
There is two other reasons for injecting the container: - It's an easy way to provide lazyness (a cleaner way is being worked on) - Some people (like Fabien P. IIRC) consider that Controllers &amp; Console commands are just a glue between the delivery mechanism (HTTP, CLI) and your application. 
I think you misunderstand something though, the reason why Doctrine and HttpFoundation are that way is for performance reason. It's the very foundation of everything, so yes, you sacrifice readability and maintainability for performance. The validator on another hand... fuck it
Rather than hiding the complexity, it forces you to go through 50 methods to follow what's going on...
And to be fair, the responsible for shitty code is rarely the framework, but the one using it. I saw pretty shitty code bases in Symfony as well, the framework doesn't make the developer (although it can help him to improve for sure).
With XAMPP or MAMP where does the code actually go bc I have those on my computer
Helper functions are fine, global functions are not. If you want to use a helper (or not) function, declare it in a namespace, not the global namespace. Period. That practice done in Laravel is just plain stupid and harmful. Stupid because the ONLY reason to do so is to avoid a use statement. That's all. Harmful because it encourages people to do the same because there's actually some people that don't know you can register functions in a namespace. It is also worth noting that autoloading is not well supported for functions. Two examples: - If you register functions in a file, you cannot autoload the file with Composer and need to specify it in the autoloaded files manually - When a function has been loaded, it's done. You can start a separate process you cannot change things, this is a bit annoying for mutation testing tools for example: https://github.com/humbug/humbug/issues/194
You're confusing functions with functions registered in the global scope. You have namespaces, use it. namespace Foo; function foo() { ... } As opposed to: if (!function_exists('foo')) { function foo() { ... } }
I personally use them a lot: - https://github.com/humbug/php-scoper/blob/master/src/functions.php - https://github.com/humbug/php-scoper/blob/master/tests/functions.php It's just that I tend to find it cleaner than a class with only static methods really...
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [humbug/php-scoper/.../**functions.php** (master ‚Üí 72182d9)](https://github.com/humbug/php-scoper/blob/72182d9357e4b9c7cd11de6da96c0206b0752054/src/functions.php) * [humbug/php-scoper/.../**functions.php** (master ‚Üí 72182d9)](https://github.com/humbug/php-scoper/blob/72182d9357e4b9c7cd11de6da96c0206b0752054/tests/functions.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkkm7ur.)^.
You'll need to read the docs to find out the default webroot path; however, it's probably configurable. 
You should still use the form tag. Feel free to prevent the default behavior of the form element using JS, but use`&lt;form&gt;` to keep it semantic. Remember, it's the internet, other devs will work on your code, and your ability to create code that is versatile and useful for other developers, in many ways outweighs the tricks you can do with the code when you absolutely have to.
Autowiring. Autowiring is nice as it lightens a lot the service declarations for sure. However in Laravel, if you get the wrong instance at one point and want to debug it... be ready. In Symfony at least if you have a wiring issue, you can see the wiring dumped (even if you use autowiring) which makes things super easy to debug. Another example: BC breaks in minor versions. Taylor's view on that is "it's fine as long as it's kept under 1 days work". Well two counter arguments: - I don't have time to upgrade everything every 6 months, I got a job to do - 1 days work of Taylor is not 1 days work of everyone - 1 days work perception of Taylor is also because he knows very well how things should be used. If you happen to use heavily something that is removed in the next version, you can't do shit Another argument: Laravel is the only popular PHP framework not following semver, because you know, fuck it. Thanks. To be fair I'm ok with it for the framework itself, but it really is awkward when that hits the components as well. Any library in PHP is semver, except Laravel ones. Cool.
I would have each form's action point to a different php file to handle it. That way updating the processing for one would not have unintended consequences on the other(s). &lt;form action="/one.php"&gt;...&lt;/form&gt; .... &lt;form action="/two.php"&gt;...&lt;/form&gt; 
[removed]
[removed]
Your strpos example I've experienced before. So this makes great sense. So, realistically. Great code should never require === Would it. It make more sence for php to not throw a fatal when accessing a non existing variable? As this would stop the poor use of isset/empty FYI the above is apreatiated, I consider php THE community code. So code improvements are driven by ( while not always positively ) places like this Reddit. 
Yeah, you can also mention node which did 8 major releases in 3 years. You're free to think it's a good idea, for me it's not. Now allow me to call you stupid to think it's a good idea, you know just because I feel like anyone disagreeing with me is stupid and don't deserve respect. Also as I said, I can be ok with it as a framework policy. I don't like it but other people can be fine with it so I don't particularly care except when I happen to have to deal with it in which case I feel pretty pissed about it. But for components which are used as dedicated libraries elsewhere, no, it's just harmful to the whole ecosystem. We have a one of a kind ecosystem where almost all libraries are semver (unlike JS for example). So Fuck Laravel for breaking that yes, that one is pretty bad.
... Or just in official php docker hub https://hub.docker.com/_/php/
I've stopped submitting forms via HTML completely. It's all requests sent by JavaScript, and the responses are displayed by JavaScript, including if there are errors. Simplifies everything substantially, and a lot of questions like what-goes-where become irrelevant.
 I'm a developer. Not a PHP one neither a Symfony one. I do use PHP and Symfony but not only those, FYI I actually have more experience with Laravel than Symfony. So fuck you with your stereotypes. It's the second time you insult me for no reason with poor arguments. Also your argument is plain wrong, or rather it proves my point. The reason why Doctrine UoW or HttpFoundation are in one file is because it's easier to optimize that way both code wise and thanks to OpCache. If you were to seperate things more for achieve cleaner code with a better design, the performance impact would be considerable. It's usually not an argument, but for things as used as HttpFoundation or the UoW it is very important, a 1-2% performance difference has a considerable impact for them.
On the internet: "Save this file as ‚Äòtest.php‚Äô in c:\xampp\htdocs\ (or whichever directory you installed XAMPP in)." Either way search htdocs on your machine. 
Jeez that's nice. PMing you right away.
It depends. Obviously if you have a site search or separate components on the page, they can be their own form element. But if you have one form with mixed 'entities' being posted to one place (eg. An order with an address), you can use an array to store the form data. &lt;input name="[address]street"&gt; &lt;input name="[address]city"&gt; &lt;input name="[order]referenceNumber"&gt; &lt;input name="[order]email"&gt; This keeps your entities separate and free from mixing up common property names (like contact.phone and address.phone) without having to create a unique name for the common field/property name. Edit: /u/CODESIGN2 explains what I meant to put.
[removed]
Ah nice, they finally added them!
That's why it's in this case, a pretty bad example. If it's complex, don't hide it to keep your methods small.
Don't know, I guess something with Laravel :P I never used Laravel nor will I ever, so I won't bother with it, I've just seen it come by.
No, docker gives me reproducible local and CI environments for all the team. Reusability is not a concern.
Cool thanks. I'll definitely look into moneyphp next time I'm doing some money stuff.
A side note of caution: It isn't legal to nest &lt;form&gt; tags inside one another. I've actually seen a multi-form system that ended up this way and it limped along for a while but... Eeew. 
Also consider if your need to build the entire app very fast is actually a need to build a very minimalist version very fast that you can learn from and add onto later.
Just read the documentation, and you'll be fine. Not crappy out-of-date stuff like w3schools, but the real docs https://php.net
This. I keep experiencing a bug where I can't click out of it.
Man Youtrack is hard to use. I just wanted to browse PHPStorm open issues by priority descending. Nope.
inconsistent parameter order
[Craft CMS](https://craftcms.com/support/sharing-craft-files) supports sharing the core files between multiple unrelated sites, and version 3 (expected to be released later this year) will also have proper multi-site support. Sadly it's a paid CMS though it's source is open.
&gt; ngrok (to show my stuff to clients and co-workers) Does it provide any advantages over starting an ssh tunnel to a server you own?
&gt; Laravel if you are not looking at something very large scale. What do you mean by large scale? And what would you recommend in those situations? Not refuting you or anything. Just interested in what people suggest in all sorts of situations and why. Never know when it will come in handy later, and it often does.
Yes: they do it for me. Plus I pay less than maintaining a server somewhere ;-) [EDIT] also, ngrok has a decent monitoring/request replay UI - not really extremely useful, but good enough to see what is going on
`Parse error: syntax error, unexpected (T_PAAMAYIM_NEKUDOTAYIM)` was pretty confusing when I first encountered it.
Why they made the ternary operator left-associative instead of right-associative. And why it hasn't been changed. It's not even useful that way round, in (literally) any situation.
There's an example of rendering text on an image here: https://github.com/jcupitt/php-vips/issues/46 #!/usr/bin/env php &lt;?php require __DIR__ . '/vendor/autoload.php'; use Jcupitt\Vips; $in = Vips\Image::newFromFile($argv[1], ['access' =&gt; 'sequential']); $text = Vips\Image::text('HELLO REDDIT', [ 'font' =&gt; 'sans 120' ]); // the position we render the text at, in pixels ... this will centre $x = $in-&gt;width / 2 - $text-&gt;width / 2; $y = $in-&gt;height / 2 - $text-&gt;height / 2; // stretch the text out into a huge overlay mask $overlay = $text-&gt;embed($x, $y, $in-&gt;width, $in-&gt;height); // use the overlay to blend the image with the colour red $out = $overlay-&gt;ifthenelse([255, 0, 0], $in, ['blend' =&gt; true]); $out-&gt;writeToFile($argv[2]); I don't know if that helps much. I might be making your point for you :( 
&gt;I rather see php get proper collection tools internally. As would we all, but a decent collection library is a very small dependency for a dramatic readability improvement. The "added overhead" is going to be imperceptible in the vast majority of cases.
Jesus, when strpos and streplace were different I was shocked. The inconsistency in the language is horrible!
What's not to understand? It was an unexpected paamayim nekudotayim. Geez some people can complain about anything
[removed]
You are the one being horribly toxic about most of those things and you are one of the people initiating this hate...
This one is actually not that bad. Check the image watermarking example here for instance: https://github.com/jcupitt/php-vips/issues/40
http://i.imgur.com/eHiRRLZ.jpg
I've seen terrible implementations done with doctrine. Active record can have elegant implementations as well.
Honestly that is the most annoying aspect - you have to read the documentation. If you just assume that `DateTime::ISO8601` means an ISO8601 compliant date or that `money_format` would never have undefined behaviour, well, hopefully that never becomes an issue for you.
That is a good point. I already have access to a number of severs (so it is not any extra cost), and what I usually do is run a reverse ssh tunnel to expose local services to the internet when needed. The request replay part seems to be a very nice feature. 
There should be a support group for ex-zf1 devs.
Automatic typecasting in comparisons. The last "Thanks, PHP" moment I had was where ($x == null) evaluates to true when $x = boolean false, the number 0, the string "0", or in this case, **an empty array**, since I was checking the return value from a function that can return either false or an array of objects.
I think it's hard to realize you can write really well structured and well architected code quite easily. This is mainly due to millions of articles written by Delva of varying levels of experience across decades of maintaining backwards compatibility and the overall accessibility of the language. This is not to say anything should change. I think php is a fantastic language with a great community. I'm just saying that it's so diverse, it can be easy to miss that it can be used for enterprise applications just as much as weekend hobbies.
A lot of it is because the function parameters are often drawn from the conventions of whatever language is in vogue at the time. 
Just imagine how confused the non-anglosphere gets about all the english language documentation and errors they have to deal with.
Why can't they just follow something like (source, destination) or (search, source, destination) and stick to that?
Symfony requires that an interface be defined as an alias for an actual implementation in newer versions. I'm okay with this implementation of autowiring, as long as the definition is manual. I write large, enterprise Symfony applications for my job and the simplicity of autowiring is greatly appreciated.
/r/sysadmin is fine. Don't be dumb.
Writing good and maintainable code. Getting started with PHP is easy, but writing code you can open in 1 year without asking yourself "wtf is this shit" is harder :)
Of all the things to complain about in PHP, I've never understood why people complain about that. If you're using multiple embedded ternary operators without brackets so that it matters, you've got bigger problems than the ternary operator's associativity.
They do now, but it is too late.
Nah, most of us still learn English in school as a second language. :)
Like most web-scripting languages, the relationship between the webserver, the language, and the output. Writing a CLI PHP script is easy to grasp. Do this thing, then this thing is on the screen. Writing a PHP script executed by apache results in output somewhere else and possibly just a whitescreen, depending on factors like ini settings and browser rendering.
I enjoy that I don't need to manually configure numerous services every time I include simple data transformers in a form. If I need to configure the service very specifically, I can do that as well, but its less necessary now. For most of my services, the configuration is done by implementing my constructor. 
Use === instead. For when you want to make sure something REALLY equals something else.
Just use === all the time, unless you really want to do php type casting for you. You barely ever need ==. Also, === is faster than == because it doesn't have to convert the type before checking the values
I want to say that's a really incorrect pluralization, but... carry on.
Inconsistencies in the core API as far as parameters (Needle then haystack? Haystack then needle?!), case (camel vs underscore) and abbreviation (strpos vs money_format in the same API). In retrospect these are negligible with good tooling/IDE tech, but if you are just starting out in programming it can make things tougher. Now I code with references nearby and IntelliJ products so if I don't know the damn name I can find it quickly enough. It is really quite a simple language to understand. And you can do a ridiculous amount of work with it.
Good point, but holy crap when I started writing JavaEE and SpringMVC stuff (despite just having worked on pretty large Laravel projects) I had such a hard time just hooking things up properly. For me PHP project start up is a real snap, but at this point I understand the whole webserver interaction and HTTP protocol enough to iron out a lot of those teething issues.
Why many programmers look down on it.
IMO if you want to do it properly, send an AJAX request to a specific action in your controller. It's 2017.
Exactly...The moment you see yourself writing embedded ternarys you should stop and rethink life.
&gt; you've got bigger problems You can say that about *every* PHP annoyance. Nested ternaries are a nice syntactic sugar for some situations ([basic example](https://stackoverflow.com/questions/20559150/ternary-operator-left-associativity)). The main thing that annoys me is not that it's just a little quirk or wart, it's that it's 100% useless. 
Installing and configuring XDebug. Then getting it to work through Docker.
I remember reading Taylor Otwell himself saying something suggesting that Laravel was not meant for large scale projects. I will try to find the quote. Personnaly, I would think Symphony is more adapted for a really large project.
In the most common use cases it's a huge convenience. In some less common use cases it feels annoying to have to circumvent it or try to get it to do something complex.
Yep. If you use phpstorm (use it), install the awesome EA Inspections plugin by /u/kalessil . It highlights all `==` usages where `===` is appropriate. My code is thousand times better with this plugin. 
I'm a newbie with Symfony 3 and I've enjoyed the KNP course on it., very approachable imo Learning a framework is probably going to slow you down, but only because doing things wrong and poorly is much faster than doing them "right" (a newbie could hack together an authentication system in raw php in 15 minutes, an hour if you add a database in. You wouldn't want to use it though. That said you have a much higher chance of a painful rebuild if you do it without a framework. In the rewrite you'd just have to learn how to avoid the shortcuts that made the first time faster. I'm a fan of not reinventing the wheel, especially when much more intelligent and experienced people have spent years making a better wheel. I wouldn't be too dogmatic about suggesting Symfony specifically, but the argument in favor of using a framework is strong imo.
why is this hard? ondrej/php PPT has `php7.1-xdebug`, and I suppose you can map ports easily with Docker?
I think it's pretty obvious I don't have a controller, I don't even know what you are referring to! Would this be an [MVC controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)? 
**Model‚Äìview‚Äìcontroller** Model‚Äìview‚Äìcontroller (MVC) is a software architectural pattern for implementing user interfaces on computers. It divides a given application into three interconnected parts in order to separate internal representations of information from the ways that information is presented to and accepted from the user. The MVC design pattern decouples these major components allowing for efficient code reuse and parallel development. Traditionally used for desktop graphical user interfaces (GUIs), this architecture has become popular for designing web applications and even mobile, desktop and other clients. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
laravel fanboys
On performance, there are quite a few vips benchmarks around. The main one is here: https://github.com/jcupitt/libvips/wiki/Speed-and-memory-use The PHP binding isn't listed, but it runs a little faster than the Python one, so about 3x faster than GraphicsMagick. sharp, the main image resizing package for node.js, is based on libvips. They have a page of benchmarks: http://sharp.dimens.io/en/stable/performance On that test, vips is about 4x faster than the best GraphicsMagick version.
On this note, I've always been a bit mystified about the different ways PHP can be run and how we all settled on php-fpm (and what that even means)
And many of you are better at it than many of us haha.
Pretty much this - pre-selection of the logic that is going to be fired on the backend is the simplest solution. Multi-step forms are still horrible, but this kinda works :)
I was pretty confused, as well. Turns out it's a simple spatial-temporal paradox, remedied with an easy 4D causal re-arrangement.
So you're saying PHP played a vital role in teaching you reality?
Oh boy, you get to learn something today! PHP-FPM is short for PHP FastCGI Process Manager. It manages the running PHP processes that communicate information from the web server to the PHP source code. You make a request to a webserver (i.e. visit www.example.com/welcome): That webserver communicates with the PHP application go get information you requested ("Give me whatever is located at /welcome.") and send it back (Your application responds using whatever routing method you use with the logic you have in place at /welcome). How does the webserver communicate with the PHP source? Through a "Common Gateway Interface"! A CGI! So, PHP-FPM is therefore a process manager for PHP processes that are run through the "webserver to application" interface. Here's a SO article that explains a lot about CGIs https://stackoverflow.com/questions/2089271/what-is-common-gateway-interface-cgi FastCGI is just the next generate of CGI: It manages processes a lot better and can keep several open at once while it waits for requests, so it doesn't have to start up a new process and wait every time a new request is sent to the webserver. FastCGI is generally about the same as mod_php. But it's the implementation of Nginx alongside it, which reduced the amount of static resource requests that PHP had to handle, is what has kind of made the current "go to" for high performance and/or distributed web applications.
You can save yourself a lot of trouble if you compile and test on a Linux VM, unless your bug is Windows-specific (and it seems here it's not).
Just a note about FastCGI is far older than nginx.
For me, the most two difficult of PHP are not of technical order but of ecosystem order. First, I really don't understand how PHP manage to allure this huge amount of bozos. And I say this in good heart - there is no filter whatsoever. You can literally just sit and code, and somehow this is the "PHP Way". I can't understand that. The second aspect that I have huge difficulty to understand why there are all these tribes under the sun. I know that every language has some tension going on towards different directions. But PHP takes this to a schizophrenic level: depending where you are in the world (South America, North America, Europe, China) - the prevailing framework changes; depending on what you are doing the prevailing tool changes; there is one tribe for every corner of the ecosystem and they do not cross-polinate as much as they should, and I just can't understand why. Edit: minor text change to make it more clean, under the sun vs on the earth.
Yes, but I don't know what your point is. Mod PHP implents fastcgi just like php-fpm.The power is from adding nginx, to which php-fpm is needed. 
I only got there after I started working on bigger projects in teams that do code review, rather than doing small projects by myself. Having to work with other people's code, and getting your own code reviewed helps a lot in understanding how to write well structured and maintainable code. Good documentation is also really important. Explain what the intention is, not what the code does. Later on I also found that writing unit tests helps bringing the maintainability to the next level. If in your unit test you need to mock a certain dependency and you cannot justify why this dependency is needed in isolation, then it means that your class has too much responsibility and probably needs to be split in two classes. This helps re-usability and maintainability.
In PHP 7.1 strict typing has become usable, I'm using it where I can and it saves me a lot of headaches. I think PHP 7.1 made PHP great again :D
This used to be like this, but in recent years I see a lot of convergence happening. This is for a big part due to the efforts of PHP-FIG and the PSR standards I think. And Packagist :D Doesn't matter what kind of project you work on, but Composer will be your dependency manager, Guzzle will be your HTTP client, you will be using a bunch of Symfony components. Laravel is the framework to use for prototyping and medium size projects. Symfony is the framework for large projects. Wordpress is for small content based websites, Drupal for large ones. Sure there are still a lot of different tools out there, but compared to only 4-5 years ago the ecosystem is vastly matured I think.
Why is that difficult? Use an IDE.
The biggest issues with the language seems to be unanimously an inconsistent param member ordering. That shit is easily resolved by using any IDE or Editor worth anything. Seems like this is a pretty solid language with very trivial reasons for hating it.
Two things: - [the Laravel plugin](https://plugins.jetbrains.com/plugin/7532-laravel-plugin) - but more importantly: [laravel-ide-helper](https://github.com/barryvdh/laravel-ide-helper) No more problems with Facades (though I use them sparingly). There are of course cases, due to all the magic (e.g. Eloquent models delegating to Builder, etc.) that you can't always have autocomplete on all call chains but that's a minor issue.
Coroutines.
Write comments and documentation.
In those cases, you can just keep using the existing service configuration. So, the "worst case" in autowiring is to do what we've been doing for the past years.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
IIRC it's taken directly from C.
Yeah it didn't sit right with me either. Although it wasn't worth investing much more time into.
Ah yeah, fair enough. Yeah seems that Laravel has a lot of breaking changes, that could big a bit difficult on large projects. I'm using Phalcon... obviously the speed thing was an initial interest, but I think it's a good framework regardless of that stuff now. Even when they completely rewrote it, and in another language (originally C in v1 and then in Zephir for v2) there were barely any breaking changes at all. Think I only needed to change about 3 lines of code. And yeah Symfony seems to be what most people recommend on big corporate type projects. I don't know much about it though.
While the syntax is interesting and there are definitely things PHP should do to simplify some... I just don't see a reason why this particular idea would even be used in production
Tool author talking here ;) Indeed it's just syntactic sugar, to reduce a bit PHP's verbosity ($variable-&gt;attribute, &lt;?php echo $this-&gt;attribute; ?&gt;, etc), and fix a few other details (relative include paths, foreach argument order, etc). So I admit this tool has probably no real interest for people who don't care about these issues or prefer to use external template engines to solve them.
Oh boy, you get to learn something today! mod\_php is an Apache module that runs inside of the Apache process. Using mod\_php is one of the easiest and quickest ways to get PHP up and running. Every time Apache needs to spawn a new child process, it has to load all of PHP (and all other loaded modules) with it. In turn, this causes each Apache process to use that much more memory. This also means that PHP runs as the Apache user, which means you run with Apache permissions and the same memory-space as Apache (I.e., if either PHP or Apache crashes, then it takes the other with it). Lastly, mod\_php can only be run under Apache. On the other hand, php-fpm (FastCGI process manager) is a separate process from Apache. In fact, php-fpm can be run from any web server (e.g. Apache, nginx, IIS) that can run FastCGI. This setup requires more effort, as you need to configure the FPM server separately of the web server and you need to configure some sort of proxy so that the web server can communicate with PHP. php-fpm also reduces the memory requirements of the web server, since spawning either type of process does not necessarily require spawning its counterpart process. You also get an additional security layer in the sense that both processes can be run as independent users with their own set of permissions. If one process crashes, it does not directly affect the other process. This also means that you can restart either process without directly affecting the other process. Another bonus of php-fpm is that you can more naturally run multiple versions of PHP on a single server. While in mod\_php you can run multiple versions of PHP, for every Apache process spawned you will have to load N number of PHP modules (where N is the number of versions of PHP). When using php-from, you only load the number of PHP processes that are needed. It is also worth nothing that there are two flavors of CGI that can be used: FastCGI and fcgi. The biggest difference between the two is that fcgi can only send one request to PHP at a time. FastCGI can send multiple requests (hence why it's called "Fast"). 
I like that it's written in D. Not enough people use D, it's a great language.
&gt; since I was checking the return value from a function that can return either false or an array of objects. To play devil's advocate, how is this PHP's fault? The developer of the function is the one who decided to return two different types in the first place. As an aside, I've never understood why some people prefer to do this to themselves/their users. For example, if your function is meant to return an array of items, and there are no items to return, why not return an empty array? Equivocally speaking, an empty array does the same thing as false, but without having to code defensively for it. What I mean by that is when you return an empty array you can still do a `!$results`, but more importantly, you can skip that check and do a `foreach` without side effects. You can't do `foreach` with false or null. As for using `==` vs `===`, be mindful that the latter checks for identity as well. This means that for objects, they must be the exact same object and not a copy or different object. In other words `(object)[] !== (object)[]`. 
There is nothing wrong with a plain old form despite the current year. It works in all browsers without any JavaScript and without any additional client-side effort, and will for many years to come.
Such question are always hard and almost impossible to answer. You're asking for a comparison of apples to oranges. One is a fully integrated development environment, the other is a fast text editor with plugins on top. You will newer have the level of integration in something not meant to be. But this level is what sets it part. When you start with PhpStorm, "m'kay, it's just a editor for PHP". You may realize it doesn't act as fast on very big files like others do. But others don't offer you the level of introspection, either. Certain features come at prices, sometimes. After some time you learn about refactoring and you realize: I don't have to depend on manually renaming a class, it's file and **all** the location the class is references. In PS, I can do it with a single atomic operation (means: you can undo the WHOLE thing too). You may not care about refactoring? But I bet you care you about being able to go to definitions. Or: find it's usages. Ever wondered there a certain method is called from, in your whole code base? "Ah, I got a plugin for that" you say. Good. Then work with some frameworks where there's a magic involved and your classes simply aren't literally used/declared but implicitly. Magic DI, whatever. PS got you covered too. JetBrains cares about these cases too and allowed those magic frameworks to provide a layer in between, if they want. This is what https://github.com/barryvdh/laravel-ide-helper does for Laravel. And suddenly you're back on track. I bet you'll not have this in the foreseeable future in any other editor. Good, you don't care about "go to definition" but you may want to run your unit tests. Often. Partially (only selected classes, etc.). You're covered. Very nicely integrated actually. A few tests failed? You fix the code and then what? In PS, you can just re-run the failed tests. This is powerful. And it's just one action button away. Screw tests, you don't need this integration? But you're surely using git. Integrated. It may not be the best integration when it comes to viewing changes on a lots of files. But being able to: - switch branches - rebase - amend - merge - push/pull All within just makes your workflow so much faster. You may be a git wizard and 1000 of aliases but these mundane tasks also take time and not having to switch context (i.e. to a terminal) for these things literally can safe you time. So your project is like Web 3.0 and you don't have just PHP. You've TypeScript. You've React. Eslint. All-the-fance-npm-yarn-packages. Yup, you're covered. Like, literally completely. Ok well, may not have as a good test integration with e.g. jest as phpunit, but hey. But you're not developing locally? You run everything in vagrant? Your phpunit has to be run over SSH? Yo, you're covered. PS can transparently execute most things remotely and still report you back within your IDE. Got a database? Haha, of course you do. Integrated. Totally. Can connect to almost any kind of database. Autocomplete all tables/columns/indices/whatever. Even more so: once you tell PS where you DB is at and you write SQL within your PHP code, you get integrated autocomplete there too. At first I found that level of integration insane. Today I already take it as granted. Truth to be told, with ORM-all-the things you need this less often, but hey: it's there. When you reach that level of understanding of the benefits of PS, you want more. You want: - code coverage. You want to see within the IDE which lines are covered and which aren't. Check ‚àö - code inspection and quick fixes: the IDE reports you that the return type of `public function foo()` actually returns class `Bar` and provides a quickfix. Your code base is littered with the return type decl omissions. But there's a quick fix. The ide can do it. For your whole code base. Atomic. Undoable. Or you want to convert `list($a, $b) = ` into `[$a, $b] = ` because you're the latest PHP 7 pro now? Done deal. - and probably many many more things I forgot about And of course there is: debugging. I mainly use it with xdebug, works like a charm. Setting breakpoints, conditions, run to cursor, watches, just everything you need from a debugger is there. Especially the bigger the projects get, as I already mentioned somewhere else, printf/var_dump mentality only gets you so far. Debugging is here for the hard cases and it's awesome. There are surely things not covered out of the box: - Birds eye view of your source file? Plugin for that: https://plugins.jetbrains.com/plugin/7275-codeglance - Better support for `composer.json`? Plugin - Want basic VIM support? Plugin. This one actually works well but surely you can't do advanced things like scripting. But once I realized that with the plugin I have also two regular copy/paste buffers, one for CMD-C/V the other with the vim commands yank/paste , this can be king - Your team uses EditorConf for the basic formatting? Plugin. If you now think "but I don't need all of this". Well, maybe you simply don't. No one is forcing you. But IMHO it's good to **truly** understand what is possible. But if you are able to master these things, Working/Navigating your code becomes so natural that, at least I feel so, I can more concentrate on the problems itself above anything else. Of course a great developer really doesn't need all these fancy things to be great. And I don't consider myself "great" in that sense. But I wouldn't say I'm a stupid fuck having no idea about nothing either. I like programming. I like to be efficient. I like to be valuable to my team, to my employer. That's why I like using PhpStorm. 
 [barryvdh/laravel-ide-helper](https://github.com/barryvdh/laravel-ide-helper) &gt; *Description*: Laravel IDE Helper &gt; *Stars*: 5091 &gt; *Forks*: 573 &gt; [Issues](https://github.com/barryvdh/laravel-ide-helper/issues) | [Pull Requests](https://github.com/barryvdh/laravel-ide-helper/pulls) *** ^(This is Earth radio, and now here's human music ‚ô´) ^[Source](https://github.com/anaskhan96/github-stats-bot) ^| ^[PMme](https://np.reddit.com/message/compose?to=github-stats-bot)
&gt; I see that now the autowiring and autoconfiguring concepts are becoming more and more popular (and from what I have seen, in the documentation they are treated as a better practice?). Better practice? That won't last for long. We always lag the Java community by a few years, so now as autowiring is becoming hot in PHP, the Java community that has been burned by the resulting dependency spaghetti are calling it an anti-pattern. It's a very tiresome cycle: "best silver bullet ever!" and then "worst anti-pattern ever!". I'm not saying "don't use autowiring at all" (although I don't), but stay conservative and **never ever** allow your code to be **dictated** by the autowiring features. Never change how you design an object **because of autowiring**. And I'm afraid this is easier said than done, the temptation is great and almost imperceptible over time. Read more about the dangers of autowiring [here](https://www.reddit.com/r/PHP/comments/6mx206/standalone_autowiring_di_container/dk584am/) and [here](https://www.reddit.com/r/PHP/comments/6mx206/standalone_autowiring_di_container/dk5qjq9/).
In larger applications it's highly important to do proper decomposition which impossible without constant refactoring process. You need to be able to refactor things more often, moveout dependencies and rearrange code. I found that when developers do not rely on autowiring, they do all this things alot rarely since in this case maintenance of all this configurations takes too much time. As for "control" part, there are another problem - with autowiring your container should provide useful information of what dependencies project is used. If your container do all this magic in runtime - yes, you could be in trouble. But in case of symfony - container is compiled. So you always could debug whole dependency graph using `debug:container` command. Moreover, I think that in complex applications with lots of configs, even without autowiring, this command allows you to check dependencies in most effective ways. So with tools like "debug:container" there are no lack of control. You just need to to get used to it. 
&gt; What do you mean by large scale? If you are planning to implement this project alone within a year - this is pretty much small scale. 
&gt; In larger applications it's highly important to do proper decomposition which impossible without constant refactoring process. You need to be able to refactor things more often, moveout dependencies and rearrange code. I found that when developers do not rely on autowiring, they do all this things alot rarely since in this case maintenance of all this configurations takes too much time. That's a suspicious statement. You extract a class and you then may pass an instance of it in the factory for the object you moved it out of. 99% of the work is in extracting the class, not the *single line of code* that you need to change in the factory. &gt; So with tools like "debug:container" there are no lack of control. You just need to to get used to it. Control implies you can control things, not just look at them. Autowiring places great constraints on the kind of dependencies you can distribute around your application, because: 1. You no longer feel pressure to organize your project as a hierarchy of modules and components. It can grow infinitely, but stay flat and autowired. The resulting (lack of) structure and "everything depends on everything" interdependence highly resembles code which is built around global variables and/or classic static registries/singletons, and shares many of the same drawbacks. 2. In the resulting flat autowired setup, having two instances of anything means writing potentially hundreds of factories manually so half the objects can get one instance, the other half - another. So you start treating everything as a "singleton" and in the exception cases you use qualifiers and tag types. Both practices further devolve your project and remove control, and reusability of code. When autowiring controls how you architect your project by distorting the incentives for proper maintenance and encouraging a big-ball-of-mud structure, that's not you having control. The container controls you.
This seems like a pretty good metric to go by.
You mean 7.0?
Is it just me, or the react/amphp documentation nowhere to find?
[removed]
No, I mean 7.1, 7.0 is not practical for strict typing since it lacks essential things like nullable types and the void return statement.
I like it, because besides providing the advantage of auto-wiring, i.e. simplicity, it: - has minimal side effects or rather you can limit them. For example if you don't want to auto-wire everything, you can just limit the services to which it applies. And the service discovery is the same: you can limit the scope as well. - it's still easy to debug: unlike in a framework like Laravel, if you want to see how your service is wired it's trivial to do, just look at the dumped mapping, autowired or not everything is there - it has no performance impact Also you can apply it only where it simplifies things and go back to a stricter way to define your services where you want to.
Speaking the hard truth right here. My work environment is only up to 7.0, not 7 .1 They are not upgrading in the foreseeable future...
Phoenix Light: Ace Attorney
it's not windows specific :) I've not set up a VM in a while- should I go for virtualbox, docker, or try out that ubuntu subsystem for windows stuff ?
I'm rewriting an application currently. It was written by one guy in an astonishingly short amount of time and you can follow his progression through learning PHP in the codebase. There are a few classes, poorly conceptualised. No unit tests. No templating engine. The page is usually rendered out in echos at the bottom of the file. We've redesigned the database structure and modified the codebase to use it. But it was hard not to get lost in the mud of trying to refactor things. For example, there are multiple pages that do almost exactly the same thing with some differences. Refactoring them into one will take some time and then you introduce a potential for new bugs unless you understand exactly what those differences were and account for them. My usual process as I work through each file is this (Note: code folding of functions is turned on): * Open file (PHPStorm is set to remove trailing whitespace and convert tabs to spaces on file open) * Ctrl+Alt+L (Reformat code in PHPStorm) * Remove old commented out code and comments that add no value * Right click file -&gt; Inspect code with PHP inspections. This will often highlight architectural issues, unused code and some sweet refactors I didn't know about. * Fix as many of the errors as possible * Read through file figure out the flow * Work through queries, var dump SQL statement and pin results then write new query that returns the same result. * Test page to make sure it looks alright. I've been pushing to test what we've done so far in an organised manner, but so far that's gone unheeded. Experience tells me this will mean there are bugs (Potentially showstoppers) in the system.
Keep it simple - virtual box.
&gt; &lt;?php echo $this-&gt;$attribute; ?&gt; You can use Twig for this. {{ this.attribute }}
TBH you are the only person who asked for more information. My hostility was towards a comment which was already hostile in itself. You are right, I am not going to rebuild anything as this is overwhelming and they simply can't afford the time it would take. Simply converting all of their data to a process structure would be unimaginable frustrating. However, I would like you hear you out, as the experience I have had with PHP frameworks has shown they don't make the build too much easier if there are too many different parts. The only experience I have is on some pretty basic websites with no complicated processes. I'll try provide some information regarding how this particular site works, but downsized and in a different context to hopefully make it easier to understand. The site has around 10 different user types, where a small portion are administrators. It is designed to group users and allow them to log all of their interactions. Users are grouped based on some information they have already provided, for example meals they'd like to eat. The site would group users who like the same meals, then allow them to log lunch meetings etc. Here is an example of a few forms which might exist, considering Adam, user type A and Greg user type B have been matched: Adding meetings: A form loads which shows the other person involved in the meeting, their common interests and free time. While querying for this information, the system also checks whether the two users have been matched together, if not they can't use the form yet. Adam wants to add a meeting, he is type A, so no problem, he is sent to a form, some logic is done to build it and he is given some specific options to his user type, compare to Gregs user type. This type of action is flagged as, say, MEET1. Greg wants to add a meeting, but he is type B, his meeting must first be confirmed by his manager before it is considered live. He is sent to the same form as Adam, but the logic builds a slightly different form. This type of actionis flagged as, say, MEET2. The form is built by querying a database for particular options for the different action types. This particular aspect of the site is already kind of generalized in the sense that it is the only form that requires the user to enter a data/time and run specific client and serverside functions to validate the form, and whether the meeting can be logged between the two users. Type A users can action MEET1 but type B cannot, and vice versa, so when the form is submitted this needs to be assured also. The form itself is also setup with a check to ensure that Type A loaded the MEET1 form, but it is double checked on form submission server side. There is 1 file which deals with the entire process, with some simple logic checks at the beginning to define some variables for the sql statements below. Confirming / Cancelling meetings: It is the job of Type B users to confirm what happened during the lunch meeting, what did they eat, what did they talk about. They are provided with a form that has several checkbox options, selects etc which are loaded from a database, based on the action type COMF1, say. Before the form loads, the system must check whether the match exists, the meeting exists as is in the correct status, and that the user accessing the form is type B, while doing so it also gathers the information about the meeting, time/date/other person involved. This form also deals with cancellation, but awaits confirmation from type B's manager. This is dealt with in another system, but once approved the meeting state might change to CANC1, for example. Admin editing meetings: Admin members can edit any of the above information about a meeting. They get another form which gives them the ability to edit the times and the meeting information, so a combination of both of the above forms. In this case when the page loads, all of the details in the form are autofilled with the details stored in the database. Before accessing the form, the system checks if the user is a admin member, that the match between the two users who met is active, that the meeting exists and that the meeting is in an editable state. On submitting the form, the system must also check that if the admin member has changed the state of the meeting, that it is allowed, considering what user type created the meeting. Between any two user types, there is a different set of meeting types which all have different meanings here and in different systems. The same files are used to deal with add different meeting types, the forms are just built based off the database. Meeting states can be changed, they just need to be consistent with the set of users who are involved. There is a large number of permutations of different user arrangement, but these few files deal with it all, but they're still separate files which depend on separate queries, each checking different, kind of specific states of the user / match / meeting before allowing users to view / submit forms. On top these there are, Type A requesting to cancel match between Type B, etc. Vice versa ^ Type A requesting to change match to someone else, etc. Requesting to remove match and remove food preference, setting food preference status to a specific code so this process of removal is logged. Requesting manager to be allow user to have a particular food preference etc etc etc etc etc, where each of the forms has different options, shows the user different information with different icons and layouts. Most forms are built with queries, but in some cases different users need to see different information about the match, meeting etc, so logic is used to iterate between what information the user should see. This is also pretty generalized in the queries themselves, but there are a few booleans used to toggle buttons, statements etc. The last layer I'll mention before I stop is the manager perspective. Manager's have a user type M, say, and have the ability for view, edit and add matches, meetings, users, etc. In some cases this refers the manager to one of the above forms, but logic allows the manager to see extra buttons etc, in other cases specific forms have been created as extra information is gathered from the managers about their requests. There is also the request system, where managers can approve requests. Here the system must load all relevant information about a user request while checking if it is valid, and must also action the requests and store information about the action made, storing information provided by the manager. This is probably the killer of the website as it has heaps of different possible requests, some of them are generalized into individual files, but due to the different nature of different requests, most are separate. Each requests needs to make sure a particular set of status codes are correct before viewing and actioning request. Requests aren't necessarily changes to individual status codes, they could correspond to massive changes in the system. There are heaps of different arrangements of different status codes, which all need to be logged for reporting. The next level is that each meeting depends on the status of the 'food preference' and there is another set of actions which can be made on those by users. Now if you replace "matches','meetings' and 'food' a few times, to represent different systems which rely on the same actions based tables mentioned above as well as other tables that store information these different systems (that have different data architecture), it's kind of similar. Sorry if it's tough to read, but it took me ages to write this haha. I appreciate you reading it and answering :) 
&gt; Right click file -&gt; Inspect code with PHP inspections. This will often highlight architectural issues, unused code and some sweet refactors I didn't know about. Oh, PHP Storm does that? Is it reliable? Can you describe this feature in more detail, especially the bit about architectural issues?
One day you'll realise being able to configure a Linux stack to run php is actually part of job description. You're doing yourself no favours with your gui centric mindset. 
I go with DO atm and think they are way more simple then AWS atleast for simple web server vps setup 
Depends on your experience with design patterns, if you know how MVC works, Dependency Injection, ORM ect. ect. then it's quite easy to jump into Laravel or Symfony. Otherwise I would suggest to built it from scratch to get a grasp of the language. Get familiair with how PHP does things like sessions, post data, get data, cookies. The stuff that's normally handled for you in frameworks.
I don't object to the *idea* of a language that transpiles to PHP, but... ...I'm not really seeing the advantages to this one &gt; .. is used to concatenate strings. . is used to access class members. If you're familiar with PHP and just looking for a way to do it more efficiently or extra features, this is needless change for the sake of change. If you're *not* familiar with PHP, you're never going to be using something like Phoenix. It seems almost designed to be a feature that benefits no one. And the rest of the changes seem to be similar, eg, renaming constructors, changing the function keyword, making `this` implicit. Too many minor changes seemingly for the sake of change; not enough major changes or things to fix actual shortcomings of PHP. &gt; More concise and readable syntax than standard PHP. Not in my view. But it's still a good idea. Maybe look at a python inspired syntax instead?
`&lt;?= $this-&gt;attribute ?&gt;`
That's it! [Here's](https://github.com/daveh/php-mvc) a pretty good MVC skeleton application. After reading through some MVC tutorials I suggest clicking around that code to get a better idea
I mean I look at PHP code on a weekly/daily basis and sometimes it's pretty easy to figure out. PHP developers need to step their game and create clean, well designed code. I've had devs that think PHP is terrible from working with Wordpress or PHP4 style for years, then changed languages because it left a bad taste in their mouths. Once they see something that's maintainable, well thought out and with nothing hacky, it makes them enjoy it more. Do you really want to work in code bases where devs are like: &gt; Push to production and let the end-user figure it out! Fuck writing tests! &gt; Why exactly are global functions a bad thing?
You can do it shorter than the above PHP example without Twig too, like what /u/Nicd has shown. E: I wish people would explain their downvotes sometimes... It's not like i'm lying! I know Twig will also escape the variables too, whereas echoing from PHP of course does not; but given the original comment is talking about the verbosity of PHP, this point still stands.
Hello CoffeeScript my old friend I've come to talk with you again Because a vision softly creeping Left its seeds while I was sleeping...
Not just a PHP problem: https://www.reddit.com/r/badcode/
As someone from the "non-anglosphere", that's bull. We write all identifiers, comments and documentation in English. A programmer who doesn't know English well is almost certainly not a very programmer, as they're cut away from all the good and up-to-date sources of knowledge, education, cooperation. Such a programmer is unhireable in any company that knows what its doing here. English is the language of international communication and the language of technology, for good or bad. Can't say the same about random bits of Hebrew dropped around PHP. Then again, of course, a half-decent programmer knows how to copy an error code and Google it. So it doesn't matter.
Not exactly. The worst case is that you end up with a hybrid approach with some auto wire and some manual wire. Which causes severe maintenance issues as you try to figure out what exactly is being used where and why. One or the the other but not both please.
Entirely why I'm writing https://gum.co/async-php-early-access
[removed]
Not really an answer here, but... My gut feeling is that you're going to have some friction between your ideal business model versus what off-the-shelf tech makes it possible to achieve. Monitoring usage (and then using the results of that monitoring to charge more or to cut-off access) is probably easier than throttling. Really exceptional amounts of usage or slow queries can also be worth reporting to a human. Counting database queries or accesses is probably much easier than accurately counting CPU usage. (And less likely to exhibit interference effects between different customers on the same nodes.) So purely as a matter of office-politics, I would make contingency plans for going back to someone and suggesting a different style or mechanism for limiting free users. Just in case the ideal solution turns out to require a huge custom development effort or a switch to a different database system. 
Let's be clear about two things: 1. Most popular doesn't mean the best, easiest, or most secure, so beware. 2. This is something you can find via Google: https://w3techs.com/technologies/overview/content_management/all
Why? It's just a traditional if-elseif-else chain.
&gt; A hard limit on database records for free accounts (like 10,000 db records or so). This will still allow entering hundreds of products and a couple thousand invoices in total. Cons: We worry might be perceived as a negative and keep some users away from using our platform. Yes, when people have to pay for things, you'll have fewer people. You will also have income, which is an essential part of running a business. You need to place limits that are somewhat annoying, or else why would anyone upgrade?
&gt; Since they are all part of the same application I'd prefer not to use a message broker for inter-module communication since it can add too much overhead and instead have some modules just depend on each other at the infrastructure layer at runtime. This is a code smell. It's how you end up with tightly-couple monoliths that are impossible to refactor, and difficult to understand. My approach to this problem would be to use task queues and workers. Either emit _everything_ to the task queue, and have workers pick it up asynchronously, or just catch failures, and then emit a job to the task queue so you can pick off that queue and retry failures later. Once you have a dedicated queue for failures, it's much easier to reason about retrying them, and recording permanent failures in such a way that you can analyze them. 
A note about Magento though, it is not very user friendly if you don't have experience with these kind of things. Magento serves really good as a commercial e-commerce site but is probably overkill for small shops, especially if you have a limited budget and/or no development staff to help
If they are happy to pay for the work and don't want to challenge the status quo, then that's their decision. If they want to pay you to dig the hole you need only ask "how deep" Sure properly parameterizing queries in a rats nest is going to be time consuming, but either do it right or don't bother IMO. (PDO isn't going to be the magic fix to string concatenation vulnerabilities) Refactoring is your best bet, as over time maybe you can dig yourself out of the hole that is likely the result of years of bad decisions. Will a framework solve your problem? Nope. Does it solve *this* type of problem? you bet. A Framework typically includes ways of handling CRUD including safely addressing sql injection, organization of code, avoiding duplication of code etc. but a framework cant fix an exiting website that is the result of some systemic problem. I probably deleted enough of my response to make 4 different responses, but there is no magic bullet for the mess you describe. If its a corporate job beware job stability IMO. It its a client and you are freelancing as long as they keep paying the bills its their funeral.
This seems like a lot of abstraction. What is the benefit this provides for a small, single-person project?
Make sure to sanitize the data you put in your database. If possible, use pdo http://php.net/manual/en/book.pdo.php http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers Sorry about formatting, I'm on mobile 
Only if it's already properly escaped though. 
Sure it's a lot to take in right now, but if it's a solo project why not take the time to learn? Find a lightweight framework and start learning the nuisances, it can't hurt.
Because it's much more difficult to read for the same effect.
This is what a command bus is for. your listener accepts an event then transforms it into a command which goes to your command bus, which you can make resilient by using an external job/message queue system [RabbitMQ, Aws SQS ... etc]
PHP is not hard to understand..software architecture is..designing an application is not about the knowledge of PHP but more of the ecosystem, concepts, design patterns, approaches etc. most of the complex parts of creating an application will not be PHP related
Yep :) In Phoenix, this would be written "&lt;% .attribute %&gt;" (or "&lt;# .attribute #&gt;" if you escape it), so indeed no big win over PHP, apart from the removal of the "$this-&gt;".
&gt; everyone is talking about Magento Another note about magento: They're all saying it's shit. http://sylius.org/ looks like it could be good but it's still in beta so it doesn't have many ready-made plugins yet.
Pretty much anything anybody makes the first time will be ugly and potentially dangerous. Don't feel bad, don't feel guilty, just make sure that you take it down later and make a note to figure out what made it ugly or dangerous for future growth.
I'm always a little bit aghast when I come across a stack-overflow question where the author seems to think that the PHP execution is interleaved somehow with what the user sees in their browser. Bonus points if they throw JavaScript into the mix as well.
I thought for a second is Phoenix the Elixir Web Framework
If you want an example of something I think is unequivocally a PHP dumb decision, consider what happens with hexadecimal values that can be interpreted as exponential notation. "0E53" == "00E7" Yes, that's not using strict equality, but only someone steeped in PHP insanities would ever expect that to result in two floats with a value of 0 being compared against one another. I've literally never seen any code where somebody wanted and relied upon the something-E-something string magic. 
if you switch the square brackets to the member fields `address[street]` &amp; `address[city]` instead of the field you'll get a hierarchy in the `$_POST` array. It can be useful if you define a static method for constructing objects from arrays with specific structures. Of course other ways are also possible, including sending a JSON body with the POST and working with that instead of bizarrely named forms.
PHP is a framework too you know.
Phoenix's initial goal was to bring to PHP the leaner and more conventional syntax we use in the other C-like web development languages. In practice, removing all the useless "$" and "$this-&gt;", replacing "-&gt;" by ".", and shortening the tags was almost enough. So indeed, nothing new under the sun, just a few cosmetic changes to make PHP look more like Go, Dart, etc. At the moment, I'm probably the only "professional" user of Phoenix and as you guess I enjoy it a lot, but I admit that many people will feel that it doesn't bring enough on the table to be worth trying.
Too simple a question. What do you want to do, hang out with it because it is popular? That is a good way to get married to shitty software. How many products? Scope? Budget? Time? Labor? 
In a way, D and Phoenix probably suffer from the same problem. They bring seemingly minor improvements over their predecessor (C++ for D), which individually look like small details, but added together still give a better programming experience. But this is rarely enough to convince people to give it a try...
I think that PHP7 only supports types for function signatures, if I remember well.
Does this mean you only have client-side validation, or that you catch and respond to HTTP responses in-case of error and only return AJAX compatible responses? I think having a HTTP form is not a terrible idea if you are using middleware that can gather state from a number of inputs (multipart-form and JSON would probably be a good starting point). Otherwise your app won't work for non-JS browsers or clients
Keep customer data in an isolated SQLite dB and limit the size of the SQLite database to a specific MB.
The year should have nothing to do with AJAX, which should always be an enhancement. Whatever year you are in, learning how to make an MVP and iterating to progressively enhance is always going to be better long-term.
Use [utf8mb4](https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html) as the character set, and check that the string contains valid utf8 chars, maybe with http://php.net/manual/en/function.mb-check-encoding.php
&gt; You extract a class and you then may pass an instance of it in the factory for the object you moved it out of. Or I could just place it in constructor without any need to write factory. &gt; because I fully agree on this problems, but I don't see how manual dependency configuration could help with that. Unit tests will add limitations on this much more effective. But yes, in some cases this simplicity allows to add new unnesesery dependencies that [could be eliminated](http://qualityisspeed.blogspot.com.by/2014/09/beyond-solid-dependency-elimination.html). But this is more about discipline rather than tools. If you understand how to structure your code, and you apply some rules, then autowiring will not be the problem. Also it's not required, you still could have manual dependency management.
&gt; Make sure to sanitize the data you put in your database. That sounds like bad advice. Why do you think anything needs to be sanitized before storing in a database. Sanitizing on output is fine...but what sanitizing needs to be done, needs to be dependent on where the output is.
Just wondering, why not? It seems a lot more straightforward than trying to limit a user based on the existing rows they are using, and way more forgiving than throttling users. 
Agreed. The only time you should need sanitization is if you can't use prepared placeholders (eg table names) or you're placeholding a like operation.
&gt; Or I could just place it in constructor without any need to write factory. If the object is used in the project, there's already a place of construction, so you don't have to write a new factory, merely edit the existing one. &gt; I fully agree on this problems, but I don't see how manual dependency configuration could help with that. Unit tests will add limitations on this much more effective. Unit tests can't test any of the two problems I mentioned. It's not a unit problem, and it's not a problem an automated test can detect. It needs the eye of architect, and they tend to not like autowiring. Manual construction helps because, as I said, it makes bad things painful and good things pleasant. Bad things like a flat highly interconnected structure of pseudo-singletons hurts. Hierarchical organization with loosely coupled, reusable components is pleasant. Autowiring does exactly the opposite: it encourages bad practices. &gt; But this is more about discipline rather than tools. If you understand how to structure your code, and you apply some rules, then autowiring will not be the problem. The issue isn't just discipline. If you structure your project correctly you literally can't use autowiring anymore. I.e. I instantiate a module that is given about 20 dependencies and it distributes them conditionally to its subordinates. How do you do this with autowiring, and lazily, so not all dependencies are eagerly created (which is especially bad for PHP in terms of performance)? You can't. But with "manual" DI, it's just business as usual. Autowiring is just a `Registry::get('thing')` in disguise. 
Well my main concern was sql injection, a mistake that many first time devs make, which is why I also suggested using pdo. He did mention it was his first time, so more than likely he hasn't been exposed to the world of security vulnerabilities. Rather than saying my advice was bad (it's not) maybe you could have contributed by saying something like "the best way to do this is to use prepared statements" or something along that line. 
&gt; Does this mean you only have client-side validation, Validation happens on the server, and it returns success, or a list of errors, which are then displayed by the JS side. &gt; or that you catch and respond to HTTP responses in-case of error and only return AJAX compatible responses? Not sure what you mean here, but maybe what I said? If so, yes :-) &gt; I think having a HTTP form is not a terrible idea if you are using middleware that can gather state from a number of inputs (multipart-form and JSON would probably be a good starting point). My request object supports urlencoded, multipart and JSON, yes. &gt; Otherwise your app won't work for non-JS browsers or clients Well, urlencoded, multipart and JSON are pretty universal formats. Just those three cover just about anything you may want (including mobile and desktop apps, and third party API clients). As for non-JS browsers, what's what? First time I hear about it. Is it truth or legend? /s
Most of these obfuscation tools are easily deobfuscated. My advice is don‚Äôt. It will affect performance and if I want to run your application, I‚Äôm sure as hell not going to install an extension which could introduce a plethora of security vulnerabilities.
I would say look into [EZ Publish](https://ez.no/) I have used it on a few sites and it works well for e-commerce and with their publication suite, you can work on SEO and customer engagement for your site. Another tip, stay the fuck away from [oro](https://www.orocrm.com/) I have made the mistake of using it, Always regretted it and will never use it again. I don't understand why it's a thing, it's utterly terrible. Fast and works well, But horrible to develop for, complete fucking headache. I wish the people who made it would DIE! Another tip, don't go for whats popular, that changes alot. Go by what works for your project. and if that means writing the who site from scratch, do it.
We did look into that, and we can't find anything that claims to be able to decode the latest ionCube 9 and sourceGuardian 11. Dezender and other tools claim to only do upto ioncube 8 and sourceguardian 9 (upto php5.6, ours is code php 7.0+) and deioncube claims to only upto ionCube 8 php5.5. We are wanting to protect the source because it is a niche product and dont want people stealing the code and claiming it's theirs etc. As for extension wise, our product is built with phalcon, so extensions is a requirement.
Can you automatically queue those CPU and memory intensive requests and email the free users when your system have decided and done processing them. I can see this as somewhat annoying because the paid users get more priority. The free user can pay for priority processing. You can also provide better graphs reporting for paid users.
Support is extended till at least 2020 (confirmed by Magento CTO). Magento development does cost a lot of time (money) but is very customizable and has a very big community. Last but not least, it is not crappy, Magento 1.x is a bit old-school but 2.x is using modern techniques and has documentation which gets improved every day.
To be honest, you're not going to be able to protect it, really. If someone wants to replicate the idea, they quite easily can. Maybe not the pure logic in your system, but an idea can easily be reimplemented. I'm not even sure if a software patent can really be applicable here.
I did a sort of freemium model once. Weird thing is that nearly every single one of my negative reviews from someone who used it for free. They also consumed over 90% of my resources. Once I kicked them all off things went a lot better. So be careful.
That would require me assuming why you were suggesting using sanitization. So instead I asked. &gt; which is why I also suggested using pdo. You probably ought to be explicit about prepared statements. You can use PDO and still not used prepared statements. Also, MySQLi has prepared statements too. 
They should either just bite the bullet and do a php namespace with these functions in a unified order. \php\String::htmlspecialchars It really wouldn't take a great deal for Jetbrains to then come along and do a one-click re-write to upgrade. Or extend the string to expose them as properly ordered methods e.g. "&lt;div&gt;&lt;/div&gt;".escape(), "hello".replace("llo", "llollollo"); 
You didn't ask questions, you made statements. Also, the tutorial I linked explains prepared statements and how to use them. Finally, more important than me specifically mentioning using prepared statements for sanitization, you said that you shouldn't use sanitization which is even worse advice.
If you are so worried people will steal your code, why not run as a SaaS? 
That's not true. I've seen Taylor step in in this very subreddit to argue that Laravel is great for large and scaling projects, citing numerous examples to back it up.
To answer your question, I would simply use git. Your local could be **origin** and your server **upstream**. Changes would be made locally and then you would push to your server. However, I would do things differently. My approach to this would be to use [SNMP](https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol), so that S.M.A.R.T. and other hardware information could be [shared](https://serverfault.com/questions/48535/is-there-a-way-to-share-s-m-a-r-t-data-over-snmp). Also, PHP seems to have SNMP [support](http://php.net/manual/en/ref.snmp.php).
WordPress / WooCommerce. It's pretty turn-key, by far the easiest I've ever used (and I've been building ecommerce sites since 1998). But it comes with all the usual risks and caveats of any WordPress site.
Wow didn't know about snmp, have to look into that. thanks
That's a great Idea.
&gt; You didn't ask questions "Why do you think anything needs to be sanitized before storing in a database" &gt; you said that you shouldn't use sanitization which is even worse advice. "Sanitizing on output is fine...but what sanitizing needs to be done, needs to be dependent on where the output is." Yes. That is exactly the same as not using sanitization.
Prepared statements isn't sanitization. U/Danack *is* suggesting not sanitizing before inserting into the database and that *is* correct. You don't want to mangle the input because you'll never be able to undo that. You *do* want to escape it depending on the context you are outputting the value in, which is maybe in an HTML document one day, a text file the next, and an email at some point. Strategies for escaping input depend on context.
&gt; we can't find anything that claims to be able to decode the latest ionCube 9 and sourceGuardian 11. The reason for that is: the people who are capable of doing this with ease typically lack the incentives to publish a decoding tool for people to use, especially if doing so would open them to lawsuits. You cannot invent an algorithm that allows my computer to decrypt something while simultaneously preventing my computer from decrypting something.
&gt; Unit tests can't test any of the two problems I mentioned. Unit tests are design tools in the first place. They are very handy to track problems with dependencies. &gt; Manual construction helps because, as I said, it makes bad things painful and good things pleasant. With unit tests you will also have ability to fill pain for bad things since you are manually construct your test code with one level dependencies, just like in case of manual wiring of your dependencies. &gt; Hierarchical organization with loosely coupled, reusable components is pleasant. Could you put more details on this? What do you mean by "hierarchical organization"? &gt; You can't. You mean "I can't use autowiring in 100% of my usecases"? Then yes, it will be just stupid to rely on something which helps with simple cases. But within single module most of the cases are really simple. &gt; Autowiring is just a Registry::get('thing') in disguise. This is way oversimplified. You always could make something "bad" if you want it so.
No surprise they failed building on top of that.
Sylius was already in beta 4 years ago when I was looking for a solution. It's promising, but unless you have the skills and the time, I wouldn't recommend using a beta software in production, if only for the possible BC breaks that may happen.
I'm sorry but I don't have any issue using mobile both on web view or using Medium app: you should contact Medium and report the issue, specifying the reference of your smartphone.
All these other guys suggest more highly regarded solutions, but as far as getting things done, finding developers to help, plugin availability, community support, etc, you can't really beat the platform that more than a quarter of all websites use. 
What the fuck do you want me to do web sockets in? PHP? Lol.
I agree bad code can be written in any language, but the easy access to PHP and the minimal programming knowledge required to start writing code, coupled with some horrible tutorials is the recipe for bad code. 
Having said that, well done OP for asking for advice. To summarise the rest of this thread: &gt; Trust nothing received from a user This is doubly true when you're going to be taking inputs from a user and creating SQL with it. Assume everything is malicious, and assume your JavaScript and HTML has been bypassed.
Totally. You do have to commit to doing upgrades SUPER frequently, which, for peace of mind's sake, requires a staging instance.
Magento is a really popular solution, but I can't recommend it. It's outdated, bloated, and buggy.
Probably this: https://github.com/barryvdh/laravel-ide-helper There's also a real plugin for PhpStorm just called "Laravel Plugin"
Anyone have any good suggestions for architecture / design patterns regarding draftable user submitted content? Specifically, should drafts be stored in the db, stored as session vars, cookie vars, passed via form post vars, etc. before they become published?
ty bro 
What are you not understanding? What is missing? How are you currently organizing your data? 
I currently have no data
It would be helpful to post some code where you are working with data so we can see how you are doing things. Array / lists / collections are a pretty fundamental concept.
If you ever find yourself writing code like this $my_stuff_1 = 3; $my_stuff_2 = 4; $my_stuff_3 = 3443256; ... and then realise you're going insane trying to declare 100 variables to fit all the 100 things you want to store ... or realise that you can't predict beforehand how many variables you're going to need once the script is running ... then you want an array. Also loops go together with arrays really nicely. Read about the `foreach` loop.
Well this puts things in perspective . I'll slack on the array chapter of my book
Well there you go. You don't have any data to put in, so why would you be worried about where to put it? When you need one, you'll get it. :)
It was just another chapter I read it but I'm rereading
Arrays are fantastic for looping on data. Also, in representing hierachy's of data.
And when you start pulling data out of a database. Think of your email inbox. Each email has an id (so you know which email it is). And there's a subject. And you know if it has attachments or not. With an array, you can grab that out of the database, and show these emails to someone. $email = "Select id, subject, attachmentcount from emails where ownerid = $me LIMIT 30"; So we've got the last 30 emails for this person. But we need to show them. foreach ($emailquery as $row){ echo '&lt;a href="openmail.php/id/'.$row-&gt;id.'"&gt;'.$row-&gt;subject.'&lt;/a&gt;'; echo "&lt;br&gt;"; } That will loop through all 30 emails (or 12 if there's only 12) and create a line of text with a link to the page that opens the email. The best way to think of arrays is like a box of stuff. You put things in it that go together. And when your program is doing something, you just hand it the box. 
But how would you log into an email with php?
Definitely store it in the DB, but not the same one. I prefer to make calls to a table of drafts and then move that to an articles table to put the data in. Otherwise use the same table, and use a column to identify if it's published or not. Getting Ajax to make calls to store data isn't hard to code, and then you know you've got the data. Rather than using sessions or cookies, fudging forms etc. Those paths can screw up if people use ad block, refresh pages constantly etc.
Think about what email is. If you're going to be coding, you have to break things apart. Email is just a format for sending data from one computer to another. The format is used so people know what to send, and how to understand what they receive. For your Gmail account? Google receives the email and stores it in the database. When you log in? Google checks the username and password you supply against their database. Is this really you? If it is, great lets show the inbox. The inbox page loads and it checks the session "Who's email am I getting?" It checks the info in your session (or a cookie) against what it knows. "You say you are you, but do you know the secret ID from this other table?" And once it's sure of who you are, it pulls the emails out of the database and shows them on the screen. Your email was only an "email" as it travelled from who sent it, to here. Once it arrives, it became a bunch of data in the database.
That‚Äôs beside the point. However, https://secure.php.net/manual/en/ref.imap.php
I learned best by having a goal of what I wanted to code and finding out how to do it. A book is a good reference, but it won‚Äôt teach you much by itself. At least it doesn‚Äôt for me.
Thelia seems like it's a fantastic Symfony friendly version of this 
If you continue programming, you'll soon begin dealing with more data, often from a database of some sort. I usually find that the easiest way to illustrate how important arrays are is to discuss them in the context of database data. So, let's say you're writing a script that retrieves a list of users from the database, and then you're going to put them all in a nice html table so that an administrator can add/edit/delete users. You could, conceivably, run a series of queries for every column of every row. For example (in pseudo code): $id = $db-&gt;User-&gt;field('id'); $firstName = $db-&gt;User-&gt;field('first_name'); $lastName = $db-&gt;User-&gt;field('last_name'); You'd have to do that for every user in the database, which would of course be crazy. What actually happens when you pull data from a database is that you get a resulting array (or object, depending on your ORM setup). So now you have an array that looks something like this: Array ( [0] =&gt; Array ( [id] =&gt; 1 [first_name] =&gt; John [last_name] =&gt; Smith ) [1] =&gt; Array ( [id] =&gt; 2 [first_name] =&gt; Jane [last_name] =&gt; Black ) ) So now you can loop through your user data and put it in table rows: &lt;?php foreach ($users as $user): ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $user['first_name']; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user['last_name']; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="?edit=&lt;?php echo $user['id']; ?&gt;"&gt;Edit User&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach ?&gt; Arrays might be difficult to conceptualize right now at the beginning of your learning, but the truth is that even without examples from commenters here, you'll soon find out how important they are on your own. You just can't build meaningful apps without arrays and objects. Collections, lists ‚Äì whatever they're called in any given language ‚Äì are very important and useful. You just need to code a little more and you'll figure it out, I promise.
I would keep it in the same table with a published timestamp unless you want versioning. If you want versioning I would store it in a separate table and then use a version pk to link to the current good version in addition to a published field.
General advice, especially for PHP. If you don't understand a concept, do it anyways. You'll figure out why we do certain things, or why a thing exists after seeing all the places it is used. PHP is so convention oriented you need to see what prompted the convention before understanding it sometimes.
What‚Äôs wrong with SFTP? That‚Äôs what I‚Äôd use.
Foreach order is pretty fine in PHP. 
&gt; Unit tests are design tools in the first place. They are very handy to track problems with dependencies. This is so vague... :) The problem with dependencies I mentioned occurs between units, not at the unit level. Unit testing isn't magic, it can't fix problems it can't possibly describe or detect. &gt; With unit tests you will also have ability to fill pain for bad things since you are manually construct your test code with one level dependencies, just like in case of manual wiring of your dependencies. The problem isn't at the unit. Is there a problem to unit test this: function showUser($id) { global $db; var_dump($db-&gt;select($id)); } No. You can just overwrite $GLOBALS['db'] to anything and test it. No problem with dependencies, yes? /s This is the same excuse Laravel uses to push static singleton proxies to people (i.e. their "Facades"). Taylor says "it's ok, because you can change it and unit tests it". The fact you can test something is a good sign, but it doesn't automatically mean everything is all right with your architecture. Unit testing isn't a silver bullet. In this case, code reuse and dependency flow control is the problem, and this is only visible once you start combining units together, a thing unit testing doesn't do by definition. &gt; Could you put more details on this? What do you mean by "hierarchical organization"? Check my other comment in this thread. It links to another thread where I go at length about these topics. It's a very simple concept though: cohesive classes that form a unit should stand together. And this is true recursively. A group of cohesive low-level units that form a high-level unit should stand together. And we keep going higher and higher level this way to keep overall complexity down, through composition and aggregation. And this is what happens in a good design. In an autowired project there's no such grouping of classes, let alone grouping of low-level units. Everything is flat and amorphous, and in such a setup, there are a number of operations that become very painful (more on this below). &gt; You mean "I can't use autowiring in 100% of my usecases"? Then yes, it will be just stupid to rely on something which helps with simple cases. But within single module most of the cases are really simple. No... that's not what I mean at all... How does this in any way reflect what I said? Or do you prefer to invent quotes and argue with a straw man :P? Autowiring has a certain path of least friction, and it's the same one you go on when you use $GLOBALS or a static registry class. With all these the problem isn't "I can't use this 100% of usecases", the problem is *the moment you need to deviate*, such as you have two instances of the same class across a large number of objects, you realize your project does not allow you to properly inject these dependencies without a major refactoring effort. At which point you give up on refactoring and start using hacks, which I already mentioned (qualifiers, tag classes and tag interfaces). Let's bring concreteness to the problem. You have a project. 100 autowired objects use `PDO $db`. Suddenly, you need 50 of those objects to use another PDO database. Now what? Let's follow the "autowiring path" and see where it leads us...
Maybe, but unfortunately it's the exact opposite of what you simply say in written/spoken English, and also of any other programming language I know, probably for the same reason. Therefore this inconsistency can easily become a trap (= bug) for each programmer (!) coming from Go, Dart, D, etc. This is especially the case for developers like me who often have to switch between two or more languages on the same day.
Thanks for taking the time to read all of that :) 
You've pointed out yourself that the encryption in older versions of the tools has been broken. This tells us that 1) there's motivation for doing it, and 2) the version you use will be broken as well in time. You aren't going to protect your codebase with these tools, you're just going to spend money reducing the performance of your product. Just like with any security system, a motivated attacker *will* get in. I would spend my money on making the product better, my support better, and accepting that some people will pirate the code. What analysis have you done on the % of your userbase that will pirate the code, and the lost sales you might see as a result of that? Does it justify the investment in installing this tool, supporting and debugging issues with it, and paying the license fee? If you've got evidence that suggests that the majority of people will pirate your code, I'd argue that there's something wrong with the product or your business model that makes people think it's not worth it. If the product is excellent, and the business model is poor, it also increases the chances that someone will put the effort in to break the encryption and give it away for free.
If you want to find out more about PHPStan, checkout this introductory post on Medium: https://medium.com/@ondrejmirtes/phpstan-2939cd0ad0e3, PHPStan's README https://github.com/phpstan/phpstan and you can also watch my talk from PHP User Group Dresden meetup: https://www.youtube.com/watch?v=majpU-_ShB0
PHPStan has also just got its counterpart in the browser, PHPStan Playground: https://phpstan.org/ You can try out features of the static analyser right in your browser with immediate results.
I find Symfony auto wiring concepts &amp; its dependency Injection component is one of the most important elements of the Symfony applications. This component allows developers to configure services in YAML, XML or PHP files and let Symfony create those services for them. Autowiring features that enable RAD in Symfony applications. Some projects and developers need this kind of development and that's why all developers using Symfony framework. 
Thanks for the effort man. Phpstan is indeed a very cool tool. Do you think that we can add a check for unused `use` statements? While they don't have any impact on the code, they can be annoying. I could implement it and send a PR but honestly I don't know where to start.
Thank you for the appreciation! Checking for unused uses is possible, but not in a performant way. I have ideas that will enable PHPStan to check this really fast and without any changes to the Rule interface. Just wait a little bit :) If you want to check out some 3rd party rules, look at https://github.com/thecodingmachine/phpstan-strict-rules.
Meanwhile, if you want to check for unused uses, look at Slevomat Coding Standard, which is another thing I made with the help of my colleagues :) https://github.com/slevomat/coding-standard
&gt; or directly connect to ‚Äúdbs‚Äù (database services) Access to the databases are on a public facing port?
It was B2B. It is unlikely they were bringing in new users because I actually saw my paid subscriptions increase immediately afterwards. I don't recall by how much though.
&gt; it can't fix problems it can't possibly describe or detect. This is what I talking about. This is it's purpose. Ability to "test" or verify is just a side effect. &gt; Everything is flat and amorphous, and in such a setup, there are a number of operations that become very painful (more on this below). I never relied on DI configuration to handle this, to me it's easier to see things like lack of cohesion in modules via other metrics. For example metrics like "do things changing together" I could retrieve from VCS history. Also things like "common" module also tells me that something went wrong. And unit tests... They are very handy at showing lack of cohesion and problems with dependencies. Since that, I don't see any problems with autowiring for myself. I understand problems you described, and yes, applied badly autowiring could be like "Registry::get()". I just don't have this problems. &gt; Autowiring has a certain path of least friction, and it's the same one you go on when you use $GLOBALS or a static registry class. No, if your container allows type mappings of local bindings. Symfony's container allow at least to fallback to manual configuration in very complex cases. You could also "extend" configuration loading to add local binding for example (unit it will be implemented in symfony itself). I don't see any problem with autowiring in a way it's implemented in symfony since it allows me to do everything I need, even if it's not possible out of the box. &gt; Now what? Let's follow the "autowiring path" and see where it leads us... You have this options: 1. Add manual configuration for this 50 cases and explicitly define dependency 2. Write compile-pass which will remap dependencies for this particular 50 cases (I don't like this way) 3. Wait for https://github.com/symfony/symfony/pull/22187. Since we are building cohesive modules this 50 classes will be probably belong to single module, so we could just place local binding for this module which will tell which implementation to use. 
1) If your goal was to hide the source of your project from your customers then PHP was a really strange (even reckless? in a business sense) decision to make. 2) Even if the application was written using something that compiles to machine code it could still be reverse engineered by simply looking at the contents of the memory. The only real choice is SaaS. If you're selling to businesses anyway I find it highly unlikely they will distribute the code and open them selves to a law suit.
&gt; Setup an AFP share in the directory I have it in Yes this is a perfectly viable option on a local network. Other options: 1) Use GIT 2) SSH to transfer files on to your home server from your computer 3) RSYNC your local folder to remote folder If it was my choice I would go with the GIT option
There nothing in PHP that is hard really, I think the hardest part is learning software engineering in general. Learning (applying) design patterns and programming concepts is much harder than calling function x() in PHP.
&gt; depending where you are in the world (South America, North America, Europe, China) - the prevailing framework changes Yeah the PHP community (and the JS one) are really bad at collabaration. "I don't like feature X in this framework but the rest of its mostly okay" *clones the framework changes a few files promotes new framework* Instead of just submitting a PR to the current project every many and his dog are out writing frameworks and packages that ahcieve exactly the same thing as the other 1000's already out there.
&gt; This is what I talking about. This is it's purpose. Ability to "test" or verify is just a side effect. Can you please make a more complete sentence. I have no idea what "this" is here. But to say that testing is a "side effect" of tests... I'm familiar with this. Happens if you're drinking too much unit testing kool aid. The unit testing obviously didn't allow you to notice there's a problem with `global $db` example I wrote, because globals are replaceable, hence testable, but still result in poor isolation and reuse across a project, and across projects. Ergo, unit tests can't help you with this. QED. &gt; I never relied on DI configuration to handle this Again... what is "this" here? I said autowiring causes flat amorphous projects. DI can't "handle" this. It's not something to "handle", it's something to keep an eye on as an architect, but autowiring actively discourages it, as autowiring is shallow: everything with dependencies must originate from the container. This is the container telling you "don't organize your project, keep it all flat, keep it all unstructured, I'll just deliver singletons to everything, don't worry". &gt; [Tests] are very handy at showing lack of cohesion and problems with dependencies. I already demonstrated that this is not the case (Laravel Facades, globals, static registries etc. don't "hurt" when unit testing). So your statement is completely up in the air, supported by nothing. &gt; Symfony's container allow at least to fallback to manual configuration in very complex cases. To autowiring, everything that's not a project-wide singleton is a "very complex case". So if you develop your project organically and don't appease the autowiring container, then every single class becomes a "very complex case". Unless you deliberately design your objects to appease autowiring and think "every dependency is a singleton". Which I'm sure you do, and you don't even notice it anymore. But it affects your project. A "very complex case"... that's curiously a "very basic case" if you remove autowiring from the picture and inject manually into cohesive hierarchical units. &gt; 1. Add manual configuration for this 50 cases and explicitly define dependency &gt; 2. Write compile-pass which will remap dependencies for this particular 50 cases (I don't like this way) &gt; 3. Wait for https://github.com/symfony/symfony/pull/22187. Since we are building cohesive modules this 50 classes will be probably belong to single module, so we could just place local binding for this module which will tell which implementation to use. All those are terrible **and you know it**. Your option 3 is not yet supported, so I don't know why you mention it. It also doesn't help, because 50 classes will be in 50 files, so you still have 50 configurations to write. And your first two options are so verbose, no developer would choose to do that. You're telling me THE MOMENT I have two instances of anything across a project, I need to start writing hundreds of configs to manually set it one way or the other for every object? This is much worse than the "cohesive high-level units" I mentioned. In my case all the 50 classes that need another PDO instance will be grouped cohesively in 2-3 components, and so I have 2-3 lines to change. That's the magic of **actually structuring your code**, instead of letting devolve to a shapeless soup of classes. But back to autowiring... with a flat set of classes, you have 50 configurations to write. So autowiring makes you choose between two shitty options: 1. Keep everything you can as pseudo-global singletons, project-wide. 2. Write dozens, maybe hundreds of individual class configs. This isn't good at all. If this is the best autowiring can offer, then you're making my case here... People operate in a very simple and logical way when presented with a system: 1. They prefer defaults (= autowired singletons). 2. They move in the path of least resistance (= avoid writing tons of configs). The simple conclusion is that autowiring discourages more than one instance of anything, if it affects more than a few objects at a time. This is the same as if the app was built out of static classes, it destroys untold number of possibilities for code reuse and leads to pointless duplication of effort. If you will be building your apps this way, at least be honest with yourself and go for a static Registry. You can achieve the same exact effect with a static Registry. Show me something autowiring DI does (any DI of your choice), and I'll show you how to do it with a dumb registry. Here, I'll even write you a PHP4 style registry with all the DI framework bells and whistles for you, to show you what you're really using: function dep_set($n, $v) { $GLOBALS['deps'][$n] = $v; } function dep_get($for, $n) { $v = &amp;$GLOBALS['deps'][$for. '@' . $n]; if (!$v) $v = &amp;$GLOBALS['deps'][$n]; if (!$v) $v = $n; if ($v instanceof Closure) return $v = $v($n); if (is_string($v)) return $v = new $v($n); return $v; } And here's a class using it: class Foo { protected $a, $b, $c; function __construct($id) { $this-&gt;a = dep_get($id, A::class); $this-&gt;b = dep_get($id, B::class); $this-&gt;c = dep_get($id, C::class); } } Setting a factory/config: dep_set(FooInterface::class, function ($id) { return new Foo($id); }); Binding: dep_set(FooInterface::class, Foo::class); Binding a dependency for a particular service: dep_set(Foo::class . '@' . A::class, A2::class); Autowiring (this class was not specified in the registry): dep_get(Bar::class); 1. No need to manually wire objects = check. 2. A central configurable repository for dependencies = check. 3. Can override the dependency used on a service by service basis = check. 4. Pseudo-singletons all the things!!! = check. 5. Unit testable = check. 6. Terrible for code reuse = check. 7. Terrible for project structure and isolation = check. We're checking everything a modern autowiring DI container does for you here. BTW, I can make it less verbose to use, but for a 5 min effort, I'm happy. This is what you're actually using. But you're using an over-engineered, slow, code generation building, reflection wielding, YAML/XML/annotation driven version of it, that gives you nothing more, rather than the false feeling you're following current "best practices". Don't believe me? Give me something you can do in your DI, that I can't factor with this dumb static registry. Let's see where the value is, or if the emperor is walking around naked and you're all keeping your heads too low to notice... 
Don't bother doing this. It makes everything slower and it makes life complicated for customers. If you are really worried about something stealing your code, go down the SaaS route, or use a language which you can compile a binary (even this can be reverse engineered, but is much harder).
&gt; So it struck me that not using a framework and writing everything from scratch is exactly the same [..] and in the end you get unmaintainable bowl of spaghetti code. That's not necessarily true. In fact, using a framework will not stop you from creating spaghetti code.
Perhaps this would be best asked in /r/PHPhelp?
I assume they still have to connect through an SSH tunnel or VPN.
Thanks for the tip!
Thanks for the tip!
Something bothers me about this flow that you don't explain. What if your local/dev environment has DB changes that are not on live yet or read for live yet? Changes such as anything that has key constraints? For example, you set up a foreign key on a table in dev to link to something else. Then when you pull data down from live (which doesn't have those changes yet) and try to push it into your dev database it will fail. The same would happen if you had any new columns that can't be null. What do you do in these situations? You don't seem to address anything like this at all.
http://mothership.ec/
Great call. Only thing I was thinking of was possibility of drafts never becoming published, and what percentage that would be. indexing and retrieving from a table could take longer than intended if it's 80% stuff you don't want vs stuff you do. You'd need a lot of articles before it was an issue though.
Yes, that's exactly the same principle :)
/r/networking is the same 
There is no silver bullet. All depends on your business needs (context). Using a framework as a foundation in a long term project context can be a pain. Using a framework in a MVP (~~Most Valuable Product~~ Minimal Viable Product) o RAD (Rapid Application Development) context can be very useful to see if the market responds positively and permit you to easily evolve your product. Software development is the last step and is the product, he has to build the boundary for the business, but should never dictate rules.
I'd say it depends. Going framework ahead may be suitable here and there, but at least personally most of the time I prefer component based approach.
1. developers can run "artisan migrate" locally which would then update dbs * in general DB changes should be somewhat backward compatible (perfect world) - we do blue/green deployments, so to ensure that we can switch back and forth without issues (and to avoid any problems during deploys) * we are quite agile, that is automated deploy on push to master and PRs branched-off master ensures that the states between production and local-dev are not too far apart 2. we have three "streams" dev/experimental/build. Dev should only be used if you do not intend to do db migrations. Experimental should not be used if you do not intend to do db migrations. That way we can isolate issues pretty easy. Also: it takes less than a minute to restore the database, so even if something goes wrong the whole team does not have to suffer :). In most cases a dev will be connected to the "dev" instance. 3. nightly downstreams are destructive. E.g. we completely drop the database prior so its always a fresh state from prod (also meaning that whatever was changed on QA/Staging/locally will be gone the next day)
You're the most toxic user I've seen in this sub yet. Congrats.
&gt; In some less common use cases it feels annoying to have to circumvent it or try to get it to do something complex. Ah, precisely... The trap of small convenience, that makes you compromise your app in a big way, in order to keep the small convenience.
Is there any good practice for alerting other programmers on a project of when they need to run 'composer install'? e.g. programmer 1 adds something to composer.json and runs composer update. I then check in the updated composer.json and composer.lock file. Another programmer then does a pull, and their dev environment breaks because they don't have all the libraries required. Do people use git post pull hooks for this type of thing? 
That's a very curious comment. It's topical, it's not spammy, but still it strongly seems as if it was written by a robot. Can you pass CAPTCHA tests?
Yes, but it is not the point here. If you own a car, you can break it and thus will have to go on foot. It doesn't mean, though, that riding a car is no better than walking by foot.
I should have phrased it as a rule of thumb, to avoid inevitable nitpicking :) Surely, every rule has its exceptions, but it doesn't mean there is no rule at all.
The only thing worse than linking a video on Reddit for this, is linking a playlist of videos for this.
hahaha yes, I have passed CAPTCHA tests &amp; your comment make me realize that i am human :)
That's a false equivalency, though. Creating your own framework is not equivalent to "walking by foot" in your analogy. Creating your own framework is equivalent to building your own car (which boatloads of people do very successfully, just as they do with creating frameworks). Using no framework at all would be the "walking by foot" equivalence. And, on that note, I'm kind of tired of this attitude in the community that developers are drones that should just stick to existing solutions and never bother trying to innovate. Like... where exactly do you think the current existing solutions came from? It sure wasn't people who just droned on with the previous existing solutions.
&gt; MVP (Most Valuable Product) I'm not sure if this is a joke, but MVP stands for Minimal Viable Product...
In this case, it would be more accurate to call it nitpecking.
Now question is, how secure will it be? And what are the best practices of protecting token based authentication. Because for this particular piece of code, if you steal token it will be the same as stealing user login and password.
&gt; (though it seems he didn't grew up the chicken from the egg which is cheating IMO) But where would he get the chicken to lay the egg in the first place? &gt;insert trollface&lt;
I have used ionCube and Zend Guard in the past. At run time there is no performance impact. The only hit is when first loading the encrypted bytecode into the opcache, but once the files are cached they are not slowed down at all. The biggest downside of these tools is version compatibility with new PHP versions. You can be stuck on an older release for a while. The second biggest downside is that it adds another thing that can break, and be hard to fix. We have had real pain when the loader wasn't working (for both ioncube and zend guard) and we were trying to troubleshoot it. Personally I don't think it's worth it. Either offer your product as an actual SaaS solution, or accept that in practice you won't be able to stop your customer from copying the source, but that you should be able to stop widespread commercial reuse of your code (if you get lawyers or the threat of lawyers involved). 
I have never seen that being a problem. The `as` makes it pretty clear.
Thank you, this is actually a comment i was looking for. Taking the information you provided, and others comments into consideration, we may look into a SaaS solution. We have never made a product before which we felt the code needed to be protected from prying eyes so needing to use either some form of code encryption + licensing or a SaaS solution is new to us. Ill bring it up in our meeting, I don't think anyone actually thought of SaaS.
Evangelists man, what can you do? We have about 50 front end devs (of varying quality) here. That ecosystem is even worse than PHP for "This is better than that".
its actually a large convenience that is sometimes also a small inconvenience. I'm generally positive on frameworks and I like Symfony, mostly. But yeah, have run into a couple of situations now where the autowiring was not helpful. However, I never thought I had to compromise my app in a big way. Just write some extra configuration and glue code that I wouldn't have to otherwise. Small inconvenience.
[different but same... but different... but still the same](http://i.imgur.com/dG64qX9.jpg)
This is a really bad analogy.
If you think so. For me autowiring goes directly against the way I structure my projects, because autowiring, and DI containers in general demand a flat structure, where you fetch everything from one container (more or less, I know you can technically have many, but who does?). If I want to put my controllers for ex. in a component, which is instantiated by DI, it means the controllers themselves can't be instantiated by DI, unless the component takes in the actual container and becomes dependent on it. And then I also lose ability to define which dependencies the component gets or doesn't get (I can override individual dependencies, but I can't remove all others it has access to). All of this is overall terrible for project structure. It encourages projects that are basically a soup of classes with no structure. And this is not specific to autowiring per se, but the the idea of "one big container to rule them all" in general. This is **not** how DI is supposed to work. It's just a fancy emulation of `Registry::get($name)`.
Creating your own framework is a different story. Though, if you are about rolling up one, if you ask anyone whether you should be doing so, then you simply shouldn't be doing so, and therefore the community is right here. And if you are determined enough, then just don't ask. And therefore that alleged attitude won't affect you :) A related musical joke: &gt; Mozart was once approached by a young man who was interested in Mozart's advice on how to compose a symphony. Since he was still very young, Mozart recommended that he start by composing ballads. Surprised, the young man responded, "But you wrote symphonies when you were only ten years old." "But I didn't have to ask how," countered Mozart.
[PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) also supports checking for `use` statements through its `no_unused_imports` rule.
 [FriendsOfPHP/PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) &gt; *Description*: A tool to automatically fix PHP coding standards issues &gt; *Stars*: 4661 &gt; *Forks*: 708 &gt; [Issues](https://github.com/FriendsOfPHP/PHP-CS-Fixer/issues) | [Pull Requests](https://github.com/FriendsOfPHP/PHP-CS-Fixer/pulls) *** ^(This is Earth radio, and now here's human music ‚ô´) ^[Source](https://github.com/anaskhan96/github-stats-bot) ^| ^[PMme](https://np.reddit.com/message/compose?to=github-stats-bot)
Sometimes choice of language, as choice of server location is not debatable (think of plugins). Also tools as mentioned are requested by menagement and on customer's side accepted... (which is also not a technical decission). Devs can argue against them, but are mostly overruled.
I'm not interested in having a bike-shed argument with you. Using a framework makes sense if you are more-or-less satisfied with the design decisions made by the framework. If you don't want to work in that design/project structure then you shouldn't use the framework and should just use individual components and libs. In the case I'm discussing, where the decision to embrace the Symfony way of doing things is already a given, I find autowiring to be a large convenience that is sometimes also a small inconvenience. YMMV. 
Often reading isn't enough for the concepts to make sense or 'sink in'. You need to write some code and run it, do experiments where you alter the code, run it again and see what happens differently, repeat. Follow your curiosity.
These are all wrong examples, for one. Here is a good example: Framework is like a plane. If you need to travel 2000 kilometers (to write a big project), then its fine to use a plane/framework, but if you need to travel 100 meters/1 kilometer/3 kilometers, then using a plane is wrong thing to do, because not only it will be superhard/next to impossible to take the plane off the ground in such short distance, you will not reach the max speed, plus landing will take some time, so you will take longer to fly short distance, it will take longer to prepare for the fly and so on. So by walking/using php language without frameworks, you will be able to travel/develop very quick and safe, and you will get lightweight result - only what you needed, because there might not be a parking space for a plane at your target. Of course, if you sit all day on your fat ass and forgot how to walk, then walking might be difficult :) There is another level of distance - millions of kilometers (moon, mars and all the space). If you need to travel such distance, then companies create their own stuff, because they want to dominate the market, they want to get good product, they need a better product than the one that exists today and so on (like big corporates, who create themselves operating systems, hardware and so on). Plus you have to consider terms of usage - using react/united airlines is a poor mans choice; others will not provide any warranty and so on, so you must have a full project first, and then you will see what you need to do - small project - use just a pure language, medium to a bit more than mediun project - thats where the frameworks fit, and for big big projects you should want to create your own big framework to get what you want and to not depend on loose ends.
Depends how you're defining a "framework" really. I quite often put an application together using different components such as routers, di containers, template engines etc and then write about 100 lines of code or so to glue them all together. I suppose this is what you would call a "framework" but for me it certainly isn't a load of spaghetti code or unmaintainable. I think as packages start to become more stand alone all the time, the need for a framework (in the current sense) at all is coming to an end
Oh wow the combination of PHPStan and type hints is the greatest thing to happen to PHP! I knew once we updated to PHP 7 I would eventually find awesome tools that I could not use before! I probably did see this before and didn't look at it much since we were not using PHP 7 yet. Anyway, I'm wondering how far defining your own rules in the code can go. Do you think it would be possible to enable a type driven development style of development? Type driven development dramatically reduces the amount of automated tests you need to write. A language called Idris was created specifically to explore this concept. I have never used Idris, so what I am about to say could be inaccurate. With Idris you basically get to write code that runs at compile time, so I see a similarity between that and writing code that runs with PHPStan. One of the unique things you can do with Idris is enforce rules around what methods can be called and when via type rules. After you call a method, the type of the object you called it on changes to a different type which will now allow you to call other methods that previously would have been wrong to call. Think of a class that helps you work with files. You have to first open the file before you can read from it. Also, once it is closed, you should not try to read from it again. It would be nice if a PHP tool enabled that style of development for PHP.
It's perfectly fine for large projects for performance concerns, it's just as performant as any other full PHP framework if not better in some cases. The real issue (talking from experience here) is every single minor point release breaks one thing or another and the list of things to check or change upgrading a point release is always quite long. This is fine for my personal projects and I will still use Laravel for those but for a large project that's at the core of a business, this becomes tiresome and not maintainable.
&gt; learn proper PHP All the frameworks are "proper PHP" makes no difference if you've written it or someone else has, it's still plain PHP
I heard someone say it was consistently inconsistent
not really..and definitely not all..have you seen codeigniters code base..no sane developer would call it proper PHP..it makes a huge difference who has written it, because if you have people assigned to work on a framework and spend their time with researching the topic and build up experience, that is a completely different thing than working on applications. Proper PHP takes years to master whilst you can start with a framework in weeks and get the same result
Unless your target market is exclusively other developers, requiring ioncube or another encryptor is a barrier high enough to prevent a great portion of your market from bothering at all. (Ask a friend with a Godaddy WordPress site to install a PHP extension and observe.) On the other end, most of the people who would be able to manage the install process would be rightfully wary of running software the source code of which is inaccessible. It's a lose-lose, and as others have said, it still won't prevent determined bad actors from cracking anyways. Piracy is a cost of doing business. Trying to pass that cost on to your legitimate users in the form of unacceptable barriers to entry is exactly the wrong solution.
&gt; have you seen codeigniters code base It's still "proper PHP", I think what you're getting at is design patterns and software engineering in general. This is completely different and totally separate concept to any one language 
For everyone saying to not protect the code because it can be cracked, I found this quote which fits. &gt;"As for what others have written here about not using obfuscation because it can be broken etc: &gt;I have only one thing to answer them - don't lock your house door because anyone can pick your lock. &gt;This is exactly the case, obfuscation is not meant to prevent 100% code theft. It only needs to make it a time-consuming task so it will be cheaper to pay the original coder." - Yossi 2011
Our target audience are other developers, not skilled developers and probably developers who don't respect IP which is why we developed this application and want to protects our IP. Here **I made** a comic to explain it: [http://imgur.com/6B5shXP](http://imgur.com/6B5shXP)
Spring framework (Symfony from Java world) have that autowiring features for 5+ years, and I didn't hear any big complains from developers.
Bad analogy. What you describe is more like writing your app in Assembly. Using PHP but no framework is more like buying the ingredients (bread, cheese, tomato, etc), slicing/preparing yourself and using that to make a sandwich. Using PHP with a framework is like buying a pre-made sandwich and adding mayo to it. 
I really wish there were a way for users(e.g. me) to opt into hiding these bot comments. So many largely useless bots that spam comment sections now.
If you're going to do anything with token-based authentication, make sure you [follow the split token methodology](https://paragonie.com/blog/2017/02/split-tokens-token-based-authentication-protocols-without-side-channels).
Enable PHP debugging, and have a look at the error logs - it will give you a filename and line number to look at as well as the general idea of what the error is. 500's are quite often PHP fatal errors, time outs or memory limit being hit - the error logs will tell you which and where. Please ensure you hash passwords in the database (review password_hash and password_verify in the PHP docs), and consider using prepared statements either in mysqli or PDO
Don't consider using prepared statements...just use them. Always. Preferably PDO.
not following PSRs and writing shit code is not proper PHP..it is just an attempt to write PHP..what you are getting at is maybe valid syntax :)
Another quick question: Does anyone have any advise for keeping a unique user ID in a database? The purpose would be to track anonymous user actions (i.e. users who have not created an account). It doesn't have to be totally perfect, but just kind of "good enough" for an intrasession basis and potentially useful for multiple sessions. Should I just use IP4? Maybe something stronger if the user changes location? Thx
Wait so how would i use this debugging tool. I am a beginner.... 
Well just do whatever you want since you obviously have decided before even posting. 
Put a [try catch statements](http://php.net/manual/en/language.exceptions.php) wrapping the code and display the error message to get a better idea where the error comes from. You should not use like as it matches a pattern, '=' will work just fine: SELECT * FROM UserData WHERE username = '$username' AND password = '$user_pass'; Also you shouldn't store passwords in plain text, have a look at [password_hash](http://php.net/manual/en/function.password-hash.php) 
I remember this. I loled hard when he said "it wasn't that good."
I've worked for a company which sells its product as a self-hosted solution, and we've been doing that without literally any obfuscation since day one, for almost 10 years now. Even the "license file" was (probably still is) plain PHP. Yes, there are plenty of "cracked" copies to download and they're just a few clicks away for anyone who might be interested in getting one, and there are plenty of them running and calling home for an update check (though not getting it and always receiving a "you're up to date" message). From time to time some of them calls for help, mostly having no idea that it's actually a commercial product, and almost all of them purchase a license (they can "legalise" their copy) and become one more regular customer after realising that their instance is actually illegal. Once we did try distributing an encrypted version and it was very unpleasant experience for all parties involved. Some of the things that I can instantly remember: - Customers have no clue or aren't that tech-savvy to install an extension themselves - Customers know how to install an extension, or have someone who can do that, but in order to get an approval for that they're more likely to find an alternative because it's just too much pain in the butt - Customers can install an extension but there's no way that the 3rd-party hosting company or their own would alter their environment just because you decided to hide the source code, which they probably won't even bother too look at - Customers want your product and mostly aren't interested in looking at the source code, they just don't care - Your encrypted code running on someone else's server is a black box that even you cannot debug, and you *will* need to do that, especially if you're just starting and you have no damn idea how versatile the environments can be. No matter how precisely you present the system requirements and anticipate the potential obstacles ("xyz must not be enabled" and so on), there will always be that something which interferes with your application but you'd never figure that out on your own. And, to get those unforeseeable things right, you'll have to debug your application right there on your customer's server, which with encrypted codebase is dead end. Simply put, if you don't make the installation process as easy as possible, it will turn people off. Adding such an extension as a requirement is a guaranteed turnoff, even if your target audience are godlike sysadmins, let alone not-so-skilled developers. If your product is valuable to your (potential) customers, they will pay for it and will keep paying for the support services for years. They are in because of the value it provides, not to browse the source code. Edit: again the topic is in a downvote storm. Shouldn't this be a discussion that brings up pros and cons, no matter how much some of us are not fans of the idea itself?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
[Uuid::uuid4();](https://github.com/ramsey/uuid) + try again on duplicate.
Any way to use PHPStan to check a wordpress plugin? I tried but it just kept crashing with no memory error, even if it got 8GB of memory. 
What would you recommend then? Lots of people bash it but I haven't really seen anyone give viable alternatives for large ecommerce sites. 
So you're saying save it to a cookie / session? And it's not a big issue if the user clears it; also not a problem if there's a duplicate UUID? (as rare as that would be) Thx
PHPStan currently needs to include files, so it works only on what (according to 2017 standards) is "relatively clean" code. Specifically, a file should cause no side-effects besides declaring symbols, when included. https://github.com/phpstan/phpstan/issues/67
my general testing process is: * php-cs-fixer * phpstan * psalm * phpunit
go the SaaS route, trust me on this you won't regret it, been selling hosted solutions long before SaaS was a word, and if someone want to get the code they will eventually.
You don't appear to actually be declaring `\My\Dependency` and `\My\Manager` as a service though? 
For those interested in pushing code-based config in Symfony, head over here :) https://github.com/symfony/symfony/issues/22407
Try to be more present when solving the problems. I think this is the biggest thing for me. Don't copy/paste. If you have an IDE autocompleting methods for you and helping you with parameters' order, try not using it for a while.
Hmm, if we're using code as DI config, why do we still need a container library and annotations at all? I mean, I follow the "code as config" (DI and otherwise) rule of thumb, too and hence I *don't* need annotations and containers. Instead of: `$container-&gt;get('service');` ...it's just writing the class directly and calling it directly: `$container-&gt;getService()`.
Stop pasting from stack overflow and start typing out the solution yourself! It will stick a lot easier Bonus points if you lightly "refactor" it, miss a change in behavior then curse the SO poster later down the line :p
 $container-&gt;getService() This looks like a factory method which acts as a "DIC-wrapper". Is this allowed and "best practice"? Pros: The return type of the getService() method can be type hinted with a docblock (@return Service). Nice.
I'm trying to resolve this, for example the playground at phpstan.org does not suffer from this but I have to work on a solution that will not affect performance when analyzing huge codebases.
I'm really impressed with Shopify. And if you're on WordPress, check out Woocommerce. They're both pretty user friendly, developer and designer friendly (less so with Woocommerce, but that's mostly Wordpress's fault), and satisfy all the basic requirements of 99% of all online retailers. In my experience, large "enterprise" ecommerce companies tend to think they are much more special than they really are. So they seek out the solution that claims to be infinitely customizable, a la Magento, so as to accommodate their perceived special needs. But for the most part, they have the exact same needs as every other online shop. So, even if Magento was a solid, stable, performant platform, it would be overkill for what they are trying to do.
It's not a "DIC wrapper" it's literally just that method, is my point: protected $service; function getService() { return $this-&gt;service ?? $this-&gt;service = new Service(); } &gt; Is this allowed and "best practice"? Well, there's... nothing wrong with writing a method :) right? &gt; Pros: The return type of the getService() method can be type hinted with a docblock (@return Service). Nice. Sure, or a PHP7 return type-hint.
Coding a lot of things from memory is not a sign of a good programmer, quite the opposite. - A good programmer doesn't know all methods and arguments by heart. They use an IDE that knows that for them. - A good programmer doesn't Google and type the header for redirect over and over. They write themselves a redirect() function, method or a class, and then they reuse it. So the trick isn't to memorize how to type lots of things from memory, the trick is to learn how not to have to.
There's no shame in referencing the docs heavily. One of the biggest things for me that indicates I know a language well is not being able to call every possible function from memory, but instead knowing where in the docs to find what I'm looking for. This is especially true given PHP's habit of inconsistent function names and arguments. üòÅ
as others have said, this isn't a bad skill per se... but unless you're a perfect programmer in every other regard, your time is probably better spent improving other things.
&gt; [I do not] carry such information in my mind since it is readily available in books. ...The value of a college education is not the learning of many facts but the training of the mind to think. *- Albert Einstein*
I don't use Symfony so I may be missing something specific, but I personally like having all of my related methods wrapped up in one class to act as the adapter. In terms of ensuring there are no conflicts with the IDs, I would definitely be having the mapping routine throwing an exception if a duplicate was added without some kind of replacement flag set. What we really need is to be able to directly reference functions like MyClass::Fn::Name
I agree. It's a problem for me because PHP uses the opposite of the other languages (including English), but I can perfectly understand that you prefer it in this way :)
Sorry for that, but I liked the metaphor, and nice project names beginning by PH* are not that easy to find ;)
I almost wish I was in school again so I can print this and wave it in the face of all the teachers. Then I realize I'm an adult so I can do whatever I want. Woohoo!
No need to be sorry...but if you want to get traction you need to come up with a unique name!
Regarding point 1: &gt; An XML editor won't give you code-completion for PHP classes or methods. The configuration is simply treated as text and has "no meaning" in a programming sense. [You just need to use the right editor](http://i.imgur.com/qYqxJpN.png)
Been coding PHP for almost 20 years now and I still have to look up things like argument order from time to time. I'd say dont focus on syntax memorization and instead focus on the logic/patterns used.
What about locking row with shared lock in mysql? and what do you mean with mutexes?
&gt; Most Valuable Product Is not a joke and sorry for that, english is not my first language but reading online about MVP and based on my experience, I found a lot of resources that talk about "Most Valuable Product", even if the most usage of the acronym is "Minimal Viable Product".
&gt; Write a project, upload on github, post a link here ...or on https://codereview.stackexchange.com
We don't fall into the 99% of retailers. We've got multiple subsidiaries which have specific needs, and we integrate with a closed source .NET ERP system using an ioncubed OEM extension. They *might* provide extensions for other platforms, but moving the existing stores and their functionality to a new platform is out of the question. As much of a pain as it can be for developers, we've had an overall positive experience with it.
&gt; PHP for almost 20 years &gt; look up argument order from time to time The memes are true! :P
[They are.](http://i.imgur.com/5c5RZcS.gifv)
If we define a framework as a set of tools designed for solving a given problem, we can put things in a reasonable context. You cant build a site without a framework if you want to be pedantic. You *can build a site without using an open source framework. I'm sure this triggers an immediate kneekerk reaction, but consider. The moment you start making design decisions you are building your own framework, you are deciding how to solve that same set of problems, or more likely just saying fuck it and not addressing the problem at all. I haven't seen any good arguments against using a framework. Usually they all just boil down to fallacies, absurd contrived use cases, and loaded terms that are never substantiated, of more often are irrelevant. I'd be interested in any arguments against use of a framework that are *relevant*. What is relevant? If one of the reasons is that a given framework doesn't make sandwiches, I don't care not the problem that a framework solves.
&gt; Using PHP with a framework is like buying a pre-made sandwich and adding mayo to it. Nonsense. What you describe is Using Wordpress and then adding a module. Thats taking it a bit far. Its like comparing a carpenter who bought tools, lumber and glue to build a table to a guy that bought his table from Ikea and painted it. Clearly there is a huge difference there.
You're not just learning PHP you are also learning a languange, the same way you would learn Spanish or Music. Pratice Practice Pratice. 
To add to this, don't worry about memorising as so much as knowing where to look and why things work, your mind has more important things to worry about. If you know what's going on, you'll quickly know where to look no problems.
Create a folder of examples of common problems. Search them locally with `grep` or `ag`. That's what I do.
after 10 years I still have to look up how to concatenate strings..thanks to template literals in JS it is a little better now..your brain has a limited storage, don't waste it by memorising things you can just look up, the important part is knowing they exist and be able to understand and use them
Why! I go the other direction and use code snippets, need a foreach loop - create a code snippet for your generic use case and assign it to ctrl+alt_shift+f, I have 20 or 30 of these. Not only am I useless without an IDE I am useless without my personal settings for that IDE loaded up!
i just opened it to cause the authentic article :) ..but please fix the grammar :)
&gt; that developers are drones that should just stick to existing solutions and never bother trying to innovate Innovate away, because its all good when its just shits and giggles we are walking about. If you get your kicks rewriting the same routing system for every site you build, I guess who am I to tell you what you can and cant enjoy? Once you start taking the routing system you "usually use" and copy pasta that to every new project, congrats you've decided to create and use your own framework. Then saying "Hey I use this a lot I should polish it up" and you make a big list of things to add/fix, and that's when the lightbulb turns on, not only is it rather boring work, its already been done! At this point unless your ego is off the charts out of control you say "Well shit not only has it been done Its been done better than I could do it" and that's when you include the symfony routing component in your composer config. I guess if you are going to "innovate" lets make sure its actually innovating not just a retread I know a guy who was an "idea guy" and his ideas were all "copy" something I like. My general response was "why compete with millions of dollars in VC funding?" I think some people take offense to the idea that webdevs don't build anything they just glue components together, but IMO that's an absurd way to look at the situation.
Give this boy a lollipop. I completely agree. I use switch statements in my language of chose ALL the time and from time to time I have to look it up because I simply cant remember the syntax. There is nothing wrong with forgetting the syntax as long as you know how to use it properly. 
there are so many issues with your example..I am not going to mention the unnecessary else statements (checkout happy path programming) but you have not verified whatsoever if the token is actually valid and from the user your believe it came from..the authorization header will usually have a JWT token which is encrypted via a private certificate and you check its validity via a public key. If the token is verified than you can just grab the user id which is in the token and query the db
Try phpstorm.
&gt; A good programmer doesn't know all methods and arguments by heart. They use an IDE that knows that for them. While I totally agree with this, I have also noticed that when you're in a programming interview "buhhhh my IDE usually does this for me" is not usually the answer they're looking for. I will say during one of my most recent interviews, I said something along the lines for "yo, I know this function accepts 2 arguments and I might have them backwards but trust me, this would take me 1 second to figure out IRL" which I think was acceptable but arguably, they're not trying to hire an IDE.
This is kind of what I'm going for with [Capsule](http://capsulephp.com) (though the configuration work is protected instead of public).
PHP is terrible for memorizing function names and arguments. So much legacy function names and the order of arguments is not always consistent. Set duckduckgo as your search engine and then search use the !php bang operator to jump to the php manual page. 
You should convert your post into a blog post. It's pretty good, with some editing. I still prefer Eclipse. I gave Jetbrains a try, but one thing they don't do well is handle a lot of different languages. It's bad enough so many SDK's have their own IDE's (Android, etc.) that are tailored enough to warrant using, without switching IDE's per-language too. I don't think you can use a single Jetbrains tool to do even just Java, C++, PHP, and Javascript. That's really not a very diverse group, and run together if you're doing Android, Node (C++ for modules), some PHP work, and a hobby language like Haskell or something. Eclipse is really nice, and has a lot of development $$$ invested in it (I saw a figure of &gt;$70 million a few years ago). 
But then you need to memorise the redirect() syntax. Don‚Äôt get me wrong I agree with what you are saying and it‚Äôs great advice. But I see where the question is coming from. I find it mentally taxing to both look up code definitions and to remember my own helpers. Perhaps there is a subset of PHP that should be memorised - just to make day to day coding a little more streamlined.
One of my favorite business analysts is Horace Dediu. He has this favorite phrase "people don't buy products simply to own them, they hire them to do a job, and that represents the value of a given product to you, so today let's discuss the jobs an iPhone is hired to do." So in that train of thought, an employer is absolutely looking to hire an IDE for their developers. They're also looking to hire suitable hardware for their developers, and all other accommodations that need to be hired, in order to form an effective team. And this is where you come in. You're far more expensive to hire than an IDE, you're far more expensive to hire even than a high-end computer. And for your seat only, even the office space you take up is far cheaper to hire (i.e. rent) than you are. So if an employer was looking to hire someone with the skills of an IDE, you'd be way more expensive than an IDE, and completely unhireable. Your skills are complementary, and synergistic to that of an IDE, i.e. you're far more effective with an IDE, and an IDE is far more useful when it works with you. It's true that many employers don't know how to interview developers, but it never hurts to walk the middle way between being interrogated, and educating your future employer. I've gently refused to take "whiteboard" tests, I've explained why it's not representative of my actual performance, and I've proposed alternatives. It seems to work in most cases. And in the cases it doesn't, it tends to be a warning sign that the team you're joining will be a big pain to work with.
&gt; But then you need to memorise the redirect() syntax. Seriously now... is `redirect($url)` hard to remember? Especially if it's on your response object, say. One of like 2-3 objects you deal with in your controller: $response-&gt;redirect($url); &gt; I find it mentally taxing to both look up code definitions and to remember my own helpers. I have quite terrible memory, but even I don't have trouble using *my own helpers*. You use an IDE right? Which IDE do you use? If you have problems memorizing your own helpers, I'd suggest again: get better dev tools, and design better helpers. Tools are readily available and cheap (even free). Designing better software is a skill you can pick up from a mentor, books and various sources online. &gt; Perhaps there is a subset of PHP that should be memorised - just to make day to day coding a little more streamlined. You can't memorize some subset of PHP like you study a poem to recite. That's just silly. You mind has evolved over millions of years to recognize which pieces of knowledge are important, and it stores that in a range of complementary memory areas (narrative memory, visual/audio sensory memory, pattern training, motor memory etc.). This happens automatically, you can't force it upon yourself, and there's no way to know in advance what subset "should be memorized" especially as that subset changes over time, and from project to project.
If, after seeing all those comments about how you shouldn't worry about it, you still want to be able to code from memory, check out [MemRise](https://www.memrise.com/courses/english/?q=php). If none of those lessons are what you want, you can create your own and use their quiz system. Personally, I find it helpful to intentionally study or memorize functions.
As others have suggested, holding all this stuff in your head might not be the best solution. Being able to quickly access information might be a better strategy. Have you considered make a cheat-sheet for things you frequently look up? I do that sometimes with [github's gists](https://gist.github.com/). Another thing which might help you to access information quickly is [duckduckgo's bangs](https://duckduckgo.com/bang). If you set duckduckgo as your default search engine, you can just enter `!php header` in the address bar of your browser, and the page you want in the PHP manual will open. If you really *must* commit this stuff to memory, then I suggest you investigate [mnemonics](https://en.wikipedia.org/wiki/Mnemonic). Given sufficient commitment and practice, its astonishing what humans are capable of memorising. Tony Buzan has [a manual on the subject](http://www.tonybuzan.com/about/memory/) which seems to attract [good reviews](https://www.amazon.co.uk/gp/product/1406644269#customerReviews). Like most others here, though, I still think you're better off developing strategies to easily access the information you need.
You can do that but you probably end up typing a lot boilerplate when services start having dependencies on other services. Just to mark something as "lazy" or "abstract" in a config file seems the better way to go for large wiring constructs.. Edit: What you're describing is basically what Pimple is, not? 
The problem here is the interview process. They shouldn't be asking you about the order of arguments in a function or anything else stupid like that. 
&gt; You can do that but you probably end up typing a lot boilerplate when services start having dependencies on other services. Just to mark something as "lazy" or "abstract" in a config file seems the better way to go for large wiring constructs.. There isn't lots of boilerplate. If the dependency is needed in one place, just specify it inline. If it's needed in two or more places, make a one-liner method for it like the above. That's not a lot. &gt; Just to mark something as "lazy" or "abstract" in a config file seems the better way to go for large wiring constructs.. It doesn't solve the problem of configuring how the wiring actually happens. You need to choose what goes where. The rest is just automated chaos. Pigs flying. Cats eating dogs. Pseudo-singletons everywhere. &gt; Edit: What you're describing is basically what Pimple is, not? Yeah it's like Pimple, in that Pimple is just a poor and slow reinvention of what a class does, and what I'm describing is just a basic class, without reinventing it. 