I think it does. It isnt to show you are good at any particular language, it shows you can program.
Are you talking US only addresses? I had to do something very similar (processing a bulk lists with numbers in the hundreds of thousands), but my addresses spanned multiple countries. If your addresses are US based only, the problem is significantly easier. If you need to process non-US addresses, I would suggest using an API even if it seems like a pain in the ass. Google has pretty low limits on how much you can use the API (and IMO their format kind of sucks in that there's quite a bit of variation in how data can come back). I ended up using Yahoo's api since they let you run 50k requests per day, and did some trickery so I could run my list in a day. I personally liked their format, and adopted something very similar for storing the data in my database.
 Here you go: &lt;?php $curl = curl_init('https://blockchain.info/api/receive? method=create&amp;address=169iA76RmnatFXmEthT6AEehxMQ9X1ro3L&amp;shared=true'); curl_setopt($curl, CURLOPT_FAILONERROR, true); curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); $result = curl_exec($curl); // Without parameters json_decode returns an stdClass object $object = json_decode($result); // With parameter ture json_decode returns an associative array $array = json_decode($result, true); echo ($object-&gt;input_address); echo PHP_EOL; echo ($array['input_address']); ?&gt;
Man, I love you, there is only one thing, it comes up with an error on echo($object-&gt;input_address); P.s Thank you so much!
I make over $1,000 an hour? Sorry.
You have delivered! Upvotes!
I would also like to hear more of a discussion on this point
FizzBuzz is useful early in the interview process for rooting out the complete fakes that get by HR.
Nicoon: thanks for your comments. I am going to take a look another look at throttling. Comments like these are great! The goal is to improve the project and really appreciate it.
I am embarrassed. :( 
The static usage is entirely optional. Sentry::getUserProvider()-&gt;findById(1); $this-&gt;sentry = new Sentry; $this-&gt;sentry-&gt;getUserProvider()-&gt;findById(1); Same thing. This is how we set it up for now in PyroCMS: https://github.com/pyrocms/pyrocms/blob/feature/sentry/system/cms/core/MY_Controller.php#L375 It's done like this until we get to L4 which has a nice IoC container for wrapping up this sort of bootstrap. Point being, we're not using static and you don't have to either - it's just easier for examples to use that simple interface.
That should be done during phone screen, bringing a person in to weed him out by a fizz buzz test is waste of time.
No it does not, fizz buzz is something that 99.9% of mediocre developers study for, same goes for other bullshit 'puzzles'. 
Laravel 4 has a "Facade" which I'm sure you've heard about before, and Sentry has a "Service Provider", which hooks up the IoC and Facade and all that jazz. But nope, this is a framework agnostic package, so that stuff IS there, but you don't have to use it. The examples I pasted are just native PHP and you can use them statically or not. The main Sentry class is just pointing you at the various other instances, like the User, Group, Throttle, Session, Cookie, etc.
You shouldnt study for fizz buzz.. fuck 90% of the people i graduated with wouldnt even solve it, let alone know it or try to rememeber it. Thats the point of the fizz buzz.
So, I went looking in the repository as well, and noticed that the library might be vulnerable to a session fixation attack. You should always regenerate the session identifier upon every successful login, but the interface offers no way of doing that. 
Not Laravel: $this-&gt;sentry = new Cartalyst\Sentry\Sentry; $this-&gt;sentry-&gt;getUserProvider()-&gt;findById(1); Optional Facade if you're using Laravel 4 and WANT to use the Facade: Sentry::getUserProvider()-&gt;findById(1); Laravel 4 usage if you don't like the Facade: $this-&gt;sentry = new Cartalyst\Sentry\Sentry; $this-&gt;sentry-&gt;getUserProvider()-&gt;findById(1); Notice how native PHP and L4 without facade is identical.
&gt; coming from another language you already know the protocol. Not necessarily.
Good. What you said wouldn't have made sense otherwise if they weren't two different classes. Well, I guess that leaves the issue of it using exceptions for flow control. 
Whats the problem there? true/false is tough to work out what the issue is without creating an ass-load of arrow code. Gimme an example of something that something that sucks, and show a better API for it without the exceptions.
hmmmm I think I may have been misinformed. Are you telling me that even if PHP 6 implements the autoloader using PSR standard that I could make my own autoloader and PHP would use it? I was under the assumption that there would bea baked in autoloader and that I wouldn't be able to override it, so if I wanted auto-loading, I would just have to conform to the PSR. So are you saying in PHP 6 I could still make my own autoloader? I remember trying to argue with my coworker that there was no way they would be so stupid it not allow people to make their own autoloader, but it ended up being 2 v 1, so I gave up.
&gt;Whats the problem there? A number of issues. 1. Exceptions are meant to be used for exceptional circumstances (like, say, a database error). Failure to log in isn't an exceptional circumstance, it's part of the flow control. Returning login failures and the like as exceptions are akin to returning result sets as exceptions in general, which is rather obviously the wrong thing to do. 2. Exceptions are essentially non-local goto statements, which could make debugging difficult. 3. It's a violation of the Principle of Least Astonishment. 4. It's a fair bit slower and resource intensive than what returning values are. &gt;true/false is tough to work out what the issue is without creating an ass-load of arrow code. Oh, pish posh. It's no more difficult to do than it is doing it with exceptions. Here's some pseudo-code: if (!$myAuth-&gt;authenticate($user, $pass)) { //an error occurred switch ($myAuth-&gt;getErrorCode()) { case MyAuth::USER_NOT_FOUND: echo "The user was not found; break; case MyAuth::INCORRECT_CREDENTIALS: echo "Incorrect credentials supplied"; break; case MyAuth::USER_NOT_ACTIVE: echo "The account has not been activated"; break; case MyAuth::USER_SUSPENDED: echo "The account has been suspended"; break; } }
I thought PHP strings in PHP were mutable ? You can do this and it will affect the same variable : $a = 'foo'; $a[1] = 'b'; echo $a; /* fbo */ Something I think this article should mention is the flexibility offered by functions like fopen, file_get_contents, etc. and that it can be extended with the use of [stream_wrapper_register](http://www.php.net/manual/en/function.stream-wrapper-register.php).
What kind of error? Checked my code again and it works for me. What php version are you using? json_decode is available for php &gt;= 5.2.0 (see http://php.net/manual/de/function.json-decode.php)
The point is that everybody knows about fizz buzz already. I interviewed people who sucked but nailed fizz buzz puzzles because they study FOR the interview.
That's no problem, let me look in to it and if I get stuck again, I'll call you! Thanks so much for your help!
Just for future reference, using these curl options is inherently insecure: curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); //insecure curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); //insecure Instead, you should require HTTPS to validate successfully. If you don't force it, your code could be subject to man-in-the-middle/peerjacking attacks. I know that this is probably just a one-off project, but it's best to learn and implement secure practices from the start, instead of making crucial mistakes later in your career. curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 2); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, true); 
Wow, thanks that's awesome! I might actually think of putting this into a possible project! Here's a sneak preview if you want it; "http://matt-boyd.co.uk/dice"
 [**@juokaz**](http://twitter.com/juokaz): &gt;[2013-03-18 13:03](https://twitter.com/juokaz/status/313636684333973506) &gt;upgraded all production servers to PHP 5.4 over the weekend. A picture is worth a 140 chars [pic.twitter.com](http://twitter.com/juokaz/status/313636684333973506/photo/1) [^[Imgur]](http://i.imgur.com/OZZ6rCf.png) ---- [[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/1ajk8w%0A%0APlease leave above link unaltered.) [[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [[Translate]](http://translate.google.com/#auto/en/upgraded%20all%20production%20servers%20to%20PHP%205.4%20over%20the%20weekend.%20A%20picture%20is%20worth%20a%20140%20chars%20http%3A//twitter.com/juokaz/status/313636684333973506/photo/1) [[FAQ]](http://www.reddit.com/r/TweetPoster/comments/13relk/) [[Statistics]](https://www.stathat.com/decks/PJSe8OF5J44Y) 
Maybe everybody in your subset of aplicants. Then change the problem. Dont call it fizz buzz during the test, use another words to confuse them. 
I really hope they add array comprehensions in the future, they will make code like this much more elegant IMO, not that I have anything with the way it is right now. I heard they were gonna be present in 5.5 but then something came up. By the way, in the array_filter example, I think you forgot to import $filterEmailAddress to the closure's scope : array_filter($payload, function($item) use ($filterEmailAddress){
I see this was solved, but just for future reference, check the return value of curl_exec and if it returns false, call curl_error on the handle to get the error : $result = curl_exec($curl); if($result === false) { echo 'Error : '.curl_error($curl); } else { /* rest of the code here */ }
Thank you, will be sure to do this next time! 
PHP sessions don't scale well. They're sandboxed to the machine with which the user communicated initially. This means you run into issues as you expand your operation and add more public facing web servers and load balancers. This is why encrypted cookies are often used for session management at scale. The client keeps it's session identification and hands it to the server for decryption. From there you can make decisions on how to handle the user. tl;dr If you're relying on default PHP session management you're going to feel the pain of them biting you in the ass when it comes time to scale.
That's pretty damn impressive, I'd be interested to see some stats from other highly loaded sites.
Yep - that's pretty much the picture I saw when on upgrading from 5.3 to 5.4 the web app stopped working. Much panic followed.
Memcached doesn't even need to be involved, var_export session data, encrypt, toss it in a cookie. Would suck to have your users sessions constantly expiring because the caching servers makes their session data as stale. How do you look up their session data? What is your identifier? I'm guessing you're keeping a unique identifier in a cookie... you see where I'm going with this right... 
You have been misinformed. PSR-0 is not going to implemented into PHP 6.
This is how it would effect my usage: https://gist.github.com/philsturgeon/5190808 I am fine with the exception-based approach as I've said, im sure some will find the if/error code approach better, but generally I find this to be less than optimal. Exceptions are not just for "Exceptional" events, is see them as "I take exception to that", which can be a wide range of things. With a mailer for example, a LOT of things can go wrong in the sending of an email, so you want to throw exceptions if the email fails to contact the SMTP server, if it fails to include a from address, if it cannot find the sendmail install, whatever. What if it doesnt have a valid email address? Is that an exception, or should it return false and make you look up an error code? Why half-and-half it? Exceptions are a preference, and it's not a surprise to see exception-weak languages like PHP have a lot of exception avoiders, but a multi-try catch block does not look all that much different to your switch - but has the added advantage of not making your users go looking for errors. The errors will be smashed into the users face and they are then told to handle them, which is an approach I like. &gt; Exceptions are essentially non-local goto statements, which could make debugging difficult. Backtraces make debugging super-easy, instead of having to var_dump error messages from a getErrorMessage() function. &gt; It's a violation of the Principle of Least Astonishment. "My code looked like it was working, but I guess I just missed a case in my switch, or the class changed its constants, but actually it was broken on production." Not with exceptions you wouldn't. &gt; It's a fair bit slower and resource intensive than what returning values are. Errors take 0.00002 longer to happen? Nobody is going to win a conversation about which is better, I prefer exception heavy and if you don't then thats ok. This may well come from the amount of Ruby or Python I've been doing recently, but exceptions make life ridiculously obvious instead of painfully vague.
&gt;This is how it would effect my usage: So, positively, by the looks of things. You managed to reduce the code by 9 lines of code and make the whole thing clearer to read. &gt;Exceptions are not just for "Exceptional" events, is see them as "I take exception to that", which can be a wide range of things. Sure it is. If you're going to argue that it isn't, then maybe you shouldn't bring up exceptional circumstances in the very next paragraph... ? Ahem: &gt;"With a mailer for example, a LOT of things can go wrong in the sending of an email, so you want to throw exceptions if the email fails to contact the SMTP server, if it fails to include a from address, if it cannot find the sendmail install, whatever." ^ All exceptional circumstances. &gt;What if it doesnt have a valid email address? Is that an exception, or should it return false and make you look up an error code? Why half-and-half it? If it's a validation function, then no, it should not throw an exception. If it's a parser function, then yes, it absolutely should throw an exception. &gt;Exceptions are a preference *What?!* No, they're a fundamental part of object-oriented fault handling. &gt;The errors will be smashed into the users face and they are then told to handle them, which is an approach I like. Exceptions aren't for displaying errors. They're for notifying your code that something went bad, so you can handle those circumstances. &gt;Backtraces make debugging super-easy, instead of having to var_dump error messages from a getErrorMessage() function. WTF? What kind of neanderthal way of debugging is that? If you want to debug, use a debugger. End of story. &gt;"My code looked like it was working, but I guess I just missed a case in my switch, or the class changed its constants, but actually it was broken on production." &gt;Not with exceptions you wouldn't. Honestly, Phil. That's an amazingly pathetic argument. You do realize that I could easily flip that around and apply it to exceptions as well, despite you claiming it couldn't be done? I mean, come on. The entire bottom half of your response made me feel like I was back in the sandbox again. If we can't hold a level which is higher than two kids going "nu-uh" at each-other, then why bother? 
No love for php -S ?
Doh nice catch - thanks. Comprehensions will definitely be a nice addition as well.
I would guess that something is not running, something broke, or your previous installation was screwed up. If not, wow.
[Be afraid. Be very afraid](http://incompleteness.me/blog/2007/10/29/web-application-security/). &gt;Am I being too oblivious in using a framework and expecting security to be taken care of with their form &amp; security modules (I feel like I am)? Frameworks won't take care of everything for you. You do need to be concerned about these things if you wish to properly secure your website. &gt;I know my MySQL is safe Using prepared statements? &gt; but what about login sessions Unless you're regenerating that session id, you're probably vulnerable to session fixation attacks. &gt;and other things like XSS HTML purifier would take care of that job. &gt;and all the other acronyms? Read up! Read, read, read and never stop.
Give PHPStorm a try. It's much faster than netbeans (and even faster with PHPStorm 6 just released). It's a great tool for any web developer that works with PHP to have. 
Yes, using prepared statements. I am not sure on how the session is handled since the framework is taking care of that, I imagine it is doing at least what you mentioned but that is something I intend to verify asap. Off to reading! :) Thanks for the link
escape your output to prevent XSS. Use prepared queries properly to prevent injection, use a user specific token to prevent csrf. i havent used symfony, but im sure it has things in place to prevent these [this book](http://www.amazon.com/Essential-PHP-Security-Chris-Shiflett/dp/059600656X) goes over these. its a little dated but im sure the info is still good.
&gt;I imagine it is doing at least what you mentioned but that is something I intend to verify asap. I wouldn't bet on it, tbh.
&gt; ^ All exceptional circumstances. If an email being invalid is meant to be handled by the application validation, and the from missing is handled by the package, is that not validation for both? How does one suddenly get elevated to this special "exceptional" level? This is the same in an OAuth 2 server. Missing a scope, missing an access token, an access token being invalid, no token being set, they are all exception problems that need to stop the flow of the application and be handled nicely if at all possible. &gt; What?! No, they're a fundamental part of object-oriented fault handling. Oh if you're going to be pedantic about this. Obviously Exceptions themselves are not optional, but their usage compared to "if(getErrorCode)" stuff is. You can use either. Thats obviously what Iwas talking about. &gt; Exceptions aren't for displaying errors. They're for notifying your code that something went bad, so you can handle those circumstances. Obviously they are not for displaying to END users, but users of a component like this. I am a sentry user, and I like seeing an obvious error smashed into my face instead of forcing me to go hunting for it. Really, I think you're picking on semantics in a bid to rip my point apart. The point is, either way is almost identical and is basically just personal preference, my preference is to use exceptions to handle error feedback from a class, and its the preference of the package author. 
Just wondering, what does this do : `$this-&gt;_persistentFilters = !!$persistent;` ? I'm guessing it casts $persistent to bool, but why not use `(bool) $persistent` ?
I know that the symfony/form package adds the csrf token (my forms won't work if I specifically exclude the csrf token from it), so that's good. Probably more I need to be aware of in the grand scheme of things, though. Thank you for the link to the book, I read that one a couple years ago but should probably look through it again to be sure I have everything committed to memory. Thanks!
The article also forgot to declare `$selectedTracks`, in the same closure. And there's a confusion between " and ”: the latter is not an ASCII character, and that's why the code online is invalid and not highlighted. Lastly, I always feel bad when plain anonymous functions are called closures. I know that the internal PHP implementation uses the same structure for both, but the concept is still different. I feel that using the right terms is even more important when the author has a BS in computer science.
Happy to see the docs are finally out! It's been annoying developing having to go through the .md files. :) Sentry has been fantastic. Switching from CI/Ion Auth to Laravel/Sentry has been great.
&gt;If an email being invalid is meant to be handled by the application validation, and the from missing is handled by the package, is that not validation for both? How does one suddenly get elevated to this special "exceptional" level? I can't even parse this sentence. What?
Yeah changing that key in the source to blanket invalidate and implement new crypto application wide would be... easy.
What framework, by the way?
Are you criticizing the use of static methods in general or the way they're used in this case? Just curious.
Symfony - I searched and found a number of different bug reports where they have ultimately patched security issues related to session fixation in their framework.
lol
Ah, I see. So you can create two instances of a static if its a facade since the underlying method it references is an instance method? Is there ever a justification for using a static method (that's not in a facade) then?
If you're just changing a key in a conf file for your session management it should be as simple as a push or commit to staging and running rsync or puppet. Sounds like you're suffering from a case of Enterpriseitis to me. The bottom line is PHP sessions suck, and you should avoid them. G'day sir.
&gt;So you can create two instances of a static if its a facade since the underlying method it references is an instance method? The facade is irrelevant in this case. The facade is merely a holder for one specific instance. If you want another instance, you have to create one using the underlying classes. You can't do it with the facade. &gt;Is there ever a justification for using a static method (that's not in a facade) then? There are, however their use cases are rare. 
Great, thanks for answering. I'm trying to learn more about design patterns and best practices these days, so this has been helpful.
*sigh* I don't know why people always think crypto is the answer to everything. PHP sessions do not suck. In fact (especially when used with memcached), they're efficient, simple, and just work.
Sorry to break it to you, but a dev who thinks using exceptions for flow control is a personal preference and generally doesn't hold programming best practices in any regard is going to turn a lot of people from even having a look at their all-inclusive mission critical security library. Edit: Nevermind, just realized Phil is not a dev, just a user.
Thank you for the good idea :)
Postgres if you can do it, otherwise MySQL will suffice.
Part of the problem IMO is the laravel tag on SO isn't particularly busy, and there don't seem to be many knowledgable people answering questions there. Perhaps with the release of L4 that will change.
damnit, I wish Centos's repo's would let me go past 5.3.3. I'd upgrade myself but I just don't have the will to mess with it.
Clearly there's more to it than that. Previously they had a plateau for most of the day with a drop for a couple hours. Now they have a spike that corresponds with the time the plateau used to start. I'd guess they are now building a lot of caches at the start of their daily cycle, which they weren't doing before.
You are technically correct, the best kind of correct. So let's say the "query string" is everything from a question mark up to a possible hash.
The will to do what? Type for 3 minutes to compile 5.4? It's not hard, and well worth it.
There's a reason CentOS 6 is still on 5.3.x, and always will be. Red hat fo' life!
I manage a high volume magento build and was able to reduce ram from 24 to 16G and my apache benchmark was still twice as performant with 8 req/s vs 3.5 req/s -- all i did was upgrade php.
I use this one: http://iuscommunity.org/ http://dl.iuscommunity.org/pub/ius/stable/Redhat/5/x86_64/repoview/php54.html
Grr I wrote this post in Google Docs and it insists on using "fancy quotes". Fair point about muddying the water between closures and anonymous functions. Probably should have titled the post like "Using PHP5.3’s new first class functions".
Using the Facades (demonstrated in the very first step of installation of Sentry) allows for much cleaner documentation.
IMO, if you've convinced yourself that a task as trivial as CSV parsing needs to be more user friendly, there's a problem which lies in the abilities of the language or, the more likely scenario, the developer.
Hey now, for all you know, OP could be fairly new to PHP, and if that's the case, any libraries worked on, etc, are good PHP experience. Besides, at a quick glance, it would appear that it could be useful, and anything that saves a developer even a few minutes is great in the end.
I'm not so sure where you got that SE is for communities. Certainly, a healthy community is necessary for a new SE site to be viable, but you don't get a new SE site just because you have a community. New proposals on [Area 51](http://area51.stackexchange.com/) (the SE staging zone) get closed all the time because their topics overlap significantly with existing SE sites, regardless of the level of community support (look at the [Atheism/Agnosticism proposal](http://area51.stackexchange.com/proposals/37472/atheism-agnosticism) for a recent example). SE's goal is to build high signal / low noise viable Q&amp;A sites, not self help, support or discussion forums. Building a strong community is certainly an integral part of the process, and a part of the process I'm extremely familiar with (I'm a community moderator on Programmers.SE and Politics.SE). But, integral or not, saying that "SE is all about creating communities" is misleading. Having a strong community around your favourite framework / language / tool / whatever is great, but in order to get your own SE site there are other equally important factors to consider (fragmenting an already existing community, for example).
It's a more common shortcut in javascript where you're worried about how much data you're sending.
I find it hilarious that you have become so used to reading terrible code that you can no longer read good code. While the example above isn't that great because the variable names are too abstract the idea is solid. The point is that you don't need to understand the how. How you determine if foo is red is irrelevant, you just need to know that the code inside that if only happens if foo is red and bar or things also match. Thus the mental process required to understand why that if branch runs is. * Read the variables. In the bottom example the mental process is. * Separate out the components that make up the if. * Determine what each part does. * Figure out the parentheses because the amount of info in the condition obfuscate them. For added bonus, if you are actually debugging why foo is red then you're now dealing with a single assignment rather than parsing the if condition. Your argument about slowing the script down isn't really valid as the time is so minuscule if you were to actually profile the code the profiler wouldn't even be able to time it. The point about consuming more memory part also isn't relevant as they second you started the PHP process you loaded 25 MB into memory. The extra few kilobytes of memory you will use due to clarifying variables is so tiny you won't notice. If you need to care this much about memory usage you shouldn't be using PHP, honestly. Write a C program that will be a million times smaller. All these things also aren't just some stupid PHP programmers thinking their way is better. It's well documented in industry recognized books such as [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) and [Refactoring](http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1363678787&amp;sr=1-1&amp;keywords=Refactoring).
Based on your mention of Doctrine Collections, sounds like you could have use for this: http://github.com/xi-project/xi-collections
On a vm or bare metal? So you built PHP from source? What version of apache? 
http://php.net/SplFileObject This is already the most user-friendly CSV Reader and Writer you can get.
Did you even read the question? A database connection has nothing at all to do with what he's asking.
This. 5.4 is the most unfriendly "stable" release I have come across from PHP till date. Half of my apps aren't working anymore and the error messages are vague to say the least. I'm really thanking myself I didn't update production yet.
isset($server['QUERY_STRING']) &amp;&amp; $server['QUERY_STRING'] !== '' === !empty($server['QUERY_STRING']) ----------------- /\/\(:any\)/ use #/\(:any\)# for better readability -------------------------- I had a closer look, IMHO it's overcomplicated for sucha simple task 
Looks like it could be New Relic.
I'm glad to see it's not all sarcasm that 5.4 breaks apps but actually manages to get some performance improvements!
V4 gave me errors out of the box during installation. I know it's beta but why launch like that? I'll stick to V3
The regex gets passed into a larger regex. Thanks for the empty though, missed that
That's perfect English.
Looks good, cleanly written and understandable code. But I think it's missing some important points: - ::parse() loads the whole file in memory. There is no point on doing such a thing (thing about importing a massive CSV file into DB in batches -- not doable with this class). - No iterating capabilities. Seriously. A CSV should be an Iterator which loads one row per iteration. 99.99% of the time I'm loading a file and iterating over its rows in some way or another. Also, some design decisions I don't like: - It seems to do some memory management which is absolute not a CSV file's business. For my taste *clearly* out of the scope of this class. - It follows a singleton pattern that creates one single global instance per file. But really? Are you going to use the same CSV file across your entire application? I don't think so (I also hope not). It shouldn't be a singleton. Just a simple instance created, used and destroyed on the same spot. This is meant as constructive critique. I've been dealing with biggish CSV files in PHP for *years* and have some curated classes and tools to deal with them. Unfortunately they're closed/proprietary code property of my company.
Take a look: https://github.com/dracony/PHPixie/blob/master/system/classes/route.php
&gt;and the from missing is The hell it is.
Yes I did.
 RewriteRule ^/([^/]+)/([^/]+)/$ index.php?p=$1&amp;action=$2 [L] The carrot ^ at the begging starts the regular expression and the $ closes it. Inside the expression, `[^/]+` means match anything except a slash at the start of the string with one or more occurrences. So * `//foo/bar/` will not match because of the slash in the first expression * `//bar/` will not match because there was nothing inside the first expression * `/foo/bar` will not match because the last / is not there * `/foo/bar` will match 
&gt;PHP 5.4.12 &gt;centos 6.3 &gt;apache 2.2.24 &gt;Cpanel::Easy::Apache v3.18.6 rev9999 built with easyapache on a dedicated server. ive been upgrading since 5.4.8 last fall.. and so far the only release that gave me a hard time was 5.4.9 --broke all my extensions.
Thanks for the down vote! Now here's something to think about that shows that I'm not trying to be a dick for no reason. You can compile php on your own and actually have multiple versions on the same server. You can have them run concurrently and move each site over individually as you have time to test for bugs. It goes beyond keeping up-to-date. It's about human responsibility as well. Think about the extra electric that's being used to run your CPUs on your servers at a higher frequencies for more time. I work hard to make sure my applications run as fast as possible, not just for user experience, but because I'm saving electric as well. Not upgrading is doing you, your customers, and the world a disservice. I know it sounds silly to think of it that way, but it's the truth. Developers making poorly written code DOES have an environmental impact. Maybe not much individually. But as a whole, there is a lot of waste in the development. 
&gt;The request method is no route, it's a request method. A route can be anything. It's function is to route to different code based on the supplied criteria. &gt; "/mysite/article.html" is a case for a route. That's a path, not a route. &gt;The route itself doesn't care much by which request type it's accessed by. It most certainly can. There are many routing engines which do provide support for request method-based routing, and could be useful for, say, RESTful controllers. &gt;Also it's not an MVC, it's a VC, it lacks a model. It's a MVC *framework*. Models represent your business logic and it's up to you to implement those. &gt;I recommend getting familiar with this: &gt;http://en.wikipedia.org/wiki/Front_Controller_Pattern He's most likely already familiar with it, seeing as he built a URL-based router, which has a front controller as a prerequisite.
Who knows? The spikes used to last for 20 hours, now they last for one hour. That's a totally different load profile.
Really? Short of things like Drupal or Wordpress (thanks to bad coding practices) 5.4 has worked fine for me.
Thank you for the feedback and the links - I will bookmark your site, looks to be a great source of information I am looking to keep up to date on. :) I know that I'm running blind a little bit at the moment, since I haven't scoured through the Symfony code enough to know the answer to my question. That said, everything I've read both up to using Symfony and more importantly, since making this post, and it looks to have strong security measures out-of-the-box. For example you have to go out of your way to not encode output, and it is not really possible to use non-prepared queries, csrf built-in, etc. Certainly no reason to take all security measures out of my mind, that will just leave me open to problems with my own code. I'm going to schedule a large block of time each week to start delving in to the inner workings of the framework to be sure everything is kosher, and if not - I can take appropriate measures in my own code beyond what I already have, and come out far better for it either way.
&gt; The extra few kilobytes of memory you will use due to clarifying variables is so tiny you won't notice. What about when you have 1000 page views an hour, or 10000, or more. Memory adds up especially with web apps that can have a lot of users. As for the other stuff I'm totally capable of reading "if this and that or that do this" when it comes to if statements. I don't need all those extra variables and they come off as amateurish. Comments are easy and don't use memory. Also I personally think that declairing variables half way through your code just for "clarity" is bad practice. Variables should be declared at the top. By using a variable for documentation you've now created a singleton variable that's nothing more than a waste of space and more work for the garbage collector. Singleton variables are bad practice.
[Remi's repo](http://blog.famillecollet.com/pages/Config-en) or [Zend Server](http://www.zend.com/en/products/server/free-edition) can help with that. I ran Zend Server on my production boxes just to get 5.3 when CentOS refused to upgrade from 5.1, and it worked great. Since I was just interested in the PHP upgrade, I didn't need all the support of the paid version. 
I think he meant, &gt;If an email being invalid is meant to be handled by the application validation, and the "From:" missing is handled by the package, is that not validation for both? How does one suddenly get elevated to this special "exceptional" level?
&gt; That's a path, not a route. this is like saying: this is water, not a fluid. A path is a type of route. I agree on the rest and have to admit that i just took a very rough look into the framework. 
I'm probably going to be downvoted. But seriously, your time is better spent changing hosting provider than to develop on the unsupported and quickly decaying PHP 5.2 &gt; platforms. That said, your code looks good and well documented.
That's the thing, we just cannot change providers. He already has a codebase he got from a random freelancer, and by the looks of it the whole thing can collapse if we change versions. I'm tied to this until I can convince him of moving into the present and rebuilding the whole codebase.
That's the most useless graph without any context what so ever. As other have stated he either broke something or lost traffic (notice how it's Sunday-Tuesday and not Week .vs Week too) 
Yeah seriously! I managed to get it working again easily (probably due to "ok" coding practices), but when I just updated it, most of the standard apps using the same core all didn't function anymore. *Update*: I keep getting this error more and more though; Warning: Creating default object from empty value in ... Which consists of the following code: $user = new User; $user-&gt;FindById($session-&gt;getID()); $data-&gt;user = $user; I know the fix; it's adding a "Stdclass" definition to $data, but I just find it odd that it's making such a big hassle out of that.
For those interested, from the [conversation](https://twitter.com/juokaz/status/313636684333973506): * Everything still runs "as it should." [[1]](https://twitter.com/juokaz/status/313913831720091648) * Nothing else was "changed." [[2]](https://twitter.com/juokaz/status/313759962436345856) * Upgraded from PHP 5.3. [[3]](https://twitter.com/juokaz/status/313640782135427072) * APC is enabled (but its mostly irrelevant). [[4]](https://twitter.com/juokaz/status/313759929234231298) [[5]](https://twitter.com/juokaz/status/313638350328315905) * Load is mostly server-side/CLI/worker code. [[4]](https://twitter.com/juokaz/status/313759929234231298) [[6]](https://twitter.com/juokaz/status/313829207279026176) [[7]](https://twitter.com/juokaz/status/313760038965612546) [[8]](https://twitter.com/juokaz/status/313639116564754432) [[9]](https://twitter.com/juokaz/status/313915186861977600) * Load is "the same" every day. [[2]](https://twitter.com/juokaz/status/313759962436345856) [[8]](https://twitter.com/juokaz/status/313639116564754432) * Exact source of performance gain is not yet known. [[9]](https://twitter.com/juokaz/status/313915186861977600) All that being said, there's some (probably unrelated) issues with network performance. [[5]](https://twitter.com/juokaz/status/313638350328315905)
A few things narrow it down. The first line wouldn't throw the error, because PHP won't allow you to use a class that doesn't exist. That will result in a fatal error. So line 1 is fine. Line 2 wouldn't be the issue because you are calling methods on objects, and stdClass doesn't allow methods. You would get a fatal error stating that there was an undefined method, so both `$user` and `$session` are valid classes. That leaves line 3. You don't show `$data` being defined anywhere, and that line is perfectly valid PHP syntax. The engine generates a new class and assigns the `$data-&gt;user` member the `$user` object. The warning should tell you exactly what line is generating the error, but my guess is that it is the `$data` object not being instantiated as an object before use. `$data` needs to be an actual class, or needs to be created as a stdClass before you use it.
Exactly what I said myself ;). Now I'm still figuring out a nice way that keeps a clean defined $data = new Stdclass; at the beginning of every page, but it's been bugs like these that just make it feel like a very unfriendly update.
you probably also want to look at functional php https://github.com/lstrojny/functional-php
"by the looks of it" Have you actually tried? Copy the codebase and data to a 5.3 or 5.4 installation, and run it. Find out what problems, if any, there are, and work from knowledge vs guesswork. FWIW, I had far more issues moving from PHP4-&gt;PHP5 vs between any 5.x versions. I went from 5.2 to 5.4 without any issues at all.
A few things on upgrading: * You lose the support of your distribution if you compile yourself. * Just compiling the software isn't upgrading. To 'upgrade', you need to deploy and test-- which takes much more than three minutes. * Even when compiling, you probably need to pull development libraries, perhaps some that aren't already on the system. * You may be able to run multiple versions at the same time using CGI/FastCGI/FPM, but some applications still use mod_php (for good reasons, some which include saving CPU cycles) which isn't able to run concurrently. * Switching from mod_php to the other methods should have a deployment plan as applications CAN and WILL break. * FPM support before Apache 2.2 is... limited-- upgrading or switch web servers also should have a deployment plan. * Your second comment, IMO, does not deserve a downvote because even though it isn't always practical to always upgrade: its right. Random notes on power consumption and performance: * If you run multiple versions of PHP on your servers, that leads to higher memory usage; it may be more optimal, power-wise and performance-wise, for that memory to be used in other processes (like the database) * Using non-system libraries for PHP (say newer versions), also leads to higher memory consumption which may better be used in other processes. * You may save power later, but don't discount the additional power you use compiling PHP more often.
That's why you never want to upgrade your PHP without first going through [their migration manual](http://php.net/manual/en/migration54.php) step-by-step.
I think that's the first time I've heard of upgrading from php 5.3.3 to 5.4 as being a humanitarian thing to do. You're not wrong but in the end we're all human and there are only so many hours in the day. I need to spend those on certain things and at the moment that's not spending a few hours upgrading. When it comes to the repo, I'll bother with it but until then my times already bought and paid for on other projects. Note: I didn't downvote you. 
I've always liked logging gin.
I was wondering how long it'd take to get one of those.
It's worth saying this again. &gt;Have you actually tried?
http://phpsec.org/projects/guide/ is a nice overview of PHP security.
Ah okay, I see what you mean.
I agree with the others here. Try it! Just make sure you turn off E_DEPRECATED warnings.
This is hit and miss. Unless you're running a testing suite against your code issues may not manifest in obvious ways. You can't really compare your migration experience with his because your code is likely nothing like his.
If you're not running it through a staging environment, you're doing it wrong.
I know it's not SEO friendly, but right now the app is just a mockup. You were downvoted because your answer had nothing to do with the question. I just wanted to know what the key-value pairs in the query string were called.
Its ridiculous over optimization worrying about the temp variables. You obviously need another server if this is a factor. You write your code for the person who will follow you after you get hit by a bus, not for yourself. The fact that you called it amateurish looking to me sounds like you havn't actually picked up other people work. Amatures are the ones that like stupid cryptic one liners cause they think its cooler or whatever, most people starting out code like this since it seems better to do the same stuff in less LOC. Unfortunately 99% of the time the human readability cost outweighs the computational gains by a large margin. Like it was said before, if this is somehow a problem with your app, write a C extension or use another lang or get a new box.
So, to address the great critique: - I am a front end developer, so that !! slipped in there. Using (bool) is indeed preferable. - It's not that I'd use this class in production myself. Indeed, I'd stick to using fgetcsv combined with one big cleanup while iterating over the file. - The reason why instances are introduced is because the original project owner was silly enough to choose csv over ini when storing configuration data. This way, calling for the CSV instance across scopes and namespaces would actually have merit, although it's a rather edgy thing to have. - About the memory management. Yeah, well, the reason it's there is hugely because of the audience the whole project is catered to, being fresh PHP kiddo's. I actually don't condone models deciding on memory management themselves, although one could turn that off. I'm actually branching off with this fork to let the original project make use of some of the useful code, as I got bored of waiting 2 weeks per pull request when helping out on the original project. In fact, all open issues on the original project should be solved in my fork. OP hopes to have cleared things up for you guys.
There's no doubt bugs can be introduced with new versions. I've been working with PHP and upgrading since 1996, and have hit a few snags. This idea that it's better to stay put vs upgrade has *some* merit, but not so much when you're also actively developing new functionality against legacy code. If there's no test suite, writing new code can be similarly dangerous. If there's a testing suite, or at least a testing procedure that is run through, then test out the code on a test environment and run the tests there. I was more reacting to "by the looks of it" - it doesn't read like there's been an attempt to upgrade, just "we have to stick with php 5.2". If you know *why* you have to stick with 5.2 - because there's some known bugs that were introduced, it's probably still worth it to isolate those, write tests around it, upgrade and patch, vs. writing 'new' code for a legacy/unsupported version of PHP.
Yeah, I'm not so much advocating never upgrading - I'd instead advocate caution while upgrading. Thoroughly testing applications in a staging environment is an absolute must if you're going to jump ahead by several versions. In any case, I agree with your clarified statement.
Actually, you could combine columns, however if you use fetchColumns() there is no logic to reduce/change the column names. Feel free to create a pull request.
Although you make valid points, keeping the CSV in memory and disallowing iteration over the Csv class are partly by design and partly because of an unfinished implementation. Your points are kind of tied to eachother, which is self evident after you read [my previous explenation](http://www.reddit.com/r/PHP/comments/1ajrkt/coseva_a_user_friendly_csv_parser_in_php_fork/c8ynqpq)
Be sure to check out http://guzzlephp.org/ for inspiration. It may not be exactly what you are looking for, but it is a widely used PHP library that has a simple and clear API for making HTTP requests.
vagrant + puppet configured to match your production environment as closely as possible.
From a quick view it seems as though they are a bit more in-depth of an API then I'd like to create. I'll definitely look at it further. Thanks for the link.
The way you explain it is if the table is empty. There is no non-hacky way of doing this. What you could do however is first checking if the table is empty with SELECT COUNT(*) FROM tname. If you want a better answer, we could probably use some context. This is generally not something you need to achieve in the SQL world.
First of all, why functions (Requests\Request, Requests\Get, etc) and a simple constant? Why not classes? It would be easier to use with autoloading and more extendable. * http://bit.ly/14alxtD return boolean value ? true : false * Too many array_key_exists checks. [Here](http://bit.ly/ZsJac7), for example, you can pass ['auth' =&gt; ['user' =&gt; null, 'pass' =&gt; null]] and it will generate a wrong auth string ":". Not to mention you're not checking the 'auth' key itself.
I've never tried logging it, but drinking gin is always fun. :)
insert into table select 1, 2, 3 from any_other_table_thats_not_empty where (select count(1) from table) = 0 limit 1; depending on database this kind of approach would work if you want to use a one line solution.
COUNT(1) is enough, but COUNT(primary_key) is necessary for proper counting on left/right/full joins.
Look, I'd personally like to stop dragging this further in that direction, mostly because you're basing your statement in a theoretical that has no basis, and no place to happen in the short term BUT can be conceivably tried later on. Let me finish this point off so *hopefully* there's a topic to return to. There's no basis for your speculation that 'everything could be OK' because you've, for obvious reasons, not actually made even a cursory inspection of the project's context, contents, requirements, or current running environment. You've only taken issue with my own cursory evaluation of code *you can't possibly have asessed* in apparent hopes that everything will be fine and the constraints that we've inherited don't exist. That won't happen, because code on this thing is right now like this: grep -r "ereg\|split\|=&amp;\|@my" . | wc -l 319 Which is what I mean by "the looks of it", among other things like no serious front controllers, has no folder-centric modules, opting instead for having up to hundreds of functions like this on each file: function module_submodule_actualFName(){ global $file_name; require "$file_name.php"; //and having func_get_args() in that file for some reason } grep "function" inc/usuarios-alta.php | wc -l 103 grep "require" inc/usuarios-alta.php | wc -l 41 **That** is what I mean by "the looks of it". **That** is what we currently have to work with. We also have an **extremely** tight timeframe making me allocate most of my free time, which is all I can dedicate to working in the project. This then means that the way the project **is** doesn't leave much room for 1. raising a 2nd test environment different from what we currently have, 2. branch the existing code, make tests for all that could possibly fail, 3. correct all the things that *will* fail, 4. merge that branch back, 5. convince my friend of changing his beloved hosting provider of 7 years for another one, 6. change DNS, and still make it to deadline. So, since I **cannot** just "go ahead and try", I decided to make my own set of tools. One of which is here. And I'd personally **love** it if you could lend me a hand in making it up to par with an actually modern solution, so that any other people who see themselves in a situation similar to mine might actually have something to work with, instead of the shitty available solutions I've seen. Please?
See http://www.reddit.com/r/PHP/comments/1ala6w/a_php_authentication_framework_for_php_53/c8yp8q9. We can't afford to do that until this thing is feature complete in its current environment. 
Is this table only ever supposed to hold that one row? Then just add a primary key column with a zero-length not-null type.
Okay, more information then. I am trying to create a booking system where each day has 100 slots lets say that you can book. Each day is a table in the database. Today is day 83. At runtime it needs to create the table for that day. It then needs to fill out 100 rows with the 3 bits of data $a, $b and $c. When this code is run again on the same day - rather than overwrite the current table with the 3 bits of data $a, $b and $c again it should skip over that table when it sees there is data in it already. I do this with tables using IF NOT EXISTS. But I can't find the same thing for actually filling out the tables with data in the first place.
I think it's worth nothing that pure MVC can't be done in PHP
yup i know, but your question was already answered. 
Wow... Because there's no front controllers, you can't move from PHP 5.2 to PHP 5.3 ? You didn't make any of those deadlines clear in your initial post - it was "hey, it doesn't look like I can upgrade this code, so I'm going to write a bunch of stuff aimed at PHP 5.2". As painful as migrating to modern/supported PHP may be, I'm not even talking code architecture, just the runtime language, it will need to be done at some point. You're punting on it, but also make the problem worse by writing *more* code that may not be forward compatible. Again, FWIW, I've personally not seen any issues on code from 5.2 -&gt; 5.3/5.4, but that doesn't mean it couldn't happen. My bigger issues were 4.x -&gt; 5, because the entire XML suite of functionality was removed/replaced. ereg is *deprecated* in 5.3, but will still work - you'll just get a bunch of notices when you use it. Again, to the point before - how do you go about making what I might consider to be a rather large-reaching change - an entire authentication framework which will presumably touch or at least affect how much of the system functions - without testing things? If you've got testing time for those changes, you probably would have time for more serious structural upgrade changes too. I didn't initially bring it up, but agreed with the first top-level comment about upgrading. Again, loads of presuming on my part going on, but if you don't have time to do things right now, you probably won't in the future. The people making deadline and deliverable decisions *probably* don't care about software versions or supported stuff. The fact that you've now written an auth framework that works with 5.2 will further cement the notion that you can keep going as you've been doing for a while longer. I saw similar stuff happen with PHP4, and Java upgrades - people are still using 1.5 stuff out in the wild, and can't take advantage of even remotely modern libraries. I've no issue with that fact that you made those tools. I feel like you don't have the negotiation ability to avoid these sorts of situations in the first place. Granted, you may still have 'rolled your own' in the first place, but part of your motivation was being stuck on 5.2 in the first place. Rolling your own because nothing fits your exact needs in general is OK, but when those 'exact needs' are artificial constraints brought about by poor management, it makes the situation worse vs better. As to critiques of the code, I'll post another thread.
It looks like a really cool tool. I'm going to check it out for sure. I'm super lazy about writing tests. This looks like it could change that!
Then you might want to check out [Buzz](http://github.com/kriswallsmith/buzz). 
Honestly, now that I've got it up and in kind of a working condition, I plan to keep using this and possibly some other utilities in the future. It's kind of trivial to package it and reuse it with actual modern PHP, and I kind of like the way the method signatures turned out. 
What makes you think a table per day is a good idea? Why not have a field called "day"
I would consider separating the response headers into their own thing and not coupling them so tightly to [responses](https://github.com/lonnylot/requests/blob/master/lib/Requests/Response.php#L57-L58). Just because it would be need to have python's `get` and `setDefault` methods and something that behaved more like an array -- `foreach ($resp-&gt;headers ...)`, etc. Or maybe you want to make response header arrays immutable. Or aware of the possibility that a single header key can have multiple values -- check out Werkzeug's [`Headers`](https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/datastructures.py#L808) object, for instance. It would also be nice to have [`raise_for_status`](http://docs.python-requests.org/en/latest/api/#requests.Response.raise_for_status). Use of [bare exceptions](https://github.com/lonnylot/requests/blob/master/lib/Requests/Session.php#L85) bothers me. Maybe just personal preference, but just throwing a plain old exception doesn't leave much opportunity for fine grained error handling. I'd rather see a library have it's own set of exceptions, each of which is for a specific purpose, that can be caught and dealt with in different ways. You can use an interface to accomplish that (ala [AWS](https://github.com/aws/aws-sdk-php/blob/master/src/Aws/Common/Exception/AwsExceptionInterface.php)) or just create a base exception class for your library.
this made me cringe.
&gt; Each day is a table in the database Is there a reason why you chose this approach? I'd think that a single table would be much easier and more maintainable. Such an approach would require two columns: `date` and `slot`. You would create a `UNIQUE` key on both of these columns to ensure that each slot can only exist once per day. (If your data maps to a 10x10 grid, you would want `date`, `x` and `y` columns, creating a `UNIQUE` key across all 3). Let's say you also have a `name` column, for storing the name of the person who booked that slot. You can reliably set their name to that slot using this: INSERT INTO tname (date, slot, name) VALUES ('2013-04-01', 12, 'Jane Smith') ON DUPLICATE KEY UPDATE name = 'Jane Smith'; This will create the new slot for that date if no such slot exists. If it did exist, a standard `INSERT` would have caused a duplicate key error. However, because of the `ON DUPLICATE KEY` part, it will instead change the name to Jane Smith. Therefore this query can always be used to add/update the slots. This works even if you create the slots in advance (which should probably be avoided, unless there's a good reason for it.) Would an approach like this work for you? If not, why? --- **EDIT:** I'm also curious as to why you're using "slots". If the available slots represent a fixed, 1-dimensional list then it should be okay, provided those slots aren't of varying sizes or quantity. For example, a numbered slot wouldn't be best for appointment times as the duration could vary, or more employees could serve more customers, meaning more available slots. Could you provide more detail on what the slots actually represent? --- **EDIT 2**: Do your tables only store a single row per day? If so, you'll want your table to look like this: * `date` (`date` type, `UNIQUE` index) * `a` * `b` * `c` This will ensure only one row can exist for each day. This query would only insert the data if the date doesn't exist (without throwing an error): INSERT INTO tname VALUES ('2013-04-01', 1, 2, 3) ON DUPLICATE KEY UPDATE a=a; The `a=a` bit is just a hack for MySQL to not change the data.
MVC in web applications can mimic the general principles of the same in desktop applications, however, it is difficult. PHP, however, is not designed to follow an MVC approach. It gets better though, I've seen at least a dozen definitions of MVC, especially where it comes to web applications. Although if someone tells me that the model layer is a model class, I will promptly eval() their understanding on other principles.
Cannot agree more with your first bullet point. Anytime I see that I just roll my eyes.
&gt;MVC in web applications can mimic the general principles of the same in desktop applications, however, it is difficult. PHP, however, is not designed to follow an MVC approach. No language is designed to follow any design pattern. Design patterns are merely applications of the language. PHP has no problems implementing MVC to the same degree that any other web-based language implements it. Additionally, you can implement desktop-kind MVC in PHP without any issues as well, which you can utilize in, say, PHP-GTK. 
True, no languages were based on patterns, however, the development of languages are heading towards designs. Designs exist to solve problems. Most things nowadays are inspired by MVC, in fact you'll most likely no see anything that's completely true MVC. In true/classic MVC, the view is stateful. Web MVC doesn't permit that. You need a persistent model layer, the model layer should be able to inform the view of any changes (el Observer pattern). The closest MVC implementation and abstraction I've seen in PHP closely resembles that of Model 2 in Java or even MVP.
I have personally found that PHP isn't like Python. Stuff from different PHP versions usually just work. It may complain that stuff is deprecated but will still work. At work we are using Python 2.5 and Django 1.1 - we attempted to use a later version of Django and it just puked. Hell I still have something written in 4.x that runs great to this day.
Yes. If this is going to be handling concurrent operations you would need to involve some locking.
It has already been done: http://requests.ryanmccue.info/
&gt;In true/classic MVC, the view is stateful. Yeah, and HTTP is stateless. I don't see why you wound find something which applies to a different domain not working outside of it as noteworthy. MVC in web applications is an adaptation of the architecture found in desktop programming, and is used to achieve separation of concerns, not statefulness in views. Additionally, there's no clear-cut definition of what MVC is, and interpretations vary. 
Holy damn this landing page slideshow is ridiculous. It's frustrating to skip, and involves a scantily clad woman saying she likes to have fun, not something I want appearing on a work monitor.
Lol, you really think I should mark a vector drawn fairy as NSFW =) ? You must have a very vivid imagination =)
her tits aint that big =) The skirt might be longer though.
Your autoloader search every module directory for the autoloading file. Why not use [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md)?
HTTP Authentication? **EDIT** Oh, I'm fucking blind. I thought you were asking what you could use for authentication for &lt;PHP5.3
I would imagine ArrayIterator would be a better choice to use with this than the legacy array_* functions, right?
Not bad - I had a brief look over the code. Good to see you saw the absolute focus of requests is on the API. A couple of suggestions: * The "magic numbers" for methods types (GET, POST) etc... are uneeded and makes code like [this](https://github.com/lonnylot/requests/blob/master/lib/Requests/Requesters/Curl.php#L77) less clear. Instead, use strings like 'get', 'post' (just internally, remember you have the named functions wrapping them) which will also allow easier extension to handle other methods. * As mentioned, [this](https://github.com/lonnylot/requests/blob/master/lib/Requests/Requesters/Curl.php#L35) is not needed and made me take a second look at it to make sure I got it properly. Just return the value of the function, or prefix it with a '!' if you need to invert it. * I like the new [new-style array notation](https://github.com/lonnylot/requests/blob/master/lib/Requests/Api.php#L30) but if you left it out, could it be 5.3 compatible? * Good [use of SPL](https://github.com/lonnylot/requests/blob/master/lib/Requests/Api.php#L30) interfaces to simplify the API, but could that data structure just be an array? * I like the proxy functions around the Request function (like Python does it). Some won't. The practice is more accepted in Python than PHP but I see no reason for them to be classes, at this stage.
Code: I would suggest not using "Auth" as shorthand - you're doing access stuff (canAccess()) which implies to me "does this agent have *authorization* for this resource?". Auth could mean authorization or authentication, and to add to the confusion, the two go hand in hand most of the time. 
Doctrine2's ArrayCollection class actually has a handful of useful methods - http://www.doctrine-project.org/api/common/2.3/class-Doctrine.Common.Collections.ArrayCollection.html Unfortunately, we're stuck on Symfony 1.4+/Doctrine 1.2+ for a couple of projects :(
In the time it took you to write that comment, i could have put your app on a 5.4.x build and known for sure.
honestly, i couldnt say 100%. my advice would be to run some tests, depending on all your settings (like caching, indexes etc.) and how big your table is will effect the outcome, on your myisam tables, count(\*) **will** be faster, by how much i don't know
A small thing, use INSERT INTO tname (date, slot, name) VALUES ('2013-04-01', 12, 'Jane Smith') ON DUPLICATE KEY UPDATE name = VALUES(name); The VALUES() function after the on duplicate grabs the value that was to be inserted. It saves a little query parsing time and keeps things a touch cleeaner. Edit:// Saves*
Thanks for your feedback * Changed to strings * Removed - 'twas a case of over-thinking what I was doing * Most likely - I suppose there is no real reason for 5.4, I just didn't want to be tied to anything less. I'll take a look again tomorrow and test it out on 5.3. * I'm not sure what you're referring to here. Is the link accurate or are you referring to \Requests\Headers? The reason for \Requests\Headers is to prevent changing the values of the array after they are set. Thank you very much for your feedback!
I think the way it currently is allows for you to use the function API or access the classes directly. You're free to instantiate or extend the \Requests\Session class yourself anywhere you'd like. The advantage of the API is it is a little cleaner - IMO. * Thanks for pointing this out. Silly mistake of being caught up in what I was doing. I fixed it to just return the value of the function. * I suppose I'm not actually checking that the data is valid, just that the structure being passed in is valid. The library expects you to make sure the data is valid.
He's not going to see your message if you reply to me instead of him...
This is definitely a chainsaw question
As mentioned by FineWolf, I've actually [done this previously](http://requests.ryanmccue.info/). I'd love to have us work together on this, since Requests for Python is awesome, and I think we need that for PHP.
PHP mess detector does - http://phpmd.org/rules/codesize.html 
It's "bugs" like this that illustrate bad coding practices
It doesn't matter what column you count if the engine does not keep row counts. You should never use count() without a very restricting where clause in the case of innodb. In engines that do keep row counts it still doesn't matter if you use count(*) since MySQL will just use any index available.
&gt;I decided to not use this pattern based on testability. You decided against method chaining based on testability? What?
There are no problems with chains at all, look for example at [configuration class](https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/DependencyInjection/Configuration.php) My library just replaces original class with decorator, but original method is still present and you can put a breakpoint in it to test it with XDebug. Additionally, FluentInterface marker for class can give you information that all setters can be chained. AOP it's a functionality injection pattern, like services with dependency injection and there are much more possibilities with AOP, so I have plans to write more articles about strict AOP in PHP. 
PHP 5.2 is really not a thing anymore.
I do a check on "SLAVE STATUS" which tells me if it is replicating and the number of seconds behind the master. It isn't 100% accurate though. The one case that I'm aware of when it is wrong is if replication begins after a crash and the tables are still be repaired. In that case it will tell me that it is 0 seconds behind. That is a rare case (at least for me) though.
This blog post describes how to automatically sharpen images, blur images and blur only detected faces in photos. Image manipulation is performed seamlessly in the cloud by Cloudinary. PHP sample integration code is included. Disclaimer: I'm one of the co-founders of Cloudinary. 
Why is this not simply a library? Why is this SaaS? Smells needlessly enterprise-y.
Being a service, it's language-agnostic. Difficult to do with a library. You don't need to handle persistant storage or CPU requirements. See http://cloudinary.com/features Disclaimer: I have nothing to do with Cloudinary, but I know them from appfog. 
Right on. Your library is great, no reason to make another.
It might be handy if you include a section on how this tool differs from PHP Doc, ApiDoc, PHPDoctor, etc so users know why they should use this over something else.
Because every method in the chain requires the previous call to return the object. So I cannot mock the object completely (disabling all methods) without PHP non-object errors, but have to rely on partial mocking. See Phake::partialMock().
Thanks. Gonna check it out.
Well, it doesn't generate documentation. It generates code in runtime, so the result would change based on configuration and php version. I am using it as alternative to php documentation to find syntax of functions and classes.
just like Netbeans.
Or Eclipse PDT / Zend Studio
Cool - what would be the best way to contact you so we can collaborate? My email is lonny@lonnylot.com
I think this is by far the most interesting feedback I've received. Your first two paragraphs provoke a lot of thought in my mind and I'm going to want to spend some more time on it before making a decision. Currently in regard to the response headers I'm not sure where I want to take this (hence the 'more thought needed'). In regard to the raise_for_status - I think I will definitely add this in. The current state is still in dev and I was just looking for some feedback (like the great feedback you provided) In regards to bare exceptions - again I see your point, but this one I don't need to think about. You're right. Needs to be made more explicit - I started with just the bare exception for dev based on the idea that I want to vet out what types of exceptions I want to throw and it would be better to force people to catch Exception then to catch something that I made up on impulse and change in a later version. Thank you for the great feedback! I really appreciate it!
Cool. I starred the repo. Thanks for sharing... Will comment further if I actually use it :)
I saw "RFC" and "request API" in the same sentence and got excited... I was excited thinking that you had created an [actual PHP RFC](https://wiki.php.net/rfc). IMO, we don't need yet-another-cURL-wrapper, which is practically a rite of passage for PHP devs, but I think what we (as in, the PHP community) sorely need are language-supported API's to work with HTTP transactions. The extent of the built-in support for working with HTTP transactions currently is limited to the superglobals (`$_GET`, etc.) and a handful of random functions (e.g. `get_headers()`), but they hardly form any sort of usable API and are more like utility functionality. Consider that PHP is made for webpages, which are powered by the HTTP transaction cycle; the way I see it, this is a fundamental, core concern of the language. Additionally, all major frameworks provide some sort of request/response API to work with these transactions. If we want to take a swipe at reducing userland code duplication, this is one area that would definitely result in less lib code and more standardized functionality, and should ultimately lead to greater flexibility and portability.
I'm not following exactly what this would be useful for; what problem is it attempting to solve?
your code is correct. you'll have to try different variations to see what the problem is. 1. make sure your db connection is working - try plain query like SELECT * FROM Bookings 2. try a simpler create table statement like create table foo(x int). also, the mysql user may not have create privileges. on a side note, it's time to switch to PDO, mysql_ is deprecated. Also, you may want to use double quotes, then you can put variables into strings like this. I think it's easier to read without the concatenation. $sql = "CREATE TABLE IF NOT EXISTS `$b` SELECT * FROM Bookings"; 
What's the difference between multi-site and multi-domain?
No vhost involvment. My setup is simply multiple directories acting as channels for a University portal.
I gotcha, well that certainly sounds like a fun project (many of my favorite personal projects have no practical use). 
Lack of documentation.
// Never used Laravel in production, just explored some of its code. I understand that you want to setup several virtualhosts &amp; apps to a single docroot? Just set this up: 'app' =&gt; __DIR__.'/../' . $app-&gt;detectEnvironment(array( 'admin' =&gt; array('admin.laravel.dev', 'laravel-admin.dev'), // goes to 'admin' app 'app' =&gt; array('main.laravel.dev', 'laravel.dev'), // goes to 'app' app )), in [bootstrap/paths.php](https://github.com/laravel/laravel/blob/develop/bootstrap/paths.php) file and you're done. Maybe it's not that pretty (not about environments at least), but does the job.
not sure if it helps, but check my similar question on [stackoverflow](http://stackoverflow.com/questions/12782699/installing-laravel-in-a-subfolder/12783467?noredirect=1#12783467) 
I had to move one of these. I spent hours finding and replacing code. It took a week to find everything and test everything. Was a nightmare.
Namespaced functions autoload fine. There is no reason to use a class (especially in this case of simple proxy methods) and doing so would make the api worse. You dont need encapsulation because there is no data or state to hold... they take input by way of its arguments and returns a data structure representing a response.
Really, people shouldn't be coding for the browser or OS. You should be coding for features. Pseudocode: if (myOS == "Windows") { // don't do this… } if (browser.hasFeature("something")) { // do this instead } I can't find any good articles on the matter, but a quick search for browser feature detection should help. Basically, instead of having to know which browsers have a feature doing something like if (browser == "IE" || browser == "Firefox" || browser == "Chrome" … etc) you can just check for the feature you're about to need/use. That said, your code looks pretty nice and clean. Also, +1 for composer support.
You can't determine the real browser and it's version on server side. Your, and most other implementations, rely on the useragent. But the useragent can be easily changed by the user, and often is changed by some browser extensions. If you really want to know the browsers version, use a feature-based javascript analysis, which is more accurate than any server check. Of course, it's entirely not working if javascript is disabled ;) An out-of-date site (and german) but you see the principle: http://www.lipfert-malik.de/webdesign/tutorial/bsp/browser_js_test.html With a little effort, you can extend these javascript tests for modern browsers and get a very accurate result from it. Otherwise, thanks for your work!
There are a few options that could make your life easier without the warnings. 1. Typecast an array. `$data = (object) array('user' =&gt; $user);` 2. Define your own `Data` class, or similar somewhere, so it might stick in your head easier. `$data = new Data;` 3. Similar to #2, you could create a little function to save space. `$data = d();` `function d() { return new stdClass; }` 4. Somewhere in your hierarchy, create a blank `$data` var. Maybe use a class property if you're in an OOP environment instead of a local var, if it's any easier. Lots of choices! :)
Thanks. I totally agree that feature detection should be on the client side and do it this way myself. There are a couple scenarios where a server side library is useful. Namely with language detection, where you want your page to show in the language of the user.
We see this with CMS, after blog, after CMS being released each day. We even had John try the [Wordpress Ghost](http://john.onolan.org/ghost/) project only realize [just how hard it would be to fix](http://john.onolan.org/ghost-from-fiction-to-function/). Personally, after skimming thousands of projects over the past year my money is on A) automattic branching out with a new system (they have the cash to do it), or B) [ForkCMS](http://www.fork-cms.com/) gaining ground since it's the best multilingual system I've seen yet (actually the only decent one).
In that case, I could see this being more useful. 
&gt; Namespaced functions autoload fine. No they don't. Maybe you are considering that sad composer hack that only eager loads. Autoloading is exclusive for classes anyway. &gt; There is no reason to use a class (especially in this case of simple proxy methods) and doing so would make the api worse. Requests\Get goes to Requests::Get. I don't see how that is any worse. &gt; You dont need encapsulation because there is no data or state to hold Maybe you wanted some functions that you didn't care to put in the API. Oh look now you can't with namespaced functions, but certainly can with a class.
sigh This rant kinda reminds of the start of the PHP rants. Something becomes too popular that someone decides that it's 'broken' and wants to throw out the baby with the bathwater and start again.
Yeah already fixed it :). Indeed working OOP so somewhere higher up I've simply defined $data as a Stdclass; Thanks for taking the time to help a fellow programmer out though!
Wordpress IS broken, in the sense that its usage doesn't match the developer's intention. Wordpress's code is horribly inconsistent, jumbled, disorganised, hard to maintain, and often hard to upgrade. The whole concept of "the loop" in Wordpress just doesn't make sense for most people these days. The use of globals everywhere is bad practice. Wordpress doesn't make use of the gazillions of great code that composer has compiling right now, which is a damn shame, as I'm sure they could make some great contributions. Wordpress is constantly getting compromised because of crappy plugins that use $wpdb without escaping user input, for example. The list really does go on...
&gt;Wordpress is constantly getting compromised because of crappy plugins &gt;that use $wpdb without escaping user input, for example. I don't see how WordPress is broken specifically because they enable plugins to use $wpdb without data validation. The plugin system is akin to *caveat emptor* (except for whatever the latin is for "plugin installer"). More modern frameworks -- Symfony with its Bundles; Laravel with its, errm, Bundles -- enable third parties to extend the functionality of the core system, but one does not indict those framework when their bundles wreak havoc. 
Did you learn PHP on WordPress? How many wordpress sites have you seen that use no blog functionality whatsoever? Wordpress is broken when used as anything except a blog
I don't see how a rewrite of WordPress would be any different than say, using another CMS not called WordPress.
I don't agree with this at all. The majority of plugins available for WordPress aren't even related to blogs, so obviously its usefulness has transcended blogging. I have a litany of complaints as well, but it's not broken - it's just flawed. Being PHP developers, we should be used to working with flawed software.
Honestly, browser sniffing in PHP is an utter waste of time. Write your HTML/CSS so that it is able to handle different media types and let the browser negotiate what it needs to do. If you need to know if a device supports a certain feature, detect it in the browser, not in PHP. If you're looking to collect browser analytical data, do this with your webserver logs, or have javascript collect information and send it to the server. Do not do this with PHP.
Your trying to cram a square through a circle hole. I guess your standards dictate that as "not broken". You think WordPress even comes close to "best practice"? lol Happy hammering.
A few things: - A rewrite could take in to account what is required to migrate existing data. Not everyone can start from scratch with a new CMS. - The user interface could remain largely the same. It's one of the core reasons people use Wordpress. - Other CMS software lags behind Wordpress even though from a code standpoint, Wordpress is atrocious. - Modernizing Wordpress would mean access to many more features that are currently difficult, or impossible to implement in the current codebase.
You're absolutely wrong. This isn't about something becoming too popular. It's about something that has become so broken that it has morphed in to an unmaintainable nightmare of insecure spaghetti code. 
You may be thinking of it differently. I see it is a tool that allows me to build applications for my clients quickly and cheaply. I could work on a better platform and have to write my own widget to do what the customer needs, or I can start with Wordpress, maybe pay $100 tops for a plugin that gets me 90% of the way there, and then customize it for that last 10%. With that, I may be able to quote a couple grand less than someone using a better platform.
* You could write a tool to migrate data. I'm pretty sure these already exist for other CMS products. * I don't know Wordpress that well, but often with poorly designed software, user interface is difficult to separate from other functions. If this is not the case, merging the UI code with another product shouldn't be too difficult either. * Other CMS software are ahead of a 'not-yet-rewritten' Wordpress. The author seems to think that you can simply rewrite Wordpress and everything will be magical ponies. In my experience, rewrite almost always take way longer than expected and often do not achieve the expected result (cf. the Second-system effect).
To me it sounds like you still have a little bug in your code. You're better off fixing the problem than masking it by manipulating the output. You could do it by playing around the output buffer (see ob_start()). Without seeing your code its hard to see where the problem is, but removing the "?&gt;" was the right thing to start with. Stick some echoes in various places and look at the output to see at what point in your code the new line is being added. Stick with it, you'll find it. 
I might give Joomla a spin. I yawned way back when it was pretty much Mambo, and didn't give it a chance. I was all into Drupal at the time anyway. Then it seemed the whole world went for Wordpress, so I figured I'd move to where the developers are doing the most plugin work. I haven't looked past that for a few years.
Honestly, I'm not sure Joomla's very good either. 
I don't think anyone expects it to be easy or instant. However, using "it's hard" as an excuse to never do it isn't a very good answer.
I can dig up a version of PHPNuke from 2001, or Mambo and write an extremely elegant and well-written plugin for those systems too. That doesn't in any way amount to a defence for the quality of those systems, though...
I've done plenty of wordpress development and I despise it. Drupal is great but I hardly use it. The only reason I like joomla is because mvc was the first pattern I learned and it really has helped me build extensions fast as well as very maintainable and extendable. Pretty nuch exactly like the blogger, after learning oop and mvc and seeing how well it works it really opens your eyes to why wordpress is not a very great cms. Also joomla templates are so much easier to code. My beef is I deal with people that force me to use wordpress and its the wrong call.
Yeah, Joomla blows chunks.
Its backed by ebay and many other web companies. Joomla 3.0 beats wordpress any day
I think that Wordpress is what Joomla was becoming a couple years ago, however I think Joomla already made most of the improvements that Wordpress needs now.
Wordpress is a lost cause. There's always the opportunity for a prominent group of developers to make a high-profile fork of Wordpress that seeks to start the extremely painful and tedious process of incrementally refactoring the tool while trying to maintain enough backwards compatibility to court users away from Wordpress. For an example, see what Joomla has done with Mambo). ...but on the other hand, see what Joomla has done with Mambo. If you installed the two side by side, you'd probably be surprised at how little has changed. Under the hood have been massive changes, and some large new features have been added, but even today it's still pretty much as crappy as Mambo was when they forked it. Years later there's still a massive amount of Mambo cruft in the Joomla codebase, and every major refactor the Joomla team do introduces another layer of backwards compatibility to try and maintain. The entire project is a complete mess, and the same thing would happen to any project that tried to do something with Wordpress.
I remember the wars Joomla vs Wordpress... At that time, the boom of the blogs, most opinions about Wordpress being better, were coming from developers (I would say designers with some development skills), that liked better the fresh breath provided by Wordpress and didn't like much the complexity of Joomla because was not new, didn't start as a Blog CMS (which Wordpress was ready to do out of the box), and it was evolving from the old Mambo which was a real website CMS at the time, and its CMS based structure and badly developed plugins were giving Joomla the problems that we find in Wordpress today. Now since Wordpress is hitting the same wall, maybe Joomla have evolved and passed that already? I think I need to check... Apart from Joomla problems (nothing is perfect), I always saw it as a better platform for solutions where we need more then just a website, as it has its (unique) framework. Wordpress in my opinion, was a Blog CMS that could be expanded in many different ways, but in the end it would be a Blog CMS with a bunch of additions. This is just my opinions... Maybe not the best one, since I only used both in a dozen projects. But I just think Wordpress was always a little overrated specially by developers hat refused to accept that its was not Wordpress that was really good but their programming skills that were not that good, so Wordpress was their savior! 
Wat
Thank you, I'll try that.
I haven't work with Joomla for a couple years. Would like to hear from you briefly what makes it better for you? I always though Wordpress was just a overrated Blog CMS, while Joomla was a more serious platform that like anything else, couldn't expand without facing some complexity, and further problems that could just be solved with a sane continuous development... that's how good software becomes good. 
&gt; The user interface could remain largely the same. It's one of the core reasons people use Wordpress. I think that the relatively easy (and poor) structure of WordPress' code plays a major role in its success. It takes very little to understand how wordpress works, and developer choose it for this reason. Rewriting in a more modern, OOP fashion would fail in this point, I think (I'm not saying is a bad thing, though). 
Sure. However I would submit that more people use Wordpress as is rather than modify Wordpress at a code level. In essence, its initial draw is the user interface and the ease with which it can be used. It's fair to say that this isn't the *only* draw, but likely the largest.
What does it output on your test environment?
&gt; Does nginx require php-fpm? Nginx doesn't require anything, php-fpm is just one of the available options.
Sure. Well with joomla 3.0 its built with native bootstap which enabled all the default templates and admin panel to be mobile responsive. Beyond that, I like using it as a framework to build custom extensions while giving the ckient the cms abilities. Joomla uses an mvc structure for components, allowing you to write maintainable oop code. Even if you don't want to do anything complex it much easier to write a template and setup modules, menu links of any sort, etc. 3.0 is a vast improvement over 1.5 and I reccomend giving it a try
last time I used Joomla was with 1.5. I'll give it a try and check it at the framework level! Thanks for the reply!
Damnit. I got off track.
I didnt think so, i just got caught up with fastcgi. What are the benefits of using FPM vs not?
&gt; Now since Wordpress is hitting the same wall, maybe Joomla have evolved and passed that already? I think I need to check... I have had to deal a bit with both Joomla and WordPress and would highly recommend WP any day of the week over Joomla.
I'm mistaken. I didn't realise myisam kept a row count. TIL
All explained on the home page http://php-fpm.org/about/ This was before it was merged into the core so it is most likely out of date. PS. It was funny remembering how unmaintained php-fpm was back in the day, now it's currently one of the most popular solutions for serving PHP with nginx.
&gt;Why is it in a directory called ‘wp-content’ when it’s actually a bunch of views? Who knows Themes are in /wp-content/themes/, not /wp-content/. &gt;There are no rules or best practices for theme development, so inheriting legacy code is a nightmare. Sigh. http://codex.wordpress.org/images/1/18/Template_Hierarchy.png &gt;Designers and front-end developers struggle to make changes because their files are full of functional code &gt; &gt;PHP developers struggle to make changes because their files are full of template code I'd say &gt;95% of the time it's the same person. &gt;It’s not optimised for speed of development Wrong. An experienced WordPress developer such as myself can work just as fast, just like with any other software package. &gt; or speed of operation. Clearly not well versed with plugins like W3TC. &gt;Even the documentation is chock full of caveats about obscure scenarios in which you should and shouldn’t use certain functions Like every programming language/software package out there. &gt;The kind of rewrite I’m talking about would require a fundamental rethink of the entire platform. We’re talking thousands of man-hours for no direct financial reward. So this article is mostly pointless. Joking aside, completely rewriting how the software is architecturally designed will simply wipe away the massive wealth of templates, plugins, and developer experience just to appease the "It's wrong unless I wrote it" type of programmer who wouldn't consider using Wordpress in the first place. This blog post, and many others posted here and in /r/programming by their authors, was nothing more than a way to draw attention towards his blog and the conveniently placed advertisement for how to hire him. Virtually nothing is gained by way of actual information, just eye candy for those who love to spite that which is widely used.
I associate only frustration with Joomla. Having done a couple of Joomla sites after which I transferred to Wordpress, I find that Wordpress is such an easier platform to work with. Also, some of the Joomla sites I made are still running version 1.5 because clients don't want to spend money to get it updated to a newer version (which is not such a straightforward process like Wordpress and thus is time consuming). Wordpress can be expanded to just about anything, and can lose that blog feel if you do some custom editing. It does have its problems, but I will not be going back to Joomla any time soon.
I'm curious to know what other CMSes/frameworks you've used and what you thought of them in comparison to Wordpress.
Oh yes, WordPress... the new PHP-Nuke.
I adore/hate PHP-Nuke and Post Nuke. If it weren't for those pieces of software, I probably wouldn't be a programmer today. I wasn't skilled enough to be aware at the time, but christ they were awful.
Was thinking about migrating a client to magento, I had heard so many great things about it. Dear God that templating system is awful.
&gt; it's entirely possible to create maintainable, well-engineered themes Do you mind elaborating more on what sort of methods you're using? This is something I'm currently struggling with.
You were basically forced to write a mini MVC framework in a plugin because Wordpress doesn't actually give you anything useful to work with. Can you imagine how many plugins are doing things like this? Can you imagine how much redundant code is running in a typical Wordpress site with several plugins all running with their own mini-MVC frameworks side-by-side? Worse yet this is somehow considered a *good* thing?
I'm curious to know if you are a real programmer or not. Any real programmer knows that Wordpress is not for programmers. It's great at what it's for, but the article is very thought out and well-written. He brings great points out that are true about Wordpress. Wordpress is poorly written, spaghetti code. Why? Too many cooks in the kitchen, with no one directing who to make what. And the plugins and themes that would be wiped away need to. There is few well written plugins. And even less well written themes. Wordpress tries to MVC, but fails because it does not follow the basic principles of the MVC strategy. Until rules are set to ensure better coding practices and higher standards, Wordpress will not be held to the same standards as other MVC frameworks. Also, the whole point of writing an article is to get someone to come to your site. And it's good to talk against that which is widely used. Maybe you'll gain momentum and do some change. Step out of your comfort zone.
That's fair. If data migration to a new CMS is acceptable to you, then by all means you should pursue that avenue. In fact, I'd encourage it because Wordpress really should hurry up and shit or get off the pot when it comes to dealing with their hideous codebase. You'd be *much* better off without it. On he other hand, a lot of people simply won't switch either because they can't be bothered, or more likely don't know any better. This leaves a lot of people exposed to security issues they don't even know exist.
&gt;Eventually he will realize that WordPress is just a poor fit for his needs and he should choose a more appropriate CMS. That about sums it up. Choose your CMS based on your needs. For nearly all of the personal/small business sites I do, nothing would compare to Wordpress for the reasons he mentions in the article. There are some projects, though, that Wordpress just wouldn't be well suited for and that's Ok. Wordpress is still a wonderful thing.
"When you learn PHP from WordPress as I..." Bwahahahaha. Oooohh I'm crying from the laughter. There's your problem right there, dude!
One more &gt;functions.php – one file to manage ALL the extraneous functionality specified by the theme. I put all of my code in plugins. I rarely add to functions.php unless it is strictly theme related. I find the simplicity of adding code to functions.php and creating plugins to be one of my favorite parts of working with WP.
Bootstrap is awesome but until 3 is released, it isn't mobile first. I'm checking the bootstrap rc daily because I'm putting off a couple of projects to see if I can use 3.
Or, you could use http://wpmvc.org/
Also, check out http://wpmvc.org/
*This got a little long. Sorry!* Of course WordPress suffers from some horrible, ancient code. Hell, I probably wrote and contributed some of it at some point over the past 8+ years I've been using it (and b2 before that). The problem is you can't just rewrite it from scratch using the much better methods that have come along over the years because you then break every existing plugin and theme out there. Like it or not, one of the reasons WordPress is so popular is due to the size of the community, both in terms of people/users and in terms of addons (plugins/themes). There have been many people over the years who felt WordPress needed a rewrite and decided to actually do something about it. As far as I know, all of the products that they have released are used by very few people. They probably wrote really great code and are written with the modern use cases in mind (CMS not blog) but who is going to use a product that few others use and that few plugins are available for? I think this author has a rather naive view of the world, as a couple other commenters have mentioned. If it ain't broke, don't fix it. I would argue while it certainly isn't ideal, it also isn't broke. However it doesn't all have to be hopeless. Just because current code is written in an old-style function-style method doesn't mean that new code has to be that way too. All of the WordPress plugins I write (last I looked, I've released more than anyone else) as well as all of the WordPress contributions I have written over the past couple years have been class-based. This is the case for most of the current contributions as well. All extensible. For example the image manipulation (thumbnailing) code was recently completely rewritten in an abstracted way where different methods can be implemented. GD and ImageMagick are included by default but plugins can easily add more: http://core.trac.wordpress.org/browser/trunk/wp-includes/class-wp-image-editor.php http://core.trac.wordpress.org/browser/trunk/wp-includes/class-wp-image-editor-gd.php http://core.trac.wordpress.org/browser/trunk/wp-includes/class-wp-image-editor-imagick.php Step by step things are improving. But throwing it all away and starting from scratch would shooting yourself in the foot. *While I do work for Automattic (WordPress.com), I'm just commenting here as me -- a WordPress plugin developer and WordPress contributor.*
I just create an `includes` folder in the theme and pull that stuff into `functions.php`. Goes well with my `partials` folder that holds all my template parts -- including `header.php`, `footer.php`, and `sidebar.php` because I have an action hook that makes that possible. What I'm left with at the main theme folder level is naught but full templates, and those use `get_template_part` to grab things out of `partials` to build the page.
I've always considered Wordpress development and PHP development to be two entirely separate things.
The loop itself is fine, I think, but how you manage those loops is, well, kind of loopy. By default, any loop will overwrite some global variables, so you have to go at things in different ways if you want multiple loops not to cobble onto the same variables. There's a set of global functions (out of the literally thousands of global functions) available to reset/clear these variables so as to not break things further down the page. Also by default, any loop will use the last set of posts pulled automatically, regardless of whether or not that's what you want. The database will have queried the default set of "the last 10 posts" by the time you're running `$cats = new WP_Query('category_name='cats')`. You're querying twice and ignoring the first one. That's just weird. The only notion of a controller in WordPress is the `pre_get_posts` hook, but putting all your logic there is dumb/hard to maintain. Finally, I think a lot of the problem is simply the notion that the templates themselves are often responsible for both pulling data and displaying it. But when they're not responsible, it's the arbitrary rules based on the URL that's doing it.
Yeah I felt the same way but I will say this. functions.php is awesome for testing bits and pieces of code. I can almost use it as a scratchpad to try things out an then move code that doesn't need to be there to functions.php.
&gt;I'm curious to know if you are a real programmer or not. Not that it matters at all, but I've been programming primarily in PHP since 1999, right around 14 years. Wordpress is what you make of it. Yes, it's not the perfect codebase that should be the model which all frameworks should be designed by. Yes, there are numerous flaws in how it's architecturally designed relative to 'superior' frameworks in the same field. Having said that, it fills the job for most bloggers out there that want a less cookie-cutter approach to owning a custom blog/website without the overly technical requirements of proper MVC frameworks. Added functionality only requires a quick search and 2-click install. If you want to have a blog that can withstand at least several million pageviews a day by seamlessly utilizing third party software (varnish, memcached, APC, automated JS/CSS/HTML minification, etc) and services (automated CDN URIs), you can by writing a plugin like W3TC. &gt;Wordpress tries to MVC, but fails because it does not follow the basic principles of the MVC strategy. I think where you, and the author of the blog, go wrong is thinking that Wordpress is actively attempting to follow the MVC model. There isn't any templating engine in Wordpress that fully separates the view from the logic, which is proof that they're not attempting an MVC design. &gt;Step out of your comfort zone. To be fair, you don't know my experience in the language, obviously, but there's very little in PHP that isn't in my comfort zone.
I happen to live in a very different corner of web development - ASP.Net ville to be exact - and this debate is interesting for an outsider (I've used Wordpress a great deal, but I don't code on it). A lot of debate was had when Microsoft threw out most of old-school ASP to create ASP.Net, and again when they replaced ASP.Net with ASP.Net MVC. Each step had pieces you could reuse but inevitably you had to break and fix an old application to port it to the new platform. It sounds a bit like it's time for Wordpress to take a break and fix step so it can grow. But that's just based on the opinions here - I've not hacked on the code.
Try sending an http header. PHP should tell you that output had started already in file X line Y.
cPanel is going to cramp your style do much, you're probably better off using an integrated solution like: http://nginxcp.com/ It won't get rid of Apache but it will cause minimal headache compared to trying to do stuff around cPanel.
If I recall, WordPress.com is pretty changed from the last time I've used it - they've tacked things on that makes it much more tumblr like. I hope that's in mainline WP. I got angry at the WP devs when they made bbPress an extension, not standalone. I liked bbPress, I'd like to install it standalone without also installing the world's best remote shell.
Cool feature, I need to do that kind of stuff all the time.
Had never heard of Fork until now... very clean codebase.
http://www.php.net/manual/en/function.stream-context-create.php that is pretty easy to use, its very low level but http requests are not very hard to write.
To me, having read the comment thread here, it sounds as though you need to do a lot more research into intermediate server administration techniques, command line administration and the intricacies (and pitfalls) of setting up web servers and email servers. Going from using a control panel like plesk or cpanel to doing everything yourself from the command line isn't difficult in my mind but I have been doing so for eight years so to someone new to it all I am sure there is a lot of trial and error learning to be done :) 
That's good news. Even though it's trivial and just a few lines to write this in PHP, it's something you use a lot on database results and such, so having it natively in the language will be faster than using it written in php.
Haven't used Magento personally, but I've heard mixed opinions about it. Mind sharing why you think it's garbage? 
Combing this with preg_grep will be a great alternative to loops
I wrote about this here: http://deanclatworthy.com/2013/02/migrating-from-apache-to-nginx-wordpress-edition/ You should check your fastcgi_pass param is set correctly by checking the socket that php is running on: &gt;If you open /etc/php5/fpm/pool.d/www.conf there is a configuration value called “listen”. This is what you should set the fastcgi_pass variable to.
For out-of-the-box functionality, it beats just about any other free platform out there. Everything in it can be customised or over-ridden, but working out how to do so is a *very* slow and difficult process. It's structure was well thought out, IMO, but it is such a monster that it is hard to navigate the code. It is also a bit of a resource hog. What you can do through the GUI is great. It all depends on where you are coming from, really. If you want a highly sophisticated and flexible shop, but don't have great programming skills, and can afford the premium plugins and themes, then it is probably for you. People love it or hate it, but you can't deny it is pretty complete for an e-commerce platform. It really pays to enter the e-commerce arena with your eyes open. Magento/WooCommerce etc. do not fall into neat good/bad categories. They cover different markets and skill levels, and your use-case will determine which is best. Just avoid osCommerce like the plague that it is ;-) Edit: I set up a Magento site for a client years ago, when it still had an Open Source community behind it, that were treated with respect for the work they put into building it (not so much now). It is still running now, the client is happy with it, and it has not needed any additional customisations all this time. The client can set up new products of various types and structures, sophisticated special offers (e.g. "buy three or more of product A before the end of the month and get 10% off plus free postage if delivered in the UK" - all point and click stuff). I know of no other platform you can set up totally flexible rules like that in a visual way, with no programming).
"It's hard" also translates to "it's expensive". Someone has to pay for the time and effort to do all this.
Wow what a great addition. I can't wait for 5.5 to be production ready
I'd rather have constipation than work on Magento.
Yes, everyone who knows how things should work would do that, but we are still drowned by the rest that put everything into functions.php (to a "theme" is actually equivalent to a functional plugin). It is the perception of what people generally see that gives bloggers something to gripe about. Hell, my plugins are installed via composer with packagist library dependencies and run from PSR-0 name-spaced classes - even that can be done in WP, and it co-exists happily with the older WP techniques based on hooks (actions and filters). You *don't* have to keep following the old ways. But the structure of WP to a beginner still encourages it, unfortunately. For example, no plugin dependencies, so people tend to pile every bit of functionality they need into their plugin, rather than building on existing plugins like lego. No templating system, so code is full of HTML, or plugins pull in their own custom templating system.
there currently is no instances of php-fpm on the server, id have to install from source. so, to avoid overhead/conflicts of cpanel, i'm switching to liquid web's core-managed vps. i may still set up the nginxcp as another comment recommended, just so my other devs can have their UI.
I think wordpress is in the same state as codeigniter. Popular and working, but cannot keep up with the practices of the fast evolving language that is PHP without breaking the community. 
I imagine that's true of tons of PHP devs from back in the day, and equally true of many WP users now (including not knowing how awful it is under the hood :P). But on the flipside, at least they're getting people interested!
im fluent enough to run a LAMP environment, but i know shit about mailservers -- fortunately we wont need a mailserver on this build. the only other thing i would need cpanel for, honestly, is managing DNS zones. 
It is also a bit of a different market. ASP et al is a lot more corporate, just because of the licences required on the complete stack, and there is money there for conversions and upgrades. WP is used by millions who cannot afford to spend hard cash on such luxuries; they just need tiny nudges forward, a bit at a time, with Open Source or cheap developers fixing the little things that need tweaking as they go along.
Never seen that before - looks interesting. Will give it a go. Thanks :-)
I feel very mixed on this topic: on one hand I agree that WordPress has too much spaghetti-code. The fact that I can include a post handler into a template... Wow. It's easy to write some horrible, horrible code. On the other hand, I'm familiar with it enough that I can use my OOP/MVC knowledge to quickly produce some pretty decent websites, all at a reasonable cost for my clients. Just because something has a low barrier to entry doesn't make it a bad thing in and of itself. People say the same thing about PHP: Look at all the crappy code, let's judge the whole language based on that. It's a mixed bag with WordPress... But the number of quality forks speaks the real story: it ain't easy. \*Edit: grammar
How bout we don't? 
That's completely different than what I'm talking about (and is actually just yet-another-cURL-wrapper, except written in C). To be clear, I'm not talking about making client requests from within PHP, I'm talking about handling the requests and responses that are served by PHP. Here's some examples from popular frameworks that illustrate the types of objects I'm talking about: * ZF2: [request](http://framework.zend.com/manual/2.0/en/modules/zend.http.request.html) / [response](http://framework.zend.com/manual/2.0/en/modules/zend.http.response.html) * Symfony: [request](http://api.symfony.com/2.2/Symfony/Component/HttpFoundation/Request.html) / [response](http://api.symfony.com/2.2/Symfony/Component/HttpFoundation/Response.html) * Kohana: [request](http://kohanaframework.org/3.2/guide/api/HTTP_Request) / [response](http://kohanaframework.org/3.2/guide/api/HTTP_Response) * Agavi: [request](http://www.agavi.org/apidocs/db_request_AgaviRequest.class.html) / [response](http://www.agavi.org/apidocs/db_response_AgaviResponse.class.html) Something like [this](http://us.php.net/manual/en/book.http.php) is practically the answer, but it's in PECL and not core.
Lets say you have a web application with thousands of unique hits per day. A customer has requested that you add functionality to automatically blur certain parts of a paycheck image, lets say. You can either: * Write and do it yourself. However, image manipulation is computationally expensive, and now you need to scale this solution by adding more servers (and this most likely means creating a message queue, writing more code to drive the process, etc...). * Outsource to a service such as Cloudinary. In the business world, there is nothing wrong with this solution. It would save time and server resources, keeping development and maintenance cost down. Which seems more logical to you?
That's funny. The web doesn't work with html/css/php only anymore, so I don't really take people with that add-on seriously. But I do use the &lt;noscript&gt; tag to display a warning when it's turned off. I do trust the user-agent string the browser sends. It can be edited, but the 'average' user won't touch it, and people who touch it, know it could change behavoir of a website.
You can check the browser and display another version of a website. The web isn't html/css only, you have HTML5 now, and it's often easy to just make more than one version. One that takes full advantage of HTML5, and another one that doesn't.
&gt; There are some projects, though, that Wordpress just wouldn't be well suited for and that's Ok. Can you give an example of some projects?
Most of these people replying with "OMG UPGRADE TO 5.4!!!!" probably do not or have not worked in a business-centric environment, where it is near impossible to convince upper management that an underlying version upgrade is worth your time. In business, time is money, and they would rather have you spending your time creating features.
Reminds me of this Joel on Software article, Things You Should Never Do http://www.joelonsoftware.com/articles/fog0000000069.html "the single worst strategic mistake that any software company can make: they decided to rewrite the code from scratch"
The company I work for tried using ActiveMQ as well as RabbitMQ. Both solutions were disappointing for our needs so we created a mongo based solution. Enjoy.
That universal answer, it depends. Wordpress would probably not be the best option for a wiki, or a large scale store like amazon, or a forum, or reddit. You could probably hack around and get something working but if you wanted to make one of these kinds of sites, it probably would be wisest to choose a cms geared specifically to that project. Only about 30% of websites use a cms at all. about 50% of those are WP. I should mention that I'm wearing a wordpress t-shirt right now. Chances are, at least at this point in my career, I'm not going to be taking on any projects that WP can't handle.
Our favorite feature of it is that the queue is queryable. With large queues, it is extremely valuable being able to search through them to gather statistics, find specific messages, etc.
Chadicus and the Creative Code Solutions Research Team (aka arch) delivers !!! 
[Generators](https://wiki.php.net/rfc/generators) are gonna be so, so nice. What makes me sad though is the other headline in /r/PHP today: [*PHP version 5.3 is now the most used version, just ahead of 5.2*](http://www.reddit.com/r/PHP/comments/1aqj9r/php_version_53_is_now_the_most_used_version_just/). Seriously? It's been out for almost 4 years ([5.3.0 released 6-30-2009](http://en.wikipedia.org/wiki/PHP#Release_history)). Not only that, here's the rundown from 3 popular shared hosting providers that I have access to right this second: - Godaddy: 5.3.13 - ModWest: 5.2.6 - HostGator: 5.2.17 Now consider that, in the context of say, a Wordpress plugin developer: you still can't trust that features added to the language *four freaking years ago* will be present for all end users. (Reference: ["What's New in PHP 5.3"](http://www.ibm.com/developerworks/views/opensource/libraryview.jsp?search_by=new+PHP+V5.3,) series from IBM.com.) I'm excited to see this stuff coming to PHP, but it makes me sad to know I probably can't use these features until 2018 at the earliest. Hopefully society as we know it will still be a thing.
I think you're on the right track, but there's an even wider problem than that: Wordpress developers have to think of their development in two parts - there's "inside the loop" development, and "outside the loop development": developing inside the loop is a different ball-game with different rules than outside the loop development. This isn't just awkward - it's bad architectural design, but also unnecessary bloat and pain for the developer.
We are still with php 5.2 at work because we have some old libraries that nobody wants to update. Updating means testing it for weeks. :P
First, lets ignore Laravel 3 and focus on Laravel 4, because it's redesigned and close to release, and not directly compatible with Laravel 3. Laravel 4 uses composer just as Symfony does because it gives both Symfony and Laravel developers the chance to use each other's code. That's very cool, and definitely the future for PHP development. &gt;I don't see how WordPress is broken specifically because they enable plugins to use $wpdb without data validation. That was just an example, but lets run with your point. The reason why we don't tar composer with the same brush is simply because the quality is better. Why is this? Because its cross-compatible! Wordpress plugins only work with Wordpress, so only Wordpress developers look at them, whereas composer bundles are used by many more people with a much wider demographic of skillset. The composer way of doing things encourages participation and general open sourciness that you don't find *as much* ('as much' being in italics here, because of course there is some) as in Wordpress. Hope that helps clear up how I see things :)
`array_column()` is awesome. So many wasted loops. Now to have an array of database results with the ID column as the key, one would just do `$results = array_combine(array_column($db_results, 'id'), $db_results);`
Finally, finally()
Oh I see. I've used stream context instead of Curl so I thought it was a legit alternative not a wrapper. I have the HTTP plugin, it is pretty nice but doesn't do as much as I had hoped (It is not a full replacement for the frameworks, it's a bit more low level). I still kind of wish they'd put HTTP into core or as a default extension, PHP is the programming language for the web after all.
I've used plenty of real frameworks and generally do not have fun developing sites using any of the popular CMSes (more often than not it turns into a game of edge case whack-a-mole). I've never used Sinatra but I've read a lot about how it works and I've built architectures with similar abstractions in the past. It's a nice way to structure things. I was just wondering what [donwilson](http://www.reddit.com/r/PHP/comments/1aoh32/the_dire_state_of_wordpress/c8zfomg) was using as a point of reference. If you've never used anything else but are a pro at Wordpress then of course you're going to think it's awesome. You have nothing to compare it to. **EDIT** Fixed a typo.
Similar statements could be made about in\_array, array\_search, etc. I also agree it is too narrow to be useful, but many of the array\_* functions are in that sense. So I don't necessarily see it as a bad idea unless it's decided "no more core functions that don't provide significant advantage over equivalents in PHP code" (which would be a good policy). edit: formatting
I wrote something like this for an old game. The game had an option where after each round it could POST the rounds info to a page you provided. Check the game and see if it has something like that.
&gt; Oh I see. I've used stream context instead of Curl so I thought it was a legit alternative not a wrapper. The stream functionality is indeed implemented completely differently from cURL and _is_ a legit alternative, but I was referring to it in the context of 'it does the same basic job' in that it makes HTTP requests for you. Indeed, it is much better than using cURL, if for no other reason than it doesn't require you to load a non-default extension. &gt; I still kind of wish they'd put HTTP into core or as a default extension, PHP is the programming language for the web after all. That's exactly what I was initially referring to -- PHP is for handling requests and spitting out responses, so why isn't the HTTP extension in core? I do agree it'd be nice to see it updated, but at the very least having it available as a core extension just seems like a natural fit. 
A more readable version of your code should go along the lines of: $results = array(); foreach($db_results as $row) { $results[ $row['id'] ] = $row; } Not exactly as condensed as a single line of code that `array_column()` provides. `array_column()` provides the same level of functionality as `array_values()`, `count()`, `str_repeat()`, and a lot of other core functions.
I had a version 4 under my care for a while, but it got hacked recently and so I had an excuse to rewrite it so it would run with 5.3
I know. For normal webpages it's silly to use javascript, but we're getting to something where normal websites are made with a CMS and an template builder, and programmers should focus more on creating apps with HTML5.
Same here. ;)
These rollouts take forever, for sure. Go with something like Amazon where you can roll your own stuff. I'm running the latest stable PHP 5.4 on my el cheapo micro instance
I bet there's going to be noise after that "Dropped Windows XP support" line.
Are there really that many people out there running PHP applications under an XP environment? Serious question; I wouldn't think there are but I don't have any statistics in front of me so I don't know.
It's what a lot of people start off web dev with, so I would imagine a significant number of XP users have it installed on their desktops.
&gt; Function calls in empty() About time, this has always frustrated me!
Sorry - I had to: http://qkme.me/3tgwzu
Server 2003 is more likely, but yes, they do exist.
Well... it's not about me - it's about the end-users of my code, most of whom aren't rolling their own Amazon/Linode/etc. I agree that that's a bitchin' setup, but portability is a high priority for pretty much all of my projects.
It takes resources though to support a platform and Windows XP is nearly end of life, can't be supported forever. Linux is free, powerful and a great thing to learn for any web dev. For a die-hard Windows XP user, or someone who cannot afford a new computer, they can always download a previous version to learn with, or just install VirtualBox and put a linux server image on it with a LAMP stack. 
FWIW, my shared hosting (NearlyFreeSpeech) used to be safe-mode-on, with PHP versions lagging at least 0.1 version # behind, but they now have something like a "beta mode" server that has 5.4 and of course no safe mode as it's been removed. You have to select it specifically. Just a bit of info if anyone was interested in their hosting, as I've been very happy with them for a low-traffic blog/homepage. Cost is $15-20 per year with around 500 hits per month and minimal data usage (a few MB, all my javascript is CDN-hosted and no images except ones uploaded elsewhere).
Finally finally!
Many frameworks have some helpers that generate `&lt;select&gt;`, for example. They accept an array of `[value =&gt; title]` items as parameter. `array_column` now eliminates any additional helpers/foreaches that build such parameters.
 Can I ask what specifically you found lacking in RabbitMQ? We're using it for several projects where I work and it seems to be serving us very well.
And this is very-very sad.
I can vouch for NFSnet too. Cheap and easy way to start up a project.
If you are devving on XP you probably aren't supporting 5.5 in fact if you are even using 5.4 on XP you can probably make enough $ to buy a Windows 7+ machine. Right?
Not because of external dependencies but because of a huge code base that requires time to weed out stuff to work with 5.3. (Some of which are old ext libraries). The code base started with php4... Good news is 5.3 is coming next month :D
How do I do that? 
The WordPress project (which usually a good barometer for that sort of thing) won't consider 5.3 as a base requirement until 2014, because of the number of users still running on 5.2. :/
Not an overly exciting feature. The stuff it does is already very easy to accomplish in userland.
At the very last script on the last line: header("Location: /404foobar"); PHP should either display or log (or both) an error saying exactly where output (the space character) has started and is causing the header() call to fail. Because headers must be sent before any output.
Indeed, although I think a lot of people outside the Microsoft world don't realize how much money is directed into that ecosystem by Microsoft themselves. They make a lot of mistakes, but in some cases they really manage to create an environment of solid, high-paying leads on various types of work where third-party teams make the lion's share of the money, and Microsoft makes money in licensing while their sales strategy is basically to facilitate that connection of developers/vendor to customers. There's a bit of a missed opportunity there in other ecosystems like Wordpress, Magento and the other big free offerings. Microsoft's business model with ASP.Net MVC and Entity Framework at this point is strikingly similar - both are open source - but they drive a lot of revenue to those that adopt them. So in some ways the fact the Wordpress world is less moneyed is not just because it starts with people on a budget, but also because Automattic doesn't work as hard on driving revenue into the ecosystem.
It is certainly frustrating, and there's a bit of a chicken-egg going on. Larger projects won't push forward because of hosting requirements, but large scale hosting companies won't push forward newer versions because a) potential bugs and b) no real incentive to until there's more demand.
What is multi-site if it is not multi-domain? If you're making several applications (api, admin, frontend, whatever) then they should be totally seperate apps with their own virtual hosts and own codebases, dont try jamming them together. Definitely don't hack the "detectEnvironment" logic as suggested below or you'll have a bad time.
The built-in implementation may perform much better than doing it in PHP. Not that I have any specific information one way or the other.
I agree, it's a real problem. PS: wrong meme.
I think its more along the lines of "That server works fine right now, and it takes time to do that sort of thing". Upgrading PHP probably isn't the highest priority either.
Yup, WordPress code is pretty terrible. I cringe when I get asked to write wordpress plugins.
I thought getters/setters were making it into 5.5 :'(
That's what I was thinking - working over larger array sets might help shave a few cycles here and there.
This is a great document to have/create. Thanks nikic. Maybe documents like this can become more formal in the future - maybe even part of the source code - Markdown release documents?
Probably safer - hacking CPanel installs would probably end in tears.
The first one is the big one. 
GitHub provides free static hosting. 
As a support person,if you are trying to debug a user issue, it is useful if you can send a user to a page that does this sort of detection and then send you the data, or collect it yourself. Many times users have no idea what machine they are using, the OS, or what browser (it's the internet). This lets you see what they are using and lets you try to replicate their issue. I wish all software came with these functions to assist us.
Hi, I did not know thanks btw, do you know why this post got removed? is this kind of posts not encouraged?
Your code isn't that good and you posted it in the selftext. 
yes self text style sucks and make it hard to read code but this is not my mistake!?
Why would you do this... serialize is ungodly wasteful. I can't imagine anyone wanting to send that over the wire... plus there's phpjs out there which would do this too, if you're crazy enough to want it.
No pues compa, el punto es mejorar, no empeorar.
At $DAYJOB we have a RESTish internal service tier that responds with serialized objects. These services are called by front end controllers located in the same or adjacent racks. It turns out that bandwidth across a 10G switch is cheap. :) The use case for parsing the PHP serialize output in javascript popped up earilier this week when a coworker built a neat javascript hack that read metadata from the service layer's documentation pages and generated dynamic forms that could call the services via ajax requests. The phpjs unserialize() method was the first one I googled up and suggested. It turned out that their implementation doesn't support parsing objects and our services were returning "Response" objects, not just arrays.
you mean property accessors? they got voted down.
Pero entonces no trabajas con otros programadores? Yo hice mi framework tambien.. pero las buenas practicas que he venido leyendo estan completamente en contra de eso.. por eso andaba buscando uno para usar. Actualmente estoy haciendo una transicion a CodeIgniter ya que es tan similar a lo que termine haciendo, aunque claro con mejoras que no habia pensado. Pero me da curiosidad laravel y todos los magic-frameworks que usan aqui. Magic-frameworks por que no comprendo como funcionan en si jaja. Wordpress/Joomla solo si lo pide el cliente especificamente.
Normalmente no trabajo con otros programadores, pero de cualquier manera mi código está bastante bien estructurado (todo es MVC), y con comentarios claros. Para llegar a escribir como lo hago hoy fue después de ver muchos source codes en github y lugares así, entonces por esa razón creo que es bastante legible. Igual todos mis proyectos los manejo con GIT, entonces si hubiera necesidad de programar con alguien más, todo está listo (que me encantaría en el futuro, cada vez hay más trabajo, y me encantaría formar un equipo de trabajo). Yo en un tiempo quería decidirme entre CakePHP y CodeIgniter, y elegí CodeIgniter, pero lo dejé porque mi "resumen" (vago, sin fundamentos) fue que me proporcionaba como maquetas para objetos, que en realidad pocas veces iba a utilizar todo su potencial. E igual que tú con Wordpress, únicamente cuando lo piden, pero trato de evitarlo lo más posible, y no únicamente por lo horrible que es realizar sitios customizados a través de ellos, sino que cada vez se vuelve más pesado, y genera muchísima carga en el servidor, además de que yo lo he notado más y más lento para el usuario también, aún con servidores buenos.
No tengo proyectos públicos tampoco :( todo lo tengo en mi servidor (como repositorios privados). Me interesa aprender Python primero, a lo que he leído Ruby tiene una curva de aprendizaje bastante sencilla, sobre todo si ya sabes otros lenguajes. Y aún no hay mucha ofertas de trabajo para Ruby, pero me interesan los dos, solo dejaré Ruby para más adelante. Además ahorita también estoy con Objective-C, mucho trabajo, y la universidad, hay poco tiempo para aprender :(
&gt;**THIS IS A DEVELOPMENT PREVIEW - DO NOT USE IT IN PRODUCTION!** This means i cant use it on production for a simple echo. Or that i shouldnt try the new features on production?
That graph the other day was a good incentive to upgrade. 
Damnit. That along with generators were what made me the most excited about 5.5. Would love to have some read only public properties without doing a private property alongside of \__get().
&gt; Too narrow, too little useful. As with almost everything else in the `array_*` pseudo-namespace. PHP array mangling functions are my go-to example of an interface which reliably excludes itself from useful solutions by covering all the wrong parts of the problem space.
Are you happy with what you're going to make out of this project? If so, then you did well. Superman does good. If the project requires 112 hours of programming, it'll really actually require closer to 300. Even at a modest $60/hour charge, you undercharged by close to $16,000. Of course, most developers I know like to set a project cost instead of going about it hourly. That involves sitting down with the client and hashing out exact details of what they want. You would get a clear idea of how much work as ahead of you. Again, as long as you're happy with what you're making out of it, you did well.
Instead of serailize, why not just use json_encode?
This means if it crashes and you get fired, its your fault. Don't use it for code that has to run. Instead load it on your dev box. Run the tests in the php package. Run your unit tests. See if anything crashes it, or emits odd errors, or whatever odd. If it does, report it so the final 5.5.0 release can be as stable as possible.
It was just the specific implementation that was shot down, my uninformed opinion is that it suffered from the too many cooks syndrome and ended up unwieldy. I'm sure we will see property accessors come up again before 5.6.
I think one of the problems with the slow adoption of PHP is the version numbering. If they had named '5.3' as '6.0' and '5.4' as '7.0', adoption might've been quicker, because of how people look at it: 5.3 was a major upgrade of the language, but to a lot of (sytem administrator type) people who do server maintenance, it was "only a 0.1 update".
You actually can implement classical MVC in PHP using sockets. It's just highly impractical and a nightmare to scale. But that's true for all of the web. Which is why we have other "MVC-inspired" pattern. P.S. I do not consider Rails and it's clones to be MVC-inspired. They are just reusing some names for completely different things.
Hi teresko, you answered a q of mine on SO which drove me to study MVC for a while. I think I would need to balance practicability here though.
Oh and an FYI just for all the haters in this subreddit, Joomla worked fine out the box the same day PHP 5.4 stable binaries were released ;-)
I hope you are aware of portability issues with serialization. http://stackoverflow.com/questions/7904355/php-unserialized-integer-from-64-bit-to-32-bit 
&gt;If the client doesn't pay you properly, he doesn't value you properly, and will expect more from you than if he paid you more. This is the truth. Personally I think you have massively undercharged, but then I don't know anything about your circumstances/experience/skillset etc.
ohhhh man I got fucked like this in the beginning. The most important thing is to really plan everything out. I find it easier to plan if I ask for designs of interfaces first. So many things you don't think about and say "oh this is easy", but all those small things that you forgot adds up and adds up and boom, you undercharged. Honestly if it's one of your first contract and you're confident you can do it, go ahead. Build your portfolio and contacts! I remember no one wanting to hire me because of lack of experience. 
Again, another useful use case I hadn't considered. Makes sense.
Wow, $2 an hour. My biggest failure was on an 8 month project that ended up netting $12/hour. Even at that point, it probably would have been in my best interest to return all payments and walk away, assuming a lawsuit wasn't in the cards. I lost 2 other big $80/hour jobs while focussing on that $12/hour job, so the opportunity costs were staggering.
I open sourced this algorithm so feel free to use it in your own projects. $time = $money; 
Just curious, is this your first coding job? You'll learn some lessons from this, and those lessons will be worth more than the money you make from it. Nobody else touched on the installments question. I have had good luck with that. I have been burned before, but never when someone was making payments during the development of a project. People that want to pay in payments are high-risk in the first place because it shows that they don't have expendable cash for the project. By having them pay during development, they're more motivated to send checks. My personal favorite billing method is to simply rack up hours and send a bill at the end of the month with expectation that I'll be paid within the following 30 days. I think it's most fair to me and my clients, and keeps the payments in reasonably sized chunks. I bill to quotes when the client insists, but I hate it because sometimes I end up with $20/hour, and sometimes I end up well north of $100. It never balances to where one of us isn't getting screwed.
Well, I suppose the point is you can use these features now for private projects, the kind where you can roll your own server and have control over what to install. But for public/open source ones, yes, we are pretty much out of luck.
I can see that, I remember seeing several different suggested syntaxes for it. Even off the top of my head I'm not 100% positive on what I'd go with, probably this or something close: class TimePeriod { public $seconds; public $hours { get { return $this-&gt;seconds / 3600; } set($value) { $this-&gt;seconds = $value * 3600; } } } Guess it's also a no for scalar type hinting as well? That, generators, setters/getters, and named parameters would all make me a happy man when working with PHP. Still, happy with the direction PHP is going and have enjoyed jumping to 5.3 and now on 5.4.
&gt;When you learn PHP from WordPress as I (and probably many other people) did I stopped reading here. Mostly because I don't think the opinion of a self-proclamed developer is relevant for that kind of matters. There's nothing wrong with learning stuff by yourself, really. But if you do, you have to make sure your vision is broad enough before judging and criticizing (negatively or positively) complicated things. The author of this post clearly doesn't have a deep enough knowledge of the whole Wordpress project. What's funny is he's kind of right, and many people will agree. But he's not right with the good arguments. On this topic, I bet Automattic will announce a new CMS product. I'm thinking : * built from scratch * in PHP * based on Symfony2 * with native support for several DBMSs * with native cache optimization * with native SEO handling * with easy integration with most popular CDNs * with plug-in capabilities and a well-thought API * full HTML5 + JQuery * with native AJAX handling * during 2013 I'm Bookmarking this, and I'll be back for a "Called it !" post in a few months :)
Can I fork it on github?
They do take a little while to grok if you've never used them before. I've been using them in Python for a little while, but it's hard to come up with examples that aren't overly contrived. Here's a decent conceptual explanation, from a StackOverflow question, and it's totally relevant to using generators in PHP as well: * [What can you use Python generator functions for?](http://stackoverflow.com/a/102632/844976) And for contrast, this is an interesting read, although it's a bit more specific to Python: * [When is not a good time to use python generators?](http://stackoverflow.com/questions/245792/when-is-not-a-good-time-to-use-python-generators) Hope that's not too much Python for this sub. There's a lot we as PHP devs can learn from it from though. Anyhow, if I had to sum it up in under ten words, I'd say it's like adding steroids to your `foreach()` powers.
$12/hr is horrible, you are short changing yourself, but you are also feeding people's ideas that web development comes cheap which is worsening this trend. When I first started doing some freelance work I started out (with no professional web experience, just self taught stuff) charging $35/hr. I only had one client (which was my previous employer) but it was helping pay the bills so I did a ton of work for him. After I was getting overloaded with work I had to up it to $50/hr so he wouldn't be so eager to keep adding more things to do. Now, after 5 years of professional experience, I won't approach anything without first disclosing my initial rate of $100/hr. This is mainly so people will not be interested (because I value my time more than that), but if someone does bite it'll be a nice extra paycheck. That rate is more aimed at troubleshooting and/or fixing problems, for large projects I'd target $50-$75/hr because the # of hours will be so great. If nothing else you now have something to add to your portfolio, and you can learn from it to keep charging more for each project. :)
Absolutely. I'm just hypothesizing a bit here, but one could reason that the majority of folks on shared hosting don't have a dedicated IT person/team, and that means that those apps probably aren't getting maintained as frequently, if at all. If that's true, then the shared hosting provider would have a higher risk of breaking a significant number of the apps they're hosting. And handling the outrage would be both costly &amp; painful. On the other hand, I feel like saying this: Send out an email to your hosting clients, tell them that 2009 was 4 years ago, and they need to review/update their applications, because y'all mofos are holding the rest of the world back. \* edit: grammar
Income tax? Don't report it. It's not nearly enough to warrant reporting and I don't even know if you would owe much of anything because it's such a low figure. I would still ask for 10% more and claim it's for tax purposes because you absolutely undercharged.
Why would anyone change the communication protocol of 70+ internal services to enable a tangential use case? We do have services which use JSON as their transport encoding when communication with non-PHP consumers is a business requirement. I read a lot of comments on reddit that seem to assume that the entire universe can and should be re-written to enable more elegant solutions of the latest ad-hoc use case. I hope each time that the commenter is either a hobbyist/student or that they have a strong team lead who will help them realize that changing code has real cost ramifications for their business. I'm not saying that legacy code should never be updated to meet changing requirements, but somebody had better make a good business case before implementing invasive changes or the development team is just pissing away profits.
A couple of already known issues to be aware of: * ext/opcache (which is the old Zend Optimiser+, and is enabled by default) doesn't build on some platforms — Linux, OS X and Windows should be good, but some of the *BSDs and Hurd are apparently problematic, at least. * `./configure --enable-maintainer-zts` is broken with the tarball due to a bison issue — if you need it, check the php-5.5.0beta1 tag out of git and build with a version of bison that isn't 2.6.1.
this also gets to distros - rhel and centos have a default position of using much older PHP than is current. Even if they backport some security patches (which I've been told they do), that's only a portion of the PHP version story, and they need to get more current if PHP upgrades are to speed up.
Do you live in the US? If you pay self-employment taxes on this income, expect to pay about double your normal income tax rate. When I am doing contract work, I charge the client twice what I want to make. Half the money goes in a separate account for tax payments and overhead.
As long as you don't joke about it.
Don't sell yourself short. I have zero education background in this line of work, and I don't think about that for a second. If you're good at something, you should charge what you think you're worth. Just because you don't have the clients you *think* you should have now, doesn't mean you won't soon. I think you'll be surprised how many people are willing to pay good money for a quality service. Just make sure you deliver that quality ;)
Always double your time. You're gonna run into something that needs debugging, or a have to come up with a way to solve a problem you've never seen that involves reading and learning on the side. You're going to screw up. The criteria for the project will be tweaked either majorly or minorly. It ALWAYS happens. I learned this the hard way and have tried to never been burned like that again. I also know what you mean. I've undercharged knowingly to fit the client's budget, because I needed the work. It's preferable to get what your time is worth but sometimes you just gotta get paid one way or the other. In general though, I hope you've learned that most of us charge far more for their time. My rate is $90/hr. If I'm trying to fit a client's budget, i just send an invoice of the time it actually took and apply creative discounts or make some time non-billable (usually debugging time, I think if I screw up and it takes 5 hours to fix that's kinda my problem in a way, not the client's). this way the client knows what your time is worth and knows how long these things take. They feel gracious that you 'cut them a deal', but you protect yourself for future expectations. This is especially a big deal for 'touch up work' and changes down the road. For example if someone needs a custom wordpress theme and only has $1000 to spend (I'd typically expect to charge close to double that at the minimum), I may take the job anyway just to make an extra $1000 if I have the free time. But they client knows that if they call me back in a month and need something else, my rate is $90/hr, not the $15 that it came out to on the original job. 
same here. I estimated about 20 hours on a project that I thought I could deliver in a month and a half. Once I actually dug into the coding and realized the true complexity of what I was set out to accomplish, I was totally fucked. Thing took weeks of fulltime work and was months late. I ended up billing almost 3x what the estimate was and I'm still fighting to collect it. Terrible experience.
The ZF2 guys have been making some noise trying to get WP to recode in their FW, but why would they? If they recode, it will break ALL of their themes and addons, which, is the lifeblood of WP. Taking the "F**k You, Start Again" approach is what Drupal did, and they had a rough time, but their community is very developer heavy. Do you think WP would survive the same? I've seen so many responses from Automattic that make me think they just want to ride WP until it dies, then just do something else. Afterall that would be more financially viable than re-investing their profits on a recode which could destroy, cripple or at least damage their community. It NEEDS a recode, but I don't see them doing it, for the same reason CodeIgniter wont ever get a recode. When business manages software development decisions, new and exciting often gets ignored, making way for the bottom line.
Agreed.
it is if you're experienced enough to back up being paid that much.
One of the many, many things your average blog owner does not care about. :) If you want to do themes or plugins, you've got to deal with WordPress.
&gt;The singleton is a practical design pattern. When an article starts like this, it's hard to continue reading.
i think about how long it will take, in hours, and decide on a good hourly rate. then, i double this. next, listen for some key phrases such as "great experience", "good exposure", "share in revenue", "i'll show others and get you more work", etc... if you hear any of these phrases, take you're doubled quote above and multiply it by 10. present your quote, and request 1/2 up front to begin work, and 1/2 when complete. 95% of people coming to you for work will go away. the remaining 5% is your client base.
If you're in the US and this is a real company/client, you're over $600 so you'll get 1099'd. On a 1099, you're paying both employer and employee SS withholdings, which is 12%, plus your normal state and federal income tax (in California, state is 9% and most people are around 20%), which means you should be planning on taxes being about 41%, not 10%. 
It's not practical because it's essentially an anti-pattern. It's what you reach for when you want to potentially paint yourself in to a corner. There is never a good reason to use a singleton.
Thankfully my dongle is small enough it shouldn't get me in trouble
I have to agree here, if you really need one instance of an object then do exactly that, instantiate it and pass it around. At a push use the facade pattern but that is essentially doing the same thing so I wouldn't recommend that either
In practice you need to double or triple your initial estimate of the work required. The client will request changes, you have meetings to attend and mails to answer. On the other hand, by taking these low paying jobs you gain experience which will allow you to raise your rate in the future. Once you get a name for yourself and start receiving regular offers you should be able to charge €60 an hour, no matter who the client is. 
Which makes the fact that my trinket works just as well in modern PHP than in 5.2 particularly cool; it's another piece NOT to change when I finally get control of the environment. 
How to measure quality?
+1 on the hassle that accompanies low paying jobs! Once you start working with clients that understand the work involved the expectations and pay become much more realistic
Yeah I agree, as much as I can I charge for all the time I spend invested in a project. I was just using that as an example of the first thing I cut when I have to. 
Dude... just found this post and those css3 rollovers on those links gave me a boner...
It means it should be considered unstable, even if all you plan to do is echoing strings. Like practically every other piece of software in the world, a new version of PHP doesn't mean they just added new features and that's all, often times preexisting code changes, hence why everything should be considered unstable unless otherwise is stated.
Not if this is your only income as you're still under the standard deduction.
Not really the feature I'm most excited for to be honest. The following for instance: $result = array_column($records, 'firstName'); Is basically: $result = array_map(function($item) { return $item['firstName']; }, $records); Sure, the second is more verbose, but I wouldn't really lose sleep about it.
I do not want to do themes or plugins. So I don't deal with WordPress most of the time. Clients finish caring though, cause suddenly, when they start getting traffic, the blog starts working like shit, why is that? Because they have a simple hosting that Wordpress is taking to the max.
I saw a 4chan post where I think this is from. But do you know why the guy said that you don't need to fork it in the story? That was the only joke in the story I missed.
There's absolutely no excuse to be running PHP 4 in this day an age, it was released more than **12 years** ago ([source](http://www.php.net/ChangeLog-4.php)), let alone the fact it was an abomination. 
I started out charging 20$/hour when I was 16, that was a couple of years ago. I have steadily increased that amount as I've been offered more and more projects so now I usually charge 120$/hour (+/- depending on client). Keep in mind that this is in Sweden, so it's roughly 50% tax on that (15% pre-tax tax + 29% tax + 31% municipality tax). What I've learnt in the trip from 20$ - 120$ is that charging too little is dangerous in long term client relationships. Even though you're a beginner, 12$/hour is not a reasonable market price. For a junior that can accomplish the tax, at least 30$/hour makes sense in my opinion. You also have to estimate hours including reading specification, obtaining the necessary skills for the specific tasks if you don't already posses them so that these hours don't become unbillable hours. Getting paid in installments doesn't really make sense since it's a really small budget. I never agree upon dividing the payment unless it's over 8000$, then I also charge half of the total sum (if agreed upon, otherwise half of the estimated hours) before I get coding. Good luck!
&gt;the exact spec In my experience (on both sides of the transaction) this is impossible and it's best if both parties understand this up front. I prefer to either have a fixed budget or an hourly rate with regular progress reports.
I'd say it's relevant, we're talking about his rate here... so if it looks simple to him, and he thinks he can do it in a 1/10 the original time quoted for, then it just became a good project.
I understand completely now. I thought it was external facing. But yeah much more understandable now. I take back my statements since more info was provided. And also yeah much easier to just write a function than to port over services that are internal only. Upvote for you, since you helped me to understand.
Thanks, i dont understand all the downvotes.
Your algorithm is a naive, but common approach. Here, let me rewrite that to be 1000x to efficient in generating money: $money = $value x $marketing This post by someone else will show you how to apply that with your current skills: http://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer/
x is not an operator. but i guess a programmer would know that.
Maybe they just map array_column to feed array_map... jquery style
I think it's just a useful function to add. You could rewrite `array_keys`, `array_search`, etc. in a one liner as well. Doesn't mean those functions aren't useful to have in core PHP. I understand that's a slippery slope, though. But I've "needed" `array_column` in many cases.
It means the build can fail on many different machines and isn't stable. So even a simple echo could fail in special cases.
Honestly I think it'd be more of a problem. People would see 5.2 -&gt; 6.0 and then say "it's a major update, nothing will continue to work, so I'm not going to upgrade". I think the real issue is that people aren't developing future-proof applications (as much as possible) or don't understand what is in the next version available.
A singleton can be useful the same way a global variable can be, and it happens more often than what you may think. But it's not as often as Singleton advocates may think, either.
Wow, all that snark and so little filler! I hope this doesn't count as cheating on my diet. \&gt; Needs to have data in a format easily handled in JavaScript \&gt; Ideally needs to support object passing \&gt; Calls JSON the latest ad-hoc use case okay.jpg
And how do you document a project?
That's great, I would try one or two if I saw them in my local.
My elePHPant would love this!
You must have an **exception**al sense of humor.
i too enjoy php
The pay seem's far. Finding someone by reference is probably best if your not qualified to interview them on a technical level. If you know anyone technical maybe they could help you during an interview. You can have them sign an NDA to not take your idea. Also I think a decent programmer should be fine getting paid for mile stones. Example: If the project is to take 40 hours, break it up into goals, when each is delivered pay 25%. This limits your risk and theirs. It's best to write everything out and both sign agreeing to terms. 
Please go a little easy on me with your critiques. This is based on [my previous socket server classes and tutorial](http://tech.navarr.me/2010/07/how-to-create-a-socket-server-in-php.html) and is really being used as my first time playing with namespaces and composer and getting a better handle on my work environment and phpunit. It is currently fully functional, as far as I can tell, but it is definitely not yet production ready.
Nothing i write is production ready, acording to this subreddit standards.. And yet it works
Yes well, there's no way to set maxClients, and it's not yet used - not to mention it's barely tested - automated or otherwise. And the Socket class doesn't yet have all the socket functions built into it.
I can't into PHP...actually I don't think anyone can. I still enjoy it though. 
Did you put the barley first, then the hops, or the hops first, then the barley?
"php hoppy pale-ale". recursive acronym
Certainly not trying to come across as negative, but let's be honest: ideas are cheap. You pay for execution. I wouldn't worry about someone stealing your idea. That being said, you can use an NDA as /u/BestGreek suggested. Or, you can write a simple contract stating that the idea and results are yours and have the developer you find sign it. Most of us are used to it. Additionally, if you want a project built correctly, don't estimate the hours for the developer. Let them tell you how long (based on the specifications) how long it should take. Make your decision based on that. One thing that bugs a lot of engineers is the note on any project is one similar to "...shouldn't take too long". If it didn't take any effort, you could have done it the way you wanted it by yourself ;)
Not specifically a PHP based GitHub repo, a step-by-step setup guide for a Webserver running Nginx/PHP-FPM/MySQL/PostFix - a somewhat typical configuration used for/by many PHP web apps/developers. Something I put together a little while ago, based off build notes/text files I use for my own production servers and decided to format them as a nicer Markdown instruction manual/guide. The Nginx/PHP components are compiled from source, so you will end up with the latest stable of both of these. Very little automation here, consider this a “handcrafted” webserver install. Appreciate any comments/suggestions, even if to critique my documentation writing style, something I'm continually trying to improve upon.
Not specifically a PHP based GitHub repo, a step-by-step setup guide for a Webserver running Nginx/PHP-FPM/MySQL/PostFix - a somewhat typical configuration used for/by many PHP web apps/developers. Something I put together a little while ago, based off build notes/text files I use for my own production servers and decided to format them as a nicer Markdown instruction manual/guide. The Nginx/PHP components are compiled from source, so you will end up with the latest stable of both of these. Very little automation here, consider this a “handcrafted” webserver install. Appreciate any comments/suggestions, even if to critique my documentation writing style, something I'm continually trying to improve upon.
So obvious once you see it on a label - nice work :D I'm a big pale-ale fan - so it has my vote.
While this is "best practice", i have to object that "passing it around" is never as safe as having a singleton. Somewhere, somebody could've created a second instance and pass this one around, and while finding the place the instance is created is easy, it's hard to find out which parts of the code use the unwanted second instance. A factory or registry is the way to go, i think. 
Funny, i did this 3 years ago, as part of a real world project. And while it's really cool to learn stuff, it won't ever be able to go into production. PHP is sadly just not built for concurrency and networking :/
I see it more like driving a vehicle tbh...
If you're using "best practices" this should never become an issue, the code should be clean enough to easily debug and if you're testing it becomes even easier. In a larger context, yes use a factory or even a dependency injection container (but use them properly) and this will never become a problem. People tend to use singletons or even static methods purely because it's easier to understand but it is not in any way good object oriented design. 
It really depends on if the beer is open source or not.
**Finally**, someone who gets it.
Yes, but in 90% of its derived usage it's not because we want only *one* instance, it's because it's practical. Quote from wikipedia: "There is criticism of the use of the singleton pattern, as some consider it an anti-pattern, judging that it is overused, *introduces unnecessary restrictions in situations where a sole instance of a class is not actually required*, and introduces global state into an application." For example one may use the singleton pattern for services: accessing them is practical, you can access them anywhere with the singleton pattern. I've seen codebases with this pattern. Now if I come on a codebase using the singleton for services, and if I can't rewrite everything, I'll turn the Singletons into "Optional Singletons" so that the existing code still work, and so that I can use Dependency Injection in the new code that I'll write.
Life doesn't get much more fun than PHP with Codeigniter... unless you know C++ :)
"should" is the key here. In "real world projects", a bunch of people is contributing code to a single project, and the human error factor is gigantic. you wouldn't need unit tests if everyone would be a perfect programmer. Muphys law applies: if nobody should make the error, somebody WILL make the error.
So instead of teaching standards we should use what many consider to be an anti pattern in case your developers don't understand how it's wired together? I'm not having a go here, I just don't understand how you can consider this to be a better option?
So far none of my non-geek friends have gotten the joke when I refer to my beer as "open sauce." I'll keep trying. 
What are you even talking about? PHP's socket functions are just a direct interface to C's, which are at the heart of pretty much any networking software ever.
Yes, but PHP doesn't support threading which makes it totally worthless. PHP is best at http-related stuff, and should be used that way. Reading from sockets is totally okay, but working as a server is unstable and buggy and a hell of misuse of the language.
Oh I agree that different situations call for different methods but there's a reason why best practices change so often, in particular PHP has made huge strides over the past few years and design patterns can become anti-patterns in a heartbeat, this is because we are constantly finding better ways to solve problems. I wouldn't agree with writing "one usage" code in any situation apart from throw-away scripting. Scalability surely has to be a factor in whatever software we are writing? It's not always about reusability, SaaS is a prime example, how much money and therefore profit could be saved down the line if we use these methods and design patterns from the beginning? Therefore planning for growth and making it easier. How many monolithic codebases do you see that could benefit from these techniques? What I'm saying is that we're in a position now where PHP is a serious player in software development and finally shaking some of it's bad stigma, many will say that PHP is not fit for this purpose but I disagree, if we follow these patterns and best practices now, it doesn't ever become an issue for our applications in future.
**If** ^I ^had ^a ^dollar **for each** ^pun ^thread ^on ^Reddit, ^I'd ^^**die** ^^^a ^^^^happy ^^^^^guy. ^^^^^^**else** ^^^^^^^**return**
Aaaaaaand this is why I charge up to twice as much for projects that involve dealing with pre-existing code.
I think you can certainly plan to an extent. I definitely agree with you that monolithic code bases were at the time in "most" cases written with the best intentions with the best techniques available at the time and that's the point I'm making here, instead of using a slightly "less bad" solution for any code, we should be using what we consider to be "state of the art" coding now. Part of the reason for planning for change is that how fast the community is moving right now so loosely coupled dependencies are a MUST. I don't want to have to completely rewrite something 2 years down the line because a component I'm using now has stopped being maintained, especially when I can plan (to a certain extent) for that eventuality now.
In their defense, if you said that to me, I would look at you like you were an alien... just a bad joke man.
a whole PHP? Damn, son!
Threading is not a requirement for a socket server and there are very few cases in which a thread per connection is needed as that's extremely resource heavy. You can write perfectly suited socket servers in PHP that work as well as (or in some experiments surprisingly better than..) other languages if you use the non-blocking calls. If offloading processing to another thread is a requirement for your needs then you can do what PHP does best and separate it completely via a job queue or get some sort of IPC going on. Note: It is *easier* in other languages however.
 if (for_sale($php)) { $wallet-&gt;open(); $address = $shipping_info-&gt;get(); $new_message-&gt;send($address); }
This is really awesome!
Weirdly enough I seem to have been writing pretty much exactly the same thing as part of a CI server I decided to build. I did mine for inter-process communication (talking to build workers) but got a bit carried away with it. Lib: https://github.com/warmans/Cinders/tree/master/src/Cinders/Ipc Some sample implementations: https://github.com/warmans/Cinders/tree/master/cli (badly named files: server is the place all workers connect to, sub_server is a worker and client sends commands to the server to be distributed to workers). I'm still having some problems with handling client disconnects. As what seems to happen is this: 1. Client sends server a message and then the script ends. 2. Server relays message to all workers. 3. Workers send back an acknowledgement. 4.1. Server notices client disconnect and removes it from pool. 4.2 Server notices one of the acknowlegements and tries to forward it to all connected sockets. The problem is 4.1 and 4.2 don't always happen in the same order so half the time it tries to write the ack back to the client that send the original message but they've already disconnected so it generates a broken pipe warning (which at the moment I just suppress). I think I need to figure out some system where the server knows if a message is fire and forget or if it should send the worker responses back to the sender rather than just assuming everything will happen in the right order. ------ Anyway my problems aside I notice you've not gone for a pure socket wrapper class but rather amalgamated factory-like behaviour, a wrapper for a resource and perhaps a socket management bit ($map?). Not to say its any better but the way I thought it should work was to have a pure socket class that wraps a single resource and only does stuff that can be done using a single resource. Then I make a collection class to manage sets of sockets and do the select stuff (though mine has some problems with write and exeption selection). I also tried to make read and write more clever as by default I think they're hard to work with. Not sure why you would want to restrict them to a certain number of bytes. If you want to send a string 20 bytes long just send 20 bytes and equally if you get sent a load of data keep reading until it runs out. Doesn't seem to benefit anyone to receive only 1024b of a 2048 byte transmission.
I know making you one cms is a futile exercise. I did it mostly for my personal enjoyment but now that is gotten almost feature complete I'm interested in feedback to how I have fared.
The Socket class is rather rushed to be honest. The management exists solely for the purpose of Socket select and I might not even need it to be global. So it's methods are all pretty much direct. I haven't gotten around to making them easier yet. 
But then you might aswell just drop the singleton pattern altogether and just remember to instantiate a single object.
No, no, no. Networking and threading are two different concepts, and one does not rely on the other. A crap ton of multi-user server software is single-threaded. Most of it relies on C's native select() function, and guess what PHP's socket_select() is? You should read at least a networking primer before spreading this kind of misinformation. I suggest Beej's guide, as it's been the de facto networking source for as long as I can remember.
Right, but I think you're missing my point. In my experience these crazy old black-box applications are untouched, left as relics of days going past (PHP 4, PHP 5.1, or PHP 5.2) and usually have nothing done with them. If a developer needs to add substantial new features (such as a new user login system or an admin panel as this package may well suggest) then that sounds like a perfect time for a 2.0. Im not some moron who can't understand that people cant always have the newest things every time on every server (not that PHP 5.3 is shiny and new), but continuing to use PHP 5.2 during a recode is negligent.
Can you add a README?
It's a slippery slope. I'm up to like three or four PHPs a day thanks to my addiction. 
In that case you have to refactor the existing code, which you can't always do.
Seems interesting, I haven't read through it all yet. It reminds me of https://github.com/reactphp/socket. 
You will probably be ripped into for recommending CI due to its loose implementation of MVC and OOP but I friggin love it. It was simple to learn and I have yet to find a project I've built that I coiuldnt use it. +1 for CI!
I know socket_select, I used it in my project. All i'm saying is: if you do network server software and need threading at some point (massive concurrency / need for paralellism etc) you are screwed with php. Okay, i admit the "not suited for networking" went a bit far.
Sometimes, I just need to get shit done. CodeIgniter lets me get shit done. Going through the checklist above: CodeIgniter: - MVC - support Mongodb - not incredibly hard to learn - Lightweight / fast - auth system, email, display/redirect and few other components - support for CLI Compare this with Symphony2: - MVC - support Mongodb - ~~not incredibly hard to learn~~ - ~~Lightweight / fast~~ - auth system, email, display/redirect and few other components - support for CLI
Yes, it is true. Even currently developed 3.0 version is 5.2.x.
Should i be concerned about this? I use php 5.4 on my servers 
Ah yes. React is a thing now. My little library is re-inventing the wheel. [Of React re-inventing the wheel.](https://github.com/reactphp/socket) [Of me re-inventing the wheel](http://tech.navarr.me/2010/07/how-to-create-a-socket-server-in-php.html).
FuelPHP / Laravel 4. They're both in active development, and are **changing** for the best (opposite to CI, which hasn't made any big changes in years). Especially with 5.4 and own servers (I understand you have at least VPS), it's totally fine to use a little bit heavier framework (Fuel/Laravel compared to Ci) but with much more power and much better architecture.
Wouldn't pcntl_fork() work in the rare occasion you need to spin up a different thread for something intensive?
Todos los mexicanos usan php?
&gt; footprint It doesn't matter so much. With, most likely, the smallest out-of-the-box footprint (not really sure about it though), CI is much less functional than Laravel. And getting that level of functionality in CI will also get you the same (or even worse) footprint.
Create a class that extends Smarty and set the variable in the constructor or function called from the constructor. This is how I use all template engines because I always want things like a method that automatically includes the header and footer.
That's pretty much the trend with all my jokes. 
could you give me an example. I am familiar with classes and the __construct but still kinda confusing me?
Sí.
Same here! I got away from doing bottles long ago (too lazy to sanitize 50 of them). Now I use 4 minikegs with a CO2 tap. Love it. Open the fridge, there's a little keg of cold, draft homebrew. The latest is a 4-hop dry hopped IPA. 
people still use smarty?
lol what would you suggest in its place? This is for a client also and thats what they wanted..Some kinda template engine in place for their IT guys to take care of once its built.
The [vote](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2#voting) got a majority, but not the required 2/3rds majority - so it's not going into PHP 5.5 or any other version in that exact form. 
[Twig](http://twig.sensiolabs.org/) is lovely. 
Holy crap, you realise you wrote all that? &gt;.&lt; Do you think the time -&gt; karma conversion will pay off in this instance?
It's not inconvienient, it's just doing workarounds for things PHP is just not ready for (yet). PHP has ways to achieve stuff, i grant you that, but it is far from enabling you to use any way you could choose. I used pnctl_fork and stuff to establish exactly what was described, and in comparision to socket server in java, php was far from as usable / reliable as java is. At a certain amount of users, a network project will get on it's limits, and the limits of PHP. You can do everything with PHP, but you **should not** do everything with PHP. I like PHP a lot, but if someone would ask me for network servers which need massive concurrency i would use Python or Java any day. Besides: Which big projects or institutions use PHP for networking? (like games for example)
When you drink a PHP beer you have to explicitly check if the beer is empty or it's just 0% alcohol.
 class View extends Smarty { public function __construct() { parent::__construct(); $this-&gt;init(); } private function init() { $this-&gt;assign('variable', 'blahblah'); } } $smarty = new View();
/r/homebrewing
If you try to drink an empty beer, you'll choke, but drinking a non-existent beer is fine.
If you were forking a process for each user, it's no wonder your performance degraded. Why on Earth would you do that? Just use non-blocking calls and polling like any sane networking daemon and you'll be able to handle as many concurrent users as your hardware and bandwidth will allow, just like any other language. Your problem is not PHP; it's a fundamental misunderstanding of network programming. You don't spawn a thread to handle a user. You *can*, but you don't. You're making your program concurrent in the wrong direction. You use threads (and/or processes) to handle tasks, not users. Things like AI, collision detection, rendering, networking itself, etc. are good candidates for threads/processes. Please [grok this](http://beej.us/guide/bgnet/output/html/multipage/index.html). It's the authoritative source on the subject.
A singleton is used when *only one instance* of a class is desired. Any other use of the pattern is actually a misuse. In most correct uses of it, creating additional instances can lead to problems (e.g. database locks), or waste resources. If it's possible to create many instances of a class without causing problems, then a singleton pattern should not have been used in the first place. I have nothing against the idea of what you did as a workaround for a misused pattern in legacy code, but it's definitely not something worthy of promotion. I would hate to see new developers thinking it's okay to use this kind of anti-pattern.
That looks surprisingly neat actually. :p
All over really, I do some freelance work but I dont look for it as I work full time (No freelance profile, etc). My work generally comes via a WordPress plugin I develop. You could approach a developer that has worked on stuff similar to your requirements. You might end up paying more but you generally end up with a better end product.
I will never understand this reddit. Why would you downvote a guy who's a developer with some good logic and good manners. He's enjoying his programming and his fucking beer when he comes home from work. Fuck you for trying to fuck his brewery. I would drink the shit of that beer man. Keep up the good work!
I only looked at the post on this page and skimmed a couple other files, but things like: * fixed salt * use of eval() * lack of comments, including on methods like "cantThinkOfName()" * Form.php lets you set method to 'get' but then is unable to process input give me echoes of many bad trips in days past. Also, at the end of the day, it's too limited to be useful, but too overengineered and over-abstracted to be performant. I'm not sure what the niche would be.
hi thank you very much * salt is supposed to be fixed per project? I'm missing something? * I understand eval is bad, I used (once) because I had two options, to use it or pre generate models, I hate generating code more than eval * code was not supposed to be released as open source project from the start, it evolved from set of helper classes I needed for my projects to this * Form.php do process input, check [example 2](https://sites.google.com/site/appshellphp/document/form), if you do $form-&gt;number(); and user type none numeric value, you get false as value I have nothing to say about the rest, you could be correct.
I think this is the right way to go with things like Database drivers. Most projects only need one database connection so singletons make more sense for queries. It's also counter productive to be passing around object instances everywhere. Once you need more than two database connections you can get away from singletons although the class could be designed to allow you to "switch" between database connections it stores references to internally within the class and/or with a label. Static singletons just make more sense for utilities like this, especially when you need to combine multiple scripts that have nothing to do with each other. You can call a static anywhere but instances require sometimes some very hackish techniques to call object instances in different scopes.
Check out www.koken.me. Really elegant UI and much cleaner code than wp. 
[Stackoverflow](http://stackoverflow.com) - It's not just for PHP, but you'll find loads of useful information here. Search before posting anything because most likely someone has already asked the same question before. [PhpFreaks](http://www.phpfreaks.com/) - You can get involved here as well.
I doubt /r/php will be receptive to your CMS. It is poorly designed to say the least. I know you spent a bunch of time working on it... however, it reminds me of very early php scripts. Honestly, I don't know where to start. 
SitePoint's PHP forum is also good: http://www.sitepoint.com/forums/forumdisplay.php?34-PHP And not only PHP...
[www.phpacademy.org](http://www.phpacademy.org)
That one if filled with bad and outdated practices. I would recommend to stay away from phpacademy.
I usually start with a Google search and 9 times out of 10 end up at stackoverflow. I need to learn to start there...
I had a similar issue before, and it turned out that it was a new line character at the end of one of my `?&gt;` tags at the end of my files. For example, one of my files looked like this: &lt;?php ... php code ... ?&gt; -- end of file Anything after a `&lt;?php ?&gt;` in an `include`'d or `require`'d file will be sent to the client. That is why it is common practice to omit the `?&gt;` tags at the end of your files, so it does not accidentally send any whitespace, like line 4 in my example.
[Devnetwork](http://www.devnetwork.net/) is fairly good, but not as active as it once was.
I quite like http://www.dreamincode.net/
And eventually the wheel becomes perfectly circular or you end up with slightly different wheels each designed for a different issue.
Phpthrightway.com pretty much all I need.
codingforums.com has a php section
definitely SO, but i also like php.net
I agree. These minor point updates are fair and accurate, because a 5.x to 6.0 jump should be "this is going to break some shit" that is beyond the deprecation -&gt; removal process. 5.x to 6.0 should be a "put some effort in or go home" upgrade, and that is not what happened in 5.2 to 5.3.
Is there a single class in this project? 
Agreed, I'm also on here. One nice thing is there are people who have advanced programming experience that can provide great help on some of the toughest issues, as well as guide (ok some times shove) you into the proper way to do things. Great forum.
Used to be my primary source for PHP help and discussions. I think the author of Swift Mailer was an active member there, so says a lot about the quality of users. Must admit I usually just go to Stackoverflow now.
&gt; I still think projects should have per project global key or salt. Well, that's simply wrong. What's your argument in favor of a global salt? It makes it much quicker to reverse your password database.
people still run out of memory in php?
Phpfreaks also has an IRC channel if you need help sooner. Irc.phpfreaks.com #help
Normal threading is one of the worst ways to scale up network concurrency, it has way too much overhead. Evented IO, as demonstrated by servers like nginx and libraries like libev and libuv, is way better.
I love vagrant when I'm coding on my linux box, but VirtualBox is way too unstable/slow on OS X :( I hope they get a vagrant+parallels plugin someday. 
http://info.magento.com/rs/magentocommerce/images/Magento-Extension-Developers-Guide-v1.0.pdf This. Almost 80 pages long, just to write the simplest extensions. Some Magento dev once said "if you have too much budget, use magento, otherwise use anything else." I worked a lot with OXID. It's a lot simpler, although it has some really awkward and sometimes ugly stuff in it.
&gt;literally blow your mind No.
Put a .htaccess file in the docroot (domain.com/) as follows: RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^search/(.*)$ /search/index.php?search=$1 Then in index.php: if (strpos("search/", $_SERVER['REQUEST_URI']) === false) header("Location: /search/".$_GET['search']); Pretty sure that will work, you may have to play with it for a little bit. :) Good luck!
 Thanks for the tip! But I ended up using the existing htaccess file, and throwing this in the index. It works just as well, I think. if(strpos($_SERVER["REQUEST_URI"], '?search=') !== false){ header("Location: /search/".str_replace(' ','_', $_GET['search'])); }
In addition to this does you estimate include developing a full test suite, documentation etc? Also I would be surprised if it didn't take 10 hours at least to get a full grasp of the problem. If, however, your time estimate is accurate I would suggest it is very fair.
You're already on it.
I don't know much about pub/sub but I remember reading that Redis is good for this sort of thing. Might be worth taking a look if you haven't already?
&gt; I have to agree here, if you really need one instance of an object then do exactly that, instantiate it and pass it around. How is it better to have to pass an object all over the place?
&gt;When you fetch a big result set, your client library typically already has it in memory LOL - what? If you are using buffered queries on large result sets you are doing it wrong.
Several reasons, the main being that by using a singleton you are creating a coupling to the global scope. This makes testing, scalability and testing much harder. By "passing an object around" I simply mean use the dependency injection pattern. With a good dependency injection container it is very easy to keep track of your objects and even create a shared instance of the object that you would normally be using the singleton pattern on with no need for static calls at all.
I have redis installed... I am talking about a websocket server.
I use Virtualmin GPL and it works fine for me
In general your `isset` + `!==` is better, because it ensures that the value is indeed an empty string and not something like `0`.
Your theme have 1 major problem, you cant change the page title...
The biggest oddity that I find with the code is that while you're using objects, you don't implement an autoloader. Adding a simple autoloader, and giving the classes a sane directory structure, would clean up those include statements.
Thanks for the input. Ideas are very cheap and i actually built a alpha but knew in order to be a sellable product I would have to get it done professionally. NDA seem to really only hold up with US and Canada. I will not be going offshore do to this. 
Doesn't mean its best practice.
there should be no problem if the code is tested. if it is not ,it is bad code anyway and i guess they prefer a broken application to a secure one...
This article is a little elitist and doesn't understand some of the most important tenants of open source software. A library I recently open sourced requires PHP 5.4. My company has standardized on certain standards which are compatible for 5.4 and the software open sourced will conform to the same. And yes, from what it appears in the source, it seems only short array syntax is the reason for the requirement, but it's part of our coding standards. It's open sourced out of generosity and doesn't have to be. I guess I shouldn't have done it since otherwise I am an "idiot", "hurting the community". Or maybe I should violate our company standards to satisfy versions of PHP we do not develop for anyways. And we might move to 5.5 and update some of our code appropriately (e.g. ::class), so I guess I better go close-source it to save the community. pffff
In addition: Type hints. Lots of missing type hints.
"That's the joke."
Well I knew it would not do to good but I didn't assume it was so bad as now appears. Guess that says something about my knowledge of PHP then. I'll probably keep using for my own sites as I myself was actually pretty content with the way it worked and proud of that achievement. Thanks for the honest answer anyway.
Adoption of new versions of PHP is becoming much faster. The fact that PHP 5.3 has a majority _before_ hitting its end of life is awesome :) It's a common pattern that only early adopters get on board in the first year, then the "free to do what they like but cautious" folks next year, then some quicker hosting companies, then slow-ass hosting companies. http://w3techs.com/technologies/history_details/pl-php/5/y It's a 4 year cycle. PHP 5.4 only came out a year ago, so we're exactly where I would expect it to be. Next year it'll be about 30% and the year after we'll be breaking 50%, hopefully pushing 60%.
A couple of places to start would be to add input filtering and to figure out how to not have the database files be publicly available.
I've spent a bunch of time on this problem. I haven't tried integrating it into Silex, just sorta made up my own app framework around Rachet. I looked into ZeroMQ and Mongrel2 as well and found this http://www.photon-project.com/. I agree that PubSub is the way to go but there aren't many great solutions on the client side yet besides SocketIO (I tried http://autobahn.ws/js too, which was a little better), which there is no PHP backend for. So I switched to Python, which has a SocketIO server. Even then, it's really tough to get the code organized beyond a few events or wrapped around a few DB/ORM models. Every attempt so far has gotten really messy really quickly. I'm thinking that I need some CRUD ORM on both ends (client/server) with WebSockets just shuffling the data back and forth. I tried using Backbone models for that but WebSockets are different enough from REST that it just needs rethought. Same for the backend ORM. I think that the application has to be thought of holistically from the ground up, I just haven't cracked it yet. I need some natural way to use events to sync CRUD ops on both ends, or think of a new ORM or data store that works better with an event-based protocol instead of MongoDB or MySQL. Yeah, Redis makes sense there I guess but that'll also take re-thinking how my app works. Maybe that's worth it though so thanks for the tip. I also just found this http://blog.jmoz.co.uk/websockets-ratchet-react-redis, maybe that's what you're using. It is probably worth just going with NodeJS and SocketIO, for sanity's sake, since there's a lot more people spending time on this problem in NodeJS than there are in PHP or Python. Taking a step back, though, I think it's worthwhile from an infrastructure perspective to separate your websocket server from your actual app code. You'll probably want to add in QoS things like queueing, load balancing, etc. Have a server manage the WebSocket traffic and just shuffle the events over to your PHP/Python/NodeJS app. I think that makes a lot more sense in a scaling sense. I haven't seen any tools do this yet. Maybe a separate Go app would do the trick? Maybe the new NginX WebSocket feature helps with this? It's also why I started looking into using Mongrel2. I'd love to see more info covering this topic out there, so thanks for asking about it. I could see a fully client-side app model that gets all it's data from WebSockets in the future. Why not? :)
Thanks for your insight. I had played with a NodeJS implementation using Faye this weekend and also tried a bunch of other approaches but I need a solid PHP Client... The problem I have is that I need to publish from the backend and have the server update the clients. This is easily done with Ratchet but I don't want to use ZeroMQ because I think it's overkill for a simple PubSub. I expect that Redis is a much better option. You are correct, I learned a lot from the jmoz PoC you linked to. Now if I can just figure out a good solution for authentication... *sigh* I think that there are a number of Nginx solutions that are viable. But there again... I am putting myself in a situation where the product I am developing would have a hefty setup... since not that many hosts nowadays offer Nginx as an option.
Ah crap, is it bottle_open($opener,$bottle) or open_bottle($bottle,$opener)?
Wow, awesome. Thanks so much man!
who cares what doc tool he uses, if I loaded this up a proper IDE, no benefit. uh, I just showed what's wrong with using extract(). It's a very dumb thing to use. It over rides the current scope. It is VERY BAD PRACTICE to do this and just because you can find it in other people's code is no excuse to continue using this pattern. function foobar($important, $data) { // I think $data['foobar'] is ugly so I do this: extract($data); if ($important == true) { // IMPORTANT STUFF MUST HAPPEN HERE } } foobar(false, array('important' =&gt; true)); There is no justification for using extract(), NONE. Learn this, live it, and be a FAR BETTER PROGRAMMER for it. Let me repeat myself: **THERE IS NO VALID REASON TO USE EXTRACT()** And to justify its usage because other people did it, is crazy. You know how many people do things like: mysql_query() or die('error')? So are you suggesting this is somehow a good thing? Stop using extract()
&gt;It over rides the current scope. extract($vars, EXTR_SKIP); I find plenty of valid reasons to use it, but eh, different strokes for different folks. It just makes some things easier. I will not stop using it. You don't have to use it but I will not stop :)
it does make anything easier. This isn't different strokes for different folks, this is just foolish. There is no predictability, it is very difficult to test, you need a lot of over head, because you're just too damned lazy to use an array, or better yet, a class, to properly define that the input should be. It is extraordinarily bad practice to use extract() and whatever pros you can possibly muster up will be outweighed (to the point of being crushed) by the cons. You turn off register_globals, you dno't use extract(). BAD BAD BAD
Hey, no problem. I've outsourced a few jobs before: the key is to already have your implementation guidelines already in place. Meaning, have a decent codebase.that someone else can add new features to. That's true, simply because it is highly unlikely that you will want to try to bring charges against someone not even in the same country. That being said, once you find a good developer, just be nice. We love what we do, and noisy of us are loyal to our customers. Personally, I know something I help develop will need maintenance and new features down the road, so NDA or not, I treat my clients with respect and act accordingly anyways. You need to find someone who you can see a long term business relationship with. 
Test suite? That is something that I would build into the original cost, and not try to bill separately for. Most clients will never know or care that such tests exist. Documentation depends: quick and dirty documentation, probably would not bill for. If it needs to be fancy, then yes, I would bill for it. It always helps to have a deep understanding of the problem being solved, but it really depends on the situation.
$12/hour is less money than you would make working as an entry level helpdesk phone call monkey, or as a Windows reinstall jockey for the Geek Squad. You're charging too little, by roughly a factor of 8-10. Everyone say it with me: Programming is not a minimum wage job. Ever.
Yeah, it really is.
Nothing says "awesome internet advice" like "Commit tax fraud."
/r/php is grossly over moderated. Just look at the new tab. There's maybe 1-2 new articles that make the front page and they're usually stupidly bad practice code and or a terribly written article. I'd honestly rather have noob questions and the like then 1 good article every 2-3 days.
This is probably not something that should be a part of core. Sorry, but one of PHP's existential problems is the fact that because it lacked a centralized way to distribute packages efficiently, anything that was considered even remotely useful got crammed into core seemingly without thought for the consequences on future versions of the language. Now that PHP *does* have an effective way to distribute packages (via Composer), the practice of cramming anything that could be remotely useful into core needs to stop. In fact, something like 80% of core should probably be stripped out, ASAP, and moved to packages. 
Without seeing full source, its hard to say. Without know what's wrong, what isn't working, and any errors you're getting, its even harder to say. 1.) &lt;script&gt; is not necessarily for PHP. the &lt;?php and ?&gt; tags handle that. 2.) Are you adding that PHP code snippet to a .php file? 3.) Is PHP installed and running? 4.) What *exactly* isn't working? What do you expect and what actually happens? Any errors?
Disagree on just about everything. &gt; This is probably not something that should be a part of core. Sorry, but one of PHP's existential problems is the fact that because it lacked a centralized way to distribute packages efficiently, anything that was considered even remotely useful got crammed into core seemingly without thought for the consequences on future versions of the language. Do you have an argument for why the HTTP stuff shouldn't be in core, other than the stale argument of "there's too much in core already"? That argument says nothing to the relative merit of the HTTP extension being included. &gt; Now that PHP does have an effective way to distribute packages (via Composer), the practice of cramming anything that could be remotely useful into core needs to stop. PHP doesn't have that, the community has that. What's the difference? PHP can't control, support, warranty, nor guarantee anything produced by the community (and rightfully so). Perhaps if Composer was included with the standard builds it'd be a different story, but it's not. &gt; In fact, something like 80% of core should probably be stripped out, ASAP, and moved to packages. [Nobody is stopping you.](https://github.com/php/php-src)
I think they failed to cite samy kamkar's work on this: http://samy.pl/phpwn/
Ha! Ha ha! No, /r/php died about 6 months ago when the mods never stopped personal attacks on quality posters here, such as StoneCypher and others, while simultaneously banning people attempting to give out good advice, like ircmaxell. Not so surprisingly, several people belonged to both categories. There's no longer so much trolling, but that's because the mods banned the people who were being attacked constantly by troll accounts such as [**PointsOutBadCode**](http://www.reddit.com/user/PointsOutBadCode) who only attacked one guy over and over, instead of tackling the bigger community issues such as ever-diminishing lack of good content (esp. after they banned core PHP contributor ircmaxell...)
If it's only short array syntax + open sourced, someone can do a backwards compatible fork for older versions if he needs it. But this guy makes a good point. Developing for PHP 5.4 just for the syntax sugar makes no sense in software which is distributed to clients / outsiders. It's less problematic for open source, but it is problematic. Not for your clients, but for yourself. It's like releasing software only for Windows 8 (or even 7 only), or only developing for android 4.2 because of convienience reasons. You unecessarily limit your range of possible customers / users. Of course, that doesn't mean "support every PHP version on the planet", but you should at least support one version backwards, as rule of thumb.
I know how you feel bro. As far as i know, Zend Guard currently still doesn't support PHP 5.4. Luckily i now develop SaaS projects only and can circumvent using any Zend product. Zend usually needs ages to update the obfuscation stuff.
Not reporting less than $2,000 is barely committing tax fraud...
but most of all, Samy is my hero
Protip: Avoid using short tags. Even if they're enabled on your server, they might cause trouble when you transfer code, and you're only saving three characters anyway.
Your github account looks interesting and I plan on looking through it later. Keep up the good work man!
&gt; I am defiantly missing something Yeah! Stick it to the man!
Why take offense? It's not like Phil's post is a rule written in stone. You have a specific scenario in which you have good reasoning to not make your library backwards-compatible with 5.3, and most people won't debate that. The title is "Pick PHP requirements for packages responsibly", which you've done. &gt; As long as you understand that the usage will be much less and are ok with that (like Aura) then that's fine, but don't release some generic Geocode or OAuth 2 package as PHP 5.4 just because you prefer [] over array().
I pretty much do the same these days but I have been a freelance developer for almost 13 years and some of my clients have been with me for nearly that long. 
&gt;I am defiantly missing something Here it is: www.d-e-f-i-n-i-t-e-l-y.com
Sure, whatever. It's still pretty ironic to come on here and ask for recommendations of other forums. That's like going into McDonalds and saying "I hate your burgers, can you recommend a good burger joint?"
&gt; Do you have an argument for why the HTTP stuff shouldn't be in core That's not how adding things to core works. You (should) need to have a compelling reason for why something *should* be added to core, not why it shouldn't. &gt;PHP can't control, support, warranty, nor guarantee anything produced by the community In all honesty, the PHP team barely seems to be able to support or control their own language. Things like unicode support were supposed to be added years ago, but weren't and now aren't even on the roadmap. Why? Because the internals are a mess and they're not good enough to untangle it. Decoupling the different parts of core, namespacing and then updating them one by one means that so many things that PHP is missing (Strings as objects, for instance) could be added piecemeal, instead of never being added due to the fact that it would break so many of the older parts of the core language. Certain parts of core, like the mysql* and mysqli* functions could continue to *exist*, without being bundled with or updated as a part of the core language. If you needed those packages, you could simply install and include them separately, even though they might not have been updated in years. There's a reason we don't design major applications by lumping a whole bunch of unconnected functions and objects in some global scope. Why would you think it's a good idea to design a language like that?
I just can't quit short tags. Sometimes instead of echo or print I'll just do: ?&gt;hello world&lt;? // equivalent to echo "hello world"; Yeah, I know that's probably bad. This is my confession.
People will be arguing about using 5.6 or 5.7 by then. :)
&gt; That's not how adding things to core works. You (should) need to have a compelling reason for why something should be added to core, not why it shouldn't. I agree, and I've already listed 2 compelling reasons, but I'll reinterate them... 1) PHP was invented for, and is still primarily focused on, serving requests (e.g. handling requests and responses), and b) every single framework has reinvented this wheel. And your only rebuttal is that "there's too much in core already", which obviously doesn't address my points at all. I agree, core does have too much! But that says nothing about the appropriateness of HTTP in core. &gt; There's a reason we don't design major applications by lumping a whole bunch of unconnected functions and objects in some global scope. Why would you think it's a good idea to design a language like that? What kind of non-sequitur is this? I thought we were discussing whether or not HTTP belongs in core, not what my opinion is on proper language design. Regardless, PHP's design is what it is, and the relative merits of design decisions and implementations are a completely different argument than the one I signed up for.
This is at least the 3rd time I've seen this today; comments downvoted for correcting misinformation because people don't want the truth.
No, and with good reason: &lt;?xml version="&lt;?= $version ?&gt;" ?&gt; Will work with short open tags OFF. With short open tags ON it will give a parse error.
right. i was talking specifically about this http://nginx.org/en/docs/http/websocket.html - you cant do the same thing in apache. its also better than just straight up exposing your app on port 80, 8080 or whatever.
Reddit is not a forum, nor is StackOverflow. I am, personally, looking for a vibrant PHP forum where I can carve out a little niche helping people out and not have to worry about the downvote troll sockpuppet brigrade and where basic civility is rewarded by the community. Something not so threaded, but more egalitarian, and not ruled by up vote ratio. Still lookin'.
I love the design btw, no images :)
by the way, if you figure all this out be sure to let us know. :)
Maybe it was my horrid grammar.
Oh I'm sorry, did I provide working code? FOAD with your downvotes. Help this group out again I won't.
Wouldn't it be easier to type "echo"? What you do still involves four characters, but they're less accessible and require the shift key. You're actually creating more work for yourself.
echo "hello world"; has 4 _more_ characters (two quotes, space &amp; semicolon). Plus you don't have to worry about proper string escaping (handy in certain contexts). The only time short tags have ever caused me a problem is at the beginning of an xml file (&lt;?xml...) and that's easily avoidable (&lt;&lt;? ?&gt;?xml...) I just don't get the outrage against them.
If you're willing to pay 100/hr, (30-50 hours for 3-5k) go with a web agency! You'll have an entire team at your disposal to produce the project the way you want and since it's essentially a brick &amp; mortar company, you have much less risk of losing a deposit and a means of support if bugs appear, as they sometimes do. If the agency you choose is as good the bunch i work for, then you'll have an app you're proud to stand by. With that said, the company i work for is a small group of talented designers, devs, and project managers, and if you want some contact info + links to our site, just PM me.
Wow. I've been out of the loop a while apparently (reddit hiatus). They banned ircmaxell? I've been trying to provide advice to this subreddit for years and combat the continued inanity, and they're banning one of the few people who actually contributes on a regular basis? It's been good guys. [I'm out.](http://i.imgur.com/cX0ItZb.jpg)
do you have be a math major or something to understand this? This seems like magic to me.
facebook.com/home.php
Wordpress.com, Wikipedia, (Facebook), Flickr, Yahoo Answers, ... ~80% of all Websites use PHP. (http://w3techs.com/technologies/details/pl-php/all/all) &gt; Before talking about the amazing things the PHP community has achieved recently, let's have a look at some interesting numbers: PHP is used by 77.9% of all the websites whose server-side programming language is known. WordPress is used by 16.6% of all the websites in the world. If you have a look at the top three CMSes, for the websites that use a monitored content management system: Wordpress is first with 54.3%, Joomla is second with 9.2%, and Drupal is third with 6.8%. Three products written in PHP. http://fabien.potencier.org/article/64/php-is-much-better-than-you-think Moodle: https://moodle.org/stats/, https://moodle.org/sites/ Magento: http://www.magentocommerce.com/product/enterprise-whos-using-magento
The problem here is I don't think codepen.io runs server side code, which php is. Codepad does, http://codepad.org/MYe3B8SD but I suggest either getting xampp installed locally if your really interested. Also Amazon AWS is free for their micro tier. Edit: on second thought, your probably won't get file access commands, your best bet might be to install http://www.apachefriends.org/en/xampp-windows.html
There is merit to the criticism if the applications are externally accessible and/or mission critical and you guys don't have the resources to secure the applications or environment. That being said, their argument is clearly incorrect - PHP can be quite secure. You should demonstrate that your applications and the systems they run on are secure. 
[NASA](http://www.slideshare.net/jjtoothman/nasa-and-php) 
It's only as secure as you make it.
I'm pretty sure the white house website and quite a few other us government websites are run on WordPress, which is of course written in PHP. Edit: or it might be drupal. You should check on that before citing this as fact. 
White House is indeed Drupal: http://www.whitehouse.gov/developers
I'd start looking for a new job. The people you're working with are not very smart and having to constantly fight stupid isn't worth it. If you insist on staying, the easiest way to defuse this situation is to ask them to show you an exploit for one of your tools. If it's as secure as you believe it is they won't be able to hack it.
I would not recommend wordpress as an example of well engineered secure software. Popularity doesn't instantly mean "well designed" or "most secure" and if the people he's arguing against do even a minimum amount of research to refute it the'll figure this out and it will backfire.
I try to keep all text output until the end. Instead I may do something like: &lt;?php $pb = new PageBuilder(); $pb-&gt;appendBody('string'); $pb-&gt;build(); This not only is good practice, but it prevents you getting header() and session issues with text being output prior. :)
http://www.microsoft.com/web/webmatrix/php.aspx "Are you a PHP developer? We love PHP too." But realistically, you will not win this battle. If you do, you've likely lost a larger war, and things may never improve without a mass exodus of entrenched players. The fact that you have "mission critical" stuff running on PHP should already mean it's "company approved" - WTH? What does "it's not secure" mean? By what measure? There are language-level exploits in almost anything out there - you have to have responsible/educated developers to avoid security holes. If security really is a concern, get mgt to agree to some research and testing time for you (and others) to test and harden the current setup. Document everything, involve multiple parties. Less work than switching to something new/unknown, and alleviates their stated issue. 
Facebook's "PHP" is highly customized. I don't think it serves as a good example. Edit: People, FB doesn't use _any_ of the Zend engine. They use code that looks like PHP with a compiler and engine that isn't anything near what the OP's original question references. There's plenty of documentation about this, but here's a good start: https://www.facebook.com/note.php?note_id=10150415177928920
All right, four then, but I would still argue that echo and the quotation marks are easier to type than the arrows and question mark -- the difference being negligible, of course, but all of this is besides the point. XML is one of several reasons why short tags would not be turned on for a server, and just because they're enabled for your development environment does not mean they'll be enabled for the production environment. This becomes especially relevant for something you're exporting for public consumption; a Wordpress plugin, for example. You should strive to be consistent with your coding practices, and because &lt;?php will always work while &lt;? will not, most formatting guidelines encourage use of the former in all situations (barring a very good reason to do otherwise).
Etsy is a pretty large e-commerce site and they use PHP.
&gt; This release also marks Elefant 2 as feature-complete. Congratulations!
Yeah, if you're releasing something for public consumption (like a wordpress or drupal theme/module), absolutely use the long tags, because many PHP installs have short tags disabled. But with all the sins PHP has committed, this has to be the least dangerous. I can &lt;% %&gt; all day in Ruby on Rails, why can't I use something just as easy in PHP? Also, In 10+ years as a PHP coder I've never seen short tags turned off on a production machine. Long live short tags! &lt;??&gt; &lt;??&gt; &lt;??&gt; &lt;??&gt; (I can type these REALLY fast) Look at how close those keys are on your keyboard. It's EASY to type, even with shift down. It's almost like they designed it to be that easy.
I was once fired, yes, fired, for trying to have a polite argument with the lead DESIGNER in a company when they mentioned they were going to trash all of the work that had been done so far, all custom PHP written in-house. They were changing over to Joomla. I'm not saying Joomla is bad, just not sure why the hell you'd re-write an entire website (was in the touring industry dealing with planes, flights, tickets, etc...) The point here is, you're up against idiots, and even with all of the best logic and arguments, you're going to loose and be outcast, eventually. I'd start looking for more knowledgeable people.
Thanks!
Which could be used as an argument against it. They'll say "but PHP wasn't good enough so they had to reinvent it".
&gt;Maybe you could also point out how much time and money is being wasted on the subject This is an underrated point. Upper management generally responds more favorably when you can break things down in terms of monetary cost/gain.
Ding Ding Ding. The only argument that needs to made. 1)In what way is my code insecure.. I've prevented against XSS via the following ways (ie. parametrized SQL) 2)I store client passwords encrypted with a dash of salt 3)I ensure I'm sanitizing/validating client input were it exists. The list could go on. I don't know why I'm still subscribed to PHP sub, I've come to really dislike the code I have to work with. None the less, scripts I've written in PHP or programs written in any other language for that matter, ought to be evaluated on their merits. If one of those merits happens to be, we can improve user experience, and lower overhead by using a different language -- I think that is valid justification.
&gt; *encrypted with a dash of salt* This is now my favorite way to say that passwords have been salted. 
I used to work on an with 8 million daily users. It was written in PHP. It's fast as hell and scales extremely well if you know what you're doing.
Thank-you for the help John. This solved the issue, thank-you kindly. 
PHP isn't any more unsecure than any other language/tool, PHP is just older and easier than rest which means more newbies are coding with PHP which in turn means more flawed code with security holes in it.
Don't waste too much time on rebuttals. Probably just throw a few out there like: [Google, Facebook, Yahoo, Wikipedia](http://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites) (and you could go on and on, wired, jquery, techcrunch, arstechnica, slickdeals....). You might point out that no matter what language, what matters is the code the programmer writes. The language is secondary. You might also point out that all of the computers there run Windows. Why? There are unarguably more attacks performed against Windows than any other OS, so why aren't all the machines running Linux or MacOS? &amp;nbsp; Honestly though, *forget all of that above*. Cut to the part that matters: **the money**. &amp;nbsp; **What is the business case for re-writing all of your custom code in a different language?** How long would this take (eg, how much money will it cost them)? What do they stand to gain for doing this (eg, their Return On Investment)? Can the proponents of using a different language present a business case for switching? Can they demonstrate how the current code is insecure? If they can't, then **you don't see a compelling reason**. They are the ones that need to bring facts to the table. **You don't want to waste the company's money.**
So basically I'm right. You've never dealt with traffic even approaching facebook's traffic. In fact, the traffic you propose is less than 1% of their traffic. Facebook has well over *800 million* users. That's almost 11.5% of the population of the planet using facebook. The fact that you just issue the statement out of hand that "php is fast and scales" like it's some universal blanket statement makes me think you're making stuff up. There are definitely things that PHP does well, but there are many others it does really badly.
Most random number generators work by taking a seed, an initial value. All of the numbers produced by the random number generator will be a dervied from that seed. Here is a simple random number generator: function generateRandomNumber($seed = null) { static $lastvalue; if ($lastvalue === null) { $lastvalue = $seed % 32767; } return ($lastvalue = (97 * $lastvalue * $lastvalue) % 100); } And this is what it outputs when seeded with the number 1364279816, the output of `time()`: Seed: 1364279816 generateRandomNumber(1364279816) = 77 generateRandomNumber() = 13 generateRandomNumber() = 93 generateRandomNumber() = 53 It is really common for programmers to use the current time as the seed. If you're using a random number generator this way that is not cryptographically secure, and the attacker can guess the seed used by looking at the timestamp sent by the webserver, they will be able to guess the series of numbers the random number generator will produce. For something like a gambling website, this would obviously be devastating. On a more general level, this means the attacker might be able to guess things like randomly generated CSRF tokens or session values. 
Damn, you're right.. :D
1 user != 1 human
not every one of those users uses the site every day Edit, we had over 500 million accounts in the db. It was a facebook app. Over half of facebook users have used it.
Which is factored in. Facebook has nearly a billion accounts. Honestly, beyond google, I'm not sure how many other sites could boast traffic on facebook's level. It's more monstrous than you think.
another link dump since i've been looking a little more into this... /r/websocket/ http://lostechies.com/derickbailey/2012/04/19/decoupling-backbone-apps-from-websockets/ http://stackoverflow.com/questions/10535007/how-to-integrate-websocket-with-emberjs http://www.reddit.com/r/webdev/comments/13ovf5/which_websockets_server_is_the_best_fit_for_me/
They are using Apache, and there are two common methods for doing this, one is an option in .htaccess to tell the server what page to feed out for 404 errors (see http://www.htaccessbasics.com/404-custom-error-page/ ) Another method is for sites that are using some type of CMS, where they want to be able to assign URLs to the particular pages. (most people use these now instead of /index.php?id=44) What these do is turn on ModRewrite for apache, and set rules that say "if the requested URL is for something that is not a file and is not a directory, call this particular file (usually /index.php). Some will also pass the url as part of the query string into index.php, some figure it out on their own. So, once index.php is called, it will look in its database to see if some type of content is associated with the URL being called. If so, it processes it and feeds it to the visitor. If not, it sends out a header message to tell the browser the result is 404 Not Found, and then feeds out the page programmed for their 404 page.
[These stats](http://www.digitalbuzzblog.com/facebook-statistics-facts-figures-for-2010/) are from 2010. Those numbers have more than doubled since that time. Compared to FB, you don't even rate an honorable mention.
Well then we'll agree to disagree. I'll keep using php to create fast, scalable, feature rich websites and you can do.... whatever it is you're doing.
I'm not suggesting PHP isn't working for you. I'm suggesting that it didn't work for them, and because it didn't work for them they had to heavily modify it. If you were dealing with traffic on the same scale (and really, none of us do) it probably wouldn't be working well for you either. If you go back over the comments, that was the whole point of what I said.
best seo services
Aaaaaaaand reported.
What is a "company approved" language? What sites have been built in that language that are "secure"?
For 2011, those stats suggested there were 500 million active users and that about half of them logged in every day. That's 250 million. Thelerk said their application got 80 million daily users. That's about a third of Facebook's daily user count (In the year 2011, which doesn't count as long, long ago in a galaxy far, far away). I'd say that's worth an honorable mention, and it's attributed to PHP. Also, I've always heard talk of Facebook's heavy modification of the language. Is there a resource you can point me to that talks about it a little? I'm pretty curious. I think OP could probably still make a point about PHP in Facebook, if not just a passing mention.
Congrats! (The naming convention is a bit confusing, though. If i understand correctly "2.0 beta 4" is the same as "1.3.3", right?)
Yes and no. Afaik, FB uses normal PHP and just compiles it with HipHop, but the basic code is absolutely ordinary PHP. (correct me if i'm wrong)
I've come to love extract. The only thing you'd need to ensure is that it comes up with new variables instead of casually overwriting yours. This is done by a flag, EXTR_PREFIX_ALL, and is used like this: extract($_POST, EXTR_PREFIX_ALL,'post'); // all vars will be called post_%KEY_IN_THE_POST_ARRAY% I've found facilitates writing method signatures like this -&gt;doSomething($param1, $param2, $options = array()); which can be a cool thing to have if documented properly.
~90% of all websites are PHP based ... edit: not strictly true, but then the vast majority of hacks are done by exploiting vulnerabilities in insecurely written modules / plugins for popular CMS's. Nothing to do with PHP...
Based on OP's post I think they are easily wooed about any large known site using PHP without any security flaws. Wordpress is a good example in my opinion.
It's not replaced in some places. They use hip hop to convert the PHP code to C++
The business question is not so much, "Why can't we stay with PHP?" but, "Is it worth throwing away all the business logic and infrastructure behind our battle-tested code?" If people with a grudge against the language have support, you're fighting an uphill battle. If logic and reason will not work as weapons, well, keep your resume up to date, because there are larger issues at hand. This is of course assuming that these anti-PHP sentiments are not fueled by dangerous flaws and poor design decisions throughout your codebase. :)
The thing about it is that it would be reactionary research. Just enough to pick apart the points you're wrong about. Even if it's only one thing, they'll focus on that.
And for 2012 they have [a billion users](http://techcrunch.com/2012/10/23/facebook-announces-monthly-active-users-were-at-1-01-billion-as-of-september-30th/) over half of which are active every day. These numbers are increasing every year. Y'know, I ramped this up a step at a time just to see if you guys even bother to do your own research. What a disappointment.
Have you ever *looked* at the wordpress codebase? I don't know how anyone who has actually seen it could defend it.
That's quite different if there's ever a situation where multiple variables are true.
Oh, right! You are correct. Have an upvote
Do the managers care about what the code looks like? They're only interested in seeing large companies using PHP at scale, to prove that it isn't worth their time deprecating it and removing it's use throughout their systems. Considering wordpress.com is one of the most popular sites on the net, it's a great example, given this context. No-one here is defending it, it's purely a demonstration of PHP being used by a large company.
Reddit *is* a forum. You cannot argue against that. And if you want to help people out, it makes no sense to go looking for a forum when Stack Overflow is by far the best place and fills all those requirements you posted. And your help you give will live on past your post instead of being buried in a mountain of noise.
look up hiphop php
agreed, however... there's nothing about a *language*, but often common libraries in different ecosystems have varying degrees of security. Part of the reason people choose a language is because of the libraries/frameworks available. If the majority of those happen to be more tightly tested/audited/secured, then choosing 'language x' (and using those libraries) will probably result in something more secure than other options. 
So, let me ask you: You think it's a good thing, to take a nice, organized array of variables, then spit them out into the current scope with a prefix, taking up twice as much memory? Stop using extract(), it is bizarre.
Your demo page: ReferenceError: $ is not defined ...){$.elefant_version='1.3.3';});&lt;/script&gt;&lt;script src="/apps/admin/js/jquery.jgrow... demo.e...cms.com (line 12) ReferenceError: $ is not defined $(window).load (function () { demo.e...cms.com (line 45) Happens upon subsequent requests to the page, probably due to cached content trying to access non-cached material. 
I would use a switch in this case also. switch($var){ case 'a': ... break; case 'b': ... break; case 'c': ... break; default: ... break; } Where $Var can equal 'a' || 'b' || 'c' || else 
&gt;The naming convention is a bit confusing, though. Extremely confusing.
Programmers who only know one language, tend to not increase in value very quickly. Why not embrace the change, get paid to learn a new technology tree (.NET, JVM, Python, etc), and then enjoy the fact that you are now worth more, with access to more jobs. And the beauty about JVM is the wide array of languages you can use. You don't HAVE to use Java to use the power of the JVM or the Java ecosystem. Check out Groovy (http://groovy.codehaus.org/). We migrated from PHP over to Groovy and it has been great. It's an excellent stepping stone into the Java world, and familiar enough to anyone who has done PHP for years.
Yeah, I over-reacted. Sorry about that. And thanks for not mimicking my attitude, as I actually deserved.
I do know about sef links. I use them myself on my own projects with a custom php route model. I also have a custom error handler for your second paragraph. Although it doesn't response with headers, it just redirects to error controller and prints 404 template file when something isn't found. (can be missing values from database, missing controllers etc.) I knew we could configure custom 404 pages in Apache (thankfully now confirmed) but how can I make it web server independent and configuration independent? I mostly work with Apache, Wamp and Nginx. Using the same .htaccess for each of them would work? Last one is, let's say I have 60 images on my homepage and 3 of them are missing. The homepage will be generated by PHP, browser will try to load those images, .htaccess will handle 404's and forward them to my PHP files, and my PHP files will output a 404 html page. 3 inexistent image will produce 3x 404 html pages and those HTML pages may be a fullscreen divs containing special styling. The entire website layout will break then. Am I going to get such kind of problems, and if so, how can I solve it? 
You're welcome. sorry I was such a jerk in my later comment. It was totally uncalled for but I'm not the "delete post" kind. I am glad it helped. I think the issue was possibly in the php setup. It can be told to look for php in .html files but I don't think it does by default. I'm not sure that's the issue exactly, but that's my guess.
A framework is not an absolute necessity, but nonetheless it is very useful - I wouldn't say that t here is a clear leader in frameworks as each have their own way of doing things which better fit into your workflow than others. I would certainly go with a framework that implements composer (http://getcomposer.org/). This will open the door to useing a lot of framework independent packages and libraries without the horrible shoe-horn hacks that you would traditionally need to do to get third party code to work with your flavor of framework. For the record I develop with Laravel3(http://www.laravel.com/) to which I upgraded to from CodeIgniter(http://ellislab.com/codeigniter), Laravel4 (http://four.laravel.com/) should reach a public stable release some point this year and has the additional benefit of using composer for managing project code including much of the core. Another framework that while I have a great deal of interest in, I haven't had a chance to use yet is Symfony (http://symfony.com). All the frameworks I have mentioned above have an excellent community - plus with the addition of Composer support you have a much wider code base of mature libraries to choose from. Documentation is pretty good on Laravel3 and they have improved upon this for the Laravel4 documentation, Symfony's documentation is also really well written. As with all these things there is a pretty steep learning curve in the beginning but it does flatten out pretty quickly once you get used to the tools that these frameworks provide and the methodology behind their actions. Scripts, etc is covered by their use of composer, which is a PHP package maintainer, it essentially opens the door to a potentially vast array of code which is framework independent so one package will work just as well in say Symfony as it would in Laravel4. I hope this helps, more than it hinders.
Respectable programmers should be charging $100/hr, not $4k flat fee. ;) Contracts are never as static as they seem
Actually, you can use apache... just might not be the ideal server for it. http://activemq.apache.org/websockets.html https://github.com/disconnect/apache-websocket I found this yesterday and am playing with it. It isn't a PubSub server but I suspect I could add Redis support. https://github.com/thunderpush/thunderpush UPDATE: https://github.com/jordanhalterman/redmq
If the application isn't working properly, then by all means rewrite it. If the application is working just fine then leave it. If it needs some updates, then update it but if it's working properly there's no reason to rewrite it.
I guess if you wanted to run a PHP application faster under IIS or with additional .net packages?
WordPress also powers [1 out of 6 web sites on the Internet](http://www.forbes.com/sites/jjcolao/2012/09/05/the-internets-mother-tongue/).
THIS! Don't waste time trying to convince people that PHP is 'good'. They don't agree; trying to change their minds is fruitless. Instead, make them do the work. Provide a clear, simple run-down of the costs of building the software to date. Explain that it works (it does work right?). Challenge them to find evidence of security breaches. Make them do the work of costing a proposal to replace existing systems. Make sure they factor in development, hardware, training, migration, fall-back. Make them list of the time requirements. Make them develop upgrade paths. You're the incumbent; use it! No company will ever drop an existing system simply because 'PHP isn't secure'. Where are the numbers??
er, it doesn't matter whether you use strong typing or not. user input should never be trusted and should be sanitised before being used in a SQL statement and before being rendered to the browser. Java strings are just as capable of containing &lt;script&gt; tags or ' as strings in PHP or any other language. can you point me to a specific vulnerability created by loose typing 
Call me crazy but, how are you going to implement this with switch? Let's say a is true, and the rest are false, the first if block will run, then if(a) block will run. if(a) can be converted to switch/case, but what about the first if block?
yep, but its not just user input, bugs in the code are more common in loosely typed langs like PHP, and such bugs can themselves create vulnerabilities. I've been coding php for 6 years and moved to Java recently, so I know what I'm talking about.
Good call. I fix people's busted Wordpress sites every day. Over, and over and over again. The real sad thing is that it has nothing to do with my job. I just feel bad for people with Wordpress!
I use it to take screenshots of some websites, so the designers dont need to go through every page to see if everything is as it should be
Same here on a weekly basis. I help out a company that has about 50 clients using Wordpress. They've invested so much time and money into keeping people from hacking Wordpress and fixing the ones that do get hacked, that they could have paid someone to make a proprietary CMS!
He wanted brutal honesty and said he doesn't take things personally.... 
That's called being a poor programmer. I don't create bugs in my software. I've been developing with php daily for 16 years, and I manage a team of developers, so I know what I'm talking about. 
 if (a) {} if (b) {} if (c) {} if !(a || b || c) {}
We use the 1.3.x numbering which will get bumped up to 2.0.0 once it's stable. So it's tagged like this: * 1.2.2 - Elefant 1.2 stable series * 1.3.0 - Elefant 1.3 dev series (will be come Elefant 2, so first beta) Hope that makes more sense. Version numbering is also [explained here](http://www.elefantcms.com/wiki/Contributing).
I think it's a minor, choice-based, nitpicky-maybe thing. I also think that worrying about memory usage when you're confronted with the choice of using it is premature optimization. I also think that your personal ("nice, organized" is you talking) appreciation is yours and shouldn't be imposed to anyone else, at least if you're not a team leader and you want your rules applied. In any other context it's sanctimonious bullshit. To me, passing humongous arrays conflating all sorts of pretend-parameters around is a convenience thing only, and accessing said undifferentiated blob of data all the time is stupid ugly when you have the option of working with dedicated variables for each thing, but I wouldn't dare impose this concern on people whose output I'm not entitled to meddle with. What do you think of the complementary call, compact()? 
1.3.x is the development series that will become 2.0 once stable, so 1.3.0 = beta 1, 1.3.1 = beta 2, etc. The beta numbering was to let people know that it's leading up to 2.0 :)
You're correct. They have some extensions that give them static typing and a template system they developed, but it's all 'regular' PHP script. The JIT compiler they are using now is actually pretty awesome. 
Those tags are a lot easier to type when there's nothing between them, which should basically never be the case. And most of the production environments I've worked on have not had them enabled, but I've done a good amount of freelance work too. Anyway, I guess the idea is that, since you can't always use them, you may as well not get into the habit of using them -- and again, most style guides discourage them for that reason. If you know they're going to work, there's nothing strictly wrong with them -- it's just not an ideal habit to be in. A major selling point to PHP is how portable and easy to deploy it is, so undermining those qualities to save three character just isn't doesn't seem worth it.
Programming is not about ease of use, it's about being smart. Pointlessly taking up twice as much memory while at the same time being inconsistent, is not only unjustifiable, but it's not even the path of least resistance! So no, it is not sanctimonious bullshit. It's just being smart. I don't know why you think you have "dedicated variables" for anything when using extract(). You do not. You have an array of arbitrary size that you explode into numerous variables of arbitrary names within the current scope. These variables are NOT references to the items in arrays, they are COPIES. So, you waste resources. You waste resources by making PHP work pointlessly to assign an arbitrary number of variables, you waste memory by making unnecessary duplication of data, and you waste cpu cycles again because of unnecessary GC. If you wanted anything at all that was well defined, predictable and self documenting, then you wouldn't be using arrays in the first place. You'd obviously use classes. As for compact(), why on earth would I use it? It's fucking stupid! $array_of_shit = compact("who_cares","huh","where_did_i_come_from"); vs $array_of_shit = array($who_cares, $huh, $where_did_i_come_from); Now tell me, which example will produce an "notice" because $where_did_i_come_from doesn't exist?
The three conditions on a, b and c in your example are mutually exclusive - only the first that is true will execute. In the OP example, all three - a, b and c - can be true and all three results executed.
The issue appears to be resolved now. The thing is, I was getting the same issue on your tumblr blog as well. 
You have offered the best response for OP. Have upvotes!
Drupal is written in PHP, btw. Edit: need more coffee, misread a whole lot of stuff.... &gt;_&gt;
&gt; It only works well now because over the years people have added to it So it is bad now because it was once bad... &gt; Wordpress is really not nessecary. Bootstrap and 2 php files can do the same things. People just lost the ability to "develop" beyond a button click. You know, those people I know that run their own little music or art projects, or are designers DON'T WANT TO FUCKING CODE SOMETHING THEMSELVES OR $2K TO GET IT DONE ...
 $noneMatch = true; if ( a ) { // ... $noneMatch = false; } if ( b ) { // ... $noneMatch = false; } if ( c ) { // ... $noneMatch = false; } if ( $noneMatch ) {} cons: initally looks a little ugly pros: may add as many more conditionals without it becoming much uglier in the long run 
Code quality does not matter to small businesses or private persons. Things must work. That's why Wordpress (or PHP for that matter) is popular. It works. And it works damn well.
I also have a question for you guys, Does anybody know how to set the width of the browser window?
At first, this might seem irrelevant. Read anyway. ;-) I once read a book called the [48 Laws of Power](https://www.google.com/search?q=48+laws+of+power) which discusses ways one can achieve power. A long description of the book is unnecessary here, but one of the principles is that you should let facts speak for themselves. You should tersely and clearly lay out the evidence others have presented here (such as the excellent post by WedgeTalon) and leave it at that. You will either win the argument and be able to move on with your life or lose and they can later decide to feel the pain as the embark on project after project to replace system after system. Another of the takeaways from 48 Laws of Power is similar to what SkepticalMartian expressed. It won't do you much good - and may work against you - to continue arguing. While you think you're being sensible (and all of us probably agree), if you're surrounded by idiots you're not going to get much except more resistance. IOW, start refreshing the resume.
Or if (a) { } if (b) { } if (c) { } elseif (!a &amp;&amp; !b) { } Even w/ just an if at the end, I personally prefer not negating nested sets of conditionals.
You need to stop writing for a second and consider the non-issue you're making such a huge fuss of. Your opinion is not going to be regarded as anything but an opinion regardless of how much you rant about it. &gt; I don't know why you think you have "dedicated variables" for anything when using extract(). Because extract($hash,EXTR_PREFIX_ALL); creates all new variables based on the array keys. What's not clear about that? By calling it this way, all your conflated variables get split into logical units you can work with separately, instead of through a nondescript bag. It's also a good idea to do it before all your other variable definitions, so you don't really overwrite shit, even if you are expected to think about what you are doing and thus are expected to pick a prefix that won't collide with other things. &gt; So, you waste resources. Which for one is a stupid thing to care about in initial development since you're *not* running inside a PIC. In this particular case more resources are wasted in abusing the config INI into an object, and is also something you should only care about once a problem is detected with your memory consumption, not before, because it generally leads you down a path of pain when you end up ditching clarity for small performance gains. In most applications you'll most like waste orders of magnite more clock and memory in a random external library that does a textbook implementation of a design pattern, or if you underestimate the actual depth of a recursive call. Both are better candidates for optimization once a problem is found than an Oh So Wasteful 400B in extra allocation that will let you find symbols 40x easier when you're debugging / refactoring. This should be extremely evident for someone who is all about *smart*. &gt; These variables are NOT references to the items in arrays, they are COPIES. You can do EXTR_REFS and have your variables reference whatever they were holding in the original array. RTFM before complaining about nonexistent problems. tl;dr: You're not only talking out of your ass, but you're misplacing concerns and passing some of your fears, clearly stemming from your broken personal abuse of the functionality, as actual problems. Chill.
 if (a) return do_something_a(); if (b) return do_something_b(); if (c) return do_something_c(); return do_something_else();
 if(!($a || $b || $c)){ } elseif($a){ } elseif($b){} elseif($c){} Edit: I put the negation first, because if they're all false, then you'll be good and jump right in, otherwise you'll need to hit each elseif. The readable cases are below. 2nd Edit: PHP $'s 3rd Edit: If you need to check each variable, in the case of multiple being true, then the way you have it is already the best way. All False{} A{} B{} C{}
But the implementation of a language can be bad. I remember [this horrible bug](http://nikic.github.com/2011/12/28/Supercolliding-a-PHP-array.html) a little more than a year ago. Could bring any PHP server down in a very simple way.
Thanks for the advice! Can you please tell me the reasons why you moved from CI to laravel? I'm currently looking at Code Igniter due to the sheer volume of documentation, but would like to hear your experience with it :)
&gt; Because extract($hash,EXTR_PREFIX_ALL); creates all new variables based on the array keys. What's not clear about that? By calling it this way, all your conflated variables get split into logical units you can work with separately, instead of through a nondescript bag. Wrong. You are taking a nondescript bag, and emptying it all out on the floor and creating a mess. There is no predictability in your variable names other than the prefix, a prefix that already existed anyways by the name of the array you're extracting. &gt; It's also a good idea to do it before all your other variable definitions, so you don't really overwrite shit, even if you are expected to think about what you are doing and thus are expected to pick a prefix that won't collide with other things. Except that this is not a concern if you don't use extract ;) &gt; Which for one is a stupid thing to care about in initial development since you're not running inside a PIC. In this particular case more resources are wasted in abusing the config INI into an object, and is also something you should only care about once a problem is detected with your memory consumption, not before, because it generally leads you down a path of pain when you end up ditching clarity for small performance gains. You are the one ditching clarity. function doStuff(Array $array) { if (isset($array['key'])) { // do something with this } } function doStuff(Array $array) { extract($array, EXTR_PREFIX_ALL, 'prefix'); if (isset($prefix_key)) { // do stuff } } The variable $prefix_key does not exist anywhere in the code other than this function. This is not clear. It is inconsistent with the rest of the code base. Programmers should have to do as little as possible to understand what the code is doing. extract() does not do this. &gt; You can do EXTR_REFS and have your variables reference whatever they were holding in the original array. RTFM before complaining about nonexistent problems. Fair enough. But even dumber. function doStuff(Array $array) { extract($array, EXTR_REFS); $key = 'foobar'; } $array['key'] = 'awesome!'; doStuff($array); There is nothing clear about the code I just wrote. Even if $key was prefixed, it's still not explicitly clear what is going on here. There is pointless code, extra documentation, extra places where things can go wrong. And for what? well, ABSOLUTELY NOTHING AT ALL. If you need something that isn't arbitrary, use objects instead of arrays. &gt; Chill. PHP has a bad rep because of attitudes like yours. It's not healthy for the community to keep permitting bad behavior in programmers.
Hacks that stem from the base WP install are extremely rare. It's the bullshit code in some plugins that cause the problems.
CI and Laravel are different tools, they can do the same job but I found Laravel to do the job better in my opinion. Laravel3 requires PHP 5.3 and above because it makes use of a lot of new bits within PHP - for this reason and the fact that it supports traits, closures and namespacing out of the box is why I chose Laravel over CI. In addition I found testing within Laravel to be very easy and its ORM flawless in my opinion. A framework is simply a tool, and what I am saying is simply my opinion, I would suggest you build a small "test" project using each framework you are looking at and see which tool best fits your use. I would certainly choose a framework with composer support baked in because it will make it extremely easy for you to write framework independent code - essentially enabling you to share the same code with zero modifications between two frameworks, where the best framework for the job at hand can then be used without causing headaches. Once again, I hope this helps. TD;LR Basically I switched to Laravel3 for its namespacing and PHP5.3 codebase plus it made testing easier.
Like most any programming language out there?
There's a firefox plugin that allows you to set the window size
I know you can set the width of the browser with some commands to selenium, but I dont think PHPUnit_Selenium2 can add commands to selenium.
This I didnt knew existed, but I think the funny thing is that I could use phpunit for it :)
&gt; You've never dealt with traffic even approaching facebook's traffic And pretty much no one else does, either.
I think it looks fine how you have it. You're not nesting it 3-4 levels deep. The real question is, what are you trying to do inside the IF that you are perhaps trying to keep from repeating or copy/pasting? **EDIT** You could possibly do an `if( in_array( value, array( a, b, c ) ) )` so that you could easily expand it later by adding more values to the array rather than another `||`. This presumes you create the array beforehand and not hard code it like I did in this example.
Could you clarify something here? How should one use a common API in different projects (or parts of a project)? I mean, using one over the web (even on LAN) sounds like it would create some overhead. Or is it still counted as an API if you use it as a common component in your projects?
right - there isn't anyone here who even does an appreciable fraction of facebook's traffic. I think only google can really compete with FB on that level. Of course, the entire point of the statement was to highlight the fact that facebook's use case for PHP is *way* different from the use case of everyone else. PHP couldn't work on that scale, which is why they did their own thing.
I mentioned those as two different options. 1.) Build components that can be reused between applications (preferably via Composer) which avoid you needing to copy and paste changes between 2, 3, 4, 100 applications which are all different parts of the same thing. 2.) Build the data and business logic in a RESTful API then hit the same endpoints in your different apps, meaning that you can have "dumb" apps, use different languages and different frameworks for different things, etc. Frontend = EmberJS, Admin = Laravel 4 with Bootstrap, some new prototype for a client dashboard or new service = Rails, whatever. HTTP = slow, but how slow? A lot of people do this same stuff with HMVC requests which is not actually that much quicker. If this is on AWS for example then hitting the private IP's and keeping traffic inside the network makes this blazing fast, and by making sure your server is nice and quick (Nginx + PHP-FPM &gt; Apache) and caching whatever data you can means you've build a nice app that will scale and support more "Areas" of applications easily. Building multiple "sites" on one core API is way more useful than copying and pasting around loads of Laravel 4 models with the same methods and same relationships. That gets unmanageable REALLY fast.
This depends what kind of array you have already and how you got it that way (fgetcsv, fread then explode, etc). A quick look through [here](http://www.php.net/manual/en/ref.array.php) might help you find some relevant array functions. It may also be worth asking yourself if you need 2 parallel arrays, since a multidimensional may be better and easier to use. If you can't find what you're looking for can post the relevant snippet?
When in doubt, grab a Composer package: https://packagist.org/packages/keboola/csv Your CSV is fine, but it's insanely simple to break fgetcsv and exploding in various different ways. If you're using this package then you just need to foreach and use the $row variable. Done.
I wasn't going to respond to this, but since you've gone and lied again, &gt; PHP has a bad rep because of attitudes like yours. It's not healthy for the community to keep permitting bad behavior in programmers. PHP generally has a "bad rep" (usually among people who, like you, can't be arsed with pesky pragmatism) because * there's a minimal barrier of entry * all of [PHP Sadness's entries](http://phpsadness.com/) * some cases of extremely sluggish bug fixing * some extreme displays of poor decision making inside php-internals people None of which, as you can see, is actually because "extract() considered harmful", or "developers favor one way of coding over another". Unless you can actually present a bugfix where the main cause of the bug was an unwatched extract, it's a non-problem. For reals. I mean, if it hasn't been actually abused anywhere, and there's thousands of actual working legitimate uses of it in the wild, it's only reasonable to think of using it as a matter of personal preference. As a sidenote, you seriously need to do something with that attitude of yours, it's eventually going to do you a huge disservice.
&gt; trying to get rid of a lot of mission-critical software At this point I'd be polishing my resumé and leaving a documentation trail bigger than the Deepwater Horizon spill. I don't think it's your code they're trying to get rid of.
The issue with just feeding out a 404 page without the proper headers is that when a search engine indexes your site, they will take those links as actual existing pages. You should really use: header('HTTP/1.1 404 Not Found'); For your last paragraph, there are two options: if you are using ErrorDocument method, then you can tell it to call a PHP file. In that file you can check the file type being called: &lt;?php $url = parse_url($_SERVER['REQUEST_URI']); if (preg_match('/\.(jpg|png|gif|js|css)$/i',$url['path'])) { echo "The document you are looking for cannot be found."; exit; } ?&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Page not found&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Your regular 404 page goes here with all of its &lt;img src="images.png" alt="images"&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Now if you are using the ModRewrite method, where you are putting the conditions to say if it isn't a file and isn't a directory, also add one in that also says if it isn't \.(jpg|png|gif|js|css)$ (sorry, I don't do these much and would have to look up how to exactly format it) then pass to the main site handler. This way if it is one of those extensions, it will pass through the normal apache 404 handler. 
The outer condition in OP example is redundant. **doobdargent**'s example is kinda the best option, I guess
Thanks for the clarification! The HTTP "slowness" is what I was worried about, but I suppose it's not really that big of a problem, especially with caching. I currently have an L3 application, on a VPS, with the front-end, administration and administration API (for AJAX calls) all in one. I suppose it could be better to separate that. The application is also deployed separately, on the same VPS, for different clients and the "instances" don't actually have any difference in the "core" code (client-specific parts are separated and the application is built to support that) - sounds like an API would actually be a lot better here so the same code doesn't need to be repeated in every instance.
This is strange, and I'm not sure I follow why there's an elseif there.
the elseif says !c 
I think this way is more confusing to follow than the OPs.
Thanks so much for the in-depth reply! A small test project using each one is a great idea :)
Agreed
The claims the OP is trying to make absolutely depends upon the compiler. The managers are not saying "I dislike the syntax of PHP;" they have whatever issue with PHP as the popular Zend project. Citing a large installation that had to _rewrite what most people call PHP_ is not going to help OP's cause. Think if you were arguing for not using PHP in a project. Would FB's implementation push you for or against it? I'm not saying don't use PHP; I'm saying there are better actual examples than FB.
[Possibly related](http://www.reddit.com/r/iiiiiiitttttttttttt/comments/1a58k8/the_joy_of_public_sector_it/)
1) Show them how Java isn't secure, then watch them jump out of windows to their death. 2) Get that promotion you wanted.
Also, don't debate languages. Languages come and go. Debate your ability to create and port things to the language that is needed AND keep it secure. If you have plans for checking and controlling security, it's more impressive than simply stating X language is secure.
&gt; it seems only short array syntax is the reason for the requirement Does that really offer any sort of performance enhancement to your application though? Seems silly to require PHP 5.4 just because you want to do `var my_array = [];` instead of `var my_array = array();`
It would push me for it. It offers me choice. Because FB saw that the standard php interpreter doesn't fit their purposes anymore, but they needed the productivity PHP gave them. It's a huge argument for PHP, that there are alternative implementations which deal with issues like performance, so you don't have to rewrite all production code. It's just very economic.
If it's just a website, hell, you rewrite it every 2 or 3 years. (or use an upgraded framework / cms etc version) I once made customers to thrash their inhouse solution for a rented SaaS solution.
I understand the "PHP is not secure" argument to a certain extent. PHP gave, and gives, you a lot of oppurtunity to fuck up. This is a "tradeoff" for the productivity you have with PHP. It's like C++ / C. You can do everything with those two languages, but you also make horrible mistakes in those languages if you don't know what you're doing. The choice "Which language do i use?" is mostly dominated by the following question: "In which language are my developers proficient?" or "How many people can i hire in my area which have experience in $language?". Frameworks, software libraries, all that is secondary for a company. What counts is the manpower available, and nothing more.
The code doesn't do anything, I would just omit this whole portion.
Uh. It's been here for over a year. 
argh. I see - so it's not just some local crazy rules:) ok then. Thanks for this information - I couldn't find that anywhere! 
As a company, we use PHP 5.4 for many reasons. And since we want to maintain array initialization consistency we require short array syntax. It's just a simple case of the standards where it was originally developed bleeding into where it is now.
What does wordpress do for those people that plain html can't do on a portfolio site? Also why would a designer use a wordpress if they can't make something on their own? They'd have to know something about development to make a theme... why would a designer not want to design their own site? I mean really a designer should be ashamed to use a template they didn't make, right? The eCommerce capabilities of wordpress are just awful, and that doesn't mean they're full of awe. woocommerce is the clunkiest crap I've ever used. I was a payment system engineer for many years, I feel I have the qualifications to call woocommerce crap. The point is, one size does not fit all, and part of the problem with wordpress is that they make it seem like it does everything everyone will ever need. but hey, when your only tool is a hammer and you your only skill is swinging your hammer... everything looks like a nail. Also, designers should keep them self educated, at least at the elementary level, in development. It's important to be able to speak with developers and have meaningful conversations. Developers have to be a bit educated in design to do a good job. Design goes far beyond the bounds of an image.
If you request an image and it doesn't exist, the output of the subsequent 404 page will not be injected wherever the image was requested. You aren't going to have 3 instances of 404 page HTML embedded wherever you wanted the images to go -- you will just have broken images.
Yeah, the elseif is goofy. It was more of a statement about negating a whole set of conditionals instead of inversing them individually.
You could you know.. start your own. ;D
you could try http://phantomjs.org instead ;) pretty much made for this
&gt; How am I able to correctly read/write to a word document? If you can't be bothered using pre-existing solutions, write an Office Open XML parser. The spec for that is [here](http://standards.iso.org/ittf/PubliclyAvailableStandards/index.html); ISO 29500 part 1-4. Should be easy, it's only five thousand pages of documentation to read through.
Thank you so much! This is exactly what I was looking for! I'm kind of new at arrays in PHP, so I always thought that PHP only allowed one-column arrays; that's why I asked about setting up two seperate arrays. But you helped a lot, sir! Have your upvote - it is but a shame that I can't give you reddit gold right now; trust me, I would if I had $3.
You have my up vote. Specifically about let the money do the talking. 
Sounds more like a: cheap shared host, weak password, to many untrusted installed plugin, to gracious of write permissions on directories, no ssl cert installed, behind on core and plugin updates... type of a problem to me. 
They kept the 2.1.x and 2.2.x branches separate. The 2.1.9 release is an update to the 2.1.x branch while the 2.2.x releases are different. 
you're right. I'm not paid to admin their server or to make it right. I'm paid to fix it when it's broken. I do tell them they need to fix their server because Plesk isn't as great as it seems either.
So it'll be that much easier for you to upgrade to Symfony 2.3 in May :)
point-point release
I can understand CI vs Laravel, but Zend is a different beast. You could compare Zend vs Symfony, which will be a lot more fair. ~~I personally think Symfony is the winner because of Composer, and Laravel4 second because of the same reason. Also, they have very powerful CLI and testing included.~~ Edit: ----- Ah, should have checked before writing this comment. It seems like ZF2 has is composer friendly. Thanks guys. 
Ty your explanation. So for this guys process, when he connects to a php server, he gets a sessionID and from that he can figure out the servers seed for it's PRNG, and then once he knows the seed, he can figure out random values and use this information to do malicious stuff?
Its common sense when you've been working in both languages for 5-6 years. So many times I've encountered bugs in PHP related to how equality works (e.g ==== failing because a number was being converted into a string etc), whereas such things are always caught by the compiler in Java. Also code like this is caught by the compiler in Java: boolean getResult() { return true; doProcessing(); } Because it tells you that the code below the return true will not be executed. PHP will happily go on with this code and it'll go undetected until you've done thorough testing which many people never do. Same goes for code like this: boolean getResult() { boolean foo = getFoo(); if (! fooo) return false; .... } Here, the 2nd 'fooo' has an extra o, and you'll immediately get a compiler warning that this variable is not set. Whereas in PHP this code will also happily execute. 
PHP is no longer terrible. But it evolved into Java
 new Reply\Replier\Replying\Interrogative\What\Are\You\Talking\About\You\Little\Bitch();
Pretty sure the problem is you're overwriting the $result variable. Three other things I noticed about your code: * Stop using the MySQL extension. Instead use MySQL**i** or PDO. The MySQL extension is old and deprecated. * You seem to have an extra brace at the bottom of your code. I'm not sure if it's your indentation or if Reddit may have messed it up... but I would stick to a consistent indentation style. * Avoid using the statement: endstatement syntax and stick with the traditional brace syntax. Two reasons for this. One, it's simply easier to read and you'll make less mistakes. Two, (most) code editors can't match up the beginning and ending. They can however match up the braces quite easily. Hope this helps.
&gt;But it evolved into Java Frankly, I don't see that as a bad thing.
Not very testable, where's your factory? :-)
The attacker would connect to the server and get the time on the server from the HTTP headers: http://reddit.com/&gt; headers Server: AkamaiGHost Content-Length: 0 Location: http://www.reddit.com/ Date: Wed, 27 Mar 2013 06:42:11 GMT Connection: keep-alive Using this information, an attacker could figure out random values generated by the server. It's a little more involved than that, but that's the basic premise.
So do I. We have enough shiny langs for rockstarninjas to talk about all the time 
&gt;Where if the request is an AJAX request, it will only return a view of the content and not the entire site layout, and then you can simply replace an HTML div How is this even considered as a problem?
this :)
Hi, Reading here might shed some insight: http://symfony.com/doc/current/contributing/community/releases.html In a nutshell: Symfony have 2.1 on long term support to give people plenty of time to migrate from 2.1 to 2.2. i personally have Symfony 2.1 projects that would require work to port but while i run 2.1 I still need to be comfortable that any security issues would be addressed.
You've got code snippets in the [github repo](https://github.com/reactphp/react). It should give you a good idea of the ease of coding. React works using an event loop, which is essentially a while loop which executes callback listeners at specified intervals (or you can use true events if you got the libevent PECL extension installed). Any code within the event loop will be called asynchronously, while any code following the event loop's run() method call won't run until the event loop has finished executing. Questions?
Agree. A very anticlimatic ending for an otherwise fine read.
Two notes I'd add to this: It looks like you are calling functions to do things without passing what you are acting on, such as: while($row = mysql_fetch_array($result)): output_results(); endwhile; // second while How are you access **$row** from within **output_results** function? My guess would be by using **global $row;**, which in general will lead to hard to follow code. It would be good practice to actaully passing it information you are acting upon. I agree on the limiting the use of the the alternative syntax style of while (and others that have it as options), except for when writing a "view" section of code, where the PHP is minimalistic. (and then, make sure you have proper indentation)
Not trying to be funny. But you might be looking for the Chain of Responsibility pattern.
Zend!?
Just a heads-up: /u/ircmaxell got (automatically) banned, because of posting too many links to his blog. Nobody complained, it's just something Reddit's algorithms decided to do, and the admins couldn't do anything about it. ^(If I understood correctly, that is.)
Your current code, you could just do a single query, as you're retrieving the list of ZipCodes and then chosing from them within a certain distance. Why not just ask for the users zipcode instead of getting a list and then run the second query depending on the users Zip? Alternatively, if your distances are stored in a database you could call up a query such as this (Not checked and possibly broken) SELECT * FROM event WHERE zipcode = (SELECT zipcode FROM areas WHERE distance &gt;= $distance);
Java I can deal with. PHP involving into Java **EE** is what scares me.
When it starts talking about the positives, towards the end, it's really about the positives of the frameworks built with PHP, not PHP it's self. Compared to most languages, PHP is still a mess. Too many inconsistencies, and too many different things bolted together, which ends up making life more confusing rather than simpler.
The whole Ajax section at the end of the article was straight out of left field. Really? That's our issue at the moment, bad Ajax? Otherwise a decent article.
and yet we still use it, because even with all its horrible flaws, its productive
Assuming $a, $b and $c are all booleans: $result = $a &lt;&lt; 2 | $b &lt;&lt; 1 | $c; if ($result === 0) { } if ($result &amp; $a) { } if ($result &amp; $b) { } if ($result &amp; $c) { } EDIT: Actually, it's not worth doing any of the other checks if $result === 0, so: $result = $a &lt;&lt; 2 | $b &lt;&lt; 1 | $c; if ($result === 0) { } else { if ($result &amp; $a) { } if ($result &amp; $b) { } if ($result &amp; $c) { } } Which is starting to get a bit unwieldy.
It's not a framework... it's a library. Ask the developer and he will tell you.
And this is what I hate about namespaces.
Running SQL queries in a while loop is *really bad practice*. What if the first query returns 20 or 50 or 100 results? You're gonna run hundreds of queries per page. If possible, use one query to get the events within a certain distance. For example something like `SELECT *, (position-$user_position) AS distance FROM event WHERE distance&lt;100` If the distance calculation is a bit more difficult, you would probably be better off simply selecting all events to start with, calculate the distance in the loop and display it if it's in the right distance. Or, select the zipcodes as you are doing now, for each one calculate a distance and if they are within range add them to an array like `$closeZipcodes[] = $row[0]`. Then run ONE query to get the events from the zipcodes: `'SELECT * FROM event WHERE zipcod IN ('.implode(',',$closeZipcodes).')'`
It works just like Node then. I was hoping to hear other peoples' benchmarks and experiences with it. I might have to test it myself, pitting it against Node.
Pays the bills 
I don't know of a specific React benchmark but here is one for Ratchet which is based on React. http://www.cargomedia.ch/websocket/benchmarking-websocket-servers/ My experience with Node.JS is summed up by a single word... "bugs".
If I could find a job using Ruby or Python, I'd probably be using Ruby or Python. Where I am you're either a PHP developer or a .NET developer.
I read somewhere once that the namespace-hate wasn't actually derived from anything concrete. Developers just didn't like that it used a `\`. If they had changed the examples to use the more familiar `-&gt;`, people were suddenly fine with it...
No, I'm looking at the 10 level nested deep namespace. The symbol doesn't bother me as much.
Thankyou!!! The simple problem was I was overwriting the results variable stopping the executing of the first query. So that's that. Now, I need to figure out how to make it more efficient. Thanks again, Cheers.
I feel like you are alluding to what I want to do with my code but I have always been confused working with arrays. Could you maybe do a simple mock code to get me started? Thanks for your detailed answer and cheers.
My biggest gripe with Java is the pervasiveness of extreme modularization and abstraction, and bending over backward to adhere to patterns. I understand the value that interfaces and abstraction can bring if there's a good chance that the underlying implementations will have to be swapped out at some point, but I feel like there's way too much overplanning, overpreparing, and overabstracting going on, to the point where there's a lot more extra work done than saved. Abstraction and modularization create trade-offs, and they should be treated as trade-offs, not universal best practices. The worst part of the trade-offs, for me, is it ends up serving as a form of obfuscation when I have to crawl through dozens of classes just to see a codepath that amounts to a few practical lines of code. Trying to comprehend a piece of code becomes more about assembling an elaborate contraption in my head, rather than simply following a set of operations on data. As an example to illustrate the difference between "the Java way" and "the PHP way", I like to look at the stack traces of a typical web app. In Java, I'm not surprised to see a stack trace hundreds of calls deep, even for a relatively simple app that happens to be built on some common frameworks. Meanwhile, I can't say I've ever seen a PHP stack trace deeper than a few dozen calls. It's so much easier to follow the code when it's flatter. And, in my experience, I just don't see the benefits that all that extra modularization in Java brings.
Nginx doesn't use configuration files in the web content area like .htaccess. Instead, that stuff gets set up in the main server configuration. In that sense it's like IIS.
PHP needs more AJAX?
That is what you should hate about incorrect overuse of namespaces. Namespaces themselves aren't the problem. That's like saying you blame email for spam.
Just do a search for "SQL JOIN". The basic idea is that you're going to need to use the name (or alias) of your tables before the column. SELECT table1.product_id, table2.product_id FROM table1 LEFT JOIN table2 ON table1.product_id = table2.product_id For convenience it's usually easier to do something similar to: SELECT t1.product_id AS id1, t2.product_id AS id2 (other fields) FROM table1 AS t1 LEFT JOIN table2 AS t2 ON t1.product_id = t2.product_id This is a simple example and not meant to be complete. :)
An array is basically just a list of values. You can create an array like this: `$mylist = array('first', 'second', 'third');` or you can add a value to an array easily like this: `$mylist[] = 'fourth';` Here's a super-quick rewrite of your code. Note that the problems others mentioned still exist like using mysql_ instead of mysqli_, and variables like `$distance_to_show` seemingly appearing from nowhere, but this should help you with the general structure. &lt;?php $sql = "SELECT zipcode FROM event"; $result=mysql_query($sql); if (!(mysql_num_rows( $result) &gt; 0 )) { echo 'No results Found'; } else { $zipcodes_nearby = array(); // Loop database results and decide which zipcodes to look up while ($add = mysql_fetch_array($result)) { if ($add[0] != 0) { calc_distance(); if ($distance_to_show &gt; $user_distance) $zipcodes_nearby[] = $add[0]; } } // First While if (empty($zipcodes_nearby)) { echo '&lt;br /&gt;&lt;br /&gt;No Shows in your area'; } else { $sql = "SELECT * FROM event where zipcode IN (".implode(',', $zipcodes_nearby).")"; $result=mysql_query($sql); // Output Matches while($row = mysql_fetch_array($result)) { //Display Results **Edited** } // second while } } mysql_close(); 
And my axe ! ^Amirite?
You can have `case "c": break;` to prevent it from going into the default case.
I took a look, these are my observations from a strictly programitic sense of view (no thinking of features, future features, looks New Development Observations: * What's up with the 216KiB `URI` file in the root directory? * The`Shel` class looks a bit... large. It seems like a lot of this logic should be in `Posts`, but `Posts` isn't used anywhere. * Instead of passing everything around, perhaps let Shell be a container of the other services so you only need to pass it around? * In `Router::getURI()`, you use `preg_replace` with `strtolower`. * You can use the case-insensitive modifier instead-- it'll read a bit easier/shorter than concatenation here. * For paths, its very common to see '#' use in the expression since its not very useful in server-side URLs. * Example: `$URI = preg_replace("#{$basePath}#i", '', $URI, 1);` * In `Theme::getTheme()`, you check to see if the parameter is null, perhaps it should be optional. * `Theme::theme()` isn't very descriptive, perhaps rename this `Theme::render()` or `Theme::getOutput()`? * In `Theme::theme()`, the assetPath seems a bit complicated. It may be beneficial to separate out the assetPath into config (where the default value is the one use here). * In `Theme::theme()`, I can see why you used constants, you should be able to integrate this into your configuration to introduce new types. (where you see if a type is configured before rendering it, unknown types can result in an exception) * In `Theme::theme()`, unless you would like `$content` to be able to override `$type`, I would ensure that it doesn't happen. (Although avoiding extract would be better, in general). * `Dispatcher::dispatch()` seems a bit hackish. There seem to be two better ways to implement it. * Use a $routes and $uri parameters instead of just one array. * Pass the entire router into the dispatcher to dispatch (either when constructing the dispatcher, or when you ask it to dispatch) * You should protect directories with .htaccess (unless you don't plan on using .htaccess at all). You can also separate out the public directory. * `themes/default/inc/{header,footer}.php`: Personally, I dislike headers and footers. Having two files for one template just seems a little hacky to me. * `themes/default/assets/js/hovers.js`: Could this not be implemented with just CSS instead? * `themes/default/assets/css/style.css`: White can be really bright... perhaps turn the shade down a bit Things I mostly agree with, that others have mentioned: * Autoloader. You'll save development time, make your codebase smaller, and make your code more performant as well. * Paths and filenames should be configurable and not class constants (just be careful with security... so you don't get hit with http://... as a path) * Documentation. Its nice, especially with IDE's that support it, but having a good/understandable/simple API is more important. * Implement caching in getter methods like `Config::get()` and `Config::getComponent()` * `Translator::setTranslator()` sets a default value if null is passed. * You only use $this-&gt; translator once. You override the value every time translate() is called anyway, so you might as well remove the variable and the method OR... * Don't override the translator on every call to `Translator::translate()`. Make `setTranslator()` a simple setter. Write `getTranslator()` that'll return a default value. Things others have mentioned, that I disagree with: * `Cacher::__construct()` is an empty method: empty methods are alright in at least three circumstances: * Constructor of a base class (so that calling parent::__construct()) will not fail). * A method a base class uses where a subclass implements optional functionality. * A implementation of an abstract method in a subclass. * `Posts::getList()` doesn't use a constant * As long as its just used once, that's alright. Constants provide a value you reuse in other parts of the code. The problem here seems to be more that Posts isn't used and Shel implements the logic itself. * xxx IS VERY STUPID/SHOULD NEVER EVER EVER BE DONE/HAS NO VALID REASON TO EVER USE. * Security and Performance are very tricky things. Your website isn't going to be magically secure or insecure because you use extract. Hell, its not going to be magically insecure if you use mysql_query without doing any escaping (i.e no variables). It depends on how you use it. (However, I avoid `extract()` and fully utilize prepared statements with PDO and mysqli). Other Observations-- more than just programtic: * Giving the ability extending themes or templates is very useful. * RSS feed? (yes... I know Google Reader is going to the graveyard) * Ability to add more page types using the configuration? * A way to add scripts/css to different page types? (Obviously you would need). * Some sort of module loading system (if you want other people to use it... so they can keep some private customizations while contributing back)
yeah no .. reddit isn't a forum and as 2012-9-4 said, we need a forum thats not ruled by upvotes. because people can never vote correctly, its all about opinion.
I've been a programmer for 12 years, and I'll never understand why my peers find it acceptable to talk this way. Why do we even allow it? Do you think professionals in other fields talk this way? "$x is no longer terrible" and "no longer the language of script kiddies." It's self righteous ego stroking and I'm getting really, really tired of it.
I must be an idiot because I never thought PHP was terrible. Then again I've been employed because of it for 10+ years and was able to live in Peru for 7 of them while telecommuting all because of this terrible platform.
My factory factory is carefully encapsulated in a factory factory generator factory generator, thank you very much.
Personally, I'd like to see the introduction of instantiable interfaces.
Thank you ill try this and will update you later on how it went 
It's hilarious that shit like this gets by the moderators but legit problems/questions get removed. &gt;Hey guys, I used to use PHP4 and it sucked compared to PHP5. Great article.
This is great info for a beginner like me. Can PHP socket servers be created on shared virtual hosts, generally speaking?
I think that's unfair. It doesn't matter if it's your personal blog or not. As long as there is something positive that your link is contributing to the community, I think it's ok
thank you, this is news to me. i will take this to /r/shittyprogramming
For someone who's excited about the great new features of PHP I'm surprised you'd use CodeIgniter as an example. It's been criticized pretty heavily for not keeping up.
FYI ZF2 makes heavy use of composer. IMO we're moving toward a meta framework where frameworks are just becoming package glue.
every component in ZF is installable via composer.
I think this article is too subjective to provide any real value to a developer looking to choose a framework. What we need is an objective review on each framework. I think the only way to objectively review a framework is to implement the same app in each and compare the actual code.
and more jQuery!!
Says PHP is no longer terrible, by simply not talking about all the terrible things that still exist.
I wonder why libevent didn't make a different, although I guess if it's already comparable to Node then it shouldn't be expected to... Very cool to see it performs so well (at least at the lower concurrency levels tested here), and that PHP 5.4 seems to make such a huge difference. I know for my app, 5.4 dropped my memory usage by half, pretty badass!
You took the words right out of my mouth.
The title says everything, no need to read the article. It should have been written in 2009 or 2010, not now.
With such vague definitions for each, how do you make the distinction?
So you downvoted me for saying that? I am repeating what the developer himself says about it. This is one of the things I dislike about a lot developers who post in this subreddit. Rather than just asking the question they downvote the comment they don't like even if they are wrong... and even if it's against the rules of reddit to begin with. Here is a link so you can educate yourself. http://conference.phpnw.org.uk/phpnw12/schedule/igor-wiedler/#video
My recommendations - **Large Project**: Laravel **Small Project**: Silex
It's just a highly subjective term. I didn't downvote you, but even if I did.. I wouldn't do so for disagreeing with you. Which I didn't.. I just asked you a question. I would, however, for making a pointless comment that doesn't contribute to the conversation. Hypothetically of course. **Full disclosure:** I did downvote your answer to my question.
The OP referred to React as a framework... the developer specifically says it is not a framework in the video I posted above. The developer gets invited to speak at large developer conferences due to his expertise... I will take him at his word. There is a difference between a library and a framework... just because you don't know the difference doesn't mean someone else is incorrect. Specifically, a library has a specific purpose and a framework is made up of a collection of libraries that each have specific purposes within a "framework"... 
Thanks, I do appreciate that..
You should have thrown SPL in my face. :D
do all e-shops run through paypal merchant api?
Appreciate it!
Huh? This is like the easiest thing to do on CI and other structure-less view frameworks. Actually, no. This is easy to do in all frameworks.
You can use www.stripe.com as your payment processor. Easy to use API, set up a testing account within minutes, and you wont have to store any sensitive data on your end. 
For something more out of the box you can look into Drupal + Ubercart. You will still need a seperate payment processor. 
sadly im in mexico, that page is only for the us and canada apparently
Ok. Well, there are numerous payment processors out there. It is just 1 part of a shopping cart solution though. You are probably better off going with something out of the box and customizing it to fit rather than starting from scratch. You'll have to manage products, shopping carts, checking out, orders, order items, tax, shipping, payment processing. A lot to handle if you don't even know where to begin. 
http://www.slideshare.net/infowonders/how-to-build-an-eshop-using-drupal-and-ubercart-3690840
i can handle that, i recently built a system that does most of that except for handling payments, i just need to figure out that part out
APHPAX
Unless necessary, don't store CC informations in your tables. Also, double the effort in security. Login and checkout should use HTTPS. Use correct hashes for passwords. I personally think making a ecommerce from scratch is a wasted effort. Unless it has to integrate to some kind of custom API, a e-store is not only a catalog, cart, and checkout: most storeowners want sales statistic, items in multiple categories, tags for items, coupons, special sales, gift cards, cross-sale, attributes, multiple currencies, shipping tables. Before starting with the client, ask exactly what he wants, and charge by the hour for extras. My advice: go with OpenCart or Magento. Good luck. 
I think you should try them all. Here's what I do to test a framework: - create table called "hotels", either manually or by data migrations if it exists. Fields -&gt; name, adress, city, country, zip. - Seed the database with dummy values. - Create a simple RESTful API that returns JSON. Don't worry about authentication, you're just testing the framework out. GET /api/v1/hotels // list of all hotels POST /api/v1/hotels // new hotel GET /api/v1/hotels/1 // read hotel id 1 PUT /api/v1/hotels/1 // modify hotel id 1 DELETE /api/v1/hotels/1 // Delete the hotel id 1 - Automated test your API. - Create the views and populate GET /hotels // view the hotels GET /hotels/1 // view the hotel id 1 With this simple test, it should take around 1 hour per framework between coding and reading the docs. After that, you should know the basic of a solid framework: tables management, models, controller, routes, views and tests. If you're not sure, you can continue the tests by integrating authentication and other stuff. Can you add packages? Check how packages are installed / integrated / created. What you should check out for: - It's useless to code for the past, so, forget outdated frameworks like CodeIgniter. Check for good implementation of namespaces and such. - Staging configuration / Production configuration. Always fun to have. - Composer friendly? - Is it possible to have more than 1 DB instance at the same time? - What about Redis, Memcache? You might need a caching system. - How does session works - Automated Test! super important - CLI friendly? - Multi-language friendly? - Templating system? My pick: Laravel or Symfony, small or large project. 
First and foremost, you should research PCI compliance - you'll quickly find out that you'll want to hand-off the payment processing to a third-party like PayPal, SagePay, or (if you enjoy pain) WorldPay. They all have comprehensive integration documentation, and sample code that you can modify to your needs. 
Uh. Wasn't this submitted the other day? 
Some thoughts: I'd definitely go the route of getting a third party to handle payment (like PayPal, but there are plenty out there). Taking payments is a big job in itself and a big responsibility. Its easier to let someone else do that bit. Key components are products, baskets and orders. All of those are conceptually fairly simple. You may want an n-level tree for organising products into categories. And you'll probably want a search on top of the products: something like Solar or Sphinx. A large bulk of work is order management and customer services. You need to be able to do thinks like refunds, managing returns, cancellations, address changes etc. 
There are lots of solutions. I won't recommend using a in-house solution, rather using a third-party processor. Some examples are PayPal, Google Wallet, and Amazon Payments. 
i think i'll do my own framework and use paypal for processing the payments, just gotta figure out how their api works
https://developer.paypal.com/webapps/developer/docs/api/ There's a composer package! You should use it! 
I never claimed to know your motive.
libevent will start to outperform streams at a higher concurrency rate by handling more simultaneous connections. They both do roughly the same I/O speed but with more simultaneous connections streams start to block or drop where libevent takes it like a champ.
You don't run react on nginx or apache. It ships with its own HTTP server that is written in PHP.
Everyone is giving good points but not in the right order in my opinion. First point is, don't build the eCommerce core yourself, its been done so many times. If you want lightweight, easily extendable, go for GoCart, it's built on CodeIgniter. If you want fully featured but, in my opinion, less easily customiseable, go with something like Magento. Here's a curveball, how about trying a hosted solution like shopify? My main work is eCommerce, so if everyone used hosted solutions that would be alot of my work gone, but its worth considering in my opinion. They still provide a high level of customisation. Secondly, and like most people are saying, go 3rd party on payment provider. Return to point 1 and pick a platform which supports your chosen payment method out of the box. PCI compliance is an unnecessary overhead when all you want is a store up and running.
Either post the question on here so somebody can see what you need or there is stackoverflow.com for specific questions or even /r/PHPHelp on here
An added incentive is that vendor processing already has the infrastructure and security taken care of. If this is your first waltz into online transactions don't try to go for the versign route. It's expensive and the company (meaning you, as the developer) will be held to high security standards your client probably can't afford to pay. I work for a fairly large corporation and SSL / credit card security is one of our highest priorities and cumulatively probably one of our most expensive investments.
sure .. obviously you are the end all be all authority on what is and isn't a forum, and the upvote model is far far from perfect on any site. but your right, there is no discussion, you are just plain wrong.
that seems weird unless you are using windows? application\core\Config.class.php backslashes are for the namespace path, not the file path.
Neat. Looks similar to my -- shameless plug -- [curly](https://github.com/ehough/curly) library. Though yours has some handy functions that I'd like to steal!
Thanks for the mention of /r/PHPHelp, didn't know that one existed.
Not bad, but there should be more checks and exception handling. The class is pretty much a dead end, there isnt much room for extending this. I would, if i were you, rethink the extensibility of this utility and get rid of the magic, aint no place for voodoo in what amounts to 250 lines of code. I definitely don't like the loop in swapSegment(), a simple str_replace is faster in your example. But then again you could also work off of indexes simultaneously. It would also be nice to see: $url = new Parser('http://example.com/category/computers/'); echo $url-&gt;swap('accessories', 'computers'); &gt; http://example.com/category/accessories/ echo $url-&gt;swap('accessories', 1); &gt; http://example.com/category/accessories/ echo $url-&gt;swap('product/mousepad', 0); &gt; http://example.com/product/mousepad/ echo $url-&gt;swap('customer/account/login', 0, array('_secure', true)); &gt; https://example.com/customer/account/login/ Then you can get into stuff like $url = new Parser('http://example.com/search/?q=toys&amp;sort=name'); echo $url-&gt;query('sort', 'price'); &gt; http://example.com/search/?q=toys&amp;sort=price echo $url-&gt;query('dir', 'desc'); &gt; http://example.com/search/?q=toys&amp;sort=name&amp;dir=desc 
Why would you want to return the entire site layout with AJAX requests? Why not just take advantage of a page request and easily track browsing history, and leave AJAX for smaller requests that update or "fill in" data for your current state? This is at least the way I have learned to write applications, and I know I'm not alone here. Otherwise, if your just talking about PHP the language, without a framework, then returning an entire site layout with an AJAX request is not a problem of the language, it's a problem of your design. Use a RESTfull approach and you can easily create an API for yourself that only returns JSON, or just adopt some kind of route convention and return portions of your page... just my 2c. Edit: I apologize for my excessive use of commas and overall bad grammar...
I suggest Shopify. It has limitations, but it's top notch for clients, and pretty easy to customize. Shopify works with most popular payment systems. Paypal sucks for selling goods. In disputes, they always side with the customer and it's easy to get screwed out of money as a seller. The client may want to switch right away if you do paypal. If you do insist on paypal there's a easy php class for it. https://github.com/drewjoh/phpPayPal Stripe is okay, but I've heard their fraud detection seems primitive compared to Authorize.net. 
Plus 1 for Open Cart. Magento, on the other hand, is a viciously slow and sluggish system for anything under a few thousand products.
I only keep my directory names lowercase (fixed my original post) and classes CamelCase. I did a simple str_replace to convert all backslashes to forward slashes and it properly included all the classes. However, I get an error when trying to call my Config class' static method: &gt;&gt;Fatal error: Class 'application\core\Config' not found in /home/lemonpole/public_html/lemon_apps/lemonMVC/application/Application.class.php on line 19 And yes, I'm on Linux Mint so backslashes should be forward slashes; but autoloader isn't fixing that for me... Edit: Thanks for that autoloader, very simple and it seems like it should work. I'll give it a try tomorrow as i'm signing off for now. Thanks!
By Http definition the query part isn't actually key-value pairs where each key should be unique, it's more like value-value pairs.
Oh awesome, I'll definitely look into using React. When I get the chance to play around with it I'll do some benchmarks, and measure it up against Node.js. How does React work with concurrent open connections, and the CPU? Is there an article that talks about this? I know that Node keeps an entire server and its connections on one thread. I know that Apache opens a new one for every new connection, but it relies on the fact that you'll usually close the connection pretty quickly. With an event loop, you can no longer expect this. So how does React handle this?
I would be checking what file (if any) the autoloader is including - it looks like it is including your intended file (application/core/Config.class.php) - otherwise you would get an include()/require() error to boot. Maybe post the contents of your Config.class.php file - I dare say it's not defining the correct class signature which would be "application\core\Config()" - thus the require() happens, but what's brought into the current runtime state doesn't add the class PHP is looking for.
I know this is old, but I have no life and re-read through this... My point here is not about making a "convincing application", I'm saying I don't have to use a class in PHP, which is not the case with Java. Functional and Procedural programming are only two "paradigms" that don't require you to use objects... Java doesn't understand this concept, PHP does.
The following is completely and utterly pointless: public function __call( $method, $arguments ) { return call_user_func_array( array( $this, "_$method" ) , $arguments ); } Here are a few more thoughts: * I shouldn't have to instantiate a parser object for each URL I want to parse. I want to instantiate the parser once and have it return `Url` objects when I invoke some `parseUrl` method. * A library like this really ought to have a good suite of unit tests backing it up. * Singletons are widely reviled at this point. They fuck up testability and they turn your application into one enormous wobbling mass of mutable shared state. It's bad. * Your indentation is a mess, e.g. in [_currentUrl](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-75). * You're not being consistent in the way you handle nesting. Sometimes it's [the same line with no curly braces](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-289), sometimes it's a [new line with no curly braces](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-262), and sometimes it's [the same line with curly braces](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-263). * You're inconsistent in your use of whitespace around parentheses. Do you want [spaces around them](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-264) or [not](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-321)? * I know what foreach does. You don't have to comment it every time [explaining that it loops through things](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-490). In summary, I'd recommend taking a look at the recommendations of the [PHP FIG](http://www.php-fig.org/). Edit: BTW, I know this comment comes off as very critical, but in general I think what you've done is very positive. It's better than the code produced by most of my colleagues at work, and it's always awesome to see somebody with the drive to learn and guts to post code on /r/php for critique. Good for you!
Although it is criticism, it is very good and well reasoned criticism. If I posted code this is the sort of response I would want so I can improve it for next time.
I don't think you can enforce that a constructor param has to be type hinted, what happens if I want to pass a string to the constructor? The configuration I do like though, it's clean, easy to read, similar to how I wrote mine to be. Edit: Also, I still don't like the annotations, it's too container specific..
See this talk: http://conference.phpnw.org.uk/phpnw12/schedule/igor-wiedler/#video
If you pass a string to a constructor (or other method), then you have to [configure with a PHP array](https://github.com/mnapoli/PHP-DI/blob/3.0/doc/definition.md#php-array) what to inject for that parameter. For the annotations, that's why I made them optional ;) Thanks!
I added a simple echo line to the top of Config.class.php to check if its being included and it is. Here is the class: [Config.class.php](http://pastebin.com/Rwkatp9a)
Yeah I think I was right if I'm reading your class (code snippet for Config.class.php) it's full address/namespace in it's current form would be: lemonMVC\Core\Config() You would want to change your first lines of Config.class.php to // Namespace property. namespace application\core; Of course this would place your config class into a different directory on your file system to match the namespace hierarchy. Note you are also mixing "Core" and "core" - in your namespaces and "use" constructs, probably want to come to a convention on that. 
Appreciate the feedback and thanks! Going to revise a bit later tonight. That magic method is useless, not sure why I left it that way. &gt;* I shouldn't have to instantiate a parser object for each URL I want to parse. I want to instantiate the parser once and have it return `Url` objects when I invoke some `parseUrl` method. You don't have to instantiate a new object. One of the design points was to allow for a kind of "bulk editing", you can do things like this. $url = new URLParser\URL(); $url-&gt;swapSegment('en','fr'); echo $url-&gt;to('http://www.site.com/en/page-1')-&gt;make(); echo $url-&gt;to('http://www.something.com/en/page-2')-&gt;make(); &gt;* A library like this really ought to have a good suite of unit tests backing it up. I agree! Honestly I just didn't think anybody would be interested or would already have some other solution. If it's something that people are interested in I'll dive in and write some test cases. &gt;* Singletons are widely reviled at this point. They fuck up testability and they turn your application into one enormous wobbling mass of mutable shared state. It's bad. I'm not truly using a Singleton pattern. I'm just using a static method as an alternate means to instantiate and return an instance. For example... echo URL::to('http://www.reddit.com/r/php')-&gt;stripSegment('r')-&gt;make(); &gt;* Your indentation is a mess, e.g. in [_currentUrl](https://bitbucket.org/codenamegary/urlparser-php/src/dddd65eaedc6374c3087275a1fb30fe7aba161ae/URLParser/url.php?at=master#cl-75). Thanks, going to fix that. &gt;* re: inconsistencies To be fixed. EDIT: Re - bulk editing. I'm actually not sure that I ever implemented that type of usage but that is what I had in mind when I started writing the class. Going to have to review my code.
They DO look similar! I like it. EDIT: Steal away!
&gt;Not bad, but there should be more checks and exception handling. The class is pretty much a dead end, there isnt much room for extending this. I would, if i were you, rethink the extensibility of this utility and get rid of the magic, aint no place for voodoo in what amounts to 250 lines of code. This is true. However... what do you think about implementing some toString magic? The thing is, I don't want to return strings from my methods because that wouldn't allow me to chain calls together. But of course, I've heard various things about toString being evil.
good point, but you dont need toString. you could have your own output method. also if you chain them together, reset the value for each new chain without starting a new object
Here is a [link to the direct class source](https://github.com/Intervention/image/blob/master/src/Intervention/Image/Image.php).
yo, isn't even about your applications you've written. find out what they're replacing your mission critical apps with and then follow the money. someone on your team knows someone on that team. this always the case. but anyways, Reddit, Huffingtonpost.
CakePHP is the slowest of the tested bunch, right next to Ruby on Rails. For the database tests, php-raw refers to using PDO. The others would be using an ORM or ActiveRecord. The different in performance is very surprising, and I will be using this to argue against ORMs in the future. Note that none of the PHP-related tests use any opcode cache, which any serious team worth their salt would def. enable. This would greatly speed up execution of the tests, most likely bumping up the PHP related benchmarks a spot or more higher.
Looks good. On your tests though, the `testResizeImage()` should be broken down into smaller tests like `testOnlyResizeWidth()`, `testAutoHeight()`, `testAuthWidth()`, etc. Also, in `testResizeCanvas()`, it looks like you've basically copy/pasted assertions based on different values you are passing. Check out using Parameterized Tests as an alternative.
opcode cache or it didn't happen...
TL;DR - Why do you think they chose Cake of all things?
I posted this to hacker news, but obviously relevant here: "These are some brutal results for CakePHP (which I use). However, in practice no intermediate developer would be issuing queries like that in a loop. They would loop through a set of data, building a IN statement example: WHERE field IN ('x','y','z'). Thus only sending a single query to the database. Still, the Cake developers really need to improve the speed of their framework."
Because that's what the authors heard most when thinking of PHP frameworks. Here is the relevant post on HN: https://news.ycombinator.com/item?id=5454775 I'll see about contributing an example using Silex to see how it performs.
bookmarked, will probably use in a project or two.
&gt;The tests were run with: &gt; &gt;PHP Version 5.3.10 &gt;Apache Version 2.2.22 &gt;MySQL 5.5.29 &gt;PHP ActiveRecord Nightly 20121221 They should be using nginx, php-fpm, optimizer+, which would be a more real-life scenario.. Cool article nevertheless, but remember people: Clean and extensible code is more important than a couple of milliseconds difference! 
I agree with this video except I would also add that the insecurity in programming comes from working on challenging problems usually in isolation. Asking for help maybe shouldn't be first, but it shouldn't be last either.
While this might be a much different way than Node.JS does things, I imagine... I have implemented React/Rachet as a broker between my php back end and the client using a PubSub example that is a front end for Redis. How this works is that I post to my backend and push the results through Ratchet... or at least an "update" notification which tells the client to fetch new results or update the results... depending on how much data it is. I am assuming this is how someone should use React/Ratchet... so far I am having great results. Basically, I never use the socket server to do anything but push messages around.
Definitely, but the amount of online community support (Stackoverflow, forums) when you are trying to solve a problem usually helps to overcome anything challenging. I think many times identifying the problem is much harder than looking for a solution. Once you get to the "will this work" stage, you presumably have identified the problem and come up with a potential solution. The final step is just proving to yourself that both of those steps were done correctly.
I used servlets for years until I moved to PHP. Honestly never noticed any difference in performance. 
Took me a second to translate Parameterized Tests into using PHPUnit's `@dataProvider`
**Breaking news:** Java developer presents benchmarks, that prove that java is the *bestest*. .. in other news: scientists suspect, that water might be wet.
&gt; Citation needed. http://sebastian-bergmann.de/archives/883-Stubbing-and-Mocking-Static-Methods.html
yeah, MS Testing framework calls it data-driven tests which allows you to put in a database connection to get the test data from. It's not as neat as it sounds and tests really shouldn't have external dependencies like that.
Also, using [DirectoryIterator](http://php.net/directoryiterator) would be helpful. $file = new DirectoryIterator( "index.php" ); $mtime = $file-&gt;getMTime(); 
Unless you waited too long to ask someone and you end up with a solution that is actually not optimal. Just because we have this nifty tool called the internet doesn't mean that all solutions are readily available. Sometimes reading the fucking manual is confusing and isn't enough.
We'd love to have it! This is an ever-evolving benchmark. We plan on continuing to update it every so often, so the more muscle we can get from the relevant communities, the more accurate our benchmarks will be! 
Bingo! I wish this post wasn't so nested and I wish I could give you more upvotes.
I think you are missing his point. If you can ask a question to someone about how would I do x, why not try googling how to do x first. You will not always have some one by your side to hold your hand. As a developer, designer, or what have you knowing how to search for your answers is going to get you a lot further than simply having someone hold your hand each time you have a question. Having an open discussion with someone about your problem and coming up with a solution is another thing completely as well. For MidwestPHP this past year their opening key note was exactly what Anthony is talking about, Learning how to learn by Joel Clarmont (http://joind.in/talk/view/8196). Before you can ask your question you need to figure out how you will best absorb that information and take it in.
Good point. Going to require some thinking and tinkering to incorporate some kind of logic to handle that case.
It's nice to have the developer of Ratchet tell me I am using it correctly. You made my Thursday! :)
the real question is: why? PHP is not Java. What benefit does a dynamically typed language get with this kind of IoC pattern?
As always, Anthony comes up with a very underrated and undervalued point that so many people overlook in their struggle to leave the novice stage.
I like this, but I feel this should be in /r/programming not /r/php
Looks nice. How does it compare to imagemagik? I'm considering using imagemagik because GD imagcreatefromjpeg has problem handling large sized image. Thanks for sharing.
Is it possible to combine two or more images with this library?
That actually brings up an idea the OP should look into. See about refactoring the library to be able to easily swap out using ImageMagik and GD Image or possibly any other similar variant that may come along.
This guy has nailed it 100% in my opinion.
Yeah actually after reading up youre right :-) have an up vote :-) Symfony's release schedule is a little confusing.
Then cross-post it. It's certainly relevant to any language.
Although I applaud your effort on this project, it seems like painting on rust. GD, although pervasive in the PHP world, it's an ugly dog. It was designed back in the days when 256 colours was a lot, and it shows. It has many ostensible features that don't work properly with alpha channels and have odd constraints. It's biggest failing, though, is the poor quality of its resampling filter. Compared to a nice, crispy bicubic filter, the result is blurry and ugly. Sorry, this probably wasn't the place for a rant about GD, but that library is a horrible crutch. From the looks of your code, you've done a good job working around GD's limitations such as resizing alpha channeled images. I think /u/LikesPortraitMode had the right idea in making a library agnostic interface for imaging. 
What I don't understand is: why compare Netty with non-blocking IO and somewhat similar Node (at least, dunno about the rest) which implement servers themselves, with php and co. that run on a separate webserver?
upvote all the things MidwestPHP!
That intro is way too loud.
Go with Stripe over PayPal, you will thank me later. https://stripe.com/ 
What are these limits? Examples? 
My opinions are rather aged and crusty but first to my mind is weird/broken OO and lack of modules/namespaces. Also these... https://www.google.com/search?q=php+bad+language
PHP has had namespaces for two major versions, over five years. As for "weird" OO, maybe you're talking about PHP4? There's nothing weird about OO in modern PHP The fractal of bad design article is riddled with inaccuracies, out of date statements, obtuse presumptions, and a whole shitload of unsubstantiated opinion. It's an awful piece of sensationalism that was written to gain the author points on Hacker News.
Don't get bogged down with micro optimisations already. There is almost no overhead. 
I think you're being way too pedantic. You may be used to enforcing such semantic standards rigorously in your code, but for most, making sure there's no whitespace before a conditional is really banal. Sometimes the time required to make such checks is detrimental to the project, especially if you're the one paying programmers by the hour. 
Don't have your code make choices based off your environment, have your environment tell your code the configuration values. See: http://www.12factor.net/config
There are really no solid limitations anymore. Java OO can be ported easily to PHP OO. The only thing is PHP uses a different mentality about overloading and extending classes, but if you understand the reasoning why PHP went the way it did, it really makes sense. For instance, they chose to not allow multiple extends statements because they felt like a single class should not inherit methods from multiple parents, it should only have one parent and perhaps that parent should have another parent that includes the other methods one would need. It also includes namespaces. The only drawback to namespaces is you need to develop or copy an autoloader, since the autoloader methods aren't built into PHP (yet?). In PHP 5.5 they've merged Zend Optimizer+ into the code which compiles the PHP code into an opcode cache to produce faster execution for future requests.
Thx. That's exactly the type of contextualization I'm looking for.
Namespaces: Roger. Like I said, aged and crusty. But, PHP OO has been complained about a lot. Is that all old news with PHP5? EDIT: Apparently so... http://programmers.stackexchange.com/questions/78089/is-php-a-bad-object-oriented-language 
$_SERVER is just a hash table. The amount of overhead to lookup something inside of it is virtually none.
Dependency injection has nothing to do with Java. Java also uses integers and booleans, that doesn't mean we should stop using them. But for the question, there are benefits to using DI, even with PHP being dynamically typed: you still have to create instances. If in a class Foo, you do a new Bar(), replacing Bar by another class later is still a problem: you have to change the code. And if Fiz and Bam also use Bar, you also have to edit Fiz and Bam. With dependency injection, the dependencies are configured externally to the class Foo. So one day you use Bar. The next you use Baz. Foo, Fiz and Bam will not need to change. You can read this example: https://github.com/mnapoli/PHP-DI/blob/3.0/doc/example.md And another reason, more of a individual preference, is that dependency injection can make things more practical. Maybe not with raw dependency injection, but with PHP-DI that's what I had in mind: injecting an instance is simpler than creating it (with "new").
Most languages require an additional framework to connect with the webserver. PHP implements CGI, FastCGI, NSAPI, ISAPI, Apache (mod_php), and even its own web server. While most other languages do not provide anything at all. All of that web integration happens in web frameworks. In PHP, the run-time does all of that. While PHP may be a language, their built-in web-specific integration makes a framework as well (at least until their web-specific features can be recognized separately). PHP is a language, but the php.net interpreter is also a framework. There hasn't been a PHP run-time yet that *isn't* also a web framework. TL;DR What do you call the framework in php.net's interpreter? The same name as the php interpreter: *php*.
Your standards are way too low. Beyond a certain level of experience, developers just don't mess up simple stuff like whitespace. Good developers are detail-oriented, they get whitespace right the first time without spending any extra time making any special checks for it.
Meta programming is the big one. Working alongside other languages, the number of times you end up with horrible reflection hacks to provide a level of abstraction on top of the code is awful (just look at python's decorators for instance). After that there are just core limitations. They've only just added support for generators and finally. You can't provide dynamic class properties (only compile-time logic). The list goes on and on. Having said that, it's still my primary language as it's still fun to bash stuff out in.
I like how Lithium handles the env setup. While it's a bit verbose, it's also flexible. https://github.com/UnionOfRAD/lithium/blob/master/core/Environment.php#L325 protected static function _detector() { return static::$_detector ?: function($request) { $isLocal = in_array($request-&gt;env('SERVER_ADDR'), array('::1', '127.0.0.1')); switch (true) { case (isset($request-&gt;env)): return $request-&gt;env; case ($request-&gt;command == 'test'): return 'test'; case ($request-&gt;env('PLATFORM') == 'CLI'): return 'development'; case (preg_match('/^test\//', $request-&gt;url) &amp;&amp; $isLocal): return 'test'; case ($isLocal): return 'development'; case (preg_match('/^test/', $request-&gt;env('HTTP_HOST'))): return 'test'; default: return 'production'; } }; }
This isn't a very good way to do it really. It's better to set a proper environment variable. This can be done in your apache vhost using SetEnv and the var will become available via the SERVER array (or the getenv function). The benefit is you can apply the same system to CLI portions of your application using export on the command line. Personally I tend to split the environment into two constants - ENV (e.g. dev, defaults to production if not set) and DEBUG (defaults to false if not set). This way you can have better control over how environments react e.g.: 1. Dev - ENV="development"; DEBUG=true - connects to localhost database/cache services etc., error_reporting -1 2. Staging - ENV="production"; DEBUG=true - connects to live services, error reporting -1 3. Production - ENV="production"; DEBUG=false - connects to live services, no errors Also as others have said the performance implications of this stuff are so minuscule they do not warrant any attention whatsoever. It probably takes literally a million times as long to just connect to MySQL let alone run a query.