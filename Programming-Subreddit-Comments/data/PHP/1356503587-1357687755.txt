The way I've been successfully hiring juniors for years is: * Look through submitted resumes to find some that look like they have some tertiary programming education and/or 0-1 years industry experience * Send all of these potential candidates a short test (completable within an hour) which covers javascript, css, php and sql. This gives you an idea of their abilities far better than any resume can. * Get everyone scoring above the baseline (whatever that may be depending on your test) in for an interview. At the interview you already know what their rough level of knowledge is, so you're trying to find out if their personality will fit in with the team. Also try to figure out what reasons there might be for the gaps in their knowledge (only worked with OO in other languages etc). And lastly, find out what experience they've had outside of a classroom / work environment. Anyone running their own website, trying out PHP 5.4 to see what's new or making little web apps for themselves etc is usually someone that likes the language and likes learning how to do new things with it. Then once you've hired them, you get to work on helping them unlearn all the bad practices they've picked up.
That's probably the case with most people but I think the idea is to show that you contribute or have some sort of hobby projects outside of your work.
Ha well my personal projects are my work essentially.
Hiring a junior developer is a lot harder than a senior. You can't expect a jr dev to have bast code knowledge or anything at all; just the interest to learn. Even if that person has the interest to learn you won't know if its a good match for the team you are trying to build. There are too many variables that can't be determined with common HR evaluations. That said, your best chances are to do what everyone else does, interview personally to talk about interests and what they've been doing with their spare time, try to compare their interests to the company's goals and go by the hunch. Make use of the period of time that is considered "try-out" in your country, if it didn't work within that time it will probably wont work later on. If you are having to layoff many who have shown interest in coding and have been doing so in their spare time, the problem is probably with your company and not them (not uncommon). Fix that. 
Personal projects can exist in so many places limiting that requirement is very short sighted and is quite frankly ridiculous. There are many alternatives to github, and just because it's the current flavour of the month doesn't mean people have to use it. 
This is not answering your question... but is this for aquarist? Where are you located?
I would. Not everyone has time to contribute to open source activities, or fork them and modify them. Some people have families etc. I know a bunch of good devs that don't have a github account and I'd hire them at the drop of a hat.
Thank you. I'm starting to get sick of the "If you don't code at least 16 hours a day, you aren't hireable" mentality. I'm married with a wife, a dog, and a house. None of those things would allow me to come home from work everyday and then sit at my computer to do more work. I really hope that doesn't make me a crappy developer when looking for work.
I would avoid any book sold in 'that' format -- the same one used for 'how to score with the ladies' or 'start your own Internet money machine'. If it was good enough to get published on paper and put in a store, it would be there. This one is not. Avoid. 
Or "How I Made Two Million Dollars With Google Adsense." Bad presentation all around.
I recommend this book-- [PHP Objects, Patterns and Practice](http://www.barnesandnoble.com/w/php-objects-patterns-and-practice-matt-zandstra/1100351201?ean=9781430229254). I have read it and it was great in taking me from procedural to object-oriented PHP. Here the [Amazon](http://www.amazon.com/Objects-Patterns-Practice-Experts-Source/dp/143022925X/) Link. If you get the ebook version, it's half of what that other site is selling theirs for. 
Dude, just learn and use PDO. You will be better in the long run
Because I'm not good at it.
It is not the OO that's important to go from mysql to mysqli (all mysqli class methods have procedural aliases) but rather to start using prepared statements which mysqli supports
It's not, that is a side project of mine and it's written in Rails. I experiment and create stuff with stacks I don't normally use professionally in order to learn. The position I'm trying to fill is in Virginia and it's a PHP gig.
Ah. Never seen that. Should be reasonably simple to convert then? 
Well is this not all the more reason to use it? Try and do some small personal projects with it, for learning it. Hopefully you didn't intend to take something you've never worked with before, and put it straight into production. As a developer you should want to learn and improve, if you're going to be stubbern or afraid, it's likely not going to go well for you - especially not with the web.
yes, theoretically, just changing mysql to mysqli in the function names should work, but one should really change queries into prepared stamenents
College degrees or a big stack of knowledge isn't a requirement. I mostly expect someone to understand what certain tech does. e.g. I wouldn't expect someone to be very experienced in MVC or ORM are but they should be able to tell me what it is. Do you think that's a realistic and fair expectation?
I feel HTML/CSS is a precursor to any back end work. Granted most of this in larger environments is offloaded to a dedicated UX/UI workflow and you get handed a template, but I have a hard time envisioning a web dev gig where you wouldn't touch these two things, if even just to integrate a template into a view.
And use a class. So much redundant crap can be wrapped. 
Do you filter your coding tests like FizzBuzz through an online site before you bring them in to interview? Making sure they pass a low-bar of programming competency before you bring them in or is it all done in the interview on a white board?
Well, to be fair, it's a resource providing both procedural and object-oriented interfaces.
Wouldn't it make more sense to actually further your understanding of the areas which you find yourself lacking in, rather than avoiding it?
My last boss found a couple on the regional sub-reddits.
I see that now. When Mysqli came out I used the class and never looked back. 
Oh, come on guys. OOP is great, but not needed for this: http://php.net/manual/en/mysqli.query.php &lt;?php $link = mysqli_connect("localhost", "my_user", "my_password", "world"); /* check connection */ if (mysqli_connect_errno()) { printf("Connect failed: %s\n", mysqli_connect_error()); exit(); } /* Create table doesn't return a resultset */ if (mysqli_query($link, "CREATE TEMPORARY TABLE myCity LIKE City") === TRUE) { printf("Table myCity successfully created.\n"); } /* Select queries return a resultset */ if ($result = mysqli_query($link, "SELECT Name FROM City LIMIT 10")) { printf("Select returned %d rows.\n", mysqli_num_rows($result)); /* free result set */ mysqli_free_result($result); } /* If we have to retrieve large amount of data we use MYSQLI_USE_RESULT */ if ($result = mysqli_query($link, "SELECT * FROM City", MYSQLI_USE_RESULT)) { /* Note, that we can't execute any functions which interact with the server until result set was closed. All calls will return an 'out of sync' error */ if (!mysqli_query($link, "SET @a:='this will not work'")) { printf("Error: %s\n", mysqli_error($link)); } mysqli_free_result($result); } mysqli_close($link); ?&gt;
some of the vars are back to front on mysqli, so changing the names of the function calls isnt the only thing. and you dont need prepared statements if you are using transactions.
39$ is a lot of money and hardly justified for any ebook on PHP. Someone recommended PHP Objects, Patterns and Practice, and I second that. For this price you'll have a paperback copy from a respected author. ( I read the sample chapter from "Do this not that" and clearly the author knows his subject. But 39$, come on man ...)
One exercise that I think shows a lot, but is rarely used, is to have the candidate work on some legacy code (preferably the code he would be working on). Have them implement a simple feature, fix some bugs (SQL syntax issue, PHP syntax error, etc) to see how they look at the problems. FizzBuzz can be informative as well, but I think having them work on legacy code is the best test.
Code together a project in a version controlled environment and on the way share your thoughts and findings to debate reasons why certain approach should be better than the other. Digg down concepts that are trending, check examples, code, and share your thoughts with the team. A certification or a course for everyone is almost irrelevant. 
I'm looking at the sidebar and not finding any. Is there one tech/web specific or just the /r/city pages?
I mean literally "spamming" /r/twincities or /r/phoenix and the ilk.
It's a US position. 
Before you start dropping a ton of money in certs you should start putting together a team identity plan. What conventions will you all use, what design patterns, frameworks etc.. that will build a lot more continuity then just taking a test and then assume everyone will stick to the studied curriculum. Also, start with picking a leader who is strong in the most important aspect of the project.
Hi there. I'm the author of this book. I'm also the author of The PHP Playbook: http://www.amazon.com/The-PHP-Playbook-Brandon-Savage/dp/0981034543/ref=sr_1_1?ie=UTF8&amp;qid=1356549053&amp;sr=8-1&amp;keywords=The+PHP+Playbook I've been writing about PHP for a long time. Google me, you'll find a wealth of information. The book is self published intentionally. When you spend 200 or 300 hours working on a book, to get $500 in compensation, that's not a model that works. The refund policy is legit: I mean what I say. With hundreds sold no one has asked for a refund; the day someone does, I will honor the request.
If you were to take the zend certification prep course online, I'd likely be your instructor. If you have any questions about that, I'm happy to answer them. I think Matt Zandstra's book from Apress might be a good primer. http://www.amazon.com/PHP-5-Objects-Patterns-Practice/dp/1590593804 If a couple of you like it, get copies for the whole dept (or just share it around after you're done).
 &gt; If it was good enough to get published on paper and put in a store, it would be there. This one is not. Avoid. This is such a ridiculous claim that I have to assume you are trolling. Getting published is never an indication of quality, only connection and a willingness to sign away all your profits. The print publishing industry is run almost identical to the music publishing industry. Most of the books on the shelf are complete drivel. 
I won't tell you that your testing method is "bad" or "wrong," but I will tell you that it's a horrible way to judge general aptitude as a developer. What you're testing here is a level of understanding and knowledge of a particular domain of information. Information that anyone can learn, and everyone (even the best developers) didn't know at some point. The only thing you can really get out of this kind of testing is to what degree a candidate will hit the ground running. That's important in its own right, and you'll likely want to set some kind of baseline for this, but it's a poor indicator overall of who will ultimately be most valuable to your company.
As a job-seeker, I've seen both methods. I think it's more efficient to do it prior to any kind of interview, though. Yes, it's easy to fake, but it's just a filter.
You are going to have a bad time. Learning OOP was difficult at first, but I just couldn't imagine doing most things any other way now. I forced myself through it, it's worth it. I had a whole big project I made all using _mysql and I easily made the switch to PDO.
Then get good at it. It will make your life better in the long run.
Thanks for the suggestion, I am hoping that we will be getting some Lynda accounts soon.
Do you know what a prepared statement is? Do you know what a transaction is? If your answer to both of those questions is "yes" then you're a liar.
+1 on this book, excellent guide to what i would describe as getting more familiar with professional coding techniques.
Right, except that you could encapsulate the setup and teardown of db connections in a class. Or, you could encapsulate the database altogether to make switching to another database much easier (changing code in one class &gt; changing code all over your application). OO is not the EABA by any means, but it's the right choice when one needs to encapsulate implementation details and create a loosely-coupled application. 
I'm ok with that, authors need to earn their lives. But I wish they stick with 14-15$ prices. It's hard to buy any virtual good beyond this point, despite the fact that I read the sample chapter and thinks that it's probably an interesting book. 
I suggest just reading up on OOP with books you can get off amazon. O'reilly books are good but a bit much for someone new to OOP. [this](http://www.amazon.com/Objects-Patterns-Practice-Experts-Source/dp/143022925X/ref=sr_1_3?ie=UTF8&amp;qid=1356554931&amp;sr=8-3&amp;keywords=OOP+php) was one of my first books when I started studying web development and PHP, and I highly recommend it. But I also suggest studying it together, and asking each other questions, possibly building some applications together using a version control system, like iswear, suggested.
[ActiveCollab](http://www.activecollab.com/) is pretty awesome. You should be able to get all of these requirements out of it.
Have you tried [Basecamp](http://basecamp.com/) or [Apollo](http://www.apollohq.com/)? Most devs I've worked with are pretty familiar with them.
Redmine WFM
Not a fan of the hackathon, eh?
Yes, that's the second half of my effort. We will likely be settling on Symfony for our framework, the issue is that it is fairly complex for someone new to PHP. I don't want to throw too many new concepts at them at once (YAML, Twig, MVC frameworks in general, Symfony specifically, OOP) so I thought if everyone was at the same foundational level (PHP wise) then it would help lead us into best practices aspect.
Trust me that won't work. There are more differences than just adding the letter "i" to the function names. For instance the return values are different.
Incorrect. It's like telling someone to build a car from scratch instead of getting a used car and learning from that.
I think it's intrusive to ask for accounts/usernames of any kind. Besides the negative connotations that go along with it (you'll automatically be presumed to be an employer who snoops), you could potentially be putting some applicants into a corner and forcing them to either lie to you or get stuck in the awkward position of having to tell you that they don't want to give you that information (for whatever reason). And really, you aren't going to learn a whole lot about them from Github, anyway. You'd learn more from Stack Overflow, if anything, but better you let them offer it up than ask for it, in my opinion.
Been writing a tonne of Markdown text recently for my GitHub repositories and found myself "git pushing" way too much to tweak/fix Markdown output issues. Through my Twitter feed found out about the very cool GitHub API method to render Markdown -&gt; HTML, so this little web app seemed like a good idea. :)
If I did have a huge beef with MySQL down the track (I say down the track, since at this point in time I'm still getting all I need from MySQL 5.5 at least on Ubuntu) - I would move to MariaDB or Postgres (as the article suggests). It certainly doesn't mean the death/end of MySQL - the re-birth through MariaDB and Drizzle mean it's got legs for quite a few years at least yet. Percona server is another good choice - regardless of what MySQL flavour you use - their [XtraBackup utility](http://www.percona.com/software/percona-xtrabackup) is one of the best pieces of companion software you could couple with MySQL for an excellent non-locking live DB backup option which I now use religiously in production for shipping MySQL DB's onto backup servers.
caching stuff works just as well, and with an application architecture, it is very unlikely to call the same query twice very often when you have hundreds of users hitting it.
I suggest you watch this: https://www.youtube.com/watch?v=nLinqtCfhKY
The article covers what they mean by "falters" &gt;In August, Alex Williams wrote at TechCrunch, "Oracle is holding back test cases in the latest release of MySQL. It’s a move that has all the markings of the company’s continued efforts to further close up the open source software and alienate the MySQL developer community." I don't think the OP was asking anything, more likely just sharing an article and possibly curious about peoples opinions of the article.
[You are correct.](http://en.wikibooks.org/wiki/MariaDB/Introduction)
Install xdebug, and then you can profile the running code to find out what methods are taking the longest. This will narrow down your bottleneck, so you can fix it. 
are you using virtualbox shared folders on linux? if so i found a big hit and switched to NFS
There is absolutely no way for us to guess what is slowing your website down from the stats you've posted. In fact, anything short of direct access to your code and your database will be insufficient. You may want to hire a contractor to narrow the issue down for you if you are unable to do so.
Phabricator
The primary purposes of using a prepared statement are to prevent SQL injection, avoid malformed queries, and enforce data type integrity. THAT is why you use prepared statements. Without prepared statements you can still run malicious and/or malformed queries in your transactions and not know it. Do you understand now how they're not really the same at all?
injection, injection. yes protection, always. malformed queries, never been an issue, even with building queries on the fly. datatype integrity should be part of your injection protection check everything coming in or going out, regardless, trim it down, case it, encrypt it, check it, know what vars are required, and what are rogue. i understand there is a purpose for a prepared statement, but im not convinced they are necassary, nor performance enhancing, nor a smart in relation to removing logic from the API side. There are other things you can do, should do, and need to do for security. Im not convinced.
This is called a long form sales letter, and marketers (most notably the NYT) have been using it successfully for decades. I've split tested my book's long form sales page vs. a more "acceptable" format... And guess which one converted better? Mocking the format is just silly. And so is thinking that the only books worth reading exist on trees at your local brick and mortar.
You have a very keen eye sir. Copied the files to another directory and the speed increased by 4x. Rendering at ~600ms now which is normal. Who knew shared folders has such awful performance. Will setup NFS. The host is Windows but from what I gather NFS should work. So many upvotes!!
Xdebug showed file loading took up most of the time, especially the translation files (MO) which are fairly large. This is in line with the solution that johnny055 provided. PS. Found a neat plugin that will let you cache these files in APC: http://wordpress.org/extend/plugins/mo-cache/
I don't understand why this is downvoted... Studying and reading languages like Java or C# was the best decision I made for grasping the purpose of objects/interfaces/generators/etc and design patterns and how to relate them in PHP.
[Here's](https://support.twitter.com/articles/76915-automation-rules-and-best-practices) their automation rules and best practices. [Here's](http://tips4php.net/2010/12/twitter-oauth-the-easy-way-simple-post-to-twitter-script/) some PHP code you can probably customize.
Teamwork++
What i found when doing inner joins is that if you have an issue with space you will find that a whole temp table is created that contains the data from both tables and then the query is performed on the temp table, which will then be deleted afterwards. This caused issues for me where i found the query took a long time with an enourmous database ( i had half a million entries ) Another method to get around this, would be to use SELECT messsage.userID, users.userID FROM message, users. This worked quicker for me, when used with proper indexes.
stackoverflow chat #PHP. requires you to have a bit of rep with the website but it just means you get a good conversation out them.
I am a php developer. I know there are thousands of applications already existing and as a computer science major year one, the first thing they taught was to avoid recreating the wheel. You speak about broken analogies, but your analogy is also very broken. If you really want to learn how to code, at some point you must look at how professional projects are created - ones that do the same type of things you were hoping to do. Without doing this, you are missing out on the most advanced aspects of programming there are. Anyone can build an application, but have you realistically put the security into it that someone with 10 years of professional development has? What about incompatibilities and interactions with other products? As much as being told something doesn't work is valuable, knowing what good work arounds look like - it's invaluable and not something you'll always know off the top of your head.
There is a performance enhancement in most databases (and even MySQL when using certain options) as the database can cache prepared statements after parsing/compilation so you can skip a complex step and get straight to fetching data.
If you are going to settle on Symfony, you might want to take a Symfony certification program instead of Zend...
We just adopted redmine where I work, and I use it for my personal projects. I highly recommend it. It integrates nicely with git.
[Podio](http://podio.com) It's not specifically project management and it's a little tricky to get used to be it's so amazingly flexible. We have a Projects workspace which has things like project overviews, meetings and ideas and we have a Tech workspace with has more technical specs, bug reporting and task management.
Well shit, it was upvoted when I first looked. No surprise that the PHP fanboys are downvoting it. It's popular to hate anything Microsoft, especially when you come from an open source background.
1. Communication, ability to articulate 2. Specialty or Broad Knowledge 3. Education doesn't mean much.. some of the top developers/designers I work with have barely any formal education 4. Post ads on different forums, gather resumes - give them a hypothetical scenario to solve - and pay attention to their thought process of how they would find a solution. 5. Make sure they're not controlled by their spouse - I've seen a few partnerships and vendor agreements disolve because a significant other tried controlling their business relations 6. If they're looking for work/been out of work for awhile-assume how ever fast they do something for you, or quality of work they present it will reduce by 15% once theyre comfortable. 7. Ask for their opinions on different subjects like mvc, frameworks, cvs, oop, wordpress.. what their pet peeves are on any technologies they've worked with 8. How they stay productive, and how they split up their work day to stay efficient. 3/1/3/1/3/1 etc. 9. How would they develop a site like (x) from start to finish (would they prototype, plan, draw out on paper, flowchart a db, etc etc) I believe the process is the most important thing in any field.. anybody can google / grab code snippets to impress someone.. anybody can learn on the fly.. but knowing and understanding the process is what makes someone really good at their profession.
irc.freenode.net, #php, #phpc irc.efnet.net, #php just be careful how you ask questions, some of the guys in these rooms are douchebags that only care about perpetuating their own pseudo-excellence, yet in reality they're circle jerk specialists. 
&gt;Ask on /r/programming [...] hate php [...] MySQL is a POS Maybe not obvious but it would defeat my purpose. I'm currently trying to learn Symfony2 (I've used php since around 2000 but never in a serious way). Now I'm going to do something that I want to last. I started to use postgres around 5 years ago. I never thought much of it except that it was such a relief compared to my previous experience with mysql. Of course, when my projects involved hosting I would still use mysql (reluctantly). Now when I'm diving into Symfony2 it surprises me that everybody still use mysql and that postgres is not the natural first choice. I don't have a beef with mysql and I don't want to push an agenda - actually I would like to push postgres, it would create more code examples, better testing and make postgres more of a first class citizen.
Check out the code of the TweetOldPost Wordpress plugin. It does this.
Sure. A few unique things: * Focused on money: will I get what I ordered for the price I was quoted? AFAIK, there really aren't any other PM tools that focus on that. * Detailed reports sent daily to your clients with what's been done, how much budget has been used, and what you need from them. * It's much more than just task management CRUD. Planscope tracks the time you log vs. the time you estimated, and over time starts handicapping both your estimates and progress calculations based on the differential. RE: Price. Almost all of my customers charge $50+ an hour, most in the low to mid $100s. If someone can't afford the equivalent of a few cups of coffee a month for a tool that runs a significant part of their company — I probably don't want them as a customer :-) RE: Trial period. It shouldn't take months to figure out if you like using a project management tool. Some products do take a while to prove their worth (e.g. HitTail, KissMetrics) but most don't. Plus, shorter feedback loop = faster results for split tests I run.
Ever think that you're just a vocal minority? Statistically, you're wrong. I *DID* split test two variations of a page, one with the long form and one without, against thousands of unique visitors from a reliable traffic source. The long form converts at 4x against the control. What I'm saying, and what marketers worldwide are pretty much in harmony with, is that while the long form letter will repel a small percentage of people, it will typically convert better overall. Look at guys like Ramit Sethi, Neil Patel, and others who do this for a living if you need confirmation.
I would highly recommend ChiliProject, which is a much more active fork of Redmine. I run it in a VM to avoid issues with rails.
I'm not talking about a dinner out or of my career. I'm talking about the fact that virtual goods shouldn't cost that much. 
It was downvoted because he came into r/PHP to tell people not to use PHP.
He was abusing reddit and pretty much only posting his own stuff.
Done.
I'm thinking of asking people that rather than submit code samples or do a programming test to rather pick any open source PHP project, fork and make a commit to it and link me to the commit. I do agree that there needs to be some kind of baseline as a filter, but I'm not keen on random developer programming testing. It's easy to fudge the answer. I think having all the choices available and then asking why they picked a particular project or solved that particular problem would give me more insight. What are your thoughts on this?
I saw this come through already, someone who has no personal sites to show and all their work is proprietary. I'm thinking of asking people that rather than submit code samples or do a programming test to rather pick any open source PHP project, fork and make a commit to it and link me to the commit.
Runs at 20 ticks/second (like PC Minecraft). It's the upper limit. If I remove it, it runs at 800 t/s. It has been profiled, and uses an event system.
While trying to find a framework I liked, I picked apart all the microframeworks and took what I thought was the best from each and I have it all compiled as my personal framework. What I learned - generally speaking the base of most frameworks is just a collection of the same tools: a router, dependency injection, event dispatching, error handling, rendering, autoloader, request/response utilities, etc. Most of it is just boilerplate that isn't built into php because it's too situation-specific or would be considered bloat. The rest is just library code integrated a bit more tightly with the framework - nothing you couldn't source from another party and tie in yourself once you understand it. The benefits for me I guess are that I now understand what each of those things is, what makes a good one (well, many are better than others), and I am able to use my toolkit to the fullest extent, mostly from memory, without being lost when something doesn't work the way I want. The only downside I can see is that if I ever get so comfortable with it that I stop studying what's out there (hasn't happened yet), it will become dated. If you're looking for a good, small framework I will suggest [flight](https://github.com/mikecao/flight). It's also a good one to study to understand the general inner workings of a framework and what they entail, it has clean understandable code, though there's room for a little improvement if you're using PHP 5.4. &gt;I just want to follow the PSR's and shit Unless you have a specific reason to, it doesn't make sense to force yourself to conform to someone else's style guidelines. I don't bother with either. PSR-0 is easy to convert a project to in no time if you really want to get it in composer (I think composer is PSR-0), PSR-1 is ok except I don't care about camelcase or studly caps or whatever, and PSR-2 is a crock of horse shit - there exist dozens of programs that will format code to however you want it to look - tabs, spaces, line wrapping, brace style, whitespace, etc - all of that is absolutely up to your preference and I would advocate that you do NOT follow PSR-2 unless you're forced to, or just agree with it already, because it takes all of 3 seconds for your computer to scan and reformat an entire directory of code if it hurts your eyes so much to look at someone else's brace style. I even have my own script that formats other people's code to conform to how I like mine. Even if you're developing for a company or team with its own strict coding standards, I'd say code in your own style and use your IDE to convert the style before committing code. edit: another not-quite-framework that you could still learn the basics of a framework from is [kit](https://github.com/xeoncross/kit) by [/u/xeoncross](http://www.reddit.com/user/xeoncross). It's currently in-progress. I am a fan of his encrypted cookie/session handlers and use something qutie inspired by them myself now. Also contains the only php implementation of hashcash I've ever seen, though nobody seems to know what hashcash is. Also check out the rest of his git repo its full of goodies.
Check out https://workflowy.com/ ! It's for making nested lists, has hashtag support and @name support for tagging people and categories... Very cool solution to manage a project, and allows you some creative control over how you use it!
eh, this is command line though, its not made for websites. won't even run from a browser ;x
This is some crazy awesome work. Care to expand on the event system part of things? Was expecting to maybe see [Libevent](http://php.net/manual/en/book.libevent.php) used in there?
I used a self-made event system, with events, handlers, scheduled events and scheduled actions. So you don't need the libevent library (though I might add it as an option)
* You've to join it using Minecraft PE (Android/iOS). * The Server uses a event library and a tick system (like minecraft one). I've tested it with remote 9 players (yeah, online :D, but they can be local players (same network)), and the TPS (ticks per seconds) was stable at 20 (upper limit). The only things that lags the server are multiple players connecting at the same time (due to map data sending, but this will be improved) and Water Spread (due to a bug) * Also, no blocking. Thanks!
First off, great idea. I think it would be a very good team-building goal to set. I'm not sure if it's still available or not, but i got a 10 pack of mock exams ($22) from Zend. I used the first test to assess my skill-level and this allowed me understand my strengths and weaknesses. Then, i started capturing the questions so i can review them later. I did this by copying the questions to a word document. So after about 4 or 5 of these tests, you should have enough questions for each category. After collecting questions, I took the time to compile the questions and categorize them. Then I focused on my weak categories until I had a very firm grasp on it. I would break down each question and rule out every possibility until i knew 100% why the answer was correct and why the others were not. This took about a month of off-hour weekend study sessions. Until you're comfortable that you have eliminated all weaknesses, i would use the remaining tests as dress rehearsals and track your progress. You should be making huge leaps and bounds with each test you take after that. During the real test, you'll have a limited amount of time, but it should be enough to do a thorough once-over before submitting. 
I understand why you did it, I just would have done it a different way. Example: http://pastebin.com/GcjjY02U This keeps the class and the HTML separate, but still in the same file which is nice for util scripts as they either tend to grow and need constant upkeep, or never need to be touched again and should stay organized for the next dev down the line. 
Good points - cheers.
Same to you and thanks for sharing.
very nice! a bit buggy, though. I can pretty much only see fog which disappears sometimes
Cool - you should have a peek at [function.stream-select.php](http://php.net/manual/en/function.stream-select.php) and [function.stream-set-blocking.php](http://php.net/manual/en/function.stream-set-blocking.php), might be able to avoid the usleep()
Fog? What kind of fog? A black screen?
I've events that are executed even if there aren't players connected.
I've had some success with the pcntl_ functions although the socket_set_ functions have been a lot flakier for me than C. Haven't had time to look at the code for this server but I'm looking forward to seeing how it's been implemented.
I refuse to acknowledge any further your lack of logic or your person. Good luck in future endeavors.
Oh, that's the server sending the new chunks. Just wait and will be sent (will be improved in a near future). Those walls are the Client-generated ones. (And the fog is client-side, it's part of minecraft PE)
Also, just got here: https://github.com/krakjoe/pthreads I'll implemet Threads in the next major release
oh, ok. thanks :)
I did think that might be the case :D
I really love the features (tried it online), but adding a task is such a buried pain. What am I missing? Why is everything so ugly and 5 clicks away?
It does look really cool. It's a little annoying to enter things in. I think I want something a little faster and leaner. Definitely has a lot to offer though. A little pricey at $9 per user.
i agree with everything you say. and i am a lone wolf, a sole developer, a sole propritor, an individual business owner. I come from a background of Application Development more than web site development. Most things are built from scratch, and even plugins like ckeditor are wrapped in classes for error and diagnostic output. If i were developing a different site every week, hell id use Zend, and as many pre developed classes as possible. The main reason i built everything core like i have is error and diagnostics, logging and caching of thinge like sql statements. i have one app, its now in its 5th incarnation over the last 12 years. Started as a basic CMS and now is part of the core for my startup idea. There is a few years worth of code in it, not just one weeks worth. That and theres no better way to learn than to learn properly. learn the actual coding instead of 2nd party languages that are frameworks to the code.
You are a mad man! 
Great work. &gt; though I might add it as an option Perhaps when you do, you could just rewrite to take advantage of a [React](https://github.com/reactphp/react) event loop. As that page says, React's design goals are: * Usable with a bare minimum of PHP extensions, add more extensions to get better performance. * Provide a standalone event-loop component that can be re-used by other libraries. * Decouple parts so they can be replaced by alternate implementations. So, with things like its socket abstractions, it'd allow you to get rid of a lot of implementation detail and pare back to concentrate more on the Minecraft-specific stuff (with a rock-solid foundation that other people improve for you). Just for example, after a quick look, I couldn't see where you fork, close STDIN and STDOUT (or log them), daemonize or handle signals. (Maybe throw a logging package in there while you're using wheels other people invented? :-) Also, because of the plugin API, you might want to look into [a custom installer](http://getcomposer.org/doc/articles/custom-installers.md) when you add a composer.json. That'd let your end users install plugins using the same frontend they install the server with. And they can manage their versioning and dependencies; something that I guess will become more important as your project ages and/if the PE client updates. Really fantastic work though. Just hoping to be helpful.
Your penis is the size of the universe. Galactus himself would have difficulty sucking your penis.
Other users can be added to projects and can have different levels of access. Try playing with it for a bit.
So when do you make the non-PE version? ;D
Thanks. What I mean is, you're always in a sub-domain. I can't see all my tasks across multiple projects on different subdomains within teamworkpm.
Sure ;)
The PC version uses TCP. That would only allow for one connection (or you'll have to jump around sockets)
I set Redmine up at my office (group of 7 in IT) and it's worked great. This is what I used; http://www.turnkeylinux.org/redmine
Proper response: Never sanitize/change user input, unless it's something like transforming a phone number. Verify information as soon as it is handed over to you, then if validation passes, save to DB or whatever you're using. If you're using a DB, use PDO and named parameters to safely insert the information. When you're outputting any user-touched information, that's the time to sanitize. edit: changed verification to validation.
What do I do to verify it?
my framework, the first thing it does is check the $_REQUEST global array for these array fields, and if found, loops over them for sanitation. So lets say I have a form with 3 fields (month, day, year). Lets say the user inputs '03', '03', 'asd' respectively. When my backend code (that handles the form input) gets executed, the data has already been converted to ints. Now the array looks like 'int[month =&gt; 3, day =&gt; 3, year =&gt; 0]' It would be up to my backend code to validate the date itself, since the actual numbers have already been sanitized. So basically something like if (mktime(0, 0, 0, int['month'], int['day'], int['year']) !== false) If I'm validating a users name, I'm basically checking for the existence of the name, because my sanitation routine, if a text field has nothing left in it after being sanitized, it is just removed from the array as if it were not submitted. If the user submitted their name was '%#@$#@', it will just be removed from the post array field because after sanitizing unwanted characters, there was nothing left. if (array_key_exists('firstName', $_POST['ano']) === true) If I have an int field, I don't convert it back to text for comparison or DB inserts. If I just want to test if the int field is equal to '2', I just do this if (int['day'] === 2) // checks that the int field is both numeric AND equal to the number 2 '=' is for assignment, '==' is for comparison of value only, '===' is for comparison of value AND data type. $a = 1; which means that $a == true but does not mean that $a === true (two different data types, $a is an integer, and true is a bool)
he wants to learn, you dont give a student a library, you teach them how to do it.
always sanitise and change user input. it is going into typecast fields, you ensure that it is right for that field, and cleaned for that field to save from injection and other issues. If its not right for that field, you warn the user its not right. You train the user to fill stuff in, you dont expect anything is going to be clean. sanitise at output??? you want clean data IN your database. Once its in there you know its CLEAN, you can output it knowing its safe. Why store bad data in the dbase in the first place. Outputting is when you urlencode and htmlentities and the like to ensure its displayed correctly. INSERT/UPDATE also takes longer than a SELECT. So when your using the data you want it to be faster. EDIT: Answer me one thing, why the fuck would you put dirty data into the dbase in the first place, this is your datastore, you do not store bad data, why the hell would you do that.
I expected to see actual examples of where pimple failed you. This is just a brief introduction to Symfony's DI container.
that is an interesting idea, but it doesn't give you a session per se that you can store things in without adding them to the user's record, or some kinda join table....
Pimple is a great and simple piece of software. I wrote a simple extension that allows Pimple objects to consume other Pimple objects (so you can modulate and compose your DI containers), and which I think is a nice addition, but other than that I can't see what more you'd need from a DI container.
1. Go to packagist.org 2. Scroll to the bottom of the page. 3. Click "Contact". I have no idea why you're bringing this feature requests with us, seeing as we're not in any way affiliated with packagist.org.
Testing code that uses Pimple if the container is injected into the classes instead of using proper dependency injection is insanely easy - simply overwrite the Pimple array key in your test and it'll affect the actual tested-code.
Can you expand on your extension? I've been doing this, and it appears to be the proper way: $app['daoLocation'] = $app-&gt;share(function ($app) { $dao = new Project\Dao\Location(); $dao-&gt;setDb($app['db']); return $dao; });
Better make sure you host your static content on a CDN or different domain. The cookie overhead could be huge depending on the size of your session. Also will slow down AJAX I would think.
It's easy to edit your cookies, if the "secret key" you use is too short you could allow a hacker to take over someone else's session
Yes, but it's easy too if use Symfony's DIC. one configuration for each environ and we use one or another depending on the environ. Anyway if we need to use the container within our test is a typical code smell in TDD. It's pretty straightforward to inject the DIC in our classes and we have all the container, but with this technique our class is coupled to the container and the main objective of DIC is to decouple dependencies, so when we are working with Tests the use of the DIC must be the last option. If we follow demeter law we only need the class that we are testing and mocks for the real dependencies (not the container)
What happens if you look for a dependency in $foo which is defined in $baz? I'm assuming the consume method either copies the definitions and instances, or creates a reference to the other container, but doesn't create a reference to itself in the other container. 
My "problem" with pimple (I'm not saying that Pimple is bad, I only say that I feel more comfortable with sf's DIC). When I use Pimple and DIC grows the PHP code "ofuscate" the dependencies. For me is more readable with yml. I'm not using xml, but I really thinking about using it instead of yaml. xml is awful, I know, but IDEs compile them and show errors while you're writing code, and that's cool. The last point about "testeable", the use of pimple is the same than sf's DIC. But as I said before in a previous comment I try to avoid any kind of containers when I use TDD. If on class depend on the container we have a problem. the instance of classes must depend on another instances (as less as possible and taking into account always the demeter law) 
It's not extortionate at all - by becoming an accomplished developer you can significantly increase your marketability and therefore your salary. If this leads to a better job and a 20% wage hike (very much possible) then it will pay for itself thousands of times over. Should a university degree be cheap because its mostly someone talking at you in lectures? The price of goods should not only depend on their raw costs but also the value they provide, but thinking about raw costs - think how many hundreds of hours would have been spent writing this book, proofing it, rewriting sections etc etc.
&gt;My "problem" with pimple (I'm not saying that Pimple is bad, I only say that I feel more comfortable with sf's DIC). When I use Pimple and DIC grows the PHP code "ofuscate" the dependencies. For me is more readable with yml. So the answer to the question is "yes". Personally, I find Pimple a bit backwards. In order to share dependencies, you need to set the dependency as static and return it, which is handled by a share() method, which in turn returns a function which does that. Additionally, in order to add stuff like parameters, you'd need to return a function, which then returns said parameter, which again is done via a method (protect()). I got my own DiC which is structurally a lot more simple than Pimple (and because of it, &gt;100 LoCs lighter), while still being able to replicate all of its features. Additionally, I got a couple of additional classes which allows me to deserialize dependencies from YAML, XML or whatever else it might be serialized in. So, it's good to know that I got my bases covered and that the issue you've outlined with Pimple do not affect my own DiC. If you got any more issues with pimple, or other DiCs in general, I'd be interested in hearing it, as it would give me an opportunity to improve my own. &gt;If on class depend on the container we have a problem. Not necessarily. It's only a problem if we use it as a service locator for your business logic, in which you have the traditional issue of your code being too tightly coupled with each-other. It's perfectly fine to have a container in your tests under other circumstances, however.
Would be great to have a look to your DIC implementation. Sounds good if it's as simple as Pimple and allows to use yaml/xml configurations. By the other hand I prefer not use "share". Share is the same than "singleton" and "singleton" something similar than the usage of global variables and global variables are evil :) When we inject a container to a class is very easy to violate the single responsibility principle. Sometimes I use it, but if my classes are not coupled to de DIC, better.
That would be a poor decision to make, wouldn't it? 
typo in the sample: __sleep(0 and __wakeup()
still vulnerable to race conditions.
Is it possible to use an image as a watermark?
He's clearly just an arsehole. Look at his posting history; utter bollocks. Uninformed nonsense. Just ignore him.
Yes, I've seen it, and I know who the guy is. I'm just curious as to what makes certain people tick. 
it is a little bit of a pain. In my own humble opinion, that is a result of the 'web-based' way of doing things. But once you get used to it it isn't that bad. Set up versions so you can see everything in the roadmap, add components and priorities the way you want them and then in the menu you'll see a 'New Issue' button that is always present. Our favorite thing about it is the updating. We keep long threads when discussing issues and their UI is really nice for figuring out what is going on (when I look at bugzilla I want to pluck my eyeballs out trying to figure out what is going on). But in the end it is all a matter of personal preference and getting used to how things are done.
I guess you could store the process id as the lock value, or some other unique identifier for this process, and check it each time you access the session to ensure the value never changes, if you absolutely had to avoid race conditions. If you keep the latency between your memcache server and your PHP server to a minimum, then the chances of a race condition screwing anything up are minuscule. I find that to be satisfactory for what I'm doing, since the chances of a user having 2 (or more) requests within the same 2-5ms on the sites I work on are very small.
if you live your life right, your session cookie is &lt; 256 characters. If you live your life wrong and put your session (even if it's only 1k after serialization and encryption) in your cookie, that's 1k for every single thing on your page. Maybe 16k per page, that could be hundreds of megs/day in wasted bandwidth. 
I was thinking more along the lines of a separate attribute in the filesystem, along with perms, creation date, etc.
Anything that saves you time has a real world application. Many of the frameworks you have been shit talking save you time... Why build EVERYTHING from scratch for no reason at all? To point out an exaggerated example... if I need a simple blog site, I will use Wordpress.. Not develop a custom blogging engine.
Everyone's situation is different, but I have not worked in an environment in the past 15 years where "hundreds of megs/day" is significant in the least.
Makefile to run a PHP script? Jesus trucking Christ.
Started tinkering with Imagick a few weeks ago for a project at work that included auto-watermarking (as well as thumbnail generation) -- I love it. You can basically do whatever you can in Photoshop as long as you can definite it programatically. Yeah, it's slow, but unless you're generating something on the spot (like a captcha image), that's easy to deal with. Other than caching (as others have mentioned) you can just save the watermarked versions as a file with Imagick.
You're making an assumption, which is that you are necessarily part of the audience I'm targeting. That may or may not be a correct assumption. Supply and demand says that if I lower the price, I'll gain more purchasers, all other things being equal. Therefore, to expand the audience without taking any other action I simply need to reduce the price. Were I hoping to sell as many copies as humanly possible, that would be what I'd do. But that's not my goal, or my audience. The audience that I'm targeting is a specific audience: professionals, who are aiming to improve their PHP skills and derive value from the other content I write (99% of which is free). They buy my book because they trust that what I offer is of value. They're not cold sales. The audience that I'm targeting respects the value of content, and understands that content has value, regardless of its delivery method. And since I'm honest, I offer a refund in case someone buys by mistake and finds that it wasn't helpful to them. Perhaps you're in my audience. Perhaps not. But the bottom line is, my audience is not everybody.
Thank you for your feedback. If you don't know who the book is targeting, then I have not done my job. I've started work on a blog post to help clarify that. It will be published in the new year.
It sounds like you intend to write one function to clean and sanitise input. I'm afraid you'll need more than one. There are two principles at work: [input filtering or validation](https://www.lazycat.org/php-input-filtering.html), and then [output escaping](https://www.lazycat.org/php-output-escaping.html). The way you do these will depend on what input you're expecting, and where you'll be using it. Filtering would be (for example) removing PHP/HTML tags from strings with `filter_input(INPUT_POST, 'myformfieldname', FILTER_SANITIZE_STRING)`. Validating would be (for example) requiring a number for age with `filter_var($age, FILTER_VALIDATE_INT)`. Escaping is preparing content to be safely passed to something: e.g. for HTML or XML, `htmlspecialchars($content, ENT_COMPAT, 'UTF-8')` Escaping is essential wherever content and commands are mixed together, like HTML. With databases you can (and should) use [prepared statements](https://www.lazycat.org/php-prepared-statements.html) instead of escaping. In PHP this means abandoning the defunct `mysql_*` functions in favour of PDO (or mysqli I guess) You'll need to filter and validate input directly as you consume it, but only escape when you need to use it (e.g. don't `htmlspecialchars` before storing in the database, do it when you're about to display it because the kind of escaping you need to do depends on what you're about to do with the content - you wouldn't want to have HTML entities if you were making a CSV report, for instance). 
You may be putting the cart before the horse. Get a hang for Ruby before you dive into Rails. I highly recommend [Why's (Poignant) Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/book/chapter-1.html).
PHP is a programming language. Rails is a framework based on the Ruby programming language. There's nothing wrong with learning Ruby or Rails, but if learning either is going to take more time than you can spare you might consider using a PHP framework like CakePHP or Symfony.
Personally I think stick to PHP. Ruby on Rails can take a while to really get the hang of and developing a large application using it with little experience means you will likely make decisions that could have been done better. With your current skills being in PHP stick to that, do things well and learn Rails in your spare time or on smaller projects. Oh and I'm a Rails developer so I'm not being biased here
Couldn't agree more with this. I started using Rails because I've used Ruby for some other development. I chose a small project, and boy am I glad I did. There is so much to learn and know in Rails, it'll take sometime before you'll feel really comfortable with how it works and operates. Take note, it also works differently when you have to deploy it to a server as opposed to just local development on your machine.
Cool. Similar than pimple with xml/yaml configuration. There's something that I miss (maybe ist's covered but not in the examples). sf's DIC alows you to call setters after instalation: view: class: Class arguments: [@anotherClassInstance] calls: - [setUser, [@anotherClassInstance]] It's very useful when we need to 'prepare' our instances with setters Sf's DIC also allows us to use variables (%variable%) and import files (useful to organize our dependences)
That's why there's a whole market of products, not just one. Clearly you're a price buyer. That's a fine and valid position. As for me, I reject the suggestion that I should earn less than a third my hourly salary for sharing my knowledge with the community. I reject the implication that my ten years of experience in software development doesn't have a value. I reject the implication that books are somehow more or less valuable simply based on the medium they're delivered in. And I firmly reject the notion that telling people what the advantages of my work is over the other works out there is "sham marketing" or equivalent to "how to earn millions with adsense." 
I wish I had more upvotes for you. Why's guide is fucking brilliant! 
But not all learning materials are the same, surely?! I remember buying 5 to 6 books on one topic (C#) and half of them were useless to me. And I couldn't return them to get my money back!
And the slowness doesn't matter when you're not running a 50.000+ visitor a day web application.
So the official full name of PHPPHP is "Personal Home Page Hypertext Preprocessor Personal Home Page Hypertext Preprocessor." Best name ever?
I did. What is it you want to have said?
I'm saying that you're not supposed to be able what I did in that switch statement. No other language that I am aware of allows it.
And what exactly does If statements? It checks whether the provided variables and whatnot evaluates to what the coder specified and if it does then the code within the brackets are ran. This is EXACTLY why it's considered bad practice to use several If statements instead of just using a switch statement. I still, however, do not see how you are obsessing about it not being strange that the code in the image works when no other big language allows you to treat switch statements like this.
Not really. It's been a long time sine PHP stood for Personal Home Page. Now it's PHP Hypertext Preprocessor. It's a recursive acronym, kind of like how GNU stands for GNU is Not Unix. 
Yes, But the PHP in PHP Hypertext Preprecessor is still for Personal Home Page as far as I know. I just expanded it to it's full possible name for comedic value just because I could, since that's basically what this library seem to be for. (Just because he could that is)
&gt;Yes, But the PHP in PHP Hypertext Preprecessor is still for Personal Home Page as far as I know. It's not. &gt;"While PHP originally stood for Personal Home Page, it is now said to stand for PHP: Hypertext Preprocessor, a recursive acronym.[8]" http://en.wikipedia.org/wiki/PHP &gt;"PHP stands for PHP: Hypertext Preprocessor. This confuses many people because the first word of the acronym is the acronym. This type of acronym is called a recursive acronym. For more information, the curious can visit » Free On-Line Dictionary of Computing or the » Wikipedia entry on recursive acronyms. " http://us.php.net/manual/en/faq.general.php#faq.general.acronym It's called recursive for a reason.
Not any more. It really is a recursive acronym, officially.
Give me an example of a language that can evaluate the following: var var2 = 'two'; var var1 = 'one'; switch(var1) { case 'one': print 'one'; break; case 'one' || var2 == 'two': print 'one or two'; break; }
COBOL. Next.
Ah well, still more fun the other way.
You're not aware of many languages then.
I dunno what if you future PHP 9 app needs to run some PHP 5 code that is no longer compatible.
Shameless plug here. This is written on top of [PHP-Parser][1], a PHP parser written in PHP, which is a library I maintain. If you find this kind of stuff interesting, feel free to have a look at it. There is a lot more one can do with it. Back when I wrote this I had a lot of plans for it (mainly for static analysis of source code), but due to time constraints I never got to actually implement anything. The most common use of the parser is currently documentation generation (phpDocumentor 2, Sami, phpdox all use it). [1]: https://github.com/nikic/PHP-Parser
What if PHPPHP itself is no longer compatible? Maybe by then PHPPHP has been upgraded to PHP 9, but then would it still run PHP 5 code? 
Probably the only gold worthy comment in /r/PHP
We set up PHPPHP as some sort of JSON service where you send it php and it sends back html. (Using a 5 compatible version)
Now feed it this! I recommend executing another instance of PHPPHP: &lt;?php function PHPPHPPHP($code){ eval($code); }; ?&gt;
Even when you save that stuff to a session it isn't passed through the network. Only session id info is. These guys are talking about how big to make the id info in a custom session handler, not how much data to store in session variables Edit: mobile spellcheck made ridiculous edits to the comment, had to fix
I agree with that. However, the way the parents phrased it "hundreds of megs/day in wasted bandwidth" make it seem like parent is concerned about bandwidth usage rather than client side lag.
No. sf's DIC allows to set up variables. for example: parameters: doctrine.dbal.configuration: Doctrine\DBAL\Configuration doctrine.dbal.drivermanager: Doctrine\DBAL\DriverManager log.path: /var/log/application/ And later you can use them within services: services: dbal_configuartion: class: %doctrine.dbal.configuration% logger: class: Logger arguments: [%log.path%] Ii's very useful to create one file with the hardcoded variables and import this file in services.yml Here you can see one working example in one of my pet-projects. It's a custom framework. It isn't sf's MVC but uses the dependency injection container: https://github.com/gonzalo123/nov/blob/master/tests/fixtures/config/services.yml 
TDD has been around for long enough for it not to be a trend. Whether you do it or not is up to you. In my experience most people that claim to be doing TDD actually just mean that they are writing unit tests. As you say that's not actually what TDD is. Personally, I do not use TDD but I do write thorough unit tests (with high coverage) because it helps me write better code (forcing things like DI) and prevents regression issues. edit: also should your title be `$tdd-&gt;fade();`?
Enlighten us, please?
In your eagerness to show that the OP must be stupid for missing this all this time, I think you are demonstrating a complete misunderstanding of the switch statement. The expressions of the case statements need to match the expression of the switch statement, not "evaluate to true".
Since its a 10 year legacy app, Im guessing its a fairly important component in your company. This is not the time to be learning a new language. Play to your strengths and deliver a great PHP app. Developers spending months crafting some project which turns out to be half-baked and worse than the legacy code, often get fired
&gt;Yes, the comparison of "true" to "something" is the important point here A comparison is an expression T__T &gt;hence my point, as that statement could mislead a newbie, which is what this thread is all about. Maybe you should stop making assumptions and claiming that other people do not know how stuff works, because clearly you were wrong about that. 
It's not a bad way to do development as long as you actually do it properly and it's not just about using buzz words.
Definitely, if you're storing megs of data, you may need to rethink your strategy. I've never actually gotten to the point where it becomes a problem though. Secure data shouldn't be anywhere unencrypted, even your database. Your session file is literally just as secure as a database. Your PHP has the connection details somewhere in plain text, or if the DB is on the same server, you can just open up the files directly. They're both good points, and I think we're on the same page with this, I just hope some folks read this and rethink their approaches, because a lot of the advice given in this thread is downright dangerous (and not even answering the question, which was about session locking specifically).
&gt;... even that would help. No, it wouldn't. You should rewite your code and use prepared statements. Parameter binding via prepared statements has the benefit of being immune against SQL injections. 
Are you currently using a PHP framework?
So we can use it with jQuery of course.
Hm, I think you mis understand. I **want** to rewrite the code to use prepared statements... but i'm trying to figure out a way to systematically replace all the old function calls with the PDO alternative (the prepared statements alternative).
BDD?
Yo dawg, I heard you like PHP, so I put PHP in your PHP, so your web pages can serve up web pages.
You should write some tests. With PHPUnit process isolation it should be doable.
No prob -- and an FYI, it emails you with updates on changes to your lists :-)
You know, that's not a bad idea... it at least buys me time, and to my knowledge mysqli functions aren't being depreciated like mysql functions are...right? It's at least something to look into/consider.
This.. Once I understood the deploy process, it was dead simple. Getting it set up was a real pain in the ass. Once you know what all the magic functions that Ruby/Rails adds to objects are, they make your life much easier. trying to figure it out as you go? Nightmare. If you are dedicated to learning Ruby and Rails, I'm sure that it can really make developing applications much faster. I was taking over maintenance on an app, and absolutely hated using it because of all the things that a Rails dev probably takes for granted, but I have to dig and dig just to find out it was some call to something in the framework. I'd stick to PHP since you know it. *I* would probably port whatever is there over to a .NET solution since you've already got a Windows codebase to work from (assuming it's not .NET already). It's not everyone's cup of tea, but being both a PHP and a .NET dev, I can see benefits to both.
Serious question. Does anyone still make Twitter apps? From my understanding they are [extremely hostile](http://news.cnet.com/8301-1023_3-57495069-93/twitter-ups-restrictions-on-developers-seeks-greater-control/) to developers. I could see writing an inhouse app but never one that I intended to market to others.
It seems to me there are so few developers creating cool stuff for PHP that I know all their handles. PHP-Parser looks cool like it might be useful for a project I've dreamed up but not yet started: Typescript for PHP. PHP seems well suited for static typing.
Be warned, should you look into the mysqli_ family of functions, not all functions are exact replacements, such as mysql_real_escape_string vs mysqli_real_escape_string, which reverses the order of inputs. Your best bet is to just take the time and completely rewrite the code using either PDO or mysqli's OO methods, as short of doing mysql-&gt;mysqli, there's not a whole lot that can be done.
As a php person who is also curious about Ruby, and got pointed to Why's (Poignant) Guide to Ruby, I have to give you an upvote.
I think what Nicoon is getting at is that there's no solution to the problem you're facing. If there was one, you wouldn't be asking this question, because unsecured database queries are arguably the #1 security issue in the wild, so if there was a solution, it would be built into PHP. The only solution is to replace your database layer in its entirety. You're currently using string concatenation for parameter insertion, which is not something that can be identified programmatically and replaced. You need to do the legwork - there's no alternative.
Replacing the function name is a red herring. There is nothing *inherently* insecure about the mysql extension, other than that it has no faculty for parametrization of query data. Replacing mysql_query with PDO::query would result in having the exact same level of insecurity. No less.
This is why data access should be abstracted into it's own class/sub-system in your projects.
&gt; it's called recursive for a reason To confuse people and never know what does the original acronym stands for?
Just a pro-tip: you should always wrap your extensions. It becomes a LOT easier to swap out when you eventually have to. class Database { public function query($sql) { return mysql_query($sql); } // etc ... } In this case, though, it's important to still walk through your code so that you can take advantage of PDO's safeguards against SQL injection.
Hi again everyone, OP here. Thanks for all of your suggestions and input. I really appreciate your comments and I'd like to answer a few questions I noticed. I have built extensively with quite a few PHP frameworks (full and micro). PHP isn't just my hobby and my language of choice at work, I wrote PHP in contracted development positions to pay for college. I thought about contributing to CodeIgniter or Laravel, but I don't have time for it right now, maybe later. The system I am replacing is written in a proprietary language that dates back to the 80s, so .NET is out of the question. I am trying to get my workplace away from the lock-in they've been in after the past ten years of shitty contractors (I'll post a novel of a rant when I am finally able to kick them out). I'm probably going to knock this project out in PHP. 
I though you wanted to create your own function to parse the query, extract the parameters and feed them to PDO in a prepared statement. You will probably want to write a CLI script to do a dry run and check the conversions. It's going to be hard to catch all the parameters properly.
Also take a look at design patterns
Dont, rails is the framework and ruby is the language
Ugh. Fucking indian junk developers treating reddit as their personal advertising grounds. 
Regarding your third point, PDO is only a database connection abstraction layer, not a query abstraction layer. You can easily change your code to connect to a different database system, but you'd still need to rewrite some of your queries (unless they're _very_ simple - Things like pagination are done very differently in different DBMSes). Using a query builder helps, or you can use the repository pattern so all the queries are centralised. Most frameworks have some sort of query builder (I've used CodeIgniter, Kohana, and FuelPHP, all of which have query builders or ORMs built-in).
It's too late for these legacy apps.
Probably true. But again, it's too late for these legacy apps...
Ah sorry, I mis-understood this before. I see your point... 
Can you explain/talk more about the reverse order of inputs? I'm not sure I understand what you mean here.
PHP in PHP. Something like "inception" movie for PHP :-) Nice!
The operands to the actual function are in reverse order: string mysql_real_escape_string ( string $unescaped_string [, resource $link_identifier = NULL ] ) string mysqli_real_escape_string ( mysqli $link , string $escapestr )
I use mysqli extension for old projects and use procedural style. rewriting code is quite easy if You are using mysqli procedural style. on new projects I use mysqli oop style or Yii framework. basically do project-wide replaces like: mysqli_query( -&gt; mysqli_query($db, mysql_real_escape_string -&gt; mysqli_real_escape_string($db, of course You will end up with some problems, like with mysql(i)_select_db (link identifier is now first param in mysqli), there will be problems also with mysql_result... There is no need for prepared statements if You escaped variables in Your old projects. It would be too much work for too few
99% of sql call time is on DB server/network side and not on mysqli/pdo side. these 30-40% numbers doesn't mean much and http://net.tutsplus.com/tutorials/php/pdo-vs-mysqli-which-should-you-use/ says pdo is about 6.5% faster
I think it is better to use IDE. For example Netbeans project-wide replace. It will warn what will be replaced and how before replace is done...
Congratulations, now you're stuck with a systemwide installed version. Composer please. 
And dependency injection! E.g.: class Post { private $database; public function __construct($database) { $this-&gt;database = $database; } public function save() { $this-&gt;database-&gt;query(...); } ... }
Related reddit question from 2 months ago: [Does Pimple scale?](http://www.reddit.com/r/PHP/comments/10xc1z/does_pimple_scale/)
Is there any change you might share that word doc? :)
Stop calling them PHP guns would be a good start.
Standard HR procedure actually sort of works. Check schools, previous employment/projects, recommendations, and if you're looking for remote work, the person should be completely trustworthy. With financials, I would go with someone close by, otherwise you have the guy in another country that for all you know is selling your company's information to others, and you have to jump through hoops to even sue. Yeah, that's no fun.
I can help, http://www.webfoundation.net/public/resume/
You can always do coding tests, but make sure they know what they're talking about. Most people have resources they use...it's true, but if they use those resources and are efficient, it's okay. I don't remember exact syntax for mysql triggers, for instance. But you can't have a naive guy that's doing total copy and paste from sites with little understanding. That'll get you in trouble. There are also PHP certs, but I honestly don't put much stock into most certs.
The Zend cert for PHP is pretty good. It's not just multiple choice and you have to have a pretty good academic understanding of the language in order to pass. It's also much more difficult to find a BrainDump of the exam online. I wouldn't hire someone solely on the fact that they had one, but it's one of the few certs that I have some respect for. Source: I am a ZCE, and have certifications for MySQL, a bunch of .NET and SQL Server, and the ZCE cert was the hardest..
Instead of looking for an individual, look for a good company. Rather than getting the experience of one person, you get a whole team. It will likely be more expensive than a freelancer, but you get the benefit of multiple people sitting down and planning out the project, bouncing ideas off of each other to find the best solution, rather than relying on one person doing it the best that they can.
Bah, Too slow! ... what you want to do is serve your PHP in plaintext over a WebSocket and then implement your PHP parser &amp; VM in client-side JavaScript.
As much as I like PHP, I wouldn't trust a PHP "script" to handle transactions, especially 1B/year in transactions. If they're handling that much in transactions then they should be able to afford an applications team to create an actual application (e.g. Java application) to handle the transactions.
And quite often that "whole company" can end up relying on one experienced developer to make all the decisions and do all the coding. I see this time and time again. A client had their CRM customised by a big company with a fantastic team (according to the marketing material). Now they need a few tweaks, the answer is, "err, he's moved on, so we will need to 'do some consultancy' to see what it will cost". They only want a few drop-down lists extended. We have also had similar experiences, where companies have sold themselves to us as having a great team of experts in some particular PHP application, but actually just farm it out to cheap developers elsewhere in the world and just do as little as they can in the project management side. We tend to have to rewrite that kind of project ourselves after delivery, which is very annoying and expensive to my stress levels. So, don't for one moment think that a large company is certain to provide better service, more care, and a more robust and *correct* solution. A large company is no guarantee of that.
Aren't prepared statements there only for multiple repeated queries? It's also slower to use a prepared statement than to use a regular one
Thank you for your comment. I agree that PHP shouldn't be trusted to handle 1B in transactions. Our parent company actually handles this with a Java application. What we are planning to do is to create a reverse proxy to an existing API (written in Java), using PHP and to also create a simple reporting/analytics interface for clients that will consume information from an existing separate API. We do have some dev resources available to us within the parent company but we thought we'd put the call out anyway as we are building up our team. Thanks again!
Certainly. You still need to vet the company. I'm still more comfortable trusting that a company with multiple developers and a proven track record will be around to finish and maintain a project than an individual. I've had too many individuals - even the ones who seemed really professional, and knew their stuff - flake out and disappear before completion or take a full time job and not be around 3 months afterwards for changes. I would avoid large companies as well, but somewhere where there are at least 3-4 devs who can complete your project means that people can get sick, take vacations and get hit by a bus without it meaning that you need to shop around for a new developer. 
Country/City? Salary Range? Just post your full advertisement on here and ask for some response. PHP is fine for front end, but given that you are doing secure transactions in the amount you are you might want to stay away from scripted languages altogether and look at some actual compiled items such as CGI or Server Mods. If you can do as much as possible in your database as well it will be more secure and more accurate in realtime. 
It's not just a multiple choice...but the sample questions ARE multiple choice. http://downloads.zend.com/guides/php5.3/PHP_53_Study_Guide_v1a.pdf Seriously...155 pages for the study guide that includes study questions. There are some good points in there that people are not generally going to think of, which talk about how PHP works...for instance garbage collection. For what it's worth, it's a good read, but it's a bare surface skim of the php site IMHO. 
perhaps they can update the About &gt; Performance page next. quite useless.
Australia/Sydney. If this initial project works out well and both parties are happy then we'll be offering employing full time employment @ ~100-120K/year + perks (gas, bonuses and more).
Can someone explain how this thing works, Please?
Do you have any in-house IT / development talent at all? Because it sounds like you're in the classic trap of needing some decent programming work done but not being able to identify what decent programming work looks like. Second, if you want good-quality back-end coding, advertising for PHP programmers is not that likely to get you what you want; most PHP people in my experience (and I am one) are not highly-skilled programmers but people who use PHP like glue to stick different pre-built modules together. Given any sort of logical challenge, chances are that guy with ten years of messing around with customer-facing websites isn't necessarily going to cut it. I'm intrigued that you talked to some people but they were "too busy". That doesn't sound like you're looking in the right way. Have you tried contacting some local IT recruitment people? They'll send you a fair number of CVs, although you do have to exercise caution and interview those people well; in my experience, recruiters are only good at doing the networking part of connecting you to CVs that match your keywords, not necessarily people that can do the job.
The changelog is huge, any highlights? 
What I just heard was, "well the project is mhrmhrmrhrmr, but here's something that's really attractive if it all works out." That's a REALLY bad sign.
I meant it in the sense that if the developer delivers then it's something we can offer if they're interested. We are currently expanding our team and starting with us on a contract basis could also allow the developer to figure out if they'd like to stay with us - something we could facilitate. The reality will remain that our company, particularly our parent company continues to be working out pretty well. Naturally if the developer borks (their) part of the project then it's not going to work out well for them. -- Edited What I should have said was that the employment opportunity is not tied specifically to the performance of the developer that takes the project on - we'll be hiring someone regardless.
Thanks for posting, Aleksey! I will be in touch soon.
We do have in-house resources to draw on where appropriate, but at the same time we would like to build up our own team and not become too much of a drain on their resources. Thankfully, we are in a position to have candidates code/github/personal diaries/memoirs reviewed by one of our lead software engineers (parent company) who will help to guide our selection.
Something that I think is unclear, and I think may contribute to the discussion about hireing an agency vs an individual. Would this new develeper be joining a team of developers, with already established technical leadership in the company, or would they be a lone developer managed by non-developers? If you already have a team, and you just need another guy because everyone's tied up with other work, then definitly hire an individual. If you don't have technical leadership, and your just getting a lone developer who you'll have to trust on his word that he knows what he's doing - in this case I recommend going with an agency. If you have a dev team (that I'm assuming your not a part of, Idk why I'm assuming that, something about the way you posed the question) then I suggest you talk to them first. Ask them what skills and knowledge would be necessary for the job. They will have more understanding and context of the work then us random redditors will. Ask them to help you phone screen and interview candidates. They will probably welcome this, since they will have to work with the new person, they will not want someone who isn't qualified, it would make their lives harder. If I'm rift in my assumption, and you are in fact not a developer, I can not stress the importance of having actual developers on the screen calls and interviews. Many candidates can spit out buzz words and Google things as you ask them on the phone - it takes an intimate knowledge of the subject to weed out the phonies. All the things I've explained about consulting with your in house developers, their importance is why I recommend hiring out an agency if your company doesn't already have established engineering leadership. Without it, hiring a lone developer is a gamble. In short, my advice for hiring a developer is to ask other developers in your company. If you don't have any, hire an agency with a good portfolio (not just a pretty sales lady with a cool powerpoint).
Does the project have broad public applicability? Or is it an in-house system only? E.g. If your reporting is for a payment gateway that can be used by anyone, then you'll find that open source developers are interested, and it is worth trying in places like drupal.org. If your system can slot into Drupal, or a similar system/framework, then you've got a reasonable chance of finding someone good. But if it's a system which is, say a reporting mechanism between your parent company and franchises, and has no public good, then don't bother looking for developers in open source. It's worth recognizing that you aren't a great place for a lone developer to go: how is she going to learn and interact with peers? Granted you have developers who are great C++/VB/C#/Fortran/Whatever developers, and there's some cross-fertilization, but PHP is built on open source foundations and community, and they'll be the lone PHP developer, always being pushed towards C# projects. If you do find a developer, chances are you won't find someone who is top-notch who wants to work for you because you lack the environment. It's partly made up for by being ok for remote work, but that's not a huge bonus. I interact with my local PHP groups on a long-term basis. When I need people to help on a client's project, I go talk to my friends, and see who has time.
Security isn't based on getting 1 magical key. More importantly, someone wouldn't have to figure it out. They would need something that hashes to the same value to have compromised the account. Pay attention to the collision finding algorithm on the wiki. MD5 generates a 128 bit keyspace, but the effective keyspace is much much smaller. If you have a target hash, it's doable in a day. There are other attacks, but MD5 is not considered safe for the purposes of security. 
I think I remember reading that they are holding off on any significant new features as they work on Yii 2.0. This just looks like a ton of bug fixes and some minor enhancements. The one thing I am most interested in is: "Added minified jQuery BBQ", maybe they are planning on allowing AJAX history by adding an option to AJAX calls?
pm sent
Sure, there everyone's experience will vary. Just walk in with your eyes open, ask to see previous work, and don't be taken in by sales patter.
Nice!!
"I need someone out of college that will work 80 hours a week for a bag of cheetos, a pat on the back, and the title of 'Ninja'."
Is there an advantage to properly using private,public,protected(resources/security?) or is just considered good practice?
Your class *variables* should always be private.
There is. It's a matter of two things: safety and documentation of intent. Let's look first at documentation of intent. Consider the difference between a well separated class and a clone of that class which is purely public. Strictly speaking, the pure-public version no less "safe" than its well separated counterpart. It's other than that the same code. Private and public don't create any kind of magic security model or anything. But it's clearer what the original developer meant to be used. You don't go using some piece because it looks like an entrypoint, because I made it private, because it assumes a specific data order from the outside that you won't be expected to have. So I'm removing the opportunity for error. And in that sense there's a very real safety issue: if the developer makes large classes of error impossible (and forget "the users would never make a mistake that stupid," because yes, they would,) then the resulting code is fundamentally safer. It doesn't, like, give you a security system to rely on, or anything like that. But it eliminates a large class of potential stupid error, as well as clearly documenting with compiler enforcement the original developer's expectations, and those are some of the biggest safeties you can have as a programmer.
You should always make a variable private unless you specifically need one to be protected, and even then you should consider if it should actually just be public. Typically I only make a variable/property/function protected if I know my child class needs to override it's functionality, but it should not be accessed from the outside. Don't worry about what child classes other people might make. Forget about them. If there is something you think they need, make it public, not protected.
If you want to use something like Rails in PHP, there are plenty of good frameworks out there, and I am of the opinion that if you have more than ~5k LOC, not using one is doing yourself a disservice.
Fuck off! It was a misunderstanding on my part.
The reason that most companies don't do this largely depends on the billing model. If you have 4 senior php programmers hammer plans out start to finish, it's running about 1000/hr billable. Try explaining to client that they just spent 1000 dollars for your team to think about how it needs to be done, and you get angry customers. Of course planning needs to be approached, or more time will be wasted.
That is debatable really, some people do not agree with that convention. I prefer to make properties for accessing variables, but I can see the other side of the argument too.
Sent a PM with some details and contact information.
We definitely do have a world class team and we get paid quite well in addition to perks like having flexible schedules, a relaxed work atmosphere and getting to work on interesting projects. That's not our average programmer, though. We have .NET guys and front end devs who have less experience. We only have 4 PHP devs, they just all happen to be long time veterans. I'm still the "new guy" on the team even though I've been with this company coming up on 5 years. I don't really know about the transition from 3/4 since I started in PHP right around when 4 came out. I did mainly classic ASP before that.
I often hear the argument that doing things like that will give more flexibility in the future. But the truth is if you are writing code to extend a class, then it's fairly trivial to change the class you are extending to expose the methods you need. Just as making class members public should be done judiciously so to should making them protected. There is no reason to make class members protected if no one is going to extend the class and utilize them. TLDR; Just keep things private until you need them less restricted.
Try elance.com. The tools for selecting your contractor based on location, expertise, and direct interaction are second to none. 
I've worked extensively with Joomla and Drupal. I definitely prefer Drupal. The architecture is just so much cleaner and the override method of handling functionality means a lot less core hacking. Plus, the modules available for Drupal tend to not only be much better quality, but free, whereas in Joomla you've really got a crap shoot. As far as frameworks, I've really only used Zend. It's good, and does provide a lot of functionality, but it's not my first choice when doing a project. There's a lot of overhead. We recently had a project where transactions per second were about 10X slower going through Zend than just straight PHP. We have frameworks that we've developed in-house over the years that includes a nice DB layer and some great presentation shortcuts. When you just need something lightweight to get information back and forth from a database to a webpage, it's perfect.
They're both have their security holes. Drupal is a little better. It's hard to find a good secure CMS. Zend has loads of functionality, but yeah, the overhead is horrific....or used to be. Kohana and CodeIgniter are simple....maybe too simple for RAD though.
This is my company :(
Abstract classes may need to use protected vars/methods but otherwise you can usually get away with private. Generally using the most restrictive visibility is preferable.
you joke, my first job out of uni was PHP development for £7.50 an hour. bad days.
Resources? No. Security? Only against inadvertent "attacks" of bad judgment by yourself or your team. But those are often the worst kind.
DOLAN!!!!
[Monkey Patching](http://en.wikipedia.org/wiki/Monkey_patch) exists because of the inability to override private variables and methods to work around bugs (usually in big frameworks). It is an absolute pain to have to do, and I am determined not to force anyone else to have to do that because of my own code. I only declare variables as private that already have getters and setters. As for functions, I go by the rule "Don't make it private unless you're 100 percent sure that there are no bugs." Hint: This is never the case. As for documenting intent, if I consider something "private" (not really meant to be overridden) then I mark it as such in the PHPDoc block: /** * @access private */ This prevents the variable or method from being exported in the HTML documentation. Edit: Corrected @private to @access private for PHPDoc.
Great year it was, I reduced my pant size by 20cm and wrote some cool code. * [Faker Port] (https://github.com/icomefromthenet/Faker) - Helps generate test data in sql and phpunit xml format * [DBALGateway](https://github.com/icomefromthenet/DBALGateway) - Table Gateway like zf2 TableGateway for Doctrine DBAL, great with silex. * [ReverseRegex](https://github.com/icomefromthenet/ReverseRegex) - Use basic Regex notation to generate strings. * [Migrations](https://github.com/icomefromthenet/Migrations) - A Schema migrations using Doctrine DBAL and Symfony2 components * [LaterJob](https://github.com/icomefromthenet/LaterJob) - A Job Queue for Silex that generates metrics too. I got around to reviewing the major config managers (chef, puppet) and finally settled on a new comer [Ansible](http://ansible.cc/), I put up my play books on [github too](https://github.com/icomefromthenet/PHPAnsiblePlaybooks) works great with vagrant. 
Got my first Developer title, Analyst no more.
That shouldn't happen. A change to a base class to accommodate a single subclass is something that should be added to the subclass instead. A base class should always be generic enough to work correctly for all subclasses.
You learned about OOP in Java, right? I'm sorry that you were misinformed in that way, but Java has several critical flaws that people confuse with OOP. The most important one, for this discussion, is the idea of *properties*, or other similar concepts (I'm not sure of a general name for them). Since we're in /r/php, I'll give an example in that language. Perhaps we have a simple class that represents some information stored in a database: class Foo { public $baz; public function __construct() { $this-&gt;baz = $db-&gt;fetch(); } } We use this code somewhere like so: $foo = new Foo(); // Do some other things. print $foo-&gt;baz; Later, however, we decide we want to delay the db call until we actually need the information (that is, implement our own lazy-evaluation). So, we change our class to use the [magic method](http://php.net/manual/en/language.oop5.magic.php) `__get()`: class Foo { private $baz; public function __get($name) { if ($name == 'baz') { if (!isset($this-&gt;baz)) { $this-&gt;baz = $db-&gt;fetch(); } return $this-&gt;baz; } // This behavior depends on what exactly you want to do. return $this-&gt;$name; } } Our calling code doesn't have to change *at all* (which is the advantage of encapsulation), but we save ourselves a bunch of work if we never need to make a change like that - how many times do you actually write different code in your getters and setters? In the case of assignments, it also keeps your calling code cleaner by having assignments look like assignments (contrast `$foo-&gt;baz = 'twiddle';` with `$foo-&gt;setBaz('twiddle');`), which is more important than you think when skimming large sections of code. BTW, most languages that have this ability allow you to only overload getting and setting on a variable at a time, rather than having to conditional through it like above; that's merely an artifact of PHP.
&gt; I often hear the argument that doing things like that will give more flexibility in the future. But the truth is if you are writing code to extend a class, then it's fairly trivial to change the class you are extending to expose the methods you need. Not always. Think, for instance, of a class installed system-wide through PEAR, on a system where you don't have root access. This also applies to libraries that you expect the user (if you're distributing your code) to have installed through other means - if you want to change it, you have to start bundling it in your codebase, and that can get into some really weird versioning issues. Just because you can read files doesn't mean you can write them.
Highfives for us! :D!
No php accomplishments, started freelancing but I keep getting hired as a systems or network consultant vs developer... Oh well.
Got a job writing opensource php code, learned the wonderful world of unit testing everything
I agree that it's generally a bad sign if you have to modify the base class. That was my point in responding to your saying "it's fairly trivial to change the class you are extending to expose the methods you need."
Yeah I don't think I am making myself very clear here. When you make a class explicitly to be a base class and have multiple subclasses extending that class making an access change could potentially cause issues and requires some serious thought. However if you are only increasing access you probably aren't going to have too many issues but it's not a trivial change. It was my impression that the OP was just wanting to make everything protected or public in case they need to subclass something later on. To which I was saying make things private until you need them to be protected or public. Since those classes weren't specifically made to be base classes they probably don't have any subclasses and so can be changed easily.
Can you mention another framework that you think does better on those aspects ? 
symfony2, silex, zend2
got my first job as programmer, learned sooo much in those 9 months!
I got a job as the front end developer on a very successful new company's development team. I started the project from a fresh deployment of Symfony 2, and holy shit has it come far. 2013 should see it migrating to something more tailored, perhaps Silex with just the specific required Symfony components and other dependencies, utilizing ember and jquery for the client interactions. And of course the in-house js libraries I've developed. It's been a hoot. Kind of distanced myself from php in learning other languages at the same time, but it's still my bread and butter so to speak. Looking forward to learning as much, if not more (if it's possible, it's been a crazy year) in the next while. I have to say... I was expecting to come to hate php as I learned more. But I like it. I get a hell of a lot done with it and it's just fun.
20cm! Shit. Good work. I was stoked about my 5. I might have a use for LaterJob. I'm just getting into queuing... It would be nice to avoid writing a solution from the get go.
Had my app featured in Inc Magazine and .Net Magazine. Had meetings in Vancouver and San Fransisco, drove there with my family and showed my children the true Ocean for the first time. Gave away a few dozen copies of it with hosting to people who needed help. Nealy moved to Belgium. More importantly though, this year I was able to hire 4 other people full time, giving them the ability to provide for their families after being laid off. That feels the best, they have kids too and knowing that the app we built allows them to do the things that kids love to do makes me happiest. Been a crazy year actually... now that I think about it. Happy New year all! 
Thx for kind words. There are plenty of database queue examples but none try to provide metrics. I'm working it into a few side projects, not version 1.0 yet but there are plenty of unit-tests. 
Thank you for the reply, and very well constructed/informative too :) I am beginning to see that so many things I had drummed into me at uni are turning on there head in the real world, kind of like the step from GCSE to A Level chemistry where suddenly your model of the atom changes :P. 
Probably not much, but since I'm still learning how to use PHP, I can finally read from and write to MySQL databases with PHP. I created a comments form doing that. c:
Got a 9-5 in May. Came in on day one to discover spaghetti code PHP on one site and two sites running Ruby on Rails with no one on the dev team able to edit them. Side job offered by previous employer at 80 per hour. Only 10 to 15 hours per month but made an extra 2500 in December alone due to holidays being busy. Spend next two months converting spaghetti code PHP to MVC. Two months after that spent adding features. Hired a second dev after that and had him convert one of the RoR sites to same MVC PHP system. Boss loves me for saving her both money and hassle. Got an awesome bonus for holidays. Entire department is getting it's own wing of the office due mainly towards my contribution to the company. Looking to be an awesome year at work. In personal life gained 20 pounds after starting to work out. (I used to be too skinny). Good year in general.
Got my first Developer job, don't start for a few more days though.
Cool! How did you get into this stuff? Always interesting to know how and why people get into internals.
* Moved into advertising as I wanted more diverse projects. * Got to finally get up to speed on SF2 and silex on some production projects and consequently realised I never want to use Doctrine again. * Continued to improve my front-end and had the opportunity to build the Angry Birds Star Wars website http://angrybirds.tumblr.com * Began blogging lot of stuff http://www.deanclatworthy.com * automated my virtual machine generation scripts. Every project has a unique virtual machine with all dependencies pulled in automatically meaning devs have an identical setup to each other. Ill be posting a long write up on this soon...
* Got my first programming job (PHP), moving outside my hometown for the first time * Learned MVC and most of the major frameworks from work (cake, symfony, zend) and a few on my own (silex, slim) * Started using version control - git/mercurial, new IDE (sublime), SSH and server stuff (basics, monit, munin, etc.) * Improved my overall coding by a ton, though still have a ways to go. OOP is making sense. Never had a programming job or learned so much in a short amount of time, 9 months. Also learned jQuery/javascript and a bunch of css - hoping to learn a lot more on OOP and javascript. My CMS actually feels modern - working on them for 10-11 years, first time I can say that. A good feeling. :)
Worked for loads of different companies that went bust fixing other people's code for €2.5/hour and currently have a good $4K to my name that I'll never see. TL;DR; fuck coding in a bad economy 
Scale when you need to, not prematurely. Rails provides a massive amount of advantages in development to make up for any speed disadvantages, and if you refuse to weigh them up "because I won't be able to scale to Twitter's size" then you're needlessly optimizing and may be losing productivity in your choices instead.
At first I started reading php-dev mailing list. Then I had read some of yours and ircmaxell's blog posts about zvals, arrays, functions and so on. So, thanks to you and Anthony :)
Your site doesn't load
I really wanted to get into php internals not only to be apart of a big project but to get better at C, unfortunately non of this happened :( Maybe in 2013 
Speak for yourself, here in portugal everything is going down the toilet. Successful would be getting paid 5€/hour before tax even if the economy was ok.
well, i'm not speaking for myself - the majority of developers I know (us-based, but some in other countries) are having success. I'm sorry it's not great for you there, but the same "speak for yourself" applies just as much to "fuck coding in a bad economy". Essentially, when a national economy seems as bad as Greece or Spain (for examples), there's not enough of any business market at all for developers to service and provide value to (because those businesses can't create or extract value themselves). In those cases, yes, "coding in a bad economy" must suck, but *living* in the bad economy - trying to do anything - probably isn't all that hot. It's not like switching careers will help all that much. Again, sorry you're going through that. 
Proud to say I finally learned to code (at age 26). Have a working site, but hoping to clean it up and make it better over the next month.
Got employed as a Junior Developer. My first job that has something to do with programming. Feels good man.
It's a _recursive acronym_. It stands for exactly what it says. Always. No matter how many times you expand it.
Está em cima da mesa... mas nem sei por onde começar.
which is why i hate it "hey what does PHP stands for? oh a PHP: Hypertext preprocessor! ok what does the other PHP stand for? also for PHP: Hypertext pre-processor... PHP: Hypertext pre-processor PHP: Hypertext pre-processor PHP: Hypertext pre-processor PHP: Hypertext pre-processor PHP: Hypertext pre-processor PHP: Hypertext pre-processor PHP: Hypertext pre-processor PHP: Hypertext pre-processor PHP: Hypertext pre-processor " fuck that
:) I'm also trying to send e-mails as well as logging any e-mails sent. I think I can do it...
Oh lord yes. Any posting with things of that nature I just out and out ignore. "Are you a web guru?" Nope, keep looking pal.
That sounds like me. I cut my teeth with Perl towards the end of the 90s and jumped over to PHP between 3/4 and at the time 3 was more easily available. Now about a decade later I just took a Perl job starting next week where portions might be ported over to PHP.
PHP is a language, and Rails is a framework. My advice would be to go for a nice PHP framework. Something like [Laravel](http://laravel.com)
If you want to check out making http-requsts and working with an Ali, you should take a look at landfill. They have a great api for sending mails. For sending mass-mails like newsletters you should check out mailchimp :)
&gt; You are correct in theory but in practice it would be a pretty bad idea to extend classes from a completely separate package. Mainly because you don't control those classes and they can change in implementation. It happens all the time, though. For instance, tons of things extend `PEAR/Exception.php`, and much desktop GUI programming seems to work by extending base classes and adding functionality. It depends on the type of system you're dealing with; some are designed to be used this way, so there actually *is* a contract regarding parameters - since that is the API you use to interact with the library. If you're not working on a library like this, though, by all means, keep things private.
Maybe don't look for a PHP professional. Just find a good programmer. Language shouldn't really matter and PHP is easy enough to pick up for anyone who has the talent already.
Moving to NYC was my biggest achievement too. This place might be expensive, but there is enough happening to make it all worthwhile.
I think you're predictions are right. Basically, PHP is becoming more professional, with better tools and processes. I hope people move towards PHP 5.4 as I love array literals/really dislike not having them.
Haters are gonna hate.
&gt;A lot of people who don't know much about hosting moving from shared hosting, to services such as appfog or engineyard I find it very unlikely that non-technical people would come up with that idea.
This question might be super obvious, but how would I use APIs? I'm still new to using PHP...
Everyone will say how much PHP sucks and we should all switch to RoR / Python / Perl / Java / ASP RIGHT NOW if we want to keep our jobs. We will keep on doing great stuff in PHP.
This post has two downvotes... for the enthusiasm displayed? What is with you, /r/php?
Hopefully it will catch up with the testability of Ruby. Sure, it has PHPUnit... but that's mostly just unit testing. When I tried it in a course, Rails' natural language BDD testing blew me away. The big three web scripting languages (PHP, Ruby, Python) all have a lot of cool stuff they could learn from eachother, IMO. E.g, recently PHP picked up generators, which I know python has been making good use of for a long time. So hopefully this sort of stuff continues. My biggest wish for PHP will always be a compat-breaking 6.0 with a re-organised function library (or even things organised into object methods!) with some internally consistent naming, but I'm not holding my breath.
You can build good and bad web apps in all sorts of languages. PHP has shown it can run some of the biggest (wikipedia, facebook) and it's by no means unable to have a complex control flow.
You must be new here. Anyone who appreciates PHP is downvoted out the wazoo. You're supposed to *suffer* while using PHP.
Care to provide an example? I don't see why adding OOP components to a web language is a bad thing. Considering the immense amount of web services running PHP. It would be inherently more difficult to make anything with any real substance without these "Java" features. The amount of time I've saved with polymorphism alone is well worth the trouble. Besides, as much as I love ASP and everything, it is not my go-to language for making something quick. PHP has the best of both worlds - albeit you have to make some sacrifices, but I think it's worth that effort. 
&gt;My biggest wish for PHP will always be a compat-breaking 6.0 with a re-organised function library (or even things organised into object methods!) with some internally consistent naming, but I'm not holding my breath. Yeah, that won't be happening, unfortunately. The guys in PHP-Internals has made that much clear. 
I hope Yii Framework 2.0 based on Php 5.3 (at least) will be avaliable 
I think people on the internet are so used to being told off for using "your" incorrectly that the mistakes will swing the other way.
Plenty of them still want it to happen.
Non-techs will no move to PaaS unless their developer sets it up for them. Deploying code using Git from a Windows machine? I struggle to set that up, and I'd consider myself fairly tech savvy.
Adding namespaces was bad? Standardizing the namespaces was a bad move? Distributing the applications through a central repository like every single other programming language has. Was that bad? Or was it the unit-testing to make the code stable you disagree with? Maybe using dependency injection to increase the accuracy of the unit-tests was the issue? Dunno, I don't see what is so bad about the PHP renaissance. 
I dunno that namespaces are the best example of PHP's strengths considering how much flack they've gotten over the implementation.
What's your point? I haven't said anything about either. :S Responding to the wrong comment, perchance?
But the core developers don't. The topic has come up so many times on PHP-Internals, and it has been shot down every single time. I don't see it happening in the foreseeable future. 
&gt;Non-techs will no move to PaaS unless their developer sets it up for them. Exactly my point. If they don't know a lot about hosting then they sure as hell won't be moving their stuff to the cloud, let alone know about the option. &gt;Deploying code using Git from a Windows machine? I struggle to set that up, and I'd consider myself fairly tech savvy. I fail to see the relevance from the topic at hand.
They're a thing? 
&gt;and these hosting platforms I mentioned are simple enough to allow you to simply push to deploy your changes. Yes, but people who aren't developers wouldn't use, know how to use, or even know of such services. Developers who are prone to use such services already know about and how to use regular web hosting.
We'll have to agree to disagree on this point then. Let's see at the end of the year ;-)
Oh yeah - http://www.cbsnews.com/8301-204_162-57535252/why-flamin-hot-cheetos-are-sending-kids-to-er/
Sounds amazing.
Fabien Potencier wrote a blog post about [why Symfony2 uses private methods rather than protected](http://fabien.potencier.org/article/47/pragmatism-over-theory-protected-vs-private). His main 2 poinst are 1. Having a few well defined extension points force the developer to extend your library the right way instead of hacking your code. 2. Closing the API allows design flaws to be found more easily and gives you the opportunity to evolve your code by creating well defined extension points.
php.net will begin allowing upvoting user comments .. wait, they already are.
Demo link doesn't seem to be working...
I use Cucumber for testing PHP applications. Works absolutely fine, even if it is a Ruby tool. Of course if you want a PHP solution, there is Behat.
I wish the PHP frameworks would embrace the PHP development server. I find it a lot more convenient to be able to run the dev server when I want, like you can with the various Python frameworks, rather than having to set up a full LAMP stack. I'm in the process of moving from CodeIgniter to Laravel as my main PHP framework, and while Laravel doesn't support that out of the box, it was easy to throw together an Artisan task to run the dev server.
Because of PHP's traditionally low bar to entry, there are still a great many stagnant PHP users out there clinging dearly to their 90s era SSIesque programming paradigms. Copy-pasting guestbook examples and mysql_fetch tutorial code into their projects has worked for them thus far, so the resulting metathesiophobia in the face of any sort of language evolution should be no big surprise. 
Well, I guess we've been doing it wrong the entire time!
PHP 5.3 will [become deployed on the majority of servers](http://w3techs.com/technologies/details/pl-php/5/all), thus allowing to actually utilize its new features in distributable FLOSS projects. And no, &amp;lt;50% ain't enough for a reasonable dependency.
From 5.3 to 5.4 is not a pain. But you might see a lot of STRICT error. Fix your errors and you are good to go
Here is some stuff that I can think of off the top of my head. **Version Control** (git is preferred generally, but svn is still pretty popular) **PHP Frameworks** (CodeIgniter is pretty easy to learn) **Linux shell** (install apache, tail logs, stuff like that) **Javascript + ajax** ( a lot of places will prefer you know how to code JS as well)
They are welcome to continue programming like it's the 90's.
I was referring to core developers I have spoken to. There have been a few non-ideal propositions but two things are true here: Eventually a version of PHP will be released that is not starting with a 5. When it happens there will be breaking changes. There need to be multiple improvements to the parser beyond just primitive types, but they'd be lovely too.
Same again. I moved from a town with 15,000 which has a claim-to-fame of having a mill in 1800. http://en.wikipedia.org/wiki/Keynsham Now I live in Williamsburg and work two blocks down the road from Etsy. Not bad :D
Well, that would be nice, but many issues i wind up with are very obscure and conflicts that arent even logged/reported. I once lost support for AddType, and case sensitivity broke, took some head scratching.
Nobody is saying this? Where in the world did you come up with that idea?
I was talking with this guy as he was programming once. Oh, what language are you doing that web app in? "Rails, how about you?" I told him I'm using Laravel. "Oh wow, you're using PHP, that's so bad lol". I gave him a look and then asked, "Ummm, okay what's so wrong with PHP that I shouldn't be using it?" No response to that.
Having no relevant commercial experience isn't a big barrier to getting an entry-level position :) the most important things are demonstrating that you show good promise and have enthusiasm to learn more. Make sure your own projects are secure and functional. Provide code examples with your CV. Provide links to working demos, or make the code available for them to setup themselves to have a look at what you've built. Your previous projects are your portfolio, show them off. If you've attended any PHP conferences or seminars, point these out. If I see an applicant has attended something like PHPNW or PHPBenelux then they stand out above other applicants. You absolutely need to know about things like SQL injection and XSS and how to prevent them - not knowing these are dealbreakers for hiring a dev from my perspective. If the people looking over your code find places where you've let these issues through, you will not be hired. And to be honest, if you can't identify and prevent things like SQL injection, then you aren't ready to be exposed to a commercial position! Knowing OO PHP is a big plus point, and exposure to a major framework like Zend is another big plus. version control of some kind is a nice-to-have but not necessary for entry level stuff, but it'd be another big plus point if you know at least some basic Git or SVN. &gt; I developed a few scripts which use MySQL databases and whatnot. I may be misreading this, but that sounds like you're saying you haven't done a great deal with manipulating databases within PHP? Improve that - reading/writing from a database is a solid part of a dev's workload and you need to have at least basic sql skills in most projects. You'll also want to have at least a passing knowledge of javascript as you'll likely need to tie in front-end functionality as well as back-end. Your HTML should be solid as well. TL;DR Show enthusiasm for learning more PHP. Know how to write secure PHP. Also know SQL, Javascript, HTML.
Needs more cowbell
But then your environment for running the app isn't even close to production as the web server will be different. It's not much work setting up a VM with vagrant/(chef|puppet) to have a LAMP stack and on a decent machine it'll spin up in under a couple of minutes and just leave it running until you're done.
At my first php/developer job, I had to learn git, CodeIgnitor, and get better at JS+ajax. I second this post!
seems so.
That's not an issue with any of the Python or Ruby frameworks that include their own dev server, so why should it be an issue with PHP? I haven't used things like phpbrew before, but they seem like a good way of having multiple copies of PHP installed and sandboxed from each other, much RVM in Ruby and virtualenv in Python. IMHO setting up VMs for stuff like that is overkill.
My current position required all four of these. Only thing I may add is ORM if you're planning on working with databases in PHP.
Absolutely right. There's an [article](http://antecedent.github.com/patchwork/docs/implementation.html) on the site explaining that, but you've already nailed it.
If you are looking for specific things to do to make your chances better, I'd find an open-source project in a field you like and see if you can contribute a patch or small improvement. Code samples are cool, but real-world code samples are way better. Also, this shows me you can work in a collaborative environment. As someone who hires from time to time, I'm less concerned with how much PHP you know and a lot more concerned that you understand the basics of coding and can think on your feet. 
Rather than ORM, learn about db normalization and the lower level DB issues. Not all places will let you roll out an ORM.
People will learn about DCI (Data Context Interaction), implement it all wrong and butcher it just like MVC.
It really depends on the company. Here's my general list for an entry level person. I wouldn't expect you to be an expert on all these things, but to me this is all basic web-developer stuff. This is actually my 'web developer' list which usually is a superset of 'PHP developer' - there are certainly large companies where you can get away with knowing 0 about front-end development. # HTML &amp; CSS * CSS 3, What browsers support what selectors at what version. Its unlikely anyone ever memorizes all of this, but devleopers should have an inkling, and know where to look it up. * CSS Based layouts, rather then table layouts. I still still student projects that use tables for layout. * Have experience taking a professional design (PSD) and building it ( HTML + CSS ) # Security * SQL injection. Be aware that using something like php's addslashes() is unsafe, and that even built in database functions like mysql_real_escape_string() are unsafe in certain circumstances. Developers should understand prepared statements and how to use them. * Should have an understanding of XSS / CSRF * Should understand session hijacking and how to defend against it # Usability and Testing * Be aware that not all browsers are standards compliant and that the same browser under different operating systems may behave differently. Be able to troubleshoot front end issues on a variety of platforms and browsers * Basic familiarity with UX issues: Fitt's Law, Human Readable Error Messages, Latency Reduction. The stuff that programmers deal with, not design issues. # General Coding * Developers should be taught how to write readable code. I see a lot of graduates with 500+ line methods, or variable names that don't mean much. Naming is hard, it should be taught. * DRY programming practices * Why globals are almost always the wrong decision * What MVC is, and how it applies to web development # Javascript * Understand the prototypical object system that javascript uses, be able to write Object Oriented javascript * Be able to use with high familiarity at least one of the major libraries: jQuery, mootools, prototype. Developers are more likely to run into jQuery then anything else * Be able to write DOM manipulations in javascript without the help of a library if pressed and having documentation. We almost never do it in practice, but one should know what goes on under the hood. * Understand variable scope in JS, including ugly little corners like variable hoisting * How AJAX works * All about lose typing, and the inherent insanity in JS * Functional Programming (ie. functions are objects in JS) # SQL * How to write queries without a framework: SELECT, UPDATE, INSERT, DELETE * Understand joins, and how the different types work * Understand self-joins * SQL Injection (Yes, listed twice) * Stored Proceedures * Triggers * Understand Foreign Keys, and CASCADE * Understand and show use of proper indexes. * Difference between persistant and non-persistant connections # PHP * Object Oriented Programming principals, including inherentence, interfaces, abstract classes * Able to develop projects with at least one major framework: Code Igniter, Zend, Laravel, Fuel, Cake * How to handle user input * How to handle database connections in PHP (ideally with PDO, failing that with mysqli_*) * How to create persistant vs non-persistant connections * How to use a debugger vs. how to debug code with echo statements # Server This stuff is more 'advanced' - I wouldn't pass over a candidate who didn't know these things, but it seems the ones who actually learn all the other important things learn this too * basic ability to do things on a unix based system via the command line * how to set up a vhost under apache * understand how IP addresses work with domain names * know how to check access and error logs to troubleshoot problems # Overall * Should be able to build a basic CRUD webapp from scratch from start to finish. 
&gt; PHP has shown it can run some of the biggest (wikipedia, facebook) What I'm trying to get at is that you could write Wikipedia in BrainFuck if you wanted. You could write it in Java if you wanted. It doesn't matter what language you use, it matters how it uses *you*. I'm not a PHP hater by any means. Actually, it's my (shameful) goto for most projects. But you can see development times decrease drastically, among other benefits, in competing languages.
You're looking for [runkit](http://uk1.php.net/manual/en/book.runkit.php), specifically [runkit_function_redefine](http://uk1.php.net/manual/en/function.runkit-function-redefine.php)
My first official development position (my current position) had me learn CVS, SVN and Fusebox. I hate all three of them.
I'm 3 hours south of Chicago, between some corn fields.
oh i know about runkit.. i should have clarified that the app is intended to be available to folks who might be on shared hosting and other limited installs where runkit is unlikely to be available.
http://nerdery.com/jobs/positions/7 It's not that bad, or that great, but they hire remote. 
You really dont need to cache anything. You can just add the watermark when the photo is uploaded, and then save that version to display.
[bitbucket](http://bitbucket.org/) has free private git repositories.
Open an account on github and add some projects. They don't have to be using particular frameworks or anything, just write some nice PHP code that solves a problem you have or a small text game, etc. The point is to show: a) you have learnt how to use git and github b) you are interested in programming beyond the day job, and enjoy learning new things. Also, make sure you have at least a basic website that looks professional and contains some info about yourself, a link to your github/projects, and also your cv. If you can, consider blogging too; it doesn't have to be frequent though - quality is better than quantity. Again, the point here is to show you read around and enjoy learning new things, and also that you can communicate ideas well.
you don't have to publish your code online to use git.
At my first position I used SVN. I was a lot happier once I started my second (current) position and could use whatever I wanted - I went for Git and I am so much happier with it.
Can you use git-svn? That would give you some of the advantages of Git when working with Subversion.
Please note that his argument seems to be focused on how walling off code benefits Symfony contributors. There is no mention of why (or even if) it is good for general users of the framework. There is just an implied assumption that if someone resorts to hacking the code, it must be because of their own bad coding habits and not because of a flaw in the framework. I don't use Symfony2, but I take it that if a user discovers a bug in the framework, they must either monkey patch, or remain completely at the mercy of contributors to fix the issue. A contributor might not share a user's urgency about how badly any particular bug needs to be fixed.
I was unaware of it. I'll look into it. Thank you for the heads up.
I just got employed last year working mostly on PHP based projects so I hope the future is bright.
Are you me? :-)
Check out the Symfony [Security Component](http://symfony.com/doc/current/components/security/index.html). It's stand-alone and can be installed with [Composer](http://getcomposer.org).
&gt;I have looked at CI, Yii, Cake and other frameworks. The main thing I don't like is how the URLs are formed. I would prefer to not have to follow a set URL pattern. I'm fairly certain that neither of aforementioned frameworks have a set URL pattern that you have to follow.
1. Work remotely. Tons of companies are hiring good developers to work from home in their underpants. I know I'm doing just that. 2. I became a developer so I wouldn't have to interact with other people! 3. Sounds like you're only applying to/working for web agencies. Try working for an actual company that has a flagship product - they care more about your input than some shitty web agency whose only concern is speed will.
From what I've seen the default is http://domain.ext/controller/action
With cake, that is the default but you're free to specify your own routes/urls - http://book.cakephp.org/2.0/en/development/routing.html
Thanks, I'll look into that more. From my first read it looked like you still had to follow rules whereas I just want to be able to assign arbitrary page names and pass arguments by get or post and not by URL structure. I also don't want to have to change the .htaccess file every time I add a page which I thought would be required for doing what I want but I'll dig into that more.
I don't mind doing the integration. I just figured *someone* must have written some login code that handles this already. The WordPress option is on the table but I'd really only be using a small fraction of it for my purposes.
At my first real development job, they didn't use any version control at all. When I finally got my way, and we all agreed it was needed, the boss insisted we use Visual SourceSafe, because 'its Microsoft'. God what a heap of junk - it would actually LOSE changes occasionally for no apparent reason. Thankfully its Git all the way these days :-) 
I would still recommend WordPress personally, we use it extensively where we work, even if a customer has a static HTML site we tend to put it into wordpress just because it gives so much flexibility. Other than that it just depends, each framework is different but if you offload your login onto a service like facebook you have to register the user to your own database anyway and save their appropriate facebook account data so you can remember who they are. While this can sometimes be convenient for the user, not everyone has a facebook account (oddly they exist...) so its usually not a good idea to only have that option, so you'll probably want to integrate some sort of a personalized login system anyway. I would still go either WordPress or a straight custom solution like I outlined in my Edit above.
Kudos on the accomplishments, but having a dev rewrite a RoR site because someone couldn't understand Ruby seems like a possibly unwise use of time. Why didn't he just continue development if he understood RoR that well?
Great list. I would add version control in there under General as it is becoming the standard for most serious dev teams.
Clever.
The social media sign in would be an *option* on top of standard sign in. WordPress is the definitely an option and would work. I'm mostly just surprised at how hard it is to find basic user registration code and want to make sure I'm not missing something.
nope, you're not missing anything. Its probably because doing login systems, in essence, is very simple, if you just want a quick snippet just google for "php login example" and you'll find a ton of people who have about 5 to 6 step instructions with example code you can steal for doing a basic login.
Yeah, a basic login is simple. I trick is to integrate social media sign in and also to do salting/hashing, email activation, password recovery, etc.
No, no. You can use it with any database actually! It's storage-agnostic so it doesn't care where the data comes from, as long as it's valid data!
The main advantage is code architecture... the two things you mentions about 'safety' and 'documentation' do not really make any sense.
If you write shitty code you should make your variables private* OOP by design is meant to be flexible, unless you have a very specific class that does only one thing you might get away with all private access scope. You should allow (by default) your classes to be extended and variables to be used directly if you are building something. The notion of writing a class and making everything private does not accomplish anything, are you scared somebody will go and overwrite your method or extend it? Makes no sense. You should only set private access if it method/property is PRIVATE to the class and does not add any benefit to the extending classes.
To a good developer, a private means you should not extend it. I would not go and change methods somebody wrote in private scope when I need to extend it without asking questions/looking at the code. Unless you are paranoid of a boggy man extending your protected $name property, keep things that can be extended protected.
&gt; I went for Git and I am so much happier with it. Why?
Just because you don't get it, etc.
Cool, I live up in Inwood (right before the Bronx), and work on 26th st. God only knows what im near down here, so many businesses :P
I never said to make changes "without asking questions/looking at the code". How could anyone write code without looking at what they are working with and asking questions? A good developer is able to understand and change the code they are working with when needed, even if it's written by others. If you need a something that is marked private in the code you are working with then you would either write getters and setters for it or mark it protected. You really aren't risking much my *adding* access to a property. You should be paranoid about someone extending your code. There is no way you can predict what will happen to your code in the future. You don't know the capabilities of the next developer who will be working with it. It's way better leave everything as compartmentalized and secure as possible so that a developer who gets your code next will have to really understand what they are doing before they can fundamentally alter what your code does.
I dunno why, but I never really realized apartments like that in the movies really exist. Sounds scary.
He didn't. He only knew enough to see what the models were and what the code was doing but not enough to be able to maintain the project. The designer was fed up with HAML templates and the management got fed up maintaining someone on staff just for Ruby when the majority of the operation was in PHP/MySQL. It made strategic sense for everyone involved to align all the operations with PHP. It only took 4 weeks to convert the whole site when we quoted 2 months originally (I honestly wasn't sure how good this new person was gonna be).
the problem with my portfolio imo is that I have hardly built any full sites and those I have I usually think suck and delete them. I have built a lot of components, useful classes and functions, but when it comes to putting them together into something large scale I either - give up because it's taking too long, run out of ideas, or end up with a solid backend and a very barebones/dysfunctional frontend. I think in an actual job this wouldn't be such an issue, since it takes a team to put together a large project, and they have real designers to take care of making a good UI. Instead of "here's this app I wrote" I get to say "here's this session wrapper that I wrote" or "here's the fully functioning backend+api to a delicious-like bookmarking site, with no interface beyond a few forms and raw json". although I have been sending my first pull requests on github lately so hopefully those contributions, even if small, help for something. I have to be honest github is a little intimidating, it lacks a sense of community and I feel like if I'm not really careful about what I do, i'll just get scoffed at.
Sorry, you are right. I code in a few different languages, and "@access private" is the correct syntax to use for PHPDoc. "@private" works with other documentors such as JSDoc. I only declare variables (not methods) as private when they are simply storage for use by a getter and setter. I don't use magic getters and setters, so this is what it would look like: private $foo = null; public function setFoo($foo) { $this-&gt;foo = $foo; } public function getFoo() { return $this-&gt;foo; } Since both the getter and setter can be overridden, there is no risk in not exposing the storage variable.
There is a difference between criticizing and being a pompous ass.
I've used [Bonfire](http://cibonfire.com/) with success recently. Bootstrap + Gravatar + CI
I'd highly recommend diving into some JavaScript and jQuery then. Getting a good understanding down of JS syntax and how jQuery works with it is empowering and fun (in a masochistic sort of way). We throw the term "masturbatory coding" around the office a lot, mostly referring to jQuery. Then onto AJAX and you'll be able to accomplish a wide variety of tasks quickly while taking strain off the server. Also familiarize yourself with JSON format. 
This appears to be based on [stream_socket_server](http://php.net/manual/en/function.stream-socket-server.php) if you're looking to implement it manually, op.
i'm surprised he didn't pull up http://www.phpsadness.com/ that site has some valid points but they're mixed in with things that are of no consequence like "Declaring a function called __lambda_func() completely breaks create_function()" - is it any surprise that a programming language has some reserved function name/keyword? Even the PHP manual notes that [any function names beginning with 2 underscores should be considered reserved for future use](http://php.net/manual/en/language.oop5.magic.php). 
well you could just edit the actual source of symfony ...
&gt; Obviously PHP wasn't made for desktop GUIs. I've been downvoted before for suggesting that PHP-GTK is a terrible abomination that shouldn't exist. &gt; In a compiled language like something you might use for desktop programming extending libraries is fairly safe. A lot of GUI programming is done in scripting languages (e.g. Python) due to the development benefits and the execution speed usually not being terribly concerning. You're correct about the problems that causes, though.
Fixed that . Please let me know if you are having trouble again . Any response appreciated :)
Not really relevant to your question, but you did CST at BCIT?
have you looked at [hybridauth](http://hybridauth.sourceforge.net/)? 
It's for development. Obviously you should test on a real web daemon / environment when you're getting close to production.
AuraPHP is very similar to how SF2, ZF2 and L4 work. Components. Yum.
I recommend subscribing to /r/netsec if you haven't already. It's one of the best resources right now for information security. Also, check out https://isc.sans.edu/
How do you know me?
Yes, ran across that one too. It has MySpace login! lol It looks very comprehensive from the social login side but that's only part of what I'm looking to accomplish.
What's wrong with using CodeIgniter? Honest question, is it a bad framework?
It's a framework whose main focus appears to be legacy-style applications, apparent by its lack of movement toward newer PHP versions. One of the community developers for it even wrote up a nice article explaining why he's moving on: http://philsturgeon.co.uk/blog/2012/12/5-things-codeigniter-cannot-do-without-a-rewrite If you *require* supporting older versions of PHP, choose CI and go hog wild. If you have anything more modern than 5.3.0, choose something else.
Interesting. Thanks for the input. What would your personal recommendation be? Symfony I assume?
I've used Smarty but I didn't want to do too much. 
If we're talking strict, best-practice OOP here, getters/setters should never exist. But neither should public properties. Both of these violate encapsulation. You don't give outside code access to internal implementation details. Ever. If you have an Employee class and you want to give Bob a raise, you don't $bob-&gt;setSalary(75000), and neither do you $bob-&gt;salary = 75000. Instead, you $bob-&gt;giveRaise(...). Outside code (including child classes) don't need to know or care that Bob has a salary property. Note that there is a huge difference between knowledge that Bob has a salary (domain information) and that Bob, being an Employee instance, has a salary property. This difference is emphasized more with better, more complex examples, but hopefully you get the idea.
I wouldn't call S2 cookie cutter :)
Very interesting. I still have a lot to learn about Frameworks and PHP, heck just programming in general, but I appreciate your time. Will definitely look further into this.
You should not have used CI for a such as small task. That shows that you are a framework puppy and not a programmer.
I'm happy for you, but why are you posting this manure here? 
I agree with you on PSR. I think a lot of programmers are OCD about programming style, but to be honest, I tend to fluctuate from between certain styles depending on what I am writing. If I am editing someone else's code, then I usually try to stick to the same format they were using (unless it is just awful). If I have been writing a lot of JavaScript that day, you can usually tell in my PHP. If I'm writing something from scratch, I will try to stay as close to PSR as I can, but dammit, I don't like spaces between my function names and the opening paren. Oh and BTW, I love short-open tags in my templates. I generally don't use any fancy template engine, and short-opens are much easier to read, IMHO. (And I require PHP 5.3+ for all my apps).
Short open tags are unreliable. Their availability changes based on server configuration, and cannot be switched on from in a script. This means that you have to mandate a SAPI-specific (PHP_INI_PERDIR) configuration change if the short_open_tags ini is set to off. PHP 5.4 comes with shorthand *echo* enabled at all times. Shorthand open tags are a nuisance. Please, please do not use them.
But in the case where you ACTUALLY want to set the salary, not give a raise or any other predefined action.... then a setter is perfectly fine OOP. I don't agree with the blanket statement that properties and public variables are not compatible with OOP, that is rubbish. They have their place, it is all in how you use them.
At first glance, your styling is way off. Sets you off on a bad start. Not saying you have to following PSR-X, but at least be consistent with yourself. It's like you turned in an essay without spell-checking. Each of your methods is essentially repeated logic. You can factor a lot of it out into a helper function. The post methods seem pretty unnecessary. REST supports lots of other verbs (put, delete, etc). Seems kind of weird to just choose those specific calls to return 403s. What happens if you call a completely unanticipated method (ex: internships_get)? Does it get handled as a 403? You should have one catch-all error handler. And CI was probably the wrong tool for the job. A microframework probably would've been ideal. Try Silex.
Heh. Wouldn't work though; mysql_connect is not user-defined.
Why thank you.
Defines... for translations. Huh. I still wonder what that would look like; could you post an example? Anyway, [this](http://www.giorgiosironi.com/2010/09/monkey-patching-in-php.html) might be what you're looking for. As for preprocessing... If one were to use that to catch calls at the point where they are made, that is, inject code into call expressions themselves, which to my mind is the only way to redefine PHP functions without any non-core extensions, then not only that would be extremely complex to implement, but would also incur a serious performance hit. However, if just a single redefinition is needed per runtime and per function, then there's an easier way, which is replacing T_STRINGs containing the function's name with something else -- see my other reply to this comment. Some of Patchwork's code could be reused for that, but I'd also look at the tools [nikic](https://github.com/nikic) has implemented. 
I think their import stuff is related to their having implemented namespaces on their own, before php supported namespaces natively. It'll be interesting to see how it looks in Yii 2.
Faster, decentralized, easier branching
For a full roundup, http://thkoch2001.github.com/whygitisbetter/ is a good place to go. For me, the initial appeal was that it made version control much more useful because I could commit at any time without inflicting the changes on anyone else. Because in Subversion when you commit the changes get sent to the central SVN repository, you can't commit stuff unless it's completed. Which is fine for minor CSS tweaks, but if you're working on something big and complex, you cannot commit from when you start it to when you've finished and debugged it. With Git, you can commit at any point you like, because the changes are only shared once you push them up to the remote repository, and if that leaves the history a bit dodgy, you can go back and amend it. Also, easy branching, and stashing (which I think is worth switching for by itself).
most likely from the resume you posted :)
Yeah, Silex is a good microframework for an API. It is relatively simple compared to a full stack framework, but still leverages many of the newer PHP features, is fully OO, and encourages unit testing etc.
1/ Go to the Github repo 2/ Click the zip button 3/ ???? 4/ Profits
I always like to think of it as &gt; declaring a method private means you have considered every possible use-case of extending the method, and have ruled them all out. It indicates a lack of imagination! 
I'm a big fan of Yii, myself. But I find when asking this question you'll pretty much get suggestions of every PHP framework out there.
[This](https://gist.github.com/4443113) is how you could redefine an internal function using Patchwork's preprocessor. However, it only allows for once-per-runtime redefinition that can't be reversed at the same runtime. Also, I haven't added any checks for making sure that the T_STRING we're replacing isn't preceded by a -&gt; or a ::, but that can be easily fixed. Oh, and this code will also get confused by namespaces and miss variable function calls.
"I was told to make a REST API, so I grabbed a giant heavy library to do it for me. Then I was told I was a junior, because I didn't do the work. How do I make it less obvious?" Well, for one, I would have interpreted their question to mean "show us that you understand how REST works well enough to implement it yourself." Given how deadly simple REST is, the use of a library to solve the goal just does not make any sense. This was a fizzbuzz: see if the person even understands the goal, or just tries to mash his way through it with libraries.
Additionally, those methods that aren't supported should be returning a 405 Method Not Allowed, not a 403 Forbidden. This is what 405 was made for.
Wanting to arbitrarily modify an object's properties directly externally (as you're suggesting) is the very definition of broken encapsulation. Classes expose *interfaces*, not internal details like properties. If you feel the desire/need to directly modify a class property from outside that class, then you're moving away from OOP. It's never necessary to do so, and your design can always be reworked to maintain good encapsulation, no matter what the situation. You have to change your thinking in terms of what an object should *do*, and forget about what it *is*. The latter is what leads to trying to expose properties. Here's a great article about the TDA principle of OOP: http://pragprog.com/articles/tell-dont-ask
It cannot be stressed enough to learn a framework. Most places these days will require knowledge of OOP in PHP, and frameworks utilize OOP everywhere. And I will say for the more modern and current techniques, learn either Zend Framework 2 or Symphony 2. It also cannot be stressed enough to learn about PHPUnit. It's unit testing for PHP, and it's standard. You will find it in all the frameworks, as ones without testing tend to get ignored. A good resource to learn about, but not a necessity is Composer. This is a script, written in PHP, that downloads and installs scripts for php. Use it to get the goods.
Yeah, unless you're running Ubuntu 10.4 in which case it looks like this: Step 1: sudo pear channel-update pear.php.net sudo pear upgrade-all sudo pear config-set auto_discover 1 sudo pear install pear.phpunit.de/PHPUnit This results in a lovely error condition: ^(**Duplicate package** channel://pear.phpunit.de/File_Iterator-1.3.3 found) ^(**Duplicate package** channel://pear.phpunit.de/File_Iterator-1.3.2 found) ^(**install failed**) Step 2: sudo pear clear-cache sudo pear install phpunit/File_Iterator sudo pear install phpunit/Text_Template sudo pear channel-discover components.ez.no sudo pear install phpunit/phpcpd sudo pear install --force --alldeps pear.phpunit.de/PHPUnit This gets you a working version, so you might actually think you are out of the woods. No such luck. First few tests will yield a nice show stopping exception in File_Iterator. If you fix that one you will get an exception in PHP_Timer. Then in Text_Tempate and so on. The solution? Selectively downgrade set of packages. Step 3: sudo pear install --force phpunit/PHP_File_Iterator-1.3.2 sudo pear install --force phpunit/PHP_Timer-1.0.3 sudo pear install --force phpunit/Text_Template-1.1.2 sudo pear install --force phpunit/PHP_CodeCoverage-1.1.2 sudo pear install --force phpunit/PHP_TokenStream-1.1.2 Why not do this in in step 2? Because then you break some other dependencies, and this is by far the quickest way we found to fix it. How do I know this? Because I had to document this behavior so that new devs can properly set up their Vagrant instance. Why not use Composer? Because everybody should have the same buggy version from pear, herp derp, signed management. Why do we still use 10.4? Because it server version is supported until 2015 so we are not switching until at least next year.
You know what they say about assuming... 1. My current job helped pay for my relocation. 2. I got my job without actually knowing anyone (so, not networking was needed). I still had to communicate well during the interviews, but communication is important regardless. However, you can be an introvert and still communicate well. Communication is a skill, not a personality. 3. That's not entirely true. In some respects, you will be required to use the tools/frameworks already in use. There are very good reasons for this. After all, you are joining a team of people who have existing tools and ways of doing things. But that doesn't mean we can't use new tools as we need it. I direct my own development. The problem really is your assumptions. It's much easier to blame the fact that you are introverted and can't socialize and communicate effectively (as if you need to socialize well to know how to communicate well).
 wget -m --tries=5 "http://www.foo.com" Have fun.
&gt; I don't like how web design/development is becoming this thing where it's all about using frameworks and templates to do shit for you. Here is the reasoning behind this: Lets say your boss hired 5 total boobs and 1 guy with at least half a clue and you have to take that motley crew and make software with it. You can't write all the code yourself, and you are expected to delegate 90% of the work, and there is only a limited number of things you can dump on the guy who can actually handle complexity. What would you rather do: * Have the 5 baboons write EVERYTHING in house tools using spaghetti code and monkey poo * Have them use well documented, tested and standards compliant frameworks Option #2 seems pragmatic and reasonable. It is much harder to screw up when you are essentially writing glue code that binds frameworks together. And if they do screw up, it is easier to jump in and fix it, even if the dum-dums never write a single comment or document anything. Hell, even if you are working with 6 brilliant programmers, Option #2 might be the more cost-effective and pragmatic one. Why? The less code you write in house, the less you have to test against, and the less bugs in the software can be blamed on your team. Remember: every line of code you write is a potential bug waiting to happen. &gt; there are so many 'technologies'(redis, why not mongodb? why not cassandra? all of these do the same thing. KV datastore.) coming out just for the sake of making them. there is a new php framework coming out every week. new useless js/jquery plugins/extension/etc for stupid shit more often than i can keep track. All of these offer different sets of ~~bugs, shortcomings and security failures~~ features. You pick the one that sucks the less in your particular sphere of interest. I honestly don't need every new framework or package to be revolutionary or innovative. If it does the same old thing 10% better than the last one, and has a nicer API, it might be worth looking into. &gt; lately it is all about buzzwords like AGILE and SCRUM MAST3RZ and daily standups xtreme pr0gramming webscale!! like shut the fuk up already once and for all. Agile, XP and all that stuff is essentially a ploy to get programmers to communicate, and micro-manage themselves. These methodologies exist because your average pointy haired boss who failed upwards into management doesn't have the capacity to micromanage a team of programmers and making sure they're doing what they need to be doing. It is all mostly a gimmick, and when it works, it usually works because the team makes it work but none of these is a magic bullet that will increase productivity if your team is not on board, or if your team is as manageable as a herd of lolcats. &gt; there are also a bunch of hicks trying to innovate and make new programming languages, especially functional ones. clojure haskell etc. dart, go-lang, dog, rust, and so on. Dude: * Go and Dart were created, and are used internally by the biggest and most successful web company currently in existence. That alone makes them significant. * Clojure is a marriage between lisp and jvm. Programmers have been jerking-off to lisp beauty and elegance longer than most reddit users have been alive. Clojure takes that famed beauty and flexibility and makes it cross-compatible with the Java enterprise ironclads. I'd call it significant. Have you ever tried programming in lisp? Changes the way you think. * Have you tried actually coding something non-trivial in Haskell? It is different. It makes you think differently. It is an interesting change of perspective. I call that a good thing. How do you innovate if not by getting out of your comfort zone to get a new vantage point on old problems? Haskell gives you that. &gt; Why waste your time making your own when you can use one that is tried and tested and already works? Using this logic we would all still be programming in Fortran and Cobol. Not to mention it contradicts your point about lack of innovation in frameworks. This is how innovation works: someone sits down and makes a new thing. It either catches on, or doesn't. Maybe it moves us forward, maybe it moves us sideways. But you can't tell unless someone makes it.
Shorthand echo is really what I was talking about. In the cases where I need to use an if-then-endif, or a foreach in my templates, I will use the &lt;?php ?&gt; tags.
I don't agree with learning a framework. First learn what is a car, then learn how to drive.
Thanks. Currently reading PHP Objects, Patterns &amp; Practice but will check those out after. 
no no no. Properties are part of the interface, and are not always internal details. That is where you have it totally wrong. You are an OOP extremist. According to you, ever large library including everything that Microsoft has ever written is not "real OOP". Sorry, but you are incorrect.
PHP will continue to grow although at a slower pace and might lose some marketshare to RoR/Django.
Yeah, I would use htaccess and a satisfy any: AuthType Basic Require valid-user AuthName "Halt! Who goes there?" AuthUserFile /www/passwords/.passwd Allow from xxx.xxx.xxx.xxx Satisfy Any Edit Here's the page I found this on when I searched for "htaccess satisfy any" http://top-frog.com/2009/07/10/simple-but-handy-htaccess-tricks/
I second this. Train yourself to be a good programmer in the round - that means understanding OOP, functional programming, the importance of testing, version control, etc., etc. Good employers will be less interested in the exact tech stack you know, and more interested in whether they think you are bright and a good learner. Training you up in specific technologies is a relatively small investment for them put against your long-term productivity. For a junior role, I would personally try and avoid companies which only want to hire people with x years experience in framework A and y years experience in language B. The other problem with just specialising in a framework is that it can pigeon-hole you; you end up learning all this domain knowledge that doesn't transfer very well. Learning a framework is often useful, but make sure you are always doing other things too.
At the least, applying for stuff will give you a good idea of what you need to work on - just ask for feedback if you don't get the job.
&gt; One thing you missed was the use of short open tags. They should never, ever be used. Ever. Not ever. Unless you're intentionally trying to cause problems. They are *hilariously* hard on decompilers.
Really? You don't even have a bar() method.
The error message is telling the truth -- there is no such method defined in this example. Foo\Bar::bar() means "a method called 'bar' of a class named 'Bar' which is defined in the 'Foo' namespace", and as you can see, it really doesn't exist. If you have rewritten this example line by line, then you're doing nothing wrong; what's wrong here is the example. I might add that it's extremely contrived as well, and it also promotes a bad practice of doing things in the constructor that are unrelated to initializing the object.
Yeah, the code above is wrong in that class Bar does not contain the method foo. In this example, the Bar constructor is actually calling the function that will print "Hello World". Removing "$foo-&gt;bar();" would do the trick. Alternatively, adding a bar() method in class Bar and cut/paste the contents of the Bar constructor into the new method would work.
[laravel](http://www.laravel.com)
Wow. This book is off to a terrible start... 
Cool I think this will do the trick, nice and simple. Thanks! 
I like Kohana which is a fork of CodeIgniter.
I've heard several things about this, but let me ask a question... I'm a "designer" trying to become a developer. I've got a strong grip on PHP with my experience in wordpress and some drupal. Overall, I understand CMS, but now I'm looking to jump into a framework. So, having a general understanding of PHP with no experience dealing with any frameworks, would Laravel be a good starting point? Or should I play it safe with CI?
Of the PHP frameworks I've played with I do like FuelPHP. I tend to use my own framework that I've developed over the years when making my own sites, but I have found FuelPHP evolved along the same lines as my mind warped mine.
If its a fork of CI, what does it bring to the table vs CI? Thanks for your reply
If by extremist, you mean purist, then sure, I agree with your assessment. The fact that most people get it wrong is a matter of pragmatism vs. idealism. It's far more convenient to expose certain properties than it is to adhere to good encapsulation. That convenience comes at the cost of tight coupling, though, which is bad for maintainability and modularity. You're 100% wrong about properties being part of an interface, though. This is made obvious by the inability to enforce such properties within actual interfaces (the language constructs), among other things. Getters/setters can be part of an interface, but only technically. Not from a pure OOP perspective. Languages that give getter/setter syntactical sugar do so to satisfy the users - not because such practices are good design (a la goto and others). I'm not trying to convert you, though. Feel free to expose properties if you like. You'll find it much more convenient, but your code will be more brittle. It's a tradeoff.
YII
I have used many frameworks, and have not been 100% satisfied with any. One that looks promising and I would like to learn is [Yii](http://www.yiiframework.com/). 
specifically symfony2
I thought Kohana was originally a fork of CI, but then they completely rewrote it. Edit: Had "rewrite" where I meant fork.
Although I'd agree, the documentation can be lacking. There are things that have caught me out that I only knew how to resolve / get around / deal with because I'd come into the same problem with Codeigniter and someone had documented how to resolve it with codeigniter so I knew exactly what could cause the problem with Laravel. It's a fantastic framework (I use it exclusively now) but I'm not sure if it's best for someone without any framework experience, until the documentation is more mature...
Any book or tutorial that uses the terrible foo/bar example is garbage imo. Wtf does foo/bar mean? It has no real world comparison which makes it that much harder for novices to understand these examples.
hmvc. its amazing. here is an article from one of the one of kohana's devs explaining it. its the single reason i keep going back to kohana. the modularity it gives me i found is unmatched in any other php framework. [http://techportal.inviqa.com/2010/02/22/scaling-web-applications-with-hmvc/](http://techportal.inviqa.com/2010/02/22/scaling-web-applications-with-hmvc/)
Um, that's the completely wrong way to fix the problem. That's like your car having a flat tire, so you "fix the problem" by not driving your car anymore. The fix here is to rename Bar::__construct() to Bar::bar(). And yes, you should go ahead and burn whatever book you're reading.
CakePHP, solid, "adult", full featured advance framework under heavy development, every month faster and easier. Friendly community at freenode.net#cakephp. REST, ACL, Test Driven Development and plugins are a pieces of cake!! 
It was originally a fork of CI but by version 2.0 practically every single line in it had been rewritten. It is now on version 3.3.0 and is considered rewritten and no longer a fork.
You guys make good points about learning a specific framework. Perhaps I should rephrase and say that it is in good practice to learn how a framework works. With that in mind, look at several different ones. 
I second (third? fourth?) this. So far, i've found it VERY easy to use, especially if you are even remotely familiar with MVC frameworks and concepts in general. The documentation is very well put together, and works wonderfully on it's own, or with other elements. Highly recommend. 
Try Laravel. I hate PHP but Laravel makes me enjoy it, so it really is a great framework.
200 concurrent is peanuts. http://loadstorm.com/ There's plenty more. Just do a google search.
Give [Apache Bench](http://en.wikipedia.org/wiki/ApacheBench) a try. Chances are it's already on your system.
I recommend the Yii Framework: http://yiiframework.com/ It has some of the best documentation out there, is under heavy development, and is very easy to learn. Being able to use lazy loading everywhere in the application is great as well, you do not have to worry about including the right files in each script, it does that all for you when they are needed. It helps with performance and keeping your code clean (avoiding throwing includes everywhere). When I was researching frameworks a year or two ago I really liked how Yii felt more "hands off" the PHP code than the other frameworks, there is a fine line between having a framework help or hurt you. But it really comes down to your coding preference. Check out tutorials for the popular frameworks and see which one clicks with you.
There are websites that will show you a feature grid of all the frameworks, etc. But really it's best to take an hour or two and read some of the documentation and code samples from several of them and see which one feels right. Personally, when I did that and ended up choosing [Yii](http://www.yiiframework.com/). For me there was no question it was the way to go (although I also liked many aspects of Symphony as well, just not as much as Yii). I found the other frameworks to be confusing... they seemed to offer a lot of things I would never use, and just didn't fit my style. But Yii just immediately made sense, is really well organized, and it was quickly obvious to me how amazingly useful it would be for building a website.
Hmmm I dunno, this philsturgeon guy... not sure if you can trust him about CodeIgniter.
My suite of tools that I use to test this are: Web Performance Load Tester [http://www.webperformance.com/](http://www.webperformance.com/) Free and you are really only limited by your own CPU for the numbers of users. I can run about 600 users at once on my computer. With this software, you record the sample steps that a user might go through and then run a load test. The virtual users request the pages in the recording order. Xdebug with Trace A great guide here [http://derickrethans.nl/xdebug-and-tracing-memory-usage.html](http://derickrethans.nl/xdebug-and-tracing-memory-usage.html). This is helpful for figuring out what functions/classes are increasing your scripts memory. Cutting back on memory means you can run more scripts at a time. When you get a VPS install php with FastCGI. That should cut your page times in a third. This means that you are not starting a new php for each script. As for what VPS to use, Linode 1GB handles 400 users at a time for me. Which should be enough for your uses. Hope this helps.
Having worked on frameworks yourself, do you see Laravel sticking around long enough to warrant using it on a long-term project? My team and I have been kicking around the idea of moving away from CodeIgniter. I'm more of a .NET and Ruby person, and a lot of those developers recommended Symfony. I have also heard great things about Laravel, but from what I understand it is primarily the work of one guy who gets to develop it in his free time, which makes me wary for choosing it for an enterprise-level project.
I didn't know you could do an IP and htaccess password at the same time, pretty cool.
I've used [BlitzIO](http://blitz.io) and it works a charm, can do what you want mostly for free too.
Why?
Sarcasm
FFS, I wanna know what happened and if she's alive or not!
I'm a fan of Lithium
Noise. What's needed in a discussion like this is more signal.
As a best SQL practice using SELECT * isn't the best way to go. Your telling it to give you all of the fields from ALL of the tables... including the joined tables. So change the SELECT to something like this: SELECT ID, posterID, description, likes, timestamp FROM posts INNER JOIN followers ON posts.posterID = followers.followingID WHERE followers.followerID = $currentID 
Tutorials here: http://net.tutsplus.com/tutorials/php/building-web-applications-from-scratch-with-laravel/
Good for you? The fact that I choke up and suck at interviews is something I've been working on for a long time, but I'm not there yet. Communication for an introvert is physically draining and leads to panic attacks, it just takes me longer to warm up to people. There is this guy named Rob Sheridan, built a fan site for Nine Inch Nails in high school, Trent Reznor liked his work so much that he hired him at 19. Now he is their art director. Moral of the story: some people are just really fucking lucky.
Another solution is: SELECT posts.* FROM posts INNER JOIN followers ON posts.posterID = followers.followingID WHERE followers.followerID = $currentID 
Great reply, but I have some questions. If my 4gb ram and Amd Phenom II X4 955 B.E@3.6GHZ can handle 700 users on my personal computer, how can I calculate what it requires for 200 users? Should I check cpu benchmarks points and look for what is available at the %30 points of X4 955? What kind of script do you run on 1GB Linode? Like, what's the load of an average page output, how many queries, do you use opcode cache or Memcached? Also, what kind of CPU does that VPS has and how much of the CPU you can actually use? 
Hijacking thread for my own question... Is there a CMS that let's you build the front-end however you like but allows you to plop in modules (like ecommerce, or blog posts/listings) for areas that editable? And the admin panel the CMS provides manages whatever modules are being used on the site?
I'm not sure if it does or not based on the website, but it also says: &gt;It is strongly recommended to limit the use of Patchwork to testing and development environments only. There are several reasons for that: firstly, Patchwork was never intended for use in production, which means it could have some undiscovered security concerns; secondly, redefined functions can quickly make code unmaintainable; and lastly, it will very likely have a noticeable impact on any application's performance. That alone makes me not want to use that, unfortunately. 
*Any* web framework can do this. Heck, PHP alone can do this. It's simply a matter of constructing an API which can transport data in an appropriate data format (e.g. JSON).
Laravel.
~~He's the guy that wrote CodeIgniter~~ 
Welcome to the wonderful world of PHP! When you say "tools from everywhere", you may be referring to the fact that PHP does not ship with a native testing library, which is great, as it throws this responsibility to the userland. It's not so great in the fact that an overwhelmingly large majority of PHP userland does not 1. Know about testing, 2. Know why they should test, 3. Bother with testing For testing, minimum you should use is PHPUnit. A year ago this was a headache to get working correctly. Now? Just use composer: { "require-dev": { "phpunit/php-text-template": "1.1.3", "phpunit/phpunit-mock-objects": "1.2.1", "phpunit/php-timer": "1.0.4", "phpunit/php-token-stream": "1.1.5", "phpunit/php-file-iterator": "1.3.3", "phpunit/php-code-coverage": "1.2.6", "phpunit/phpunit": "3.7.8", "phpunit/phpunit-selenium": "1.2.10", "phpunit/dbunit": "1.2.1", "phpunit/phpunit-story": "1.0.1", "phpunit/php-invoker": "1.1.2", } } I personally do not use Mockery. I honestly think that PHPUnit's `getMockBuilder()` API is *all* you need for mocking correctly. I use Behat/Mink for behavorial/integration testing. I use PHPUnit for unit testing. Both are mature, stable and very powerful libraries. PHPUnit is the de-facto standard, and I believe Behat is as well. Any other questions?
People have answered your initial question, but to help you out, I suggest not getting a full on server if you are only going to have temporary burst. Use a service like https://www.appfog.com/ or https://pagodabox.com/ . Both of these will more than handle your base load and easily scale up and back down with your needs. Also, the detailed configuration of PHP and such is already done and will already be set up to be optimal.
Have a look at http://www.slimframework.com/
I absolutely agree CakePHP is great for rapid development of many apps. Very cool framework. I also find that it's not as flexible and there are many cases when the magic can get in the way a bit. Depends on the app.
Absolutely. But I think that goes for most frameworks? :)
Shouldn't have to go back to research sarcasm. Some of us are in a hurry, with looming deadlines, and skimming for relevant answers, which is what r/php should provide, and save humor for r/funny.
Come on, get real. You want OP should kiss his ring, or something?
Sorry I didn't realize humor was reserved for r/funny. Judging by your post history today, your deadlines aren't that serious. Or were you skimming for web dev answers in cognitive science and world news subs as well?
Enjoy. http://tsung.erlang-projects.org/ Unless your software is very poorly written, 200 users should not present a serious problem.
See, that's the thing: you assume just because I'm posting in off-hours, that the work-related posts I make aren't time-sensitive. That's a specious non-sequitur. When people post to a subreddit like /r/PHP, they are often reaching out to their extended network about a career-related question. You assume it's not urgent because I post about work in off-hours, but there's no basis for that assumption.
They asked you to write an API in CI? Jesus.
Love cakephp! I used codeigniter for two years and cake was an easy transition. Cakephp also is much more structured in terms of code and database structure. Overall my code looks cleaner and more consistent. They have won me over and the documentation is great. 
Apache bench is useless unless you know exactly what you are doing with it. 
I don't want to sound like a douche, but questions like this are silly. If you test for 200 users on an empty server that would not reflect real world scenarios. I assume you have a budget that does not allow you to have RAID storage so let me give you this scenario... you tested for 200 users on a perfectly fine server then all of a sudden you get 200 users while you are running local back-up... BOOM outage. Be prepared for those kind of things and don't save $20 on a hardware that just handles 200 users. Also be aware that as time goes on, your back-ups will get larger and your database/cache pool will get larger and slower as well. So once again, be smart about it. You should also use opcode cache and Memcached, those work together to solve different problems. As for your Linode question, I would think that is different for every cluster they have VPS provisioned on since resources are somewhat shared. 
I think you will have better luck finding such framework in Python, not PHP.
I think you are confusing the roles of a CMS and a framework. You can create whatever you want with a framework. Most of them only restrict you on how you go about implementing it to adhere to some standards etc. Frameworks don't come with admin panels, editable sections etc. However, there are lots of projects that strike the middle ground between a frameworks and a completely rigid cms(wordpress, magento etc). CMS based on Codeigniter: FuelCMS, ExpressionEngine, PyroCMS CMS based on Laravel: PongoCMS CMS based on Symphony: Symphony2CMF, AlphaLemon CMS based on Zend Framework 2: Libra, Kapichi
"You shouldn't be storing much information in the session anyway." Says the guy storing session information in cookies.
Hundreds of megs/day on Akamai will cost you $$. You will also be saturating both disk and network i/o. It's all relative.
I like liquid web for their support. I actively manage a few dozen large sites (and a few hundred smaller guys) all on liq. web's vps. i personally have a godaddy vps which im moving to liquid web. and like everyone else said, 200 concurrent users is easy to manage with even just a few gig of ram and a mediocre cpu.
a job. senior dev, but i dont flaunt the title... i just do the stuff that no one else knows how to do.. and everyone else does the stuff i dont want to do.
Phil Sturgeon was part of the Codeigniter Reactor team.
I would say Symfony2 is the gold standard for a modern PHP 5.3+ framework!
I would definitely recommend anyone using laravel to hit up their respective channel on freenode (irc) at #laravel. There is a great community of developers that know the framework and can help solve your problems and the creator of the framework, Taylor Otwell also hangs out there.
I manage a website much larger than what you have stated and run it on a Linode 1GB with no issues. www.linode.com if you wanna check it out
Not specifically in CI but in a framework. I was told about CI so I chose that one.
At this point I'm mortified I made some rookie mistakes. I just had a baby and was exhausted and it shows. I think I have the idea of what I did wrong. Thanks for the tip though. I did look into making an API from scratch, but they specifically said to choose a framework so a friend recommended CI. It was my first time working with it.
Every modern framework supports subrequests.
Lazy loading classes in the way Yii and CodeIgniter allow is a sign of bad design choices. Also, your argument about having to include files is no longer valid with the rapid adoption of PSR-0 in most frameworks.
The magic is being phased out slowly. 2.x has far less than 1.x and 3.x it should be mostly gone.
Phalcon.
Yeah. I have no idea why he's tagged with that.
There's a lot more to it then that. I'm not even a big autoloading, but Yii is just a great framework overall.
A massive thank you for this link. I do not follow the progress of Kohana anymore so I didn't see this, my entire opinion about Kohana being against PSR-0 comes from this whole angry thread - and shadowhands childish reaction to the situation on his twitter shortly afterwards: https://groups.google.com/d/msg/php-fig/Pe0yMKEvPAc/cIQJXWk8oFcJ Good to see they bounced back.
Ok then, advertise Yii on those merits. I'm just saying that at the moment, your argument for using Yii (in the comment above) is like saying "I really like this car, because it has a steering wheel.". :)
That is not true, I contributed to CodeIgntier for a year or two and was on the CodeIgniter Reactor team for a bit there. CodeIgniter was developed by Rick Ellis and the EllisLab development team. Please don't give me any undue credit.
Currently using FuelPHP and completely loving it.
An interesting throwback from history past!
Do you mean hundreds of gigs/day? I don't think any modern system will be saturated at those transfer amounts...
One thing: PHP sucks. Sincerely, Someone who uses it every day.
If you just had a baby, you get carte blanche on tired. Congratulations. In the meantime, my normal reaction to a framework being recommended is "are you sure you don't want to learn to do it yourself?"
You are missing the point.
I've been experimenting with a combination of symfony2 and zf2 (zend framework 2) and it is a great combination. You can use composer to pick the components you want from each.
I think we just have a difference of opinion here. All things equal, it's generally more desirable to pass fewer bytes over the network instead of more. The scale of this situation, however, falls below my personal threshold. At worst, this is a premature optimization. At best, it's something that I don't care to spend any mind share on. My original comment said, "Everyone's situation is different, but I have not worked in an environment in the past 15 years where "hundreds of megs/day" is significant in the least." You seem to be taking issue with my assessment of my personal situation.
Laravel, especially with 4 about to be released shortly. We're making the switch at our company from CI.
The number of "which is best framework +1" is just ridiculous. For fucks sake stop it. Please - stop with the framework posts. i want to follow PHP news, not be inundated with spam.
I don't really get why you're focusing just on that one point. He listed 5 different advantages to Yii and only one of them has anything to do with autoloading. I think you just misread what he wrote?
Thank you so much, as a PHP 4 vet I was looking for something thorough like this! Lots of stuff I need to start doing, and lots of stuff I need to stop doing! :)
Follow up question, does anyone know how secure htaccess auth is (compared to say, a very well developed login form with prepared statements/stored procedures)?
I can only speak for ZEND and CI, but the documentation and support with CI is far superior... They have a very friendly IRC channel, people there helped me a lot when I started using the framework... it's @ freenode #codeigniter
Or Ruby on Rails. I belive it has that functionality built in.
No worries, glad to help. I was also surprised to see it included after the very public lambasting, but seems like either shadowhand was overruled or changed his mind on it.
I got a promotion to lead developer, went to ZendCon and learned a whole ton of cool things, and finally finally finally got in the habit of writing unit tests for everything.
If you are looking for something new yet similar to CI you can try: http://phpixie.com It's more or less a lightweight rewrite of CI
I keep getting Laravel pushed at me, with FuelPHP apps still running out in the wild to support. I guess I am going to have to make that leap... Mind, with more frameworks being based on common components, switching frameworks is getting easier all the time, with less to learn. Or maybe that's just age and experience. Hope all is going well for you Stateside :-)
So as Ruby, Java, C#, Python, etc. etc. Every programming language has it's pros and cons. The language is just the tool, whether you use it correctly or not it depends on you...
That is a good read too
The OP mentioned CodeIgniter, I'm confused as to why autoloading is not a valid point? Also, every other framework has not supported this for years (a year maybe), only the ones with versions built specifically for PHP 5. Maybe I have not done my research in awhile, but when I started with Yii many frameworks were still supporting PHP 4.
What are the reasons it is considered a bad design choice?
About 8 years old. But then, there are people still trying to catch up with PHP5.
*Always* use an opcode cache. Memcache is something totally different.
Use WordPress. It has "themes" for the frontend and "plugins" for the backend/etc. There are plugins for ecommerce that perform well for most sites.
It's going great thanks :) I dont mean to sound patronising, but you don't need to write every application ever in the same framework - especially now you have components to inject new functionality into older frameworks.
I'll second Slim. Built an API recently and it's extremely simple and flexible.
Every actively developed framework that I know has been using PHP 5 (and therefor - except CodeIgniter - some form of autoloading). Yii has supported PHP 5.1.0 since it existed: https://en.wikipedia.org/wiki/Yii So... while mentioning that Yii does have Autoloading, it seems weird for you to base your entire recommendation based on that. I was suggesting you mention other things you like about it too! :)
The other points were "it has great documentation" which basically every popular framework has. "It's easy to learn" yeah I've learnt to use 5 without needing a book on the subject. "It's being actively developed" so are all of them. Those were non-points, so I focused on the functionality he listed, which is a common feature that pretty much every framework has. I didn't misread anything :)
I disagree with all frameworks having *great* documentation. When I was looking around the Yii one was leaps and bounds above the others. the "Definitive Guide to Yii" (http://www.yiiframework.com/doc/guide/) and "Blog Tutorial" (http://www.yiiframework.com/doc/blog/) are fantastic.
Unfortunately my recommendation comes from researching frameworks a couple years ago. Yii at the time was one of the only ones not backwards compatible with PHP 4. To add onto this the only other framework I've had to work with recently was Codeignitor. I wrongly assumed the other frameworks still did not support it!
&gt; Good for you? No, good for you. You're just ignoring the fact that you are wrong. &gt; I can only assume to find this type of work you need to meet the following criteria You don't. Rejoice. &gt; The fact that I choke up and suck at interviews is something I've been working on for a long time, but I'm not there yet. Verbal interviews aren't the only way to interview. Regardless, if it's that big an issue, then dedicate time to it, like you say you do. &gt; Despite my dedication to the language and qualifications, Communication skills are just as important. &gt; There is this guy named Rob Sheridan, built a fan site &gt; some people are just really fucking lucky. Or work really hard. Sorry, but that story isn't about luck. It's about effort. He built something, something of quality. You can chalk it up to luck, but that's just an excuse.
I hated the documentation for yii. a full book on the subject o read is to much to read for me :P yet laravel has a long high level doc I feel like I could fly through in an hour. At the point frameworks are easy enough to learn that I just want it under my belt asap
I'm sorry dood but you deserve the down votes. This isn't another one of those best framework posts you seem to hate a lot, which is more than understandable. I searched for those best framework posts and most of them were posted by noobs looking to get started, those threads wouldve barely made it to front page with 20 some odd up votes compared to this threads 30 some odd up votes. Also I didn't ask which framework is best, I asked if not using CI then what? Very similar to a which is best post but if you read my description I think you'll see I'm not trying to a get a which is best so much as which framework is modern enough and functional enough to expand on the strong programming base that I built with CI. This is a very valid and current question because a lot of people use CI, and it might be a good idea to switch, I am... to laravel. Now as far as your comment of don't post crap like this here cuz u want your news.... Jesus old timer did u wake up on the wrong side of the bed with your last beer poured out? Its a PHP discussion site, u want news why don't you try and make an r/phpnews? Thanks for stopping in dood but jeses, think about what you are posting
Asking for suggestions on a framework is like asking for suggestions on a programming language... so many opinions on so many aspects! The important thing is that you found one that works for you and will build a working product.
No, I don't know what his problem is. Show me a 720 page book on the most stable version of php and i'll show you the 650 pages that go over the same thing. 
Can you give me an example?
Thanks. Yeah I might redo without the framework to prove to myself I can do it.
Laravel needs some serious holes patched. If you like being hacker bait, tread on.
Thanks for the update. Just to clarify, it's not that I don't think the code itself is stable/worthy of enterprise-level projects, only that if your lifestyle changes (new kid/job/wife etc) and you don't have the time to devote anymore, does the project have enough people on it who can contribute down to the very core to keep it going or does it stagnate until you can find time again. Mine was more a question of momentum rather than quality. People with much better credentials than myself have already vouched for its quality. 
random example of things i dont like about this book (emphasis mine) p14 &gt; The **ﬁrst thing** you need to learn about PHP is how it is embedded in HTML: &lt;HTML&gt; &lt;HEAD&gt;Sample PHP Script&lt;/HEAD&gt; &lt;BODY&gt; The following prints "Hello, World": &lt;?php print "Hello, World"; ?&gt; &lt;/BODY&gt; &lt;/HTML&gt; p16 &gt; An **extremely useful** feature of PHP is that you can access variables by using &gt; indirect references, or to put it simply, you can create and access variables by &gt; name at runtime. &gt; Consider the following example: $name = "John"; $$name = "Registered user"; print $John; p117 &gt; Between the &lt;/form&gt; and &lt;/body&gt; tag we add the following: &lt;?php } else { ?&gt; E-mail: &lt;?php echo $_POST['email']; ?&gt;&lt;br /&gt; Name: &lt;?php echo $_POST['first_name']. ' '. $_POST['last_name']; ➥?&gt;&lt;br /&gt; Password: &lt;?php echo $_POST['password']; ?&gt;&lt;br /&gt; &lt;?php } ?&gt; &gt; This piece of code is executed if the form was ﬁlled out. As you can see, &gt; we simply echo all the form values by echoing the elements from the $_POST &gt; array. Dealing with user input data is not much harder than this, but.... There are certainly plenty of relevant things in this book, It covers not only php but general "how does that programming thing work? Whats a control structure? whats a variable?". In that respect its a wonderful book. But if someone read this whole book and started programming like it shows, they will be a decade behind the times. EDIT: formatting 
Hes not trying to be aggressive or argumentative, in fact secretly hes trying to help your argument by trying to force you to bring out a more factual and logical reasoning to your argument than "you like it" or "it feels good." For instance you say "built some great applications for clients very quickly with it." this could be worded with more factual representation to give a clearer and more concise answer for the OP to take quality information from the thread. We could say that as "It's really easy to extend Gii (the code generation tool in Yii) through the Gii code generation template system" One thing I would say though is that Yii is a much more matured framework, for instance with the DB migration tools, you can roll back / implement individual migrations. Whereas in Laravel 3 I believe you cannot specify an integer amount of rollbacks from the CLI?" Please don't take this as factual evidence I was just trying to explain Phil's point. I'm extremely new and only just made the jump from procedural to OOP and getting into bed with frameworks. Also, i'm not sure if Laravel can do a set amount of migration rollbacks? For instance, how I understand Laravels Migration system If i wanted four rollbacks I would do migrate:rollback 4 times? As I said i'm new, and do not have actual experience with Laravel, other than reading alot of documentation. Also, I think if you want to find the true value of a framework you need to find a fanatic / supporter and ask him what the framework could do better. As no framework is perfect, it might be perfect for your needs or for X project but the framework itself wont be perfect. And if we ever think it is, the user is probally too short sighted or blinded by love and to take their opinion with an even bigger pinch of salt.
Have any information on those holes?
I really hate Wordpress and any CMS that gives you a complete out-of-box website solution. I can spit out FE code faster then I can debug Wordpress spaghetti nonsense. I just want a system where I can drop in and then style things like shopping carts, newsletter sign-ups and blogs without forced to use a CMS's front-end framework.
I haven't done the scans myself. I know some folks that have -it's not pretty.
Then you should get those "other folks" to give you the data or find it yourself before making unsubstantiated claims. Just sayin'.
If you have 30k laying around, plunk down the money and do the tests. Unsubstantiated implies that I'm not working with security professionals. My people are maybe not top of the field (as in the ones developing the hacks) but they are professionals and they don't blow smoke about shit like this.
It's unsubstantiated because you assert things without evidence. You made the assertion that the framework has huge holes in it while appealing to an outside authority that none of us know. The fair and proper assumption is that smoke is being blown until otherwise shown. Have they reported these holes to the developer?
Possibly. You could do the same.
Awesome, thanks.
When all frameworks are so similar (as I'm finding out), things are unfortunately being left to opinion when we are looking for a general question such as "what frameworks you guys like to use and why?". I think the best thing to do for the OP is to look at all the suggested frameworks in the thread, and pick one that matches his coding style. As long as you pick a secure and stable framework you really can't go wrong. If you fall in love with a framework that is missing a feature, build it yourself!
Holes like this....just 4 months ago suggests Larvel is not ready for prime time: http://joncave.co.uk/category/security/
Something tells me that you dont mean REAL 5 connections at once. 200 connections at once. 200 Connections at once. Would mean there would be around 1000 - 10.000 users (depending on content) at once on your site. No, no I dont think you would start a tournament which would attract 10.000 players. Or even more. I guess with 5 Users at once it is some kind of counter on your site. ( I you start a tournament, lets say HoN, CS or whatever handing out 10K dollar, then I am sorry what I said, and I am wrong. But I dont think so. )
holy shit do I hate Yii. Did some contract work for a company that bought a product based in Yii and it was a nightmare to work with. Trying to track down where the code is that generated that page that you are looking at is a pain in the ass. Maybe you will have better luck, but I hated it. 
over the years, I've just developed my own framework that I like working with. I feel like the time spent learning someone else's framework can be better used in designing and building something yourself, and I feel like it makes me a better coder. 
the yii wiki has over 400 articles covering most topics of the framework http://www.yiiframework.com/wiki
There's a lot of literature, but PHP is a fast growing language. It moves at pace faster than that of most other languages that I know. More pages isn't necessarily a good thing since I find most PHP books that are filled with hundreds of pages normally all waste their time repeating the same boring nonsense over and over again and avoiding the meat of the problem. Like **solving real world problems** and *not* just making interesting, but completely useless, *hello world* scripts. We all know PHP is widely used. We all know it has a lot of history. We all know it's not that hard to learn and a lot of beginners start with PHP. We also know it has a ton of extensions, libraries, frameworks, etc... What we should be teaching people is how to more easily solve existing problems. Not making up fake non-existent problems to solve in books so we can make an extra buck. Just because **PHP** is on the cover, doesn't always mean the book covers anything fascinating about PHP. The truth is most PHP books I've read don't offer you anything you couldn't get from Google or one of the one-billion-and-one blogs out there that cover PHP (*and believe me I have an entire bookshelf filled with PHP books that I've gathered over the last 8 years*). Don't get me wrong there are certainly *some* good books out there on PHP that do actually help you solve real world problems in PHP, but I just think every time I see another PHP title I sense that I might be able to recite the first 600 pages from memory before I've even turned the cover.
This makes it a lot easier to understand. Thanks!
&gt;The ﬁrst thing you need to learn about PHP is how it is embedded in HTML Uh, there is nothing wrong with embedding PHP in to HTML. That is one of the core purposes of PHP. It is often useful to introduce the user to this early because they're going to wind up using it for a lot of things.
I'm not doing your homework for you.
You know, I feel the same way. I've been an on again, off again php coder for about 8 years now. I just started doing serious jobs with it and picked up CodeIgniter. I don't know how "bad" of an idea it was to use it as my first framework, at least it helped me understand OOP and MVC a great deal more. I'm in the middle of a project using CodeIgniter and not really any way I can switch as my development partner is also used to CI, but for our next project I might try something else, no ideas as to what yet. This doesn't really help you answer your question, but just putting in my two cents.
I'm not doing your homework for you.
You've probably seen these articles already (they're a bit dated, but still relevant to v1.1.*): http://www.larryullman.com/series/learning-the-yii-framework/. He also has a Yii [book](http://yii.larryullman.com/) out which I highly, highly, highly recommend. It might just be me, but his writing style is so effortless to grasp. I spent time initially looking for tutorials too, but then just dove into it, and it was pretty intuitive; so I wound up mostly using the [class reference](http://www.yiiframework.com/doc/api/) most of the time. If I had to do it over again now though - I'd probably read Larry's book first. Were you looking for something specific? or just general stuff?
I have. Nothing specific. I just like learning by following along. Thanks
Wasted? Suboptimal, maybe, but not wasted. I bet you learned a few things that'll stand you in good stead no matter what you're working on or with. What you should do next depends entirely on your preferences and situation. Learning another framework is a good idea. So is trying out a CMS. Learning a new language entirely would be yet another good thing. Beefing up on CSS, javascript or SQL? Also good. Getting down and dirty with the rest of the [LMW]AMP stack? Check.
Learning anything about programming is never a waste. The more you learn the easier you will be able to switch between whatever language and/or framework fits the problem best. On a side note Laravel is amazing. The code you write with it is extremely readable and the community/documentation is great.
We (me and my colleagues) are hearing a lot about Laravel lately, but we asked ourselves what were the problems we set out to achieve through codeigniter, and found that codeigniter had solved them. Now the general feel is we could see further benefits from moving to Laravel, but in our case we have other areas we could take more benefit from improving on. 
I have [this book](http://www.amazon.co.uk/dp/1849515484/?tag=hydra0b-21&amp;hvadid=9556672869&amp;ref=asc_df_1849515484) which I found very useful. But the best way IMO to learn Yii is just to learn by doing. The Yii wiki and documentation is great. 
You're apparently not interested in doing your own and supporting your claims.
Burden of proof can be shifted either way. You're not interested in proving its security, and I have no desire to further prove to you what I already know. You'll have to settle for what I've already said.
The creator of Laravel just responded to my post, is it odd that excited me more than opening gifts on Christmas?
Laravel is all about doing it right, from my perspective anyway. One of my favorite features is laravel's orm and restful controllers, I'll give you an example and then link to it: ORM: Creating a user in laravel just makes sense. Let's say you want to make a new user. // Create a new user $user = new User(); $user-&gt;username = $input['username']; $user-&gt;password = Hash::make($input['password']); $user-&gt;save(); and you want a restful controller for that login system. class Account_Controller extends Base_Controller { public $restful = true; public function get_login() { //return login view } public function post_login() { //validate and do above code } } http://laravel.com/docs/database/eloquent http://laravel.com/docs/controllers#restful-controllers All in all the benefit for me is the fact that Laravel is how my brain works, doing $this-&gt;user_model-&gt;create($user_array) just doesn't make sense to me, this what? Why are we adding models to controllers? What? 
In this case, the burden of proof would be on the new or remarkable idea. "Laravel has no security holes." Would be a remarkable idea. Most php frameworks and CMSs have holes, but are they exploitable?
If you know php, you know laravel. Let's say you want (better) access to your POST input values, what do you do? Input::all() (You want to get all input variables (array keys/values)). Also see my comment here: http://www.reddit.com/r/PHP/comments/15z0vt/learned_codeigniter_and_feel_it_was_a_mistake_now/c7r5jwn
Actually no. Look up burden of proof.
I felt the same way. Haven't done any coding in a while but I ended up finally learning Zend.
And stop being a bullying ass or I will report you.
burden of proof burden of proof - noun 1. Chiefly Law. the obligation to offer evidence that the court or jury could reasonably believe, in support of a contention, failing which the case will be lost. 2. the obligation to establish a contention as fact by evoking evidence of its probable truth. Seeing as #1 doesn't apply &lt;this isn't a law forum&gt;, #2 applies. Burden of proof remains on your head. I understand it quite well :)
The trivial thing is not the thing being proved, but the non trivial.
Allow me to demonstrate: Programs contain bugs and exploits. Trivial Program X has no bugs or exploits. Non-trivial Edit:carriage returns
Ah yes, I am obviously the bad guy here, and you pour on the inflammatory replies.
Good choice. `:)`
Through the process of "learning CI" you've probably picked up on some of the design patterns that it uses which will help you "learn" another one. What you're actually learning is computer science and more advanced PHP programming - try lots of frameworks as this debate and the "best framework" changes every day. 
Can anyone post a free ebook this extensive that is a little more updated?
:)
It's just different, classes will autoload and are static objects, so instead of: $this-&gt;input-&gt;post('comment'); You might have: Input::post('comment'); The other cool things that will be obvious to a CI dev are custom routes (not just controller/action) and the ORM. CI is still plenty powerful and its a fantastic tool, it does seem like Laravel 4 is the next big thing but CI was not wasted learning.
Note sure if someone else covered this, but.... I help interview a lot of candidates at my current work place, and one thing I look at is interview skills. By that I mean, good posture, calm demeanor, don't fidget. I mention that because often you'll have to deal with angry clients/managers, and an employee than can keep his cool has value. On to the technical stuff: I see people covered almost everything, but know how to set up LAMP stack. Know how to create virtual hosts, and edit your hosts file. Have some knowledge of unit testing. You don't have to be good at it, but just show you know some of it. 
I've created 2 tutorials that I thought might be helpful. http://iobe.net/yii.php 
Learn Java and pull your hair out. Then the circle will be complete.
I actually pulled away from Yii because there seemed to be a big gap between the basic entry level tutorials and the raw API documentation.
jQuery + HTML5 + PHP backend. Write ajax style websites that only use php to feed data to a jQuery+ HTML driven website. Then move to learning backbone.js and learn to better organize your javascript. JSON is your friend here. With this setup, you don't really need to bother with php frameworks, but you can. I enjoy this approach because it allows you to change the layout without re-writing code, and extending functionality is as simple as writing a new php function, writing the jQuery code, and creating the templates for it (also, you should look into jQuery templates or mustache.js/handlebars to take this even further)...
Yeah I'm in southern California here and I see a lot of job openings for php developers, and they are paying well for the experience you have. 
learning any framework makes you more employable. I almost never do any backend programming anymore, but my knowledge of the different frameworks helps me to communicate with dev teams. I learned CI first, then ASP.NET, and now I have the foundations for ASP.NET MVC. It all builds over time.
When I was in EE school (in the late 90s), I took a course on the 8088 microprocessor. Of course, nothing runs on the 8088 any more, but I had a much easier time learning the x86 because of that class. Same thing. You have learned a technology that has become a bit dated (although lots and lots of stuff still runs CI). But you will have a much easier time learning the new hotness because of it.
Speaking as someone who worked with CI only for several months and then tried to switch to a few other frameworks, I instantly fell in love with Laravel because of how similar it was to CI, making everything so much easier. Every time I seemed to find something that was different from CI, Laravel ended up doing it better.
why does this article say its very complex when it seems so simple? 
I'm not sure. I think their audience is beginners or they are assuming they are.
If you can understand its faults and learn from them and recognize its benefits, then it's not a mistake or waste of time.
Thank you for your comment. The flow of the code does seem more natural and I'll remain open to the idea of changing. When i get some research time I will aim to get through an installation + tutorials, but it will come down to how it affects the bottom line (e.g. time saved during development or reduction in server resource usage) as to whether we actually roll it out. Having said that, if its as good as the hype suggests, I'll definitely start using it for private work.
Yikes!!
Learn something else. Did you really think you'd do the one, learn CodeIgniter, and then never have to learn another framework or technique? Better get used to it...
I'd recommend trying out FuelPHP if you're interested in another framework. CodeIgniter isn't a total lose. You've now learned how that framework works. It's good to have a nice range of framework knowledge under your belt.
&gt; Just sayin'. If I claim it doesnt have holes, is that just as unsubstantiated? yes.
I bought [this book](http://www.packtpub.com/agile-web-application-development-with-yii-second-edition/book) and will start with it today.
&gt; I realize I'd be starting from zero again. Not true. Learning an MVC framework has probably taught you a great deal - you now have a good idea how MVC frameworks work, and you may have figured out what you do and don't like about CodeIgniter, and can now look for a new framework that solves those issues. I'm in a similar position. I'm just finishing off a CodeIgniter project, and during the development of it I started running into its failings. For instance, it has piss-poor support for unit tests, and I'm keen on going in a more TDD direction. So I've looked around and Laravel seems like the best fit for me - virtually everything I've found in it is implemented the way I'd want it to be, which wasn't the case for CodeIgniter. I can't deny that Laravel is a more advanced framework, but picking it up when you already know CodeIgniter will be a damn sight easier than from scratch. My advice is to pick a simple, straightforward project like a blogging engine and try to build it using Laravel. That's what I'm doing and it's worked before for me.
I'm new to frameworks and Yii seemed like a good one to learn. I bought a book and I'm planning to start with it today. Would you recommend that I rather learn something else? What framework would you recommend?
Learning what doesn't work is good, it helps you to not repeat mistakes.
&gt;large majority of PHP userland does not Know about testing, Know why they should test, Bother with testing I'm one of them. Can you briefly explain why I should bother with testing?
30 years ago in The Mythical Man Month the author made an interesting observation (imo): &gt;Systems program building is a an entropy-decreasing process hence inherently metastable. Program maintenance Is an entropy increasing process, and even its most skillful execution only delays the subsidence of the system into unfixable obsolescence. Testing is the best way to avoid unfixable obsolescence in software, which is to say testing is the only way to safely refactor or make significant changes to code. Finally professional programmers test their code. If you want to call yourself a professional (and not everybody does!) you should be testing your code. The tools are there, there are a great many books on automated testing - you have no excuse any more.
This has nothing to do at all with PHP. Why is it here?
Nothing which isn't already covered in the manual.
Actually GET and POST work in an identical fashion (since 2.0.0, before that GET didn't work for shit).
This article might shed some light on it: http://philsturgeon.co.uk/blog/2012/12/5-things-codeigniter-cannot-do-without-a-rewrite
This bug was patched quickly after being reported and the community was promptly notified. An overview of other source code was done as well.
Ignoring the whole semantic argument below, thank you for getting this link over. I sent it off to Taylor Otwell and that bug was fixed 3 months ago. If you have any other security holes (you suggested there were lots?) then please post them up here, as issues on the Laravel GitHub, on their forums or anywhere else, but just trolling threads that might mention Laravel and reporting it has security holes with NO evidence, then using 3 month old bugs when asked for more information is not helpful or constructive for anyone.
I'd say to look at the code examples and documentation on the big ones and go from there. I've learned Symfony, cakePHP and Zend (1) in the past 9 months - while I like and dislike certain parts of each one, I definitely don't regret learning them. CakePHP is probably the easiest to get into, you could always check into that and if you don't like it, you won't spend much time on it. (it's that fast to pick up) While I still am a little fuzzy with OOP, I am liking Symfony more and more. I can't speak of Laravel, I've heard great things and the documentation is very good.
Tell you what, if you want to believe that everything is 100% safe, you go right ahead. I deal with criticals, highs, mediums, and lows every day. What you consider a real hole is a critical for us. Most developers don't care about the others. We on the other hand, care, but it's not a product we're supporting.
Good. It still doesn't convince me that it's stable and ready to use yet.
Sure, but unless you know what you're looking for and are actively looking it up, you might not find it in the manual. You'd be surprised how many beginners have no idea the feature even exists. I confess, despite using the language for 9 years, I had no idea the __set_state() method existed. That woulda saved me some hell a few weeks ago when I was working with SimpleXML objects.
&gt;I confess, despite using the language for 9 years, I had no idea the __set_state() method existed. I did. Then again, I explore the manual at regular intervals, as I think everyone should. There's some interesting stuff in there for those willing to look.
As other people have said here, I don't think learning CodeIgniter was a waste of time for you to learn. You can definitely carry the semantics and syntax you've picked up from CodeIgniter and help learn a new framework. 
I hope this really helps for many!
OK. Just curious, when are you satisfied? Rails just had a major SQL injection vulnerability this week. Would you recommend Rails for production?
If you're autoloading, make sure to use spl_autoload_register() rather than adding an __autoload() function to your class. __autoload() is outdated and is subject to deprecation in future versions of PHP.
Funny, solidly 3/4ths my in-development PHP book is nothing but real-world production code, how to build it, etc., including [**YouTube videos**](http://www.youtube.com/user/phpu2) of it being created (time lapsed w/ soundtracks, so you're not bored to death). The apps described in the book include: * RedditMirror, * RosettaBlog (drupal 4-7 database compatible blogging platform), * Personal Income Tax Calculator, * MultiAuth: Authenticate billions of users via their Facebook, Google, Yahoo, Twitter, or any OpenID URL with just 30 lines of end-developer code. * FlexExchange: E-commerce system that will allow acceptance of arbitrary combinations of commodities (USDs, Euros, silver, gold, oil, cotton, more than a 100 commodities), creation of loans denominated in various combinations of commodities w/ the option of converting to other commodities. * and more... What's more is that any purchaser of the book can get write access to the repositories that contain these projects. So not only can you read the code, but you can (and are **encouraged**) to start contributing in the repo. It's not published yet (so don't think this is some advertisement lol) but it's going into the editing phase in about 6 months. I've been writing it in my free time since 2009.
Ruby is a crazy mess. I've heard over and over again that their patching is awful. Maybe they hit the criticals. I don't know why they don't fix the rest of their shit.
My answer is this...run it through all the commercial scans. Fix everything that's wrong. Maybe something else will eventually be discovered, but don't leave the known vulnerabilities there if you really want it secure.
If you don't have the capital to buy the licensing to scan things yourself, find a company in your community that loves your product and doesn't mind contributing to make it better. The truth is that most companies and organizations with scanning software would rather have your software secure (if they themselves are using it). It saves them time that the original developers do the work. This doesn't always happen. Sometimes they say it's not a big enough issue. Sometimes that why/when things fail. edit:spelling
I don't believe anything is 100% secure and anyone who does is a fool. But for you to actively discredit a framework based on a single (already fixed) security hole is ludicrous. This bug reminds me a LOT of a drastic security hole discovered in GMail a few year back. Would you troll any thread that recommends a Google product in the same way?
If I knew anything bad about their security, I would call them out. I don't think it's morally wrong to do so. edit:missing word
&gt;I may have to um... borrow some features from your gallery. =) It's not his gallery. He's just posting a bunch of links on multiple subreddits. He's been a user for a day and has already made at least 12 submissions. 
This caused one of the weirdest php error states I've ever seen. Occasionally it would trigger __autoload, sometimes not, then found some forum post about the fact that the function is going away, checked my version of php and in fact it was "trying" to use my spl_autoload_register, all while refusing to throw any real errors for whatever reason.
Well I'm using a class I found online to create a .pdf and just putting the sql in there since that's what it tells me to do. This class uses the php mysql functions, and I don't fancy re writing this class as I have no idea how it works. Also the SQL doesn't seem to work in phpmyadmin so...can you help?
its true, there is a lot in there that just hasn't gotten much exposure. its also good to google before doing anything the hard way, chances are good someone out there has asked that question, and there might be a much easier answer.
Hint: Try to avoid using the property and method overloading ones unless you have a really good use case for it. Future programmers and their IDE's will thank you.
Just what we needed, another article that just parrots the manual instead of writing something new or interesting.
Bad. This is horrible design. Dumping everything in to a single file is silly, and completely unnecessary. Dumping all your display logic in with your business logic is a terrible way to organize and makes it more difficult to modify the templates. Dumping all your user configuration values directly in to the script is also horrible design. The javascript is completely terrible too. None of it uses unobtrusive design, preferring instead to cram javascript in to the html elements themselves. Author doesn't demonstrate a very good understanding of event binding. Author doesn't seem to understand little performance enhancing things, such as storing object references in order to avoid resolving common lookups over and over. Then there's the laughably bad security which seems to employ a security by obscurity approach instead of strong checks and directory jailing. The author especially doesn't seem to understand null byte injections. Avoid. This is written by an amateur with very little understanding of good software design.
Agreed, the very idea is awful, and the implementation is worse.
Full disclosure: this is my personal / portfolio website that I'm trying to promote. That being said, I think the subject matter is useful and relevant, so I guess that's up to you guys to decide. Also, this is a new reddit account, but my main account is 4 years old so I'm not here just to promote, I don't want it tied to me professionally. Cheers!
I would worry more about your use of tables for layout when you put CSS as a primary language
Really I don't get all the table hate, they're easy to use and if they accomplish the same goal what's the issue? If I was going for a different type of layout I would use divs if they were necessary.
Tables are for tabular data. While you've accomplished what you want visually, it is semantically incorrect. And what freezedriedpop said is correct, if you're listing CSS as a language you're good at and an employer checks your source (they often do), your "expertise" in CSS will be exposed.
Okay, I'll accept that. I personally have preferred tables probably because when I started out you couldn't float divs and do the fancy layouts with them you can now, so it turned into a bit of a habit I suppose. Were this strictly a personal site I'd probably say f-it, it's my site, but since it's also a portfolio site I'll look into changing things, since the layout is pretty simple it shouldn't be too crazy to do. Cheers.
You're not giving him hell for the inline css?
If a style isn't going to be reused (especially in a template file) and is simple generally I will just put it inline, especially during the initial design process I find it easier to tweak things. Similarly, if I go back later to change something small and specific I don't have to go into the css file and worry about it affecting other elements. Just preference again. Same with my use of empty divs to add a bit of space before/after elements. I just find it quicker to be able to copy/paste them as a single line and tweak the spacing, vs. creating a style just for top and bottom padding. I get pretty picky about the spacing so I'm usually editing them a fair bit. It's also a bit of a habit from doing a lot of Flex coding and using Spacers all these years.
Have you thought about using http://php.net/manual/en/class.domdocument.php instead of regex? Tons better.
1) It actually takes less code you've used a whole table to center it where as it would have just taken: margin:0 auto; 2) It's not just tables you're using things like align="center" everywhere which has been obsolete since HTML 4.01, we're now on HTML 5. If you're coding peoples sites in that manner, they're not going to last as long or possibly work on all devices. It's incredibly lazy to just leave it because they work right now since it's only going to wind up costing your clients more in the long term to bring it all up to scratch and frankly that just means you're ripping your clients of. It's the equivalent of having an oil leak on a car where the mechanic simply patches the hole and assumes it'll be okay and charges you same amount as for properly fixing it. Maybe it will be okay, maybe it won't, but you don't care, it's just job done to you. That may seem harsh and I don't mean it to be an aggressive attack (always hard to tell on the net), but to use the same analogy again if I was speaking to a mechanic who was telling me he was doing a half arsed out of date job simply out of habit rather than bothering to get up to date with the latest and proper standards, i'd question that mechanic's suitability for his job.
i didn't get it either until i got rid of them and made the switch over to div based markup and CSS driven design. tables use HTML code to dictate design. certain elements of the design are hard coded into your HTML code. div based markup uses CSS to dictate design. for any professional web developer, you need to make the switch. i would run away from anyone i saw using tables for layouts if i were looking at hiring them.
I saw an iPhone specific page the other day that used tables. Sigh...
I like SimpleHTMLDOM myself. Recently built a web app that scrapes pages and I used that.
Yeah I did, but I haven't used it before, whereas I've done a ton of regex stuff, so I just went with that.
DOMXPath is my tool of choice when doing web scraping, XPath is more readable and easier to write than regex in that matter IMO. Besides, there's the whole Zalgo thing...
The problem is that these articles tend to live on past their expiration date without being updated to current practices. I don't know how many newbies I've seen asking questions relating to some bad practice or misinformation they've picked up from some old tutorial they've found on the web. 
&gt;Really I don't get all the table hate, they're easy to use and if they accomplish the same goal what's the issue? The issue is that they're semantically incorrect when used for layout. Tables are for tabular data *only*. What you're doing here is ruining the experience for users using assistive technologies. What's more, you're hard-coding the layout, requiring a full rewrite if you ever want to change it. Had you done it properly, all you would need to replace is the CSS. So, no, you're not saving time, if that's what you're thinking.. You're merely postponing it.
http://savannah.gnu.org/people/?category_id=1 
Try $query = "SELECT teams.id_team, teams.shortname, games.id_home_team, games.id_visitor_team FROM teams JOIN games ON (teams.id_team = games.id_visitor_team OR teams.id_team = games.id_home_team)"; But I have a feeling this won't give the result you're looking for. Explain the bigger picture and I can give a more accurate reply (I've built a team management system in the past). 
Use aliases for the tables: $query = "SELECT home.id_team, home.shortname, visitor.id_team, visitor.shortname FROM games g INNER JOIN teams home ON g.id_home_team=home.id_team INNER JOIN teams visitor ON g.id_visitor_team=visitor.id_team"; 
The other replies look better, try those.
All of them?
A further update: I decided I'd get the SQL working before thinking about the PHP. I have it kind of working. SELECT * FROM sales sa INNER JOIN stock st ON st.StockCode = sa.StockCode WHERE st.SuppName = 'Name 1' This works and returns the data I thought it would. SELECT * FROM sales sa INNER JOIN stock st ON st.StockCode = sa.StockCode WHERE st.SuppName = 'Name 2' This returns nothing. I have been over the data again and again and it definatly should be returning something. Why is this happening?
Most likely, something is not syncing up on the field that is joining the 2 tables. Perhaps the results in `stock` where `SuppName = 'Name 2'` does not have any records where its `StockCode` exists in the `sales` table. Trying changing the JOIN to a LEFT JOIN and check out the value of the StockCode fields.
Sure why not. What are some of your favorites?
This is what I have been checking, but it's exactly the same data as Name 1 but just different names. All have similar records, can post table data if it makes it easier. Tried left and right and normal joins too, no luck. I just keep thinking something has to be different but I really can't see it...it's weird.
* [Symfony](https://github.com/symfony/) * [Doctrine](https://github.com/doctrine/) * [Friends of Symfony](https://github.com/FriendsOfSymfony) * [KnpLabs](https://github.com/knplabs/) * aaaand shameless plug [Orkestra](https://github.com/orkestra) - still getting established. needs moar docs
Looks good!
I try this however is only returning shortname for the visitor team. not the home team.
Thanks for this, very informative. Someone over in /r/sql actually managed to solve this for me. Turned out it was trailing spaces in the name 2. Using TRIM in the WHERE clause fixed this. It's weird because I actually thought this might be the problem and tried copying and pasting it from the stock table, assuming it would copy the trailing spaces as well, but it still returned nothing, so assumed that trailing spaces wasn't the problem. But using TRIM returns what I expected! How bizarre.
I've used SimpleHTMLDOM myself as well, it hogs memory like hell and is slow, but for it's simplicity it's great. I was using it to spider web content and it is really, really slow compared to using domdocument, but it's not anywhere near as easy(dom).
Thanks a lot for making this whole thread about fucking tables. 
You should probably fix your data to not have trailing spaces. `TRIM()` shows that altering the data to match the same makes it work but you shouldn't have to use it like that to make your data work properly.
&gt;That problem applies to every single paper publication too, ever. Not necessarily. Paper publications tend to, for the most part, not be written by people who are new to the language. The same unfortunately isn't true on the web. As such, the quality of such articles tend to be lacking and contain a fair deal of incorrect information.
How can I fix it? 
I'm really not sure without looking at the codebase but it's just a matter of making sure your data values are consistent when you insert them into the database. So, if you insert a value of "Name 2" in place, the exact same value should be used else where when inserting for "Name 2".
All of this code and advice should be ignored. First, stop writing your own curl stuff. Just use a well tested library like [Requests](https://github.com/rmccue/Requests). Then, stop writing your own scraping code and just use a class like [QueryPath](http://querypath.org/) or phpQuery or one of the other jQuery PHP libraries. You'll save yourself hours in writing boilerplate XML/HTML parsing code. And the screenshot images? I guess you *really* don't want anyone using your code.
There's a download link for the full php in the post. I'm using images because I don't have any code block/colouring set up yet - maybe you can recommend a lib?
More likely it seems you hate code written poorly, that is not a reflection on php but the authors who wrote the code. New modern php frameworks are changing what people think of the language because they are using more modern design patterns and features of php of today, not yester-years.
I think you'll do well with the beforeSave callback. I don't know of any Cake magic that will help here, but it shouldn't be more than a couple dozen (or less!) lines of code to get it done in the beforeSave() method.
I would highly recommend Symfony2 or ZF2 over Laravel. Something about so::many::statics irks me the wrong way... That said learning any framework is never going to be a complete waste.
&gt; when I started out you couldn't float divs and do the fancy layouts with them you can now Now? "Fancy layouts" as you call them have been possible for *at least* 8 years. I don't want to sound like a dick, but you simply cannot defend your outdated knowledge of the web.
Thank you so much!
This kind of problem isn't really suited to PHP. Calling 'set_time_limit' is a big clue right there.
Are you one of those dudes who will open multiple pull requests all over the place for easiest bugs then claim that you contributed to X,Y,Z? Hah!
You think that was a mistake basing on what? You learned basics that are pretty much universal for all frameworks. I'm opening /r/php like in once in month, so I have no idea which framework is currently most popular here. I just heard about Laravel for the first time reading this post. According to its homepage it is merely little more than a year old. Maybe some day it will be insanely popular, maybe it will die in next 5 years - impossible to say at this point. Sure it has some nice ideas, but at any moment core team may split over different pathes of development. If you want guaranteed benefit for your career learn something that is well estabilished industry standard - Symfony, Zend maybe Cake. Other way - just do what in your opinion feels best for you and keeps you in front of code - every written line makes you better.
Hah! No! Im one of those dudes who see new dev's asking how they can get experience and being told to contribute to open source projects but never knowing specifically where to refer them to other than google.
The DOMCrawler component can take care of this with _significantly_ less code being written: https://github.com/symfony/DomCrawler file_get_contents() the URL and shove the HTML through there, or Guzzle/Buzz/Requests it for a more exception heavy experience. Let's not write more code than we have to (especially if its HTML traversing or directly working with CURL - which sucks), and really lets not advertise it as "the current way" to do things by blogging about it in 2013.
[PyroCMS](http://github.com/pyrocms/pyrocms) welcomes any useful contributions. Translations, features, bug fixes, whatever you do means we can work on something else. But yeah, basically every open-source project could do with some contribution, otherwise nobody would bother open-sourcing it. A project isn't finished until it's dead.
What are you promoting? Shitty code?
http://en.wikipedia.org/wiki/Phishing Now stop propagating that shit.
&gt; So I was curious what frameworks you guys like to use and why? This is a clear invitation for simple one-line "framework x is the best" responses, and I see that's the result you clearly got with a large number of direct replies to this post. It's a subjective discussion that's held or at least solicited very often. Look up [three or four posts above yours](http://www.reddit.com/r/PHP/comments/15z0vt/learned_codeigniter_and_feel_it_was_a_mistake_now/) on the front page to see what I'm talking about. You're right though: "Its a PHP discussion site". I was wrong to frame all framework-related posts in the same negative light. I understand my opinion alienates many and is rather harsh and perhaps offensive. Thinking on it more, I realize that discussions on the world of frameworks built around PHP are just important and relevant as core PHP itself. On the flipside, I feel questions asking or inviting for comparisons between frameworks are too many and are not often any more productive than the very first one posted. Many PHP frameworks have their own subreddits - /r/laravel and /r/cakephp for example - where one can research the best options for their scenario. You do have a good idea about starting /r/phpnews though. I might soon.
I've seen this question a lot and have often wondered it myself. But the best way to start contributing to an open source project is by becoming a user first. Find something that interests you and use it. Don't start off thinking, I'm going to make a name for myself by solving all the bugs on Doctrine's bug list. Say, hey I'm going to figure out how to use Doctrine. Once you start using a project it's much easier to make meaningful pull requests. That all being said; I was playing around w/ [log4php](http://logging.apache.org/log4php/), it has a lot of good ideas - but it's really rough around the edges. I'm sure they're up for some contributions. I'd suggest reading the documentation and using the php config parser - its totally broken.
Thanks for adding one to the list!
http://www.yiiframework.com/wiki/98/yii-related-sites/
Seems like many of them are very inactive. /r/php and /r/phphelp seem to be the only two very active ones that I know of. /r/webdev is nice general web development stuff, and /r/programming is always good-- just never mention PHP.
I think he meant "All of them" as in, ever single open source project needs contributions. You may have mistaken his question to mean, "Do you want me to list all the ones that need help that I know of?".
A demo install somewhere would be a good idea.
You're a true dickwad, you know that?
Sounds like what you need in your life is [Amazon Web Services](http://aws.amazon.com/). You can create instant virtual services on demand, and only pay for what you use. I recommend this because from your post and comments it sounds like you may be at the beginning of your 'scaling' journey in PHP. I went through the natural progression of shared hosted, to even more powerful shared hosting, to a dedicated server, more power dedicated server and I was never prepared for an influx of X amount of users even with my most powerful server. What AWS lets you do with your virtual server is to stop is, and start it up again as a higher grade server. You don't have to change anything for this to happen. These [instance types](http://aws.amazon.com/ec2/instance-types/) are varied, and the micro instance (which honestly you could probably use) is free for a year along with an assload of other free tiers. They offer a CDN for offloading images and static content like css and js, and cloud databases as well. Definitely check them out, as they don't charge $x.xx/month for anything its solely based off what you use. You could even upgrade the server pre-planning a big event and downgrade it when its complete. For a startup site I built with them using all services (EC2 for servers, S3 for CDN, SimpleDb for database) my bill was &lt; $1.00 a month fitting into the free tier for the year.
http://www.reddit.com/r/symfony
Yes, please post a demo. Or at least some screenshots with a better description of the functionality. (assuming it's yours, that is)
IIRC, they won't help that case. You would have to refactor the code or find a way to collect all the $ids and put them into one statement and iterate over the results. However, if performance is your problem, your first stop should be profiling, then caching any existing expensive operations before you go refactoring, unless the data is too unique to be cached. Caching helps with scaling, too, if you need that. Failing that, then yes, whether using prepared statements or not, you'll want to minimize your I/O calls as they are likely your culprit. But profile first!
Yes, you want to move the preparation out of the loop otherwise not only are you losing the value of prepare/loop, but you actually are causing a lot of extra back-and-forth with the server to send the prepare datapackets over and over and over. You might be able to avoid HUGE rewrites by passing it an array of data to be dealt, if at all possible. But, I don't really know your code. Ultimately, it's probably a optimization that won't save you a lot of actual performance. If it's going to be a huge rewrite, it almost certainly won't be worth it. Do it "right" next time around and for this app, just toss an extra $0.5/per day at amazon for a slightly more beefy machine :)
&gt;Yes, you want to move the preparation out of the loop otherwise not only are you losing the value of prepare/loop Actually, that might not be completely accurate. Depending on the DBMS you are using, as well as your settings, the prepared statement might be cached. Of course, that doesn't mean that writing things in this manner is okay. You should, of course, move the prepared statement out of the loop, as you say. Just nitpicking for the sake of correctness.
I'm wondering why you'd need to write an online source code viewer when you have a github account.
If they're incapable of finding an open source project they can contribute to on their own, they aren't trying very hard.
Reddit votes are fuzzed for antispam.
I commented when it was sitting at 1|2.
For the civil union of my brother we made everyone ftp their photos on my server and I then searched for a simple gallery script. I tried A LOT of them and they all would be too complicated or not working with a simple folder structure. I was then glad to stumble upon Single File PHP Gallery and ended [using it](http://pacs.funkybits.fr/). **Cons:** - IIRC I made the information panel showing up by default and it made the page buggy once there was too many galleries. - First gallery display can be slow due to thumbnails generation. - There is no "intermediate" thumbnails so to browse photos individually they need to be downloaded full size. All in all it saved my life as we all wanted to see each other photos and move on :)
/r/phpcodereview
the point between "obtaining" the lock, and marking that you have the lock can lead to multiple request believing they have it. The problem is, you haven't obtained the lock in the scheme described, you only know that, when you checked, there wasn't one.
As an aside to your note: just to ensure you really understand prepared statements, you are making *two* calls to the database via the database API. The first is to prepare the statement. The second (or N+1 calls) are sending just the data only. Thus, the database already knows about the statement, and you're saying "this data goes with this part of the statement". The database just inserts/updates/selects that data into/from the tables. Because of the two different API calls, injection attacks are much more difficult because you do not have a concatenated query.
A lot of it depends on the project and framework you're using but I have found that PHPStorm utilizes PHPUnit fairly easily without a whole lot of configuration. The best/easiest setup I have found so far is using [Composer](http://getcomposer.org) to setup the project. It has its own packages it looks at for repositories as well as you can add your own sites for private repositories and exclude the public ones. There are several PHPUnit repositories available in composer as well. Composer already handles autoloading of classes assuming you utilize namespaces properly. An example project I started recently: https://github.com/haydenk/EnvironmentManager PHPStorm is actually really good about giving prompts that lead you towards how to fix certain settings that may be missing like what PHP interpreter it's supposed to use.
I would say don't waste time and effort learning to do things the wrong way that could be better invested elsewhere. Just use mod_php or fastcgi/fpm and invest your time in learning how to do useful things.
The key is based on a session id, another client will not look the same key up.
Should have thought of that... here it is: [Demo](http://www.fractalice.com/demos/syntax/)
Yup, it's mine. The link is here: [Demo](http://www.fractalice.com/demos/syntax/)
I wanted to ability to put the code on my own domain so that if I wanted to password protect some/all of it but still be able to view it I could. I didn't want to get into too much detail in my README as it's just boring, but I used to be able to live view my code because we used WebDav, so if I was ever outside of my job I could just quickly and easily browse my code. I've since left that job, but I still need to reference my old code, and I don't want to carry it on a thumbdrive, but I also don't need to have it in CVS (at least not right now). So I decided to just make something and release it. First time I've been able to.
I wrote an article about setting up XDebug with PHPStorm (although it wasn't originally intended to be PHPStorm-only, I've not had a chance to add more IDEs): [Xdebug and You: Why you should be using a real debugger](http://jtreminio.com/2012/07/xdebug-and-you-why-you-should-be-using-a-real-debugger). Setting up PHPUnit is as simple as setting up Composer. Here's my intro to Composer: [Composer Namespaces in 5 Minutes](http://jtreminio.com/2012/10/composer-namespaces-in-5-minutes). You'll want a VM. Don't develop on your day-to-day OS! Don't install Apache/MySQL/PHP on the same machine you play games and watch porn on! Read my [Setting up a Debian VM, Step by Step](http://jtreminio.com/2012/07/setting-up-a-debian-vm-step-by-step). Setup git for your project. It's as simple as `git init` and `git add .`. Push to GitHub if you have nowhere else to push. You mentioned unit testing. You didn't mention you knew unit testing. Maybe my presentation will help you understand it a bit? [Testing with PHPUnit. My First Presentation!](http://jtreminio.com/2012/10/testing-with-phpunit-my-first-presentation). I've yet to write anything on Phing, but FYI the gold standard is still Jenkins.
Please use http://prismjs.com/ to highlight your code, my eyes are bleeding trying to read the example code you put on your demo. I can not even imagine trying to read lines and lines of that.
I don't use PHPStorm, but I did recently publish a five part blog series where I actually do exactly that. I set up a local server, show you how to set up and use Composer, use a git repository, create unit tests, and create a simple pastebin app using Twig and RedBean ORM. You can [read it here][ti]. I did not use Phing though. I might write about that next. :) [ti]: http://www.terminally-incoherent.com/blog/tag/php-like-a-pro/
We could always use help on the [Elefant CMS](http://www.elefantcms.com/) project!
Jenkins on its own isn't quite enough - you still need some kind of build scripting system to tell Jenkins what to do, and that's where Phing steps in.
Gonzalo didn't mention this, but if you want to use Doctrine without the ORM, use Doctrine DBAL. It's basically an updated Zend_Db and I love it.
Wow, thanks for enlightening me with that information. I don't think I need to tell the same to you, though.
&gt; Don't develop on your day-to-day OS! Wait, why?
I'm working with the second part of the post and (spoiler) It covers DBAL :)
Actually I would say the biggest benefit of using a VM as your development environment is that it eliminates the "it works on my machine" argument, since your VM and your production environment should be exact mirrors, or as close as possible.
Thanks to both of you, I'll definitely look into this.
The expression you're looking for is "bear that in mind." "Bare that in mind" means to denude something in your mind. 
Again, PHP internals.
I'd say of all the things you're guilty of, lack of version control is the thing that needs fixing asap. I couldn't live without git or even some form of vc. | How do I configure PHPStorm to develop locally, publish remotely and commit to git all in the same breath? You probably dont want to do that. Develop locally (ideally on a VM or local dev server). Commit it all to git. If you have unit tests you could perhaps use git hooks to automate it all, preventing you from pushing any code which fails the tests. Finally have some form of deployment stage. For me this is simply telling the web server to pull from git, but many people uses deployment chains such as Capistrano etc. The important thing is that committing to git and deploying to live are treated as two separate events.
Yep I got that, I just wasn't sure whether PDO was intelligent enough to recognize a second (or N+1) call to prepare the same statement and then re-use the already prepared statement.
Uh, fuck that. 
Do you know if PDO does caching? I doubt the performance improvement will be worth the code rewrite, but I wanted to understand how it works better to see if what I thought was correct.
&gt;It's basically an updated Zend_Db and I love it. Which Zend Framework are you comparing it to?
It's old code, not object oriented, but you gave me an idea - I could write a class for caching the prepare statements and wrap it around PDO.
&gt;Do you know if PDO does caching? It doesn't work like that. Like said, it depends on the underlying DBMS.
I switched to Laravel on a recent project and really like it. Is CodeIgniter actually planning to bring itself up to date like other frameworks?
This is why we have PSR-0 autoloading.
Unit testing and version control should be at the top of your list. For how to properly use git check out: http://nvie.com/posts/a-successful-git-branching-model/ Here's what I do: 1. Develop test driven code locally. 2. When complete and all tests are passing I commit to feature branch on git. If feature is complete then I merge it into the develop branch. 3. Log into my hudson server. Kick off Dev project. This will import source into hudson, run Unit tests on Code. If those pass it runs through a code coverage analysis, check style analysis, and documentation creator. If code coverage is high enough and check styles are low enough it will kick off my Integration project in hudson (pretty much the same as Jenkins). 4. Integration project runs a build script that imports some config files from source code, which contain nginx.conf, php.ini and a dev.ini. Nginx.conf is conf file for web server. Im guess you know what PHP.ini is. and dev.ini contains variables such as server hostname. I can supply a new hostname and it will build a bare bones server, install NGINX and PHP and will have my site running in a matter of minutes. At this point, I can go to dev.domain.com and access my site as double check to make sure everything looks good. 5. Once the server is built, the integration project will kick off selenium tests, which are test that mimmick a user's action on the website. 6. If selenium tests pass, then the code is checked into my master branch which then will allow a Production project on hudson to pull that master branch and make the code officially live. I don't PHPUnit integrated with my IDE. I just go into the terminal and run them manually. The same goes with git.
Oh, I got confused, but it's possible that PDO *could* do caching of prepared statements, right?
It could do that, but I have no evidence to support that it does. One possible way of doing it is to keep a hash table of statements linking to a statement name. 
There are some dangerous mistakes in this application concerning file system sandboxing. What's keeping me from posting action=get_file&amp;curr_dir=/etc/&amp;file=passwd? Be very careful when developing applications like this.
I am thinking about wrapping PDO in a class that caches the statements
EllisLab are still using 2.0.x to power their latest version of ExpressionEngine, not 3.0 which is due to be released sometime relatively soon. My personal opinion is that if EllisLab are that far behind the current version then it suggests that no 4.0 is about to magically appear. If there is a recode, it would have to be at least a year away, maybe two. That's just my opinion of course.
Baaaad puns.
Am I the only one who thinks using a VM for developing in seems like overkill? Most other languages have a means of creating a sandboxed interpreter (Virtualenv in Python, Perlbrew in Perl and RVM in Ruby), and most developers use those. PHPBrew seems like a good way to do that in PHP, although I haven't tried it yet. To me, it makes sense to use something like PHPBrew with the dev server. Even if you needed a totally isolated environment, surely there's better ways than running an entire VM? For instance, could you maybe create a chroot jail containing only the components you need?
I have a VM for development, but then I also have my workstation set up with an instance of Xampp, this way I pretty much always test my code in both Linux and Windows (my hobby is playing with a PHP framework I've been doing for 6 years now). I would then also have an extra VM for the builds and automated testing (don't really do that now). This way I am testing it across two OS's and at hopefully my build OS and my real web server and kept close together. In the past, I've changed something on my dev box, forgot about it, and then when I pushed live it's blown up.
This is what I came up with ... Any comments would be appreciated! class PDOCached extends PDO { private $PreparedStatementCache; public function prepare($query) { if (!isset($this-&gt;PreparedStatementCache[$query])) { $this-&gt;PreparedStatementCache[$query]=parent::prepare($query); } return $this-&gt;PreparedStatementCache[$query]; } } Note: I know this doesn't take into account $driver_options, but I am not using them in this project, so it doesn't matter for now :)
Some general advice: If you are writing a very complicated application with many tables, joins, views, and stored procedures using an ORM might create more headaches for you. In this instances just write some core data access logic in true object oriented fashion. Also... if you need bleeding edge speed look at writing SQL (or using a very lightweight ORM). If you are writing a "simple" application with simple CRUD type operations using an ORM will save you time in the long run, "help" protect you from sql injection attacks, and help maintain a "standard" query language (I've seen 5 different devs write 5 different simple select statements). It's usually a cleaner abstraction than embedding sql everywhere in your app. Now... In practice it really "depends" if an ORM fits your application. I've tended to use ORM's in the last 5 years and probably wouldn't go back to writing sql queries. 
I use Yii, and let me tell you ORM has made my life incredibly easy. Author::model()-&gt;with('posts')-&gt;findAll(); gets an author and all of his posts, probably in a single query. ORM isn't always the fastest thing right out of the box, as they constantly query the tables to make sure they know what the structure is, but it can definitely decrease the amount of time needed for development. They're not always the answer, however, and most frameworks include ways for writing your own SQL queries. I myself learned Yii first and I was incredibly frustrated with the lack of ActiveRecords in Zend 1.x. I'm still not sure if we're using Zend in the office right (we have models that extend from nothing and DbTable models that we power the models with). If you tweak the settings properly for good caching of the database structure, and pay close attention to queries the framework is generating, you should be able to generate as-good performance as self-written queries, methinks. I'm not as experienced as you, so take my advise with a grain of salt - but it's personally done wonders.
ORM's save an incredible amount of time. Are you going to write your own CRUD methods? How much time would it save you if that was already done for you? How much time do you think would be spent reviewing your custom methods during development, when it could all be done with the same behavior and syntax? For example, let's say you want to join 2 or 3 tables, apply a few filters, and display them in order. It's very possible you would end up having multiple methods in multiple areas of your application doing this. With an ORM, it's already done for you, using a uniform API. After you've spent some time with the ORM, you won't even look at your model code anymore, you'll just remember how the ORM works, and write code. I've seen quite a few apps with a ton of time spent wasted in the model. It's a no-brainer in my opinion.
Once you get up to "enterprise"-level development, it's crucial to mimic production. I've had so many issues over the years where a piece of code worked on my desktop using XAMPP, but it would not work on production, because I was running Win7 and prod was running Debian or something similar with a bunch of different library versions and file locations. You can't test chmod issues on windows; what if you want to test a library that uses GD or imagemagick? There's lots of little gotchas that simply taking that potential headache out of your hands makes it all worthwhile. Also I get to use the terminal!
"Or are ORMs really there just to make development easier?" Short answer: Yes. Long answer: Using ANY sort of database abstraction library is a good idea. If you code everything using a specific extension then if it gets deprecated or removed you're gonna have a bad time: https://wiki.php.net/rfc/mysql_deprecation Any sort of abstraction layer will also mean that if you need to switch from MySQL to PostgreSQL down the line it will become much easier. While PDO handles the connections it's the actual SQL you're writing that is different, so you need to use a "Query Builder" at least to handle that. Query Builders are generally faster, but they do less - which is why they are faster. ORM's get lumped in together as "big, slow, memory hungry", etc but it depends on which you use. http://philsturgeon.co.uk/blog/2011/06/misconceptions-about-orms An ORM is basically something that maps rows to PHP objects, and sometimes contains relationships, and should probably have something like lazy-loading and eager-loading to make working with those relationships efficient and easy. That by itself should not be drastixcally memory hungry, it's when (as NavarrB says) ORM's try to "constantly query the tables to make sure they know what the structure is". That shit scares me, and it should scare you. Don't use a system that does that. I like to use Eloquent which is a Laravel component. It doesn't try to know what your whole table looks like, but supports eager-loading, lazy-loading, polymorphic relationships and all that good stuff. Try it out: http://12devsofxmas.co.uk/post/2012-12-29-day-4-mixing-and-matching-php-components-with-composer My approach is: Rapid Prototyping? Use ORM Low traffic API: Use ORM Low traffic website: Use ORM High traffic API: Replace ORM endpoints with raw queries, or stored procedures. Nobody wants to wrestle raw queries for no reason, and the differences between raw SQL and a lightweight ORM are so tiny its negligible. Throw a little caching on top and when that doesn't do the trick any more replace the query. Keep an eye on your SQL slow logs to see which are the worst offenders.
I implemented the wrapper class (see http://www.reddit.com/r/PHP/comments/163w56/a_question_about_prepared_statements/c7sq9bf ), but I am not sure if it provides the performance benefits ...
Laravel 4 only uses statics as an optional facade: http://vimeo.com/53029232 People see a few statics being assumed and jump to the conclusion that it's not unit testable or whatever, but it's just not true.
many ORM projects have options to use native SQL within the ORM context, so you can use native queries for more intensive parts and still end up with the same object output as if you were using the direct ORM methods.
Well, in my case some of those issues are taken care of for me anyway. I develop on Ubuntu, and generally use Debian for the servers, and while they're not exactly the same OS, Ubuntu is based on Debian so I rarely have those kinds of issues (although I did once have an issue with a known bug in PHP 5.3.2 on a server running Ubuntu 10.04). &gt; what if you want to test a library that uses GD or imagemagick? That's why I mentioned PHPBrew. While I haven't used it myself, it seems comparable to Virtualenv in Python, which sorts out these kinds of issues by allowing you to install those kind of things in a sandboxed install.
Looks okay, provided you've set PDO's [error handling](http://uk1.php.net/manual/en/pdo.error-handling.php) up to throw exceptions. If not, then you would want to make sure that you don't cache `false` because `isset(false) === true` and then the query will fail all the time. `empty` would work well there, though.
Hey Phil, Short reply: Thanks a ton! Your blog post was a real big help. Made sure to bookmark your blog for future reference. Medium reply: I definitely see the benefit of avoiding things like deprecation and the headaches that can come with having to switch technologies. I might as well use something like Eloquent for one of the internal tools I'm building this week to get a better feel for ORMs, but it sounds like for our main production websites, I'll have to stick with standard raw SQL due to the traffic/scaling. Thanks again for your comment, you really helped me out a bunch!
Good point! I have setup exception based error handling, so this shouldn't be an issue, but I will update the code to take this into account. Thanks!
I'm sorry but I think in a big, complicated project it is even more important to use an ORM to provide a layer of abstraction between the models and the data. What if further down the road you need to migrate to a from MySQL to Postgres? This migration will save you some time and headache using an ORM.
Specifically, we're looking for translators and designers to build new design themes, but also any other help we can get :) We're super close now to a 2.0 release as well, which means we can always use more testers and bug fixers too. Here's the page in our developer docs that can help new contributors with getting started: http://www.elefantcms.com/wiki/Contributing
Another example: Posts::model()-&gt;findAll(); You can define the relation between posts and authors in the Posts model. Then in a view, you can start doing things like: $model-&gt;title for the post title, and $model-&gt;author-&gt;first_name for the author's first name. But like you said, it is not going to have the best performance, but it greatly speeds up development.
Perhaps in regards to how triggers are written, but for the most part the complicated queries between the two will be very similar in syntax. In that case, you simple put your trigger logic in the DB Handler layer. In reality, you end up with a hybrid system... ORM is there to simplify things, but then you have to be able to get around it when performance dictates so.
And politeness ensues everywhere.
&gt; What if further down the road you need to migrate to a from MySQL to Postgres? This migration will save you some time and headache using an ORM. If you are using an ORM, why would you ever need to migrate DB platforms without ditching the ORM? After all, you're already getting the worst of all possible worlds in terms of performance and feature sets. I think the only reasonable use cases for an ORM for anything but a completely performance-agnostic project are when it's going to deployed to multiple existing database platforms, either because you're giving it to customers or you have some complicated in-house legacy database proliferation issue.
The performance improves if you do Posts::model()-&gt;with('author')-&gt;findAll() because then it doesn't run queries to call author when you need it. It's already there (if you know that you're going to need author)
While many have outlined lots of great points I just want to add http://propelorm.org into the mix as an orm that I think is excellent. 
One of the main benefits of an ORM is that you can switch DB platforms, why would you ditch the ORM? They're not faster in regards to performance, in fact they are generally slower performance.
Write now, deploy soon, optimize later is in this "fast living world" a must have. So write ORM, deploy, benchmark (log) see which queries are to slow (if a page is to slow) which is rarely the case. 
I think I can boil this down to a simple question: Whats more valuable, your time or the performance of the application? ORMs are of course going to have a fair amount of overhead per query compared to just directly using PDO\MySQLi\Whatever but an ORM, once you are familiar with it, will save you a lot of time writing queries.
To be fair, how many times have you switched database platforms mid-project? I am adamant about ORM use (Doctrine ftw) but this argument is not, in my opinion, grounds for using an ORM. Also, many (most) database abstraction layers offer this abstraction without the need for ORM. Doctrine DBAL is one of those.
Before just assuming that Eloquent (or any ORM for that matter) is slow: try it. Take one typical client website already build with raw SQL and smash it to death with Blitz, Bees with Machine Guns, whatever load testing software you use. See what traffic it holds up to and what the response times are. Recode it with Eloquent (and do it properly, learn about lazy-loading and use with()) and run the same tests. You may well find its not actually that different. If it is slow, don't do it for those sites. But right, absolutely use ORM's for internal / low traffic stuff.
I guess my point is that since the main thing holding you back is the ORM, then why bother switching platforms? You're still going to have the same disadvantages afterwards. Might as well instead work on factoring out the ORM.
You might be switching for reasons that are out of your control. But that being said you could be switching from something to Percona's MySQL fork for their backup system. 
You can have a database abstraction layer without using ORM. Doctrine has one for example (DBAL), as does Drupal 7. This provides limited abstraction over mysql but still gives you a lot of control over the actual queries you are producing.
Advantages over WAMP/XAMPP or the VM setup?
1. version control for a one man band if a waste of time. 2. you should develop locally, why upload test, upload test 3. unit testing is a waste of time, if it works, why bother testing it. 4. build and deploy solutiuons, thats a new one, another waste of time. As i understand. 1. yes develop locally. 2. youll waste time building unit tests when you could be building apps. 3. commit changes if you are in a team, or arent confident enough. 4. push to live server. All this crap about unit testing i find a complete and utter waste of time, it takes three times the code to write the tests to find out that you code works. Be confident in what your developing and get another programmer to read it. Unit tests = waste of time and effort. Develop OOP from the start and you wont need to test it so thoroughly. I use notepad++, i develop a full blown AJAX app. if i spent half my time fucking around with all these things i wouldnt have even finished a framework in the time ive built most of a full blown app. Be a programmer and not a tester.
Well, I agree PHP is not for serious or professional efforts in the slightest. However, for someone just playing and testing it out should not be discouraged from trying. I thank you for more information.
10. Do you have testers. (why does reddit format my one zero to just a one, its the TENth one) this i find the most important, everything else is just circumstantial. you can get away with notepad and ftp client for the rest if you are a small operation. BUT. nothing beats someone else telling you where you went wrong. Coding forces you to wear blinkers. Use other people to see outside of your own perceptions.
I really don't mean to be rude about this, but for the love ^of all that is holy, please google. I didn't even qualify the search with "programming" or anything: http://lmgtfy.com/?q=What+is+a+framework%3F
TL;DR of everyone, basically. Simple to moderate complex SQL, ORM. Very complex SQL, No. Personally I am in love with Datamapper on CI. The one pitfall that is easy to get stuck on is the memory management of it. You MUST use something that iterates (get_iterated() in DM) through results set as you loop so you don't build up thousands of objects at the same time and exhaust all your memory.
I would guess ZF1. ZF2 would be Zend\Db, right?
&gt; version control for a one man band if a waste of time. Hrm... I think quite a few dev's would disagree with you there. Being able to feature branch/mess around/rollback/merge is critical to my workflow regardless of team size..
#1) If you're writing a product to sell and don't care about the database, then you need db abstraction. Otherwise, consider what you are doing, and choose a storage that's right for the job and don't pretend like you don't know where your data is going. But DB abstraction does not mean SQL abstraction. SQL abstraction can be done by a complex collection of classes and methods, or by something simpler like an l18n system. #2) Depending what you do, ORMs can be very slow. They do a lot of behind the scenes work in order to make sure you don't have to care about your RDBMS because hey, you're a developer, you don't got time for that shit. As such, a super mega robust ORM that has a PHP class for every single fucking thing imaginable and so chainable that it's starting to feel kinky, is not going to deliver the greatest amount of performance. But hey that's cool, the Rolling Stones are a little slower now too, doesn't mean they still can't rock out. #3) You know what's fucking annoying? Data modeling. Why? Because it's tedious, repetitive, and SQL fucking sucks. Wouldn't be great to create my data models and *poof*, I've got PHP classes, Java beans, BackboneJS models and collections, and some SQL!?! Hell yeah. That's why ORMs are so fun dude. It's because I can create all boooooooooooooooring DDL in code. And using either whatever ORM convention along with some good ol class design, and I've got a single place that describes my data and no matter what new technology some jackass product manager read about in "Shitty Products for Shitty Managers Monthly", I can still easily cope with it. #4) If you can't understand the output of an EXPLAIN SELECT, then you should ignore ORMs completely. They are not for you, no no no. ORMs really fucking hurt when they are used by people who wanted to use them because they were too cowardly / lazy to learn how to use an RDBMS. 
i find it gets in the way. i commit very infrequently. when in a team it is very important if you can get your team to use it properly and not commit broken stuff. same with unit testing, if your a coporation where 100 dev's put there hands on your code, fair enough. If you building an app then maybe, for a general web dev, what a waste of time, seriously.
fraemwerk. i dunno what is a fraemwrk I know a website that could help with your question. It's called Google.com
getting every web developer to follow the protocols of a large corporation is just stupid.
You have a very relaxed writing style, which I don't think is very conducive to trying to teach, and I also think it turns off potential readers. Try and write more professionally. I guarantee you'll find a bigger audience. Cool stuff though, keep it up.
For high traffic, I'm of the opinion to use model objects with sql generators. The generators are not slower, but they protect you from some of the sql dependency problems. If you need to for some reason change db backends. Plus it will protect you from api changes and interfacing deprecation. 
You're absolutely right. However, 1. I use git, as a sole developer for my freelance/open source projects, because I like having the peace of mind of saying, "well, this didn't turn out so well. Let's undo it completely" and nuking the git commits that caused the problem. Gone are the days I would have to copy/paste folders when making a major change in case I need to revert. No longer do I have to keep my editor open just in case something fails catastrophically and I need to CTRL+Z my way to how it was. 2. I develop locally. This is a great idea. I do it in a VM because I've been bitten before by having the server stuff running on my daily machine. For example, Skype blocks port 80 by default, XAMPP won't work unless you know Skype in particular blocks that port. Previously, PEAR didn't work very well in cmd.exe. I miss many powerful linux tools that are not available to Windows via the command line. There are all valid reasons for keeping my development environment separate. 3. Unit testing has been the single biggest boost to my confidence in my code I've ever had. I no longer have to click around everything to make sure the changes I've made haven't affected something else. I can now refactor with impunity because if I get that green bar, and I have confidence in my tests, I know nothing has broken. If something breaks, and I have good test coverage, I know exactly what needs fixed. Being good at unit testing has also made me immensely more marketable, and dangit, testing is *fun*. 4. My build script is: Commit, run several tools like CS, MD, CPD and tests, then allow push to remote. If any of these fail, it lets me know I need to fix them. This keeps the quality of my code consistently high and lets me come back in a day, a month or a year and pick up where I left off much more quickly and easily than if I didn't have all these checks. I see absolutely no reason to not carry over what I do in my paid, professional career and implement that knowledge into my freelance or personal projects. I feel it has made me a better, more capable developer overall, and I have turned down offers where I would be working in environments where I would not have the luxury of these processes in place. PHP is *not* just a front-end language relegated to simple tasks. If you have a disciplined, dedicated and hungry developer, you can create many great things to rival what's already out there - you just have to want to do it at a higher level.
 three. fun. ewwwwww And i develop an application site, mostly in AJAX, PHP, mySQL, all of my PHP is backend stuff, hardly any of it reaches the front end. And i agree with you too. If you intend on going down the corporate path, theres no reason why you cant take that home with you, or vice versa, learn it to get into the corporate path. The biggest asset ive had in all of this is not testing, its getting other developers to go over my code.
I guess lying about issues is more your forte.
Why are you moving away from ZF?
I use Symfony2 framework which utilizes Doctrine. I find it extremely easier to use than writing queries on my own. Also, if I ever want to write a custom query and I can type my own SQL. 
IMO your biggest sin is not using a dev-test-live type environment. To set that up you'll address the second biggest sin of not using a version control system. Unit tests and build deploy stuff is good, but far below the other two in importance.
&gt;To be fair, how many times have you switched database platforms mid-project? I've worked on a few projects both new and in maintenance that were each tied to MySql. In both cases we considered moving to Postgres due to the various issues with MySql, but since an ORM wasn't used, it would have been a real pain to migrate the code with the embedded SQL due to the MySql specific syntax used. 
I would add that you need to keep an eye on what queries the ORM is generating. I've seen instances where it'll perform two separate queries or a subselect (and we all know how shitty the MySql subquery optimizer is...) which would have been much faster with a raw sql join. The other thing is that since objects are created the memory footprint can be significantly larger depending on how much data is being loaded from the database. This is why ORM is great for general CRUDs but terribad for any significant amount of data. 
You can usually get a raw connection and write pure sql when you need to.
What if further down the road you have to migrate to a different OS or programming language? You should use Wasabi or dev on top of LLVM just in case. &lt;/sarcasm&gt; If you don't have a need for multiple DB's, then don't add that type of complexity to your app. 5 years down the road, when the app is making money you can __afford__ to move it onto a different DB. Do it then. There are a lot of reasons to use an ORM, that you might maybe one day possibly want to use a different DB is _not one of them_.
I'm calling you antagonistic for throwing out an "argument" that can't be argued. You're arguing about the cost of learning a new technology. From the comments mentioned in this post, most of them work the same way, with -&gt;with(). For any sort of API you should read the documentation and understand what you're doing. The same goes with query languages, SQL, NoSQL, Mongo, etc. You're not raising a valid argument, you're simply yelling at us for promoting a technology that we find useful. It's like complaining that people use frameworks because they're all different!
So your entire strategy in these types of conversations is to attack the other person as being 'antagonistic' and characterizing them as 'yelling'. When you get a bit of maturity about you, let me know, perhaps we can finish the conversation.
*facepalm* You're not presenting a conversation. As for "yelling" and "antagonistic," let me refer you to your own comments in great big bold letters [over here](http://www.reddit.com/r/PHP/comments/164r3w/to_orm_or_not_to_orm/c7t1bdv). If you would like to provide a debatable argument about ORM vs. Raw SQL than please, feel free to act mature and do so, as my original post did.
Thanks for all of the feedback. I've actually tackled a bunch of what you wrote for the next release. 1) Per jefffan24, I switch to using prismjs. It doesn't have as many definitions as GeSHi, but I like where it's heading. 2) I'll add that to the todo list for a future release 3) Added a spinner right before I read your comment. 4) I'll have to check that out, I was bad and only tested in FF and IE 5) Yeah, I hard coded it for right now. I'll put in better icons that represent the actual files in another release. 6) And most important, I fixed up the code so that it shouldn't be possible to go outside of the top level. Of course, I haven't done much with file tree browsing in the past (which is why I'm doing this project) so there may still be a way, and I still need to lock down the $_POST so it won't accept outside requests, but it should be better by tomorrows commit. Install should be pretty quick, just dump the whole thing into a directory and then start putting your source code into the "source" directory or define another directory in the config.inc.php file, make that dir and then put stuff in it. I also want to see if I can add password protection for some (or all) directories with something other than .htaccess
Switching up now, I like this system a little bit better then GeSHi just for right-out-of-the-box formatting.
'would like to' and 'need to' are two different things. 
I would very highly recommend you start contributing to some well-known open source projects. It doesn't matter what, but hopefully a project you use and are passionate about. Open source will do a few things for you: * You'll get familiar with working with other people. This is very important for the future of your career * You'll be exposed to (other peoples') best practices. This will help you form your own opinion on why or why not these 'best' practices work and are truly the best. Things like unit and integration testing, version control, and a whole wonderful world of magical stuff. * You'll come to know some really smart people who may pass on their knowledge to you. [This thread](http://www.reddit.com/r/PHP/comments/162opy/can_we_get_a_list_going_of_any_open_source/) is a great start on which projects you might be interested in contributing to. edit: Finally, you'll always be behind. There will always, ALWAYS be something new. The fact that you realize this is a very good sign that you're competent at what you do. Keep it up, and try not to feel overwhelmed.
Thanks, I've often thought about this, but then I guess my concern is looking like a total noob to the other contributors, or worse, completely stuffing something up because of my lack of knowledge / experience. Is there a "right way" to get involved in OS projects?
Nope. Fall into it, make mistakes. Some people are rude about it, some are nice, but they both tell you what you messed up. After a few red-faced moments you'll remember that we were all newbs once and that is that. One thing I like about Symfony is they have a label for some of their issues called ['easy picks'](https://github.com/symfony/symfony/issues?labels=Easy+Pick&amp;page=1&amp;state=open) -- and they are just that. Somewhat straightforward issues that are fantastic for getting your feet wet. I've also found that the Symfony community is extremely helpful to new contributors. Last thing, get on IRC. Freenode is cool, join #phpc and idle for a bit. There's a lot of off-topic crap and lots of on-topic too. And some cool people that aren't afraid of telling you how it is... even if they are wrong. ;)
Bare minimum to be an "effective" professional PHP developer these days: * Git/Mercurial * SQL * OOP To be considered appealing to more and more companies, add in test, one framework (once you know one good one ...). I don't know how you're getting swamped by Laravel, CodeIgniter, CakePHP (haven't seen any CakePHP code in the wild in years!) and Symfony. At most there should be one. Also, you missed Zend Framework, Kohana and Yii. I stay away from "Fluent", "Eloquent" and ORMs. kcacheGrind is part of my everyday toolset, along with XDebug. But yes, you're right about falling behind. One of the major reasons I quit my last, cushy job where I had been moved from a fast-paced, exciting team to a very slow, methodical bug-fixing team working on a 5-year old codebase, was that if I stayed there for 10 years, in 10 years I wouldn't have advanced one bit and I'd still be in the same exact spot. Remember that web developers have a shelf life : you either keep up, stay fresh, or get left by the wayside.
This has extremely little to do with the PHP community at all.
Yes, PHP has really started to pick up better practices as a community, and this is a great thing! That said, you by *no means* must use them. You are free to hack up a contact.php and run it as is and there are very good reasons to do just that often times. Not every script needs to be installable by composer, unit tested, version controlled, or frameworked. Sometimes a client just needs a damn contact form. That said, any serious project, you **should** invest in these things. A solid framework gives you good structure for your code and solves many, many repetitive problems. Unit testing ensures a stable system so you don't break things as you go. Composer helps you manage dependencies for your code (and can also help ensure YOUR code is friendly to being packaged with others), and version control -- duh. Just duh.
You make some good points. What is your favorite ORM for php? Thanks.
1. find a guy that is really fucking good at doctrine 2. have someone else pick a reasonable data-heavy sample application 3. you write it with your sql, he writes it with doctrine 4. the "someone else" comes up with a requirement change (change behavior of old feature) 5. make changes 6. test for sql injections 7. winner gets beer from the loser this should take 3 hours at most
&gt;unit testing is a waste of time, if it works, why bother testing it. You have to keep in mind that if you work for a client, the requirements will always change. And any change brings along its share of bugs. So even if it works now, it may break, when you change some code for a new requirement. The new requirement will work, but some old features may have broken silently. So unless your project is really small or you have the superhuman ability to know all the implications of your new code change, you have two options. 1. Make the change . And check the whole project manually. 2. Keep writing the tests from the beginning. When a new requirement or change request comes, implement it. Run all the previous tests, which is a one line command. If every tests passes, add a test for the new functionality you just added. &gt; Be a programmer and not a tester. When you write unit tests, you will see that the testing process becomes programming, which you love already. and I think that's the reason why jtreminio said testing is fun. In other words, Unit testing shifts testing from being a mechanical process to a creative one. So if you love programming, you would not mind writing tests. &gt; version control for a one man band if a waste of time. This may be a matter of personal preference. But How do you backup your code in case of a hard disk failure? I use mercurial and all I need to update my code to bit bucket online repo is the command hg push Updating my code online enables me to work from anywhere. Earlier I had to send mails to myself with zip attachments. If you are not using something like that, you have to use an ftp client to sync with a ftp server. In that case you will have to keep track of which files you changed or upload the whole project always. neither of them are very elegant. 
i can be in agreeance with what most people have said, yourself included. i dont think its a bad thing, dont get me wrong, i just think in practicaility unless you are working in a multi departmental environment, it can be a waste of time. There is an inherent step backward in web programming in that widgets are the go go. Many progamming paradigms get lost in this new generation of the OOP. Sitting down and planning out a projects goals gets lost in the interwoven single call scripts that get run. In the days of application programming, including today, it is impertive to have an infrastructure and without planning it would likely fail. unit testing is the planning for future failure. When in many instances it may never fail, so this becomes bloatware inside a function that was never in need of extra code to make it work. So now you have the problem of looking after two environments, the code itself and then the code for testing the code itself. Now were two layers deep into one problem. On another note, the corporate box you are confining yourself into, albeit for the security of future development is not the one usually attributed to new discoveries, time and again, it is those that dont follow the norms of behaviour that break the barriers. So, i guess, its not a bad thing, or is it. Youll have to make up your own mind.
Don't be alarmed by all the frameworks out there. Most of them essentially solve the same problems, in different ways. Some solve more problems than others. You don't need to know everything as the frameworks are generally well documented and if you can't find the answer then it's normally around somewhere in the depths of StackOverflow.
You also forgot all the modern deployments methods.
IMHO in PHP world (when all dies at the end of each request) ORM doesn't have the same sense than with other environments such as j2ee or .net (with a persistence layer). ORM can help you to organize code but if you are smart enough with raw sqls, not to use ORM can be a good decision.
re: ORM and switching databases. I'll agree it doesn't happen much, but will throw in an example. I'd written an app using an ORM - hundreds of queries scattered around the code, but no actual SQL written. We get to a point where we needed some complex reports, and the ORM wasn't sufficient - so I wrote a couple of queries by hand for the reports. Worked fine. A year later we're hitting some performance issues around the reports. I tried index changes,etc but reports were now taking 45-60 seconds, up from about 8 the year before. This was all MySQL. Moved data to PostgreSQL, rewrote the 2 report queries for PostgreSQL - reports are 5 seconds. Yay. A month later, I realized a mistake in my logic - rerunning the reports on MySQL was back down to ~10 seconds. Granted, still faster on PostgreSQL, but bad query on my part meant we wouldn't have had to switch in the first place. BUT... the switching was not a bit deal. In fact, migrating the data was the trickiest bit, because we were using 'boolean' (bit in mysql IIRC) and they're represented rather differently between the two systems. So while it doesn't happen all that much, it can happen. To the points others have made about using ORMs and raw SQL mixed - I agree, and it mirrors my own experiences. Start with ORM, and drop to raw SQL when needed for performance. FWIW, I'm using redbean in PHP and GORM/Hibernate when in Grails/Java. re: having the other developer who's a genius at SQL, so what? He won't be working with you forever, now will he be on that code forever. The more complicated and complex the code is now, the harder it will be to maintain it later. Or is he a 'mad genius' on writing clear tests and documentation as well?
Not sure why Doctrine would be considered a buzzword, I've seen it used in professional projects for close to 5 years now. It's not like it popped up out of the woodwork yesterday. Entity isn't a buzzword either unless you've been in a time capsule since the 60s. Downvotes initiated indeed.
The PHP community is maturing and specializing. This is a sign of a healthy community. You are always free to write the code any way you want -- but the community is moving on from that. The first thing you are seeing is the floor being raised, the minimum standard to be a "solid" PHP develop now includes: distributed version control understanding, unit testing understanding, basic SQL, 1+ framework, 1+ debugging toolkit. While the floor is coming up, the expectations on the high end now including noSQL experience, multiple frameworks, PECL, clustering, security profiling, security proofing, etc. 
Where are you guys even getting that I meant multiple DBs? I was trying to say migrating DBs, in other words, you start out using MySQL but then after a bit of time realize that MySQL isn't doing it for you and you need to migrate over to Postgres, for example, instead of MySQL. So, you're still only using 1 database but you're switching platforms. Also, I didn't mean it as the only reason or primary reason but it's a good reason.
Hi geusebio, can you tell me why these are buzzwords? The blog post is about a new couchbase cache driver for doctrine and it is used to cache entities. How else would you've named it? I'm all in for constructive feedback but this certainly isn't.
Sorry it took so long. Here is a three part article: http://codeangel.org/articles/option-pattern-and-avoiding-nulls-pt-1-introduction.html
Can you recommend an IDE once the VM is setup? What do you use?
No, if the GET parameter contains a number and the query treats it as such, mysqli_real_escape_string wont do you any good. Example: $my_value = mysqli_real_escape_string($_GET['value']); mysqli_query($link, "DELETE FROM table WHERE user_id = $my_value"); if the get value would be: 1 OR 1=1 it would still delete everything. Now if all your queries look like: "SELECT * FROM table WHERE '$my_value'" , note the quotes around $my_value I believe it would not be a problem (using mysqli_real_escape_string that is ofcourse) Anyway I suggest you get your prepared statements up and running asap..
Thanks.
So this is better than going the Debian route described in the article you posted above?
Your first and best solution is to start fixing it properly right now. A grep of the codebase should get you a list of the files that make mysqli calls. Get others to help you if possible. Also, try to abstract common calls in to libraries. This will not only help solve your injection issue, it will potentially cut down on the amount of code in the project.
If you're not interested in the slightest on learning the basics of setting up a server environment, then yes.
Here are the other two parts: [Part 2](http://codeangel.org/articles/option-pattern-and-avoiding-nulls-pt-2-method-chaining.html) and [Part 3](http://codeangel.org/articles/option-pattern-and-avoiding-nulls-pt-3-request-variables.html) [github project](https://github.com/cythrawll/Option) I am hoping this might start some interesting discussion.
I think disagree with the other posters - the pragmatic solution would be as you describe. In the immediate short term put in the real_escape_strings. So long as the value is quoted in the SQL this will deal with the vast majority of vulnerabilities. Even if you miss some which don't have quotes fixing 95% of the vulnerabilities now is better than fixing 100% in a month and leaving yourself open to attack in the mean time. Once you're reasonably happy you've eliminated the worst of it you an start doing the actual fix (prepared statements). The result will be the same but you'll have more protection in the short term. 
Well I didn't make this decision personally, but in my research of ZF2, it just seems it's a tad behind the times and ridiculously configuration heavy. ZF just seems to be a bit of a bloated memory hog while there are many other frameworks that can give us what we need without all the overhead (it looks like we will be going with Laravel most likely).
I've been manning the GitHub pages for CodeIgniter, PyroCMS and FuelPHP for a while. On those projects I would see a lot of people sending in their "first PR" and it was usually a little wrong. People would send things to the wrong branch (new features should go to the NEXT version, bug fixes to the current version), accidentally send up multiple changes in a single PR (use branches to keep them separate) or generally screw up whole files (make sure your [line endings](https://help.github.com/articles/dealing-with-line-endings) are set up properly). Nobody is going to give you shit for getting it wrong, and you might learn something along the way :)
To be fair a lot of this stuff is not new, it's just getting more popular these days. You don't NEED to learn any of it, you're just going to get a lot more out of PHP development if you do. * GIT: Ignore previous. Learn it or else. * Composer: Install stuff easily, replace PEAR. * PHPUnit: Test your code, so you know its not broken. * Vagrant: Stop the "Why does my Windows code not work on Linux?" derp. Now, this is where it gets more optional: * X Framework: Yeah there are lots and there have been since 2006. There will always be lots. Some are good for API (Silex, Slim) and some are good for prototyping backends quickly (Laravel, CakePHP). Some are component libraries that can be used to do anything (Symfony2, Zend2) but are a little more complex. Pick whats right for the situation. * Fluent / Eloquent / ORM: You don't need to use ORM's or query builders if you don't want to. Use PDO, that's ok. * kcacheGrind: No idea what that is. New stuff comes out every day and you don't need to learn all of it. Remember a quote from Leathal Weapon 2: &gt; Captain Ed Murphy: I don’t give a fuck, Riggs. That’s why I don’t have an ulcer, because I know when to say, "I don’t give a fuck." Keep an eye on [PHP The Right Way](http://phptherightway.com) to let you know what stuff you should give a fuck about.
Next time, leave the "What is Symfony?" section: 1. Go to symfony.com 2. Click on "get started" 3. Under "The quick tour", click "Read". 4. Read through each of the five subsections. 5. Click on "Documentation". 6. Read the sections you wish to know more about.
No, No, No, No. Escaping is one thing, forcing it to be a compatible and potentially broken value is quite another. Never, ever use typecasting as a means to sanitize your inputs.
If I'm doing a look up against an integer - why wouldn't I cast the value to an integer? Please include an example.
Jump in. The get started tutorial is fine for getting your feet wet. If you have any experience with any other framework at all, the concepts should come pretty quickly. The hardest parts for me to understand was service configurations (and why they are important) and the constant reliance on the CLI tool to perform tasks. Although the folder / code structure is pretty free form (outside of putting everything in a bundle), most libraries do follow a similar pattern. I learned a lot just by looking at some of the popular Symfony2 bundles about how to structure code. https://github.com/FriendsOfSymfony is a great place to start to just get an example of how a good bundle is put together. One of the first things I struggled with is whether or not to put all my app code into a single bundle or multiple bundles. In the end, I chose to store all my app code in one bundle, which in hindsight I wouldn't do again - the app I built was large and had several major components (store, forum, etc) that definitely justify having their own bundle. 
Just use your operating system's scheduler (e.g. cron if you're on unix or Task Scheduler if you're on Windows). What's the problem?
I agree with most of the comments here but there's a major point here that I think is important to each person's career. I spent most of the last 10 years feeling very much like a complete newb and wondered when I'd finally know enough to stop spending so much time learning and spend more time actually doing. The time will come. In this industry, you can't get away without investing time in learning new tech, but the time will come where you start to feel comfortable with what you know and can start really knocking out projects, even best of breed using all the technologies you mentioned. And new tech will always come so you'll need a base of knowledge in which to place this new tech in its correct context, and better learn how to implement it. For example, I feel like I have a pretty good handle on PHP and programming for the web. So I'm taking on Python and Websockets, where I feel like a newb again. But at least I have a base of knowledge with which I can see where these new pieces can fit in the context of overall software development. You build on your previous knowledge when you enter new, unfamiliar areas. I would disagree with others here saying that the tech you've mentioned is not really important. It is important to learn and work on and understand high-quality apps, so its great that you're learning these things. These are important decisions that can really impact a project's efficiency. The "bare minimum" isn't what we should be striving for, you should always try to do better. TL;DR: Keep up. You'll get there.
I fully agree with you. One of the reasons I would love to get into bed with Laravel is because its in its infancy? I don't mean that in a bad way at all, I just know I could help contribute in a more meaningful way whilst still being such a underdeveloped aspiring developer? As mentioned I don't think Laravel has integer based migrations, most people would never ever need it, but its something simple and small I could do to help contribute both to the framework and the community. It might seem small and negligible but meh it gives satisfaction knowing I helped out.
I would also advise against using is_numeric(), since it's not specifically for integers only - it allows a range of numeric representations. I would suggest you use [filter_var](http://php.net/filter_var). Ex: if (filter_var($my_int, FILTER_VALIDATE_INT) !== FALSE) { // do whatever you need to do } else { echo "Sorry, you didn't enter a number!"; } 
If you're going to keep downvoting the people who are trying to help you, you frankly don't deserve any help. 
Not sure about your actual question but just FYI you might want to look at this CMS: http://www.pimcore.org/ It has a crazy object system which sounds vaguely similar to what you're describing (in that you basically build parts of the CMS itself in the CMS using a system of objects that are stored in generic tables). I'm not saying you shouldn't build your own but it might be interesting to look at how they've done it.
If you have php 5.3 or before. You can turn on magic quotes. This should handle your case. But it is NOT a long term solution. 
This. I'm not saying it is the best, but I would guess that whatever performance problem yo have is not because of Zend. I would first calculate the cost of doubling the server cost, and then both of your time over the next year. Then realize, that at most, Zend might be a 10% hit. I just find it unlikely that Zend is the culprit you are looking for. Keep looking for your bottleneck. 