&gt; This is a silly test. Agree (= As I wrote in other comment, comparing Netty or Node to Apache + PHP is pointless.
&gt; Most languages require an additional framework to connect with the webserver. At least Node.js and Netty (from all that FW list) do not require anything, they listen any socket by themselves. Why use them in this test?
&gt;You can't provide dynamic class properties (only compile-time logic). You mean assigning properties to objects which hasn't been defined in the class? ...You can do that.
**Node.js**: * Runtime: V8 * Language (users): Javascript * Language (platform): Javascript, C++ **Netty**: * Runtime: JVM * Language (users): Any JVM supported (Java, Groovy, JRuby) * Language (platform): Java **PHP**: * Runtime: PHP * Language (users): PHP or C * Language (platform): C PHP does not have the same level of separation. You can write a web-server in PHP, sure, and then you don't have to use the PHP framework, but nearly everything uses the PHP framework as it integrates well and performs well enough. HipHop is another implementation of the PHP framework (for PHP), as are a few other projects **TL;DR** PHP is a language, an interpreter, a framework, and a spec all rolled into one. Edit: missed what you were asking. Sometimes they're load balanced behind other servers... but I can't really say for sure. They are both frameworks, just not specifically web frameworks.
I agree with the comments that say not to get bogged down in the optimization for this but I thought I would chime in with my two cents. Zend Framework sets the environment in the apache config file like so: SetEnv APPLICATION_ENV development Then you can access this in your code: if(APPLICATION_ENV == 'development'){ // devel specific stuff } I also prefer doing what Wordpress does for settings, have have a config file with your base settings (so you have an example to work off on a new deploy) and then a specific file for that deployment (wp-config-sample.php vs wp-config.php). This way you won't have your database usernames and passwords floating around in your source control system and devs who shouldn't have access to live/private databases won't have direct access.
https://github.com/haydenk/EnvironmentManager I like keeping it simple. The environment is whatever you say it is in the environment INI file, period. No reading if it's localhost or checking the hostname. Also, the environment file that specifies the environment should not checked into the repo. You clone it where you want to set it up, create your environment file on the server. There's no mistakes if it doesn't read a $_SERVER variable or hostname correctly.
It's totally ok. Laravel, for example, does this too.
&gt; This isn't a very good way to do it really. It's better to set a proper environment variable Sometimes defining environment by hostname is the only option you have have.
Agreed on the apache-php (although they need to use APC and turn of .htaccess). However, PHP is still a web framework in this context. Look at the stack. * Resin &gt; Django &gt; Application * Rack &gt; Rails &gt; Applicaiton * Apache &gt; Rails &gt; Application * Apache &gt; PHP &gt; Application * nginx &gt; PHP &gt; Application Just look at it. We don't put Silex where PHP goes. We don't put Symfony2 or Codeigniter or Laraval. We don't put any PHP frameworks there. It'd be very inefficent to write a FCGI/CGI/NSAPI/ISAPI in PHP. So its written in C and included with PHP. PHP conviently is a language, a runtime, and a web framework (when compared to everything else). The API includes web-specific features when using the web features (you don't get _GET, _POST, _REQUEST in CLI). A language by itself does not process those for you. PHP does a lot of things before it gives control to the script. It is not a web server. It is not an application. It is a midddleman between the server and the application, sitting firmly where every other framework goes. If it wasn't, we'd be using something else to implement FastCGI/CGI/NSAPI/ISAPI as every other language has to do. Most PHP frameworks don't reimplement any of that. They just build on what PHP, as a framework, already provides. It isn't strictly required, because PHP is *also* a language. You can write a FastCGI processer in PHP without using the web framework portion of PHP (and thus, not using the superglobals nor the provided functions getheaders() or setheader() functions). TL;DR PHP is a language, an interpreter, a framework, and a spec all rolled into one. 
I'm just saying that there is no real benefit to a "DI Framework". PHP does not NEED Spring (which I assume is an motivator/influence here, if not then check out [Spring's documentation on it](http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/overview.html#overview-dependency-injection))the way Java does. You can setup dependency injection, in pure code, without the need for externalized configuration or reflections. http://stackoverflow.com/questions/2461702/why-is-ioc-di-not-common-in-python Checkout the accepted answer to this question. Yes, it's Python, but the same conclusions can be reached for PHP as well.
Maybe. A lot of people are obsessed with verbosity. I do hope that PHP moves in the direction of [Groovy](http://groovy.codehaus.org/). And it does seem to be doing that, which frankly, is not a bad thing.
&gt;AFAIK most MLS allow brokers or even agents to get a RETS feed - so dev can simply do his work programming things - or am I not correct? Can people working more with IDX systems share how they've gotten RETS feeds? This is how it works generally. Dude, you are in for a world of pain if you're messing with an MLS that Rapatonni or any of the major players cover. They will randomly change crap about the "API" (worse API known to man) without telling you/other outside developers. These changes in turn will break your API calls. When you try to explain it to your client, you'll look like the tool, because "all of Rapatonni's sites are working fine." Hit me up if you need the PHP to RETS connection code. I know there are some packages that do it, but I have the code to do everything without all the package nonsense so you can lay your own application on top of the data. Edit: Also be prepared to deal with the most passive aggressive, neckbeards you've ever seen. I don't know why, but RETS server guys are the worse. It's like they all came from the same factory. Oh, you need support? Just visit our [RETS forum](http://www.reso.org/index.php?option=com_content&amp;view=article&amp;id=33:support&amp;catid=25:resources&amp;Itemid=112). Oh wait, it doesn't work.
There is never ever any reason to store credit card information in your tables. Ever. Never ever ever do it. You expose yourself to all sorts of liability and this makes your app NOT PCI COMPLIANT. If you want to store CC information, use a payment gateway's API (like auth.nets's CIM). Here's how it works: You send the cc information to auth.net, they validate it, store it and then send you a payment profile ID. When you want to charge the stored card, you simply pass the profile ID and the amount you want to charge.
Actually for web I'd recommend using Graphicsmagik (which is a performance optimized imagemagik fork). it has less features but performs basic tasks (like scaling, cropping, writing text and overlaying) a LOT faster (of the top of my head I would say 6 times as fast)
Symfony2 is your main "competitor". It's an "enterprise"-level framework that is great for larger teams, or complex applications. It has extensive documentation, a large community and well-written code. For me, however, one of the biggest benefits of Symfony2 is its little brother, Silex. Silex introduces you to many concepts found in Symfony2, but in smaller, bite-sized chunks. Once you learn how Silex is structured and how it works (it's easy!), you can take that knowledge and apply it more easily to Symfony2. Does Zend Framework 2 have a Silex equivalent?
Here's what I consider, at its most basic terms, a web framework: * Abstracts away web-server specific features and bugs. * Automatically processes web input. * Automatically sends/receives headers, when appropriate. * Provides a template system for easy outputting of HTML and other text. That can be written in C, C++, Java, Ruby, Perl, PHP, whatever. There are several ways to talk with the server. With PHP, all of these frameworks build on top of the foundation PHP already offers. They don't have to, we could write a CGI scripts that in PHP that doesn't utilize PHP's web framework features: #!/usr/bin/env php5 &lt;?php echo "Content-Type: text/plain\n\n"; parse_str($_ENV['QUERY_STRING'], $get); $name = empty($get['name']) ? 'World' : $get['name']; echo "Hello $name!\n"; return 0; Not very clean. Probably a waste of time. But it by-passes those web-specific features that php provides. In PHP, instead of doing what PHP does: we could instead implement an application server, in PHP (as nearly every other language does) that does the following: * Application Initialization * Persistent routing and dispatching (same object instance throughout multiple requests). * Persistent pool of reusable resources (database connections, among other things) * Dispatching of non-requests (background) tasks from the persistent application state. Except... PHP already provides a lot of that: * Initializes an application state (you need to use an extension, using C, to add your own logic that persists between requests, such as APC does) * Receives as request from the webserver (probably through stdin), and unifies the interface of accessing web-related input before passing it to the view layer (php). * Automatically provides HTTP compliance, often when the application tries to be non-compliant as well. * Provides a configurable templating language that allows easier integration of view logic. I'm not trying to convince you that PHP isn't a language: it is. I'm not trying to convince you that PHP provides the same functionality of Rails, Django, Symfony2, CakePHP, and such: it doesn't. I'm not even trying to convince you that mod_php, php-fpm, or php-cgi make PHP a web-only language. PHP is not *one* thing. There is no separation from the language spec, the runtime spec, the api, and the bytecode. There's other PHP implementations, but they will always be 'wrong' if they don't operate the way the php.net interpreter does. It acts like a web framework. It does the same essential things web frameworks have always done (process URLs, cookies, post input, web server processes, etc). It may not be as sophisticated as the frameworks built on top of it. PHP, the language, is not a framework. PHP, (the non-cli and non-gui runtimes, at last), is. So. What do you consider a web framework? Is PHP missing something for it to be a framework?
Here is something for you to do: **stop calling it PHP-DI**. `DI !== DIC` Dependency injection is language-agnostic development practice, while dependency injection containers are structure, that analyze code and inject requirements for an instance. Also, **FFS**, stop writing procedural code that is based on global state. Just because you use classes is not enough for it to count as OOP.
You are actually right. I am considering renaming the project for the new version. I chose "PHP-DI" quite some time ago when not much existed about that (in PHP) and I really didn't think much about it. Regarding "procedural code", the examples are about **services** They are not "based" on global state since they are stateless. They are very helpful in Domain Driven Design since they contain code that **does not conceptually belong to any object** (so forcing that code into "OOP" just for the sake of OOP is not very good either). And I never said anything about my code being OOP (?).
well, preference or not, reflection is not free. you could always generate a PHP script that does all this as a means of caching the whole thing, then next time around you can just include that script to do all the DI work. Generally, Spring stuff is going to be running as some kind of service that can resolve all the DI stuff at start up time and remember it as long as the service is running. Chances are, you are not doing that with PHP.
PHP sure does act differently, thats why you need to tell PHP-FPM specifically what is going on when using it in Nginx. fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include /etc/nginx/fastcgi_params; &gt; It only cares so much. Much like Symfony has no idea what I'm using it for... just like every other framework, the only thing it knows for sure is that its a web request. That's way out of context now, we might as well have a conversation about how a cow doesn't know what a Tuesday afternoon feels like. The server has to pass values and variables to PHP in a way it expects, or its going to be broken. That is not abstraction, thats a specification. Symfony however does provide a generic layer of abstraction, which is very useful indeed. &gt; $_SERVER was always meant to be server-specific headers... hence the name. No shit? But, the values you get are different on different servers. Very different. They're even different on different configurations of Apache with CGI, FastCGI, mod_php, Windows, whatever. Again, thats not abstraction. I've suffered from this time and time again while working on PyroCMS. It's not an issue if you know about the problems, but saying PHP magically abstracts away server differences is patently false. &gt; It does when its designed as such. Designed at a time to be comparable to other systems such as ASP and JSP. I suppose technically its a 'Server Page' system, but there's not much of a difference. We arent talking about PHP 1, we're talking about PHP 5.4+ so those arguments are completely irrelevant. I'm not going to hold a conversation about HTML 1 or CSS 1 any time soon either. &gt; I thought I tried to clear this up. This isn't specifically about the PHP language. Its about PHP as a distribution. The project doesn't make any distinction between them, although I try to.. You're alone in this crusade. &gt; I'm not saying to use it as such, but really: what does it not do? Abstract away $_SERVER? file-less URL routing? What is a web framework to you? A web framework provides you with a structure to build out your applications within a specific language, and sometimes on a specific platform. It maps input and routing through to various actions, then gives you a system for handling output. That is very vaugue of course, but the main difference here is PHP does not provide you with any structure. Does PHP implement an MVC folder structure? No. Does it handle your DB migrations and seeing? No. Does it handle environment specific config files? No. They are the job of the framework. Just because you can build websites with native PHP does not mean that native PHP is a framework. Thats fine. At the end of the day we're arguing semantics over an extremely generic word, but I don't know anyone else who would argue that PHP is a web-framework of any kind. I dont know why you would, why anyone would need to call it that, what benefits it adds or anything else. It's just not - and thats ok.
To be fair Symfony did the same thing with 1 and 2. Now CakePHP... Slightly better legacy support.
When I wrote about procedural code and global state, what I meant was the existence in static method calls and singletons in your codebase. If you the code that i browsed through is any indication, then you currently do not have a DIC. What you have is a service locator (which some people, including me, consider to be an antipattern).
I second Stripe over Paypal, as long as you are in a position to use it. 
I was thrown in at the deep end when someone refactored my project into Silex. It forced me to learn the concepts of a framework. Silex is perfect for small projects or just a personal website with a few pages. I've now moved on to using Symfony2 which for the most part, I think is excellent. Oh and twig is awesome. 
No, you can't do the following: class Example { protected $foo = some_func(); } And you shouldn't be dynamically adding properties, normally a code smell.
PHP in the wild, isn't.
Exactly how is Reddit not a forum?
What do you need doing? I work with opencart usually on a front end basis, but I know bits and pieces. Might be able to help.
I have a vQMod extension installed that enables multiple vendors within a store. It's working fine, but I need to make some alterations to the way it calculates order totals in order to send notification emails and create reporting for the vendors. It involves a few model and controller files. 
There is a cache on top of the "definition" sources, i.e. Reflection, annotations and array configuration. So the cost of using reflection is only on the first time.
Speak of coincidence I removed the singleton on the container yesterday, that was an overdue task (and that's the only singleton there was in there). So again you were right I was just a bit late ;) Regarding the service locator I totally understand what you mean. The thing is the container is not meant to be used like this: $container-&gt;get('foo'), but that's the only thing I can use in the examples. The docs are not complete enough, but in the end there will be a paragraph like the one in the Symfony docs: http://symfony.com/doc/master/components/dependency_injection/introduction.html#avoiding-your-code-becoming-dependent-on-the-container I need to work on it but it will be something like: "You will need to get a service from the container at some point but this should be as few times as possible at the entry point to your application." And that's why I provide integration with ZF1 (and plan on integrating with more): the goal is that you never have to $container-&gt;get() because the container is only called once at the root of the application (front controller, bootstrap...).
And less seriously a "soft rename" would mean something like: "PHP-DIC" and I'm not naming my project dick ;)
My current conclusion is that DIC's have to be used within factories. They are another part of creation/instantiation process, that you would usually want to abstract away. This seems to be an exact opposite of how you see it. To understand where my viewpoint is coming from, you could watch [this lecture](http://www.youtube.com/watch?v=RlfLCWKxHJ0). 
Unless I'm wrong (I'll watch the video) we're not so far appart. Here is an extract of the new README i'm writing: Here is how a code using DI will roughly work: * Application needs Foo, which needs Bar, which needs Bim, so: * Application creates Bim * Application creates Bar and gives it Bim * Application creates Foo and gives it Bar * Application calls Foo * Foo calls Bar * Bar does something Here is how a code using PHP-DI will roughly work: * Application needs Foo so: * Application gets Foo from the Container, so: * Container creates Bim * Container creates Bar and gives it Bim * Container creates Foo and gives it Bar * Application calls Foo * Foo calls Bar * Bar does something If I understand you correctly you would add a Factory layer between the application and the container.
"March 30th from 9am Central European Time to 5pm Eastern Standard Time". ^ This is so confusing... So, it goes from 4am to 5pm EST?
I agree, a bit confusing. I'm sure someone in #symfony-docs on Freenode can confirm.
&gt;No, you can't do the following: Nor do I think you should. 
&gt;I don't know if you're arguing for something though because I stated that he could use an autoloader by developing one or copying one and you're saying that he doesn't have to, which isn't really helping out the argument that PHP is a better language than before. I was just noting your wording, where you said that he *needed to* use an autoloader when using namespaces. He definitely *should* be using an autoloader, but it's not like it's something that's required for the use of namespaces.
I'm not sure why people are downvoting this since this is actually the most precise answer in the thread.
There are tons of them out there, you just have to look around and find one that fits your needs. You may even find its to your advantage to build your own. I can say from experience that Paypal, Amazon and Dwolla all have pretty easy to use APIs. 
For which market? PayMill and Stripe have awesome APIs, unfortunately they're both under certain geographical restrictions.
If you're targeting the US, go Stripe or go home.
Did twitter bootstrap really come out that long ago? I thought it'd only been around for maybe 3-4 years. Either way if you base your PHP experience on CI then - yeah - it'll probably seem slightly out-dated. CI is famously long in the tooth (though not bad - just failing to keep up with the alternatives). If you had more experience with modern PHP frameworks Django would most likely seem like less of a massive leap forward.
It's actually very useful. Just look at the ORM models defined in Django/Rails to see how powerful it can be. Edit: meant the dynamic value, not dynamic properties.
How does command line help? Cafes only allow outbound port 80 (HTTP) and 53 (DNS). And a lot of hosting companies don't like giving SSH access anyway.
You should take a look at the observer pattern: http://phpmaster.com/understanding-the-observer-pattern/
ah, i never considered that; i dont mix business and pleasure. i guess you should be working local then. look into XAMP or WAMP. then you can save the bandwidth for redditing.
I've been using this when clients need a file browser integrated into their websites: http://elfinder.org/
yes i have that might work. but i have to manually code it that way. I want to automate the process 
just use a php script to scan the directory and then create the appropriate JW player code. Even better: use php to scan your directory, then output a playlist file. JW Player can take the playlist file and use that to play your videos. When a new video is uploaded, the php script will find it and add it to the XML playlist and then it will be available in the video player.
You could try with [httpfs](https://github.com/cyrus-and/httpfs). &gt; Remote FUSE filesystem via server-side script
I'm new to php, could you link me to some tutorial or give me some script to play with?
Personally, I prefer assigning values to properties like that via the constructor.
Uhhh first of all, I need a video of this in action because it sounds ridiculous and awesome. Second, if it works from command line, maybe issue is whatever you're using to face the web? Is whatever you're using (Apache, whatever) logging any errors?
ZF2 has an Event Manager package. This blog post explains it pretty well: http://www.mwop.net/blog/266-Using-the-ZF2-EventManager.html
Is the machine in question using SElinux maybe? grep -i denied /var/log/audit/*.log
PHP is running under www-data (tested by "`system('whoami');`"). When I log in as www-data and run `eject` myself, it works fine.
`grep: /var/log/audit/*.log: No such file or directory`
Yeah, tested by `system('whoami');`
Yeah, yeah, we could go on a bit deeper, if you like. I think it fundementally boils down to the last thing you said: &gt; PHP is no more or less of a framework than any other language listed there To me, it is clearly more of a web framework than *every* other language listed there. I suppose we could agree to disagree, for a while at least. &gt; You can use that definition as much as you like, but I don't know why you need to when other established terminology is available The [Wikipedia](https://en.wikipedia.org/wiki/Web_application_framework) definition, as well as many others apply do apply to PHP. I'm not trying to say "stuff goes in, some abstraction happens, then stuff comes out" makes it a web framework. When using other frameworks as a comparison, not as some weird one-off definition. &gt; We've already agreed that it should be renamed to "apache-php" and I've filed an issue. I see there's a comment there already implementing something I thought of in our comments: apache-mod_php seems a bit more appropriately named. &gt; Anything else at this point is just going to be pointless squabbling over semantics. Perhaps, but its also interesting as well. Pleasure talking with you. And good job on PyroCMS. I haven't taken much of a look at it yet, but I've heard a bit of praise from colleagues. You're doing a lot of good. Thanks for all of the work. I suppose now we can go back to being a bit more productive. 
I'm not OP, but by coincidence I also have something like this set up, I learned about the `eject` command today ([this](http://www.reddit.com/r/linux/comments/1b9iyl/my_friend_foolishly_let_me_ssh_into_his_account/c94wh6s) thread, maybe OP was inspired by that too?) and have been toying with it for a while. I've made a network-controllable music player. I'll post a video in a few minutes.
http://www.youtube.com/watch?v=bPj0RsXqA80&amp;feature=youtu.be
You could try Git?
Do you use a hardened version of Apache like suhosin or modsec? If so what do their respective logs say? My money is on suhosin.
How would I check?
Ahahahah I fucking love it
I would check what the difference is between your cli and your mod/fpm (or whatever you are running) run php -i
I don't know where to look for that, does the command output any information that I wouldn't want to post here?
Apparently safe_mode is off :/
Just checked, it's not
there has to be a better way of doing this 
........................................... I am a retard. I forgot `www-data` was still logged in. That worked. Thank you.
Not to doubt you, but I got the same exact error as you when logged in as www-data ("sudo su www-data") on a fresh VM. However, as soon as I ran "sudo gpasswd -a www-data cdrom" then eject worked without a problem. This was on a Ubuntu box so you will want to check what group owns /dev/sr0 and then make sure www-data is in that group. 
I found the issue, basically I forgot you needed to log out and back in again to be added to a group. Restarting Apache fixed it.
This is very likely a permissions issue. // redirect stderr to stdout and it should help you determine the problem system("eject 2&gt;&amp;1"); 
Sounds like you need to learn how to create a reverse SSH Tunnel. 
Brilliant.
Now please video this automation because it sounds both hilarious and awesome.
Not OP, however here's my version: http://www.reddit.com/r/geek/comments/1bbv83/my_ghettostyle_network_controlled_cd_player_setup/
This might work also, http://php.net/manual/en/function.shell-exec.php 
amazing concept. It's what one of my old mentors tried to beat into all his students in high school. One of the tricks is really learning, and not just pattern matching bigger ideas and concepts. 
I did a talk teaching this concept in PHP. There are some animated diagrams to help you learn the concepts too. [Video](http://www.youtube.com/watch?v=q3hfa3wdT0s&amp;feature=plcp) [Slides](https://speakerdeck.com/u/johnkary/p/writing-extensible-code-using-event-dispatcher) Hope this helps you!
&gt; You can filter numeric digits as house numbers. Nope, letters and spaces are perfectly valid. Addresses are pretty similar to names in that people can make them whatever they like. Should be fine with zip codes though. Actual Example: &gt; W156 N8480 Pilgrim Road &gt; &gt;Menomonee Falls, WI 53051-3140
Beta5 is more or less available, I think
The select page in documentation isn't loading for me: http://medoo.in/api/select 
you have to edit the class to add the server/username/password?!
Yes, configure it before using it, and will not have to care those stuff any more again for project development.
Database parameters will be better in a config file that isn't committed to the repo (to protect DB access credentials). Then users commit a template version of the config file that people can copy and give it a '.dist' suffix, this seems to be adopted as the standard way of getting around this problem
If you add these to the constructor for each database call, it will become a nightmare. How about the database password, username or server updated one day? Change every code of those info?
That changelog was started 2 months ago for stuff fixed during the beta 4 dev period. With beta 4 released, there's now a changelog for the beta 5 dev period.
didn't think of it that way, you are right. 
This isn't really a framework. It's just a simple database abstraction layer. Not sure how useful it is really. I'd probably rather just extend PDO myself or use Doctrine DBAL. Might be useful for somebody I guess.
For most part, you'd only need one database connection, yes, but why in the world would you design your class to disable the option of having two simultaneous database connections? Isn't it up to the programmer to use the class in whatever manner he or she sees fit? I can see the need for maintaining simultaneous database connections, e.g. for querying a third-party database resource (e.g. a forum's database), or migrating data between two databases. 
It's cute, but essentially worthless as it cannot (as far as I can tell) do JOINs. 
The system will only scan the PATH environment variable to find the program you're running, not any arguments you give to it. That is, you're piping to the php binary, not to the script itself. You'll need to specify the full path to paste.php.
For US users Stripe is best, unless you utilize PayPal's micropayment rates. Even then Stripe might be better.
&gt; if everyone jumps ship from Symfony2 to Laravel? For newcomers - it's just one more option to choose from. For current users - don't think anyone would want to move a running project from Symfony to Laravel. It's not like switching from CI to Laravel (what guys from PyroCMS are doing).
It's seems like a personal project you put some effort into so I'm not going to bash, I just think it may not be very useful since a lot of alternatives already exists. Now you put forward one difference with other libraries: the size. However, size may be a decisive criteria in Javascript, it is not in PHP. You only download the library once to your server, and after that you can use opcode caches (even without, I'm not sure that's really a reason to choose a PHP library).
I guess I'm not thinking about the users so much as the developers of the projects. But it seems like my concerns were unwarranted in any event.
&gt;Stop and think about what you're saying for a minute. "This hammer only works with nails and not screws, so it's obviously inferior." What a fundamentally flawed perspective! What the hell are you on about? I'm merely pointing out issues which are easily remedied. This is not so much a case where the hammer only works with nails and not screws, but a case of the hammer only being able to be used once. It's a plastic disposable spork. &gt; YAGNI is relevant here. No, it really isn't. It doesn't have anything to do with extended features which isn't going to be needed, stop being silly. What I am arguing for is **basic** OOP and design. 
That's exactly the first thing that came to mind with me - size of file/LOC's means little server side to most people - unlike JavaScript where getting code crunched is the name of the game. Still, a nice looking project page - the project logo is rather cool.
Really trying to come up with a constructive criticism of this but there are so many bad points I don't know where to start. It's just a load of scripts full of HTML and db queries. Haven't we moved beyond this as a system for constructing php software yet? I would consider reading up on OO PHP. Look at some of the frameworks or popular libraries. Generally absorb some information on how modern PHP web applications are built. It's difficult to move away from thinking of a php site as just a load of pages at first but an extremely worthwhile thing to do.
Will do! Thanks for your feedback
I learned Symfony2 first, then tried Laravel. I found the similarities to be quite numerous. I like Laravel more because I felt it was simpler as far as syntax. However, they both do templating with very similar syntax, they both follow the MVC structure. By doing clever replaces, I was able to convert my Symfony2 site to Laravel pretty easily.
Can you recommend me a guide/tutorial to start with Chef?
I cannot disagree with this statement enough. It is a pretty nit picky question about a specific function and has nothing to do with programming ability. Why are people always interested in what situation I would use a desired design pattern or function, the inverse question gives far more insight about the candidate. "What could you use to solve this situation?". Even if the candidate has no knowledge about your obscure function they might yet have a valid solution. All that having been said its good to know what common design patterns are used.
Know the difference between an inner and outer join. Have basic working knowledge about indexing. You might want to know some basic design patterns maybe factory, but I wouldn't care if my php intern couldn't tell me what the difference between active record and datamapper was. 
...it's sarcasm. That was a jab at how PHP has extraordinarily crazy/awesome functions.
Of course it's relevant. When was the last time you coded anything that used different database connections? It's useful, of course. For someone. Somewhere. But it's a prime example of YAGNI. I'd wager less than 1% of apps *ever created* have this requirement. You and I agree about injecting the credentials. I'm just pointing out that you picked the worst possible supporting argument for it. The reasons are plenty, but doing it so the project can support multiple connections is as silly as you think I'm being. Instead, you should have stuck with the *good* reasons, like keeping the credentials out of the repo, keeping configuration out of the code, being able to use different data sources in different environments, and so on.
Size matters a little bit for me personally. I have my development files locally and I get charged on my host by how much space I am using, per megabyte. I would not minify code though. If it is a very large library, I will make it into a gzipped phar file. If it is small and simple enough, I'll just combine it into one file. I know it might have a small performance impact but I have very low traffic and don't pay for CPU time, just disk usage and bandwidth, so some extra milliseconds to parse the file is fine with me.
Framework users = developers of course. No one will think about the end-users in this question, since they don't care about what you have under the hood, be it Symfony, Laravel or anything else :)
Laravel is basically a simplified Symfony2. If you have already mastered Symfony2, why would you want simplified version of it?
They charge you per MB though? That is an awfully limited plan if it is.
I love this one: http://php.net/manual/en/function.date-sunrise.php
The size of the project doesn't matter. It's the complexity. You can have massive enterprise software that's relatively straight forward to implement. Laravel's opinionated structure can help you build that faster. But if the complexity of the project goes far beyond that, you'd probably be better off with a more flexible and less opinionated stack like straight Symfony 2.
[Beginning PHP 5.3](http://www.amazon.com/Beginning-PHP-5-3-Wrox-Programmer/dp/0470413964) seems like the less harmful on that i have encountered.
What about a Silex / Laravel 4 comparison then? What are the important similarities / differences there?
To be honest you're there to learn so they're not exactly going to expect you to already be an expert on PHP and SQL. Personally I'd probably expect someone applying for such a position to know things like what functions and classes actually are and how they can be created but probably not have memorised many of the built in ones yet. Similarly just knowing the basic bits of SQL - SELECT, FROM, WHERE, ORDER, LIMIT - will get you remarkably far. 
This sounds like you are trying to build webmin on PHP. You better off with whats already there son. ps. Seriously don't install Webmin.
in my second job interview i was asked about - mysql storage engines and differences between them, - whats new in php 5 compared to 4, - if multiple inheritance is possible in php5 - what are interfaces and some stuff about js i dont even remember.
The size of the project is very much irrelevant in the decision. Symfony2 is for people who love being able to configure, tweak, and have FULL control over everything, whereas Laravel 4 makes use of some conventions to speed up your development. I'm not generally a fan of conventions which is why I avoided things like CakePHP in favor of CodeIgniter back in the day, but these conventions are minimual, usually default to off with an easy on-switch or can be avoided with no trouble, and generally make sense. I've used Laravel 4 since the August somewhere and have used it to bash out prototypes, create complicated API structures and generic bootstrap-based Admin panels. It's surprisingly well rounded and those conventions don't get in my way at all - but may potentially annoy some SF2 fans who are used to doing it all themselves.
Don't take the comparisons to the two that literally dude, im saying the difference between the two is the same. Laravel 4 takes the existing system, adds a new interface layer and puts in some extra components, some of their own and some from third parties. That's about as far as you need to go with that analogy :)
The way that Silex and Laravel 4 handle routing is very similar. Laravel 4 will take strings as arguments and Silex requires you to instantiate a while bunch of instances, which to me feels unnecessary. Trivial, but hey. Beyond that there are a lot of similarities. They both contain service providers which are almost 1:1 the same, they can both support middleware (L4 call it Events and Filters), L4 has a IoC much like Pimple, and it has service providers that provide much of the same functionality out of the box: Forms, Twig (L4 has Blade), Session, Validation, Monolog, Translation, Doctrine (L4 has Eloquent), etc. Silex and L4 are functionally on the same level as far as functionality goes, but you'll need to pick and chose which you prefer. It's very much the same sort of base with a bunch of different (or more wrapped up) tools, making this considerably easier for newcomers and especially the old CodeIgniter userbase which is generally moving over to this.
You may not be the only person on your team. For example, by using Laravel 4 for PyroCMS the barrier to entry for contributors and developers is much lower than if I just decided to use Symfony2 because I know how it works. See the difference?
&gt; It's very much the same sort of base with a bunch of different (or more wrapped up) tools, making this considerably easier for newcomers and especially the old CodeIgniter userbase which is generally moving over to this. Does *it* in this sentence refer to L4?
Nice article but, c'mon man, whats with [the drawings?](https://igor.io/img/dic/dic_destroy.png)
I'll try it.
Cool thanks. Did you have a programming background though when you read Headfirst PHP?
So, they want a walking changelog, not a good programmer?
Very much so yes. Many CI users moved over to L3 but L4 is drawing far more in, with its brazen adoption of PSR-1, Composer, Monolog, etc. I'm a big fan of any framework that adopts Composer and PSR's as part of its core philosophy, but im saying all these nice things about L4 as it gives the average CodeIgniter fan a framework on a functional and philosophical par, without a steep learning curve.
I've tried Laravel a little but do most of my applications with Symfony2 and Silex. I find Symfony2 to be more flexible. The bundle system is great too. Laravel also has a bundle system, but I have not played with it that much. I'm intrigued by Laravel and am tracking its progress, but I'm not a huge fan with the number of static methods Laravel seems to use for everything. My impression is that Symfony2 is a better choice for creating applications that do not necessarily fit a certain mold and Laravel is more suited for creating applications quickly that provide certain types of common functionality, e.g. implementing a blog, content management system, or an e-commerce platform.
I'd say I'm probably still a noob at php for the last 7 years and there's still things I haven't the clue on doing properly (like unit testing, etc.. etc..) w/ that said I thought Laravel was easier to get into compared to symfony personally (I've worked w/ codeigniter, kohanaphp, cake, bits of zend). I think what sets it apart to most people who use it is how straight forward the documentation is similar to codeigniter - not many frameworks allow non advanced coders to just hop in the docs and know exactly what everything does. 
:D going to read this in a few minutes
https://www.nearlyfreespeech.net/services/hosting its a good service, but using more space does cost more. not a lot, but it adds up. I host with them so it stays very cheap, around $20/year. I really only host a few scripts for personal use between several computers, and my homepage that gets 100 unique hits per month, most probably by accident. `Disk Space (Storage): $0.01 per megabyte-month` - so hosting laravel would cost me around 30c per month with all the docs and test cases included, whereas the minified version of nette framework (for example) would be 1 cent per 2 months. I know it sounds like pocket change but if the yearly price got much higher I could get a better deal elsewhere at around $25/year, but I do like NFS for philosophical reasons - they stand behind their customers, they opposed SOPA and even let people black out their domains via the control panel, they have good support when needed, and have very few restrictions given the low price and it being a shared plan - I even log in via ssh and compile programs, don't force you to store all your files in a public folder, let you set up virtual hosts and unlimited htaccess, etc. It's not quite a VPS but I can ignore it for a month and they'll do updates and admin, and its a lot cheaper than the cheapest vps.
I like laravel, but mainly because of how they utilize closures. Some great examples: [Schema Builder](http://four.laravel.com/docs/schema) or [Advanced Wheres in Query Builder](http://four.laravel.com/docs/queries#advanced-wheres). They seem normal at first right? except you don't have to pass around a variable, it's given to you, you do things, and that's it(works great since objects are automatically passed by reference). For the most part it has the same items every other framework has(MVC, ORM, routing, etc). I also loved the fact they are utilizing Symfony components. I don't personally like Symfony's API, but the fact that they are working together to improve one library instead of growing their own is part of what makes open source awesome.
phaha, thanks!
I'd like to see a part with Phake as mock library.
Similarly it is worth mentioning https://github.com/padraic/mockery. It has many more features that PHPUnit's built-in mock library, and is mostly a drop-in replacement.
I think the confusion you have here is down to a misunderstanding. Routing and MVC have nothing to do with each other. 1.) index.php will include some bootstrap files to set up the environment, maybe register a few event triggers, load the core config, etc. It will then load a routing file. These in earlier frameworks used to be an array with syntax often similar to: "foo/:any" =&gt; 'bar/$1' That is handled by a routing class, which is called by the bootstrap logic to try and match a route to the current URI, often using regex. In this example (CodeIgniter) `:any` is replaced with `[a-zA-Z0-9_-]` or similar (off the top of my head). It will loop through all the routes until it returns a preg_match value of true. This is still not really MVC. The value of `bar/show/$1` is saying "use the bar.php controller, this is the C of MVC gets involved. This will find the bar.php file, and the show method, then send $1 as an argument. Route::post('moments/{id}/gift', 'MomentsController@sendGift'); This is a Laravel 4 route example. Notice here it's a bit more specific with actually mentioning a PHP class, your params are named and there is less guesswork between where the route actually goes. Once the controller is loaded you can do what you like, which leads on to the next few questions. 2.) "How is the view structured?" However you like. It's HTML/XML/Magic and you can mix it with Mustache, HAML, Smarty, Twig, Blade, whatever. Views do not handle user interaction, that would be a job for JavaScript - which should be included as JavaScript files and not smushed into your views. Views show stuff, and that is ALL they do. Limit your logic and keep CSS/JS out of there. Presentors or Composers (two terms for the same thing) are present in some frameworks like FuelPHP or Laravel to help you keep presentation logic out of the controller and out of the view, That makes it a MVCP framework if you like buzzwords. 3.) Avoid using auto-magical routing for URL's to controllers. List each and every one specifically, and your routes are then self documenting. I used to love using sub-dirs and crafting my file system to look close to what the URL structure would be so I could avoid writing my own routes, but eventually you HAVE to use custom routes and there is no point half-and-halfing it. No magic, build routes yourself. For example: Route::get('merchants', 'MerchantsController@index'); Route::get('merchants/{id}', 'MerchantsController@index'); Route::get('merchants/{merchant_id}/moments', 'MomentsController@index'); Route::get('merchants/{merchant_id}/opps', 'OppsController@index'); Route::get('merchants/{merchant_id}/locations', 'LocationsController@index'); Route::get('merchants/{merchant_id}/stats', 'StatsController@merchants'); The URL does not need to represent the controller at all, and often leads to people putting WAY too much logic in the same controller, or copying logic between controllers.
http://fabien.potencier.org/article/51/create-your-own-framework-on-top-of-the-symfony2-components-part-2 Go through this IMO. Very instructive. Illustrates how a front controller works, and does a pretty good job of showing how it decouples the path from the results provided. As for a complete description of MVC, I doubt you'll find it. Its either going to be too simplistic, or too specific to the framework that you are seeing it described with. At its heart is just a way of organizing code.
I enjoyed the read 
I have found these very useful. I'm pretty new to PHPUnit and we just started using it at the office, and I really love seeing all the green and the code coverage grow. These tutorials really help me fix up my code so that it's appropriate for testing, and teaches me better ways to test. So, thanks :3
&gt;How does routing requests work in MVC? 1. The rewrite engine reroutes the requests through the front controller, making it a centralized entry point for your application. 2. That script then invokes the router, which is responsible for matching the request against a set of URL patterns. 3. Once a match is found, the dispatcher invokes the appropriate controller, and off we go. &gt;How does the front controller determine the best route for the request It doesn't. That's the job of the router. A front controller is merely a centralized entry point for handling requests, but the pattern itself does not itself handle routing. &gt;how do I handle the routing? You configure your router with a set of patterns. What these patterns look like differs from framework to framework. Which pattern takes precedence usually depends on the order they are added, but you might also be able to set the priority in some frameworks. &gt;How is the view structured? The view is just a way of presenting your data. Usually, that means presenting it in the form of a HTML website, and the views are then just markup mixed together with some presentational logic. This can be powered by whatever you'd like to. PHP, Mustache, Twig or whatever. &gt;Should I be creating a View Helper class that selects, for instance, the login form if a user clicks login or a registration form if the user clicks Register? No, that's the job of your controller and the routing. View helpers are for helping you perform complex operations, for example, building a link from a URL pattern and parameters. &gt;How should the URL be structured so the front controller can handle requests and call the appropriate class? Any way you'd like to. &gt;For instance, I’ve seen URL’s structured as http://www.example.com/class/method/param1/param2. Is this the common way to create the URL? No, the standard is: domain.com/module/controller/action
^^^ This makes me want to murder a kitten. Routers have no business specifying HTTP method types. What if I want to do Route::post('media/upload', 'upload@success'); Route::put('media/upload', 'upload@success'); * Why should I have to specify it twice? * Why should I have to define all the rewrites on every page load even though only one of them (or none) will ever be invoked? * Why should I have to learn a new arbitrary language for handling rewrites when PHP is perfectly capable of doing it without a massive class? My opinion is that router classes are garbage. &lt;?php class SiteRequestHandler extends RequestHandler { public static function handleRequest() { switch($action = $action?$action:static::shiftPath()) { case 'x': return Admin\ReportsRequestHandler::handleRequest(); case 'sandbox': return TestRequestHandler::handleRequest(); /* Admin */ case 'admin': return Admin\AdminRequestHandler::handleRequest(); /* Media */ case 'media': return MediaRequestHandler::handleRequest(); /* CRON */ case 'cron': return CronsRequestHandler::handleRequest(); /* CRUD */ case 'crud': return static::CRUDhandleRequest(); /* Home */ case '': case 'home.php': case 'home': return HomeRequestHandler::handleRequest(); For path: /hello/world static::shiftPath() returns 'hello' first time and 'world' second time and null in the end. And look I didn't waste any resources registering a bunch of rules for no reason.
man i hate april fools day.
YES YES YES. I can haz tabs now. I can now stop DoSing the FIG issue queue on github \o/
That sounds great and all, but I don't have any of the problems you're talking about. Let's be happy we both have solutions that work perfectly for our needs.
Yeah... it's a day I really have to temper my hopes and wishes.
For a second there. Just for a second...
It's a state gun, firing mutations at the services in the container.
I don't trust anything on April fool's day.
Back in the day, I, among others, used to push backspace to unident one line. Its wonderful that we've come so far with spaces. I have much more choice now. I can: * **backspace ** 4**: Most compatible, except for the exception noted below. This option is most profitable with clients that are billed per-keystroke. * **Shift + Tab**: Not as effective price-wise, provides a good balance if needed, but application support is more limited * **(ESC|CTRL+C) + &lt; &lt;**: much less compatible than shift + tab * **1x Backspace**: Some smart applications optionally allow the user to configure backspace to erase 4 spaces. This feature seems to result in several more keystrokes. With all of these choices PSR-2 has definitely increased my productivity-- especially when working on hundreds of differently configured servers with editors that all seem to prefer tabs. This change may force me to stop using PSR-2, I'm not sure if I'll be able to make up the lost income. TL;DR Once? I wish it was once. I really do.
SPACES FOREVER!!
its hell
Guess it wasn't as much as a joke as I thought...
I don't understand how people think videos are going to help them learn. Sure some recorded talks can be informative, but you have to jump in and get wet. Read the awesome php docs, read frameworks' source code, etc.
Well it's always April 1st in my world then...
Too soon, guys. The wounds haven't healed yet. Too soon.
Nothing more than learning it on my own through websites and books. I would always buy the newest "PHP X" book when it came out and look through it.
Funny how some people felt the need to point out that it is April fool's, as if the dripping sarcasm weren't obvious.
http://i.qkme.me/35kgha.jpg
Author of Laravel here. I think this is a great question, and probably one I'll hear more as Laravel 4 releases. As you mentioned, it is in Laravel's best interest that the Symfony eco-system thrive, and I certainly hope it continues to do so, as we use 6-7 of their components. I'll try to share a few of the major differences I see. In terms of architecture, Laravel is much more similar to Silex. In fact, Laravel 4 even uses "Service Providers", the same term Silex uses, to describe classes which add functionality to the application, usually by binding "services" into the application IoC container. Again, like Silex, the application *is* an IoC container. The only difference being where Silex uses Pimple, Laravel uses a more powerful container that can do Reflection based object resolution, etc. I think this Service Provider concept is a really cool feature of Silex and Laravel 4, and have no problem giving credit where credit is due there. In terms of "feel", Laravel is quite a bit more terse, and generally has more syntactical sugar. Laravel also more opinionated out of the box. We ship cache and session drivers for memcached and Redis; we have a unified Queue API (similar to Rails 4) with drivers for Beanstalkd, SQS, IronMQ. We bake in an ActiveRecord style ORM named "Eloquent", as well as a great migration system that is platform agnostic. From my perspective, Symfony tries to have very few opinions out of the box, and I think that's the very thing that makes their individual components so useful across a wide variety of projects. Basically, when writing Laravel 4, I tried to focus on what makes Laravel unique. HTTP request parsing isn't one of those things, so I chose to use HttpFoundation... same with matching URIs to routes. Symfony has a **great** Console component, so that was an obvious choice. This freed up a lot of time to focus on what makes Laravel unique, such as our ORM, templating engine, clean syntax, etc. I believe Phil's Debian / Ubuntu comparison is somewhat applicable, and I think Symfony or Laravel will work well on any project you want to throw at them. Both will continue to be very popular frameworks. It's really just a matter of which one you prefer, and, as some have pointed out, you can now mix and match aspects of each framework. You can use Laravel's ORM in Symfony, or Symfony's Form / Validation in Laravel thanks to the awesome work of the Composer team. Laravel and Symfony are both really good for PHP. Symfony is doing amazing work in giving us some great, well tested components, and Laravel seems to be making PHP development fun again for a lot of people. It's a really exciting time for PHP.
Agree that there are 100 ideas guys for every real dev. Cool to see that he was able to get to the point to build something like http://booknug.com in (a year?)
This is so cruel..
http://imgur.com/gallery/XS5LK
My complaint with the FIG isn't that it sets standards for itself. My complaint is that it affixes PHP to its name, thereby lending itself some unearned credibility that makes the n00b class believe they actually speak for the whole community. Call yourselves the FIG or GTFO.
If we were talking about JavaScript Framework Interoperability we'd be the JS-FIG. If we were talking about Python web frameworks maybe we could call it PyFig. But no, the PHP-FIG is a group of PHP projects so it has PHP in the name. 
And you'd still be claiming unearned claimed credibility of any other languages you decided to co-opt. Call yourselves the FIG or GTFO.
April Fools!
My issue is that the last statement is horseshit. The FIG may plead that they're only trying to address their own issues, but they seem to relish in the pseudo-recognition of being informally thought of as "the" PHP-FIG, and seeing how often you find yourself having to defend them don't you find it strange that you're constantly being put in this position. If you are working for your own aims, fine. Keep your arguments and standards to yourself, and for god's sake stop the goddamn press releases. But, like I said, that's horseshit; if anything, the FIG seems adamant on butting its way into any realm it can find and in so doing has wrecked much of the group's initial promise.
What press releases? If you're talking about this blog then you must have completely ignored the date. I dont know who you've been talking to about the FIG but if you're getting your information only from Reddit then you're going to have a bad time. Read the FAQ and calm yourself down. Nobody is breaking down your door and forcing our standards down your throat.
No OOP in your code? I cant even begin to think why you would be worried about handling file includes if you are writing functional code? Try writing some classes and using spl_autoload_register.
I recognize your name as a respected member of the PHP community. Why are you wasting your breath on this troll?
Actually, even toString won't do it. As it is now, I have my own output method called "make". If you take a look in the tests you can see how to use a single instance to perform operations on multiple links, you just have to call the -&gt;to method for each new link.
Hmm.. There's no input from the user, so it should be pretty safe, unless I'm missing something. Is this the best way? Nope, not at all. You're going to run into function name collision, also, all functions are loaded at runtime, at all time.. I can see a performance issue here. You're better off learning about autoloading and using proper OOP. http://www.phptherightway.com/#namespaces
With an opcode cache such as APC, the performance implications would be negligible. 
This shouldn't be any less safe than including a file, assuming your filesystem permissions are set restrictively. As [maktouch mentioned](http://www.reddit.com/r/PHP/comments/1bhr7q/do_you_consider_this_code_to_be_unsafe_php/c96shmc), autoloading may be a better solution to your problem.
`DirectoryIterator` has to do some extra filesystem work that wouldn't be needed otherwise, but I agree that under most ordinary conditions this should not be significant.
I like to do this comparison. In Symfony, there's 4 ways of defining a route. I know I know, defining a route is not "all there is", but I think it's a great example. * with YAML * with PHP * with XML * with Annotations in the Controller. Laravel 4 * routes.php Which one do you prefer? Source: * http://four.laravel.com/docs/routing * http://symfony.com/doc/current/book/routing.html * http://symfony.com/doc/2.0/bundles/SensioFrameworkExtraBundle/annotations/routing.html 
Agree, but it's never late to learn though
http://php.net/manual/en/function.spl-autoload-register.php is all you need then. To use it properly though, you'll need to write your functions as class methods, probably static methods for as long as those classes are stateless.
You know, people have been claiming since the 60's that rock is dead, but it's still all over mainstream radio. Someone claiming something is dead doesn't kill it.
Using functions != functional code
&gt; For instance, I’ve seen URL’s structured as http://www.example.com/class/method/param1/param2. Is this the common way to create the URL? Please don't do that. Method or class names don't belong in the URL. I know CodeIgniter does this, but it's really not the way it should be done. You can discuss about doing parameters as path fragments, or via get / post parameters, but never about including method or class names into the URL. Work with action names, which alias to specific classes to handle that specific URL. That said Nicoon gave a good overview how to do it.
seems a shame to needlessly incur the small overhead of scanning a directory and dynamically including files on every page request. why not have a link to a single file called say includes.php and from there include all your other includes.
use FilesystemIterator, it has FilesystemIterator::SKIP_DOTS so you won't need to check for "." and ".."
&gt;PHP is dead &gt;Of course PHP isn't dead k 
Nice read but I feel like his problem was hiring the right people, rather than not knowing how to code. And Laravel doesn't really have anything to do with this.
Got me :-(
We provides industrial training in Chandigarh,SEO,Web Designing,PHP,Android Applications,Embedded System and animation training program is on live Project.
I wouldn't say 'respected.' ;)
Bromance canceled.
At the most basic level, even if PSR-2 only exists to give style to PSR-3 (Logger) and the upcoming Cache proposals a consistent style then that is enough to justify its existence. If the code coming from the FIG had no standards it would be ridiculous. Other people happen to use PSR-2, and some other people compain, but it was never meant for them :)
Notice how this will include all files in the dir, including any ~ file that your editor could save there, or any image/other type of file that can't be included. consider using something like glob() ? just glob("/assets/functions/*.php") and you get only the php files to include. keep things simple.
Usualy I use a file called 'environment.php' that is included when the application starts. this file only has the code that defines the ENVIRONMENT constant and is ignored on version control so its allways set to "production" unless stated otherwise. Another way is to keep diferent config files and have your deploy script switch the file as it runs. but, in the end of the day, the way you are using now is efficient enought, the only problem is when you want to deploy this to another dev machine it wont work unless the name has .dev on it.
How is PHP-FIG forcing anything? I do not like everything PSR-2. Therefore, I do not abide by everything in PSR-2, it's that simple.
I am sure if you look there is Javascript is dead, Java is dead, css is dead.. etc There are always haters 
Which sucks. I mean, big woop you have to prefix function names with class names, not that big of a deal, but I really wish we could autoload functions.
See, this is why I loathe this sub: self-righteous taints who assume anyone who has consternation over the direction of some of its more dictatorial members are trolls.
If you look closely... "Caution This article is NSFJA."
For one thing, you are NOT a standards group. Let me repeat this. YOU ARE NOT A GODDAMN STANDARDS GROUP. A standards group utilizes the RFC mechanism; a standards group actually tries to build standards that cover as many use cases as possible, and wouldn't tolerate the half-assed approach PSR-0 takes to namespacing and case insensitivity. Oh, and what motherfucker got the brilliant idea to use require in a fucking autoloader? Did it not occur to anyone that PHP supports multiple autoloaders and one further down the chain might know how to load the goddamn file? You're a bunch of fucking amateurs playing at professionalism, and ruining the entire concept of interoperability by putting together limited solutions and acting as if they all "the" way to achieve interoperability, when they're as brittle as fucking glass. And even worse, you have some of your more idiotic members then pushing to have shit like the psr-0 included in the goddamn core. Like hell are you only creating standards for yourselves: you asshats are pushing your shit. Do you know why I take this personally? Because you imbeciles had a great idea AND ROYALLY FUCKED IT UP. I want the PHP prefix out of the name because eventually there's going to come a group that's not a bunch of neophytes who think making a CRUD framework makes them experts in the fucking language, and they'll be more deserving of the community's respect.
In a strict sense iterating over files in a directory that are not specified is insecure. It's more insecure than specifying the files, but since you've specified the directory to pull from, it should be reasonably safe as long as the directory itself is secure, and there's no way to backtrack into a different directory. It may be possible on some systems to create files that are literal "../other_dir/file" names and iterating on a name like that with concatenation would ultimately parse a file in a different location. Files with special characters might be able to do similar things, so validating your filenames to be characters you are expecting (via whitelist) is going to be your best option. This is all assuming that you're expecting your system to be hacked to a level where one can create a file in that directory without changing the existing files or permissions.
can't highlight text while reading. fuck you phil.
His code and methodology could certainly benefit from the introduction of SOLID principles.
To that end, and although I love the SPL filesystem iterators, `glob()` is one of my favorite functions because it makes this type of task trivially easy: foreach (glob('/assets/functions/*.php') as $file) { require_once $file; }
I think that most people would consider this 'ugly' or 'inelegant', but if you're your own boss (or this isn't for an interview) then do whatever you want. This type of coding is usually seen as haphazard and careless though.
So did the PHP-FIG run over both your cat *and* your dog?
Don't those caches have to check the timestamp of every included file, to ensure that there is no new version? And if you include lots of files each time...
My goldfish. . .poor Flippers. . .
And yet the top comment. &gt;Hmm.. There's no input from the user, so it should be pretty safe, unless I'm missing something. Is this the best way? Nope, not at all. You're going to run into function name collision, also, all functions are loaded at runtime, at all time.. I can see a performance issue here. You're better off learning about autoloading and using proper OOP. http://www.phptherightway.com/#namespaces Is essentially saying the same thing as me, with more explanation. I should have said, "If you are just including some random files in a directory, why not just include them manually, its not like you have 200 of them", and if he does have 200 of them.... start writing classes with an auto loader.
great advice. thanks, maca
Its still negligible. Do an strace on your web server (even without PHP), and you'll see its doing a lot of fstats() anyway. I'm not saying his Directory iterator is a great way to write it, but he would have to be getting some massive traffic for disk performance to be a reason to rewrite it.
That's basically what you're doing. Right? The class name is only used as a namespace type of thing, which enables dynamically loading of the function (static class method). In my humble opinion, adding a function autoloader for global functions actually sounds dirty, and performance-wise bad.
You did not answer his question (is this considered unsafe) You did not give him any reasons, why his code isn't optimal (like the cited comment warns him about namespace conflicts) All you did was chanting the "procedural is bad, oop is good" mantra
I definitely don't agree with it going in the core. That would be silly. Also you clearly don't understand the history of PSR-0 and its complicated requirements, or understand the groups wish to provide an [improved alternative](https://groups.google.com/forum/?fromgroups=#!topic/php-fig/JdR-g8ZxKa8). But, instead of whining like a petulant child and using lots of swears and caps lock, why don't you apply for membership and show us how it should be done? I didn't agree with everything that was happening, or like every team member on the project, so I joined to give myself a voice against further bad decisions. You should do the same, or just continue acting like a grumpy troll. Either way.
You seem to have ignored what I said. PSR-3 uses PSR-2. Even if you, I, Drupal, or Kevin don't implement PSR-2 it doesn't matter in the slightest, it's been used by PSR-3 and will be used by PSR interfaces in the future. The end.
:(
Slapping a namespace on something doesn't make it "proper oop".
Yes I did, though I'd accuse you of the same. Nobody gives 2 shits how you format your code within the FIG -- minify it for all we care. **Code formatting has absolutely zero effect on interoperability.** Sure, format your code according to your internal standard, but it's asinine to think that the use of spaces vs. tabs (or PascalCase vs. camelCase vs. unix\_style, etc.) has any effect whatsoever on whether arbitrary code file A will be compatible with arbitrary code file B, but by making this a standard you're now trying to say just the opposite -- _"we believe PHP code will be more interoperable if we force everyone to use spaces"_. &gt; The end. Really? Get over yourself. If you want to know where some of the animosity comes from, it's statements like that. "Hey I'm on the FIG, what I say is law."
@jtreminio thank you for phpunit testing links. already enjoying the read.
So to claim FIG compliance, will random framework X be required to implement PSR-2 within their own code?
I think this link will help you : http://johnsquibb.com/tutorials
Nope. FIG compliance is not a thing. Compliance with any PSR is completely optional, for anyone inside or outside of the FIG.
I'm slightly drunk, I won't lie. OK, not slightly. Fucking Far Cry 3 marathon and work the next day. . .what the hell was I thinking. . . But seriously, I get animated about this because the FIG could have been special, but when I started lurking through the specs and the personalities involved it just became obvious to me that this was a great idea destined to fail because it lacks the ability to stay on topic and keep people's personal agendas out.
Shhh. Don't give away all the secrets.
Fair. I can't speak for everyone, but I personally joined up because I could see that it had amazing potential and wanted to help keep things on topic, avoid over-engineered solutions and try to reason with (or shout down) anyone who was acting moronic. There were a few Cache proposals that were SO complicated it was painful. Not moronic, just more OOP than you could shake a stick at. As for the rest of that I think a lot of people on the outside don't really have any idea what is happening on the inside. It's not hiding, its all on the mailing list, but people don't read up. Also fair. There was a little hubhub when MWOP left but Padriac has replaced him and Zend is represented again. Other than that there are no real problems. We took a few votes on the aim of the group and everything else, and the decision was what the group feels, which resonates with the PHP community: * Hard standards are more important (make things _actually_ work, like PSR-0, PSR-1, PSR-3, etc). * Soft standards are less important, like PSR-2, but still have to be done now and then If you don't like soft standards at all and feel like they have no place, then ignore them, and nobody will ever care. That's the benefit of keeping them separate, and the reason PSR-2 was split out from PSR-1 Basic and PSR-1 Advanced. The FIG KNEW PSR-2 would be controversial, and as such made it ignorable. Wasn't that kind of them? This is going to sound offensive, but it's not: If you're not following the mailing list (and never have) then you have no real place to talk about these things, because you just don't know. Thats not an insult, it's just saying that you're throwing around your opinion (while drunk) and not actually aware of whats happening. I disagree that members joined for the sake of it and are not helping. The only way members can get in is by contributing and making useful discussion. We don't just vote in any random jerk that asks, even Taylor Otwell from Laravel got bounced for not being involved in the discussion enough, and he's a damn smart developer who I respect a great deal. Trust me when I say the group is doing just fine, and cranking on some pretty cool new standards (which don't mention tabs or spaces once). I have a lot of respect for the members, and as problems come up they will be addressed. It can't be all perfect all the time, but most of the problems the FIG are invented by people arguing about it instead of contributing useful discussion. Even the [PSR-0 problem](https://github.com/philsturgeon/psr0-naming-oddity) you mentioned is known, but trivial.
actually in Symfony2 you can easily define your own loader and there are several Bundles that do .. f.e. FOSRestBundle. so there is essentially no limits to the number of ways you can load routes. btw this is sort of true about everything in Symfony2 as even the framework itself is a Bundle.
Correct. There are some smarter [auto loaders](https://github.com/symfony/ClassLoader) that will cache the file lookups for you.
I'm on the mailing list. This is my pseudonymous reddit account, not my primary. I comment very little, preferring to read. Most of my contributions are trying to smooth over differences, lol. Not very encouraged on the direction of the group, which is obvious. And a mailing doesn't make for a remotely good mechanism for this kind of effort, I have no idea who thought that was a good idea. As for being drunk, I'm still clear-headed enough to type without a litany of misspellings, so my inebriation isn't to a point that I'm not still lucid. I'm just feeling a little freer to blast away at my misgivings.
try: &lt;OPTION VALUE=0&gt;Choose&lt;/option&gt; &lt;?php echo $options; ?&gt; in line 32: $options.="&lt;OPTION VALUE=\"$id\"&gt;".$Category_Name." (".$City.")"&lt;/option&gt;;
Actually, he said functional code. He just doesn't like code to function, but is fine if it is procedural as long as there are some classes and stuff. 
Nice! I had forgotten about that one.
First off, ditch the `mysql_*` functions. You use PDO to connect so you should be using PDO to query. Not a huge issue at the moment since you don't have user input, but it's definitely best practice. I would change your while to: while ($row = mysql_fetch_array($result)) { $options .= '&lt;option value="'.$row['Company'].'"&gt;'.$row['Category_Name'].' ('.$row['City'].')'; } ``` You don't need to reassign variables if you only use them once, so you can access the `$row` array directly while building your options. Now, what you should be doing is assigning `$results` or some variable to `mysql_fetch_array` and then doing a `foreach` to build your select. Like so: &lt;?php // Code $results = mysql_fetch_array($result); ?&gt; &lt;select name="myslist"&gt; &lt;?php foreach ($results as $result) : // Alternate syntax ?&gt; &lt;option value="&lt;?php echo $result['Company']; ?&gt;"&gt;&lt;?php echo $row['Category_Name']; ?&gt; (&lt;?php echo $row['City']; ?&gt;)&lt;/select&gt; &lt;?php endforeach; // End foreach (alt syntax) ?&gt; &lt;/select&gt; To actually populate the div with the text, I'd recommend using the `data-` attributes on your &lt;option&gt; tags, and with jQuery use the [`.data()`](http://api.jquery.com/jQuery.data/) method to retrieve that info.
&gt; You can have named routes, and generate the link from the named route. I'd say you MUST have them :)
I'm also running into issues with connection, which is Access Denied for User (using password: NO) and here's the code i'm using for db connection (i have it relegated to a separate include now: &lt;?php // Create connection $con=mysqli_connect("localhost","admin","fEQaMx]n5*7$","dbname"); // Check connection if (mysqli_connect_errno($con)) { echo "Failed to connect to MySQL: " . mysqli_connect_error(); } ?&gt; Any ideas why that error would be popping?
Wait are you using this code to connect or the PDO in the original code? If you're getting that error, your password isn't being passed to either mysqli or PDO correctly.
I have no idea what I'm doing. I pulled out the original because that was kicking errors too. So I tried this because I saw something do it this way. I'm completely lost.
You can vote on this feature [here](https://bugs.php.net/bug.php?id=62162).
You can pick up the dev version or compressed version whatever you wanted. It`s up to you, freely:)
I think it could get messy for truly global functions, but autoloading namespaces containing bare functions seems like it shouldn't be any more complicated than autoloading classes. I shouldn't have to wrap a bunch of stateless functions up into a class when real namespaces are a much more direct way to express my intent.
Awesome, I have been waiting for this. Thanks for sharing!
God, how do you still have the energy to do this :p you are like a PSR2-pacifier-machine
PDO can connect not only MySQL, but also other db that MySQLi cannot. The where_clause() is case-sensitive only for SQL keywords, so that it can be differentiated to other value easier. If the value is really a number determined by is_numeric(), how come to make it without quote? For what case will become dangerous? For serialization, Yes. You cannot insert array data into SQL database if the database is array object, right?
What were the errors when you were connecting through the PDO driver? Make sure to set all the defines properly.
this is with the pdo: http://toledohba.com/build/memdir_test.php this is the other: http://toledohba.com/build/memdir_test2.php I'm seriously lost as can be, this is one of those things I wasn't intended to be doing but it was sold and now I have to try to figure it out. I make things pretty damnit, this backend stuff hurts my head! Heh.
Just providing two options for user to pick up. That`s.
I had this error once. I wasn't escaping special characters ($ in my case) and it caused the password to be ignored for some reason. (Using password: no)
The issue, I think is much larger than Tabs vs Spaces, at least for me. When I first saw PSRs, they seemed akin to Python PEPs (although, while the python users made it clear by calling them a 'proposal' instead of a 'standard'). Python's PEP8 is pretty much the de-facto python formatting guide. They recommend spaces, but allow both (probably because they quickly noticed how religious spaces vs tabs became). For some reason, it seems the PHP-FIG never wanted PSR-2 to become akin to PEP8-- something all developers would point to. And this isn't even a problem, although it is a big disappointment to many. The problem, is this 'guide' is grouped up with all of the other recommendations. It claims to be a recommendation, yet the attitude of the members is 'we don't care if you use it' which seems very contrary to the definition of a 'recommendation'. The PHP FIG group has a separate by-laws section. Should PSR-2, or the controversial tabs vs spaces not go into that instead? Perhaps it'd be different if these were called proposals instead of recommendations, as PEP does. Perhaps it'd be different if "PHP Standards Recommendation" didn't imply that it was from a group trying to come up with PHP standards for everyone, as opposed to the real group's purpose (Framework Interoperability). Perhaps it'd be different if PSR-0 and PSR-1 weren't so popular. Some of us saw great potential for PSRs and PHP-FIG. But its become a lot harder to take the group seriously, as a standards organization, with their attitude towards their own "recommendation". TL;DR: * Disappointed to see PSR-2 won't become akin to PEP8. * Disappointed to see PSR-2's controversial issues weren't placed into its by-laws instead. * Disappointed to see PSR named 'PSR' instead of a more clear PFR (PHP FIG Recommendation) * Disappointed to see how PHP-FIG is handling their own recommendation(s) (basically "Don't use it. We don't care.") 
Their site seems to be a little funky right now, getting lots of disconnects and errors.
It will can JOIN in the further.
Is it *difficult* to run PHP and Python apps on Ubuntu? Pretty sure the answer is "no" but I haven't used Ubuntu in a while...
Why should he not install Webmin?
Hi. As you noticed, our documentation is still pretty light. We definitely plan to include many more details. Thanks for your suggestions. As for packages, we do install deb packages from our own repository. What our installer does is configure our apt repo and install packages from there. It probably wasn't clear from our docs because they just show the installer command. So, certainly another case where we need more documentation.
Also, just to be clear for people reading this thread: Python apps are served by Gunicorn. PHP apps are served by PHP-FPM. In all cases, Nginx is the public-facing webserver. For PHP apps, Nginx proxies to Apache so that PHP apps can use .htaccess files.
...and they're still awful. [Seriously???](http://www.codecademy.com/courses/web-beginner-en-ZQQ64/0?curriculum_id=5124ef4c78d510dd89003eb8#!/exercises/0)
I put this together and it all seemed to work for me. It's gotta be a credential problem or the DB isn't configured properly or something. http://pastebin.com/DabFsQGq Edit: I also show how to use PDO querying and jQuery for the form interaction. jQuery makes life easier.
After just reading another post on here I think I have just answered this. Services are supposed to be stateless, correct? I can call a service from anywhere with Servicename::serviceMethod(param1,param2) and have it perform that action? Is this the proper way to handle these service and factory issues?
Diagnosis: overengineering, 99% :) Seems like you read enough books, but none (or not much) of the real-life code. Also, I think you might exaggerate the meaning of object itself a little bit, that's why your have so many factories &amp; other stuff. Objects are just variables, bit more powerful than the scalar ones. My advice is: read more other people's code. It will help you learn a lot.
&gt; Services are supposed to be stateless, correct? Well, I wouldn't say you should blindly follow that article. Especially that it doesn't provide any solutions to the problem. The most important thing here is for you to understand what and why you do. &gt; Servicename::serviceMethod(param1,param2) DIC is there for a reason. If you'll someday want to switch from one service to another, with DIC (or ServiceFactory in your case, if I understood correctly) you'll do it a lot easier than with rewriting all of your code which uses the service.
It's funny you mention that. I actually have the feeling that I'm over thinking just about everything I do. After reading all these "best practices" articles and whatnot I feel like I'm adding way more than the program needs to function... I'll look more heavily into some other people's projects. Do you happen to know any well written open projects off the top of your head?
There's not much value in putting everything behind a factory. It mainly just destroys readability (+ IDE click-though navigation) and doesn't really help with much. Dependency injection is better in most cases as it achieves the same goal of preventing client code from needing to know how to construct objects while reducing unnecessary abstraction. There are quite a few definitions of services but generally they're just "code that does stuff". I wouldn't worry about statelessness or anything like that. I tend to put session stuff into services for example because this allows simple migration between session storage backends. I really just want client code to just send session data off somewhere and then forget about it. A DIC would also do this but service locator-like behaviour is often more convenient (perhaps I'm just old-fashioned). It's worth remembering WHY you're abstracting things and in most cases it's to facilitate unit testing. If you have to mock 10 different factories to test a simple request object it's not supporting the objective. It's probably hindering it. "Use the simplest thing that could possibly work, but no simpler". If you can't test things because of tight coupling with an immovable object (file, external service, stateful service e.g. session/cache etc.) abstract it up a level but don't just abstract everything up to the highest level right off the bat or you end up increasing complexity in areas that do not need it. The most reliable code is the code you don't write. Bugs can't hide in empty files.
The services I have currently don't hold any values between the objects that call them (nor do I plan on them ever needing to). There's no reason I can think of for any one of the services to ever be initiated. I was under the impression that they were all supposed to be initiated at some point, which lead to some crazy parameter passing that I felt was super unnecessary. My factories really only exists to include the proper files and make sure the item get's constructed correctly. They're pretty basic and just provide me with the convenience of dropping in a file and making a single reference to it. The rest of my services are really just actions that I was performing over and over again. Most are some kind of assigner, comparer, etc. If I read the article correctly, this would be the exact case for them, correct?
It sounds like you might be conflating the idea of autoloading and the traditional GoF Factory. Autoloading is the right tool for including classes. Factories are the right tool for preventing client code from having to know how to produce complex objects (though as I said in my other post DIC may actually be better here as it removes a lot of the mystery a factory introduces into a codebase).
PS, it's "code**c**ademy", not "CodeAcademy". No "A".
Have you tried http://framework.zend.com/learn/ It was good back during v1.x days, but I haven't touched v2 so I don't know if it is as good.
Ah yeah. This means that the query is coming back false. You need to check that $query != false. Like this... // Generate query $query = $db_handle-&gt;query('SELECT id, company_name, category, city FROM companies ORDER BY category ASC'); $result_array = array(); if($query != FALSE) { $query-&gt;setFetchMode(PDO::FETCH_ASSOC); // set to fetch as assoc array while($row = $query-&gt;fetch()) { $result_array[] = $row; } } Sorry about that. Wrote this really quick. Edit: !!!Important!!! : Be sure to change the SQL query to match your database and what data you need to pull out. Mine is just an example of the simple table I made for this test.
I should mention that a var_dump returns the entire table list..I just want one of the columns
I have had a lot of conversations with Python developers (I am one too) about this, and I understand exactly what you mean. Now, the awesome thing about PEP-8 is that it was thought up, then the core team thought "Yeah, let's go with that, it seems like a good standard!" and it was baked right in. Now when I code Python in Sublime Text it tells me out of the box I should avoid too many blank lines and mentions if im using too many spaces. Great. I feel like the main reason PSR-2 and PEP-8 are on a totally different level is because of the community. The python community is smaller, and more mature. So if the core team says "we think this makes sense" people are going to go along with it much easier. PHP is MUCH larger, and way less mature. We have a community that is probably 1000% times larger and way less interested in "doing it right". Besides, one of the largest complaints about the PHP-FIG is that we're somehow trying to tell everyone how to write their code, which we aren't at all. The PHP-FIG is interested in making some standards to help ourselves work together. As somebody with a project on this group (PyroCMS) I cannot explain to you how much this group has helped! But, we are not trying to tell every PHP developer how to write their code, and this can only be seen as a benefit. Why the hell should we?! It is a "recommendation" because the FIG recommend the other FIG projects use these standards, but they dont have to. So, if the other FIG projects dont have to, why on EARTH would we even think about suggesting the entire community has to? 78% of the internet use PHP. Just because 20 projects got together to improve their own interoperability, why should we think we can control what 78% of the internet does? That would be INSANE. The fact that PSR-0 and PSR-1 are popular is lovely. This helps a lot of people. It still doesn't mean we can get PSR-2 baked into PHP to help the entire internet code with the same style guide... Keep your expectations reasonable and dont complain because some people did something good, maybe something EPIC could be done afterwards.
I'm dedicated to helping people understand what is going on. There is a lot of hate for something that people don't understand. It's like the PHP-FIG is a bunch of scientologists or something.
What's so bad about it? Edit: I mean I get what's so horrible about the class and everything, but it is the extreme basics for learning purposes.
Symfony 2 or Zend are good examples.
It makes sense. Why not just capture the whole row in a variable then use the key for the column as normal $something = $this-&gt;functiona(); echo $something['a']; Also, if your only getting one row, I'd highly suggest you add "limit 1" to your query. Now that I think about it, I think you're asking about a "pluck" function. You want to end up with an array of values of just one of the columns returned: Try this: $something = array_map(function($row){ return $row['a']; },$something); Hopefully that helps, I typed it all out on my phone :p 
haha thanks alot bud...I'll give these a try!
You run a php file on what?, I will just assume you are running it on a potato since you have provided no information about your platform.
Yes, those are excellent examples of overengineering in PHP, but I don't think he was asking for that.
Just to add to the overengineering point: don't follow blindly every single good practice and pattern without asking "why". Some patterns and practices are useful, but there are also many that try to be clever for the sake of being clever. 
Interestingly there was also CodeAcademy (in Chicago) that was started around the same time that had to change their name to "Starter League" due to a trademark dispute with Codecademy.
Wouldn't say Symfony is really overengineered. Probably in some of its parts yes, but not completely. It's divided into packages - that's what adds some additional abstractions, I guess. 
As someone learning PHP who has some web design experience; it is extremely frustrating try to learn writing code within the html markup.
It would be kind of neat to setup users accounts by having them download an image with their "access code" embeded in it. Then they just upload their image to login to a site. _Yeah, there's probably some obvious hole in this, still would be neat_
I'm looking forward to see if this will help. Currently my server runs Ubuntu with Plesk Panel and as it's really easy to manage my clients, their websites etc. It's too much PHP orientated and that sucks. Sure PHP is probably the most used language for web development, but if you want python - no way to do that if you don't do some manual configurations. So if that could be automated - I'll be happy. Plesk prices also suck - I mean I pay for the panel, then I have to pay for every module (say: Tomcat - not included by default, PostgreSQL - not included by default, Nginx - not included by default). You see the options in the panel, if the services are installed on the server - but you have no control over them with that Control Panel and if you already have some clients - good luck replacing the Plesk Panel install/configuration with a standard install without panel (nobody likes downtime)
Neat idea, decently documented, horrible implementation.
Dude, they declared a class right in the middle of some markup. That's straight up god-killing-kittens blasphemy right there
I never noticed that before, it will annoy me for the rest of time.
I actually attributed nobody (the link goes to a draft book chapter) but this hasn't been secret knowledge for many many years and there's a lot of people who have worked on the problem besides Samy (e.g. Stefan Esser and George Argyros who has presented the topic at conferences across 2012/2013. Plug his name into Google for his slides.
Yes, that package stuff abstraction is one point. Symfony needs that, because of it's featurette. Frameworks are actually a very specific development case, and i wouldn't recommend "learning" from it, because you don't need the level of abstraction for every project case. Well, except if you do a framework ;)
 &gt; Neat idea, decently documented, horrible implementation. Compliment, compliment, fruitless negativity. You would sound like less of an ass if you explained why the implementation is horrible, or perhaps made a few recommendations. I've seen [something similar](https://github.com/filefrog/illuminati) if you care to look it over, albeit written in C.
I've written something like this before, though not in PHP. I actually managed to embed an entire harry potter book into a photo of a lion. 
Yeah. I know all too well the PHP-FIG's goal, its relation to the PHP 'core' project. However, the 'maybe something EPIC could be done afterwards' is a bit misleading because FIG's attitude seems to have shifted to "We don't want to make it epic." as opposed to a more ideal "It may be epic one day, but that's just a dream." It still doesn't address the confusion of the PSR name (why they weren't renamed with or after the group is beyond me). It also doesn't it address the controversial (pretty much known-religious items) the PSR chose to include in their recommendation, instead of making them into their by-laws for all interfaces. There would likely be a similar response (simply larger) if the group had added in "The first line of every file MUST include an Islamic prayer before a license." No one knows fully why, but it invokes a very similar response to religion. Sure, you'll give similar responses as you do now, but there's pretty much nothing that can be said to change the attitude of the developer, its almost a waste of time to try. (perhaps in the far future (2+ years down), the joke should be to make new indentation character a more neutral \r or 0x00)
We used s2Member for about a year, but found it to be buggy and relatively inflexible. So we switched to aMember, which was a little better but still buggy and not quite powerful enough. Both programs also had hideous code quality, so trying to figure out what's going on under the hood was very difficult. So we landed on the [IPS Community Suite](http://www.invisionpower.com/) and could not be happier. It's fast, flexible, beautiful inside and out, and our users love it. Plus there's a relatively large community of support and add-ons.
arrays have always given me grief. This might not be the best way, but it's the way I deal with it. I'll use your array from above to demonstrate. at line 23 I would insert the following: echo "&lt;pre&gt;"; print_r($menu_items); echo "&lt;/pre&gt;&lt;hr&gt;&lt;pre&gt;"; And the result of that would be: Array ( [0] =&gt; Array ( [name] =&gt; Home [url] =&gt; index.php [title] =&gt; [classes] =&gt; ) [1] =&gt; Array ( [name] =&gt; QTs [url] =&gt; qts.php [title] =&gt; QTs [classes] =&gt; ) [2] =&gt; Array ( [name] =&gt; Submit A QT [url] =&gt; submit.php [title] =&gt; Submit A QT [classes] =&gt; ) ) now it will print an hr so we can separate that from what I'd insert at line 26: print_r($menu_item); echo "&lt;/pre&gt;"; and that will show: Array ( [name] =&gt; Home [url] =&gt; index.php [title] =&gt; [classes] =&gt; ) Array ( [name] =&gt; QTs [url] =&gt; qts.php [title] =&gt; QTs [classes] =&gt; ) Array ( [name] =&gt; Submit A QT [url] =&gt; submit.php [title] =&gt; Submit A QT [classes] =&gt; ) and from there I'm able to determine not only how to handle the output of my array, but also to determine if I've built it wrong. Hope this helps a little bit. *edit: incidentally, I typically put that bit of text in a comment block in my php script for quick and easy access to the structure. That has helped me quite a lot when coming back to the code to try to determine what the heck I was thinking. :)
Snow crash.
&gt; $item = array( Why are you doing this? it looks like a case of copy-pasta gone wrong. &gt; foreach ($menu_item as $li) { $li isn't an item, it's the individual values in your key/value list. This loop shouldn't even be here. &gt; I can never understand how to display nested lists. $menu_items = array( array( 'name' =&gt; 'Home', 'url' =&gt; 'index.php', 'title' =&gt; '', 'classes' =&gt; '', ), array( 'name' =&gt; 'QTs', 'url' =&gt; 'qts.php', 'title' =&gt; 'QTs', 'classes' =&gt; '', ), array( 'name' =&gt; 'Submit A QT', 'url' =&gt; 'submit.php', 'title' =&gt; 'Submit A QT', 'classes' =&gt; '', ) ); foreach ($menu_items as $item) { $output .= sprintf('&lt;li&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;', $item['url'], $item['name']); } If the menu were a tree, you'd need a recursive function to assemble the menu instead. 
Got it working! So I have a question then... currently its just populating everything in the column, including duplicates, is there a way to truncate duplicates down to a single selection? Also, how do I get it to show the results? If I had to guess, I'd say I would change the alert line to a print line then include whatever it is I need to include in the print? Something like this maybe?: &lt;select name="myslist"&gt; &lt;?php foreach ($results as $result) : // Alternate syntax ?&gt; &lt;option value="&lt;?php echo $result['Company']; ?&gt;"&gt;&lt;?php echo $row['Category_Name']; ?&gt; (&lt;?php echo $row['City']; ?&gt;)&lt;/select&gt; &lt;?php endforeach; // End foreach (alt syntax) ?&gt; &lt;/select&gt; I took that from a previous iteration, so I'm not sure how correct that is or isn't.
To explain your array definition: you have created an array of 3 elements, where each element is an array. Those sub-arrays each have 4 elements which have keys of name, url, title and classes. Note: the `$item =` bit in your array definition is entirely meaningless. So remove that or alternatively replace with a key for example `'home' =&gt; array(...)` Next, you have two nested loops where you only need one loop. Remember, you have an array of 3 elements (menu items). So when you do the first loop, `$menu_item` is set to be each of those 3 ment item arrays. Not sure if you missed some other code but you need a `&lt;ul&gt;` tag to wrap the list elements, and you should define the $output variable before you use it. Fixed code: $output = '&lt;ul&gt;'; // uses = not .= for the first bit of HTML if (is_array($menu_items)) { foreach ($menu_items as $li) { $output .= "&lt;li&gt;&lt;a href=\"{$li['url']}\"&gt;{$li['name']}&lt;/a&gt;&lt;/li&gt;"; } } $output .= '&lt;/ul&gt;'; Personally, I would also use single quotes for the output so you don't need to constantly escape the double quotes in HTML. It does mean you have to break out of the string to output variables but IMO it looks a little neater. $output .= '&lt;li&gt;&lt;a href="' . $li['url'] . '"&gt;' . $li['name'] . '&lt;/a&gt;&lt;/li&gt;'; 
I think you're being a little ridiculous now. We're building something that we all find useful. The member projects have benefitted, and beyond that PSR-0 has changed the way the PHP world shares its code. That is epic in its own right. It's not going to be PEP-8. The PHP Group are not going to start throwing errors if you indent things wrong, and it doesn't need to. Maybe it could happen, maybe, but I don't care either way and its certainly not the FIG's "dream" or even a realistic goal. 
PEP never tried to be the 'standard' it became that way independently. Some developers still don't follow it. PHP-FIG at this point is telling developers not *to care* about their standards. They're purposely relegating themselves to a less important role. They're making themselves less relevant on purpose. I don't care what group you're a part of. When a group is trying to make others NOT care about them, maybe they should take a step back and reconsider. My issue isn't specifically about with PSR-2, its about how the group and its members are dealing with it.
It's very disappointing to see that they did an open call for people to write these PHP courses, and this was the "Best" they could get?
It's a good thing we're not trying to win, because it would definitely be impossible for us to do that. We have a bunch of people saying "HOW DARE YOU FORCE YOUR STANDARDS ON OTHER PEOPLE" and now you're saying "Why on earth arent you trying to force the entire standard on every single PHP developer?!" From this point on I'm going to answer any confusion over this subject by pasting the FIG's mission from the website: &gt; The idea behind the group is for project representatives to talk about the commonalities between our projects and find ways we can work together. Our main audience is each other, but we’re very aware that the rest of the PHP community is watching. If other folks want to adopt what we’re doing they are welcome to do so, but that is not the aim. That is a very reasonable mission. If that is not enough for you then I'm sorry you feel that way.
Factory design pattern is mostly used for returning "similar" objects. Let's say you have types like "Widget", "RedWidget" and "BlueWidget", a WidgetFactory returns a type of widget object dynamically. You seem to use Factory for the controlling part of the MVC (if I read your code correctly). That, to me, added unnecessary vagueness to the controlling logic. Without a framework, I would just do this for controller: In main_controller.php - if add widget, include add_widget_service.php - if list widget, include list_widget_service.php And of course, you want to use OO to define the data type and create business models in the back, which is more important than anything else. 
Yep, I'm getting a lot of compiler errors on the lessons when I try to run my code. And not because I wrote bad code. 
I don't feel the need to go out of my way to make everyone feel warm and fuzzy. A few people here know what I'm talking about, one of them likely being the author. I refuse to believe that he was smart enough to write the code, but isn't smart enough to understand what I've said, and why.
I will definitely try to keep this in mind. The actual syntax was the simple part to learn. Knowing how to wield it seems to be the hard part.
^ You still come across as a complete a$$. For the benefit of those not clever enough to 'get it' .... what exactly is the issue with the implementation?
Is there anywhere else like this to practice good php techniques?
I very well might be. It basically just auto loads the files for me. I'll have to make a pass over my "factories" and weed out some things I dont actually need. 
Wow, bet you're great fun to be around. 
Zend Framework 2 is a very big step if you want to start from a very basic level. The documentation is at best incomplete and a lot of it is without context, if ZF is a requirement then I'd suggest diving straight into the code base and only using the documentation for reference. Otherwise I'd recommend a smaller framework that's more suitable for the task 
The concept looks quite neat, haven't tested it though. I would gladly contribute but there are a few points that I'd like to bring your attention to : * Please consider using a coding standard (eg: PSR-2): your code is difficult to read. * You should definitely consider using return values more often instead of nested ifs and elseifs. For instance instead of having this. Example : if (isset($message)) { // do something if($condition1) { // something else if($condition2) { // etc... } } } You should really do this (really more readable code, and easier to maintain/test) : if (!isset($message)) { return false; } if (!$condition1) { $log-&gt;error(); } * You should move all your notes into your README.md * Test units would be nice (instead of having a massive block commented at the end) All in all, looks good (merely scratched the surface on this though), I'd really like to look more into this and contribute, please please make it more friendly :)
 echo "&lt;pre&gt;"; print_r($menu_items); echo "&lt;/pre&gt;&lt;hr&gt;&lt;pre&gt;"; ... is a great candidate for a netbeans code template. I use the exact thing, except I add a few things for visibility: echo '&lt;div style="background-color:black;color:green"&gt;' .__FILE__ . ": " . __LINE__ ."&lt;br/&gt;" .'${VARIABLE variableFromPreviousAssignment}&lt;pre&gt;'; print_r(${VARIABLE variableFromPreviousAssignment}); echo "&lt;/pre&gt;&lt;/div&gt;"; 
Cramming every single thing in to a single monolithic thousand line class is not good design. He obviously understands how it all functions, but he writes it like it's procedural. I'm hoping that this is just a prototype he intends to actually refactor, because this is pretty terrible the way it is. This entire style of cobbling things together in a haphazard fashion is a symptom of a much larger problem with the PHP community, and we don't do anyone any favours by telling them how awesome they are when they write code in this way.
Thanks for all of the explanations so far guys, each response has helped me out so far. One other thing I just thought about was how to handle HTTP status codes? Say for instance that someone loads a path that doesn't exist, what's the best method of presenting an 404 error to that user?
Brace yourself for the world of PHP. Half the replies here will feel PASSIONATELY that even OOP is "overengineering". The other half will be going nuts in the opposite direction. That being said, this may be a tad too far in the "too much" direction, IMO. This is just one man's opinion, but here's what I think makes the modern web app, regardless of the language it's done in: 1) MVC Framework. Choose whichever one floats your boat. They've all got plusses and minuses. 2) Business logic in the models, if it is specific to that model. 3) Business logic in a service layer, if it implements some kind of process involving multiple models and is therefore not appropriate to implement inside one specific model. 4) ViewModels. They represent the state of your view. They are necessary because what's depicted in the view rarely matches up 1:1 with your regular models. So trying to pass a regular model out to your view will require you to also pass out a mixed bag of other variables. This leaves the front-end guy working on your view with pretty much no consistent interface he can rely on. 5) Repositories to do database access. Your controllers, service layer, etc., should never hit the database on their own. What if you change one day from MySQL to Postgres? From one ORM to another? From ActiveRecord to Data Mapper? From a database to a REST service? A repository can be easily swapped out for another one without disturbing the calling code. 6) Constructor-based dependency injection. You don't need a fancy IoC container, but if the PersonController needs a PersonRepository to get records from the database, you shouldn't be able to instantiate the former without the latter. 7) Interfaces for services and repositories. Your PersonController actually only needs an object that implements the PersonRepositoryInterface. You can implement one today that relies on your Framework's ActiveRecord, and pass an "ActiveRecordPersonRepository" to your controller today. Tomorrow, you implement the "RESTPersonRepository" and pass that to your controller. Your controller doesn't even notice. The last few things in that list will have some people frothing at the mouth. But these things will keep a web app future-proof, and clear and easy to understand. And really, none of the above is very complicated. Lastly, if you're learning OOP, don't fall into the trap of thinking it's all about code re-use. It is definitely not about code re-use. And it's not just a trendy way of namespacing your code. (When you see "OOP" code where every class member is static, it's a sure sign the coder did not really get the point of OOP.) Familiarize yourself with the "SOLID" principles of OOP. They're a great starting point, though the wikipedia articles may be a little dry (no pun intended): http://en.wikipedia.org/wiki/SOLID_(object-oriented_design) Hope some of that was in any way helpful.
Ya'll need proper debuggers.
Downvotes? Looks like *someone* hasn't read Harry Potter.
When the language itself can't name functions consistently how can you expect people using the language to have good habits when it comes to readability? 
The point is not to make anyone feel warm or fuzzy but to impart knowledge to help the person out instead. With your condescending attitude the only person feeling warm and fuzzy from your posts is you because you feel superior to someone with less experience than you. Try helping people out.
When I stumble into a new problem area, I usually expect to write the code three times. Once to fully understand the problem, a second time to clean up my mess, and a third to make it to where I am proud of it. You obviously over thought the issue, so now you need to think about how you can simplify that. Odds are, you will over simplify it and the perfect solution will be shown before you as a result.
I did help him out. I pointed out that his implementation could use work. I came in to give him feedback, not to teach you proper software design. If you want specific help with something, try asking a targeted question.
I've never found a commercial PHP debugger worth using. 99.9% of my debugging needs consist of examining a variable or verifying that a particular branch of code is running, which this accomplishes with minimal effort.
A commercial debugger? Fuck, use [xdebug](http://xdebug.org/) instead. It's free, and a lot of IDEs got support for it. 
So people have to bait answers out of you one at a time? Do you crave attention or something?
http://www.jetbrains.com/phpstorm/features/index.html#debugging http://jtreminio.com/2012/07/xdebug-and-you-why-you-should-be-using-a-real-debugger/ &gt;Oh and another piece to the puzzle is that I work for the feds, so any change to a server involves hours if not days of paperwork and meetings and usually gets vetoed. I've learned to deal. Uh. You **don't** put a debugger on a production server. 
I'm talking about a dev server. It's not worth my time wrestling with a bureaucracy to make a change to a server (yes even a dev server) unless it's something I absolutely need - and I have very little need for a PHP debugger.
Not everyone has a webcam.
Why on earth would you develop against a "dev server"? Host a virtual machine, develop locally, THEN push it up to a staging server. 
I [complained about this](http://www.reddit.com/r/PHP/comments/1a2s34/codecadamy_have_launched_a_php_tutorial_the_only/c8to47b) when they released the first batch. tl;dr: * They approach PHP like it's the late 90s / early 2000s. * The lessons are much lower in quality than the lessons for other languages (python and ruby, especially). * They actively encourage bad coding practices and mentality by claiming: "The best part about PHP is that including it in your site is as simple as learning a new tag. PHP code can be written right in your HTML document." What would be better would be to port the ruby or python lessons over to PHP. There is no reason to teach the bullshit that's up there to new PHP devs unless you're trying to keep the stereotype of clueless PHP devs around a bit longer.
&gt; Edit: I mean I get what's so horrible about the class and everything, but it is the extreme basics for learning purposes. This is even more reason it's awful. You should never use bad examples as the only example when first introducing concepts.
Maybe they taught their devs with this PHP tutorial...
There is no advantage to working that way for me. Our environment is shared, with site-level codeigniter elements being developed by several programmers and absolutely no way to locally replicate the databases. Keeping a local virtual machine updated would be a waste of my time.
That's your biggest problem with this? :D
You should probably hit up the Temple, Drexel, and UPenn sub reddits.
Yeah, but I dont want to piss in another man's sandbox. The subs i did post to, i subscribe and contribute to.
 'classes' =&gt; '', ), should be 'classes' =&gt; '' ), EDIT: Holy moly! It worked with the extra comma o_O. My apologies.
I agree that the original reply could contain more specific help. But sometimes people just don't have the time to send in whole pull requests, or even review line by line. People have real jobs and limited amount of daily energy. Best thing to do I guess is to be a little more specific by pointing out a global or systematic implementation flaw. Like another top reply in this thread does. Perfect bait there. Let the OP ask and fish for more help, if hes even interested...
&gt;It really makes no difference whether you code locally or on a server Yes, it does. The fact that you are all developing towards the same environment should set off alarm bells in anybody. &gt;I've never seen anyone develop with a virtual machine. Ever. Wow, really? &gt;You are suggesting that I set up a whole new way of developing, one with virtually no advantage other than the ability to locally install a debugger I don't need or want. I'll stick with print_r, thanks. I don't know if I am supposed to cry or laugh... I mean, every single thing you've told me is setting off a gazillion alarms. An absolute nightmare. And you're working for the feds? Yikes.
[Recursion](http://www.reddit.com/r/PHP/comments/1bl2y5/problems_displaying_information_in_nested_arrays/c97wnqi) is your friend.
It's valid syntax, and actually encouraged by the Zend coding standard. 
That's true but look at the wording of his posts &gt;Neat idea, decently documented, horrible implementation. &gt;I don't feel the need to go out of my way to make everyone feel warm and fuzzy. A few people here know what I'm talking about, one of them likely being the author. &gt;I refuse to believe that he was smart enough to write the code, but isn't smart enough to understand what I've said, and why. Do you not think that if there was no time to put any more information it'd not have been best to not reply at all rather than say "good idea, too stupid to do it right" and then follow it up by saying "I don't need to make OP feel good, he should be smart enough to decode meaning from my post"? It's unnecessarily antagonistic and nothing he said helped anyone. 
Is this a remote opportunity?
Hey, as I tweeted to you, I would have a hard time recommending this article because of the problems with it: * `mysql_*` functions [1] * SQL injection * HTML/PHP mixed I understand PHP has a reputation, rightly deserved, for its easy of entry, but modern tutorials should really try to introduce best practices from the get-go, so new programmers don't ever consider the wrong way of doing things. Don't let this fool[2] put you off from writing more stuff, though! [1] You fixed this afterward, so that's a plus! [2] Myself, not you.
Sorry, no.
Everyone needs to read [PHP The Right Way](http://www.phptherightway.com/) :)
Deleted. I wont make that mistake twice.
Excellent post. Very nice theme on the code snippets, as well. Added this to the notes section of my GetOptionKit post, because it is relevant to the interests of the readers. :)
What's the advantage of using a debugger? My method might not be pretty or complete it gives me advantages: I had to figure out how to do it, and it shows me what I need to know.
There are many advantages. There are no print-out on the page, you can set breakpoints everywhere and inspect the state, you can move up and down in the scopes, and it'll show the state accordingly, you won't be polluting your code with a bunch of debug code, etc.
Thanks for the explanation, I'll take the cue from your other posts and check it out!
Even like a resource to learn it on my own would be great, this is driving me nuts.
That's a really poor guide that Go Daddy provided. The mysql functions in there are going to be deprecated as of PHP 5.5 so using them is a bad idea. Instead use either [MySQLi](http://www.php.net/manual/en/mysqli.quickstart.dual-interface.php) (example #1 is useful) or [PDO](http://php.net/manual/en/book.pdo.php). As for connecting to the database, if you provide the error message it will help narrow down the problem.
Regarding that example code: Don't use the mysql functions(they'll be deprecated in future php versions), switch either to [MySqli](http://php.net/manual/en/book.mysqli.php) or [PDO](http://php.net/manual/en/book.pdo.php) ( my vote goes to PDO which has the advantage of working with more than just MySql). This is a [comprehensive tutorial on PDO](http://www.phpro.org/tutorials/Introduction-to-PHP-PDO.html)(pay special attention to the part about prepared statements and avoiding sql injection). Second thing: Dont use GoDaddy for anything, not even domains(namecheap is a good registrar alternative and there are much better shared hosts out there). That being said, assuming your database is up and running and that you replaced the variables correctly you should get some output on your browser, at least an error of some sort. Double check the hostname that godaddy gave you , and make sure your credentials and database name are correct and that the table exists.
I've used both extensively. Symfony: Steep learning curve. Overly complicated in some areas. Powerful. Laravel: Easy to learn. Powerful. FUN to develop with.
Cross post this to /r/phphelp - it's exactly what it was made for. 
Did you create the database yet using GoDaddy's Web Hosting control panel? I know that their SQL servers are not hosted on the same server as the website, so this is one of those instances where throwing 'localhost' into the hostname variable isn't gonna work. Other than that, getting PHP and SQL to work on GoDaddy is the exact same as if you were on any other web host.
I just think many people have no real idea *WHAT* to code, so instead they obsess endlessly over *HOW* to code it. What do I care what Twitter runs on? It's still Twitter, if you catch my drift. It's kinda like the only people who would seriously argue about what's "better" metal, or hip-hop, don't know any good songs/artists of either genre, only overly technical crap without any content or soul. I say this as a shitty coder, but as a knower of people :P 
error in your code it should be $menu_items = array( array( 'name' =&gt; 'Home', 'url' =&gt; 'index.php', 'title' =&gt; '', 'classes' =&gt; '' ), array( 'name' =&gt; 'QTs', 'url' =&gt; 'qts.php', 'title' =&gt; 'QTs', 'classes' =&gt; '' ), array( 'name' =&gt; 'Submit A QT', 'url' =&gt; 'submit.php', 'title' =&gt; 'Submit A QT', 'classes' =&gt; '' ), ); if (is_array($menu_items)) { foreach ($menu_items as $menu_item) { foreach ($menu_item as $li) { $output .= "&lt;li&gt;&lt;a href=\"{$li['url']}\"&gt;{$li['name']}&lt;/a&gt;&lt;/li&gt;"; } } }
If you are making this a PaaS-implantation you are going to the wrong way. I'd suggest opening this up and providing "Community"-edition and "Enteprise"-(paid support) versions. If you want to keep this boat a float.... 
What is your site's architecture? Common php framework (Drupal, Symfony, Wordpress, Zend, etc.), custom framework, or procedural code? Same or different host? The bad example GoDaddy provided should use the mysqli connect function (as others have said), and move the $query (using PDO) &amp; $result to index.php or other document. Include the db_connect.inc (or whatever you want to call it) in your document before issuing any queries.
_This_ is how these kinds of articles should be written! Fantastic post.
interesting name, to make a uninstersting person interesting :) pdo seem a bit easier, tnx gonna try and check up on it :)
http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers
I prefer using `mysqli` over `PDO`, just a matter of preference. To translate your coding from: $id = $_GET['id']; $sql_indhold = "SELECT * FROM table WHERE id='$id'"; $query_indhold = mysql_query($sql_indhold); $indhold = mysql_fetch_assoc($query_indhold); $test =$indhold['data']; I would write it this way: // Create connection $mysqli = new mysqli($server, $user, $password, $database); // Get ID $id = $_GET['id']; // Sanitize it $id = $mysqli-&gt;real_escape_string($id); // Create query $sql_indhold = "SELECT * FROM table WHERE id='{$id}'"; // Execute it $resource = $mysqli-&gt;query($sql_indhold); // Walk through the results while ($row = $resource -&gt;fetch_assoc()) { // Do anything with $row, in this case `$test = $row['data'];` } // Close connection $mysqli-&gt;close(); Once you advance in your coding knowledge, you should definitely start looking to abstract this process using a `Database` class that deals with everything related to DB interaction, and make the resource implement `Iterator` to ease things.
IMO to sanitize an ID number you should be: $id = (int) $_GET['id']; $sql_indhold = "SELECT * FROM table WHERE id={$id}"; Why accept a string when you only want integers?
Who says the ID is an int, and not a string? :) Apart from that, I wanted to write an example he could use in other situations, just to set an example of what would work regardless of the type of variable that is being passed. Just for reference, I use the following function to sanitize values: public function escapeValue($value, $force_type = null) { if (is_bool($value) || is_int($value) || $force_type === 'int') { return (int)$value; } elseif (is_float($value) || $force_type === 'float') { return (float)$value; } else { return "'{$this-&gt;mysqli-&gt;real_escape_string($value)}'"; } }
&gt;Who says the ID is an int, and not a string? Touché!
http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers
Hi tnx for your answer, helpfull, i have some questions that i hope you can clear up. $test = $row['data']; data is the name of the row, with the data i want to get out right? so if i wanted 2 fields out i could do: $test1 = $row['data1']; $test2 = $row['data2']; right? or? for some reason i keep getting "Undefined variable: result" and "Call to a member function fetch_assoc() on a non-object in" on this line: while ($row = $result-&gt;fetch_assoc()) { // Do anything with $row, in this case `$test = $row['data'];` $test = $row['data']; } any idea why? complete source can be seen here http://pastebin.com/cHzGw7Bs do you know any good sites that show examples on diffrent mysqli usages? 
From your example, I can notice two things: * First, you have not initialized `$mysqli`, which is the first thing you should do (create the connection). That's why `fetch_assoc()` can't be found. * Second, I made a typo and wrote `$result` instead of `$resource` in my example. I have fixed it in my previous comment. Apart from that, your first `if` conditional is wrong. You're testing whether the **string** equals to true, but what you're probably trying to check is if the query has been successful. The conditional should look something like this: // Create query $sql_indhold = "SELECT * FROM table WHERE id='$id'"; // Execute it $resource = $mysqli-&gt;query($sql_indhold); // Check if the query has been successful if ($resource) { // Yes it has! } else { // No it hasn't echo 'error ' . $mysqli-&gt;error; }
I forgot to answer the first question! `$row` is, well, the row we just fetched. Given a table with the following columns: * id * name * timestamp We would have to use `$name = $row['name'];` to store the name of the user. In the example, `$test1 = $row['data1'];` would not work, because your column is probably not name `data1`.
Pre-warning: I've never seen Laravel's website, docs, etc. I'm currently working for a company where most of the projects were written in ZF 3-4 years ago, and we're currently seeing a lot of growth in features, scaling, etc. and one thing I'm glad of is ZF's lack of opinion. As we've realised that feature X within the framework is lacking for our needs, we find that thanks to it's extensive use of adapters and so on that we're able to change extremely core features without having to alter much code, for example switching our caching layer from APC to Memcache or adding encryption to our session handlers. Take the APC one as a good example, no-one really expected it to stop being supported, but here we are a couple of years later and it's basically dead, and Zend Optimizer is now being integrated in to core. How much thought has gone in to migrating from a memcache session handler to something custom? Is it as easy as it would be with symfony2, or are there more hoops to jump through? What happens when people inevitably decide that ActiveRecord is no longer the best thing ever and move on to a new ORM pattern? I would (probably) enjoy and try Laravel if it's effectively Silex+sensible defaults with the ability to migrate core features easily, but if it's quite tightly coupled with little/no thought put in to moving beyond what's built in then I can't see it being used for anything other than prototyping applications that are going to be rewritten in symfony2.
It's extremely extensible. Custom cache and session drivers may be easily registered, and we use a couple of interfaces where needed to keep the ORM de-coupled from other core framework features. And, of course, almost any core class can be replaced by binding a replacement in the IoC container.
P.S. Godaddy almost certainly will not allow external database connections. That is, you'll only be able to connect to their MySQL from one of their own hosting servers. If you're trying to connect from your own personal server, it won't work at all.
I had a [discussion](http://www.reddit.com/r/PHP/comments/166q3r/i_need_a_quick_and_dirty_approach_to_prevent_sql/c7t9r7n) about casting integer ids to ints on /r/php not too long along. I was all for it at that time, but I then decided it was not such a good idea. Essentially you have to assume everybody is stupid. And that they'll pass in something like "123 456" and it will be converted to 123. This isn't terrible on a read, but on a db write this can have devastating effects.
In what situation do you ask users to blindly type in an ID number, show them nothing about the entity they referred to, and then perform an operation on that entity? It seems to me that for that case, a user typing in 124 when they meant 123 is just as likely, and just as devastating. If it's not a value typed in by a user, how could it be damaged in the way you suggest? I think you would have bigger problems in that case.
like others said, use the PDO class
Please please please don't listen to this guy. Doing queries using the same bad practices as the old mysql functions is every bit as bad as continuing to use them. See [the examples here](http://www.php.net/manual/en/mysqli-stmt.prepare.php) for a description of how to do prepared statements using mysqli. Or even better, follow the advice further up and use PDO. When used properly, prepared statements remove the work of having to escape or otherwise think about the security problems associated with the mysql functions. Attempting to handle escaping manually is the source of a huge number of data corruption(over-escaping) and security(lack of escaping) issues when there is really no good reason you should have to think about it at all.
I'm fairly certain I don't want to sign-up somewhere just to read more stuff about PHP when there are so many places to read about it without giving out my name, e-mail &amp; job.
I guess I should also mention how I got myself all setup. - Get a windows VPS. At least a 2008 server version. Use the Remote Desktop Connection or VNC to jump into your servers desktop and get going. - If your not familiar with running a windows server i recommend you get the Web Platform Installed as it'll remove all of the actual configuration and headache. http://www.microsoft.com/web/downloads/platform.aspx (note you'll have to adjust your IE settings to allow you to download it. Sometimes just easier to upload it remotely. ) - Once you've installed Web Platform Installer you'll just want to go to the Products Tab and Search for "PHP" You'll get results like: http://puu.sh/2tQ8O.png Mark PHP 5.3.19 (or any 5.3 version for that matter) AND Microsoft Drivers 3.0 for PHP 5.3 for SQL Server in ISS. - Breathe, but know you may be stuck on IIS for a web server. I'll just be building an internal REST API so I can keep my development back on my comfy CentOS box. Best of luck to ya.
My stab... $query = "select * from table where id=" . mysqli_real_escape_string($link,$id); $sth = mysqli_query($link,$query); if(!mysqli_errno($link) &amp;&amp; mysqli_num_rows($sth) &gt; 0) { while($fetched = mysqli_fetch_assoc($sth)) { // ... } } else { // handle errors/no results } There are probably better ways, but that's the way I'm in the habit of doing it.
I hate to be one of 'those' guys, but I can't recommend moving away from GoDaddy enough. They are a terrible company on pretty much every level (including treating their employees like crap, I had a couple friends who were sysadmins there in Scottsdale). That being said, you should probably post your question to [StackExchange](http://stackoverflow.com/) if you can't get a working answer here.
Have an upvote! Best reply in here. Edit to add some value to this comment. Following SOLID principle and decoupling classes, there is this formula I often use: a group of classes like A, B, and C, doing different things but living in a single business request, should never be interdependent like A directly knowing about C. Much rather build dependency layers (preferably with interfaces) and have the dependency like: A layer uses B layer, which uses C layer. So C layer can be executed without A layer, and at the same time A layer can be reused for a different purpose than only executing C layer. (In real life code you probably have A1...A99 in one layer and C1..C99 in the other layer, but still routed with one single B layer.) This little formula has helped me greatly to write testable decoupled code. It can be applied to a group of classes, but also to a group of methods. Even apply it cross web servers. (Like others have mentioned, *software design patterns* basically guide you to apply the above formula in more specific situations.)
I did create a database using their panel, and I'm using the hostname they provide in their database panel.
I'll look into using those, the error message I'm getting is the one that I make in the guide above in javascript, then it automatically sends me back to my last page visited so I cant see any normal error or even look at the source code.
I'm getting nothing and I'm copy pasting everything straight from the godaddy panel, It's getting pretty frustrating. Could you give me a brief description of the differences between mysql functions, MySqli, and PDO? People here seem to be leaning toward PDO, but I'm in unfamiliar territory. Thanks for the resource, I'll check it out very soon.
So, to clarify, you're running your own personal physical server, correct? So did you have to pay for a static IP address or something?
I have a webcam but no printer :(
&gt;Never any strange random errors that other environments suffer from Etc... I myself, love PHP also, but have come across some weird issues. Some times I have to var_dump() a variable in order for PHP to realize what the value is.
I was wondering why I was being suddenly downvoted although I offered a solution that was correct, secure, and easy for him to understand coming from old `mysql` functions. You may consider what I'm doing are bad practices; I don't. As I said, a `Database` class should be created for continued use, to avoid forgetting about escaping values. I personally use a `QueryBuilder` class that transforms parameters into queries, for example: $users-&gt;select([ 'id' =&gt; ['in', [1, 3, 5, 7, 21]], 'role.type' =&gt; 'admin' ]); Would be converted to: SELECT main.*, role.* FROM users AS main LEFT JOIN roles AS role ON role.user_id = main.user_id WHERE main.user_id IN (1, 3, 5, 7, 21) AND role.role_type = 'admin' Is that a bad practice? **Edit:** typo
Thanks, this is a big part of why I said what I did. If the community wants to combat the negative image of PHP the best way they can do that is to start taking code quality seriously. It's not enough for something to simply work - it has to work *and* be well designed.
/r/php is not a help channel, and my comment was not meant to help you with anything. It was meant as feedback for the author. I stand by my statement content in the knowledge that telling him he can do much better does more for him than telling him that everything he did was great when it really wasn't.
Some popular frameworks I've worked with in the past, all are great: * [Larvel](https://github.com/laravel/laravel) - The best one out there in my opinion. * [CodeIgniter](https://github.com/EllisLab/CodeIgniter) - Also really good, a bit of a learning curve. * [CakePHP](https://github.com/cakephp/cakephp) - Overall great. Has a great community. * [Flight](https://github.com/mikecao/flight) - So light weight, so beautiful. **Pros of a framework**: * Keeps structure and consistency * Good security, since everything is made to withstand high standards * Faster coding (when it comes to coding things you have a good understanding of) * Make life easy **Cons of a framework**: * Limitations to how much you can modify it * Some difficulties along the way. For instance I had a pain trying to make a basic file upload page with codeignitor. But finally figured it out, and it worked perfectly. * Refer to [this stackoverflow answer](http://stackoverflow.com/questions/5925356/reasons-to-not-use-a-php-framework) for why you may not want to use frameworks. 
tnx for taking the time to explain things :) helped me getting it to work, even thought i converted it to prepared statements just to get rid of the escaping stuff....
tnx for this, really helpfull. tnx for taking your time to answer my questions.
I'm all for this in PHP just don't don't get so lax with the same syntax in JavaScript. Firefox and Chrome have no trouble ignoring the extra comma but Internet Explorer not so much!
I've only used one, but enjoyed using it. It was CakePHP. 
I use CakePHP and is a good MVC framework. 
Given the relative non-complexity of the system you described (though not in much detail, so take this with a grain of salt) I would say CakePHP is perfect for such development. I will give you a set of easy to use tools that should meed most of you needs right out of the box, and for anything above that, the developer community should be able to assist you to figuring out how to get there.
How do you rank Yii among the frameworks you mentioned? I'm starting to learn it with the new book by Larry Ullman, but it seems like Laravel might be easier. Any suggestions?
Haven't used it in a while (went back to CI after Kohana went to HMVC) but yes, love (provided their documentation is back up to snuff). 
I've heard great things about Laravel, but never seriously looked into it. Why do you like it? 
I happen to have both, but for the longest time had neither, so I sympathize with those who don't have one or both of them.
hahaha, well you'd better stay away then. The documentation is still pretty bad, but the framework is so elegant I love using it. 
I've shifted most of my logic and MVC-ness to the client side with angular.js as of late. With that in place I haven't had much use for a PHP framework aside from a self-rolled SQL Connection class ( which is really just PDO function calls wrapped up in nice error catching). If I was going to do something that needed more PHP-side logic I'd use Laravel. 
I followed the link trail back two articles to his original [WordPress Craftsmanship](http://tommcfarlin.com/wordpress-craftsmanship/) article, read half of [Software Craftsmanship](http://tommcfarlin.com/software-craftsmanship/), tried to skim through this article, then gave up. Can someone summarize this? It seems like he's just repeating the same thing over and over again: “I love Uncle Bob, and by the way, we should write better code”.
If you're using mysqli, you should be using parameter binding, not sanitization.
Between the ones I've used (symfony, silex, cakephp, zend 1) I would recommend cakePHP based on your post. cake has excellent docs and is really quick/easy to get started. For a small project it works out very well. I wouldn't recommend from scratch though, so many options for various experience levels with frameworks that it's not worth the amount of time. Once you start using more and more frameworks it might be worth it as a learning experience, that's what I want to do eventually so that I learn exactly how the stuff that frameworks come with, work.
[Flight](https://github.com/Xanza/flight) -- hands down.
People that write better code work with Drupal and stay clear of Wordpress.
Personally, I just enjoy larvel. After getting familiar with it, it was saving me a lot of time compared to other MVC frameworks. It's a personal choice thing. All 4 I've listed work great! Read more about why larvel is different: http://laravel.com/docs#laravel-is-different
To clarify, "die" in this context is to be not constantly running. This does not mean go away from existence as a language.
Unfortunate title is unfortunate. at least for getting upvotes in /r/php
It's a great article. Yes php processes do need to die. I've successfully run five daemons programmed 100% with php. They've ran for two years with no failures. They run every hour, then sleep for a hour. I use unset to remove every bit of unneeded data, and call phps garbage collection methods. As a backup, I have monit watch my daemons pid files and fire off my init.d script to restart the daemons. The article is completely accurate. While my solution isn't 'complex' it's some php and monit basically. The php is extremely complex to create pid files, write to logs, work with an init.d script, even some nifty garbage collection. I've been using php for a very long time (longer than 10 years). Running a daemon written with php and having it perform mission critical tasks is not for the faint of heart.
&gt; Is that a bad practice? If you are not using prepared statements, yes.
The article brings up very good points. HTTP is stateless so it makes sense that an early web language would have this suicidal tendency. I was disappointed he did not mention queues or message buses or gears worker bees as solutions to the death problem.
"If your project will rely on continually-running processes to function, avoid PHP." This is hardly news though. PHP was never designed to write daemons, and I dont know of anyone who knows their stuff, who has ever recommended it. This is one reason why node.js has received so much attention. 
I agree with part of what he's saying. The main point he's making is that PHP is good for short-running processes, but not good for long running processes. I don't see any problem with this idea. Where I begin to disagree is when he starts to intimate that if you need a long-running background process you'll always pick PHP over something else. This is completely false, and there are many ways one can have background processes which can be started by PHP, but don't actually have to be PHP themselves. It all comes down to picking the right tool for the job. If you use PHP for long running processes, the problem isn't PHP, it's the programmer. For example, I've written a few daemons in ruby which run great - and I feed them processes via a beanstalkd queue from PHP. PHP can still die in a timely manner, and a more capable language can handle my background processing. Everyone wins.
It was clearly an intentional, though unfortunate, word choice.
can you add your own code onto a framework or does everything need to exist within the framework? Thanks for the thought out response!
What do you like about it? Why this over any other suggestions?
Great answer. Thank you!
Right, so the very essence of the framework is that all the unimportant stuff is taken care for you in the background. Everything you would ever need to modify can be modified within the designated classes. However, if you want to really customize things then you can find plugins. CakePHP has [an entire website] (http://plugins.cakephp.org/) just for awesome packages you can add. Google around, and you'll realize that each framework has a great community which makes extensions for frameworks. But of course you could dive right into the directory which contains the framework php files and modify stuff there. That's not recommended, and I really don't see a reason to do so. Hope that answers your question. :) ^EDIT: OP, I think you should start of with CakePHP. Here's where you can [download it](http://cakephp.org/). And here's an [awesome YouTube tut](https://www.youtube.com/watch?v=nO9oSQhRa9s) for how to get started. And finally here's your [map](http://api.cakephp.org/2.3/) (documentation), now go off on an adventure! (:
Please see http://reactphp.org/
You forgot to put quotes around the value you escaped, leaving it open to SQL injection. That's a really painful way of checking if the query succeeded, you can just check if the return value from the query is non-false: if ($sth) {
Actually those are the guys who *think they write better code*, those that actually write better code write using Zend Framework or Symfony.
Well, I ran the circular references script shown there and it ate my memory quite fast. It'd be a nightmare to debug a script just to find that **unset** doesn't do what it means to do. edit: MAMP v 2.1.3, PHP v 5.4.10
No mention of the 5.4 GC which *can* collect unreachable circular references? I'd hardly advocate for PHP as the best choice for a daemon, but I'm not 100% convinced those particular arguments stack up for modern PHP. Most of them apply equally to any other language that uses reference counting.
The article clarifies what scenarios he've seen where this happens: &gt; The most infamous implementation for the above thing may sound familiar: No matter how “enterprise” PHP or the framework of your choice claim to be, it’s also supposed to be so cheap that you don’t have access to ssh, cron or any similar tool in your $5/month shared hosting server. and &gt; Do you see the pattern? I’ve inherited projects where PHP was used for daemons or other stuff that’s not just regular websites
No, I don't mean to say so, but as the subreddit and the article targets PHP and I myself am a PHP developer and can test the script as well, I am commenting on how PHP is behaving. It also has to do that PHP is the most common language around for web pages, and very popular for newbies. I think the article just says PHP is not suitable for everything, but you may get that feeling if you started coding web pages with it. I'm running MAMP, PHP v 5.4.10, it seems the problem is still there. As for memory leaks and alike, it is sad that the developers seem not to worry about this kind of bugs: https://bugs.php.net/bug.php?id=49664 &gt; Infinite recursion crashes. There's no fix for that. A stack overflow may be comprehensible, but a segmentation fault?
You do not seem to disagree with the OP at all. He is essentially saying that if you use PHP as a daemon you are doing it wrong. He is not saying that this is PHP's fault, it is obviously the devs poor choice in tool.
You're completely missing the point. Why would you tell him it was great, when it isn't? That wouldn't make sense. My point was that you could just have given a few pointers to lead him in the right direction. For example: "It's bad practise to have everything in one huge class, you should refactor". That wouldn't hurt your precious ego to type and would be immensely more useful than saying it sucks. 
I don't understand how this is insightful. Running deamons in php is just as bad as baking potatoes with PHP. I can't phantom why anyone needs to do that when there are many other better approaches. Using the right tool for the right job : using pure C for example for building a web app is as bad. PHP really shines in pure HTTP context. And saying crons aren't available in cheap hosting is inane because if you don't have crons you won't have virtualenv nor supervisor either. 
Flight is simply highly extensible; not to say that I've worked with all PHP frameworks, but it's at least the most diverse I've had the pleasure of working with. It's only a simple php include to get it setup and working, far less setup than some. It's ability to patch functions and classes is pretty seamless as well, very close to Larvel if I'm not mistaken. Needless to say I use it for just about everything. Check out my little [boilerplate](https://github.com/Xanza/flight-boilerplate).
Unfortunate? It's called linkbait, and it worked.
Yes, upgrading to the latest version without doing proper tests is always the best solution ... **not**! There are many companies which do not upgrade their software in production immediately because there are many tests which must be done, many other components that are involved. Sure, if you do web development it's simple to just upgrade a server, but in real-life production you often have a few dozen servers to upgrade - and often this means a lot of regression tests, memory leak tests and end-to-end scenarios tests. It all depends on how business-critical your application is. In a fairly large company this whole process can take even a few months. Your reaction would be accepted if you were talking about PHP 4.
Good article. And this has been my experience in practice. Thankfully, PHP bundles the FPM component: a process manager built into the core that handles PHP's built-to-die nature. And even copes with things like APCs instability and horrible locking. FPM is *not* just for FastCGI. I use it to process my Resque queues, for example. This, to me, seems much nicer than shoe-horning background jobs into an execution context they don't belong (request serving). At some point, you are going to want to completely isolate those components of your architecture (as they develop different growth needs and load characteristics). And say what you will about PHP itself, FPM is pretty damn rock-solid for a daemon. You'll still have to break your task up into "requests", but for job processing and message consuming that's natural.
Last time i mentioned here that concurrency is bad in PHP i got lots of downvotes and was accused that i have no clue about network programming. Even given the fact that there is no big project using PHP as a daemon. This article says exactly what i said.
I would be careful with saying "php has no memory leaks" ;) It's just that nobody found one recently. But yes, if you know your shit, it works okay. It's still fiddling and requires an awful lot of experience to do it and it's certainly less complicated in some other languages. But i wouldn't use PHP for that, even if it works, it's not the optimal tool for the job.
Sorry to contradict your experience, but I've found out the hard way that long running Ruby processes are in the exact same boat PHP is; Ruby processes die a fair bit, and can get bloated after a while. They're unreliable, and if you *need* a service running, you'll be looking at process supervision. (Speaking only of CRuby here; haven't used other implementations much.) That's why you don't run a Ruby webserver, for example; you run nginx/Apache/whathaveyou, frontending a Unicorn or Mongrel process that manages a bunch of constantly-recycled workers. (See the similarity to FPM?). It's not *just* for parallelism, but for reliability too. In fact, Ruby developers often have [god](http://godrb.com/) or monit on top of that, watching the master process.
APC 3.1.13 constantly segfaults for me with newish 5.4 builds. No releases in almost six months? Seems dead to me. Zend OPcache (formerly Optimizer+) 7.0/dev-master is broken for me too. (And seems pretty unstable for now in general.) So, I'm stuck for the time being. `crap()['dammit']`
That was a 5.3 innovation. (The NEWS for 5.4 doesn't mention any specific improvements). And it doesn't quite work well enough, in my experience. Although it could easily have been extensions too.
Sure, if you consider the refcount a lock on eligibility for collection. It's just that it's not, really: it's a *refcount*. And there's nothing concurrent about this, so it's a bit weird to use that term. There's no shared resource being accessed, there are no competing actors, there's no mutual exclusion, and no locks. You might as well say it's a traffic jam. That's how loosely you're using the term. &gt; PHP doesn't use that algorithm anymore Sigh. Yes, it does. The "traditional reference counting" was never removed, and is still used. The new GC only happens from time to time, and can be completely disabled (non-cycles will still be free'd).
'Godmonit' sounds like a real curse word. What language would you recommend as better than Ruby? I was thinking of learning another language for web stuff (or learning a web framework in a language I already know), and for a while was considering ruby. One thing I'd like to do is do a continual process thing for properly handling Comet/reverse AJAX.
Yeah, people who use Frameworks for almost everything clearly write better code...
You've piqued my interest. Can you explain more about these things? I have not heard of them.
That's still the programmer's fault. If your hosting doesn't let you do what you need it to do then you need different hosting. Saying you can't do it because you refuse to move away from your $5/mo hosting is silly.
Actually daemonizing is quite easy (even in PHP) but most people don't seem to understand the rules for daemonizing, and they get in to trouble with it as a result when they start trying to write daemons. A lot of people nohup somehing and pipe the output to /dev/null or wherever and think this is the right way to do it, but nothing could be further from the truth. It bothers me a great deal that yours is the top comment, because there are so many things you don't consider while evangelizing PHP for all the wrong tasks.
Sorry, if it came across as me bagging on Ruby, it shouldn't have. Most interpreted languages have exactly the same problems or close analogues. For development and fun, use whatever you feel like. Reactor patterns (Node, Twisted, Eventmachine) are all the rage these days, and you can even get a decent one for PHP (React). Hell, I'm the maintainer of [Wrench](https://github.com/varspool/Wrench), and I'd be the first to admit [Ratchet](https://github.com/cboden/Ratchet) is damn fun. In production, however, I like the approach of turning long running requests (Comet, Websockets) into requests/messages with something like [WAMP](http://wamp.ws/)/STOMP and a messaging middleware of your choice (RabbitMQ, ActiveMQ, PubNub etc.). That frees you up to use any application language you like, in a process manager (FPM, Unicorn) to deal with reliability.
Refcount == 0 checks are made whenever a refcount is decremented. That's the traditional algorithm, and it occurs even when GC is disabled, and at a different time to when the optional garbage collection mark-and-sweeps. So, yes, PHP does "still use that algorithm", and it *is* like you have two different garbage collection mechanisms running. In fact, because of this, the cycle collector you're so enamored of, will usually *only* collect cycles!
The concept is pretty simple. Say that you have some part of your application that runs slowly, such as resizing uploaded images or sending e-mail. You don't want to do that in the same PHP code that runs when a user visits a page because it takes too long. Instead you want to offload it to a PHP script that runs in the background (a worker). To do that, the PHP page needs to be able to tell the worker what to do. That's where a queue or message bus or Gearman comes in. The PHP page generates a message and puts it in the message queue. A simplified example: $message = [ 'command' =&gt; 'resize', 'file' =&gt; '/path/to/image.jpg', 'width' =&gt; '640', 'height' =&gt; 480, ]; $queue-&gt;put($message); That code runs very fast and your PHP page can continue doing whatever it needs to do (e.g. render a template and die). But now you need to have some commandline script in the background that reads these messages and does whatever it needs to do. Example: while (true) { $message = $queue-&gt;get(); // blocks until a message appears $this-&gt;handle($message); } A nice side effect of this is that the PHP page and the worker can run on different machines. And if the number of messages increases, you can easily add more machines running more workers. The problem that the article points out is that this kind of script needs to run forever, and PHP isn't great for that. But there are some easy solutions that the article doesn't mention: Just let the worker die at appropriate times and restart them. There are many ways to do that. Personally, I like [Supervisord](http://supervisord.org/) but you could use Monit or a host of other applications for this. What Supervisord does is basically watch a bunch of programs, and when they die, it restarts them. So, you would tell Supervisord to start 5 workers. When a worker dies, Supervisor automatically restarts it. All you have to do now is add some code to the worker to make it die. A very simple way would be to die after processing a certain amount of messages. Example: $iterations = 0; while (true) { $message = $queue-&gt;get(); // blocks until a message appears $this-&gt;handle($message); if ($iterations++ &gt; 100) { exit(); } } A bit simplistic, but it works. You could also die when you reach a certain memory limit. Example: $memoryLimit = 1024 * 1024 * 128 * 0.9; // 90% of 128 Mb, or calculate it from ini_get('memory_limit') while (true) { $message = $queue-&gt;get(); // blocks until a message appears $this-&gt;handle($message); if (memory_get_peak_usage() &gt; $memoryLimit) { exit(); } } This is just the basics, but you you get way more fancy than this. For example, instead of running 5 workers all the time, you could scale the number of workers automatically. You could program the worker supervisor to start more workers if the number of messages waiting in the queue gets longer, and when the queue gets shorter, it can let some of the workers die without restarting them. Of course, all this means that you must have a decent webhost with SSH access, monitoring applications and PHP CLI. You can't do this on your $5 GoDaddy hosting package.
For real. When the author said: &gt; Which is the easiest solution to that? Bring background tasks execution to the foreground, of course! My response was "WTF? People actually do that?". If your application is complex enough to need background processing then you need need an appropriate tool. Doing it any other way is the equivalent hammering screws (my dad calls it a Geordie Screwdriver).
I came here to say exactly what you said - in addition I worked for a company that had multiple php daemons processing hundred gigabyte size data-sources daily with no issues - in fact I remember once the only noticeable error being that we had forgotten to restart a php daemon after updating the code base, the daemon had been running for more than six months.
I, too, run a shop with my partner and we mainly do Symfony projects. Once you're familiar with it, well, I can tell you that *our* development time and overall quality have improved in outstanding ways. Since then, we've also shifted paradigms to "reuse" rather than "build it and throw it away" and we've been able to provide tremendous value to our clients by delivering high quality, still-maintained components for their web applications. Anyway, the investment was rough, indeed. Worth it? Yes, very much so.
On the one hand I agree. PHP is not generally designed to support long running processes such as daemons. That being said I tend to take the Amazon EC2 approach to them. With EC2 servers are just disposable units of processing power that are likely to die at some point and as such an instance dying should not be an interesting event. Just an everyday occurance that you plan for and fully expect. You can build scripts in the same way - expect that they may not live forever and build this into their lifecycle. A script dying shoudn't be something you particularly care about - there should be mechanisms to ensure the system as a whole will recover. This way of thinking actually makes a lot of stuff easier. For example rolling out updates is extremely simple if it's possible to just shut down workers without any consiquence. They can even shut themselves down when they realise the current version is not the same as what they started as. I guess my main point is that when you recognise that PHP isn't that great for writing immortal services you should accept it and build something that has this at the core of its design. To come back to my previous point you wouldn't expect to run a web server on a single EC2 instance. It's not designed to work that way. Similarly don't try and make PHP do something it's not designed to do. Work WITH the language instead.
This is actually very useful thing. I spent quite a while trying to find an embeddable nosql db to no avail recently. I had the same idea of just doing it in sqlite but never got around to building anything.
Here's another up vote for you. We have PHP daemons that run for months. We route phone calls to the tune of 200 calls per second, millions and millions per day. Each call requires approximately 30 transactions to various sources (memcache, mongodb, even mysql) look up customer rates, vendor rates, quality selection options, record call records and statistics, etc. We have over 500 million rates loaded covering every country in the world. We do this on relatively few servers, and have no memory leaks. Could I do this on fewer severs if we wrote in C or C++, probably. Servers are cheap though, compared to developers, and making, testing and deploying changes and customizations is much easier in PHP (we just merge to trunk and then update our servers). Plus we get to share code from the back end processing with the website that maintains and reports on the system. Changes on the website automatically update our memcache and mongodb instances and take effect real time. We have had several programmers over the years. Myself and one other guy maintain the core code, and it's solid object oriented code to be proud of, in any language (like everyone though I feel like the code I wrote 2 years, or even 6 months ago could use some improvement; the joy of learning even after 25 years of programming). Other guys have written some code I'm sure wouldn't run for months, it's our job to teach them, not blame the language.
I have been using PHP in different production environments for the last 6 years now. Where PHP is now is well ahead of where it was, but the problem is that you can still write it like you could 6 years ago. A lot of crazy hacks I had to do are no longer needed to make things 'work' (my life became so much easier when they allowed static:: as well as self::). I used to have a daemon that allowed me to monitor cronjobs, never had a problem with it. I could turn off cronjobs remotely from home when we needed to prep for a system shut down, or I could force a cronjob to fire early if I knew the processing batch would be large. It really was great, and never once had a problem. A lot of people want to blame their architecture short comings on a language... but that is the beauty of PHP. It allows you the flexibility to do whatever you want. I already know for web dev, I will be moving away from PHP, but not for at least a few more years. Meteor just looks amazing and it goes with exactly how I think web development should work. It actually flows the same way I have been trying to get my own PHP framework to act. However, for scripting, I will prolly stick with PHP, because Python makes my eyes bleed. I wouldn't argue against a PHP fork that fixes a lot of PHP's idiotic stuff, but a lot of what people complain about, really is their own dumb fault, and often you can find in other languages.
Thanks for sharing
You should give [Boris](https://github.com/d11wtq/boris) as spin then. It's a shame it's third party and not built in but I hear it's very nice. 
Can you name one programming language that has never had any memory leaks, or a programming language that nobody hasn't found any recently?
I have a project that uses Twitter's Streaming API and has 2 PHP scripts running persistently in the background and it works perfectly. They've been running for around a month continuously now with no problems.
Even though they mix up quite a bit of code together that shouldn't go together, it really is a nice looking tutorial.
No, that's the point ;)
How is trying to run one command 'trying to build webmin'?
If having the database in UTC solves everything, why not convert every date to UTC when storing data?
Hey look, buzzwords for the sake of buzzwords. "I wanted simple key value store and I used a lightweight relational database, but I'll name it after a popular complex key value store to make people think it's something more significant" Racking my brain for a use case where I'd want nosql semantics without the SQL semantics, and I can't really find one. 
It's great that he took it upon himself to be the doer as well as the thinker, but booknug.com has some glaring issues in both the design and code.
That does not set database time zone. PHP converts it to UTC, but the database still thinks its in whatever timezone it is configured as-- say America/Chicago. Perhaps it only matters if you use TIMESTAMP columns... at least in MySQL. Still seems like something should tell the database what time zone you want to work with.
You can always save dates at UTC timestamps and handle the conversion form UTC -&gt; Local within the code instead of having the database handle dates
Does it abuse, punctuation as badly as you?
Reinstall or reconfigure the mysql server to use UTC. If you don't have control over that because you use a hosting provider, your hosting provider sucks and you should find a new one. Or you could ask if they would do this (probably not, because if they were too dumb to do this in the first place they are probably too dumb to do it now). 
Right. And that's unfortunate. 
Always store the dates as unix timestamps (ints) and then do the time zone conversion in PHP (DateTime makes time zones really easy). You can get them from time() in PHP, strtotime to convert a text date (append the time zone indicator to the end when passing it in, or UNIX_TIMESTAMP() in MySQL
Thanks, you summarized my impending hate rant. btw &gt; Fatal error: Exception thrown without a stack frame in Unknown on line 0 Seriously? SERIOUSLY? You've errors in your autoloader handlers. 
Using date() and strtotime() to work with timezones is like using sand-paper to scratch your arse.
MySQL has some good resources about this on their site. Check them out here https://dev.mysql.com/doc/refman/5.5/en/time-zone-support.html You can set the timezone at runtime or at the app level
Storing them as unix or MySQL date time doesnt matter, just make sure its all UTC going in and all UTC coming out. Always UTC everywhere. Then in your PHP framework you just use whatever Date class they have available, or DateTime, or [Carbon](https://github.com/briannesbitt/Carbon) to take the America/Chicago value our of the users profile and set the timezone. If they are a facebook user and you dont want to ask them for a specific timezone then you can take the timezone offset from their user account and just update that value each time they log in, so it might be -4 for a while but next time they log in it could be -5. Remember this value should be A FLOAT because some awkward-ass islands are UTC+5.75 and have +30 minute summer offsets. If a user is logged out or you have no idea who they are then you could do some geo-lookup on their IP to find their timezone. But that is not fun, I just show UTC to those folks.
If/when I get some downtime, I will definitely give Symfony a try. I'm starting to think I'll need to hire someone else if that's ever going to happen- I haven't had a day off in 4 months :(
Can you explain this a little more, unless i'm missing something with your reference to strtotime(). I always do everything with the server time and save all dates in the database as the unix timestamp using time() e.g. in the articles table there is a column called time_added with the unix timestamp of when it was created. Then when displaying the time I always use date('Y-m-d H:i:s',$article-&gt;time_added) or something similar and it gets presented in whatever timezone the user wishes (assuming i've set a relevant timezone for the specific user based on their profile data or something) As far as I can tell storing dates as timestamps (ints) is the simplest way to work with timezones.
Imho, you should never use the time returned from the database, for exactly the reason it sounds like your bringing it up. ie, you should *not* use functions like NOW() I ran into this issue using Amazons RDS server where you CANNOT change the timezone for the database server, its stuck in UTC and you just have to deal with it.
I have timezones set up on the database. Every date inside the database is stored in UTC, and every date is generated inside PHP instead of in the database. I like to use the PHP DateTime and DateTimeZone objects for handling dates, ex: $date = new DateTime("now", new DateTimeZone("UTC"); $date_utc = $date-&gt;format("Y-m-d H:i:s"); $date-&gt;setTimezone(new DateTimeZone("America/Los_Angeles")); $date_pst = $date-&gt;format("Y-m-d H:i:s"); Sometimes I need to group by date in SQL queries, and that needs to be timezone-aware: SELECT date(convert_tz(hour_utc, '+00:00', 'America/Los_Angeles')) as tz_date, SUM(stuff_count) FROM table GROUP BY tz_date
I was actually using "user" to refer to the registered user who has presumably set their timezone in the user settings somewhere which would be saved in a users table in the DB (we may be talking past eachother in this case) Basically what I took the original poster that you responded to as saying was just that you should save timestamps as an int in the DB that way you can display them in any timezone you wish. The flow would be something like this: if($user-&gt;is_logged_in) { date_default_timezone_set($user-&gt;timezone); } else { date_default_timezone_set($config-&gt;default_timezone); } $article = get_article($id); echo date('d-m-Y H:i:s', $article-&gt;time_added); Assuming `$article-&gt;time_added` is simply an integer dates will always be displayed in the right timezone and the database can be taken anywhere. I'm not sure if this is the sort of workflow you where criticising or not, if it is then i'm not sure what the problem is, it's always worked fine on my projects.
With the default for MySQL being the system time zone, wouldn't it be simpler to have the application run a `SET time_zone = '+0:00'`?
Storing UTC + the timezone name indeed covers 99.99% of the possible usecase. In the 0.01% you also need to store local intended time along with it.
Not to be offensive, but this is a moronic article without any insight. If you understand how memory management works in PHP, and manage your resources accordingly, there is absolutely no reason for anything in this article to be true. And there are many people out there, me included, who have examples of PHP daemons running for years without leaking a single bit of memory. Believe it or not, there are even frameworks for building websites on top of a PHP daemon. Check out [the Photon website](http://photon-project.com/) for instance...it works wonders, runs for months and doesn't leak (as long as you manage your resources as you are supposed to).
I think you are missing the point from the article: * PHP is popular * PHP has limitations * *Some* devs don't pay attention to these limitations and misuse PHP * Projects get ugly * PHP explodes when misused At the end he says he decided to move away from PHP, he just doesn't want to *build web forms*. I don't like a wrench that breaks because you hold it for longer than a minute or so. 
I store dates and times as good old UTC integers and completely ignore that SQL has date &amp; time handling stuff.
carpii is entirely right when he says PHP was never designed for this sort of thing. Just because someone forced PHP to do it doesn't mean it was a design consideration when PHP was being built. Not that this is a problem, since there are so many other options when you need this sort of thing. Just because you may have a task that PHP is not suited for doesn't mean you suddenly need to throw the baby out with the bath water. It doesn't have to be an all or nothing thing. You can use PHP and still communicate with processes in other languages.
php for windows isn't something you really "install", at least not in the normal sense of installing windows applications. just download and unzip. You'll want the thread safe version, but if you are not actually going to be running php on your system it might not matter. Then I'm guessing youll just need to tell css comb where php is.
Well, which web server are you pairing it with? Edit: None, apparently. You're just using it for the express purpose of running CSS comb in Sublime. Either version would do. 
[Here](https://github.com/miripiruni/CSScomb/wiki/Requirements) are their instructions. I need to assign it to a path within &gt; $PATH environment variable They provide images, but it seems it is already assigned to something for Nvidia. 
I don't think I am, I don't have a web server. [This](https://github.com/miripiruni/CSScomb/wiki/Requirements) is how / why they want me to have it installed somewhere. But I just don't understand any of it. ^Sorry!
See my edit above. 
In [Derick's book on date &amp; time handling for PHP](https://www.phparch.com/books/phparchitects-guide-to-date-and-time-programming/), he recommends using an unsigned int field for the timestamp but also having a char/varchar field for the timezone information. That allows you to store the timezone along with the timestamp and recreate a DateTime object afterward.
Start with a concrete problem. I find I have trouble learning something unless I'm learning it to do something. So set yourself the goal of building something, preferably something you actually need or want. As you're doing it, I recommend keeping [PHP the Right Way](http://www.phptherightway.com) open in another window. Things have changed a lot since you last touched it (for the better).
Right, I thought I did it correctly, [It looks like this now](http://snag.gy/JEYvh.jpg) But I still get the error: &gt; Unable to find php.exe. Make sure it is avalible in your PATH. What did I do wrong?
For windows... use the [Web Installer](http://www.microsoft.com/web/downloads/platform.aspx) and install [PHP On Windows](http://www.microsoft.com/web/platform/phponwindows.aspx). Or use something like [WAMPP](http://www.wampserver.com/en/)
Ah right! This made it work. Thanks for the patience Nicoon and Allmighty, definitely appreciated.
Provided you're going for a degree of Mongo compatibility (which seems to be the case), then Mongolite as a join of Mongo + Sqlite seems like a good name choice to me.
Thanks, I'll check the site out. It looks pretty well documented. 
PHP doesn't need to be "designed" to do it for it to be suitable. Personally, I agree that there are better languages than PHP for doing daemon-like processes, but I wouldn't necessarily say that PHP *shouldn't* be used for such things. There are plenty of examples of working PHP daemons that run for a long period of time without issue. You're likely to encounter the same issues in PHP for long-running processes as you would in any other language. Things like garbage collection, etc. In other languages, you tend to also need to really *understand* those things for developing daemons, rather than it just being implicit functionality. Garbage collection is hard, even when the collector is good.
Don't be. a dick;
Thanks for the information, I'll look into it :) I'm not quite at that stage yet, but since I figured I would be at some point I'm glad I know this now.
I see. So this won't work on those free hosting sites, but as long as you have real access to the (virtual )?machine, you're fine.
There are many of these posting in /r/php I think.
Actually **yes it does**. Memory management suitable to these tasks is not something you just bolt on after the fact. I don't expect most people here to really understand this though since many don't really understand how the language (or any language for that matter) works at a fundamental level. I'm not even sure why I'm trying to combat the ignorance here, it's a fight nobody can win. The chief problem with php and long running tasks often isn't php - it's all the libraries and other items which aren't managed very well that people use with php. Much of PHP is just glue for other libraries which may or may not behave in PHP's model. This is the thing so many of you seem to be missing. You can't take one or two examples that seem to work and come to the conclusion that it must always work.
Yeah, this is why I use unix time in PyroCMS but MySQL datetime at the day-job.
&gt;I don't expect most people here to really understand this though since many don't really understand how the language (or any language for that matter) works at a fundamental level. Not sure why you needed to include that jab. I definitely understand how PHP works at a fundamental level. You simply need to justify your statements by explaining what's lacking in the PHP runtime to handle long-running processes. I'm saying you *can't*, because long-running PHP processes already exist. &gt;The chief problem with php and long running tasks often isn't php - it's all the libraries and other items which aren't managed very well that people use with php. Much of PHP is just glue for other libraries which may or may not behave in PHP's model. Yes. And if you plan on daemonizing PHP processes, then you should have the extensions limited to those that play nicely. It's actually not a complicated task.
&gt;Not sure why you needed to include that jab. It's not meant as a jab - it's a truth. A lot of people who use PHP don't have a very solid background in how languages work. Now, you don't necessarily need to know how all the nuts and bolts fit together in order to use PHP. Not knowing doesn't make you some kind of moron. On the other hand, if you're going to start arguing internals then you're starting to travel on a slippery slope. Things aren't always how they appear to be from the outside. &gt;Yes. And if you plan on daemonizing PHP processes, then you should have the extensions limited to those that play nicely. It's actually not a complicated task. Actually depending on what you're doing and what you need to make it work it might become a very complicated task. There is no document that states in no uncertain terms that "module x, y, and z play nice, but a, b, and c don't". You wind up slogging through that with a trial and error mentality. Plus, there's a chance others may break later because the devs don't see daemonized PHP tasks as even remotely approaching a priority. Realistically they shouldn't either - that's not the sort of job PHP was designed for. In any case, I'm done with this entire thread. Your post was a good read, and I appreciate that you posted it. However, I don't feel an intelligent discussion can be had about it because there are too many uninformed opinions on the topic.
&gt;I've been away from it for quite a while and have forgotten most of the things I knew from back then. This is a good place to start. In all seriousness, checkout [Laravel](http://laravel.com/). It's **the** framework for beginners in my experience, which is extensive as I myself am a beginner. It has an advantage over something like CodeIgniter in that it's built around 5.3. 5.3 is where the magic is happening. As an unencumbered beginner, don't settle for anything less than 5.3 (5.4 and 5.5 if you can). I will also second Sandy's advice to learn it right. One thing to keep in mind though is that you don't have to do things correctly right off the bat. Just make sure you always fix what you did wrong when you finally realize it's wrong. OOP and MVC aren't easy concepts but they are where you want to get to eventually so do your best to ease into them as quickly as you can.
&gt; Storing them as unix or MySQL date time doesnt matter Yes it does matter. If you want to use mysql's date/time functions it makes more sense to use a date/time field or you wind up having to perform conversions every time you query. If you have some component of PHP which requires a unix timestamp, convert it after, or when you pull the row.
Yeah, there is definitely a step missing here. I tried this not more than 2-3 days ago and it always failed on the push step. I never looked into it further since I haven't yet had the time, but I did see mention of a php buildpack that was needed.
Actually if memory serves, the database (most if not all) stores dates in a UTC based format. It then presents the date/time in either the servers default, or whatever you ask it to. So either tell the mysql session what timezone you want, or grab it in raw UTC form and do your own date/time math fun.
I store them as UNIX timestamp, and then I use GMT to calculate where we are from there. My servers are in Australia and are set to UTC+10 (Vladivostok, Brisbane time; non daylight savings). So if the user is on American Eastern Standard Time (UTC-5), then I take away 15 hours. (UNIXTIME - 54000)
Didn't the creator of Fuel say he uses a different framework now?
Are you thinking of Phil Sturgeon? in his blog post [Moving On](http://philsturgeon.co.uk/blog/2012/09/moving-on) he says he's leaving the Core Team. To my knowledge he was not the creator, just a member core team.
That's exactly what I'm thinking of.
Does it only work using sqlite or would mysql work, too?
I'm a newb but couldn't the complexity, lack of features, etc. contribute to a multitude of problems created by newbies? In a simpler language there might be far less problems created by newbies. Theoretically you could have one language that takes years to master but in another it would only take 1 year to get to the same point. In this way you can blame the language itself.
I'd say this is more than 0.01% of the time. Anytime you're storing future dates (such as for a scheduled event), it's important to know the indented local time. The reason for this because governments can change timezone or DST rules, and have been known to do so fairly last-minute. If I schedule something for 09:00 local time, and the government changes DST, the timestamp is now an hour off of when I want it to run.
Oh very true!
As a person not that knowledgeable of Fuel, care to explain further?
&gt;On the other hand, if you're going to start arguing internals then you're starting to travel on a slippery slope. Things aren't always how they appear to be from the outside. Of this I'm rather aware. I'm part of the doc team, which means I do a fair bit of investigating of what is *actually* happening behind the scenes. You're making the argument that PHP isn't designed to support long-running processes, and that its current state isn't suitable for doing so. You need to provide evidence for your claims, or else you're simply talking out your ass. Your claim that extensions often don't operate well in a daemonized context are also entirely unfounded. It *sounds* maybe true, but I've never encountered such an extension (at least, bundled extension) other than perhaps ext/GD or ext/mysql, which are pretty well-established to be shit. As well, just FYI, it's not my article. I found it on /r/programming, and it was of interest to me, since it's something I've dealt with in the past. I find it pretty absurd that you're painting the opinions of everyone but yourself as "uninformed". I've seen some of the most knowledgeable people about the language, in this thread, and its counterpart in /r/programming.
Actually unset works fine but you have to unset the right thing, the author's example doesn't. 
It's much better and easier just to set the MySQL timezone equal to the PHP timezone on each connection. And set both to whatever the user's timezone is, if you know it. Then don't do any other conversions. I develop calendaring software and believe me storing UTC for anything other than timestamps is not going to make for a good time. I still have an old application that stores everything in unix timestamps and has periodic off-by-one hour errors due to future dates and daylight saving time. 
Yeah, I was reading up some of the posts here and I heard someone talking about mysqli and was wondering what the heck that was. 
[`Timestamp` column types only](http://dev.mysql.com/doc/refman/5.5/en/datetime.html), and just for internal Mysql storage purposes.
The fact that both UNIX_TIMESTAMP and FROM_UNIXTIME exist, and the fact that PHP DateTime can read MySQL time and unix time, and output to MySQL time and Unix time, means it doesnt make a drastic difference either way, as long as UTC times are being passed in correctly.
uh, yeah, I started my senior project which is in PHP and had to relearn a number of things, that included.
 so depending on what you do, ints / unix timestamps are a bad choice, esp. when users can change the time (i.e. Posts in a blogging system p.exp.) datetime might be the best format, which leaves you with your timezone problem - which only occurs if you use now() or curtime() in a default configuration now() and curtime() report the same as the unix/bash command 'date' will do as other users pointed out, if you cannot avoid the usage of timezones, then do everything in PHP and only ever use UTC times, the ony please where you show them within a timezone should be your views theres a couple of problemy you have to keep in mind when using timezones, (thats why i try to always avoid them even in blogging systems i rather display the timezone it was stored) to give one example: DST .. daylight saving time ... this can be a pain in the ass and confusing, at least those 2 times in a year where the change happens 
Please do take the crash course. lightstrike would hate to be responsible for any delayed aftereffects.
Why not just use a `DateTime` Mysql column type then? Whether it's a `DateTime` column or an Int, it's still going to be the exact value you Select as it was when you Inserted. Mysql [`Timestamp` column types are an entirely different story however](http://dev.mysql.com/doc/refman/5.5/en/datetime.html) and does actually suffer from this problem you mention, so ignore that column type for the moment. The magic format for Mysql DateTime being `'YYYY-MM-DD HH:MM:SS'`. Original timezone where that datetime came from is of course not included, and is at the heart of OP's question.
 start by writing a proof that true == false like that: $var1 = 0; $var2 = 'foobar'; var_dump($var1 == false); //true var_dump($var1 == $var2); //true var_dump($var2 == true); //true so be prepared to be confused :)
To add, in Javascript, [the `Date` constructor](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date) expects UTC. This means you don't even necessarily have to care about a client's timezone in PHP. You can usually pass off the conversion responsibility via javascript on the client's machine using such javascript methods as `toLocaleDateString()` and `toLocaleTimeString()` on the date object. Edit - rough example: &lt;script type="text/javascript"&gt; var displayDate = new Date(&lt;?php echo strtotime($utcDateTime); ?&gt;); clockHtmlElementSpan.innerHTML = displayDate.toLocaleTimeString(); &lt;/script&gt;
I would say inexperience can contribute to a multitude of problems. This is the problem with PHP, and why people judge it so. The ability to do dumb things easily can lead to bad programming and reenforce bad programming habbits. PHP doesn't die or error out at evey silly mistake. New programmers generally are not adept at debugging or using profiling tools available. That doesn't make PHP a language that must "die" though. You don't have to call free every time you call malloc in C, perhaps using the OP's logic C should "die" too.
coercion, how does it work!?!?
They're import scripts, so there's not a lot of code reuse between them and the front end web application.
In my opinion, you should completely ignore it and only use PDO.
That's fine when you have 1 user.
No, what he means is he encodes timestamps using catface emoticon characters.
You set the timezone per connection. Works for an unlimited number of timezones and users. 
If a country changes it's daylight savings dates, then a recurring transaction is at the wrong time. That is, if you set something to happen every 1 Jan at 10pm, and when you set it it is DST, but next year when you run it it isn't thanks to politics, and your transaction happens at the incorrect time. There is only one time, like there is only one length. You would hardly store things in feet or meters depending on where the login was from.
If that recurring transaction is a dentist appointment I think you want it to be at 10:00pm no matter what the DST setting was at the time you set it or when it occurred. There isn't just one time. There are at least 24 different Jan 1st 10:00pm's. And exactly how you should handle that is very much context sensitive. 
Ah fair enough!
PDO - Prepared Data Object
And if it's a dentist appointment in a neighbouring state with different timezone rules? Also, try programming for milking and tell the cows that 4am is now 5am ... There is only one time (excluding relativity), timezones are a convenience so that we can all agree lunch happens at about noon.
The $5 shared hosting argument is no longer valid, you can get 512MB VPS from Digital Ocean, and number of others, for $5 a month.
The [Project Euler](http://projecteuler.net/) Challenges are cool and fun to work out, I used them to get myself familiar with Python.
Can anyone explain to me, why PHP Frameworks still use arrays for every configuration thing? Why don't they use Objects made for that purpose, so you don't have to constantly look stuff up in their docs?
edit: I have renamed this to Zimple: https://github.com/jtreminio/Zimple Such a stupid name ---------------- Sorry for not coming up with some fancy schmancy name - I'm not so good at naming things. My son has my same name. What is this? --------------- This container allows for easy dependency control. It wraps around Pimple ... so I guess you could say it's a dependency injection container container. Benefits over Pimple are ability to grab previously undefined object entry: $userModel = Container::get('\yournamespace\models\user'); In Pimple you would be required to define this previous to calling it from your code. My container uses your autoloader to grab it if not defined. You can also pass in parameters: /** @var $date \DateTime */ $date = Container::get('\DateTime', array('2000-01-01')); When parameters are passed, it uses `ReflectionClass` to generate the object for you. If no parameters, it uses `new`. Why should you use this? ------------- If you currently have a well-tested, well-written codebase using proper dependency injection, you shouldn't use this. Continue on your path, you're doing fine. This is for codebases that are a complete mess, where proper dependency injection would be too difficult to implement, where you have thousands of classes you don't want to create a definition for in Pimple. Using this container you can very easily make your code testable, since injecting mock objects to your code is dead simple with it. Just look at the tests for an example. What the fuck it's a static! ---------------- This initial version is a static container, yes. Here are the reasons: * Ease of use: Simply call `Container::get('your\magical\class')` and boom you're good to go * Completely unit tested: It's green all the way down! * How many times do you really require multiple container instances? * Dead simple to inject mocks for testing I may eventually release a non-static version so you can be super cool and have multiple containers in your application, you monster.
What reason could there be in managing time zones in two places rather then in one be?
My current gig brought me in to help them in their rewrite of their application. They had chosen Yii a month before I came onboard. I dislike Yii pretty heavily, and I didn't want this rewrite to become dependent on an old, weird framework. What I've done now is basically abstracting out the Yii framework as much as I can. I've implemented proper namespaces, used more logical folder structure, and hooked in Composer to use better libraries for things I don't think Yii does all that well. The initial time investment was non-trivial but in 4 years when they want to move away from Yii, it will be that much easier to do because they're not actually tied down to the framework - just plug in the flavor of the month in 2018. This is also why I am currently a huge fan of Silex: it provides the bare minimum necessary to be a framework, plus some convenient, optional extras. I don't feel like I'm marrying this framework - it would require much less time to move off of Silex than it would take to move from Yii.
Funny, we have several long running tasks written in PHP where I work, mainly as they share a lot of the same code and libraries as our main web app (split out into multiple composer projects). Because of the code reuse I believe PHP was the correct choice. The "memory leak" issue is easy enough to work around, and the garbage collector has improved greatly over the years. As for exception thrown without stack frame - that's caused by throwing an exception where you're not allowed to, so a destructor or an error/exception handler. That's it, period.
You can just: $query = "select * from table where id='" . mysqli_real_escape_string($link,$id) . "'"; This is immune to any funny-business. (or check it as you suggested). Comment characters and semicolons are not the problem. In your original code, you can also inject: select * from table where id=NULL UNION ALL SELECT * FROM users An attacker can get whatever information they like from your database.
As I said, you set the PHP and MySQL timezone to whatever timezone the user is using. When you read/write the time you're always following the correct timezone rules. You cannot accurately convert future (or past) dates and times to UTC because timezone rules change and are arbitrary. You can only accurately store local time and the user's timezone. If you're recording when things have occurred, like this reddit reply, then a UTC timestamp is the best choice. If you need an absolute time regardless of timezones (like a rocket launch) then also use UTC. If you're trying to set an dentist appointment, or the time a blog post should appear, you should store local time. 
but it does make a difference if you have to convert the unix timestamp in every row to use mysql date functions. This is especially problematic when you're trying to use the indexes to range limit. Suddenly everything needs to be a unix timestamp for no valid reason. This isn't to say you can't return a timestamp column in your selected rows, only that it makes no sense to use a timestamp at the point where you're searching/filtering the rows.
Yes, Justin I've seen your commit messages. You mark things as deprecated and alter return values to be "more correct", fix minor typos, and alter basic code examples. Hardly the sorts of things I'd call any sort of in-depth study of the source. This is when you commit *at all*, which is usually months and months between stops. Don't get me wrong, any contribution is better than no contribution and people are needed for that stuff, but don't use the phpdoc team as some kind of validation. There are tons of undocumented/underdocumented items in PHP that you could have tackled instead of just polishing existing work.
Haha, it's wonderful that you resort to attacking my contributions, when you find that you're wrong. I don't claim to be some master of core bug investigation. I do a lot of housekeeping. However, I also tend to tackle the weird bugs that nobody really wants to handle, because it'll take too long, without much benefit (edge cases). I also spend a fair bit of my time contributing to the PHP project in other ways. I spend dozens of hours each week in support channels, mentoring a young developer, and, when I can, involving myself in the PHPMentoring organization that I've helped put together. As for my gaps in contribution, I happened to have been busy with work, and have been supporting and involving myself with my family. I'd hardly say that undermines what I've done at all. Since we're going for the low blows, what have you contributed to the project at all? It seems like you spend your time talking out your ass in comment sections.
If it's a wrapper for Pimple, then call it Cyst or Zit. ;-)
And I'm asking what qualifies you to make definitive statements on the matter yourself, and even to claim that everyone else in this thread is incapable of offering a valid opinion. I was not using my contributions as an appeal to authority. I was responding to your discounting of everyone else as uninformed. So, given your redirection of the conversation toward the end of my own credentials, and inability to establish your own, I can only conclude that you lack any foundation for what you're saying, and are merely talking out your ass.
&gt;Of this I'm rather aware. I'm part of the doc team, which means I do a fair bit of investigating of what is actually happening behind the scenes. Actually that's exactly what you were trying to do. You're trying to tell me that because you make minor documentation fixes that you are an authority on this subject. Why bother to list my credentials at all? You've already made up your mind. The top rated comment itself is conjecture, and the most intelligent and thoughtful comments made by people with actual knowledge here were downvoted. I've seen maybe two people in this thread who have demonstrated any appreciable knowledge of the topic, and honestly you aren't one of them.
that can also be exceptions being thrown in a destructor or an exception/error handler.
Huh, I was taught while learning them it was prepared...never questioned it.
Always relevant: [Falsehoods programmers believe about time](http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time)
Your string is relative to the current date. You need to add the word "of" to get the first day of a given month. [Source.](https://bugs.php.net/bug.php?id=55046) $timestamp = strtotime("first Monday of April 2013"); $result = date("d", $timestamp); echo $result; Or simply use: ["Monday April 2013"](https://bugs.php.net/bug.php?id=40003)
Change *first Monday* to *first Monday of* Seemed to fix it for me Edit: damn phpworm beat me to it.
You didn't use "of": First Monday **of** April 2013 Per the second "note" on this page: http://www.php.net/manual/en/datetime.formats.relative.php there are can be special issues when the period you are working with is the same week that the current time is (if I am reading this correct), so you need to use the "of" to force it to go off of the first of the month... Not exactly clear on the why's, but that does fix it for me. Also note, that your code is doing **date(m)** and **date(Y)** which is improper, the **m** and **Y** should have quotes around them (otherwise on a development server, it will throw warnings that you are using undefined constants and it is guessing what you mean) 
We do something like this for our password manager. Except instead of an image, it's a symmetrically encrypted private key. To login they enter their username and password and upload their key. The key is decrypted with some securely generated random data held server-side per-user (allowing us to invalidate a user's keyfiles without invaliding the key itself). All the passwords are stored encrypted in the database with the users' keypairs, so the uploaded key is necessary to decrypt and view them. It's not just an artificial restriction somewhere in the code... The records in the database are actually just meaningless without that file.
&gt; Now in the real world, of course, you know not to put files in this directory unless you expect them to be included. But shit happens Like vim. vim tends to drop swapfiles around as you're editing. If you run that code while you have one of the files open in vim, it will try including the ".myFunction.php.swp" and either output garbage or error out. I'd go with something like: if (strlen($file)&gt;4 &amp;&amp; substr($file, -4)==".php") { Or, at the very least, stick with the tradition of dot-files being 'hidden' and use: if (substr($file, 0, 1)=='.') continue; (edit: not meaning to pick on vim, it's just what came to mind since it's what I use - other editors do this too)
Because it incurs a very slight development overhead. What's more expensive: * 0.0001% extra load on the server, necessitating the purchase of one extra server for every 10,000 in service * 30 seconds of developer time every time a function is added We make trade-offs like this all the time. Which is why we use PHP instead of C or something.
If you want to use PHP on Heroku, here's a boilerplate I wrote a few months ago. You can always remove all the remove all the CodeIgniter stuff and it will still work since all the Heroku PHP magic is in the buildback.
You should instead read general programming books, for example, on OOP patterns and stuff. It's better to be a programmer than be a PHP programmer; not sure if I'm getting myself clear but, general programming patterns can be applied almost everywhere and it's a good thing. The problem with PHP books is that, PHP moves way too fast. A book released 3 years ago about PHP 5.2 is pretty much obsolete by now.. There might be good stuff in there but a lot of OOP goodies came with 5.3 and 5.4. I will back wdmeldon in choosing Laravel, but make sure it's version 4. It'll propel you into using git, composer, mvc code, routings, **automated code testing**, migrations and seeds. 
No, store as UTC. Consistency will be your friend and will help keep you out of trouble further down the line.
Tested it, you are right. `unset($a-&gt;f);` works perfectly.
Don't forget that sometimes you don't want to convert times to the user's local timezone. If storing flight times, then the times need to be displayed at the local time for the airport. In that case you should store both the [UTC] time *and* a timezone offset. The troubles I have had with SugarCRM that does a UTC-to-local time conversion on every date fetched from the database at such a low level, where it is impossible to switch that conversion off without some serious hacking at the core...drives me mad.
A non-static version does not imply use of multiple containers.
Evangelists are like salespeople. It's hard to like them when they're in your face trying to sell you something.
Sure, kinda. If you're searching and filtering then shoving it through a function is not going to make a huge amount of difference to your day until you hit a huge scale, by which point you wont be seeking advice for timestamp handling in comment forms on reddit. If you're handling a site big enough that this stuff matters you'll either know your stuff or be fired. As I said elsewhere I use unix timestamp for portable systems because its more noob friendly but less awesome, and whatever DATETIME the SQL engine of choice uses whenever im working on a day-job project. Generally, on low level sites, it makes f**k all difference to anything.
You're missing my point. If you want to use mysql functions (for example, if you're doing intervals) and you start converting columns to mysql timestamps so that it works you lose the ability to index since it has to read in each row to perform the conversion (incurred full table scan) which can have serious performance implications even in smaller sites. It doesn't make any sense to use unix timestamps in your table when all of mysql's date, time, and datetime functionality is optimized for its own column types.
&gt; PHP by itself has NO MEMORY LEAKS Then explain why I had to use *explicit garbage collection* to prevent a series of PHPUnit methods from regularly blowing out main memory. No one ever does explicit garbage collection. I had to dig like Dug to even find out how to do it.
Dear God, no! Facades needs to die.
ok. I am sorry if I was not clear. Let me show an example by using a query. In the following query 'temp_table' was created using an earlier 'create temporary table ...' statement in the same session. (select * from users as u1 join temp_table as t1 on t1.userid = u1.id) union (select * from users as u2 join temp_table as t2 on t2.childid = u2.id) In the above query, the temporary table temp_table is refered twice. Mysql wont allow this query. So I have to create 2 separate temporary tables for doing queries like this.
Yep, indexing is broken if you rely on functions to convert stuff, but as I've said unix time ends up being a little more useful for portability (working with multiple engines) than relying on DB timestamps. But we're not talking about that here. I started the statement "they dont make much difference" because a few folks were saying unix was better at timezone work than MySQL datetime, which is obvious baloney. As far as timezones go, they really dont make much difference - which is the scope of this conversation.
Unless you're going to be using specific PHP 5.4 functionality ([outlined here](http://php.net/manual/en/migration54.new-features.php)) Then you should be good to run the same application on either PHP 5.4 or PHP 5.3
What version of Plesk are you using? 11.5 apparently supports PHP 5.4.
it is not a DIC but a simple example of service locator antipattern
Introducing a global state in codebase is never helpful. It might be convenient in short term, but later you have to pay for it with additional time and hacks.
11.0.9 - Try installing it... I did and plesk flipped out.
If you store UTC, the timezone (e.g. America/New_York), and the UTC offset that you expect to be in place when the time comes (e.g. -0400), you should be good. Then, when the time comes, your code can detect if the offset has changed, (e.g. if Congress changed the DST rules, you should see that the current UTC offset is now -0500) and adjust accordingly.
&gt; A good PHP5 application will work on PHP 5.2, 5.3, 5.4 and 5.5 - learn how to properly use OOP elements OOP in PHP was broken previous to 5.3
By broken meaning that you did not have namespaces or what exactly? I worked with 5.2 for a few months and I can't say I've had any problem to write some pretty good code (which actually follows quite a few OOP design patterns and how do you know, it still works perfectly well today).
We're still stuck on php 5.2, mostly due to legacy apps without test coverage. Too scared to update and wait for edge cases to break...
You get what you pay for. 
&gt; A good PHP5 application will work on PHP 5.2, 5.3, 5.4 and 5.5 - learn how to properly use OOP elements And also work on Internet Explorer 6, 7, 8 and 9 equally well. The release dates are comparable, after all.
Considering OP said that security issues prompted the need to re-factor; prepared statements are the way to go, not sqli...
I completely after with you.
&gt; If you ask that question, it's very likely that you don't even know the features from 5.0. I'm sure you didn't mean to, but your response comes across as very derogatory. I'm familiar with the variances of 5.0 through 5.3. However, as I'm developing this application from scratch, I want to take specific advantage of traits, new typehints, the compact array syntax, array de-referencing, etc... Basically, things that will help me write cleaner, more concise code.
&gt; Unless you're going to be using specific PHP 5.4 functionality... That's the idea. :)
5.4 is faster. You should use it. 
My apps run twice as fast w/ 5.4 than 5.3
If you are providing software that has to work on as many hosts as possible then you may well be better off using PHP 5.3. People say "PHP 5.4 is faster" but thats not relevant. If you write PHP 5.3 code and run it on PHP 5.4 then you get the speed benefit, PHP 5.4 specific syntax is not quicker than PHP 5.3 syntax. I wrote an article about [Picking Package Requirements](http://philsturgeon.co.uk/blog/2013/03/pick-php-requirements-for-packages-responsibly), which is more about making composer packages work, but it applies directly to building distributed applications too. We use PHP 5.3 for PyroCMS (we've only just been able to switch it) and as much as I would LOVE to use PHP 5.4 our users are mostly PHP 5.3, so we can't. If your users are mostly PHP 5.4 then absolutely go for it.
You're thinking of this: https://github.com/infusion/PHP Which was, of course, abandoned because he went about it completely the wrong way.
I don't assume anything, the author of the article does. I'm just clarifying some of the points.
This attitude that any negative comment is a personal attack is pretty stupid and holds people back more than anything.
You have to look at the usage numbers for your existing audience (or your intended audience) to make these decisions, not just guesswork. The most used version of PHP is always 2 points behind t he leading version. 5.1 was popular when PHP 5.3 was released. 5.2 was popular when PHP 5.4 was released. 5.3 is most popular when PHP 5.5 is about to be released Sad, but true. It takes time for version numbers to proliferate through.
Accusing someone that "you don't even know" something doesn't accomplish anything constructive. Regardless, I consider the matter over.
Yes, the application is going to be SaaS, but there is the potential for someone to pay for a license and run it on their own server. I've decided to develop for 5.4 - someone willing to purchase a license will likely be able to run it in a custom environment.
that's why, if i'm forced to use external hosting, configure servers myself. i hate that managed crap.
To be fair, the shared hosting on my side of the pond is actually quite decent. The most common hosting providers in my country tend to upgrade to the latest version of PHP within 6 months.
Could you expand on "he want about it completely the wrong way"? I couldn't find anything on the project page except an issue.
Was it by any chance a [PHP implementation in PHP](https://github.com/ircmaxell/PHPPHP)?
OH! Then definitely use PHP 5.4, and PHP 5.5.0 when its released.
Yeah that sounds like a reasonable requirement if they are specifically interested in paying for a license. Pyro needs to be available for everyone everywhere without us even talking to them first so its 5.3.
It's really not that bad. Try using any of the popular nosql abstraction layers - Doctrine ODM for example. You'd need to do something similar to: //[obtain document manager as $dm] foreach($dm-&gt;getRepository('products')-&gt;createQueryBuilder()-&gt;sort(array('price'=&gt;1))-&gt;limit(5)-&gt;execute() as $product
I'm still waiting for a solid RPython VM for PHP. Less convoluted than HipHop (to a degree...) and with JIT compilation off the bat. There was an [effort](http://morepypy.blogspot.com/2012/07/hello-everyone.html) last year that implemented PHP 1.0 (no objects, basic functions, vars, etc) and blew HipHop and Zend out of the water, but of course how much of that performance would remain when implementing the fully PHP spec is anyone's guess.
This wasn't a recent change. Mysqli dates back to the early 2000's and PDO came out around 2005. It's taken a while the general usage to move away from the older methods however.
oh, well, when I learned it was with the old mysql, and when I came back mysql was being deprecated for mysqli. I assumed it was new because it seemed so much easier to use than mysql!
If you plan on using 5.4 just because you want to use the array shorthand, don't ! Develop on it if you really want to use traits and the other stuff.. Old $arr = array(1,2,3); New $arr = [1,2,3]; I'd be quite mad if something was incompatible because the developer decided to use [] everywhere, making it 5.4 for nothing.. 
I'm curious as of why do you think that, could you explain? 
No, array shorthand isn't the compelling reason I want to use 5.4, but it is a nice addition. :)
&gt;I completely after with you. wat?
Probably just basic stuff like form inputs, GET variables, PDO, etc. Something like this shouldn't take more than a day or so to write. Also read up on SQL injection and proper escaping to make sure your site's not vulnerable. This is especially important on a pastebin type site since your users will probably be posting code that may *accidentally* cause problems even if not meant to be malicious.
We have to run php as Fastcgi if we want 5.4 on our domains. But if 11.5 supports 5.4, then it may be worth the upgrade
Yep - when interacting with the database, the concept of "prepared statements" is also very useful for safe communication. One could also look into some of the microframeworks (like Silex or a few others) to accelerate development, composer and packagist to find reusable code, and using PHPUnit for testing if wanting to learn "best practices".
Instead of trying to implement your own flawed design, try contributing something to an existing project, such as [Stikked](https://code.google.com/p/stikked/).
If you're comfortable with it, I would also suggest looking into MVC frameworks like Laravel or Codeigniter. These frameworks really make it sane to build multi-page web applications with heavy user interaction. They also allow you to implement RESTful applications ( that is, navigating to HTTP GET http://example.com/paste/1 would return the paste whereas navigating using HTTP DELETE http://example.com/paste/1 would remove the paste from your DB, provided you have authenticated the user)
Contributing to open source is great, and everyone should try to do that. But the OP seems to be interested in getting started with PHP again. So in thise case, the entire process of building a pastebin is more important than the final product/project.
unfortunately i am quite familiar with your pain ... I have been dealing with the same issues on a daily basis. The worst thing is that in the codebase that i have to work with currently, there is not even any possibility to refactor it. 
Shouldn't be too difficult to rewrite the SQL queries, etc. For MySQL
+1, I appreciate this suggestion. I'll be looking into this project, I'd love to implement a pastebin on my personal site for all my random codes; and working on OSS always looks good when applying for jobs.
Because OP explicitly said it wasn't HipHop. 
For escaping output which is printed to the page, definitely read up on the [OWASP Cross-Site Scripting prevention cheatsheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting\)_Prevention_Cheat_Sheet). In PHP you will be using [htmlspecialchars()](http://php.net/manual/en/function.htmlspecialchars.php) as your main escaping function. Be certain to carefully consider the arguments to this function, you probably want ENT_QUOTES for flags, and UTF-8 for encoding. If you're not using a framework which provides it, you will want to make your own escaping wrapper function so you don't have to specify these arguments every time. On the database side, using [PDO's prepared statements](http://php.net/manual/en/pdo.prepared-statements.php) should be okay. If you're providing a "raw" link for pastes, be sure to [read up about browser content sniffing](http://www.adambarth.com/papers/2009/barth-caballero-song.pdf), which could cause visitors' browsers to unexpectedly interpret an uploaded paste as an HTML page with embedded attacker-controlled JavaScript.
_although DateTime sucks because it uses strtotime_ You can use timestamp to instantiate DateTime like that: new DateTime('@'.$timestamp);
What spec? 
Since you're dealing with information that needs to be returned exactly the way it has been put in, I'd also do some reading regarding character encoding.
If this is what you meant: ?t=news&amp;article=304 Where I'm using 304 as the article's ID in the database. You could also use the article-name whilst replacing spaces with '_' and converting it back again.
That sounds close to what I want. I now realize this may be more difficult than I previously thought. I'd like to be able to sort my news page by Announcements, Siute Updates, etc., so that clicking any of those navigation links brings me to the news page only displaying those types of posts.
Thanks so much for the response, and I apologize for my poor choice of subreddit for this. Thanks for the correctly formatted code. I have to admit I'm mostly copying and pasting it as I go, so it's really good to know I was close in my own approach to the indentation. Regarding C, does this mean that my 404 message in invalid? I assumed that would show the message anytime an invalid link is clicked? D) is totally beyond me. I'm assuming that was your answer to my main question? I have a 't' array, now I'd like to add an 'n' array. Is that what you're indicating how to do?
?t=news&amp;n=announcements&amp;a=0 (you can exclude "&amp;a=0" "a=0" should be the announcement ID in the article database Alternatively, "a=0" could be replaced with "a=article_test" which would load the HTML document with that name. $works = false; if(isset($_GET['t']) &amp;&amp; $_GET['t'] == "news") { if(isset($_GET['n'])) { if($_GET['n']) == "announcements") { // Show announcements $works = true; } else if($_GET['n'] == "etcetera") { // And so on... $works = true; } } } // If "$works" is false if(!$works) { // Display 404 } Please note that normally I'd use clean formatting. I'd for example remove the brackets ('{' and '}') on some if-statements to clean it up (Your if-statement, for-loop, while-loop, foreach, etcetera do not require brackets if the action that is to be executed if the statement is true is only at the length of one line of code.)
Regarding C: The end user will still see your "404 error" as it should. But the browser thinks that everything works perfectly. The browser doesn't know about the 404 whilst the user does. Regarding D: The data passed over the URL (?var1=democontent&amp;var2=additionalcontent&amp;var3=etcetera) are called GET. The data that you can't see in the URL (for example when you're logging in, since nobody should be able to log into your account by copy-pasting a link) is called POST. Then there are SESSIONS which are there to store data over multiple pages (it remembers data on the server assigned to a specific browser and a specific computer with the use of cookies.) GET uses $_GET['var1']. POST uses $_POST['var2'] and SESSION uses $_SESSION['var3']. And ALL of those ($_GET, $_POST and $_SESSION) are arrays. (I'm going to write it as easy as I can.) Arrays are a group of data bunched into one variable. (Please note: GET, POST and SESSION are not all of them!). Arrays can be custom as well. If you're trying to access a variable, you'll be able to read and write data to it. You'll also be able to manipulate it. But if you're trying to access a variable that doesn't exist (example 1) it'll crash there and log an error thus (that part of) the script stops there. To make sure that you're not trying to access a variable that does not exist (THIS INCLUDES VARIABLES IN AN ARRAY) (for example $_GET['articletobeprinted'] you'll need isset to make sure that it exists. "isset" returns true if the variable exists and false if it doesn't. Example 1: $array = Array(); $array['cheese'] = "green"; echo $array['peanutbutter']; This will crash or at least throw an error because "$array['peanutbutter']" doesn't exist. And thus won't work like you want it to (print "green").
Depends what you mean by 'invalid'. It could be 'invalid' in the strict sense that HTTP is a standard protocol that you should try to follow in the guidelines, and if `index.php?t=random` is an invalid link / doesn't exist then your web server should return a HTTP 404 response. There are many web sites that routinely get this wrong, though (they'll send a HTTP 200 OK page but with content that says to a user that the page doesn't exist)... so I thought I'd just mention The Right Way To Do It™. I didn't quite get what you wanted from your original post, but I have some of an idea from your comments. Take a look at this example - http://pastie.org/7369709
http://www.php.net for more info. They have a manual there. But the "manual" is FULL of small tutorials by the developers who develop PHP and the developers who develop websites.
`[]` syntax for arrays alone practically makes it worth it for me...
You're awesome! And yes that's why I meant by invalid. I'm glad you told me the right way to do things! Thanks for the example. I'll be returning to this tmrw with a fresh mind and will update this post when I have it figured out. :)
Thanks again. Lots to take in but it's all very helpful. Hopefully tmrw night I'll have a fully working navigation system!
An object with a type, where you can see what's available by using auto completion in your favourite IDE, or generate a documentation for it. There is no need for messy documentations with guesswork anymore.
I'm curious - you page says that you run PHP behind Apache as FPM. Why don't you directly use PHP-FPM from nginx?
Client wants php. What can i do )
This is anything but modest. Seriously, take a look: https://github.com/WordPress/WordPress/blob/master/wp-includes/admin-bar.php#L18 You can't refactor this - it needs to be started from scratch.
I hope you were honest and told them you don't know PHP. PHPixie is a newer framework that confusingly uses conventions from older-generation frameworks. I wouldn't bother with it as there are many more high-quality frameworks available.
You're trying to turn WP into something it's not. By iteratively replacing old code with new code, you can improve the code-base, but it will inherit the things that you consider broken. Either you will not change enough (so that it will still be broken), or you change too much (at which point you should've just created a new CMS from scratch). I don't know, maybe I'm wrong, but this discussion pops up every year or so. Wordpress is not going turn into something else. Something else/new will come along, and take it's place. This happened before, and it will happen again. Greymatter, blogger, HotMeTal, Golive, PHPnuke, Movable Type, Mambo, Vignette Storyserver, and countless others were all good systems in their own respect, and they've all become irrelevant. Well, except for Blogger, but that's because Blogger never tried to become something that it's not. If you're really willing to spend a chunk of your time on building a 'better wordpress-like CMS', you should join the teams of people working on something new: Drupal 8 is moving over to Symfony. Phil Sturgeon's PyroCMS is good and modern, and ^([shameless plug alert]) I'm working on Bolt, which is a lot smaller in scope, but works pretty well. 
Was supposed to be a bit tongue-in-cheek. http://en.wikipedia.org/wiki/A_Modest_Proposal
We want PHP developers to be able to use .htaccess files. Many existing PHP apps even rely on being able to use .htaccess files. But even for PHP apps, Nginx is still the public-facing server.
Not really. Makes perfect sense. unless you start comparing apples to oranges. Even then it still makes some sense though strict rules of logic will not apply. Solution: do not compare apples to oranges.
Here is a post that covers some popular PHP frameworks: http://mavrck.com/blog/2013/01/ive-evaluated-php-frameworks-and-the-answer-is-laravel/ The author is obviously pro-Laravel. But it is, in my opinion, a good listing of the most popular PHP frameworks.
If `$a` and `$b` should not be compared then all of `$a &lt; $b`, `$a &gt; $b`, `$a == $b` should simply return false. That's obviously not what PHP does. Rather it tries hard to get *some* order into it, usually resulting in an order that does not make much sense. Just my opinion.
PHPixie is incredibly lightweight, because there is barely any code to it at all. Sadly that doesn't make it good, or particularly usable. The loader is inefficient, the community is tiny, nobody I know is actually using it for anything and the lead developer (only developer) is a teenager who is doing this mostly as a learning exercise it seems. The other concern is the developers dedication to doing things the old way. Modern PHP frameworks are mainly using Composer, giving them solid, tried and tested packages for their core. Laravel, Symfony2, Zend Framework 2, Silex, Slim, etc all use this approach, and as such are much much more stable than something a kid has been making in his spare time. I don't think thats unfair to say. It's about numbers. I would strongly recommend Silex or Laravel 4 to you, as they cut out the learning curve involved with getting started on SF2 or ZF2. Laravel was written by Taylor Otwell who has a strong background in .NET so you might find some patterns in there that you recognize.
Or, [this](https://www.pyrocms.com/store/details/import_and_export). WordPress could easily be improved with a rewrite, which would destroy compatibility with their thousands of addons. Those addons are the only thing keeping WordPress in the money, so they'd basically destroy their business by improving their software. They could make some staged plans, get their addon devs involved, field surveys about when and how changes should come into effect and refactor over a series of 0.x releases with one final big x.0 like a sensible CMS development company, or they could do what they're doing: beat this same old horse until it dies.
Calling me a teenager doing an excersize is Very not true, i'm actually 25 and have been writing php for like 9 years now. I dont really believe in reusing packages because i believe i can better integrate stuff if its all done by me and actually make something better. The component reuse path leads to less variety and general stagnation.
My opinion is of course completely biased, but if you already got through the tutorial than give it a try )) Im always easily accessible on the forums, and i do care about people using phpixie, so ill provide as much support ad possible =)
Crap, sorry for getting your age wrong. I could have sworn I read you were 16 somewhere, I think Amy Stephens might have told me to be nice because you were so young. FuelPHP was originally built because we felt like we could take some ideas from existing frameworks and improve on them. Laravel 3 was also built with the same premisse and improved on FuelPHP. What does PHPixie improve? The code quality is low, the standards are inconsistent, the documentation is extremely weak and the community is almost non-existent at this point. Do you have a roadmap for improving any of this?
They could keep the way the plugins work and re-write the core. I'm no Worpress guy so I'm just talking out of my ass.
Looking at the answers, if you just took NAN and INF out of the equation, a lot of the "exceptions" go away, which makes sense because NAN is weird and exceptional. PHP's comparison operators are only weird in that they do their best to let you compare things from two completely different sets, so arguing from set theory is pretty pointless. The other option (which other languages take) would be to just throw errors when people try to compare a class to an array or a string to a number, but PHP is loosely typed, so it doesn't. **TL;DR:** PHP lets you compare apples and oranges if you want to, but you'd better be prepared for some weirdness if you do. Otherwise it's pretty straightforward.
PHP is a loosely typed language, which has lots of effects, this being one of them. And returning false wouldn't really help - the best thing imo if you want a strongly typed language is to throw an error if you try to compare two non-comparable things. Having them all result in false just causes different problems and weirdness.
So, you can make PHP comparison operators do silly things if you're careless or stupid. PHP auto-casts the type of variables into the appropriate type, wherever possible, if they are not already the appropriate type. Many developers jump into PHP and for some reason think this means that they *have* to ignore types in PHP. That's a ludacris thing to think for any serious developer in nearly any language. PHP does that as a convenience instead of crashing the whole script, because PHP isn't compiled and was designed for the web where users *might* be able to affect data-types, so quirky behavior is often *preferable* to crashing the entire script for the end-user. However, the PHP operators are not at *all* weird if you take care to keep track of types, which you would anyway in any language that *doesn't* have these quirks. In other words, as I said to begin with, this only becomes an issue when you're careless or stupid, (i.e. too lazy/time crunched to pay attention to it or don't know any better). If you make liberal use of the is_* functions, as well as the instanceof operator, you shouldn't ever encounter these kinds of problems, because you'll *know* where it will and won't be okay to mix certain types.
To answer some criticisms regarding this submission (or its title?): I do understand that PHP is a loosely typed language and as such comparison between different types is bound to have unexpected results sometimes. The point behind this post is more that with comparisons in PHP you cannot trust the "common-sense" logic you could usually employ. Some things only break in edge-cases, e.g. the (ir)reflexivity when comparing with NAN. Others already fail with more common values, e.g. the transitivity of the == operator. I think it's useful (or at least interesting) to know such stuff, though maybe that's just me being crazy :)
Ya, as one of the comments to the answer states "MHO operators do follow math rules, but only when dealing with the same data types. Type casting is what really creates the confusion here (and in many other situations). When comparing numbers and strings and special values type conversions are done before the operators, so strictly speaking comparison operators are not confusing, casting is... "
Thanks! This is a lot more than I bargained for originally, I really only considered SQL injections. Is there anything else I should be aware of?
I will now use the [neuralyzer](http://en.wikipedia.org/wiki/Neuralyzer), so you will forget about Pixie. ... That's it, you no longer know anything about it. Hope you get the message (=
This really depends on what version of "common sense" you're operating from. If you're aware of how PHP works then common sense might mean you don't make any of these mistakes. I'd agree that someone unfamiliar with PHP may make these mistakes, but then again, they're making them because they didn't bother to learn how the casting system operates. So depending on your perspective, you might blame PHP for not being obvious, or you might blame the user for not educating themselves.
Well I actually decided to give it a try, as I had some spare time inn the evening, and it seems to do it's job pretty good. I don't know what's the state with the other frameworks you guys mentioned here, but this one seems quite straightforward an easy to use. I'd compare it with Nancy in the .NET world, but Nancy has a bit more limited features. I sure hope it continues to go as smooth with it as it does now.
alright and I fix this how?
Agreed. NAN intentionally has that behaviour, as per IEEE rules for handling it, so it's unsurprising. If that's taken out of the equation, PHP becomes a lot more sane. Anecdotally, I've never even seen NAN used in PHP scripts, so I don't think it's something most people need to worry about.
I've not said a single lie, I was mistaken about your age, but I thought it was accurate. Don't accuse me of making things up, because I don't. You seem to have run the code through some sort of formater too, or at least manually fixed all the indentation. Last time I looked brackets and indentation were over the place. As for the other issues, I've put a few on the GitHub [issue tracker](https://github.com/dracony/PHPixie/issues) for you. But, [this](http://phpixie.com/tutorials/database/) is not documentation, thats just a lot of code. Really, you've made a start but what is there is a very very basic start and you really need to do more before you, I or anyone else can responsibly recommend this framework to anybody. Finally, saying your classes have their properties listed with visibility scope tags is definitely not documentation, sorry.
I can appreciate the sentiment, but for anything non-trivial shared interfaces will be completely useless. Why? Because the *implementation* behind each interface will be non-trivial. Let's say an ActiveRecord interface is defined and libraries begin to arrive utilizing that spec. Everything will be fine and dandy as long as everyone is building their own version of MySQL wrappers and calling it a day. But the moment you attempt to to utilize a conformant library that uses MongoDB as its backend instead, you substantially changed the expectations of the implementation, and its intended usage. Let's say you were using the MySQL library to store snippets of user-submitted JavaScript for a gist-like clone; suddenly your database server becomes a vector for server-side JavaScript attacks since MongoDB supports using JavaScript code to query the database. There's a reason that everyone builds their own CMS/framework/tools and repeatedly reinvent 99% of the wheel: because there's always 1% of the code that is specific to the problems they are targeting and are non-portable or useful elsewhere. Establishing shared interface specs will achieve little more than spawning a slew of conforming but repetitive libraries that would be little removed than being a framework themselves.
If $a and $b should not be compared, an error is significantly better than returning false! 
That should be fairly comprehensive, and you can count yourself as a pretty good PHP developer once you've built a secure working site on those principles. Will you have an account system? That brings another raft of potential security holes to be considered. I love practising site security, so if you want a code review, give me a yell. 
and enabled by default &lt;?=$var?&gt; tags, those 2 are amazing for speeding up coding and making it look cleaner
Having the interfaces outside of the framework is a major advantage. Your application layer is now framework agnostic. 
&gt; I do understand that PHP is a loosely typed language and as such comparison between different types is bound to have unexpected results sometimes. Ah, not really. Python is also loosely typed and doesn't have any weird behavior. It's just the fact that people don't understand that PHP does a type conversion when comparing. It's just a design decision. It's also not weird, PHPs comparisions / type casting follow a certain logic.
With Laravel 4 coming out in less than a month this is extremely unfortunate timing for a launch. Some theory remains the same, but this is not going to be very useful come May.
This is not the sort of problem the PHP-FIG is trying to solve. Logging, HTTP Messages, HTTP Client, Caching, etc are the first on the list and these are easily approachable with interfaces, no matter what content is on the backend. Your assertion that anything using a shared interface is going to make libraries repetative (or 99% the same) is ridiculous. Interfaces can be optional (a non-compliant logger could add an optional compliant interface exposed via a method) and any features can be added on top of what is defined in the interface, so there is little room for complaint on this subject.
yes more useless trivia to vet programmers is exactly whats needed
You won't ever write any software that keeps totally up with the requirements over time within 2 years, except you are working for a bank or the government. Agile and "RAD" suggest that they are there to solve problems with flexibility, but they really don't. Programs are in general like machines. But with the exception, that nobody will try to update all VW Golf 3 cars on this planet with top notch board computers and rain sensors and shit. With software, people try that. We can be flexible to a certain extent, but no technique (not even DI) will enable you to realize every requirement which comes up over the years without having to struggle with your current codebase. Also, you will realize that a lot of flexibility you implemented into your software, is not needed and when it's needed it's not flexible anymore because it's outdated. When i think of what i thought is flexible 5 years ago, it's really more valuable to focus your resources elsewhere. This is why i still like very atomar libraries above "frameworks". Frameworks aren't mostly that flexible when you try to get rid of them, simple libraries are. (i don't mean functional libraries, i mean component collections) Like Phil said, this is anyway not the purpose of PHP-FIG. They aren't there to "enforce" design patterns, they are more like there to give a state of the art of the language.
And what is wrong about those tutorials really? They are full of examples. "Properties listed with visibility tags" - what? That's not at all what i ment. I ment that a lot of people document just the public classs API while phpixie has privates documented too. If you are looking for the conventional style docs check http://phpixie.com/api
Yeah, you are correct. Mixed that up a little.
It benefits a car manufacturer to release new models quickly so I can't accept that as a comparison. In most cases we don't want our application to age quickly. What I describe in the post is an ideal world situation that chances are will not happen, however, even if 5 years down the line popular frameworks are implementing shared interfaces for half of their components, porting to a new framework will be much easier than it is now. Personally I already just use a lightweight routing layer and bolt on the components that are needed for the job and I feel this is a better approach than the framework route in many situations but frameworks still offer huge benefits so anything that can make life easier when scaling is very welcome.
I would be happy to pay for a Laravel 4 course and that's what I expected. Looking at the course structure, it actually sounds really good, just a shame that it's for L3. I am disappoint
Yes, it's an antipattern. You could just implement Zimple as a global variable too. It's all the same - a global state shared across many objects that is not subject to replacement. That said, it's not for new applications - it's for legacy apps where proper DI was never applied to start with.
I can't say you're doing anything wrong or right: you've not shared enough code for that. At any rate, is there a reason you chose not to use Doctrine DBAL for database access? It is very well tested, vetted, supported, documented so I would definitely recommend that. I'd be interested to see what your common\view class is up to. If you're literally just setting content, you might want to think about building some kind of templating engine, or (what I'd recommend) look into using [Twig with Silex](http://silex.sensiolabs.org/doc/providers/twig.html) edit: [What he said](http://www.reddit.com/r/PHP/comments/1bz525/my_first_silex_code_please_review_if_anything_is/c9bihud)
You could try using [Doctrine DBAL](http://silex.sensiolabs.org/doc/providers/doctrine.html) as it's probably more mature and flexible than your own class. You should also probably consider using [Twig](http://silex.sensiolabs.org/doc/providers/twig.html) for the same reason.
Haha, I must have posted just after you! Agreed, man, agreed :P
The page you linked to isn't loading for me. But if you're looking to scrape data from another website in the way you are there is an easy class to use called Simple HTML DOM. You can find it here: http://simplehtmldom.sourceforge.net/ Here is the manual: http://simplehtmldom.sourceforge.net/manual.htm It's fairly simple to use. 
Honestly I don't think I've ever come across any of these edge cases in my PHP programming, apart from possibly `'a'==0` once or twice. I've never compared anything to NAN or INF, PHP has better methods for that (e.g. `is_*` functions).
&gt;At any rate, is there a reason you chose not to use Doctrine DBAL for database access? I dont believe in ORMs. I would rather use raw sql with pdo.. For templates I am using a very basic templating object using only out buffering without any special syntax.
Right and when those docs are fixed that will be a step forward, but just relying on API documentation and about 5 pages of Tutorials which are mostly code dumps with a few comments is not good documentation. We can agree to disagree there, but newcomers will not be impressed with this the way it is.
Some of you guys seem to be getting defensive about this. It's ok to say that PHP is a quirky bitch, because it is. https://gist.github.com/philsturgeon/5281485 Thats a fun one I came across the other day. Why? Because some dick developer put `$i = "";` into the code, then I wondered what was happening. Looking into the theory of how this stuff works is an academic exercise, which is sometimes fun and sometimes interesting. As many of you point out, most of these are avoidable by decent programming, but just avoiding problems doesn't mean there are no problems. They are trivial, but they exist, and pointing them out doesn't hurt. You also don't need to tell nikic how PHP works, because he's a core contributor.
Gotta say, I agree with /u/philsturgeon pretty strongly. Please don't misinterpret this feedback as an attack on you as a person or as a developer. It's clear from your work ethic that you're a person who enjoys making things and wants to do it well, and that makes you a kindred spirit. Other people like you want to help. Many of the comments in your code are boilerplate, or otherwise covering up for shortcomings in the code itself. For example: /** * Mysqli database connection object * @var mysqli * @access public * @link http://php.net/manual/en/class.mysqli.php */ public $conn; Now, perhaps there would be no need to document what that `$conn` variable was if its name was a full English word such as `$connection`. And surely the fact that it's a public variable is already more clearly denoted by the presence of the `public` access modifier three lines below? There are also many comments of the following form: /** * Generated by PHPUnit_SkeletonGenerator on 2013-02-08 at 21:28:15. */ or /** * Sets up the fixture, for example, opens a network connection. * This method is called before a test is executed. */ Automatically-generated comments are not good. It's better to omit a comment block completely rather than use a tool to fill in missing ones with boilerplate. A comment should always contain unique, new insight unavailable anywhere else. Anything less simply trains you to ignore all comments. Also, the following approach to database connection management is deeply problematic: DB::query('select')-&gt;table('fairies') -&gt;where('name','tinkerbell) -&gt;execute(); I'm very pleased to see that you have a suite of automated tests for your framework and it really confirms for me that you are a serious developer. However, your multiton approach to managing database connections deprives those who use your framework of the same opportunity. Any piece of code containing a static call to `DB::anything` is shackled to that `DB` class and cannot be properly isolated for unit testing. This is especially problematic as code that interacts with the database is often some of the most important to test thoroughly. Not to mention that it makes it altogether too easy for any code anywhere in your application to access the database, which is highly likely to lead to a lot of cross-cutting concerns in applications built on the framework. I'd encourage you to read a bit about just how harmful singleton/multiton design can be: * http://googletesting.blogspot.co.uk/2008/08/root-cause-of-singletons.html * http://oncodingstyle.blogspot.co.uk/2008/11/singletons-deemed-dangerous.html Also, very few PHP projects these days use all-lowercase filenames for classes. In fact, the state-of-the-art these days is PSR-0 compliance, and I'm very surprised to see new code being written that doesn't follow that standard. Same goes for Composer support: gotta have it these days if you want your project to be taken seriously as a modern PHP codebase. If anything, the reason I've taken the time to write this comment is that I recognise myself in your project. I had a similar, very quirky one-man PHP framework project of my own a couple of years ago, and I was making many of these very same mistakes in it. Edit: BTW, the sexual innuendo you're creating by anthropomorphizing the framework as a scantily dressed female pixie who "likes to have fun" and is "easy to start playing with" is a dangerous game to be playing. This is a friendly word of warning: if you ever get any significant press coverage, the tech community at large will burn your public image at the stake if they notice [this](http://phpixie.com/contribute/). And in case it's not clear, I think I'd side with them too.
&gt;Doctrine DBAL is not an ORM. That's what Doctrine ORM Sorry about that. I took a quick look at Doctrine DBAL and I think I will use it. Thankyou. &gt; Also, "I don't belive in..." in relation to technology is just... well, silly What I meant was this. ORM cannot completly replace SQL. So why learn two syntaxes. Because we can use ORM syntax for simple queries and SQL for complex ones? Anyway I think I shouldn't have said 'I believe'. All I meant was, I think they are not worth the trouble. 
No, you're misunderstanding the issue. The libraries built on top of the PSD specs will have different expectations, not the PSR interfaces themselves. You'll likely have to shim your way around implementation edge cases.
awesome thanks. I checked the link and it still works for me, but here's a screen shot too. It's just a bit of text and then a table. http://imgur.com/M2lkRKe
For a good example of a well-built skeleton, look at https://github.com/dustinwhittle/Silex-SymfonyLive-2012/tree/master/Silex-Kitchen-Edition Just remember: Silex is good for you if you are comfortable creating your apps architecture yourself.
I still can't get to it. It looks like some military related URL so I'm assuming it only allows access from the US or certain countries. I can't trace route it either, times out just before the US. Seems to work fine with a proxy though, so I was able to look at the source. So in your code do something like: include('simple_html_dom.php'); $html = file_get_html('https://www.manpower.usmc.mil/cutting_score_portlets/cutting_score/showScores.jsp?dutyid=1&amp;month=Apr-2013') $elements = $html-&gt;find('tr[class=DataGridRow],tr[class=DataGridAltRow]'); foreach($elements as $element) { $primaryMOS[] = trim($element-&gt;children(0)); $score[] = $element-&gt;children(1); } The $html-&gt;find line searches for all &lt;tr&gt; elements with a class of 'DataGridRow' or 'DataGridAltRow'. Next loop through them and put them into arrays by selecting the children. Read up on the manual I linked you earlier for further explanation. I can't access the site so I haven't tested any of the above, but what I remember from the class it should be alright.
Finally! God, it's a breath of fresh air to hear someone actually criticizing Wordpress, I mean it's like a freaking circlejerk in this place, what with all the people insisting that Wordpress is perfectly fine, that PHP4-style procedural code is better than OOP, and that `mysql_query() or die()` calls in your template is actually good coding practice. But one thing: You forgot Composer integration. I'm thinking August 2013 sounds reasonable? Let's get on this, I've got the Mountain Dew - can someone else get the Xbox?
Yeah, but these types of posts show up on a weekly basis here (and a daily basis on SO). While you do give a really good answer -- which I suspect is the motivation for you posting it here in the first place -- it's such a worn-out subject..
This looks great - looking forward to seeing a Vim plugin to get things moving :)
The point of an interface is to provide a contract to expose public methods for this exact reason, by injecting any implementation of an interface, the understanding would be that the implementation would behave in the same way as any other implementation. I'm not describing other PSR specs but the interface defined by PSR-3 (https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md#3-psrlogloggerinterface) and the interfaces that that are to follow in upcoming PSRs.
My 'vision' is of a climate where the shared interfaces will simply make things easier, it is implied that there are certain exceptions to the rule but there are many topics where a shared interface could benefit everybody using it.
Which is all fine and well for the type of interfaces that can be trivially defined where a common implementation could coalesce. . .but for anything non-trivial such commonalities wouldn't exist. The PSR specs might cover a lot of boilerplate code but they're not going to replace the need for larger-scale frameworks, and the plane of benefit will likely be much narrower than you imagine.
Exactly, but the OP seems to envision the FIG to eventually abstract away any need for frameworks, which is obviously not going to be the case.
See, and coming from my decades of programming experience I can tell you that the "exceptions" will be the rule for everything but boilerplate code. The PSR might specify a shared interface for everyone to implement but then you enter shim hell anytime you actually try to do anything non-trivial. . . The greatest benefit will come from defining interfaces that are relatively well-defined, like HTTP requests, but things that frameworks are actually built around like ORMs and authentication layers will be too generic to be really useful.
You're passing the limit of `int`. Use BC Math Functions : http://www.php.net/manual/en/function.bcadd.php edit: nm I'm an idiot. $foo = 1.30101084E+17; printf('%d', $foo);
Brick wall... The simple point is, that however many "non-trivial" implementations are going to be coming, this is still an infinitely better situation to be in than right now.
Better? Perhaps. Utopia? No. And whatever work the FIG does they don't need to be hurried, that already bit them in the ass with PSR-0. And what might I ask do you mean by brick wall?
No, not the case at all, I'm providing an extreme example of an ideal world that I explain will likely not happen, this does not however mean that the dependency on a specific framework will not be loosened.
The idea is that we are provided with with interfaces for non-trivial functionality that provide us with tools to build the trivial stuff ourself, this is purely an OPTION that will allow developers to be better prepared to build applications without the need for a framework. It's a lighthearted look at an ideal world. Nothing more. The point is that a framework is not always right for the job, PHP-FIG whether they intended so or not are making the step into building good applications without a framework that little bit easier. And the hurry up is simply a nod to me welcoming what they are doing.
Your code is borked.
Could you elaborate on *borked*? I'd appreciate the input.
Never said they weren't good things, just pointing out that the expected improvements will likely not be as beneficial as the OP seems to imagine they would be. If you want the FIG to be as much of a benefit as possible to the community than realistic expectations of its efforts should be promulgated.
 https://github.com/wwwroth/sanitize/blob/master/function It looks like part of the file/code is missing, those functions should be within a class.
When I'm developing I just toss those functions within a input validation class so I just posted the snippit of PHP as functions. I'll update the repository and make it follow OOP. I didn't at first because what's the point of creating a class and object for one function? Edit: I'm new to git.
In case /u/chriswatt wasn't specific enough. 1. Why doesn't your file end .php if it's a php file 2. Why are you using `$this` when not in the scope of a class 3. Do you have an existing mysql connection open for mysql_real_escape_string to work with 4. mysql_real_escape_string is deprecated 5. Remove the closing `?&gt;`
Understood. I don't get why any injection of realistic expectations in this subreddit is immediately greeted with such rampant antagonism. Programming is hard; shared interfaces, standards, frameworks, etc. are mere glancing blows at inherently difficult problems. I was just pointing out that the scenario you paint is hardly as rosy as your article made it seem.
Me: "Framework agnostic packages are inherently trivial; frameworks will still likely be required. Also, shim hell." Everyone seems super-excited to rush after other languages cool toys; no one seems to realize they trade a set of lower-level problems for higher-level and thornier ones.
Hi! I would want to say.. nothing but encouragement from me. Thinking about security, and getting into open source are great things. However, you just wrote some code that doesn't really help most new projects. For one, the "mysql" functions are now old and will be removed in a future PHP version. Also 'magic_quotes' have been removed some time ago. I would also not really call this 'sanitizing'. These functions do the following: They _escape_ strings and arrays containing strings specifically for use in MySQL queries. So it would be better to call it 'escapeForMySQL', because in a lot of other contexts that are not mysql, (other databases, you name it), this will not do a good job sanitizing, if at all. So, one suggestion.. How about taking a look at PDO? It's modern and here to stay. Then you could extend the PDO class and add a function that does precisely this, specific for the database-type you are connecting to? Cheers, and I hope this helps.. Evert
what error does it throw?
PHP warning: mysqli_query(): couldn't fetch mysqli in /Applications/MAMP/htdocs/file/index.php on line 11 (referencing line 11 in the code above, not in my local script)
But this gives me 548837376 not the starting number of 130101084000000000. Really making my head hurt this.
Are you sure? http://codepad.viper-7.com/9GQq1W
Very nice!
There is no real reason to extend PDO to add this capability. Parameterized queries are a much more robust strategy. 
well, require_once won't include a file if you already included it else where. if $link is getting defined in connect.inc.php you just want to use require all the time. A better way to do this would be to use a database method that returns a reference to the connection or something instead of including the file all the time. For example this [http://www.ibm.com/developerworks/library/os-php-designptrns/] (singleton) example is what I would do. Just use your second code snippet if that works for you.
You're mixing up "framework agnostic packages" and "interface driven packages" assuming they are the same thing. A package doesn't need a PSR interface to be framework agnostic. http://www.12devsofxmas.co.uk/post/2012-12-29-day-4-mixing-and-matching-php-components-with-composer I wouldn't call Eloquent trivial, nor is it a shim.
Thanks for the comments- I appreciate the criticism. Looks like I have some catching up to do on PDO as well as mysqli. I'm a self-taught developer so I'm glad you brought this to my attention and I begin to use more current API.
That was a remarkably helpful and positive comment. I like you. :)
http://www.yiiframework.com/wiki/154/impersonate-users-within-yii-framework/
Guess you require this file in many places, so it can't be loaded again this time (when using require_once). I also guess that you have smth. like this in the file: $link = mysqli_connect(...); If so - you MUST require this file only once, because otherwise you'll end up with 'too many connections' error, or smth similar.
Why would I memorize some random video? OPs code was fucked when he posted it, had functions referencing $this when they weren't in a class themselves.
It's hard to keep track of all the things that are going on pretty much anywhere, but as soon as you are up to date, I guarantee that it will be pretty easy to keep riding that wave and always be strongly aware of the latest developments. Good luck :)
I agree that parameter-binding is superior to escaping, because it reduces the risk of human error a great deal, but when you're just getting into this stuff, I feel that it's good to provide incremental steps. I have no doubt OP will also get to the same conclusion after getting into this a bit deeper.
Something similar in PHP is the [Levenshtein Algorithm](http://php.net/manual/en/function.levenshtein.php). From the manual: &gt;The Levenshtein distance is defined as the minimal number of characters you have to replace, insert or delete to transform str1 into str2. Using it to search however could be extremely slow so I wouldn't recommend it. I'm sure there's a better solution out there, so I hope someone else can assist :)
 try { $sql = "SELECT * FROM pdo WHERE id = :id LIMIT 1"; $stmt = DB::getInstance()-&gt;prepare($sql); // returns a PDOStatment object $stmt-&gt;bindValue(':id', 1, PDO::PARAM_INT); if ($stmt-&gt;execute() &amp;&amp; (boolean) $stmt-&gt;rowCount()) { $data = $stmt-&gt;fetchObject(); // here is your data } } catch(PDOExeption $e) { // handle errors } It's pretty simple really. If you don't want to type that out each time you could abstract some of that out. You also don't have to bother with escaping as that's all done for you, provided you use parameterized queries. You might like this: http://www.codinghorror.com/blog/2005/04/give-me-parameterized-sql-or-give-me-death.html
Consider having it added to the plugins repository?
It didn't really seem like a plugin to me since I'm just using the command line tool framework. But I'm certainly open to anything that would make it easier to import it into a project. Do you have a link with more info?
Aside from the ability to change code just by updating memory I don't see any advantages over using regular files with an opcode cache like APC. That's not to say this is not an extremely interesting experiment. 
You can go to settings &gt; command line, and actually add artisan, and it will parse artisan for commands. It will also add a alias for it, now go to window &gt; command line, and you can type your alias and you can tab/write through all commands.
I'd say your best approach is leaving PHP and using a search engine such as solr, lucene, or sphinxsearch.
Right, that's basically what I did. It created an XML file but there isn't a way for it to parse artisan and figure out what the available options are for auto-complete. That's what I manually added to the XML file. 
Well it has built in setups for symfony, doctrine, and composer. Dunno how it worked out commando but it certainly didn't provide any auto-complete goodness for artisan.
I enjoy working in CodeIgniter.
It's all about knowing the right questions to ask!
I've heard its quite easy to learn. 
Thank you for the Gold :) Yeah, the right terms make all the searches easier.
Some people might disagree with me but I think Laravel 4 would be a good place to start if you are up to it. It has enough syntactic sugar that you don't need to be an expert in PHP to learn. If you are learning any framework you're going to have a large learning curve as it is, and L4 might be able to alleviate some of it. With the built in ORM, verbose routing, composer-ready, etc. it should be fairly easy to get started and build a simple application. Check out http://four.laravel.com/ Before Laravel I was using CodeIgniter for a few years. I like CI, but I feel like it just leaves a little *too* much up to the developer for things that don't need to be. L4 simplifies it a lot and requires you to write a lot less code. Especially when your project sounds to be a lot of simple CRUD operations and nothing too technical.
TL:DR
In past I've used the [Jaro-Winkler algorithm](http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) for performing fuzzy searches on words. Some sample PHP code can be found [here](http://www.iugrina.com/files/JaroWinkler/JaroWinkler.phps). 
I fully agree that given the circumstances other tools people have at their disposal will do a way better job :) 
In my opinion Twig is pointless, PHP is a templating language as it is. Adding twig is just another abstraction for no real reason besides the consequence of it rendering slower. Also I'd strong recommend against forms too, they WILL make your life complicated if your application scales up. On regards to DBAL, I don't have much any criticism, I'd suggest you give it ago. 
CakePHP is the MVC I use and I really like it. www.devdungeon.com has a couple blog posts about CakePHP as well as the twitter bootstrap, which go together like a match made in heaven!
Bootstrap sounds good for your use because of the ease of responsiveness. You can create one page that works on desktop and phones just as well.
Interesting... forking...
Indeed, PHP is not the right tool for the job in this case whereas baileylo's examples are.
Don't use PHP for this kind of thing, it's the wrong tool and simply can't be done efficiently using only php. Use [sphinx](http://sphinxsearch.com/), or [elastic search](http://www.elasticsearch.org/), or [solr](http://lucene.apache.org/solr/). All of these things can be used along side PHP.
This is nonsense. I don't want my template designers, often inexperienced front-end developers anywhere near PHP source code. Templating languages are built for a reason: to make writing templates simpler for people that don't understand programming languages, and to abstract away complexity that these programming languages introduce. Also by introducing a simpler subset of logical functions and operators, you limit the scope of what the front-end designers can do, which is a good thing. Your point about performance is not valid. Silex compiles templates to raw PHP code anyway, so it's no different than writing it like that in the first place.
As usual: What about ... - [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md) compliance? - [Composer](http://getcomposer.org) support? - Testing? 
You should implement this using [the streams layer](http://php.net/streams), then you don't need `eval()`, and can access the files using `memcache://&lt;file&gt;` with most every file I/O function. $file = file_get_contents("memcache://file"); $sxml = simplexml_load_file("memcache://file"); $dom = DomDocument::load("memcache://file"); $fp = fopen("memcache://file"); require_once "memcache://file"; ... You get the idea. There are some slides from an older talk of mine [here (pdf)](http://daveyshafik.com/wp-content/uploads/2011/11/Get-Soaked-An-in-depth-look-at-streams.pdf) and better ones from Elizabeth Smith [here](http://www.slideshare.net/auroraeosrose/streams-sockets-and-filters-oh-my). Feel free to ask any questions (here), I'll try to answer them so everyone can learn :)
I'm really happy to see this project grow like it did, specially thanks to great contributions and help from people like [bobdenotter](http://github.com/bobdenotter) of [Bolt CMS](http://www.bolt.cm) fame, who integrated whoops into the CMS and contributed a lot of great tweaks and fixes upstream, Laravel's [Taylor Otwell](https://github.com/taylorotwell), who made the first Laravel 4 provider, and gave me some help on IRC, and [Phil Sturgeon](http://reddit.com/u/philsturgeon) who spread the word through twitter. If you'd like to help, anything is appreciated, and in particular - documentation, handlers and providers for other frameworks and applications. (PS: the reasons for the name change were discussed in the original submission available [here](http://www.reddit.com/r/PHP/comments/1aabj2/show_rphp_damnit_php_error_handling/) and in [this issue](https://github.com/filp/whoops/issues/1))
This worked though: sprintf('%.0f',($un_ts+11644560000) * 10000000); 
Got a demo?
I'll get one up and running in a few minutes, good idea!
Demo added: http://filp.github.io/whoops/demo
Excellent, thanks.
I'm not seeing the arguments that the function/method is called with. You might want to add that (should be available in the array returned by getTrace() under the "args" key). 
It's a planned feature, there's an open enhancement issue for it - the delay is an effect of some doubts about the best way to display arguments in a meaningful and useful way, without bloating the page with too much data. Any suggestions are appreciated, ideally in the following issue: [#15: Display arguments of failed function calls](https://github.com/filp/whoops/issues/15)
Well, PhpStorm displays the arguments as a tree structure when debugging. Arrays and objects are displayed as collapsible sub-trees. Edit: [Found a screenshot](http://devnet.jetbrains.com/servlet/JiveServlet/download/5465158-16550/example-debugging-with-phpstorm-xdebug-breakpoint-watch-variable.png;jsessionid=659F22B1BB04CD614F791253FC689571). 
Upvoted for something so crazy, it might just work! :D Good to see people trying something new - no matter how little use it may/may not have in the real world....
That's a great idea. A bit like a NFS...
*Use bcrypt.* scrypt is the theoretically stronger hash function, but is not yet considered sufficiently vetted. PBKDF2 is a better choice than most, but it is still weaker than bcrypt due to lower memory requirements. Also, *use an existing library* for the hashing. I'd recommend [password_compat](https://github.com/ircmaxell/password_compat), which is the current de facto standard. Please, do *not* try to roll your own stuff.
Generally speaking bcrypt, scrypt and PBKDF2 are all good choices as long as they are implemented correctly (and not in userland PHP code, because the cracking/validation ratio would be poor). However, bcrypt is most probably considered "the best", because it is technically harder to crack than PBKDF2, and it has had more scrutiny than scrypt. I recommend you choose to go the easiest way and use https://github.com/ircmaxell/password_compat library. You can possibly wrap it to make it yeasy to use "local parameterization" with HMAC for example, but you need to decide is it worth the added complexity. Anyway, no practical password scheme and settings is going to save passwords like "password" etc. (as long as the attacker has all the relevant info about the hash). So you may also want to introduce some kind of password policy, for example. 
&gt; Or perhaps use a combination of all of these? &gt; No, definitely not. The reason I asked this is because in my search for the truth, I came upon [this](http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html), from which I found the following(perseids comment down the page, which I probably misunderstood): &gt; If you want to be on the safe side with password hashing I, you can diversify your choice: Let p be your password and SaltI be 128 bit random values. Derive p_1 = HMAC(Salt1+"PBKDF2") with key sha256(p), p_2 = HMAC(Salt2+"bcrypt") with key sha1(p) and p_3 = HMAC(Salt3+ "scrypt") with key sha1(p). Derive key k1, k2 and k3 by using the key derivation function PBKDF2, bcrypt and scrypt respectively, each of them using 1/30 seconds CPU time with input p_1, p_2 and p_3 respectively. Compute the key (or database reference entry) as sha256(k1+k2+k3). Here "+" designates the concatenation of byte arrays. This way you get the best of all worlds: A proven bcrypt, an experimental but very promising scrypt and a traditional PBKDF2. The important aspect, is that you tweak the parameters of each KDF such that they take long to compute (that's why I proposed 1/30s CPU time). Then your KDF is as strong as the strongest of the three. 
Thanks for your comment! &gt; Anyway, no practical password scheme and settings is going to save passwords like "password" etc. (as long as the attacker has all the relevant info about the hash). So you may also want to introduce some kind of password policy, for example. Indeed I have something in the plans. I just want to go by this the way I truly understand what the code does, with maybe something in hand I could use in my later projects. This one doesn't really require something like bcrypt, since my final userbase consists of maybe hundreds of users, with pretty much no Very Important Information. I'm just very much welcome to the information about slowing down their efforts if somebody did get their hands on the database dump.
&gt; Please, do not try to roll your own stuff. This much I gathered after I started to even scratch the surface on security. ^^ Thanks for your comment!
I went ahead and reposted this to http://www.reddit.com/r/phpstorm as well. Thanks for sharing!
Sweet! Congratulations! 
&gt;Derive key k1, k2 and k3 by using the key derivation function PBKDF2, bcrypt and scrypt respectively, each of them using 1/30 seconds CPU time with input p_1, p_2 and p_3 respectively. Compute the key (or database reference entry) as sha256(k1+k2+k3) After skimming this text, I don't see how this adds any extra security. If I'm reading it correctly, all that is is a concatination of the hashes the three algorithms produce, which is then sha256'ed. You'd merely need to crack the sha256 and then split the concatinated string and target ONE of the hashes, not all three of them. 
I came here to point this out... It would probably take out that initial performance hit that he was seeing, right?
I have a highly functional tool I built over the years and as good as this looks, much **useful** info is missing for me to consider switching - the parameters passed through out the trace, $_SESSION and $_POST, and you could also display all variables defined in the context of a (non-exception) PHP error (not sure whether you have this, I just checked out the demo). Also, you can make stack trace file:line combinations clickable to work with several PHP IDEs which is a huge help. I put some of the aforementioned functionality into Kint, especially the trace features: http://raveren.github.io/kint/ I'd gladly contribute, but it's not possible for me at the moment due to time constrains. --- EDIT: here's [my output](https://dl.dropboxusercontent.com/u/3790097/3.htm), it might not be visually as pleasing, but it has 100% of available information presented. Obviously I stripped everything private - eg. $environment which contains $_SESSION, $_COOKIE, $_POST and etc.
A lot of info is available but not displayed if empty, such as `$_POST` and `$_SESSION` data. Other useful information can be added for individual projects through the available methods (esp. `PrettyPageHandler::addDataTable`). Some other contextually-sensitive information could indeed be made available, I'll work it into future updates. As for the suggestion to make clickable IDE links - good idea! I'll put that into an update in the near future, thanks! 
Not currently, although it should be pretty straight-forward to integrate. Contributions are very much welcome, and if nothing happens on that end, I'll make it myself soon-ish!
Well for one, the passed parameters are missing from the trace, also IMHO it's better to show $_SESSION as empty instead of not showing it at all, lack of information is also information :) Just my 2c, great project, I starred it long ago!
IMHO, 5.3. If you are intending to sell your app to a client, keep in mind that you need to make his life easier on providing a product that runs on any webserver. Also, if your customer already have a 5.3x PHP server with N apps running on that version, do you think that he will take the effort to update PHP just to run your app? or look for another application on the market? 
The difference being that my template designer can write $db-&gt;query("DROP TABLE user;"); or something equally awful in your second example. Also by limiting available functions to a small subset, my template designers cannot end up doing some crazy logic to display the data how they want, which then gives me feedback that they need the data in more usable format.
PhpStorm is the bomb. Those blokes at JetBrains know what they're doing.
Cool! Didn't know that sub existed. Thanks
I'd be very happy if you did. If you want some idle chatter on the know-how I've accumulated with catching php errors and stuff, PM me, we'll continue on gtalk or similar.
I've pushed support for clickable editor links to its own feature branch, available here: https://github.com/filp/whoops/tree/feature/open-in-editor I'll merge it in after I clean-up the code a bit, and add some more default editors to the list (only textmate, sublime and emacs thus far; with support for adding more through the handler). Again, thanks for the suggestions!
You think correctly! I'll fix that right away, good catch!
Thats a complete contradiction to your previous statement of Designers knowing nothing about programm, even if they did and performed such an action, thats a adminstration problem with you and your work mate, nothing more. Code does not abstract the development process. why would the $db even be in the template's scope? The template scope should only contain what is required for display, nothing more and nothing less. 
Or pass $link as a parameter to the function instead, that way you avoid using globals. Or use a constructor and create $link there.
I'll be integrating this into PyroCMS 2.3/develop shortly too. This is great work.
Not yet! If you're up for it, I'd really appreciate it!
Nope. She doesn't have the *privilege* of working with me.
I'll have a closer look soon. If anyone else is up for co-maintaining let me know!
Use either SHA2+PBKDF2 or bcrypt, with an appropriate number of rounds for your use case (basically, as many rounds as you can handle without becoming a system bottleneck). Both approaches offer the same security characteristics. Between SHA2+PBKDF2 and bcrypt, the former is much better-vetted than bcrypt (although the PHP developers seem to favor bcrypt for reasons I haven't seen properly explained). Also, if you're doing work for the U.S. federal government or a state that follows federal guidelines, you aren't allowed to use bcrypt; SHA2+PBKDF2 is your best option. For SHA2+PBKDF2, either SHA-256 or SHA-512 should be fine; the bigger number doesn't really mean better security. I'd go with SHA-256. SHA3 also exists now, but you shouldn't use it. It isn't well-vetted yet and isn't even theoretically better than SHA2. It was just developed as a "plan B" in case flaws are ever found in SHA2, but that doesn't mean it's more resistant to flaws than SHA2 is.
Why do you say bcrypt is safer than PBKDF2 (with SHA-2)?
Because it is generally known that bcrypt is crypographically stronger than PBKDF2, and scrypt better still (although less vetted).
I keep hearing non-cryptographers say that bcrypt is stronger than PBKDF2, but I've never heard an explanation beyond that. At best, I hear bcrypt requires a little more memory than SHA2+PBKDF2, but not enough to impair hardware acceleration. If you're tuning the numbers of rounds to be the same length of time, bcrypt and PBKDF2 should have the same security characteristics, with the difference being that SHA2 is much better-vetted than Blowfish. EDIT: By the way, the phrase "bcrypt is crypographically stronger than PBKDF2" doesn't make any sense. PBKDF2 isn't a cryptographic hash, it's a key stretcher. If you want to compare cryptographic strength, compare bcrypt's cipher (Blowfish) with a particular hashing algorithm (like SHA2). PBKDF2 can be used with any hashing algorithm. EDIT 2: Blowfish, not Bluefish. :P
I'm not a cryptographer, nor do I pretend to be. If you want to read up to why bcrypt is better than PBKDF2, it's covered in Colin Percival's scrypt paper. 
Awesome library. Thanks for the name change. While I personally wasn't offended by the name, I could see the potential problems with it's original name and glad you changed it early.
Did people give you shit for the name?
I wouldn't put it that way, there were some people with concerns about the name in a more...no-fun-allowed environment. Rather than risk losing adoption, I chose (after also taking it up with some more active contributors) to steer clear of any possible complications by renaming the library early on, while I still had a chance to.
just assign a random string as the file name, then store this value in your user table (if it is relavent to store it there), then look up the name of the file when you need it.
Still need to cache it, unless you pre-cache.. but that will also work in the current version :P
Me and my bad english. I'm sorry, I meant "if you are intending to sell (..)".
Nice, I will look into it as I have more time :)
Yes. This occured to me too. But I already have 1000's of files which are linked to the users, and need to be easily connected to them by staff. I guess I could write a small script that renames them all... &lt;id&gt;+&lt;randomstuff&gt;.jpg 
Both apache and nginx (and probably other servers like lighttpd) have implementations of x-sendfile. I'm on my phone now so I can't link you anything, but a quick Google search should do the trick.
Gotcha. That makes sense. :)
Indeed. I'm again leaning towards my original solution. 1. Filenames keep their name, making it easier for the people who work on them. 2. Anybody with a link (youtube-style) can **not** get the file. Sorry, missed a crucial **not** in there
In that cause you're only really going for a sense of security. You could simply show an extended progress bar sequence when they upload an image that says random stuff like "Encrypting the Firewall" or "Generating RISC Key Sequences" I'm being serious, [banks do this shit](https://wellsoffice.wellsfargo.com/ceoportal/signon/loader.jsp). Here's the [Hackernews thread about it](https://news.ycombinator.com/item?id=5305925) I guess people feel better when security takes time. 
Is it a preset, or can you add them on-the-fly, like categories or tags? If the former, use enum, if the latter go with an additional table or two.
Never rely on concatenation as a means to defend your inputs which will be used in file access. This entire script is wide open to [null byte injection attacks](http://hakipedia.com/index.php/Poison_Null_Byte).
Wouldn't reccomend enums in mysql. Should use a another table (buisness_type (id, name)) with a business_type_id pointing to that table.
That was the first thing that popped into my mind as well when I saw the code, but if you look at it closely (and while there are some typos) there shouldn't be any null byte exploitation vectors, since he's constructing the filename from the id found in the session and comparing it to what's in the query string. 
Good point, I stand corrected.
blowfish*
Create a table that lists one type per row. When associating the type to something else, associate it with it's ID (has one). If an item can have more than one type, use another table to record the relations (has many through). In any case, you should not keep the types in PHP code as static arrays, and I would avoid ENUM unless it's a very basic category list that will never grow or shrink. Some models that may help: Has one (two tables, one containing items, another containing categories. category ID stored in item table. no duplication in categories, an item can have only one category): Table 1 Table 2 item ----&gt; category Has many (two tables, multiple categories relate to a single item. Item ID stored with category, categories may be duplicated): Table 1 Table 2 item &lt;-----+-- category 1 | +-- category 2 Has many through (three tables used. middle table contains a list of category IDs and item IDs so that categories may relate to items. no duplication in items or categories): Table 1 Table 2 Table 3 item &lt; -- item ID | category ID -- &gt; category 1 ^ | +----&gt; item ID | catrgory ID -- &gt; category 2 
I briefly tried Ruby on Rails this weekend. My immediate thought was: 'Hey, it's Laravel but in Ruby!'.
Interesting point about gems being more cohesive with Rails because of its widespread (universal?) adoption among Ruby developers. For the longest time I didn't understand what gems brought to the table beyond package repose. The wide variety of PHP frameworks does the drop-in component developer no favors. You can't make any assumptions about ORM or MVC which is a blessing in flexibility but a curse for rapid prototyping. Glue, glue everywhere. 
It's a Kohana knock-off.
Because once you make that assumption something will never change, no matter how many times people have sworn to you that they won't even change their minds, it'll change. And then you'll have to run a migration.
Had the mirrored experience with Laravel a few months ago.
Symfony, Zend, Laravel, Silex. I prefer Laravel. Please make sure you go with the beta (version 4) one if you ever decide to choose Laravel. 
I use Yii
It has all been said before - it will all be said again...
The more content the better. The better pieces will normally float up to the top anyway!
Do they have a preference?
&gt; can I pick up quick and get used to? That is not good criteria with which to choose a framework
Hopefully, if more people adopt and write packages for Composer, this trend can continue to change for the better. His comments about Rails support in gems is something you're starting to see with Node.js + Express and npm modules, and exists in PHP in the larger CMS projects and Wordpress, but these are highly non-reusable compared to a Composer package. For bundled models/views/controllers, each framework would likely need an additional framework-specific adapter package for it at this point. But hey, maybe the FIG group can come up with a minimum interface for these to become interchangeable too, or at least supported via a single adapter and any additional Composer dependencies (their chosen template engine, for example).
Note: "Allowed memory size" errors are *not* "out of memory" errors. The former are thrown when the `memory_limit` is reached, the latter when the system actually runs out of memory.
bcrypt in its default configuration is WAY slower than PBKDF2. For making brute-forcing passwords harder, being slower is a feature. And if that wasn't enough, bcrypt has another very nice feature in that it encodes the number of iterations in the output. This gives you the option to increase the amount of iterations over time as users change their passwords without having to do any manual intervention. Scrypt also has this property and is better than bcrypt in that it is memory-hard (= requiring lots of memory) which makes it incredibly hard to brute-force on specialized hardware. But until crypt() or the new password hashing functions in 5.5 gain scrypt support, I'd still stick with bcrypt for better usability and the possibility to easily upgrade the algorithm at some point. If an attacker gets your password database and notices its bcrypt'ed, it's currently way more likely for them to just try the low hanging fruits (really bad passwords) and then move on to another site than it is for them to purchase and build specialized hardware - even more so as scrypt wouldn't protect against the low hanging fruits either.
Except for model-based validation :(
Honestly, your introduction to yourself at the beginning of this post makes you sound pretty full of yourself. Enough that I stopped reading.
Anyone working today the same as they were in 1997 has some severe problems, especially if they are in PHP. We don't work in VM's mostly because we're all on OSX which is an excellent substitute (and does the same thing - provides a local server). I can only imagine how annoying it would be having everyone working on the same codebase instance.
&gt;We don't work in VM's I wouldn't either. The entire point would be to RUN the code in a virtual machine, not work from it. This is where tools such as Vagrant and Chef comes in handy. The point of working with virtual machines is that you can quite easily control the environment and match it up with what the production environment looks like, without having it interfere with any other sites which you happen to run in parallel. &gt;I can only imagine how annoying it would be having everyone working on the same codebase instance. Yeah, tell me about it. What that xanax_anaxa guy is describing is insane, and what's worse is that he is defending it.
Please, if you see any mistakes let me know over here so I could correct them. I try to start blogging in English.
If you get your DB wrapper to log it's queries before they're run you can look in your log to find the last query you've tried running before the script was killed. That should give you a starting point.
PBKDF2 is a key derivation function. It was never meant to be used to store passwords. In fact, it was designed for exactly the opposite purpose: to safely encrypt content without storing the derived key or the passphrase used to generate it. All the research towards PBKDF2 was geared towards that purpose and that purpose only. Bcrypt on the other hand was designed for password storage. 
&gt; Ideally I'd like to log the query but memory errors seem to just kill the php process dead. If you're using MySQL, try to [enable logging](http://dev.mysql.com/doc/refman/5.1/en/query-log.html) and see what queries pop in the log file.
I don't know how I didn't see this until now, but this is awesome. Wonder how much of it I can fit on a back label... 
I'm actually just starting out with brewing but I appreciate the offer. :) 
Why not discuss using queues? Resque, Gearman, ZeroMQ, etc are fairly easy to get started with and are meant to handle long running processes.
Listen to this man.
His site, on android is shit. It randomly rotates, and I can't do shit. The link I heard about before, I'm using a different prng than mtrand, I'm using mcw4096. By... can't remember his name off hand, but I'll link to his code later on my PC in case anyone wants to use it too. It's faster than mtrand, and is more random.
I tried keeping it vanilla. What you can do with a basic LAMP setup. I guess I could add an example with Gearman at the end, what do you think?
When I found myself in your shoes I not only had that problem, but I couldn't use a framework due to the nature of the work. I was working on a contest piece that ended up going to national contest. They required that we not use any frameworks or classes we found online. I was already using CodeIgniter and liked a few things about that framework. I coded a framework and a system of libraries and ended up making my own framework that I've pulled apart and rebuilt about 3 times and still use to this day. In the end it took a good week to build the first version, but it was worth it to me as I knew exactly what was going on in my application every step of the way. Of course it had minor problems here and there, but again fixing those was much easier when you built the code yourself. For those that are wondering I've played with the idea of going open source with it, however I feel like it's not really good enough that other people would be interested. I feel like documenting it would require too much time as well. So far it's been a great tool for the small apps I've been able to build with it, but pales in comparison to the vast tools and libraries that are available to other frameworks.
It might be worth noting that you should really only be changing max_execution_time etc for pages that you expect to be running a long time. If you just bump up the limit for every script, you lose the automatic kill of runaway scripts which normally run subsecond, that aren't doing what they're supposed to and are running for hours. You should probably use [set_time_limit()](http://www.php.net/manual/en/function.set-time-limit.php) if you only need this for a couple of scripts.
Why? Shouldn't one be proud of its accomplishments?
bcrypt is not slower than PBKDF2, nor is it faster. Both are as slow or as fast as you set them, which is the whole point of using them. In fact, PBKDF2 has the advantage that its speed can be fine-tuned much more precisely than bcrypt's can (bcrypt's rounds are specified as an exponent of 2, whereas PBKDF2's rounds are specified as an absolute number of rounds). Also, bcrypt does *not* encode the number of iterations in the output. You're thinking of crypt, which is a wrapper around various hashing functions that include bcrypt. Crypt could add SHA-256+PBKDF2 to its arsenal; it just hasn't yet, probably because it already supports SHA-256 with a different method for doing rounds. Alternatively, a number of password hashing libraries extend crypt's modular output format for use with SHA-256+PBKDF2 and store the rounds and salt just like standard crypt does for bcrypt.
Yeah, I went from CodeIgniter to Rails to Laravel. I feel like Rails had a bunch of great ideas but many others (like Laravel) have copied &amp; improved upon them, leaving Rails to be the framework that used to offer a lot but doesn't have much to offer anymore.
Literally no one cares
Ok
also he's setting the scene, saying how he's had experience and knows what he's talking about!
&gt; bcrypt is not slower than PBKDF2, nor is it faster. Both are as slow or as fast as you set them, which is why I said: &gt; &gt; bcrypt in its default configuration is WAY slower *default configuration* Also due to the choice of algorithm, bcrypt needs fewer rounds than PBKDF2 for the same amount of slowness - not that it matters much. The usability point still stands though. Using PHP crypt() or the 5.5 password hashing library doesn't require any configuration while providing easy upgradeability. Both only support bcrypt.
But that still isn't true, because PBKDF2 doesn't have a "default configuration" in PHP. hash_pbkdf2 requires you to specify the number of rounds. Also, you *should* be specifying the number of rounds for bcrypt manually, based on measurements from your architecture.
Be neat to mention Gearman and others. This has info that I never knew about though! Thanks! Also, I like how it is vanilla and can be applied to without installing Gearman on a VPS or dedicated.... you know?
Could you expand?
Also, if you use PHP-FPM it has fastcgi_finish_request() that will end user ouput, so the user goes on their merry way, but the script can continue. This is ok for some things, but most valid uses of this, a queue would be better.
Most of those WTFs were borrowed from Perl, were they not? (Not needing () on function calls, if !, if not, unless, implicit returns)
Well, on your model in Rails you have methods for validation, such as ``validates_presence_of :name`` and won't save models unless they meet the validation requirements. Rails has a heap of neat validation rules built in. Laravel doesn't come with model-based validation at the moment, you just do it in the controller. Of course you can extend your model to run validation before creating and saving or create a validation service (as Jerffrey Way demonstrates in his new Laravel 4 video series) but they aren't built-in to the framework.
They are, yes; but I've never really played with perl, so they're ruby WTFs to me :)
&gt;Docblox and PHPDoc which seemed to have merged. I'm not sold on it a 100%. What's the problem with PhpDocumentor 2?
thanks, had no idea. I'll use that then
According to the docs ignore_user_abort is only useful on command line scripts. Using it under HTTP conditions won't do anything...
Composer still has a way to go to catch up with the usability that npm and gems offer, I think. I've worked on 3 finished projects using composer, and I've had problems with it every time. It's still new, so it's expected, and I hope the composer guys can keep up the good work and make something as well-made as npm or gem soon!
Fixed.
&gt; On one hand I'll read the PSR(master, not develop) saying to use @type because @var is deprecated, then I go to their docs which don't even mention @type and don't even have @var docs. Wait, what? When was this deprecated?
To give more context this is magento which has dozens if not hundreds of queries per page request. So it would be like finding the proverbial needle in the haystack in a production environment. I actually have an idea to cross reference the time (with a delta of several seconds) of the exception with a particular URL and THEN log just the queries for that page generation... I was just hoping someone else had a way to actually get more information from the allowed memory size errors... 
Damn that's a shame.
POST date=/etc/passwd&amp;mysupersecretfunction=file_get_contents
In terms of picking up a framework and getting used to it quickly - my pick is cakePHP. There is a tutorial on their site on how to setup a blog and you have all the simple things you would need to build a site and has a good amount of customizability. The cons are that it is currently not utilizing PHP 5.3+ things which include a lot of cool stuff (namespaces, composer isn't coming till cakePHP 3.0) and doesn't use an ORM. (subjective)
Whoops has been integrated into the core of Laravel 4 https://www.evernote.com/shard/s196/sh/850eb7b1-47e3-4c1f-aac8-263aea23556c/378f78722e49f43b96bcef252b23f50c
PSR can say whatever it wants, but if phpDocumentor parses it the other way then you write documentation the way it works with phpDocumentator. If PSR-9000 said jump off the bridge would you do it? 
Laravel 4 or FuelPHP.
Let's ask the PHP-FIG mailing list
What? It's the PHPDoc author that is being self-conflicting. He just used the acronym "PSR". If the author of a program tells me something on one side, and something else on another, I get confused about the direction. It has nothing to do FIG...it's about what the standard is moving forward, what IDE's and people should accept, etc.
Background jobs.
Can this be used with plain PHP? I couldn't find anything about it in the docs.
I'm using apiGen for API documentation and dokuwiki for documenting procedures, practices, etc. It works wonderfully well for the project I'm working on. 
No I see your point, I'm just saying if tool works for given syntax then use that syntax. Don't bother following syntax given in a PSR file that does not even work and could be a proposal.
Neat idea and thanks for the effort as well as the reddit post, but I wonder how memfs-php compares to files loaded from opcode cachers like APC?
The information in the post is exactly the same if you remove every sentence containing the string " I ".
The Wadsworth Constant applies very well for this blog post.
**Use scrypt**. There's a whole bunch of bullshit in this thread about how "scrypt isn't as vetted yet". There are two problems with that: 1. We're not talking about cryptographic security here. All three of these algorithms use SHA-256. The real question is which of the three algorithms is better in avoiding brute force attacks. So in the end, worst case scenario, you're just in the same place you were before (safe passwords, but open to brute forcing). 2. In cryptography, there's no telling when something is going to be broken. The concept of "being vetted" just means the algorithm happened to go a certain amount of time without being broken. It doesn't give any indication of its future chances of being broken. Now to explain why you should actually use scrypt over others: **it's memory hard**. To explain further, the reason you want to use these key stretching algorithms over pure one-way hashes is to exponentially increase the amount of time and memory it takes for an attacker to brute force a password hash *in the worst case scenario where they broken into your database and got all the hashes*. PBKDF2 is not memory hard at all, and can be easily implemented using a hardware circuit. So while it does provide more protection than basic SHA-256, it isn't that much better. bcrypt is an improvement, but scrypt is by far the best (theoretically). The professor who designed it made it in a way where the memory usage is unpredictably random, meaning you cannot make shortcuts in your memory storage, thus forcing attackers to actually have a certain amount of memory. This becomes a huge problem for attackers because now your cracking platform needs to have a variable amount of memory depending on the hashing parameters. EDIT: There's a PHP plugin [here](https://github.com/DomBlack/php-scrypt) that does scrypt. It's implemented using the original author's implementation.
To be honest I've yet to find a PHP documentation generator which isn't as ugly as sin. Even the ones that just use bootstrap somehow look awful. I really like this one for ExtJS: http://docs.sencha.com/ext-js/4-1/#!/api But nothing similar for PHP apparently exists. In the mean time I'm just using PHPDocumentor 2 IIRC. Whatever is suggested by the php-jenkins page anyway. It's fine.
APM extension might be what you're looking for. Of course, that's only afterwards. The only way to prevent memory limit hits, I know of, is to simply increase the limit if you notice the memory usage is high during development. Hardware is cheap, remember.
But I would have to use @method in every class that uses this one. Is there any way to define it in one place?
Is it really necessary to use the magic method? Can't you use -&gt;execute() or something like that? I never saw the point of __invoke() because I think it actually makes your code less readable. You can use real closures in PHP, if you need them.
Well here is an example: Imagine you have class Traffic which defines lots of vehicles which you don't know beforehand. So it would work like this: you extend the class and plug in the vehicles. E.g. let's say I have a Helicopter class. Helicopter would provide also a method that would count all existing helciopters, what I wanted to do is to be able to have the following: class Traffic{ .... $this-&gt;helicopters = new Helicopters(); // ..... } And then use it like this: $this-&gt;helicopters-&gt;count(); //and the important part $this-&gt;helicopters(13); //get helicopter by ID Here I would use __invoke, so that not to have super long names like $this-&gt;helicopters-&gt;get(13) It would be a very nice shortcut, especially for vahicles that don't have any special methods like count() and just provide the simple get() functionality 
&gt; There's a whole bunch of bullshit in this thread about how "scrypt isn't as vetted yet". You have got this wrong. Recall DES bitslicing for example - what if there is to be found some kind of way to make scrypt algorithm run, say, 10 times cheaper, or more? Cryptographic construction are approved this way, by time. We are not talking about block ciphers or raw hash algorithms per se, but the same still stands. &gt; PBKDF2 is not memory hard at all, and can be easily implemented using a hardware circuit. So while it does provide more protection than basic SHA-256, it isn't that much better. If you compare raw SHA-256 (not SHA-Crypt) and PBDF2-SHA256 with 100 000 iterations, the PBKDF2-SHA256 version is roughly 100 000 times harder to crack. That is quite a big difference. The real difference here is salting and stretching. Plain hashes or salted hashes are the weak ones. Sure there are big differences between "stretching methods", but for example, I don't think a security audit would go on alert if PBKDF2 (with proper settings) was used instead of scrypt (with proper settings). It is quite reasonable to recommend bcrypt for PHP applications, since it is supported out of the box. This is not the case right now with scrypt.
You've basically said your purpose for doing this is: &gt; so that not to have super long names which sounds like it'd be easier just to create a common method like was said above. It sounds like a lot of magic to save 5 characters. 
I can only agree, this is not readable at any way, because how do you know its the ID you need to use, and not the name? $this-&gt;helicopters('Gazelle')
Well that's one reason why I wanted a way to document it =) I could always make a trait that would describe helicopter() and helicopter_count() methods. But I'm afrraid I would get quickly overhwelmed with a lot of those in one class
Exactly this is what I mean: "helicopters(13)" is absolutely not expressive. In your app it might return helicopter with id=13, in mine it might return the 13th helicopter regardless of the id. In yet another app it might create 13 new helicopters and return them. Point here is, you can dramatically lower the learning curve for anyone trying to comprehend and use your code by writing in full: helicopters-&gt;findById(13); That way I don't even need an IDE nor PhpDoc to figure out what it does... 
It can! Scroll down on the project's page, it has an example for setting it up without any other framework. Let me know if you need a hand.
&gt; $this-&gt;helicopters(13); //get helicopter by ID I'd better go for ArrayAccess then.
&gt; You have got this wrong. Recall DES bitslicing for example - what if there is to be found some kind of way to make scrypt algorithm run, say, 10 times cheaper, or more? &gt;Cryptographic construction are approved this way, by time. We are not talking about block ciphers or raw hash algorithms per se, but the same still stands. I'm not trying to say scrypt won't be hacked, I'm saying that the amount of time an algorithm has been out there for analysis is not a good measure of how secure the algorithm is, and to argue that you shouldn't use scrypt just because it isn't old enough despite its theoretical superiority is bad reasoning. &gt; If you compare raw SHA-256 (not SHA-Crypt) and PBDF2-SHA256 with 100 000 iterations, the PBKDF2-SHA256 version is roughly 100 000 times harder to crack. That is quite a big difference. Not true. The idea of key stretching is that you adjust the hardness of the algorithm to your application, e.g., for a web application, you adjust the PBKDF2 parameter to the maximum point where it doesn't slow down your application. Slower implementations of the algorithm mean less iterations. Therefore, the advantage of key stretching becomes directly related to the ratio of how fast an attacker can perform the algorithm to how fast the application can perform it. If an attacker is using a hardware-based PBKDF2 circuit, and the web application is using a PHP-based PBKDF2 implementation (which is most likely the case), the advantage isn't anywhere near as linear as you're making it out to be. &gt; since it is supported out of the box Also not necessarily true. It's system dependent, and depends on what version of libc you have installed. However, I'll admit that nonetheless PHP support for bcrypt is more mature than scrypt. Nonetheless, it's not like it takes that long to download and install the scrypt extension.
Doxygen has worked pretty well for me, and it's not PHP-specific either.
I wish they kept the ability to output a PDF.
If you don't want parallel execution and you're running from a cron on Linux then you can use flock. e.g.: /usr/bin/flock -n /tmp/myapplock.lockfile php -d /usr/bin/script.php 
Jeffrey Way posted another video this morning that demonstrates extending Eloquent for model-based validation that does it in a pretty clean way, only needing rules to be stored on the model. Each to their own I suppose, but I guess I feel safer knowing my validation is tied directly to my model.
Chill I hope this isn't above my meager php skills^.^
And the whole point of using an IDE is that it autocompletes the "super long names" for you.
I wish the whole world thought the way you do.
Out of interest, what are these specific issues?
So if its something like gender, where i know its either male our female, i should create a gender table, a gender_person table, and a person table, just in case my assumption is wrong? Or should i stick with enum?
I had to work with a pretty hacked-up Magento app, it was a Groupon clone app... real nightmare to maintain
Any hints in the web server error log, or just the same message?
This can be tedious when you just want to make it work quickly, but it's really the best way to do it...
php 4 was end of lifed a while back, no security updates, nothing....upgrade.
You can use [xml-parse](http://php.net/manual/en/function.xml-parse.php). Somebody posted an example class on that page, or maybe search around for a tutorial.
You really need to: A) Have a conversation with your boss. B) Have a conversation with their boss. C) Have a conversation with yourself. D) Straight up rage-quit.
There's a difference between telling people who you are, and telling people how awesome you are with emboldened bits. You could just add a tagline to your blog that says "PHP programmer of 13 years".
That's a really weird article.. It builds on the previous article "PSR-Huh?", and still manages to only pick at random aspects of the very different PSR's, without going into any detail. 
I could give you a more thorough list of issues when I get back home, but the one that sticks out in my head most was problems with the autoloader not picking up private repositories (git) repositories that had been installed through composer.json. I'm pretty sure I had a lot of fun trying to override dependencies because one dependency wasn't working, so I made changes and made a new repository, but couldn't get composer to ignore the official one in favour for mine. We also had a variety of composer-based issues when running our code across multiple platforms (can't remember the details; I left the company before it was resolved). 
Forms are powerfull and simple enough. twig allows powerfull stuff. How to you deal with content blocks , template inheritance , escaping strings automatically if not with twig ? twig handles a lot of stuff and have a really tight integration with all symfony components with symfony/twig-bridge. You should , in fact you must use twig and never echo a damn stuff yourself , never !
Silex is good if you want to understand how symfony components works. Having to instanciate all stuffs your self or having to write your own modules for dependency injection will make your read the library. How often do you read symfony XML container config ? usually people only bother with the YAML config. 
The point of using mongodb is because it scales , sqlite doesnt really scales at all. While the lib looks great there is no real point using that when sqlite performances are not very good.
I would probably look at setting up a test environment for the debugging instead of bugging down the production environment even more by using it for debugging purposes as well.
I came across [Sami](https://github.com/fabpot/sami) just the other day, which is used to generate the [Symfony 2 API](http://api.symfony.com/2.2/index.html). It has a much cleaner, simpler feel than any of the "standard" tools I've seen. That only solves the API half of the documentation, but if it were me, I'd use a combination of that, and [Markdown](http://daringfireball.net/projects/markdown/basics) files for non-API docs.
Nice name.
Offtopic. I think Fabien Potencier is a great and smart guy, but LOL to his username on Github. Everytime I read it fapbot
Only a wise man will tell you he is a fool. But any fool will tell you he is wise.
Fair enough. I remember a few quirks trying to get private GitHub repos to override core ones myself, but I think in the end it was just because my certificates were screwy on my vagrant box or some junk. On the whole I've been using Composer heavily for a year and I've only noticed two service outages and 3 real bugs which have all been resolved very quickly. Nils and Jordi are nailing it, and I feel like its easily on a functional par with NPM or bundler.
I'm at C right now!
Thanks!
That motto would work really well on /r/resumes 
This seems remarkably unnoteworthy.
I'm wondering if it has something to do with my mysql_query syntax? Is it okay to do it that way? SELECT [column name] FROM [table name] WHERE [column name] = Session username value.