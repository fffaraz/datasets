thanks for the good advice
Depends on your goals. If you are not looking for a new job it's a great validation of your skills but irrelevant beyond that. It's not an easy certification, there are lots of questions nitpicking on details of not commonly used functions. Two other arguments not yet named: \- I work for an agency that contracts out loads of programmers. Some of our larger contracts for Oracle DB and Java include a stipulation that requires our employees to be certified. I assume large PHP agencies will have to deal with similar clauses. \- Also, if you are looking for a job, just imagine an employer having to pick between two similar CVs - but one has the ZEND certification and the other does not. At the very least I'll ask the one without why he did not bother to certify. 
welcome to actual programming
Silex is dead now. Slim is very similar in concept to express which Node bods will be plenty familiar with. Slim 4 which is on the works even more so.
Okay, I have to prefix format with `!` so it doesn't use 31 for day which doesn't exist for September. üôÑ
&gt; You're just saying "it doesn't work" You can't even read what I am saying. because I said exactly the opposite. 
7.4 is going to be all about plumbers
Ohhh this is some weird Indian spam technique. In OP's first post they oddly include a phone number that's registered to "Sanjeev Kumar". The domain he's plugging is registered to "Devesh Rajput". He pretends to be a woman with the username "AnnieDaniels". He uses [this chick as his Reddit profile picture](https://s.redditmedia.com/t5_nsy72/styles/profileIcon_pb2j00nygej11.png?fit=crop&amp;crop=faces%2Centropy&amp;arh=1.0&amp;w=256&amp;h=256&amp;s=4447e73523ee6f9d5f15dfa30180c30b) to really make it all seem authentic ^^^/s. Then in this post he, for no reason, includes [a picture of a different chick sitting on a shag rug who is, I assume, struggling to type on her macbook with those fingernails](https://i.redd.it/wpyojr9v7zi11.png)
I haven't read the article yet - I'm on shitty connection just now - but why are people downvoting this?
I write bare php. 5.3 no less. Code base here is an interesting mix of spaghetti and melted/half-hearted OOP. It do the do though.
I use slim for all My personal projects and it's really nice if you ask me but you have to boilerplate allot but I have my own template setup.
 echo PHP_EOL; http://php.net/manual/en/reserved.constants.php#constant.php-eol It handles doing the appropriate line break for the OS.
And how it's supposed to solve the problem for the OP? 
I run this exact code and the resulting file worked without errors. Keep on with your tales 
&gt;[30-Aug-2018 23:26:24 America/New_York] PHP Parse error: syntax error, unexpected "'hello!"' (T_CONSTANT_ENCAPSED_STRING) in /home/xxx/public_html/QandA/question_list.php on line 2
Sooooo, you hastily edited your comment, to make it match with the above code. But I've seen it with just `hello!`. Irony, you are failed with your forged error message - it is not a real one still. The only question, why you are constantly lying?
Can you upload the file that is created somewhere? Not the contents of the file, but the actual file itself, exactly as it is after your script creates it.
* i guess the closest you can get to nodejs would be r/http://reactphp.org * a good resource on best practices with php is [https://www.phptherightway.com/](https://www.phptherightway.com/) as for how it handles requests processes data and retrieves it, that very much depends on what you do, more modern frameworks will map the request to a standardized request object (no matter if you come through php-fpm, mod\_php or by any of the solutions that do php as long running scripts. (for example reactphp/http), how you process data kinda depend on what you want to do ;), and how you retrieve data is a bit specific on the situation as well, most database implementations will do synchronous queries on the databases, most api-libs by default do synchronous http requests, and using stream wrappers you can do a few nifty things to retrieve data through your system as well, but depending on what you use you can also do asyncronous http requests (guzzle for example allows that, or reactphp/http-client), and for some databases you'll find that there are async client options as well. In the end the answer to your question in many ways is "depends on your framework, and what you want to do"
exactly. it is not *what* to write but *how*.
Upvoted, good stuff!
Because ndejs is no good to handle heavy server processes and im thinking about creating an application that will work with video processing/editing.. and php seems cool
I copied from an error file and copied the wrong error. I realized the mistake and corrected it. Sue me.
So you can access it to view it or so you can download it?
I want to download it.
I should be able to get something for you later this evening. I will PM you a download link.
Horray, thanks for sharing this great news!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig/fig-standards/.../**psr-8-hug.md** (master ‚Üí f8cdc8b)](https://github.com/php-fig/fig-standards/blob/f8cdc8bd67ffa938b81c33a750b65e1814d1824b/proposed/psr-8-hug/psr-8-hug.md) ---- 
&gt; I think it might be possible to use this pattern successfully to build small APIs, but I don‚Äôt think it can be used for enterprise applications as I believe that enterprise applications require a Domain Driven Design approach, and therefore a domain-centric software development strategy. This paragraph near the very end of the article is key IMHO. It seems like a suitable pattern for modeling simple REST APIs that do not have a lot of (business) logic attached. &amp;#x200B;
The [FAQ](https://developers.google.com/recaptcha/docs/faq#id-like-to-run-automated-tests-with-recaptcha-v2-what-should-i-do) has a section on this with the mentioned testing keys. I also don't think that there usually is a *need* to test this.
Those are full-on frameworks rather than libraries, but generally speaking frameworks are just a coherent collection of libraries. So, indirectly I guess?
&gt; PHP Parse error: syntax error, unexpected "'hello world"' look at the bit after "unexpected". "'hello world"' https://stackoverflow.com/questions/13565768/php-syntax-error-unexpected-t-constant-encapsed-string
Well, no. The non-minified version requires everything too, since all the code is essential (because the library is very small). I only use it for very small projects/libraries. For large projects, the conditional requiring is required. I also dont want to spend ANY money on my super tiny projects. Lets say I create this cool html/php minigame. The code is small and so is the audience. I would not want to spend any money on it. So, what do I do? I minify it and publish it. (P.S. It does not just remove white-space, it renames variables too. For SuperSQL, it halved the number of kilobytes) (PPs. I use completely free hosting, not paid. Thats why)
&gt;&gt;The idea being on read you execute commands that raise events and update the aggregate as needed. &gt;Not on read, but on write you reconstitute the AR and then apply the latest change, which raises and event. (i.e. you "log" that a thing happened) I totally crossed my wires on this statement.. Thank you for taking the time to discuss this with me. Now that I have a working proof-of-concept with `EventSauce` I'm trying to wrap my head around why I would want `Commands` and `CommandHandlers`. In his library I would use the dispatcher to handle side-effects. Looking at `Proof` it's just a standard create a command for the sake of creating a command and pass it to the CommandHandler for the sake of doing it. At least that's how it feels in my project. As I'm typing this I'm thinking back to a previous comment I even made.. I would want to use a `CommandHandler` to handle the main use-case plus edge cases. The `Command` itself is just a value object, because it's just good practice. The `CommandHandler` would attempt to make changes to the aggregate while the aggregate itself may return `Exceptions` to notify the `CommandHandler` on which `Events` to raise. Some you may want to store and other might not matter to your business rules. Am I on the right path?
You‚Äôre wrong, take a look at SPL Autoloaders. It only loads what‚Äôs required. Whatever floats your boat man. I wouldn‚Äôt suggest anyone to do this, it over complicated everything for absolutely no gain at all except for introducing bugs you wouldn‚Äôt expect.
I heard that PHP 8 will be all about Wordpress devs by introducing hooks and plugins for native functions.
Bad post title
Sounds to me mostly like "I teach Node because of hype". The upsides listed for node are beaten by many other languages with the only real benefit being that you also have to use Javascript on the front end so it reduces the need to learn 2 languages... but that's quite the useless pro.
Your point being?
My initial reaction (admittedly I only skimmed the article) is that as developers our goal is to understand our work well enough that the language one chooses is only a minor impediment. Learning PHP is fine, but only learning PHP (or Node.js, python, etc.) limits you.
Wow, nice.
Plus he forgets to put this chart forth: https://w3techs.com/technologies/overview/programming_language/all
... in the example, they hit the same site. But the cralwer might as well be hitting different sites at once, so it's not greedy at this point. 
My opinion is the most telling thing is that salary/years experience graph. PHP salaries are depressed, because the reality is most PHP work is Wordpress/Drupal jockey shit. While that graph probably includes salaries from India, that is also telling: because you're competing against 10s of millions of Indian developers willing to do work for a fraction of the pay you would need to even survive. If you're fortunate enough to work on an enterprise project whose backend is mostly PHP, then you will get a salary comparable to any other server-side language developer. But if you're stuck in WordPress hell at a typical WP dev sweatshop, then good luck to you. My advice: you would do well to master JavaScript to have as a backup in case PHP jobs are light in you area. Contact a recruiting agency and find out what languages come across their desk the most for your area. I'm willing to be JavaScript is at or near the top of the list. I had to switch from PHP to UI dev because that's where the jobs and salaries were at for me. I fucking hate UI development with a fiery passion and would love to work with PHP again, but that's what pays the bills right now so...
Hahaha....... Hats off to you Mr. Actually, who need the php ideas and program, this post for them. anyway leave it. Thanks for the comment and review, &amp;#x200B;
2004 called..
No man
Yes, I feel you. UI dev is kind of in demand here in PH.
This is why domain models tend to naturally gravitate towards anemia. Any complex domain involves multiple touchpoints, and it feels REALLY fucking dirty giving *models* what will inevitably be infrastructural dependencies. Domain models should be created via data in their constructors, and validated right there in the constructor. Domain models should be 100% bulletproof. No partial state or temporal construction. Literally if you have an `Order`, then there is one and only one way to construct it. If you have different kinds of orders, then guess what? Those need to be their own domain models that express the different kinds of orders of your domain. This fundamentally means that the constructor of these objects are reserved for data. Period. End of story. The only work they should be doing is work that acts upon their own state and validity. When some domain procedure has to happen, it typically involves more than one domain model, and that's where services naturally arise. The problem is that services often get treated like method dumping grounds, when services themselves should be specific expressions of the domain, much like models are. 
My opinion is that anyone who thinks you should focus on one programming language in your career is either a noob that has not yet mastered even one language, or someone who's always worked with just one and gotten too burnt out to learn any more. 
Didn't read it. JS is the most popular language at bootcamps. When you spend a lot of money on something you put yourself at risk of becoming a fanboy. In the early LAMP days you had to learn at least 3 to 5 languages. If you spend the same amount of time and effort _and money_ on only one language you're going to be a fanboi
Totally agree with that. The content of this post is too good to stay hidden.
Yeah don't learn oop and traditional inheritance. Specialize in a unique prototypal language. Definitely sounds like solid advise /s
Agreed. I'm an Enterprise CMS jockey and I and most my staff make well over the median here.
I don't agree. JS is terrible language when compared to PHP; no typehints, no interfaces, "this" has really weird usage when compared to any language... The only reason people use it is because it is easy to learn it. Or in other words; you don't need much time to learn something so limiting. It is the same as Laravel vs Symfony; just because something is easy to learn cannot be an argument for that, it only means you are using something with very little features. But there is one hope for JS; Typescript! TS is an **amazing** language, totally beats PHP, has generics, typed properties, decorators... If it only had decent framework, then yes, I would be switching to node (because TS compiles to JS). But Symfony has too big an advantage so I don't think others will easily catch up. By the time that happens, PHP will get those missing features. Next year we will have typed properties and maybe even [generics](https://github.com/PHPGenerics/php-generics-rfc/issues). When that happens... oh man... a whole new world will be open for speed optimizations. Imagine PHP code statically compiled :)
My experience with about 30-40 programmers is that when someone says they know 5 languages, they don't know even one of them correctly. Heck... I still never met a person who even heard of iterators and generators but they all say shit about PHP not being able to handle large tables. I once saw a guy claiming that ORM slows down when used on big tables (13 million in his case) which is something 100% totally impossible. And he has been using PHP for 17 years! I built 100 million rows demo to prove him wrong and it will be shown in few months. No visible slowdowns, full Doctrine2 mapping.
No üëé
If you want to be a web developer, you should learn web development. &amp;#x200B; To think it is limited to nodejs, or php, or any one language, is a mistake.
Learn both. It's entirely possible and the more you diversify yourself, the better jobs you'll have access to.
I work a lot with Node in the backend, either for actually writing backend services or writing integration tests. I've said this elsewhere recently, but I find they're complementary. Stuff one is very good at the other one isn't so good at, and viceversa.
I feel this must be quite regional. Here in the UK the php market is very healthy, and it's real development work. There's of course WP/Drupal/Magento, but there's a lot of pure backend work to be had over here - apis, queue workers, nothing that generates HTML.
I see a lot of UK clients getting devs in PH. Mine in particular.
Misinformed article. Pick the right tool for the job. In the web domain it does not matter that much whether you choose one or the other, although everyone will have their preference. My preference is NodeJS (or Go) for simple and/or near-realtime APIs and PHP (or Java or C# or even TypeScript) for more complex business domains. Python for data science, scripts and machine learning with C bindings.
Clickbait? Can't stand it, downvote it on sight.
To be fair, most of the OOP design principles apply equally to both languages, and knowing how to assign responsibilities to classes is the hard part in OOP.
Wow, it‚Äôs 2018 and there‚Äôs a blog out there that *isn‚Äôt* responsive. Useful content though. 
Composer can be annoying but it‚Äôs like caviar &amp; lobster compared to the braunschweiger that is npm.
Read first line, saw it was some sap whoring his Udemy course, closed tab.
Behat test would be considered a bot so it would need to guess which picture has road sign in it. Only way is to use test keys
Oh man, amen to this. NPM is *awful*. It's fucking hysterical to me how when you run `npm install` with a package-lock.json file present, *it installs new versions of things and changes the lock file*............ I can't even comprehend what was going on in the heads of the NPM devs when they decided that a lock file should *not* be a deterministic install...
I‚Äôm mostly a backend guy. Our front end dev quit. Needed to install one of our apps on a new server. Followed the notes. Git clone. Installed composer, installed node, run npm install (breaks). Try npm run build anyway (breaks worse). Npm stack traces are super clear, aren‚Äôt they? Revert to prior working backup. $1k and 2 weeks later, hired JS guru explains: install nvm (figure out on Windows, Mac and Linux under duress of ‚Äúthe site is down‚Äù) force install of 1 year old version of node (nvm install 6.11.4; nvm use 6.11.4; specifically) now this breaks because it refuses to install, update or repair nvm if you installed nvm with the standard `npm -g i nvm` so you have to remove it with `npm -g remove nvm` with a message like ‚ÄúThis isn‚Äôt the nvm you‚Äôre looking for,‚Äù and then a message to install nvm from https://nvm.sh - once that‚Äôs sorted you can force node version to the old one that works. Ask the js guru why this version? Why this process? Answer: because That‚Äôs the newest version I tried where it didn‚Äôt break. Mind blown.
This isn't true. All the work I do on php is not web development but backend services. 
Every time someone says "Why don't we use X, it's newer", it makes me want to blow my brains out. "New" is a flaw, not a feature.
If you think the code is too much confuse, too much spaghetti just forget that code and start all over. Try to evaluate the trade-off of having to fix spaghetti code and bad design decisions vs starting from scratch. 
Start with a golden master test that works at the http level. `curl | diff` is even sufficient here. Once you've made some set of changes, check against your golden master and see if the output is the same.
So you wouldn't ever check for null or empty variables or entity properties just because the table schema says the field is not null?
You assume results are not empty or the database is not responding?
Are those \`if (!empty())\`s actually doing anything? If it's as bad as you describe it, it might be that the code exhibited a lack of clear understanding of the data flow. What happens if the variables are indeed empty? Do they get handled somehow? If not you could try logging cases where the check fails and start to see how you could clean up code from there. 
Good refactoring skills are just as important (if not more so) as good architecture and coding skills. Get your hands on a really good IDE that traces references and has a good "find in files" and take it one step at a time. Work from the views inward, keeping in mind that views should have no real dependencies on them, migrating those dependencies back into business logic in your controller. And most importantly, use the original developer. He might not remember all of the weird spaghetti that he baked in, he probably knows all the places that he would stay the hell away from.
I'm worni2ng on large migration that includes db refactoring and I've been swapping isset to !empty() &amp;&amp; is_numeric() &amp;&amp; $var &gt; 0 to take the safest path (I have no experience with the codebase, just started the other week) .
Just a heads up, !empty() will return false if your value is 0 so no need for the $var &gt; 0
Ok, so there are other use cases for PHP, it is a general purpose language after all but it's more **commonly** used for web development let's say. Either way, it is a server-side **only** language whereas Javascript while primarily used as a client-side language can now be used server-side as well. So my point was that it is arguably more advantageous to learn Javascript instead of PHP because of this reason
Well there are -{int}s lurking in calls.
Does it work? Don't touch it lmao. But in all seriousness, what version of CakePHP are you running? If it's too much work it's better to rewrite the old applications in a newer (or other) framework or have the newer applications run in a newer and cleaner codebase. You could break a lot of things if you edit the current codebase and database. Also, discuss some code guidelines with your boss so everyone can work in the same manner without making a huge mess.
It seems like he definitly baked a spacecake üòÇ
Of course not. I've been a force for pushing the concept of a development server on the team, since prior to my working there, they had a greater tendency to work on the prod. server. I've watched the talk on your Modernizing Legacy PHP link before and have that book on my to-read list, but I'm still trying to learn comp sci fundamentals through Mythical Man Month, the wizard book, and Code Complete. They're great so far, I just can't stay focused on one of them long enough to finish them.
&amp;#x200B; I agree with what you're saying about picking the tool by the task at hand, also that nobody only specialise in one technology but if you were a beginner just starting out and had to choose between PHP and Javascript (because it is advisable to focus on one programming language at this stage), why would you need to choose PHP when Javascipt can do what PHP can and more. I can see why some decision makers would favor nodejs for the reasons you've outlined. However, I do think that it is a benefit that Javascript having both client-side and server-side capabilities. &amp;#x200B; &gt; Sadly, most "fullstack js" developers i had to deal with are glorified frontend developers, who are able to hack together a simple backend for their apps, but really don't have the experience or understanding of a full blown backend-developer, quite often lacking in knowledge especially about security and resource usage / resource planning - now that might be me having had to deal with the wrong guys, so take this with some salt. &amp;#x200B; That's likely due your experience working with these particular individuals. The same is true for any programming language really, its perfectly possible for a PHP developer to lack knowledge about security / resource usage etc. In fact there is a reason why PHP is renowned for having many horrible Legacy projects that most developers would hate to maintain. It is simply due to the developers who wrote the code, which is sometimes done under certain restrictions and conditions. The point is that if you worked with developers who lack understanding due to x,y and z. It is probably the developer not the technology they're working with, this includes PHP. &amp;#x200B; And as far as being able to have better structure with PHP, I think for Javascript, that has changed when Typescript was introduced. Typescript has basically solved most of Javascript's problems based on my experience. Javascript is much nicer to work with when you use it with Typescript. &amp;#x200B; Ultimately, the question is aimed at somebody starting out. If you're looking to be a web developer, do you choose PHP or Javascript (NodeJS)? And I think the article outlined some pretty good points why to go with NodeJS. In my opinion there is almost no real reason to choose PHP unless there are more **PHP** opportunities than **NodeJS or Javscript or Both** which is all dependant on the individual and the areas they live in. &amp;#x200B;
Well learning multiple languages can be beneficial. However, its not necessarily the programming languages you want to focus on, but things like programming fundamentals and design patterns. A beginner would have to start with learning one language at that stage, so should they choose PHP or Javascript? The article makes some good points, now that JS can be used server-side, what advantages do PHP have over Javascript? Well the only reason I can think of is that there are fewer JS opportunities in their area and more PHP opportunities, thats about it in my opinion.
Does this include PHP?
BTW, I had a similar experience. Is there a chance you're Dutch?
PHP (and/or alternatives), JS, MySQL (and/or alternatives), bash, others.
&gt;And as far as being able to have better structure with PHP, I think for Javascript, that has changed when Typescript was introduced. Typescript has basically solved most of Javascript's problems based on my experience. Javascript is much nicer to work with when you use it with Typescript. I'm sorry, but TypeScript is not JavaScript - while JavaScript is valid TypeScript, you can't run TypeScript directly on a JavaScript interpreter. The Argument of TypeScript vs PHP is a different one, than the one of JavaScript vs PHP, and by all means a JavaScript developer is no TypeScript developer. As for someone starting out there are quite a few valid reasons to chose PHP as the first language over NodeJS: * availability hosting wise. * more, and more mature learning material &amp; better documentation * you can start learning in smaller pieces, writing code you understand, rather than copying code without knowing how event loop of the nodejs framework even works. * a much more mature ecosystem of available opensource projects and libraries which you can use to learn from * better IDE support * better tools for debugging On the other end, If you want to build client side apps, you should pick something like reactjs, angular or vue, rather than starting with nodejs, aiming for "full stack" right away, which i wouldn't recommend, would be something like: js(+ReactJS/Angular/Vue)+css+html+nodejs vs php(+Slim/ReactPHP/Symfony...)+css+html, which still leaves you with a smaller stack to start with on the php side. &amp;#x200B;
If it really is a legacy system (rather than a good old fashioned shit show) there is likely a lot of old data and migrating that data would be another process in itself. I don‚Äôt think ‚Äúscrap all of it and start over‚Äù is really a valid answer.
!empty() is an elegant way check if variable is not empty regardless whether it is defined or not. It‚Äôs easy to read as well.
I took it 10 years ago. Just a line in my CV.
Why not use a real validator like https://symfony.com/doc/current/components/validator.html
Here‚Äôs some practical advice, not that I recommend against reading the suggested book. Do you have the ability to run it locally? If so, cannot recommend xdebug enough. Post to a controller method with the data from the form (use postman, it can sync with your login cookie and capture requests). Get xdebug working and add the ?XDEBUG_SESSION_START=phpstorm (or netbeans or whatever IDE you use) to the postman request and set a debug point at the top of the controller. Step through the code and take note of what variables are set where. A lot of old code uses shitty globals that can get created in code included in the controller. Next, take a stab at grouping similar code into objects, such as helpers, that you include in the top of the controller or the base controller constructor method. Create method names that actually say what they‚Äôre doing and add doc blocks identifying the name and type of data you‚Äôre passing in. If they‚Äôre arrays, paste a sample array of the $data getting passed in. One of the best things you can do right off the bat to understand code flow is just add some sane debug logging. You won‚Äôt be changing the spaghetti you inherited at this stage, but rather just getting an idea of the code flow and making sure your logging is working. You can add special constants __LINE__ and __FILE__ to the debug log message. Set your log level to debug and inspect log output. If possible include a session ID or other identifier like an md5 of the logged in users email in the debug log message. I say this because if you have a high volume transactional server where this is running, you can deploy this code for a few minutes, and do something like `tail -f error.log | grep &lt;yourEmailMd5&gt; &gt; /tmp/debug.log` then do your thing with your email on the server. Now debug.log has a whole bunch of info in it about the order of what‚Äôs happening in the code. Don‚Äôt forget to set the log level back to error, else you can fill up ‚Äú/‚Äú drive on your box with a 100gb debug log and bring down the app. Take back the debug log to your local machine via scp and study it line by line. To start refactoring, do as little as possible in each new method you make. Before long you will start to see some overlap, and you‚Äôll be able to start reusing code, most likely. Create helpers/objects for each ‚Äúdomain object‚Äù in your code, like UserHelper, OrderHelper, ProductHelper, ShippingHelper etc. Iteration is key, make very minor changes at first. Test the bajezus out of everything and have a rollback strategy so if something bombs you can quickly revert to the prior working version. Pretty soon your controllers will be short, and they‚Äôll be much more human readable because you‚Äôve moved blocks of code out to domain objects grouped by type. ~~~ $customer = $userhelper-&gt;getCustomerProfileForOrder($user); $order = $orderhelper-&gt;startNewOrder($customer); ~~~ And so on. Basically just by compartmentalizing functions together, the business logic of what the controller is doing should at least fit on one screen and be understandable. If you‚Äôve been using xdebug while doing this refactor work, and taking decent notes, you should be able to tell with high certainty that each iteration is not introducing new bugs. Of course, it goes without saying that by virtue of you now having first class objects with small, predictable, clearly defined methods in them, you can write unit tests for them. Hope this helps. Good luck!
We are heading that way. Let's say this code is partying like 1999.
Keep those on your book shelf. Find other good CS books ("Introduction to Algorithms" is one) and read them as you're able. These kinds of books are better done in short bursts than as a cover-to-cover read. Just read a chapter at a time and take the time to digest it. It's OK to revisit an old chapter again much later, when you're more prepared to internalize its contents. This is a long-term endeavor that should be ongoing throughout your entire career, so treat it like the marathon that it is and pace yourself. For the shorter term, your focus should be on improving the craft of coding. Get better at refactoring, learn patterns for cleaning up legacy code and writing clean new code. That's going to pay you much bigger dividends in terms of being productive and functional. I would much rather hire a clean coder than someone with strong CS chops, since most code is quotidian. The central challenge is to organize large amounts of simple code, rather than to algorithmic work.
I prefer using ini files to keep configurations. PHP users should be familiar with this file format. Usually I would have two ini files: application.ini and environment.ini, in first I would store settings common to all environments and in the other I would store settings that depends on environment.
Good advice, thanks.
I've done a LOT of cakePHP coding from version 2 through the latest version of 3. That being said I've moved all my dev work to Laravel - based on Symfony (as is cake 3) but is much cleaner and much more robust and has a MUCH larger and active ecosystem. I worked for a company for several years who talked about modernizing but when I presented several project plans to do so they always said no. Then the owner hired his buddy and they went to a convention for 3 days and came back and said "we're changing everything!" I asked what happened and they said they talked to some guys at the "Magento booth" and they guaranteed them that if they switched to Magento that they would go to the top of the Google search results because "Google loves Magento". Then they asked me if I knew how to program in PHP because that was required for Magento. I facepalmed my resignation. Anyway - loooong story short - if they're really gonna get on board for an upgrade then great, but if not, I'd wish them good luck but they probably wouldn't know what to do with it. And you may have topped out at your current job - maybe time to move on / up.
This was my first thought too, and removing a bunch of variable checks because they ‚Äúaren‚Äôt pretty‚Äù seems like the best way to refactor a codebase into a worse state.... There are so many ways data could fail a !empty() check between the database and the executing code.
Isn't C#'s standard published and mono open sourced?
C# as a language is open source. .NET core is too.
First, C# is a purely OOP language. PHP offers support for OOP, and it's considered best practice, but it also has support for procedural programming. Second, PHP is more geared towards web development, while C# is more general purpose. Third, PHP is an interpreted language while C# is a compiled one. 
only [partially](https://github.com/dotnet/csharplang/blob/master/spec/LICENSE.md).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dotnet/csharplang/.../**LICENSE.md** (master ‚Üí 8b155d4)](https://github.com/dotnet/csharplang/blob/8b155d4c9dd5679982fd48afae48cdd7c765aaf0/spec/LICENSE.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e58nrcx.)
Open source does **not** equal free software.
Having been down this path many times, I'd say worry less about "fixing" those individual controllers and views, and instead find ways to replace the most important ones piece by piece. My preferred path is to simply replace PHP rendered views, with simple JSON serializing rest endpoints, then handle the presentation with react on the client side. I'm sure many of the controllers/models are doing many things wrong (e.g. the constant empty checks are probably bad practice, and I have a hunch there are numerous repeated queries that should be a single query using JOINs instead). But that doesn't mean you need to junk all the old code just because it's bad. I'll often make simple Model classes that serve as wrappers around some PDO built prepared statements. Go through his old code to see how to build your queries, then build models out only when you need to create a new feature that relies on them. You'll quickly reach a point where 95% of the time you have one of your nice new models to use, and the other 5% of the time the old code will still be around. 
semantically true, but licensing plays a significant role. i don't consider C# open source just because the underlying code is publicly available, it still has proprietary / non-open interests, and the open source community in general is far less likely to support such projects without monetary interests of their own.
You'll get an error if you use !empty on undefined vars. 
No one cares what you define as open source. We have definitions for a reason.
You're on deep water mate.
not really, but whatever.
Haha what version of CakePHP? We are stuck on 1.3 at work and are in the process of migrating our front end to angular and our backend to java (spring/akka)
TLDR: We're making optimizatinos. Use phan, static code analysis by the same guy. 
https://3v4l.org/Ydc5q
CakePHP 1.3, which is a little ways back from 3.6 that they're on now. We've discussed it before and he's even given me time to try to update the framework to get us toward being able to use PHP 7.x. There's also talk of using Laravel for new projects, which we've dabbled in.
i would just use doctrine (one of orm/dbal) instead. :)
&gt;latin1\_swedish\_ci You should probably add the `charset` and `collation` keys to the array passed into `$capsule-&gt;addConnection()`. Example: $capsule-&gt;addConnection([ "driver" =&gt; "mysql", "host" =&gt; "127.0.0.1", "database" =&gt; "test", "username" =&gt; "root", "password" =&gt; "root", "charset" =&gt; "utf8mb4", "collation" =&gt; "utf8mb4_unicode_ci", ]);
There‚Äôs no bad part from OOP, he is just a frenzied FP fanboy and I don‚Äôt recommend you to listen to his nonsense. 
Thank you so much!
&gt; because my boss doesn't really know how to handle errors correctly. but boss is not developer, or is he? checks like `! empty ()` are quite hard to just remove safely. you need to rely on and ensure that the data source does never sends empty/invalid. and if the same boss is not around maybe try adding constraints to db as well?
but \`use App\\Somewhere\\\*\` is not not present :(
phpstan is also very good, and complementary. There are things that one doesn't catch but the other does.
Very interesting video, I found it quite enlightening that his vision for PHP is not what PHP became at all. As a professional developer myself I have to wonder how I would feel if a project of my own got carried away. Proud I imagine :)
ctrl + d
Sometimes it might to people who come here rarely and miss it. This filtering of seen posts should be handled in reddit itself though. 
Is there any tl;dr; post summing up main points in practical easy-to-apply bullets?
I wonder how this matches StackOverflow Survey.
&gt; they don't know even one of them correctly. define "correctly". You mean that you could write production code on any of this languages? This isn't needed. The goal of learning different languages is to better understand concepts. Some of them could be applied to your PHP code. Language is just a tool and it shouldn't be matter if you or someone else loves it or hate it. &gt; who even heard of iterators and generators There are more chances that you will find nodejs developer who is aware of generators/iterators and knew how to use them than php community. And I'm not talking about C# or Kotlin developers. Even if they got generators not as long ago. &gt; but they all say shit about PHP I like quote from Joe Armstrong (one of the creators of Erlang) - "PHP is brilliant language, apart from syntax and the semantics" [source](https://youtu.be/-I_jE0l7sYQ?t=40m16s). This is really good talk, I recommend it to you. &gt; I once saw a guy claiming that ORM slows down when used on big tables (13 million in his case) which is something 100% totally impossible. I would argue this kind of tasks could be splitted into 13 million transactions (OTLP is where ORM shines) so it could be done iteratively, or you should use SQL. &gt; And he has been using PHP for 17 years! Again, from other talk: "If you hire developer with 10 years of experience please verify that this is 10 years of experience and not 1 year repeated 10 times" (can't find link right now :()
If it was posted before I must have missed it. Thanks so much for sharing! That was awesome!
Interesting stuff. Looks like javascript and python are really cleaning up..
&gt;I'm sorry, but TypeScript is not JavaScript - while JavaScript is valid TypeScript, you can't run TypeScript directly on a JavaScript interpreter. The Argument of TypeScript vs PHP is a different one, than the one of JavaScript vs PHP, and by all means a JavaScript developer is no TypeScript developer Typescript is a superset of Javascript, and I would still say that it's an valid argument as it is an option that is available to Javascript developers no different than options like Carbon or Guzzle available for PHP developers. &amp;#x200B; And I'm not convinced by some of your reasons for PHP are valid either: &gt;availability hosting wise. Both PHP and Javascript are on the same level in terms of hosting. &gt;more, and more mature learning material &amp; better documentation I wouldn't say thats true, in fact PHP has a lot of outdated and terrible tutorials. If by documentation you're referring to [PHP](http://php.net/manual/en/) vs [Javascript](https://developer.mozilla.org/bm/docs/Web/JavaScript), I would argue that the JS one is better and is maintained by Mozilla. Not that it matters, both languages have been around for a long time and both communities are large and thriving &gt;you can start learning in smaller pieces, writing code you understand, rather than copying code without knowing how event loop of the nodejs framework even works. This sounds like an developer problem, not programming language issue. Not too sure why this gives PHP an edge over Javascript. I've not convinced this is a valid argument, and what you've said here can also be applied to PHP. &gt;a much more mature ecosystem of available opensource projects and libraries which you can use to learn from Its not a numbers game, both have a high number of open source projects. Not easily comparable but we know Javascript is likely to have more diversity and variation due to its flexibility as a programming language e.g. Mobile development, server-side, machine learning, game development, web development etc &gt;better IDE support How do you know this? if you're referring to PHPStorm, JS has Webstorm which is equally good. The difference between the two is that Webstorm is free and therefore would be a pro over PHPstorm which you'll have to pay for. VSCode has IDE-like features for JS out of the box as well, although we can get similar features for PHP via extensions. &gt;better tools for debugging Again, how do you know this, most major browsers has support for debugging for JS out of this box. PHP has xdebug which is ok but sometimes difficult to setup. So I'm not too sure why you think this gives PHP an edge over JS. &amp;#x200B; I agree those things you've outlined are some of the good things about PHP but those are already available for Javascript. The only difference here is that there are Javascript features that are NOT available for PHP at all, which is why I would consider Javascript the better language to pick up by beginners. Furthermore, Javascipt simply has better salaries, there is no real reason to pick up PHP unless there are more opportunities than any other language in your area, this includes Javascript, Python, Java and C# and maybe Ruby as well (although Ruby has been on the decline recently) &amp;#x200B; Those all pay more and most can do **everything** that PHP can do and **more**. I'm not say that PHP is a bad choice, its just that there are significantly better choices for most people based of the reasons above and NodeJS in particular based of the evidence provided in the article of this post.
One big gotcha here is that it won‚Äôt support multiple connections out of the box. I haven‚Äôt figured it out yet, but our apps get data from two sources and we have only migrated to some of the code. We tried adding multiple connections by name but the bootEloquent() should only be called once. Maybe I need to create one capsule and add a function that can do this so when it boots, it boots both at the same time...hmmm. Anywho, I‚Äôd only suggest this if you‚Äôre working on migrating towards Laravel and your source code was riddled with vulnerabilities. 
Can you describe a situation that Eloquent makes difficult to test so that I can show you that it doesn't? Thanks.
You don't test the database, or the fact that the record exists in the database, you test the logic of getting the data set up to be inserted or updated. So many people, I have seen in the past, Test from the fact you say `$model-&gt;column = value;` to the "Does table have the value in said column"
https://www.reddit.com/r/PHP/comments/9c9a8o/php_in_2018_by_the_creator_of_php/e594dzt
Grab the dragon book, too. Compilers Principles, Techniques, and Tools - again - read it bursts.
I've been working in CakePHP 1.2 legacy code for years, I've also tried updating to 7.x but it's not easy and we didn't have the budget to continue with it. At least not for the projects we had running. Eventually we made the move to Symfony and all those CakePHP projects are in support more now. The project I was leading that was still on CakePHP had major refactoring done to it, all new developments would be split up from the framework unless it was a small bug fix. Adding composer and a service container which you can access from the controllers is a good start. It allows you to move code away from the controllers and make them independent of the framework, Symfony's components were very helpful with that. CakePHP's database layer is a giant mess but making repositories helps you move away from it later on. Honestly, before you start refactoring things, you should learn how to program correctly. How to split up code in logical pieces, follow best practises, unit test if possible but definitely do some functional/integration tests. Another piece of advice, you don't need to refactor everything right away. If you can manage to just copy paste the code in logical pieces, you can still refactor those pieces later on, and even test it properly. Do consider seeking the help of a consultant or hire someone with experience with modern code and refactoring.
What do you mean it won‚Äôt support multiple connections out of the box? It works how it works in Laravel, you can add another connection by calling the addConnection method again and passing the name as a second variable. 
My team uses CakePHP 2.10 (the latest version in the 2.x releases), and an upgrade to 3.x was not tenable for us. We have dozens of controllers and hundreds of models and the amount of rewriting to upgrade would be astronomical. 
Key takeaway: 30% of devs don't unit test. Would one in three of you reading this care to comment as to why not? 
it does. you are making some mistake testing it
Ahhh... perhaps I mentally extrapolated from unit test to "any testing at all", for which I'll forgive myself since no other forms of testing were noted in the survey. Behind that, you're absolutely right. I used to strive for as close to 100% coverage in unit tests as possible, until I forced myself to recognise that false pride had actually cost me productive development time in writing tests that added no real value in the way you describe. 
Exactly what does in Java. Include every namespace.
I'd rather spend 5 minutes fixing a problem than 30 minutes writing tests to prevent the problem. 
Overall, use psalm and phpstan, not phan, which requires an extra extension that doesn't match production deps anyway.
Don't engage. He's just parroting shit that he hears and doesn't actually know how testing works.
I've read that before. I meant something more useful in practice.
Mostly job security
 I agree with your points. Unit Test is not for every situation, and some tests are useless. But it's more dangerous when **developers cheat** and some developers cheat a lot. For example, let's say that you are using mock to test the database and, instead of testing a real database, you are testing code that doesn't connect to any database. If you are testing the database and, at the same time, you are not, then what are you testing?. Also, it's not as simple to do a unit test. Let's say for example sum($n1,$n2) { return $n1+$n2; } We could test : * 1+1 = 2 * 0+0 = 0 * -20+40=20 and so on. However, *9223372036854775807+9223372036854775807 returns a float (it lose precision). So if we don't do all possible test then, we aren't doing a proper job
Are you using or connecting to RD or RDS? (Remote Desktop Service). If it's the first one, then maybe you have "root" (administrator) permission or you have enough permission to download and run PHP as a website under a session. However, if somebody closes the session, then your program will stop working. 
Often not worth it. Depends on the cost of the code failing. NASA should do it. The guy building the app for his local pizza store? Maybe. Maybe not. Some code, once you get it working you really don't change it much,candidate there's no value is testing something that's not changing. Pizza ordering app? It's all lists and forms. Here's a list of coupons. Here's a list of stores. Here's a list of pizza's. You'll change the data but you're aren't changing implementation of those lists every time you update. If I'm writing data transformations I'd favor running a unit test over Going 4 screen deep into an app to see if its worked, because unit tests will be faster faster. Often though that's not the case, and I'm not NASA. 
the feels when phpstorm has changed all the file associations to itself and it was just some simple shit you could fix in a second. 
Unit tests (or any tests for that matter, unless you are doing TDD), don't save your time right away. But they will save you time and give relief over the time. I'd gladly spend time to wrote tests if I can upgrade the PHP version, run the test suite and deploy knowing that nothing is broken. 
QuickCheck is very useful for this kind of tests, although I don't know if an active and complete PHP implementation exists.
Terribly bias BS. They only surveyed the emails on their list. and then list say "Try PHPStorm, majority of developers use it", Yeah majority of the users you surveyed are already fans/consumers. No shit. I want to see real statistics. 
A good place to start is when bugs come in. Honestly only about 60% of our application + use-cases is covered by unit/integration tests. But often when new bug comes in, I write a unit test for it, so I never have to deal with a regression again. Two tickets or tasks get created any bug now, a fix and a unit test. You are only adding a bit more labor here, frankly, your boss doesn't even have to know you wrote the test if they are being grouchy about it. Just include that time in the scope of the bug fix.
 In the beginning of 2018 we surveyed 6,000 ~~developers~~ customers. No surprise that Java is their top programming language result
For me it really depends. Our core API that powers our business? Yeah it has unit tests and integration tests out the ass. I think 70 tests and 1,400 assertions. And its saved us on releases a bunch of times. Our backend b2b CRM? Nope. We don't want that to break, it looks bad, but we just didnt spend the time to write the tests because its just not a mission critical piece. I think its crazy to not have tests for mission critical components though.
Correct. And what is the cost of a bug? Do you have reporting in place to catch it? It is only catchable by user reports? Could cost a ton of money. Not worth it to me.
If you're a startup, you're changing your code a ton. But there are times when it just doesn't make sense. I would think on this sub we are speaking to engineers and not pizza app builders though.
Python is surprising. JavaScript isn't. JS has a complete monopoly on the browser. Zero competition, of course its in that position. 
Typos are a funny thing, the amount of times I accidentally have tried creating a new public functino is incredible. 
Always thought they just hijacked that name for some reason. Thanks.
Very literal interpretation. Pizza ordering app represents something trivial with the point being that some development is more trivial than others and will have different needs. Changing code != editing code. Editing existing code is when unit tests become valuable, but you don't have to edit existing code to change an implementation. You could make a v2 function/component/app and swap out the old for the new. Old unit test now means even less than it did before. Testing that can survive that are still valuable, of course. If the old code is being used in many places, and you have to edit that code then we have a very good use case for unit tests, since editing could break several things in the app in unique ways but, having x copies of the algorithm that work in their respective niches is a safer bet imo since you won't break the others implementing changes just for one.
I know fb group admins usually will manually approve all the posts on fb, so that there's not as much double up. But I don't know the norm on Reddit.
That should work. I had two separate connections configured (same db but different users) in a non Laravel app before.
I agree that some integration tests are important. As are hand tests where you simply use the application. But some things can't be easily tested without unit tests. For example, you'll have a very hard time testing that your data access layer's partial retry logic works without unit testing using mocks. And that's very important to test before it happens in production.
&gt;**Lorem ipsum** c'mon
What are some examples of well built, open source, MVC-based PHP applications? I'm interested in seeing how duplication was avoided in the controllers. 
That's brilliant. I love the idea, hahaha.
Alternatively, I have adopted a legacy system based on a well known an thoroughly NON-unit tested framework, and am expected to introduce improvements to an existing ecommerce site... So while I'm catching up with backing up the whole thing into a git repository, while I'm planning a deployment process that isn't just FTPing files blindly and hoping for the best... Well, I don't quite yet have time to start looking at unit tests, or take the next step beyond to integration testing, then full suite testing including robust fuzzing... So while I know that unit testing is a foundational part, I'm currently sinking in quicksand... and while I'm shipping in boulders to stabilize the ground so that I can start planning my foundation before I actually build my empire... I just need to worry about keeping my head above water for a few more months.
This is exactly how I've always felt, but I've also always felt that I'm "missing" something, lacking a key understanding. It's good to know others are on the same page as me.
&gt;define "correctly" There is no possible way I can write here all the bad code I have seen. But imagine Wordpress, Opencart, OS commerce... style of programming, tons of if-else statements, hundreds of lines of code per method... and most irritating: no typehints. PHPStorm gets all yellow (even without EA plugin) and that doesn't bother them; it is PHP's fault somehow :) &gt;If this kind of tasks could be splitted into 13 millions transactions (OTLP is where ORM shines) so it could be done iteratively. If it's not you should use SQL. Again, this is more about algorithms and dependencies on data. &amp;#x200B; Why would I run 13 millions queries? Makes no sense regardless if you use ORM or not. It should be done in batches; can't remember the best results for reading but best write results I got is 9000 objects per seconds. Yep, I didn't even think that PHP can create that many objects+that many reflection instances per second even without any DB writes. Although, indexes were turned off during import but it only affects the speed of DB, not the ORM. But that is not the point. He claims that using ORM makes things **much** slower which is bullshit; ORM has fixed cost. Dummy example with fictional numbers: if my query takes 10ms to read 100 results, total execution would be 12ms; 2ms are mapping those results to objects. If my query takes 5000ms, total execution would be 5002ms. But he claims it would be much higher in this case, for reasons unknown; we never got any numbers, first signs of bullshit. &gt;Again, from other talk: "If you hire developer with 10 years of experience please verify that this is 10 years of experience and not 1 year repeated 10 times" (can't find link right now :() &amp;#x200B; This one is **amazing**, I love it! Thank you, I will surely use it when someone tries to use years as argument for something. And I will check the video later, gotta earn some money now :) &amp;#x200B;
Why not have look at the [Symfony demo application](https://github.com/symfony/demo)?
What does 'include' mean in a PHP context though?
When they go to shake your hand, offer your schlong and start to pee immediately
You can have phpstorm reformat everything to psr-2 either by pressing ctrl + alt + l (windows) or automatically when you commit, very nice
MVC is a difficult concept if not impossible to reproduce in a web application, it was never designed for web applications. The term has become a 'buzz word' or 'marketing' term which has lost most of its original defined concepts from the 80s. This is why you see so many different 'implementations' of 'MVC' because they are all so far from the original concept people do as they please. The ADR pattern makes much more sense in a request/response environment which the web is. More reading here: [https://github.com/pmjones/adr](https://github.com/pmjones/adr) 
Certainly type-hinting all of my functions brought me to realise a couple of bugs that had somehow gone unnoticed for years. Now I try to be as strict as I can throughout my code, but I still do everything in php.
type definition done freely by the developer wins.
I'm not actually answering your question directly (never come across any github examples myself), but all the duplication you see is controllers in most projects always seemed pretty crazy to me too, especially for form submissions. Always seemed a bit off to me that I would tend to copy &amp; paste the general form submission logic (for many many many years), because it's basically the same thing for all forms, aside from them having different fields and permission levels needed. These days I just have one controller action that all forms are submitted to. And my forms are defined using a form system where each form is written as a class that just defines the fields, validation rules &amp; permissions needed etc. They mostly don't need any actual custom logic/flow code (`if` statements etc). Form the most part the definitions could even be written in JSON. The form processing code for all forms is just in that one-and-only form-submission action (and the base form class). It does all the typical things you need to do when taking a form submission: * check the user has access to edit the model * loop over all fields in the form definition, run their validation rules etc * 0 validation/permission errors?... Cool, save the model(s) and redirect the user to whatever page they should go to next * Validation failed? Send back the validation error messages All my forms use AJAX, I stopped bothering with non-AJAX forms a couple of years ago. I can do something similar for AJAX links too (things like upvote/downvote/subscribe buttons etc), as they technically aren't really that much different forms. Same for deleting models too (both soft + real deletes). So for all above there's basically three URLs for that cover all models/tables: * Forms get POSTed to something like: `/formpost?form_name=EditUser` * AJAX links POST to something like: `/ajaxlink?ajaxlinkname=upvote&amp;model_class=Comment&amp;model_id=45434534` * Deletions get POSTed to something like `/delete/soft?model_class=User&amp;model_id=123` On PHP I was using Phalcon and it's form system, with my own extended class with lots of helper methods for it all. Lots of other frameworks have form systems that work the same way. Obviously you need to be careful that your permissions system is done right, and you should make it default to everything require a full admin user, unless a lower level is explicitly allows. And you need to whitelist stuff like the `model_class` values etc. But once you get that stuff done, it saves an absolute fuckton of repetitive work (which gives many more opportunities to create new bugs too). Also makes it trivial to add logging and auditing etc to the entire system in one go instead of more copy &amp; pasting with minor edits. So basically the only controller actions I need to make are for the regular read-only viewing pages. But even then, more of that's also being centralised with AJAX/JSON, and also looking into graphql soon too. It's crazy the amount of mostly-redundant backend code I used to write compared to how I'm doing things now.
Don't get me wrong, your archaeological effort is very impressive and educational. But... making each chapter a distinct link on Reddit is a bit overkill, IMO. It will make a spam-ish feeling, though your articles are not spam at any rate. Would you consider to post a link to a complete work instead? It will get a decent rating, I believe. 
Well, it's still better then the weekly "Which editor/IDE do you use to write PHP" oder the monthly "I read this article from 2005 that says PHP is dead and a bad language, DAE think that's so much bullshit?"
Excuse me if my question is too dumb, but what are key differences between mvc and adr? The way i understand mvc is the same as adr described with different names 
I understand your point. This was the last one though. :) Tkx fir making a constructive critique, btw. I appreciate it, and will take note for next time.
All things being equal, strong typing would always win out. But all things aren't equal so it's a trade-off. Weak typing tends to ease development through less boilerplate and more flexibility, strong typing catches a whole class of bugs in the compile phase. But beware of bullshit strong-typing: every time you downcast an object in Java, you're just pretending to be strongly typed. But thankfully these days the choice is more nuanced - type inference systems mean that in e.g. Haskell you can write an ACTUALLY strongly typed program with very little requirement for explicit type declarations (with the trade-off that the fewer types you explicitly state, the less helpful the error message is likely to be). Gradual typing plus static analysis in PHP (especially with support for union/intersection types) means that you can get some of the same type inference benefits, without having to bend your architecture to fit the type system, or tediously declare types that you can prove are correct anyway by inference. And finally, strong typing rarely goes far enough. Sure it'll stop you supplying an array to a function that expects an int, but it will quite happily let you email a telephone number. The OO answer to that is to stop using primitive types and wrap everything in a value object, but I assume that's because the proponents enjoy carpal tunnel syndrome. Contrast with Haskell again: type Email = String type Telno = String And that's without getting into algebraic data types...
How do you learn faster while working 9 to 6? I have started learning programming this year. When i just started, my progress wad fast enough, after couple of months i started internship anf later got hired as junior developer in the same company. But noe i feel like i do not learn fast enough. There is so many things i want to understand properly, such as SOLID programming principles, different design patterns, http requests, functional programming and i could keep on going forever. But if i am home at 7pm and tired as hell i get no time to study. By the time i learn all the things i consider a must, i will be 60 yo going at this rate. How do you guys manage to improve when there is so much to learn and so little time?
&gt; Sure it might be nice to be able to return an int, array or bool all from 1 function No, it's _NOT NICE_! unless the return value is nullable (union between null and the type), you should avoid multiple return types.
It is nice if you're lazy as hell ¬Ø\_(„ÉÑ)_/¬Ø
unit tests suck though, we've replaced all our unit tests with functional tests. Implementation details are not that important, it's the outcome that should be tested. Unit tests require so much mocking of the implementation details that you end up with a useless test when refactoring.
I'm still unsure why ADR was created (if we can call it that because it seems to be made up). What specific problem does it solve? It's just Request -&gt; stuff happens -&gt; Response. This is not revolutionary: this is how web works.
You nasty. 
Here's a starting point on the differences: https://github.com/pmjones/adr/blob/master/MVC-MODEL-2.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pmjones/adr/.../**MVC-MODEL-2.md** (master ‚Üí 5c6c043)](https://github.com/pmjones/adr/blob/5c6c0436ea58e9665c253a53688be99cf71fbe75/MVC-MODEL-2.md) ---- 
I didn't ignore the rest of what you said, but what you said was wrong. You said _"it might be nice"_, no it's never nice, so don't mention it, even if you want to contradict yourself afterwards.
First, I must say I am surprised that this question was posted here and not in /r/programming - that's not the kind of high level question that /r/PHP usually gets. So first addressing your question. Weak typed languages are perfectly fine and acceptable for large systems. Those who say it's not are usually thrown off by the consequences of lack of strong typing: the ability to let bad and wrong code explode in your face before it hit production. It's important to say that you really can't avoid typing. If you're handling it or if the compiler matters very little with the regards whether there's type checking or not. PHP is more "flexible" (and I am using this word very broadly) than some of the other mainstream dynamic typed languages in the sense it tries to align the types for you. That's why you can add 1 to "a" and it doesn't error. Something has to do the type check for you if you are not aligning types yourself. PHP just tries to convert the types and move on. With that said, if you want to go big you'll need to at least write unit tests for your types. That's the safest way to scale PHP code bases up. The tests are going to do the type checking for you. Not the runtime. The larger it gets the more critical is to keep a healthy test suite of the code aiming to cover at least types behaviors and, possibly, integration with other types. All that on top of the regular testing strategy that you might be already doing. OK - PHP introduced optional type checking. So you can add types in your code and it is going to play just fine with the rest. PHP is not still a language that you can use a compiler to generate an asset that can be used to serve. You have to use PHP runtime to serve it. That means that part of the benefits of using static type system goes down the drain, because there is not an obvious way to massage the code unless you run it. Again, tests here are your salvation : you might need to write tests that confirms the type design you made so to give the runtime the opportunity to crash. I don't dare say that strong typing system is better than weak typing system. What I do know is that I experienced way fewer catastrophes with strong type systems. 
&gt; I think the term MVC has been so overloaded and applied to so many different approaches that it has has become pretty much meaningless. I agree; for a background on how that got started with Model 2, one may wish to see https://github.com/pmjones/adr/blob/master/MVC-MODEL-2.md .
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pmjones/adr/.../**MVC-MODEL-2.md** (master ‚Üí 5c6c043)](https://github.com/pmjones/adr/blob/5c6c0436ea58e9665c253a53688be99cf71fbe75/MVC-MODEL-2.md) ---- 
I like returning multiple values with Go. Well maybe just two values, the result and an error and checking for that error is amazing. Seems to make code much cleaner and you don't have to deal with try/catch hell. Also enforcing types is great. I feel I can unit test my code and I feel like it's going to work. I know my requests will come in the format and type I choose and there's no weird type juggling bug that I'm missing.
&gt; Our core API that powers our business? Yeah it has unit tests and integration tests out the ass. Agree 100%. I want to make sure if I change anything in my system that the API is still returning the exact same thing it was returning for previous requests.
&gt; unit tests suck though, we've replaced all our unit tests with functional tests I guess you've never been in an environment where unit tests are worth their weight in gold. I'm with you on functional tests, I always write functionally tests for every user facing application even if their are zero unit tests. Unit tests really matter when it comes to writing business critical code. In a recent project it involved payment processing and as a result adding 'credits' (in this case credits = GB's) onto a user's home broadband account. For things like this ensuring low level functions performed calculus correctly is a no brainer. &amp;#x200B;
So a company's survey highlights JAVA as the most used language when that said companies main customer base are JAVA developers? Eye opening stuff 
you can write pretty low level functional tests as well though
The tech industry is huge, so the first thing you need to get comfortable with is just not knowing everything, that's an achievable goal. Instead of trying to learn "faster", just set out to learn a little bit every day. It's nearly impossible to write good code for the entirety of your work day, so use the time when you're in between tasks to read up on the topics you want to learn. Follow your interests and just take the topics one problem at a time. Prototype some ideas you have using new frameworks that use the techniques you're wanting to acquire. Maybe even try to automate some of your more tedious tasks at work. That will help you improve your skills and make your life easier. Also, look for ways to discuss these topics with your more experienced co workers. They can point you in the right direction and give you inspiration on how to use different coding techniques. After you spend a few years learning little by little, you'll look back and reflect on how far you've come, and you'll surprise yourself at how quickly you actually learned it!
Do you see duplication in [https://github.com/Cryde/insult.es](https://github.com/Cryde/insult.es) or [https://github.com/Cryde/php-vote](https://github.com/Cryde/php-vote) ?
The reason why PHP and Javascript are weakly typed languages is that they make things easier for absolute beginners. A web designer whose pages are primarily HTML pages, with minor PHP/Javascript code, will enjoy him/herself with the weak typing. He/she doesnt have to worry about whether it is 2 or "2", as a designer this isnt important nor interesting. But if you are a programmer, the weak typing will bother you a lot, leading to strange and annoying bugs. When you apply operators with 2 or "2", the results may surprise you. Also when you pass them to functions/methods, you may get unexpected results. At this moment weak typing is a hindrance for PHP to evolve as a programming language, perhaps PHP 8 should become a strongly typed language instead. 
If you are quickly prototyping/POCing then weakly is fine imo; even getting to MVP will work. But to scale a production-ready product certainly strongly-typed is a better choice. Sadly though in reality most companies will prove the concept using a weakly typed language and then never rebuild for the long term, so at this point I recommend strongly-typed in all situations as a mitigating factor against future tech debt. For example, I see no reason why Typescript shouldn‚Äôt be the norm in Javascript.
There‚Äôs nothing elegant about using `empty()`. 
TS is game changing for the javascript ecosystem for sure. I cannot code any frontend or backend js project without the ts compiler anymore. PHP is still good enough. I see so many Symfony powered project here in London in the fintech industry. It's crazy. I would have thought Symfony would die a few years ago. But it's still going strong.
This is something that fucking pisses me off about programmers: we like to come up with strange usages of words that totally obliterate all intuition. How long did it take everyone here to really understand what "Model" means in MVC? Raise your hands. I'm betting a few of us. Model means lots of things in English. "Model citizen", "model car", "weather model", "to be a model", "to model clothing". The closest meaning is the "weather model" one, but at the end of the day, what happens is exactly what you described: A request comes in, a URL is matched to a handler, and a response is returned. *So why the fuck aren't we using those explicit terms*, and instead are using these verbal gymnastics that only leads to confusion?
What exactly did you expect from a survey from the creators of tons of IDEs? Just accept that some questions will be very biased. 
Agreed
Just another cargo cultist.
While this isn't the _only_ reason to write tests, it's certainly one of the many benefits. So, maybe time to write tests? :D
I feel like your last bullet missed the mark on testing a bit. The point of testing isn't to try and prevent every bug you can possibly fathom, that's almost wasteful. Some of those bugs may never make it to reality. The most important test to write is the happy path - what happens when everything is "right" - you absolutely want this because this is what lets your users keep moving forward. The obvious edge cases are also important, of course. Rather than focusing on adding as many edge cases or input combinations as possible, add them when the bugs actually make it to production. It's a much better use of your time.
PM me and I'll screenshare with you in your framework of choice for a couple hours.
Looks like a peepee
If you want, PM me and I'll screenshare with you for a couple hours in your framework of choice and help you get started with testing.
&gt; Two tickets or tasks get created for all bugs now, a fix and a unit test. Interesting, I've just always considered the test part of the bug fix (kind of like the last thing you said). It's reassuring knowing that at least _some_ places appreciate their developers writing tests. Personally, i write the test for the bug first so I don't have to use my browser to fix the bug. This is obviously a lot easier if the happy path is already tested.
I've been thinking about the lack of seperation of concerns: https://github.com/ellisgl/OBWA its definitely a WIP.
&gt; Changing code != editing code...you don't have to edit existing code to change an implementation. I'm a little lost on this. You absolutely do, as you even say so here: &gt; swap out the old for the new. The _unit_ tests might be fine to do that and they might be "less valuable", but hopefully there are also integration tests somewhere!
I audited a system that has a high code coverage (about 80% I'm not kidding) and it passed its tests. However, the entire system was a mess, I found several vulnerabilities of security (SQL injection for example) and of course, they (the developer team) failed to test it, simply because they don't know about it. You could say, but SQL injection is obvious. Well, not for everybody. For me, Unit Test = Gamification. It works in some cases, but at the end of the day, it's all about the quality of code and a **PROPER QA** (that it's different to sugar syntax). 
Not exactly. Depends on how the function is invoked. Even if you hard code it, you'd be updating code covered by an integration test not a unit test. In retrospect, I should have said changing functionality != Editing code though. 
I disagree here. We started integration test heavy, but as we've moved more stuff to dependency injection we've deleted heavy integration tests that require lots of fixtures in favor of smaller unit tests. I guess the caveat here is and rather big assumption is made that the engineer is implementing the class/method correctly. We are still integration test heavy and will never get rid of all of them as they are very nice to have, but I prefer unit tests when possible.
Whether it's backwards or not is definitely subjective, and ultimately it doesn't really matter as long as the test is written. I do think you spend a little more time on it your way if the happy path already exists, though, but that's only because you still write the test and also still do all of the manual testing. Looking at things from a matter of typing, if you write tests at all, and you use the test to drive the code, you'll type less in the long run (because you don't submit the form however many times as necessary). Either way - it's good to hear you're at a place that at the very least is neutral on their developers testing, rather than "we don't have time for that!"
&gt; Depends on how the function is invoked. While things like `call_user_func` or `$foo()` can be useful at times, dynamic function invocation is something I try to actively avoid. That said, I will usually do dynamic functions over a long switch or if else. &gt; Even if you hard code it, you'd be updating code covered by an integration test not a unit test. As was my last point in the previous post :D &gt; I should have said changing functionality != Editing code though. I absolutely agree with this! However, you shouldn't do _either_ without tests, though :D
Both are good; have their pros/cons. I feel like most reasons usually trumpeted for strongly typed languages are expected to be accepted; i.e. their claims are unproven.
Naturally you need to test :D the point is unit tests aren't always the right tool for the job, not that testing is bad :3.
I couldn't agree more. It's as if there's a fetish for creating patterns... The web is request-action-response. I guess what happens in the action is really where it's at and regards that, well it's just good old general coding, right? Actually, you should be able to take a two programmers, one without any web development experience and one who knows about handling requests and responses, and the latter should be able to give the former a spec for the inputs and the expected response, and they should be able to produce a working app. That's essentially what APIs are. Hey! The API pattern. Who's with me?
I really should try full TDD sometime. There is often so much trial and error in programming and structuring the code, refactoring to reduce cyclomatic complexity etc. that I just assume write the test after.
Slim has a great approach on ADR
So, the point of TDD is to make that trial and error, structure/architecture, and refactoring easier (and flat out safer). Now, it depends on which tests you write first, of course, but the "outside in" approach was a god send in helping me understand how to do this stuff. I'd be willing to screenshare with you for an hour or two in your framework of choice to help give you a kickstart if you want. If you don't want, then there are also great resources like [Test Driven Laravel] (while it's how to do TDD inside Laravel, it's really a great beginner's resource for testing), which is basically a video form of [Growing Object Oriented Software Guided by Tests]. That took taught me the outside in approach as well as "programming by wishful thinking". The point is that you let an outside level feature/acceptance/functional/etc test be what you start with, and you write production code that you _want_ to exist. Starting at your controller, you just write the function calls you think would make sense for that feature. Of course those functions might not exist, but that's okay! You use this skeleton to drive down into unit tests for each of those functions, then as you bubble back out to the controller code, eventually as you get the unit tests written and passing you have no more controller code to write tests for. You re-run your outside level test and it just works. It completely changed how I viewed TDD.
How much more time are you spending planning code now versus before TDD?
I think it's because the term originally referred to program state rather than a persistent store, and was used in the context of desktop applications running an event loop. When the pattern was applied to the HTTP request/response cycle, the naming conventions just naturally followed since there was already published academic work using those conventions.
&gt; ADR :-( I am interested in ADR but I don't get it neither there is an example or something that show what it does. Right now, I embrace ASP.NET MVC design, it works and it's highly defined (Convention over configuration), Bundle (resources) and Identity is so-so but everything else is pleasant.
I don't really plan code, most of my planning is for a solution, not for the code I'll write. I'll write a higher level test (acceptance/functional) for a behavior I want, then I'll start mucking around with some code to get that test to pass. Truth be told, I'm not always great at the "wishful thinking" part from the book I mentioned earlier. I'll refactor like a mad man once I get that test passing, though. Refactoring is _always_ fastest when you've _just_ written the code you want to refactor. Then the tests already being in place to tell me if I've messed anything up is the icing on the cake. I also just realized I didn't provide links to the things I put in brackets in the last post. That was a failed attempt at markdown (forgot to put the links at the bottom, so here you go! [Test Driven Laravel](http://testdrivenlaravel.com) and [Growing Object Oriented Software Guided by Tests](https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627)
I coach programmers (mainly in Java but also in c# and PHP), practically all my students study at night (the onsite classes are around 7pm-10pm). It takes 3 months and my students are able to develop a system, they aren't expert and I cut corners but they learn, basic programming, web, session, arrays, objects/class, persistence and so on. I am yet to find a student that isn't land a job, so the demand is high. If you are disciplined, you could learn by yourself considerably in 3-6 months. **The secret is to go straight to the point**. It's silly to try to learn everything, even PHP is huge, for example, mysqli or PDO MysqlI, pick only one and leave the other. Then, is it possible?. yep, it is. And yes, it is possible and there is so much to learn, so you must be really picky in what you are studying. 
Would you happen to know where it is? I looked for it in their catalog and couldn't find it.
For more and more projects I just start with UML again as that is something business and proces people can understand. I also build proper test cases with decent coverage and data fixtures to do case / workflow testing. When one of the requirements changes, and they do as the business changes, I can safely make changes or see what needs work. &amp;#x200B; The funny things is when you just update a sequence diagram in a meeting and you see people change their minds (about priority also) as it becomes visible what they're asking. Specially when you can run some unit tests with some of the modification. Then again I work in a sector with regulators that want to see proof and minimal risk exposure.
It's called "The PHP Practioner". You don't start refactoring to an MVC type framework until the last few episodes.
I don't really bother with UML. This is likely because I've never had a good mentor/coach for that specific skill, but every time I've tried to commit to doing any sort of modeling (whether I follow UML or any sort of loose diagrams) I end up feeling like I'm doing more work than I need to, and it hasn't helped me catch any pitfalls up front. This is certainly a skill I wouldn't mind developing, but I think I'd need a good "here are the benefits" and "here's the gotchas it can save you from" type scenario. I'd actually like to see how changing a diagram can make people change their mind or priorities. Something I've always struggled with at various places I've worked is getting the business people to understand it's not "just a button". I do, however, make some small modifications in meetings and run tests and tell them what breaks as a result, just to prove a point. I think that's a very powerful tool. I usually get started by asking people to define the behavior they want. I've yet to work for a place that can give me adequate acceptance criteria, but I'll take what they give me and turn it into something similar to Gherkin (but i won't get that verbose since it's only for me), and I'll often ask probing questions for obvious edge cases I think they might be missing. I'll take that set of acceptance criteria and bring it into function/acceptance tests into my test suite. I'm absolutely in love with this workflow as it provides a type of checklist.
&gt; neither there is an example or something that show what it does Ask, and ye shall receive! https://github.com/pmjones/adr-example (It's linked at the bottom of the README/home page, but I can see where it might be easy to miss.)
I remember at the time being impressed with Symfony and its creator Fabien Potencier for exactly this reason. Everyone was obsessing over MVC and its interpretation, and [Fabien came and said](http://fabien.potencier.org/what-is-symfony2.html)... &gt; I don't like MVC because that's not how the web works. Symfony2 is an HTTP framework; it is a Request/Response framework.
Found the right documentation and kit after logging in
Web controllers (or handlers) are implementation details: a way of accepting and sending messages coming via HTTP. I'm not a fan of patterns that seem to completely overtake the application architecture, such as MVC and ADR, often turning implementation details into their primary state of being. Maybe I'm poisoned by DDD and hexagonal architecture, but I also disagree with putting persistence-specific details in the domain. I guess you could use MVC, RMR and ADR for these implementation details only, but it's not how they are commonly used.
We also have integration tests, functional tests are way lower level
I actually made one of these systems. The reason i use the word model it comes from my postgresql database model. My Members table and my Products table are all "Models", and from those i automatically generate class files in php to create them and update them ect. Entity framework did the same thing in C# with the word "Entity". It's the name for the atomic or generic thing everything is.
Man I don't understand that title, I briefly skimmed "kitesurfing" Not saying the content is bad... wind window... a window of wind, a square, with air flowing through it
I don't feel like the author made his point at all. The article basically says "there is good re-use and that's what I want to do". Even the sole example, having two sources stuck by using the same database is solved better not by re-use, but by an API between both sources and the database. The kitesurfing analogy just served to muddy up the topic as well, it didn't really fit anything that was said at all.
For a large application, it is crucial that small parts work neatly. To work neatly, unit tests are necessary. I have observed that strongly type languages do some part of the unit tests. Therefore, I would recommend a strongly typed language for a large application.
I work everyday 1h on my personal project and I experiment whatever new concept or tech I want to use to achieve some funky idea. Repeat this process over 2/3 years and you will level up. &amp;#x200B; To be honest, I also had the opportunity to experiment new tech while working (mostly in startups). I could for instance use Angular 2 in alpha/beta because I sold my boss this was the future and Angular1 update would require months to achieve. This way I got to improve on tons of new concepts like Reactive and Functional Programming.
&gt; Mostly job security Official team members taking digs at another project? Classy. I thought that was Taylors job
This article is pretty much a copy and paste from most of the other articles that explain this, you haven't even bothered to changed the model examples. This is a very common pattern from [codewall.co.uk](https://codewall.co.uk) hopefully it will be banned soon.
In your `docker-compose.yml` file (as stated in the beginning of the section) :) https://github.com/thecodingmachine/symfony-vuejs/blob/master/docker-compose.yml
I'm probably not your target audience, but it would be nice to see something visual of what you've made - personally I've never used any of the technologies you've used for this tutorial and clicked hoping it was a showcase.
Well, it surely is job security for me: already had to "refactor" that stuff out a few times due to otherwise unmanageable complexity.
Can you elaborate on what you think qualifies as "good" reuse? I really didn't get anything from your article that exemplified that.
Reusable components, shared libraries, inheritance is a form of code reuse, traits...
Shared libraries, traits and inheritance are not reuse, they're quite literally the opposite of reuse. They are components invented specifically to avoid reuse.
Thank you, 
Yes, I developed the interface. Thank you.
But I got the job 
Ok so we have a definition problem, what's code reuse for you?
You should definitely put it on WrapBootstrap. I would buy it 
I am an entrepreneur, I do not have much time. but I will think.
&gt; Well, it surely is job security for me So the main reason to use Eloquent is job security? I've personally never used it outside of Laravel and not really used Laravel that much professionally in the last year so I might be out of touch but it was perfectly fine for the job and very well documented. I have picked up many Laravel projects in the past and had no problem understanding and using the Eloquent implementation, hardly the previous dev trying to keep job security, in fact quite the opposite. It just seems a crappy, petty dig for no reason, something Taylor is (and rightly so) often called out for.
I wanted to start collaborating with other devs in github. Like do a WordPress plugin or something. Where should I start? Should I randomly pm people on github? I got no idea.
I've been reading a bit about Vue recently, and it seems a bit easier to grok than React. Would you say that is the case? 
&gt; it seems to be made up Isn‚Äôt that always the case? üòÇüòÇ It was created to make explicit a separation of concerns that does not exist in ‚Äúwhatever MVC alternative you use‚Äù for the web. It makes explicit that use-case logic should not go in the action, but somewhere in the ‚ÄúDomain‚Äù, which i personally prefer calling ‚ÄúApplication Core‚Äù as it is called in Onion Architecture. It also makes explicit that the role of the action is to translate a request to a ‚ÄúDomain‚Äù call, and the responder role is to do the inverse, which is translating the ‚ÄúDomain‚Äù response into an HTTP response. It also prescribes ‚Äú1 controller -&gt; 1 action‚Äù as a way to optimize dependency injections in the controllers. ADR makes all this much more explicit than any other HTTP presentation pattern I know. I guess the blurriness of HTTP presentation patterns is why @pmjones put time in figuring out how we could do it better and published it. I think he did a great job with it.
I think just like you, but i also think ADR came to fix that blurriness in HTTP presentation patterns. I think my reply here might make my view clearer to you: https://www.reddit.com/r/PHP/comments/9cjtt3/comment/e5daoi8?st=JLNL7GE3&amp;sh=ff49faf4
Yet another article where someone touched PHP a few times (if at all) in the 2000s and now talks about it like a veteran. Also, contrary to what the article suggests, Web 2.0 was pretty much built on top of PHP, Ruby, and Python. Where was JS then? Right, in jQuery, mootools, and prototype.js, doing the exact wrong things which the article describes PHP was doing.
&gt; Web controllers (or handlers) are implementation details: a way of accepting and sending messages coming via HTTP. Correct; specifically, they are User Interface details. In ADR, the Action "accepts" the Request, and the Response "builds" the Response to be sent. 
I don't know how to meaningfully test the database lookups. And &gt;95% of all functions have at least one SQL. 
So... if I'm to take your definition of reuse and your medium article, you work with developers who advocate ***against*** traits, inheritance and shared libraries?
Just to bikeshed for a minute while I'm having my morning coffee... PHP, as a language, offers me nothing- honestly. It's a weird love-child of JavaScript and Java and it does neither side very well. The only thing it has going for it is the ecosystem. If PHP 8 were to be a different language, it would likely lose backwards compatibility. So it would have to be significantly better than Go, Java, Kotlin, etc. That's a tall order as there does not seem to be any shortage of really nice languages lately.
This tutorial is awesome! I've been building traditional Symfony applications for two years and it was very interesting to read about how you use it to create SPAs
Returning multiple values is different than return potentially different types as your result.
Didn't get the question sorry. The article is about balance, looking for appropriate duplication and code reuse, knowing how to spot them.
Good stuff :)
Massively. Vue makes use of existing HTML rather than invent a new language with tons of special connectors and syntax. I personally prefer the single file components as well, which keeps the HTML and JS separated but adjacent (CSS is also an option but can be a little more effort to set up correctly). To me React feels like trying to play Code Golf or doing some sort of self-congratulatory pat on the back for writing the most technically correct code possible.
&gt; It's as if there's a fetish for creating patterns. In the case of ADR, at least, it was not so much "creating" a pattern as "recognizing" one that already existed, and giving it a name.
Did you ask them? From a couple of minutes I've spent checking this out, I would say that you have to work on your language skills. There are quite a few typos in the README and variable naming is also problematic (I've noticed you have **$route = new \Klein\Klein();**, when you probably wanted to name the variable **$router**). Also, the commit that adds the "Builder pattern" actually is implementing all of the Controllers, so your commit history is not logical. I don't know what was exactly asked from you, did they maybe tell you that they use some framework and yet you "wrote your own"?
If you try to submit the exact same URL the submission form will tell you that it's been posted and provide a link. That falls apart when you submit a URL with parameters on the end or, like in this case, when you submit a shortened URL and the other posts used the full URL. So yes, it's been shared before but it's usually not a huge deal, especially if it still generates discussion.
But 45% of PHP devs don't use a testing framework..
no, I made it public after their response.
I agree that the most sane approach would be to default to strict typing. As far as what future PHP may look like, I'll be amazed if PHP actually looks like that pre macro within the next 10 years. In the mean time, Swift, Rust, Kotlin, and Go already exist and look like that language.
Actually the virtual DOM is a neat way to update the view without writing complicated render() functions and functional components are a nice idea as well. Although one can use both without having to use react. Unfortunately people hardly go see what the codebase of their favorite tool look like.
&gt; but they just said we cannot move on after reviewing your code. well ask them why. Only them can tell you what's wrong.
Still, I think it is bad form to publish your repository and the assignment. Were you discussing techniques, components, philosophies or the color of your buttons, out of context, that would be okay. What your Reddit post ends up doing is devaluating this interview material. If I would work there, this would tick me off pretty badly.
So you have no configuration management at all? How do you ensure consistent, reproducible development environments?
I write my own containers... in PHP. Who needs freaking docker?
There is the tutorial in the docs : https://exakat.readthedocs.io/en/latest/Tutorial.html It goes through installation and the first audit. You may DM me if you need help, or join the Slack channel for exakat : https://www.exakat.io/exakat-slack-channel/
I have the feeling you might be confused as to what a container is, seeing as implementing one in PHP is hardly practical and would offer none of the benefits offered by services like docker But it sounds like your workflow is working well for you, so if it ain‚Äôt broke, no need to fix it. Unfortunately such an approach isn‚Äôt sustainable when your requirements expand beyond a typical standalone CRUD app 
Thanks :). Ive also Just hear a podcast with the maker of exact.io so he seems legit. Still then so weird there isnt so much to be found regarding external article etc. Because it all looks amazing!
as someone who's done a lot of interview projects - props on you for going through that. also, i think that's some bullshit. maybe they wanted you use a framework like slim or silex? maybe they wanted to see some swagger (openapi) docs for quick ingestion? it's also possible someone just did it better than you and they didn't want to do the dance of trying find a way to put you down lightly or something. don't take it personally. i did a full blown project and live testing for a company. we're talking 4 hours live coding complete with tests. they said they loved it to my face and they'd give me an offer after talking to HR. then they ghosted me real hard. who the hell knows. 
But php fpm in combination with nginx or apache is
Can confirm. Using Laravel with doctrine.
I believe it‚Äôs a question of taste. On one hand meeting and interacting with other people not related to your projects can be great. On the other hand, think about the quality of furniture you can buy yourself to keep forever if you invest $250 differently, as well as the quiet you can have at home when you have a dedicated office room. I have spent some time in co-working spaces, but eventually I prefer working from home, where I have a nice desk, chair, and silence. I can still go out for lunch and to meet other people at meetups and the like. 
Nope.
This depends on how big of a team are you working with and what is your deployment process. Having docker allows you to easily onboard new developers with same exact setup.
with so much happening at the data layer i feel like e2e / acceptance / integration (whatever the current name is) can be more useful. i still keep 90+% unit coverage on my project, but another project i work on (java) has like 1% unit coverage but more or less full e2e coverage
sure would be interesting if all browsers supported more languages i guess a happy medium would be to write PHP / C# / Java that compiled to JS or something. but at that point why not just write JS. although i will say that that most annoying thing is JS config objects where you need to pull up docs to know what to write. would be awesome to inspect and see getters and setters
You misunderstand the issue with ORMs. The problem with ORMs isn't slowness mapping the results to objects; people using non-ORMs will map results to objects as well. The problem is that the schema and queries generated by an ORM are often highly inefficient. 
&gt;ORM are often highly inefficient Can you give one example? And no, triggering many joins are not a problem of ORM but of a programmer who forgot them. That is why my 100 million rows table works totally fine. The guy I mentioned never explained the reasons but I am pretty sure it is because of pagination; counting is the only thing that is slow on large tables. But this guy uses Laravel; that pretty much explains his lack of programming skills. My solution had same problem which I solved by simple cache of nr of results per table. Just one small annotation on entity and pagination is working instantly. Heck... if I had bigger SSD, I could put 1 billion results, just to see what happens :)
How is this any better than traditional SQL? With this I need to learn a new way to write SQL which is not normal for me or anybody else reading my code. And since I assume that you are converting to SQL on the backend it is just adding that tiny bit of overhead for no reason. The idea here is good, but I think it's not good to be used beyond yourself that developed it. Not trying to discourage you from continuing to develop.
&gt; PHP, as a language, offers me nothing- honestly. It's a weird love-child of JavaScript and Java and it does neither side very well. The only thing it has going for it is the ecosystem. fwiw i think its a love child of Perl and C++, i dont see much (any?) influence of Javascript in PHP. I don't see a lot of Java influence either TBH
&gt; I like returning multiple values with Go. Well maybe just two values, you can return multiple values in PHP as well, just return an array and unpack it 
Does coffee script or those type of things help with any of that I wonder? 
I think PHP type "hints" are probably the best implemented type system I have run across with the one exception that it would be nice to be able to type hint array/collections using either generics or some kind of special typed array functionality. i mean there are a lot of advantages to being forced into types especially because you can really get bogged down in pedantry.
&gt; Docker I really should learn that shouldn't I. VMs are so passe... &gt; Symfony 4 Oh, I know this one! &gt; Vue.js Ok, I know it's similar to React, I'm not completely lost here... &gt; Vue Router Aha! I can imagine what this is by the name! &gt; Vuex Sure, why not...of course there's a thing called Vuex &gt; axios ...I'm just old, aren't I?
That one definitely needed /s
Sorry, I mixed up what I read. In the opener to the article you say that you were arguing for code duplication (I thought you had said reuse specifically). I guess my question is actually, in what situation is code duplication ever appropriate?
Fair enough with respect to Perl. Some things look a little more Perly (`$variable_names`) and some look more like JS (`function(foo) { return foo * 2; }`). I haven't written Perl in years, though. But I disagree vehemently that it's more like C++ than Java. C++ allows multiple inheritance and has no `interface`, first and foremost. Also, C++ has a concept of constness, which neither Java nor PHP have. All of the OOP syntax is basically verbatim copied from Java. Look at the following classes in C++, PHP, and Java: &amp;#x200B; // C++ class Foo final : public FooBase { private: const int x; public: Foo(const int x) { this.x = x; } int getX() const { return x; } } // Java final class Foo : FooBase { private int x; public Foo(int x) { this.x = x; } public int getX() { return x; } } // PHP final class Foo : FooBase { private $x; public __construct(int $x) { $this-&gt;x = $x; } public getX(): int { return $this-&gt;x; } } The C++ example contains some const semantics that don't exist in either PHP or Java.
When you work from home, you live at the office. And for many people that works just fine. I've worked remotely from my own home office for about five years now; however, the best thing I've done for my productivity was join a co-work space. I now work from the co-working space 3-5 days a week. If I need complete privacy for a meeting, I'll stay home, but otherwise, getting that separation back between "work" space and "home" space has been great. There will always be distractions and noise including the neighbor's kids/dogs, construction in the next lot over, and the pile of laundry/dishes. It's done me a lot of good to be around other tech-oriented people and in a walkable downtown area -- I was having trouble getting the motivation to get out of the house after 7pm, after working there all day. YMMV, but I started getting enough extra productive hours to offset the cost for my space.
Still way different. In Go, you can return a `(double, int, string)` and the compiler will always make sure you return exactly three things, the first of which is a double, the second is int, etc. In PHP, you return an array and it may be empty or contain three `PolarBear`s.
Not according to this article. The Action is clearly the processing of the request, the responder is clearly the construction of the response. The domain is the logic that takes the output of the action and provides an input to the responder. It's request -&gt; "domain"-&gt; response. My point is since the "domain" (business logic, call it what you like) is simply processing inputs and providing outputs, it's not necessarily web-specific. I consider this part of the whole thing to be the least worthy of discussion from the WEB developer's perspective. If the goal is to explain to newcomers how apps can be structured, and those developers are operating in a web environment, then the focus needs to be on the request and response parts since the "domain" is just a data source, an API, whatever, it can be mocked, and it's secondary to the web functionality of parsing inputs and constructing outputs. 
So, got it. I can't share the code since I wrote it at work, but all I had to do was have a custom DatabaseManager extend Illuminate\\Database\\DatabaseManager that changes the implementation of addConnection() to accept a PDO and a connection name. From there, addConnection examines the attributes to determine which driver to use, then returns back either a MySqlConnection, PostgresConnection, etc from Illuminate\\Database with the PDO passed into it. &amp;#x200B; I did this so that we can continue using our centrally managed database configuration setup.
phptherightway either the website or the book, either one works as something to fall back on. Laracasts and Codecourse are the two best PHP tutorial sites I'm aware of right now. They are mostly focused on the Laravel framework though, not a lot of vanilla PHP. 
&gt; ...I'm just old, aren't I? If it makes you feel better, I had to google axios too...and I have "senior" hanging on my office door.
Why do you equate complicated code with production readiness? Excluding a vendor folder and tests you could write this app out it maybe 10 files, 15 to 20 lines a piece. Let's add in 10 test files say 40 lines each. You've got a robust production ready app thats robust and we'll built in less than 600 lines of code. Production ready ‚â† complicated. 
Don‚Äòt worry: As soon as only one of the components gets a major overhauled, the hipsters get called out if their beds :)
There's a difference between over engineering and creating something confusing. Separating this out in to Hexagonal Architecture would be a good example of over engineering. Going for CQRS (Like I think you were trying to do? I'm not sure) would been over over engineering, but still good. But the goal is still to be understandable. They should be able to take 3 minutes and see where everything fits together, even if it's over engineered. You may have aimed for over engineering here, but you hit confusing instead. There's no point in throwing in a bit of high level skillsets in if your reviewer has a hard time understanding what you're doing 
Laracasts has a lot of great content for vanilla php for beginners :)
 1. Security - The most important thing One of the main ideas is that it is more secure and user-friendly. With just traditional SQL, it is just a nuisance to escape user-inputted values to prevent SQL injection attacks. With SuperSQL, you do not have to worry about handling all that because it does it for you seamlessly. (An SQL attack is where a person uses the syntax of the SQL language to "inject" their own code. IE, if someone inputed `' - DROP users`, he would effectively erase that table. 2. User-friendliness &amp; compatability SuperSQL makes SQL very easy and simple to use. Traditional SQL requires more effort, as you must handle everything. Its much more simpler to do `$row1 = $db-&gt;select("table")[0];` than using the PDO/MySQLI Interface, which requires more lines of code. In addition, the goal is for the library so that it is easy to build compatible code with SQL, so it works on every database. 3. Efficiency SuperSQL encourages people to use SQL efficiently because of the way it wraps results. A common mistake among amateur programmers is that they fetch all rows after a query even if they are only going to use one. For SuperSQL, the SQLResponse object handles the optimizing that so you can literally just do `$result[0]` while fetching only the first result, and do things like `foreach ($results as $row)` while only fetching the rows used. In addition, the overhead is amazingly small (as you said, tiny). I optimized it as much as I could. The time actually used in executing the query actually dwarfs the overhead. I would say, that for the benefits, it is totally worth it. 4. Its better than SQL @Flipper - Just because traditional SQL is "normal" does not mean it is the best. SQL is a big mistake of a "language" in the first place. It was designed to be "natural" so it would sound more like a conversation/voice command than a programming instruction. Think about it, why in the world would having a separate "language" inputted with a STRING be better than having a API coded in. SuperSQL emulates that, and so "fixes" SQL by having a code based API. 5. This has been done before - Many times Many people have already created this sort of library to interface with SQL. Such example is Medoo (which is really popular), which uses almost the same concepts as my tool. However, SuperSQL is far more advanced. It's so much more efficient (it's parser is about 3 times faster), and has more features in a smaller file size (Code redundancies were avoided, im talking unminified here ;) ). 
Vuex is just state management for Vue. Axios is just a JavaScript library to make HTTP requests. 
I can't imagine how you could split them? 
This is a pretty nice stack. I use exactly the same, except swap Symfony for Laravel. 
All very good points and things that I had overlooked. I agree with all of the points about security and having a layer of abstraction (it's what Laravel's [Eloquent](https://laravel.com/docs/5.7/eloquent) is able to to well too). However, I think my main issue with the library is the format of it. Looking at your example code I could never understand the SQL statement it is running behind the scenes. I may be biased, but I just love the format of the [Query Builder](https://laravel.com/docs/5.7/queries) within Laravel. And going a step further, would this be for cases where an ORM is not necessary? And what are the use cases of those in the current development landscape? /u/ollieread has a neat [blog post](https://ollieread.com/blog/2018/08/07/how-i-accidentally-created-an-orm-to-avoid-using-eloquent) about how he tried to stop using Laravel Eloquent and at the end of the day he ended up creating an ORM anyway. I guess: what makes SuperSQL better than other Query Builders? If it is just speed/efficiency, you should include some benchmarks to give an idea of that.
I'm going to also recommend Laracasts. Can't support them enough 
I traveled for a year during which I checked out some coworking spaces abroad. It's an easy way to find a stable office and to meet new people (stable meaning - good wifi, desk space, etc) . I came back home, where logistics aren't an issue, and worked from home and cafes for a year. After a while I needed something different - I craved being around productive people and having more consistency in terms of going to work. I have a membership through Croissant, which is nice because it lets you hop around a bunch of coworking spaces, but the tradeoff is that you don't consistently see the same people. You also aren't included in events specific to each space. I'm heavily considering getting a dedicated desk at a single workspace to meet more people, both professionally and socially.
Are you using vagrant for your local environment? Does your nginx config include `sendfile on`? If so, turn it off.
&gt; Are you using virtualbox for your local environment? Yes, I'm using VirtualBox for local &gt; Does your nginx config... I'm using apache
Disk cache means that Chrome is pulling the data from its caching location. You can prevent this during development by enabling ‚ÄúDisable cache‚Äù in the Network tab of DevTools or by doing a hard refresh (Ctrl+Shift+R). To force end users to ‚Äúclear their cache‚Äù without actually doing these steps, change the query string on the end in the HTML.
My personal opinion, believe it or not, is that SuperSQL's strength is it's format. I personally do not like chaining, as in the query builders. For speed and efficiency, although I have not tested it against a wide variety of query builders (I would want a test though), I am certain that it would perform better than a lot of them. I believe this mainly because I think that other projects do not aggressively optimize as much and are probably more "bloated" projects. I super-optimized SuperSQL, making sure I use all the most optimal methods. From almost not using the super slow PHP `count()` function to optimizing regexes, I kinda went crazy on the optimizations.
It sounds mystical haha, I also wasn't sure I saw a quadrant diagram thing and I was like "window as in the cliche square with a cross on it window?" haha
Maybe this plugin can help you[Copy Path Helper](https://plugins.jetbrains.com/plugin/10304-copy-path-helper) 
Turn off `EnableSendfile on` in your apache config, then.
&gt; Fair enough with respect to Perl. Some things look a little more Perly ($variable_names) and some look more like JS (function(foo) { return foo * 2; }). I haven't written Perl in years, though. im not sure what you mean here? r u saying they got the idea for using lamdas from js? because both JS and perl implement lambdas as closures and php does not 
If you had some experience earlier, I think the official documentation is just great.
You misinterpreted SPA, I think.
This is not a support forum. Please use /r/phphelp
Perhaps it's an issue with Code Style settings? When PHPStorm generates code for you, does it generate with single or double quotes? 
It's impossible for this code to produce an error like this. Show us the real code.
Check out your codestyle settings, but if you use PHP CS fixer on save it will fix it for you when you configure it to use single quotes
&gt;Python is surprising They have one of the best (probably the best) Python IDE's which also happens to be free. Of course Python is going to favour well in their customers/communities survey when a large proportion of people the survey targeted use Python.
Probably not your target audience anymore but I had completely forgot about tuts+! Glad to see it's still going, I learnt a lot from it in my early career
God you're up your own ass. It's an API with 5 endpoints and it edits TWO database tables, I am consistently blown away by developers abilities to think they're prepping a Luna Landing Module for its maiden voyage and not making a fucking simple API. The solution I proposed had 3 x times as many testing lines as it did functional and you're saying I didn't add enough? You're crazy or your tests are wrong. If a million line project has 250,000 code lines and 750,000 test lines you've gone to the zoo! And again why the fuck do we need a overly complex domain model here? It's an API with like 10 fields!!!!! Y'all a crazy. You can do this, safely, securely, production ready, well tested for 600 lines, less most likely anyone who says different is waiting my companies money so they fellate themselves with the complexity of their domain model. I bet you're a Drupal developer. 
Thanks for the support. This means a lot :) 
Ok so now that's what the article is about. A very short answer is when code reuse is not working anymore, it's causing more more work than maintaining duplication. That's why you need to do figures of 8 in the good quadrants.
Thanks. My frontend skills are somewhat out of date, and while I still like jQuery, picking up JS app skills that are amenable to unit testing would be pretty good. I'll put Vue on the list `:=)`. 
I would hesitate with recommending phptherightway to a complete beginner - it presumes a large amount of knowledge and uses a lot of jargon. 
Would also recommend Laracasts - the [PHP practitioner](https://laracasts.com/series/php-for-beginners) course would be a good place for a beginner to start.
Thanks for your message
Your biggest problem just became nothing to do with your code, but how you take valid and useful feedback. Even if you don't agree with what someone says you do not have to say you don't think very highly of them. I wouldn't hire you on that basis alone.
&gt; And again why the fuck do we need a overly complex domain model here? It's an API with like 10 fields!!!!! Y'all a crazy. Because you're meant to be showing off how good you are. If a 600 lines project is the best you can do, then you're not good enough for my teams. We deal with extremely complex things. That's the whole point of the test, show off what level you want to work at. You're talking about a junior development level of quickly get there, instead of showing off that you know, how can I know if you know how to properly do functional tests and unit test etc if you don't show me? &gt; I bet you're a Drupal developer. Nope, I deal with large-scale complex systems. 
&gt; Nope, I deal with large-scale complex systems. Me too. I don't know what gave you the impression I'm a rube and reading your comments about discarding perfectly good developers because they don't conform to your strange idea that complex ideas need complex code as the only solution seems strange to me. I wholly stand by my assertion that a PHP project with 250,000 code lines and 750,000 testing lines is a bloated piece of junk no matter how complex you think your system is.
What? Who said I would say this to someone? I said I would think it. Words are important. And in this case, I would be the one reviewing the test and obviously, when reviewing tests you need to either positive or negative thoughts. I honestly suspect you didn't understand my comment at all. 
&gt; discarding perfectly good developers because they don't conform to your strange idea that complex ideas need complex code as the only solution seems strange to me. That's not what I said at all. I said I would discard developers who provided anything other than greenfield production code. The entire point of the test is to see their level of development. Since they don't have technical debt or anything else to deal with and they are 100% free to write what they want and they should be trying to show how good they are. If they have an anemic model, no interfaces on their repositories, SQL queries in their view, they breach SRP, no unit tests or poorly written unit tests, no functional tests or poorly written functional tests, no build process for CI, etc then obviously I am going to judge them on that. Especially if it's for a senior position. If you don't know how to write a unit test that isn't going to break on the 29th of February you're probably going to break my stuff. If you create classes called services that contain 4 different responsibilities you're going to do that to my code base if you don't understand the difference between unit and functional testing you're not that experience at testing. Obviously 250,000 lines of code is nuts, it's a simple spec but equally 600 lines of code shows that you put little to no effort into the test and you either haven't put any effort into showing how you want to work professionally, or you have and I have no interest in that. Overall though, I don't use these sort of tests while recruiting, simply because I would refuse to do it because the amount of time I would take to do it properly and produce something that could withstand good developers looking at it to find flaws. 
https://knpuniversity.com provides quality content. 
The only thing I quickly see is that you run $insertStmt-&gt;execute() twice. But don't know if that can trigger an error like this...
nope it cannot. it was already resolved, a confusing function name in mysqli
Or, you know, just pay up 100$/year and use [Envoyer.io](https://Envoyer.io) It's way way simpler to set up and use, just as powerful (based on the same tech) and you don't need to set up and maintain deployment servers, you just rent operations servers and connect them to Envoyer.
No, I just mean the syntax for defining functions and/or object methods is borrowed from JS.
&gt; It's request -&gt; "domain"-&gt; response. (/me ponders) When I read "request -&gt; something happens -&gt; response" I see "request" as "the HTTP Request" and "response" as "the HTTP Response". That is, a request is provided to the system, and a response is emitted by the system, but those are products, not processes. Now, if you treat the word "request" as "the processing of an HTTP request to marshal it as input", and the word "response" as "the processing of domain output to create an HTTP response" -- *then* "request -&gt; domain -&gt; response" might make sense, but I think that strains the definitions of Request and Response. Thus, my reasoning when I say that ADR describes the "stuff happens" part, a la "request -&gt; (action -&gt; domain -&gt; responder) -&gt; response".
You can't go wrong if you start here: [https://www.phptherightway.com/](https://www.phptherightway.com/) . It will also give you a sense of what is worth reading and what to discard.
constantly working alone from home can become claustrofobic
"...with PHP Deployer" missing in title
Sorry, wasn't aware.
I'm symfony dev, should I give second chance for laravel?
I'd like to interject for a moment. The IDE you appear to be referring to as, PHPStorm is in fact called, PhpStorm. Don't worry, I don't expect developers to pay attention to details, but you would do yourself and everyone else a favour to get it correct in future.
I'd like to interject for a moment. The IDE you appear to be referring to as, PHPStorm is in fact called, PhpStorm. Don't worry, I don't expect developers to pay attention to details, but you would do yourself and everyone else a favour to get it correct in future.
Nope, if Laravel didn't pass through in your books in the 1st chance, no way it will now. It's taken the same direction it took long ago. I like the way it's headed but the critics have only more to criticise now
Did your main account get banned or did you just decide to make an alt for fun?
Do you feel that Laravel would make you more effective? Do you feel that there are jobs in which Symfony is more poorly suited than Laravel? If neither of your answers are "yes" then you're probably safe in sticking with Symfony. That said, I personally like Laravel and it was worth learning it. You never know when you might inherit a project based in Laravel.
&gt;I'm symfony dev, should I give second chance for laravel? Nothing wrong with learning both it will put you in a stronger position for employment and arguable make you a better dev seeing the strengthens and weaknesses of both frameworks. If you will like it or if it will make you more productive is a difficult question to answer.
Been ages since I used GD, does anyone here know how it compares today to i.e php-imagick? From what I can remember GD had issues with blurring images when resizing and some color representation stuff when saving edited images etc.
Why pack what is essentially two applications into one project? Especially if the back end app is going to be a REST API anyways. Just create the Symfony app in one project, the Vue app in another. Then if for some reason you decide you want to use React for some reason instead then you don't have to mess with the Symfony app necessarily.
Such as? Can you be specific? 
Indeed, I guess it depends of the project. I talk about that in the "alternative" section :)
PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm PHPStorm 
Don't underestimate the power of exchage
By the way, I went with the first option and made PHP script that connects to SSH and its been working wonders for 6month+. Even wrote a "revert" script to list releases and revert to a specific one. Pros: 1. One file does everything, no require, no middle-man. 2. Everyone knows php, we develop php applications after all, so it's absolutely maintable 3. I can change anything, down to format to private key not found error messages 4. No new framework to learn, licence to worry or price to pay. 5. No "breaking" updates, everything works as intended, one-file-does-all 6. Learned more than using a "one-size-fits-all" tool. Cons: 1. Had to write my own command-line progress bar and logging system 2. PHP-SSH must be installed (apt install solves this easily) 4. If PHP version changes and SSH2 becomes deprecated, I'll have to fix it myself. Keep in mind we used Rocketeer for 4 months and still changed. Less is more when less solves the problem!
You definitely need to try Symfony 4, it just pure joy coding in it. This is coming from a dev that started from a custom framework that looked a lot like codeigniter, then codeigniter for a while, now symfony 4 (even though I tried both laravel and symfony a while back never got into them), now I love it... compared with Symfony 3, 4 is nothing a like... it resembles a RoR framework, but with doctrine and written in PHP, what's not to like.
r/12btw
That‚Äôs way more than it deserves.
Try it and then paste it to a text editor and see what you get...
Symfony junior i guess
That's one thing I like about PHP, it's that you can strengthen it quite a bit as you do more complex things and learn more.
Their old account, /u/SaltTub, was in fact banned. They're just a low effort troll
Oh yea, [I'm familiar with Saltub](https://i.imgur.com/0jf1xql.png) just forgot their name ^_^
Thank you, that's one error down!
r/iamverysmart
take your spam somewhere else
It's worth note that you shouldn't just escape your query here, you need to parameterize your query. This is a massively vulnerable script.
Have you ever tried not being a disgusting human being? Your comment history sickens me.
Indeed. If nothing else, sanitize all your inputs before using them to form a query. 
not "sanitize" but parameterize . do you copy?
Please use /r/phphelp. This is not a support forum.
Your spam is neither required nor desired
Right? If it's shilling it should at least be up front about it.
Well, if you look at history, there have been quite a few critics since the early days of Laravel. What's fantastic about Laravel is it's feature rich, simple to use and adopts a service oriented architecture. Service Providers, IOC Containers, Facades, etc. - these are the things that led to its growth / adoption. A lot of people believe Facades and some other patterns make Laravel slow, some say even that Laravel is not well designed. I, along with many others, believe the Laravel architecture is great! Extendible, easy to use and the possibilities are endless. Many critics used to come up with metrics on how Laravel is slower than other frameworks. I believe it to be rubbish. First of all, it's not a like to like comparison. Laravel has many more features out of the box and comparing that to bare bones frameworks is ridiculous. Take Ruby on Rails for example. A lot of the features are powered by gems / external packages. Laravel has a lot of the features out of the box. &amp;#x200B; Yes Facades and Service Providers may take a fraction of a microsecond longer but the ease of use and abstraction between what goes behind the scenes and what the user wants is totally worth it! Imagine how many days/weeks/months of development is saved. Also, Laravel doesn't tie you to anything. Dont want facades? Disable them. &amp;#x200B; Anyhow, what I'm trying to say is that Laravel's roadmap, the one that critics used to go beserk about years ago, has only progressed towards the same things the critics used to talk about. After so many years, it's now even more prominent on these architectural features. So, if you passed a couple years ago on Laravel thinking hey it's bad design, well it's gotten worse by your definition!
I'm a little late to the party but [Laragon](https://laragon.org/) is also really nice, simple, and free.
You're so sick you read comment histories.
That i do
That's an option, but I would like to just have it copy with the right quotes the first time.
There's several plugins that's named similarly but what they do is copy the file path, not for copying nested array paths.
Note: I am **not** the author of this test. Only reporting it.
Or you can just try out Swoole instead of ReactPHP/AMP... and already say goodbye to NodeJS now. https://www.techempower.com/benchmarks/#section=test&amp;runid=6feb4a73-1fca-4d1c-9cdc-cdd46df81a82 Those results are from the old 2.x version and Swoole is now at the 4.x version.
Excel / PDF generation libraries? Its something i run into plenty of times. For most projects its the only code where i need 3th party content for. And Excel generation under PHP can be very, very slow. So a C based library may be a good solution. Its less of a issue for normal web development, but when you deal with anything financial or payment, PDF generation is a default necessity. And Excel tends to be also extreme useful.
Something like Python's BeautifulSoup HTML parser would be great. 
If your PDF design isn't too complicated, you can try [FPDF](http://www.fpdf.org/). It's pretty simple to get started with - just extract and include fpdf.php. Their site has a list of [tutorials](http://www.fpdf.org/en/tutorial/index.php) and [scripts with sample PDF output](http://www.fpdf.org/en/script/index.php).
&gt; When I read "request -&gt; something happens -&gt; response" Well, you didn't read that from me.
Beat it into submission with HTMLPurifier, then use a regular DOM parser on it. (But seriously I agree with you. I'd also like a decent way to drive a headless browser).
[mpdf](https://mpdf.github.io) is very good
Sounds like a good opportunity to port it to PHP
KnpLabs/snappy is a nice wrapper around wkhtml2pdf &amp; wkhtml2image
Maatwebsite/Laravel-Excel is an awesome Excel/CSV lib for Laravel
SNMP was a pain last time I used it, not sure now though.
https://www.phptherightway.com/
The PHP ecosystem is not as insular as Node.js. Node is a new language and ecosystem so it hasn't deviated much yet. There are modular PHP projects, like [Symfony Components](https://symfony.com/components) that may be more what you want.
LINQ. There was a couple attempts but try don‚Äôt work well. I don‚Äôt think lambdas are very performing in PHP.
That is not at all the experience I had setting up a symfony 4 app last week. Follow the guide in the docs? Everything is "We recommend doing it -this way-, to do it -this way-, you need to install -this package- through composer". Got pretty old. I won't even get started in how hard it was to setup multiple database connections just to get functional tests working.
Yalinqo works well and to syntax is mostly comparable to LINQ.
Haven't tried it, but to get the database to work for tests I would create a doctrine.yaml file in tests folder, and would override doctrine:dbal:url with the test database url (dont even need to put it in an env file) IMHO this is what a framework should do, give me the tools to create my application. If I wanted a framework that needed me to code everything (that is not my application code), I would still be using CodeIgniter. File uploader (with amazon s3 support for production, uploads folder in public for localhost, and memory for tests, multiple adapters) just works, validation just works, assertions just work, serializers... the list goes on and on... Symfony is very solid...
Yes, you can use small libraries in PHP just as in Node - although you‚Äôll never find it taken to the same extreme as e.g. leftpad as a third-party component. Many frameworks throw a lot of those pieces in place for you, but there‚Äôs absolutely no requirement to use them. ‚ÄúBulk‚Äù isn‚Äôt nearly as big of an issue with PHP since it has no impact on client transfer times like it can with JS. 
I like all of my db settings to be passable through the `.env` file, so that any dev can say "no I want a different db than the one you're trying to provide me". Symfony4's test environment doesn't load up `.env`, you are expected to create a `phpunit.xml` and put all your env vars in there, and modifying 2 separate env files is ridiculous (to me). Take me as a Laravel fanboy if you want, but I can install Laravel and hit the ground running. Want to have a separate db connection for testing? Copy it in the config, change the setting in `phpunit.xml` and keep trucking. All of the things that "just work" that you listed also "just work" in Laravel. It's absolutely fantastic. To be fair, coming into a symfony project that's setup, that's fine. It's the initial setup that just annoyed the hell out of me. I help a lot of people and I suppose I'm spoiled by `composer create project laravel/laravel foo`, cd into it, open vim, and go. Can't do that with symfony (if you follow their recommendations).
Thanks, much appreciated, and oops.
have you tried [this](https://www.reddit.com/r/PHP/comments/96tyzk/library_tool_discovery_thread_20180813/e4ijd38/)? 
Use composer and browse packagist.org pick the components you want to use in your project.
No but that looks promising. I remember the native stuff couldn't even do v3 a couple years ago.
First, make sure exif is actually loaded by looking at \`php -i\` on the command line, or a \`phpinfo()\` in a web page
I've switched to using headless Chrome for rendering PDFs now.
Because that's not always the option that you have? 
It doesn't look like it, the only instance of "exif" in phpinfo() occurs in the authors section. Any ideas? Thanks for the quick response
Well there used to be no option to affect PHP version nor have ssh access to the server, but we don‚Äôt live in 1990s anymore. 
You might need a custom compiled PHP for your Apache version. I see that exif requires a compile time (PHP compile, not script compile) flag. That is out of the range of my practical experience, but I'm sure someone else will have a different opinion, and someone else will have a walk-through.
IMO the only typing that really helps is function parameters and function return types. Beyond that the utility of strong typing is 50/50 imo. Sometimes it helps, sometimes its just a massive pain in the ass. &amp;#x200B; So I think the way PHP is going is right on the money. 
I am guessing you are using the same windows server. Did you enabled the extension on your php.ini as stated here? https://secure.php.net/manual/en/exif.installation.php Note there is an order to it. Make sure the dll's are in place, you may need to copy from the previous install. And if it all fails make sure you edit the correct php.ini - phpinfo will tell you the full path of the configuration being loaded. I do not use PHP on windows since.. long time, so I do not remember if Apache reload is necessary, I would do it anyway.
https://www.phptherightway.com/
Mind telling why? :)
I'd like some SHA3, please!
For various reasons, PHP has loads of old tutorials and tips and things out there which are outdated or just-plain-wrong. 
r/lolphp
Try DiDOM. We've used it at work recently and it's been great.
What about laravel's collection class?
I haven‚Äôt looked at the site that you cared enough to mention in a few years, but when asked why you feel it is bad you just 100% skirted around the issue and said ‚Äúlook - over there!‚Äù. 
Much better - cheers
Pdflib is a terrible mess and outrageously expensive but it does everything you need for PDFs once you read their site and docs that look like they‚Äôre from 2002.
You seems to misunderstood the question Besides, you are heavily confusing the term query cache, which makes your musings on the matter quite amusing but incorrect. To avoid further confusion, next time try to talk of the things you have the practical experience with, and refrain from repeating some pointless bullshit you've heard from someone. 
Proper collections that include a Map which supports any key type.
I use SimpleHTMLDom works great, sometimes you have to edit the file limit, and I also sometimes kill the script when the page is like 6MB haha
LibPHPExcel works well can produce .xlsx no prob
&gt; wkhtmltopdf Yeah I just convert from HTML whenever possible. I still have some PTSD from trying to actually generate PDFs directly.
I would propose my own resource, which, beside containing a few tutorials, deals with [various delusions](https://phpdelusions.net/top) deeply rooted in the minds of average PHP folks 
To elaborate. A query cache deals with the query results, not query plans. And the latter is bound to a prepared statement, so you can tell that there is a *very* little chance to reuse it in a regular PHP script.
wow. Anyway you can open-source it? Also another question, do we need passwordless (trusted auth source) from deploying server to all app servers? (if so, is it from root user?) I understand reverting it to old versions, how did you achieve this ( *I can change anything, down to print format to the error message for private key not found.*)
BrowserKit does not, as far as I know, render Javascript. My specific need is to drive (ok, scrape) a web app that does all its rendering in JS.
Look for "awesome php" on Github and choose whatever component is necessary. You don't have to use a full blown framework.
- mature and featureful tooling for Machine Learning (see python) - more parser (generator, PEG, etc.) libraries (see Java or NodeJS) - better ways running co-routines or asynchronous tasks. There are some solutions but nothing compared to what you can do with Go or Erlang / Elixir. I don't want special redis/pgsql libs, I just want to use the regular stuff and be able to await async IO (NodeJS) 
Hi see\_Darkness If you are beginner in PHP. Please visit below mentioned links:- 1.) r/https://www.w3schools.com/php/ 2.) www.php.net/ Here, you can learn basics of PHP. For example:- Which statement is used for display output and looping etc. According to my experience , you should follow some steps to learn basics of CORE php after that you can move on for PHP Framewoks(Laravel etc.) and CMS(Wordpress). some points listed below:- 1.) Install PHP on your local machine. 2.) Try some short examples with desired output. For example:- CURD Operations, Registration and login and how to upload a file. 3.) Fetch data from database using Mysql queries. 4.) Checkout array functions, String functions.
&gt; SHA3 https://github.com/0xbb/php-sha3
We're using [graphics magick](http://www.graphicsmagick.org) which is a imagick fork so you can use all the same options. Its faster than GD and gives smaller filesizes. 
It‚Äôs good overall but I‚Äôve had it fall on its face a few times when it comes to more advanced formatting. 
Does http://php.net/manual/en/book.openssl.php not fill this need?
But it will on server response time if your framework really load irelevant parts. Like trying to enable a MySQL connection at bootstrap, or trying to boot a controller system before any controller have been called.
I‚Äôd like to see real Enum support, without faking it using a class with magic methods and a bunch of constants.
Not really a library, but one thing I always missed in PHP were generic types.
I actually had some text saying how I **hate** exactly that magic stuff about Laravel, but decided to remove it because I didn't feel it added much. But yes, I consider the magic stuff in Laravel (Symfony doesn't have a lot of "magic" of this type as far as I'm aware) to be a bad practice. It is one of the reasons why I don't like using Laravel - everything is magic, making everything difficult to understand.
The last one doesn't sound like a library.
Not really what you would probably want but try [phan](https://github.com/phan/phan/wiki/Generic-Types)!
Thinking about it, BeautifulSoup is about 360k including tests. A port might be feasible.
BeautifulSoup uses Python's HTMLParser library and supports alternative parsers as well which a PHP alternative would probably also have to do to keep such a project relatively small. What I personally like about BeautifulSoup is how one can navigate through the elements of an HTML doc, they have super useful search and filter helpers and I found that I can code a scraper far quicker with it than some of the other available options out there. I don't personally ever use it to modify HTML content so I'm not sure how other parsers compare with BeautifulSoup in that regard.
Maybe you already know this but regarding async tasks, I've recently completed a project using [ReactPHP's](https://reactphp.org/) event loops to develop a TCP/UDP socket server, it has Javascript style Promises, a ChildProcess utility component, etc. I used most of what it offered together with PHP's POSIX pcntl_* functions and so far it has been working pretty great. The project is a TCP/UPD server on one end and talks to RabbitMQ on the other end.
Hmmmmmm. You may have just unblocked one of my low-priority projects. Thanks.
Since learning to use CSS Selectors properly I've found I've not got much use for BeautifulSoup - they're more compact, and probably easier to read than BS's method chaining approach. I guess if I ever need to parse tag soup I'll break it out again.
After 2+ years of active development and running on production environments, I'm proud to show your v1 of the library. With the help of some awesome folks we've managed to create the best library (in my opinion) to parse and manipulate HTML5 documents in PHP. Get it free at [https://github.com/ivopetkov/html5-dom-document-php/](https://github.com/ivopetkov/html5-dom-document-php/)
phpseclib?
We were relying on DomDocument but after getting an error on a valid &lt;svg&gt; tag, we decided to switch to a better solution. &amp;#x200B; We're using your code now. Good job!
I know Alle.bg because they offer free web shop system or something like personal craigslist on your own domain full of used overpriced shits from shady businesses &amp;#x200B; nothing wrong on lib tho
For fast excel manipulation: https://github.com/box/spout
Does this library support partial HTML documents (aka snippets)? Seems almost every DOM manipulation/parsing library freaks out if there is no \`&lt;html&gt; \` &amp; \`&lt;body&gt;\` tags, and will ad them if they are missing.
Any chance it's failing to do opcache things, or failing to connect to some sort of memcached?
[https://clojure.org/guides/spec](https://clojure.org/guides/spec)
Yes, but nothing in the logs that indicates this was an issue, no connection errors etc... The servers do some start up tasks like a git pull when they are spawned, I've noticed sometimes I get a NGINX PHP-FPM proxy error not found if I launch a test instance and try to access it quickly, but the servers have a warm up time of 2 minutes after spawning 
Love it! I think it's the most flexible stack. Why is this not the norm? With the php 7.2 breaking outdated projects and 5.6, 7.0-1 not working with 7.2 many devs need a stack just like this to have the flexibility to work with all, as well as mysql updates. Nonetheless will continue moving development of the application to project assist side instead of integrating with dev stacks.
&gt; go to github &gt; a recursive children merge is called "insert" Yeah, no
Not to mention that generally because of autoloading, only things which are needed are loaded. unlike with node apps where you have to compile everything you use out of node_modules and send it to the client for them to run.
AWS API gateway is an incredible tool for building adapter layers. Build the backwards compatible version out in the gateway and adapt it to work with the new one in your live system (or vice versa)
Autoload is resolved at runtime. I've always meant to do some comparisons with hard-coding all the includes and an opcode cache. My suspicion is that autoload isn't as fast.
I really just want arrow functions. 
I cannot open-source it, i'm afraid, but unless your deploying magento applications it wouldn't be very useful since the framework configuration (folder structure) is embeded in the deploy logic. For example, the "media/catalog" folder is separated and shared for all releases so that product images aren't on git, but others images like favicon are. About passwords, unless you plan on typing the password each time you deploy, you need passwordless auth, we use ssh public and private key encryption. Our server holds a copy of the public ssh key of each developer computer (including, for instance, a public key of the developer personal notebook), so that the deploy is just a "one-command-deploy" solution. If you need to know how we revert to previous versions: we connect to ssh, list releases (they are folders, after all), print to the developer and use a command-line logic of "Type the number of the release you want to revert", then we get the selected folder name and connect to ssh again, redirecting public_html to the chosen release. If you're wondering how to change print format, well, if your ssh2_connect function fails, you have to literally check that and echo out something like "ssh2 connection has failed, email sysadmin@buggyserver.com for help".
Man at the end of the day its php guys. With that being said I laravel is good for simple crud apps once you start needing heavy business logic it can get messy even when using doctrine as an orm. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You can't put C#'s LINQ DSL into PHP, so even if you manage to recreate the functional part of LINQ in PHP, it would miss the point of LINQ entirely. You could use annotations I guess, but it's a ugly hack.
just use Go frankly if you need concurrency or Node.js. Every solution I tried like ReactPHP was a complete disaster, because the echosystem is not coded with asynchronicity in mind. Same problem with Ruby and Python by the way. Most codebases aren't thread safe. 
Looking at everything that‚Äôs involved in this, it‚Äôs far easier to use git hooks. You don‚Äôt need the whole ‚Äúlog in to your server, pull git repo, run build‚Äù etc etc. You just push to the git remote from your computer with one command.
You might want proper closures before that, which PHP still don't have (yes I know use() ).
I still have to use SFTP for deployment so I personnally resorted to git-ftp which works quite well with post-commit hooks. I didn't want to use this or that python/ruby DSL for automation.
And he is right. MVC is very much a GUI desktop pattern. Although you could argue that webforms and their equivalent in Java tried to actually implement MVC between the server and the client by shoving the entire GUI state into sessions. Asp.net MVC is not MVC at all either.
care to explain why?
True. I hate using use(). 
Is it possible a load balancer is routing more traffic to the higher load servers?
Try posting here: [https://www.reddit.com/r/PHPhelp/](https://www.reddit.com/r/PHPhelp/)
It could be you are seeing the effects of noisy neighbors. To test your cloud provider, have a look at stone research Rasmus Lerdorf did: https://lerdorf.com/archives/61-Testing-VPS-solutions.html
We had a similar thing happen in our environment. In our case, the culprit was sticky sessions. Basically, when you hit the load balancer for the first time, you're assigned a server. That server remains yours for every subsequent interaction. The problem, then, is that not all traffic is created equally. Some people have auto-refresh plugins with low refresh times. Some people scrape website pages. Some people use more cpu intensive functions of the site. Basically, the sticky sessions meant that the effect of bad actors was localized to one server instead of being evenly distributed. Not sure if this is your problem, buf it sure sounds like it. Check your ELB settings.
The current RFC for arrow functions will do away with `use()`.
Dear God yes. Id attempt to write something like it but I have other projects. 
Thanks for the reply. I think I especially needed to hear the bit about the marathon.
Why not use the official docker images as a base instead of alpine and manually installing?
How sure are you they are 100% identical? Cloud providers allocate certain hardware but they are always adding new stuff. You could with the specs as a description, get a slice of a very vast system, e.g. In I/O speed. A second system on the older spec could with the same numbers, be slower. Low I/P could give you high load (remember that 'load' is not the same as cpu usage, you could be busy waiting). I would do some benchmarking on at least I/P to see if they are actually the same. Some company (I forget which, Netflix maybe?) was doing this by definition : spin up a new vm, test the speed and if it wasn't the best, drop it and start another. 
&gt;Does this library support partial HTML documents (aka snippets)? Seems almost every DOM manipulation/parsing library freaks out if there is no \`&lt;html&gt; \` &amp; \`&lt;body&gt;\` tags, and will ad them if they are missing. Yep, using the LIBXML\_HTML\_NOIMPLIED option in loadHTML(). You can also find useful the LIBXML\_HTML\_NODEFDTD option.
xD
&gt;a recursive children merge is called "insert" Here are some features I think you'll like: 1. Query selectors. Example: `$dom-&gt;querySelector('h1')-&gt;innerHTML` 2. Inserting html fragments into the current document. Example: $dom-&gt;insertHTML('&lt;head&gt;...&lt;/head&gt;&lt;body&gt;..&lt;/body&gt;'). Haven't done performance comparisons with other libraries. I my experience working with the DOMDocument (my library extends this native class) can vary a lot depending on the HTML code used.
In addition [pdftk](https://www.pdflabs.com/tools/pdftk-server/) with a simple wrapper for PHP like [php-pdftk](https://github.com/mikehaertl/php-pdftk) can be useful for combining/splitting PDF files and other stuff. [TCPDF](https://tcpdf.org/) and [dompdf](https://github.com/dompdf/dompdf) may also be *somewhat* viable options, though I personally prefer wkhtmltopdf with [phpwkhtmltopdf](https://github.com/mikehaertl/phpwkhtmltopdf).
Are you running New Relic or something similar? Rule out issues at the application level. Perhaps there's some poorly performing endpoints, which aren't hit very often, that make the server `sick` when accessed.
It always amuses me that they remove methods and break signatures in minor versions.
A framework by definition abstracts the logic, that is common. What is defined as logic however is left to the developers.
So basically we get to do your homework?
Observer pattern. 
Just because it's OOP doesn't mean it's good OOP. I joined a new company, and the senior guy insisted we just make one massive object, that hits every table we have every time you populate it to get all properties of the object, whether you need them for what you're working with or not (and people keep wondering why it's slow -\_- ). It's hard to say if it's necessary or not, without knowing the product, nor do I recommend you post the code anywhere to look at (your company would probably be pretty pissed at posting even the most mundane code in my experience because it's their property). A lot of programming tends to break away from academics in reality. It's the constant trade off of the business world of "this should be broken out this way for future proofing" vs you know there's a 95% chance it will never change, and the deadline is next week. My suggestion to you, since you're new, would not to be adversarial about it. Ask questions, try and "understand" it. If it turns out you're wrong, and it is abstracted how much it needs to be, you're just having a hard time understanding it, you look like the diligent employee trying to learn the product. If it turns out it is pretty fucked up one of two things will happen. it will get noticed as you ask questions, or, they're complacent with it, but it should become obvious at this point, and as you understand it, you should be able to think of ways to start improving it little by little.
Laravel doesn't use semver. Boy, don't you look stupid, heh.
Hey, I routinely find myself in a boom and bust cycle, where I push too hard to learn and exhaust myself, then stop and take a few months to just breathe and live before eventually getting restless and cracking open more books. It helps to recognize it and just relax.
It is as fast, because opcache caches in shared memory the included files and their opcode, meaning the execution time is literally the same. 
I am making [this](https://github.com/Talesoft/tale-collection) right now, it also contains a Map class that takes any key type, similar to JavaScript's. It's not finished yet though, tell me what you think! If you like you can contribute, I will finish it soon as I need it for some projects.
" I found that it was 300+ lines long. " It depends. The motto says that you must separate a function into it's atomic limit. However, there are so many people that split and fision the atom and creates dozen of wrappers that does nothing. &amp;#x200B;
LINQ is entirely different to Laravel's collection class. [Have a look](https://en.wikipedia.org/wiki/Language_Integrated_Query#Architecture_of_LINQ_in_the_.NET_Framework), it's pretty cool.
"Never Settle"(\*) (\*) Unless you are playing Civilization. &amp;#x200B; &amp;#x200B;
Yes, you could ask for colaboration on github by randomly pm people or opening a issue report. &amp;#x200B;
That's a good point. It would be good if you can denote source only, no bs. Looks like --prefer-dist might do this
I've never seen that before &gt; 1. HUMAN version when you make any conceptual change, major rewrite, major documentation changes or any other change which requires additional HUMAN involvement. &gt; 2. MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, or fix with backwards-compatible bug fixes. &gt; 3. MINOR version when you add functionality in a backwards-compatible manner, or fix with backwards-compatible bug fixes. Huh... first level is touted as needing a human. Which implies the other levels don't. But then the seconds level includes breaking API changes. I'm pretty sure breaking API changes are going to need some human involvement, often times a lot. After all, it's not called *breaking* for nothing. Can't say I'm a fan, but to each his own, pick a methodology and stick with it 
Which image do you refer to? We mostly do exactly that when it‚Äôs possible
Like half of your images. nginx, apache, mariadb, postgres, solr, redis, nodejs, elasticsearch, php, and adminer are some that I know have official images available to use or extend.
Can you go over the benefits of your library? In what respects is it best? Ease of use? Performance? Robustness? Features?
Nginx compiled from source because we add additional modules like uploadprogress and mod pagespeed, you can‚Äôt just plug it in, nginx is monolithic. There‚Äôs no Alpine-based MariaDB in docker library. Elastic doesn‚Äôt have Alpine-based version of Elasticsearch, they refer this to a bug in musl that was fixed a while ago by Alpine Linux team (all our images are based on Alpine). There‚Äôs no official adminer image (at least there wasn‚Äôt when we checked). As for the rest if you‚Äôll look closer you‚Äôll see that they are actually based on the official images or on their forks that automatically updated from upstream.
The answer to your question is to come up with a plan to refactor this function that would produce demonstrably better code. Then ask if that work is worth the time, or would it be better spent elsewhere. I assume you can work on a local copy. If so, actually attempt to refactor it. You will quickly get insight into the code. Have you asked anyone about their thoughts about this function? You may discover that there are good reasons for why the code is as it is, and get information on how they got there. Plus you may discover that others have similar thoughts about the code (and even a plan). Ultimately it does not matter what you suspect or if you are worried. The goal is to improve code, not point out bad code. Refactoring is how code is improved. Either come up with a plan with a clear goal for the code, or actually refactor it. You need to demonstrate that there is a better code design and a refactoring plan to get there. 
Everything else aside, what is wrong with a method returning a boolean? Am I living under a rock?
&gt;In what respects is it best? Ease of use? Performance? Robustness? Features? Here are some of the benefits as listed on [https://github.com/ivopetkov/html5-dom-document-php](https://github.com/ivopetkov/html5-dom-document-php) * Preserves html entities (DOMDocument does not) * Preserves void tags (DOMDocument does not) * Allows inserting HTML code that moves the correct parts to their proper places (head elements are inserted in the head, body elements in the body) * Allows querying the DOM with CSS selectors (currently available: \*, tagname, tagname#id, #id, tagname.classname, .classname, tagname\[attribute-selector\] and \[attribute-selector\]) * Adds support for element-&gt;classList. * Adds support for element-&gt;innerHTML. * Adds support for element-&gt;outerHTML.
This is great advice.
Good point. I may have been overreacting about the !empty portion of my question a bit.
I too am curious about the boolean thing.
No. No sane person encourages such practices. A method should do only one thing and nothing else. I assume that there is no test written for that function, right? Or even worse.. i assume that there are no tests in general.
Sorry, that didn't make sense. Can you explain again?
I feel your pain. I saw a project similar to yours; code looks like the guy tried to make it bad. In short; no method must be that long, ever! It doesn't matter what it returns, bool, object or string, such code is made by beginners. You can try to split into multiple small methods if it is even possible to figure it. The other problem; never use if-else. Use "early exit strategy", make code many times more readable and flexible. You can find plenty of articles about it online, I think KNPUniversity videos also have it explained.
If I see it correctly you have implemented some form of CSS selector parser yourself, right? Do you know about [https://symfony.com/doc/current/components/css\_selector.html](https://symfony.com/doc/current/components/css_selector.html) which simply converts css selectors to xpath statements? Might be worth having this as a dependency instead of re-implementing it.
So here's what jumped out at me: &gt; The thing that jumped out to me was a method call that returned a boolean, fine &gt; that perform multiple side effects and then return a boolean If the purpose of the method is literally to query the domain for its state (e.g. `isSomethingWhatever()`), *and* it has side effects like you describe, that is obviously dog shit by any reasonable software design standard. However, if it is a *command* to the domain and it just happens to return a boolean indicating success or failure, that's not quite as bad. Maybe you could clarify more about the purpose of this method? Regarding the actual implementation, procedural spaghetti encapsulated behind a method is obviously not ideal, but the real litmus test is how good the automated test coverage against it is. Given the complexity, it sounds like it should have a mix of unit tests that isolate its dependencies, AND functional/integration tests that ensure it works as a black box without mocking. And due to the described cyclomatic complexity, it should have a substantial number of edge-cases accounted for in those tests. If it's spaghetti without adequate test coverage, then that isn't code smell, it's technical debt.
This is great advice. I would like to add that one of the goals should be to add or improve automated test coverage against the code as well. Refactoring without automated tests to back it up is only half the battle.
This one time, I was working on a 1600+ line file. The capstone of this opus was method with a foreach inside a foreach with a HTTP get with another foreach in a callback. No comments.
One more proof if needed that picking one of the best PHP Framework doesn't prevent building the worst PHP code. &amp;#x200B; I bet if you run a few quality tools like phpstan or PSR2 checks, it will burn with 10.000+ errors on this project. &amp;#x200B; A few months ago xD lol
Before adding CSS selectors support to the library I used XPath. I was surprised to find that XPath was much slower in some cases than getElementsByTagName(), getElementById() and iterating over all the elements. That's why I spend a lot of time optimizing for the different selectors. Not all are currently supported but the most popular are.
You have a door!
Currently out of the PHP world professionally but like the look of this. What use cases does it fill? You say you're currently using it in production on another comment, what are you actually doing with it? Would it be used for web scraping?
It looks pretty good! I've been working on a PoC map implementation that should speed up operations by means of a hashing function that can produce a hash for any value. Maybe that's worth trying :)
The main use cases for me and my projects are: 1. Find and extract content from an HTML code. 2. Modify HTML code (add fragments, update innerHTML, etc). I'm working on a hosted CMS platform and the library helps us build the HTML output for our client's websites. 
That function effectively does absolutely nothing. I can only imagine it used to do something else and was left in out of laziness for backwards compatibility.
I also agree it's probably for backwards compatibility. If there's a git repo you can probably find the old code that it had.
My map implementation works differently, it actually contains two arrays, keys and values, and it syncs the keys where it's needed. There's spl_object_hash(), but it doesn't work on arrays. in_array and array_search work with arrays, as expected. I'd love to do some benchmarks later and compare the solutions, I thought about implementing it with hashes a lot and I'm still playing with the thought.
Yes that makes sense. Thank you for your reply @irythros
I've found with age -- the more something runs - the more something can break (sql service, switches, localhost network stacks) so even if you code for auto-reconnect/etc there will be a fault someday in the most peculiar ways!
Maybe it has something to do with that return values are returned as value and not as a reference to that variable? Don‚Äôt know though. 
It's used somewhere else in the code, so I am not sure. 
Maybe there is an interface that requires this function?
CPU credits depleted?
Its purpose is to slow down the application.
Considering the variable is called $dateRange I'm guessing you're right.
or to fulfill an interface
Vibrant Info is one of the best PHP website development company in Bangalore. Provides all kinds of web solutions like eCommerce development, Mean stack, AngularJS, Mobile apps, IOS apps, wordpress, website maintenance and project management. For more details please visit: [https://www.vibrant-info.com/](https://www.vibrant-info.com/)
If you want to advertise on reddit, you should [purchase an ad slot](https://www.redditinc.com/advertising). Self promotion in posts is frowned upon and not welcome here.
Assuming this is a screenshot of PhpStorm I have no idea, otherwise it might be that this method does something different in different classes, and this particular implementation might make sense for this particular class. I'm mentioning PhpStorm because I don't see any override icons in the margin.
My first thought as well
Variables are passed as value by default.
The screenshot is from VS CODE. 
Sorry, I fell asleep while writing this function and never realized it was incomplete.
Pointless function.
The thing is that we just switched to a new load balancer and we initially forgot to enable sticky sessions, we did have that before, but the problem was still there before we enabled it again. However, we enabled it again so that's definitely something I'll try out, thanks! 
PHP-FPM has the same requests per second metric across all servers, to make it even stranger 
We definitely are not. We are just getting the same instance type from AWS each time. Benchmarking is a good thought, I'll try that! 
Ah, well in that case (not being familiar with VS Code) the above might be it. I got downvoted so I must not be contributing to the discussion but I don't see why.
That's some next level code right there.
Looks like someone was being paid per lines of code.
Is it in version control of any kind? Can you view its history?
Yeah, I've Ben around enought to see this kind of shit in php , Java, javascript and c# ... It's not the language , it people
Yes. 
My guess would be that $params used to be wrapped in a function. I would guess to sanatise an input/output from the database
&gt; Can't say I'm a fan The alternative would mean that Laravel would be on version minimum 13+. Semver can be weird too.
Lets be clear, that's not a valid reason to write this abomination
TDD / BDD? The person wrote their test and then needed to write the lowest-effort version of code that would pass the test. Before they made the rest of the tests, and functionality, they died, leaving you to figure out this silliness.
Did its history show ur having more code
Not necessarily, PHP 7.2 compiler should inline this IIRC.
not really! this function was not changed since it was created. Also it is used twice in the whole app. It all makes no sense.
the variable naming also is weird af.
Even if it was indeed slowing the app. Slowing it how much? 1 nanosecond? It's ignorable either way
In php 7.2, that code doesn't even run. Hallelujah. 
A function that returns its parameter(s) unchanged is called an identity function. Given the name, it probably was intended to do some process on the query parameters and that was never implemented.
I‚Äôm sorry that the majority of comments here are not helpful at all. 
&gt; A framework by definition abstracts the logic no, it doesn't. a framework handles boilerplate stuff for you (db connections, mvc implementations, container implementations, configuration management). it should not at all interfere with how you implement your business logic at all. It has nothing to do with abstraction of logic. And it surely does not do so "by definition". the function OP describes is not the result of working with a framework.
? 
Ok, I understand, those sound like optimizations worth doing. Still supporting a broader spectrum of CSS selectors by falling back to that symfony component might be useful to those people struggling with XPath (quite a few, in my experience :-) )
/api/v1/ /api/vforcoolpeople/
The only time I have written a function like that is to create an easy way to format values. instead of writting $this-&gt;value; if later it needs to be formatted to be different I have to look for instances of that variable on all the files and change them to $this-&gt;newFormatValue; Using a function like this is a good way to say $this-&gt;getValue(); that way if value needs to be formatted it needs to be changed in one place. Hope that makes sense.
Don't know when's the last time you looked at PHP framework, but they're causing a flood of uneducated developers who know the framework and not the language, you can attribute that to whatever you want, but I attribute to framework enhancing laziness and promoting disregard of education.
You refer to getters and setters but this function returns the input parameter which is something else 
frameworks do not abstract logic, they give you a place to put **your** logic in, to write **your** businesslogic in, without having to worry about ubiquitous things like configuration, logging and linking and managing dependencies. And that's another discussion than "frameworks make developers lazy". Which is another discussion than "ne developers dont know the language, they know the framework". frameworks allow you to do spend more time **writing your logic** instead of spending time linking everything together and doing tedious, repetitive tasks.
oh I thought you mean there is error or something 
I have never heard of that. I make methods all the time named something like isEntityUsable() which has a couple of conditions that must all evaluate to true for instance.
Not Necessarily a getter, Here is an example of how I used it on a project from a couple of months ago. //somewhere in the code echo $this-&gt;formatLocation($loc); // somewhere else in the object protected function formatLocation($location) { $newLocation = preg_replace("/\[.*\]/", "",$location); return trim($newLocation); }
Perhaps if you can debug with xdebug, you can see which steps the program does, and based on that, add some extra comments for future reading.
What's with returning `false` instead of throwing exceptions?
[https://www.slimframework.com/](https://www.slimframework.com/) &amp;#x200B; [https://lumen.laravel.com/](https://lumen.laravel.com/)
Slim is a great recommendation but I think Lumen is API-only therefore would ship [without views, sessions, etc](https://stackoverflow.com/questions/29647960/differences-and-similarities-between-lumen-and-laravel#answer-29648574).
Same goes for slim, they're the same sort of thing. You can bolt on top of them whatever you need tho but why bother having Laravel and Symfony. Either comes with all the bits and pieces the OP's likely gonna need. I always lean towards Symfony personally, I find it a lot easier to write code that's completely separated from the framework with it, and crucially framework upgrades over time are 100% painless.
Slim does not have a templating system, so I suggest adding: http://platesphp.com/
How is that a problem? It‚Äôs PSR based middleware. It doesn‚Äôt limit you from doing anything. 
PHP by itself is an ugly and terrible templating language, its much better to use a template engine like Smarty, Twig and Blade. 
[Yii](https://www.yiiframework.com/doc/guide/2.0/en) has a really nice [CRUD generator](https://www.yiiframework.com/doc/guide/2.0/en/start-gii#generating-crud). I wouldn't necessarily call it a "small" framework, but easy enough to learn. 
Whatever you do, plan on this codebase growing. You"ll likely experience feature creep over the course of its lifetime
If the hairiest function in the codebase is only 300 lines, consider yourself lucky. 
9 years old articles .... And he proposed plates, not hand crafted php stuff. &amp;#x200B; While I'll (almost) always use a templating language myself, plates is a reasonable middleground to me, for someone with a backend mind. &amp;#x200B; And please, smarty is a dinosaur at this point, no reason to use it instead of twig.
&gt;\--prefer-dist I'm working on it.
Functions that have lots of if/else and other responsibilities is a bad sign... In my experience it usually means a code monkey (at any seniority level) wrote it. These aren't people who know how to write well written code... There are people who hack MVPs together and don't GAF or know any better. What should be done is loose coupling and high cohesion... This is probably the most important thing to learn from a software design course. Make functions that have a single use. Don't add multiple bools to create different affects, add enums. Don't let you function set a bunch of globals etc. Try to write code that you can read and follow. Like a recipe: 1) add ingredients (get data from db), 2) warm pasta in hot water (massage model 1), 3) heat sauce in microwave (massage model 2), 4) put food on plate (encode your data for use). These can all be broken down into steps, it makes it testable, and it makes it so much easier to change behavior or make new behaviors. Ever try adding a new behavior to a method that does a million things? Moral of the story is, do not respect seniors who do shitty work. If there is a time crunch they should know better to do things clean and simple, not slap shit together. Thats the sign of someone with limited mental capacity IMO. Those people shouldn't be paid more or called seniors if they are making lies. My company is in a similar spot where a ton of code in mangled together. We could be better off if we just kept things organized. When creating new code, physics entropy doesn't really apply, the develop is the entropy... Space rays aren't coming down and reprogramming your work.. When you write well and write it once it never has to change all that much. I've rarely had to refactor my own large contributions (proud sure)... I mostly have to work with other legacy code thats a cluster fuck... And it's not as fun.
This only good for massive BC breaks, like separate product. It's not suitable for incremental changes in API.
"It's the constant trade off of the business world of "this should be broken out this way for future proofing" vs you know there's a 95% chance it will never change, and the deadline is next week." If you need to write some code that probably isn't going to change 95% of the time, you really should consider where that code is going to live for the rest of it's life. If you are building a foundation for a house and the deadlines next week it's probably pretty important to get that right the very first time either way. If you are a small startup and you're creating a data layer to a database, it probably makes sense to analyze what the current state of technology is today and how it might be used in the future. Otherwise if you just say fuck it, it won't change 95% of the time, I'll just write this design idiom I thought of in 10 minutes... You probably can't easily change the old way to a newer and better way in the future. I think whats lacking is the "think about the implications step". Sure lots of companies need something now, but business people have no idea what it really means to the project if you don't think before you act. If you just do it you might literally hide away a multi million or thousand dollar rework project, only to sneak up on the company in 2-3 years. Like oh fuck I guess we should have though about it instead of just do it.. Now we're slow, can't compete, and nobody wants to invest to clean this mess up..
Each to their own. I like Plates. Your links are worth a read, but I read them in 2009. I guess a trip down Memory Lane isn't so bad... `;-)` 
He must be thinking about an Interface ;-)
+1 for plates, though it‚Äôs rare that I ever need it at all since almost all of my code spits out JSON. I absolutely hate using templating languages in PHP - it‚Äôs just extra complexity and I‚Äôve yet to find a benefit. 
There are two things to consider in autoloading: 1/ the autoloader itself (ie the include when a class is not found) 2/ the resolving of the appropriate file to include at autoload The first bit is basically one more function call than a classical include, which I think we can ignore in terms of performance. The second one could be the issue: transforming a class name into the appropriate file to include it can involve a bit of logic that would be slow. The best example of that is Composer, which relies on a set of packages definitions to find the file. However, since PHP 5.6, something helps dramatically: opcache internal strings and arrays. These internal elements are bits of data stored in shared memory and reused between workers and requests. What's great is that Composer uses this shared memory, meaning that the association between classes and files is only an array lookup away. In my opinion, this can also be ignored. Read more at https://blog.blackfire.io/speeding-up-autoloading-on-php-5-6-7-0-for-everyone.html
I see it mostly as a joke, and not suitable for everyone for the reasons you mentioned
Oh yes, APIs don't need it. Save it for outputting HTML where there are templates, partials, components, inherited fragments... `:-)` 
Symfony4 is a good idea! You could use the SonataAdminBundle to have a backend where the people can fill and edit content. It just needs some basic configuration 
In that case, just go with what you know. If you've not used any framework so far - any will do, so pick one you're looking forward to learn.
I only skim-read the article, but his critisms seem to be: * Ugly syntax * Can't use short tags * Unescaped by default The first is subjective, the second is no longer true, and the third is valid. I'd probably use plain PHP for templating in a small project.
Managing tons of separate api versions is also not a perfect way. Better to have one coedebase and different facades, than having 10+ active versions of API (I mean 1 version is a totally new codebase or different git branch). Because managing so many apis become problem when you find a bug in all of them so instead of fixing one place you should fix all supported versions. " Should define your real requirements better. " - This works for public APIs, unfortunately for internal APIs everything not so clean and requirements can change very frequently, especially on the early stages when your system is growing actively. 
Everyone has different needs is the thing to realize (nothing specific to public or internal apis at all). And also it's not that easy to switch off an API when people are depending on it... So to accommodate those needs give consumers of you API the tools to do what they need is the goal, not creating solutions for everything anyone wants (facades). You should focus on making the right set of tools for people to do what they need to do. A proxy server just creates a layer between the consuming apps and the source of data or servers. The proxy server can point you to a new server with the latest or different codebase, but the apps would have no idea... They'd still call getUserInfoWithId(1) and the data would get to them etc. That request could be fulfilled in many different ways from the servers perspective. This is how many companies scale their internal and public apis. They don't use facades to do this... If they did for every unique request they'd have hundred of REST endpoints for different types of similar work. It'd be a nightmare. Let people get their data/run whatever and tell them to put the pieces together to get what they ultimately want is my belief. For example if I was building an internal inventory system API, I wouldn't waste my time creating elegant endpoints for everyone who had an ask. Id say hey here is an endpoint to get all the items in our warehouse and here is a way to filter that list down in the request. I wouldn't make an endpoint that was like getAllTheSundaySchoolClothes(). IMO thats a waste of my time. The developer on the other end should be able to leverage your tools to get his stupid Sunday clothes... Not the other way around.
this is basically slim as well... 
Are you sure you're not running single threaded tasks that take up a lot of CPU power? I don't think those kind of tasks are going to scale over multiple servers unless you program them that way. Also you may want to look into resource blocking, something could be spin locking until it gets what it needs (oops I need something wait cpu drops to 30%, then ah I got it boing 100%). Also by any chance are your servers using 1 core or vCore or multiple core/vCores? That could be gimping your requests and tasks etc.
I think migrations, while nice to have, need not be baked into a framework. There are third-party packages you can use - I use Phinx on a Zend 1 legacy project I maintain and it's perfectly decent. However, it might be prudent to perhaps put something in the documentation making it explicitly clear that users who want to use migrations should look at third-party solutions, and maybe link to a few, just so users know they have options.
Right your request damein might be showing you the same requests per second, but that doesn't mean the LB is working right. Just because you are load balancing doesn't mean you are going to get a %50 %50 split, lots of LB configs just look to maximize resource use. For example thats how AWSs container service commonly load balances... Fill up the buckets one at a time vs evenly for all of them. Idk how else I can't help you look into this... good luck :)
 It's a lie!! Truth Can Be seen here https://goo.gl/kAV5eK
I am still using [CodeIgniter](https://www.codeigniter.com/) for most of my projects... it is bare bones and easy super easy to get into but with enough flexibility to form it into nearly anything you can imagine. 
I think production ready really just means how many people are successful in using in a production environment, and I believe if you look at how many contributors &amp; the timeline of how much code committed during certain periods, you will realize that many organizations are already probably using it for production purposes.
The idea is not about creating an elegant endpoints to evryone. The idea is if you have getAllTheSundaySchoolClothes() that returns list of SchoolCloses with fields Id, Type, Color. And all clieants are waiting for this. But sydenly you want to add on new field Style, for example. So idea that tis add should not break a work of allyour clients. Because if you have field in model Cloor ad want to rename it to Color - you will break yur clients. So here you've changed your API without adding new endpoint and your old clients are working fine 
I hear that a lot, but it doesn't help with a) existing code base / business logic and b) unfamiliarity with the language. I'm not saying it has to be strictly PHP and we are indeed using NodeJS for selected parts but TBH while I love Typescript: all the magic going on under the hood, I would despite all its flaws choose PHP any time ATM.
Instead spend the money on a laracasts subscription: PHP Fundamentals: https://laracasts.com/series/php-for-beginners PHP OOP: https://laracasts.com/series/object-oriented-bootcamp-in-php Laravel: https://laracasts.com/series/laravel-from-scratch-2017
This!
Well that's in person and I think learning like that is much better maybe I can launch a freelancing career after that
So, you clients should be fault tolerant. If there is a new field this shouldn't break your clients... They should effectively ignore the new field... If you want to change the name of a field, the client haves to update anyways if they are using the same version of the API (no way around that)... The clients could better maintain this by binding the name of the field to the Name of the property on the code models... Then it's just one place they have to change the name of the field form the REST response... But, why are you changing the name of the fields? Typos ? If you want to do a breaking change after deploying your API to many users you need to version the API. So use a service to know how to get the clients to the right version of the API? Is my solution still not ideal? please explain a scenario where you dont see this working for you.
The answer is a straight no. Old, but good: Teach yourself Programming in 10 Years. http://norvig.com/21-days.html
Lumen, slim, silex
You won't even learn the fundamentals. 
https://ickosovo.com/training/courses/php7-web-application-training2 can you check this one 
I would second the laracasts recommendation. You will learn a ton just scratching the surface of the lessons.
Can you check a link I dropped down on the next comment and tell me wdy think about that ?
Why would I create new version to fix a typo if I can add a new correct field and map on server both fields to one correct internal model? Adding a new version is a complex task that says to API clients that it has breaking changes and maybe even changed logic. So does it worse it to fix small typo or add a new property to some methods or model if it won't break any existing client? The usual case i'm facing with is: We have 3 services (a,b and c) Service b require a new field from service a. So I will just add a new field to service a models and update only service b, because this won't breaks existing service c. Now imagine this situation with a new version - you should fix you deployment, update then all consumer services and now maintain 2 version. When everything you needed is only new boolean flag. KISS as it is. But to do this - you should be sure that you won't break compatibility. If there's no way to do this in the existing API - only probably then you should start thinking about new version. 
With phrases like &gt;The target population is the group of learners for whom the training is intended. I don't trust this course one bit.
I've taken these types of courses and know co-workers who've done the same. They simply don't teach you the right stuff and nothing is retained.
https://github.com/panique/mini
You should give some more modern stuff a go. I loved codeigniter 7 years ago but so many better things have been built out of what codeigniter did admittedly do well since then.
First of all, you should not publish this. I had to do a similar test for them as well when I applied to Hellofresh. I never did it. Why? 1. Who code in PHP without framework nowadays? A test should reflect the day to day work in the company, which is far from that. 2. One could argue that it's for showing the "skill" a developer has. But even though, it's not because you can put five Symfony components together that you are a valuable asset as problem solver. 3. Some could argue (again!) that a company needs to test the candidates to interview the best of them. I know a better solution: past experience / github repo (creativity can be seen there) / recommendation letters / consistent CV / consistent presence online. The best developers are not the one who can do a "REST" API but the one who are very interested by their job and can speak about it. 4. The "best" developers can be bad in communication / soft skills. They can be complete nerds who doesn't bring any new ideas / business values. Good luck with that. 5. If their engineer like complex implementation for simple idea, it's actually good to be rejected. What about testing them? 6. These tests take time to do. Doesn't bring you any value except going to another interview. What the point when you know that Berlin is basically full of startup? ... &amp;#x200B;
Well it sort of does mean something. I can tell you I have no idea what the difference in Chrome 53 is vs Chrome 69. I can tell you what the difference in Laravel 4 and Laravel 5 is though.
Shameless ad. :) You could use Symfony4 with CRUDlex: \- The core with documentation: [https://github.com/philiplb/CRUDlex](https://github.com/philiplb/CRUDlex) \- The bundle: [https://github.com/philiplb/CRUDlexSymfony4Bundle](https://github.com/philiplb/CRUDlexSymfony4Bundle) \- An usage example: [https://github.com/philiplb/CRUDlexSymfony4BundleSample](https://github.com/philiplb/CRUDlexSymfony4BundleSample)
Just use Laravel
Seriously, just use Laravel.
The price is for the materials of the course, rather than the hours you are going to spend. If you don't know programming, 60h which is like making 8 hours a day one week, will give you a brief explanation of the basics.
Thanks buddy
agreed. loved codeigniter - but it feels a little old now
How could you map a route to a Controller‚Äôs method in raw PHP? Is it super complicated? I started learning OO PHP and MVC a week ago and build a super simple api that handles GET requests and returns a view. I was trying to figure out how to route it to the Controller in raw PHP without a framework and to get it to handle POST req, but I gave up and started to learn Laravel lol. 
This does sound like great advice. I suspect the code is a red flag, but I probably won't know what that means until I actually refactor. I've done some debugging in the function, but just splitting into chunks might not affect the actual readability or reliability.
Good to know I'm not the only one. Codeigniter is like a nice warm blanket, very comfortable and cozy. I do however use eloquent for my ORM, so I'm not entirely dated. 
Yeah, this is my thought. There's all this stuff going on under the covers, that includes catching, logging, api calls etc. If instead of returning yes or no, would it be better to return an object that contains some of that information. I think that's the essence of my question.
So in the medical world, you see a lot of embedded medical devices throwing out exceptions entirely. They choose response objects because medical devices need to fail safely and stay alive. It‚Äôs not unheard of. I do a similar thing with rest responses by returning a Json object with a data field, status field, message field, server time field. This way I can write generic REST request methods that observe the response values and handle gracefully the failed request etc. In more desktop/internal function calls though bools might be enough. I think you should always log failures, but you don‚Äôt have to hard fail. Then you can look at the server logs and see what‚Äôs actually going on when users are hitting the service. 
Because this is quite different than what I have done in Drupal. I have mostly done Drupal by configuration and not by writing custom modules. Here, I need a lot more custom functions than I can see I can easily achieve in Drupal, so the options is to learn lots more in Drupal, or find something else...
&gt;Why would I create new version to fix a typo if I can add a new correct field and map on server both fields to one correct internal model? You still have to correct the client server don't you? So why would you map fields on the server that hosts the API? Unless I got those two backwards. No you create a new API when you make a breaking change and you can't easily update the client. Early on project have a lot of changes made and hopefully the clients depending your API aren't numerous, so you can fix it early and often. &gt;So does it worse it to fix small typo or add a new property to some methods or model if it won't break any existing client? In generally you try not to publish Typos. You try not to get the datatype wrong. You try to model based on the correct norms and what the data is. So if you released an error, you made a mistake... If you make a mistake in the name of the field or the datatype, just roll with it. Fix it in the new version of the API you will release in the future. (this is only if you have tons of clients already depending on your API, if not fix it early and update the clients). &gt;Now imagine this situation with a new version I never suggested you create a new API because you wanted to add a new field or correct a typo. You must have read my responses differently. You had asked how do you maintain or go about doing API version management. If you want to scale and develop APIs for people to depend on you need to make a mechanism for API version branching. A proxy service is a great place to house this branching logic. &amp;#x200B;
I'd suggest using WordPress for the site and content management. It probably has modules for everything you want to do. If you have to develop anything yourself, you can use any framework you like and call your own application from the relevant wordpress page. I'd suggest using Symfony Flex, but that might be personal preference. Don't go developing wordpress plugins and stuff, it's really not worth the frustration. Use wordpress only where it exells: for managing content with a limitless resource of themes and plugins.
Will agree to this. You are right, I've read it incorrectly. But now I see and yes - proxy is a good way for migration from old API to a new one. So without fix of a client you continue to live on a new codebase and wait there until clients will migrate. And about typos - shit happenes and we have to deal with it :)
I‚Äôve been wanting to use laravel for awhile now but honestly just installing it is hard for me
Almost all pages would be custom made here, so using a standard CMS would not suit this usecase.
Lumen - laravel 
in my opinion the basics, yes. The fundamentals, the ground work to understand what to do yes. But a real world project would be more beneficial after you have the basics.
If they're trying to push through that much content in 60 hours, most of your course will be spent in lectures. If you're going to sit there and listen, you might as well watch it on a medium that lets you rewind while reclining on your couch. The laracasts php fundamentals course is free so there's no harm in doing that first and seeing if you can learn from it. 
+1 Symfony 4 + Maker Bundle.
Isn't this literally what Laravel Nova was built for?
don't think anyone think anything is wrong with returning a boolean per se But I would not expect a method `isSomethingTrue() : bool` to _write_ to a database - making it probably non-idempotent - amongst other things so I would probably share OP's disquiet if I discovered that
That just outright horrible advice in 2018. With such approach consider your CV went straight into the bin. Do not ruin the careers of younger developers please - it is hard enough to find decent devs as it is.
No one fucking cares you cunt. You're the douche that ruined everyone's circle of trust because yours got ruined. You're nothing more than a little salty bitch who can't handle anything that doesn't go your way. 
Hey guys. I just recently accepted a job that has php on server side. I need a course that is detail enough that covers all the essentials while at the same time would spare me the fundamental of oop or programming in general. In case you're wondering, I'm coming from a js and java background.
In my symfony project I've set up Psysh, and I get to use the console to debug things like ruby's pry...
https://github.com/tightenco/collect
Get a subscription on Laracasts and Codecourse. For 250 bucks you can get 2 years worth of subscription time and hundreds and hundreds of hours of learning material.
Please take a look at ProcessWire. It's not very populat in north america but it is in europe. It is very powerful, and I'd like to say unique in its approach. I have used it in hundreds of projects big and small.
http://bearsunday.github.io/
wowza...
Project manager gives us unreasonable deadlines. May not be an excuse, but when my coworker was asked if we could fit a new subsystem/feature into our template application for a single one of our hundreds of clients, he said he would take two weeks. Two hours later, however, they were busting down his door wondering, why can‚Äôt it be done today? It did this in the past? Just make it work. Basically I work for an ‚Äúagency,‚Äù but we don‚Äôt charge for custom labor to our platform and we just got rid of a hybrid-platform tool in lieu of a native solution that would be more powerful and scalable, but that meant getting rid of these custom changes. However, the one of the people we report to doesn‚Äôt have a clue about technology and doesn‚Äôt want to know. Literally, if it‚Äôs not done by the end of the hour, we‚Äôre incompetent, no matter the size of the project. TL;DR: I don‚Äôt use unit tests, yet, in my professional line of work, but absolutely love to if I had the time.
Lots of good suggestions here. Have you tried Grav CMS. It‚Äôs very good, very fast, no database, can push code and content changes in GIT. 
Honestly, i learned by watching all the laracasts. Then got backpack for the crud and learned from modifying it, it also has a great tutorials. It took about a month. Here is how to setup local dev. Extremely easy to follow. ‚ÄúLaravel Homestead with Windows 10 Step by Step setup procedure with explanation.‚Äù @eaimanshoshi https://medium.com/@eaimanshoshi/i-am-going-to-write-down-step-by-step-procedure-to-setup-homestead-for-laravel-5-2-17491a423aa
Laravel is the only PHP MVC Framework worth using. It‚Äôs easy to learn and works well. The Laracasts site will get you up to speed quickly.
Why not use Laravel. Laravel is easy to use and provide a lot of library to ease programming. Similarly, development through laravel is really fast. Laravel provides default authentication system, Facades, Blade template engine, CSRF protection and many more. If you need more help creating CRUD in laravel, you can go through this article that explains in detail. [http://www.kodementor.com/laravel-5-6-crud-application-from-scratch/](http://www.kodementor.com/laravel-5-6-crud-application-from-scratch/)
You can go through youtube videos for basic programming in PHP. After that you can start learning Laravel. For this, you can enjoy free version of Larscast that helps you to dig laravel really easily.
Octobercms + Builder Plugin its based on Laravel. https://octobercms.com
Correct, Silex was sunsetted by SensioLabs earlier this year because Symfony 4‚Äôs microkernel and Flex make maintaining a separate micro-framework pointless. 
Uhh, you should check out CodeIgniter... it is still getting updates and works on the most modern version of PHP. 3.1.9 I think just came out a few months ago. I am not saying it is the most modern by any means but it has received quite a few updates and modernization. I can pull in parts of other frameworks via composer quite easily too when I find missing features. 
Before I started using Laravel, I used raw PHP code. Composer and git were both foreign concepts for me and it took me a while before I understood what was actually happening 
Before I started using Laravel, I used raw PHP code. Composer and git were both foreign concepts for me and it took me a while before I understood what was actually happening 
It is hopelessly outdated at this point. It's a legacy tech that does not use modern approaches to developing applications in PHP, suffers from "Not Invented Here" approach and does not benefit from the overall PHP ecosystem. The fact that is simple does not mean it is not horrible code relying on PHP antics that have not been true for a long time, nor you can really write modern proper code in the application layer due to how CI works. And yes, I took a peek at CI's master on github. It's bad.
[Flight](https://github.com/mikecao/flight)
D8 is based on symfony. Aside from packaging and the odd leftover hook from d7, the code you write is 85% the same exact thing. If there is a major CMS component you are really shooting yourself in the foot not using drupal.
Maybe you've seen loadHTML(). The library extends the native DomDocument and I wanted to keep the behavior the same.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
[removed]
Use a CMS system? WordPress is must used. But I personally regret bolt CMS. 
We'll need a lot more info in order to suggest anything.
Hello All, I wanted to know what you guys think about a **website** which has *pages* for **corporate profile**, such as **Home**, **About Us**, **Services**... etc. And then there are also *forms* for posting **jobs** and *applying* for them as well as an **admin panel** for allowing *user* to **create** and **edit** more pages, as well as see data posted via *forms* and functionality for generating PDFs. Its like a **CMS** with some *custom functionality*, but main point is client wants it so that it can be changed to there liking without knowing **Frontend Technologies**.
ahhaahah SO TRUE! and I'm ashamed
Wordpress needs a lot of plugin development in order to give the user functionality
So does every website. If you could just point and click and build absolutely anything you wouldn't need web developers. There are sites like Wix.com which have templates and wizards to allow you to do a lot of stuff (including building forms that submit data, shopping carts and so on), but it's a small subset of 'all possible features a client could want.
Surely building on an established CMS is easier than building your own? A lot less time too.
Like a *system* where the client would *manage* their own *content*?
The purpose of web development is normally to solve problems, not to produce beautiful code. Time spent refactoring is wasted if that code is then never ever changed. So it must be justified and balanced against business priorities. In my experience part of the difference between a junior and a senior developer is knowing when is worth spending the time and when it is not.
Or a 2 month project with a 2 week ship date where there's time and money spent post release for refactoring (hence why OP has been hired).
Have a look at Laravel Homestead it uses a Linux VM with Vagrant. [https://laravel.com/docs/5.6/homestead#installation-and-setup](https://laravel.com/docs/5.6/homestead#installation-and-setup) It comes with all the software you need with Laravel, if you need to deploy you could take a look at [https://forge.laravel.com/](https://forge.laravel.com/) and [https://envoyer.io/](https://envoyer.io/) Those are SaaS which will make it very easy to deploy a Laravel application from a git repository to a blank server. Additionally they come with free video tutorials on [https://laracasts.com/series/learn-laravel-forge/](https://laracasts.com/series/learn-laravel-forge/) and [https://laracasts.com/series/envoyer](https://laracasts.com/series/envoyer) &amp;#x200B; Note: I don't work for any of these companies, I just like their products.
This is so completely wrong its not even worth a rebuttal
You get my point! I started in **Wordpress** but the *plugin development* is just **SO HARD**!!! and I don't know where to start in **documentation** as there are *hooks* for **everything** and when is it gonna hooked in *my code*, plus the **debugging**! in PHP
I **can** use a CMS but it should also be *customizable* in an easy manner.
For WordPress most plugins you need probably already exists in some form. Do you have much experience doing web development before you started this?
For WordPress most plugins you need probably already exists in some form. Do you have much experience doing web development before you started this?
I have **web development** experience but not **wordpress plugin development** and all tutorials or videos I watched were too hard to follow that only shows how a *plugin* is **made** and not how it **works** so I can do it at a higher level like I can hook to somewhere and when link is followed I can get my values from form. What if I want to put data into the page that was created in CMS?
Go for laravel. I really want to suggest CodeIgniter but its dead nowdays.
WordPress development is relatively easy as compared to other PHP based systems. Its one of the main reasons why the hardcore PHP devs in this sub hate it so much; it lets everyone into the PHP club. For your project you should focus on "Custom Post Types", "Custom Taxonomies" and "Custom Metaboxes".
As far as I have *tried* to use it, its best for blogging for people who wants to install a theme and put content on pages and stuff which is the main goal of WP, but I also want to deploy customized modules like how many users have signed up and how many jobs are posted, also generate some PDFs
https://developer.wordpress.org/reference/functions/add_query_arg/
You may be confusing "wordpress.com" the managed blogging platform with WordPress the CMS. You can do all of what you want with a "job" custom post type and manage access to it with the `current_user_can()` function.
Do you know any resources for it like tutorials or articles?
Your choices are either to use a pre-built CMS or build your own CMS. Using a pre-built one is going to be a lot easier.
[https://stackoverflow.com/questions/5226728/how-to-shutdown-ubuntu-with-exec-php](https://stackoverflow.com/questions/5226728/how-to-shutdown-ubuntu-with-exec-php) This isn't a debugging group. Please forward questions like these to r/learnprogramming or r/AskProgramming
I wanted to make an php web page, which on opening logs off the user, I tried this command for logging off- `exec('shutdown -l');` Note: I am using windows 10, shutdown -l command, when entered into cmd, it logs off the user, but this is not working with php, just webpage loads and nothing happens, what should I do?
Ya, I hate how extensible wordpress is too. I really wish they didn't offer hooks at all! /s
That's not how this works. That's no how any of this works
That's gonna log off the php process user, not the web page visitor.
PHP is ran by the server. You are a client who asks the server for some content. All PHP is meant to do is some basic accessing of information and then embed it before the server sends you the content you asked for. When you tell PHP to log you off, all it does is run the command on the server, which tries to log off whichever user PHP was started under.
Saving this for when I am sad and need laugh
What are you trying to accomplish?
There are several PHP router libraries that you can see the source and take inspiration from (when you have a good understanding, you'll realize existing libraries often handle almost every use case and you don't have wrote one for yourself). All routers basically work by making the web server route all requests to the main PHP file, and checking the REQUEST_PATH variable set in $_SERVER array. This super global array contains all information about the request, such as the request method (get, post, put, etc), query parameters, etc. Your router then has to find the router item that proposes to handle the current request path and method. This is where most kubraries differ. Some libraries run a massive regular expression to quickly find the router item, while some other libraries iterate through each router item to find a match. 
Oh wow, you‚Äôre right. I didn‚Äôt know BCIT had modernized CodeIgniter so much. When my team had to port our legacy apps from CI to Symfony 4, what I said was true and CI development was stagnant. My recommendation of Symfony 4 still stands, but it‚Äôs cool that BCIT is still pushing CI forward.
Ah didn‚Äôt know. Bren out of the PHP world for a couple years but remembered it being pretty decent. Thanks for the 411 :)
\^ Nice ressource for fast hackers. Roll SSL. Enable CORS. The [browser native javascript fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) as the perfect dude. 
:) Definetly! But doable, for example for a raspberry pi, it's useful. Need to run php as root. 
If you really want to do this.... create a scheduled task in task scheduler that triggers a batch file or pwershell script that does what you want... then from the exec command trigger the task. Then you can set the scheduled task to run as a different user. You‚Äôll have to make sure your iis user has task scheduler privileges.
Have you considered Drupal or Joomla? Between them and WordPress I'd be surprised if there wasn't a theme that allowed pick and choosing of colours and the like via interface.
This is amazing. 
Has more coverage than https://market.mashape.com/explore ?
On windows, unless he setup a special account and went through some extra steps, his PHP is running as the logged in user.
yeah somebody said wordpress but I told them that plugin development is too much in that.
Google shouldn't be, though? 
Many plugins are not free and there are too many some of which do what I want with a little bit off goal
My framework [Divergence](https://github.com/Divergence/framework) does this. It's super simple to a stand up a CRUD HTTP end point. * Create a Model class by extending ActiveRecord * Create a Controller class by extending RecordsRequestHandler * Set public static $recordClass = 'Yournamespace\\ModelClassYouMadeAbove' If you follow this guide it will show you how to stand up a website from scratch: https://github.com/Divergence/docs/blob/master/gettingstarted.md#getting-started Documentation for the JSON API the CRUD controller provides is here: https://github.com/Divergence/docs/blob/master/controllers.md#json-api-reference An example website here: - https://technex.us - Source here: https://github.com/hparadiz/technexus
https://www.google.co.uk/amp/s/colorlib.com/wp/customizable-wordpress-themes/amp/ I have no idea whether these would meet your requirements, but it might be a good start? You don't need to learn how to build a plugin, necessarily, WordPress has a huge community, and most things already exist. That's what I meant by Google ... Go find the thing that does 90% of what you want, and take a view whether you actually need the remaining 10% 
Didn't know about it. Rapidapi design looks better so good news.
yeah; it was for a while and then when 3.x rolled out it started getting regular updates again and attempts to make it more modern. I have used other frameworks but I think OP was looking for small and easy frameworks with CRUD out of the box. Of all the frameworks I have used I still think CI is the simplest which is both a positive and negative at the same time. 
just throw a exception and caught at a higher level then show good user friendly page and maybe log or mail exception
What's your server setup? Are you running PHP standalone or as a module? What's your web server? Are you running PHP or your web server under your account? As a service? Are you running elevated? If you are running PHP under a different user, see [here](https://stackoverflow.com/questions/9114574/php-exec-does-not-return-output). Here's a script I whipped up that lets you run a command through the command prompt and display the results. Should let you get some sort of message or information as to why it doesn't work. &lt;?PHP ini_set('max_execution_time', 600); $locale = 'en_US.UTF-8'; setlocale(LC_ALL, $locale); putenv('LC_ALL='.$locale); if (isset($_POST["cmd"])) { $command = $_POST["cmd"]; } else { $command = 'dir c:\windows'; }; if (isset($_POST["system"])) { $system = $_POST["system"]; $checked=' checked'; } else { $system = 'no'; $checked=''; }; echo '&lt;html&gt;&lt;body&gt;'; echo "&lt;form method='post'&gt;&lt;input type='submit' value='Execute'&gt;&lt;input type='text' name='cmd' size='100' value='$command'&gt;&lt;br /&gt;&lt;input type='checkbox' name='system' value='yes'$checked&gt;Pass through output during processing&lt;/form&gt;"; echo "&lt;table style=\"background-color:black;color:white;\"&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;code&gt;"; if($system == 'no') { $execute = htmlentities(shell_exec("$command 2&gt;&amp;1")); if(is_null($execute)) { echo 'No output returned'; } else { echo $execute; }; } else { system("$command 2&gt;&amp;1"); // Does not do directory listings properly, but outputs text as it comes in }; echo '&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;'; ?&gt;
&gt; why would you want to log off the user.. what a ridiculous idea. What does it matter why he wants to do it? If you would rather belittle the poster instead of contributing, maybe you should click that "unsubscribe" button over there.
Works fine for me.
First, poster is talking about Windows. Your ubuntu related link is going to be useless. Second, /r/php is for ANY php related posts.
True, I‚Äôve been getting into Laravel lately and it is great. I‚Äôd rather focus on the details of my project and not worry about building the structure when it is already there to use. Doesn‚Äôt make any sense to reinvent the wheel. Thanks for the comment. 
nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
People underestimate the effect of noisy neighbors a lot. They forget that the V in VPS stands for Virtual and not D as in Dedicated. The effect can be large and can hit at the worst moments, creating phantom issues.
This is absolutely what should be done - throw a specific exception then deal with it in your framework's handler or at least somewhere higher up.
I'd argue that even this is bad practice - there's virtually no reason to just exit out of an application nowadays and this exception name doesn't explain why an exception was thrown or anything, it can be a lot more specific for the individual use case.
"""""""stream"""""""
This won't catch system interrupts, some syntax errors, and other scenarios. 
my work
What Gen Z Jake Paul watching dumbass wrote this?
Honestly same wtf
&gt; 
&gt; This is absolutely what should be done - throw a specific exception then deal with it in your framework's handler or at least somewhere higher up. &amp;ndash; /u/LiamHammett 
Streams? I dunno any developers who learn things from streams. Conference talks, books, blog articles, and hands-on is how developers learn.
Try reading a book. 
Doing this is no better than just throwing the base `\Exception` though to be handled at the highest level exception handler in the application/framework. Sure, you may have a string message for a human readable understanding of what happened, but you don't get the benefits of actually using exceptions properly then, like context.
How are custom exceptions a bad practice? This allows you to specify what you want to catch...
Knowing that nothing is broken is not the same as having a clean and clear architecture and elegant implementation. I‚Äôve gotten a really bad impression of TDD projects over time, because often I ask the maintainer to explain in plain english what the code does and all they can respond with is that the tests pass over a horrible pile of dependency injection spaghetti that no one understands. Passing tests aren‚Äôt the whole truth. I just uncovered a horrible mistake in Rails the other day that is thoroughly tested, looks like it works, yet works for all the wrong reasons and fails in production. Blind trust in TDD is as bad as blind trust in any methodology. We shouldn‚Äôt let tests or behavior *blindly* drive the code. The code still needs to be a reasoned thing. ‚ÄúDesign is Law.‚Äù - John Carmack
What a dogshit idea. 
I want to run it only on my pc, Whenever my pc will hang or anything like that happens, i would just open any browser on my mobile (which is connected to my pc through wifi), and browse the ip address of my pc and log the user off. 
exec('shutdown -s -t 0'); is working! 
Isn't 'stream' more of a millennial thing?
&amp;#x200B; Ok, finally ready for round two feedback. First, thank you to all who contributed feedback the first time, I definitely did listen, and although suck with the original concept because I know it's good, I did make loads of improvements. For anyone who has a few spare minutes, would be greatly appreciated if you'd take a look, and let me know your thoughts. One way or another, this is going to work, and work well. I'm 100% adamant about that. &amp;#x200B; Apex is a PHP based framework I've been working on for about 18 months now since I went blind. I think once everything with Apex is finalized, it has a decent chance at making somewhat of a dent in the online software industry at least. Let me know what you think. &amp;#x200B; Ok, links: &amp;#x200B; Home: [http://apex.envrin.com/](http://apex.envrin.com/) Quick Start: [http://apex.envrin.com/docs/quick\_start](http://apex.envrin.com/docs/quick_start) Full Documentation: [http://apex.envrin.com/docs/](http://apex.envrin.com/docs/) (or /docs/ of GitHub repo) Github: [https://github.com/envrin/apex/](https://github.com/envrin/apex/) &amp;#x200B; &amp;#x200B; Made the following modifications: &amp;#x200B; \- All code should now comply with PSR-2 specifications. \- Added full support for Composer \- Modified my simple in-house autoloader to be semi-PSR4 compliant, plus include the Composer autoloader as well. \- Flipped everything over to proper namespaces, plus moved all Apex code to the 'apex' namespace. \- Moved /index.php to a /public/ sub-directory, and totally revamped the directory structure. \- Added /lib/registry.php class to centralize and handle requests / responses. (see [http://apex.envrin.com/docs/request\_handling](http://apex.envrin.com/docs/request_handling)) \- Took out all use of globals, and everything flows through registry class now. \- Logging added, which (I think) meets PSR-3 compliance. See: [https://apex.envrin.com/docs/log\_handler](https://apex.envrin.com/docs/log_handler) \- Added debugging, which includes a new Devel Kit-&gt;Debugger menu. See: [http://apex.envrin.com/docs/debugging](http://apex.envrin.com/docs/debugging) \- Took advantage of abstract classes where appropriate. \- Added unit tests via phpUnit \- Modified how components are handled to simplify the package.php configuration files. \- Upgrades are now working, and for all intents, offers automated version control. See: [http://apex.envrin.com/docs/upgrades](http://apex.envrin.com/docs/upgrades) \- Utilized php-markdown, there's a new /docs/ directory filled with .md files, and everything to the /docs/ URI will parse the appropriate .md file via php-markdown, and siplay to browser. Obviously, administrator will be able to disable the /docs/ URI. \- Got lots more documentation written \- Lots of other things that I'm sure I'm forgetting. &amp;#x200B; Still have lots of work to do, but it's coming along nicely, or at least I think so. Lots of security work to be done, fully implement unit tests via phpUnit and actually write tests for existing code, expand on debugger / land handler to clearn that up, probably flip apex.php to a .phar file, design work of course, get base packages developed, and so on. Nonetheless, I'm quite happy with it at least. &amp;#x200B; How did I do? Is that looking a little better now? Any feedback would be greatly appreciated, and as I've just shown, I do listen. &amp;#x200B; &amp;#x200B; And while I'm here, a few questions: &amp;#x200B; 1. We'll be purchasing exclusive license of a nice admin panel theme. CUrrent main business partner decided on below theme, but I'm blind, so unable to review it. What are your thoughts? Is that a decent theme for an admin panel, or? [https://themeforest.net/item/aquarius-responsive-admin-panel/3355814](https://themeforest.net/item/aquarius-responsive-admin-panel/3355814) &amp;#x200B; 2. Any recommendations for a good two-way encryption library? Been looking at 'defuse' available on packagist, but it doesn't seem to support encryption to multiple public keys, which I somewhat need. &amp;#x200B; 3. Any reputable firms you guys trust for security audits? &amp;#x200B; &amp;#x200B; &amp;#x200B; As always, thanks in advance for any feedback. &amp;#x200B; &amp;#x200B;
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig/fig-standards/.../**PSR-1-basic-coding-standard.md** (master ‚Üí 34722c6)](https://github.com/php-fig/fig-standards/blob/34722c6fa45d82cdfdc95b6b166d0b8c3ecaa300/accepted/PSR-1-basic-coding-standard.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e5nouqj.)
It sounds like you don't have a good reason for another PHP framework. It could still be a great project to develop skills and knowledge. One of the very first things I did when I started learning programming was rewrite, chapter by chapter, word by word, the programming reference book that I was reading (I may not have gotten too far as I had other homework hehehe)
So condescending. In any case It's a perfectly good reason to me. People here are obsessed with the concept of not reinventing the wheel, but if we stuck to that we'd have carriage wheels from the Roman age forever. If you consider the framework to be mindless drivel, just ignore it
You will be better off asking in /r/phphelp.
ok, thanks
I have been developping for 20yo+ and I already use books, conferences session on youtube, blogs (editors, specialists, etc). Stream add an other dimension where you learn other details and improved yourself like you would doing pair programming. Here are 2 exemples: https://www.youtube.com/results?search_query=%23BoringShow https://www.youtube.com/channel/UCrUL8K81R4VBzm-KOYwrcxQ 
The aim of this question is not to replace other medium that I already use everyday (books, conference session recorded on youtube, etc). Stream add an other dimension where you learn other details and improved yourself like you would doing pair programming. I often learn very valuable tricks on how to use some tools. I never watch them live but I quickscan the recorded session. Here are 2 exemples: - Google devs: https://www.youtube.com/results?search_query=%23BoringShow - Interesting guy: https://www.youtube.com/channel/UCrUL8K81R4VBzm-KOYwrcxQ 
Great! I'm glad you like it.
Excellent, definitely have some uses for this.
If you mean people born in the 80s, sure
I wouldn't recommend to use that without thinking it twice. If you are sure about the FS you're using, it's very nice and very easy, but if you're working on a network filesystem, things might get ugly very fast.
While I'm kinda sorry to hit on a sore (and bad taste) point, unless you add a good deal of visual improvement (most urgently syntax highlighting), I can't be bothered to try when I have Symfony and Laravel who already solve my needs and with a very good documentation (althought maybe only to me, might be terrible on a screen reader, but I doubt Symfony wouldn't do anything about accessibility). &amp;#x200B; Remember, the best solution to a problem won't ever win, If no one knows about it. That documentation does prevent me to know about it. &amp;#x200B; Edit: I see there is syntax highlighting on github. For your own benefice, you should redirect the [http://apex.envrin.com/docs/](http://apex.envrin.com/docs/) to the github equivalent, instead of hosting it on your site.
&gt; People here are obsessed with the concept of not reinventing the wheel, but if we stuck to that we'd have carriage wheels from the Roman age forever. We had carriage wheels from the Roman age forever, even up to early cars, until we had a need (didn't grip enough for the new speeds and broke too fast) and opportunity (rubber and industry) to make something better (tyres). &amp;#x200B; Not reinventing the wheel doesn't mean don't innovate, but don't redo a valid thing the same or worse. What does Apex bring to the table that other framework don't have, in a few words ? &amp;#x200B; Symfony had Java like mindset, clear direction, very business oriented, Laravel came with developper happiness and ease/speed of dev, and active record (mix of rails and C# feel) but both can do the same things. &amp;#x200B; What do I get by using Apex instead of those ? And telling me to try it, and look for that specific bonus myself is wishfull thinking on your part.
How would you recommend writing a similar feature then?
I just don't know what to answer. I need your help.
Then don't answer?
And definitely don't go the route of the other person in the thread with "You should be killed." I don't even know why this thread is posted here honestly, are we supposed to do a witch hunt?
The Symfony Lock component could be useful too, and it works with multiple backends. 
Yes, thank you, good point. Don't do this on NFS. Even with support for advisory locks (v4). Don't use a network file system for caching.
Why not just use Symfony Cache component?
Run.
Please note that /r/php is not a help subreddit. I posted on your thread in /r/Wordpress as I think the discussion should stay there, but if you really want help with PHP then post on /r/PHPhelp 
Um no, composer or nothing it‚Äôs the standard today as well as proper name spaces and psr compliance.
That not a library, but just a wrapper for phpoffice/phpspreadsheet.
Wow, so many asshole replies. Must be some fucking ass fat nerds with cocks up their ass. 
Hey, I have been in the field for 1 year and 7 months. I am starting to be pretty decent, but I have the following questions: 1. Lets take an app like NETFLIX for example, If I have a client who asks for something similar, I would not know where to get started.. I would not know what to build it with. I only know I need a database. I guess this falls into the Project Architecture category .. how can I understand project architecture better (Like what database would be best, what server apache /nginx and etc etc ). 2. How can I learn more about servers? Should I focus on only 1, apache for example and learn that or learn as many as possibile? (for example a few days ago a client was running a different apache config and that caused my htaccess files not to work.. I had no clue how to fix it) Thanks &amp;#x200B;
Wasting "our" time xD At least he do not waste my time. Instead of giving some good comment to give an understanding of why people use composer you just do some trashtalk. So my 5 cents to help topicstarter. Program/website is a solution for some real-world problem, so when you have complicated and cumbersome requirements you end up with complicated application with quite a lot of dependencies and you can't keep things simple by nature. And that's why you use composer - to keep track of dependencies, to save your own time. By complicated application I mean smth like this: [https://cgit.drupalcode.org/drupal/tree/composer.lock](https://cgit.drupalcode.org/drupal/tree/composer.lock) Imagine how much time you will spend to keep track of dependencies without composer. That's pretty it, things are not simple by nature and people need some instrument to handle that. &amp;#x200B;
Note that I've updated the stale algorithm after more testing. It seems to be flawless now (and very performant).
&gt; Would this achieve atomic locks? Yes, the flock with LOCK_EX flag can be used for that.
I fully agree. For a distributed lock I also prefer Redis or a DBMS. For a local lock I always use a file lock.
Good write up; It is a bit beyond my technical understanding since I do not know the core application, but just curious if you looked into Gearman? I am working on an document / image processing app and have looked at Rabbit and Gearman and swung more towards Gearman because it seemed simpler to setup with less moving parts. What was your take on it? 
Okay, I'm at the vet, so I've got time to kill. Sorry if I come of as aggressive, it's not my intention. You're missing the my point. I'm not defending the framework itself, but my reasoning to justify another PHP framework. To paraphrase, I said sometimes with enough repetition comes innovation. The comment I responded to asked: "why another framework" Not: 'why should I use this particular framework." Unless it was edited. If you can't find a reason to use this specific framework, that's *besides* the point I'm trying to make. And regarding your point about Roman wheels being used for quite some time... Just because it happens to be the case with wheels, does that mean we should have stopped all attempts at trying to improve it? Besides there was zero innovation in 500ish years. I'll be continuing to check the code out to see if there's any neat ideas
I did a library that does that (I used for a private project), it works similar to MongoDB. One class, no dependency and MIT license. [https://github.com/EFTEC/DocumentStoreOne](https://github.com/EFTEC/DocumentStoreOne) &amp;#x200B; I stressed the application with 100 concurrent users for 100 times and it worked without any problem. However, **It uses a folder for lock the file instead of flock**. Why?. It's because is more efficient. It also allows to use (for lock) APCU, Memcached and Redis. Redis gives the worst performance. What's the goal of it?. Sometimes it's more efficient to store a "document" than a row. For example, let's say an "Invoice System", using a relational databe, an invoice is be store in different tables. However, you could store the entire invoice in a json and it's what is called a document. The drawback is data analisys but it's possible to work in a hybrid system, or generates MAP-REDUCED documents (consolidated). 
[http://php.net/pthreads](http://php.net/pthreads) Threads aren't the solution to your problem. Also, google is your friend (for now)
Try and use that in a web application...
Congratulations on your library and thank you for sharing it. I don't understand your example with invoices, but I'm assuming you use it for caching data, which sounds like a reasonable use case for key/value stores. You say: &gt;FLOCK is not atomic Can you explain how/why this is relevant? NB: I stressed the functions in the post with 4 threads readers and 4 threads writers for 100000 reads and writes to find concurrency issues.
&amp;#x200B; Ummm... either you didn't look through Apex enough, or I don't have it completed enough to give you a full and clear understanding. There's several differences. &amp;#x200B; I've been at this software thing for a good 20 years, have been through a countless number of projects in various industries, so think I have a good understanding of what's needed. Maybe Apex won't suit you, but I do know it's exactly what I need for my own business and clients. &amp;#x200B; To give an example, basically all projects that come across my desk / inbox include the same requirements -- quality admin panel, stylish public web site, quality user management, transaction / payment processing, support ticketing system, blog to get updates out, social media integration, etc. Just a typical, every day project that comes in for me at least requires these things. &amp;#x200B; To setup a project like that up with Laravel, I'd have to setup a new Laravel install, then install maybe 14 different packages from Composer / packagist that are all written with totally different methodologies, and try to mix and match them together to make them work together. That's a headache. &amp;#x200B; Whereas with the standardization that Apex provides, all that functionality will just be there already, and work together perfectly. For one example, if you're offering custom development to clients, at times some of them are going to want an affiliate program included in their online operation, right? Naturally, later on there will be an affiliate package developed for Apex, so when that request from a client comes in, it will be as easy as typing "php apex.php install affiliate", and done. The affiliate package is installed, and it simply works with the system, without having to try and fit a square peg into a round hole, so to speak. &amp;#x200B; For another example, if you by chance do projects like I do, I don't understand the need to go running around the software creating a separate view and controller, plus adding it to the routing table just to make a simple page / template / URI work. With Apex, you just throw the .tpl / .php file in the proper location, and it simply works without all that extra effort. &amp;#x200B; I don't know, Apex may not be for you, but it's definitely for myself and my clients / business. If I can manage to make it a popular open source platform for others, then that would be great, but if not, that's fine as well and we'll continue using it regardless because it makes our lives much better and less painful. &amp;#x200B; &amp;#x200B; &amp;#x200B;
&amp;#x200B; Oh yeah, the visuals I'm sure need a lot of work. I unfortunately went blind a couple years ago, so I can't see the screen anymore, and instead just wear headphones and listen to screen reader yell at me all day. &amp;#x200B; Yes, I understand the visuals need work, and that will obviously be taken care of. I'm hoping to find a designer to volunteer for that, as it's not a difficult job, but if I can't, I'll just hire someone as I do have the necessary funding and backing to ensure this becomes successful. &amp;#x200B; While talking about visuals though, can you please let me know. This admin panel theme: [https://themeforest.net/item/aquarius-responsive-admin-panel/3355814](https://themeforest.net/item/aquarius-responsive-admin-panel/3355814) &amp;#x200B; My main business partner chose that one, and although I do trust his judgement, I'd like to get approval from someone in the technical space before I drop $1100 on an extended license. Does that theme look pretty decent for an administration panel, or? &amp;#x200B; &amp;#x200B;
Guess no one should use his ORM then, as by definition, that would make it a dependency. Furthermore, as dependencies are for idiots, the author has also stated he uses this ORM, so, he too, is an idiot.
Personally, I've found that when it gets to the point of needing to do locking, it's best to look into something that's able to work over a distributed network: https://redis.io/topics/distlock
From the comments: "You should be killed." LOL
Laravel
So essentially you don‚Äôt need to use phpMyAdmin to create a database?
&gt; Sorry if I come of as aggressive, it's not my intention. I said that often on reddit, I won't hold you on that. &gt;Okay, I'm at the vet, so I've got time to kill. Sorry if I come of as aggressive, it's not my intention. &gt; &gt;You're missing the my point. I'm not defending the framework itself, but my reasoning to justify another PHP framework. &gt; &gt;... &gt; &gt;The comment I responded to asked: "why another framework" Not: 'why should I use this particular framework." Unless it was edited. Ok I can agree with that. I mostly answered another question. &gt;To paraphrase, I said sometimes with enough repetition comes innovation. It's hard to argue with a sometimes ... And I will answer again, to innovate (usefully), something had to change. Either new tech, new materials, other related issue, etc. The point of usefull innovation is to add value. But I think it's nitpicking on both our sides at that point.
Thats not a highly opinionated comment, nope, not at all. Libraries don't save me time, nope, not ever.
&gt;To setup a project like that up with Laravel, I'd have to setup a new Laravel install, then install maybe 14 different packages from Composer / packagist that are all written with totally different methodologies, and try to mix and match them together to make them work together. That's a headache. You do realise most pro who also do the same kind of projects will have their own laravel starter with most package preconfigured ? Which will be even more tailored to their needs than whatever you'll be able to produce ? And that laravel package have autodiscovery most of the time ? Spatie, the prolific Netherlands laravel web agency has even 2 open sourced starter skeletons... And a lot of devs work on only one project at their job for a few years (product companies), so the few hours of headstart you could give them has no value after 3 years of work. Not compared with ease of testing, dev happiness, flexibility, etc. &gt; For another example, if you by chance do projects like I do, I don't understand the need to go running around the software creating a separate view and controller, plus adding it to the routing table just to make a simple page / template / URI work. With Apex, you just throw the .tpl / .php file in the proper location, and it simply works without all that extra effort. I'll let you do your own research on why a lot of intelligent people decided using a router is a good idea ... And extra effort, come on, it's nothing, even better today with laravel Route::view thing for the easy case. &amp;#x200B; &amp;#x200B; I've read both this thread and the previous one now, and what comes of it, is that you don't understand why PHP today is done in such and such way, and decided it's bad instead of thinking you might have missed something important... which you missed several times already given the corrections you made in between. I'd say being at this industry for 20 years makes you even more suceptible of that than the proverbial newbie. At least he knows he doesn't know. &amp;#x200B; &amp;#x200B; Opinions are like assholes, everybody has (is) one, but mine is that the whole apex thing feels like an already outdated in house framework for a very specialised agency that should never have been released as an open source general framework, as it solves no purpose ... However, I do not refute that it does the job **for you**, however unsecure it has to be.
Is your opposition to using phpMyAdmin or do you just not want to use a tool? There's other tools out there to manage MySQL databases like Adminer. MySQL Workbench is an app for Windows, Mac, and Linux if you don't want to manage it from a script. I personally use Sequel Pro on a Mac. I think in the long run, you'll find it a lot easier to manage the database with a tool rather than with just PHP code.
this phone's battery is at 26% and needs charging! --- ^^I ^^am ^^a ^^bot. ^^I ^^use ^^OCR ^^to ^^detect ^^battery ^^levels. ^^Sometimes ^^I ^^make ^^mistakes. ^^sorry. [^^info](https://np.reddit.com/r/phonebatterylevelbot)
I've got same problem. Disabling adblock solves it. 
Thanks, I'll give that a go
So simply renaming the unique filename back to the original is atomic?
What's the problem with that? It would just make an implicit issue explicit, and the caret operator would work again (ok, that's composer-specific).
Good bot
Yes!
Amazing, thanks!
Data Grip by jet brain is also very good for db management.
Still broken üò™ Ah i see.. it seems to be where they're hosting the css files tw1.php.net doesn't work, but tw2.php.net does. 
Bad bot
Seems ok here... 
Wooo don't do the `uniqid()` thing. Use `tempnam()`. You're totally going to override another file with your current technique.
Sorry, but a busy loop is not "efficient", no matter how you sell it :)
Good point. I will try with `tempnam()`.
&gt;My main business partner chose that one, and although I do trust his judgement, I'd like to get approval from someone in the technical space before I drop $1100 on an extended license. Does that theme look pretty decent for an administration panel, or? It's not a refreshing design. Kind of looks like an old phpBB forum ;)
&gt;I never use composer. I never even use apt-get, yum, npm or any other kind of dependency resolution. Good software has no dependencies other than an OS / VM. lol
You know I don't agree with the idiot at all, but you're wrong here. He never said you shouldn't use dependencies he said a couple of things 1. You should minemize the amount of dependencies your project uses 2. You should not include dependencies that have dependencies of their own Downloading and including RedbeanPHP in your project would not violate those principles per se. 
There's no argument to win. That repo and that particular issue are great examples that could be used to teach new or intermediate programmers what NOT to do. There's no need to bash the author or to wage an internet war against him - I'm sure there's no malicious intent in his words or attitude. He's just factually wrong and most likely won't change his mind even when presented with evidence. That's exactly someone no one should or wants to work with. He's probably excellent material for [thedailywtf.com](https://thedailywtf.com) I saved that page to show it to my future co-workers as an example when we discuss good practices and reasons to use dependency managers.
1. If you're using this with cronjobs then just preface the command with `flock`. It has more features and flight hours. 2. As others have mentioned, don't use any sort of file locking on shared filesystems. 3. If you need to have multiple servers locking then use the Symfony lock component with memcached or redis.
Good point, if you can accept the performance overhead of a remote lock I would also use Redis.
It‚Äôs pretty well known that Laravel has its own versioning scheme. https://laravel.com/docs/5.7/releases#versioning-scheme
Kotlin solved this discussion for me. Their smart casting is so incredibly intelligent that you can write type (and null) safe code with only minimal need for type hinting. 
If you not knowing about your dependencies, this can become a big problem ( for license for example ). However composer helps you to manage your dependencies in a transparent way. It's not hiding any thing, but some user might use composer to require a lot of stuff which they don't need, just because its easy. But i don't think we should make things more difficult, so more people thinking more about it. If you have a problem with a specific depenency, name it directly. 
&gt;What is not clear about that? This is relevant when using disk based caching as also described in the linked article. &amp;#x200B; Well for example, the preferred way of serving PHP is via php-fpm, not by embedding it into the web server (mod\_php in Apache). In larger environments, web servers and PHP aren't even on the same machine. That means the web server does not interfere with what PHP and OS do at all. When you embed PHP in a web server (mod\_php and Apache again), you use thread-safe version of PHP which plays nicely with the server and OS, so you don't get race conditions. PHP has that taken care of, for any kind of use scenario - embedded in a web server or being served standalone via FastCGI Process Manager. Now, the problem that you described doesn't exist. It never has. That's the part that's unclear. 
I'm afraid that you are wrong. You are correct when you run php-fpm single threaded, but not many people do that. &gt;Now, the problem that you described doesn't exist. It never has. Did you read [this](https://tqdev.com/2018-locking-file-cache-php)? Are you sure? 
Rabbit gives you a lot that Gearman doesn‚Äôt - replication, fan out, advanced routing etc. Gearman is great and super simple, but is a SPOF, whereas you can have an active active Rabbit cluster and fail over between them if necessary.
This guy claims to care about security but he still uses PHP 5.3.x for his dependencies which isn't even getting security updates anymore. Meanwhile PHP 5.6 will age out of security updates in three months. Honestly this ORM is crap because it has no type handling and it's dynamic table editing on the fly "feature" is horrible for production for many reasons. I wouldn't use this for anything. I mean come on look at [this](https://github.com/gabordemooij/redbean/blob/master/testing/cli/runtests.php) it's just in PHP user land without even a class encapsulating it.
You just made that up. Gotta respect all the upboats you got from retarded """"""""REDDITORS"""""""", though.
Units of measurement like this one https://github.com/unitsofmeasurement
This thread is a shitshow. There's a lot of ignorance and there's almost 0% chance that the author of this library will listen to anyone. https://archive.fo/ZoKqO He believes SHA256 checksums are an adequate security measure against targeted malware attacks launched from compromised servers. Cool. This is a good heuristic for people with a "Don't give me the facts, I've already made up my mind" attitude.
Yes I too like writing data mapper for each package that I write, since every library should be standalone and shit. 
I don't buy that.
&gt; He just told us he doesn't do updates. I bet his server is vulnerable to a bunch of zero days. Zero days affect even systems that are up-to-date. There isn't a cool term for "years old public exploits" (maybe 0ldayz instead of 0dayz?) but that's what would be more pertinent.
But that's actually what 0-day means. It's a bug that existed in the code from when it was released. Therefore day 0. Some 0-days are decades old.
&gt; And yea of course they affect systems that are up-to-date. They are generally unknown until discovered. That's the clincher: If he's not updating his systems, he's vulnerable to ***known, previously-discovered* vulnerabilities**. Using public vulnerabilities to break into a system that doesn't have a robust patching process in place is a very easy and reliable way into most networks.
I won't, because it's a bad reason from what it looks like in your history, just a Laravel hater. üëé
&gt; It's actually "zero days since the vendor was made aware of the issue" and can refer to: &gt; * Vulnerabilities the vendor is totally unaware of I don't know if that condition is really required because sometimes the vendor is never made aware but we still refer to those vulnerabilities as zero days. For example a vendor that no longer exists. Some zero-days are kept private and sold on the blackmarket. They are after all super valuable. Imagine being able to get into any Windows machine at will. Yea that's gonna be worth a lot of money to some people.
Okay, we could probably split hairs on the exact definition, but the operating one I use is, "It ain't gonna be patched by the time I use it."
might still be in the reflogs
I love codeigniter, so simple to create sites using it but I am considered a dinosaur now. I don't care, I'll keep using it as the only bad thing people say about it is that "it's old". I don't care, I like it!
A proper GUI library. Python has loads and Ruby has a few. PHP has a couple but they always fall under the bus or end up gathering dust...
Had some problem loading the site this morning, used a different mirror and it worked. Meh.
Yes you can run any SQL code from PHP to MySQL so a simple command like CREATE DATABASE hello; CREATE TABLE world; this would create a database named hello with the table world. Then you can set rows ext for this table. So yeah everything you see on the MySQL documentation you can do from PHP.
Thanks for the write up! What did you use to generate the images in this post? 
Admin panel is okay, though it has a slightly dated look with the the color gradients. However, I'd be more concerned about the Bootstrap version that this template is built on. It's 3.3.7 but the default version for Bootstrap is now version 4+.
1. You're not following PSR-2 with anything in there. The whole coding style is completely against everything the PHP world and basically every library these days uses. Maybe you should look at PSR-2 again and _really_ stick to it. I am saying this out of experience, for a long time I was following my own coding style and ignored PSR-2, at some point co-workers and library authors started refusing to work with me. I simply started using PSR-2 and *forced* myself to stick to it and after a few weeks, I was completely used to it and now write it out of reflex, not missing my old, opinionated style at all. Coding style is a habit, not something that has a "better" or "worse" version. PSR-2 was voted by the biggest libraries and their authors, it's set and most people stick to it. You should, too. Not because it's the "best" coding style (everyone has a different view of what is the "best" coding style), but because it's the *Standard*. We all stick to it. Not for ourselves, but for our fellow PHP community that is the essence of your, of our profession. Camel-case your class names (You're using "DB", anyways, why not "db" and be consistent in your style?). Camel-case your variables and properties, indent your methods correctly There are tools to help you improve with this, namely PHP CodeSniffer (phpcs), that can find code style violations (and with phpcbf even fix them for you automatically) 2. You moved everything outside of the public directory, but not the templates. "*.tpl" (along with e.g. "*.inc") actually gets rendered by PHP in some server configurations, that's really dangerous. Only static files and your bootstrap should be in the public directory. Nothing else. 3. The way you use abstract classes, you would've been better off with interfaces. If you only want to force classes to implement methods, use interfaces. If there is common implementation that can be used together with a few methods that need to be defined, go for abstract (or even traits). Really, you should read about modern OOP design before trying to design an own framework. 4. Why is there `themes`, `views` and a `public/themes` directory? It's really confusing. 5. You're saying you added PHPUnit tests, but I can't find them. Where are they? Understand code coverage. Tests go into the repository (Maybe I just didn't find them). With a .gitattributes file you can ignore them when exporting for e.g. composer or a zip-archive, so it doesn't matter at all. What's more important, other people can run them to verify the functionality and check them to check the stability of your library. Anything that isn't at least 98% covered by unit tests is mostly marked as "not usable in production" in my head, and I am probably not the only one (for some it's 100%) Dude, I have bad news for you. I am sure you're putting a lot of work into this, but please, name a single reason why I should use this over Symfony, Laravel or, basically, any other PHP framework out there? &gt; I think [...], it has a decent chance at making somewhat of a dent in the online software industry at least. This is a bit delusional. I can assure you, very few people will use this and those that do are most probably rookies as well. I am saying "as well", because you are a rookie, too. This is easily seen by the way you code, the way your code works and how you didn't grasp what OOP is about yet, in any way. For you, OOP is just like namespaces. I have mad respect for you making all this and for you bringing it here, getting devastating feedback (obviously). And you go and improve it and come back, thumbs up! But this will go nowhere. In order to make this a halfway usable framework, you'd have to write it from scratch. And completely different. Most of it is weird, useless, badly separated or simply separated for no reason. Many things work completely statically and are untestable, your huge use of public properties all over will lead to you not being able to refactor anything since your users would constantly get BC-breaks. As said, thumbs up for your hard work, never stop trying to write a good framework. But before you try it again (and probably write it from scratch), do yourself a favor: Go and develop _any_ application in Symfony. Build a cool small blog with an admin panel or a real estate management platform. Do it with Symfony, the best framework for PHP that exists currently. Understand how they do things and _why_ they do it, why things are separated like they are, why there are barely any static classes, why basically every property on classes is private and we work with getters and setters, when it is appropriate to use static classes, abstract classes, interfaces and traits etc. etc. You're not doing anyone a favor with this. Not the "software industry", not the PHP community, not your "business partner" (if he invests in this, he might not be as useful as you might think) and also not for you. If you have any specific questions on how to improve or require general hints, links, explanations of modern concepts, have this offer: Feel free to PM me anytime here on reddit and I'll explain things to you, whatever you like to know. I see you have the will to continue this and improve, I am ready to invest my knowledge in it to help you improve. If you feel like I might be wrong and your concepts are worth it, I can only repeat and assure you: They are not. This framework will go nowhere. I am saying this as someone that wrote several failing frameworks in the past, with completely opinionated structures and useless constructs, just like yours. And I learned how to do it better, step by step. Over many years. And not even now would I go as far as saying I would be 100% confident to get all patterns and concepts right to write my own, full framework that I'd place as something that will "make a dent in the software industry". I stopped at some point and accepted that Symfony does everything what I need in the way I need it and now rather try to extend it with smaller libraries. That's better for the ecosystem and my work and countless hours aren't wasted for nothing. 
You do know it's fairly easy to just lie on Reddit for upboats, right?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Envrin/apex/.../**sqlparser.php** (master ‚Üí e8ebf7b)](https://github.com/Envrin/apex/blob/e8ebf7b3b1f2deb59e19798ca3a6f18005b83cfe/lib/third_party/sqlparser.php) ---- 
I hated when Composer tried to upgrade me to an unsupported version so I created this meta-package to avoid them. Hope someone else finds it useful!
This isn't really PHP specific but, I currently have a website that is just a traditional server side website (symfony / twig). I would like to look into migrating to a SPA but would like to do it one page at a time. My sessions are currently cookies that are http only (and need to remain that way for the time being). What is the best way to handle setting a http only cookie using a SPA since javascript cannot? What I was thinking was checking if the user has the session cookie in nginx. If they have the cookie load the SPA. If they don't send them to the backend which will pass back Set-Cookie header with the session cookie and a 302 to redirect to the same page. The only problem I see is doing a 302 to the same page. I am under the impression that is not necessary correct. The other way would be to load a page in twig that has javascript or a meta refresh that redirects the user to the same page.
 I was thinking how to reply to this, as it did get me down a little. I start second guessing myself, and thinking maybe I really don't know what I'm doing. Thankfully for me though I have this absolutely amazing spouse, we've both been through some rough times in life, but we have some absolutely amazing plans for the future. In order for those plans to materialize, I have to stay strong, so I will do just that. So here's my answer to you. If you're so confident that Apex is a pile of garbage, then you're more than welcome to show me up, and you will have that chance in the near future. I have to take a couple weeks off to concentrate on another project, then will come back to Apex and finish it. Once completed, I fully intend to cause some controversy online, with hopes of sparking a developer competition. There's a good chance I'll be able to get some sponsors to provide cash awards via bitcoin. Say $2000 USD via bitcoin to the winner, or similar. Individual entrants only, we'll somehow get some judges everyone is comfortable with and knows are unbiased. They will come up with some project specs, we will all get them at the same time, and have 24 hours to complete the project using whatever language / framework we want. May the best person win. What do you say? 24 hours of your time, a nice say $2000 USD payday, plus you get to showcase your skills and show everyone on the internet how much of an idiot and novice I am. Who knows, maybe Apex will get slaughtered, but only one way to find out. Up for it? 
Yeah, I don't get the hate at all, and it's actively being developed. Let's keep being dinosaurs, shit pays the bills. 
I do, and that helps ensure the currently-installed versions are compatible, but it does nothing to limit what `composer update` tries to install. Sure, I could manually `require` every single indirect dependency as a solution, but I don't want to manually manage versions of things I don't directly depend on.
Sorry, I don't understand why you're running composer update on everything in your project like that. That seems... irresponsible.
Why did they comment out the `pg_escape_string` line, the only thing keeping them safe?
It probably didn't work how they expected (some how...?) so better comment that out and do what they know works!
India
You missed the plain text passwords too. Wheeee!
If you're concerned about security then running composer update on an entire project with a lot of dependencies is the *last* thing you want to do. Perhaps I'm a little over-cautious working with primarily HIPAA clients but I don't like this trend of composer being treated like the node.js community uses NPM. It's dangerous.
Oh I saw the plaintext password just fine. The lack of a WHERE clause, however, I didn't not even pay attention to! Wow. WOW.
Please dont generalize Indians here. Shitty coders exist, and they are worldwide. Everything depends on client's budget. There are brilliant coders from India but they wont charge $2 / hr!! So in the end you get what you paid fo, nothing else.
As /r/OMDB-PiLoT said, that is not indicative of India itself, just the particular company used here. My experience with offshoring for quick and cheap results in this kind of work, but that is not an indication of a locale as a whole. I've worked with some very brilliant people and teams in India and many countries. This particular company turned out to be, as I feared, a churn and burn shop. At least for the team they've assigned to this project. 
Play stupid games, win stupid prizes. 
Is admin a single row table?
wait, wtf, is admin its own entire table?!
`$old=$this-&gt;adminDetails();` `if($old['password']==$oldPassword)` &amp;#x200B; The vault is CLOSED! Booyah, let's go grab a beer my leet brothas.
That's true, but as a first approximation rule of thumb it's not a bad one to live by - just be prepared to change opinion on evidence. Having said that, some of the worst code I've every had to handle comes not from the third world sweatshops, but young western guys who've been given a *little* bit of training in programming then taught themselves and now believe that they're the wizzardiest wizard on the whole planet. Who needs Symfony or Lavarel or anything when you can roll your own 'superior' framework and show off how much smarter you are to than rest of us. 
I don't - I run `composer show -om` to see which dependencies have updates and then I manually `composer update` them individually (or several in one command). In the examples I've screenshotted, I'm trying to update just the Symfony components used in the project. But only some of them are direct dependencies listed in my `composer.json` file - some are required by other dependencies. I still want to upgrade them though, but I have no constraints telling Composer "hey I only want the LTS versions". I therefore have three options: 1. Install the non-LTS versions (no thanks!) 2. Add them as direct dependencies which I then have to micro-manage (no thanks!) 3. Use something like this metapackage to ensure that my current dependencies never try to install a non-LTS version (yes please!)
I'm working on a project for my wife's client at the moment. It's my first time working with WordPress, and with an outsourced codebase (also Indians - based in Jaipur, apparently). Holy shit, it's awful. It's like somebody skimmed a few pages of a "Teach yourself PHP in 24 hours" book from 15 years ago and then set to work. It's just as bad as what you've posted above, with HTML, CSS, PHP and jQuery all mashed together in the same file, each file is thousands of lines long and there are SQL injection vulnerabilities all over. At the checkout they actually send the item prices in a POST request instead of pulling them out of the db, so you can set your own prices if you fancy because the backend doesn't do any validation on them anyway! You get a confirmation email with a URL ending in a 5-digit number, which you can just increment or decrement to see another customer's name, contact details, billing address and order details. I put together a list of about a dozen things like this he should be really concerned about. I refused to work on it unless I was allowed to bin the existing code and start over, and be paid accordingly. 
I am doing an ICT study. Most kids in my class program this way. The worst off all the programming teacher teaches them so. Now the most kids going to learn laravel but the do it wrong the don't read the documantion. They also don't understand the basic of composer what it is what it does. I am really worried that I got do deal with bad code. Does somebody has tips for me what I can do. Because when i say to the kids it's wrong code they say it works.üôÉ
I don't think it's an India thing. I live in Poland which I think is another great destination of outsourcing and shit like this is real in the vast majority of Software Houses. I'm not going to defend anyone. Just want to give a glimpse of how it looks like. The market is a bloodbath. Who was keen emigrated. Who can, works remotely for North America and the United Kingdom. The foreign and domestic companies that need in-house developers for the last years were paying above market average to get the best ones. PHP wages are 3 times higher than 5-6 years ago. This makes Software Houses operating on the verge of profitability. Not to mention that domestic software houses offer wages below market average. Ambitious people usually left and the recruitment process is being held by people who stuck there and live in their delusional world. Well, I don't want to say that all Software Houses in Poland are total shit, but... you got what you pay for.
That's a fair question OP. What was the hourly rate that your partners pay for this? :-)
The problem is not offshore work, the problem is CHEAP offshore work 
Looking at the code, I don't know what $this-&gt;conn is? Is UpdatePasswordData a method of a class? It looks to me like they copied this from somewhere else and just got it to work. The commented out line is probably some code for debugging purposes.
Looking at the code, I don't know what $this-&gt;conn is? Is UpdatePasswordData a method of a class? It looks to me like they copied this from somewhere else and just got it to work. The commented out line is probably some code for debugging purposes.
Looking at the code, I don't know what $this-&gt;conn is? Is UpdatePasswordData a method of a class? It looks to me like they copied this from somewhere else and just got it to work. The commented out line is probably some code for debugging purposes.
I'm not really sure what your problem is. Between the lock file, version constraints in your project composer.json, and setting the minimum-stability option should be enough to cover you? Symfony &lt;=3 you can install with the `symfony` installer where you can specify the version you want which composer will take into account the version constraints. Are there some packages slipping through to versions they do not work with?
`$this-&gt;conn` is probably the Postgres database handle. OP omitted a lot for brevity.
&gt;And the &gt; &gt;WHERE &gt; &gt; clause sorry but i don't see a 'WHERE' clause in the example
I may have phrased that poorly. The absence of the clause is the problem :)
The purpose is similar to `symfony/lts` or `roave/security-advisories` where I essentially want to blacklist certain versions of dependencies. Here's an example: I have a legacy Silex 1 application which requires `silex/silex:1.3.6`. This package in turn requires: - pimple/pimple: ~1.0 - symfony/event-dispatcher: ~2.3|3.0.* - symfony/http-foundation: ~2.3|3.0.* - symfony/http-kernel: ~2.3|3.0.* - symfony/routing: ~2.3|3.0.* For `symfony/http-kernel`, I don't really care what version I get as long as it is supported. `3.0` is not supported, so I don't want that. This metapackage ensures that I will never get it. I don't directly use `symfony/http-kernel` in my code so I don't want to list that as a direct requirement of my project. Composer is bringing that in automatically for me without regards to any preference I might have. And it's not just that one Symfony library that's an indirect dependency - I have several. With this metapackage, regardless of what project I'm working on or which components are direct/indirect dependencies, I'm assured that I'll never get an unsupported version. Without this metapackage, Composer would put me on `3.0` and then say no newer compatible updates are available. But `2.8` actually has fixes for security issues found in `3.0` that I'd want. This is similar to how `roave/security-advisories` ensures that I cannot install an insecure version of something without me needing to micro-manage those constraints myself in my own `composer.json` file.
Don't talk about quality. They don't care about quality. Highlight the security risks, the loss of data, the end of the company...
What I said to them was "If you got this for free, you still got ripped off". He replied that they owed him something so he actually didn't pay anything for it. He asked me to make a list of what they need to fix and I told him it would be impossible. The funny part is, I asked him for the requirement specs he originally sent them. It was essentially 6 screenshots of the reports he wanted, secured under an Admin dashboard. So essentially it took me 10 minutes to add Symfony's ROLE_ADMIN to the 3 users we wanted with the permission, check for the existence of that permission and display a dashboard link if it exists, then mockup the first report (also secured by the ACL permission) showing live data. The work will be completed this week when I have a couple of hours and it will be properly tied into the existing framework, security, and utilize Doctrine (really simple report queries; one table each and with a date range and pagination. Not exactly rocket science )
That's horrifying.
"Can you fix this?" "No." Been there, dome that. Some clients come back for a rewrite and some don't. 
The security was the first thing I lead with in our convo
I'm not sure what composer as a dependency tool has to do with risk management and compliance, though. Regardless of how or what tool you use, you still have to consciously make the decision of whether you trust other people's code, vet their code through review, or write it yourself. I'm assuming your advocating that nothing gets updated unless it's needed which requires a code audit of the changes since first vetting the package? What do you do as new vulnerabilities get discovered? Wouldn't every new vuln warrant an audit of every package? 
if it's anything like `mysqli_real_escape_string` then it shouldn't strip slashes and stuff.
&gt; For symfony/http-kernel, I don't really care what version I get as long as it is supported. 3.0 is not supported, so I don't want that Either there's some dependency you have that just doesn't play well with `symfony/http-kernel:3.0` or they fucked up the requirements for `silex/silex:1.3.6` You do use it though, unless I am mistaken with Silex, http-kernel is pretty much the heart of the app. It sounds like it works though. Really should be resolved with the other packages setting their dependency requirements but if they're not yours that can be somewhat of a pain in the ass and take a while or not at all if they're abandoned like silex/silex.
Yep exactly! And you're right, ideally others would keep their constraints up-to-date, but that (understandably) doesn't always happen. At least now I have an easy way to always get LTS or current versions without needing to whitelist those versions manually.
Composer, as with all package management tools, can become a spider-hell of dependencies. As we've seen in recent issues with NPM, one person can insidiously weasel a small package into thousands of widely used repos for malicious purposes. Obviously there's a point where you have to call it "good enough", but I make it habit to independently verify at least the changes in my direct dependencies - and especially take note of any new sub dependencies they have added.
It doesn't strip slashes, it escapes stuff but that should all be transparent.
There are crappy coders everywhere as crappy requirements too. Did the OP included in the specs about symphony integration, a minimum style guide or a base css to base on, non allowance of using proprietary framework, etc? I've worked with terrible indians coders in the past, I know how frustrated the OP may feel, same with romanians, spaniards and USA coders as well. I really think it's a cultural *plus* a budget issue. Good coders are not cheap and are hard to find. 
Ok so your nooooooo was more about bad error handling than using the shutdown closure. 
of course but when you read article it goes like this 'but everyone‚Äôs first database connection in PHP looks something like this:' and rest of it is simply big no no no 
Argument count didn't match. I think it needs an object of the connection so it knows the char set in play When they got the error or warning, couldn't be bothered to look at the docs and said fuck it, this is fine
include is not a function
You folks react as though nobody ever seen /r/phphelp
PHP mirrors (outside the US) are run by third parties. Sometimes those third parties have issues.
**Phata Hook** https://gitlab.com/phata/hook A minimalistic hook library you can build your moduliazed system on. Allow you to declare any php `interface` as a hook. You can add any number of classes (i.e. module) to the registry, then invoke them based on he hook (i.e. interface) you want invoke. The registry can be safely serialized / unserialized. Hence it is cachable and need not be reindex every run. Class implentations are drawn from container and thus can be reused. 
Sure, but the cheaper you go the more likely you are to get someone trying to do minimal work for maximum return...
Meh, it's not that crazy. If the sites getting heavily traffiked your just as likely to get caught in a widespread framework vulnerability. Its simple and easy to read.
&gt; they decided to outsource to an offshore company to do some admin tools/reporting that I didn't have time for. I stressed that this was a bad idea, especially given the reputation of offshore work and my personal experience with the utter crap they produce I once inherited a wordpress site built by an outsourced company that had a PHP endpoint called `download.php`, which ran a raw `file_get_contents()` from user input. The best part was this was on an extremely large and popular shared WP host that shall remain nameless. Needless to say `../../../../../../../etc/passwd` as a `?file=` query param gave me the server's /etc/passwd file. I died, rolled over in my grave, and then came back to life dumbfounded.
There is cheap and there is dumb cheap , I personally have worked with companies overseas (I'm outside the us) and yes I can do cheap simply because I have the advantage of lower cost vs the exchange of the dollar, but I can not beat the guys from freelancer.com doing stuff like your post showed. While I understand someone looking for development on the cheap overseas, that's no excuse to not have a proper review of the company and the code they produce
Because it didn't work and they couldn't debug it. I can even tell you what happened ‚Äì they wrote `set password="..."` and expected it to work like it does in MySQL. The SQL standard says that a string wrapped in double quotes is always an _identifier_ such as a column name/table name/etc., but MySQL winks at it and says "if it does not represent a known identifier, I'll treat it as a _string literal_". ^(So does SQLite.) Postgres does no such winking and only accepts string literals in single quotes. So their query basically never worked in PG.
Please don't besmirch the word "quality", as the above code lacks anything in common with it.
Can someone show me what the proper version of the code above looks like? 
good bot
Boohoo we hired a bunch of idiots to make an app and they messed up. No shit, go rant somewhere else.
It is entirely possible to be _critical_ of the choices a particular technology makes, and _critical_ of the author of a particular technology without being a _hater_. You don't have to drink the koolaid and get onboard with everything anyone ever says about a particular set of tools. I use, and actively advocate Laravel - and I think the fact that it doesn't follow semver is clown shoes, pants on head, completely without justification and hostile to it's user base. 
You're saying because Symfony is not perfect Laravel is just as good? You're advising someone who doesn't know any different to learn Facades over proper DI? Or that fucking abortion that is Eloquent over a proper mapper abstraction like Doctrine? Way. To. Go.
1. Hooks should have an execution priority 2. Hooks should receive parameters. Eg: give me the list last 5/10 articles and display it a dropdown/list. 3. When using hooks you ask the library to give you the result of the hook. There shouldn't be 2 different ways to call a hook. Also, does \`map()\` return an array? IMO, all hooks handlers should receive the \`carry\` as parameter and be able to stop the execution of the rest of the handlers. For example, you can have a hook handler that queries the database and generates an HTML and another that caches the output which may decide to stop the execution of the stack and immediately return the cached value. So hooks should behave similar to PSR-15 middleware.
It's a matter of personal taste, but maybe the limitless theme? [https://themeforest.net/item/limitless-responsive-web-application-kit/13080328](https://themeforest.net/item/limitless-responsive-web-application-kit/13080328)
Some things should be common sense to a developer with a shred of experience. Like hashing passwords or not putting user input directly into the database.
Good job well done
Yes! Such a great addition !
Agreed, no excuse. The trouble is that many companies look at development like a commodity; that it's all much of a muchness and you just choose what you want to pay and put up with perhaps a little inconvenience for the cheaper ones (language, timezone issues). Then we end up with the type of situation that OP is in, time and time again.
Absolutely. Many businesses just don't know where to set their limits though. Just what is "too cheap"? You need someone within the company who knows their stuff and can keep on top of it, and move away from "too cheap" quickly, before too much damage is done. OP should have been in that position, but seemed to have been overridden because "cheap" was just too attractive to the bosses. 
This is huge! I'm excited!
GDPR has opened a lot of people's eyes to the seriousness of security, because it means a real threat of punishment if you don't treat people's data with due diligence and respect. 
Will I speculate too much if I say this is the feature what we all wanted to see?!
OMFG &gt;**Software Requirement** : xampp , notepad++
Who wouldn't want the _ability_ to use strict types whereever they please, but the _flexibility_ of not using it for whatever reason? I, for one, embrace _any_ improvement to the typing system with open arms!
It's happening!!!!
Soo .. in the original proposal, that didn't pass, `callable` was a valid type for properties. In the new proposal, they explicitly exclude this. &gt; // All types with the exception of "void" and "callable" are supported Anyone know why?
xampp and notepad++
To be honest I don't know why everyone is so happy about this. Maybe I'm wrong but the end goal of this is to let some piece of code safely modify the public property of an object. I can't figure out how this could be good code. Am I missing the point?
declare as private/protected and use setters/getters/__construct/build
Hell, I'd even add a LIMIT 1 out of sheer habit...
There is no point for typed properties when they are private/protected because their values have to pass through some method argument type check.
Performance optimization oppotunities. But I agree - read/write only definitions on top would be great addition.
That is tru only for private, right? When declared as protected you still can mess something up.
?
Not everyone likes the getter/setter design, and would like to skip that entirely and have direct access to the variables with type restrictions. I see this as a nice step forward in PHP and hopefully it gets accepted. 
I'm dreaming of final properties. ```php class User { public final int $id; public final string $name; public function __construct(int $id, string $name) { $this-&gt;id = $id; $this-&gt;name = $name; } } ``` And voil√†! Immutability! (sorry for Java influence) 
I've been working with C# for the last two years and have just started to work with PHP again. The lack of things like this is quite jarring coming back.
Did this panel cost 5$ or some shit, lol 
By far the worst offense in that bit of code. 
I asked because my code looks like the code in the original post... after seeing yours I have a lot of work to do
The next rfc will be supporting the decision to change \_\_construct to void :D
Thank you, I can't hit the upvote button hard enough to express how much I agree with this. Using final by default is the most beneficial piece of advice I ever heard to improve my object design. I try to only create final or abstract classes and to use abstract classes only to provide concrete classes with default injection. &amp;#x200B; For the mocking point it was a pain at first, then I realized my tests are way better without mocking those classes. They do not rely anymore on how the tested object uses the injected object methods. For example when a tested object requires and uses a `ListOfSomething`, I don't have to change the tests of the tested object when the list of something method changes. Mocking interfaces is enough.
Immutability is something really healthy, it avoids a lot of issues, make your code strict and predictable, I like this!
After reading his arguments, I'm still not convinced final is a good design decision. It keeps from inheriting code, for the wrong reasons. I won't be using final, and that's.... final.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [localheinz/repository/.../**SrcCodeTest.php** (php-library ‚Üí c75e788)](https://github.com/localheinz/repository/blob/c75e788e40162c061c7044883ed4845c419e26f2/test/AutoReview/SrcCodeTest.php) ---- 
Can someone please ELI5 dependency injection and inversion control with good scenario examples to support it?
I think it's just poorly explained. Using `final` simply makes the composition over inheritance an absolute necessity which _might_ lead to a better overall design. Personally I use `final` only for concrete implementations of a contract - in those rare cases when I still need to extend the behavior, it can be better achieved by using a decorator instead of using inheritance.
Software engineers prefer programming constructs which visibly explode when their software tries to enter an unexpected state, the sooner the construct explodes, the closer it will be to the original source of the error, and the less likelihood it will have had of propagating down the stack and causing even more complex problems. Typed properties (and all static typing in general) are a way of telling the programming environment what your expectations are, and thus giving it the information to add checks to say when those expectations are not met.
I agree with this. But I don't understand the use case of safely setting the value of an object public property (what ultimately allows this rfc)
Dang. Name them! &lt;‚Äîj/k, j/k
If you're looking for immutability, Java is not the place to draw inspiration. The `final` keyword in Java only means that you can't *rebind* the variable, not that you can't *mutate* it. Huge difference. You're looking for something like C++'s `const`.
I can see it... A future in which we don‚Äôt need to scatter PHPDoc all over our code just to enable autocomplete functionality in IDEs!
I believe she's saying that having a type on a private property can protect you from bugs in your class methods (eg assigning the wrong type of variable to a property)
Didn't see this! That's a good point thanks.
I didn't mean to suggest talking about syntax, just the concept of strongly typed languages.
That's cool but nobody ever do this in real life
Anyone catch this in the first example? ``` class Example { // All types with the exception of "void" and "callable" are supported public int $scalarType; protected ClassName $classType; private ?ClassName $nullableClassType; // ... } ``` Since when is there a `ClassName` type? I couldn't find anything else about that anywhere
There is fixer for this: https://github.com/Slamdunk/php-cs-fixer-extensions/blob/master/lib/FinalInternalClassFixer.php I use it happily for years :)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Slamdunk/php-cs-fixer-extensions/.../**FinalInternalClassFixer.php** (master ‚Üí f2d819f)](https://github.com/Slamdunk/php-cs-fixer-extensions/blob/f2d819ff70cc098f68cd2eefd3279c2f54e0ccad/lib/FinalInternalClassFixer.php) ---- 
It's just an example showing you can type a property to be any built in or custom class/interface.
I sure hope so ;-)
Fair enough. But it's not just syntax- it's the *semantics* of the features that also match Java's. My original point was that PHP is becoming more and more like Java, overall. The work on the type system is simply part of that. The fact that other languages also have types is only tangentially relevant. PHP is becoming a poor Java clone.
I builded a small "no-framework" using only PHP packages, [here](https://github.com/petronetto/no-framework), need some improvements, but I believe that's enough to you get the basis. In addition, there's [this good article](https://kevinsmith.io/modern-php-without-a-framework) that provide a good basic entry point.
That's already allowed. You could still use getters and setters.
There are lots of cases where you might want to set properties directly, just because the current prevailing style is that you should spam get/set methods, doesn't mean it's the only way, or the right way in all circumstances. This RFC does two things: First, it allows you to document your types without relying on docblock statements, and second, it enforces those types where they are used. It will apply to private / protected, as well as public properties. 
Ohhh that makes sense, I was thinking it was some new proposed type you could store a class name string in that would get validated as an instantiable class
&gt;First, it allows you to document your types without relying on docblock statements, and second, it enforces those types where they are used. I agree with all this but I just can't see why it generate so much enthusiasm.