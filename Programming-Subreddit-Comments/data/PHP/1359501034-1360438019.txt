or 6 beers too few :)
Well speed (look at the benchmarks on their site), especially callgrinds. I guess it is a very niche system (like Slim and fat-free are). Obviously they are not going to win over people from Zend and Yii with whole PHPixie consisting of say 10 classes? Rather it is something to use if you are doing sites that do simple things, like for example messge bords, image sites etc for which Zend would be such an overkill
&gt;If you are using editor that you never used and it has tabs set to 8 so it overflows the lines, have fun editing your code via mobile SSH without going back out and changing tab settings. First of all, any kind of code editing on a mobile device is going to be crappy, no matter what style you use. I hate mobile devices in general, as far as any kind of productivity is concerned. Second, even so, there's something called scrolling. It allows you to see stuff that can't fit in the tiny screen. &gt;Or maybe you can explain to me how you will tab your code on a mobile device without tab button? That's not the only thing I find lacking about mobile devices, but I'm sure you can find a solution to a tab key if you insist on putting yourself in the least conducive environment imaginable to do code development. Are you actually using SSH without the ability to do autocompletion? Yikes. &gt;And if you set your tab width to 12, what will you do with line width limit of 80/120? I don't agree with line width being a requirement in code formatting standards. I do think developers should be reasonable about their line lengths and the number of indentation levels, just as a matter of general readability. I think character counting is overkill. &gt;Furthermore you obviously never seen .htaccess or other non code files that need to align with 'tabbed' indentation it simply will not work so you will end up using spaces for those either way. Again, I don't know what you're talking about. Unless you think I'm advocating for tabs *within* the line content, which I'm not. I'm only talking about tabs at the beginning of the line. And, again, I've never had any issues with that in any of Apache's config files. &gt;If you are working on a project that has files with random space length then it's not really a space problem. It's a developer problem. But it sounded to me like your complaints were mainly about developers failing to use tab indentation correctly. I'm just pointing out that it goes both ways. &gt;Anyways, like I said there are drawbacks and edge cases when using tabs and sooner or later you will see them. I've been using tabs for indentation in web development for about 10 years now, and only place where I've actually run into any trouble was when, for whatever reason, I needed to write code in an HTML textarea, where browsers tend to reserve the tab key for other purposes. One Firefox extension later, and that problem is fixed.
You are using simple examples, try multiple conditions that span over different lines. 
I don't think its a strict requirement for composer, there are numerous autoloader styles it can use and generate, though PSR compatible sources are recommended. However creating a non PSR compliant product at this point in PHP history unfortunately doesn't make any sense. Honestly I have my own in production framework quite similar to this except its built around PSR and uses some external libs like twig, aura.router, swiftmailer, etc, all pulled in via composer. I have a hard time understanding the purpose of a microframework lib when it makes it difficult to integrate with other libs and the PHP ecosystem as a whole.
How about you show me an example of it breaking, because I can't think of one. I've always used tabs for indentation, and the problems you're describing just don't happen.
Hm well I know for a fact that Kohana never accepted PSR in full too. It's not that universal. If I feel like it I might actually submit a PHPixie issue to github asking to add composer support.
Not *quite* what I was looking for, althought they will come in useful and I will get them bookmarked, I'm more looking for a learnig environment.
Just do conditional logic with multi line alignment.
I never knew that existed. Could get messy when trying to learn about MVC and stuff (I'm trying Laravel, finding it a tiny bit overwhelming to go from no-knowledge to working site). But definitely useful.
So.. like this? &lt;tab&gt;if ($a == $b &amp;&amp; $c == $d &amp;&amp; &lt;tab&gt; $e == $f &amp;&amp; $g == $h) &lt;tab&gt;{ &lt;tab&gt;&lt;tab&gt;doSomething(); &lt;tab&gt;&lt;tab&gt;doSomethingElse(); &lt;tab&gt;} How that's displayed at different tab widths: 8: if ($a == $b &amp;&amp; $c == $d &amp;&amp; $e == $f &amp;&amp; $g == $h) { doSomething(); doSomethingElse(); } 2: if ($a == $b &amp;&amp; $c == $d &amp;&amp; $e == $f &amp;&amp; $g == $h) { doSomething(); doSomethingElse(); } Seems fine to me. Or did you have something else in mind?
I'm not going to read through all that, tab is required to use SSH for every command? Yeah okay.. anyways this is a waste of my time. 
Yup, and I don't foresee the vote wielders of php-internals ever approving such a tool either. However, for a new language like Go, I think that it was a very progressive and awesome idea. It's the sort of evolution that I'd like to see more of in programming languages, things that make _development_ either easier, more efficient, or safer (with respect to bugs). Language features themselves are important but at the end of the day, some person is going to have to sit down and write code, and in a team environment, I believe it's imperative that coding styles are as consistent as possible.
My thought behind it was in case they wanted to reuse the same handle for additional custom queries (without creating a separate one).
This is, IMHO, the best approach. You hack and hack and hack until you get frustrated enough to look for help. At that point, you stumble upon frameworks! By this time, you realize the benefit yet still know enough to deconstruct and understand it!
Is Silex actually easier to learn than Symfony? It seems (from my vantage point as someone who doesn't know Symfony2 but often thinks of learning it) that it might be something that you can drop down to from an understanding of Symfony, rather than the 'simple version of Symfony' that would be nice for beginners.
composer is to make your code like a module e.g. ruby gems. like someone would install dracony/phpixie and it would be updatable and if it ever did get dependencies, even optional ones, it would be easier to keep track of. granted composer is still kind of clunky but its getting better.
Any chance you can clarify what he said was wrong on the the 20 files being loaded instead of one? 
You're definitely not in the minority. Symfony does have a really steep learning curve and it does keep many people away. As you become more accustomed to it and everything it has to offer your code will become less verbose and more maintainable. When you're just starting out though spending all your time in the documentation to even accomplish easy tasks is no fun but it pays off in the end.
What i find can help a lot is to follow the code path of an existing framework to see how they tick. Start with good ol' index.php and trace the code through to a controller of your own. Some frameworks are quicker then others to do this with. ... if your gonna do it with the Zend framework make sure you clear your schedule for the next few days first.
I collect error messages in an $error[] but run through all the tests. If $error is nonempty, I have one or a list of problems to show. Generally, you avoid nested structures with return statements (like throwing exceptions) and sometimes I use a while(1) with break / continues.
Can you elaborate on what you mean by "more *stable*"
I'm yet to work on any brochure site that ends up being that basic. If only they all were. I always find a CMS will fit a requirement 90%, but not completely, so one has to rely on a number of poorly written, often buggy 3rd party modules to get the job done. That or rolling your own modules to recreate the wheel (again). After almost a decade as a PHP developer I've recently made a rule to myself that I will never again accept a job that involves Drupal or Wordpress, no matter how simple it seems on paper. This was due to recent head banging experience with "services" in Drupal. Further I have the philosophical view that developers should be developing solutions and content creators should be creating content. I'm yet to work on a project where passing on some development responsibilities to content creators (aided by a CMS) results in either time or money being saved. Re the OPs question, I say go for it. Use this simple site to get familiar with the framework knowing that it will take longer than you think it. That time you spend is investment so the next site you can throw together faster. One point that is often overlooked is maintainability. CMSs by nature have poor separation of concerns, they store way too much configuration in a database. This makes any form of automated deployment, decent version control, automated testing and continuous integration an absolute nightmare that one can always get working but with so many hacks you start hating yourself - Drupal, I'm looking at you. It seems like a wank but really learn "best" practice and follow it. It will make you a better developer and cover your ass when you start working on bigger projects when downtime is not acceptable. I used small projects while I was cutting my teeth to get experience with these practices on the clients dime.
As a Drupal developer of 5 years, you summed up my feelings very nicely. I'm very competent writing custom modules and handling services and things, so I'm not too worried about banging out a 15-page brochure site for the local theater or the Corvette club or whatever. Throw together an event calendar and a news listing and teach a few people how to get down and dirty. I hate the way WYSIWYG's work, but that doesn't get better by enough by going to anything else. Anyway, I'm recently learning Symfony and very happy because of the prospect of being able to do bigger projects without all of the hacks. I run a big administrative site that handles a lot of reviewing and input from at least four different perspectives. It's been a mess to un-tangle and re-tangle to include new features every year and hand-writing my own testing implementation to fit my own version control implementation has been... Well I'm actually doing things in a pretty standard way and yet... I won't every approach something like this in the same way again. I can't wait to understand Symfony. When I was in high school I wrote my own framework though I didn't know that was what it was called at the time. It handled simple routing things and provided me the ability to have threads and permissions and handling sessions and user accounts and good password salting and hashing and the ability to update all of my features as I went to keep up with the latest standards. I was really proud of it. How I drifted from those days I will never know. I long to be back in that world. That said, reading some of the stuff elsewhere here I wonder if I shouldn't explore CodeIgniter a little bit. I do love what I've learned with Symfony thus far though I only have the basics down. It's been really hard to find a great learning resource that doesn't feel disjointed and hard to follow because of a thousand asides and tips interjected. I guess maybe it's just my learning style or that I'm not a great reader but it's been hard to learn. Still, I want to know what is the most flexible and powerful and I definitely want dependency injection handled for me, etc. I appreciate your post. That's a lot of typing to say that, but... there it is!
Create [composites](http://en.wikipedia.org/wiki/Composite_pattern) for each question type. Each composite instance should be aware of what it should provide as questions, and should define rules about what to provide in response to an answer. The advantage to this is that if it is designed properly (interfaces must be kept uniform), any question type should be able to be used interchangeably with any other.
It's not massively out of date. There's only 2-3 minor parts that need to be altered to get it working with 2.1 and there's not many other tutorials that go into that level of depth. Your second link even features it prominently as a recommended resource.
If there is I would also like to know.
Because less files are not necessarily better, and opencart and symfony aren't really comparable anyway. Symfony is architecturally different from opencart, and prioritizes things like flexibility and extensibility. In other words, the number of files are there for a reason, and it's not like they bring nothing to the table. To ignore that is dishonest and shows a lack of critical reasoning skills in the author. 
* 5.3? This framework does not use *any* of 5.3 features. * Autoload? With no PSR-0 compliance?
[PHP Master: Write Cutting-Edge Code](http://www.sitepoint.com/books/phppro1/) Title sounds pretentious, but it has mostly good content. Will help you update your practices in practically every area of PHP, not just application design.
Except the 2-3 minor parts that are out of date can translate into a good few hours of guessing and searching through stackoverflow. Better to start off on resources that are current, if you're using it to learn the framework. 
Suggestion for the people complaining about the plural/singular language bits: Separate pluralizing, singularizing, and other word/symbol transformations out in to an inflector class that can be overridden. This way, if someone really wants to localize these things to a given language, there's nothing stopping them. It also makes your ORM class marginally less complex as you're reducing its responsibilities. This also has the side benefit of being reusable in views, which some people may find useful.
What about people on shared hosting that can't run CLI? making composer mandatory is a hard blow for such users
PHP Academy. https://phpacademy.org/
&gt;Is there anything wrong with creating a website and not using a MVC framework? Not necessarily, but they do provide you with a nice structure which would help your projects' maintainability. Additionally, frameworks also provides you with a lot of components, so there's no need to reinvent the wheel. &gt;From quickly looking at the documentation for a few frameworks, they look very confusing to me. Do you require an explanation of how they work? If so, here's a very brief description: 1. All traffic is routed to an index.php via the use of a rewrite engine (e.g. .htaccess). 2. In the index file, the application pulls in its resources and is executed. The URL is passed to a router, which is responsible for matching the URL against a collection of patterns which determine which controller and action should be invoked. 3. If a match is found, the result is then passed along to the dispatcher. The dispatcher is responsible for loading the controller and (depending on the framework) executing the correct action method. (In some frameworks, the controller itself is responsible for executing the action method). 4. The action method executes its business logic, and passes its results to the view, i.e. a template engine, which is then displayed to the user. If you got additional questions, go ahead and ask. 
I was talking about *my* preference for indents being the same width. I agree that tab width is personal preference, but for the sake of argument, if everyone has indents the same width, if I pop over to look at something on a colleague's screen, it'll look as I expect it to, and vice versa. All arguments about consistency work in reverse, too. If everyone used spaces, there'd be no consistency problems either. Varying tab widths can cause problems when someone opens a file in a hurry, doesn't notice that it's using a number of spaces equal to their tab setting, and pops in a few new lines which are then indented badly when opened by someone else. Of course, you can exchange the words 'tab setting' and 'number of spaces' in that sentence and reach the same conclusion... Sure, using either tabs or spaces exclusively would solve this, and I'll gladly adopt either one if it becomes a standard - I only have a preference at all because I've spent so long working on projects which use 4 spaces. Referring back to the article, *it really doesn't matter* as long as everyone on a project outputs code files written to the same guidelines.
To expand on Nicoons description a bit, here is what MVC is basically about: segregation of concerns. Your M stands for Model. Models represents elements in your database (or wherever you store your data, it is not impossible to have a model that uses a textfile as basis). The model does everything that has to do with retrieving and saving data. Also with massaging data (i.e. making unix timestamps human-readable etc.). The controller is your core business logic. The controller does everything that does not have to do directly with data. In many frameworks it is also the mediator between the model and the view. The view finally is responsible for the display. Here the html/cvs/rss/whatever is created and the data from the model (probably handed over via the controller, as mentioned before) is displayed in whatever way you want to. What this gives you is a very clean structure and therefore an easy environment to work in. Your table not displaying correctly because it is not closed - well, that must be a bug in the view. That date format not being saved correctly? It's definitely a problem in the model. The user session randomly killed when you click on "save changes in shopping cart"? Probably the controller that is borked. Everything in it's place and a place for everything. You don't HAVE to use MVC, but it does in fact help a lot.
What? Symfony compiles and caches them for you. In development/test, it's when the file changes, in prod, it caches it once on deployment and then not after that.
You may want to try out something like Yii's code generation (Gii). You can give it the name of a table you create in your DB and it will generate the models, controllers, and views for CRUD methods. Not the only thing you need but it can be a great way to understand what's happening when learning MVC. I've always found that examples are the best learning tool but you either find examples that are too complex to come to grips with or so simple they leave you asking the question, "But how do I accomplish any more than this?". So maybe playing around will help you understand it, and if not, you may find that your friend's site is simple enough to be 80% code generation and then you just customize what's generated. The reality is, if you don't know either, raw PHP is going to take you more time than learning how to use a framework. What I can build in a day with something like Yii, Concrete5, or even CodeIgniter would take me at least three times longer in raw PHP. Honestly, I don't even know your project, and I still think I'd recommend Yii with a UI extension like 'bootstrap' to make your life easier. You'll shift the difficulty up front but you'll go much farther with it once you start to get comfortable. If you really don't know this stuff yet you are absolutely best served by shifting the workload off you by using stuff made by better developers. Here are some things I talked about: http://twitter.github.com/bootstrap/ http://www.yiiframework.com/ http://www.yiiframework.com/extension/bootstrap http://php.net If it seems like I'm being repetitive it's because I'd like you to avoid making a mistake I made often in the past. That mistake is thinking, "It'll be easier if I do it from scratch".
Using MVC, at least within the PHP community, will get you a long way as there are many frameworks and tools built around this architecture. But this is by no means the only approach you can take. This is a great write up on some alternative application architectures: http://aspiringcraftsman.com/2007/08/25/interactive-application-architecture/
If you don't have much experience with PHP, and it sounds like you dont then using an MVC right away, or even building a full front facing website is probably not the best place to start. Building good code in the MVC pattern requires understanding of not only the particular MVC framework but also why the rules you're abiding by are important. Some of the best advice I got some years ago was to simply build a project from the ground up in OO PHP. I learnt very well why the MVC pattern is important and moving into full MVCs and their way of doing things after that made alot of sense
did you mean to reply to grandparent post? I didn't give any example.
Composer has been added to PHPixie now =) 
I'd say it depends how substantial your application is. For really small things, it might not be necessary to use a framework or an MVC pattern. It is very bad practice, and frankly quite stupid, to not use a framework for larger projects, or projects that you're going to have to maintain for a while, or projects that someone else has to maintain; remember, you should always write code as if the person to maintain it is an axe-wielding murderer who knows where you live. That said, even for smaller projects, frameworks can still make things easier. Whether a large or small project, I'd always recommend using a framework. I'm personally fond of Yii, but there are many to choose from.
There are different levels of MVC out there as well. Some of the easier ones, like CakePHP and CodeIgniter, are easier for beginners to hop for various reasons, but they also have some limitations that don't exist in more complex MVC frameworks, like Symfony. I'd recommend starting with a mature MVC with great documentation, like Cake or CI. They are also easy to get started on, more drag, drop and program rather than running scripts and code generators. Once you've mastered the MVC concepts move onto one like Symfony or Yii, which are 'more' powerful and extensible ... and also more complex. Personally, I started with Wordpress/Joomla, then on to CI as my framework, which helped me master the concepts. Once I was comfortable with how things worked in the MVC structure I then moved on to Symfony.
No, not at all. Some sites just don't fit the MVC structure. The problem is building a site with no architecture or design for the code. Different sections end up being interwined, and it becomes difficult to change, or even just find, different sections of code. The real advantage with architecturs like MVC, is that you can make predictions on where code will be, and where new code should go. That goes a *LOOOOOOOOOONG* way for making code maintainable.
Also, while you're at it, fix your methods $row-&gt;item-&gt;isSent(); instead of the comparison outside the class (why should the surrounding code know about the class constants?)
My main reasons for not using an MVC on a project are either (a) it's very tiny (one page, maybe two database tables) or (b) speed, for things like repeated ajax requests where you don't want to load the whole application every time (though MVC would be used for the project proper). Other than that, the benefits outweigh the costs and once you start using one, you'd be hardpressed to go back.
So in Laravel, is Route declared in the global namespace?
For AJAX requests, I would hope loading the "whole application" involves just what is needed to serve the AJAX request. It it's not, then it may be worth considering a different framework.
Do it. It's fun. It's got great documentation. You can learn one component at a time. I was in the very same situation as you are, and I chose the SF2 path. I couldn't be happier. It is a bit of an overkill for a couple of static pages, but then you have a ever-lasting, flexible, scalable web site (just in case, you know). It also learned me a couple of new tricks/concepts that I can use on older projects. 10/10 would learn again.
And thats referred to as tight coupling, which is generally frowned upon by anyone who isn't CodeIgniter, Yii or PHPixie. Using a component that somebody else has made does not stop you from being a framework, you seem to have a weird idea of what a framework is. A framework is the architecture that takes a URL, passes it through a routing mechanism, decides where the controller or business logic exists and handles a response. That is about as much as any framework needs to handle at a basic layer, and the rest has been done to death by 100 people. How do I handle OAuth 2? I use a component. How do I handle HTTP requests? A component. ORM? There are a bunch of components for that too. Anything I need to do can be done with a component, and I can use those components in any framework I end up having to use for any project. So, why should I build my entire application and business logic around this one specific ORM and be tied to this one specific framework? That is an old way of doing things that the PHP community has finally started to move away from, but you seem to want to pull people back into an older way of thinking. And the advertised speed benefits don't mean much. Every framework developer ever has released benchmarks showing that theirs is the fastest. Interesting how that works.
All of those reasons above are exactly why I built [PyroCMS](http://pyrocms.com/). Give it a try, you might like it.
&gt;(b) speed, for things like repeated ajax requests where you don't want to load the whole application every time I don't understand what you're referring to. MVC places no such limitation on a project. You first serve the full page, then you make asynchronous requests to the site which delivers the data in a more appropriate format, e.g. JSON, which you can use to update the page with.
Hi, I'm not sure if you intended to reply to mjcov or me. First, I'm not bashing on symfony. I know it's a very powerful framework and has quite a following. I just, **personally**, find that it's less clean than Laravel, even though it uses Symfony's routing component (It's written clearly in Laravel's docs). contact_process: pattern: /contact defaults: { _controller: AcmeDemoBundle:Main:contactProcess } requirements: _method: POST vs Route::post('contact', 'AcmeDemoBundle\Main@contactProcess') It's hard to argue what's easier to understand, what's easier to write, and what's easier to the eye. 
And with Fuelphp can implement a Rest controller who will be able to manage your ajax call very easily.
No way! Keep it simple. Wordpress doesn't use an MVC framework and it is a huge success.
no, you do not need a mvc. As you learn PHP and become better at it, you will later get into a mvc framework and realize that they are nice to use unless its a few pages because the structure is nice and the frameworks can ease the coding down. Before I got into MVC's i sorta built my own structure that separated my PHP classes, template folder, external libs that i bring in such as PHPMailer, i used a template engine called Rain TPL which works good easy to use and is lightweight (1 file). Then my public_html folder would only be my php files that load my templates that are outside my public_html folder and interact with my class files in a class folder. I am currently building a big product on Laravel. The framework is fairly new but seems to be taking off and is actively developed. It is used in HelpSpot and developed by one of the guys that works there. You may want to check it out. You can always use youtube for tutorials on these frameworks if reading how tos just isnt cutting it. Good luck.
A good resource to learn, even though they aren't tutorials, is to use [knpbundles](http://knpbundles.com/) and search for what you're trying to make. They're all hosted on github so you can take a peek at their code and see how they accomplished the same thing. Also, all of the documentation on symfony.com has a little dropdown in the top right corner that lets you select the branch of symfony you want to learn about. There are quite a few good write-ups on there. 
Those are two disparate facts.
Or the Magento way, take all the core files and compile it into 1 large PHP file. How would that actually perform, it would take all the harddrive searching for files away, but will take longer to read that single file. Of course its not good from a developer perspective, but still its only the core file (which you generally shouldnt touch anyway). The compiler in Magento also have a cronjob, so you could generate that single php file every night.
Honestly, just follow [this blog tutorial](http://tutorial.symblog.co.uk/). It's written for 2.0, but the changes needed for 2.1 compatibility are in the comments. 
Having spent a good chunk of yesterday exploring both systems, I'd agree with your assessment. I don't think I can understand Silex without understanding Symfony first.
Because it is the framework itself
The main difference between Symfony 2.0 and 2.1 is that 2.1 uses Composer to manage dependencies (which makes is much easier to install compatible 3rd party bundles). The other changes are reasonably minor and so you could probably apply *nearly* all the symfony 2.0 resources to 2.1 
I get that a lot :)
Neat!
&gt; public function toJson() { &gt; return array( &gt; 'title' =&gt; $this-&gt;title, &gt; 'teaser' =&gt; $this-&gt;teaser, &gt; 'author' =&gt; $this-&gt;author, &gt; 'body' =&gt; $this-&gt;body &gt; ); &gt; } &gt; public static function fromJson($json) { &gt; $d = json_decode($json, true); &gt; return new BlogPost($d['title'], $d['teaser'], $d['author'], $d['body']); &gt; } - &gt; $post = new BlogPost($title, $teaser, $author, $randomString(10000)); &gt; $post = $post-&gt;toJson(); &gt; [...] &gt; $encoded = json_encode($post); Why do this, when you could have used the [jsonSerializable](http://www.php.net/manual/en/class.jsonserializable.php) interface?
http://knpuniversity.com/ The video's cost $12 each. Seriously just start at the first one and go the whole way through. Some of them might still be for 2.0 though but the time you save will be well worth the investment. Edit: Oh I see in your post you don't want to fork over $50 for a valuable education. How much did you spend to go to college?
Link for the lazy: http://symfony.com/doc/current/book/index.html
I am the lazy. Have an upvote!
Even better!
Ah, I see. Sure, it's less overhead, but does it really matter? Pretty sure that you wouldn't see any noticeable difference between the two as a user. 
Hmmmm...I understand...maybe give option? But that's where static fails :/ 
I was going to recommend this article. It's a good, short read and highlights a few important things about MVC that can get ignored(i.e. "If the display component does not have direct, random-access, pull-access to the data store, then it is not MVC."). OP, there are a lot of models out there, I think you should dig around a bit, and maybe find a framework or CMS to build on top of to get started.
skip mysqli and go directly to PDO. [Manual](http://www.php.net/manual/en/book.pdo.php), [a good reason why](http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/), and a quick [tutorial](http://net.tutsplus.com/tutorials/php/php-database-access-are-you-doing-it-correctly/)
I think it depends on the application. Imagine it's thousands of users at a time and the check is to look for new a new message flag every second. That's thousands of hits per second, so whatever the ajax call is doing those small single performance differences add up.
Thanks for the leads. That reference I had linked, and your stuff, are the few good updated references on this stuff. A lot of material online goes back to earlier last decade.
I never mentioned mvc and understand there is other conceptual ways to seperate fode like pac or mvp. However mvc is such an abstract concept I would argue the olther abstract conceptual ways of code seperation are just variations of mvc and visa versa. If a framework doesnt offer code seperation and promote writing dry code then it is most likely a bad framework to use as a base. By the way a lot of the features people have discussed such as routing engines etc arent necessarily mvc concepts but they have been lumped in with mvc frameworks because they are good features and most frameworks include them. I assumed id be downvoted for saying yes instead of the normal "no but there is benefits". It is because of the bad developers that think their reinventing of the wheel on every project is the right way to do things. For some reason php is full of these devs.
Hmmm, a toJson() method which returns an array. Nice.
I'd file this under the category of micro-optimization. A good read nonetheless.
For most, this is common knowledge. Manual pages aren't newsworthy unless it's a completely new feature. This has been around for 13 years. 
&gt;A lot of material online goes back to earlier last decade. Which is why people should look to the PHP manual, not random posts people have made on the web. 
I would just read the docs for symfony 2
Yeah this tutorial is still good. As he said, check the comments if something doesn't seem to work - there are only 2-3 instances of problems in the whole tutorial (it's quite long). 
Agree... This was one of the first things I learned
How about msgpack?
I'm working on one... [WorkingPHP](http://workingphp.com). Only the initial intro tutorial works right now â€” I've been too busy to put any time into it in the last few weeks. :( ETA: Only the things described in the intro tutorial, and `date()` work right now; you can define classes, functions, anonymous functions (closures), traits (IIRC) and more, you just can't *use* them. This is due to the whitelisting nature of my sandbox; I'm still working on the best way to allow authors of lessons to open up the sandbox for the necessary functionality applicable to their lesson.
I was going to suggest the same thing. I used MySQLi for just a bit, but there were a few features that BIZARRELY were missing. PDO has been much easier for me.
Totally, I'm just explaining where it might be used :)
if(($mysqli = new mysqli(...)) &amp;&amp; ($stmt = $mysqli-&gt;prepare($stmt))){ }
- uses ctype_* functions all over, and really shouldn't. - uses is_numeric when it really shouldn't. - ~~has no abillity to accept a validator function to cover complex validation, or validation which is not otherwise covered by the library.~~ - validation functions are underdocumented, and don't give any indications of what they expect specifically. - class is being treated like a container for functions instead of embracing the OOP paradigm. Too much responsibility placed in a single class. - absolutely no tests at all. Recommendations: Read about [ctype functions](http://php.net/ctype) and gain a better understanding about why you shouldn't use these. Pay particular attention to how the behavior of ctype_* functions change based on the variable type (string vs integer). Read about [is_numeric](http://php.net/is_numeric) and note the large number of things which can be considered numeric to understand why as a validation, this is rarely ever useful. Consider designing your library so that it is capable of decoupling the various validations from the object which keeps track of which ones are in use. There are two types here: * The validator - the object the user will interact with. This should be part factory so that it is capable of instantiating validations and telling them to run. A validator encapsulates validations. * A validation - an object which derives from a common class/interface that defines a method for testing something. A validation should be able to accept any parameters which may alter its behavior, but it should do so with an interface that is common to all validations. This makes it easier to build newer validations, and keeps the object the user interacts with slimmer. The validator should not be worried about how to validate something, it should be worried about keeping track of validation objects associated with a request, and collecting responses from individual validations to send back to the caller when a request to execute validations is sent to it. 
You know, this will probably be the nitpickiest thing you'll see for this, but it was the first thing I spotted: you have a space character after every foreach, but not after if/elseif/else. I don't care which spacing you prefer, at least use it consistently across built in structures.
And actually, I went back to check the site to make sure I was right. It turns out the author has already incorporated most of the 2.1 changes from the comments into the tutorial. So you may even be able to follow the tutorial verbatim.
I really dislike assignment in conditionals. 
Not to sure how well it is compared to PDOException but... try { $db = new mysqli( ... ); $stmt = $db-&gt;prepare( "SELECT `field` FROM `something`"); $stmt-&gt;bind(...); $stmt-&gt;execute(); } catch( mysqli_sql_exception $e ) { echo $e-&gt;getMessage(); die; }
thanks, i'm going to look into the first two. as for number 3, i do allow for custom validation functions, i'm guessing thats what you mean. line 15 of the example.php shows how to do this. i'll be sure to add more documentation to the specific validation functions, but they will be very redundant, since they all take the same 2 or 3 parameters. i give a basic description of them at the beginning of these functions. very much appreciate your recommendations, i'm going to go through them and see if i can restructure this in a better way.
point taken.
There isn't much reason to check that $mysqli variable itself because you are creating a new instance it will be valid even if something goes wrong. Otherwise an exception would be thrown. You should check the $mysqli-&gt;connect_errno and make sure a good connection was made. Provided you have a good connection to the db and correct SQL statement then it's pretty unlikely that the prepare method will fail. I'm not saying it wont happen but you will drive yourself crazy trying to account for every single issue that can arise from your code. Also as you mentioned it makes the code pretty unreadable. My suggestion would be to just make sure you have a connection to your database and have that be the only mysqli verification check. Then if something does go wrong an exception will be thrown and you can debug from there.
I stand corrected - I missed the anonymous function assignment. Guess I got too caught up reading the code, and didn't go over the examples as I should have.
this was the type of input i was looking for so thanks
This is the correct answer. Other suggestions here are really fugly.
Take a look at Respect Validation for good data testing methods. https://github.com/Respect/Validation/tree/develop/library/Respect/Validation/Rules
Enough that I'm still paying it off, smart ass.
I'll take a look at it. Now here's the cynics response: There are a lot of "decent" CMS applications out there, none come without some sort of limitation... I really can't see much benefit investing time in learning yet another platform when I have already put the time in to become familiar with a number of rapid development frameworks in a number of languages. I wonder if I would be better off spending that learning time just bootstrapping a bunch of independent components for that boilerplate page, comment, layout, asset, analytic stuff. No two websites are really the same, especially if they have any sort of complexity. Yet developers constantly try and shoe horn them into a CMS with a one size fit's all approach. I don't buy it anymore.
Awesome. I will start there then.
Cool, good to hear coming from someone currently using it to learn and not just upgrade their skill set from a previous version.
Appreciate the link. Exactly what I was hoping for (a blog tutorial!) As blogs seem to incorporate most of the basics required for any site.
I understand, really. I talk to a lot of developers who are jaded against the whole idea of a CMS because of the pieces of shit they've been forced to use in the past. Then they use PyroCMS for a while, convert all of their projects to it, convince their boss at the next job to use it and invite me to their town to pay for a nights worth of drinking. True story.
Your trim_post function. What if your $_POST['key'] is a multidimensional array itself. try maybe using a recursive solution so it handles both strings or arrays, something along the lines of: function trimStuff($item) { if (is_array($item)) { return array_map(trim_post', $item); } else { return trim($item); } } 
Your grasp of opportunity cost indicates you will be for some time :)
Nope. Try being a freelance developer working on the other side of the planet supporting himself just fine. The reason I don't have the money for it is purely budgeting. I recently spent my "self-education" budgeted money on (spoken) language learning material that would be of much more value than 4 videos as getting my Japanese to a business level opens even more doors for me. I am just careful what I spend money on - and $50 for intro videos when every other framework out there has free alternatives doesn't seem like the smartest thing to buy when I'm sure if I ask the community someone is able to point me towards the free alternatives.
Sweet. Glad to hear that.
Models: Data interaction and business logic. Views: Your HTML, if statements, foreach loops, but nothing else. Or mustache/twig/haml/smarty/whatever. Controllers: Call up the models, send it to the views. I just saved you $20.
Nope, nothing wrong with not using an MVC at all. If you ask me that shit just adds another layer of confusion. Start with the basics and learn what you're doing then when you're comfortable with that you can dab your toes into the world of MVCs and see if it's for you or not. 
Named placeholders for prepared statements made choosing PDO a no-brainer for me (sqlite support was a major bonus too).
What type of a setup do you use / need on heroku? Lets say for an average business site? I've never used them before. I'm assuming 1 web dyno and a 10m line database would suffice? Or is there a need for a worker dyno as well with this? Sorry if this is a silly question.
me too, if you don't know it's there it's tricky to spot !
I showed checking the connection for the sake of the example and getting the point across !
Usually your business logic should live in your model. The controller should only be the glue between your model and view. You should be aiming for fat models, skinny controllers.
I thought of doing that as well, but this is why I created the thread, to get other opinions as well ! Also, in the individual functions of mysqli module in php.net, why isn't it explicitly declared per function which kinds of exceptions might be thrown ,or do they all throw [mysqli-sql-exception](http://www.php.net/manual/en/class.mysqli-sql-exception.php) ?
You don't check the connection is what I'm saying. Doing: $mysqli = new mysqli(...); if($mysqli) will always enter the if regardless of whether a connection was made or not because $mysqli was instantiated with new. I don't really know why you have that check even if it's "for the sake of the example". [EDIT] Sorry that came off way more dickish than I intended.
You can use any of these wonderful existing packages to give you inspiration: https://github.com/Respect/Validation https://github.com/fuelphp/validation https://github.com/symfony/Validator I just use these, but if you're going to release your own: * Use [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) * Distribute with [Composer](http://getcomposer.org/doc/01-basic-usage.md) * Add it to [Packagist](https://packagist.org/) * Write some [unit-tests](http://www.phpunit.de/manual/current/en/index.html) * Put it on [Travis-CI](http://travis-ci.org) Before worrying about any of that I'd clean up my examples so its not PHP and HTML munged together, I'd add a README.md and give my class a upper-case first letter like everybody else. Also, you could probably use [filter_var()](http://php.net/manual/en/function.filter-var.php) a lot more than you are already. Best of luck! 
A full MVC framework certainly isn't your *only* option for making a good, maintainable application, but most time it's the best one if you don't want to write a bunch of code or architect anything yourself. That said, if you *do* want to architect more of the code and organize and put it all together yourself, you may want to look into microframeworks. They pretty much handle just basic HTTP request/response routing, and leave the rest up to you. Some have templating, some don't, etc. but none of them will force a strict organizational style on you or force you to learn a bunch of new concepts like MVC frameworks will if you're new to them. You can check out more here: http://microphp.org/
It's there to show the level of annoyance :P And don't worry, not offended :)
Biggest problem I've run into is the wide variety of PHP syntax over the past 15 years. Today I was looking up stuff to interface with MySQL: a book I had from 3 years ago didn't match the current reference site, nor several other sites I looked up.
One thing that's been useful on the manual site are the user-submitted code-examples. Saw some entries going back 8 years: imagine a Reddit thread lasting that long...
An echo and die in a try catch is fugly too IMO. I'd hate to see that web page experience. I'd just use a DBAL and at minimum log the error somehow with a logging class. Instead of die why not rethrow the exception and let the system handle it according to the environment?
Globals are also a code smell because they tightly couple all of the code that depends on them, you then have a much harder time reasoning about a piece of code - removing, or modifying a constant becomes that bit more difficult. There's also a world of different between PHP_EOL and the constants being described by the OP IMHO.
I'd be extremely careful with user-submitted code if I were you.
This is a preference, not a rule.
It's a good preference to have and good practice. It's much easier testing methods on your model that do one thing than testing a monolithic action (controller method).
Yeah, I could have used a better example in the catch.
No big deal, just throwing out alternatives.
Possible? Yes, but the session will be tracked separately from the user's session in GA, making it a single page view visit (bounce). I've done this and it can still be valuable for tracking that event, albeit separately from the user's referral, browsing, and other data. 
Would be easier to just get the existing project working as stable as you can get it *as is* than it would be to try to move it to a framework. If you want to end up using a framework for it, start from scratch, fully plan it out how it should be architected. Look at any and all options, even other languages to determine what is best. Don't just do PHP or Laravel because PHP is what you know and you like Laravel.
Yeah I guess I need a way to pass the user's session in GA to this other script. Any idea on how to do this, if I can at all?
To do what? Replace the PHP script functionality or are you talking something else?
I think a big question is whether or not the app is written in something resembling MVC style or not. because in my opinion if it isn't then your probably going to spend more time trying to shoehorn things into laravel then you would by re-thinking and re-coding from the ground up. It's my experience that with code that's touched a lot of hands over many years, especially with more recent developments in OOP for php, a well thought out re-build is more efficient and productive. opens up a lot of possibilities for adding new features and forward thinking as well.
I have started separating newer things into a psudo mvc type system, it's not as OO as I would like. I guess I just need to convince my boss of the benefits, he loves overloading me with work and never giving me chance for things like this.
I have done this before and it's very difficult especially if you aren't the original developer. Mainly because there is always a lot of small, undocumented functionality that users have gotten used to. Often when you start developing on a frame work there is a much simpler approach to take to replicate a page but you ultimately miss the small hidden functionality on that page. So you end up having to play catch up with the original app or occasionally adding functionality which was a result of a bug but was something that the users expect and don't want to get rid of. TL;DR It's a pain. I wouldn't recommend it. Just start from scratch and try to iterate on what is already in existence. 
I came here to recommend this book, too! This book is a solid book for those who already have an understanding of PHP. I should say, though, there is only, albeit long, chapter on MVC. It walks you through the basics and helps you to build your own MVC framework to help you learn more about the MVC framework. Other great chapters include a chapter on developing API's, unit testing, general OOP concepts, and many others.
Maybe Silex and NGINX?
 $is_valid = (@preg_match($rx, '') !== false); should work
On the subject of igbinary, dotdeb is working on including it in the core serializer and memcached and redis extensions: http://www.dotdeb.org/2013/01/24/php-5-4-11/
If you can define custom routes, you can dump everything you currently have into the views, define a route for all of your old urls to the view, and systematically work things out into the models and controllers as you go. 
Create one, for learning, then use Doctrine's DBAL. Then [study DBAL](https://github.com/doctrine/dbal) to see how it all fits together, it's very interesting.
Whatever you do, replace one bit at a time. And always strive to de-couple code.
I haven't finished going through it yet, but I'm enjoying [Create your own framework... on top of the Symfony 2 components](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1), which leads you slowly from a basic php page through adding functionality with Symfony.
We have recently moved our website to the Symfony2 framework at my company. It is a very large 10 year old site, originally written in php4, and rewriting from scratch is a complete non-starter. We basically have all the old urls going to a 'fallback' route, while everything new is done the proper 'symfony way'. For our site, it definitely is not a one programmer job. We have someone slowly refactoring old classes to be psr0 compliant, someone else getting rid of super globals littered in the legacy code, removing pear apps and using composer for everything, etc. Even more slowly than this we are refactoring the old legacy urls. Usually it will coincide when business wants a major update to a particular part of the website. It's definitely a lot of work; we're not even close to being 'finished'. But if you take your time and do it one piece at a time, it can be worthwhile.
Cheers, sorry I had to get some stuff done by the end of the day, I do know other languages, but since this site has been made with php and I have a junior who is most comfortable in PHP it would probably be the best choice, I wasn't set on Laravel I was hoping for suggestions if there was something made for this kind of implementation. I might just put in some better database and validation classes and leave it as it is until work settles down.
This isn't an answer to your specific question, but it sounds like you might want to implement a job queuing solution such as [php-resque](https://github.com/chrisboulton/php-resque). It'd be a lot more reliable than fsock or curl, as you can prioritize specific tasks and set a finite amount of workers, which would make it a lot harder to overwhelm your database and other socket-based resources. To address your question though, typically when utilizing something like a job queue, you would create the job request and close the http request once you get your job id/token. The user would then loop and request the status of the job at whatever interval is appropriate to you. When the job is done and you display the results back to the client, this may be the right time to have the client's browser make the Google Analytics calls describing said results. At least, that's what I do.
As someone that's been through this, and maintains a large proprietary framework here are my thoughts: 1). Approach this as a MAJOR project. 2). Use a project management system to map out and define all functionality 3). Reconsider the actual need, and benefits to moving to a framework. Do you really need to do this, or will you gain more problems than solutions? 4). A redesign gives you a great opportunity to really understand the application and identify problems that haven't even been found yet. Replacing the existing system will identify and fix a lot of issues by using a framework and it's testing. 5). Have a SOLID migration plan that involves user testing involving all related stakeholders, and a decent subset of your users before launching and address overlooked aspects. 6). Seriously reconsider if you really want to do this.
We recently had to do something similar. We used Zend Framework and installed it in a sub directory from the docroot. Each "sub project" we needed to bring into the new framework we built as a ZF module. And to be able to do one thing at a time we create .htaccess rules for each page/feature that we finished porting over. This way any new pages can be served from the new framework, and unfinished stuff can be served from the old code base. It's tricky and requires planning, but it has worked fine so far.
At the moment, I don't have an numbers to share about the setup for an average business site. I did run an instance through several performance/stress test tools and I'm genuinely surprised at what I can do with just 1 web dyno hitting 1 MySQL database. The good news is that dynos are easily increased/decreased.
Frameworks are generally a great starting point, and the popular ones have lots of people using them (so if you ever need to teach someone else how to use the framework, it should be pretty straightforward). They're great for maintainability as the framework code usually has extensive documentation and unit tests. I'd strongly suggest learning one (I like FuelPHP and Kohana, but Yii and Laravel are pretty popular as well). Note that MVC isn't the only design pattern that can be used to build a website, and not all frameworks use it. It's not the only way to achieve separation of concerns and code reuse (which is what frameworks are aiming to do). For simple lightweight sites that wouldn't really benefit from a framework, I use an approach somewhat similar to MVC (although it's not MVC): * Make a PHP file for the main page logic (say, example.php) * Make PHP files for all your database logic (models, essentially). These should have **all** your SQL, there should be **no** database calls anywhere else. * Put the HTML for the page into a separate file (say, views/example.php). These should have **all** HTML rendered. * Then just render the HTML with `require('views/example.php')` at the bottom of the logic file Basically, like a "traditional" PHP site, but with the database calls and HTML output split into separate files. This achieves some separation of concerns (HTML, SQL queries and page logic are all separated) without going for a full-blown framework. Here's some examples of one I've done in the past. The code is a bit old and messy as I rushed it at the time, but it still works: * Database access: https://github.com/Daniel15/pmacct-frontend/blob/master/includes/data/summary.php (I used static methods in here, but I'd advise against that as you can't easily mock them for unit testing) * Views (HTML): https://github.com/Daniel15/pmacct-frontend/tree/master/views * Page logic: https://github.com/Daniel15/pmacct-frontend/blob/master/month.php This uses a very simple helper class to render a view file surrounded by a template: https://github.com/Daniel15/pmacct-frontend/blob/master/includes/view.php In the end, not using a framework is fine, but you'll find yourself building your own framework. You'll notice the common patterns you use when developing PHP pages, and refactor the logic to make it reusable. That's how frameworks begin. This is absolutely fine as well - If you build something great and like using it, then there's nothing wrong with that. Just make sure the code is maintainable so your successor won't hunt you down. :)
I don't know about you, but I spend more time programming than I do actually running scripts. An execution timer is just about useless...
http://sourceforge.net/projects/galvanize/ was designed exactly for this.
What about all the time spent not actually dealing directly with the php, like designing and planning, documenting. I can't believe anyone could really measure their time properly like this. 
...I can spend hours in pure code before testing even begins.
&gt; The weird class name is to ensure no name collision will occur. Don't you have 5.3 installed? And in general - it's all strange =\ Totally agree that you spend more time designing and programming that running some tests
No, there's nothing "wrong", but in the long run, you will probably be more productive with a framework than without. It's kind of like Abe Lincoln's quote [â€œGive me six hours to chop down a tree and I will spend the first four sharpening the axe.â€](http://www.persistenceunlimited.com/2006/01/abe-lincolns-productivity-secret/); You can dive in and start coding, or take a bit of time up front to learn good design/development principles (which most frameworks illustrate for you) and be more productive in the long run. The choice is yours. 
We did this with a really big, in use system, spread over four or five core areas, that had been updated and developed all over the place, in classic ASP, connecting to MSSQL and Access and with no centralised user system. We rebuilt from the ground up (into a LAMP stack using CodeIgniter), using the existing system as the core requirements, then addressing areas where it fell short or was poorly architected. It took three years for a full migration. 
This post contains absolutely no useful information at all.
Looking forward to it. [Our readers](http://it-republik.de/php/news/Woodhouse-Testabdeckungs-Laempchen-fuer-GitHub-und-PHPUnit-066590.html) seemed rather interested. Let's hope for the publicity to kick in and wake up some sleeping open source dogs. 
You have to consider which framework to use rather carefully for this. Laravel is soong going to be updated to version 4, so if you start using it now (version 3) you will end up with something that isn't supported at the end. If there is a lot of it already written perhaps you could restrrcture it using some of the lightweight stuff like Slim etc.? there was a PHPixie tutorial here somewhere too.
Hm. While I too subscribe to fat model, skinny controller, I still would put business logic into the controller, since it normally only has marginally to do with data entries?!
Open some issues and milestones on the github with what you will do, what you read here and plans to do or wants do discuss. Thats an easy way to find contributors.
I added a note pointing this out.
I guess it depends on what you deem business logic. I would rather make small, testable, reusable methods in my model that are called via the controller. Although the logic to call these methods (conditionals) would live in the controller based on data retrieved from the request.
Thanks for the link. I hope the use of annotations was for the sake of debate and that you're not using it in production? I honestly don't know who thought about putting valid code in a comment. That's so wrong. http://theunraveler.com/blog/2012/php-annotations-are-a-horrible-idea/ 
I'm currently contracting as a senior PHP dev. Jobs seem to come easy enough :) Just do it! Any questions give me a PM
I'm contracting/freelance up in the Midlands, outside of any major cities, and work is still forthcoming.. so I would imagine in the city, especially London, it is plentiful? Just remember with contract rates that you won't be working 12 months of the year, and you won't get other employment perks and budget accordingly. With contracting I try and plan that I could get by on 6 months work a year, and make sure you put several months rent/bills aside in case of a slow period. Also, there is occasional remote work available, which is great.
with most web development related jobs in london (including everywhere else right now for that matter), there always seems to be more positions available than people to fill them. go for it. the best advice i can give you if you do decide to start looking for contract roles, when you start sending out your c.v. or uploading it onto recruitment sites - remove your phone number, simply include the line 'please email for my phone number'. the first time i put my c.v. on a couple of sites my phone didn't stop ringing for a few days - its not very courteous to your current employer to start receiving calls all day about your current availability etc. also, most recruiters are snakes, never accept their first offer finally, if you are interested in keeping most of your money - set up a ltd company and contract through that
Right I have no idea how CFS works, I wasn't on the core team of FuelPHP at all. But yes while your Hello World is pretty quick I'd imagine that any sort of half-decent usage of this framework is going to be slow as hell. You see, when you build a framework based on CFS it CAN be rather quick, if you use any sort of classmapping. Kohana would cache its class-maps, FuelPHP would require a pre-build class-map. Without those you have to foreach through the file system on your hunt for classes: https://github.com/dracony/PHPixie/blob/master/system/classes/misc.php#L39 With APC installed this is a little better, but its a silly way to design it. But of course, as somebody who doesn't know anything about CFS, my opinion is irrelevant. Keep on going with your re-invented-but-worse wheel.
... how? isSent means status equals STATUS_SENT if true. If false then status does not equal STATUS_SENT. It performs the same test as in the code above, which clearly tests for just one state (but implementation details has leaked to the surrounding code) and does not care (neither should it) about other states. I'm guessing you though isSent would be the only method, when there will be three - one for each status code. If needed, that is.
Kohana 3.3 is actually PSR-0. This nearly didn't happen because shadowhand could not refrain from being rude about PSR-0, 1 and 2 on Twitter, yet at the same time wanted to join the PHP-FIG and got called out in [his Membership Request](https://groups.google.com/forum/?fromgroups#!topic/php-fig/Pe0yMKEvPAc). Very funny stuff.
Globals are global - the fact that they're provided by the language does not mean your code is not coupled to them. Is your code more bulletproof simply because the constant it is coupled to is provided by PHP and not your own code? Other than that, there is a point to the tight coupling - however, constants are limited to being scalars, and if you need to change the value of a simple scalar that often, you have far bigger problems and should probably step away from the keyboard to actually plan and design your software properly before doing anything else.
Meanwhile Zend Server is a full release cycle behind php.net.
http://programmers.stackexchange.com/questions/177684/what-are-the-benefits-vs-costs-of-comment-annotation-in-php Code should be clear. Code in comments is not clear. Unclear code is bad. We can debate this all day long or we can agree to disagree. One thing for sure: we do not have the same standards of code cleanliness. If you really think annotations is a better way of defining route, even after showing comparison,.. Well, I hope we never work on a project together. Here is a debate about PHP annotations. http://news.ycombinator.com/item?id=4663919 
Completely different product maintained by a different team with different corporate goals. What's your point in regards to Zend Framework?
No, the code is what's slow.
If you're really desperate about budget then this probably won't change your mind, but... It's actually $36 for the full 2.1 series, you don't need to buy 2.0 ones and you get $4 discount if you buy all 4 2.1-s. Also those series cover every topic you need to get started with Symfony2 and are made by core Symfony2 developers.
Cheers if you're from Knplabs. They're from Montreal and not too far from where I am, and I heard nothing but great things about them. If there is absolutely no way to do something and you use workaround, it's okay. If there is 10 ways of writing routes, and you choose the one where it's written in a comment, instead of choosing the YAML one... Can we still use the word workaround or should we use laziness? It's not impossible to debug, it's just a bitch, and the usefulness is not even that great. Consider this. domain.com/random-route-name/ Now you have to find which controller this thing points to. In Laravel or in a clean Symfony situation, we're going to check for routes.php or config.yml. You know exactly which controller it points to. You want to redirect random-route-name to 404 handler or to another controller? No problem. It's all right there. No core codes modified - just the routing file. In your example, I will have to rely on Find in Files. I am honestly unsure how to do the rest. I personally never tried it. When I code, I read comments when I need to understand what it does. I don't read comments to look code. I would be pretty mad if I had to. 
If you are developing a library or coding from scratch, yes. But I mostly work with CMS and framework. I really donâ€™t see how you can do JS/HTML/CSS without refreshing at least every 5-10 minutes. There's also configuring the CMS, test if an installed plugin works. Somethings, just an ajax request on an opened page will keep the timer running. This tool is not meant to be exact, but to help you have an idea and not forget that you have indeed work on something
I suppose if you had 5 megabytes of text comments it might slow down the PHP parser the first time it read the file, but proper use of APC would solve that problem too.
It depends on the rest of the file, does that last } close out an opening { at the top of the page? If so you'll need to put your code before that last } and the first example is correct, no semi colon.
Not at all, the parser is a honeybadger, it doesn't give a shit.
I added a block about your point in the article.
There does not appear to be an opening bracket at the top of the page, as the first one appears several lines in. The only "opening" characters at the top seem to be the other half of the angled bracket from the bottom: &lt;?php load_theme_textdomain('freshshop'); // localization 
Thanks. And I'm safe to just place this at the "bottom" of the file? It doesn't need to be listed in any certain section? 
Same company though, and I'd much rather see them focus on keeping their **commercial** (paid) product up-to-date than some free framework. You may be correct insofar as the teams are disjointed and managed differently, but as a paying customer of the same company that manages both products, I feel that I have the right to complain when I see free products being upgraded while the product that I've paid for is over a year behind schedule. I mean, it's not like they bill themselves as "The PHP Company" or anything.
this is the table view visually - i am open to changing this as required. http://mossco.co.uk/wp-content/uploads/2013/01/table.jpg
Okay cool - I may wait until later (when business slows down) to test this. Thanks so much for the help :)
If it were me, I'd take a step back before trying to build on top of a framework. I'd start by refactoring the existing codebase out into PSR-0 compliant namespace. You can do this slowly, class by class untill the vast majority of your business logic is organised. Then look to adopt or port your domain logic to an ORM such as doctrine. By making these changes you will make your job of porting to a framework a lot easier. When you have done this you could easily choose between ZF2 or symfony2 (and probably other frameworks) because both work seamlessly with Doctrine and expect PSR-0.
While the parser does take time to skip over these lines, it is so minuscule you likely won't notice unless the source file has millions of lines of comments. As a fun exercise though, OP might want to try getting some benchmarks with comments in, and with comments out. For benchmarks, you can either run the php directly from the command line with "time php index.php" or something. Or you can use apache benchmarck (command ab) to test web performance. And to strip out the comments, this [guy's post](http://stackoverflow.com/questions/503871/best-way-to-automatically-remove-comments-from-php-code) might be useful: Good luck.
Regardless of if the comments slow it in any measurable amount (which I doubt), if you use a cache (apc, xcache) it will only do it the first time the code is loaded. 
Do this whenever you can. It helps prevent hard to find errors when there is white-space following the closing tag.
It's probably worth noting that he may need a semicolon (although I doubt it). E.g. $a = function(){ echo "heya"; }; $a(); without the semicolon you get a parse error.
If you really care about speed, you should be running an opcode cacher (such as APC, or theres a Zend one too I think). This caches the compiled opcodes, so it doesn't have to parse the source php each time, and can provide a massive boost to performance. But comments themselves dont have a significant effect on parsing speed.
You could also probably just remove it with CSS. Look at the output code (right click, view source code) and look for the output message. Chances are good it has an id or class that you can set to "display: none;" 
That... is actually a very reasonably explanation of why the PHP parser does a lot of things the way it does.
Inori, I meant no disrespect and did not call you lazy. I'm sorry if this is what you perceived, as it is not what I intended. The entreprise level app I am currently developing is now at ~200 routes. Although it is not Laravel, it is pretty similar. 1 file for routes is manageable and very clear - I'm pretty sure it will be okay for 500. If not, splitting it is not a problem. Using Find instead of Find in Files is a little bit faster. Annotations are very useful, and yes, they might improve readability, but only in a language where it is supported, like Java. PHP does **not** support it. Annotations are written in comments. This is a problem. A readability problem. Plus, we're using PHPDoc So consider this /** * Copy all assets from a given path to the publish path. * * @param string $name * @param string $source * @return bool */ public function publish($name, $source) { ... } with Routes, it would look like.. /** * Copy all assets from a given path to the publish path. * * @param string $name * @param string $source * @return bool * @Route("/publish/{id}") * @Method({"GET", "POST"}) */ public function publish($name, $source) { ... } 
This is the best advice. Just start refactoring little by little using good OOP concepts. Start separating all your concerns. Tackle little things (Validation Containers, View Helpers). Soon those little things become BIG things and you're rolling. Always have your framework as the target. Going to Laravel or Zend? Write your code in that style. Use their interfaces, then your models will port without any rewrite. It's going to be long journey. 
I too would contribute at least one implementation. I have been looking for something to demonstrate a new framework I've built compared to what's out there.
How will it effect the first run through for an app that parses doc blocks looking for annotations, something like a Doctrine or Symfony app?
I have seen people split them up into one rule one line with a comment that is the closest I have gotten to understanding RegEx but its probably the one coding/scripting thing I understand non of the "logic" in
Write your own sort function and pass it to usort().
Not sure exactly what you mean, but this is probably it. usort($array, function( $obj1, $obj2 ){ if ($obj-&gt;title == $obj-&gt;title) { return 0; } return ($obj-&gt;title &lt; $obj-&gt;title) ? -1 : 1; });
The parser doesn't care what you want. The parser doesn't give a shit. The parser does what it wants, and if you don't comply with its wants, you won't get what you want.
It still has to read the file from disk and iterate over each line. It's not free.
Right. You want to name a class or namespace "Default"? Tough, parser don't give a shit.
Actually I just did some testing with this in my regex program. It looks like having a : in the remote_host it acts strangely. If you add it in, it should work. So, change it like this (?P&lt;remote_host&gt;[a-zA-Z0-9:\.]+)
Magento slow? NO WAY. Just kidding- check this out http://www.magentocommerce.com/boards/viewthread/74272/ Magento is terribly slow for a few reasons: - Metric fucktons of stats for page loads - No static file caching - By defualt, logs all visitors/actions to the database...in new rows...stored in InnoDB...meaning that you could get ~5GB of InnoDB LOG DATA over a period of time and have no idea why your servers going to shit - Magento pretty much needs APC/KeepAlive to run I'm smacking the core dev team around a bit to fix this, so they might not have these issues in future versions. 
APC is brilliant. The web app I've been building has one particularly intensive bit where it uses HTMLDiff to compare two files, and even on the quite beefy server it's running on, it could easily take five to ten seconds to come back with the response. Once I'd enabled APC, even without rewriting anything, it comes back virtually instantaneously.
thanks very much for the advice! I have already experienced the recruiter phone problem applying for permanent jobs in the past! Do you have any suggestions for setting up a LTD company? It seems like you can just set one up online, but I'm a bit sceptical. 
Thanks very much for the advice, I will try budget sensibly! It seems like with the rates I've seen I could earn almost the same by working for 6 months per year as a contracter than I currently do working full time. 
Thanks for the offer, I will almost certainly take you up on that! 
 I'm still getting this error, I restarted apache that should refresh the script right? [31-Jan-2013 20:55:27 UTC] PHP Fatal error: Uncaught exception 'MongoException' with message 'no elements in doc' in /var/www/mongolog.php:82 Stack trace: #0 /var/www/mongolog.php(82): MongoCollection-&gt;insert(Array) #1 {main} thrown in /var/www/mongolog.php on line 82 
these are the settings, X-forwarded-for just corrects the IP because of the proxy, in normal logs that IP turns into 127.0.0.1 when I bypass the proxy with the :8080 port. LogFormat "%{X-Forwarded-For}i %l %u %t \"%r\" %&gt;s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined CustomLog "|php /var/www/mongolog.php" combined 
Yep, its pretty awesome. You can also configure it so it gives you some shared memory so you can persist variables or objects between scripts. Personally I dont use the shared ram though, favouring memcache instead.
Based on your reddit history you answer lots of questions that people have about PHP and you're a helpful and productive community member. You must be a real turd and all your friends must hate you! I've seen some strange comments in this subreddit, but papermatthew's was the first that made me say 'WTF' out loud.
I just get so vulgar when I'm being judged as a person based on a couple reddit posts. I'm sorry, it was uncalled for. 
I'm not 100% sure about the %O, the httpd documentation doesn't show that as anything. I have to have a custom log format too to capture the user from php-fpm and here's what I have for that. CustomLog "|/var/www/apache_log_parser" "%h %l %{REDIRECT_REMOTE_USER}e %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-agent}i\"" env=redirect_user
Actually really nice idea. Find a graphic designer, do it! 
&gt; **Logging actual bytes sent and received** &gt; mod_logio adds in two additional LogFormat fields (%I and %O) that log the actual number of bytes received and sent on the network. I don't think I added it (I mean I think it was in by default before I edited)
Looks a bit like http://dochub.io/#php/
My mistake, yeah I just re-read it and came across that. Try enabling logio or changing it to %b and see what you get.
I would have to disagree with a LTD company, especially in London umbrella companies (companies who technically employ you and who get paid from your agency or direct employer) handle everything, only take around 20 pound a week, pay your tax and can offer advances. Love my umbrella
didn't seem to change anything. If it matters I'll just say I'm seeing two of those errors in the PHP error log for each page load. also every insert into mongo includes these with the value of null. "remote_logname": null, "remote_user": null, edit: this just popped up, haven't seen it happen that's why I'm sayin.g [31-Jan-2013 21:50:37 UTC] PHP Notice: Undefined offset: 1 in /var/www/mongolog.php on line 62 [31-Jan-2013 21:50:37 UTC] PHP Notice: Undefined offset: 1 in /var/www/mongolog.php on line 66 [31-Jan-2013 21:51:08 UTC] PHP Fatal error: Uncaught exception 'MongoException' with message 'no elements in doc' in /var/www/mongolog.php:82 Stack trace: #0 /var/www/mongolog.php(82): MongoCollection-&gt;insert(Array) #1 {main} thrown in /var/www/mongolog.php on line 82 two of this one as well. 
Well, I already have quick docs in the IDE, so something like this wouldn't be useful for me *personally*, no.
Ok, good to know that at least some people have that.
Well, there's http://prototype.php.net/
I was mostly surprised that Netcraft is still around. :-) &lt;/old-timer&gt;
Btw, strlen($value) doesn't work for UTF8 strings. Take a look at mine if you want to: https://github.com/dracony/PHPixie-validate/blob/master/validate/classes/validate.php
And even without that, php.net/&lt;what I want to know about&gt; is almost unbeatable.
Hm, looks nice and simple. I actually begin to really like the whole simpicity of the PHPixie thing. I like the option of putting '!' in rules name to invert it.
This a thousand times. PHP for windows has so many gotchas, it's a minefield to develop. I currently run a CentOS VM that mirrors my production environment. File access via Samba. (Don't use VirtualBox Shared folder, the seek/read performance is garbage.)
With the improving github search you can usually find a repo that uses X framework to do Y task pretty easily, but I still think a TodoMVC sort of thing would be fab. I think we'd all like to see how it would be done in PHPixie. Any good idea for a theme? Same old Todo-list? It's not a bad choice, just a bit bland.
Seriously, it would take and I'm not exaggerating at all, over 3 minutes to load a simple page with barely any db calls.
&gt; someone came to /r/php ... He got heated anytime someone mentioned PHP Sounds like a troll. My experience of industry is that PHP with a decent framework is considered a great way to get a product launched without being held hostage by a small language small talent availability pool.
ugh, thankfully my magento days are behind me, never looking back;) 
I found the logarithmic scale a little deceiving.
Exactly. And while it might not be "hot" right now, the community is very active. We're getting cool things like Composer and the framework interoperability movement now.
PHP is hot, we are looking at at stuff Ruby &amp; Node.JS is doing and implementing it in a way that works for PHP folk. If you look at other languages (Like Java) who have failed to adapt, it's a totally different story.
&gt; meaningful impact Others have answered the actual question, I just wanted to say that I like you for specifically asking about meaningful. So tired of see people arguing over the speed difference of different loop constructs, etc.
Yeah that's kind of how programming works.
Access a variable that doesn't exist? Parser doesn't give a shit. Database error? Parser doesn't give a shit. Compare a string to a number? Parser doesn't give a shit. Treat an array like an object? Parser doesn't give a shit. It just keeps on parsing like a boss. It'll shit out a webpage no matter fucking what, even if it makes no sense.
"Dot net technologies" has a lot more buzz sound to it than "PHP". 
To be fair, Netcraft hasn't confirmed that Netcraft is dying.
Did you get this sorted out? If not, send me the entire file via [pastie.org](http://pastie.org) and I'll get it working for you.
You do realize that Zend Framework has contributions from OSS developers right? You have no right to complain at all, not on this medium. Vote with your wallet and move on.
It took me significant effort to get PHP accepted into a fortune 100 company. My use of PHP started a storm of opposition from the Ops team, since they had no experience with PHP. They thought that there "aren't enough developers that know PHP", although just about every business unit in the company had a PHP website. I said that I could grab any random guy off the street and he'd know PHP, it's not hard to find someone. Still, my manager believes that pure Java can perform better, and while it may be able to just slightly, I contend that it'll take a Java developer a year and a half to create something that a PHP developer could do in a few weeks or months.
I've already voted. They're not holding up their end of the deal. Since this is /r/php, I'll complain here if I like. Vote with your arrows and move on.
I tip my hat to you. Java (Java EE for web apps?) managed to get itself into education &amp; business years ago which makes it a dog to get rid of, but give it time &amp; the people who support old technologies will move on. That said, in my experience developing a project in PHP has been quicker than me doing it in Java, but that's mostly down to me not knowing Java as throughly as PHP. I imagine a decent Java developer could match PHP in a project time wise (but they might cost a heck of a lot).
 I { don't get } { what the OP means? )) {
I think one reason that the JS todo project is successful is things like hosting and server configuration don't come into play. When I think about it things such as configuration should be as indentical as possible with respect to each frameworks design. I'm wonder if it'd be possible to host everything in a single repo or if that would even be a good idea. 
All charts are deceiving in some way. It would look like a rocket launching on a linear chart. 
You can host the files on Amazon S3, which you can then create an expiring unique link to the file for your user to download from. There's also an Apache mod that generates a time-limited link to a file, very similar to the process for S3.
Ever heard of Play? 
This. "It's going to be a long journey." Are you a solo coder / army of one there?
&gt; I've seen I could earn almost the same by working for 6 months per year as a contracter than I currently do working full time. this is actually very true, if you use your money and time wisely - last year as a remote contractor, i worked for 3 months :)
good shout on the dedicated email address, forgot to add that. even better, if you are using gmail - you can add +something after the email address when you give it out so you know who is spamming you or giving away your email address. e.g. myemail+somerecruiter@gmail.com will be sent to myemail@gmail.com but you will be able to see the +somerecruiter part in the 'to' field. yes, i would recommend speaking to an accountant regarding setting up a ltd company or using an umbrella company. i chose to take the ltd company route as i had a lot of computer equipment i wanted to buy and then claim back the expenses through my new ltd company, also a lot easier to work as a remote contractor through my own company.
S3 is also a good option because it'll almost certainly be faster than your webserver.
Like: http://start.gotapi.com/ ? 
I would deny access to that folder using an .htaccess for instance (with apache) and feed the video files with a php script. You can then check for an existing session before starting to read the video file and outputting it. Use the header() function to change the Content-Type header to a and video mime type or octet-stream. Use the Content-Disposition header to force the user to download the file, instead of the browser rendering it. The key is that Apache or whatever server you are using will deny access to that file when it is asked for it. However, php does not pass by apache, it will use the file system directly. Therefore you can control access to those files by ensuring in a php script that the current session/cookie is valid.
Let's not forget to mention [fpassthru](http://php.net/manual/en/function.fpassthru.php). Alternatively, you can use [stream_copy_to_stream](http://www.php.net/manual/en/function.stream-copy-to-stream.php) and copy the file pointer to php://output.
If the comment block extends the size of the PHP file into a further disk block (depending on the file system) then it would be one more block read. for eg. If you have a file that is 3KB without the comment block, and 5KB with the comment block and your filesystem uses 4KB blocks, reading the file will be 2 blocks rather than 1. Reading additional files, with an fstat, is much more expensive than reading additional blocks from one file. On a production server, that data is likely in virtual memory anyway, and as other have mentioned an opcode cache skips these steps anyway. The tokenizer will also parse comment blocks, but not read the contents. File this with single quotes vs double quotes, there is a tiny performance difference, but not merely enough to concern yourself with.
Personally, I just like to hit shift+k in vim to open [pman](http://bjori.blogspot.com/2010/01/unix-manual-pages-for-php-functions.html).
"World domination" needs to go back on the priority list!
In PHP programming whips you.
ignore, resolved, will post full how to on my blog. 
It can be like a dojo with something like google hangout for example. One develops, many watch e give their tips. Who doesnt want to participate can watch live. Google records it too and post to youtube if you want. :D
Sending a file with php is only an option if you're running some simple hosting and can't change your webserver apps and their configs. If you have a VPS or smth like this - nginx with its 'internal' locations would be way better (if not the best solution possible), since it produces much less load.
See above, it's a logarithmic scale. It hasn't plateaued - and even if it had, it's not indicative of anything unless you also have stats for total number of servers and the languages on them.
1. Don't store the videos in a publicly-accessible folder. 2. Use a PHP script to validate the user then serve the appropriate video. (You'll need to set a correct video header then use something like the `readfile()` function.)
You can read the articles from the Symfony creator. http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1
I've tried php streaming solutions, and it's not very efficient with video files or even with multiple images to serve on a page. I think the better solution is using php to check access rights, then to use apache mod "X-Sendfile" : http://codeutopia.net/blog/2009/03/06/sending-files-better-apache-mod_xsendfile-and-php/ http://www.jasny.net/articles/how-i-php-x-sendfile/ header("X-Sendfile: $somefile"); header("Content-type: application/octet-stream"); header('Content-Disposition: attachment; filename="' . basename($file) . '"'); 
&gt;By January 2013, PHP was being used by a remarkable 244M sites, meaning that 39% of sites in Netcraft's Web Server Survey were running PHP.
Funny, even Java is being used by "hot startups". The days of Ruby and RoR being "cool" are over. Ruby and RoR are production ready, widely adopted, and supported.
The Record class should hold the data that's returned by the get_record function. Instead of returning $record, you should be setting $this-&gt;propertyx to $record['propertyx'], then use the Record class in the controller. Controller: public function get_record($record_id){ $record = new Record(); $record-&gt;get_record($record_id); echo $record-&gt;propertyx; } A better approach is to load the record on instantiation: public function get_record($record_id){ $record = new Record($record_id); echo $record-&gt;propertyx; } Note: You can overwrite the magic getter property so you don't have to write a public property for every column in the database, but that goes against the object-oriented approach.
This is a major gripe I have about many frameworks. While many don't explicitly state (Except CakePHP!) that the model is DB-specific, almost all of them make it very easy to fall into that trap. A model is *not* for database transactions. A model is where your heavy lifting belongs. This means data manipulation, retrieval, etc. I personally dislike having a model have so many responsibilities, however, and like to split the "traditional" model into several parts: 1. Domain - basically renamed model; this is where my data manipulation, loops, class instantiations, etc goes. 2. DAO - This is my data access layer; it retrieves data from a source, be it SQL, remote API, local files, etc. It does no data manipulation and only exists to do CRUD. 3. Entities - Contain the data retrieved from DAOs in an easy-to-use interface. 4. Validators - Set the validation rules for entities. So, my controller instantiates a Domain. If it needs to do *anything* more than simple operations, it interacts with the Domain/s. - My Domain retrieves data from a DAO and hydrates an entity object (just fills it with information). - OR my Domain accepts data from the controller and manipulates the data to fit into the entity object, where it's either returned back formatted, or passed into DAO. There's a bit more going on, obviously, but this is the gist of how I work.
Magento is a beast. Optimizing it for speed can take some time but there are some things you can do to vastly improve overall speed. This advice would apply to most any PHP application. - Installing APC and setting apc.stat to 0 on production. This will cause PHP to not stat the file on each call. The downside is you will need to work into your deploy process a way to refresh APC cache when you redeploy a new version. - Using memcached to store DB results. Memcached is a key/value memory store and is excellent for storing expensive DB calls. This is also great for configuring Magento to store sessions in. When your site gets busy, it will lighten the load on the DB server. - Magento EE comes with FPC (Full Page Caching). By default, cache is stored locally on disk. You can set magento to store the cache within Memcached. This is great for multiple web heads as they are able to share the cached results. - Setup a varnish cache. This is the single most powerful optimization tool you have in your arsenal. I highly recommend reading through the varnish manual. Magento has a few extensions available to help with management of a varnish node. Also, varnish supports ESI (Edge Side Includes). - Using a CDN to offload static content. By serving up images, css and JS from a CDN, those requests do not put load onto your main web heads. By using the specific tools available to you, you can tune magento from handling 20-50/req/s up to 5K-10K req/s. There are hundreds of things you can do to tune magento. Listed above are some of the biggest wins. Source: I work DevOps for a magento site that get 1-3 orders per second during peak hours.
Wow, that's a nice function I didn't know about! Thanks.
I only skim read the article, but this seems to cover everything quite proficiently. A refreshing change to see the why and not the how.
Any business logic (tax calculations, number of players involved, scores, how many chickens you think will hatch) goes in the model. Any logic related to presentation should go in the view, but if its complex logic putting that into the controller and setting it as a variable or property of the existing data is a better shout. SOME MVC frameworks add Presenters, Composers or ViewModels. These are the same thing pretty much with a different name, so put complex view logic in there. **tl:dr** Don't set a CSS class in your data model. That's way too much presentation in your core data layer. And no, your models don't have to be DB only, they can be Redis, XML, text file or a Fortran interface for a freaking tape drive if you feel like it. The outside code (controller) should never know the difference.
thanks for reading...i didn't want to delve too deep into how to set this stuff up.
Although Apache's Event MPM doesn't benchmark nearly as well as Nginx, I believe many benchmarks between the two include static assets in the benchmark as well as dynamic pages. I'd guess that on a pure PHP only benchmark, Event MPM would benchmark very closely to Nginx in that respect if using PHP-FPM. Since the topic is scaling, then the sane thing to do would be to simply put your static assets on S3, CDN, etc. Most people might actually prefer to stick with Apache and use the Event MPM in this case as it would allow legacy code to still use .htaccess files rather than having to figure out new Nginx rewrites. Also iirc, every time you would normally make an .htaccess change, you would have to make a configuration change to Nginx and bounce the service.
Nice article! I'd been casually wondering what this Nginx thing was, so this has served as a very timely introduction :) One thing though: your bullet "Don't forget to set up your expires headers. See this awesome google presentation on the subject." down the bottom doesn't have a link on it.
Looks to me like the CURL request is probably failing (`curl_exec`). It returns `true` or `false` based on success or failure and you're storing that in `$result`, but you never actually check to make sure it succeeded. You could try replacing the conditional at the end with this: if ($result &amp;&amp; stristr($buffer,'Your information has been processed securely.')) return array('status' =&gt; 'success'); else return array('status' =&gt; 'declined');
Good article! I recently discovered Nginx, etc and have been experimenting with offloading PHP to another server. Regarding syncing the code, have you thought about DRBD as a another solution to the code syncing?
nope, can you clarify DRBD?
thanks! sorry about that..fixing now
xcache has been my goto. Is APC better?
Yes, probably.
Thanks for the article. This is what I want to do for a living, scale web applications. Tweak them and the servers they're running on for every last little bit of performance. Someday...
This is a really bad idea without some kind of sanity check, that's going to cause an infinite loop at some point. You should have some max timeout and track out how long it's been going and bail if duration &gt; max_timeout.
Thanks for the clarification about php_memcache vs php_memcached on Windows. I've spent lots of time searching for a php_memcached.dll, only to come to the conclusion that it doesn't exist. Hopefully people will discover this post before looking! For anyone interested, the reason it doesn't exist is that php_memcached depends on libmemcached, unlike plain old php_memcache, which has no external dependencies. Libmemcached has historically been unavailable on Windows (minus a few forks that added experimental compatibility), so it simply never could be built.
thank you for clearing that up!
Both Apache and nginx support graceful configuration reloads/restarts with zero downtime. nginx even supports graceful in-place upgrades with zero downtime.
As others have said, the best MVC practise is [Fat Models, Skinny Controllers] (http://www.slideshare.net/damiansromek/thin-controllers-fat-models-proper-code-structure-for-mvc)
I'm pretty sure you don't have to take nginx offline and then start it up again, as I have previously completely changed the whole configuration file in nginx, and then issued a reload (not a restart) and now I have instantly switched to a completely different configuration without noticing any downtime. Not to mention, nginx binaries can be upgraded without taking your server offline at all. Also, in most applications, you don't tend to be adding rewrite rules constantly once the app has gone live.
Zend Optimizer+ could be a part of 5.5.0, heard nothing about APC. so there is that (= https://wiki.php.net/rfc/optimizerplus
Didn't know what is was either, http://en.wikipedia.org/wiki/DRBD
I hope not, unless they'd add a local key/value store API like xcache and apc have.
Obviously they won't, at least before the integration. 'cause as the RFC says the integration itself would take a while
My main reason to use nginx over Apache is not performance. I think a well configured Apache server can work just as fast as nginx, or at least in the same range. The reason I use nginx is that the "well configured Apache" part is really hard. At least I was never able to configure Apache in a way that can handle larger load. Clearly it is possible as many large sites use it, but I was never able to get it there. With nginx on the other hand things are rather simple and "just work".
 Irony: I thought you still hadn't fixed it because I had the original version cached in my browser.
Agreed. I'm not opposed to going out and reading all the docs and figuring it out myself, but it's always great to follow along with someone who's already dealt with whatever I'm about to deal with. It makes the process that much more sane.
I don't think it'd be worth while to just to target the MVC Components of various frameworks thought. Since we are talking PHP I think you'd want to also look at: * Sessions * Databases * Caching * Configuration * ~~Performance~~ &lt;-- not worth the trouble imo, too many factors, and too many flame wars 
lol
i'm thrilled that this could help you.
Meanwhile I'll give you â‚¬50 for a Wordpress blog for my dog.
As for the performance, something like [this](http://phpixie.com/blog/php-framework-comparison/) should be enough...
Oh, I get that it's logarithmic, but flat is still flat, which is what this chart shows towards the end. Agreed on the server quantity, but one could assume the the totals for the other values (IP address, domains, etc) have been increasing throughout that time.
True, apache sucks in this regard as well as the .htaccess overhead on every request. 
IMO the number one performance benefit of Nginx over Apache is memory usage for keepalive connections. Apache's prefork MPM uses about 20MB per connected client on my system, so with, say, 1000 keepalive connections, that's 20GB of memory sitting there doing absolutely nothing. Meanwhile on Nginx, memory usage per keepalive is approximately zero. Nginx averages 3,000 connected clients on my server, try doing that with Apache!
exactly, and after thinking about it, I think you could do all that stuff with a todo app - it's small enough to do just a little bit of everything, but it can take advantage of most of what frameworks have. another idea would be a blog... blog is the typical "wetting my feet in the language" project for PHP.
That hits so close to home it hurts. Right now I'm fixing a Wordpress store with 50 WP plugins installed. Yes, I said Wordpress store. A web-store built on top of Wordpress. This is not where I saw my life going.
Personally, i'm getting better performance with XCache. And there's one very useful thing that XCache has and everyone else seems to neglect: deleting cache entries by prefix. xcache_unset_by_prefix('article_'); 
You're not really decreasing code leakage by hiding those constants behind methods, you're just doing it with methods instead of constants. It's not dissimilar to the stupidity of making instance variables private then providing one-line getter/setter methods; you haven't encapsulated anything, you've simply wasted your time writing boilerplate. 
Up vote for the mojoLive badge.
same performance. apc has a nice UI and is very configurable. BUT it doesnt like threads, so all my apps run mod_php.
it has daddy issues.
i havent used nginx for anything yet, just got into varnish as a reverse proxy. how does nginx compare as a reverse proxy vs varnish? or do the somehow compliment each other.
If you are looking to scale, don't forget to use unix sockets over TCP. A cheap optimization if you are dealing with high loads.
This isn't scaling, this is making a single web server more efficient.
A blog would be perfect.
I'd be happy to contribute for CodeIgniter.
Providing getter/setter lets you throw shit into the interface layer so you can have multiple implementations for one interface, although I have a huge distaste with getter/setters, and yes you are correct they really don't provide much encapsulation, however PHP provides more encapsulation than Java with its value semantics. However I don't agree that isSent() is leaking, it is only returning a new bool data type, not an internal member variable. In fact it is kind of nice since the API user does not have to remember the correct constant type to compare to or the best way to compare them. I much prefer this: if ($request-&gt;isPost()) { ... } over these: if ($request-&gt;getMethod() === 'POST') { ... } if ($request-&gt;getMethod() === Method::POST) { ... }
Also you can check these stats too http://w3techs.com/technologies/history_overview/programming_language
http://www.exploit-db.com/search/?action=search&amp;filter_description=wordpress
Their numbers appear to add up to more than 100%. Either these stats are not representing what I think they're representing or that's a very impressive statistical trend. EDIT: Ah &gt; We investigate technologies of websites, not of individual web pages. If we find a technology on any of the pages, it is considered to be used by the website. So... websites can count towards more than one technology, and this doesn't guarantee that the site in question is really actually using the language - just that it is available.
sorry if you felt that way.. but recently only i had this issue and in process found few probable solutions.. so just thought of combining all the approaches in one single place..
Sure... If you used the evented mpm. Unfortunately it's incompatible with mod_php so you'd have to use cgi/fpm anyway. 
i had a setup exactly like this using a Symfony 2 site. It all started ok, then slowly but surely more and more pages had a 502 error. It got to the point where 10k of my pages had 502 errors, out of 70k pages. I dropped everything and rebuilt (debian) running a bog standard apache2 install. It's not as fast, nor as scalable, but it's not faulting either. I know it was something I did wrong in the config - but without getting very unixy, I couldn't figure out why. My theory now is, worry about scaling my web server when the traffic grows significantly. I know that's relatively short sighted, but it's one less thing to worry about in the early stages of my bootstrapped start up. 
Have you asked this question at the PHP fusion forums?
I was expecting something a little bit better than that since ShutterStock has (from what I heard while interviewing around) 50+ PHP developers. This is as simple as it gets but even within this simple implementation there are tons of issues. if ( isset($this-&gt;current['file']) ) { // Run route file if ( file_exists($this-&gt;current['file']) ) { include($this-&gt;current['file']); } else { echo 'NO ROUTE OR ROUTE FILE: '.$route; } } } else { error_log("Sorry, but I'm afraid I can't do that. " . $route); } Just look at mastery above.. error_log? then echo for other stuff? What? I'm not even going to touch several formatting problems and file naming conventions among of other weird things. "Basecoat is designed to be a centralized core code base that websites are built on. " Sorry man, but it should not be a core of anything in the current condition. 
Dafaq did I just read?!
This must be why ShutterStock is hiring via every single recruiter in the city. For the last 6 years straight.
Heh
thanks for pointing this out. i will definitely look into xcache
without having used varnish, i would hazard a guess that varnish will serve static assets and other cacheable resources so apache doesn't have to handle it which should save a lot of memory and cpu
I would always advocate frameworks especially for complicated projects. However why Zend? It is [one of the slowest](http://www.ruilog.com/blog/view/b6f0e42cf705.html) around. I would recommend Laravel.
it sounds neat but part of my workflow is typing a function name in google, and the first result is usually php.net so i'm not certain i would use this
[Aptana Studio 3](http://www.aptana.com/) has built-in documentation.
There was something similar some time ago here, might want to check it out: http://phpixie.com
What are your thoughts on Cakephp? Just curious, it's the only MVC php framework I've ever touched so it's really the only thing I can relate to (as far as PHP MVC's go)
Wow, thank you so much! I've already read the "How I explained REST to my wife", and it's a pretty cool post. I've previously implemented very simple REST interfaces, but now that I want to go big, I'm finding myself lacking experience in best practices. Many thanks! 
When I'm writing code, I need some small routine that runs the code and lets me verify it's working. That routine might a well be a test.
The framework has 1200 lines of code, and can be explained file by file in a way that introductory PHP students can understand very easily in a single session, which is very useful in the case of PHP meetups.
From the looks of this page, it's a little too heavy for my tastes: http://api.cakephp.org/ It really depends on what you're building though. Use the framework that is right for you and your coding style. My personal favorite PHP framework is Kohana.
Our route syntax is almost identical!
Maybe nice to teach some basics of MVC, definitely not nice for real projects
It means that there are Java sites that have a WordPress blog.
For the record, Shutterstock has 5 PHP developers. Most devs are Perl and/or Node. Basecoat was born of the need to interact with existing systems (some legacy) through services and occasionally on a much lower level. We could make no assumptions and have no impositions.
I would say that Silex is significantly easier to learn. The reason is simple: Symfony requires you to know a shitload of concepts upfront. Without an understanding of what a Dependency Injection Container is you're going to be completely lost. Silex still has the same concepts, but hides them from you, allowing you to ignore them until you need them.
This is fucking ridiculous.
Overkill at it's finest!
In case anyone is wondering: https://github.com/thestringy/freezing/blob/master/stringy.php
Its core libraries also grows &amp; grows. ;)
As ridiculous as the dimension around the 10 lines of code feel, please keep in mind that achieving cryptographically secure (pseudo-)randomness is not that easy. I'd recommend using `openssl_random_pseudo_bytes()` as it is available on all system (PHP 5.3). If you need random strings for salts, don't roll your own crypto. Use https://github.com/ircmaxell/password_compat so you'll be ready for PHP 5.5. If you need random names, addresses, etc. then I'd recommend Faker. https://github.com/fzaninotto/Faker PS: Also please don't ridicule someone for open-sourcing code. That's not what a community should do. We can all learn from each other.
&gt;It is funny how as a .net 'programmer' you are automatically handicapped in that you're totally useless without an IDE that does everything for you. Way to be a complete asshole, bro.
It was a fair jab.
No, I don't think it is. First of all, it generalizes the entire .NET development community, and secondly, it assumes things about the OP which probably isn't even true (sounds to me that he's just asking about nice-to-have features). If you want a discussion infused with bias, head over to /r/programming instead. 
As Nicoon said, I'm far from useless without an integrated development environment. I simply would prefer having everything in the same place for the convenience.
Thanks, I was only familiar with Netbeans from a Java perspective. I will look into it's PHP abilities. Its handy to be able to manage the web server from the IDE for various reasons like automatically attaching the debugger, managing the instances and ports running locally, etc etc.
Thanks mate, I will dig into that. I'm frankly a little shocked that there doesn't appear to be much consensus in the PHP community on which IDE to use. I expected there to at least be front runners by now.
As PHP is mostly used in UNIX environments - I'd recommend you to go the UNIX way and use specified tools for each task. * php -S localhost:8000 as dev webserver * xdebug for debugging (works well with Netbeans and PhpStorm) * Use console commands for generating code, managing database migrations, routing, assets etc. (most modern frameworks provide these) Don't try to do everything with IDE! 
Take a look at PHPStorm, it allows you to configure your own internal servers (including the built in one from php 5.4), it has connection to xdebugger and the zend debugger, has full syntax highlight, plus like a hundred other really really nifty features (inteligente search and replace for example). It is not open source (and cost you some cash), but its one of the best IDEs for PHP I have ever used (specifically out of Aptana, Eclipse, and Netbeans)
There *are* front runners. PhpStorm is among the most top-voted IDEs whenever this topic is brought up, however it costs money, so some people might be more attracted towards free open-source alternatives such as Netbeans or Aptana. Then you have the crowd who prefer more lightweight editors such as Sublime or Notepad++. 
&gt;inteligente You a Spaniard? :)
I'd say PhpStorm is the front-runner. I've tried them all and it's recommended. But more often than not, you'll see people wanting to use a free solution and that's where everything else comes in. 
This will get you started on everything but the IDE: http://www.wampserver.com/en/ And then pretty much any IDE will work.
I use eclipse for android development, and phpstorm for php. The latter is much better a performing and helpful IDE than eclipse, eventhough eclipse has more advanced plugin support. Running on a dual core with cheap SSD. The php community is maturing. In a few years the static analysis and testing tools will be so much improved, that's when IDEs like phpstorm will be as big as visual studio. Of course there'll always be the basic editor purists.
PHP IDE's, in general are horrible. You might have luck with Zend Studio with a locally hosted copy of Apache + PHP. Its debugger is the most solid that I've seen, but you have to install a Zend component on your server. It also has a tendency to get lost when stepping through code, especially if your code has any sort of convoluted paths, symbolic links, or weird class names. It's also not free ($269 I think). A great feature, IMO, is the PHP code analyzer, which is extremely nice for a non-compiled language and has caught countless bugs for me. You can jury-rig something similar with code-sniffer, but the Zend Code analyzer just works right out of the gate. If you don't want to drop the money for Zend Studio, Netbeans for PHP is a decent alternative. It has decent intelli-sense, but again it can get easily confused if you have weird class names or pathing. It has no built-in debugging support, although supposedly you can use xdebug. I've never gotten it to work successfully for me codebase, however. 
console when required - yes (e.g. composer, or framework-specific commands). php -S as server - definitely no. use one of the standard apache/nginx + php combos (personally I use nginx + php-fpm)
You can come pretty close to something like that with Komodo IDE. It's not exactly open source, though they have an open source version called Komodo Edit. You can configure it to listen to your web traffic and it fully integrates with Xdebug. It's my editor of choice.
About IDE + server. The webserver itself is obviously a standalone app, as for the server management - it's hard to do that in the PHP world. There are too many possible combinations of a web server + php installation to implement them in an IDE.
&gt;You won't find anything like that for PHP. I disagree. [PHPdesigner](http://www.mpsoftware.dk/phpdesigner.php) in combo with a [Xampp](http://www.apachefriends.org/en/) setup will do most of that.
You misunderstand. The web server isn't built into the IDE, like it is in Visual Studio. This is what OP was getting at. We didn't say anything about IDEs not being able to integrate with a LAMP/WAMP setup.
You are aware that the author (Ulf Wendel) works for Oracle on MySQL, right? He developed the native mysql driver (mysqlnd).
Superior is a bad word, but this makes sense to me http://en.wikipedia.org/wiki/Unix_philosophy
https://panic.com/coda/ It's amazing. It justifies a purchase.
About 'localhost' installation - it's better to install every part (web server/php/db server) by itself, not a combined package like WAMP/Vertrigo/smth else. First, you'll know how it's working and how it's connected to each other. Second, you'll configure everything the way you want, not like some people configured it for you. Third, maybe you don't even need that mysql installation that comes in the package or you want to use nginx instead of apache. ps. I'll also say that it's better to work with PHP under nix system. Don't want to start any holy wars 'bout OSes, but it's true. Yes, most of the PHP-related stuff is doable on Windows (except, at least, php-memcache**D** extension - it just doesn't exist). But when it comes to using SSH + any popular VCS - this is where nix owns.
OP is probably not on a Mac, coming from .NET dev.
Cool. Where from?
Even if he's on Mac, I'd never suggest Coda since there is Sublime. More to that - OP asked for an IDE, not a text editor
Very true. I'm a Sublime user.
Me too (=
any work in web development will help you get further work in other web development projects. You're focus should be on knowing web development, not just knowing a specific language. Things you learn to do in one web-centric language will carry over if you switch to another web-centric language.
you might be misleading the OP.. there isn't anything that will be as good as the visual studio IDE.. but there are a number of IDEs for PHP (or IDE's with a PHP plugin) that work reasonably well. You just wont have as detailed help with locating errors or debugging from the IDE.
PhpED does all that. http://www.nusphere.com/products/index.htm Not free though.
Visual Studio doesn't actually run the web server. It integrates with IIS.
You're incorrect about that. Visual Studio has both a built-in web server, as well as integration against IIS. The built-in web server is called the Visual Studio Development Server.
&gt;there isn't anything that will be as good as the visual studio IDE Sure there are. &gt;You just wont have as detailed help with locating errors or debugging from the IDE. Yes you do. Have you not tried PhpStorm, or any IDE which has integration with Xdebug?
No problem.
Indeed, you shouldn't focus on learning a language. Focus on learning to program and then you can use the language that will suit the task at hand instead of only knowing how to solve problems in one language.
Oh, cool. I was in Venezuela back in '08 when my brother got married. His wife's family is from over there. It's an.. interesting country :)
Do you do anything besides throwing insults left and right?
Then he is either not aware who his audience is or has no idea what Memcached actually does if he thinks adding caching layer on MySQL might be good enough to replace Memcached installation. Makes zero sense.
No need to dualboot vagrantup.com
If you are new, you are going to learn a LOT no matter what language you're working in -- XSS, CSRF, scaling an application, code management, team dynamics, and so much more outside of "well, in php, you structure a for loop like this..."
Actually the new netbeans 7.3 release candidate incorporates the PHP internal webserver - You can configure the project to use "php -S" for all run and debug operations - it's pretty damned sweet. 
&gt;its still not as good as what you'll get when working on .NET projects. It's perfectly able to debug code just as well as Visual Studio does it. What are you talking about? In a matter of fact, I dare even say I like PhpStorm a fair bit better than Visual Studio in certain regards. 
You can try it for free and decide for yourself.
I have both Coda and PhpStorm on my Mac. I only use Coda when my Java is borked (thanks, Apple) and it's a last resort. PhpStorm does the error checking as I'm typing. (At least the Mac App Store version of) Coda doesn't do that. That, or I never found the setting to turn that on.
Upvote for PhpStorm
First of all, CamelCasing is the norm when it comes to OO. Secondly, it sounds like you're interested in the [Data Mapper pattern](http://www.martinfowler.com/eaaCatalog/dataMapper.html). Essentially, the data mapper's responsibility is to act as an intermediary between the controller and the data source, and map the data over to objects which is then used in the communication between the two. The controller calls the data mapper, and an object is returned containing the data. That object may then be passed to a view, manipulated and sent back to the data mapper to be stored in the data source, or whatever. An example: class PersonMapper { public function fetchAll() { ... } public function getById($id) { ... } public function save(Person $data) { ... } } class Person { public function setId($id) { ... } public function getId() { ... } public function setFirstName($firstMame) { ... } public funciton getFirstName() { ... } public function setLastName($lastName) { ... } public funciton getLastName() { ... } } -- $mapper = new PersonMapper; $person = $mapper-&gt;getById(1); echo $person-&gt;getId(); // 1 echo $person-&gt;getFirstName(); // John echo $person-&gt;getLastName(); // Doe $person-&gt;setFirstName('Luke'); $mapper-&gt;save($person); // Updates data for id 1 (John is now Luke) -- $mapper = new PersonMapper; $person = new Person; $person-&gt;setFirstName('Jane'); $person-&gt;setLastName('Doe'); echo $person-&gt;getId(); // NULL $mapper-&gt;save($person); // Creates a new record echo $person-&gt;getId(); // 2 
I guess we'd have to know the full scope of your code library to give you advice on optimizing it. Keep in mind, youll get a lot of conflicting answers, but it really comes down to: * Will the patterns you create limit the use of your code? * Are you able keep it low profile to perform simple tasks? * Will you have dozens of objects loaded just to write a simple note? * Are you abusing memory? Youre right, this will be good practice for learning OOP, but dont just wrap your library into classes for the sake of being organized, you may take a perfectly good code library and turn it into a unmaintainable resource hog. OOP is an ideology, not a technique. Also, stay away from magic until you learn all the basics.
That's what I said. Knowing several languages is pretty much the same as knowing how to program ("skills" as you said). If you only know how to code PHP then you likely don't know how to generally program (speaking from experience) - you just know how to write PHP code. A resume that only shows PHP will be a red flag to most companies as they usually want full-stack engineers rather than someone who can only write in a single language. Interviews are usually to get to know you as a person and only offered to those who look good on paper - which you won't unless you *learn how to program*.
as far as imitating pros.. I think on a large team they'd use a `Note` class since it's more modular/reusable. For just yourself, it's probably a premature optimization (actually, it's not an optimization, since more classes probably means more stack space used), you might just write a method like `getNoteProperties`.
there are a lot more entry/mid-level PHP jobs than ruby jobs, fwiw. It won't hurt to know PHP in that respect. It's good to know both, they're very different, I think PHP is a bit more portable to other domains since it uses the common C syntax and actually a lot of C functions as well. Its OOP is also similar to Java. Also, just Rails? Ruby is as powerful a language as PHP... Rails is just a framework. It's like PHP people who only know Wordpress... sad.
that is called freedom
In some sense, there's just less to debug - the internals of the language aren't compiled ala Java or .NET, so there's a lot less 'stuff' to debug in the first place. There's also not a lot of 'step by step' stuff you can do through the PHP internals, whereas with .NET, you can step through a lot of the .NET core libraries. I used intellij and java stuff and phpstorm for php stuff (I used zendstudio for some php stuff too - some plugins I use for some projects aren't available in phpstorm). 
I wouldnt sugest using the PHP internal webserver (php -S localhost:8000) unless you are sure that you're not going to use/need any webserver features or mod, ex: mod_rewrite... 
First, understand that OO makes more sense the larger the app is. If OO seems silly, it's because this app seems so small. Secondly, there is no 100% right way to do things. You will get different answers on this. If you're using a framework my best advice is to do whatever it recommends. Trying to do your own thing will eventually bite you. If you're writing your own framework, do whatever works for you (which will take time to figure out). Finally, on to the real answer: Most frameworks I've seen split things into two classes. One is the actual model that mirrors your database table. There are very few/no static methods in this class. It's up for debate how much business logic is in here. The second seems to have a different name in every framework, but is a class that handles the logically static methods, things like fetching instances of your model based on criteria. The people that don't put the business logic in the actual model put it here, usually. tl;dr: Do whatever your framework wants you to do if you don't want pain. If no framework, there is no single answer to this.
Netbeans + any of the AMP packages. (WAMP, XAMMP etc)
Netbeans and XAMPP. WAMP packages all the server stuff really easily for a dev environment, and net beans handles everything else. Look at setting up xdebug to get proper debugging in your ide too.
It can manage the debugger side of things: look up xdebug. Though in PHP land errors and bugs are a little funkier than you'll be used to.
This person clearly does not have a good grasp of the CodeIgniter framework. Granted, while some of the features he wanted are not in the core framework, he went the wrong way about extending it. Also, he's obviously ignored CodeIgniter's coding style guide. There are many good extensions of CodeIgniter that add oft-missed functionality but do it the right way, instead of being a hack.
That does sound awesome. I'll have to check it out. 
Thanks for the correction. It's been a while since I bought Zend Studio. The companies I worked for usually bought them for the developers.
Well, I was just using wordpress as an example of something a lot of people know without knowing much else about PHP - how to set it up, install plugins, copy/paste code, but not much else. I think, or at least hope, that most people that know a full stack framework could understand the code inside the framework and can write PHP without its help.
Won't find ANYTHING like that for PHP? PhpStorm is decent, although I find it has some major quirks that bother me every day. NuSphere PhpEd is very slick and streamlined and includes built-in web server, debugger, and browser(s). It lacks certain things, like PhpStorm's "language injection" (highlight a string as another language, often automatically), or at least it did at 5.9 (they're at 6.1 or something now). All in all, if you're willing to pay for it, I recommend PhpEd as a well-designed PHP IDE. 
PHP came from the open-source UNIX world and draws many of it's developers from the same wider community. The UNIX/Open Source community has historically taken the "many small utilities that do one thing" approach to composing large systems and it reflects in the development environments, the PHP community is not really that different. Because of this, many if not the vast majority of PHP developers will use many separated components in their workflow, even if they're using an IDE instead of VIM or any other advanced text editor. While I use PHPStorm daily for my PHP development, I really only use it for project navigation and debugging. Everything else, from unit testing to hosting development servers to managing source control state I eschew the built in tools and do them by hand. It follows naturally if the bulk of the customers really only look for an advanced text editor with project navigation and debugging UI, it's really really easy for competitors to continue to enter the space and keep the waters muddied. PHPStorm is, as of right now, the community favorite but it will get replaced just like PHPStorm replaced NetBeans replaced Eclipse replaced Zend Studio etc etc.
I went the other way around. I started with PhpEd and switched to PHPStorm. I prefer that PHPStorm uses standard stuff like Xdebug and PHPunit instead of NuSphere's proprietary debugger.
[Netbeans](http://netbeans.org/features/php/index.html)--has most of the bells a whistles, including doc info, completion, and hooks up to xdebug for remote control. There are also a lot of formatting tools, although it does not yet support PSR-2 perfectly. It's also oracle, so who knows what could happen with licensing....
Notepad+Â± guy reporting in.
As others have said, PHPStorm is the one you want. My little company has used every IDE and text editor under the sun and now we all use PHPStorm and everyone loves it. The full price is about $100 but a couple of times a year they have a half off sale so you can easily get it for $49. They also offer student pricing (I believe). If you must have open source then try Netbeans. It's slower that PHPStorm and a bit less capable but still a nice IDE.
Do not get annotations and comments confused: Comments = sod all difference. Annotations = minor difference, if processed. We're talking about comments, not annotations. Annotations live in comments, but that doesn't mean comments are slow. Get it?
I don't know if you foresee yourself using other languages, but I like Netbeans because then I only have to use one IDE for all of my non-.NET languages. I do about 40% .NET, 40% PHP and 10% Ruby on Rails/Java (Android). 
&gt; First, understand that OO makes more sense the larger the app is. If OO seems silly, it's because this app seems so small. Absolutely. In my company, now that we have a sizable team, trying to figure out "What columns came back in that query?" is somewhat annoying and troublesome. We're gradually converting things over to objects with consistent interfaces and, more importantly, phpdocumented getter/setters to help developers consistently and correctly use the objects. It makes very large codebases significantly more maintainable.
I bought it during that "end of the world" sale. I do like it, but it also has been extremely buggy; at least on OSX. Also, if you *do* have issues most of the documentation and tech help frequently seems geared towards windows.
Also, what are your system resources? Just because you deal with code, and not super heavy system dependent programs (like Photoshop) doesn't mean you can't do well with a good machine. I'd like to _figuratively_ burn you at the proverbial steak for saying that Sublime Text is more productive than Eclipse; that my friend, is just not true at all! If you find that you truly believe that it is, then you're not using Eclipse correctly. __That's the skinny of it.__
&gt;whereas with .NET, you can step through a lot of the .NET core libraries. You can step through some assemblies, but you need the symbol files from microsoft to be able to. It takes some tinkering, but frankly, I've never had the need to, nor do I think that most people do. So by average use-case, I find VB's debugger and PhpStorm's debugger to be fairly similar. 
I use Notepad++ for simple stuff. It's free and easy to use. For a full IDE, I use Aptana. Again, it's free and easy to use. Best of luck finding what you're looking for.
Wow. Going for an award or something? "Asshole of the year"?
I think you didn't get my point. You mentioned that in the PHP community there's no consensus on which IDE to use. That happens because there's many to chose from, and that is gives PHP developers freedom to chose. If there's not one IDE that people stick more to, that for me only means that they are all good, or different people different preferences. That's all! And what makes you think that PHP developers don't know .NET? I consider myself a PHP developer. Does that mean I know less?? I know .NET and have developed with .NET since its birth... but I stick to PHP as a matter of choice. And yes, I Know you can compile .NET from the command line, have compiled tons of code myself, I know and have used other IDE's to work with .NET, in case you don't know, MS Dev. Studio is not the only one either. Now, if you come here to look for help to jump into PHP and all you do is bash the tools and the community, I guess you are getting in through the wrong door. Maybe you should stick to your almighty .NET! 
I wasn't trying to come up as a smartass, my point was to write stuff all by yourself first to familiarize with the language and then use autocomplete when you have a solid grasp of it since OP is coming from another language. Nothing wrong with syntax highlighting though, don't know why I brought that up.
&gt; Jumping in to PHP from .Net Why? 
I did this. I needed this upgrade for a one-off project, and did not feel like wasting the client's time and money on learning the ropes of the community and CI's standards just for something I'll most likely never use again. I admit, I never even checked if the plugins I needed existed because it all seemed so fundamentally flawed when I realised that they were missing, and extending it on my own into something I'm familiar with only took a couple hours and quickly got it approximately to where I wanted it to be. Point taken, though, thanks for the feedback. If I ever end up in another CI project, I'll make sure I do a better job at extending it with what I need. Cheers
&gt; For example, in PhpStorm, you can set it up to use the PHP internal web server, which you can launch from the "run" button. What's the advantage of that? Over Virtualhosts?
Is there a reason you chose to use CI for a one-off project then? While CI isn't quite up to the level that others like CakePHP, Laravel and Zend/Symfony are it's a very capable and lightweight framework that comes with most things a project would need bar an authentication library and ORM. If you do come around to using CI again I'd suggest you have a good poke around the documentation - I'm sure you'll save yourself a heap of time and see what else it has to offer!
It's not an IDE by design at all (although combining enough packages for it can let you get pretty close to what would normally be termed an IDE), but is easily one of the best general code editors out there. You can try Sublime 2 for free for as long as you wish.
It has 86% upvotes currently, which is higher than average. Vote fuzzing can easily account for the rest.
Have you actually read the article? He did not implement the memcached layer and even said, that you can only compare stand-alone memcached to the one integrated in MySQL 5.6 under certain circumstances. You may also want to read up on http://dev.mysql.com/doc/refman/5.6/en/innodb-memcached.html.
The advantage of using the built-in development server? It's quick and easy to setup. php -S localhost:80 And you're off.
It had 7 up / 5 down votes when I posted this
+1 for aptana
Have you tried Sublime Text? Not to start another holy war or anything but ST is many times better than NP++.
I've been doing PHP since 2003 and .NET since 2010. Let me know when you find one.
It wasn't my choice, unfortunately. The project I was hired to finish was already partially done in CI and the client insisted on keeping it as it was "the only one he thinks he can follow". I'll have a more detailed look next time, if I find myself in a similar situation. This merely seemed like a decent shortcut to get things done on time, and I thought it might eventually help some people who need to get it off the ground quickly.
No I haven't. I'll give it a shot.
Well that's funny. I'm jumping from PHP to .Net. The best PHP IDE is PHPStorm, no doubts. About server, just setup remote connection in PHStorm to VDS with *nix system where Apache/Nginx is installed. And you will feel like with IIS Express. Debuging: xDebug. But you will not use it only becouse to write echo or print_r is faster, then start debuging.
The easiest way to convince a sys admin to upgrade is that 5.1 has been end-of-lifed, meaning that it will no longer get security updates and such important stuff. Seriously, the last 5.1 release in 2006.
it wasnt working for me anyways, only cached a single file at a time. downgraded to .13 soon after installing.
[PhpED](http://www.nusphere.com/products/phped_features.htm) has all the features you described, plus things like code insight and automatic refactoring (a la Visual Studio). Plus it has all those features for Javascript (and HTML/CSS as well). Everyone is generally in love with PHPStorm around here, but I would recommend at least doing a side-by-side comparison with PhpED before purchasing either.
PhpED has a built in web server, and allows running/debugging on either its built-in server, a local server, or even a remote server.
http://nikic.github.com/2011/12/28/Supercolliding-a-PHP-array.html Pay special attention to the "Hashtable collisions as DOS attack" section. [Reddit thread about this problem.](http://www.reddit.com/r/PHP/comments/nu4ly/supercolliding_a_php_array_inserting_65536/)
Well, it depends on your position in company. The person who is in charge of developers should say, that 5.4 is needed to use modern high-quality components (I refer to ones installable with composer/packagist). And using good components is the recipe for high productivity, better maintainability, etc. You don't want to reinvent the wheel, especially for old versions of PHP
Even 5.3 is reaching end of life in a month. I really hate it when I'm stuck in a situation where system devs won't listen when I tell them to upgrade us - but they're in charge of much more than just PHP versions, so keep that in mind.
Stop using Java based crap!! That includes PHPStorm, Netbeans, and Eclipse. Pure crap! Supporting Java is a crime against the whole computer industry. It leaves you open to zero-day exploits!!!! http://www.nusphere.com/products/phped_features.htm PHPed is EXACTLY what you are looking for. It has a built in debugger that is able to do live breakpoints.
Sublime has no SFTP/FTP/FTPS support without an external plugin and doesn't have WebDAV support at all.
Fair enough. I haven't used PhpED and it doesn't appear to be a feature that's particularly well advertised. Couldn't find a single mention on its product page about it, but I did find some mention about it in the forums. Interesting.
Punch them in the throat.
I've had some pretty good luck with xcache, if anyone needs an alternative
It's not EOL, it's 'security-only fixes' mode. EOL will be a year from 5.5.0 stable release
This topic is something I'm very interested in. I'm in the process of doing exactly what you're talking about with a fairly large codebase. We had talk of a complete rewrite into Symfony2. But after watching Paul Jones' talk on refactoring (http://vimeo.com/47849625), it was clear that refactoring was the way to go. Watch that video. He doesn't talk about a specific framework. But introduces steps that will need to be taken regardless of framework that you choose. Also, instead of jumping full into a framework consider introducing parts of frameworks slowly. The Symfony Components are perfect for this. In fact I'm pretty sure Laravel is using a few of them. A comment in this thread mentioned introducing Composer into your app right off the bat. If you have some PEAR dependencies, start using Composer to manage them. Even if you do not have any 3rd party dependencies (yet) use Composer's autoloader. We've started moving away from PEAR_DB to Doctrine DBAL/PDO. Having Composer in place made this move super smooth. A great way of gently introducing Dependency Injection into your app would be to use Pimple as your DIC. Another thing, lay the foundation for easily adding unit tests. If they're easy and straight forward to add then folks will be more likely to do it.
I've been using and have had success with the 6.0 Early Access Program versions, mostly because of superficial reasons (it has a nice dark color scheme).
Sorry bub, you're wrong: http://php.net/archive/2012.php#id2012-12-20-1 &gt; Please note that the PHP 5.3 series will enter an end of life cycle and receive only critical fixes as of March 2013.
Ending **Cycle**, not the EOL itself. And who's wrong? (= https://twitter.com/nikita_ppv/status/295929770523365376
Upvote for correcting me. My point is that 5.3 is old, 5.4 is stable, go to 5.4
Totally agree (= [] array syntax + unified $callback() calls are already enough to love 5.4, not to mention all other changes.
I'll have to give it a shot when i have some down time one day. Sometimes the N++ menus can be a bit much... I used to work on a local machine, however i found that with the NPPFTP plugin i can open and save files to the server like its a local hard drive, and i can just refresh our beta.url.com/Client-Name/ url and see the changes instantly. It also helps when working with a team of designers, copywriters, and a client to get approval from, i can make a quick change and everyone in the office can see it at the same time, instantly. plus, i have the luxury of a full dedicated development and beta testing server to myself :)
Sounds great. I'm turning anti-Java after being forced to work with it for a while now anyway so I second the sentiment!
Consider it done.
Just as a side project to help some friends get their sea legs under them in programming again. Plus my job has slowed down a bit so I'd like something to play with in my spare time.
Wow you're aggressive. When and how did I bash PHP? All I said that I was surprised there was no consensus displayed. Obviously you have lots of tools available but normally when there are multiple options people zero in on the best and it becomes the standard tool for that purpose. LAMP, for example, does exactly that for each of the four core components. I wasn't looking for a pissing match. I'm glad you're familiar with .Net, its a solid stack. I'm going to get back to learning PHP now...
Thanks!
PhpStorm user on OSX and Windows, no bugs to report on any system. Are you using 5.0 or 6.0 beta? Also, PhpStorm is the best PHP IDE, I've never seen anyone (who tried it) disagree with that.
apc 3.1.13 works great for me on php 5.4.11
You're dead on. Here's the direct link. http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1
I just want to express my appreciation to all the people who responded. It's so amazing to be able to get insight and advice from such an extremely intelligent and well-informed group.
This was a very useful answer, and I really appreciate you taking the time to provide some help. I've got a quick follow-up question (obviously from a novice perspective). In your Person class, you have methods designed to set or get each of the various properties. Why not simply make those properties public and just access them like so? $person = new Person; $whatever = $person-&gt;id; It seems like all of the "extra" methods would be unnecessary overhead. That said, I know what you're showing me is standard practice. I've seen it in two of the books I'm studying. But the books don't explain why it's done that way. (Couple of edits for clarity and formatting)
&gt;In your Person class, you have methods designed to set or get each of the various properties. Why not simply make those properties public and just access them like so? Exposing properties makes you lose control over the data. Using setters is a way to enforce and ensure that the data stored is in its proper format. Additionally, they can contain some level of logic which properties cannot, which is useful in certain use cases. 
Thanks for the input. I appreciate your somewhat laid-back and pluralistic point of view. It's . . . oddly reassuring.
Neat, xdebug looks effective.
Your comments have already been deleted by the moderators. Are you sure you want to continue down this route? 
It's probably that I'm sick, but I'm not following you at all. I don't know what this means. &gt; Comments = sod all difference. But more to my point &gt; Annotations live in comments, but that doesn't mean comments are slow. I was never asking whether comments were slow; more that annotation parsing could be slow. And that adding a large doc block comment to the top of every file will increase the annotation parse time. It rightly figures that there will at some point exist an illogically huge app where the annotation parser could be significantly sped up by removing comments from the top of the file. At which point to answer the OP's question: yes, but only when using annotations and only when the number of doc block lines exceeds an excessively large number and then only on the the first run. 
Okay, that all makes sense. Thanks again.
Why would system administrators refuse to update free software?
&gt; PHP 5.4 is twice as fast as PHP 5.3. If you read the blog, you'll see that he immediately retracts the headline, pointing out that he just happened to test one thing that was twice as fast in 5.4 Not that I'm disputing the general point that upgrading from 5.1 is a no-brainer.
You're quite a piece of work, you know that?
The OP was talking about comments, not annotations. I saw you asking about annotations as a confusion of what is otherwise a simple topic, but yes the more processing that something does the slower it becomes. Processing Annotations may well be slow (it depends how they are being handled and by what script) so the more annotations you have the slower this will obviously become, which is why most annotation-based systems implement caching. But, we're not talking about annotations, just comments. Comments effect shit all.
What is the error you are receiving?
The error: Fatal error: Uncaught exception 'PDOException' with message 'SQLSTATE[3D000]: Invalid catalog name: 1046 No database selected' in /Applications/XAMPP/xamppfiles/htdocs/usingpdo.php:22 Stack trace: #0 /Applications/XAMPP/xamppfiles/htdocs/usingpdo.php(22): PDO-&gt;query('SELECT * FROM a...') #1 {main} thrown in /Applications/XAMPP/xamppfiles/htdocs/usingpdo.php on line 22
If you have no idea what the UK cookie laws were all about you can check this infographic: http://blog.silktide.com/wp-content/uploads/2013/01/Cookie-Law-infographic-reduced-size.png For the record, I never spend a single minute of my life working on solutions to this "law" for any project I ever worked on. I have ignored this law since day 1, and it being discontinued is mildly humorous but completely irrelevant to any sane-minded developer. If you have a warning on your site, go and delete it.
They're probably using whatever version's shipped with the distro.
Looks like maybe: ';dbname' . $config['db']['dbname'] should be: ';dbname=' . $config['db']['dbname']
Oh boy, this is after I just invoiced 2 months worth of work for my clients to add an obtrusive banner to their website. I'm totally screwed for revenue now. Just kidding, I'm with you guys.
You don't need to concat strings $db = new PDO("mysql:host=$config['db']['host'];dbname=$config['db']['dbname']", $config['db']['username'], $config['db']['password']); also you forgot an = sign between dbname and your string, which gave you the &gt;No database selected error
Last time I asked web developers for an answer to this question, they all told me to use VIM. I did, and now I have a unibrow and hairy palms. Don't make the same mistake I did, OP
Hah! I think if activities were going to make my palms hairy, it would have happened a long time ago...
It must be nice to work on solutions that are not so widely used as to draw the attention of the ICO.
And you forgot about curly braces inside double-quoted strings.
Please stop it. You're ruining everything PHP community did &amp; still does to get out of that image of "language for dummies".
Interesting - have 3.1.14 running on a few production servers against PHP 5.4 without any issues, one handling a fairly well trafficked wordpress site - but YMMV and if it's a bad release, still the best thing to do..
Had a great 2 weeks over Christmas adding cookie policies to all our sites, just the type of work I crave as a programmer.
You could look at it that way, but Google, Amazon and Yahoo didn't do a damn thing about this either. Your attempt at insult is not all that relevant. I'd be really interested to see an article about anybody getting prosecuted by the ICO over this law. 
Eh - are we sure about this? It was never a British law, it was EU law, and the ICO is purely a British institution. The EU might disagree with the ICO's claim that the law is dead. Plus, you're still expected to put notices about cookies, you just no longer have to *obtain* consent, as implied consent is A-okay (which they said ages ago already).
&gt; $this-&gt;getGetParam('param1', $defaultValue, 'alnum'); Honestly curious - is this the kind of thing that makes a framework be seen as more advanced? How do you know all the possible values that can be given for the third parameter? What if you don't specify a third parameter? &gt; $c = new Cache($config); Afaik this is never done in a CI controller and you've just pissed off the guy who's working on this project after you. Thanks for the write up, I enjoyed reading it and am always curious to see how people use CI.
I'm a bit confused. I was responsible for my website's Cookie Law compliance, and after months of audits and meetings last spring, we ended up just putting up a banner on our page that says we use cookies. So, we no longer need to display this banner? 
I tried with 5.4 a couple months ago and had serious segfault issues. I wonder if things have been worked out since then. I miss the snappiness of APC.
I don't think I've worked anywhere, ever, that has been limited to a single language. [Simon_x](http://www.reddit.com/r/PHP/comments/17u06w/employment_dilemma/c88tjqa) has it right.
Third param can be omitted. A ctype check is not done then. The possible values are simply php native ctype checks. A very similar structure exists in Zend which I'm very used to (minus the ctype checks), so I replicated it here. CI has a default "cache on" mode that you need to activate, like the post says. But since I replaced it with my views, it won't work, as their documentation explicitly states one has to use CI's views for the original cache "engine" to work. There's far better cache solutions either way.. I'm curious though - assuming this wasn't a do-and-dump one-off project, why do you say I pissed of the next dev?
I didn't downvote a thing.
the only authority i listen to is the client
Never heard of it, but it looks snazzy as all get out, plus [it has tests](https://github.com/pimcore/pimcore/tree/master/tests) so it's already far ahead of 99% of the CMS out in the wild.
for the purpose of being a highly extensible ecommerce platform, magento is good architecture. 
Seriously, magento is not an example I'd use. But then again, I wouldn't recommend using it for anything period;)
To have associative arrays in a string like that, you have to wrap them in curly braces: $db = new PDO("mysql:host={$config['db']['host']};dbname={$config['db']['dbname']}", $config['db']['username'], $config['db']['password']); 
I'm the author and presenter of that talk; glad that it was helpful to you. Note that the Aura project, with its completely independent and fully-decoupled packages, is geared toward the refactoring approach. http://auraphp.github.com
Your View class could've appended the output to the Output class, and still took advantage of its built-in cache mechanism. Your param methods totally ignore the Input class, which, apart from ctype stuff, already does the same thing as your getParam solution, and still includes xss_clean capabilities. I'm sure he means that you took CI and made it do things it wasn't designed to do (like using "new Class()" and such). If the next developer doesn't know CI either, he has to learn it *and* figure out what you modified. They are some nice ideas -- nothing wrong with the functionality you were trying to get. And you certainly aren't the first person to have a distaste for CI. But a lot of it could be implemented better.
You've been through Javascript, which sucks even more and somehow you can learn to appreciate it. PHP sucks too but it's everywhere, on every web server and you have a strong incentive to learn how to use it. Many popular frameworks and open source CMS are built in PHP, it still has a vibrant community and documentation is easy to find. Every programming language has its flaws, you will discover them and you will curse while using them. There's a big part of personal preferences and also an argument to be made about using the right tools for a particular task. Outside of its questionable design and engineering, I think PHP also get a bad rep from the past having had many revisions and for being around for so long. PHP is so easy to use that anybody can program working crap in it, which I'm sure a lot of programmers ended up having to fix a giant clusterfuck of spaghetti code. That being said, you can always learn other languages. A particular language is irrelevant and as long as you learn programming concepts, they will translate. If you're going to learn PHP, at least make an effort in learning what are the best practices.
The same reasons keep popping up over and over again: 1. needle/haystack in some functions 2. inconsistent function naming 3. not everything is an object 4. php doesn't stop you from writing bad code I think #1 and #2 are easily fixed by not using a text editor, because this is a programming language and you should use a tool for the job like a proper IDE. #3 is just how this language was originally written. #4 is an excuse that I believe shitty developers make when they lean on their language of choice too much to help them write good code. C doesn't protect you from yourself. You can write absolutely horrible code in it, but guess what? It's not supposed to hold your hand. Neither is PHP.
Double check Google because I found a lot of first hand opinions on why PHP isn't so great. For example: * It was built as a procedural language. PHP objects don't feel as smooth as they do in fully OO languages. * Built in functions have a seemingly random naming convention * PHP is weakly typed and will occasionally make some surprising casts under the hood (JavaScript has this problem too) * There are some really terrible features which used to be turned on by default like register_globals or magic quotes. Honestly PHP is really kind of terrible, compared to other languages. But it does web pages nicely enough that once you learn to work with its kinks you're fine. If you're interested in learning web development, you should learn PHP. The one **huge** thing PHP has going for it, and probably the biggest reason it's still around is portability. Installing a PHP application is as simple as dragging and dropping, and 99% of web servers already have PHP installed.
The reason PHP is still popular has little to do with existing codebases or availability. It has a lot to do with the ease at which new people pick up the language + those things. Terrible language or not, you will write beginner code. Why would you think it matters what language you use?
Any popular language or platform will invariably have its share of haters. The main reason people don't like PHP is because it's so easy to learn that a lot of people don't take the time to learn how to do it right, so there are a lot of bad examples. Any other argument against the language is quite negligible. It's the community that makes the language, not the other way around.
While your code now looks cleaner because of iterators, you missed the point. It's about *not* using the arrays when possible, because they eat a lot of memory. So better check if this possibility exists and apply it (=
Don't listen to most people about why PHP sucks. I can say the same thing about english, french sounds so much nicer, german might be more expressive blah blah blah. Here is what you need to know. PHP is a very robust language, it has shown it can keep up with the times and it's being very innovative in it's formative years as many people who were veteran users have switched over to python or ruby. PHP has improved by leaps &amp; bounds. You will be successful working with php if you adopt the most modern techniques in using it. If you feel that you will need to maintain older code-bases, without some formal software engineering experience or programing experience in general, PHP will be a moving target for you. My suggestion is learn good techniques, through the composer &amp; packagist projects, read the code that these projects consist of. Don't listen to the haters, people who make money still complain, mechanics complain about fords / older cars, but they still make a living fixing those older cars.
Check out template inheritance. It's the best thing since sliced bread for views.
#1, #2, #3 fixed by [scalar_objects](https://github.com/nikic/scalar_objects/) extension, but it's third-party (hope it might be included in PHP in new versions)
&gt; "PHP is weakly typed and will occasionally make some surprising casts under the hood" Actually this usually happens when you don't know what you're doing - sure if you try to concatenate a string with an array, what _would_ you expect to happen? Write your code correctly, track your variable type correctly (using an IDE and doxygen comments) and it's all good. It's all part of "PHP lets you write bad code" really. The register_globals or magic quotes crappy features have been deprecated and will be removed in time.
Compared to the other options for server side scripting, and given where your focus has been previously, just go ahead and learn PHP. There are hundreds of thousands, if not millions of PHP programmers and 90% of websites run on PHP (I'm making that up... but most are built with PHP).
&gt;Oops! Google Chrome could not find www.pimcore.org Try reloading: www.Â­pimcore.Â­org Oops indeed 
Causing frustration was certainly not my intent. Point taken, the things mentioned in the comments of this thread are something worth considering further down the road, thank you for the feedback.
I think that http://www.phpliveregex.com/ is a better tool.
Not sure, but since so many websites implement this as an opt-out (which I don't believe is required), and yet many more ignore it altogether, I'd ignore it too. 
But if they say it is legal and the EU doesn't come after them, other countries can pull the same conclusions.
As someone who did the same thing as you recently, here are my tips: - Make sure every bit of learning material you hunt down is current. At least look at the publish date and try to stick to stuff from the last 3 years. If you go back to tutorials from 2006 that look great, it may just have very little resemblance to how PHP is done *now*. - Choose a framework and at least have it in your mind as you work alongside "raw" PHP. Everyone says it's good to know the mechanics under the problems that a framework will solve, and that's true. But it's also good to have in your head what problems *do* get solved by frameworks so you don't spend too much time on things you will never do in the "real world". Codeigniter is a great framework that is probably the most accessible of all of them, but is considered to be a bit "trailing edge" as it is built for backwards compatibility with earlier PHP versions. Laravel or Symfony2 are good to look at if you want to see more forward looking design. I have no experience with Zend, which is one of the "big boys" used for enterprise level stuff. I would say it's also valuable to look at something like Will Bond's Flourish library to see an example of what is basically a collection of really nicely put together and documented classes outside of a framework. - As you are learning, save your code. Try to get an idea of classes right away, even if you don't fully grasp Object Oriented Programming (although you might have some of that from JS) If you do anything that you think you may do again in the future, then try to make a class out of it. And then as you see cool tricks or interesting techniques, you can go back and refactor your own classes, adding or changing. Before you know it, you have yourself your own reusable private library of best-practices. - Get a handle on Composer/Packagist. Modular distributed code bundles are where it is at. Get comfortable on the command line if you aren't already. - I really don't get why people get so down on PHP, and Javascript. I came to programming a bit late, so everything had a certain WTF? factor to it anyways. I think it's just that people who are really into something like to bitch and debate and deconstruct everything about it. So it's kind of like if I'm listening to a song with you and I go "I can't believe you can listen to this! The tone on that guitar is terrible, the singer is consistently 50 cents flat, the drummer is not doing anything interesting at all, and you can totally hear the edits." And you're like "But it's... nice." 
I use this regex tool http://gskinner.com/RegExr/
And don't go near W3Schools - ever!
The translation: PHP is a language that is cheap and easy for anyone to get something working in, so many people do. That generates a lot of code and a lot of projects, some put together by well trained and educated professionals, and some by complete noobs who know very little about what they are doing. That's the bottom line - there is a massive spectrum of PHP projects out there, covering every level of quality, and the complainers tend to complain about one end of that spectrum - the dross. I can only assume they are the same people wading around in the dross, so avoid them.
Anybody who has been relying on register_globals any time in the last *decade* (seriously - I've has this "feature" turned off since 2002) really does not know what they are doing. It is amazing it even comes up in discussions concerning PHP, but I guess there is a lot of really old code floating around out there.
Sure, I just don't want websites which operate across the whole European Union to get in trouble. Neither do I want my country to face more EU fines.
I've used it on a couple of sites. It's actually a really good CMS if you put in the time to figure out how it works (the docs are OK but it takes some figureing out - knowing how Zend works is a good start). You can build very cool admin interfaces and it's pretty user-friendly (albeit a bit daunting for some people due to the large number of options). The main downside is really performance. It's HUGE and while Zend is great for a lot of stuff, it's really not that brilliant for high-performance websites. It's probably not quite at Magento levels of slow but not that far off. Running a busy site would probably require some levels of caching beyond what pimcore does already (proxy caching might be the easiest way e.g. varnish or I guess cloudflair). 
PHP isn't terrible, the things some programmers do with it are. PHP seems very easy to learn, but most people misunderstand the language and the whole programming thing and ask the forums why code like this doesn't work as expected: if $foo or $bar == TRUE { do_something() } So I would never recommend to learn PHP as first language. Python is more suitable for this, since it is very readable and consistent but powerful. But you already learned JavaScript, you know the basics of programming, so you won't make these beginner faults.
Oh come on, you should use a "proper IDE" because it's the "tool for the job" but people who don't like PHP "lean on their language of choice ... to help them write good code" huh? So it's OK to lean on an IDE, but not a language, in the case of the language you should just man up and dance around the downsides of the language.
The problem with PHP is that beginners don't always learn to use it correctly. There are countless resources on the web but many are outdated and target old versions like PHP 3 or 4. These older versions also had poorly-planned features like "magic variables" which were security risks. IMO you should start with PHP 5.2 or higher. Virtually all those annoying bits are fixes and it has good support for OOP. Also take some time to [learn best practices](http://www.phptherightway.com/) once you begin to understand the language.
&gt; Why do people say PHP is terrible? Mainly? Because criticizing something that's very popular is an excellent way to get traffic to your blog. You draw in both the contrarians and the righteously indignant.
Plus, nginx still doesn't seem to work properly with PHP on Windows so anybody who wants to use it must use linux.
regexpal.com
You miss one tiny insignificant semicolon though...
Actually, by definition I have. Encapsulation is about encapsulating implementation details. By providing methods that check for a specific state I have encapsulated how the status is implemented. It could be a property, a constant, a calculation - surrounding code has no idea and couldn't care less. Same thing with getters/setters: they allow you to change implementation details without changing the interface. It might be that most people don't actually change their implementation details and so end up spending more time than needed on boilerplate. That doesn't change the fact that your way of writing code (change properties directly on the object) will eventually blow up in spectacular refactoring disasters, as you've closely tied code to objects.
&gt;comparisons to "le cool language du jour", normally Python or ~~Rails~~ Ruby FTFY.
All languages have their down side. Unfortunately for PHP, it has a tendency to support legacy for far too long. This is where a lot of the criticism comes from. However, PHP is still a very successful and powerful language. A large majority of web servers are running PHP. By not learning it, you are essentially cutting your potential working field in half. All good programmers don't 'learn' PHP. They learn how to program in languages. This is how you can become successful in any language you choose. Its the programmers responsibility to know the quarks and faults in their languages. Aware programmers can use any language and make solid and reliable programs.
PHP is a pretty old language. In fact, when it came out, it wasn't much of a scripting language at all, just a set of c-inspired syntax for adding some logic to web pages. Over the years it has matured, adding a powerful object syntax, and a fantastic collection of libraries that is tailored to web development. A lot of people complain about PHP, and they have valid complaints. Not everything has switched over to using object oriented syntax, several functions are either inconsistently named or have unexpected order of arguments, and so on. That said, PHP is highly optimized, widely available, and if done correctly scales very well. I'll admit, it's such a flexible language, it's easy to write bad code; but you can find bad code written with any language. I think PHP is a great way to start with server side scripting. It's so accessible, and has a very web-targeted feature set. Plus, it's a good thing to put on a resume that will appeal to a lot of potential employers.
 M_PI
Yeah, I know the constant exists, but what I was curious about was what the point is to making the function in the first place.
 var_dump(phpversion() === PHP_VERSION); // true
A lot of the downsides and upsides of PHP have already been mentioned in this thread, so I won't rehash them. Here are the universal points to consider: 1. All languages have quirks. 2. It is possible to write "bad" code in all languages. 3. All languages have advocates and detractors, some of whom will be louder than others at various times. 4. The more popular a language is, the more evidence of aforementioned advocates and detractors you will find online. Given all of the above, there's no reason to choose or not choose any language based on those factors alone. For most people learning to program, grammar and syntax is a big factor in success. So, if you've learned Javascript then either server-side Javascript (e.g. Node.js) or PHP will probably be the easiest to learn for you. In contrast, Python, Ruby, Scala, and F#, being whitespace-delimited, will probably be the biggest syntactical leap for you. Languages like C# and Java are syntactically similar to Javascript, however they are compiled and statically typed so those might pose a bit of a challenge. At the end of the day, the most important thing (and probably the hardest thing) for you to learn is how to write good code, which is really the same regardless of what language you're writing your code in. What's good code? Well, here are a few quick hallmarks of good functions, as an example: * A function's name describes what it actually does. * A function has no external dependencies (i.e.: it does not rely on external state, such as session data). * A function has no side effects (i.e.: it does not change the state of your application in unanticipated or unpredictable ways). * A function is deterministic (i.e.: given the same input a function will reliably produce the same output). * A function does just one thing. You can learn any language you want, but the principles of what make a good function, for instance, are always the above. Does that make sense? 
Most of those inconsistencies can be explained away though. Not with any arguments that make any sense if you did any sort of planning, but I imagine the one guy implementing strpos() decided to put haystack first, while the guy implementing array_search() decided to put needle first is possible. However, in the same way those guys decided on their argument order based on some kind of logic, there must have been someone who thought making pi a function would be a good idea, and I was just wondering if someone understood that 'logic'.
The online docs says the constant M_PI "yields identical results to pi()". Does this mean M_PI is an alias to the function? http://php.net/manual/en/function.pi.php
Since Aptana dropped PHP I went to use Netbeans which is very cool. But then I bought PHPStorm and never went back.
I always like to think that the original intention of pi() was so that they could include a function variable to limit the length of the value returned, but then never got around to implementing it.
You're probably right, but then it's weird you can't manually indicate an accuracy as function argument, like /u/expressadmin said.
zend debugger isn't available for php5.4. We need to use xdebug
regexbuddy
I've been using [PHP101](http://devzone.zend.com/6/php-101-php-for-the-absolute-beginner/) lately. Do you think that this is too outdated? Looks to be from 08 but it certainly has helped me quite a lot.
Regex is only complicated if you don't take the time to try to understand it. The hardest part about learning regex is knowing when it isn't appropriate.
So where should I go instead? If you're going to tell me not to go on w3s you might as well list some alternatives.
I like PHP and despise Wordpress. 
You can theoretically fold space time to make a circle whose ~~radius~~ circumference is not pi*d. PHP is just that forward thinking.
He doesn't like PHP therefore he doesn't want to install Wordpress. I think thats it.
Then you need to speak with the project leader or manager, because it sounds like he's letting his personal biases get in the way of work.
Because it's an example of terrible PHP. 
Why would it ever, compute Pi at runtime? It would have only ever returned a static value. Anything else would have just been silly, and have taken *significantly longer* to implement, than just 'return 3.142 ...'.
It can be adjusted ... but only in PHP.ini. I don't know if there's a good use case for ever wanting to use two different pi lengths in a single application, but if there were it would be impossible.
It looks to be from 2006, definitely look for another source.
That's easy to say from a top-down perspective some 18 years after-the-fact, but at the time PHP was first written it was just a collection of some guy's scripts he created in his free time.
If a thousand monkeys had a thousand type-writers...
http://wiki.theory.org/YourLanguageSucks
[headache relief for programmers :: regular expression generator](http://txt2re.com/)
but why would you like to limit the length?
I just took a quick peek at it, and it's "ok" in that it has a nice conversational tone about it... but just quickly clicking through the lessons I notice some big black flags.. - I see mysql functions... PDO is much better and not any more difficult. - I see things like database config information being put right out in the open with other code, instead of trying to hide it at all. - I see "spaghetti code" .. PHP mixed in with HTML on the same page, and forms submitting to themselves instead of to a separate .php file, etc. This is kind of like throwing your javascript in throughout your HTML. Separate it. Have your PHP somewhere else and send stuff to it from HTML. Look at Model View Controller architecture. It's really not so complicated... you just kind of divide you code into smaller parts that are always located in the same place. Model &gt; interactsWithTheDatabaseAndDoesMostOfTheWork.php Controller &gt; trafficCopBetweenViewAndModelDirectingTheFlowOfData.php View &gt; receivesOutputAndPresentsItAtTheFrontEnd.php It might seem trivial when you only have 30 lines of code, but as soon as you have code that is keeping track of sessions, plus form input/output, plus contact form logic, plus e-com functionality, etc.. it makes sense - I see HTML with inline CSS.. which is just a sure sign of substandard practices. ... so .. I guess my answer is "yes" it is outdated. But it is a good read. Go through it quickly, absorb the big ideas, and then move on to another resource a bit more modern. Don't spend too much time on it and don't try to memorize all the details because you think "this is how it's done". The site is like a professor who is a great speaker and who explains the "big concepts" well .. but then leaves out all kind of little stuff that is going to be on the exam.
The real explanation is the same as the reason why some functions are likeThis while others are like_this: PHP is really just the offspring of other languages (primarily C and Perl). The calling conventions and naming conventions come from whatever language PHP was copying at the time. This also usually explains whether something returns -1, FALSE, or 0 on errors, etc. PHP started as a very thing wrapper/emulation of whatever the core dev(s) liked in other languages, and carries a lot of that legacy forward even to this day.
phptherightway.com is great.. but I feel you kind of have to be intermediate level to get anything out of it. It's kind of like directing a Javascript learner to Crockford's "Good Parts". But it's good to have as a reference and keep going back to it to check your knowledge, as it is current and "best-practice". It just discusses everything pretty abstractly with no real context, and the order of presentation is kind of .. puzzling. phpacademy.org is a good one .. I think videos are good, because you get a lot of "supplemental" info on whatever is being described.
I don't have anywhere near those numbers on the site I built (I built the same site twice with different versions of the CMS so I only have one actually live) and I'm using shared hosting so I'm not really sure what you can expect. It might be worth just installing the sample application that is on the pimcore site (IIRC) and throwing some benchmarks at it (ab should be installed on most systems and is simple to use). I'm pretty sure Varnish would work on the same system but I haven't installed it personally.
Sometimes... you just don't need a perfect circle. ;)
That still doesn't imply they chose to **calculate Pi from scratch every time you call the function**.
[Huh?](http://lxr.php.net/xref/PHP_TRUNK/ext/standard/math.c#550)
Meh, it works and it works well. There is a reason it is the most popular blogging platform. However, it is a _developer's_ nightmare. Calling the code a mess is not even scratching the surface, and the plugin ecosystem is a nightmare at times. For a non-developer blogger, though, the shit is magical. 
Well, the issue is not to what precision PHP can handle pi, but to what precision PHP handles floats. That's why it's a php.ini directive and not something that can be passed to the function-- you can't (or maybe you can, but you shouldn't) change the precision of ALL floating point numbers in your application at runtime or willy nilly, and since pi is going to be floating point it's going to be inherently linked to the precision of floats. edit: clarity
&gt;Why are people upvoting you for making an outlandish statement without providing one single reference or citation? Because some of us have experience with Wordpress' codebase, and know that he is right. &gt;without providing one single reference or citation? What exactly do you expect to receive a reference or citation on? &gt;This subreddit is fucking stupid. This subreddit is stupid because we agree with timw4mail's opinion that Wordpress' codebase is bad? Uhhh..
Just the tip?
Resolution. The more of it you have the bigger the number needs to be.
&gt;Oh, look, another person who is shitting on something without providing one single reason, source or citation. [...] No, this subreddit is fucking stupid because they upvote posts that shit on a technology without providing one single reason, source or citation. The reason they upvote it is that they already know the reason to why it is bad. If you wish to know the reasons for that opinion, maybe you should try asking for it rather than flatly declaring that the entire subreddit is stupid. &gt;PS: Your level of reading comprehension is disturbingly poor. My reading comprehension is fine. It's just you that have an attitude problem.
Well. This just confused things further.
Here are a few of the reasons people whine about PHP: http://philsturgeon.co.uk/blog/2012/12/why-some-people-hate-php
pi() was introduced in PHP3, before there was a precision argument in php.ini. See the [man page](http://medialab.freaknet.org/php3/ref.math.html) It must have been kept in php4 for backwards compatibility reasons. It is funny because all of those functions and all the constants directly correlate to [math.h](http://en.wikipedia.org/wiki/C_mathematical_functions) except for the pi function. There must be some strange esoteric reason why the function was included as well. edit: Further, the function does nothing but return the constant from math.h: /* {{{ proto float pi(void) Returns an approximation of pi */ PHP_FUNCTION(pi) { RETURN_DOUBLE(M_PI); } /* }}} */ edit: and here it is in PHP3, has not change, other than being ported to the new Zend engine in php4: /* {{{ proto double pi(void) Returns an approximation of pi */ void php3_pi(INTERNAL_FUNCTION_PARAMETERS) { return_value-&gt;value.dval = M_PI; return_value-&gt;type = IS_DOUBLE; } /* }}} */ in both version M_PI is simply: #ifndef M_PI #define M_PI 3.14159265358979323846 #endif to find out the real reason why, you will have to ask one of the authors of the PHP3 file - they are both still active contributors. Jim Winstead (jimw@php.net) and Stig Bakken (ssb@php.net)
I'd gladly have this discussion with you once you learn how to conduct yourself and not act like an angsty teenager with a hormone imbalance. Until then, I bid you good day.
"There are only two kinds of programming languages: those people always bitch about and those nobody uses."
Well, now a little googling never hurt anyone did it? I am pretty sure you will find plenty of reasons for hating wp all over the internet. Wordpress from the sourcecode point of view reminds me of php4. Very unclean, very unprofessional. Most plugins written for it are crap (last problem was with a plugin updating and breaking a entire wp installation). And before jumping to "judge the plugin creator, not wp, i think plugins are so bad because wp itself is so bad. You will find a million other reasons for this hate against wp, and i assure you 99.9% of them are absolutelly correct. Regarding being a horrible programmer, I am pretty sure that supporting wp will be considered at my workplace as a notification for a resignation. You will not last too much in a real dev environment with people with alot of experience saying that. So now, go edit your wp, make money or whatever you do, and stop all the nonsense. C'yah.
As an IT guy that supports these type of software stacks in live environments, I'd be pretty pissed at the guy trying to install a PHP blog on an otherwise Rails environment. In most installations (mine anyway), this would mean supporting (upgrading, patching) an entirely separate software stack, as well as dedicating resources (RAM) just for the blog in a otherwise highly optimized environment. Just because the Rails dev doesn't want the PHP blog mixed in the app, doesn't mean he hates PHP - it's likely just something very practical. Maybe just have a chat with him (without making it a you vs him thing) or your IT guys. You can probably work out an alternative that makes both of you happy (e.g. host your blog on a subdomain on a separate PHP environment, even if it's a 3rd party host)
I'd like to see a circle with a radius of pi*d.
Well. Actually. You are wrong. On all accounts. Actually I program in php quite alot. But as i said i've moved past php4. And I also program in clojure. And python. I actually never touched .Net. And honestly i don't really give too much on what you think. I guess that is legal right? From the "proving" point of view, well, i gave you some reasons. You gave just about... well... nothing? C'yah m8.
Wordpress is not a library. Now go back to school and learn a little. PS: do not forget that not all the popular stuff is actually good. PS2: I wish i'd get the chance to interview you. I would laugh so damn hard :))
Is there any way to do this but with the help of another language(javascript,...).
Yes, so I am correct. You said ... &gt; I'd guess that earlier versions of PHP didn't have the ability to generate it at compile time, and so there was a function for it, but then someone figured out 'hey, we can compute these at compile time and never have to compute them at runtime!', Can't at compile time, so they use a function to do it at runtime. In that code you link to, they are not generating Pi at runtime, they are returning M_PI.
I maintain projects in PHP, ruby, and other languages. I wouldn't want to install wordpress solely on the basis that it's wordpress. I hate having to do anything inside that train wreck of a codebase. What I can tell you from personal experience, is that after you've spent a while in ruby it gets more and more difficult to go back to appreciating PHP. While PHP is capable of many of the same things, ruby is far more elegant in its execution. YMMV of course, I don't expect everyone to think exactly like me. I would recommend you at least ask him what he thinks you should use in place of wordpress and hear out his arguments. While dismissing something out of turn because it's PHP is not a good idea, there could be merits to using something else that you hadn't considered. You also should not dismiss his ideas out of turn just because they may not be PHP solutions. Good programmers consider all tools, and try to pick the one best suited for the job.
Did (PHP) constants exist at the time that function was added?
I use [http://regex.larsolavtorvik.com/](http://regex.larsolavtorvik.com/) (php/js) and [rubular](http://rubular.com/) (ruby, ofcourse) for my dayjob but when i'm feeling particularly lazy [http://txt2re.com/](http://txt2re.com/) (almost anything).
I haven't used an IDE to do php in ages (I think about 7 years). Personally I find them to just get in the way and slow down my typing. That said, when you're learning and unfamiliar with any language, they really are great when getting use to the language.
Ah yes, the article that I agree with quite a bit, but basically disagree with because the author really is just bitching about being unfamiliar with a lot of php's issues.
Facebook is written with php. Take that for what it is.
Thank you for including their text, it truly defeats the [deleted] purpose, and calls these people out for their bullshit.
PDOStatements already implements the transversable interface which allows them to iterate on foreach statements
At least the ui makes some sense. I have to consult the manual every time I try to do anything in Joomla userland. I know that the purposes of these two are different and that's the problem - when all a small business needs is wordpress and someone installs joomla it does my head in!
BeOS had [is_computer_on_fire](http://www.gormagon.org/2006/09/28/beos-is_computer_on_fire/).
See, that's the tool that everyone always touts, but I'm not a fan. It's nowhere near as good for highlighting sub-matches.
Agreed. Just as there is absolutely no reason not to "lean on a language" that'd be easier to write stable code in. That was my point. (And I don't necessarily mean "protecting you from yourself" though there is an argument to be made for that; I just mean consistent enough that you can safely make assumptions or guesses about what library functions might be called instead of having to look them up every time).
That argument only makes sense in a world lacking IDEs with proper refactoring support.
I've never used F#, but neither ruby nor Scala are whitespace delimited.
He's a rails dev, his job is to maintain rails code, your desire to add Wordpress for fuck knows what reason is absolutely wrong. Devoting resources to PHP in an otherwise rails environment (when adding a blog to an existing rails app is so stupidly simple it would probably take less time than it will for you, the reader, to finish this post) is absolutely wrong. 
So, basically you lied your ass off about development speed and performance and now you're bragging about it on reddit? Java's a lot faster than PHP (not a little, a lot) and "development speed" is a totally unprovable metric.
you should let him do it, being curious is a great skill in a programmer
&gt; you can't (or maybe you can, but you shouldn't) You definitely can with ini_set(), but I agree it's bad form. You can do it pretty safely, since you can use ini_get() to get the initial value to cache and switch back, but you can just use round(pi(), $decimal_places) and avoid messing with system variables.
&gt; if there were it would be impossible. It's very possible with ini_set() if you want to actually change pi()'s values on the fly at runtime. round(pi(), $decimal_places) will work too, as long as $decimal_places &lt; your float precision.
Would it not be for forward comparability as well? I'm mean as the resources in computing increase so increases our ability to calculate a more accurate value on the fly? Withstanding the limits of the float data type that is. 
i dont think varnish would work on a "shared" host. youll need the webserver to listen to a high port and let varnish listen on port 80. 
Not PHP.
You're right, and that's always bothered me about Regexr. I'm not set on the way this one highlights the matches in a different area than the textarea, but I'm going to try it for a while and see how it feels.
Just use 3. Close enough 
So why would you ever want *less* precision? It's not like it makes the computation faster or anything.
I don't get this deep into Pi, ever, because well, shit I've seen how crazy the guy goes in the movie;) j/k... Think about it this way: in what can be represented as a circle in a grid: (and I'm sure math purests will hand my ass to me on this) 3x3 is the least amount of resolution possible to represent a circle 0X0 XXX 0X0 that's technically a circle as represented in a 3x3 grid, so whether you have pi as a 3, or a 3.14 that really doesn't matter now imagine it as 4x4 (hell this doesn't even look right, seems to work better with odd numbers) 0XX0 XXXX 0XX0 00X0 and 5x5: 00X00 0XXX0 XXXXX 0XXX0 00X00 Continue through, say 1,000,000x1,000,000 As you increase in number of "pixels" you need more resolution (precision) to determine what aspects of the grid are presented as X or 0. As I understand it, and again, I could be VERY wrong... The more precision/resolution you require you're adding to the complexity of the calculation. I don't believe it's only about how many zeros follow that 3. I'd spend more time on it, but I'm no math wiz and I really suck at explaining things:) tl;dr: I think it actually is less computation time if your number doesn't go to about 100 places past the integer when you don't need it... 
&gt; As I understand it, and again, I could be VERY wrong... The more precision/resolution you require you're adding to the complexity of the calculation. Your explanation was fine, except for this part. A computer stores a float using either 32, 64 or 128 bits. Once you've picked your size (and PHP picks for you - you don't get to choose), using less digits of Pi does nothing - you still use the full number in all calculations. So given that, why would you ever reduce the number of digits given that it doesn't actually make the calculation any faster?
Genuine question: How does dependency injection conflict with the expressive and readable syntax of Laravel?
And you're constantly avoiding the actual points, so let's just end it here
Please tag in bro:) 
Looks great! Perfect for those small-mid sized projects. Bookmarked
Writing blogs with a Java EE CMS is quite painfull compared to wordpress so the blogging part can be outsourced to wordpress and then integrated into cms 
What does return double mean?
RegexBuddy rocks
I use a visual tool to ensure i get the regex right the first time. Also because I am often matching against largeish files with complex and varied rules from one set to the next. It is far easier to see a missed character type or other issue this way.
Phped rocks. It is the only "complete" IDE I know of for PHP.
Phped gets the closest to Visual Studio of any editor that I have tried.
Phped is worth every penny
Whitespace delimited means that changing the indentation level changes the current scope. In Ruby, the current scope is generally changed with an 'end' call (and {} matching for lambda expressions) while in Scala it's OK to write a single line function with no {} brackets, but any multi-line function has its scope managed by those brackets as well.
Any reasons?
Return means to return the value to the calling function. [double](http://en.wikipedia.org/wiki/Double-precision_floating-point_format) is the data type.
Using mod_rewrite directives during development is an awful thing to do. It usually results in large unmaintainable .htaccess files containing application's routing logic. This is the reason you won't be able run your apps on nginx/lighthttpd if needed. 
Aha, thanks!
Looks nice. Though ever since I discovered [RedBeanPHP](http://redbeanphp.com/), I never looked back.
Looks like Redbean only slightly less easy.. Redbean is amazing for prototyping.. I modified the code to get it to store migrations too, so I can prototype on my dev server then migrate the changes to the staging (which uses redbeans "freeze" and raw queries). Saves me so much time, I really don't have to worry about the database anymore apart from when I'm creating indexes and fine-tuning.
I'm glad to see you have PSR-1 marked on your todo list, I'd say the sooner the better as the more coverage you have on the old-style means more disgruntled users when you inevitably change over.
PSR-1: "Method names MUST be declared in camelCase". It would make me happy if this ORM changed its underscore-based names. Or is it purely to avoid ambiguity with user-defined methods?
PhpEd uses PHPunit as well, AFAIK. I must admit I am currently working with PhpStorm. At first I didn't like it, but I always force myself to try something over a long term to get a true feel for it. All in all, PhpStorm is nice to work with... I just find its IDE is not as clean or smooth as others. Lots of good features that I quite enjoy, but also lots of weird quirks. The one that gets me the most often is that I expect sidebars to act as sidebars, not windows - when I press ctrl-w, I expect my current file to close, not the folder tree toolbar or search results I last clicked on! 
You can pin your sidebars so they aren't flyouts.
Sorry, I don't understand the question.
Looks cool, but what makes Paris different from eloquent?
He means the method names are seperated by underscores like "my_function_name", which should be in camelcase like "myFunctionName" And the ambiguity question means: are the underscores used to avoid that a user will give the same name to a self defined custom method.
oh yeah and out of curiosity why.. wouldn't that code work?
Sorry, I don't know what you mean by "tag in".
any suggestions where to post it? is there an /r/interestingInternetTraffic? ;)
Right, thats why I didn't really understand what was going on. As long as nobody is suggesting mixing method styles then I don't mind or care. If you ARE suggesting mixing them then I hope a raptor rips your damn face off.
"One ORM to rule them ALL!" It's good to have options. Don't be a fanboy.
* How do you set up php -S working with N docroots all on 80 port? My guess is - you don't. * What do you write in that 'router' script to replace default htaccess (or similar nginx rewrite), required for all frameworks to work with friendly urls? Honestly I have no idea. I'll better read the nginx docs for an hour and easily set up all of my hosts. * Using apache/nginx combo u can use about the same config which is used in production - this way you eliminate any problems that could pop out in that environment (less probable, but still)
I just quickly read through all of the reply's and saw that very few actually gave you what you ask. I use PHP every day for my day job, and it certainly gets the job done. But if you're asking why PHP is bad, then here are a few reasons: I have been through the project lifecycle with a few different languages The number one reason against using PHP is that it is very easy to write messy code. PHP is a very loose language. It allows you to use any variable anywhere, whereas other languages (eg java) make you declare a variable say, an integer, then will give you explicit errors if you try to use it where an integer does not make sense. Also PHP does not require you to declare all of your variables before you use them. Inexperienced coders tend to sneak variables in all over their code. The issue here has nothing to do with the power and expressability of the language, but when you're coding in a business environment, code readability is huge. When you inherit code that your predecessor wrote and he isn't around, you need to be able to figure out how it works fast. PHP allows messy code, many other languages explicitly forbid some of these bad practices. Another reason is the lack of an industry standard when it comes to frameworks and tools. If someone tells me they wrote a ruby app I immediately assume that they used the rails framework, and thus I can hire any ruby dev. As far as PHP, it could be wordpress, joomla, symphony, or who knows what else. (this is becoming less of an issue as symphony 2 is taking over) Another reason is the shitty documentation. Try to follow Joomla documentation, I dare you. It will take you a full day to figure out what version number you are on. That being said there is a very large community out there which is a huge plus Another reason is inconsistent syntax. Others in this thread have mentioned the needle/haystack singularity. I personally think that the whole idea of having '==' and '===' is just silly. I could keep going but I think you get the point. There are some very legitimate reasons (code readability and consistancy) and some shitty ones (syntax, its uncool). Is PHP terrible? No. I could write a list of the bad parts of every language. If you are choosing a first language to learn, I would pick the one that most of your friends/coworkers/siblings/people in your part of the country know. Then you will have more support, more things to talk about, and more job opportunity.
* Do you really need to deploy multiple docroots for your app to work? Are you talking about a single complex multi-domain application or many simple apps on your dev machine? The point of integrated http server is to run it in console while you're coding, not as a daemon. When you switch projects - you just stop it and start in another directory. * We even don't use router scripts. All routing should happen inside the app. During development I just use http://localhost:8000/app.php/some/friendly/url. And we still use .htaccess on testing and production boxes but it's as simple as: &lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ app.php [QSA,L] &lt;/IfModule&gt; * You're right, but I'm talking about fairly simple projects here. Complex web applications need to be run in the same environment anywhere - developer machines, testing, staging or production. We use Vagrant for those with the same OS, same web server configuration, packages etc.
* Sometimes I need to use 2 related apps at one time. Soon it will be 2 must-have + 1 occasional, so php -S is already not an option (= (there were times when I used even more 'must-have' apps) * App routing - yes, of course. But having /app.php in the urls isn't really friendly :) and it might lead to some problems in some use cases, just like the 3rd point And of course it's about the personal preferences. I prefer having a full-stack web server which always works with as many virtual hosts as I could possibly need (=
what version of php are you using? older versions don't recognize charset in the pdo connection(pre 5.3.6)
I am saying Idiorm and Paris have underscores in their method names...are they planning to change that to camel-cased or is it intentional to avoid clashing?
Everything is changing to PSR-1, so it will use camelCase. That is all, it's nothing to do with "clashing".
Upvote for objectivity.
What's changed?
Thank you for the great reply! Eliminated my fears of going into PHP.
3 words: late static bindings. it will confuse him and he is bound to just nod and agree.
Check the topic url, it's http://php.net/?beta=1 ;)
I know, but the [prototype site](http://prototype.php.net/) has been up since forever. The title quite clearly states that the "new design is getting better and better". So the question remains: What's changed? Because [I don't see any difference](http://web.archive.org/web/20120723035757/http://prototype.php.net/). 
You're right - I don't recall it looking this snazzy!
I knew that I shouldn't have listened to you! ;) In all seriousness though, it's good that you submitted it, as I doubt many people know that an alternative design exists. Though, I doubt they'll ever finish it, seeing as the designer bailed. I wouldn't have minded if it replaced the current one.
As pointed out, I was wrong. The design isn't new, I just hadn't looked at it in a while. The proper url is http://prototype.php.net I thought it had changed since last time I saw it - apparently not.
or ||
i kinda mumbled along until OP exec()'d a curl command. ive done this before long ago for homegrown logging in production but i didnt consider it asynchronous, just lightweight for the end user. 
I use message queues, they're great, but sometimes you just want to smash out a few PUT requests and get on with your day. I would never put code like this into PyroCMS or an open-source component, but if you control the one server that this is ever going to go on then I see no harm in the approach.
Never knew this existed. Looks great - get it finished and put live I reckon. I'm sure some budding designer would be keen to pick it up for their portfolio.
Go a step further and just use a queue. Web server software should be processing and returning requests as soon as possible, so you can free up resources. Responding with 'still being processed' is ok, this is what all good web applications at medium and large scale do. There are plenty of robust messaging/queue processors: * [Amazon SQS](http://aws.amazon.com/sqs/) * [0MQ](http://www.zeromq.org/) * [RabbmitMQ](http://www.rabbitmq.com/) Or roll your own. PHP specific projects (I have yet to try these): * [php-queue](https://github.com/miccheng/php-queue) * [tutorial](http://squirrelshaterobots.com/programming/php/building-a-queue-server-in-php-part-2-building-the-queue-structure/) You set a rule that anything over x ms goes in a queue. Keep that number low. You'd much rather have a thousand 40ms connections than a hundred 5 second connections. The other big congestion point in PHP is the default session_start(). If you automatically include this in your scripts and use the file based backend, you are forcing your users into synchronous connections if you know it or not. That is because the session file reads lock, so if you have a client making a connection to a single page that has 3 sub-requests (via xmlhttprequests or script includes, etc.) they will each be processed one at a time. If you want to know hore of the how and why of queues, Google has a good [chapter in AppEngine docs](https://developers.google.com/appengine/docs/python/taskqueue/). Once you go completely asynchronous in this way you will never look back. Better user response, get more out of hardware, much easier to scale, forces you to design with no sharing, etc.
Not seeing 'responsive'.
&gt; Curl exec limits your software to Linux environments. You lost me right off the bat, seeing as I use curl on a mac and there are native binaries for windows (not to mention cygwin), and runs on pretty much every unix variant.
why not just use PHP's [curl_multi*](http://php.net/manual/en/function.curl-multi-exec.php) functions?
Like I said below: &gt; I use message queues, they're great, but sometimes you just want to smash out a few PUT requests and get on with your day. &gt; I would never put code like this into PyroCMS or an open-source component, but if you control the one server that this is ever going to go on then I see no harm in the approach.
Cake is currently a 5.2 framework, all the ones I linked are 5.3; plus: I ran out of words.
The prototype domain has been around a while, but having it merged into the main site like this looks interesting. Hopefully they'll flip the switch soon enough.
Was about to comment about this. It's a solid way to do it without writing a lot of custom code. And you can tell curl to not bother getting the response if you don't care about it.
Fair enough
What versions of PHP and Apache are you using? Are you on x86 or x86-64? What distro are you running on?
Last I checked "Mac" (osx) is not used as a platform for standard production PHP stacks, although it might be used for development. Sure I could have said *nix but really it's just a nitpick.
PHP 5.1.6 Not sure about Apache, I'll post soon. Redhat RHEL 64bit. But really my question is, is it even possible for the PHP code to be causing this? If it's an OS/PHP/Apache version/config issue that is a whole separate thing.
Sure if you need something quick and dirty you don't want to over engineer. However based on the article it opens up specifying how this is a client library to run in a multitude of PHP environments. Perhaps I misread; regardless best of luck and happy PHP'n!
Does it manipulate images at all? That completely clobbers memory. Using GD-based functions is brutal -- we just ported our image manipulation to ImageMagick and the speed and memory improvements are striking.
I understand they can be _made_ available if you have administration access to the machine. But at that point why are you using exec to call curl? Anyways, I have a feeling most 6$ a month hosting plans will not have exec enabled; if it does have exec enabled your guarantee of "curl" existing as a executable binary is very low in a windows environment.. and if it is there, you won't invoke it using the same command you will need a platform independent check to execute curl in the background; the nix piping won't work. I wasn't wanting to get into the technicalities; simply convey this is not a viable one size fits all cross platform approach.
Clearly this guy doesn't understand how background child processes work if he's not using nohup or disown. Let me show you what I mean: create two files, one called parent.php, and one called child.php parent.php: &lt;?php exec('php child.php &gt; /dev/null 2&gt;&amp;1 &amp;'); child.php: &lt;?php $i = 0; while(true) { sleep(1); file_put_contents('test.log', $i."\n", FILE_APPEND); $i++; } once this is done, run a new bash instance in a console window by typing "bash" and hitting enter. This will give us a controlling terminal that we can easily terminate by using the "exit" command. now run: php parent.php it should immediately exit. running: tail -f test.log should show numbers getting added sequentially. now, exit the shell using the "exit" command and perform the tail command again. oops! looks like the child process terminated! This is because killing the shell (aka: the controlling terminal) issued a SIGHUP (SIGnal HangUP) signal to all its associated children and nuked the process. Depending on how your webserver handles child processes, this can happen there too. If you want to ensure that a child ignores this signal, you need to use the nohup command: parent.php: &lt;?php exec('nohup php child.php &gt; /dev/null 2&gt;&amp;1 &amp;'); This will ensure the child doesn't terminate prematurely by reparenting it to the INIT process. **Don't forget to kill the child.php process if it's still running - that'll write a lot of numbers!** Optimally you shouldn't be doing any of this stuff. Use a proper job queue like [gearman](http://gearman.org/) if you need a job done and you don't care about the response. This is far cleaner and more effective than trying to get php to do things which are potentially bad in a webserver environment. A good rule to remember is that all child processes spawned with a php instance in a webserver environment should end with it. Never put yourself in a position where you could potentially wind up with runaway processes, or processes that terminate prematurely.
I think they're using ColdFusion.... 
I'm making the assumption that PHP is running as a module within Apache, not an external process. Depending upon your Apache MPM(should be prefork for PHP), if your php code is executing stuff that allocates a memory and PHP isn't releasing it, due to memory leaks, circular references, etc. then slowly you will see high amounts of memory usage. With the prefork MPM, by default Apache will kill child-processes every 10,000 requests. Depending upon the number of child processes and depending upon your code, it is quite possible that you'll eat through some memory. As drunkencop mentioned, if you are doing things with images this is a prime candidate for large amounts of memory usage. Newer versions of PHP(5.3+) are much better at handling memory cleanup, but since you are running RHEL 5.x, you'll either have to use a 3rd party package or compile it yourself(avoid that if you can). I would first investigate the Apache configuration, as PHP ultimately is running within it and it will be controlling the processes.
Good point, whilst PHP should do this for you, I'm always being a good developer when working with GD and use imagedestroy() once finished with image instances to ensure they are removed from memory.
You can do wonderful things with color purple but if you are keeping it plain it looks like shit.
Definitely a best practice, but for us imagedestroy didn't stop the crashing. Only imagemagick did. 
orcus' information is solid. The MaxRequestsPerChild set to 1000 will probably clean up memory much better than the default. If you want to upgrade to a newer version of PHP, I would recommend the [IUS Project](http://iuscommunity.org). They provide up to date and maintained versions of PHP (5.2 - 5.4), MySQL (5.0 - 5.5), and Python (2.7 and 3.1) for RHEL/CentOS 5.X and 6.X (i386 and x86_64). All via a yum repo. You can also change the yum settings to use the IUS packages as drop in replacements for the OS supplied versions. Edit: Updated PHP version to include PHP 5.4 which I initially typoed.
Still requires some minor amount of blocking. If you just call curl_multi_exec() and don't let the script run long enough after that, php gc will cull it before the request actually fires off. I know, I tried this, literally, earlier today :)
Surely someone in the community would be willing to design them something decent.
I dunno. I think they need to go deeper with the current site; maybe add some more logo effects in Kai's Power Tools
Oh wow, not even a little bit. Everything is a static width, even the blocks of text.
Nope definitely no image manipulation. It's a pretty basic database app really, about the most interesting thing it does it generate some PDFs.
You're right. It's PHP5.3.3. Just checked the PHP 5.3.6 changelog: PDO MySQL driver: Implemented FR #47802 (Support for setting character sets in DSN strings). (Kalle) Thank you for your help!
I don't think there's a strong use case for checking the site on mobile. How often do you need to check a php function on your phone? 99% of traffic will be desktop based as that's where people do their development Saying that, this design is so simple it would have been incredibly easy to make it responsive so it's a little disappointing in that regard. Is the new site an open source project? If so instead of complaining we could add some media queries :)
Holy damn, the menu dropdown effect is jarring. I'm not a fan of navigation that repositions the entire page (surely this is a no-brainer), but they could at least keep the menu open once you're interacting with it! (e.g. http://vimeo.com/videoschool)
Damn, I was hoping it would be semi responsive. Well, doesn't look to bad on a tablet &lt;3
my eyes, my eyes!
the flicker effect is enough to give you a headache
Are the sources of the new site available somewhere? It would be great if the new site was hosted on github, people could help easily with PR and bug reports
I'd assume that your password and cpassword aren't the same
put message in the brackets: die("message here"); die without brackets only works when there are no arguments passed. btw, either your condition or message is wrong.
Unlike echo, which is a language construct, die() is a function, and thus requires brackets. The line should be die("Your passwords are not the same, try again!"); 
'die' is also a language construct, but it behaves like function (just like 'print'), while 'echo' doesn't.
thanks
JS is required :(
Allow me to explain how to read PHP error messages. PHP Parse error: syntax error This means that you have a syntax error somewhere in your code, i.e. that you've written something incorrectly. unexpected '"Your passwords are not the sa' (T_CONSTANT_ENCAPSED_STRING) This means that it encountered a string in a place where it did not expect to find one. In other words, this is where your error is. /Applications/MAMP/htdocs/website/users/register.php on line 192 This tells you in which file and on what line the code which triggered the error is. The solution here is to feed it a token that is expected. If you check the manual for the construct preceding the string (i.e. die), you'll find that it requires the status message to be encapsulated with a parenthesis. Now, while this solves your issue, do note that this is not the way that you would want to do form validation in a real project. In a real project, you'd want to handle this flow and pass the error messages to the view, not kill the script completely.
&gt;but it behaves like function (just like 'print'), while 'echo' doesn't. Both print and echo can be used with or without parentheses. 
Which pages are you looking at? It doesn't work for me on either the tutorial page or the latest release notes page. These are the two biggest things on the homepage, I'd expect those to be implemented. 
&gt;Now, while this solves your issue, do note that this is not the way that you would want to do form validation in a real project. In a real project, you'd want to handle this flow and pass the error messages to the view, not kill the script completely. I know, it is a test project to build my PHP knowledge, I just needed a quick error screen.
Yes, I suspected as much.
cpassword is my variable for confirm password
I didn't say anything about parentheses. I said 'behaves like function'. You can do false or print('printed'); false or print 'printed'; false or die('dead'); false or die; but you can't do false or echo 'echoed'; // syntax error
It's also very annoying that once you click on a dropdown, there's no way to get back to the blurb/"Download PHP" segment without refreshing the page. I hope they fix it before it goes public.
The function reference pages I've looked at all work (e.g. http://www.php.net/manual/en/book.solr.php?beta=1).
Glad to see they're sticking with that [super](http://www.playerschoicevideogames.com/misc_images/snessystem.jpg) color scheme.
I've been watching the php webmasters mailing list for a long time now. A lot of work has been put into this design. Recently they seem to be pushing real hard to get this site live, unfortunately it's going to be at the cost of bugs and inefficiency. It appears as though the list is being ran by "Google Guy" and he just wants to push this thing out as fast as humanely possible.
It;s really annoying me that the right hand column is out of line!
What shitshow. They've been working on this for what seems like at least a year. It isn't responsive. How hard is it to make a docs site and migrate content?
Just something to be aware of once you fix the issue with die(): &gt;if($_POST["password"] == $_POST["cpassword"]) { This most likely will not do what you want it to. It's checking that the two inputs match, and then telling the user that they don't when they actually do. It should probably be !== instead.
I've had to debug something similar in the past, not properly closing cURL resources was the culprit.
I guess the other question is, why use sessions at all when most actions you want logged in a DB anyway, and the actual session can be handled with an encrypted cookie. It's been a long time since I used PHP's session handler.
I only have one monitor so it'd be nice to be able to have php.net in a narrow browser window off to the side.
Wow. 
Unfortunately, no, it isn't getting better and better. I'll take the ugly, designed by a developer that knows he's just a developer, site over this one. Maybe they should do a zen-garden inspired contest and let someone create something better for them?
I really hate when people assume that only static pages can have beautiful HTML. Here's a generated page I made: http://dimention.x10.mx/ It's sorta describing the website I'm making. Source code for that website (which shares some of the same code to get the beautiful indenting): https://github.com/Tynach/Unite/tree/dimentions And the code for mostly just the indenting/templating: https://github.com/Tynach/Unite I have not had time to actually apply anything I've learned recently to this website; I have a feeling it's badly coded by your guys' standards, so please don't judge me too badly... But basically, it allows for very well formatted output HTML.
huh, I thought they were looking at rolling APC into it. Either one is better than nothing I suppose.
Formatting display code is a waste of time because almost no one is going to look at it; of those who do, you and your fellow developers are the only ones who matter, at you really should be observing it through something like Chrome's web inspector, which reformats HTML nicely. Usually you'll be looking at the source, anyways, not what's generated. For the majority of the people viewing your site, nicely-formatted HTML is merely a page that lacks proper compression, and thus takes longer to download (although gzip makes the difference negligible).
If you [install pman](http://bjori.blogspot.com/2010/01/unix-manual-pages-for-php-functions.html), you can view all of php.net's documentation from a terminal. In a strange reversion, this text *is* responsive (rather than hardcoded to 80 characters).
Lea Verou has given talks on Regex, for which she has built a nice regex tool. http://lea.verou.me/regexplained/ Here is the video of one of the talks. (not the one I saw her give) http://vimeo.com/49446079 
I analyze public password dumps and shared my findings with the [netsec subreddit last month](http://www.reddit.com/r/netsec/comments/166t6s/hackers_exposed_over_450000_passwords_through/), but wanted to share the new January results here as well. I made a comment back then that it seemed like a lot of the sites were PHP-based, and that proved to be true when I actually checked this time around. If you have more experience dealing with the security issues of PHP sites and want to share your theory on why they are so prevalent on the list, do let me know. Some people have asked â€œIsn't that in proportion with the number of deployed PHP sites?â€ Of the two stats I've seen, one is from Netcraft (which I quote in my blog) that puts PHP sites at 39% of the Internet. The other is from W3Techs, which puts it at 79%, but is only gathering data from the top 1 million web sites. To me it seems like the numbers don't match up closely enough. If you have questions about the password dump findings then comment and I'll try to answer. Edit: fixed link &amp; fixed my fixing of link
Parser loses its shit!
&gt;Some people have asked â€œIsn't that in proportion with the number of deployed PHP sites?â€ Of the two stats I've seen, one is from Netcraft (which I quote in my blog) that puts PHP sites at 39% of the Internet. The other is from W3Techs, which puts it at 79%, but is only gathering data from the top 1 million web sites. To me it seems like the numbers don't match up closely enough. Is that also counting static HTML pages? You can't really congratulate them on making those services secure.
array: needle, haystack string: haystack, needle
I haven't looked at the data, but just by guessing I'd assume it's because a majority of the large CMS's are written in PHP. Most people set up these sites without doing any of the security dirty work and go about installing modules and plugins that have holes in their code. One-Click installs are great, but nobody thinks about their site once it's working.
Which doesn't speak to any insecurities which are specific to PHP, but rather to its popularity.
That was one of the guesses I made in the document. What I hadn't heard was a PHP experts say something along the lines of "Oh yeah, RandoPHPCMS v1.0" was used all over and had terrible SQL injection problems. Not enough people have upgraded to v2.0 yet." I don't think the problem is a single piece of software, but was curious if there were any worse offenders.
Ugh, this is weird. The homepage links to http://php.net/tut.php for the tutorial, which doesn't work (for me) if I append the beta query (http://php.net/tut.php?beta=1). Since there *is* a working beta page (your link), why on earth doesn't the homepage link to it?
The docs site is probably pulled from a MySQL database anyway...
&gt;I don't think the problem is a single piece of software, but was curious if there were any worse offenders. Oh god, thumb.php (or timthumb.php) used in countless wordpress themes as well as many other pieces of software. That was a bad, and prevalent issue.
At least one of the sites with a password dump was a static HTML site, so apparently it is possible to screw that up.
Interactions with the database in php are very easy to make insecure. Not that the problem doesn't exist in other languages, but with how you directly manipulate strings in php and how mysql extension was written, people being lazy can cause a lot of problems easily. Forget to escape your input and allow ", and just dump a response to the page... very easy.
I don't really doubt the numbers, but I have to wonder how often the DB dump was obtained through exploiting code vulnerabilities and generating database output, and how often the DB dump was obtained by finding sql dumps, backups or improperly configured but not inherently insecure software. And how many of them are from shared hosts (where PHP has the lion's share of the market), and how many are from VPSes/dedicated/colocated servers. Another interesting statistic would be the breakdown of the software package the database dump itself belongs to - I'd wager of the PHP dumps, over half would be WordPress+Drupal+Joomla. 
It might be that a lot of the PHP projects are open source. So when a security hole is found and patched its relatively easy for a hacker to compare the two versions and work out the vulnerability. If they do this before the site upgrades, well... The number of plaintext passwords are disturbing in this day and age. With the hashed password dumps do you try them with any reverse lookups/rainbow tables to see if they've been salted? I can see why you wouldn't from a ethical standpoint, but maybe make a PasswordResearch dummy account on major sites? That way if they get dumped you can look up that account and see if the hash can be easily broken without being in too much more of a grey area.
I wish I had a week free right now, I'd happily do it for them. This new site still looks like it's from the 90s.
39% of the websites on Netcrafts list are PHP. 78.8% of the websites that W3Tech track are PHP. If Netcraft sucks (which is possible) then the 91% seems like a reasonable number, seeing as 78.8% of these sites are run with PHP. More sites = more hacks. On the other hand, if it is because W3Tech only track the top 1 million sited, then it means that a lot of those other sites on the Netcraft list are just not very popular. Who is bothering to hack these unpopular websites? A third assumption, of these many websites that are PHP, how many of those were WordPress? That thing has more holes than a sive.
My suspicion is that this particular site was changed between when the database dump happened (the dump file does show MySQL info) and when I visited the site. That's not entirely unexpected since some of the admins probably were alerted that their site had been compromised after the dump was posted.
Last month the ratio of hashed to plaintext passwords was closer to 50/50, so this month's totals may make things look better than they really are. The password hash analysis is the part I didn't complete in time to include with this post. It is something I'm interested in measuring, along with the types of hashes used. I found some sites that did salting, but out of the list I've gone through so far they are definitely in the minority.
Nice work. I am curious about the performance implications of all the reflection, function invocations, and annotation reading.
PHP definitely makes it easier for a developer to cut corners with database interaction and leave in a vulnerability. There's a lot more bad code and bad resources in the PHP world than there is in the Python world, for example. That's especially true with database interaction. There are certain SQL functions that should probably just be removed from the language (because they're so prone to misuse). Ultimately though it's up to the developer and whoever hired them. PHP is as ugly or as beautiful as you write it, as secure or as insecure as you write it, etc., and that's probably what I love most about it.
From the mailing list http://marc.info/?l=php-internals&amp;m=135913119321197&amp;w=2 Having something baked in as default is a great move forward, rather than PECL. At the very least it should see the attention it deserves being put into Opcode caching for PHP going forward. Not at all trashing the great work done with APC, a PECL extension I consider pretty much essential on any production PHP server. As a side note, has anyone successfully installed Optimizer+ into PHP before under Linux? A quick Google I get the impression it's a pre-built component of Zend Server 5.6? http://www.zend.com/products/server/
With some dumps it is very clear that it was obtained through SQL injection, while others you only get the exported columns and have no idea how they were obtained. I may go back and tally up how many show clear signs of how they were obtained. I agree that this info would be more valuable combined with installed software packages, but I wasn't prepared to look that deeply into the sites.
&gt; There's a lot more bad code and bad resources in the PHP world than there is in the Python world Doesn't that also speak to its popularity.
At string comparison function: why not http://www.php.net/manual/en/function.similar-text.php ?
I realize the author means well, but you couldn't pay me to add this level of unrequired bloat to any project.
Not necessarily. It also depends on it's popularity, against the competency of the programmer. i.e. is it popular with everyone, or popular with just beginners? I know plenty of very experienced programmers, who would never dream of using PHP. I also know plenty of inexperienced programmers, who love PHP, because other languages seem far more confusing with their build processes, XML config files, jars, stacks, and so on.
&gt;PHP definitely makes it easier for a developer to cut corners with database interaction and leave in a vulnerability. You can do insecure as hell interactions with other languages, as well. It's just less likely, becauseâ€”againâ€”of popularity. Newbies are going to gravitate toward what's popular, not Python or whatever.
I would say a combination of popularity and also technologies used. There are plenty of PHP sites out there that are completely custom built php. On the flip side, anyone using Java, Ruby, Python, etc is almost certainly using a 3rd party framework which provides some tools and best practices for avoiding SQL injection. On top of that, there are plenty of popular PHP packages (wordpress, drupal, phpBB) which are often installed, never updated, and have a history of security issues. There are very few non PHP packages like this that are installed so widely by amateurs. 
Oops
I think this is a great idea. However, this is going to have performance implications. Implement this as a php extension in C and you have a winner. 
what Windows is to the OS world.
Since nothing was created, I would say yes.
Over 90% of servers serving up dynamic web content are running PHP. Makes perfect sense statistically and has little to do with PHP itself.
nah, php's really not as beautiful as you can make it. Even when using CodeIgniter and full MVC and OO code, Java is so much better than PHP.
Where is the meta programming? This is in no way sane, its the exact opposite of sane.
I think you are somewhat talking yourself down - from what you have written above you are miles above the great bulk of crappy PHP programmers I have come across in my working life.
I appreciate it as an experiment. However, there are good reasons why it is a bad idea to implement stuff like this in userland, not the least of which is performance and memory usage.
lol You can't blame the paper and pen if you end up writing a bad letter.
The "o" stands for "overhead".
I've personally written some totally bullshit hackable C++, Java, C#, Perl, and Python code. PHP's PDO is about as safe as anything else. You can write crap in any language. Believe me; I've done it. Maybe languages like C# are a little easier to write securely because they're generally very high level. The lower level you go, the more easy it gets to make a mistake.
Being many of those amateurs Designers wanting to do the job of developers. Sorry... couldn't stop myself from saying this!
Its all a matter of choice and ways of thinking... I guess people tend to adapt better to a certain language because they understand it better, it fits better in their logical thinking. 
Here we go again... which one is the best... PHP vs Python vs Ruby... and blah blah blah. What makes bad code is not the language but the coders. And there's no better or worst... they are all different up to a certain level, but deep down they all are the same. People should discuss coders methods, practices, frameworks but not the language in this cases. For me, who says that X is better then Z is just being biased through their personal experience and taste, sometimes because they are lazy or in some ways unable to learn the others,so the one they know and work with is always better. I learned and worked with all 3, and for me none is better or worst... they are just different. Just my opinion...
As a PHP developer for 10+ years I would say: don't. You'd be better off in the long run learning something like Python, Ruby or Node.JS. If you want a summary of why PHP is bad: me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
My point is that none of the security issues listed are in any way unique to PHP, and PHP isn't any less secure than other languages, but the reason why PHP ranks so high is only because it is a whole lot popular than its competitors and powers the majority of the web. Whether a website has security holes is not the fault of the language, but that of the programmer.
I wouldn't care of the packages, PHP, SQL, whatever... Independently from the language I would use, I would make things safe in a way that even if the passwords database would get stolen, they would be encrypted. Being able to retrieve an unencrypted stored password in any way, it is a sign of a bad development practice. Storing a simple hash of the password and do authentication by comparing the hash of the password from the login attempt, would make the passwords from stolen databases almost impossible to use. 
Calm down man, sheesh. 
I guess I wasn't really saying anything but what I said. Literally, take it for what it is, fb uses php to make a massive site? Even before hip-hop it was php.
Your statement is not at all accurate and is even address in the article.
Sounds like you don't need to keep up. If you were a full time dev I'd say "shit or get off the pot", but give yourself a break and just keep on meeting your immediate requirements.
But even still: You can make a big site with PHP but it's not the best way to do it.
&gt;for novices like yourself His description of himself made it sound like he was way better than a novice.
You make it sound like the contents are anywhere near scientific; it isn't. For starters, the data isn't representative of the web as a whole (if you wanted something which is representative, you'd go with a fairly distributed sample), and secondly, he didn't even collect it himself. They're just a small collection of dumps he found on pastebin.
&gt;Register globals ... is gone. Deprecated as of PHP 5.3.0, removed as of PHP 5.4.0 and hasn't been enabled since before PHP 4.2.0 (over a decade ago). &gt;arcane comparison operator Is called weak typing and is hardly limited to PHP (and again not the fault of the language, unlike the register globals example). &gt;for a long time PHP made SQL injection attacks easy to leave yourself open for and while PHP does now contain mechanisms to handle it correctly, the old insecure methods are still widely taught and used. Again, not the fault of the language, but the developer. These issues also exists in other languages.
I fundamentally disagree that there is a "right way" to do it. There is nothing that makes this case coming from any platform. Tools are tools, what matters is what you do with them. Why do you believe php is not the "right way", as you say? Any seasoned php vet will disagree with you.
I still see it in theme files all the time. ugh.gif
Register globals exists today primarily in the form of legacy code, but you're naive if you think they're not still a problem. Weak typing is only tangentially related to the bizarre design decisions on how comparison operators decide their results. &gt; These issues also exists in other languages. Few other languages have retained blatantly insecure interfaces, causing them to be haunted by obsolete tutorials and information. Even the PHP manual is loaded with comments which range from broken code, to bad ideas, to outright security vulnerabilities. Really the root problem in PHP is that the language was never actually designed, it's been cobbled together using bits and pieces of other languages that don't always fit well together. On the surface it's a simple easy to use language, but delving deeper it's full of brain damaged decisions and behaviors that cannot be realistically fixed.
&gt;Few other languages have retained blatantly insecure interfaces If you're again referring to register globals, then again, it no longer exists, it was removed in PHP 5.4.0, deprecated as of PHP 5.3.0 and disabled by default since 4.2.0 (11 years ago). 
In that case I'm referring to the mysql_ interface which has only been recently deprecated.
Uh huh, and when did Mysqli and PDO show their faces to the world? PHP 5.0 and PHP 5.1 respectively? Nearly a decade ago. Not to mention that there's nothing actually stopping you from writing secure code, even in the old mysql extension. So no, it's not inherently insecure as you claim, and again, the fault is with the developer.
 $function = function(){}; // ... $value-&gt;$closure instanceof $function Are you kidding? how about "instanceof Closure"? PS. You have some refactoring and error fixes to do, e.g: https://gist.github.com/AstDerek/4546115#file-collection-php-L67 - $value-&gt;closure() instead of $value-&gt;$closure() About refactoring - at least change multiple if (is object &amp; smth) .. elseif (is object &amp; smth) to a single if (is object)
 $value-&gt;$closure instanceof $function I was getting undefined errors trying to call the lambda directly, found this approach at StackOverflow and it worked, so I kept it. Maybe I was getting those errors because of those missing *$* at *closure()*.
Right but if you write a static HTML page with usernames and passwords on it then that's not a flaw in HTML, PHP or the web server.
Yeah, PHP and Java are used for similar jobs right?
I am in a similar position, although I do use PHP in my job, so I guess I could be considered a "professional" developer. I asked a [similar question](http://www.reddit.com/r/PHP/comments/1664lq/is_it_just_me_or_does_the_way_php_development/) a few weeks ago and got some very helpful answers.
it's just an example
It was interesting, but when it got into securing sessions and templating, I was "wtf is that doing here!". There are several topic mixed here. But the approach is refreshing, even though I would never use it in real-life project.
Seriously, if OP is a novice, then I'm a fetus.
Novice is not an insult.
Plus he mentioned several other sites like Twitter/LinkedIn in the article that were hacked and I assume not counted the database dumps (and thus not part of that 10%).
&gt; None of the security issues here are in any way unique to PHP, but also exists in other languages. The reason the numbers are so high is not because PHP is any less secure than other languages, but because it is a whole lot more popular than other languages, and drives the majority of the web. Where did I say otherwise? I said it was down to the competency of the programmer, but could be more popular with less competent programmers, than good ones. In what way does that state the security issues are PHP issues?
I only looked at sites that had their passwords dumped in January, so you're right, Twitter and LinkedIn weren't counted. But that 90% figure came from counting the number of sites and not the number of passwords from those sites. Including a large password breach wouldn't have made as much of a difference in the trend for this particular stat.
You and several others have made the argument that they make up 90% of the vulnerable sites because they make up 90% of the total sites. I've offered statistics that dispute this. That's why this I see this finding as significant. I agree that there doesn't seem to be any reason PHP sites should be inherently more vulnerable to SQL injection than ASP or JSP sites. But it does look like it is apparently coded/deployed more often in insecure manner that allows these database breaches to occur.
No, I have not made the argument that they make up 90% of the total sites. They make up 90% of your data set. The problem here is your data set, which I have pointed out isn't anywhere near scientific. 
I think there's still place for hobbyist programmers. They will have a bit different route of learning these days. Basics are still the same, but next step is using some micro-framework instead (silex, etc.). It becomes "best practice" as it allows to have much better productivity with less efforts
Well, thanks, I really appreciate that. It's difficult to assess one's skill level relative to the general php community, particularly when working in isolation, more or less. I've recently been trying to reach out and connect more. Maybe I'm more advanced that I realize, but there sure is a lot to learn out there.
No insult taken. And, I think you're right . . . it's nice to have the freedom to code in one's own style. But at some point, you want to use the utilities that other people have created, and you've got to understand their dialect. That's exactly what got me started down the road of trying to understand OOP.
Yeah, it's kind of an adjustment to realize that I can use something without trying to fully understand it in every detail. Like that Zend Gdata library I'm using. I understand it well enough to get the results I want. But I'm not an expert in it . . . but it's still quite useful.
Just wanted to say "thanks" for all the replies. You all are a great resource!
As a bit has changed with Slim since this article was written, anyone interested in using it should also keep up with the changes on http://www.slimframework.com/.
And you suck a trolling.
I haven't tried it yet but if it's as simple as it looks this will be a huge time saver! Code looks pretty clean and could easily be extended to support other git remotes. Thanks :)
You could try using "exec", "system", "passthru", or backtics.
It seems like a lot of php devs in here are getting defensive about it and downvoting. Clearly the language is just as secure as its competitors. But is it any secret around here that PHP is popular with noobs? Just venture over to /r/PHPhelp and take a look at the awful practices that beginners are taught through outdated blog posts and youtube videos. There is a lot of *terrible* code out there being mimicked, so why are we surprised that there are so many vulnerable PHP sites? As stated above, there are almost no Ruby sites being built without Rails, nor Python sites without Django. But how many PHP sites are built from the ground up? Nicoon and yourself are both right. None of it is the language's fault (especially as of 5.4), but we can't deny that there are proportionally more noob PHP devs than other languages. It's great that PHP is that popular, but it means there's a lot of bad code out there. edit: Also, much like the "OSX doesn't get viruses" phenomenon, I think it's the case that hackers target PHP sites *because* of its popularity.
I just did a quick Google search, it said around 94%-95%. I was just ballparking.
You mean like this? https://github.com/nikic/scalar_objects
as in routing to a pseudo file extension, like `$app-&gt;route('/blah/thing.json', 'doThing');` ? Or as in actually serving the json resource properly? It wouldn't be very hard to write a middleware for it that accomplishes that, I thought there was one but I could be wrong.
It also has a lot to do with the popular website engines (e.g. wordpress, which is PHP) and what they are written in. There isn't necessarily as much roll-your-own as there is off-the-shelf. Most sites in fact probably don't give a shit what language their pre-fabbed engine happens to be coded in, because the important part was the feature set it came with.
I wasn't trolling. I doubt you've actually developed any kind of javascript skill apart from using `document.write` and `onClick` hahahaha
I think what he's wanting to do is get traceroute data from the viewer back to his server. Not going to be possible.
I really enjoy working with Slim. I have used it in many instances as the REST API for a Backbone.js app as well as simpler jQuery + Bootstrap tools. It is also the easiest way to get started with [Composer](http://getcomposer.org/) IMO.
Look into this - I know when I was writing a PDF generation app, memory leaks and the like we're involved. 
yeah kinda like /{controller}/{action}/{id}.{ext} giving the ability to serve different responses (json vs xml vs html). Somebody posted a middleware to detect that, but it is incredibly dirty. Basically the middleware was modifying $_SERVER variables to have the router act differently.
I said "almost impossible", and by that I mean almost impossible between certain measures... as for me, nothing is impossible. Probably not the best use of the word, but I totally share the same opinion as you.
the Git/Composer hook works really smove http://support.fortrabbit.com/customer/portal/articles/717047 
Thanks to this article I've finally got to understand what RESTful services are.
Content negotiation should be done via the Accept: header and not the file extension. 
Yep, Java can be used for web development and its quite good for it. http://www.playframework.org/
Just because you can use Java for web development doesn't mean it's main uses are in web deveopment in the same way you can use PHP for general scripting but it's mostly used for web development.
really? I looked at Slim for a recent project but chose CodeIgniter w/ Sturgeon's RESTServer instead so that I could use controllers / models and have better separation of code. Did I gloss that over in Slim's documentation?
You're thinking about the [PHP-FIG](http://php-fig.org).
That's it. Thank you!
Im asking is puttting data to a file can make database faster. Can it speed up my sql queries. And is this a custom when it comes to optimization. Also can i find some articles about this kind of optimisation. (by putting data to file and importing it)
&gt; Im asking is puttting data to a file can make database faster. Can it speed up my sql queries. What kind of data? What kind of file? What relationship does this file have to the database? What kind of queries? &gt; Also can i find some articles about this kind of optimisation. (by putting data to file and importing it) I have never heard of such a method of importing flat file data to a database that would ever yield any sort of optimization. A complete shot in the dark here is that you have a shit db and you are constantly inserting or updating values on it (hundreds to thousands of queries per second) and your code is waiting too long to open DB connections and execute queries. So instead, you want all these queries to be cached in a flat file so you can (during non-peak times), run all of the cached queries in one go. If this is the sort of optimization you seek, then you've got deeper issues you should resolve first. Do you know what an index is?
It's called caching. Serve up the data from cache until it's updated.
But it is easier for API consumers just to GET {url}.ext.
&gt; This is called confirmation bias. People in glass houses shouldn't throw stones; neither of us put forward any citations to back up our comments. However, if you re-read my comment you see I put this forward as a question, and not as a statement.
Hey thanks for this tip, turns out I was wrong about there being no image manipulation. I went through the code and did find an instance where it creates a barcode image and doesn't call imagedestroy. So that will be my first thing to try, and if that doesn't do the trick I will be looking into ImageMagick.
For the size of site you're talking about this is unnecessary and not going to speed things up. MySQL/PostgreSQL/etc. should be able to handle 100s of queries per minute easily.
Am I the only one who thinks some of the standards they're pushing at FIG are completely retarded? &gt;no tabs, 4 spaces &gt;brackets on the same line as if/while/do but not class/methods 
You said, to paraphrase, 'hashing the password would make the passwords from stolen databases almost impossible to use.' Am I wrong in my interpretation? Maybe you later changed your mind on that statement, but you still seem to be arguing that it isn't worth someone's time to crack passwords. 'Almost impossible' means it is not worth trying, and that is very far from the truth. Hashed password are cracked on a regular basis and are little trouble for anyone unless the site uses a strong hashing algorithm and salting, which few sites currently do. There are web sites dedicated to performing password cracking for free. It takes little time and energy on behalf of the person doing the cracking. As to your question of why would someone spend time cracking passwords to get access to something like an online game, that depends on the game. There is a very large black market for in-game currency or items, and sometimes entire game accounts. If there is a perceived or real value in having access to a site's accounts you can bet that someone will try to crack the hashed passwords.
Why are you using `twilio/php` as the composer package name, I assume you don't work for twilio? You should consider writing tests. If this is based on an existing library, you should consider contributing your changes upstream.
Because I've been using PHP for a long time, and I recently moved to Java, and I love it. Its just as easy to deploy as PHP, costs a little more - Around $40-50 a month opposed to $5-10 a month for crappy shared hosting, but there's no question that Java code is a lot more elegant and stable even in the hands of an amateur programmer than PHP is in the hands of even someone with 6-7 years experience like me.
Let me know how it works out! And fwiw I found imagemagick very nice to work with when resizing images.....
If you have a reasonable IDE/editor it shouldn't matter if spaces or tabs are used, it should silently convert one to the other, but using all spaces has advantages As for brackets, that's K&amp;R/1TBS style which is used in many many C/C++ style projects (like the Linux kernel). 
yeah that was my conclusion, I just wanted to make sure I made the right choice. I couldn't find ANY other frameworks for PHP that were suitable for REST using some sort of models / controller arch. I use a couple different Chrome extensions for testing REST apis, that one looks great though, I'll have to add it to the collection. My personal favourite is Postman. 
There's always a prick.
Again, once more... you are trying to prove your point that was already proven and I agreed... and trying to lecture me about encryption and security, about what I already know maybe since the time that you probably in the kinder garden. What makes you think I don't know what you are saying?? What makes you think that I'm disagreeing with your point or saying that you are wrong about hashes and shit?? What's wrong with you?? Did you try to understand what I was saying at least?? Am I speaking Chinese?? English is not my first language, and I may have difficulties on expressing myself, but I guess you are not even trying or even reading what I'm saying... I may have used the wrong words, but I didn't change my mind. that is the excuse of stubborn people that often fail to understand and then never admit that they didn't even try to. My opinion was based on the simple fact that I have witnessed counts of stolen databases where the password fields were simple plain text without any kind of encryption. I guess it doesn't need to much to understand that I was saying that is a bad practice, and at least some encryption makes things more difficult (yes I said "almost impossible") in case databases get stolen. Simple as that... Now because I used the word impossible for some reason, you got it in a way that you fail to accept that was the wrong way, and that I didn't mean what you understood. Man, get your mind out of what it is stuck to, and start listening (reading) better and understand what people say before jumping on wrong conclusions and start lecturing them. Nobody is dumb here and nobody is fighting you... 
Repost because I'm an idiot and linked to mobile site originally.
Reposted: http://www.reddit.com/r/PHP/comments/1861gy/the_joy_of_php_free_on_amazon_for_limited_time/
Note that this is a *very* light introduction, and even includes some bad practices, such as: http://min.us/mbbClPf0mzczC2 You would do well reading more advanced books after this one that will clear up security issues. I haven't read the rest of the book but immediately jumped to the SQL section, which doesn't mention injection at all, until in a few pages much, much later.
&gt; The closing ?&gt; tag MUST be omitted from files containing only PHP. why'd you ever leave a closing tag out of anything?
Keeps you from making a mistake and leaving content (like an empty line or space) after the closing PHP tag. If that happens, calls to header() later will fail since content has already been sent. 
I think the idea behind this one is that if there are blank lines left on a document following the final `?&gt;`then it would cause issues with output bufferring. Because the parser does not require the closing tag it is easy enough to leave it off.
oh wow, i wasn't aware of such a problem with php, has it been an issue for long?
You could look at [Lorna Jane's new book on PHP Web Services](http://shop.oreilly.com/product/0636920028291.do).
I don't understand why anyone considers spaces a good idea. Let's claim that spaces are better because you can emulate tabs with an editor... But you already have tabs that behave like tabs! Then there's the preference problem; I've seen some like 3, 4, or 8 spaces. Great. If you don't like the indent level, you're stuck with it or have to re-indent which is a no-no if you're working with others. Tabs? No problem. Just set your editor to whatever you prefer, and it works for everyone. Tabs are also unique in their use for indentation. If you see a tab, it's guaranteed to be indentation. Hell, you can even trivially s/// it back to spaces if you want. Not so for spaces. Then there's the lowest-common-denominator. Stuck editing files on a system without your favorite editor? Sorry, it's space-space-space-space, delete-delete-delete-delete over-and-over again for you! Tabs... They work just fine. I have yet to hear an argument for spaces that has come anywhere near winning me over. Bracket style? Fine. That's coder-religion and nobody can claim one is better.... But the tabs v. spaces argument makes no sense! There are actual reasons why one should prefer tabs beyond just preference!
OP mentioned that he expects asymmetric routes, so server to client isn't really going to help. There isn't a way to do what he wants to do using PHP only.
I used to prefer tabs but shifted to the spaces camp simply because it's easier for larger projects with several people editing in different platforms. Different editors handle spaces the same way, but tabs, not so much. Tabs are definitely neater and have certain advantages, but when you're merging / reviewing code from several developers, it's just easier to setup a 4-spaces per indent standard. For editors, I work mostly with linux platforms, so my favorite editor (vim) is usually available. Not arguing for or against, just giving the perspective of a project manager.
In my project we've decided to close all PHP tags and make damned sure we don't make the mistake of breaking the system with extra content. This is a stupid rookie mistake if you decide to put line breaks at the end of a class file. While it goes against this convention of "thou shalt not close tags on only PHP files", it's visually more understandable, preventing people from questioning why all the PHP files are missing closing tags.
&gt; The problem here is your data set, which I have pointed out isn't anywhere near scientific. That will be why it was published on a blog, and not in a scientific journal. However that doesn't mean you can just blindly disregard it, simply because you don't agree with what it is implying.
Anyone who questions why PHP files are missing closing tags hasn't been around the PHP community for very long. This has been a standard for close to a decade.
You must not work in a Java shop then.
Ah, so you work with QuestionFactories. It's all clear to me now! ;-)
I'm trying to learn it as well. it's been one week and still i haven't written any code yet. is there any tutorial which shows a basic project. so I can understand how to write the code, where to put the files etc...
Nope, because it really doesn't matter much with a modern IDE. I can convert between them easily, or I can adjust the tab width. I prefer spaces, but I don't feel I need to justify my preference to other developers. If I work on a project which uses tabs, I'll use tabs. That's the point though; it doesn't matter. Coding standards just make projects uniform. I never understood why some people choose to bitch over another project's standards or developer's preference.
I'm a vim guy myself. :) I don't understand why you say different editors handle tabs differently? In my experience, every editor is capable of inserting tabs when the tab key is pressed. The simplest will only insert a tab. More advanced editors are configurable. I.e. in any editor, a tab (character) is a tab is a tab, and a space is a space is a space. In a significant project, people will prefer different spacing for one level of indentation. If you mandate 4-spaces, everyone reads code at 4-spaces. If you mandate tabs, people can read code with the indentation level of their choosing. Merging/reviewing code from several developers is equally consistent either way if indentation is consistent. The biggest issue I've had is the guy that refuses to give up 3-space indentation. As I see it, every developer will be using a developer's editor most of the time, so regardless of tabs or spaces the behavior they encounter is that of tabs. Choosing spaces means everyone has to read the code with an imposed level of indentation, choosing tabs means they get to choose.
"I have yet to hear an argument for spaces that has come anywhere near winning me over." Open putty, and ssh to a Linux box. Open a web browser, and copy a line of code (for example, from Sourceforge). Paste said code into nano/ed/etc. Save. Diff. Notice that your simple copy paste now triggers a diff because tabs don't paste, but spaces do. The FIG actually cites that issue (copy/paste/spaces/tabs) in their discussion of the choice.
Every project I've ever worked on ended up with a mix of spaces and tabs. When cutting and pasting code you just don't know what it will end up like. Then you look at code with a different indent size and everything looks like crap. 
If someone questions why PHP tags aren't closed, give them an education. There's a perfectly good reason for it. 
Uniformity clearly takes precedence within a project. No argument there. Nobody is forcing anything on anyone either. (Even though the PSRs say MUST, the list of projects is fairly divided with respect to tabs/spaces.) What I wanted was to elicit discussion about tabs/spaces because I want to understand why anyone would choose spaces. wasted_brain had some good insight (below). All I'm getting from you is that you don't like my strong preference for tabs...? (FYI, you're getting upvotes from me.)
A valid and reasonable argument, thank you. That's one. :-)
Full disclosure: I co-created silex. I don't really get the fear from installing 4 symfony components. Sure, I would mind 10 or 20 needless dependencies. But 4 of them, really? And if you look at what they do, then they actually make a lot of sense: * routing: core routing logic * http-foundation: sensible http interface * event-dispatcher: core event logic (you wanted before/after, didn't you?) * http-kernel: request lifecycle, routing (via event listener), actual before/after events * silex: ties the parts together and provides a nice API If you're still not convinced that they are lightweight and harmless, I suggest you take only the routing component and build your own framework with it. [Part 4 of Fabien's "Create your own framework" series](http://fabien.potencier.org/article/53/create-your-own-framework-on-top-of-the-symfony2-components-part-4) should give you a good starting point.
My understanding from tabbists is that you indent with tabs but align with spaces to avoid such issues. Tabs show your nesting level, spaces align things to be pretty.
I'd like to find some me too.
I'm curious about things like this. I wonder how much real world difference something like this would do to a project vs the amount of time saved maintaining the code. 
Well, there's [/dev/hell](http://devhell.info), which includes PHP and is quite entertaining. IIRC, last year they did a live podcast from php|tek.
There is also [PHP the right way](http://www.phptherightway.com/)
I think using a mixture of any kind is even worse. There are cases where developers want to line things up on beginnings of new lines, which would put tabs and spaces next to each other and that's no bueno. I'd rather maintain code with all tabs than a mixture.
There was http://phptownhall.com/ but it's been a while
You're looking for [Toro](https://packagist.org/packages/torophp/torophp). 1 file, 100 LOC and its in composer / [github](https://github.com/anandkunal/ToroPHP/blob/master/src/Toro.php).
Do you have a blog? That was a clear explanation, and well written. Cheers for taking the time to write it.
It's about learning php in common, not about standarts. But ye, it's a good place to learn (=
No composer =( IMO it's a must now.
It's possible to munge the requests before they go out by subclassing SoapClient and overriding the __doRequest() method... but you'd probably want to make sure that it _is_ simply the namespace *prefix* that's making the difference (it probably isn't). Can you post the whole failing request, along with the successful SoapUI counterpart?
i've got a pull request due that separates the matcher and the resolver so you can override either edit: checkout my fork: https://github.com/nikcub/ToroPHP i'm about to add it to packagist incase the pull requests aren't accepted. it will be in nikcub/ToroPHP
see: http://www.codefromthe70s.org/traceroute.aspx
I believe that the reason is the belief that tab spacing can cause issues in diff comparisons, whereas spacing does not. Whether this is actually true or not, I have no idea.
Exactly - on the one hand you COULD make sure you always avoided trailing white space after a closing tag. On the other hand why bother when omitting the tag from a pure php file will prevent it ever causing a problem. Why do people like to make their lives hard?
A space is cross platform and is always one character, a tab isn't It doesn't matter what one developer preferes 2 spaces or another 4, the key is to make it consistant throughout a project For eg. If I am contributing to Drupal and the project is a consistant 2 spaces everywhere, but I prefer 4, I can easily change that in my editor &gt; Hell, you can even trivially s/// it back to spaces if you want. This is what smart editors do *with* spaces. For eg. if you are 2 spaces throughout, your editor will s/^[\ ]{2}/ to 4 spaces in your view
You're really missing the point though. What the standards are doesn't really matter that much (within reason) the important thing is that everyone in FIG follows them. You get used to standards pretty quickly (I have shifted between same-line braces/new-line braces a couple of times in the last year for different jobs and within a week or so you can't believe you ever did it any other way) so the less switching between standards the less you notice them. Generally 50% of people will complain about any standard you could come up with. In this case just accept you're in that group and deal with it. Everyone following a single standard that is not perfect is better than everyone following their own standards that are not perfect.
It's worse than this actually, extra whitespace etc when outputting HTML or most other text-based formats doesn't cause problems. The real problems come when you're using PHP to generate an image, pdf, other binary format on-the-fly.
Generally, people convince themselves that they're too good to make "stupid rookie mistakes". Then they get incredibly frustrated when they do. It's the same as folks who champion against IDEs -- those are also the people who make "missing semi-colon" jokes.
&gt; Others use Symphony components Be careful with the spelling of the project name you're referring. There are actually 2 completely different projects with the similar sounding name. * [Symphony](http://getsymphony.com/) - XSLT-powered open source content management system * [Symfony](http://symfony.com/) - Open-Source PHP web framework
looks great, thanks!
There was only Ham when I wrote it, seems like mjcov edited message after that (=
Two wonderful projects that I am happy to be involved with, but PHP The Right Way has nothing to do with what the OP asked.
It's not a problem, you just make sure you dont output garbage whitespace.
Why would anyone be confused? "Im not sure if PHP is still parsing anything. I mean, there file ended, but maybe there is magically some PHP which I can't see somewhere?" If the file ended, PHP has finished parsing, so you dont need to close it and give yourself the concern of whitespace problems ever happening. Stop it. The standard added this line for a reason.
There is a [proposal](https://wiki.php.net/rfc/phpp) for that already.
You are not, there are plenty of people whining about PSR's and they have been for months. I got so bored of answering the same things over and over again I wrote [a blog](http://philsturgeon.co.uk/blog/2013/01/most-important-conversation-ever).
Tab formatting is really inconsistent across OS's and editors. Spaces are explicit. As for the brackets you really won't notice the switch. Whatever the reasons are it helps foster code sharing and collaboration in the PHP community without having to worry about conflicting commits that just use different syntax.. it wastes time trying to resolve and if committed is just superfluous.
Indentation and alignment are two different things. I always used to use tabs for indentation (because it doesnt matter what happens in your editor, your tab size will be used and you win at seeing code your own way) and spaces for alignment. Obviously spaces for alignment are the only way to ACTUALLY align the code, but even then in some editors tab indented code will break that space aligned code. Plus that means that sometimes using tabs and sometimes using spaces means I can't repurpose the tab key to spaces and means that indentation takes a hell of a long time. SO, this one rule makes both alignment and indentation entirely consistent, and that file is always going to look perfectly formatted in vim, nano, Netbeans or printed out in Comic Sans. These are some of the reasons spaces can be considered a good idea. Try to keep an open mind about these things, decisions in the FIG are talked over a LOT and we're not just making up random things for no reason what-so-ever.
There is a section called "Code Style Guide". It specifically talks about FIG.
I thought of it because that is how I first discovered FIG. I was reading the "Code Style Guide" section.
The [Smart Tabs](http://www.emacswiki.org/emacs/SmartTabs) technique doesn't have these issues if followed properly, and then has the advantages of both tabs and spaces.
Since when do companies reserve composer package names? It's completely rewritten.
The smart tabs technique is exactly what paranoidelephpant was describing. Putting tabs directly next to spaces is error-prone and unnecessarily complex. Your editor can't accurately predict whether you want to keep indenting or start aligning, so you then have to make excessive use of the space bar for adding large amounts of whitespace. Take the following code for example: if ($foo) { $bar = isset($baz) ? $baz : 'quux'; } With smart tabs, you have to press [tab][space][space][space][space][space] to begin the lines beginning with '?' and ':'. With spaces only, you press [tab][tab][space] instead. That's 3 key presses instead of 6. The effect is greatly exaggerated in some other cases (like the first example in the link you pasted), leaving the difference even greater. You can also just hold down the space bar, but that's error prone. You're not likely to stop exactly where you need to, so you'd still need to press [backspace] or [space] a couple more times. If your editor had an auto-indent feature, the effect is still the same. It'll either insert tabs or spaces for you for indentation, but you still have to align manually. In this case, it would be the difference between 2 key presses and 5.
But .. I'd rather bitch about spaces vs tabs instead of building cool shit. I'm a serious developer.
Indenting is only about the white space from the start of the line to the first non-white character on the line. It should not make a difference what the spacing is - all lines indented by N positions will line up. Now, if you are trying to align stuff within code, on multiple lines that are indented to different levels, then something in there is going very wrong IMO; you have visual constructs that attempt to span multiple code blocks.
That looks uncomfortable to me, and is what leads to horrible indentation issues. The ? and : have no purpose being aligned with the = IMO. That makes indentation change according to how long a variable name is ($bar, $foobar). Indentation is about code structure, *not* about how long variable names are. if ($foo) { $bar = isset($baz) ? $baz : 'quux'; } Of course, in this case it could all go on one line, but this shows the principle nicely.
Haha :) That attitude in a non satirical sense is why I prefer to work as a remote contractor 99% of the time.
It has been an issue for as long as PHP has been around. Leaving the closing tag off is only a fairly recent idea that people follow, but has always been possible. Finding and correctly white-space accidentally put after closing tags was a big problem with some template-based projects in the past. In one framework I did work for ten years ago, a script was added to the change control *push* function that looked for white space (apart from a single "\n") between any ?&gt; and the end of the file, and rejected those pushes if it found any. That make the code a lot cleaner and the system a lot more reliable. Why we did not just leave off the ?&gt; is beyond me - looking through the PHP documentation it seems that ?&gt; has always been optional.