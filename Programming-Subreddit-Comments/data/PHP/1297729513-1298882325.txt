Talk to the original programmers at Twitter and see if they wished they had thought more about scale from the start :) I agree with your point but the OP did specifically ask for a more efficient way than querying the message table each time.
Yup, I do. Typically with a 60-second expiry on it just in case I miss a key delete on a data update.
Bit of both really
CSS not my primary skill but pretty sure that would be better done in js.
Imagine function liberal_guy() What would it do?
So a user script probably for greasemonkey
Yes, yes I did. =) Was just curious to know if people would pick it up. Granted, that's one of the things editors help you with.
Good point for Twitter, yet it's always a balancing act when and where to spend your limited time. I guess I ignored the OP question a bit as it's a little hard to offer a good suggestion without knowing the current setup and requirements. &gt; but they all seem to incur too much overhead server-side Cool, but what's "too much"? Do you know, or just think that it's too slow? How many queries/s? What part of the query is slow? What database system? What (if any) caching? What type of server? Are you disk or CPU bound? How will this change in the short term? Long term? Etc, etc. Guess I'm a bit critical because it's something I catch myself doing too often.
Traffic is kind of an unknown. I'm writing an application that allows freelance web developers/designer to manage their clients. It'll be free and self-hosted; I'm doing it mainly as a learning project. I can't imagine a freelancer having more than 20 clients at a time, but who knows? Honestly, I think I came off in my OP as worrying about overhead a lot more than I really am.
&gt;Just make sure to properly index the read_status column. What do you mean by that? This is one of my first major PHP projects and I'm unfamiliar with any use for index other than for searching/primary key. &gt; …is a 1-2 minute lag acceptable? Absolutely. As I said to strangeelement, I think I overstated the performance issue. This won't be for hundreds of users, just 50 at max.
I'd love to, but it's just too expensive, especially if you live so far you have to stay in a hotel. I think I priced it all out at around 3k, just too much.
I'm reading these posts and constantly being impressed by the vast breadth of knowledge on PHP and webdev, then I notice the usernames and it just gets so much more awesome. NotYourMothersDildo and Buzzard, explaining the fuck out of some PHP. But seriously, I don't think this will *ever* have to scale to more than 200 users. It's a small application meant to help out freelance designers/devs manage their clients/estimates/invoices. This messaging system will (hopefully) replace email in a way when managing clients and all messaging will be back and forth on the application, all in one spot.
I think he's just hit upon a common point of denormalization. You have a user object that is loaded with each page load. That user object has related objects like messages or ratings; and those related tables have multiple entries per user (sometimes many thousands of entries per user). So a common denormalization point is to include counts of those other tables inside the user table. I'm sure you know this, but to point out for the OP, this is a typical spot where denormalization is worth it for the reduction in queries that have to happen with each page load.
Part 1: Aside from a primary key, you can add more indexes to your tables including non-unique indexes. This helps speed things up by narrowing down rows that the db engine needs to check during queries. Let's keep it real simple and assume your message table looks like this (pseudo-sql since I don't know your db engine): CREATE TABLE Message ( MessageID INT PRIMARY_KEY, UserID INT, ReadStatus BIT, MsgText TEXT ) Now let's assume your select query for new messages looks like so: SELECT COUNT(*) FROM Messages WHERE UserID = ? AND ReadStatus = 0 By adding an index (note, you'd do this once after table creation, not after every query): CREATE INDEX IX_MsgCount ON Messages (UserID, ReadStatus) you're helping the db engine to quickly look up all messages with a specific UserID and a specific ReadStatus. Without that index, the db engine would have to go through all of the messages in your table to do the count.
Part 2: If 1-2 minute lag is acceptable then your caching solution is going to be easy. The first time a user logs in, your app will run the query and save the results in &lt;insert your caching engine here&gt; for 1-2 minutes. Subsequent page loads from the client will generate a cache hit until the cache expires, at which point you run the query again and cache it again. This way you only ever query the server for this particular information, at worst, every 1-2 minutes (per user). (But now that I know you'll only have 50 users I think you should not worry so much about caching until the day comes when the app starts to bog down and you run a profiler to figure out why. Good table design goes a long way to stave this off.)
db.messages.find({user_id:USERID,read:false}).count();
Cause a lineup at Starbucks to form while annunciating his precision beverage formula? 
delete the cookie? If there is one.
[Go here](http://php.net/my), and deselect the php.net alpha at the bottom of the page. If pain persists, delete cookies, as suggested by notenoughcharacters9. Incidentally, the search issue is a good point, and the fact it's happening probably shows you how often some of us actually search (or don't, more to the point).
This is the solution you should be looking at. Caching is great and all, but you can build caching on top of this solution right here if you ever need it, but no matter what, you'll still need this basic setup.
Oh thank God. That seems to have done it. I didn't realize I had the option to personalize anything. I use the search mostly via a Firefox shortcut (type php and the name of a function). With the old site, it brings up that function page. With the new site, it brings up a list of vaguely relevant matches scattered across the Tower of Babel.
I have a similar quick search in Firefox and Chrome. The trick is to bypass the search altogether: setting the search URL to http://php.net/%s generally works well if you're only interested in functions and classes and not searching in general.
I shall be attending
I have *never* seen any native support from Microsoft towards PHP.
documentation -&gt; chm with comments. works perfect. offline, fast, fulltext search, etc. (there are chm readers for every OS)
I've only been to the Barcelona and London conferences. Are you in Europe?
The Steam Passage is my usual haunt, and it's pretty close to the Business Design Centre, but there are loads of bars and restaurants in Angel. It's a pretty trendy part of London. "La Forchetta" is the best pizzeria I have been to outside of Italy (mind you, that's not saying much).
Not sure of another site to use that has a similar function. This was listed in the wordpress forums to use when pasting large section of code. I wasn't able to see a lot of other peoples code, so I am assuming this is a piece of shit site. Regardless of the site, I have decided against the theme. I was able to find the creator's website and in response to others inquiries about the obfuscated file, he mentioned it would allow him to change some links in the theme. While the theme looked nice, in no way do I want someone to be able to change my site without my knowledge.
How do I make stop trying to deliver everything to me in French?
No.
try codepad.org
What the hell kind of redesign is that PHP? &amp;#3232;\_&amp;#3232;
Thank you never thought about making a custom search for chrome. Great idea!
Based on this post, I'm hoping they leave the site the way it is. 
If you refactor the vars, more stuff is revealed. Apparently the function is used to create some kind of hash, but there are two more unknown functions in there: function someFunction($key1, $key2) { echo ""; $var0 = ""; $var1 = (v_RQj8gkbaR2A($key2) / 2); for ($i = 0; $i &lt; $var1; ++$i) { $var0.=chr(hexdec(substr($key2, $i * 2, 2))); } $retString = ""; $var1 = v_RQj8gkbaR2A($var0); // Unknown Func 1 $var3 = v_RQj8gkbaR2A($key1); // Unknown FUnc 2 for ($i = 0; $i &lt; $var1; ++$i) { $var0_letter = substr($var0, $i, 1); $keyLetter = substr($key1, $i % $var3, 1); $var0_keycode = ord($var0_letter); $keyLetter_keycode = ord($keyLetter); $keycode_diff = $var0_keycode - $keyLetter_keycode; $var0_letter = chr($keycode_diff); $retString .= $var0_letter; } return $retString; }
I guess his example string is valid JSON just by chance.
&gt; Here, just use this. What, wrong language? No problem, just re-write my entire fucking library. It's twelve lines of code, three of which are just adding one, three of which are just signatures, and two of which are "end." The library, of course, is slightly larger. Since you didn't know this, let me be clear: it's a simple, simple equation, and it's quite likely easier to convert those four lines of actual code than to locate and adapt an existing library which may or may not even be correct. But yeah, rage about stuff that didn't get said, instead, on a topic you don't really understand at all. Clearly saying "it's trivial, here's a correct one you can work from" means "rewrite my whole library." Don't be angry/lazy on the behalf of third parties. &gt; Oh, and it's MIT Licensed Awwwwwwwwww, you don't like my choice of license. How sad for you! Go release some code of your own, then. &gt; No, I can't justify that statement. I can, I just have more important things to do. I'd think you'd be perfectly familiar with that excuse. &gt; But I have a blog! I have a lot more than a blog. Where's your free code, pose-a-potamus? The less they contribute, the more they want to criticize how other people contribute.
I had noticed some wierdness, but I always search by 'http://php.net/&lt;search term&gt;' so I didn't really notice 
Stop being French. Do not try and claim you are not French - php.net knows better than you do.
That doesn't exist anymore
Ever heard of usenet()?
If languages were considered "awesome" by the number of times # Separate name/value pairs appears, I think Perl would win. 
COUNT(*) from messages where user_id ... too slow for real time.. often shows up in slow query log. I cron a script to update fields like this.
This is a slow query. 
You'd rather use brackets?
I would prefer any of the following: if($thing) { echo "&lt;p&gt;Thers is a thing&lt;/p&gt;"; } or: {block name="thing"} &lt;p&gt;Thers is a thing&lt;/p&gt; {/block} in a template file which PHP reads in, ideally via some standard templating system like smarty or Template Lite but homebrewed is OK or: if($thing) { ?&gt;&lt;p&gt;Thers is a thing&lt;/p&gt;&lt;?php }
Your template class seems fairly tightly tied to some files and features (calendar/photo etc). This could be a problem if you want to add more templates, as you may end up adding a method for each one. The template class I use comes from here: http://codeangel.org/articles/simple-php-template-engine.html It could hardly be any simpler, but it would still allow you to use sub-templates like you do in your class.
You should really look into PDO for database access. There's very little reason not to use PDO, and prepared statements can help you to avoid a lot of bugs and security issues that you might otherwise run into. But overall, you're re-inventing the wheel. AFAIK, all the major PHP frameworks out there have database adapters, and templating is also pretty standard in most frameworks. If your chosen framework doesn't have anything, there's always [Smarty](http://www.smarty.net/). You can save yourself a lot of time by looking into an existing open source framework. If it doesn't do what you need, most projects accept community contributions.
Even having your own private fork of an open source framework is better than starting from scratch. Smarty is pretty much the devil though.
I agree. I hate Smarty, but I know a lot of people who love it, and afaik it's one of the most visible templating engines.
I personally believe taking a crack at writing your own mini framework gives you much more of an appreciation for the work that went into building something like Zend and Cake. Just a few points I would like to make. With your database class... stop. There is almost no point in making one. Stick with PDO. Learn it, love it. Most of the other frameworks have their own adapters but all the ones I can think of are based on the functionality of PDO. You should be able to cover the largest chunk of your use cases just using PDO and it should be that difficult to extend it to cover the rest. With your Template class... I agree with dig412 on this one. Your class is going to quickly turn into a mess of code. Look into the view helper pattern that the Zend Framework uses. This should help you out a bit on how to subclass out the stuff.
&gt; It's twelve lines of code which relies on language-specific features. 1) There are no language specific features there. It's a recursive addition loop on two counters. Just how much of a novice are you? 2) It's four lines of code and eight lines of framing. You're an ass if you try to complain about lines that are just "end" or just signatures. Of those four lines of actual code, three of them are repetitions of one another. 3) "Rely." English just isn't this difficult. &gt; Likewise, I wrote a Radon transform in one line in Matlab, but when someone asked me to port it to C# it was rather more work. That's nice. Nobody asked you to port anything, or what your opinion was. It takes a Very Special Mind (tm) to compare a recursive counter in two imperative languages (here comes the standard "but erlang is functional" novice fapping) while claiming there are "language specific features" in play to a matlab implementation of feature extraction in calculus. To be clear, given that you think recursion, addition and case statements are "language specific features," I've just got to assume that you have no idea what you're talking about. &gt; I was making fun of the fact that you come across as completely crazy I don't really care what someone who thinks recursion or addition is a language specific feature thinks. You were making shit up ("No problem, just re-write my entire fucking library.") and now refuse to face that what you said is completely false and without merit. Someone - not you - asked for help. There are only four lines of real code there; this is something the average eighth grader could port. So I offered help. I really do not give one half of one fuck what you think of my attempt to help someone who is not you. &gt; by making bold statements and then completely forgoing any explanation. And here you fail to understand how this applies to you, I trust? Get lost, Chachi. Nobody asked you.
Its used to apply a function to each element of an array.
I use it pretty much whenever I am applying changes to all values in an array.
Have you used existing PHP frameworks before? I wouldn't go as far as to say that you should not have your own homegrown solutions for certain things, but becoming very familiar with existing solutions could help you better refine your own work.
An example case would be for the validation of input values in unit testing. I expect an array of ints, I walk to make sure they are all ints.
Not very useful answer: when I want to do a "map" operation, but want to affect the original array rather than return a new one. If I wanted to return a new array instead I would use array_map. More useful answer: if I had an arbitrary number of strings in an array - let's say 200 strings - and I wanted to call trim on each one to make sure none of them had any whitespace on either side, I could call: array_walk($array_of_strings, 'trim'); Which is much less verbose than the alternative: foreach ($array_of_strings as $key =&gt; $string){ $array_of_strings[$key] = trim($string); } I realise that example is a little contrived, but it's the best I could come up with without thinking *too* hard... I've been at work all day, you know... Stop shouting! Leave me alone!
One clearly made by a programmer.
FYI, these days I think you can also use: foreach ($array_of_strings as &amp;$string) { $string = trim($string); }
Indeed. There's a bunch of different ways to do it. I tend to avoid using the "value-as-reference" method; if only because I think it's more obvious what's going on when you read the code... It's easy to miss that little ampersand and get really rather confused.
Why is smarty the devil? Serious question, I'm not defending it, I'm just curious. It seems like a pretty basic template engine to me.
Thanks! No wonder the error.log was growing so huge for this comments page.
Smarty tries to reinvent a lot of what PHP can do itself. It's just another layer of stuff going on that I'd rather skip. In my opinion this: {if $name eq 'Dan'} Hey Dan {/if} is not better than: if($name == 'Dan') { echo 'Hey Dan'; }
But isn't the whole point of Smarty to separate programming logic from display logic AND to make the "template code" easy to understand for non-programmers? If I have a graphic designer working for me designing templates who doesn't know a single bit of PHP code I think it would be way easier for him to use something like {$name} than &lt;?php echo $name; ?&gt; Then again, maybe the programmer should just go in and insert the small amount of template php code himself. I guess it just depends on what your businesses approach is in regards to who does that kind of coding. I certainly wouldn't call smarty evil just because it's a bit redundant, because it's only redundant if you're a php programmer, and the whole idea behind the template code is that the php programmers don't have to write any of it.
I too am a fan of the alternative syntax. If it's not an open project it's all alternative syntax. Personally find it more elegant, however for single line if\else\foreach\etc then it's not brackets and it's on the same line. /* ... */ if(isset($something)&amp;&amp;is_array($something)): echo 'Key Count: ',count($something),PHP_EOL; foreach($something as $key =&gt; $value) echo $key,' =&gt; ',$value,PHP_EOL; else: echo '$something is either undefined or not an array'; endif; *Edit:* Which I find helpful for scanning through blocks and see where they start\end without having to match brackets (although most editors make that quite easy anyways). 
I agree that PDO does everything you could ever want in a DB access layer, but it seems whenever anyone brings up making their own they get hassled for it. I dont deny that its full featured and takes care of everything for you, but i have rolled my own many times if anything just for the learning experience and never had any problems. The same argument could be used against creating a framework of any kind. Why re-invent the wheel when Zend and 50 other projects have done the same. I say good on the OP for making a go of it (even if he is just wrapping the existing functions in class)
Yeah that's true, just pointing it out since some people aren't aware that it exists :)
My intention was never to give any flak for "recreating the wheel." As I said in the beginning I think it is good to try some of that stuff out to see how much work goes into it. My point was that part in particular is the one that should really just be left alone until need be. Mostly because it is possibly the most complicated part of a framework. With all that said if you want to roll your own by all means have fun. Personally I don't think it needs to be done.
i apologize, hassle wasn't the best word to use, as i didn't mean intend to imply you were a 'hasslin
I personally prefer (in the context of a template (and i know many people may want to slap me for this)): &lt;? if ($name == 'Dan'): ?&gt; Hey &lt;?= $name ?&gt; &lt;? endif; ?&gt;
thanks for the replies guys. i actually know what it does but i don't know when best to use it. the array_walk with the trim function as an alternative for a foreach blew my mind. I always do foreach on things like that. anymore applications you can think of ?
Right. I'm insane because you think two counters in a recursive loop are "language specific features," and because I don't capitulate to criticisms you made of things I never actually said. Get lost, Chachi. Nobody asked you. I get it: you're unable to admit fault or apologize. You still haven't made any attempt to be helpful, huge surprise. Wonder if and when you'll man up and admit that the claims you made *just* *aren't* *true*.
CakePHP 1.X doesn't support PDO, which is an automatic disqualification for me. CakePHP 2.X didn't quite work "out of the box". I'll revisit the bakery when their cake tastes better.
Here, made a subreddit for this kinda stuff that keeps popping up around here: http://www.reddit.com/r/phpjobs/
You're hiding the error messages with @ instead of logging. This is bad, really bad. If I were I'd develop my programming skills rather than writing my own framework.
This one also has the often forgotten and nasty side effect that after the foreach is over, the very last element of the array is now actually a reference to the $string variable. $strs = array('one', 'two', 'three'); foreach ($strs as &amp;$s) { // … } var_dump($strs); // array(0 =&gt; string 'one', 1=&gt; string 'two', 2=&gt; &amp;string 'three'); So whenever you assign anything to `$s` somewhere in the same scope again, it will change your last item of the `$strs` array. Most prominently this happens if you decide to reuse it as iterator variable, for example in `foreach (array(1,2,3) as $s) {}`. `$strs[2]` equals now `&amp;int 3`.
I did a mysql class last year, then I started to learn PDO. The class made it easier to add/edit/remove from a database basically.
Thank you! I used to be deep into Smarty/Dwoo/Twig, but I eventually found it didn't do anything to help me and just made everything more complex. Having to write my code around the template engine was a pain in the ass.
ATTENTION PEOPLE: Pay attention to this man - he knows what he's talking about (I apologise if you are, in fact, a woman).
[Anonymous functions](http://php.net/manual/en/functions.anonymous.php) come to mind.
PHP short tags aren't always enabled on production servers, which is a shame because they look so much cleaner.
Yes, thank you, I wasn't aware of it. I think it's a lot more readable than "the old way", especially if I don't need $key anywhere else in the loop. But the side effect mentioned by vihil makes it a bit nasty. The [manual page](http://de.php.net/manual/en/control-structures.foreach.php) recommends to unset the reference after the loop.
Maybe i should just go look into this myself but has this changed in later versions of PHP? Im often the one setting up production servers and its never something i have ever even had to think about and it always seems to be enabled to me. Looks to be enabled by default as of [5.3.0](http://php.net/manual/en/ini.core.php)
This one bit me badly! I think I fixed it by unset()ing it when done.
slim framework, fatfree, lithium take a look. esp the first two.
And I think they're going to be depreciated as of PHP 6.
No idea why you're being downvoted. Hidding errors is very bad practice. Write the code in a manner than the error need not be shown.
&gt; I'm not a fan of output buffering, since I've had inconsistent results in the past. There's no particular reason why it shouldn't work. One company I consult for develops and hosts sites for a number of big-name companies (any number of which will be mentioned in the news each day, drawing major traffic). Their templating system is entirely based on output buffering. Pages are built with one layer of output buffering, captured with another layer, cached, and served from there. It all goes like clockwork and makes many things much easier to manage and abstract.
The errors should be logged, not displayed. But never just tossed in the bitbucket. @ is almost always a sign of failure to plan robustly.
This subreddit is known for just bitching and complaining when people post legitimate job offerings. I suggest you post to /r/jobs so you don't get flamed here.
Thanks for pointing this out, I think I had heard about something like this happening but never had it explained so well.
Hello, I enjoy the taste of toasted raisin bagels with cream cheese. Especially if you put the cream cheese on while it is still hot so that it melts into the bagel a lot. A lot of places that sell bagels don't actually sell bagels, they sell circles of bread that have as much in common with an actual bagel as baloney does with corned beef. These places should be forced to label their products "circular dough", like how imitation chicken is "Chik'n". At this point you are probably wondering what my comment has to do with your post. The answer is nothing at all. Just like your post has to do with discussion about PHP. See you wasted my time with your spam, and now I've wasted some of yours. Please learn how to use the internet as it will make you a better person.
I usually avoid it just because it is weird. I like code that is obvious rather than code that is clever.
I'm currently trying to tackle a templating engine in a framework that I'm building. Currently, all the output is wrapped buffered using ob_start("ob_gzhandler");. I'm thinking this would make the engine you use fail? Or is it possible to do nested output buffering? What would you suggest as a solution for gziping all the output, but still using a basic templating engine that uses output buffering?
I just checked this out on php.net. A lot of the example have the ampersand in front of a value - what does that indicate? example: function test_alter(**&amp;**$item1, $key, $prefix)
Php is already a great templating language I would recommend passing variables right into your template class and exposing those vars and require the template file inside a function. You also have access to all php logic for iteration and if statements. Shorthand syntax would help here too, like &lt;?=$var?&gt; 
array_walk($_POST, 'trim') is usually one I'd have tucked away in a form handler.
You're spot on. Looking at the posting history (how I found your comment), it appears that he starts an argument every time he visits Reddit, and will continually reply to someone until someone makes an off the cuff mistake he can harp on. Essentially, he's a troll by any definition, even if he's right a lot.
I sense that you're getting defensive- but they have a point. Your original post says you're using this solution on your smaller sites and are thinking about using it for a larger one- and it handles errors with suppression and *or die()*. I may be off the mark on this, but it seems like a sql error will just kill the page and give no explanation for the user. Something can be said for graceful error handling and letting the user know that *something* went wrong, even if you're not really going to explain what.
You may also want to `unset($string);` at the end or else PHP will keep the reference to the last element there.
For a basic template engine, it's also *huge*. I've made a few template engines myself, with similar functionality, at a fraction of the size.
Wouldn't it be easier to just use (english) $me?
I think it's often beneficial to go the opposite route. Learn how major frameworks structure things, and their usage patterns. With that knowledge gained from a few different frameworks, go ahead and create the correct mesh of PHP libraries to give yourself the perfect framework for you. Not that it's necessary, but if you're the only one writing a project, it might feel better to have each library (isn't every framework really just a specific group of libraries?) customized the way you like it. A counterpoint is that using a specific framework can be a great time-saver if that framework has great integration support with specific modules/functionality your site requires.
Fair enough, I was just curious why people hated it so much.
Pdo is excellent...unless you need oracle support...learned that one the hard way.
Normally when you modify a value provided to a function as a parameter your modifications do not affect the variable provided, as such: $x = array(); function f($input) { $input[] = "Hello, world"; } f($x); count($x); // 0 When the ampersand is used the variable becomes a 'value-as-reference' (or simply `reference variable`) which leads to the original variable. This can be shown in the following example: $x = array(); function f(&amp;$input) { $input[] = "Hello, world"; } f($x); count($x); // 1
I shall try that if I have any more coding issues. Thank you.
Yep, you can nest output buffers: &gt;Output buffers are stackable, that is, you may call ob_start() while another ob_start() is active. The template engine just uses buffering so that you can store the results of one template in a variable, and pass it to another template. As each buffer is closed once the content has been rendered, eventually you'll just have one variable with all your html, which you can echo into your ob_gzhandler.
Nobody gave you the simple answer: in documentation, you can usually think of it as indicating that the value of the variable in the marked parameter will be modified by the function.
I've always found google search superior to the php site. Just type 'php &lt;search phrase&gt;'. Whatever I am looking for is usually the top result.
It's my opinion that unless you are intimately familiar with all the security concerns with Tomcat, you should never use Tomcat for a web-facing application.
I'd run screaming.
Year 3: jesus fuck, how could I write this piece of crap.
I'm using PDO for oracle right this second. I've yet to run into any problems that couldn't be worked around.
What would you use, Jetty?
The same could be said for any language. The OP says that the project has already been implemented so I would suspect that this is a good opportunity to learn from what is there to begin with.
I'm not quite sure what sort of answer you're looking for, but personally I find that in the move to MVC (using Zend) I write a lot more code (models &amp; controllers) before I worry about views (html).
I feel, from a security point of view, that Tomcat requires a lot more knowledge to secure it than other platforms. Sure, any platform can be insecure, but from my experience Tomcat takes the cake.
I've never used Jetty. I've used Tomcat and Glassfish. I liked Glassfish more than Tomcat, but I didn't get a chance to know it as well as I would have liked.
There's certainly approaches that are more industry preferable to working with Object Oriented PHP and MVC. It sounds like you are coding directly on a production project if you need to access your development environment using WinSCP. I suggest getting to know web servers and how to set up a development environment. Explore the world of source code control like Git and Subversion. Start learning a popular framework (Symfony2 or Zend Framework).
fair enough
If you're not writing object oriented code, then yeah definitely get into that. There's no way I'd go back to writing database stuff without objects/classes. Regarding using WinSCP to edit code, sounds a bit painful. Set up a local dev environment, the way I do it is by running a Debian virtual machine on my Windows PC. That way I can use the exact same version of apache etc as the live server. And yeah as blikskottel mentioned, get into using version control, I use subversion with the TortiseSVN GUI. It comes with lots of handy tools to compare code changes etc visually. Also for an editor I use Netbeans. Makes it much easier as you can just click through on function names to get to their definitions etc, rather than having to manually open files all the time. Also will autocomplete function &amp; variable names etc for you, saves lots of time and unnecessary thought when you're trying to focus on what's important.
MVC FTW (I like symphony, but the learning curve is *steep*) I use tramp (emacs) and ssh into a remote server (I could not recommend slicehost more, but it is like $20 a month). Server is ubuntu apache and i have svn on there which has saved my ass countless times. I always start with the controllers, and get around to the views at the end, except for the layout, I usually have something up so that if I am showing it to a client, it at least looks decent.
&gt; There's certainly approaches that are more industry preferable to working with Object Oriented PHP and MVC Such as?
Some people will not use a script they don't host on their own server - if your service goes away, their contact form breaks. Of course, most of the people with those kinds of concerns will just write their own anyway. And a suggestion: Do a double opt-in for the receiving addresses. Make them enter the address, send an e-mail with a validation link letting them know what they're getting in to, and require them to click it before you send them any e-mail - otherwise someone **will** use your service to send spam, and you'll get added to a dozen blacklists. Then your service won't be terribly useful anymore! :)
You're asking the wrong end. Ask a JSP community about moving from PHP to JSP.
After configuration and setting up a bootstrap I get the controllers and models working first, wire up a basic view, refine the controllers (breaking things out into plugins as/if needed like for authentication or some cross controller common functionality), tweak the models and when I'm getting all of the data I need for the frontend I finish up the views.
I'm guessing he meant "when" instead of "to".
You should know *exactly* what your site does before you start coding— I can't tell you how many times I started writing an app and a month later, it's completely different than what I intended and, as a result, there's spaghetti code all over the place. Cue rewrite. That being said, my development mostly works like this: 1. Create basic controller structure. 2. Create basic model structure. 3. Expand/alter controllers. 4. Expand/alter models. 5. Create views. I save the views for last because I find that even with planning, what I need my views to do changes a lot, and I'd rather leave that until the end. Plus I'm not much of a designer. I spend most of my time fiddling with my models, though; probably the same amount of time I spend pondering my database structure. I'm never happy with it so I'm always looking at how to make it better.
Coding remotely instead of on your own server makes sense, especially if you're coding for a particular site and not a big project you're going to distribute. However, you shouldn't be editing the live code directly. You should at least have a test version to edit first. GIT works just fine with remote working copies as well.
When I need to parse an array into XML in a semi-retarded fashion.
"... We have noone that has that has the know-how and time to implement this CHM stuff. The references to this package have been removed, it is highly unlikely that it will ever exist again." http://bugs.php.net/bug.php?id=48707
Generally speaking someone else writes the HTML/CSS for me.
The biggest step a lot of people miss is clearly defining a project scope. Everyone wants to dive right into coding with a broad understanding of what you hope to accomplish. Never leave anything to interpretation. Imagine telling a contractor to build you a home, and then walk away. It will never be what you wanted, take longer than expected, and most likely never habitable. Focus on small goals. Do not corner yourself into a single long-term goal. Instead do a lot of short term goals that lead up to the long term result. In our house example, don't think I want to build a house, instead think I want to make a front door, Tomorrow I can do that window. Most people who have not been indoctrinated by blood (new programmers, users, and especially clients) are to caught up in how something looks. They want you to build the interface and then "just make it work". This may of been the case 10 years ago when the web was mostly static pages but it isn't the case today. Do not start with your View, or you will find yourself mashing square pegs into round holes. Based on the information from your project scope (that you should have written down by now) build your data layer (Database structure &amp; Models). The closer you can mirror the design the happier you will be. OOP changes the game a bit in the fact that it keeps things organized. Nothing worse than a Psychotic Model on Acid. "Model, show me your nodes!" "Turkey Muffin!" "Ok User Model, getUserWithName("ofSteve")?" "Steve; born August 14th, 1976 ...." Now its Interface (view) time. Take your requirements and go all gui with your bad self. So you got a Data Layer ready to go and an interface layer ready to go; it's time for them to get a bit freaky in the dark. The great thing about MVC is Models don't care who touches them, so long as they follow the rules (no kissing on the mouth). And Views are like the douche bag from high school who is as dumb as a rock and only cares about how he looks. So your job is to get these lovely specimens to hook up, with Controllers. Controllers are not so much a person as they are a spotter during sex. "This doesn't go there, get your foot off her face, YOUR DOING IT WRONG!" Your controller is going to make sure that everything goes where it should and everyone ends up satisfied. Write your controllers to send the requests from your views to models and back. Good luck and welcome to the dark side of the moon.
I find I do most of the logic before I get to the presentation stuff. I find I don't hack crap into my views nearly as much this way since it's not like "oh, everything is looking good except I need to just grab the user's first name. Let me just reach into the session here and grab it...*slap* C'MON man, pass it in from the controller, don't be weak sauce!" This drives my PM crazy from time to time because it will look like nothing is done and then BAM! project completed once the views are connected.
Without contradicting n1c, you could also start with the views--often clients don't REALLY know what they want until they see the final product. Instead of coding your views in HTML, build them using Wireframe software, which can be extremely quick and with a little practice can be done right in front of the clients during a meeting. I tend to start with the model (domain logic + db) layer first and code the views/controllers afterwards. 
So is it like declaring a static variable? For example, would: function test( ) { static $num = 0; $nums++; } echo $num; //1 Be the same as this: $num = 0; function test(&amp;$num) { $num++; } echo $num; //1 Or is there a rule or other stipulation I'm not accounting for?
That doesn't make a lot of sense to me. If you recommend a test version, then you should have a local test version. Why bother having a remote local (as in yours and yours alone) test version?
They must have put the CHM files back in after you posted this because I see them listed now. [Here's a download link to it](http://us.php.net/get/php_manual_en.chm/from/www.php.net/mirror)
There was a normal CHM file and an "Extended" CHM file that contained all of the community contents, AFAIK the latter is unavailable... [archive.org](http://web.archive.org/web/20080621101026/http://www.php.net/download-docs.php)
while that is a very simple example, and *will* work, i would recommend at least using captcha ([recaptcha](http://www.google.com/recaptcha) is a good one), and probably a honeypot too, to avoid getting the ** spammed out of it.
Off topic a bit, but why? What does that file provide that you can't get from php.net?
I'm speaking from the prospective of a student who runs a dynamic website for a university club, along with some other volunteers. So I'm sure the situation would be different in a professional situation. First of all, I want it to be as easy as possible for new people to work on the site. Many of them are mostly helping out as a way to start learning PHP, and I don't want them all to have to install a local copy of PHP and everything to work on the site. Second, it only really matters if our site is compatible with our web server. It would be a pain if someone's relying on a feature that only works on Windows for some reason (probably not too many examples of that), or they have an older/newer version of PHP and use a feature that has since been deprecated and throws notices/doesn't exist yet on the server. Since everything will have to be tested on the server anyways, it makes more sense to develop there. Finally, and I'm sure this doesn't apply for many situations, but I will often times want to do some work on the school computer labs. I don't want to have to carry around a portable version of a WAMP stack (and hope I can get it working without admin). I want to fire up WinSCP and start coding. In addition to the club website, I also do an internship for a university department's internal PHP site, and they also use the remote working copy paradigm.
Offline access
You're fucking insane because you come back to this subreddit time and time again trying to help and get nothing but shit on - even though I've yet to run across any really significant case of you being wrong or incorrect at all. Which, to be honest, I completely don't understand - everywhere I see you you're downvoted into oblivion. All the way through an entire thread. (I have to assume you pissed someone off enough one day they now have dedicated their life to following you around and downvoted you - that'll show you!) Have an upvote or... According to RES, 24 total now. You're vulgar and abrasive but you're technically correct. And that's the best kind of correct.
sending mail is easy with mail() (see the php docs) 
thanks i'll look into this
OH, gotcha. It seems strange then that they can publish regular CHMs but not the extended.
I'm a PHP developer who has recently been involved in a large Java EE project. JSP is one small part of Java EE, and it's easy to get lost in the different JEE technologies. You can probably just use JSPs, but in my experience (limited as it may be) that's rare. JSPs themselves get compiled into servlets, and if your project uses one of the MVC frameworks (e.g. struts or spring), servlets will play a larger part (controllers are normally implemented as servlets). JSPs can connect to your backend database in several ways. Commonly there will be EJBs (MVC models) used by your JSPs, but you can also interface with SQL directly through JSTL tags (or through custom tags they've written). One big thing that takes some getting used to is the XML configuration files. Just about everything is configured through XML in the JEE world, and each part will use a different config file. When I got started I used the Apress book [Beginning Java EE 5 From Novice to Professional](http://www.amazon.com/Beginning-Java-EE-Novice-Professional/dp/1590594703)[.](http://thepiratebay.org/torrent/3666726/Apress_Beginning_Java_EE_5_From_Novice_to_Professional_Oct_2005) It steps through each technology bit by bit and was really helpful. It even helps you get set up on tomcat, which is really helpful if you're going to be deploying your code yourself.
I like editing directly w/ FTP as well when possible. From scratch, MVC is basically like: I will need a /users segment of the site.. so you create a UsersController. Get some required data if necessary, then make the views. Starting with your global header, footer, content wrapper HTML isn't a bad way to get setup either. If you are a noob, then I'd suggest CodeIgnitor. It's pretty easy to work with and has some of the best documentation.
Well, that's a rather unique situation. I'd suggest that having people who want to learn install WAMP/XAMPP is not such a big deal, and unless your server is set up in a rather bizarre way you shouldn't have any issues. While it may work for you currently, I'm sure you'd agree that this is not exactly a good setup to recommend.
That's the only thing that comes to mind, but dosen't seem particularly helpful, especially when the difference, as fas as I can tell, is just the comments. Not that the comments aren't helpful, but...
If you look at the link, that's exactly what it's using. It just does some extra stuff for you like extract all the form fields and populate the email for you. It's designed for someone who knows zilch about PHP.
&gt; You're fucking insane because you come back to this subreddit time and time again trying to help and get nothing but shit on That isn't actually correct. I get thanked a whole lot more often than I get nagging nobodies telling lies and screeching. Sometimes whole posts (that is, not comments). In the last 31 days, I've had more than a dozen comments cross the 500 point threshhold due to thank yous. I also get about six of them a week in private message. But you're right, there are a lot of punishment-fetishizing douchebags in proggit (some editorializing does apply.) &gt; even though I've yet to run across any really significant case of you being wrong or incorrect at all. This seems to me more like a criticism of other people as a result of this observation. Perhaps that's intentional. &gt; everywhere I see you you're downvoted into oblivion. I'm actually vastly positive. I also don't care about reddit karma scores. I'm from IRC. I'm used to whiny people who don't know what they're talking about. &gt; I have to assume you pissed someone off enough one day they now have dedicated their life to following you around and downvoted you Quite a few of them. There're also two dudes from IRC who do it. One's been doing it for seven years, and followed me here with throwaway accounts. I actually kind of enjoy it, in a schadenfreude sort of way. What better could be done than to waste the time of dunning kruegers with rage problems? Let them take it out on me; my ego can bear the weight. &gt; You're vulgar and abrasive but you're technically correct. And that's the best kind of correct. Upvoted for a Hermes reference.
I often find the comments more helpful than the official manual articles.
Right, I'm not saying that they aren't helpful, but It doesn't seem like they are so world shaking that they can't wait until I have internet again.
Worst. Advice. Ever. You need a wrapper because of header injection and all sorts of handling.
Use [PEAR Mail](http://pear.php.net/package/Mail/).
Many MVC frameworks get pretty unhappy if you don't have an associated view so you usually create stubs (empty files named correctly and in the correct place). While I create a basic controller structure in my mind/bootstrap router/whatever, I implement in spurts. Creating a CRUD interface, you end up making paired pages rapidly. The view all "Whatevers", view individual "Whatever" pages are both very similar. The create/edit "Whatever" pages are also very similar. Javascript validation is last. I bring in a designer after all my logic and data is being presented in a plain-ugly format. This prevents a constant flow of "I did the logic differently so now tweak/reslice the creatives for this case", rinse repeat cycle.
I do confirm that there are no plans for this, so until someone says "I want to work on this" and does so, then it won't exist.
You can also put a hidden field at the bottom of the form with a hidden element with the value of time(). Then in the script that sends it, have an if statement at the top that's simply if((time() - $_POST['time']) &gt; 5) { Basically it says if the form was submitted in less than 5 seconds (or any other reasonable amount of time it would take to fill out the form) then it wouldn't send. This won't completely eliminate spammers, but it will slow them down. And it's less annoying than a captcha. Another similar way is to just have a field that is hidden via CSS. Then once the form is submitted check to make sure that field is blank (since real people wouldn't be able to see it to fill it out). If it's not, then you know to not send the mail. You should also look into validation.
You'll usually want to follow the coding style of a particular framework or community. What language are you using? I'd start with RoR, Django, or Kohana PHP for example. Creating your own MVC is probably yack shaving. You'll get good OOP practices by emulating an existing project.
&gt; That isn't actually correct. I get thanked a whole lot more often than I get nagging nobodies telling lies and screeching. Sometimes whole posts (that is, not comments). In the last 31 days, I've had more than a dozen comments cross the 500 point threshhold due to thank yous. Fair enough - I'm just going based on what I see the odd time I spot you around r/php. &gt; This seems to me more like a criticism of other people as a result of this observation. Perhaps that's intentional. A criticism of other people and the system - you come in and post correct answers, but all the 'experts' around that wouldn't know a Dictionary from an Array from a Linked List from a Singleton Pattern if they all showed up in their coffee one morning downvote you. As this happens, the correct answers are buried and this makes the 'popular' (but wrong) ones appear more correct. Thus the reputation of the PHP programmer as an idiot is continued. &gt; I'm actually vastly positive. I also don't care about reddit karma scores. I'm from IRC. I'm used to whiny people who don't know what they're talking about. *"Stand back, ma'am! I'm from IRC!"* I spend most of my time in a modified version of the old unix talk client. It's pretty much non-stop abuse. Reddit is very tame, slow, and structured in comparison to five people all typing at once in realtime about different things. &gt; I actually kind of enjoy it, in a schadenfreude sort of way. What better could be done than to waste the time of dunning kruegers with rage problems? Let them take it out on me; my ego can bear the weight. Anything that keeps 'em away from a compiler! If their life is so sad that they're willing to dedicate more than a mere moment to making some imaginary number on a website go down, perhaps they could really use the sense of purpose. As an aside, for a man who claims to not care about his karma, you certainly know a lot about it. ;)
Most of your projects even though working with/around/inside OOP ideas/classes will still boil down to standard procedural code. The OOP only really comes into play when writting helper classes, generic reusable parts (base controller, base model, etc.) and from there you jump into procedural mode using your existing classes. When I first moved to OOPHP I tried to overuse it. I created more classes than I actually needed to do small things I needed to get done, usually it was just bloat. Now I only really try to force functionality into a class if it really warrants it. An example being an Authentication/Session class, since authentication and verification will be used pretty widely it def. should be moved into a class as to be easily reusable. At the other end of the spectrum a user might need to view a list of their previous logins and IP addresses (If you store that kind of thing) and it would rarely be used, and is very very very unlikely to be reused. It would be bloat to throw something like that into it's own look up class. considering the likely hood of needing to reuse it elsewhere. Sorry that's kind of a shitty example but... yea. As far as the order of MVC goes I usually build the Controller first, then the Models and Views together. Once you've nailed down your base classes (Controller, View, Model) you'll just extend those, since nothing works without Controllers those usually come first, from there you can jump to either View or Model depending on which you like doing more. As said I'll mix it up, I'll get the generic template in place, then I'll put the model in place to get what I need, then back to the template to tweak the data output, so on and so forth.
&gt; Fair enough - I'm just going based on what I see the odd time I spot you around r/php. PHP has the navel gazing fake experts worse than most of the other proggit and proggit-related reddits I'm in, admittedly. &gt; Thus the reputation of the PHP programmer as an idiot is continued. All blub programmers are idiots, IMO. Indeed most multi-language programmers are too, but I've never met a blub programmer who spoke in terms I found to be intelligent. Admittedly, because of PHP's ease of use and pervasiveness, in combination with the bulk of bad tutorials out there for it, the bottom of PHP's barrel tends to be fairly low. &gt; I spend most of my time in a modified version of the old unix talk client. It's pretty much non-stop abuse. But the fun kind, from people who aren't completely idiotic, I hope. &gt; As an aside, for a man who claims to not care about his karma, you certainly know a lot about it. ;) The morons try to rub it in my face a lot. It's sort of ... forced learning. I like you.
Functionally both are equal. The `global` keyword works the same. Usually where the global keyword is used such functionality should be encapsulated together in the form of a class.
K, I guess I'll port it. Threw it in my utility library while I was at it. (Did this last night, but reddit downtime.) Remember, kids: good code does three things. It gets rid of every piece of decision making and sourcing it can; it writes enough documentation that it can make significant assumptions about how the data is presented; it is ridiculously unambiguous, down to taking the data in ways that cannot be wrong. For example, my first stab at this, I was taking the total set count, the count of each [flag/no flag][show / no show] then comparing their counts, and erroring if they didn't match, to show that the data was valid. Later, I changed it to assume that the data was already juggled, and could not be presented incorrectly. No need for error handling, much safer, etc etc. &lt;?php /********* * * Naive bayes likelihood classifier * * This function performs a naive bayes classification. Given four tabulated priors (explained below,) * return the likelihoods that on and off will show. * * In Naive Bayes classification, probabilities are sums of interpretations of characteristics. They're * explicitly not correlated - that means a bayes system which thinks an apple is a red, round 4" object * that weighs 1 ounce, and receives a green round 4" 1oz object, will say "this is 75% likely to be an * apple." Those factors do not affect one another. * * The likelihood of one characteristic is simply the count of flag cases showing the feature divided by * the count of flag cases, both first scaled to the number of cases. * * A different way to phrase the same thing is "target triggers in set, over all targets in set". * * For example, say a study of 60 people is done to find out the cancer effect of smoking in a ten year * frame. No person entering the study has cancer initially. Please note that these numbers are made * up, and have no bearing on real medical data; it's just an easy to understand example. For the 60 * people, we have 47 non-smokers and 13 smokers. At the end of the ten year study, seven from among * the larger non-smoking trial people have developed cancer and 40 have not, whereas in the smaller * smoking set, three have and ten have not. Naive Bayes classification gives us a way to interpret * these results. * * The probability that a smoker will develop cancer is three in thirteen, or ~0.23 . * * The probability that a non-smoker will develop cancer is seven in fourty seven, or ~0.15 . * * Therefore, the probability by which smoking will increase cancer is (0.23-0.15) = 0.08, or eight percent. * * More clearly, 15% of people will get cancer; 23% of smokers will, meaning smoking increases your chances * of getting cancer by 8%, or about one in twelve. Get 36 smokers who have cancer in a room. Three of * them got it from their cigarettes. * * In that case, this function will return an array of two items: the chance that a feature will exhibit, * then the baseline chance that a non-feature will exhibit. * * &lt;code&gt; * &lt;?php * * print_r( naive_bayes_likelihood(3,13, 7,47) ); * // shows array( 0.23, 0.15 ) * * ?&gt; * &lt;/code&gt; * * Note for code purposes that we don't divide the numerator and denominator by set size - it's appropriate * in understanding the math, but it's tautological, so we skip the computation step, because at best it's * wasted work and at worst it causes IEEE float erosion. * * @author John Haugeland * @copyright 2007 - current John Haugeland * @license MIT License http://scutil.com/license/ * @see Derived partially from tutorial at http://www.ibm.com/developerworks/web/library/wa-bayes1/ */ function naive_bayes_likelihood($FeatureEvident, $FeatureTotal, $NonFeatureEvident, $NonFeatureTotal) { return array($FeatureEvident/$FeatureTotal, $NonFeatureEvident/$NonFeatureTotal); } ?&gt; 
I wouldn't exactly say it's an example of "well-built" and "modern". Being immensely popular doesn't necessarily mean an application is well-built. WordPress has a lot of cruft and global namespace contamination. It is a great piece of software however.
I've heard good things about PrestaCart (http://www.prestashop.com/) as a well-built e-commerce software. Especially when compared to the other free offerings in its category. The fact is that most popular PHP software may not be exactly "well-built" or "modern", but if it's tried-and-tested code that stands up under most use cases, that can be more important.
Try phpStorm. I used Aptana before, now I'm reborn. Seriously. A new, majorly version (2.0) improved just came out.
Gosh yes darnit I'm stuck with a 2007 build of the manual, but it's still more useful if it has the comments.
I recommend the [formmailer from gentlesource](http://www.gentlesource.com/form-mail/). It has protection against header injection an automated spam. I'm using it on all of my websites. Support could be a tad better, though. :-)
For the uninformed, Philip Olson is the editor of the PHP documentation.
OMG! A celebrity on my reddit!
Fair cop, but then "modern" and "well-built" is a bit of an oxymoron especially when it comes to anything using html5.
When you're on a 12-hour flight with some code to deliver two hours after you land, and the documentation doesn't explain some obscure side-effect that someone discovered and commented about, it makes a difference.
This comment makes me a little bit nervous. I have been programming in PHP for quite awhile now, but just recently began using MVC Frameworks (About a year ago). I started with CodeIgnighter, but quickly saw its short comings and checked out the Kohana v3 Framework. My development process seems to be more along the lines of, doing sections (building the door or window of the house), but I do the views at the same time as doing the models and controllers. I find that If I try to do the models and controllers and then deal with the views later I get stuck [over-analyzing](http://en.wikipedia.org/wiki/Analysis_paralysis) everything and starting at a blank controller thinking way too far head, I feel like I need to think out a strategy to complete the entire house. However when I do the views along with the models and controllers at the same time I feel like I have fully completed a section of the project and can move on to the next task. However, I feel like I SHOULD be following the pattern suggested in this post.
Model view controller as a web approach is a cult followed by novices. HTTP itself is already model view controller; creating a framework for it just shows that the developer doesn't know what the phrase actually means. Don't learn development from blogs; they're usually wrong. Go get Design Patterns, and find out what the phrase really means, and what MVC is really for. Then look at the things you've been learning from, and how this comment got buried by novice fanboys, and shake your head sadly at what that means for getting advice in proggit. MVC is just how people who don't know what they're doing say "dispatch."
&gt; This drives my PM crazy from time to time because it will look like nothing is done If you were unit testing the code, s/he could just look at coverage and satisfaction percentages. Plus, you know, unit testing has its own merits.
&gt; I have been programming in PHP for quite awhile now, but just recently began using MVC Frameworks Don't worry, it'll pass.
Funny thing about MVC: its meaning mysteriously shifts to whatever the library authors wanted to implement. Symphony bears no resemblance whatsoever to what Design Patterns defined MVC to be.
If you're using PHP 5, there are some [magic methods](http://www.php.net/manual/en/language.oop5.overloading.php#language.oop5.overloading.members) just for this! Example #1 on that page should get you going.
Good tricks!
I know you can merge arrays easily with array1 += array2 not sure if you can do the same with objects?
Dear god, I hope and wish and pray that someday I become you.
Your point is absolutely correct, from my experience, but your assertion that Symfony "bears no resemblance," that I just don't understand. Enlightenment or retraction required.
I can understand that some objects simply have too many members to set them each individually. Your method assign_to_this() would probably be better named setFromArray() or setFromObject(). I will comment that when I see developers accessing members of an object like they would an array, I just have to say 'dont do that'. Also php has clone(), but I haven't used it enough to recommend it. Why do 2 objects have to merged into 1?
You might want to be more careful how you phrase things like that. I almost didn't answer. Symfony is a component and plugin system with ORM. It's a gigantic system which requires specific webserver configurations. It talks about best practices and security (then advises chmod 777, load code over the network and leaving root passwords in command history just in the first half of the installation guide.) The developers are so clownishly incompetent that their software fails if there are spaces in the path on windows. Symfony provides a required entrypoint, then suggests it be hidden with mod_rewrite. Symfony provides four distinct environments - development, testing, staging (sic) and production - to support a concrete deployment process. Symfony is an application framework. Model View Controller means "separate presentation from logic and datastore." MVC does *not* mean generalized architecture for insertion of third party code. That's a plugin system. Where do you see the MVC pattern actually applying here? MVC is three classes: one which stores data, one which presents data that's handed to it, and one which can perform transformative acts on data when handed to it. An ATM is model view controller: the view is the local money machine, the model is the bank that holds your money, and the controller is the clearing house inbetween serving as authorization and escrow. Symfony isn't even remotely MVC. The only reason it thinks it is is because it's a cheap knockoff of other frameworks which think they're MVC, also written by incompetant goons, like Cake, CodeIgniter and so on. People just say MVC to look smart, because they know if they say "framework" everyone will fall asleep halfway through the title, since frameworks are generally just a small utility collection and a huge pile of half-working crap that looks like it's going to save you a ton of time and ends up sinking you on rewrite.
Wow, this looks very interesting. Abstracting out extension specific image manipulation tools could really help people and provide simpler usage. Does anyone know if there already are such libraries?
only if you cast them as arrays, meaning implicit conversion of properties to key-pairs.
checkout mailchimp or google groups.
For that, you may want to look at the clone keyword. If not that, it might be necessary to write [magic methods](http://php.net/manual/en/language.oop5.magic.php) in your class and redefine "assign_to_this" as "assignData", simply using "assignData" to set a local array with values that then may be accessed/mutated by magic methods. Interestingly enough, I have just implemented a modular persistence framework for the sake of extending built-in PHP magic and automatically populating objects in a way like you have illustrated. However, such extraneous overhead is meant to resolve more complex dependency issues and compensate for impedance mismatches, not just trivial object duplication. When using a persistence framework, it is possible to impose multitudes of custom behaviors on objects without imposing any direct dependencies on them. As such, external code may use the persistence model, and the persistence model may use external code, but neither need have any direct knowledge of the other(therein still working in isolation). This is known as a decoupled or modular architecture.
I'm not really a tdd fan...probably because I'm the only dev on my projects. I imagine its pretty useful in a team setting though.
As an every-aspiring developer I really appreciate the meaningful clarification. It wasn't in vain.
The question is OOT but [SendGrid](http://sendgrid.com/) hands down.
I will be.
[WideImage](http://wideimage.sourceforge.net/). It's extensible and absolutely fantastic.
You don't need to write models for the entire project, just the piece your working on. Never code more than you need. Release early, release often.
And yet the fanboys have already started the downvote parade.
There's a pretty big difference between doing unit tests and doing test driven development.
What, in your opinion, *is* a real life example of the MVC pattern?
Changelog: http://svn.php.net/viewvc/php/php-src/tags/php_5_3_6RC1/NEWS?revision=308400&amp;view=markup
Fair enough, that seems worthwhile.
gud.provide the link , Let me try ..
I will attend too. Always good to meet up with ex-colleagues.
Komodo Edit is good enough for me and performs snappily on my Linux and OS X workstations. The free SourceTree extension is a must!
mail()
I should give some more explanation: I'm getting a database row that comes in as an instance of stdClass. (Let's pretend for the moment that that can't change.) I simply need all the properties of the stdObject to be assigned to $this, without having to set each one individually.
Is there something wrong with the one in Design Patterns?
Yeah, magic methods can help here. class Example { private $_row = array(); public function __construct() { $this-&gt;_row = (array)Database::row(); # whatever it was. Type casting to (array) for stdClass objects so key=&gt;value. } public function __get($key) { if(array_key_exists($this-&gt;_row[$key])) return $this-&gt;_row[$key]; } public function __set($key,$value) { $this-&gt;_row[$key] = $value; } } Personally I like to take out the $this-&gt;_row = array(); from construct and toss it into invoke, so $Example($new_id); will give me the new values during things like iterations. And then the construct be: public function __construct($id=0) { if($id) return $this-&gt;__invoke($id); } **EDIT:** To clear things up in my example, all you really need is the: public function __get($key) { if(array_key_exists($this-&gt;_row[$key])) return $this-&gt;_row[$key]; } And define: $this-&gt;_row = $object; However you want to, then $this-&gt;$key will return the value of your $object. You can remove all of the other stuff (especially the setter if you want those values to be read only publicly).
So basically you think replacing a two line imperative function with five magic, version dependant functions is ... an improvement, and easier. Got it.
While everyone else presents a bunch of ridiculous magic functions to replace a simple straightforward job with a more complicated and php version dependant job, let me be the first to tell you: 1) No, not really. 2) You could just set the result as a member, probably. 3) Format it differently and it looks easier: function duplicateMemberProperties($o) { foreach ($o as $k =&gt; $v) { $this-&gt;$k = $v; } return this; } There's no reason to replace that. It's fine, fast, easy to understand, easy to ensure correct, and works back to PHP3. Easier and better than one line of logic? No.
Clone isn't correct, and has significant implications regarding behavior, including the invokation of magic methods. Magic methods for a direct memberwise copy are neither better nor easier. You appear to have repeated the mistakes other people made. Answer fail.
Actually yeah. A little bit more code at the beginning yet it is a lot easier to then implement outside by yourself or other developers on your team as well as being more dynamic (adding areas to add different assertions\validations depending on the job on hand). Not to mention his assign_to_this would also need to be implemented elsewhere (probably inside his constructor) so his example would also need more lines of code to call said method. P.S. Mine is also only two lines of code, one in the constructor grabbing the data, and two is the getter to return said data.
Anyone upvoting this answer hasn't thought it through. Magic methods are a lot more work for the programmer, a lot more work for the interpreter, a lot more code and a lot less easy to debug. They have significant performance impacts and provide no benefit to the existing one-liner. This is, frankly, a terrible answer.
&gt; yet it is a lot easier to then implement outside by yourself or other developers on your team In what way is this ease created? This is a bald and incorrect assertion. &gt; as well as being more dynamic There is nothing "more dynamic" about two different methods to copy members. You don't know what you're talking about. &gt; Not to mention his assign_to_this would also need to be implemented elsewhere Why? &gt; so his example would also need more lines of code to call said method. No, it wouldn't, because this need doesn't exist. &gt; P.S. Mine is also only two lines of code Lol, ok. Maybe if you just pack a bunch of crap onto one-liners, the number of lines of code changes, right? Because clearly what we're measuring isn't function points, but rather the number of newlines in the source. Hell, if you just take out all the newlines in an entire application, the whole application becomes a one-liner! PS, yours is also incorrect. &gt; one in the constructor grabbing the data, and two is the getter to return said data. Yeah, there aren't anything there other than the constructor or the getter. Really. Be sure to downvote people for disagreeing with you. That's how to be adult about technical decisions.
&gt;In what way is this ease created? This is a bald and incorrect assertion. In his example he's going to either need an constructor or a method in order to call assign_to_this. Either he'll need to program into his class or force someone using his object to do it. &gt; There is nothing "more dynamic" about two different methods to copy members. You don't know what you're talking about. It is more dynamic in the options you can do, especially since the provided example can cause conflicts with the object's own private\protected keys if the source happens to have the same names. Which can be helpful if the source is being developed by someone else. &gt; Why? Read the first part of my reply. assign_to_this would need to be called somewhere. Either by his\her object itself or a programmer that is using the object. ($Class-&gt;assign_to_this(Database::row()) or $this-&gt;assign_to_this(Database::row()) in the constructor). &gt; No, it wouldn't, because this need doesn't exist. So how will assign_to_this fire then? &gt; Lol, ok. Maybe if you just pack a bunch of crap onto one-liners, the number of lines of code changes, right? Because clearly what we're measuring isn't function points, but rather the number of newlines in the source. &gt; Hell, if you just take out all the newlines in an entire application, the whole application becomes a one-liner! 1. $this-&gt;_row = (array)Database::row(); 2. if(array_key_exists($key,$this-&gt;_row)) return $this-&gt;_rows[$key]; &gt; PS, yours is also incorrect. &gt; Yeah, there aren't anything there other than the constructor or the getter. Really. Exactly, he wanted to know if there was another way he could have $this mapped, I provided an example using magic methods. &gt; Be sure to downvote people for disagreeing with you. That's how to be adult about technical decisions. Considering you downvoted me felt it was an equal response. Edit: My getter also addresses the OP's follow up comment "I simply need all the properties of the stdObject to be assigned to $this, without having to set each one individually." That's what a getter is for.
There are now real [plans](http://markmail.org/message/mwscwey4yhbqdalf) (prodded by this reddit) for this. It won't be the same "enhanced" version, but we'll offer a "with user comments" version of the CHM that essentially inserts user comments into the HTML that the CHM is based on.
No I was just wondering if there was something else real world that you were a proponent of or if you were just complaining that the way in which people separate their Model, View and Controller isn't similar enough to the pattern in Design Patterns to merit being called that.
Why in the world would you make it more complicated than it is? That 4-line code is quick and gets the job done, given what we know. I personally would just assign $this-&gt;db_row = $object since we're dealing with a single database row and access it using $this-&gt;db_row-&gt;property. Easy, straightforward.
Very cool. I was just lamenting the lack of a modern image manipulation libraries in PHP yesterday, other than WideImage. The Zend_Image proposal looks good, but development seems to have been stalled for quite some time. I'll be putting Imagine through the paces in the next few days.
I think most stuff nowadays uses md5. Stuff that's not totally stupid uses md5 + a randomly generated salt. Bad Example (someone should fire you if you copy and paste this): $salt = md5(time()); // do something better than this for your seed $store_pass = md5($salt.$_POST['password']).":".$salt; Better still is to run md5 N times, where 1000 &lt;= N &lt;= 10000. Better still is to use Blowfish or something.
&gt; Why in the world would you make it more complicated than it is? That 4-line code is quick and gets the job done, given what we know. Don't see what is hard\complicated about setting a simple getter. The OP has a source, he can define it anywhere, my example uses the constructor to set the $object source only for reference. Yet if the OP wanted it could be set via a method, say "public function assign(stdObj $object){}" and inside there define $this-&gt;_row = (array)$object. &gt; I personally would just assign $this-&gt;db_row = $object since we're dealing with a single database row and access it using $this-&gt;db_row-&gt;property. Easy, straightforward. Same here, that's why I went with $this-&gt;_row, since he said it was a simple DB row. The getter just allows the OP to do what they wanted, being able to use the DB row as $this-&gt;$key. The benefit of doing it this way is also to avoid collisions of possible variables if the source is not developed by the OP.
[phpass](http://www.openwall.com/phpass/)
What advantages does it offer? crypt() offers the system's hashing algorithm, with fallbacks.
But managing your salts and stuff is actually more effort with a shittier algorithm.
&gt; if you were just complaining that the way in which people separate their Model, View and Controller isn't similar enough to the pattern in Design Patterns to merit being called that. That's like saying "if you were just complaining that the way the pizza shop puts pepperoni on its pizza isn't similar enough to a Toyota to merit being called a car." Yes, I'm complaining that the phrase is being hilariously inappropriately used. This isn't a question of fine distinctions, though. MVC is a ten or twenty line minor tool. They might as well call Symfony a singleton. After all there must be a singleton poorly implemented in there, and if 99% of the work is something completely separate and unrelated ...
&gt; In his example he's going to either need an constructor or a method in order to call assign_to_this. No, he isn't. &gt; It is more dynamic in the options you can do, especially since the provided example can cause conflicts with the object's own private\protected keys if the source happens to have the same names. One, that's not even slightly related to what the word "dynamic" means. Two, please pay a little bit more attention. The object was described; there will be no conflict. Three, what I said takes account of that, if you read more carefully. &gt; assign_to_this would need to be called somewhere. You keep saying this like it's only true in the original case but not the replacement case, to hold up a cost differential. This makes it very difficult to take you seriously. &gt; So how will assign_to_this fire then? You pretend that A needs to do work that B doesn't, in order to justify replacing a one-liner with either five or four lines, depending on the outcome here. One, the same way it does in yours, which you're pretending isn't true. Two, it doesn't matter; the replacement is still more work for the programmer, more work for the interpreter, more complexity, more opportunities for error, and absolutely no benefit. When you argue for the degree of increased work but don't talk about why the new approach is better, you make clear that you're just trying to be correct, rather than thinking about the actual problem. &gt; Exactly, he wanted to know if there was another way he could have $this mapped, I provided an example using magic methods. And yours is longer, more work, less correct, and does not provide any advantage you're able to describe in more technical terms than some handwaving about it's somehow "more dynamic" because blah blah function call. &gt; Considering you downvoted me No, I didn't. &gt; felt it was an equal response. Justifying bad behavior in terms of incorrect guesswork about what someone else did is the sign of an immature man. &gt; Edit: My getter also addresses the OP's follow up comment "I simply need all the properties of the stdObject to be assigned to $this, without having to set each one individually." That's what a getter is for. Getters are for getting single values. You might as well respond to "is there an easier way to get this trunk open" by telling them how to build a new trunk, then preening about that that's what screwdrivers are for, since they're one small piece involved in the process. &gt; Edit: My getter also addresses Your getter doesn't address any reason for this replacement to exist. That you _still_ haven't successfully justified this much larger, much less correct, much slower approach makes clear one thing: you don't have a justification. (Actually, it makes several other things clear too.) Made simple: you could do this with an iteration, or you could do it very slowly through the object system in a much more complex way, getting less correct results in a more fragile system. If you can't explain the choice, you're making a bad choice. Case closed.
It should be, that's what the function is designed for, much better then just md5 or sha1, even with a salt.
Yes it is. But you asked what's the de facto standard. You were asking what everybody's using. So I told you what most code I've seen uses. I wasn't actually advocating using md5, which I think is obvious by my response. Though I got downvoted to oblivion anyway because people don't read they just click the pretty arrows. The problem with just using crypt (or phpass), especially if you're writing something that someone else might use, is you potentially lose portability of the passwords in your database, unless the 2 systems you're moving between both use the same algorithm. Which obviously in an ideal world, they'd both use Blowfish or DES. But that's not always the case in the real world. You might have to move between one machine using DES and another using md5. If you're leaving it up to crypt or phpass to decide what algorithm to use, suddenly none of your passwords work. This is also why a lot of code is written using the most/worst common option of md5 and just add salts and/or repeated re-hashing to make it less bad. Because it's guaranteed to be available, and the passwords are still going to work when you move between systems.
&gt; One, that's not even slightly related to what the word "dynamic" means. Dynamic in the sense that the programmer doesn't need to be over concerned with the incoming data, it can have any key\value pair and it won't in the slighest affect the object itself. &gt; Two, please pay a little bit more attention. The object was described; there will be no conflict. &gt; Three, what I said takes account of that, if you read more carefully. The object was described, the keys of that object were not described nor where the sources described. Only that it was a database response that is a stdObj. class Foo { private $foo = 'value'; public function assign_to_this($object) { foreach($object as $key =&gt; $value) $this-&gt;$key = $value; return $this; } } $Foo = new Foo; $Foo-&gt;assign_to_this(array('foo' =&gt; 'new value','baz' =&gt; 'value')); Internally $this-&gt;foo is now overwritten. Maybe what is wanted, may not be, an issue can change if the programmer doesn't have control of the incoming sources key =&gt; value naming. &gt; You keep saying this like it's only true in the original case but not the replacement case, to hold up a cost differential. This makes it very difficult to take you seriously. &gt; You pretend that A needs to do work that B doesn't, in order to justify replacing a one-liner with either five or four lines, depending on the outcome here. &gt; One, the same way it does in yours, which you're pretending isn't true. Actually it's the opposite, I'm saying it does work in the same way it just seemed you thought my basic two lines of codes (a single set, and then a single getter) were more only because in my example I implemented the calls while the original example only showed the function at hand. &gt; Two, it doesn't matter; the replacement is still more work for the programmer, more work for the interpreter, more complexity, more opportunities for error, and absolutely no benefit. &gt; When you argue for the degree of increased work but don't talk about why the new approach is better, you make clear that you're just trying to be correct, rather than thinking about the actual problem. &gt; And yours is longer, more work, less correct, and does not provide any advantage you're able to describe in more technical terms than some handwaving about it's somehow "more dynamic" because blah blah function call. How so? All mine does is simply see if the key exists, if it does it returns the value. The $object can be stored in various methods. And again, it's dynamic in the sense that we can accept various $objects and not have to be concerned with conflicts which is helpful when specifications change down the line. &gt; No, I didn't. &gt; Justifying bad behavior in terms of incorrect guesswork about what someone else did is the sign of an immature man. In that case I apologize and will dedownvote. Just the timing seemed to be quite impeccable in that regard. Sorry. &gt; Your getter doesn't address any reason for this replacement to exist. &gt; Case closed. Suit yourself.
A simplified API which handles fail overs in a cross-system compatible method as well as good salt generation algorithm.
is this still a problem if you can guarantee the use of php 5.3+ since it includes it's own copy of the algorithms as a fallback if the OS does not provide them? so, for example, shouldn't blowfish always be the same blowfish with php 5.3+ no matter what OS it is running on? 
But surely if you are using PHP5+ you're going to be assuring the support of Blowfish AND DES?
Excellent, have implemented it and am using it. The test.php is so much easier to understand than the tutorial on the site, though.
I use them, and if shorttags are disabled (they are enabled by default on PHP5), I bitch and scream at a sysadmin until it is changed.
Because some people bitched because they conflicted with some XML declaration tags.
Everything is so tightly coupled :(
Yeah but if you are making a system, these things could be implemented in a superclass and be inherited from, thus all your classes store their data in a standard location, not to mention the fact that you can also implement Iterator templates etc. https://github.com/radiosilence/core/blob/master/core/types.php Have a look at this. Most classes in my framework inherit from either the Dict or the Li classes (based on whether they're logically a key value store or a list), meaning they get a whole load of useful methods that logically make sense to the class.
It should be but that's the point, if you're writing software to be used by others, in the real world, they may deploy it on older systems that are not up to date, then move it to a more up to date one and all of a sudden their passwords don't work. This is a real concern. It's silly, and ideally we wouldn't run into these types of things but they happen.
Ok, ok, ok. Let me weigh in here. First of all, three points (or, three things that don't matter at all in this argument): 1. I don't care about other people on my team because I'm the only one on my team. This is a very small project and I'm not on a team. 2. I don't care about how many lines a solution takes up (within reason). 3. I don't care about being backwards-compatible with older versions of PHP. *Man, Bellythroat, you sure sound like a careless programmer!* Well, hear me out: True, my concerns are not line numbers or maintainability, specifically. My concern is to write *elegant* code, and I'd argue that maintainability and efficiency will be the natural *result* of that elegance. (Maybe I'm an idealist.) I know there usually isn't one single "correct" way of doing things, but I try to get my code to be *as correct as possible* (although like I said, I don't need backwards-compatibility). Now, with that in mind, mullanaphy deserves some credit. I'm not totally against magic methods, and I don't care if the code is a bit longer. However, there are two things I don't like about mullanaphy's solution: (1) It casts an object as an array, and then turns around and pretends like the array keys are object properties. It's like fitting a square peg into a round hole and then back into a square hole. Or something. It just feels a bit hacky. I'd rather the row's field values be real properties of $this. (2) It uses the Paamayim Nekudotayim (Scope Resoultion Operator, ::), which I generally try to avoid, and in my case wouldn't even work. For the sake of argument (not that we should necessarily keep arguing), let's pretend like I *only* have access to the row as a stdObject, and I can't dig into it's parent class using Database::row(). So it feels too messy to me, but again I think he deserves some credit for the idea. Ideally, I would [return the row as a defined class](http://www.php.net/manual/en/pdostatement.fetchobject.php) and just extend that class. Unfortunately, the framework I'm using doesn't support that right now...
&gt; Dynamic in the sense that the programmer doesn't need to be over concerned with the incoming data, it can have any key\value pair and it won't in the slighest affect the object itself. But we already had that, which I've already pointed out more than once. It's becoming obvious that you aren't reading what's being said to you. &gt; In that case I apologize and will dedownvote. I appreciate the gesture. Thank you.
&gt; I don't care about other people on my team because I'm the only one on my team. This is a very small project and I'm not on a team. K. &gt; I don't care about how many lines a solution takes up (within reason). Good. This is a rare and mature perspective. &gt; I don't care about being backwards-compatible with older versions of PHP. Neither do I under two circumstances: one, it will never be a client library or be distributed to end users, and two, *that* *there's* *a* *good* *reason* *for* *the* *difference*. &gt; Man, Bellythroat, you sure sound like a careless programmer! I realize you're kidding, but I actually don't agree. You sound sensible. &gt; My concern is to write elegant code, and I'd argue that maintainability and efficiency will be the natural result of that elegance. I need to check my math here. Are you suggesting that five magic methods glued into place by an object system which was replaced last major and is getting replaced next major is more elegant than a one-liner imperative function? Magic Is Bad (tm). Somtimes it's worth it, but here there is zero justifying reason. Magic has a price. Every time you use it, it tries to hurt you. There needs to be a reason to invoke it, or you're wasting time and introducing risk for no reason, by definition. Here, there is precisely no stated improvement for the extra work and risk. Zero. Count the listed benefits. There's a lot more in terms of downside than to what you're paying homage: the action is less clear, the correctness checking is on more code and across multiple methods, the mechanism isn't single function point anymore, the cyclomatic complexity is staggering, this relies on an object system implementation which is known to be about to be replaced, it's time-expensive to the compiler, *and* *it* *serves* *no* *purpose*. &gt; It casts an object as an array, and then turns around and pretends like the array keys are object properties. It's like fitting a square peg into a round hole and then back into a square hole. Or something. It just feels a bit hacky. There are many things here that are strictly incorrect. Neither solution is correct, if you're careful. However, for the purpose stated by the user, the magic method solution is not actually beneficial in any way. Its behavior is less strictly defined, it's far slower, and it's much more likely to harbor bugs. There is no apparent upside of any form. I asked for it quite a few times. &gt; It uses the Paamayim Nekudotayim (Scope Resoultion Operator, ::), which I generally try to avoid Well now ... being honest, I have a hard time imagining a reason to avoid :: . May I request your reasoning? This threw my skepticism flag hard. &gt; So it feels too messy to me, but again I think he deserves some credit for the idea. Why? The idea doesn't improve anything, and it makes significant problems where they don't need to exist. It's just relying on tools that were written by someone else; he didn't have any idea. Shall we give credit to the guy who wanted to add bubble sort to the standard library? After all, that's a bad idea that belongs to an undiscussed third party and gives no benefit of any form, and that one doesn't actually cause problems like this one does. Credit for what, specifically? Having a bad idea is something to be lauded now? &gt; Ideally, I would return the row as a defined class and just extend that class. The fuck for? It's a row of POD. This whole thing is silly. PHP is built around native type-variant containers. This is all just masturbating into a cup about the needless addition of tools to look fancy. return array('field'=&gt;'value', 'field'=&gt;'value', ...); Faster, clearer, simpler, easier for the developer, easier on the compiler, cleaner, far less likely to harbor bugs, etc. This whole thing stinks of people trying to be smart for no gain. It's just creating a bunch of pointless work for the human and the machine, which isn't just expensive: more importantly, it's defect prone. Take off the fucking wizard hat and just get the job done. Jesus. &gt; Unfortunately, the framework I'm using doesn't support that right now... Yeah, you shouldn't be using a framework either. They're all garbage. It's a shame that it takes so very long for new programmers to become skeptical of shiny things. You guys waste _so_ _much_ work it's unbelievable.
&gt; Yeah but if you are making a system, these things could be implemented in a superclass and be inherited from Yes, because why implement this as a function when you can build an entire object model around it, then die painfully the second you actually need the object model for something legitimate instead? This wouldn't even be a good idea in a language with multiple inheritance. It's a one-liner function. Stop trying to make everything into objects. Golden Hammers Are Bad (tm). I'm not saying OOP is bad. Just that using it without any particularly compelling reason is. This whole thing is ridiculous. &gt; Have a look at this. Most classes in my framework inherit from either the Dict or the Li classes (based on whether they're logically a key value store or a list) Meaning you actually have a dict and a list, and instead of making individual functions to work on them, you decided to wrap everything up in a monsterous unnecessary object tree, preventing composability and skylining the cost of testing. &gt; meaning they get a whole load of useful methods that logically make sense to the class. "I used the object system to inherit so that they'd all get the functions, instead of just making functions, which they'd all get." Uh huh. A purely functional language or a type-variant template language would do you some good. This is not a job for which OOP is well suited. I would recommend that you go learn Erlang deep enough to implement a new ets, C++ deep enough to implement a container, or Haskell deep enough to say zygohistomorphic prepromorphism with a straight face.
Don't use client-side methods like css. If for some reason css isn't available, people will see the element. The hidden field is a good idea. Also, the linked script doesn't strip out things like html. You should do that.
It's also slow which is actually a feature as far as secure hashing goes. Slow hashing means it's basically immune to brute force.
People still use functions??
What license is PHPass under? I couldn't find it anywhere.
&gt;# Written by Solar Designer &lt;solar at openwall.com&gt; in 2004-2006 and placed in the public domain. Revised in subsequent years, still public domain.
Yes. I just submitted one. It's quite possibly the *best* function on that website. http://projects.westhost.com/contest/php/function/returns-false/146#php-snippet
I gave you five stars. I also created an incredibly useful function. http://projects.westhost.com/contest/php/function/isitmonday/147#php-snippet This is wrong isn't it?
&gt; crypt() offers the system's hashing algorithm, with fallbacks. The system's hashing algorithm is unpredictable and may be the asstastic default truncates-at-8-characters DES implementation. You know, the one crackable by looking at it sideways. Unless you're using PHP 5.3, where crypt() is guaranteed to have Blowfish, SHA-512 and 256, you should avoid using it. If you neither control the server nor can mandate PHP 5.3 use, phpass is a great solution.
&gt; die painfully the second you actually need the object model for something legitimate instead? Not sure how this applies, the inheritance in my object model is logical, and most things can be explained via a dictionary or a list. If not, I can implement another parent class (like a tree or something) and inherit from that instead. I don't see how having an inheritance tree is an issue for this, OOP provides logical organisation of concepts that inherit from each other. &gt; This is not a job What exactly? OOP is perfectly fine for what I'm doing.
&gt;Magic methods are a lot more work for the programmer This is really situation-dependent. &gt;a lot more work for the interpreter Fair enough, but that depends on how big of a factor performance is. &gt;A lot more code Not always. I've used magic methods to eliminate most of the getters and setters for some model classes. I've had a couple places where it's saved me 500+ lines of code. &gt; A lot less easy to debug Even with a debugger?
Hot, sexy PHP ass. Couldn't resist.
I'm not exactly sure whether this would apply to your problem or situation, but I recently learned that [you can use PDO to fetch database rows directly into objects](http://stackoverflow.com/questions/13569/mysqli-or-pdo-what-are-the-pros-and-cons/368990#368990).
Awesome, well phpass it is!
Firstly, I am sorry for not responding earlier. I had trouble looking through the wealth of links and information you provided to backup your claims. Secondly, object cloning is just as "correct" as anything else. It is entirely possible to accomplish what the OP desires using cloning exclusively. In other words, without a) looping through stdClass members, or b) using any magic methods(aside from __clone()). Those "significant behavior implications" you mentioned are specifically [shallow copying and __clone magic](http://www.php.net/manual/en/language.oop5.cloning.php), neither of which are particularly significant compared to the behavioral gotchas present in property overloading magic. Thirdly, [stdClass](http://php.net/manual/en/reserved.classes.php) does not, nor could ever have any magic methods. Nor is magic method behavior difficult to circumvent, were that even necessary. Lastly, please elucidate\iˈlo͞osiˌdāt\, for I am genuinely concerned about the aforementioned behavioral implications. Specifically, why are they so incredibly dreadful that their mere mention results in your feverish trolling of r/php? 
I just wrote another wonderful function. http://projects.westhost.com/contest/php/function/ismywebserverworking/149#php-snippet
You must not have gotten the memo. All the supporters of CI left for Kohana, which was originally based on CI, but made for PHP5, and then was rewritten several times yet again after that. The latest is really slick.
[best](http://projects.westhost.com/contest/php/function/save-the-world/75).
Yii is nice, but learning curve is STEEP. It has the whole kitchen sink and I personally find that with Yii, adherence to convention is strict. I use Kohana. It is flexible, uses hierarchical MVC, and fits your requirements, but unfortunately support and documentation is terrible. 
I think you would be well served looking at Yii for this. I'd say build some simple database driven tests in a few popular frameworks (Yii, CodeIgniter, and Kohana seem to be well-liked) and pick the one you like using the best. I also tend to evaluate what kind of library support a framework has, and what third party modules are available that I may need for the project at hand.
Thanks I'm not worried about existing libraries. I just want it to perform some general tasks well including form handling, validation, authentication, etc. All the code is very custom, so I doubt I'll be able to use anyone else's modules. Your suggestion to just try a few is a good one. I think I'll do one a week for a few weeks until it's either obvious or I've reached a good compromise.
Steep? Really? There are a lot of classes to learn, but the examples seem very straight-forward. I've also heard the exact opposite about Yii: it gets out of your way and doesn't make you jump through hoops to tweak it. How do Kohana and Yii stack up to custom extensions to core functionality? I need to take another look at Kohana.
Except it restricts variables to _row. You guys (including the OP) are making this more difficult than it needs to be.
I'm a huge Yii fan, but realistically there are many frameworks out there that would work. That being said, let me tell you how Yii fits this description: Yii auth is built around RBAC, role based authentication. You can define roles, tasks, and operations arbitrarily and assign users to roles (ex: marketing guy), operations (ex: make some content), or tasks (ex: edit a specific content). You can tie a task to a specific action in a specific action if you wish, but you don't have to. There are also some extensions freely available that help with setup and are really flexible (I like the rights extension). You can build your url rules based on whatever pattern you like. If this is not flexible enough, you can override the built in URL manager to do whatever you want. There are a ton of built in validators, and you can easily create your own. Validators can be functions or classes, and are really easy to write. jQuery is baked in Your user object is left up to you, so you can hash passwords however you want to store in the DB, or authenticate to LDAP, or via text file, or via smoke signal, or whatever you care to do with it. ORM is really straight forward. Code looks like this: $arrayOfObjects = myTable::model()-&gt;findAll(); foreach($arrayOfObjects as $object) { $object-&gt;field1 = $object-&gt;field3; //or whatever } CRUD can be auto-generated, but you can also define relations between models and use them with lazy loading or by joining in the main query (lazy does another select when you actually ask for the data) //Joining posts with author and comments //this is not lazy, so a post with 5 comments will create //5 rows, one row for each comment, and the post data //will be the same in all five rows Post::model()-&gt;with('author','comments')-&gt;together()-&gt;findAll(); //This uses lazy loading and will return one of each post $posts = Post::model()-&gt;findAll(); foreach($posts as $post) { foreach($post-&gt;comment as $comment) { //this gets all the comment rows for the post automagically if you define a relation called "comments" //do something with comments here } } Yii is php5 You can extend the db component to support multiple db connections easily, or use one of the several extensions that already do this Yii claims to be really fast, and with xcache it seems to be based on our seat of the pants dyno test yii is integrated with phpunit Yii has many logging options and the logging is really flexible (and awesome) Yii has a bunch of built in stuff, so the learning curve is: rough first two days doable first two weeks embarrassing month or two as you realize you could have done everything up to this point so much faster/easier had you only known what you know now 
Ha! After re-reading your post I see you already looked at Yii. My bad. I spent a lot of time typing that shit out, though, so I am leaving it here in case it helps :)
Just a side note: Mysql also has [generic built-in encrypt/decrypt functions](http://dev.mysql.com/doc/refman/5.5/en/encryption-functions.html) if PHP isn't your defacto getter and setter of sensitive fields. Also, "hashing" (md5, sha, etc) may be the wrong term and approach, as that implies you're only shortening or converting the password to some useable and predictable string a cracker can better deal with. A "hash" is only good to determine if the file you just downloaded is mostly reliably untainted (IE a collision on a file of the same size and type shouldn't realistically occur), or if you're trying to name array keys with almost impossibly unique values (PHP arrays or any other language). "Encrypting" may be a better term and approach, as that implies a cracker won't know what to do with a stolen password table with a jumble of characters, except to give up and fall back on brute force (or simply thumb through the script with your encrypting method and just simply employ the reverse to crack your entire table, which by this point they'd already have on hand... but that's not the point here). 
have you thought about augmenting the existing project using some Zend framework modules (form, authentication, validation etc) and slowly migrating the whole site over to the ZF way of doing things (MVC)
No, it's great! Thank you. I've been reading so many things, I don't even know what I've been looking at anymore. I don't mind making things that are easier if I only knew how. I've had that feeling for 5 years. As long as I can get what I want done and it looks good, performs quickly and as expected, I'll be a happy camper. with findAll() does that mean that you retrieve all fields in the database? ORM stuff seems so ... not fast. I have so much data getting retrieved that I'm worried non-hand-written queries will bog everything down. I think I read that you can have the system build the inital CRUD using ORM and then you can just go in and tweak the files that are built as needed. Is that right?
I am now! The main problem with the current code is that it's spaghetti and it's all inline. Most of the data is handled by staff, not clients, so that's made things manageable, but now we're thinking about marketing our product to other organizations so I want something that's more maintainable. I think your suggestion is a great one. Are you saying that I could include the modules and then convert files to MVC over time?
&gt; Not sure how this applies Well, if you hadn't played downvote games, you might have learned.
&gt; This is really situation-dependent. The situation is original post, derp. &gt; &gt; A lot more code &gt; Not always Please stop attempting to generalize. &gt; &gt; A lot less easy to debug &gt; Even with a debugger? Lol. You're just trying to look like you have a point. Why can't you get to the part where you explain why doing any of this extra work has any benefit at all? As far as harder to debug, you appear not to see the bug yet.
&gt; &gt; Clone isn't correct &gt; Secondly, object cloning is just as "correct" as anything else. I didn't say cloning isn't correct. I said clone isn't correct. It's a little like if someone said "to find the count of four sets of three, divide three by four," and someone else responded "divide isn't correct." They aren't criticizing the validity of the concept of division; they're just saying that it isn't the appropriate tool for the job and will have undesirable results. &gt; Those "significant behavior implications" you mentioned are specifically shallow copying and __clone magic Oh good, you're telling me what I meant, and you're wrong. Lemme know if you stop pretending to know what I meant. I have better things to do than to be preached at by someone who wants to overcomplicate and slow down a perfectly fine one-liner with no actual stated benefit. When you find the bug in the given implementation, lemme know. Otherwise I'm bored of the way in which you present yourself. &gt; Lastly, please elucidate\iˈlo͞osiˌdāt\ Jesus, dude. &gt; Specifically, why are they so incredibly dreadful that their mere mention results in your feverish trolling of r/php? This cost you an answer. It's really not very smart to speak down to people while asking them things. Feel free to pretend that I just don't know, in order to not have to face that your poor behavior cost you what you wanted. Flies with honey, flies with vinegar; when you ask for information in the same comment where you call someone a troll, get repeatedly sarcastic and cut and paste pronunciation keys, your desperation to bore someone into not answering so that you can pretend you've won a non-argument becomes relatively transparent. Not genuinely concerned enough to maintain a basic demeanor. Self control is hard, I guess.
I am against this and here's why: What you're essentially doing is altering the semantic and logic flow of your program for the sake of less keystrokes. This is a syntax issue, and you're not addressing it at the syntax level. In other words, this is something that needs to be part of the language, not a forced feature at the app layer. The best solution IMO is to encourage the PHP guys to give some thought to putting in a native method chaining operator. Something that produces a reference to the object after a call and allows proper syntactic chaining. And not just PHP; this goes for all languages where app layer chaining is popular.
I like this idea, but good luck getting it to happen.
Actually I didn't downvote you at all. You're just being a jerk even though I've been perfectly civil.
Love it!
Why not use array_multisort? Yes, I know it's a mess to call, but why not a wrapper around that function?
once the code base settles down a bit and documentation improves, i might consider kohana again. right now, fuel looks like the new hotness.
*dat pass*
See also http://node79.com/blog/schwartzian-transform-in-php/ Note that this also answers the question "when do you use array_walk()?".
&gt; Oh good, you're telling me what I meant, and you're wrong. No, I simply clarified that the behaviors you referred to are simply the result of two very basic aspects of the object model. Both are trivially easy to use and understand and neither of which(implications included) pose any risks as you seem to imply. &gt; I have better things to do than to be preached at Despite your claim of having better things to do, you seem to have no trouble finding the time to 1) lambaste me for suggesting cloning, 2) indict me for essentially making a beginner mistake and finally 3) concluding with the very insightful "answer fail". Have I accurately portrayed your comment? Because if so, that's quite a demeanor you have there. For that matter, you persist in criticizing my condescension, yet seem to have little compunction in doling out plenty yourself. Kettle, meet pot. So forgive me for responding sardonically to uncited claims, mischaracterization, and memes. &gt; Feel free to pretend I don't need to pretend, I know for a fact that your perception of programming is intrinsically limited by a wide variety of factors. Not the least of which being the fact that applications are drastically modified at an increasing rate. Moreover, the core language developers are continually introducing new features and phasing out old ones.. Said factors are essentially the personal and environmental struggles of which we are all inexorably subject. Considering such circumstances, engineers typically have before them an increasingly volatile landscape whereupon they are constantly onslaught by the grueling reality that they will need to move into their mother's basement should they eschew the burden of relentlessly reinforcing their skill-set to comply with ever-mounting industry demands. &gt; that I just don't know It isn't a matter of whether or not you "know" but rather, to what degree. The likelihood of a random programmer on reddit having anything more than a cursory comprehension of the object model is slim. Why? Because as developers, we are effectively forced to occupy most of our time with numerous tasks which oft epitomize mundanity and repetition. Programmers, with such inhibiting expectations bestowed upon them, can rarely find the time or inclination to expose themselves to the gritty underbellies of software they so rigorously employ. That is, unless you're an academic. Though, I find that unlikely, given your propensity towards "doing the easiest, simplest thing." By the same token, while you comfortably declare the necessity of simplicity from behind the wall of wide-spread acceptance and popular adoption, you simultaneously castigate the (even brief) mention of an alternative. In other words, it's easy to advocate the usage of an already ubiquitous and integral engine feature like dynamic property overloading. No one could or is going to disagree with you on that alone. That said, it is totally presumptuous of you to assume that proposing an alternative is wrong simply because it isn't commonly understood or in widespread use. Not to mention, you're doing yourself a disservice by forgoing unorthodox techniques, therein abdicating the possibility of doing anything different or discovering anything new . &gt; they're just saying that it isn't the appropriate tool for the job and will have undesirable results. Determining the best tool for the job isn't even remotely possible within the limited scope provided by the OP. We can make assumptions with regard to the context of the overall application, but despite that, we still remain positively unqualified to determine an optimal implementation. In any case, there are multitudes of situations where magic methods may be unwise or impractical. For that reason, an alternative must be used, regardless of whether or not you agree with or like it. *Edit: formatting
since you have your own modules I think it would be simpler to use a micro framework that won't get in your way of doing things: http://fatfree.sourceforge.net/ also doctrine orm(http://www.doctrine-project.org/) is always a good addition to any database driven php project.
I would suggest reading the user contributed notes on the [array_multisort page](http://php.net/manual/en/function.array-multisort.php); there are a wealth of good ideas there.
And then kohana launches an update and you have to spend an entire week rewriting your application. Try to explain that to your boss. Kohana dev team are to horny for improvements and tend to forget retro-compatibility.
I entirely respect your point of view, but from a purley educational point of view, I found this article interesting and informative. Upvote for all. Thanks.
I'm not going to weigh in too heavily on this because as long as you end up using one of the more modern php frameworks (and I would say one built from a php5 perspective as opposed to an older one) you'll be doing the right thing. Personally I can recommend looking into Symfony. Edit: Spurious word removal
&gt;You're just being a jerk I was actually trying to teach you something. But hey, don't worry - I stopped.
WTF on that markup. 
&gt; No, I simply clarified that the behaviors you referred to are Not the behaviors I referred to. That's the part where you're telling me what I meant, and are wrong. &gt; Despite your claim of having better things to do G'bye, Dolores. &gt; Kettle, meet pot. The difference being I'm not failing to justify the increased work and decreased correctness I'm advocating. &gt; It isn't a matter of whether or not you "know" but rather, to what degree. The likelihood of a random programmer on reddit having anything more than a cursory comprehension of the object model is slim. Look, I gather that you're trying to look like an expert, but this has nothing to do with understanding the object model. It's simpler than that. You tried to implement something to save someone hassle. Your new one is more work, more hassle, and has a bug you don't seem to see. This isn't about understanding the object model. This is about having the ability to step away from one's favorite toy when it isn't the right tool for the job. &gt; That is, unless you're an academic. Though, I find that unlikely That's nice. Here's a thought: when you're whining with words you can't even spell about how people are lambasting you (incidentally, that means "to beat you with a cane," not "to laugh at you for giving bad advice,") turning around and saying you don't think they're academics because they don't show a characteristic that you imagine no academic has ... kind of makes you look completely unaware of your own behaivor. &gt; while you comfortably declare the necessity of simplicity from behind the wall of wide-spread acceptance and popular adoption What? &gt; you simultaneously castigate Jesus christ, dude, put down the thesaurus. Nobody punished you. You sound like a bad Damon Wayans skit. http://www.youtube.com/watch?v=UBM6CBtuHS4 &gt; you simultaneously castigate the (even brief) mention of an alternative. This is of course riotously incorrect. What I criticized was the mention of a bad alternative that is both less simple, which was the poster's original criterion, and also slower and not correct. Stop trying to melodramatize victimhood into your situation. It's dishonest and childish. &gt; In other words, it's easy to advocate the usage of an already ubiquitous and integral engine feature like dynamic property overloading. Wait. First I'm the badguy for advocating something for being wide-spread and popular, which I didn't do, and then you're advocating this because it's wide-spread and popular. Nice. You really just can't cope with the question you were actually asked, can you? Next you go on to whine at length about how bad it is that you imagine I have some problem with unorthodoxy, even though I never said anything of the sort, and do not, which bores me half to tears. Do you just not understand how retarded you look when you screech about something someone didn't say and doesn't believe as their problem? I criticized your non-solution because it was slow, stupid, wasteful and buggy. This has nothing to do with orthodoxy. Let me break it down really simply for you, because you seem to struggle with basic motivation. 1. It's wrong - not the technique, just your attempt 1. It's more work for the human 1. It's more work for the compiler 1. It's extra time 1. It triples the number of function points 1. It doesn't add anything desirable Notice how there's not one god damned word about orthodoxy. Indeed, it's actually the orthodox solution to use the object model, for all your whining about how novel and fancy you're being; the idea that you using clone to clone is somehow inventive is laughable. This is what clone is for. It's just that the original poster's method is smaller, faster, less code, easier to understand, and doesn't have the retarded bug yours does. So I'm actually arguing *against* orthodoxy, all your bellyaching to the contrary notwithstanding. &gt; We can make assumptions Indeed it seems that's basically all you do. G'bye, Dolores.
If you have the ability to run PHP 5.3, you might want to consider [Lithium](http://lithify.me/) It's extremely modular and lets you use as much or as little as you want, and it's made so that you can drop it in to a current app, and it plays friendly with external classes. If you're super concerned about DB performance, you'll want to avoid ORMs entirely. Since Lithium is modular in nature, there are lots of contrib plugins for authentication (ACL, role-based, group-based, etc).
While I love it, Yii's learning curve is a little steep. That is my biggest issue with it. We have a new dev that started on 2/14, and he just started being able to write basic stuff in yii yesterday afternoon (24 hours learning to start). It will be about a month before he learns all of the components in the framework, so while he is beginning to crank out things that work, it takes a while to get a feel for how efficient you can be with it. This means you will not be effective for about a week and you will not be efficient for about a month.
Documentation is actually pretty good these days [Kohana Docs 3.1](http://kohanaframework.org/3.1/guide). It also depends on what you mean by support, I have always found the forums pretty helpful. That said, I have never used Yii. 
 $sortArgs = array ('DESC'=&gt;True); I dislike the use of the parameter $sortArgs .. Don't use arrays with boolean values. Thats what flags were invented for (you can even use the default flags like SORT_ASC etc). Also, check out multisort, this function is made for that : )
You can use scopes and relationships to tweak the default behavior quite a bit. You can also use the query builder if you wish to execute queries directly http://www.yiiframework.com/doc/guide/1.1/en/database.query-builder What our DBA has started doing as a best practice, though, is creating views for complicated queries, creating ActiveRecord objects off of the view, and then letting the devs use the active record objects in the same way they would use a table active record object. This way, the DBA retains control of the join structure and keys and so forth, and the devs don't have to know as much about the internals (would a straight join here speed this up, should we double a table back on itself with an inner join for speed, etc ). We also use scopes to make code more readable when it is used. This takes code that used to look like $objs = myObj::model()-&gt;with('table1', 'table2', 'table3', 'etc')-&gt;together()-&gt;find('myfield = :myfield', array(':myfield' =&gt; $myval) ); now looks like this $objs = myView::model()-&gt;withMyField($myval)-&gt;findAll(); What happens is this: once you start relying on the validation and tying behaviors to your models, you start to get more and more value from (almost) always using models for database access. With behaviors, you can tie into events in your objects on the fly without actually adding any code to your object. This lets you do things like build in an audit trail logger, make a remote api call when something is updated, push to your caches instead of pulling to them, etc, all with tiny amounts of code. Additionally, Yii's caching is really robust. After a few programs, you start to really rethink the way you build. My advice would be to start working on your back end management tools in Yii (nothing client side yet!!!). As you build them out, you will get past the initial learning curve and start seeing how you can do things easier on the stuff that is not client facing. If you plan your structure out well, you will also have a bunch of stuff that you can reuse (behaviors, caching, logging, custom ). Lemme know if any details about this stuff would help you make a decision. I can also make some pretty good "best practice" recommendations for your layout if you ever decide to use Yii and want to PM me for them. It seems like posting specific architecture issues online might be a bad idea.
This is also known as a fluent interface. Edit: Typo! cheers footle
Argh... Sounds awesome. I think I looked at that for about 2 minutes. I'll look again. I really think I should rebuild, but maybe Lithium would be a good stop-gap.
I heard Symfony is fairly slow compared to Yii or Kohana (my site on straight PHP can sometimes get bogged down--users tend to log in simultaneously and with heavy data use). I also heard that it's pretty restrictive in how you can use it. Not true?
Someone else suggested Lithium. I'll look at these too. Thanks.
Creating views is something I've thought of, but have never done since all my queries are hand-built and I'm the only one touching the code. I love the idea, though. Thanks for the PM offer. I'll probably take you up on it early next week.
This approach breaks Encapsulation quite horrifically. You should avoid at all costs.
Honestly, I doubt learning what you were trying to teach me was worth having to communicate with you anyway.
Indeed it restricts it to _row (or whatever private property you set). I prefer this method as it allows me to not have to worry about the naming convention of the incoming data, so publicly I can access the data coming in and not have to worry about overwriting private\protected properties. Still don't see whats so difficult about a single get method, always found magic methods to be extremely easy to utilize from beginning to end. Luckily though PHP is one of those there's more than one way to do things, so to each there own.
That's the attitude that's left you needing such rudimentary help.
NEVER EVER use or die(mysql_error()); /slaps hand
no, its worse than nothing. it clearly defines your database to anyone on the other end. generally not something you want others to have access to.
&gt; The situation is original post, derp. When I posted this answer, there was no other information other than what was provided in the original post. There was no context, so I provided a solution. &gt;&gt;&gt;A lot more code &gt;&gt;Not always &gt;Please stop attempting to generalize. You're the one generalizing here, not me. You said (or at least implied) that using magic methods requires "a lot more code," which is not *always* the case. &gt;You're just trying to look like you have a point. I do have a point; it just isn't the same as yours. Here it is: There's more than one way to solve this problem. Using magic methods is not an incorrect solution. It might not be the easiest way to do do it, *in your opinion*. It might have some cons, but for me, they are outweighed by the simplicity of using them. &gt;Why can't you get to the part where you explain why doing any of this extra work has any benefit at all? I did. "I've used magic methods to eliminate most of the getters and setters for some model classes. I've had a couple places where it's saved me 500+ lines of code." &gt;As far as harder to debug, you appear not to see the bug yet. Then instead of being condescending, please tell me what "the bug" is. That way, I'll learn something new so that I don't make mistakes in the future. I would much rather be wrong once now than be wrong a hundred more times in the future. **Edit**: since elsewhere in this post, you've seemed to be concerned about the "downvote game." I noticed that your above post got downvoted. I didn't do it. In fact, here's an upvote in the hope that you'll teach me something useful.
Speed wise, Symfony 2 especially is supposed to be awesomely fast. Symfony (1.2 through 1.4) I've never had any speed problems with although I've not tried Yii and have heard its quick but I obviously can't give you a relative "it's quicker or slower". Restrictive wise... well I think that discussion basically comes up when people look at it from the perspective of say Zend or something: - In Zend you can include as little or as much of the framework as you need to use, Symfony comes as one big lump that you use whatever you use of (the rest of it then just being spurious files but it's not like they get in the way or slow anything down). As for usage restrictions from a 'what you can build with it' perspective... There's no issue there AFAICS
Also, (to go against my initial weighing in too much statement). If you look at Symfony 1.4 with sfGuard plugin (I've just overriden all the login/auth stuff to use my own methods on a second db connection for a project i'm working on) You've got a user login system with roles and groups and an MVC framework with inbuilt unit testing and support for multiple db connections. Also the inbuilt form processing (once you get your head round it) provides great extension for validation etc (and plugins like sfAjaxFormValidationPlugin will automatically take you php validation and check it frontend). As for CRUD if you look at the ORM options and admin generator(http://www.symfony-project.org/screencast/admin-generator) then you can probably generate a hell of a lot of code and forms and save yourself a load of time. Anyway there's an example of a site build here: http://www.symfony-project.org/jobeet/1_4/Doctrine/en/ and some other relevant links here:(http://www.symfony-project.org/plugins/sfGuardPlugin http://www.symfony-project.org/plugins/sfAjaxFormValidationPlugin
Using two-way encryption *on passwords* is something short of insanity. Also, all modern PHP versions have cryptography and modern hashing functions available. There should be no need to fall back to MySQL nowadays.
Not really, I was merely asking you what you were referring to. If I want help I can go to the vast majority of people who aren't jerks.
&gt; Are you suggesting that five magic methods glued into place by an object system which was replaced last major and is getting replaced next major is more elegant than a one-liner imperative function? Well, the beauty of inheritance is that if the magic methods get replaced next major, you only have to re-code in one place :)
More name calling while acting like the victim, please. The point you're missing is that your attitude is why you didn't get an answer, and as such, *why* *you* *had* *to* *ask* *a* *question* *like* *that*. It doesn't matter what you think of the other person. In other news, when you repeatedly insult someone else, they don't actually care whether you think they're a jerk.
And you get the same wrong answer again. It's pretty pathetic that in one thread you're asking to end conversations, while in another you're butting into conversations had with third parties.
&gt; &gt; The situation is original post, derp. &gt; When I posted this answer, there was no other information other than what was provided in the original post So, the reason you provided an answer that ignored the superior answer in the original post was ... that the original post was all there was. Got it. &gt; You're the one generalizing here, not me. I'm not interested in "no you." Go away. &gt; Using magic methods is not an incorrect solution. I don't know why you keep making this mistake. At no point have I said that using magic methods is an incorrect solution. I have repeatedly very carefully pointed out that I'm saying your solution is incorrect, *and* *not* *because* *of* *the* *magic*. The multiply and divide example wasn't very complicated. &gt; I did. "I've used magic methods to eliminate most of the getters and setters for some model classes. I've had a couple places where it's saved me 500+ lines of code." This is the generalization you keep pretending you're not making. Just because it was a good idea somewhere else doesn't mean it's a good idea here. I've lost interest. &gt; In fact, here's an upvote in the hope that you'll teach me something useful. You're not reading what I'm saying, in favor of reading what you'd like to see. I can't teach when my words aren't read, nor can I teach to someone who refuses to look at the current situation in favor of handwaves at other abstract situations. Best of luck.
It's a free internet.
I like beef jerky.
How so? Isn't this: $instance = new Class(); $instance-&gt;method1(); $instance-&gt;method2(); The same as: $instance = new Class(); $instance-&gt;method1()-&gt;method2(); It's really just shorthand, isn't it?
I know you're not talking about magic methods being inherently wrong. I understand that you're saying the wrong tools for this situation. I don't necessarily disagree. All I did was offer OP a different way to approach the situation. &gt;So, the reason you provided an answer that ignored the superior answer in the original post was ... that the original post was all there was. The reason I ignored the "superior answer" in the original post is that I'm sure that's not OP's entire program. In some contexts, magic would work just fine. Yes, I recognize that's a generalization, but six lines of code is hardly enough context to come up with an answer that isn't generalized. If using magic saves OP from having to write and maintain 500 lines of code, then he should use it. However, given the added context (which, I admit I hadn't gotten around to reading until just now), I concede that the original code (and your simplified version) is probably the best. &gt;As far as harder to debug, you appear not to see the bug yet. I'm still not clear on what you meant by this. I'm not asking you to explain it again, in case you already have. Maybe just quote or provide a link.
CakePHP is great too, Lithium is the updated Cake 3.0. The problem right now with Lithium is model relations are not yet supported. I"ve been using Cake for a long, long time, it's great. You can also look at something like Zend which is great to patch things together (use what you want), or Kohana. I've also used flourish, a PHP "unframework". But I really dig Cake, probably because I've worked with it so much as well
Actually, both sites belong to the same guy. He uses the first one as a pass-through so he can double his ad-revenue. You'll see he spams geekword.com as well, although not as often.
put it in a class
Instead of `$obj-&gt;f1()-&gt;f2()`, you want something like `$obj&amp;&gt;f1()&amp;&gt;f2()`?
Good point. I think I did slip into a bit of insanity when I wrote that.
 function sortMultiDimensionalArray($array, $key) { $tmp = array(); foreach($array as &amp;$item) { $tmp[] = &amp;$item[$key]; } array_multisort($tmp, $array); return $array; }
Yes, it's free enough for you to be a pathetic hypocrite who's desperate for attention.
&gt; Yes, I recognize that's a generalization, but six lines of code is hardly enough context to come up with an answer that isn't generalized. If using magic saves OP from having to write and maintain 500 lines of code, then he should use it. If you look more carefully at OP's post, you'll discover that the context is well enough known to exclude this concretely &gt; I'm not asking you to explain it again, in case you already have. I haven't, in order to make a point: for everyone's talk of how simple and easy magic methods make things, the implementation provided has a significant defect, and nobody but me seems to be able to see it. I have a test case which displays the fault. Please try to find it. You'll learn something about the dangers of magic in so doing.
&gt; "PHP has the navel gazing fake experts worse than most of the other proggit and proggit-related reddits I'm in, admittedly." Yep. Not sure why I even come back to r/php. I stop in every few days when I get some time at work hoping it will have someone miraculously transformed from a festering pool of idiocy into something vaguely resembling an intelligent discussion but I'm continually disappointed. &gt; "Admittedly, because of PHP's ease of use and pervasiveness, in combination with the bulk of bad tutorials out there for it, the bottom of PHP's barrel tends to be fairly low." Hence my annoyance at the 'experts' around here continuing with their incorrect bullshit. &gt; "But the fun kind, from people who aren't completely idiotic, I hope." The banter is often idiotic, the people are not. The distinction is subtle.
I haven't given it much thought, personally. I imagine it should be easy to type and also make some intuitive sense. Most importantly, it should address all of the tedium that chaining is supposed to eliminate; the current way does not. For example chaining right after new() or setting public properties or using methods that don't return $this. Inventing something like this would require some serious thought and time. A resource I don't have at the moment.
Is it something to do with this? $p = new PropertyTest(); $p-&gt;array['key'] = "value"; That code causes a notice (indirect modification of overloaded property). I can definitely see how that unexpected behavior could be a problem. Not sure if that's what you wanted me to find though.
I use that for reference. The class reference is great, however, the user guide is terrible. It contains about 30% of the capabilities of Kohana and is only to get you started. For me, it doesn't matter as I have expereience, but for beginners, lack of documentation &amp; support will destroy the whole MVC / OOP programming paradigm.
That's not safe, but it isn't the incorrect result I found, no.
&gt; The banter is often idiotic, the people are not. The distinction is subtle. Agreed. I now officially like you.
No, this calls method2 on the object that method1 returns. Works only if method1 returns a reference to its parent object. Breaks when you need to return something useful.
I think this would work nicely: $obj-&gt;{ method1(); method2(); }
For chaining after new, they would need to make valid something like `$obj = (new Stuff($a,$b))-&gt;f($c)`, or it can be done now with static constructors: `$obj = Stuff::create($a,$b)-&gt;f($c)`
The Jobeet tutorial is fucking fantastic.
I love how he posted his API key in the code examples: 6c16562376f47eb3e9ffabc01742f02ebd5ef1d3c46ec5e09962c3d9ebf4f66b
In any case, you've made your point. I, for one, will certainly be more discriminate about when and where I use magic in the future. I don't have the time to debug that example all day, so I would appreciate it if you'd share the fault you found. I do understand the purpose in asking me to find it myself; finding it yourself is a much better learning experience. If you don't want to spoil it for everybody else, you can send me a PM.
&gt; Not the behaviors I referred to. Whatever you think you were talking about must not actually be a behavior, perhaps instead it's just your hallucination - or rather a delusion. Judging by your inability to read or compose coherent sentences, delusion is the most likely culprit. &gt; The difference being I'm not failing to justify the increased work and decreased correctness I'm advocating. No, the difference being that you love to excoriate the behavior of others whilst consistently indulging in the same behavior yourself. There is a word for that in the dictionary, it's called being a [hypocrite](http://dictionary.reference.com/browse/hypocrite). &gt; but this has nothing to do with understanding the object model Are you seriously going to accuse me of changing the subject? Now, I really hope someone discovers the center of the universe soon, and therein proving without a doubt that everything does *not* in-fact revolve around you. Should you then have trouble rationalizing your pathology, remember that it's okay. You can compensate by being more of a truculent bore. &gt;You tried to implement something to save someone hassle. Your new one is more work, more hassle, and has a bug you don't seem to see. Redundant much? Are you seriously going to complain about overhead, in PHP of all things? Hah! &gt; Here's a thought Did it hurt? &gt; words you can't even spell lam·baste - to reprimand or berate harshly; censure; excoriate. &gt; &gt; while you comfortably declare the necessity of simplicity from behind the wall of wide-spread acceptance and popular adoption &gt; What? I apologize for using words with more than 2 syllables. I'll try and keep it on your level from now on. &gt; put down the thesaurus Nevermind. You obviously think it's cool to be stupid, and there is a [word for that too](http://dictionary.reference.com/browse/antiintellectual). &gt; You really just can't cope with the question you were actually asked, can you? Here's a thought: when you're whining about the fact that no one is indulging your curiosity, it's definitely a good idea to insult them incessantly. Insulting someone will almost certainly provoke a response. After you garner their attention, don't forget to punch them a few times in the face just for good measure. This may then make it possible to initiate an actual conversation. This, however, is not a conversation. 
Just throwing this out there (don't want to get dragged into this argument), but you've now destroyed the ability you would have had to iterate over the class, use reflection and a half a dozen other things that the simple, straight-forward solution originally posed would have supported. Don't get me wrong, I've used (and abused) magic methods to the point where I'm sure there's a special circle of hell reserved just for me, but only when there was no other option that I knew of. (Adding methods to a class at runtime, for instance.) They're "cool" and "shiny", but are really just not appropriate in this situation. Especially, as StoneCypher has mentioned, when you take into account the additional overhead you now have to consider every time you use the class. A simple: foreach ($array_of_objects as $object) { if ($object-&gt;Property==1) { // Code } } Is now a much more expensive operation - and the programmer using it likely doesn't even realize it. When in doubt, always take the [route that involves the least astonishment](http://en.wikipedia.org/wiki/Principle_of_least_astonishment).
I see where you're going with that... Kinda like JavaScript's "with", right?
To save you potential embarrassment when talking to other programmers, I think you should know that it's actually a "fluent" interface, not "flaunt" :-)
Yea, something like that, but ruminating deeper on it, it doesnt seem like the little 'temporary namespace' would be able to distinguish between php functions, user global functions and class methods. I still think method chaining is stupid, just man up and do it the normal way, if you have that much trouble typing the object name out then you're using names that are too long.
I don't see anything wrong with that personally. If a method needs to return something 'useful', then that's fine. If it would otherwise return 'void', then returning $this seems pretty reasonable. I quite often find that when I hit a method that returns something 'useful', it's tends to be the last one in the chain anyway. For example, in an imaginary DB abstraction: $result = $db-&gt;prepare('select name from people where id = :id') -&gt;bind(':id', $_GET['id']) -&gt;execute(); The only method in the chain that returns something I want is the execute function. IMO, saying it's broken because it depends on what the method returns is pretty much saying that all methods are broken. 
Out of interest, is it object dereferencing in general you do not like, or just when it's used with $this being returned? 
Its not broken, it can be made to work. It breaks consistency. How are you supposed to communicate which methods are chainable? Edit: The only way I see around this is to define a property "return" and have the method write to that when you need the result, just tack on -&gt;return. I think its stupid but if you must, its an idea.
Perhaps people do need to man up a bit. I personally don't mind method chaining, but each to his own. Out of interest, what if the methods return an object other than $this? Are you again method chaining then, or would you rather assign the result to a variable and then call the method on it, despite its potential 'use once' nature?
IMHO that would be acceptable, but remember if you dont toss that returned object into a variable its going to be garbage collected as soon as the method you called on it runs out. Not very useful unless you're sending yourself to side effect hell.
The same way you communicate the return type/value of every other function in PHP; other than having people read the code; you don't. Let's say you're not returning $this, but another object; maybe the method is a factory of some sort. You have two choices when it comes to calling a method on that returned object: you can either assign it to use-once variable: $object = $factory-&gt;createObject(); $result = $object-&gt;someMethod(); Or "chain" it with object dereferencing: $result = $factory-&gt;createObject()-&gt;someMethod(); I didn't have to have any extra information about what was being returned from createObject() in order to write the second bit of code; nothing needed to be 'communicated' that I didn't already need to know to write the first solution. **EDIT:** to respond you your edit, my main point is that if you want to access the return value from something, don't use method chaining on that method. Not all methods have a useful return value; e.g. property setters. When you're writing methods that would otherwise return void, why not return $this so you can chain the methods if you want to?
If it was something I was only going to use once then that would be exactly what I would want to happen; get rid of it instead of having it sit there doing nothing but taking up memory :-)
Yea, but why would you use an object for this?
Can't go wrong with Zend in my opinion.
The method I'm calling on the return object may do something relatively complicated that could do with being modularised, and it's useful for that method to have access to (protected) helper methods. I'll give a real-world example... I've worked on a code-base that had a split model layer. i.e. there were "dumb" objects that had setters (with validation) and getters for its various properties, and then "gateway" objects that contained logic for doing CRUD stuff with these dumb objects. It was split that way so multiple gateway objects could be used to create the same dumb objects; e.g. one that used a database, one that produced mocks, one that used a remote http API etc - without repeating the validation rules etc. The gateway objects were created / accessed with a factory so that the dependencies (access to the database etc) were abstracted away. Each gateway had multiple 'find' methods used for fetching the dumb objects; getById, getByUsername and all that kind of thing. Those 'getBy' functions would use shared/common helper functions for producing the bulk of the queries they used etc. A common thing to do was along the lines of: $user = $factory-&gt;user()-&gt;getById(1337); or: $user = $factory-&gt;user()-&gt;getByUsername('footle'); The 'users' gateway is no-longer needed once I've fetched the user I wanted. If I was going to use it a bunch of times I would have assigned it to a variable instead of just chaining the 'getBy' functions on the end; but there's no reason for that gateway to hang around taking up memory once I've used it - and the alternative would be to do: $user_gateway = $factory-&gt;user(); $user = $user_gateway-&gt;getById(1337); unset($user_gateway); I hope that's not too much of a big example; but I can assure you that it's actually a really nice system to work with.
I'm okay with returning $this as long as it makes sense. Function/method return values exist so that the caller can glean something meaningful from the result, whether that be a computed value or an error code or what have you. But when you return $this *not* for any programmatic benefit but rather just to spare you from typing, then my warning bells go off.
Just use array_flip(), man. &lt;?php $arr = array('a', 'b', 'c'); $arr2 = array('b', 'c', 'd'); var_dump( array_flip(array_intersect_key(array_flip($arr), array_flip($arr2))) ); 
That's fair enough; and an interesting point of view. So, you'd be OK with returning an object other than $this and "chaining" method calls on to the end of that?
&gt; perhaps instead it's just your hallucination Right. You're not telling me what I meant. It's just that when I say that the thing you're claiming I meant isn't correct, I'm hallucinating. Get lost please. I'm not interested in amateur hour at the thesaurist's poetry slam.
That jobs a memory from Pascal programming in the '80s. The "with" statement kind of sets the context within a a block so all the operations act in that context. It was handy. I would love something like this for CSS too, so long runs of related style selectors could be combined into sets all within the context of a higher-level selector: .myBlockClass .myWidgetClass { .next {styles ...} .prev {styles ...} .other {styles ...} } Sorry - bit off-topic, but this thread kind of reminded me of what I have been thinking about for a while. Perhaps I'll write a pre-preprocessor for this syntax one day... The idea is to keep it simple for the programmer to write and for the maintainer to read, understand and change.
Yes, yes that's exactly it. Time to change my ways.
Nice ACL (various source for the permission data), everything can be customized but does not have to be, tons of documentation and community support, existing integration with most other popular related software (e.g. Doctrine as ORM), build-in caching solution (including e.g. mock driver for your tests).
Thats cleaner than array_fill_keys, but still not exactly what im looking for. Thanks for the improvement.
Well, perhaps elaborate some more on what you're looking for?
Exactly what my functions do, I was hoping it was built into PHP. I'm just being a minimalist, but there *are* functions for sunrise and sunset times...
I mean, I get what your functions are doing, but what are you hoping to achieve by doing this? There may be a better way to accomplish your task.
&gt; OK with returning an object other than $this and "chaining" method calls on to the end of that? Sure as long as it makes sense, for example: echo $myobject-&gt;getRobot('J5')-&gt;killAllHumans(); Pretty easy to figure out what's going on there. But consider a first-object centric method chaining example: $myobject-&gt;setRobot('J5')-&gt;onRobot('J4')-&gt;print(); You've not only just passed back 3 redundant references to the same known object on the call stack but you're not being very clear semantically. Pretend you don't realize right away that these methods return $this. What's printing at the end there? Are you printing the robot? Which robot? Or the object? Well, we know you're printing the object, yet the actual code suggests a different context. It's awkward to say the least. But like I've stated already, the heart of the problem is that you're modifying the program to fix the language which should at least strike you as questionable practice.
Needed a quick way to take only certain keys, or the opposite, from an array.
The best you're going to be able to achieve without using a separate data structure is O(n) where n is the size of the key array. Either your method or mine is going to run in worse-than-linear time, so you probably should just iterate: function getCertainKeys($arrayOfKeys, $targetArray) { $newArray = array(); foreach($arrayOfKeys as $k) { if(isset($targetArray[$k])) { $newArray[$k] = $targetArray[$k]; } } return $newArr; } function getAllButCertainKeys($arrayOfKeys, $targetArray) { foreach($arrayOfKeys as $k) { unset($targetArray[$k]); } return $targetArray; } edit: as a side note, your function names are more ambiguous than necessary.
It's not an improvement. array_flip() is more costly than array_fill_keys(). Not only that but you're calling it three times, compared to just one call to array_fill_keys().
I think I can just replace the array_fill_keys statement with the array_flip statement.
I don't see why I should iterate.
Actually wait, I still stand by it. You're right - two-way encrypting a password is morally wrong. But, (and this could be the insanity or drunkenness talking): 1) if PHP _isn't_ your defacto getter and setter of sensitive fields, passwords or otherwise, (ie you have script or applications based on other languages or platforms working the same tables - think ms access, db admin apps, etc), then you might be pretty much stuck with having Mysql as the middle-man with its own encrypting/hashing functions. Most of the time, other platforms or languages share the same encryption/hashing methods, sometimes not. Folks need not worry though if their database is only there to serve their PHP scripts, and for most websites, this point is just noise. 2) hashing a password alone provides little protection against users with crappy or common passwords. A cracking dictionary would probably have `81dc9bdb52d04dc20036dbd8313ed055 = md5('1234')` at the top of the list. Hashing a combined string of `password` and some other random bits is usually fine alone, except when it's not: when your login, password changing, or new user script is stolen along with your password table. That script shows quite clearly the process used to use, hash or encrypt any sensitive value (`$h = $p + $x`). 3) "Hashing" implies creating a small thumbprint of a value to ensure `$v === $v` from original source to destination during transport, but not obfuscating it. But I guess in terms of password storage, it all depends on different interpretations of the word.
Isn't he saying why in the post you commented on here?
&gt;Either your method or mine is going to run in worse-than-linear time, so you probably should just iterate: not a very compelling argument.
Timing... `$array = array_fill_keys(range(0,100), null);` vs. `$array = array_flip(range(0,100));` You're right - `array_flip()` takes on average about 10-15% longer.
Cool. I'll check out flourish.
Thanks for the tips. I'll check it out.
Ok, so you want to do something like this but cleaner and not having to deal with `array_key_exists` check on every included key... `$arrayExtract = array(0 =&gt; $array[0], 99 =&gt; $array[99], 234 =&gt; $array[234]);` No such short function exists that I'm aware of. I think you already have the best and shortest alternative going, even when competing against any of the callback filter or comparison functions. The actual better and less costly method is to not wrap this in a custom function at all... `$arrayExtract = array_intersect_key($array, array_fill_keys($keys, null));` 
I'll check up on Symfony versions regarding speed. I've seen a few benchmarks, but don't know what version they were comparing.
How is that not a compelling argument? An iteration is O(n) so just use an iteration.
I believe my code implies iteration without leaving me to deal with its details. If the most efficient way is so simple, then why would array_intersect_keys not use it?
Okay you're saying it's wrong but then you defend it, wtf? &gt; if PHP isn't your defacto getter and setter of sensitive fields This is /r/PHP, so for the OP it is most certainly. &gt; hashing a password alone provides little protection against users with crappy or common passwords Correct, this is where proper salting comes in. Even with salting, this isn't the developers fault or a fault of the technology, this is human error. You should **not** be using encryption to store passwords. End of story.
Defend what? I don't think you read me right. &gt; This is /r/PHP, so for the OP it is most certainly. Which is why I admitted my mysql encrypt/hash comment was just noise. &gt; You should not be using encryption to store passwords. I think we already settled that, and I already moved on to the possibility that hashing or encrypting is actually almost pointless if the cracker has a hold of your script. Edit: maybe I better just drop off for tonight. Drinking and programming don't mix.
&gt; and I already moved on to the possibility that hashing or encrypting is actually almost pointless if the cracker has a hold of your script. Encrypting yes hashing no. Hashing is one-way (you already know this) so you can't take a hash and reverse it, and using proper salts and a strong hashing algorithm makes rainbow tables practically useless and unfeasible.
The difference is your functions that use the built in run much worse than O(n), given that: * array_intersect_key runs in O(n) where n is the length of the first supplied array (plus the length of any array where its arg value &lt; total_args - 1) * array_diff_key runs in the same polynomial time as array_intersect_key * array_fill_keys runs in O(n) where n is the number of keys to fill * array_flip runs in O(n) So, these functions: function distill($array, $keys) { return array_intersect_key( $array, array_flip($keys) ); } function distill($array, $keys) { return array_intersect_key( $array, array_fill_keys( $keys, NULL ) ); } Has to run O(n) on keys twice, meaning it runs in O(2n). These functions: function antidistill($array, $keys) { return array_diff_key( $array, array_flip($keys) ); } function antidistill($array, $keys) { return array_diff_key( $array, array_fill_keys( $keys, NULL ) ); Runs in the same polynomial time (O(2n)) because array_diff_key having the same polynomial time as array_intersect_key. So, the compelling argument is that your supplied solution runs in O(2n) while the other, more explicit method runs in O(n). The source for those functions, if you want to verify, is [here](http://codepad.org/6RuuAEkN). 
I disagree, I think it concisely outlines the majority of what Kohana has to offer. If you have been using Kohana for any length of time, you'd know that these Docs are by far the best there have even been. The user can clearly see how Kohana implements (H)MVC, and it is up to them from there to use the building blocks. So I am not sure whether you were referring to the Kohana 2 documentation when you made your initial comment. Since the new docs are definitely **not terrible**.
its working, isnt it? ;)
Just to be pedantic, O(n) and O(2n) are the same thing. If you're using that as a point of efficiency, then there is no point.
add depth limit ;)
&gt;The best solution IMO is to encourage the PHP guys to give some thought to putting in a native method chaining operator The best way to do this is to encourage articles like this. But I think you over simplify things. It's not about adding an operator, it far more intrinsic to the language. PHP's version of references should be adequate to demonstrate this.
&gt;ruminating deeper ruminating means think deeper I say this not to be a dick, but to tell everyone not to be a dick. Just fucking say "thought deeper" instead of "ruminated deeply" and two things will happen: you won't sound pretentious and we won't be confused.
Symfony 2 will be out in a month (I think), have a play around with that (it's reaso stable atm). They are focussed on performance (just reading other replies) so you should have no issue there. And it is very flexible. They lazy load so the size is not an issue, you can use any combination of ORM to pure SQL you want. I'm still evaluating, but just to reply in order to your bullets: * yes, auth is built in, use it with a bundle or create your own * yes * yes, just inject whatever you need into the templates, hard to get this wrong tbh * yes, aside from front controllers requiring controllers you can do whatever * it is, to a certain extent, it is a bit of a different way of thinking though (eg doctrine 2 v 1) * no worries, as mentioned, you can just query shit if you want * 5.3 required * this is built in, just a matter of specing different db's and requesting them * Supposedly their goal (yet to see anything that says they do worse than others) * built in, not only unit, but functional (comes with a crawler etc) * views are pretty flexible, learning curve may be a bit steep * same, but I've ended up with symfony hth
&gt;unpredictable I keep seeing crypt (php) and every time I open the man this is all I see.
That is indeed an easy approche to cache but it will fail when the page is a dynamic website that allows users to log in and personalize the site look &amp; feel. Could be handy for blogs (from the viewers perspective) as it passes through the POST requests. But then again, comments for example would not appear for the cache life time.
The entire point of this method is exactly to make comments appear immediately. There is no cache life time really. Everything is cached until it is manually invalidated or it slips off of the LRU list. The sample application included will serve cached pages but make comments appear instantly when they are submitted.
My operator comment was a little hasty. At the end of the day it may turn out that there's just no good way to do method chaining at the syntax level, but I don't think that gives the green light to go ahead and fudge it via code.
Thanks for your detailed answer. I did see the release is coming up. I'll probably play with both.
array_flip() has to ensure that pre-flipped values are numeric or string type and resolve duplicates before allocating and copying which is what probably eats up the clock cycles. 
The app will make the comments appear to the poster, as it passes the POST request to the backend, yes - but will it also immediately show the new comments to other visitors?
Yes. That's exactly the problem I wanted to tackle. Whenever a comment is posted the library calls the cache invalidate method of the cache tracker. The cache tracker does a look up and finds all the controllers that relies on this data and allows those controllers to specify which cache keys this data is under. That way the application knows which cached pages to invalidate so next time they're visited they'll be regenerated with their new data. The whole point of this method is to avoid showing stale data.
Oh, I see now - that part is handled by the backend / PHP not the Nginx configuration. Need to pay more attention :)
yii doesn't support multiple db connections out of the box. also, yii does not support optimistic concurrency control, if that's important to you. otherwise, it is great, but you'll probably want to borrow some code from zend or cake (like lucene and some of cake's nice functions like date formatting)
Strictly speaking, yeah they're the same and this was an academic setting, I'd never have said what I did. However, when I'm using polynomial time as a factor in deciding one of many algorithms to use in actual production code, I tend to leave the coefficients in place. Example: You've got the the choice between two algorithms - one runs in O(n) and one runs in O(n^2 ). The obvious choice is usually the one that runs in O(n), but if I had left the coefficients on and it turned out that O(n) was really O(10000n) and you know you're never going to have 10,000 elements - the choice isn't quite so simple any more. Another Example: You need to speed up a web application you developed, as it's taking way too long to render pages to clients and they're complaining. So, you've profiled your code and noticed that the method foo() is eating 80% of your program's running time. You analyze it and come to the conclusion that it's running in O(logn) and give up, the only other solution you can create running in O(n). You leave the coefficients on, however, and find that your original solution runs in O(100logn) and your alternate solution runs in O(2n). Now, the choice is a lot clearer that your alternate solution might be faster, if your set size is small enough - so you do some more profiling and find that it is, so you switch algorithms. tl;dr: I play loose and hard with academic rules like that when following them can be ambiguous and potentially make me make the wrong decision.
The framework in a zip file is a bit of a hassle to download and browse. Why don't you put it up on GitHub or someplace similar, especially if you intend to make it open-source? Invalidating cache keys on update is very clever, and it would probably work well for blog-like sites where visitors can post comments anonymously. But how well would full-page caching work in a site where a large percentage of users are logged in, such as Reddit? One solution would be to load the cached page first, and load user-specific content with AJAX. But then you're hitting PHP anyway with every page view, and a lot of the performance/scalability benefits of full-page caching might be lost. It might not be that much faster compared to caching the various components of a page and assembling them with PHP. 
Yeah, as I mention in the limitations section it's difficult to cache full pages when there is something user specific on them. It's not impossible, though, ESI allows you to cache the full page and fill in specific areas from other sources. You don't necessarily need to have PHP generate those areas either, with Nginx you can have something like Lua + pgsql or mysql generate it. As for Github, at this point I'm not sure what I want to do with the code. Right now it's on a limited commercial use license but it's fairly useless in its current state as there aren't any modules with it. The PHP framework market is so over-saturated and I'm not sure whether I want to actually bother releasing this code. 
 // isset, empty, is_numeric. Do not reorder. if(!isset($val)) { return false; } // handle unset vars if(empty($val)) { return false; } // not empty string, 0, “0″, false, NULL, array() if(!is_numeric($val)) { return false; } $val = floor($val); if( // Expecting a 1+ number, or return false !isset($val) || // handle unset vars empty($val) || // not empty string, 0, “0″, false, NULL, array() !is_numeric($val) ) { return false; } $val = floor($val); Both seem ok. First one seems a bit noisy, but I'm more concerned about understanding it. Both of those look pretty bad with no comments describing WHY. If you don't group them in 1 logical guard, it becomes very easy to split the logic. I would want to, at least, explicitly say, this order was intentional. Code spacing is a bigger deal for me. If I have blank lines between lines of code, that usually means I simply added them as needed with only a concern as initializers or logical operations that needed to happen before following code. If guards aren't grouped, that means they just need to occur without a concern of when. Lines packed together usually means the code is related and I try to describe why they are done that way to ensure nobody tries to split it up. Generally code that has a need for a certain order of operations to be followed can be factored into a function, but not always...here's how I would do this one. // Now that it's in a function, I dont care if you want to do the first example style or second function numeric_gt_0($val){ // Did second style if( // Expecting a 1+ number, or return false !isset($val) || // handle unset vars empty($val) || // not empty string, 0, “0?, false, NULL, array() !is_numeric($val) ) { return false; } return true; } if(!numeric_gt_0(&amp;$val)){ return false; } $val = floor($val); 
&gt; But how well would full-page caching work in a site where a large percentage of users are logged in, such as Reddit? The problem is not really that the users are logged in (you'll get around most of that with per user caches for particular elements through ESI), but that each users frontpage is custom tailored to just that person.
Either of those two would work, and neither is wrong. Using imagepng() just results in a PNG being made, while imagejpeg() makes a JPG. You can output different formats from your input.
The GD image resource returned by imagecreatefromjpeg() is format-agnostic. It's just a bitmap at that point, and you can write it out again in any format you want.
no you are wrong. the example is outputting a png. it is irrelevant that the the main image is a jpeg as 'imagepng' output the resulting resource as a png.
I had to look up "optimistic concurrency control". I thought Yii just extended PDO. I thought table locking was related to InnoDB vs MyISAM. I just started learning about transaction sets (I'm not sure what they're called). This is a fascinating concept (optimistic concurrency control). If you can tell me more about how you use this and how this is limited by frameworks or databases, that would be great. I don't know if I'll use Yii's DB layer. I'm in the middle of finishing up my own DB class. I already have all the queries written out, so there's no need to de-optimize my queries by FindByPk or something. It's really fun to think of borrowing classes or functions from different frameworks. I just looked up lucene and it seems to be a search class. Why do you like lucene? What other things have you borrowed from other frameworks? Which framework (if any in particular) do you like/use?
The only small thing to fault is that HTTP headers are ucfirst()'d so it should be Content-Type. But I doubt browsers will care.
you want to use a .png for the transparency?
i read a value from a table: select company_name from table1 where id=1 [save company_name to $old_company_name] someone else reads it too: select company_name from table1 where id=1 they update it in the meantime: update table1 set company_name='acme' where id=1 and then I update it: update table1 set company_name='globocorp' where id=1 and the acme guy wonders what happens to acme with optimistic concurrency control, you can do this instead: update table1 set company_name='globocorp' where id=1 and company_name='$old_company_name' if nothing was updated you can warn the user that someone changed the record while you were editing it. regarding lucene, it's a very good free text engine, that can be used with databases. if you have lots of documents, lucene is very good at searching them. check out the docs online
Thanks a lot.
Thanks
Thanks
Thanks! That's pretty nice that some frameworks do this automatically. I do have issues with people overwriting each other's data. I think you just helped me solve that one.
At least as of 5.3, PHP automatically corrects the case of certain headers, Content-Type included.
this is good stuff.. I like seeing others bringing scalable PHP-based stuff to the masses. &gt;Right now it's on a limited commercial use license if you could find a big user-generated content website that has scalability problems and does like a billion pageviews a month, I bet you could get a pretty sweet licensing deal going. I'll keep my eyes open. &amp;#3232;\_&amp;#3232; 
Yeah, that somehow doesn't surprise me.
Thing is it'd require a pretty heavy rewrite of their code so I doubt anyone would use this for a currently running project. I could see this being used in new projects if I start adding modules to it, but I'm always bored with such tasks. :)
silverstripe/sapphire is a good cms/mvc framework combination that will do everything you mention 
Configuring varnish and properly tagging what content to cache and for how long is probably a more flexible approach, IMHO. It avoid lots of the listed limitations.
How does that avoid stale data?
(Reddit 504'd on my orig reply, replying with the tl/dr from memory:) Good point, the common way is to output a Cache-Control header with a TTL (cache expiry) you can live with. Then optionally you'd issue HTTP PURGE to varnish to expire pages that have been updated. Not ideal, but you can get from 400 req/s for a PHP cached page to about 10k req/s just by adding: header("Cache-Control: max-age=3600, must-revalidate, public'); http://www.varnish-cache.org/docs/2.1/tutorial/increasing_your_hitrate.html
TTL based caching was exactly what I wanted to avoid. To me it's not acceptable to have stale data for however long you cache, at least not if it can be avoided. Varnish can cache just fine but it does not know enough about your application to smartly invalidate the cache at the instant of data change. The only way you can achieve that is by having the application do the invalidation, and for that you still need a method to track the data - which is the entire goal here.
Ah well, a case of which trade offs to prioritize.
I don't really see what trade off there is. You have to program in a specific way to ensure you can invalidate data but it's not time consuming, just something you have to do from the get go. I'm not saying I'd convert current projects that work fine, but whenever I start a new project these days I always do it without TTL caching.
Not sure what you need, is it a pre-built solution or some pointers about how to code it?
Great site, will use! I'm willing to translate into Swedish. Drop me the language file!
What I need is data. If there's a web service that provides them I can consumer, or a database I can get or buy. I can code the thing, I just have no idea where to get the data.
All of the ticketing agencies I've worked with have used proprietary systems and each was different.
But where did they get their basic data from? They didn't compile lists of venues and create seating charts?
Ah ok. Well I doubt there's going to be a simple one-stop solution to this. Most venues sell their own tickets or outsource the job to specialist agencies. I know seetickets have a fairly good reseller/affiliate program where you can feature concerts on a webpage, this works with a couple of calls to their API. Also last.fm has a fairly decent events database (http://www.last.fm/api/show?service=292) There's also Eventful, which try to do a similar thing. http://api.eventful.com/ Hope that helps.
Many Thanks. I have plenty of feeds for affiliate programs, mostly through CJ. My problem is in standardizing across a variety of feeds. For that I need to begin with Venues and Events, after which I can match my feeds to Event and Venue objects. I believe eventful will help quite a lot.
Nothing that I would have been given access to. It's usually a ticketing service that provides an online and box office ticket management application that is customized for the venue. Seating charts are handled by a the venue in a static format or they are part of the ticketing application. There's probably a really big one that might be able to provide a lot of venues' information. Maybe some kind of service along the lines of OpenTable but for tickets. If not there's probably a lot of money in building one.
I've googled your site a few days ago because I've needed the copy restrictions removal function. Worked great. Thanks :)
English UK? :P
thats who we use. Very easy to use
Reddit actually has horrible database design (it's getting better though).
What kind of plugin do you need? An API to be used with your web service, or a C++ plugin to patch PHP's core? Edit: FYO, your link to http://pdfpirate.com/plugins/remove_restrictions/apis/v1/remove_restrictions.html from [this page](http://community.pdfpirate.org/doc/remove_restrictions_API/) does not work.
All frameworks seem like they take too much effort - this although 'fat free' and by far the best. Still seems like too much. &lt;?php require_once 'path/to/F3.php'; F3::route('GET /','home'); function home() { echo 'Hello, world!'; } F3::run(); ?&gt; vs &lt;?php echo 'Hello World!'; ?&gt;
Theres always the last ditch solution of spidering Ticketmaster's or StubHub's website for the data. Mostly you'll only get seating chart graphics... not more specific detail like maximum occupancy etc... but hey, at least its something. 
Interesting, but ultimately destructive and misleading. [Comparing addslashes to mysql_real_escape_string](http://net-beta.net/ubench/index.php?t=addslashes2) is nonsensical, and comparing [md5 to sha1](http://net-beta.net/ubench/index.php?t=hash1) is counterproductive. [Prepared vs non-prepared statements](http://net-beta.net/ubench/index.php?t=mysql2) is downright dangerous. [urlencode vs base64_encode](http://net-beta.net/ubench/index.php?t=urlencode2) is downright absurd. These need to be properly labeled with disclaimers. Just because it's "faster" doesn't mean that it's better to use, correct to use (with regard to equivalence), or even safe to use.
owned dude
You are right that these benchmarks should not be used for making decisions solely based on their results as some comparisons indeed don't make sense. However, this site is very cool, I will definitely resort to it when I need to make a decision between two valid alternatives.
If you're using mysql_ anything you're doing something VERY FUCKING WRONG.
A lot more detail will definitely be necessary if any coder worth his salt is going to be interested.
Norwegian version translated.
Don't work with this guy. He sent me a fake Paypal payment email, to get me to continue work on his site when I said I wouldn't unless I got paid. He then blocked me on skype and I haven't heard from him since.
Care to elaborate?
Because the alternatives such as PDO or even mysqli are much better and more secure due to things like prepared statements. Escaping is such a stupid process (you could miss something, or add too many slashes), whereas with prepared statements you don't need to escape at all. MySQLi and PDO both give the option to be used as objects. PDO supports exceptions, which is a far superior way of dealing with errors than return codes. I really can't see any excuse to use the mysql_ extension for anything.
How do I interpret the results? For starters what's a hist? If its int vs intval 40hist, does that mean intval is 40hist slower or faster than int?
[This made me laugh](http://net-beta.net/ubench/index.php?t=include3). Apparently the tested operation is repeated multiple times. I wonder why include_once() 10000 times is faster :D.
"hist" appears to refer to historical measurements. The test appears to be done every time it is accessed.
I think that's a great idea and you're doing a good job. The results page could maybe use a little margin at the bottom. The second test is stuck at the bottom of the screen on FF.
If all it takes, in your mind, is to ignore everything that's said to one and to repeat one's self, then to get brushed off by the person who's tired of watching...
I'm working on a project just now, and one of the things the client asked for was for a particular page to be available as a PDF as well as web version. I see your API documentation, and it seems fairly quick and easy to use. Would there be anything to stop me using this service for commercial purposes? What are the terms? Would there be a restriction on the number of conversions I could do in an hour? Well done, excellent product!
Interesting. I just read a couple of weeks ago a PHP benchmark comparison between foreach vs. for where foreach took over 300% of the time of a for loop.
put debug_print_backtrace() inside the method that is being called twice. Let's you see where, when, and who's calling it in a hierarchy. I'd &lt;pre&gt; around it too. echo "&lt;pre style='float:left;padding:20px;width:100%;text-align:left;font-family:Consolas;'&gt;"; debug_print_backtrace(); echo "&lt;/pre&gt;";
As far as prepared statements go, the MySQL performance blog [has a few things to say](http://www.mysqlperformanceblog.com/2006/08/02/mysql-prepared-statements/) on the pros and cons.
I bookmarked this and am just now getting around to implementing your library. I changed line #38 (it's a bug regardless of your results on that particular image) and was very happy with the results. Btw, I kept the -1 in entropyCalc(), as [seen here](http://www.astro.cornell.edu/research/projects/compression/entropy.html). Thanks, groinkster. 
I was about to say that I thought they fixed the query cache problem, but then I noticed that the article is from 2006...
TicketNetwork or EventInventory, but neither are free and each cost hundreds / month.
I didn't catch that - I honestly didn't know they had fixed the query cache issue with prepared statements. Thanks!
Oh no, don't get me wrong, I only *think* they fixed the problem. Unfortunately my Google-fu is weak today, and I'm not in the mood to crawl through four and a half years of changelogs. (Anyone serious about performance on a MySQL database that's even moderately write-heavy has already disabled or severely shrunk the query cache anyway...)
Sure it is. Just look at the 3.0 to 3.1 release along with the documentation that's provided. Then spend a week or two figuring out what was left out on documentation to migrate from 3.0 to 3.1. I'm not even going to get into details about the 3.1 docs in the link you provided, just that there are broken links and pages with empty content.
tizag.com plain,simple.
Maybe the Diving Into PHP section on [this page](http://net.tutsplus.com/articles/web-roundups/who-needs-university-the-best-nettuts-screencast-training-courses/)?
I owe you a hundred beers.
Ok, we will have to disagree on the standards of the documentation, but really, it isn't terrible, that is a massive exaggeration. As well as your comment on the state if the 3.1 docs. I've been using them since the release of 3.1 and haven't had a problem. It took me less than a day to get up to speed with the API changes. It really wasn't that complicated. I'm not a kohana contributor, but an average Joe web dev. Kohana really is a great framework, and I have used it for many projects. It really pisses me off when people instantly say "the docs are shit" because their best friends dog says so. I'd admit that they aren't geared well for absolute beginner PHP devs, but if you understand MVC as a concept, you can easily work out what you need to do with kohana from the documentation they have provided, if not, well, perhaps you should give up. 
Will they let you use a framework? Or is this completely from scratch? I have a lot of code myself that covers all of the above.
Honestly? For caching you should be avoiding your SQL server altogether and using something like Memcached. I think it's worth the minor other drawbacks purely for the SQL injection protection. Pretty much every site hack I've heard of lately has been due to SQL injection, it's not something to take lightly. Sites don't generally need to be real-time unless it's something really time specific like a bidding site. If you had 200 reqs/sec, (if you script dies with less than this you have other problems), and you had your results of say, a topic list, being cached with a one second expiration in memcached (`$m-&gt;set('threads:page:1', $result, 1);` or something), you're reducing your db load by 99.5% for what, a one second delay? Memcached is fucking cool, I can handle 30,000-40,000 requests/sec for static pages on my tiny Linode 512. If you are worried about speed, use memcached. Fuck, if you want things to be instantaneous, simply have writes invalidate the cache for relevant data and cache for 60 seconds or something...
Was thinking of using an open framework such as CodeIgniter, I got pretty free hands on this project.
ALWAYS get a contract signed.
wireframe. shit even wordpress LOL. easy to mod.
Don't know how fast you can code, and code well, but one summer may not be enough time. Where exactly is this company located, anyways?
YouTube.com/phpacademy
Five or six years ago, I used this to make a web interface for Microsoft Outlook. I don't remember why. It was kind of fun, but ended up being mostly useless. Being able to parse Excel spreadsheets without third-party libraries would be nice, but since COM is only available on Windows, it defeats the purpose 9 times out of 10. Edit: good article though.
I second this suggestion. They have some great CodeIgniter (PHP Framework) and other related video tutorials if you want to start building something in PHP, too.
Is there anything along the lines of this for C++? Love PHP, just would like to broaden my horizons.
Well I wasn't going to get into details about how shitty the documentation is, but if you insist: 1) The ORM section of the guide, which I believe is pretty integral to the framework, has a whole whopping 9 links, 1 of which has a TODO section. The said pages BARELY scratches the surface of the ORM module. 2) There's barely any mention of the helper classes - just a list that points to the API. 3) No mention of i8n. 4) Basic auth/role module is provided, but once again no documentation. The list is a few dozen long but those are just a few. Like you said, the documentaiton OUTLINES what the framework offers and thats about it. I just wish their documentation was better. Like 10x better. It's bad when a developer have to go everywhere else BUT the Kohana site for documentation, examples, and usage. Don't get me wrong, Kohana is a great framework and works out of the box for most of my basic web implementations, but for sites that require the advanced feature set of the framework, there's going to be a lot of digging for info.
Interesting article, but like many on the subject it doesn't mention the practical difficulties encountered when automating some applications (Office up to 2003 being a notable example). Granted, most of the issues involved therein are really outside the scope of PHP (having more to do with server configuration).
Looking at what you've said, I'd say around 6 weeks full time for a developer without too much experience either not using a framework or learning a new framework as you go. Closer to 4 for a more experienced developer with their tool set all ready to go. This includes design time, implementation, testing, feedback and perhaps some small changes from the customer. In regards to hiring somebody else to write the thing: most developers I've worked with end up being useless in terms of either being too slow, not polishing the project or not understanding the spec entirely. The exceptions end up being constantly busy because everybody wants to hire them. If you're the one that has to maintain the project in the future, you really want to write it yourself.
When you say design time, do you take in account of possible mockups, design documents, erd and dfd's as well or just the general outline of the project?
I would recommend using something other than CI. There are much better MVC frameworks out there, such as Symfony, ZF, and Kohana. Each of those have their strong points. Kohana is light-weight. ZF is more full-featured, but leaves a lot of room for design and decisions. Symfony has more of a defined application structure and data-driven approach. Symfony basically requires an ORM. Both Symfony and ZF are great with ORM's such as Doctrine and Propel. Personally, I prefer ZF with the latest version of either Doctrine or Propel. Another good option is to go with Symfony and include ZF as a 3rd party library. As far as reports, you should be able to use some php magic to programmatically place filters on ORM queries. As far as permissions, Symfony has sfGuard, where ZF leaves it up to the coder to decide how Zend_Acl is used. I would go with either ZF or Symfony along with an ORM. If you keep your code organized and use repeated code in the right places, you can have a very robust and maintainable application. 
sigh... just because you CAN do something doesn't mean you SHOULD
I'd suggest also printing [this](http://www.addedbytes.com/cheat-sheets/php-cheat-sheet/) out and having it by you when you start.
In Estonia which isn't that far from my home (Sweden) and while I do enjoy a vacation, being away for over a month makes me homesick :) Of course there's a dozen of unknown variables that even I can't give a good reply on!
I'll be looking into other frameworks as well, was primarily thinking of CI mainly because I have some knowledge of it since earlier.
Would like to thank people for answering me quickly so far with valid input and good feedback!
General outline. My first 2 projects I did straight out of uni I did "proper" specs for only to find the clients didn't read them and didn't actually *want* what they'd agreed to on paper. Not only that but they were very time consuming, when taking into account the time and complexity of the project, really not required. It's a nice concept to: design -&gt; client signs off on design -&gt; build what the design says -&gt; amendments to spec are documented and charged for separately. But I think it's a more useful business model on a larger scale project with many people working on it over a longer period of time. For a one man project scaling a few weeks I find it's better to spend some time talking with the client, give a brief outline of what you intend to deliver with a couple of pages of bullet point functionality items and anything else you really want them to sign that you have NOT agreed on doing ie. training, installation, backup systems etc. Get them to read that and openly ask them to see if you've missed anything. Then, you have your feature list to work from and go from there.
If that's the case, my recommendation would be to look at Kohana first which started life as a CI fork before it was re-written to be less crappy ;) Though, Zen and Symfony are both also solid choices that might do a bit more for you framework wise and have slightly better docs. Depends how lightweight you want it.
As one of Reddit's outspoken Yii advocates, I highly recommend https://www.packtpub.com/agile-web-application-development-yii11-and-php5/book You should use a framework to handle a lot of the plumbing (validation, access levels, routing, blah). I prefer and recommend Yii, although many frameworks are great. This book goes through developing a super basic issue tracking system with Yii. Once you get to this level, you can add the functionality from the rights extension: http://www.yiiframework.com/extension/rights/ To handle multiple security levels, and then you can build views and use CGridView to handle report building. Along the way you will learn much and probably become a Yii advocate. It takes about 2 weeks to learn the framework (steep learning curve), and then everything is super amazing happy time. Ps - This will take at least 4-6 weeks.
I've used COM to integrate Crystal Reports with a php page (To produce embedded printable PDF invoices) It worked surprisingly well.
That site covers web design/development, and it's sister sites seem pretty design focused. But you might find some helpful resources at Microsoft's [beginner developer center](http://msdn.microsoft.com/en-us/beginner/bb308891.aspx). They have some training stuff that usually applies to their [free tools](http://www.microsoft.com/express/Windows/).
Just remember that caching is a devil. If your pages take substantially longer than a second to process, it virtually **always** suggests that a good many deep structural flaws lurk just beneath the surface. And once you implement caching, business will never consider fixing the code a priority, until the caching itself takes many many many minutes and threatens to overwhelm the server, at which point fixing the code has become exponentially harder. In short, most caching is to cover up noob mistakes.
This article is shit. File-based caching is widely known to be the most awful you can use. The only people that use it are those that don't know better and those that are on such poorly-configured (usually teh cheap-ass shared hosts) that they don't have access to all the other better alternatives. He also implements it in a very poor manner. One of the most ideal ways is to stick the caching in the \_\_construct() and \_\_destruct() of your view, but I doubt the author of this article ever even considered that (may not even know what MVC is). Or use .htaccess and mod_rewrite to implement "lazy caching", as per PHP creator's Rasmus Lerdorf's recommendation. Since this article doesn't even talk about the alternatives, I have to assume the author is just as ignorant as the masses, which is unfortunate (shouldn't write such articles unless you know what you're talking about, in my opinion). In order of efficiency, ascending: 1. File-based: Slowest of all. 2. Database: Much faster than file-based 3. Memcache: Almost always faster than spinning up your DB code 4. APC: Localhost, in memory, FAST 
[Here's a much more thorough writeup on the subject](http://docforge.com/wiki/Web_application/Caching).
This is incorrect. There are many situations where the time it takes to gather data and render output are significant, regardless of coding skills. Business reporting is a classic example. Where on a desktop app a user would be willing to wait 10 seconds for database queries to run, it must return almost instantly on a web page.
**Nevermind. The poor kid wrote the article on 27th March 2004.** That's before eAccelerator, probably before APC, a year after Memcache came out (may not have had PHP support then), and 3 months before PHP 5.0. I'll repeat: This article is shit. If you're a new PHP coder, you should take this with a grain of salt. Look of Zend_Cache for a modern alternative. http://www.reddit.com/r/PHP/comments/fqap5/zend_cache_a_more_modern_php_caching_strategy/ 
Mine was of course a generalization. Of course there are exceptions.
AND it mentions APC and memcache. Thorough win.
Can I ask how you got the job? I'd be interested in European contract jobs in places like Estonia (I'm in the UK).
Both APC and XCache don't work in the most common web server setups, with apache2_mpm_worker and fcgid. FastCGI is no longer supported by mainline Debian, and fcgid doesn't allow for inter-process communication or shared memory between php threads, so there's no way for APC or XCache to run effectively. memcache is OK, but not nearly as fast as either APX or XCache in environments where those work. There are still performance benefits to file-based caching for sites that do enough backend processing. edit: moar downvotes please! I just recently spent a full day dealing with this very issue and have compiled a ton of notes on it. If you think APC will make your life better, and you're running in an Apache environment, then you either haven't tried to get it to work, or you don't know that you'd be better off switching to mpm_worker + fcgid.
Is file-based really slowest? I mean, if I have a file cached and I am going to output everything from that file right to the user, vs have to query multiple rows and then output. Is the database still much faster than file based?
There are situations where it's appropriate to roll your own caching code. In general, if you're actually in one of those situations, then you already know what you need to know about file-based caching in PHP. But, let's go over it anyway: First, make sure it's actually necessary. If your custom CMS or web app is just using standard include()s, you're not likely to see any gains from caching. If you have a few database calls, you're not likely to see any gains from caching. If you're on-the-fly resizing large images with gd or do heavy database work, then you might get some gains from caching. So the next step then is to create a test case and measure it. Keep in mind that building a *correct* file caching system is a hell of a lot more complicated than this article suggests. Expect to spend at least a couple of weeks building and debugging it, so if the time difference that you measure can't justify a couple of weeks of your time, then don't bother. Also keep in mind that a correct caching mechanism is going to make your code a little bit more complicated and increase the number of places that bugs can hide. If you decide to go ahead with it anyway, here are a few considerations: * Browser headers: you will need to speak correct http/1.1 with browsers; specifically look up HTTP_IF_MODIFIED_SINCE, '304 Not Modified', and the 'Last-Modified: ' header. * Cache invalidation: you will need to know when something has changed in your content and then invalidate all of the appropriate cache files as a result. This means that if you are include()ing multiple files, you will have to track each one. If you are pulling data from a database lookup, you're still going to have to do at least one database request to check a timestamp table in your db. This is also why solutions like ob_start() (and its kin) actually work well: they can easily be nested, are easy to manage overall, and they allow you to build your content and then deal with the http headers later. * Cache management: even systems like Joomla fail at this. You can't let your cache directory just sit there and grow and grow and grow. You have to have some additional code that keeps the size of the cache directory reasonable. You also have to be sure that you can set up a writable cache directory in various hosting environments; some hosts give you a specific temp dir, others don't, for example. * Content type caching: you will want certain content types -- like probably your css or js files -- to bypass your cache entirely, unless you're doing something terribly complex with them. So, you'll need to have some additional code that looks at the specific content being requested and only bothers with cache lookups if it's appropriate. ...and that's why a lot of programmers don't roll their own file caches in php.
Funny timing- I've actually been working to document and release a caching library I wrote called [Stash](http://code.google.com/p/stash/). It isn't a full page cache (although it can be used as one), instead allowing developers to pick and choose what to cache in order to improve performance. It can use APC, Xcache, SQLite or even the filesystem as a back end, and will even allow you to use multiple back ends (you can use it to have APC as a primary cache and the filesystem as a secondary, for example). A memcache handler is on it's way. It also has a lot of other features for performance, and is really simple to use.
I really don't think filebased is the slowest- in my experience caching database calls can dramatically improve performance. When calling from a database you have the whole tcp/ip overhead, as well as the overhead to actually run the query and return the data. On an unrelated note, I haven't seen you in IRC in a bit- how are things going?
Shit, the guys downvoting clearly are idiots in this respect. We faced the exact same issue with APC that you're describing so we had to use a filebased backend for caching. That being said, it doesn't make APC useless- just, as you said, it makes it work ineffective. With fcgid you still end up reusing processing a lot, so giving each process it's own (smaller) cache with a larger file based cache to fall back on can still have it's benefits. If anyone is interested I open sources the code I use for [caching](http://code.google.com/p/stash), including the bit that allows [multiple cache pools](http://code.google.com/p/stash/wiki/Handlers#MulitiHandler) behind a single caching library (so you can check APC first, and then the filesystem).
Websites? In MY registry?
Make sure there aren't any blank/newlines before the closing tag in any files included prior to calling session_start()
I should clarify, no whitespace outside of the &lt;? ?&gt; tags at all. (iReddit won't let me edit so I had to reply to myself)
Double check everything again because even a space outside &lt;?php and ?&gt; is enough. A common pitfall is the files included with the "incude" and the "require" keywords. Check that there is no whitespace after the final ?&gt; of these files.
Arg it was one of my include files! DOH! I had a &lt;?php tag starting on line 2. I feel derp. Thanks all. 
Nice, I like your lib actually. It's laid out about right and is really straightforward to use, and not too over-engineered. The only gripe I'd have with it is it looks like it relies on marking cache items stale according to an expiration date, instead of checking to see if the original content has changed (which is a lot harder). Doing it by expiration date either causes a site to post old content after an update until the expiration date, or forces the admin to invalidate the entire cache.
&gt;The only gripe I'd have with it is it looks like it relies on marking cache items stale according to an expiration date, instead of checking to see if the original content has changed (which is a lot harder). Doing it by expiration date either causes a site to post old content after an update until the expiration date, or forces the admin to invalidate the entire cache. I agree that using the expiration date is not ideal, but this library is (by design) too low level to be able to judge how content should be erased. Instead the developer should use the clear functions in logical places to invalidate old data. I am still working on the documentation (if you look at the project history you'll see there was no documentation at all two days), and in it I'm going to include examples of this so people are clear about it. The way I've done it in the past is pretty simple though. I'm a big fan of MVC, or at the very least keeping data separate from the code in a logical way. Most code that splits out the data retrieval into models has a save and a load function, so placing the cache block in the load function and a clear command in the save function (or even another store function if you know the object is going to be used again) takes care of invalidating old data.
Thanks, I can't take the credit though, this is just a random site I found.
I'm pretty sure your problem is here: echo fputs($file,$write2File); Change to this: fputs($file,$write2File); Explanation: `fputs()` returns the number of bytes written to the file or `false` if there was an error
Yep. This is it. fputs [returns the number of bytes written](http://us2.php.net/fwrite).
Yep. This is it. fputs [returns the number of bytes written](http://us2.php.net/fwrite).
My sites, such as www.redditmirror.cc, use FastCGI + APC: http://www.redditmirror.cc/server-status It doesn't share across multiple cores, but that just means 4 caches and still has exceptional performance gains. Besides, memcache doesn't provide opcodes caching. Server uptime: 193 days 22 hours 11 minutes 2 seconds Total accesses: 29265037 - Total Traffic: 662.0 GB CPU Usage: u1.64 s.73 cu0 cs0 - 1.41e-5% CPU load 1.75 requests/sec - 41.4 kB/second - 23.7 kB/request
Agreed on all counts. The only issue is that four caches means four times the amount of memory to store the exact same stuff, which puts some limits on how many things you can store.
yayyy! Fixeded. Thank you so much!
Don't bother with a closing tag at all -- even safer.
this. I never close ?&gt; because editors sometimes add a new line after the end.
How does this compare to nginx with php-fpm? I've switched over, never played with fastcgi on apache, but in my own personal benchmarking I've found a significant increase in performance when using nginx/php-fpm with APC. This of course assumes you've got your database caching down.
APC works just fine with PHP-FPM, or good old spawn-fcgi. In the past you had to change a flag or two when downloading APC from PECL and compiling it for use with FastCGI, but recent Debian packages just work out of the box. `apt-get install php-apc` I haven't tried whether XCache works with FPM, but I know it was designed specifically for lighttpd and spawn-fcgi so it's definitely FastCGI-compatible. Apache seriously screwed up its FastCGI implementation, but other servers don't have that shortcoming.
Everything that I've seen shows that for busy servers, nginx just completely embarrasses even a well-configured Apache server. I run nginx on one of my servers that's hosting some in-house tools, but I haven't run any load tests on it so I don't have any first-hand knowledge. Unfortunately I can't run nginx on our customers' web server because it doesn't support Apache's mod_rewrite stuff, so that breaks some CMSs. I should run httperf against the two servers and compare. If I get around to that, I'll post the results back here.
I've recently setup WinCache on an IIS7 server and have to say it's done a brilliant job so far. Using it with a framework like Yii, which includes DB schema caching (for ActiveRecord calls), op code caching and page fragment caching, makes a huge difference.
My father works in the crane industry so I have many opening there in different areas. This will be my 2nd programming job through him, also had an assembler job in Estonia last year. Sadly it's mostly contacts nowadays.
Last time I got paid flight, paid appartment in central Estonia (like 30s from the centre) and an "OK" salary :p
nginx supports any rewrite rule you might need though, it just uses a different syntax. I run plenty of Drupal sites on nginx, no problem with all the rewrite rules. As for performance, from the best I've found Nginx supposedly tops apache when it comes to serving static files. However I've seen a lot that indicates that when it comes to PHP apps and such, it's mostly a toss up. I haven't done too much on my own, I personally run nginx because I find the configuration easier and it seems easier to split out php via php-fpm and have independent control over configuring PHP and the web server. I will say, I think apache can be tuned quite well. I did some testing on an Amazon Linux AMI on a EC2 large instance and was able to get better performance on static files out of apache than nginx. However, I suspect that's due to amazon heavily tuning their OS and apache install, whereas I was running a mostly stock config for nginx (basically just bumped up the worker processes and such for the high horsepower machine). In that case I was able to get 5,549 requests/second out of apache and around 2,000 out of nginx. I didn't touch the apache config at all, just what amazon's package installed, and I increased the workers for nginx, that was it.
Looks nice. I normally use phpMyAdmin for this stuff, but I'll give it a go.
Thanks much.
&gt;editors sometimes add a new line after the end. Which is the exact reason PHP doesn't actually care about a blank line, it will only care if you add two blank lines.
I love HeidiSQL - so fast for MySQL administration.
Looks great! I have been a long time user of [SQLyog](http://code.google.com/p/sqlyog/), but this will probably replace that. The code completion looks/works nice, and the built in ssh tunneling (available only in the Enterprise version of SQLyog) looks awesome too. Kudos to all those behind this project. 
This. Love SequelPro and used it daily up until I switched to Linux Mint for my work machine. Still do use it at home for all my other dev stuff though. Such a great app.
Unfortunately it's no longer free, best you can get is a 30 day trial w/o purchasing it.
I just wish they'd come up with a better icon. Nothing like a very low res ugly icon sitting in your Win7 launcher :( That's pretty good when it's my biggest complaint though.
Actually, the Community Edition is still free. Just go to the link I posted in my first reply and go to the "Downloads" tab - the latest version is still available there at the top. It is just the three other versions (Professional/Enterprise/Ultimate) that have the 30 day trial. 
I prefer Navicat, personally.. but both are nice, and Navicat isn't free.
If it's open source, is there a chance of a native Linux port compilable from source?
include() vs include_once() is bogus, since I am sure it is including the same file each time through. While it is faster to include_once() the same file 10000 times, since it only parses the target file once, that's not a real-world use case. I don't believe it's faster to do use include_once() once, since it has to check whether it's already been included.
You still need mysql_real_escape_string, as there are things you can't practically do solely using prepared statements' substitution.
When you send the votes do you get any sort of response/error? Is it possible that the votes are counting but just not showing up due to reddit caching/hiding scores? They fudge with the displayed votes a lot to hinder gaming.
Congrats Have fun, hope you don't get wound up in loops. and ya do maintain good relations with the testing team. :P 
Usually such problems can be solved in a way that involves prepared statements, you just have to be a bit more clever about how you do it, and if you absolutely need to do it, there's http://php.net/manual/en/pdo.quote.php
Ooh, this is rather nice. Is there something similar for PostgreSQL? PGAdmin III seems mighty unstable.
What if your class is importing a list of dependencies at the top, and you import two classes that have the same dependencies, and thus don't want to get their dependencies twice? If importing file speed is causing an issue for you, then you have some fucked up priorities.
&gt; support and documentation is terrible. See the code maturity, documentation, and support is the only reason I'd actually consider using a framework I haven't written. It could be the prettiest thing in the world but unless there's sense using it in a business context (no docs, support, immaturity means NO), I just can't see the point.
I've been using Heidi for about 2 months now. It's so much faster and more convenient than signing into Plesk to use PHPMyAdmin. I've also been using Toad SQL for MS SQL Server - far better than MS SQL Server Management Suite!
I use [Fences](http://www.stardock.com/products/fences/) to group relevant programs on my desktop. I like that far more than cluttering up my taskbar.
I am only disputing the informational value of the benchmark, not the utility of include_once().
Reddit uses a technique called "fuzzing" to somewhat randomize and fluctuate the upvote totals (on links and comments). This is because of their anti-spam measures, and the "shadow-ban" mechanism. It is basically in place so that when a spam account is detected and banned, the spammer cant tell he's banned by upvoting or posting something. To the spammer, it still looks like everything is working as normal. Could this possibly have anything to do with your troubles? Could it be that your votes ARE counting but it just doesn't appear so because of "upvote total fuzzing"? I really have no idea, just through I'd mention it.
Thanks! I would use this in my next project! Would it be possible to use memcache as a handler as well? Edit: From the roadmap: &gt; Memcache/Memcached Handler - For systems with memcached and either the memcache or memcached extension. 
Community version is available at Google Code. http://code.google.com/p/sqlyog/downloads/list
Ah, fair enough. Well yeah, the benchmarks are pretty useless really. 
Was going to say the same thing. I've purchased Navicat because I use it so much.
http://www.php.net/manual/en/language.namespaces.rationale.php
This is a slightly different problem, namespaces do not affect variables, just classes, functions and constants.
Voted up for Zend + Doctrine. Killer combination in my experience. It can be quite hard to initially setup though, so here's a video link for people interested in learning how to do this: http://www.zendcasts.com/deep-integration-between-zend-and-doctrine-1-2/2010/01/ (Note that this is for integration with doctrine 1.2 and not the latest version with is 2.0. I actually wanted 1.2 for my latest project though, because 1.2 has native support for hierarchical trees inside a database) Doctrine is pretty awesome, and in my opinion is much better than the standard zend stuff for interacting with your database. And yes, for permissions, you want to be looking at something like Zend_Acl. A potential downside to all this is that you have to learn how to use these frameworks before you can be productive with them. Zend is a little more difficult to learn than some other frameworks, but the pay-off once you've got your head around the basics is quite significant.
Poor English and example is really confusing.
Ah ok. I understand that but if you have the problem of having PHP code that needs to be portable and potentially not conflict with other variables in the global name space, surely that code should be in a collection of functions or classes that have their own symbol tables? I can see why this is useful for JavaScript but not so much for PHP yet.
Interesting, I assumed your link went to the [WebYog](http://www.webyog.com/en/downloads.php) URL which doesnt show their community version at all. Thanks for pointing that out.
I personally disable icons on my desktop, I hate the clutter over my background. Plus I usually have 50 windows open at all times. I did try Fences on WinXP a while back but it caused all sorts of issues. Explorer was crashing all the time. So I ditched it.
I'm loving the SSH Tunnel option! And it's much easier to keep a list of MySQL servers on this program than memorising lots of URLs to PHPMyAdmin.
Good read. I myself have been have fooling around with Closures a lot recently. They are definitely useful in some limited cases, like the example you provided. Though, there are some major issues: 1) Closures do not inherit scope from the function in which they are defined. 2) Closures may not be used directly as object methods. Both of these things make Closures almost entirely worthless in an object context. 
If someone is willing to port the entire user interface, then yes. This is basically a rewrite as this is a useful program precisely because it is a GUI for mysql. I'm so glad I've come across this program, it's already saved me hours of work.
Generally I agree with you but there are cases where it still makes sense. For example I used it in a little script that registers autoloaders before starting the application and of course before loading any classes. I could have encapsulated it in another class like AutoloaderLoader but I think this way it suits better.
So you're saying it's useful where you "can't" or you aren't going to use functions and classes? Fair play. That reminds me of when all I knew how to do was include(); good times.
In fact, the whole scope concept of PHP is poor when you start thinking about it... But you are right, in an object context Closures are not reallly useful and they can make it look otherwise but under the hood functions/methods and variables are too different in PHP.
I don't know, using closures to solve namespace clutter seems rather cumbersome to me. It seems like a better idea would be to just a) pick distinct variable names, or even better b) refactor your code. This usage appears to just be a hack to get around PHP's lack of one-off scope creation. From my experience, anonymous functions are really only particularly useful as callbacks. In JavaScript, you use a lot of callbacks because it's event-driven. In PHP, you don't do much waiting around, so callbacks are a lot less common. There are a few internal algorithms that accept them as a means of "extending" their functionality (usort and preg_replace_callback come to mind), and they work out well there, but those cases are few-and-far-between. It seems developers are trying to use them for everything under the sun, just because they're new, and are forgetting about logical and maintainable code structure along the way.
The easier way to solve this is with a wrapper function around require(): function require_scope($file) { require_once $file } Now any file you include with require_scope() will get it's own non-global scope. 
Try something like this: set_time_limit(0); // do not time-out for ($i=0; $i&lt;20000; $i++) { do_something(); if ($i % 500 == 0) { sleep(1); // do not overload the server } }
Instead of executing the script via your web browser, use SSH to run it. I believe running it via command line eliminates time and memory usage limits.
presuming by "pieces of data" you mean rows, a dataset with ~20,000 rows really isn't all that big
"20,000 pieces of data" is really, really unhelpful. What exactly are your pieces of data? 20,000 names and addresses should be no problem whatsoever and be handled very quickly and easily. 20,000 complete account histories for 5-years of activity on a busy site, might not be so quick. Unless each individual "piece of data" is massive it shouldn't be a problem. 20,000 is not a very big number for modern computing.
What happens if the script, for whatever reason, cuts off halfway through? I personally would split the data into manageable chunks - ie ~1,000 rows. Have the script loop through 1,000, then call itself again
Um...I'm talking about storing fully-rendered HTML in a table called somethign like webcache in a database dedicated to webcaching that's based on the localhost. If the DB is not on your localhost, then memcached makes more sense 9x out of 10.
Agreed. With regard to Closures, were the 2 aforementioned issues fixed, it may then become possible to create object prototypes similar to those found in JavaScript. It's unfortunate that the current implementation is so limited, as Closures provide nearly no benefit in reducing code duplication as they do JavaScript. Ideally, it would be advantageous to simply assign Closures to an object and replace methods dynamically, including magic ones. Some may consider this an anti-pattern, but I'd happily incur some additional overhead expense to avoid a dozen different __get() implementations strewn throughout my code. The only way to accomplish anything resembling prototypes now is by wrapping your objects with a magic method routing object. Despite getting the job done, it's slow and suffers from the same scoping issues as Closures do now.
It should not be a problem (have handled gigs of data in memory in PHP). * If you are querying a lot of data, make sure you only fetch the fields you need (don't do select * .., do select id, name, password from ...) * If using a custom database class, make sure you are not keeping track of all your queries because this stash will be big. * Create a way to continue (php script.php --from=xxxx) 20k pieces of data isn't much btw.
I thought about this too and it is in fact the easier way as long as you do not want to share any variables.
Even if it is on a local host, filebases caches are going to be much faster than database based ones (and trust me, I've benchmarked it). Done right pulling the data out of a filebased cache should be as simple as "include"ing a file.
Sorry I tried to say "about 20.000 row with about 20 fields".
I do not think that i will have root access on their server.
&gt;user might need to view a list of their previous logins and IP addresses Sure, maybe wouldn't want that in its' own class, but that's exactly what models are for.
Glad you like Stash! If you have any issues or encounter a problem please let me know. I'm also still actively working on the documentation (there literally wasn't any documentation at all last week), so if there is anything you'd like me to focus on first as far as that is concerned just let me know.
You're absolutely right. But without wanting to start a procedural vs OOP holy war, some of us will avoid writing global functions at any cost. Furthermore, the OP's solution is more versatile because it's possible shuffle Closures around and share variables from multiple mutually exclusive sources.
I agree it should be in a model, anything that interacts with the DB shoul, but what I meant was some people (OOPHP newbie devs) might try to create a helper class for something of that nature, which isn't needed. Like I said, hard to come up with a good example of what I'm trying to explain.
Don't need root, just need a user with permission to run this command: php path/to/script.php
Set "memory limit" and "max execution time" high enough and you'll be fine.
You just need that one function (each time it's called, it gives a new scope). It works similarly if you drop it in a namespace or a static member of a class, if you really don't want to add one global function. If you'd like to share variables, this also works: function require_scope($file, $vars) { extract($vars); require_once $file } But really, once your passing variables to a block of code you might as well make it an actual function. I never have any global variables, but code including this way can access static members of other classes, etc. Shuffling closures around is what they're made for but the OP is explicitly not using them for that purpose. 
I just wrote a multiprocess PHP program (using pctnl) to parse through 166gb of apache logs. And 166gb isn't that big. But no, it shouldn't be too big of an issue.
There's also apache, http, browser, network connection timeouts to consider when running a script via the browser. I believe Firefox's default timeout is 120 seconds.
Are you running this via a web server or at the command line? The latter is better suited for this sort of work.
he said they're hashes
he said they're hashes
 $query = "SELECT * FROM assp WHERE fname LIKE '%$keyword%' OR lname LIKE '%$keyword%' OR CONCAT_WS(' ',fname,lname) LIKE '%$keyword%'"; This might work. I don't have MySQL around so give it a try and see if this does the job. Line breaks added for clarity.
Yes, you'd have to explode by space and implode with % However, you probably don't want to do this. MySQL indices are left-prefix, this means that they work from left to right. When you search for "%John Adams%" The left part is everything, so it cannot use indices to limit the search range. You're essentially doing a manual check of every single row in the database. If you have 200 rows then no problem, but once it starts ranging in the thousands you will have real problems with this query as it will be slow as shit. More optimally is to use full-text search, so you do WHERE MATCH(`full_name`) AGAINST ("John Adams") This will keep performance more linear with amount of data. Sadly, this means you cannot use InnoDB as only MyISAM supports full-text indices. More optimally yet again is to use something like Sphinx, which is a dedicated search daemon. This will take data from MySQL and generate indices made for search against, so it can do wildcard search without limitation. The down side to Sphinx is that it's a separate daemon so you need to know a bit about installing software, your application also needs to be coded to use it so there is definitely a learning curve. The upside is you get wicked fast search and you get to keep InnoDB.
I owe you my life :) Worked perfectly! Thank you so much.
No, he didn't. He indicated that passwords were a component of it, but not that passwords were the entirety of the content.
Hey, I'm new to PHP and MySQL too, but I have an idea. Try this: You could use [explode()](http://php.net/manual/en/function.explode.php) and [implode()](http://php.net/manual/en/function.implode.php) to break the search string up and and dump all of the where conditions in one query. That way, you wouldn't have to run a bunch of individual queries. However, the query won't be pretty. $where = array(); $search_words = explode(' ', $search_string); foreach($search_words as $word) { $where[] = "fname like %$word% or lname like %$word%"; } $where_clause = implode(' or ', $where); $query = "select * from assp where $where_clause"; 
I've read quite a bit about anonymous functions in javascript, and I've just read this article. I'm still unsure how I might benefit from these within my applications though. I do use an anonymous function in javascript when executing various bookmarklet scripts... but with PHP...
Thank you for the advice.
Thank you for the advice.
just timeout, memory is still restricted via the php.ini file.
You're going to have more issues with the update statements than you are with the parsing through PHP. I've found that a lot of shared hosting doesn't like more than 600 records in an insert/update so you might need to chunk that up.
Pass a second variable by reference that contains what you want to modify. EDIT: Really? Why is putting all of the stuff you need into an array then passing it in by reference bad? It's far better than throwing it into global.
I'm lazy. I also do it in one batch, but then have it print out the id of whatever it just handled. If it dies partway through I just hack the code to start at that id... 
 ignore_user_abort(true); //Script won't stop if you lose the connection set_time_limit(0); //Script won't time out after N seconds
That's actually a pretty small dataset. I've worked on applications that blended datasets consisting of 500K rows with about 200 columns per dataset. Took a while, but it would with any language.
&gt;Edit: maybe I better just drop off for tonight. Drinking and programming don't mix. Nah, you had either passed or hadn't quite hit the Ballmer Curve.
Or simply: $query = "SELECT * FROM assp WHERE CONCAT(' ', firstname, ' ', lastname, ' ') LIKE '% $keyword %'"; If you just need a simple matches/doesn't search, and don't need to order by relevance or anything fancy, this will work just fine. It could be quite slow on large datasets though, so if you aren't using MyISAM, you might need to build your own fulltext indexing.
Figured I'd throw my function into the pool for the WestHost competition. I did [push everything to github](https://github.com/BauerUK/choo/), however.
**Important Side Note** For the love of all kind of religious and non-religious deities - DO NOT use variables in a string like that. You will open yourself up to all kinds of sql injection trouble. Use parameter binding. [MySQLi](http://www.php.net/manual/en/mysqli-stmt.bind-param.php) [PDO](http://www.php.net/manual/en/pdostatement.bindparam.php) [More Information on SQL Injection](http://php.net/manual/en/security.database.sql-injection.php)
I thought i would SELECT all the rows an then in a while loop php makes some changes and INSERTs again. So alot of small inserts. Is that a problem?
Web server
Just a thought, is there any reason to continue searching the separate attributes of fname and lname when you're searching the concatenated attributes anyway?
It's good advice in general but he may already be sanitizing his user data and just not showing us here. In a perfect world you'd be using PDO. In the real world sometimes you have to work in existing systems where decisions like that aren't feasible from the business' perspective.
I suppose not. At least I couldn't think of any reason why off the top of my head. The reason I left it alone was because the OP already had it developed, so I wasn't changing it much. Also, it resembles an LDAP search string, which I have a lot of experience with: (&amp;(objectClass=user)(objectCategory=Person)(|(name=\*$variable\*)(givenName=\*$variable\*)(sn=\*$variable\*)(sAMAccountName=\*$variable\*)))
Unless you are running it on a production server that is already running short of resource this is not a problem. Should take less than a second. It's when you get to millions of rows that you need to start thinking of batches.
Why concat spaces on the beginning and end?
Google is your friend: &lt;?php // Function to check response time function pingDomain($domain){ $starttime = microtime(true); $file = fsockopen ($domain, 80, $errno, $errstr, 10); $stoptime = microtime(true); $status = 0; if (!$file) $status = -1; // Site is down else { fclose($file); $status = ($stoptime - $starttime) * 1000; $status = floor($status); } return $status; } ?&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd"&gt; &lt;html&gt; &lt;body&gt; &lt;form action="" method="post" name="domain"&gt; Domain Name: &lt;table&gt; &lt;tr&gt;&lt;td&gt;&lt;input name="domainname" type="text"&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;input type="submit" name="submitBtn" value="Ping domain"&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;?php // Check whether the for was submitted if (isset($_POST['submitBtn'])){ $domainbase = (isset($_POST['domainname'])) ? $_POST['domainname'] : ''; $domainbase = str_replace("http://","",strtolower($domainbase)); echo '&lt;table&gt;'; $status = pingDomain($domainbase); if ($status != -1) echo "&lt;tr&gt;&lt;td&gt;http://$domainbase is ALIVE ($status ms)&lt;/td&gt;&lt;tr&gt;"; else echo "&lt;tr&gt;&lt;td&gt;http://$domainbase is DOWN&lt;/td&gt;&lt;tr&gt;"; echo '&lt;/table&gt;'; } ?&gt; &lt;/body&gt; &lt;/html&gt;
Yep, it's going to time it out quick. All of those little inserts put a big strain on the DB. It's better to send them all over as a big chunk.
It ensures that every word has a space before and after it, so that you can include spaces before and after your keyword to prevent matching of partial words. For example, for the name John Doe, it would be comparing: " John Doe " LIKE "% $keyword %" So if you searched for John, it would match because the concatenated string contains: " John " But if you searched for Jo, it would not match, since the concatenated string does not contain: " Jo " Of course, this falls apart if there is end-punctuation involved, but you shouldn't use this method to search full sentences anyway.
Wouldn't you want it to match? What if it was in the database as "Johnathan Doe". I'd want a search for "John" to return the result. Edit: I think this is just arguing business rules at this point.
That's small. Unless your machine is really crappy it should be able to handle whatever you want to do with that no problem.
you might use pma without going through plesk though, couldn't you?
I have never used the tunnel option, but just "ssh -L" and then the corresponding port.
Create a new field containing both the first and last names and search against that. Populate it with an insert/update trigger or, less optimally, in your PHP program. Concatenating at runtime for each query will make the search much slower.
It is really nice and sweet when used locally, but gets indifferent already when you want to use the power of a good editor (like Vim), and HeidiSQL does not provide an external editor, but phpMyAdmin does so via just pressing ctrl-i (vimperator/pentadactyl). Knock out really much too often..
Think for one moment about the approach you are suggesting of running query A and then, if that has zero hits, running query B. What if query A returns a hit, but the real result the user wants is actually selected by query B, which they will never see? Does it feel wrong yet? When running search queries, try to get an approach that is consistently predictable. On a more practical side, what I would do is split the query text into separate words, then include each word in a separate condition. Searching for "john doe" should be able to return "john doe", "john p doe" and "doe, john" every time. Mix that with the other suggestions here about how to apply it using separate name part columns and full-text indexes, and you should be good to go.
My original post was in response to: &gt; You can try MySQL Full-Text Search if you don't want to break into words. If you _do_ want to match partial words, just remove the spaces in the pattern and the leading/trailing spaces from the CONCAT. If you want to match only the beginning of words, remove the trailing space from the CONCAT and the pattern.
That's why I instinctively new there had to be a less ridiculous solution (in fact my idea would probably not even be considered a solution, lol). I surely am not the first person creating a simple search function.
Good - instinct can help you steer around many a tricky problem :-)
&gt; It works similarly if you drop it in a namespace or a static member of a class. Though a kind of encapsulation, namespace'd and static functions still technically exist within a global scope. &gt;If you'd like to share variables Right again, but the use of extract in this way is commonly known as a kind of View, often found in frameworks that implement [MVC](http://en.wikipedia.org/wiki/Model%E2%80%93View%E2%80%93Controller). On a previous note, Views are typically not implemented globally. I can't possibly see any reason why modifying Views to use Closures is any less effective than conventional applications. While not only conforming to expected View requirements, Closures would allow Views to be more extensible by providing a way to plug into other potentially disparate rendering components.
You will need to apply string sanitising and escaping to that solution, or use bind variables, to prevent SQL injection. Also trim multiple whitespace runs down to single spaces and trim leading and trailing spaces before using explode. You just have to be ready to do lots of cleaning of the input data - don't underestimate this. Also avoid really short strings such as "a" if you want the results to be meaningful. If your first and last names are in separate columns, you may want to think about dropping the leading % to enable indexes to be better used. It would mean a search for "john" would need to involve "j", "jo", "joh" or "john" and not "ohn" or "hn", but that may well be perfectly acceptable.
No, but somebody will, and they can set up the permissions your non-root user needs.
If there's any possible way for you to do this directly in SQL, you should try, because it's likely to be a whole lot faster. MySQL and other database engines have pretty rich languages these days... 
I've used PHP with a 130 gigabyte dataset, with ~2 billion documents stored in MongoDB, it ran fine. If you think about your code and have a fast enough machine it's fine. It's almost always limited by disk io / ram than code speed, from my experiences.
[I'll just leave this here.](http://xkcd.com/327/)
Also: $sth = $pdo-&gt;prepare("SELECT * FROM assp WHERE CONCAT(firstname, ' ', lastname) LIKE :query"); $sth-&gt;execute(array(':query' =&gt; "%{$keyword}%")); I just saved you from a load of shit for your site getting hacked.
keep in mind that a % *not* at the end of the word makes the query slooooooow.
I really don't think the programming world is ready for parametrized statements, or let alone sanitizing. A decade to raise awareness just isn't long enough. Someday perhaps... someday... On the bright side - free porn storage, movie-star loggins, and DOS bots for everyone!!
Hey Everyone. Thanks for letting me know about the vote counting fuzz! Also, I was checking my like page and it still wasn't showing up there. However, I have taken another look at the http_request2 doc's and after switching from addCookie('cookiename','value') to addHeader('cookiename','value') things are working and the vote gets counted and shows up on my like page. Here is the updated PasteBin Example Code [http://pastebin.com/f0xskYKg](http://pastebin.com/f0xskYKg)
You should make a temp table in mysql (or whatever database you are using) and then work from that. You could do it in one script, but you are limited to about 32mb most times on the server, although you could get around that by doing PHP from the command line.
i have seen hosted services put hard limits on CLI php scripts :( not saying that they all do it, hopefully yours does not.
This. If searching across multiple columns, always go for full-text.
Rather than doing one insert at a time try using transactions. They work well for bulk inserts/updates/deletes. Doing one at a time is very slow and often causes the script to become unresponsive.
true, but given the &gt; PHP/MySQL noobie statement I would most likely think not. That said you may be correct, however given that mysql library is superseded by mysqli the more experienced of us should be actively encouraging best practice. 
If you do this also remember to close your database connection to free up the database to prevent it getting locked. This would be immediately after php has the data from the db but before the looping takes place.
keep in mind that a function like CONCAT() in a where clause makes the query slooooooow.
For PHP I recommend this one. I've used it and helped the developer port it to PHP5. It works very well comparatively compared to other php bayes filters. http://nasauber.de/opensource/b8/
urlencode. The space between john and adams, is being converted to %20.
an @ sign infront of fsockopen should do the trick. http://php.net/manual/en/language.operators.errorcontrol.php
really *any* function that uses a column for input... *hello table scan!*
This article really made me think. At first I thought that the issues that you mentioned would generally be fixed with proper usage of object oriented programming, but then I realized that I too have a portion of *dirty* code that would just *feel* better if it was put in closures. Great read!
Can't this all be done in SQL?
HeidiSQL looks nice but it would be perfect if it had HTTP tunneling integrated like in SQLyog.
No arguments there. I'm sort of a novice myself and it was thanks to /r/php that I realized I should be using PDO instead of MySQLi when possible.
Anyone who would call PHP "very good" has questionable programming knowledge and skills. The fact that your whole team is familiar with PHP and your entire codebase is in PHP is plenty of reason to stick with PHP. But to say PHP is "very good", I think is going a bit too far. PHP is fine. It does the job. It's got eccentricities and annoyances. It also has a future only slightly more clear than Perl's. I use PHP every day, the reason? I'm writing scripts that are part of a larger project that's all in PHP. It would make little sense to have part of a project in PHP and part of it in Python or Ruby or Perl or C or Go or SSJS. Consistency cannot be overvalued in terms of software development.
So, you're suggesting the following, please correct if you've got a better solution: $query = "SELECT * FROM assp WHERE (fname LIKE '%$fname%' OR lname LIKE '%$fname%') OR (fname LIKE '%$lname%' OR lname LIKE '%$lname%') OR (fname LIKE '%$fname%' AND lname LIKE '%$lname%') OR (fname LIKE '$fname' AND lname LIKE '$lname') ";
tl;dr: We like it. We spent money and time training our staff on it. We think there are still great innovations to come.
because at the end of the day php gets the job done.. very quickly.
what everyone seems to forget when ruling out any language is that a project can be done in pretty much any language, its the developers choice to select what language to use and how to fulfil the projects spec. I wouldnt look down on anyone for choosing any language as long as they knew why they chose it. Typically projects are written in the lead developers strongest language.
That would be nice - but it isn't available in the free Community Edition of SQLyog anyway.
My work bought SQLyog licenses and http tunneling is really great feature.
&gt; its the developers choice to select what language to use Not always. We often deal with clients who want to host the sites themselves, and have restrictions on what we can use on their server, for any number of reasons. Whether it's because the corporate bureaucracy restricts their IT department from adding anything new to the servers, or the IT department itself plans on maintaining the site, so we have to stick to what they know, etc.... 
What language do you consider "very good"?
That's a loaded question. It depends on the purpose and situation. Objectively every language has problems and shortcomings. It's really a matter of picking your poison. But I think PHP in particular is full of bad design, inelegant kludge and inconsistencies. It's a mess. Perl is a better designed language, with more sensible behaviors and more internal consistency. Which is not to say Perl is "very good", it's only better than PHP. The original context where the article used "very good" was that "PHP is a very good glue" between interface (JavaScript/CSS/HTML) and database (probably MySQL.) So what language is "very good" for that purpose in my mind? I honestly don't have one that I'm totally happy with. My personal preference would be for SSJS to mature and for there to be a single web language to rule them all. But currently SSJS is nowhere near "very good", certainly it would be more painful to develop in than PHP even. The best of the bunch in my mind is Perl, but I may be biased because I have done the most coding in Perl and its internal logic matches up better with my own. It has problems too. My point in pointing out that PHP is not "very good", was not to assert that some other language was better, but merely that PHP is not that great.
Perl is the only language I've coded in that I can no longer remember. I just can't remember all the rules, the symbols, and the strangeness of it all. And I coded in Perl enough to actually *like* Perl at the time. PHP's advantage is that has a relatively small syntax that's pretty straight-forward for a dynamic language. Yes, it does have inconsistencies, bad designm and even a few kludges but it's also a very efficient language to code in effectively. 
If it ain't broke don't fix it. I can remember when if you weren't doing everything with activeX controls then you weren't cool. Funny how things work out. PHP sucks in a lot of ways but it doesn't suck in enough ways to allow me to recommend it for my clients. If they have to have ROR or java or python, or whatever I send them elsewhere because I can't and don't want to be an expert in all those languages and various web frameworks. For backend and utility work Perl is the best tool available anyway.
I would agree it's pretty easy to write something in PHP and just get the job done. But I'd say it's just as easy in Perl. Perl's really not that complicated. $ = scalar @ = array % = hash That's 90% of what you need to know.
Function parameters are weird, there are magic variables, object definitions are weird, etc. I could go on, but as I said, I don't remember much anymore. Even your "$ = scalar @ = array % = hash" only scratches the surface of the complexities behind that. 
This article seems to be lacking in the "why" (I use PHP daily and I like it, but I was interested in seeing their reasoning)
tl;dr: I LIKE PERL, HA HA PHP SUCKS, BEHOLD MY EPEEN disclaimer: I develop using five languages, Perl and PHP are two of them.
I dunno I find the unanticipated weirdness of PHP to be much more unanticipated and weird than Perl. But maybe that's just me. I find a lot of the Perl stuff to be fairly intuitive.
Wow do you ever fail at reading comprehension. Also the "behold my epeen" followed by "disclaimer: i develop using five languages" is just unadulterated retardation in its purest form.
I would like to say congratulations on your sales. The project seems promising and the search module has a really low WFT/line of code ratio which is superb. I am not sure if you already tried this or not, but I think it would great for your business exposure if you can make a couple of sites for some groups in your local community. It does not have to be very fancy, just a nice presentation of your softwares true potential. It could be for some clubs or charities. Just be sure to have a link back to your site. This should get you some exposure in your community and online.
It might just be you but I'm curious what you find that's really unanticipatedly weird about PHP? Perl, for me, is somewhat of an alien language filled with unique concepts (functions returning different values based on context) and twisting basic concepts like objects and classes. PHP, by comparison, is much more straight forward and works much like many other languages. 
Not worth the risk.
Awwww, kitten. 1. I was cracking wise. 2. You overrate the importance of your opinion to practically everyone here. 3. Everything you accuse PHP of, Perl has also been guilty of, in the "bad design" department, and yet you claim Perl to be superior. 4. "unadulterated" is eqivalent to "purest" in this sentence, and is therefore redundant. Due to this, I would hazard to guess that you wrap your scalar variable names with scalar() when you reference them in Perl, too. 5. Blah blah blah, something else you will take offense to. 6. I like pie! 
Thanks for the ideas, that's a good one. My father in law works for the city he lives in, and this would be a perfect way to get some exposure. I appreciate the idea.
I can agree with the points in this article, as they're laid out: * We already have a mature and profitable code base written in PHP. * Our developers are very well educated and know PHP well. * We don't write anything that does anything but glue a database to a website. The last point, though, I think is the most crucial. PHP is a perfectly fine solution for 99% of the websites that exist on the internet - after all, they're not usually much more than CRUD layers and in that case, your frontend language doesn't really matter so much as how you choose to architect your data. That said, though, there are cases where you do have a lot of interesting things your frontend has to do - like full text search or data aggregation - and that's where PHP starts to fall apart (of course there are magic black boxes for most of these solutions, such as Solr) because of the limitations of the runtime's performance (it's demonstrably the worst-performing managed runtime, see [this post](http://www.reddit.com/r/programming/comments/fpxap/using_the_windows_com_component_object_model_in/c1hst0m) I made in a separate thread). That is to say, in cases where performance of your frontend-generating language matters, I don't think PHP is a good fit, but those cases are exceedingly rare and for most things PHP is a perfectly fine solution. I don't think PHP has any place outside of web development though.
1. You fail at it. 2. Where? I don't see anywhere that I said anything about how important my opinion is. That is complete inference on your part. It's probably transference on your part. 3. PHP has a lot more bad inconsistencies than Perl, at least IMHO. You're free to disagree. That's the beauty of us being separate entities, you can have your wrong opinion and I can have the right one. I never said Perl wasn't full of flaws, though, again you're just inferring stuff left and right. In fact I went out of my way to say Perl has problems, I just think it's a little more elegant than PHP. 4. If had phrased it as "pure, unadulterated retardation" then you would have a point. But the way I phrased it means something totally different. It's ok if subtleties are lost on you. 5. I take no offense at all, you're just some random dipshit making a lame attempt at trolling me. But, to me anyway, you just look like an imbecile. Clearly the upvotes are with you and against me. But that's OK, I expect to be downvoted thoroughly whenever I point out that PHP is kind of a pain in the ass. 6. Me too. Mostly pecan and apple.
Well just as an obvious example the various built in file routines are just a mess. You have file(), file_get_contents(), fopen(). There's no internal consistency on any level between the 3, not in the naming and not in the design. file and file_get_contents almost make sense where one puts the results into an array and the other into a string, but why aren't they named file_read_string() or file_read_array() or something logical? fopen and its related routines make sense, but it follows a completely different style and logic to file() or file_get_contents(). They seem like things that belong in different languages. Then there's language features like globals having to be declared within a function. They're globals. They should be expected to be global. Don't get me wrong, none of its remotely insurmountable. It's just, to my mind, bad design and illogical.
for me it's always been easy to write both in perl and php (though i learned perl a lot earlier than php).. basically what it has come down to is that if it is something web related then php works better.. otoh if it is a system level task like writing a cron job, crawler, data processing, etc then perl does the job just fine (thanks to the amazing CPAN!)
That's pretty fair. Probably part of my bias comes from I'm more of a back end guy.
1. Rather, you fail at humor comprehension. Everyone else here seemed to get it. 2. You're taking great offense to an eye-rolling comment. That indicates that you have highly overrated the value we place on your opinion. Pro tip: If you don't want to look like a self-important douche, *don't react like a self-important douche*. 3. PHP inconsistencies that people tend to rave about aren't in the core but in user-developed libraries. This is a silly argument against the language itself that people post again and again, and I came to PHP after writing code in Perl for 15 years and expecting the worst. It's just another language, no worse, no better. 3. (redux) "you can have your wrong opinion"... see above comment about avoiding coming across as a douche, assuming you don't actually intend to be a complete douche. Ad hominem will get you nowhere fast, kitten. 4. " It's ok if subtleties are lost on you." Oh, zing! Snap! In my face! Wow, how will I ever recover from these burns! Oh, right. By merely remembering that your behavior is that of a condescending douche. 5. I'm just a random dipshit? See item four, above. You apparently take great offense, because you're downvoting me and responding with insults and vitriol. You descend far rapidly into insult there to be worth a burlap assplug, Captain Awesome. 6. BRING OUT YOUR TROLL What we have here, apparently, is a failure to communicate. Let me break this whoe thread down for you: 1. You posted a lot of e-peen waving WHARRRRRGARBL that does no one here any good. You could have posted this as an interesting "Here are my reasons and evidence for them as to why I prefer Perl to PHP", and instead, chose the "RAAAR YOUR LANGUAGE CHOICE SUCKS AND I'M HERE TO TELL YOU WHY YOU'RE WRONG AND RAPE YOUR WIMMENFOLK". 2. You neglect that Perl has been around a decade longer than PHP, and has become glacial in its development. Perl 6 has been in progress since early 2001. The current 5.x major release branch has been around *for eighteen years*. Check back in on PHP in 15 years and see if your current arguments still hold. I will guess that they won't. 3. PHP certainly isn't perfect. No language is. PHP is (in my opinion of course) far better for development in its own arena than Perl is, *in that same arena*. If I'm parsing data to generate a result though, Perl is my choice. I think the reasons for my statements here are mundane and obvious enough that I don't need to post any exposition, but if you need me to, I'll be glad to elaborate. I released my first piece of commercial (well, shareware) software in 1983. Since then, I've used a lot of technologies and languages, quite possibly everything you've ever thought to use in production. And, as a result, my opinion is just as low-worth as yours. You are attempting to come off as a greater authority in a sea of authorities. Unless your name is Rasmus Lerdorf, though, or you present valid and compelling evidence supporting your claims, I'm just going to chalk your presentation here against PHP as the ramblings of youthful inelegance and poor form, rather than an intentional sociopathic descent into the dark nature of assclownery. I greatly prefer pecan to apple, but I'm quite fond of berry pies, honestly. Homemade peach pie is phenomenal though, when the peaches are ripe.
If you can get a government contract, then you will be golden.
tl;dr - I am a booger eating buttface.
if it wasn't obvious.. I was speaking, with heavy snark, of our beloved Reddit. ;) it's obviously not a fit for them, but they appear to fail at implementing something that *is* a fit- so..
It will be comparatively slow for any size database, '%$keyword%' is still a scan of the whole index.
I thought you might have something more than the inconsistent function namespace. There is historical reasoning behind the design: file() is a very old function and is very Perl inspired (it's also not terribly useful). The fopen() and similar functions are just light-weight wrappers over the C standard library (similarly named functions with nearly identical semantics exist in Perl). file_get_contents(), on the other hand, is a relatively new function and is really just a shortcut for what you could always for yourself with fopen() and fread(). The only way for these functions to have consistent naming is to have a time machine. Globals have to be declared within a function in Python as well; it's a consequence of not having to declare variables. I agree it's a bit of a mess, but you shouldn't be using global variables anyway! :) The equivalent of file() in Perl is this: open(MYINPUTFILE, "&lt;filename"); my(@lines) = &lt;MYINPUTFILE&gt; At least in PHP it's just a function and not some weird angle-bracket syntax! 
Well right, I realized there was historical reason for it. My point was more than it's not internally consistent and that's what bothers me. I'm OK with whatever the language wants to do as long as it follows an internal logic. I'm not OK when there's the several different file handling routines which all have different behavior and the naming is all goofy and nonsensical. Also you forgot a semicolon in your Perl, there. ;P The "Why PHP is dumb" argument is old and tired, so I'm sorry I'm not putting my all into it. I'm also really busy at work.
[Yay boogers!](http://en.wikipedia.org/wiki/Eating_mucus#Advantages)
&gt; I realized there was historical reason for it. My point was more than it's not internally consistent and that's what bothers me. All languages have historical baggage, even Perl. I don't actually think the function naming is such a huge problem -- I've never used the file() function ever in my life. &gt; The "Why PHP is dumb" argument is old and tired, so I'm sorry I'm not putting my all into it. I'm also really busy at work. Your karma took a bit of an inappropriate hit as well. I voted you up, but I suppose such negativity to be expected on the PHP subreddit. 
Thanks it's OK, I expect it. I have plenty of karma to spare. If I wanted a boost I could always just make some pandering joke in /r/pics.
I don't understand why in some circles, people hate PHP. It get's the job done, and it's matured.
You may want to read it again. He outlined reasons * We're experts in it * We've got years of components that we can snap-in to new projects * We've invested a lot of time and money into being good at it * The frameworks built around it are doing some exciting things Better to be a master of one than a jack of all. 
In the PHP circle, you hear about how shitty PHP is. You'll hear the same things in just about any other programming circle. Like anything, people feel some need to be ridiculously competitive about something that doesn't matter.
&gt; Lifecycle of code FTFY.
Another reason, for me at least, is that PHP is the easiest to host and most widely installed.... next to Perl. Even MS supports PHP on IIS now. PHP is the new Java - "write once, run everywhere". Yeah the language is sloppy, but using a good framework cleans things up reasonably well.
**TL;DR** I have no idea how to engineer software
&gt; Day 215: Whoever wrote this class is a dick and I hate him. Ugh. Day 216: Apply for job washing dishes. 
Be careful with using empty(). If any method of the object returns false, 0, an empty string, etc., your __call method will return the object instead of the actual return value.
I think the main reason is that it is simple. So far it is fast enough, reliable enough, and secure enough, for several different things. It's not perfect, but it is OK for some things.
Ah, good point. I had dabbled with using the reflection classes to inspect the underlying object to try and determine if the method being called had a return type, but I couldn't see a way to determine that. Would there actually be a fool-proof way of determining whether a method had returned anything (whether it be empty, or `null`) or nothing at all? *Edit:* This very question has been [asked on StackOverlflow](http://stackoverflow.com/questions/1809764/check-if-php-function-returns-null-or-nothing) in the past. The answer seems to be: no, it's not possible. That's a shame.
I've never understood the hate against static functions.
I actually miss that, but I laughed when you pointed it out so thanks for that.
You'll want to wipe your demo site every so often, to avoid garbage posts giving your potential customers a bad impression. Fill it with random friends and data and reset it to those defaults more often.
only ruby coders masturbate to their own code. besides that youre right.
If you *really* wanted to, you could make sure every method has docblock comments, and then you could use PHP's reflection classes to check (specifically [getDocComment()](http://www.php.net/manual/en/reflectionfunctionabstract.getdoccomment.php)) if a method's docblock has @return in it.
Unit testing.
You might want to read it again. That's the same as any other language that any given shop uses. The exact same reasons shops claim when they continue to use Perl, Python, etc. Hiring around a single language should be one of Joel's checklist, but those aren't reasons to stick with php.
I'm actually in the process of transitioning it into a real community, the same way the vBulletin forums are quite active. Really dogfood my own product.
Why would a static method make unit testing any more difficult?
Why do you assume that they're making the argument as to why _you_ should use PHP? They're clearly not. They state that people wonder why **they** stick with PHP and then he clearly outlines it. You're right, those are legitimate reasons for any language but it sounds like you failed to understand the point they were trying to make in the first place.
Because they're hard to impossible to override. See PHPUnit's author [here](http://sebastian-bergmann.de/archives/883-Stubbing-and-Mocking-Static-Methods.html) or for more depth (but javabased) [one of googles test engineers](http://googletesting.blogspot.com/2008/12/static-methods-are-death-to-testability.html)
Static is pure evil. I really hate when I see applications use it. I can't extend it, I can't override it, it's useless in most cases I find.
also depricated.
Great job on your sales. I can see the potential with the "build your own modules". 
Seems a bit odd to have the css and js files as an array in your controller object, or am I missing something?
slim framework. class loaders. no other way getting out of this situation.
upvote cause i wanted to write the same but got comment time blocked. yes, the lithium framework is perfect to study because its the cutting edge what php can do.
Why can't you override it? In PHP &lt; 5.3, the _static_ keyword didn't exist-- but this was a problem with PHP's implementation of static methods, not static methods themselves. In PHP 5.3+, along with any sane OO language, you can extend static methods just as you can dynamic methods, and static methods are very useful. In fact, you probably use static methods without even realizing it. Do you have a method that makes no reference to $this? That's a static method, whether you label it that way or not.
look into the slim framework and fork.
This seems like more of a problem with people using static methods the wrong way (case: singletons). There is nothing wrong with static methods when they are used properly. When a static method is used properly, it _should_ always return the same output X for given parameters Y, independent of any outside variables and be completely stateless. Problems arise when people try to use static methods with state-dependent output. EDIT: In your second example, the author is upset that the method for finding an absolute value of an Integer is a static method instead of a dynamic method of an Integer class. However, what if you're using someone else's Integer library, and it doesn't have an abs() method? You're going to have to write your own, and where are you going to do that? If you want to make it dynamic, you're going to have to write your own SuperDuperImprovedInteger class that extends the other Integer class, then use that class in your application instead of Integer, just so that you can add a bit of functionality. Do this with every single foreign library your application uses, and it's going to get unmanageable a lot faster than a few static methods will.
activerecord objects. i use it with mongodb. the class that defines the collection data holds its fields and field infos. like user visiblity, type, preset infos etc. i also implemented hasmany/hasone relations so if i load the activerecord object it will handle further queries etc. im using activemongo. but there are others. same should apply for mysql.
function which doesn't return anything returns NULL. $ phpsh Starting php type 'h' or 'help' to see instructions &amp; features php&gt; function abc() {} php&gt; var_dump(abc()) NULL 
&gt; It has a significantly higher overhead than the individual $GET, $POST and $COOKIE variables. No it doesn't, $\_REQUEST is an array not a method. The $\_REQUEST array is already set before the first line of code in your script even runs (just as with $\_POST, $\_GET, $\_COOKIE). The order of precedence for a given array key is set with the request_order directive of php.ini and not sorted out as and when array is used. **tldr**: using $\_REQUEST is the same speed as $\_POST, $\_GET, they're just global arrays.
&gt; May not sound like much but keep in mind a script could reference $_REQUEST hundreds of times Oh god, what kind of scripts have you been reading? How many times does you need to access the same $\_POST data? I don't think I've seen many controller actions over one hundred lines of code, and only a small percentage of those lines will use request data.
The people who downmodded me are idiots. Their loss. I'd wager they've never looked at it.
What's the alternative to SuperDuperImprovedInteger? If some library doesn't have what you need you need to code it yourself. I don't see how this is relevant. Do you mean refactoring? Can you give some examples of when it's better to use static? I honestly haven't given it a whole lot of thought. I've had problems in testing, and I see them as globals, so I try to avoid.
&gt; What's the alternative to SuperDuperImprovedInteger? If some library doesn't have what you need you need to code it yourself. You could define a static method in whatever class you wish to find the absolute value of a given Integer object. Or just use a function outside of a class, if you have no objection to that. Let's call this **function abs(Integer $someInt)**. Remember that class-less functions (including core PHP functions) are essentially static methods without a class containing them. Now, if there is another foreign class (let's say PrimeInteger) that extends the Integer class, you can get the absolute value of its instances using the same abs() function. Since you can't change the class definition of PrimeInteger, you can't change it to extend your SuperDuperImprovedInteger class, and so PrimeInteger instances won't have the functionality you added in your SuperDuperImprovedInteger. You would have to write an additional SuperDuperImprovedPrimeInteger class and duplicate your absolute value logic. This is why extending classes simply to add functionality (as opposed to sub-typing the objects they represent) is in general a bad idea. It screws up your inheritance hierarchy most of the time.
Thank you. That's down the road a little bit development wise, but eventually I'd like to have an ecosystem where developers can build their own modules and publish them through our sales channel or theirs (or both).
right, so just define a plain old procedure. I don't see what this has to do with math::abs vs int-&gt;abs IOW, there are disadvantages to statics, what are the advantages? Aside from making shit global and easy to call.
Excuse me, what is deprecated?
&gt; IOW, there are disadvantages to statics, what are the advantages? The example I just gave you demonstrated an advantage. Let me ask you: what are the advantages to all of the built-in PHP string functions? Aside from being global and easy to call. The core PHP libraries _are static class-less methods_. They take input, and give you output based solely on that input. They do not have a state and do not require creation of an object to use. They just aren't wrapped in a class and you don't need to use the "static" keyword to define them. You aren't going to stop using the core PHP libraries because they make testing hard. You can't override the fact that your method makes a call to str_replace. So what? You can rest assured that it will always return the same output for the same input, because that's what the unit tests for str_replace are there for. Trying to isolate each of your units from each of PHP's core functions would be an unnecessary nightmare; the same is true for isolation from stateless static methods.
That's an incredibly ugly solution, IMO. Relying on code comments for functionality feels so wrong. What I would do is store the return value for the previous method call in a class variable and make a method to access it. So this: $details = choo(new User) -&gt;SetName("Eddie") -&gt;SetAge(14) -&gt;GetDetails(); Would become: $details = choo(new User) -&gt;SetName("Eddie") -&gt;SetAge(14) -&gt;GetDetails()-&gt;swallow(); // method name completely up to you :P It's more code, yes, but it makes a bit more sense. And you don't need to document how to document!
Let me test for you! &lt;?php class test { function foo(){ echo "bar"; } } $var = 'test'; class test2 extends $var { function fuz(){ echo "baz"; $this-&gt;foo(); } } $obj = new test2; $obj-&gt;fuz(); ?&gt; Returns: PHP Parse error: syntax error, unexpected T_VARIABLE, expecting T_STRING or T_NAMESPACE or T_NS_SEPARATOR in /home/slowbro/testphp on line 13 **BUT** you got me thinking, and I came up with this solution for you: &lt;?php class test { function foo(){ echo "bar\n"; } } $var = 'test'; ob_start(); ?&gt; class test2 extends _NAME_ { function fuz(){ echo "baz\n"; $this-&gt;foo(); } } &lt;?php $ev = str_replace("_NAME_", $var, ob_get_clean()); eval($ev); $obj = new test2; $obj-&gt;fuz(); ?&gt; Happy scripting!
&gt;Trying to isolate each of your units from each of PHP's core functions would be an unnecessary nightmare This is just silly now. If I'm writing code, then why should I use a static. It makes it hard for *me* to test *my* code. I'm not talking about the libraries you use. The advantage you've given is just procedural code. If you're going to OO then it seems silly to write procedural unless you absolutely have to.
All OO code is procedural, it's just broken up into smaller procedural chunks. And static methods, when used correctly, do not make testing any harder than PHP core libraries do.
But in this instance, what is the difference between: function abc() { // don't do anything! } And: function def() { return NULL; } ... and can you ever determine the difference?
Yes I stick to PHP because I also have to stay competent in sql, html, css, javascript, jQuery &amp; photoshop and it's time consuming. And I think it takes more time to dive into Zend Framework or Symfony 2 than learning that that new magic-language-that-hipsterz-says-it-s-magic-but-will-improve-barely-anything-and-whoes-hosting-will-be-crap but it's more valuable. So ... :)
there is no difference
Holy crap. You started off sounding intelligent. Now you sound like a creationist with his fingers in his ears shouting "lalalala I'm right". If you want to say all OO is procedural, why not just jump to ones and zeros and say punch cards are as good as high level OO languages? I've asked repeatedly for you to provide some context where using static is better than not. All you've come up with so far is that if you follow all the rules it doesn't make testing any harder (despite the author of php's only real testing tool advising against it), and that if you had a library you might need to write a procedure if it didn't do everything you want. PHP being procedural is not a reason static functions should be used. I dare you to suggest that PHP would be worse off if it was more OO, e.g. all the fucking substr($haydle, $neestack) vs $string-&gt;substr($needle).
Please tell me how you would solve the problem I addressed in [this post](http://www.reddit.com/r/PHP/comments/fs2ey/lifecycle_of_a_php_class/c1i9y2y): 1. using pure OO as you see it 2. without using static methods or a "procedural" function (they're one in the same, just named differently) 3. without duplicating code (the problem was that you have an Integer class and a PrimeInteger class that extends it, and you need to be able to find an absolute value for each type without modifying the original classes) I'm still not quite convinced you understand what a static method is, aside from "a method with the word static in front of it". I've explained it several times but you seem to have blindly ignored my explanation each time.
The thing is, the problem you propose isn't really relevant to the question I am asking. And I was genuinely asking it. I admit there are cases (you could wrap the library, but lets just consider the real world where things need to get done) where you are **forced** to use a procedure, I am asking why I would use static functions in my own code (think my framework, db, models, etc) over OO. If I've blindly ignored anything, please state it and I will be happy to admit so.
I hate to be the boring one but, may I ask *why* you are trying to do this? What problem are you trying to solve? If you're just trying to find out if you can do it for the hell of it then that's cool; but, if you're trying to solve a real world problem there is quite possibly a better solution. As a pure guess at what you might be trying to do, have you considered the [decorator pattern](http://en.wikipedia.org/wiki/Decorator_pattern)?
That's a very creative solution, but you'll break your head later why you had to did this. Don't do it.
Thanks! I'd never use it myself, but it's the only solution I can think of to the problem.
*That* is the right question. The answer to nearly all programming questions asked in various places is, "that depends on what you are trying to do and *why* you think this is the way to do it". And the OP questioners *hate* that!
Alternate solution: &lt;?php if ($_POST['q'] == '') { class_alias('class_name_1', 'class_to_be_used'); } else { class_alias('class_default', 'class_to_be_used'); } class class_name extends class_to_be_used { // do something } ?&gt;
decorators...still can't quite get those working...
Something like this in order to be done right needs to be done as a PECL extension.
If your using static all the time you've designed your script bad. Too many devs I see are too lazy to use dependency injection or containers (or they just dont understand it) and just call everything they need via static calls. I'm not saying its completely bad, its useful in SOME cases like for singletons. Its just hard to replace because the name is also coded in. If you had some company version-controlled framework, and some guy who wrote the framework decided to code it so the router was used as static calls and you wanted to change the router for a specific website to do something unique, you wouldnt be able to without modding the core router class because he hardcoded the name everywhere without dependancy injection, and thats bad not to mention how hard it would be to unit test crap that is hard coded into an application, you can't mock it. All I'm saying is, watch how you design your applications, use static WISELY and rarely IMO... unit test them, you'll see how bad it really is for extendability of a core application.
I sometimes use them for method-specific recursive functions that don't need to be class methods.
I'm learning the basics of the ZF right now and it's the first framework I've ever tried...Could you briefly explain me in which cases you'd rather use Symfony than ZF?
I've written a really simple (and somewhat contrived) example for you to get you started: &lt;?php abstract class Decorator { protected $parent; function __construct($parent){ $this-&gt;parent = $parent; } function __call($method, $args){ return call_user_func_array(array($this-&gt;parent, $method), $args); } } class Coffee { function stir(){ echo "Stirring the coffee\n"; } } class Tea { function brew(){ echo "Brewing the tea\n"; } } class Milk extends Decorator { function addSkimmedMilk(){ echo "Adding skimmed milk\n"; } function addFullFatMilk(){ echo "Adding full fat milk\n"; } } class Sugar extends Decorator { function addSugar($spoons = 1){ echo "Adding {$spoons} spoon(s) of sugar\n"; } } //Coffee, milk and 2 sugars: echo "Make some coffee:\n"; $coffee = new Coffee(); $coffee_milk = new Milk($coffee); $coffee_milk_sugar = new Sugar($coffee_milk); $coffee_milk_sugar-&gt;addFullFatMilk(); $coffee_milk_sugar-&gt;addSugar(2); $coffee_milk_sugar-&gt;stir(); echo "\n"; //Tea, milk and no sugar echo "Make some tea:\n"; $tea = new Tea(); $tea-&gt;brew(); $tea = new Milk($tea); $tea-&gt;addSkimmedMilk(); Output is: Make some coffee: Adding full fat milk Adding 2 spoon(s) of sugar Stirring the coffee Make some tea: Brewing the tea Adding skimmed milk The main disadvantage to using decorators in this way is that you loose type-hinting. The main advantage is that you can re-use code really easily. There are other more subtle pros and cons, however. If you are using a language like Java, or you don't want to lose type-hinting, you can make your decorators extend the object you want to decorate. I personally think the decorator pattern does have its uses; but should be used sparingly. I've worked on a pretty large project that uses it a lot and while useful, it did get rather confusing at times. 
Perhaps in combination with concat() when you are trying to pad something out.
Unless you want to use unsigned integers. ;)
If you needed to export data in a fixed column width format, this would be handy I guess :)
There's lots of cases where for formatting reasons you might want fields space-padded to a certain length. This was especially true in the old days of daisy-wheel, dot matrix printers and text-mode terminal displays. It seems useless in today's HTML-based environment where extra spaces get ignored, but there was definitely a use for it in the past. And space-padding text fields is not necessarily totally useless today.
As an older Redditor, +1.
Um, static functions have existed since PHP 5.0.
tl;dr: inertia
An example of PHP classes, showing how to override the constructor and other functions. class class1 { public $myVar; function __contruct($var){ $this-&gt;myVar = $var; } function myFunc(){ } } class class2 extends class1 { function __construct($some_value){ parent::__construct($some_value); } function myFunc(){ // this function automatically overrides the function in class1 echo $this-&gt;myVar; } } $obj = new class2("hello, world"); // EDIT - was missing my second quotation $obj-&gt;myFunc();
That is there so you can, within an action, specify a JS or CSS file to add to the &lt;head&gt; tag in your layout. Ideally though you don't access the array directly, you would use the function within the base controller to add to it.
Why would **we** care why they use PHP if it doesn't apply to *us*? There is a good answer to that question, of course. At the beginning of the article they explained that the motivation for it was questions that their potential employees and clients wanted to know, so apparently he wrote this post to have a clear, well written, well thought out answer to that set of people. Unfortunately that means that this article doesn't really do much for the rest of us, so its a reasonable criticism to make of it appearing here on reddit. 
It doesn't apply to you or me but it does apply to people who are stupid enough to think that they should use a language because it's the cool thing to do. Something a lot of people in programming on Reddit seem to think. It's something many people don't consider. My company is one example of that. Working with proven tech that you have experience with is just smart. In the future, don't get ruffled because people are saying things that don't matter to you. You can choose to ignore them.
I would think RPAD() would be ideal for that.
Don't remember what framework used a similar approach yet it was along the same lines. It looked like: eval('class _Controller extends '.$controller.'{}'); class Controller extends _Controller { /* ... */ } However, personally would never use that and would strongly suggest you stay away from this methodology. Celtric has a possibly interesting solution, and the same with footle. Most likely just need a little refactoring instead.
That's the only thing I can think of as well. Definitely not an everyday usage case for most people.
It seems like a generic string multiplier would be more sensible than this. Why not have a function like ZERO(5) print five zeros? or DASH(5) to print 5 dashes?
Yes, but sometimes you need padding in the middle, or in ways that lpad/rpad are too simple to handle.
Here is [why](http://www.google.com/imgres?imgurl=http://static.phparch.com/phpa/apparel/img/items/full/php-ball-of-nails.png&amp;imgrefurl=http://phpadvent.org/2009/1500-lines-of-code-by-terry-chay&amp;usg=__aikFtGe2HdKiwW_dz02dUBeXNyM=&amp;h=223&amp;w=600&amp;sz=96&amp;hl=en&amp;start=0&amp;zoom=1&amp;tbnid=Wsl7MyF2jdqMVM:&amp;tbnh=72&amp;tbnw=194&amp;ei=74ZmTaGLKcPVtgfhqZjoAw&amp;prev=/images%3Fq%3Dphp%2Bwhere%2Byou%2Bthrow%2Bit%2Bsticks%26um%3D1%26hl%3Den%26sa%3DN%26biw%3D1440%26bih%3D743%26tbs%3Disch:1&amp;um=1&amp;itbs=1&amp;iact=hc&amp;vpx=81&amp;vpy=126&amp;dur=4106&amp;hovh=137&amp;hovw=369&amp;tx=132&amp;ty=77&amp;oei=74ZmTaGLKcPVtgfhqZjoAw&amp;page=1&amp;ndsp=28&amp;ved=1t:429,r:0,s:0). 
Some people may think they "should" use a language "because it's the cool thing to do", however I think a lot of people who are in the position of deciding on a language to learn or use are interested in what advantages a language might bring them. Then when they see an article on Reddit with a title like this one they might spend the time reading it, thinking it was written from the perspective of someone genuinely considering a similar choice. When they instead find out that the answer is "because we're already using it, it works for us, and we're not interested in changing because that would be too much trouble, even if the alternative might be superior" they might be justifiably annoyed that they wasted their time. 
Yeah, you're right. It's really misleading. With an article titled: &gt; Why **we** stick to PHP I can really see how someone might spend a precious 5 minutes reading the article and then say, "But this doesn't apply to _me_!" because they lack basic reading comprehension skills. Once again, I feel the need to mention that they covered that they didn't feel that languages like Python or Ruby were superior on the basis that they all are capable of producing the same product as PHP. In other words, all the options were on equal footing so the only reasons to stick to it were personal. This article would be no less valid (if somewhat confusing) if you were to replace all instances of "PHP" with "Python" or "Ruby". The fact that the article is entirely anecdotal does not invalidate the points being made nor does it become less valuable to people who do not work for or with that company.
Aren't you marvelling at the potential of server side scripting now? Have you not decided to stop avoiding it like the plague?
Backward compatibility?
Ahh nice. I can see how it would work well with recursion. Thanks for that :)
As explained many times, and I very much expect to be downvoted for this, PDO is shit. "Cross-compatibility" is a joke with databases; you might as well use the correct library for each database. "Oh noes, I have to write my own code", says /r/php and all these other software engineers, the idiots who cannot write real code but spend all day discussing the best way to run a super controller mega extension method control unit test. Spend 20 minutes doing something worthwhile instead of gluing together other people's crap.
True.
&gt; but it sounds like you failed to understand the point they were trying to make in the first place. Why we stick to PHP Because it's expensive to switch technologies. I didn't fail to understand anything. It would have been better titled, Why we don't change. Has nothing to do with PHP, per se.
First of all, thanks for taking the time to explain this to me...it's rare to find someone who does what you did instead of giving newbies a hard-time while trying to look cool himself. I got where you were going to with this. I thought Decorators were more like...view or controller helpers. What I can do with this instead is nesting classes or something like that?
SSH tunnels are much easier aren't they?
There is FreePascal, which can be used basically, but many Windows-specific things appear to have been used, which are not yet available in FP.
Interesting I will look into it. I may even consider running MongoDB specifically for this purpose.
OP, not your answer, but NEVER use unsanitized POST or GET variables directly into your code, especially in a logic construct like in your example. Sanitize them first and assing their value to a normal variable. Even if you aren't planning on sending their value to a database people can still inject code into your script using unsanitized POST or GET variables. 
First of all, if you wrote the damn code why didn't you just run it to see if it works instead of asking on here? It probably would have taken less time. Second, this is a bad idea. It smells bad. Third, if you really want to do it, here's how: if (class_exists($classname)) { $myobject = new $classname(); call_user_func(array($myobject, 'someMethod')); # or $myobject-&gt;someMethod($arg1, $arg2, [...]); }
As hopeseekr stated, static methods have been there since PHP 5. &gt; In fact, you probably use static methods without even realizing it. Do you have a method that makes no reference to $this? That's a static method, whether you label it that way or not. It's only static if you declare it static or access it through the scope resolution operator.
I'm all about using the right tool for the right job. My current company has yet to give me enough time or a small enough scope to do anything more than beat nails in with the side of a saw. That being the case, I don't spend time on extensibility or writing my own quality code and instead spend my day gluing garbage together and hoping it doesn't break before I abandon ship.
yeah it looks like thats the situation in this subreddit. you tell someone with a mysql question to use mongodb cause it fits better and you get -20 even with supplied example code... weird.
if you need example code (php) let me know
http tunneling helps if You don't have ssh access
I should have clarified. I meant the _static_ keyword has only been usable for Late Static Binding since 5.3.
There are quite a few reasons to choose Symfony over ZF. Symfony has more of a defined application structure compared to ZF. If you don't want to make architecture decisions or decide how permissions should work, etc then I would take a look at Symfony. With ZF, you can build an equally robust application, but it will take more work to get some of the 'gears' in place since you'll have to create those parts. I've worked with quite a few ZF apps, and only a few Symfony apps. I would say all of the ZF apps were very different from each other, where the Symfony apps all worked the same. The automatic admin feature and the included permissions library (sfGuard) are among the biggest reasons to use Symfony. You can always include ZF as a 3rd party library too.
This idea smells. I would consider using a factory or abstract factory pattern. Here's an overview on Wikipedia: http://en.wikipedia.org/wiki/Abstract_factory_pattern . eg ` class myAbstract1 { } class myAbstract2 { } class concrete1 extends myAbstract1 { } class concrete2 extends myAbstract2 { } class abstractFactory { public function create($type) { //construct instance based on type return $instance; } } `
No he didn't he's talking... (does a google for the term).... well what do you know, he's right!
Interesting, it's never caused me a problem on XP or Windows 7, but each to their own.
its nice for making a CLI script to add/remove/edit things in outlook, like adding tasks/appointments
I spend some of my time this weekend reading your code and studying your project. I really like the way that you are doing it. One thing that took me a while to grasp is the getCache method $stash = StashBox::getCache('models', 'users', 32, 'info'); it is really nice once understood, but I really think that you should start to explain it the way that APC does it. $bar = 'BAR'; apc_store('foo', $bar); var_dump(apc_fetch('foo')); How come you chose to separate the naming of a cache, and the storing of a cache? I also found some spelling errors in the docs, most of them is about MultiHandler written as MulitiHandler and MuliHandler. But nothing major. I tried to edit it to help you, but I think you need to subscribe to the project in some way i couldn't figure out.
I'm glad you like the project- it's always a bit nerve racking to put code out there, so that means a lot to me. I updated the frontpage documentation per your suggestion. I have to add you to the project before you can edit any of the wiki pages, so if you're up for it just let me know your google account info. As to the naming thing- honestly, I thought it would be easier this way. I wanted to keep the naming from the cache separate from the actual functions because of how the whole get/isMiss/store process works. I figured it would be annoying if I had to type the key out for each call (although I guess it could just get stored in an array). Honestly though I just like the concept of each Stash object representing a specific cache item or node, and since handlers can be reused there is minimal overhead. I added the static functions in the two wrapper classes to streamline the whole process for the function calls outside the get/isMiss/store blocks because in those contexts it makes more sense not to separate things. On a side note I was actually planning on poking you today- I finished the first version of the memcached handler today! It works with the newer memcached extension, not the older memcache one (although support for that is planned). It passes all the tests on debian with php5.3 (getting the hierarchy stuff working was a fun challenge). It still has a bit of work (particularly on the documentation side), but I'll be working on it a bit this weekend.
i dont sent any parameter to sql. This post is for selecting entends classes. Maybe I can use define() for config file?
thank you very much for solution. i found like this example. But i dont want to use eval in this problem, even if I dont found anything.
are there any advantages over [MySQL Workbench](http://www.mysql.com/products/workbench/) (from MySQL AB)? the community edition is open source (GPL) &amp; free.. runs on win/osx/linux..
I love how your entire Decorator class is glue code and no real work. Downvote for you. And yeah, I can expect the software engineer "WELL Y U NO USE ASSEMBLY DEN LOLZ!!12"
Reddit isn't traditionally what one would call a CMS. Perhaps try searching for a social bookmarking script.
[Pligg](http://pligg.com/)
What do you actually want? Reddit is not a CMS, and not written in PHP.
you would probably have better luck with one of the many digg or StackOverflow clones out there which have much of the same functionality of reddit. such as: * http://hotarucms.org/ * http://www.kubelabs.com/phpdug/ * http://www.question2answer.org/ * http://www.qandasystem.com/
And what else should the decorator class do, exactly? Especially in such a simple example, I see no need for it to do anything else. I have updated my example to make the decorator an abstract class to make it a little more clear that it's not something you would create an object from directly. I really don't see what you're getting at; sorry.
You are most welcome, sir. You can use decorators for whatever you want, really. I think of them kind of like run-time, re-usable inheritance. I know that's not a very helpful explanation; what I really want to get across is: don't go looking for problems to solve with them - wait until you hit a problem that they solve. Design patterns are terrible for the "when you have a new hammer, every problem looks like a nail" thing. As an example of where I have seen this used in production: we had a few different models that all needed a street address; let's say a 'person' model and a 'building' model. All the addresses were stored in the same database table, and the address didn't always need to be loaded, so we wrote an address decorator to handle all the address logic and CRUD. Both the 'person' and 'building' models implemented an interface to say that they could be decorated with an address; the interface specified that that model must provide a 'getAddressId' method and 'setAddressId' method, which were used by the address decorator. That way, we could attach a street address to any object that implemented the right interface without worrying about any of the address CRUD etc more than once. I'm not saying it's the best solution to the problem, but it did work well for us. There's always lots of ways to skin a cat. 
I can't really say I see any advantage of his example over yours. ONe thing can be validation - while creating the object you can check if the constant exists in the class and throw an exception if not. Also it could be used while working with IDE - and IDE would know what Class::MEGA means, but wouldn't have any idea about 'Mega' (string).
Pligg sucks... use http://hotarucms.org/
The reason for using the consts are twofold: it provides an easy list of actually available values (through the consts in the class in the IDE), and it allows the actual value to change without the calling code having to be updated (which you'd otherwise have to handle with a mapping from 'Mega' to the desired value, with will then just be an implementation of consts without the context). Whether it's common practice depends; some coding standards use it, others don't. You'd be able to write readable code regardless of which method you use.
I like this solution. Personally do not have a use for this yet think this would be the best was of doing what the OP asked for. Also, happy birthday OP.
It also protects against programmer errors. If you just use a string, you can enter something that isn't a valid mode (let's say you forgot to capitalize it) and your script is none the wiser until it causes problems later on, which can be difficult to debug. If you, on the other hand, provide a constant that doesn't exist, PHP will throw a notice. It's pretty standard practice among programming languages to use constants or enums (PHP doesn't have enums) for things like options/modes and also for "magic numbers" (see [this](http://en.wikipedia.org/wiki/Magic_number_\(programming\)#Unnamed_numerical_constants) for more information on that). 
Constructive arguments ftw :)
If you are thinking of using this (or already using it), I strongly suggest you audit the code first. And then don't.
Since nobody has commented on the switch statement, I'll throw in my two cents. I think it makes a big difference in scaling to many branches readably; If you're potentially going to be checking for many possible values (more than 3-4), having many elseif blocks is less readable than many "case" blocks in a row. In the end though, it's just another tool in the toolbox. IMO, farsghtxr20 has it right about the biggest benefit of constants though; The language will quickly make errors obvious. Additionally, if you want to change the constant, it means changing one instance rather than searching through who knows how much code to change all instances... No to mention far less ambiguity - a reference to ClassName::CONSTX can only possibly refer to one thing, which does not hold true for an arbitrary string or integer. It makes me cringe to see the same string used several times in a class, or "magic" uncommented integers; $mode = 3? Great! WTF is 3?!
I've upvoted the four of you (BTMPL, fiskfisk, farsightxr20 and naberus) for responding with some great insights -- you've made me consider a few things that I hadn't previously. If anyone else would like to add a comment, feel free -- I like learning these best practices, etc. Far better to get them now before I develop bad habits. Thanks.
Another vote for Yii here. Using it professionally as my main framework for over a year now and I still continue to be impressed by it. Currently building an enterprise level web application with it and finding it a joy to work with.
I think you'll find that the more you code, the more you'll develop habits that are beneficial. Think of it more like practice makes perfect rather than better to fix everything up front. (I.e. a good coder tends to always seek out better ways to do things, so their coding style and practices are always improving.)
There is currently discussion on the internal-list abot enums, which might make an appearance in the PHP/next, whatever version that turns out to be.
ok,...silly question then: Do I need to somehow flag the classes which might or might not be decorated afterwards?
Yeah, I know what you mean. I'm just getting into Zend_Acl and while it's probably not that hard tog grasp it's far from authomatic
Wasn't that given away by 'PHP based Reddit type' in the title?
The source code and license for *Menéame* (pretty much like Reddit) are open, although the out-of-the-box version is a bit "bloated" for my liking you can customize it and strip it down. The original is in Spanish but I think the code and documentation were translated to a few other languages. [Here's a link](http://meneame.wikispaces.com/Source+code) to the source and doc. 
Drupal and a few contributed modules can get you most of the way there. 
you can perfectly do this: $class= 'Foo'; $bar = new $class;
I use Drupal a lot... but it is only really good for sites where the majority of users are anonymous, otherwise it just doesn't perform.
You're welcome, and I don't blame you! :P Also, Happy Reddit Birthday!
To avoid this devolving into some kind of flamewar, I respect your opinion but humbly disagree as I personally run multiple drupal sites with &gt; 8k constant, simultaneous logged-in users. Of course, you'd never run Reddit, itself, on Drupal. However, given what the OP's use-case is (ie, I doubt he'll be running a site even remotely approaching Reddit's traffic), we both know we can recommend it for that purpose :)
Shame it sucks though...
(Not to say this is a good way but...) We define an array that describes the fields of a $table and there's a corresponding data array created. We populate as per $this-&gt;data = (get row). Then whenever we say $table-&gt;table_id __get is called, we check the array, then pull it from the data array or we then check the object for a traditional object property (with some consideration for visibility).
String switching can be done, but you want constants. switch(true){ case ($this-&gt;object_type == 'Mega'): return "MegaCal header\n"; default: return "BloggsCal header\n"; } $mode is a badly named variable.
Shouldn't `$this-&gt;data-&gt;$table_id` work? Alternatively, you could experiment with the third code example [on this page](http://php.net/manual/en/language.variables.variable.php).
You can accomplish this using curly braces: $s = 'bar'; $foo = new foo(); echo $foo-&gt;{$s}; echo $foo-&gt;{'bar'}; //works too
 $this-&gt;data-&gt;$table_id Unless I've misunderstood you completely, and in that case I'm sorry.
create a return function, something like $table_id = 'some_id'; class genericTable() { function __construct() { $this-&gt;data = $this-&gt;get_db_array(); } function get_var($id) { return $this-&gt;data[$id]; } } then when you want the var you call $table = new genricTable(); $table-&gt;get($some_id); it's cleaner in the long run and reduces the amount you are accessing the db. plus you could run through the $data array using foreach or pretty much any array functions
Only if $table_id is defined within the scope of that function. If it is defined in the class properties, $table_id would have to be access by $this-&gt;table_id or self::$table_id, in which case, how would you access that property?
See my reply to Gliridae. I need to access the property within a class, so: $this-&gt;data-&gt;$this-&gt;table_id. That is incorrect syntax, but logically, it would be something like: $this-&gt;data-&gt;($this-&gt;table_id).
Switches evaluate more quickly. It's not a big deal for this trivial example, but if you have a bunch of cases to try, it can add up (however slowly). Plus, as others have mentioned, switches are much better for readability.
Oh, in that case you can use $this-&gt;data-&gt;{$this-&gt;table_id}
This big issue is this: $comms = new CommsManager( 'mega' ); Can you spot the error? You think you're getting "MegaCal header" but you're actually getting "BloggsCal header". 
What did he post, BuddyPress?
It's true, though. I've used pligg precisely once - for [a site I set up](http://www.hiv-nutrition.com/) and then immediately forgot ever existed. I remember it being a bit clunky. Maybe I'll redo that site in this hotaru and then forget it again.
No, Boonex Dolphin.
some code would help a lot more in debugging this, could you post it on pastebin? as for the mail server, if you have a gmail account, you can use smtp.gmail.com to test sending your emails.
Side effect of Python.
It looks like you're writing the script for a server with register_globals turned on, and WAMP does not enable register_globals by default because it is a deprecated feature. Try replacing $name, $email, etc. with $\_POST['name'], $\_POST['email'], etc. Also make sure your form's method is set to POST. [More information about register_globals](http://www.php.net/manual/en/security.globals.php). In short, it's a bad idea to use it, because it allows anyone to inject arbitrary variables into your script. You should always use the actual superglobal arrays ($\_POST, $\_GET) to read values submitted through a form or the querystring. EDIT: The mailserver error is exactly how it sounds... you don't have a mailserver, which is required to use mail(). You can either: 1. install a mail server 2. use gmail as scriptmonkey420 suggested 3. save the form submissions in a database or text file and check the directory/DB regularly for new messages
Hi all, I'm working on a threaded forum plugin for symfony, which I've named marae (Maori for meeting place - I'm a Kiwi). It supports fully nested forums and posts. Currently you can start new topics, reply to posts, edit them, and delete them, and I've just added being able to upvote/downvote individual posts, reddit style. An example site (the site I'm using it for) is at http://www.xiphosgame.com/forum It's licensed under LGPL. At the moment I'm looking for feedback and/or fellow collaborators! There aren't any threaded forum plugins for symfony aside from Marae (the reason I started it), and I wasn't able to find any which integrated easily. Thanks for checking it out!
mail() relies on sendmail, so you'll need to install it (or sendmail wrappers for any other mail server you may be using). You may want to look at using something like PEAR::Mail (not my first choice), phpMailer or SwiftMailer, etc. to send mail over SMTP instead. If you want to send mail via GMail, you'll also need SSL support.
your link is 404'ing btw. I will check this out. Did you use native ORM methods for the nested set behavior or did you make most of it yourself?
`$this-&gt;data-&gt;{$this-&gt;table_id};` but I recommend writing a getter in the class of `$this-&gt;data` (but not `__get()`!) instead of exposing it through a member.
Thanks - it was the full stop at the end of the URL. I'm using the native Doctrine NestedSet behaviour.
Thanks guys! It was the email server like you said. I decided to go ahead and publish it to my server to avoid installing a mail server on my local machine. New problem though. When I receive the email from the form the Name, Email, Comments and senders email fields all show up blank. Everything else works great. I've checked over my code for misspellings and can't find anything. Here's the link to pastebin, http://pastebin.com/PK6x9U8y
Thanks for the help. Posted pastebin link.
Thanks for the help. You're right. I ended up posting to my server to avoid installing a mail server on my local machine. I have a new problem though. See comment.
Thanks for the help. You're right. I ended up posting to my server to avoid installing a mail server on my local machine. I have a new problem though. See comment.
 class CommsManager { // Factory method pattern static function createInstance($mode = '') { // Assume consistent naming convention $classname = $mode.'CommsManager'; if (class_exists($classname, true)) { $object = new $classname(); assert($object instanceof CommsManager); return $object; } throw new Exception("No such class"); } function getHeaderText() { return "BloggsCal header\n"; } } class MegaCalCommsManager extends CommsManager { function getHeaderText() { return "MegaCal header\n"; } } $defaultCommsManager = CommsManager::createInstance(); $megaCommsManager = CommsManager::createInstance('MegaCal'); //alternatively: $defaultCommsManager = new CommsManager(); $megaCommsManager = new MegaCalCommsManager(); Otherwise kinda of defeat the purpose of using Object Oriented Programming. You can then keep adding new CommsManager without touching the code for the existing CommsManager. And if your code turns out to call getHeaderText() a lot, this method should be faster. Edit: bugfixes.
not really python, more that reddit was built, fixed, rebuilt, fixed, fixed, fixed...
Can you post the HTML for your form as well?
What kind of software/hardware setups are you running those sites on?
Reflection.
If you're a "total noob" to PHP, putting a form like this on your web site is a recipe for disaster. Use a third party hosted form service such as http://wufoo.com until you understand properly what you are doing.
If I were to guess I would guess the problem may be in the html, but then again I don't know enough about this stuff yet. The email server that this is going through doesn't require authentication if that matters. (I know it says gmail in the script but that's not the email addy) html link: http://pastebin.com/YZ15U2xP
It's just a temporary website. More of a learning tool for me than anything else. Working so far. :D
While nested set is considered great for reading data, writing can be costly. How scalable would you see this being?
Oh, the mistake is in your PHP actually. Your variables are named $nameField, $emailField, $commentsField, but you still try to insert them as $name, $email, and $comments. Just drop the "field" from each of the variable names when you assign them.
What kind of validation and sanitization do you have in place?
That was it! Thank you so much. I knew it was going to be something like that. I've just been looking at it for too long.
I did client side validation through Dreamweaver on the name and email fields. Name, anything; email, a valid email. I'll prove my noobness on the sanitization though. Should I do this as well? 
You should read this: http://net.tutsplus.com/tutorials/php/sanitize-and-validate-data-with-php-filters/
Always validate and sanitize user input on the server-side. You can use client-side validation as a convenience to the user and reduce some server load from requests with errors, but anything going through PHP must be validated and sanitized by PHP too. No exceptions. Ever.
That's where I got a lot of my information I guess I just didn't get that far yet. Thanks for the help!
So is it overkill to do both, client and server side?
No. They accomplish different goals. You MUST validate and clean your input on the server-side because people don't actually have to use your form to submit a form. They can create their own form and target your server or even just send HTTP header requests without bothering to use a web browser. Since you have no control over the client, you have to take matters into your own hands. Always. Validating and sanitizing input client-side can be a nice usability improvement. Something like letting someone know their email address fields don't match before they submit a form is a nice touch and convenient. It can also prevent most of your legitimate users from sending submissions that won't pass the server-side validation. This can reduce a lot of load on a high volume site. If you have the time and inclination, it can't hurt to do both. Just make sure the validation rules are the same on the client and server-side or you can make life very frustrating for people.
A friend of mine who's actually a network guy said that since there are no variables in my XHTML there was no need to output PHP. If that's the case is there still need to validate and sanitize? 
Are you accepting user input?
Yes, I suppose. So I guess that answers my question?
Much better (although factory may be a bit overkill). Looking at the example my first thought was, who would ever create a class like this? It's a class. Subclass it to override something...
 class test { var $table_id = 'test'; function __construct() { $this-&gt;data = new stdClass(); $this-&gt;data-&gt;test = 'woop woop woop'; } function get() { echo $this-&gt;data-&gt;{$this-&gt;table_id}; $tmp = &amp;$this-&gt;table_id; echo $this-&gt;data-&gt;{$tmp}; } } $t = new test(); $t-&gt;get(); Both examples work just fine.
There is absolutely no reason to do that. PHP has these wonderful things called associative arrays. They are perfect for this and can easily be iterated over via a foreach.
A good question. There are always more reads than writes in webapps including forums, however. Features such as requring a minimum post length and being able to upvote/downvote posts should discourage short 'I agree'-style posts. I doubt this will be the bottleneck, but you learn these things from seeing real world data. 
Your "die" message doesn't have to contain details of your database schema or the query that you were trying to perform. If you let MySQL dump its own error then it could reveal your whole query.
Short answer: yes! The best way of "flagging" these classes is to have them implement an interface. In my example of the address decorator, the interface might be called "CanHaveAddress" or something like that, and would guarantee that any class that implements that interface has methods for getting and setting an "address ID". Even if your interface is empty and called "Decoratable" it can be of use to people reading the code - as they should quickly realise that an object of that type may be decorated, because the class implements the "Decoratable" interface. 
Only time will tell. Nevertheless, this is a great plugin. Thank you very much.
It was fixed? I thought they just hobbled it together and then gave up... Not to mention that the open source branch is far from what they're using on production...
the open source branch is a nice gesture but it took me a week to build in spam filters and user blocks and shit like that. its also on postgres and i never worked with postgres so that part is pure magic to me. also my install (fuddit) is constantly down because the daemon randomly dies for no reason... i bet i could rebuild with php and mongodb the same result in a couple days. since all the algos are missing...
Do it! Make it open source and call it NotReddit :P
i have a prototype with templating, upvote &amp; karma algo, db schemes for nosql etc.... cause i wanted to code it myself before they open sourced it. if there is interest expect a repo on github called notreddit in a week. (serious, no kidding) btw. i wrote this on an afternoon cause i was bored... (related) https://gist.github.com/295338
i won't address the security issues in your script, but here are some dummy smtp servers: java jar http://www.aboutmyip.com/AboutMyXApp/DevNullSmtp.jsp win32 exe http://www.cylog.org/tools/smtpdummy.jsp
I agree with this. The advantage of OO is that you can keep creating children of parent classes that inherit all the methods of the parent. Makes everything more organized and easier to maintain, IMO.
I do not like Workbench. It's very slow at times, it crashes frequently, and the query browser/administration plugins aren't very useful-even the old standalone Query Browser/Administrator tools were better. The modeling tools in Workbench are still fine, but that's about all I use it for. It is free, so I guess you get what you pay for. I'm an SQLYog fan-my work bought it a while ago and I love it.
you should write a book on this. Haa at least I'm understanding stuff in here I didn't understand on some tutorials I read before. Thanks again!
right, it doesnt have to include database details but the example said or die(mysql_error()); which will include database details
I have considered writing a book; but I think I could only manage it if someone asked me a few questions for each chapter. There's plenty of books out there on design patterns and stuff anyway; pretty sure there's no point in me writing about something that people far more clever than me have already done to death. Out of interest: what kind of thing would you want from a PHP book that's not just the same as all the rest?
Actually a couple of months ago I started studying php with a guy who had a pretty cool and personal way of teaching too. I think the best thing about his way of teaching is that he guided me through the creation of this dynamic website and of course it was all structured programming but with so much refactoring and the filesystem structured in a way so that the transition to OOP seemed almost effortless. I don't know how much sense I'm making since English is not my first language...but the point was that all the different files with functions ended up looking pretty much like classes, so I'd have a db.php, users.php, guests.php, admin.php and the different controllers. The result was far from MVC but after that grasping the basics of OOP wasn't that hard..but I'm human so I still find difficulties in understanding some concepts and patterns...and of course..when to use them
uhm... have you even seen what HotaruCMS does contrary to Pligg? Have experienced the problems that Pligg owners go through? *Serious karma-whoring here on your part.*
Nothing open source / CRM but we have been using Google Apps and with shared contacts anyone in the company can edit/update contacts in the 'global address book'. Works very well. 
hrm.. never had any performance issues with it, but I admittedly haven't used it on any servers with what i'd consider "big" databases. i've only used it on windows (client side, i mean, obviously) also..
From a security stand point... This is a horrid idea. Each person can export? 
I did a Google search for web ldap. Found a couple of items, including this one. http://ldapweb.sourceforge.net/ Good luck. Good idea, by the way. 
I just finished a phone directory at work that is Drupal based using CCK and views. You can check it out http://www.syracusecityschools.com/?q=directory
The size of the database hasn't been a factor. My problems stem from the UI, difficulty to find some things, can't open multiple query tabs without opening a new connection, the admin plugin crashes from time to time, and just general sluggishness. I haven't used it in a few months though (5.2.16 I think), so maybe some of that's been improved by now.
From a learning stand point, what is this a horrible security issue?
Upvote for also using Yii. We must stick together here. We are few and far between :)
Having every employees contact information in one form that anyone of them can export. It may not seem like a big deal, but I have read it over and over again in so many security books. The social engineer comes in "hey I forgot my copy of the contact sheet, could you print one out for me?", or "fax it over to so and so". The way it should work is it shouldn't be fully visible. Only see the contacts made by request.
This is a comlicated question. It depends on what your bottleneck is. Some file systems on linux are cached in unsused memory, so frequently used files may sometimes be in memory implicitly and other times not, which would make speed vary. If the file is cached in memory, it will be wicked fast. Depending on the number of files being cached, it could depend on if your file system is optimized for handling a billion files or not. Most of the time the answer is not. Some database systems cache frequently used results in memory impicitly (mysql does if query cache is turned on). If most of your system memory is used specifically for mysql key and query caching, then it will probably be faster if your database handles it than your file system. To throw a further wrench in your machinery, I would recommend caching directly in memory. Generally speaking, this takes advantage of the only way caching in the file system or DB would be really fast (implicit memory storage), and makes it explicit. You can do this with xcache, memcache, or others. I hope this helps! 
**tl;dr:** It depends. [Profile your own code and find out where your bottlenecks are](http://www.xdebug.org/).
good summary. upvote for link.
sugar crm http://www.sugarcrm.com/crm/community/sugarcrm-community.html
I second the "it depends", but with a whole other set of ifs-and-buts: * *If* you are performing only a couple of simple database queries, it *might not* be faster to use a file cache; * *If* your file cache code is extremely fast, and reliable, and *if* your web server -- like most of the big servers these days -- is using 10k RPM enterprise-class hard drives, and *if* you are doing something more complex than a couple of db queries, you *might* see some performance gains from file caching. One of the most common suggestions I see for WordPress sites that are buckling under a sudden spike in activity is to turn on caching, and I've seen it help a lot. But, especially in WordPress's case, I think that has as much to do with the complexity of the code being run as it has to do with a simple mysql-versus-file-caching comparison. I've also seen people claim that sql databases can be thought of as heavily optimized file systems, so sometimes you can (supposedly) get a performance gain by moving your static html *into* a db lookup. I am extremely skeptical of that idea, but there it is. And, all of this is somewhat moot anyway if you can have in-memory caching: http://sivel.net/2010/11/wordpress-caching-comparisons-part-1/
I'll add another point... File based caching scales much better. Although a database cache *may* be quicker, especially if it hits the query cache, there is still more overhead in loading an application stack and doing a database query than there is in just serving up a static html file. For example, nginx or apache should be capable of serving up thousands of html files per second (I recently got 5,500 requests/second out of apache on a drupal site with static page caching). However, when you're dealing with php/ruby/.net/java/whatever there is WAY more overhead in loading that up and hitting the database. More CPU and RAM will be used in fetching that from the database, which means your machine will run out of resources faster. As a good example, while I was able to get 5,500 request/second out of a drupal site using .html file based caching, I was only able to get around 400 requests/second out of the same site using database caching. Of course, there are a lot of variables here... Hammering on one URL means the filesystem is likely caching the result (sames goes for the database though). And Drupal has to do a partial bootstrap to load up the cache from the database, which has quite a bit of overhead. And many other variables... But in general, caching in static html files will certainly make scaling a much less painful proposition (at least, as long as we're not talking about going to a multi-server setup with a load balancing reverse proxy config). And if you are on a machine with limited RAM and CPU, it's much friendlier on the server. 
The article was written in year 2004. &gt; The Output Buffer, introduced in recent versions of PHP, is ideal for this. that should have given it away.
I will answer your question, since nobody here seems capable of doing so. The answer is no. Serving a static HTML file instead if a dynamically generated one is *always* going to be faster. Look at Donncha O'Caoimh's WP super-cache plugin for Wordpress. This is exactly how it works. Coupled with a squid proxy, it's a very fast way of serving files, if not the most practical. 