Same here, but the RFC destroys my ability to use public properties at the same time (at least when it comes to proxying) :D
You might find it helpful to put the code on something like pastebin or gist and to state what error you're getting.
Microsoft natural ergonomic 4000, best thing Microsoft ever made.
Oh man. You need to work on your coding conventions and formatting. I assume you've never worked on a team before. You will make people very upset. It's really hard to follow the logical blocks and flow of your code. You should buy this book and work your way through it. You will be 1000 times better at this. https://www.amazon.com/gp/aw/d/0735619670?pc_redir=T1
[removed]
What are you looking forward to with 7.1?
[Happy Hacking Professional 2](https://en.wikipedia.org/wiki/Happy_Hacking_Keyboard). Nice and portable. Kinda loud, but not as loud as some. The CODE keyboards look quite nice, they weren't available when I bought my HHKB.
Matias Quiet Pro mechanical keyboard (Mac version). I originally got one of the Corsair RGB which looked amazing, but the keys were sticking when I got it unfortunately. So went with what others recommended. It doesn't look near as fancy, but for an open office it's nice and quiet and feels good to use which matters more than the gimmicks. I have a Cordair K95 mechanical at home and love it, it's just too noisy for an open office. I don't think I could stand using a non-mechanical keyboard anymore.
I used a [Microsoft Wireless Comfort Curve Keyboard 4000](http://i.imgur.com/DdoRIK6.jpg) before I got my mechanical, I loved it.
People in my office said they found the sound of my Model M calming and nostalgic. Must depend on the type of office (my colleagues were techs, I was a web developer).
You're asking for help in a technical forum. You should take effort to be correct, or else you'll lead people down wrong paths and everyone will end up with wasted time. In this specific case it's not too much of an issue, since the only ambiguity is over the version you're switching *from* (is it 14.04 or 14.10? They have drastically different versions of included software) and we can imply what the version you're switching *to* is. But more importantly, it shows that you don't understand the Ubuntu versioning scheme, which will get you into trouble. Posting incorrect information and then arguing that that is actually the *correct* thing to do is asking to be bitten in the ass.
&gt; more valuable then Judging by this grammar, I'm guessing maybe you should have taken English Framework classes in school, rather than English ;)
You're not alone here. There are two of us.
Logitech Wave keyboard.
HHKB Type-S I'll never go back to Cherry switches and probably never ditch this layout. It took all of three days for me to get used to the arrow cluster. 
Based on what was submitted to pastebin that line was commented out - whether or not it actually is - i have no clue. try what i posted and see if it works. For the record - yes, if you want to multi-line comment you would use /* */, but as far as what you posted to pastebin - most of that code was on a single line. 
Logitech K400, I'm on my fifth or sixth ... soon to be seventh, left CTRL comes off during vigorous programming, or when you turn it upside down ... the hoover done it ...
alright then, just stop trying. Understood. Fucksakes. Unsubscribing from this group because it's obviously useless. Queue: "see ya" useless responses. 
I didn't say "give up". You came on here, complaining to this group to do something about something it can do nothing about.... i told you that there are mailing lists where you'll find plenty of people who can help you if they are so inclined. You took that as "stop trying". ok....
I'd like to see a list of feature changes this community has directly influenced. The only one I can think of is the scalar type hints RFC... and it really only got over the line because a certain core developer changed his mind. Whether this community changed his mind is debatable (i was involved in that fight. it involved dozens of threads and thousands of posts, and the person who was effectively holding the item up was thumbing his nose at this community the entire time). 
Complaining? This response is exactly why people don't bother trying to debate in this community.
Seriously, why can we not use string and int as scalar hints? What reason exists that is even logical at this point?
&gt; This is without a doubt the most ridiculous php "bug" that exists. Really hard to interpret that as anything other than a complaint. It's not even trying to be constructive. And there are plenty of examples of healthy, constructive debate within this community.
You go ahead and deal with the reality of that problem then. I encourage you to see why it's a ridiculous problem and contribute something that makes you feel happy about "not coming off as complaining". Fucksakes man, do you even php?
I have a Poker 3. I love the keyboard but I wouldn't recommend it to anyone. Don't get me wrong I love the thing but I can think of a couple situations I needed a (~) and I had to google and copy and paste. Like I just did. Cause it doesn't fucking work.
I've had two ultimate favourites, my [Microsoft Comfort Curve 2000](https://www.microsoft.com/hardware/_base_v1/products/comfort-curve-keyboard-2000/mk_cck2000_large.jpg), and my current [CM Storm Devastator ](http://www.newegg.ca/Product/Product.aspx?Item=N82E16823129030) I've tried a variety of makes and models. As a quick sum up Dell keyboards have been above par, not my favorite and nothing memorable, but they stay out of my way and register keys nicely enough Microsoft keyboards are more hit than miss for me, I've been running Microsoft Wireless 5000 Desktop's for too many years to count, and I've worn down at least 4 or 5 sets of them. It's sad at how little compatibility modern Microsoft keyboards have with Linux (at least, the ones I've tried to use anyways, not a single one has worked) Logitech keyboards, and mice for that matter, are the opposite end of the spectrum for me. I hate the way Logitech keys feel, and I dislike the strange jitteriness of their consumer targeted mice. It takes a herculean amount of effort to accurately click on what I want to click on compared to any similarly priced Microsoft BluTrack mouse, and the marshmallow keys on the various keyboards I've possessed over the years actually let you fucking bend them like a chicklet balancing on a chopstick. I've had so many keys frustratingly get physically stuck under one another, and I actually ran into a case where the key heads just flat out fell off. Besides that they've all just been super, physically, uncomfortable to type on for multi-hour sessions. I know Logitech gets a lot of love and praise from my peers and anytime I poll for recommendations someone recommends me a Logitech Keyboard, and every single time I check them out I'm super underwhelmed and drastically unimpressed. The "chicklet" Apple Keyboards from 2009+ have always been an incredibly comfortable typing experience, and I've always found that a bit off. There's nothing special about their shape, it's extremely simple and straight forward. But the low-profile keys means very low effort typing coupled with excellent responsiveness. I liked it so much for a short period I owned a Mac, that I attempted to look for something similar in the Windows world. I did not successfully find that keyboard (well, I did, but they barely functioned) 
Work in 3 different places, sometimes 4.. Using a simple logitech K120 everywhere, ~~15~~10 euro keyboard. I dont understand the sudden hype around mechanical keyboards. Tried several--sold several.
Not all, no. But many popular and non-malicious libraries (installed through e.g. Composer) should work just fine. It's a matter of protecting those who do not know how to be suspicious and check for sinister code. In my eyes, the functions mentioned should be disabled by default and be an opt-in feature for the more skilled programmers.
I've been rocking a happy hacking lite 2 for years.
It is confusing but is it the most idiotic problem ever? I don't agree. First, your objects should be handled as..well... objects. If you want to pull some data, use getters for that. Magic methods are slow but comes to the rescue sometime. If you want to use magic methods, there is a set of rules you have to follow. Not being able to throw an exception is one. It is probably too late for the engine to catch an exception (due to its architecture), but you can throw exceptions in getters so it's not the end of the world. 
But this has a size limit on what you can store, no?
Ducky Shine2 with Cherry Red switches.
Still he can do it custom, its not must to use frameworks, but its certanly recommended
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
`__toString` does not allow exceptions, because every place that performs a string cast would need to be exception-safe (i.e. typically explicitly handle the case of an exception being thrown). Of course, there's a *lot* of places that perform string casts. Edit: Err, that was supposed to be a top-level comment, sorry for wrong reply. Just wanted to provide a small bit of context on why the issue is there.
You can put all the old classes into the same namespace, then you don't have to worry about using imports and you have the possibility to use the function mocker.
This is great, but: - would it be possible to have `array` "implement" `Traversable` instead? That would mean no BC breaks, no new concept, no new pseudo-type. I have no idea how doable it is in the internals of PHP. - the only thing we can do on `iterable` is `foreach`: it would be awesome if `array_*` functions would be made to work with `iterable` values
In this case how do you plan to Unit test your classes that are using class_exists or extension_loaded for example? For example lately we were creating a cache package to support both memcache and memcached, and the logic is checking if memcached is available, if it is it will use that, if not then checks for the memcache one and use that. How do you test that? Will you setup multiple php.ini and run the tests with separate php processes by hand? Function mocker seems to be an easier solution.
&gt; Parameters declared as iterable may use null or an empty array as a default value. This has to change, for null support is better to follow the previous rfc and name it as public function doNothing(?iterable $param): ?iterable;
What's up with your if statements? [See PSR-2 5.1](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#51-if-elseif-else)
There is no limit in *JWT* per se, but there are limits in the mechanisms used to transport it (URL, request header, etc.).
i know nothing about the internals so would you mind explaning this: isn't it possible to use a macro or function to cast the strings?, or is it possible but so hard to find all the right places that the team chooses to focus on something more important?
There *are* macros/functions for casting to string. The problem is that exception handling at the C level requires *local* decisions. The exception does not simply bubble up, instead you have to add explicit checks for whether an exception was thrown and abort execution of functions early, likely freeing or releasing values as you go along. From a quick grep|wc, there are approximately 500 string casts in the codebase, so doing this for every single one is a non-trivial effort. As a personal opinion: I think this excuse is nonsense. We can with relatively little effort cover all the most important parts in the engine, in fact I have proposed patches in this direction. For everything that is not explicitly covered, the only effect is that an exception is not handled at the *very earliest* possible moment. This already happens in lots and lots of other situations, and suddenly being extremely pedantic about this particular case is just hypocrisy. (Ironically it is possible for string casts to throw exceptions anyway -- we just forbid it when they come from `__toString` in particular...)
I've bought 3 of them over the past few years. One for the office, one at home, and just recently had to replace the one at home, and I was happy to get the same keyboard again.
omg, been wanting this for years!
Docker.
I recommend a Cherry MX (whatever color switch) mechanical keyboard for the following reasons: - You can replace keycaps with ones from different vendors - Error rate is greatly reduces - Long lasting had mine for over 3 years and still feels the same since I've had it If you are not sure on which type of switch, try a switch sampler, they are between $20 - $30 USD. After that, buy the cheapest keyboard of that switch. I say that because all you are getting with the more expensive keyboards, are extra features, such as lighting, macros, and more. However beware of the issues: - Its loud, you can but o-rings for the keys to reduce the sound but its still load, also depends on the type of cherry mx switch you have. I cannot use this keyboard around coworkers even with my o-rings on. Even than I do not like the feel of the keys with the o-rings on. - They are expensive, however in the long run its far cheaper.
I've wondered aloud more than once if I should buy in bulk should they ever stop making it!
Looks pretty much the same, good to know, thanks.
I foresee a lot of bugs being caught in very old code when run under PHP 7.1. :)
Would someone elaborate on why adding typed properties has such a negative performance impact?
My apple keyboard oO
The company I worked for used PhantomJS which had a header and footer space on the page, but those were the document header and footer and the files were generated on the backend. As far as printing a table header on every page, that would be nearly impossible with html and css. (Provided nothing new has come out for that since last year).
considering the context and arguments of the author, yes, certainly. by definition? no. are you suggesting PP is superior to OOP by definition?
I think OOP has a few good ideas, but by and large, it does a significant amount of harm when it is forced onto a project as the dominant paradigm. I'm the nice guy in comparison to others who think OOP brings [absolutely nothing of value](https://www.youtube.com/watch?v=QM1iUe6IofM), but they're [not entirely wrong](https://www.youtube.com/watch?v=IRTfhkiAqPw).
???
To which example are you referring? In the first, it doesn't assume that it is an instance of `Iterator` if it is an instance of `Traversable`, as it checks for `IteratorAggregate` if `!$value instanceof Traversable` is false and calls `IteratorAggregate::getIterator()`. Your code basically does the exact same thing only in a different way. In the second example, `iterator_to_array()` accepts any `Traversable` object. My point is that making `[] instanceof Traversable` be true is another way to solve the problem, but is not *entirely* without BC breaks, however they are minor. I could get on board with this solution as well, `iterable` was just my proposed solution without having to impose any object-like qualities to arrays. Edit: You're right about `is_object()`, there's no reason an array would have to return true even if it was considered an instance of `Traversable`. Don't know what I was thinking there. :-P
[Happy Hacking Professional 2](https://i.imgur.com/EpAVYnu.jpg). Minimal, beautiful, sensible, control is in the correct position. Pleasure to type on. A bit too pleasurable, actually. Those 'thunks'.
Ok, the statement "assuming $value is instanceof Iterator if matching Traversable" confused me since there was a check for IteratorAggregate. I agree that it is bad to assume that a Traversable could only be an Iterator or IteratorAggregate, but I commonly see this sort of assumption. IMO this would be an acceptable BC "break," but I'm still not sure if special casing `instanceof` on array is the best way to go.
Docker.
Try laravel.
Thanks. Will do 
Check out https://laracasts.com
Can't think of a single modern full-stack framework that **forces** you to couple the framework to your domain model.
Some background to let you make up your own mind. In the enterprise world, you have complex "domains". For example, insurance would have a very complex set of rules and behaviors regarding policy underwriting. That is its domain. For highly complex domains such as these, the code that powers them is best kept "pure" - that is with absolutely no knowledge or dependency on a framework at all. Any and all external dependencies should be adapted before being consumed by the domain. Need to change a dependency? Just build a new adapter and then the rest of the domain will just work without issue. From there, you would usually use a framework like Django, Laravel, or Rails to build an HTTP client around that domain - forms, HTML pages etc. The framework then has a dependency on the domain, not the other way around. Any tools provided by the framework might very well be used by the domain, but that goes back to that whole adapter thing. This is all well and good for large complex applications, but is completely overkill for most CRUD-style apps. /u/ocramius advice is good for certain problem spaces, but not every problem space. Also, what /u/utotwel said is true, no modern framework forces a coupling between your domain and the framework. It's up to you to decide how much coupling or decoupling you think you'll need. Coupling can be murder, but decoupling can be really time consuming and unnecessary if it's not needed.
I think the coupling/decoupling logic is as much a headache of the programmer as it is that of the framework. If you have a shitty developer, even if you give him laravel or symfony, no doubt he will manage to couple the business-logic, data manipulation and view all inside a single god component!
Currently got two for home/work: - Deck Ten-keyless backlit in Cherry brown for home: https://mechkb.com/products/mechanical-keyboards/deck/deck-francium-pro-tenkeyless-backlit-mechanical-keyboard - Same for work, but without the backlight. Brown keys are nice enough in a work situation - and can happily bash away on these things for 10+ hours without fear. 
Eloquent does a pretty good job of tying your entities to it.
XSS is an engineering flaw, so the efficacy of libraries is rather limited. https://paragonie.com/blog/2015/06/preventing-xss-vulnerabilities-in-php-everything-you-need-know That said: * [HTML Purifier](https://github.com/ezyang/htmlpurifier) is great for when you need HTML * `htmlentities($input, ENT_QUOTES | ENT_HTML5, 'UTF-8');` for when you don't need HTML * [CSP-Builder](https://github.com/paragonie/csp-builder) for assembling Content-Security-Policy headers.
To be honest, building a desktop app in Qt/C++ with the webkit bridge wasn't that hard to learn. Qt makes C++ easy, and there's plenty of help on stackoverflow and the Qt community forum to help. To keep it cheap, stick with the open source license, which only requires that you include the Qt runtime and the open source license file, but doesn't require that your source code be downloadable. For the Mac, though, a better approach (smaller install download) is to use native webkit and Objective C/C++, and then maybe add the Boost C++ library. From this, you can connect to a remote PHP server, local PHP server, or avoid PHP altogether and stick with C++. In my case, I use PHP for in app product purchases, license registration, dashboard stats, and the rest is all done in C++ and local webkit files. I do jQuery in those files, talking to the C++ over the webkit bridge and then interact with SQLite over the C++. I loathe Objective C because sometimes it's messy, but sometimes it does something more efficiently than C++ and therefore I can make a C++ wrapper function of that Objective C code. C++ was easier than I thought. Qt and their great IDE makes it even easier. On the Mac, I used Xcode and ObjectiveC/C++ instead of Qt/C++ and the Xcode IDE did a great job of showing me where my mistakes were.
I won't downvote you. You are right. I've done PYGTK and it worked well. I prefer Qt/C++ (or ObjC/C++ on Mac) with the webkit bridge now, but PYGTK is also a good, effective option that wasn't too hard to learn.
I only nodded for this few days ago. Now that I have picked Laravel - as the majority suggested - I have noticed myself editing Laravel it's self a little. So your comment was spot on. Thanks man!
Great article. One improvement would be to add S3 Content Transfer Acceleration service (http://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html) in front of this so that uploads to S3 go via Cloudfront and the user uploads to their nearest server instead of whichever region you've set up the S3 bucket.
&gt; no modern framework forces a coupling between your domain and the framework. Sorry, but I laughed really hard while at the airport gate, and now everyone is looking at me as if I was a psycho. Thanks :-P I don't think that is true, but I won't go and pick examples, as it will just anger all the fanboys.
Having spent thousands of hours helping people on IRC, in contexts such as Symfony, ZendFramework, pure PHP, Silex, Expressive, etc, I strongly disagree with this. Poka yoke all the way. Developers are clever animals: the "bad" definition of clever.
&gt; Seeing how TypeScript and Python (among others) handle types, I was wondering if we can get a switch in PHP to disable type checks in stable production code. Not worth it, and really dangerous. Hack does this: https://3v4l.org/0PvDf &gt; In stable code most of the argument/property etc. type checks are redundant, a TypeError would never be thrown. It's more like an assertion (which one would also disable on production code). One exception are scalar argument types (the cast is still needed), but type checks can go for objects and arrays. I would agree with this if we weren't talking about interpreted languages. The only way I see this as possible is to still have a compiler step that signs the generated code (which would pretty much be the same), and then makes sure nobody tampered the generated files. Still, the dynamic nature of the language makes it really hard to catch all possible execution paths, since even things like `unserialize()` can lead to code execution (`__wakeup` + autoloading). &gt; Working with those other languages, I honestly don't miss runtime type checks at all. It's only overhead. I actually had legit scenarios where a manual e2e test discovered issues with fully tested code that had "lax" type-checks in place. I don't believe in this approach at all. While types are indeed more of a "programming time" aid (they make your code understandable/semantically meaningful), they also support the actual security context of your app, preventing things like https://www.reddit.com/r/PHP/comments/4n4y9d/fixing_sql_injection_orm_is_not_enough_xpost_from/ (YAY!). You are still free to run a simple code tool to strip all type checks in your codebase, but that's because you OWN your entire codebase (including `vendor/`) - don't do it for everyone. It is even trivial to write such a tool, so I suggest you give it a shot. Anyway, the overhead mentioned by Dmitry is still ~15% on assignments of properties of defined classes, and it reflects in an overall 0.1% slowdown of the entire engine, when put in actual benchmark scenarios. If you want, I can provide some actual performance tests instead (with `phpbench/phpbench`)
I found compiling it from the source much more appealing, specially if i wanted to run php5 and php7 at the same computer for testings (hate VMs). If you do it once, thats enough for doing it over and over again 
HTTP Basic Authentication or HTTP Digest Authentication
And remember that `posisx_isatty` is not available on windows platforms, where afaik there is no way to check if output or input is redirected.
Great point! I actually had no idea about the transfer acceleration service. I'll add it into the post when I get a chance.
Except that you 1) don't have to use Eloquent at all and 2) Do not have to use Eloquent models in your domain model but rather use them as a data access later. 
Is it also possible to use this for providing upload targets to API clients? For example, sending a target URL to a mobile app to complete an upload?
Why do you think XSS is an engineering flaw? It's user input and the software should do its best to filter/sanitize it. 
It's probably for the best you don't try and pick examples because they'll be extremely easy to disprove as coupling. Hint: adapters. Anything you claim is coupling, can be uncoupled by building an adapter around it.
No CORS setup required with the mobile client?
Potentially setting inside the constructor only could be allowed
&gt; If you are implementing a __toString() method, why would it ever do anything exceptional? I regularly saw this problem when I worked with Laravel. If you render a blade view it returns an object which you can return as a response. If you do that, there's a call to `__toString()`. This is pretty handy as you can basically create and return a view with a single line in your controller. If you happen to have a mistake in your blade template you get this exact error. You can work around this by calling then `render`method first, but that's an additional line lots of people tend/want to avoid.
[This method](https://github.com/octobercms/library/blob/master/src/Html/HtmlBuilder.php#L114-L151) should keep you out of trouble in most cases.
Is there a way to abuse this? If I get a presigned url with an expiration timer of 1 minute. What keeps me from using multiple servers to upload large files to generate aws-cost for example? Or is the signed url IP-locked? What happens if the upload takes more than a minute? Will the connection then be terminated resulting in a uncomplete file?
RTFA - you can still limit post size and your timeout is for the post to begin uploading not complete it. The article addresses this.
If you're uploading images., just go with cloudinary. Probably the best 50 bucks per month I've ever spent. Upload through browser with jQuery, on the fly transformations.. case closed
Yeah, images are a bit of a special case. Since they're usually under 10MB or so there's not much harm handling these server-side, or using a service like Cloudinary or imgix like you said.
I agree with this in your point of view. One doesn't strip out unwanted characters before putting them in the database, nor stripe out HTML tags when saving it to the database. In the output, JSON/HTML, etc, the relevant sanitation should happen. I'm building a newsletter drag-and-drop app, and it comes with a lot of control for them to design it (WYSIWYG). Even though the email composer can sanitize the HTML and fix bad HTML, and remove XSS possibilities, there is still something missing, because the user could craft an HTTP request and send it to the server in first place. A well-thought app will still need XSS libraries if it has any user input that may contain HTML (or anything similar) and you still want to retain it. 
&gt; In the output, JSON/HTML, etc, the relevant sanitation should happen. Someone should have told WordPress that years ago: https://klikki.fi/adv/wordpress2.html
Yeah there'd need to be a check after the constructor ran.
Here's the RFC: http://wiki.php.net/rfc/invalid_strings_in_arithmetic I wrote it. Why? [Frustration when writing PHP just after having written JavaScript](https://www.youtube.com/watch?v=bYMUbavj9uE&amp;t=15m28s) (warning: video). I said I wanted to deal with it in PHP 7.1, and I had time, so I did. But it should be more broadly useful for spotting other bugs.
Or you could use `@`.
Yes, that is a true instance of when one does need sanitation. Taking HTML input and sending it as output is akin to `eval`. To use parameterization there you would need to construct a HTML tree in memory and remove unwanted branches (at least logically). It is a good place to use a sanitation library, but I'm still leaning towards trying to do it in the output step rather than the input or we are back to the leaky abstraction. But of course one could be pragmatic about it and choose the best solution at the time, especially if there are just limited instances of that data.
Derp, that makes sense. Lack of caffeine to blame.
CORS wouldn't be necessary from a native mobile client, because there's no “cross-origin” to worry about when you're not a web app.
Looks like that code need rework
CORS wouldn't be necessary from a native mobile client, the Single Origin Policy only applies to web apps.
CORS wouldn't be necessary from a native mobile client, the Single Origin Policy only applies to web apps.
I notice that the CORS configuration you provide allows requests from absolutely any origin. Perhaps you could mention that, so viewers know what it does? 
I notice that the CORS configuration you provide allows requests from absolutely any origin. Perhaps you could mention that, so readers know what it does? 
I notice that the CORS configuration you provide allows requests from absolutely any origin. Perhaps you could mention that, so readers know what it does? Perhaps they might want to write a CORS configuration allowing uploads from their domain only.
Posted 4 times. :P
I'm glad to see this, because I was worried that the Union Types RFC might kill interest in creating the supertypes that PHP is missing.
Solution: just call 7.1 8.0 instead and be done with it. 
Lets stay on the safe side of semver! Instead of releasing PHP 7.0.0, 7.0.1, 7.0.2, 7.0.3, 7.0.4, 7.0.5, 7.0.6 etc. we should go with PHP 7.0.0, 8.0.0, 9.0.0, 10.0.0, 11.0.0, 12.0.0, 13.0.0 etc. instead!
That should give you an idea how much rework that code needs. :D
But each release contains many unrelated ~~bug fixes~~ backwards-compatibility breaks! We should increment once per commit. Instead of 7.0.0 and 7.0.1, we'd have 7.0.0, 8.0.0, 9.0.0, 10.0.0, 11.0.0, 12.0.0, 13.0.0, 14.0.0, 15.0.0, 16.0.0, 17.0.0, 18.0.0, 19.0.0, 20.0.0, 21.0.0, 22.0.0, 23.0.0, 24.0.0, 25.0.0, 26.0.0, 27.0.0, and so on.
&gt; (Sorry, not entirely sure what you mean...so this might be addressed on a bad guess) A court judgement established a precedent that some UK laws (like the European Communities Act 1972) are “constitutional” and therefore cannot be implicitly overridden by later laws, but can be explicitly. So you wouldn't just be able to break BC without being explicit about overriding the Release Process RFC.
It's almost as if semver is a bad fit for a project as large and ill-defined as PHP....
&gt; Well. The point releases were nicely backwards compatible. No ... not really. Not by any strict definition of the word. I know of *multiple* specific instances of real codebases breaking (which is to say, at least having test failures) due to changes introduced in PHP 7.0.x releases. Nonetheless I'm pretty sure that we made the right call on these changes, because not doing them would have meant to leave some core functionality in PHP 7 broken for the whole release cycle. This would have caused more damage in the longer run.
Something like this... http://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html S3 Events can post to an SNS topic or SQS queue.
Who knows what happened :D
Nice drive-by comment. It works just fine. What's the problem?
~~Feel free to rework it for me then. All talk no substance much?~~ edit: Ate a snickers
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
It was a joke. Calm down.
I just dunno whats with the down votes.
Seems like something derped a little here :)
Thanks man. I retract my snappy comment.
`explode("\n",$_POST[$key]);` Note, this only works if someone actually hits "enter" and creates a new line. If you're just looking for the number of lines after line-wrapping, the method of splitting a string like this won't work. Edit: Fuck; quotes.
In Elm, it is.
You'll need to double quote the \n character though: explode("\n",$_POST[$key]); 
Hi /r/php, I'd like to make something like OmniPay, but instead of payment gateways, service multiple 2FA backends and strategies. On my todo list: * FIDO U2F (TOTP) -- implemented * OTP over SMS (probably facilitated via Twilio and its competitors) * OTP over Signal (secure alternative to unencrypted SMS) * Send a one-time token via [GPG-Mailer](https://github.com/paragonie/gpg-mailer) * Third-party APIs * Authy * Yubico If anyone has any specific requests, please open an issue with your suggestions.
I tried the '\n' method before too... Yes, the textarea allows for "enter" key which is exactly what I'm trying to count.
After some thinking, I will get rid of the explode and push/merge line of code. Instead I just explode the variable count it and add the count directly to my $Page_Lines value and compare directly. $list = 1; $Max_Plan_A = 1; while ($_POST['Dx'.$list]) { $Page_Lines++; $Page_Lines += count(explode("\n", $_POST['Plan'.$list])); if ($Page_Lines &lt; $Page_Lines_Max) { $Max_Plan_A++; } $list++; }
I edited my post above, so I don't know if you saw my change. Instead of `array_push`, try `array_merge`. `$Lines_to_check = array_merge($Lines_to_check, explode("\n", $_POST['Plan'.$list]));`
The problem isn't that you can't write decoupled code. The problem is that all these frameworks, "Laravel" included, teaches newcomers to their frameworks to write highly framework coupled code. 
Is PHP7 really the lowest version you are comfortable using?
Question mark does nothing, if a property is to be nullable it should be defined as null in my opinion. I know the question mark thingy passed, but I don't see how it solves anything rather than make the code look like something only a mother would like.
I feel like php 7 is justified here.. Php 5.6 will have its end of active support in less than 6 months and this library will take some time (probably a few months) until a stable v1 will be released.
Device white-listing? You've got to be kidding. Pinching in a code that's automatically SMS'd to you on login is far simpler for the end user. 
This code allows safe HTML but removes common potential XSS threats. Of course htmlentites will block everything, I'm sure this is not what the OP asked for.
Ah i see, this is from october cms, no offense bro, its just look messy to me. Btw nice job with october.
Gonna throw another hat into the ring, take a look at [CakePHP 3](http://cakephp.org/) as well. Fantastically powerful ORM, large and helpful community, and (imo) really good documentation. Performance wise, we've got a large multi-user (20+ concurrent users) application and average at around 140ms. We haven't done any major performance optimisations as yet.
Honestly? As a rough estimate to complete that spec to satisfaction I personally would want to dedicate much more than two hours of my time. Hell, getting a good set of unit tests in, I'd want at least an hour. It's been a while since I've built a simple CRUD application, but I suppose you could build the back-end in 30-60 minutes, but then the front-end? Along with styling? I'd want to set aside 4-6 hour for this test. And there's the problem. Two hours is about the limit I'm willing to put down for a technical test, and even that's a bit annoying. Any developer worth hiring isn't going to be interviewing *just* with you unless your offer is extraordinary. My last job hunt lasted a week and a bit and in that time I interviewed with 6 companies and did two technical tests and multiple interviews of an hour each. If any of them asked me to do a 4-6 hour technical test, I'd politely decline because I had more than enough other hiring processes on the line that the cost to benefit of doing it didn't come out well enough. And if any of them wanted a technical test before a face-to-face (even over Skype), they'd get a half-assed solution and I likely wouldn't want to go with them anyway. And if you've done face-to-face, you can just ask them about some high level design concepts instead of requiring all of that
Not true at all, in fact white-listing could be via 2FA one-time per device with a nice easy revoke button like google has. The hardest part of white-listing is picking something unique enough, but as small as possible to reduce the lag introduced (which IMHO is still less than waiting for an SMS, then typing into a PC what I see on the phone-screen).
If it's just a password protection issue, don't allow crappy passwords. It wouldn't affect the login mechanism as that would just verify a password that exists. A little more effort one-time every month or three or twelve to generate a new password (which shouldn't be memorable anyway) is a doozie compared to every access using 2FA. TBH I used white-listing earlier as an example of an extra security layer for access that also works for BYOD; it's not that it is not vulnerable, but even if someone has the device they need the password. If it's for every login and is to be considered part of a system with a weak password; then that system is F'd anyway. I'm pretty sure all SMS are unencrypted in transit, and free apps are a vector for aligning e-mail addresses and usernames with phones, intercepting SMS and forwarding (not sure if it happens, but it's not difficult, doesn't take much imagination).
Would || be a good operator? Since it means or, and you want it based on true or false. It could be weird I guess, but `the result of empty($var) or default to 20` would read quite well.
OK, the "too few arguments" RFC is nice to have, but is that particular RFC really worth throwing the whole process off?
 ($z &lt; 5) || 5 is also already a valid expression, so the same argument applies.. You'd really need something different for it to not completely fuck up backwards compat
Very odd, they must have had a glitch.. I think reddit hashes comments and doesn't let you post the same one twice 
So you want `$z &lt; 5 ?? 5` to be equivalent to `$z &lt; 5 ? $z : 5`? Imho, using `??` for that is confusing. And what happens when you write `$this-&gt;test($x, $y) ?? 5`, do you get $x before $y? do you get $this? Not to mention the main benefit or your proposal only saves you two characters. It really isn't worth it.
If anything, I feel like the new ? syntax would be better off being reverted and phased out. It makes no sense to change something that was already there and implemented. I see no benefit in using `?$var` over `$var = null`, because you only have two options; either you pass a value, or you don't, it's that simple. The question mark is just there to make the code look like something only a mother could love.
Ah yes, okay. Im struggling to think of anything that could be used that'd be clean. `%%` `!!` etc all feel.. bleh.
No, no, no, no, no. That is absolutely confusing behavior. $v = ($z &lt; 5) ?? 5; What would happen if you were to do ($z &lt; $x) ?? 5 or (5 &lt; $z) ?? 5? What value would $v take then? Just because a value isn't an explicit variable doesn't mean it shouldn't be treated as one. It's incredibly ambiguous and fragile if you dared to try refactoring it. empty($x) ?? 10; Why should a function argument be the final return value here (as compared to the result of empty() or 10)? Giving empty() special treatment is going backwards (considering previous updates to the function were to actually make it work like an *actual* function instead of failing on expressions). It adds a stupid gotcha that doesn't need to exist -- suddenly empty() is the only function that has a special exception for null coalescence in that it triggers on boolean false? No, just no. The point of null coalesce is to add a fallback to a value that may be null or undefined. The way it is implemented in PHP7 is perfect, straightforward, and I would never change it.
one major per year/ couple of years would be OK. Four,five years to break something is too much
wow... didn't think anyone still used this package... 
I'm not against the library, just the concept that 2FA makes things more than superficially more secure. It's not that I'm religiously against 2FA, it's just that I haven't read anything yet suggesting it's going to help more than hinder, unless it's a one-off per-device (in which case it doesn't make passwords more secure, it limits legitimate access routes, which is easier to keep secure due to reduced opportunity for entry). Btw, I look forward to trying [AirShip](https://github.com/paragonie/airship); thanks for pointing that out. 
Thanks for sharing; I can relate to most of it and the affirmation that I'm not the only one that feels like that is golden - especially on a Monday morning! :)
No, this is a terrible idea. * You cannot revoke them. * Data goes stale. * What problem does it even solve? Chances are, you're not running at a scale where you *need* stateless sessions to begin with.
How do you delete/invalidate a JWT **without** server-side storage?
&gt; The answer to the "why?" question is: "because it's 2016" :) That's a terrible answer. You want to know what to use to get the same functionality as sessions - well, sessions are *it*. The year we are currently in has precisely nothing to do with the appropriateness of a technology. If you feel that sessions somehow do not work for you, then explain *why* they don't, so that people can make useful and informed recommendations. Don't just try to change shit for the sake of changing it.
1. You can [invalidate them with a blacklist](https://auth0.com/blog/2015/03/10/blacklist-json-web-token-api-keys/). 2. The JWT can be replaced any time by setting a new cookie. 3. If you are distributing load between multiple servers, you are probably running at a scale where stateless sessions will reduce server loading. Particularly if your servers are in multiple regions.
JWT is not a silver bullet but it works really well for handling authentication needs without sessions and, when used properly, can massively reduce storage requirements.
I started at age 28, went to university but have no STEM degree, and waited far too long to get into the community. I'm glad you put yourself out there. Keep going, because this community is amazingly welcoming to newcomers. Everybody starts somewhere and at some age. Everybody there is looking for a positive experience, so they want you to succeed. Just be honest about what you know and don't know, and you'll find that people are happy to talk with you at whichever level--advice if they have it, peer conversation, or asking questions if you're ahead of them in some aspect--which you probably are to more people than you'd suspect.
Because objects have methods. If you want to check if your object is in a valid state to do something, this is more expressive and meaningful. if ($object-&gt;canDoSomething()) { // do something } Or better yet, just *tell* your object do the thing and have it throw an exception if it can't complete its work. Having a `__toBool` method would also make the truthiness rules in PHP really hard to deal with. Right now we can rely on any object having a truthy value. If __toBool existed, userland classes could mess with that expectation quite a bit, and really without any guidance on what makes a good `__toBool` method. 
Don't use PHPActiverecord. There are a million ORMs out there which are better maintained.
What's the best way to sync an external data source and a local database using Doctrine. In my case, there is input in the form of an array (example below) with three levels of nesting, each level represents one type of Entity in my system. $data = [ [ "id" =&gt; 7, // TopLevelEntity "lots of keys" =&gt; "", "_children" = [ [ "id" =&gt; 7, // SecondLevelEntity "lots of keys" =&gt; "", "_children" = [ [ "id" =&gt; 7, // ThirdLevelEntity "lots of keys" =&gt; "", ], ... ] ], [ "id" =&gt; 107, "lots of keys" =&gt; "", "_children" = [...] ], ... ] ], [ "id" =&gt; 8, "lots of keys" =&gt; "", "_children" = [...] ], ... ] The input data changes very often and I need to apply changes from the input array on to my database preserving the items Id's, relations between them, removing nonexistant entities and making the changes it in one transaction. My first thought was to implemet the entities and relations, load the existing entities from the database and populate them in loops during sync But there has to be a nicer cleaner way to do it, im open to any sugestions regarding tools and best practices 
cookies get sent with every request, I do not want every request to have my token.
That's the *point* of authentication tokens - you need them all the time. And what is the problem with sending them along for every request anyway?
1. It took me a while to figure out with php 7. I created my own "php7" image with composer &amp; phpunit. FROM debian:jessie #DEPENDENCIES RUN apt-get update \ &amp;&amp; apt-get install -y curl wget \ &amp;&amp; rm -rf /var/lib/apt/lists/* #ADD PHP7 BRANCH REPOSITORY RUN echo 'deb http://packages.dotdeb.org jessie all' &gt;&gt; /etc/apt/sources.list \ &amp;&amp; echo 'deb-src http://packages.dotdeb.org jessie all' &gt;&gt; /etc/apt/sources.list \ &amp;&amp; wget https://www.dotdeb.org/dotdeb.gpg \ &amp;&amp; apt-key add dotdeb.gpg #PHP RUN apt-get update \ &amp;&amp; apt-get install -y \ php7.0 php7.0-common php7.0-dev \ php7.0-cli php7.0-fpm \ php7.0-curl \ php7.0-gd \ php7.0-gmp \ php7.0-igbinary \ php7.0-intl \ php7.0-json \ php7.0-ldap \ php7.0-mcrypt \ php7.0-memcached \ php7.0-mysql \ php7.0-opcache \ php7.0-redis \ php7.0-xdebug \ php7.0-xmlrpc \ &amp;&amp; rm -rf /var/lib/apt/lists/* #NEEDED FILES / FOLDERS RUN mkdir /run/php &amp;&amp; touch /var/log/xdebug.log #PHP-FPM CONFIG COPY files/php7.0-fpm.www.conf /etc/php/7.0/fpm/pool.d/www.conf #COMPOSER RUN curl -sS https://getcomposer.org/installer | php RUN mv composer.phar /usr/local/bin/composer #PHPUNIT RUN composer global require "phpunit/phpunit" ENV PATH /root/.composer/vendor/bin:$PATH RUN ln -s /root/.composer/vendor/bin/phpunit /usr/bin/phpunit EXPOSE 9000 CMD ["php-fpm7.0"] 2. Once it was done, I created this bash file and put it in /usr/bin (more convenient): cabz@localhost:/usr/bin# cat docker-php7 #!/usr/bin/env bash PROJECTS_DIR=/var/www/projects HOME_DIR=/home/vagrant VAGRANT_DIR=/vagrant DIR=$(dirname $(readlink -f "$0")) sudo docker run \ --rm \ --pid=host \ --sig-proxy=true \ -v /tmp:/tmp \ -v ${DIR}:${DIR} \ -v ${HOME_DIR}:${HOME_DIR} \ -v ${VAGRANT_DIR}:${VAGRANT_DIR} \ -v ${PROJECTS_DIR}:${PROJECTS_DIR} \ -w ${PROJECTS_DIR} \ docker_php7 \ php "$@" 3. Once it was done, I added a remote interpreter which had the php executable to be "/usr/bin/docker-php7" (make sure to chmod +x). 4. And finally, I setuped the PHPUnit to run from the "phpunit.phar": /usr/bin/phpunit (this is the phpunit from the docker image). Hope it helps you!
And? What's the problem there, really?
I'm running all my dev environment with docker-compose so multi-container with one being my PHP environment. Also I don't have the same path on my host and in my docker but my volumes are already mounted in my `docker-compose.yml`. Can I run it with `docker-compose` command ? &gt; Once it was done, I added a remote interpreter which had the php executable to be "/usr/bin/docker-php7" (make sure to chmod +x). I don't understand this part because on PHPStorm a remote interpreter is either with Deployment configuration or SSH. I have none of those. Did you setup one ? I don't want to install SSH on my PHP container. At least if this is possible.
I guess HD version should be processed soon!
1. A blacklist requires much less storage than storing sessions. 2. Obviously when taking this approach the data in the token would have a expiration and/or would not contain data that is subject to expiration. 3. Trust me when I say that there are use cases that are not solved by sticky sessions. I know from experience. It might work in your setup but doesn't work in ours.
Check out laracasts.com. While a lot of it is focused around the Laravel framework, there's a lot of content on there for just general PHP and web development in general.
This is extremely short-sighted. You just wrote your own [test double](https://en.wikipedia.org/wiki/Test_double) (you wrote a stub for `PaymentProcessor`). You could have used a mock object system to generate one for you, but you chose to write a stub. That's cool, I tend to do this as well for some services. That said, don't pretend replacing a generated test double -- a mock object -- with something bespoke automatically makes your tests more meaningful. In fact, by using a stub that doesn't allow you to inspect arguments given to called methods (a spy), you can no longer verify that the payment processor recieves things like the value from the invoice or the account's auth code. Given that the return value in your payment processor isn't checked in the example code, you can't really be sure the service was called at all. Are those things important? Depends on the application, I would imagine, as well as the rest of the test suite.
/r/php is not /r/phphelp
I think those are good points. But you could easily make the `PaymentProcessor` return specific values depending on the arguments, correct?
Sure, you could write that. Or you could do... $paymentProcessor-&gt;expects($this-&gt;once()) -&gt;method('settle') -&gt;with(/* stuff here */) -&gt;willReturn(new SettleResponse(/*...*/)); And not maintain a stub implementation that's likely to get more complex as things grow.
I think a lot of programmers go through some kind of depression just because of their career (add in personal depression and self-worth issues and its probably much worse). I know guys who feel inadequate because they dont know Laravel, or have not implemented a REST API, or dont use Composer or conform for PHP-SIG coding standards, or maybe they have never used PHPUnit or practiced test driven development. Throw in a misunderstanding of MVC, MVP, MVVP or whatever it is nowadays and they feel they are just idiots. Even though every day they are kicking out great maintainable code for their team and may have years of coding experience, they feel like failures. And often forums like Reddit reinforce their lack of skills. Depression is an inevitable consequence. I think this is even more likely if you are doing full-stack development and have Javascript issues, lack of experience with Bootstrap and Angular and React and whatever. So many depressed programmers.... even though they are really good at coding on a day to day level. 
Yeah, I get that (or using Mockery), however that means you can't use the Symfony container to create a new `InvoiceGenerator` (if that's what you're testing), or, if you do, you have to manually inject the `PaymentProcessor` into it.
I don't think the claim about local storage is true. If there's a possibility for XSS, things can be exploited using CSRF instead of stealing the session identifier and doing that request then.
This is often incorrect and misleading, and even if it weren't it'd just be rehashing (with no additional explanation) the official documentation.
The problem is that popular demand will never ever make it secure enough to be classified as true "something *only* you have" 
What's with the additional vulnerability of bad keys that can be broken offline?
That doesn't make the Local Storage claim untrue, it just means there is *another* security concern. It is still more dangerous to allow malicious code to get hold of a session cookie, since that only has to happen *once*, you don't know what happens with it afterwards, and the attacker can continue using it regardless of whether you are still on the page in question. In contrast, making requests from the malicious code (and I'm not sure you can consider it CSRF at that point anymore, since it now operates from the same domain) is an ongoing *detectable* process, for which the original page must remain open to work.
&gt; that means you can't use the Symfony container In your functional test's setUp: $this-&gt;paymentProcessor = $this-&gt;getMock(PaymentProcessor::class); $this-&gt;client = $this-&gt;createClient(/*...*/); $this-&gt;client-&gt;getContainer()-&gt;set('payment_processor', $this-&gt;paymentProcessor); You do have to manually inject it into the container, but I don't see that as too big a deal. Depends on how big a surface area `PaymentProcessor` touches, I guess.
Trade-Offs and mitigation. For instance I can choose CPU cycles / Application complexity [Encrypting the JWT string] over eco-system complexity [ Needing to use yet another session storage medium like redis ]. I don't use cookies at all and prefer my UI to be a Single-Page App where I don't even need local-storage...
While possible, it's not something I'd take into account here. That's purely an implementation detail (namely - the sysadmin needs to pick a strong randomly-generated key), and not dependent on *what* you use the tokens for.
&gt; For instance I can choose CPU cycles / Application complexity [Encrypting the JWT string] over eco-system complexity [ Needing to use yet another session storage medium like redis ]. The complexity of eg. a Redis server alone is negligible once you run at a scale where you actually need a separate session server, and doesn't even come *close* to outweighing all the other issues of stateless tokens. If you run at a smaller scale, you can just use the database you're already using, or even - in the case of PHP - the default session store that you get for free. &gt; I don't use cookies at all and prefer my UI to be a Single-Page App where I don't even need local-storage... That means you can't persist logins across pageloads, which is a UX problem. Aside from that, I hope you are building a highly interactive application - SPAs are *completely* unsuitable for websites (including things like forums, blogs, etc.)
It's still something that might be worth considering. Once broken, a user could fake any identity they like which isn't possible when using session identifiers.
&gt; The complexity of eg. a Redis server alone is negligible once you run at a scale where you actually need a separate session server, and doesn't even come close to outweighing all the other issues of stateless tokens. In your opinion. &gt; That means you can't persist logins across pageloads, which is a UX problem. Aside from that, I hope you are building a highly interactive application - SPAs are completely unsuitable for websites (including things like forums, blogs, etc.) Yes, that is exactly what I am doing.
Why not just use sessions? The handshake is initiated with a normal HTTP request, so it sends the session cookie as well.
It is likely still possible with session identifiers. The reason that session identifiers are frequently signed cryptographically, is to prevent a user from just iterating through all the possible session IDs (or even attacking its randomness sources, like has [happened for PHP in the past](https://www.youtube.com/watch?v=fWk_rMQiDGc)), until a valid session is found. This is often not practical to protect against otherwise - bruteforce protection on cookie values is *difficult* and hard to scale, and you often want to keep session IDs relatively short for lookup performance reasons, so just increasing the keyspace doesn't always work either. In that sense, if the signing key is broken, then *both* JWT tokens and signed sessions will be affected - and while session IDs still present more of a hurdle, I don't personally consider it to be significant enough to really present this as a *downside* of JWT, in and of itself. This holds particularly true because the sysadmin can trivially prevent this by picking a strong key.
&gt; often want to keep session IDs relatively short for lookup performance reasons, so just increasing the keyspace doesn't always work either I don't think anyone wants to keep session IDs short for lookup performance. If you look it up in a hash table or something like that, it's usually hashed to something shorter for the pure lookup anyway.
I'd say the issue is Laravel using a storage format that isn't interoperable. Can't you swap the storage driver there?
Of course, if the key length doesn't matter for your storage method, then it's better to make it harder to guess. I'd wager that generalized session implementations won't want to make that assumption, though, especially if they have swappable storage backends.
Sure, progressive enhancement is a great solution, but poorly supported by current SPA frameworks. I'd like to see better support for that. That having been said, Discourse is not really a good example - last I checked it's entirely read-only without JS (which is unnecessary), and right now, their [demo setup](http://try.discourse.org/) doesn't work without JS *at all*, and just throws up a pile of HTML... EDIT: Depending on your rationale for building an SPA, progressive enhancement may or may not work. If it's about liking the 'views' model more, you'll probably run into trouble. If it's to support something like JWT without using cookies, that definitely won't work. If it's about performance, something like [InstantClick](http://instantclick.io/) is probably an easier solution. EDIT2: Okay, their demo setup *intermittently* shows content, but still won't let you log in without JS.
Yeah, in retrospect, I wish we hadn't started with PHP. However, we're only using WebSockets to enable real time 'stuff' in the application - Laravel broadcasts events into Redis when certain things happen, which broadcast some updates to the client in real time after node reads the event out of Redis. The meat of the application is all still in PHP, so there isn't a lot of 'secret' data available in node anyway - for example, node doesn't even have access to the database.
&gt; The first problem is assuming that the session should be used to store anything that is not permanent. This bad and you shouldn't do it. You should not define the user role in session, you should be storing the user identifier in session and checking against the current state of the app (probably persistent storage). At that point, you defeat the entire point of self-contained, stateless tokens. &gt; On the last point, the easiest way to provide good security for user tokens is to sign the token using a key derived from the user password hash. This way, when the user changes their password, all other tokens (perhaps stolen) will immediately be invalidated. Not possible without separately accessing the user database, which again would defeat the point of self-contained, stateless tokens. &gt; The second method of invalidation is to maintain a blacklist. This does require hitting your server side blacklist store, but that is generally a tiny amount of data compared to maintaining the complete user session server side. This is very complex to get right, and also reintroduces state (thus defeating the point of stateless tokens). Do you fail open or do you fail closed, for example? You might as well just use sessions, instead of reimplementing this architecture yourself. &gt; Transient session data (that does not contain private user info), such a redirect-location-after-login, can be sent with signed cookies over HTTPs. Sure. I'm not including that kind of data in my assessment, because its storage in a session is more something people do for convenience than because that's where it's supposed to be. &gt; In my experience, user credentials and transient data are the top two things sessions are used for. Cookies can hold both, and JWT provides a reasonably good level of security for authentication. That's completely orthogonal to the point, and ignores the drawbacks pointed out in the article. The argument shouldn't be whether JWT is *acceptable*, it should be whether it is *optimal*. For session data, it is almost always *not* optimal.
You can do CSRF regadles of XSS, but you cant CSRF if the JWT is stored in the local storage UNLESS you have XSS. If your application has an XSS you are fucked anyways. And like joepie91 said, you cant call it CSRF if you use an XSS to perform it.
That doesn't solve the problem of using a weak key to begin with.
https://github.com/lexik/LexikJWTAuthenticationBundle/blob/master/Resources/doc/index.md Those guys for example use openssl to encrypt and decrypt their jwt. Thats an easy way to do it and if openssl fails, you will probably have other worries. And i dont get the point in using stateless JWT, just use JWT for authentication.
We're talking about a weak __key__, not a weak algorithm. No matter how strong the cryptography is that you're using, if you use a weak key it will still be trivial to bruteforce. The solution isn't to add more encryption - it's to pick a strong key. &gt; And i dont get the point in using stateless JWT, just use JWT for authentication. JWT was specifically *designed* for stateless use. It can be beneficial for sessions in large-scale setups where you can't have centralized session stores, but 99% of developers will never run into this.
totally agree, this is a really common problem, hopefully my little post will help someone else who might think its just them feeling this way.
https://news.ycombinator.com/item?id=11896851 has some information/speculation
&gt; On the other hand though (my favorite hand), this change can avoid a huge amount of bugs that may go unnoticed by teams if they ignore or silence warnings and notices. I have been hit by this behavior in a legacy codebase. Not fun. My opinion seems to be that of yours: that in the majority of these cases the current behavior is broken already so breaking backwards compatibility here is annoying *but helpful*.
Always thought JWT = Java Web Toolkit...
The thing is: It's claimed that local storage is less secure than cookie storage, because javascript can access it. That's only an issue if there's a possibility of XSS and then we're at the starting point again.
&gt; but you cant CSRF if the JWT is stored in the local storage UNLESS you have XSS. The same is true for if the JWT is stored in a cookie.
&gt; The problem with SPAs is that they inherently require JavaScript. So? What is this, the late 90's?
Thanks, but I don't have a need for this library, I was just interested in the authors reasoning of making PHP 7.0 a requirement.
&gt; Not possible without separately accessing the user database, which again would defeat the point of self-contained, stateless tokens. Nobody says you have to *only ever* use JWT tokens as a "self-contained, stateless token". If you want to do a database request, that's totally fine. You're probably doing a bunch of other database requests for other reasons anyway. I use JWT's alongside OAuth in a REST API environment and do exactly that - hit the database to determine if a JWT has been invalidated. Works great, no worries.
If you use OpenSSL to generate public and private keys that both are stored on the server and are used to crypt the Token, then how exactly would you generate an encrypted token locally on your machine and check its validity without asking the server? Either i am missing something obvious, or its not possible.
[wow..](http://imgur.com/wpZ5Apv)
&gt; CSRF is in both cases possible. It is not. Which is the reason CSRF tokens are commonly stored in cookies to start with.
https://labs.mwrinfosecurity.com/blog/laravel-cookie-forgery-decryption-and-rce/
Implementor of one of the JWT-based session middlewares (and CSRF protection layers) out there. Specifically: * https://github.com/Ocramius/PSR7Session * https://github.com/Ocramius/PSR7Csrf Usage of these sessions has clear limitations described in the package docs (including security requirements and limitations). Still, the packages cover ~90% of scenarios, but of course not 100% of all of them, nor were ever meant to do that. I don't see a point in the article, therefore. I think that /u/Shadowhand's answer pretty much clarifies the flaws with this article at https://www.reddit.com/r/PHP/comments/4nwpvg/stop_using_jwt_for_sessions/d47n15v
It was taken down by the author (who provided it for free without pay for a long time). The plugin has been forked and I am migrating the plugin to a new repository. The new plugin repository is a "stable" release based on phpfmt version 6125cf9 (before the business model change). It is available at https://github.com/nanch/phpfmt_stable. To revert to version 6125cf9, you can download the zip from https://github.com/nanch/phpfmt_stable/archive/master.zip and put the contained files in a folder: C:\Users\Me\AppData\Roaming\Sublime Text 3\Packages\phpfmt
The request in packagecontrol.io to point to this new repo is already on the way. It might take few days though.
Completely bad at making my point today... it wasn't a pro 5.x comment, or a pro WP comment. I'm pro what you're doing; you've released a lot of very nice libs, and some readable, enjoyable articles. 
creator of phpfmt plugin here. phpfmt plugin comprises two parts, an engine built on top of token_get_all command and the plugin itself. I have been on talks with an interested buyer that wanted to own the copyrights of phpfmt engine and its plugins. After some debate, they decided to buy only the phpfmt engine's copyright. While the deal was being closed, /u/nanchiboy opened those PRs. So it might seem that he had any part in, but he didn't. When the deal was closed, I decided to move phpstorm-phpfmt to github.com/Shaked (he's the only who built it anyway) and move sublime-phpfmt to somewhere else from phpfmt. Meanwhile, /u/nanchiboy and I exchanged messages and he was OK in taking it over. So he said that I shut it down yada yada yada, but I was in the process to move to a new repo. The timing was formidable to say the least. /u/nanchiboy seems very enthusiastic in keep sublime-phpfmt (and its Win version) going, and I cheer to his success. By the way, I need to find someone to maintain vim-phpfmt too (msg me if you want too)

That doesn't help though: https://github.com/guodf/VSCode-phpfmt/issues/3
Considering the final `fmt.phar` file has only that 1 license, and it appears to permit free usage, I would be comfortable using it freely. Do you have any details about where or when new licenses may be obtained (for newer versions)?
The current owners should reveal themselves anytime. I am commanded to be silent on the details of the deal.
API first, make your web-app a consumer client of the API.
or write a script that you can schedule to do cleanup, scan dir directory contents and remove database entries, then do the opposite and remove orphan files.
Quoting from the answer to which you linked: &gt; Any derivative works during the time of the license continue to be licensed even after revocation. This fork (and I'm guessing others) is a derivative work. If this answer is considered to be lawfully accurate, that provision means this fork (and I'm guessing others) are still freely usable. 
It is, because cookies are sent with each request, even with forged requests. That's why you pass the tokens via hidden form parameters.
Hence why my post said "in most cases" and not "all cases", in response to OP's "greatly" and not "completely". I always assumed HTML Purifier was just a bigger blacklist, what does HTML Purifier do differently?
It digests your text input into tokens, rebuilds a valid HTML document with configurable whitelists, and discards anything that deviates from the standards.
The point is that statelessness is JWT's selling point. If you're not using that, why use JWT at all?
&gt; If you use OpenSSL to generate public and private keys There's your problem. The fact that you do that, gives you a strong key. It isn't the 'encryption' that provides your security, but the fact that you've *generated a strong key*. Just generate a strong signing key for your JWT and you can forget about the entire encryption step.
You don't need to, the browser does that for you. That's the entire reason CSRF is a thing. You build a form that will POST a request to, let's say, delete one's Google account. If you make another person visit your malicious site and either manually or automatically submit said form, the browser sents a request to Google, including the correct cookies, which would make the Google server believe the request was willingly sent by the person and delete their account. That's why you generate short-lived tokens and require that all POST requests pass them. An attacker can make your browser send the right cookies, but he can't make it send form parameters it doesn't (and can't) know.
That's the joy of our industry, formal education is essentially worthless. The tech moves too fast to be taught anything truly practical. 3 years of a computing course and I learnt more in my first 3 months on the job than the entire course. I don't even look at education when hiring devs. Self taught with the huge number of available online resources is far more valuable. 
i really doubt it's the router as most tests have 1 or 2 routes. It's probably a lot of PHP code of all different kinds that "boot" the application with all the right Objects, even if you won't use them. If performance was critical to me i'd try out PHPPM, even though it has a lot of gotchas. Update: I made a little naive test and most of the time is spent here: * Illuminate\Foundation\Bootstrap\DetectEnvironment * Illuminate\Foundation\Bootstrap\LoadConfiguration * Illuminate\Foundation\Bootstrap\ConfigureLogging * Illuminate\Foundation\Bootstrap\HandleExceptions * Illuminate\Foundation\Bootstrap\RegisterFacades * Illuminate\Foundation\Bootstrap\RegisterProviders * Illuminate\Foundation\Bootstrap\BootProviders
Reading this, is like looking into a mirror of myself. Like OP, I suffer from depression and anxiety, and like OP, I have that little voice in my head that tells me that no one wants me around and other things that undermine my confidence in going out and meeting new people. Our industry is a funny one when it comes to depression, as much as we say we need to seperate ourselves from the code we write, its hard not to take things personally when you read things like "oh, your code is crap", "you're not a real developer unless you practice X" or "only bad developers use Y tool/language". We're told we need to seperate ourselves from our code, yet these comments which are incredibly common on reddit/HN etc can be pretty personal. My advice to people who read this and can relate in some way is to talk to your GP. Having been through it myself, I know people can feel like it is embarassing or a sign of weakness to admit to someone that you might be suffering depression, but remember this - depression is an illness just like any other, and I can guarantee that not only has your GP probably heard hundreds of stories just like yours before, but their entire job is to care for you and help you get better. If you are really unsure, talk to someone close to you whom you trust, they might tell you the same thing I do, but I am just some strangers voice on the internet, and you are much more likely to listen to someone you trust than to me.
Not really setup that way, but how would that help with 2FA?
&gt; I used a minimal installation of PHP and Apache with no additional configurations or sever settings changed. Does that mean you didn't use OPcache? 
Isn't that standard now on 7?
It's always built as a separate extension and some repos don't include it with the PHP base packages, not sure about the version of Ubuntu the OP used. Also, the ini settings could make a huge difference.
&gt; That's why you generate short-lived tokens and require that all POST requests pass them. And you would of course be sending that POST var regardless, as that is how you implement anti-CSRF. Storing the token in a cookie does not make you more susceptible to CSRF vs local storage. The attacking site can do nothing with the cookie, just like they can do nothing with local storage. I'm not advocating that you use a JWT to prevent CSRF, as that seems weird, but you certainly could if you wanted to. Storing it in a cookie vs local storage makes no difference. EDIT: So what I said still holds true - the attacker would have to have the value of your cookie in order to populate the POST field. They can't get that unless there is an XSS vulnerability.
Seeing as Lumen is included, it seems weird not to include Silex or Slim. 
What I want to know is why the hell Codeigniter consistently does so well in benchmarks. For something that old, and CI3 is pretty creaky, it performs better than most other popular frameworks in almost every test I've ever seen. I mean, there's a big difference between the results for CI3, and the results for Symfony or Laravel. Not sure whether the right question is what makes CI so quick, or what makes them so slow, but either way I'm curious.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/hance] [Writing Functional Tests for Services in Symfony](https://np.reddit.com/r/hance/comments/4o0634/writing_functional_tests_for_services_in_symfony/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Not every day, but possibily two or three every week. Today there's another one coming.
Well I did managed to call php with this script : #!/usr/bin/env bash docker-compose run --rm -u "www-data" php_container php -v Where `php_container` is defined inside my `docker-compose.yml`. So I assumed by tweaking it and put it like that : #!/usr/bin/env bash docker-compose run --rm -u "www-data" -w "${PWD}" php_container php "$@" And call it from PHPStorm would the same as the script in the link I provided. Plus I can use my container without any added setup. But PHPStorm can't recognize the script apparently. I wonder what's the difference because to me it's the same. I would love to be able to make use of this container because I won't have to setup another container just for testing purposes outside my docker-compose setup and because he already know how to talk to mysql for instance, for which I need for some tests. EDIT : so I tried to build an image and I end up to the same result. Here's what I did : 1. I took your dockerfile (removed the part where you copy file for php-fpm as it fails for me and stop the build) 2. Created a `/usr/bin/docker-php7` file : `#!/usr/bin/env bash` `sudo docker run -it --rm -v "${PWD}":"${PWD}" --net=host -w "${PWD}" docker_php7 php "$@"` 3. I created an interpreter with this file (which PHPStorm doesn't seem quite happy with it) 4. Setup'd phpunit with `/usr/bin/phpunit` But when I want to launch a test, PHPStorm says : &gt; Error running ServiceTest: phpunit.phar is not specified or invalid. Press 'Fix' to edit your project configuration. for ImportServiceTest run-configuration 
&gt; Or better yet, just tell your object do the thing and have it throw an exception if it can't complete its work. Even with an exception as a fallback I would still have the check in place. There is no need to provoke an unexpected situation if one can be avoided. This depends on the business case of course. &gt; Having a `__toBool` method would also make the truthiness rules in PHP really hard to deal with. Right now we can rely on any object having a truthy value. If `__toBool` existed, userland classes could mess with that expectation quite a bit You should switch to strict comparisons any way, ie.: `if (null !== $object)` instead of `if ($object)`
I know what CSP means. I wonder why was it mentioned.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Alright. Great to hear. I specialize in nodejs, I always use express with socketio. So I can just send the user a php file and it will work? Or would I have to get another module to handle all the php
If you're using an existing framework it may have a way to broadcast events via something like Redis out of the box. If not, then it should be fairly easy to create. I wrote [a blog post about how I did it](http://matthewdaly.co.uk/blog/2016/05/14/broadcasting-events-with-laravel-and-socket-dot-io/), which you may find informative.
Keep in minds that steam profile names aren't unique and can be changed at any time. Socket.io is also a client, so you can replace your jQuery AJAX solution with a socket, and have a socket server either in node or with PHP (yes, it can be done - the question is should it be done ;))
Alright, the update function is for updating the profile name :P. I will look into it, thanks!
If you're integrating chat you should just be able to set up a websocket connection straight to a Node.js server. Correlating the sessions between PHP and Node.js will be simple enough, the client could pass a token through when it opens the websocket.
Right, if you don't use the cookie for the actual token verification on the server side, it's no harm storing the token in a cookie.
Because it's old, so it doesn't have the ridiculous amount of bloat that newer/"better" frameworks have. That'd be my guess anyway.
Knowing and computing something are different, but let's not get bogged down in terminology or we'll be here all week. Having access to, allows you to know is my point. Access is trivial, so knowing is trivial. I don't think you can compute the key; that is not my point. But access is now one of the simplest ways to hack anything, and that person using "password" or "1234" as their password; is going to be easy to access
It shouldn't, but nice question ;-)
Ratchet does what you want : http://socketo.me
I have never had anything other than abysmal experiences with outsourcing. It has been my experience that outsourcing costs you 3x the amount of just employing someone locally. This stems primarily from having to employ someone to fix the problem created by the outsourced company/agent but also from loss of revenue due to unlaunched products, broken systems, etc. The end result is you are not actually accelerating anything, you are just wasting money. I second /u/Wraldpyk with the idea of getting freelancers into your office.
An asia-based full time freelancer here. I believe I'm doing a great job, and my clients tend to stick with me. On the other hand, my roommate is also freelancing, and even though he is putting all his effort, we have a lot of different devOps and our clients are getting entirely different work. - If it applies, prefer freelancers who know their way around version controlling. Then, make your human code reviewers keep an eye on their code for every commit. Spin up some CI servers, and test their code with an MD and a CS checker. This helps us a lot to automate most of the work. - Secondly, I would like to say that designing the architecture by some senior developer and making the freelancer follow the blueprint can sometimes backfire. I know how hard it id to stay on the field, and chances are, your developer knows how to design the architecture properly. You are just decreasing the productivity of them. I'm not saying to let them break the consistency either. Just give him some room to make his own decisions. - Please refer those who speak proper English. Emphasis "speak". The job applications, cover letters, and everything can be a copy-paste. Being able to speak English means a great deal because they can at least figure out something from stack overflow or such on his own. philippines people will speak English well enough, but that does not necessarily mean they can do a great job. - Unfortunately, PHP has a very low barrier to enter, so everyone claims to be a "PHP ninja". If they call themselves a ninja, move on. See their github contributions, stackexchange rep, etc, and decide yourself. 
In my experience as a contract and an employeer: The biggest downfall is hiring outside help too late. If the project is behind there's no point in hiring outside help to save it. Deal with the lateness and move on. Adding outsider contractors or in general more people to a project hinders the timeline. Unless someone is actively doing nothing [fire and replace]. &gt; My client wants to accelerate the amount of work we're getting through by outsourcing some development (Asia most likely). Honestly this is only going to work if the project is longer than 6 months. It takes literal weeks for a new-hire to correctly on-board regardless of their skill-level. &gt; I'm thinking one way to limit the risk might be: start with a software design, and ask the developer to write specific implementations - almost class-by-class, initially - so the client can build a relationship with a developer without setting themselves up for a big shock. For the best experience: - Have a scope of work document - Work with Test Driven Development. Furthermore for each "unit" of work have a minimum amount of tests it must pass. For instance your class idea, that's fine but make sure each method signature is documented, and make sure each method passes your tests. The only problem with class driven development is that you need to know exactly the entire design to figure out a logical starting place. - Do not delay payment to good contractors. - Conduct Code Reviews on completed work, either as a method of closing off a task item or on a weekly basis. I personally have no good outsourcing oversea stories... I have hired US/EU developers with great success.
We outsource a bit and get hit or miss code. We also tend to hire the more expensive outsourced folks so I don't know if that makes a huge difference. Communication can be hard so make sure you hire someone who speaks well in the spoke language of choice at your company as well. We also tend to set up check in points after having a few issues where someone came back 30 hours later and basically hadn't started. I would check in with them more often than someone at your office (with the understanding that yes, they are coders as well and hate it as much as you do). edit: ultimately I would rate them as 4/10 or 6/10 on average. Some are better than most but ultimately I think it's better to hire 2 great devs instead of 4 meh's.
Same thing for me here (France). Trends are for outsourced developments. I'm in my 8th outsourced project (india, brazil, madagascar and togo). Poor code quality, very poor communication and very low dev skills. Keep outsourcing works for non-dangerous projects.
You can outsource, sure, but if you're doing it purely to save money, you're in for a bad time. There aren't hordes of freelancers out there willing to do great work for peanuts like many managers think. Don't be cheap. I recommend you find someone who really knows English properly, otherwise you'll get stuck with mysterious functions, variable names and even weirder comments. Not to mention the fact that a lack of proper communication yields very bad finished products. Start small. Don't dump the developer into the pits of your code base and then expect him or her to do just fine. Prepare some smaller tasks and make yourself available for any questions. Make sure your new dev can contact you for anything at all. Just like you said - build a relationship. Imho, outsourcing can work great if you separate your jobs properly and find the right people for the right price.
&gt; You did little to no research on this. By going to `phpmentoring.org` the problem is [blindingly obvious](http://image.prntscr.com/image/4e0718fb11c1497aa037ed631df0d09c.png). Screenshot doesn't work. For those wondering, it's because the domain name is parked with Ghandi, and not pointing to the website it's meant to
If you want to run command directly within your running container, I guess you could look at the [docker exec command](https://docs.docker.com/engine/reference/commandline/exec/). I had different goals than you when I setuped PHPStorm with PHPUnit.
Read "[Speaking of India](https://www.amazon.com/Speaking-India-Revised-Bridging-Communication/dp/1941176119/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1465910967&amp;sr=1-1)". It explains some of the cultural differences that cause difficulties with outsourcing.
&gt; The point is that statelessness is JWT's selling point. Checking a database does not make it any less stateless.
While this may be interesting to some people, I don't see how it is connected to PHP.
I haven't read the other comments, but in my experience you get back what you put in, regardless of the country of origin. Foreign employees has its unique set of hurdles: language (including difficult to understand accents), hours of operation (Chennai, India is 10.5 hours ahead of Eastern Standard Time, as well as quality. A lot of outsourced contractors have other jobs they work on, so they are having to divide up their time, which sometimes shows through the code quality. That said, I work with a team of outsourced Indian developers. There are a couple that are really great, and if it were up to me (it isn't), I'd hire them full time. There are a couple who seem to be in the business simply to earn a paycheck (not unique to foreign developers). We talk constantly: Skype, email, and daily phone conversations. I find the phone conversations difficult because of the accents and having already bad hearing. So I find myself asking them to repeat themselves a lot, which I'm sure is pretty frustrating. But they kindly oblige. Working with a remote team can be rewarding. A nice side effect of the time difference is that we practically have someone available for questions/emergencies 24/7. Bonus. But, there is one drawback that comes with adding bodies to a team: more people does not mean faster work--not initially at least. You have to remember that no matter the skill level of the developer, they still have to be on-boarded and learn your systems. This takes time. It also means you have to take an existing developer to train the new people (maybe more than one). This often equates to slower development all around. As long as you and your management team accept and understand this, then in a few weeks (or even months), you'll then start reaping faster development cycles. Just keep communicating as often as makes sense for your projects. Be patient. Even the worst of developers still want to do a good job (if they don't, fire them immediately as they tend to be the "somebody" who poisoned the water hole), and if treated like members of your team (i.e., given some sense of ownership) they might decide to rise up and become better developers.
make a symfony console app... php cli.php delete 1234 -&gt; runs unlink then db transaction php cli.php download &lt;link&gt; -&gt; downloads then creates a record in the db
Outsourcing can work but detailed requirements and specifications need to be made. This will take a lot of time that would typically be used for development. In my experience, the project managers that want to outsource are the ones that shouldn't. To be fair, I have made a living off of cleaning up outsourced projects that failed. 
got job to fix code after indians. poor guy from australia paid them LOT of money and job was late and not even done so he decided to find someone. unlucky it was way too late for him. * they used one single big ass fat class (tens of thousands lines). * db injection in every single query. * also they really loved to download twiter/facebook tweets using PHP (not even caching it) together with main "template" so load times was complete disaster. * obviously no formatting at all css html and js was disaster too i won that job at elance some time ago, but when I saw their code I rejected the job and I gave guy proper explanation, tips and I let guy know how sorry I feel for him. edit: * and obviously sql, php, html mixed all together worpdress beginner plugin style everything they did was like from 2000 book except they "used" OOP which was single class. all php developer nightmares in one project.
What about return types? There is no variable like this: public function method(): $var = null; It is obvious you did not read the RFC for nullable types or any of the discussion around it.
You get what you pay for.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I think I'll stick with an extra image but I can't make it work. I don't know how you managed to make PHPStorm recognize the script as an interpreter. That's where I'm stuck for the moment.
ingenious library!
Thanks friend! One of my goals in making it was challenging myself with modeling a really terrible arbitrary process and use it to discuss the merits of unit and bdd tests in understanding what is happening in the code...and I just love the hell out of Rick and Morty
Well... this kind of testing breaks DRY quickly. Also please see: http://stakeholderwhisperer.com/posts/2014/10/introducing-modelling-by-example
Really nice, I'm doing a lot with ES in Laravel and my implementation is nowhere near this clean. One suggestion would be to be able to build migrations for ElasticSearch so that you can properly define the fields (I also end up adding a lot of fields like .raw to make term matching easier, for example.)
If you need a seeded random number generator, shouldn't that be an object so you can have multiple instances? Or return a token/resource after seed you can use in function calls to decide which instance you use? rand() and mt_rand() should be deprecated and moved out to a library imo, replaced with a multi-instance seeded rng object interface, where you can have ClassicSeededRng, MTSeededRng, PCGSeededRng, ...? 
https://github.com/phpmyadmin/phpmyadmin/blob/4cd8ab8a957a2324b4e218acc048642b9a6d2a23/libraries/session.inc.php Despite setting several security-related session configuration values, they don't touch the cookie entropy fields, which means a potential session fixation vulnerability. Typically your distro ships a php.ini configured to read at least 16 bytes from `/dev/urandom`, but many projects set this just to be sure. EDIT: To be clear, I'm not offering this as a criticism of the audit nor NCC Group. They were severely time constrained and phpMyAdmin is an enormous codebase. They did a stellar job, especially if they don't work with PHP every day.
The following practices in your coding standard are terrible: - prefixing private attributes with _. We have the 'private' keyword for that nowadays - inlined opening braces for classes and methods. WHY - 3-line attribute PHPDoc type hint. Have mercy on my scrolling wheel. /** @var string */ - those spaces you put after opening parentheses and before closing parentheses - that "// method_name_here" comment you add to the end of methods. If your methods are long enough for that to be useful then your problem is method length. - those unnecessary blank lines you put after &lt;?php and class declarations. https://github.com/remotelyliving/plumbus-php/blob/master/src/Factories/PlumbusFactory.php#L16 - catch on its own line: https://github.com/remotelyliving/plumbus-php/blob/master/src/Factories/PlumbusFactory.php#L58 - no NL at EOF http://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline Peace among worlds.
I don't understand why you'd really care unless you want to contribute, but I'm guessing you don't. Furthermore, these are the coding standards of my employer and I find it much easier not to switch for personal projects. They have several well used OS contributions with these standards enforced as well. You're 100% free to not like them.
I just don't wanna see a post about your coworkers' suicide notes saying "PSR-2".
&gt; why you'd really care unless you want to contribute, Not all contributions are going to be in some specific format you desire. I would think that this would be something to appreciate from your own editorial.
&gt; For example, the Indian developers I've come across will almost always say yes to a question This drives me absolutely insanely potty. It wastes *so much* of everyone's time.
Sure, I agree with you. I'm just saying if you're not going to be all up in this repo, let it be.
The only one of those that isn't entirely a matter of opinion is: &gt;that "// method_name_here" comment you add to the end of methods. If your methods are long enough for that to be useful then your problem is method length. Everything else is just you telling OP to do things your way because you like your way more.
He's got a point though. Any additional optimizations would also improve frameworks with a better performance than Laravel. A better question to answer would be whether the performance tradeoff is worth it.
You can also get a lot less than you pay for, so how does stating this help?
ctrl+alt+f in netbeans would do better job than them
[removed]
Of course not, and I'm not proposing we do that either (just in case anyone is misled by your comment). I'm not anticipating much internals support for replacing the existing functionality with something more modern, but willing to be surprised. Also, just for fun: https://github.com/lt/PHP-PCG
Without a secure RNG, the cost of this attack is roughly on par with brute-forcing a 32-bit number (in the worst case). It can be done from anywhere.
If anyone is relying on the functionality that this RFC breaks, I've knocked up a [Mersenne Twister compatability library](https://github.com/lt/PHP-MT19937) that provides the old broken functionality.
&gt; css html and js was disaster too I can remember acting as outsourced CTO for a business; I always felt sorry for the Indian coders until one day I asked "Why don't you have tooltips". I was told it would take a month to develop, so I took a look into the code. Having a coding background I was horrified to find jQuery had been edited "to add functionalities", and the prototype for the software was built in a point-and-click application that had no idea of OOP or classes... &gt; everything they did was like from 2000 book except they "used" OOP which was single class. all php developer nightmares in one project. The one thing worse than one large class is no classes. On the same project, I found a CRON task that was basically copy-&gt;paste, where code would repeat. The saddest part was that we used CI to try to ease them into development, and they acted like knowing MVC was a feature, not just a way of tackling problems... I don't think it's right to blame the outsourcing company, often they receive very little vision, support or direction; which is why I now take more time selecting clients, asking what processes they have and seeing how open to input they are on this. If someone thinks of IT as a magic hat, they will always be disappointed.
It could be because the author wanted CI to shine. Slim was faster in my results. I had a weird feeling about this so I ran it myself, with some minor changes: - overkill opcache and realpath cache settings. The defaults for these aren't fair on larger frameworks. opcache.validate_timestamps = false opcache.max_accelerated_files = 12000 opcache.memory_consumption = 256 opcache.interned_strings_buffer = 16 realpath_cache_size = 4096k realpath_cache_ttl = 7200 - benchmark.sh makes a request to /hello/world and sleeps for 2 seconds before proceeding with ab - ran nginx with fpm instead of apache - reload fpm before every framework in order to start with clean opcache I used the same 2GB digitalocean VM. |framework |requests per second|relative|peak memory|relative| |-------------------|------------------:|-------:|----------:|-------:| |no-framework | 3,898.94| 18.2| 0.33| inf| |slim-2.6 | 1,848.48| 8.6| 0.39| inf| |ci-3.0 | 1,688.35| 7.9| 0.00| nan| |slim-3.0 | 1,453.31| 6.8| 0.00| nan| |lumen-5.1 | 1,681.14| 7.9| 0.00| nan| |silex-1.3 | 1,260.73| 5.9| 0.00| nan| |symfony-2.7 | 590.99| 2.8| 0.00| nan| |symfony-3.0 | 459.72| 2.2| 0.00| nan| |laravel-4.2 | 213.79| 1.0| 0.00| nan| |laravel-5.2 | 286.29| 1.3| 0.00| nan| |zf-2.5 | 321.90| 1.5| 1.06| inf|
Did you not notice the project I'm commenting on isn't of substance?
A missing NL at EOF breaks CLI tools. You need those if you want to be able to use things like sed and wc.
This is absolutely squanchy.
Totally squanched to hear that.
That's a good point. Is there a benchmark comparison out there for the most highly optimized versions of each framework?
Your shitty attitude is why no one would want to adopt whatever you're proposing. Psr aside, if you're working with people for acceptance of a standard, invite them in. Show them why it benefits them, and don't insult or demean them when they don't care the same way you do. You're saying it isn't what you like more, but it is. Instead of actually proving a point, all you've done is hide behind a body of work and say: "do what I say because it's what a groups of people want."
It's not personal, I'm taking the time and care to actually respond to you. The fact that you've got to whip out your throbbing psr to combat its non use on a joke lib is what's puzzling to me. We're just having fun here dude. More important than a standard is the ability to communicate and get work done with a group of people. I don't care how standardized your code is. Unless I've completely misunderstood you, I wouldn't hire you.
you must be joking, right? it's a php implementation of Plumbus
The domain info was updated today: Domain Name: PHPMENTORING.ORG Domain ID: D165984083-LROR WHOIS Server: Referral URL: http://www.gandi.net **Updated Date: 2016-06-14T00:37:52Z** Creation Date: 2012-07-03T16:23:59Z Registry Expiry Date: 2017-07-03T16:23:59Z So, someone probably messed up when updating something. 
`// method_name_here` at the end of functions is a rule enforced by the PHPCS and Squiz standards, fwiw.
Now the question i am asking myself: Is anyone actually using phpMyAdmin?
I own a software shop in the Philippines. I'm American. We've been in busy for many years with some fairly large clients, for a long time. I've seen first hand the issues and non issues people here are commenting about. Cost is not the issue. The biggest issue I see is that clients often fail to produce a good spec with context, background, engineering/performance requirements, and wireframes/mock-ups. There is a ton of non-verbal and indirect information a programmer gains when on site. Much of that is not present when you're off site. This is even a problem for telecommuters within your own country. Clients tend to just throw projects over the fence. That's not how any project should be treated. Then they complain when they don't get what they want. Oh, you want nice code? Well did you ask about your vendors QA practices and interview it's developers in some form? If you got bad code it was probably a relationship management problem not an outsourcing problem. I've coordinated multimillion dollar projects offshore with quality results. Did I just throw projects over the fence? Or did I use agile practices and set explicit expectations with regular check ins and qa. Bad things happen sometimes, even internally at your own company. People write shitty code. Sometimes because they were a bad hire in the first place. Hiring someone in house doesn't guarantee anything. Tldr people here don't understand the actual problem. Provide good specs and context, research the company you hire, and manage the relationship appropriately. Also read The Black Book of Outsourcing
Passes security audit, fails grammar and spellcheck audit in the first paragraph. "Software Freedom Conservancy congratulates its phpMyAdmin project on succesfuly completing completing a thorough security audit, as part of Mozilla's Secure Open Source Fund. No serious issues were found in the phyMyAdmin codebase."
I've being waiting for this since type declaration introduction!
12 years?
I haven't used it since I discovered Adminer, single file and much better usability than PMA imo.
Call it what you will. You referred to feedback as "insulting" and "demeaning". You're as butthurt as they get. As I said, if it's all praise you want then perhaps you should stick to showing this stuff to your loved ones.
Hey I'm gonna call it a day with whoever you are. I didn't make/submit this for praise. This was a joke to make people who love php and Rick and Morty laugh. I worked hard on it, but if I was looking for street cred I wouldn't be here. I'd be off quietly working on symfony.
I still use it on home projects that use MySQL, otherwise Toad. 
My question is, given the more than a 2x difference between Symfony and Laravel, and given that (as far as I know) their reasons for existence and use cases are very similar, why would I use Laravel rather than Symfony?
&gt; The one thing worse than one large class is no classes. sorry for sarcasm but say hi to every C program, for example linux. no. its not about them using/not using classes, you can build beautiful php app using functions only (there is no point i know) but thing i real thing they used class because they thought its OOP. basically one constructor and $this everywhere. they just used class as namespace or shit, it was disaster i feel bad i deleted sources (I respected my employeer) i could get infite karma here for shit they did there :D 
Yeah. But it's too late now, ain't it? You fucked up and you'll be forever haunted by your mistakes of the past.
Better late than never.
You'd have to consider what resources there are outside of the framework itself that'll make development easier at this point, like good documentation and community support, and whether that makes up for the performance hit. A framework can be optimized out the ass, but if it's impenetrable and no one uses it, it's not worth your time. [added by edit] Case in point is PhalconPHP. It's stupid fast, but it's got an added layer of finicky setup because it's a compiled extension. For devs who need speed at any cost, it's awesome, but that tradeoff between ease of use and performance is still there and it means not everyone is into it. This isn't to say Phalcon is impenetrable - it totally isn't! But if performance isn't as important to you, as a dev, than ease of setup and deployment, then it's not for you and you'd be better off going to Laravel or Symphony.
There is a reason C is isolated to low-level systems like kernels and drivers. I'm not talking functions, I'm talking an entire app with modules etc written almost entirely in procedural code (80%). It was an app from 2008, but I worked on it between september 2012 - End of January 2014. It was horrible, it made me a lot more picky over clients and what they accept as nothing was documented either. Lastly PHP is not C!
Article is pretty old and mixes the ideas of testing with BDD. Gherkin syntax is a high level abstraction so there should not be any "I wait for x seconds" or filling fields by their HTML names. The scenario should follow the real user's actions while underlying steps can perform all required technical actions.
I'm confused, isn't this exactly why `mixed` exists?
Personally: weak typing is a mess, introduces unncessary complexity, encourages (what I think are) bad practices.
That's not a language keyword, it's only in the manual.
mixed means any, and isn't a real type while union types are only those in the union.
Why wouldn't they?
There are MUCH better tools for the job. Hell, MySQL Workbench is better.
I would like to see that statistic :)
Why would anyone be against that?
It doesn't mean everyone has to use the better ones.
Wherever you go, customers will use ORMs in their software, you probably do too, if not, you should at least concider it. Most ORMs allow you to create databases and schemas directly from your entities. Its super easy to do this and its easy to get a normalized database out of this. Also if you don't want to rely on the default table design of your ORM, you can control nearly everything through configuration. There are some very rare and special cases where you would not be able to solve a problem through ORM configuration, and this is when you simply could connect to your mysql server or use a tool like the mentioned DataGrip or MySQL Workbench, or microsoft sql studio or whatever. Like said, in the past 5 or 6 years i have never used PhpMyAdmin, and i have never seen anyone using it on a live machine. In short: there are better tools to do the job!
Wherever you go, customers will use ORMs in their software, you probably do too, if not, you should at least concider it. Most ORMs allow you to create databases and schemas directly from your entities. Its super easy to do this and its easy to get a normalized database out of this. Also if you don't want to rely on the default table design of your ORM, you can control nearly everything through configuration. There are some very rare and special cases where you would not be able to solve a problem through ORM configuration, and this is when you simply could connect to your mysql server or use a tool like the mentioned DataGrip or MySQL Workbench, or microsoft sql studio or whatever. Like said, in the past 5 or 6 years i have never used PhpMyAdmin, and i have never seen anyone using it on a live machine. In short: there are better tools to do the job!
&gt; You fucked up and you'll be forever haunted by your mistakes of the past. Well, maybe. Not sure that's the fault of this RFC though.
On the other hand, I read the other RFC's that is meant to solve the problem, but I guess having a shortcut here and there isn't messing anything up, right? `public function whatsMyName(): string | null;` Nullable types already exist, return types are new. I'm not arguing that this is good or bad, I was expressing an opinion, and if that meant stepping on your toes, I'm sorry.
I actually like MySQL workbench. I've given up on phpmyadmin. It's doing way to much SQL parsing/manipulation behind the scenes.. and just look at how many open issues are tagged *parser*
noSQL is all the rage now /s
I am just saying that you usually don't need to use tools like phpMyAdmin anywhere close to how often they where used like 8-9 years ago... I am not saying you need to switch to any other toolset if you dont want to. But obviously it would make sense regarding how you develop software these days.
Why not? I know a few alternatives of course, but it is really convenient and it does its job perfectly. Is there a way better alternative I'm not aware of?
Yeah, except if less people were using this, we wouldn't end up with so much script kiddie port scanning etc. to clutter up logs.
I want some of that hate - the same people are still using cPanel.
The fact that I mentioned no nation or geographic locations in my comment, yet you chose to be offended because of where you live, only alludes to the grains of truth in the stigma that you find offensive.
Trying to enforce a coding standard across every project written in an entire language is dumb, and PSR-2 is bad for that reason. I will follow the coding style of a project I'm contributing to, but otherwise I'm using the style I prefer on projects I maintain, and that's how it should be.
You don't need to tell me, i already got 9 hate points for trying to explain that to people :P Its probably because there are a lot of beginners installing xampp or something that feel offended.
Lots of people on here don't do operations for a living.
sure, so does notepad, but if you want to do the job quickly and not waste your life, use better tools.
TIL. Thanks!
I use ORM's, but I also still need to get to the database very often. I need to test queries, look at data, change data to test different scenarios, etc.
Now i am finally seeing some arguments here. It could make sense if you propagate data into your databases to run different scenarios of your integration tests. Although i personally would run those against a mock, not against a real database connection. Since i don't want anyone to twist my words: I am not saying you should do it like i do, i personally just feel like this is the way that results in the least amount of problems, and it worked out great for me in the past. If i need to write more complex queries, i would use DataGrip or any other tool that i got to hand. Off the topic: Others stated that they want cross platform support, but i think phpMyAdmin is the exact opposite, since you probably do not have php to hand if you work on a project utilizing any other programming languages. "But i am a freaking php developer!" - you are a developer, a language is just a tool to make your solutions real
&gt; in that case any typing at all is introducing complexity. Not to the degree of union types. I have difficulty enough explaining the weak typing rules clearly and concisely just for, say, `int`, which is why I ended up pretty much hand-waving it when I did a talk about it. Weakly-typed `int|string|bool` is a whole new level of complexity. &gt; It's perhaps true that it may encourage some bad practices, but I don't see the abuse potential to be that important here. After all it also solves some problems, which aren't really solvable without it (apart from no typing at all). We don't need to add type declarations for every possible use-case, because we can always fall back to no type declaration. I'd rather we be selective in which declarations we support, to nudge people towards cleaner API design.
I cant believe a (probably) developer can be so resistant to arguments. Your posts are highly opinionated and personal instead of objective and informal. At least give some arguments.
Most hosting companies still give it as the only way to access MySQL. So yeah, lots of people use it. 
what? you mean quit using it? if so, read the rest of this mess of posts :P
&gt; I didn't mean actual tests. More like "hmm this shit is broken, let's see what happens if I change X to Y". Makes sense to me. &gt; Which is not really a good argument considering all of the better tools are already cross-platform. Exactly! 
You know what, I appreciate the work you do, really. But what always gets me is this ABBR things and of course, the complication of everything, that I don't understand. So imagine I have my password stored in (simple..) md5(), crypt('$1$'), crypt('$2$') or whatever - even though it's not secure from your POV, whatever: how insecure is this really? leave out md5 or whatever is incompetent from my side. So how can I potentially (or really) break a system that uses X as an algorithm. Would be nice if you could explain that or even link to a page where you already did that. Thx a lot! edit: I dont want to know how to bruteforce whatever sth., I just want to know how and how long a possible attack will take and how it looks like or whatever. I think its important to know at least why you are doing X and what is Y
One Word: Adminer
every php developer knows in his/her heart, that there is no escape from phpmyadmin 
I already stated in another post that i do not differentiate between developers using different languages. PHP is just a tool like any other object oriented language. You use the same logic, the same pattern and the same principles to develop in all those languages. At the core you as a developer are just a problem solver.
Why do not use server-sent events? With socketio the connection is full duplex with client and server. With SSEs you can implement the publish-subscribe pattern. I'm just asking because I'm noob and I'm developing right now a chat using SSEs. 
Because marketing.
i was only joking, i'm a sequel pro person myself. phpmyadmin is so pervasive though
I don't know enough about the internals of either one to answer, and I don't really use them, sorry.
&gt; Weakly-typed `int|string|bool` is a whole new level of complexity. While that's true, it's just mattering internally; in the eyes of the user, he just sees the surface, but typically not the hidden complexity, which is why it should be pretty much negligible in the users eyes. But still, better suggestions for this are welcome. At least with unions it's deterministic what will arrive inside the function. Without unions you completely loose control and whatever magic is done inside that function to properly handle the types weakly is not visible from the outside (i.e. signature interface). &gt; We don't need to add type declarations for every possible use-case, because we can always fall back to no type declaration. I'd rather we be selective in which declarations we support, to nudge people towards cleaner API design. While I'd like to agree here with you, I've found myself annoyed enough times writing PHP 7 code with this and that not typable just because of certain limitations. The language has a certain responsibility for users to not do shit (strictly seen you do not need goto and it's typically a bad construct, but it has it's uses (which are achievable without in uglier ways…)), but it also should not introduce arbitrary limitations in typing and control flow (i.e. goto). Ad. Why use scalar types and class types at all? We always can fall back to no type declaration and just have it properly throw Error at the first object access. (or classical weak cast upon first use)… I realize it's a little bit exaggerated, but I think you get the point...
Which MySQL clients *aren't* cross platform?
&gt;But doesn't giving away the salt make it easier? Correct, having a salt stored in the database doesn't make it much harder to bruteforce (versus a shared salt unknown to the attacker). This statement is only valid if the attacker targets a single account because using salts does make it unpractical to crack more than one. If you think it can be a problem, you can: 1. Increase the cost(rounds) of password_hash making it very difficult (read: impossible) to bruteforce. 2. Or have an application salt stored in a PHP file outside your webroot and append the salt to your passwords before passing them to password_hash. 
This is something I've been fighting with recently as well, though for method parameter typing of interfaces. I've combed through Stackoverflow and the most common response is "then don't do that" or "manually check the input/output and throw an exception if it's the wrong type". I think it's really stupid and makes it a lot harder to DRY in certain systems. This requirement also reveals a lot of issues in frameworks that try to make generic classes, which is good and useful, but then being unable to type for the specific classes in specific usages also means my IDE thinks I only have a subset of methods available when in reality it's _always_ the specific implementation in that scenario.
What a great idea and concept. Do you plan on using it in any educational capacity?
Yeah, our dev team does internal tech talks. This is going to be an intro to one of mine on testing. I have a more concrete / decent case to follow up with written against our own code. This was just supposed to be for kicks and giggles and an excuse to watch the r&amp;m segment at the beginning .
Sequel Pro isn't, and it is my personal favorite. 
Lol okay ioncube... Still not interested buddy.
Hijacking slightly... For the non-TransactionalDB noobs, my understanding of ElasticSearch is it's a noSql database with a focus on timeseries data. Why would I use ElasticSearch over say, InfluxDB, or even MongoDB? School me.
There's a lot of things that doctrine isn't going to do for you right off the bat. I've written or helped write a few things that make this easier, however, documentation is essentially non-existent and they're somewhat incomplete. That said, having worked with various active record implementations for some time, even after using Doctrine in a mostly failed project, I began to realize where it excels and why it's better. I'm not going to go into that here cause there are 1,000 articles out there. My two main remaining gripes with doctrine include configuration and/or configuration support. I'm traditionally the type of person who wants to write my DB schema and then have my ORM know how it works. Doctrine does provide a mechanism for reflection, although there's some questions it can't answer on it's own, i.e. should a relationship be bi-direcional with respect to the models. It probably certainly helps to have a framework that pulls in some of the missing pieces and makes config or setup easier. That said, two pieces which were first for me to write: 1. Hydrator to fill models (properly) from request input. https://github.com/imarc/tenet is the source, but again not really well documented and essentially no tests. 2. Code generation which creates base models and the extended (final) models, part of: https://github.com/dotink/inkwell-doctrine You'd probably not want to use these solutions given state of docs and tests, but perhaps finding similar solutions will make your go easier. 
If you even know any other option, you're probably not cPanel's or phpMyAdmin's target market. 
I've recently gone through a similar transition and concluded that the answer to your question, in my particular case is "benefits seen immediately", but I think a lot of this comes down to a question of taste. There's nothing that either can really do that the other can't. Benefits for me thus far have been * The fact that I can model my entities and their behaviours first, and letting the ORM design the DB schema that matches that for me. This fits better with my current mental model - the database is a detail and it has for sometime felt "icky" to me that I have to think about the database first then craft code to match that. Doctrine (if you use the code-first approach) allows me to treat my persistence as a side effect, an implementation detail... which I personally quite like. * The fact that everything is implicitly wrapped in a transaction. My current project deals with a third party system and without boring you with the details, I can't store a record in my own persistence without first knowing that it's going to be stored successfully in the third party system. Because persistence is seperate from the entities I can just withhold calling flush until the communication flows through a try/catch block. Not to say you can't achieve something similar with Eloquent, but having to manually wrap DB calls in transactions adds a lot of noise. * The migrations system seems to be a bit more mature. At the very least, it deals with the fact that whilst production may be running on mysql, my tests run out of SQLite - with Laravel migrations I have to deal with that reality in the migration itself, whereas with Doctrine I can have a set of migrations for mysql, and rely upon the metadata reader to build a set of migrations in my test setup based on current class meta data. It takes care of the inconsistencies between db storage engine implementations. * My entities explicitly state their members. I know if an entity has a given property available because it's right there on the class. With Eloquent, those are looked up magically - what is available to me is a function of the db schema. * I (personally) find the handling of relationships a little more natural. If I have an entity which is related to another entity via a hasMany, I just append the related records to a collection, persist and flush. * Because of the decoupling of the entity from the persistence logic, I can make a choice as to whether or not a test needs to hit a database. When I simply want to check the logic of an entity and not anything else it depends on, I can forego the connection to the database. For a single test this isn't much (in memory SQLite databases are pretty fast after all) but over time it adds up and does give a nice boost to test execution speed. Note I'm not saying you should test everything without hitting a database, or that this is somehow a benefit - I don't believe that is the case, but there are times when I felt with Eloquent that I shouldn't *have* to have a db connection just to check that some function works as expected. Lines of code isn't really a true measure of anything. Yes, Doctrine is more complex. Yes, there is more setup involved and yes you end writing a bit more code. One would expect that over time as a system grows, the difference in lines of code would close up as the more important lines of code, the business logic, would be more or less the same in both cases. The question is whether those extra lines of code give you value. For me they do - I feel the intent is better revealed and that the code is more understandable. But this is a question of taste. If your tastes fall along the same lines as mine then you will probably find the benefits in Doctrine. If they don't then you probably never will. That's fine. Programming is a broad church and there is no "one true way". We all make tradeoffs based in no small part on the approaches that we like. As for what you should be testing - I wouldn't test getters and setters if they are just getting and setting straight values. However, if a setter had some sort of logic beyond simply going $this-&gt;property = $property, then yeah, you could throw some tests around it. I find that getters and setters are covered through objects which collaborate with the entities anyway and only really see value when those getters or setters are doing something a little more tricky. As for "don't just say SRP without giving a code example" (and note, i've not cited SRP as a reason for one over the other here..)... why do you think named patterns and principles exist? They exist to encapsulate things which hundreds if not thousands of developers over time have found to be _broadly_ true, so we can apply them as _guidelines_ to other work precisely so we don't _have_ to show code examples. We all know singletons can cause spooky action at a distance, we shouldn't have to show examples of that every time we want to speak about that case - it's a known quality of the pattern. Likewise, we know that making the choice to violate SRP can cause issues of coupling and make refactoring/reusing/modification more difficult than it would otherwise need to be. We shouldn't have to show examples every time to back this up. There are cases where not following SRP may be entirely appropriate for your use case, but given this is the assertion I would suggest that it is on the person making the assertion to show why it's appropriate, not the other way around. I'm not saying Eloquent is bad because it violates SRP, but spitting back "YOU NEED TO SHOW AN EXAMPLE" when someone points this out as a legitimate concern suggests you're chasing validation for a decision rather than a legitimate conversation. 
Doesn't change the fact that you're exposing your database to outside factors. Keep that shit locked down. Local only connections.
The biggest benefit for me is that data mapper do not make you inherit your model from abstract one. This allows you to use all the good OOP practices to model your domain with plain PHP. For example you have a rule in domain logic "user cannot be created without email". So you can actually make a constructor that takes email and checks it's validity. And test it with unit test. 
&gt; I'd rather we be selective in which declarations we support, to nudge people towards cleaner API design. This. Please this. Turning existing bad ideas into a language feature is the wrong solution. If people want to write sloppy code, the language has supported that just fine for twenty years. 
It makes it easier to attack a single password compared to not having it, yes. Salts are more designed to solve the problem of a bad person getting all of your hashes and reversing all of them in seconds by looking them up in a rainbow table. (This is a gross over-simplification, but accurate enough)
For me phomyadmin was ok and got worse with every version. Now the usability is so bad i never use it anymore. Still makes me sad a bit, i liked it before the ajaxified it. 
Yeay, Sequel Pro is quite good! I use it as a hub for all of my mysql / mariadb servers.
It's been several years since I last liked it for the same reason. Switched to Adminer and haven't looked back.
Finally after all those years! \o/ \o/ \o/ Good work guys, now fix the bloat ;-)
There are remote partners out there who do great work and are awesome partners and save you money as well (Like us :P). But it has to be the right partner. I like to make a difference between outsourcing and remote partners. You can't expect to just hand something off and then in a few weeks get the perfect project back. You wouldn't expect that from an in-house dev. either. You also can't expect, and then be surprised, if the project you handed off to a 15$/hr developer in India, who says "Yes" to everything and likes to disappear once in a while, comes back as a disaster. The way this works best in our experience is if you have a remote partner instead of just outsourcing. Find the right partner, hint: it's not going to be the cheapest dev. on the list, a company/person who cares about your success and recognizes that your success is your collective success and is invested in the partnerships he makes. Look for just common sense, experience, good communication ( to be honest more important then quality code), ask about how they like to work - see if it correlates whit what you want, maybe start with a smaller test project. The way to offset the type of things OP describes , and crucial to the partnership working correctly, is communication. Daily, weekly chats, lots of questions on both sides. Things like Slack, Skype, Hangout, PM tools make this incredibly easy nowadays, but you do have to do it. A good partner is not a "robot" just waiting for something to be handed off. They are involved in more facets of the business if there is possibility for it. Ultimately remote partnerships/outsourcing can definitely work, there are a lot of success stories out there, but it has to be a partnership with the right partner on both sides. 
Sequel Pro FTW
This is not really related to md5. Just fetch the hash and compare it using `hash_equals`. But md5 is still a bad choice.
I was primarily referring to schema generation here. That I don't need to know what columns and tables make up my persistence, I only need to know what my object structure looks like. The metadata is read and diffed against the current schema to generate a migration file which brings the database inline with what the code expects it to be (within limits - if you're moving data from one place to another you'd have to modify the generated migration to deal with that). Interested in some specifics around consistency and durability though - and how that would differ from any other implementation... I'd imagine since everything is rolled up in transactions, consistency should be fairly well guaranteed (at least, as guaranteed as you could expect it to be).
but in order to average you need to have a lot of data, no? I mean you have test the same user+pass combination multiple times to discard the the sleep, right?
Best PHP training in Allahabad Varanasi and noida with Live projects , Documents and Live URL
Relevant https://blog.8thlight.com/uncle-bob/2013/10/01/Dance-You-Imps.html
&gt; You can also just not mutate state (event sourcing, transaction logs and so on No update, just add new stuff) and compute state on demand. Event sourcing has even stricter requirements about serializability of the event stream. While an event itself is immutable, you'll get unpredictable computed entity states if events are added concurrently to the stream without every producer having full visibility (semantically at least, in terms of snapshots) of the events preceding the one being added (unless you specifically model your entities as CRDTs, but that's something else). Plus, once we're talking about event sourcing, ORM's usefulness is highly diminished. You only need a 10-line helper function to do lock-and-insert to the respective event stream. Computing the state becomes an entirely app-specific functionality as well.
&gt; I was primarily referring to schema generation here. That I don't need to know what columns and tables make up my persistence, I only need to know what my object structure looks like. That would be a big impediment to a well performing app once you need to query this data in a specific way, don't you think? Looking up an object by id represents only the most basic of cases in using an ORM. It doesn't match real-world use cases for a database, even through an ORM. And the exact representation of your data in-DB determines how fast or slow it is to read it in specific clusters, and by certain criteria. Doctrine does provide a default mapping, so you don't have to think about the schema, and has some limited flexibility in filtering and transforming the in-DB representation (without altering the resulting object entity), but the most powerful aspect of a true data mapper is to decouple schema and object, not to make rigid default schemas based on an object. Come to think of it, I wonder how schema generation came to be a *thing* for a component called a "mapper". A mapper takes an instance of A and produces an instance of B and vice versa, where ideally A and B are as independent as possible. So a Data Mapper, in its original intent at least, wasn't intended to hide the database, just to decouple DB representation from in-memory representation of an entity, so both can model their data according to their specific needs. As one example, based on what you plan to do, you can model a set of flags as an integer in a bitmap, as JSON, or as a set of BOOL (or TINYINT) columns, among others. You can also model them as a specific string, which you query using text indexing or what have you. A good mapper, IMHO, gives you the tools to choose what that set of flags looks like in PHP, what it looks like in SQL and makes it easy to map between them in queries. &gt; Interested in some specifics around consistency and durability though - and how that would differ from any other implementation... I'd imagine since everything is rolled up in transactions, consistency should be fairly well guaranteed (at least, as guaranteed as you could expect it to be). Transactions in SQL are not absolute. Just to get started, check the four levels of isolation offered by most SQL databases. Note each implements the isolation constraints slightly differently (including with differing semantical results). Now ask yourself where do you choose the isolation level in Doctrine ORM when you do work in a transaction. And if you don't, then you just run on defaults, which don't provide complete isolation. So basically you trust transactions to do something their don't. Once that's clear, consider that ACID doesn't define "Consistency" in absolute terms, in makes some concessions with consistency, even at level SERIALIZABLE, in order to afford better concurrent performance. Sometimes when you add rows to a table whose interpretation is linked to other rows (and this link can't be modeled via foreign keys, as is the case when you use SQL to store event sourcing streams for ex.), the MVCC logic of your ACID database can't take this into account, it has no way of understanding that relationship, so inconsistencies can happen. One way of fixing this is "materializing" the relationship, with advisory locks, or as rows in a table that you can lock and release as you mutate the state of your app. But to do this first you need to know how exactly your database works, and then your ORM or what-have-you should give you enough control so you can take and release locks at this more granular level (and desired isolation level). Doctrine doesn't do this. Its API just has save and load, in a nutshell.
Awesome work!
&gt; you'll get unpredictable computed entity states if events are added concurrently You can make write queue to make it predictable. &gt; Plus, once we're talking about event sourcing, ORM's usefulness is highly diminished. Yep, the question was can we think of concurrency issues as technical detail and skip it when make our domain layer.
&gt; You can make write queue to make it predictable. The problem isn't just writing, but also what is read by the writer. Write decisions often depend on the state that was last read. A hypothetical scenario. You have only "add number" and "subtract number" events, last read state snapshot is 8, you want the value to be 10, so you append event "add 2", but if in the meantime someone else has also read 8 and added 2, concurrently, now you have "12", which is not the intended value. With event sourcing in particular, the ideal scenario is you have a single persistent process which serially mutates the state of a set of entities and produces a linear stream of events, which can then be processed concurrently (in a read-only way) by multiple read-model services (for querying). Once you have multiple writers... it becomes complicated. And given PHP is typically used this way (you have multiple concurrent short-lived PHP environments, each processing one HTTP request), we have a problem. &gt; Yep, the question was can we think of concurrency issues as technical detail and skip it when make our domain layer. Nope. In the case of event sourcing, you basically have no write concurrency at all in most cases. In any other case, concurrency should be approached very, very carefully, or you'll have data consistency issues. Even top-performing high-end systems try to stick to single writer when it comes to event streams, check http://mechanical-sympathy.blogspot.bg/2011/09/single-writer-principle.html The reason why Doctrine, or anything really, can't handle perfect consistency for you automatically is because consistency is specific to your domain logic. Only you, as a designer of an app, know how entities are related to one another (and I don't mean just the pedestrian 1:1 1:N and M:N table relationships). Some relationships are implicit, and neither the DB nor Doctrine have no way of knowing this, unless you explicitly design your schema and queries to "materialize conflicts" via locks, counts, versions, or whatever technique you prefer. Or you can also avoid conflicts by using CRDT, but that's only applicable in limited situations.
Meh. There are a lot of things that can be heavily abused in PHP, but I wouldn't see this as one of them. For example these union types might serve as an actual replacement for operator overloading in a lot of cases, which would be great. Of course this might introduce code smell, but if it allows cleaner public APIs, I'm all for it.
Cron job to walk the DB, retrieve n records; prune DB if file in records does not exist as a set (build a list of PK's), then use WHERE IN condition in delete statement. Backup DB before pruning each day. Honestly don't even worry about files, handle that when in-app a file is deleted.
&gt; CSV Export Allows Arbitrary Command Execution in CSV File This is a *medium* impact vulnerability!?
&gt; decoupling of the entity from the persistence logic If that doesn't seem like a huge instant benefit, I don't know what will...
I also work for a place with a rather weird set of coding style standards and I'm curious about your company's success in getting actual contributions on projects using these standards. It was my assumption that if we wanted to successfully open source libraries we should format them in some well-known way, like PSR2 or PEAR.
i can't agree more with this. 
&gt; Anyway, I'd rather use Carbon and enjoy the extended functionality. If you like your immutable times, consider looking at [Chronos](https://github.com/cakephp/chronos), which is a drop-in replacement for Carbon but uses DateTimeImmutable instead.
I'd wager mounting successfully such an attack (even without rate-limiting) is not in the scope of "possible to do". This is because string comparison timing leaks are extremely hard to exploit because the comparison wouldn't go byte-by-byte, but instead CPU word-by-word on modern hardware (it is a different story on embeded systems and other alike systems). This coupled to the complex nature of database server lookups it gets impractical for attackers operating even on same hardware as the target application is run. I have never heard of such string comparison timing leak attack performed successfully, but that being said, you should take care of it where it matters (ie. use hash_equals when comparing MACs etc.).
haha good catch
it's kind of a non-starter for me because I think annotations are evil.
Great post. I've been using [Jens Seggers' excellent Date library](https://sourceforge.net/projects/ksar/), which is based on Carbon and multilingual. ^**Edit:** ^added ^multilingual
So use php mapping. Or xml mapping. Or yaml mapping. Annotations are entirely optional. 
havent seen the php mapping the rest of those things are also evil.
Sent a message to /u/frozenfire 23 days ago about this and the fix. I guess maybe I should have sent it to the other mods as well :-/ &gt;If you're "MY SUBREDDITS" menu is long it will appear behind the textarea for writing a comment https://i.imgur.com/jW7eT2o.png. A fix for this would be to add z-index of less than 100 to .md-container .md textarea https://i.imgur.com/b0rfz8s.png
z-index: 999999999999999; problem solved
OIC WAT U DID THAR
Honestly, I didn't get too much push back or headaches configuring the ORM with Silex even having never done it before. I'm fairly use to having to "shoehorn" libraries into older frameworks, but the documentation was clear in this area (did get some resistance with SimpleAnnotations) and no "shoehorning" required. I already had the DBAL service provider setup and it was pretty easy to get going after that. The big area for me so far is configuring the entities.
I had no idea that this was a thing.
I'll probably try your framework next with the same project. See what all the fuss is about with ADR.
&gt; Otherwise, their code doesn't work. They will typically be able to just assume sane behavior. I imagine the cases where non-knowledge of exact rules makes their code fail very, very small. &gt; That might be a good thing. /* * @param int|false Position of foo; because stupid internals made unions fail, I now need a docblock. */ function(SomeClass $obj, $pos); Non-enforcable etc. Just like Pythons typehints, in-midst of most types being enforceable... Well, thanks internals?
Thanks for the well thought out response. As far as code-first in terms of not considering the DB schema seems short-sighted. Besides the entities seem to match 1-to-1 with tables, so I don't see the benefit. Maybe I'm missing something. &gt;My entities explicitly state their members. I know if an entity has a given property available because it's right there on the class. With Eloquent, those are looked up magically - what is available to me is a function of the db schema. Fair enough, but nothing a @Property docblock can't fix - though I even stated that was something that I wasn't a huge fan of in Eloquent - until I hand coded every damn property of my database. &gt;Because of the decoupling of the entity from the persistence logic, I can make a choice as to whether or not a test needs to hit a database. Another fair point, but on the other hand you can just modify a line in your PHPUnit.xml, migrate, and you're testing with SQLite. However, after thinking about this point a little more I can see a big benefit in testing here. I'm actually little excited to write some tests where I can just new up an entity, set it's state, and inject where I need to test. That seems nice. &gt;Lines of code isn't really a true measure of anything. It is when it takes me 2-3 times longer to accomplish the same task. &gt;As for "don't just say SRP without giving a code example"... The reason for this was to actually create a discussion - like this one. I haven't been "bitten" by using Eloquent, but I decided to give Doctrine ORM a try for my own experience and to see why it's been considered "better". &gt;I'm not saying Eloquent is bad because it violates SRP, but spitting back "YOU NEED TO SHOW AN EXAMPLE" when someone points this out as a legitimate concern suggests you're chasing validation for a decision rather than a legitimate conversation. Looks like I did help inspire a legitimate conversation :). Honestly, I have nothing to gain endorsing Eloquent, but to be fair - using Doctrine ORM has given me a new appreciation for what's happening behind the scenes of Eloquent. Like I stated before I'm going to keep pushing forward with Doctrine.
I agree - pivot - if I remember my SQL properly is used to turn rows into columns - but it's not a fight I care about. I'd prefer to call it a collection table, a through table, or if everyone understood many-to-many then I would just say "many-to-many" and everyone would understand that's a 3 table relationship. EDIT: Just read your link and looks like I just reiterated it poorly.
Yep, I like to imagine a person sitting in front of `z-index: 1000;` thinking "Yep, that'll do it!" Luckily `!important` isn't stackable, eh?
Surely this is an architectural problem with the way PHP is being used? I Understand there is a problem, PHP can always be improved; but part of being a coder is surely working around such issues by adjusting your thinking and approach? As an example implement data-window returning extension of linked list to 1000 ± 500 items at a time. Also interested to know if this would be the same in a HHVM implementation of PHP
Please demonstrate why sum types are useless without a compiler.
&gt; As far as code-first in terms of not considering the DB schema seems short-sighted. Perhaps my statement was a little flippant - of course you _consider_ the db schema in your mapping information - a @Column(type="string") is going to be a string - and you do retain a fair amount of control as to where it goes, but you don't have to remember the conventions of the ORM for building the table (plural or singular table name? snake_case or UPPERCAPS column names? Don't care, don't *have to care*). The key take-away I think is you are considering the schema in your mapping information, not your object design. ActiveRecord necessarily muddies these waters. &gt; Besides the entities seem to match 1-to-1 with tables, so I don't see the benefit. Maybe I'm missing something. Perhaps you're lucky - but I've had cases before where I've had to create a new table when I really didn't want to in ActiveRecord, just so I could maintain the 1:1 relationship. &gt; Fair enough, but nothing a @Property docblock can't fix Perhaps, but this relies on colleagues adding @Property whenever they make a schema change. I've got colleagues who are kind of lazy about this sort of book keeping. &gt; Another fair point, but on the other hand you can just modify a line in your PHPUnit.xml, migrate, and your testing with SQLite. Well aware of that, and do a similar thing in Doctrine. The point is I can *decide* when I want to involve the database... Another subtle benefit is that because Doctrine has the mapping information to bring a database from nothing to a valid schema in a single shot, you don't see the kind of performance degradation you do when you have to run through 60+ migrations for every single test. Your actual migrations don't get run in testing at all, you just set it up to read off the metadata and generate a schema from that metadata. &gt; It is when it takes me 2-3 times longer to accomplish the same task. But did it take you 2-3 times longer because you were typing more or because you were learning? &gt; Looks like I did help inspire a legitimate conversation :). Yeah sorry about that.... your remark was reminiscent of a flawed argument that seeks to reduce complex problems to 20 line snippets, so that one side of the argument can declare that the other is unnecessary/overly academic/not based in reality. The SRP issue is a genuine problem for some people. For me the lack of separation of the entity and it's persistence mechanism has made solving certain problems difficult. 
To say they should be using interfaces means that interfaces are better than algebraic sum or union types. In my opinion these claims need to be justified just as claiming X is better than Y in general should be justified. I also think if you actually examine the arguments there is clear room for both constructs.
And I thought I was subscribed to too many subs
I'm not sure why you have such a vendetta against this feature because I know you like alglebraic data types in other languages. Are they bad practices? Bob has already demonstrated that weak typing is a mess regardless of unions; the rules for unions are quite simple. So the only remaining point to stand on is unnecessary complexity, which in my opinion is usually just said as a crutch. Let's also keep in mind people are already using union types whether this RFC passes or not. PHP is a dynamically typed language that tracks types at runtime, so people do type inspection and act differently in many cases. Union types is perhaps the most fitting type system proposal that we've added in the last few years. It allows code to be dynamically typed and still retain type safety.
`echo iconv('UTF-8','UTF-8\\IGNORE',"$final");` .. problem with your encoding.
&gt; You say doctrine is a failed project... No I didn't. I said I used doctrine **in a** failed project, and still realized why it preferable to active record implementations. &gt; What about bi directional relations can't doctrine handle? Doctrine handles bi-directional relations just fine, in a sense. What I said was that if you reflect a schema with doctrine, it's not going to know whether or not you want a relationship to be bi-directional. &gt; How must the hydration be "fixed", of how is it broken? Depends on the hydrator you're talking about. Doctrine's hydration from the database is just fine last I checked. &gt; The code in both repos idd look like something I wouldnt want to use. Then don't use it.
It won't be serialization error, not to mention a real app won't compute state from scratch every time, this would scale horribly. Instead it'll be using snapshots of earlier states to build upon, which won't even be in the same table 
Persistence is neither a side effect nor an implementation detail.
ok, but now it doesn't print anything, should I use different function to decode? Oh, do you mean there is the problem because of encoding in python?
Yep, not a fight I'm interested in either, I kinda meant it might have been harder for people to find the right info.
.organic-listing has "z-index: 9999;". Why
... ... doesn't print anything... that is super weird.
Enhancing the list * YouTrack * Bitbucket / GitLab If you know you are working agile, you might want to look at * sprint.ly * yodiz
well it should be executing this sql statement. &gt; SELECT * FROM table WHERE \`id\` = yarda So if yarda means something in your thing then that would be why. That is also a terrible sql statement. 
[removed]
I'm probably going to get downvoted to hell for this, but I still use a query builder specifically because of the mismatch between relational databases and OOP. I've used ORMs and I'm not a fan - they don't fit well with how I work. The best solution, for me anyway, is to just treat the database like another data source, like an API, that has rules about how to get things into and out of it. So I design my projects around required behaviour first, and I have a set of classes whose only job is to interact with one or more database tables according to the logical requirements of that behaviour. That I'm usually the database architect as well is incidental, more or less. Sometimes I'm not. Either way, I find it works out pretty well.
Ask here? https://www.reddit.com/r/mysql/ Please say you're using prepared statements.
Doesn't work if you don't use a Mac. :) But all my coworkers with Macs use it.
I put my hands up, this was a terribly phrased question. It's been answered [here](https://stackoverflow.com/questions/37841101/sql-query-returns-first-row-in-table-when-where-clause-is-false)
&gt; Real world differences between C and C++ code The language likely has nothing to do with it. Long running, repetitive processes are HHVM's strength, as it can JIT the code and optimize the instructions.
I started working on an IMAP library a while ago: https://github.com/mnapoli/imapi I picked up working on it again because I needed it, it's not finished but it works right now. If anyone wants to get involved I'd gladly share the fun of working with IMAP ;)
PHP strings are simple arrays of bytes, they do not store meta info about encoding. "\xc4\x8d\xc4\x99\xc4\x97\xc4\x8d\xc4\x8d\xc4\xaf\xc4\x85" is a sequence of escaped characters (bytes) in hex notation, which if interpreted as utf8, produce čęėččįą. Not sure what the problem is. [edit] oh, and strings in single quotes are not processed, so '\xc4\x8d\xc4\x99\xc4\x97\xc4\x8d\xc4\x8d\xc4\xaf\xc4\x85' will be output exactly as is.
Previous pre-RFC discussion thread: https://www.reddit.com/r/PHP/comments/4m93s1/i_want_to_enhance_and_break_the_reflectiontype/
This is right. You can unescape a variety of ways, but here's a really rough example using `mb_convert_encoding`: $response = "b'\xc4\x8d\xc4\x99\xc4\x97\xc4\x8d\xc4\x8d\xc4\xaf\xc4\x85'"; $babe=str_replace("'","",$response); $final=substr($babe, 1); echo $final; $final = preg_replace_callback('/\\\\u([0-9a-fA-F]{4})/', function ($match) { return mb_convert_encoding(pack('H*', $match[1]), 'UTF-8', 'UCS-2BE'); }, $final); echo $final;
In case it isn't obvious, this is caused by a stack overflow during the destruction of the linked list, which is done recursively.
Wow really ? One would expect an SPL datastucture to implement some proper destructors to handle linkedlist without recursion. Pity really
Same thing happened when I tried to use mb_convert_encoding. I am sorry, I have written this post kind of hard to understand my question, if you could check out this post and give your opinion on it, that would be great: http://stackoverflow.com/questions/37841747/why-doesnt-this-plugin-decode-final 
Is everything set to use UTF-8 globally, maybe: mb_internal_encoding('UTF-8'); mb_http_output('UTF-8'); and then use the multibyte string function equivalents, mb_substr() and possibly mb_str_replace().
The problem is your string is escaped, so you have to unescape it. This might be a little bit of a hack, but escaped UTF-8 is unescaped as part of the JSON decode so this should work too: $str = "b'\xc4\x8d\xc4\x99\xc4\x97\xc4\x8d\xc4\x8d\xc4\xaf\xc4\x85'"; echo json_decode('"'.str_replace("'", '', substr($str, 1)).'"');
Well you would have to inject something INTO the database first...
what is this, /r/css?!
I get what you're saying, but I'd probably just create a different object for that and inject the `Chat $chat` model/entity and the `User $user1, User $user2` objects into the newly composed object. 
It doesn't matter in the end, the browser will sort the numbers for you during composition. z-index: 0; z-index: 10; z-index: 1000; z-index: 9999; z-index: 10000; Would just be z-index: 0; z-index: 1; z-index: 2; z-index: 3; z-index: 4; 
Uncle bob would disagree. 
You forgot to add !important to the end...
You're missing the point, which is that if someone chooses 10,000 then if you want yours to go on top, you have to choose at least 10,001. [this comment](https://www.reddit.com/r/PHP/comments/4o6t5e/rphp_has_a_zindex_problem/d4ae4dq) elsewhere in the thread sums the problem up nicely.
Exactly. It's not a question of whether it works but a matter of maintainability.
Getting the same thing in IE6, win xp
Here is another slim 3 skeleton: https://github.com/akrabat/slim3-skeleton 
Prepare to be amazed! Postgres serializable snapshot isolation really does work how I said. Try it for yourself - use a recent version that actually supports SSI (9.1 or greater, IIRC) and be sure to start the transaction in serializable isolation level (`begin transaction isolation level serializable;` is one way). It's pretty incredible really. An example in the docs that shows how it can seemingly detect inter-row dependencies and capture the semantics of an external app is the black/white example here: https://wiki.postgresql.org/wiki/SSI#Black_and_White The advantage to all this is that you can wrap your app logic in a loop that automatically retries on SQLSTATE 40001 errors, and then pretty much forget about concurrency issues - the DB just handles them all for you^*. Once the transaction succeeds, you can guarantee that there's been no possibility of inconsistency due to concurrency. ^* Terms and conditions apply
And another https://github.com/edhaase/slim-skeleton
Is it 100? 1000? Ohh fuck it: 99999999999999999
Nice. A couple suggestions you might want to check out? **CodeCeption:** For testing. You add tests to test suites, I find it makes it easier to do acceptance testing and organize tests (unit, functional, acceptance, api). **[PsySh](http://psysh.org/):** Interactive repl. Ever use artisan tinker? It's that. And it's awesome. If you haven't, imagine having access to your application state and your doctrine entities from the command line and doing whatever you want with them. It's all kind of fun. **php_codesniffer:** code beautifier, you can combine with the following in your composer.json to add shorthand to PSR-2 formatting your source via `composer cbf`: "scripts": { "cs": "phpcs --standard=PSR2 src/", "cbf": "phpcbf --standard=PSR2 src/" } 
I've worked on projects where I've had to do this, and exactly like you said: I used a random bunch of 9s and sure enough it still wasn't high enough. Ended up having to track down the z-indices individually, and they were all either in the hundreds of thousands or millions. Had to manually write each one into another file so I knew which to replace with a 2, 3, etc.. It was mind-numbingly tedious, as every time I thought I fixed them all, another one would pop up in some single makeshift style. I almost said screw it and dropped the project over it. 
If you were hoping for an article that accurately describes why PHP is not a great language, they are only a google search away. The article is about PHP's reputation and how it can negatively affect ones career.
"you should talk about making chairs and tables but avoid talking about wood"
BRs gotta hue
&gt; There was not a single example or comparison to another language for something that was actually bad in PHP. PHP devs are largely impervious to those anyway.
Netscape here. Many issues. Plzfix.
As much as you may disagree with the article, I lost many many many job opportunities for very interesting projects because more "hip" or "enterprisey" languages are picked, and a different contractor wins on a certain bid, and builds the same crap that an outsourced team would have built. PHP has an awful reputation coming from tools that most of us already know (the typical blogging platform, and its "wonderful" ecosystem). It will take time to get this reputation eradicated: as much as it will take for Micro$oft Windows and OracleDB to become popular among open-source developers. 
&gt; I hope we will get them some day They could just pull https://github.com/nikic/scalar_objects and be done with it :P
Imagick is just a real pain with windows, I was hoping for another solution. Unfortunately I eventually just had to deal with it.
&gt;as much as it will take for Micro$oft Windows and OracleDB to become popular among open-source developers I don't think it will take that much... PHP is OSS, it can change without needing a CEO to shuffle through powerpoint slides in front of shareholders.
I read this as "Sims 3 apps" and got very confused
&gt; but he didn't seem to care :( It's a recruiter so that's no surprise. The only concern they have is to get an ass in the chair and earn that 20-40% commission off the salary.
&gt; And in order to make PHP palatable to the masses and cease this weird reputation, it needs to do some standardization in the library As a beginner I confirm. Cryptic identifiers, messy documentation, quirks, all the tools to install... I want to be proficient with a modern, java-like PHP, but I spend much more time learning PHP than I did with javascript, with less results and more frustration.
I'm in this position right now. We had to chose our next application's languages. Since we have a small dev team, we outsourced. Angularjs front end (written in coffeecript) with a PHP backend (using Laravel). Up to this point I had built so many classes and then one of the outsource devs said "you write straight PHP code? You're a dinosaur!". Luckily, Laravel is fun to learn, but damn it feels like just yesterday when I was interweaving PHP inside of html. Now, it's a whole new ball game. Learn Laravel when you get the chance, but you knowing PHP is an absolutely amazing asset when beginning the framework
&gt; all the tools to install... a) PHP Optional: a) text editor of preference b) an actual httpd (PHP has a built-in web server that's good enough for starters) c) any *real* website will also have a database... but that's true regardless of the programing language. am I missing something?
&gt; any real website Front-end is real work.
I'm not dismissing front end. Front end is a whole different animal. your options: markup language: HTML Programming language: Javascript (or some higher level language that transpiles to javascript) CSS (or SASS/LESS... that gets converted to CSS) Pretty images: SVG, PNG, JPG... and the tools necessary to create em
With 2 points and currently 51% positive votes, I'd like that people don't downvote this blog post only because of the title. The article is an insight about PHP's professional reputation and real-world jobs, which you don't read everyday. Explain if you disagree with his impressions.
Oh, it's not like I wouldn't learn other programming languages (I know a few), it just isn't as simple as switching when your core knowledge is around one. You wouldn't start a project for a client in a new language by having only some theorical knowledge and some experimentation done, wouldn't you? Being hired in a team and being hired as external expert consultant are different things ;-)
Well the author made a point, PHP's reputation is surely a drawback in many case scenarios. Its understandable hes moving on to a new language, not everyone can withstand the low reputation of PHP which can backfire. But, why Golang? To me its the most overhyped language that does not have any practical use cases. I've seen enough of this hype and its starting to get annoying. You will be way better off picking up Java, C#, Python, Ruby, or even stay with PHP, than GoLang. 
Looks like this is a simple matter of a goof in the naming of the API (design by committee problem?) Given this API: http://www.php-fig.org/psr/psr-7/#3-4-psr-http-message-streaminterface Where `isReadable()` checks if the stream is readable, `read(bytes)` reads a portion of the stream, it would seem to imply that `getContents()` should be called `readRemainingContents()` instead. Whether or not those function calls should be idempotent or not is a different technical matter. I'm sure that if you tried to request 400mb worth of data, you wouldn't want that occupying memory in a variable that can be re-read from. *THAT SAID*, the majority of the time you'll be doing simple, small requests, so perhaps the more unusual case of reading large data should have been given a "second class citizen" API like `new StreamRequest()` which then returns a StreamInterface? That way if you know you need to stream the response, you explicitly seek it out.
I've been so excited for this release. It looks really good. Like a smart and thoughtful architecture that is very programmer friendly. The addons section being empty is disappointing. I was expecting too much I guess. 
&gt; To me its the most overhyped language that does not have any practical use cases. What use cases have you tried and why do you think it was not a good fit? Here are some big Go projects: - [Docker](https://github.com/docker/docker) - [etcd](https://github.com/coreos/etcd) - [kubernetes](https://github.com/kubernetes/kubernetes) - [hugo](https://github.com/spf13/hugo) - [grafana](https://github.com/grafana/grafana) - [beego](https://github.com/astaxie/beego) - [echo](https://github.com/labstack/echo) - [gin](https://github.com/gin-gonic/gin) - [prometheus](https://github.com/prometheus/prometheus) - [juju](https://github.com/juju/juju) These are very popular projects that cover a wide range of topics from server management, systems monitoring to web development. There is also a *massive* list of high quality Go projects at [awesome-go](https://github.com/avelino/awesome-go) and on the [official wiki](https://github.com/golang/go/wiki/Projects). Go is hyped for a reason. It is a *huge* breath of fresh air for *a lot* of people who have been using Java, PHP and C#for a long time. A statically linked, strongly typed, compiled language with cheap and fast concurrency? Yes please! It is also stupidly simple to learn, and [extremely minimal](https://golang.org/ref/spec) (you can read the entire spec in a few hours). I strongly recommend trying it, it just might surprise you.
Add [Gogs](https://gogs.io/) to that list. It's a brilliant bit of software.
If you always write the same functions to manipulate a array. Now you can find all this her https://github.com/narrowspark/arr | A collection of utilities to manipulate arrays. Any feedback or suggestions for it are appreciated. Thanks!
Of course I've tried it, and never liked it. And yeah, its hyped for a reason. Not saying it doesnt deserve a bit of excitement from some programmers, but it clearly its way too overhyped. I mean, overhyped, too many people jumping on its bandwagon just because it feels like a cool new little thing to them. And why do those programmers need so-called 'breath of fresh air'? I think this 'fresh air' benefit is totally subjective. I love the C family syntax of Java/C#/PHP/Swift, and even if I want something new I can always go for Smalltalk and Ruby. I honestly, dont see what Go has to offer that cannot be done easily in another language. Does Go have its place in the world of programming language? Yes of course. But does Go deserve this much hype it receives? Nope, not at all. 
Finally someone said it, i many times said on /r/PHP that wordpress is anti-pattern of everything and mostly i got downvoted pretty hard. 
Relevant, because most of their arguments can be transposed to PHP: [Make ruby great again!](http://blog.testdouble.com/posts/2016-05-09-make-ruby-great-again.html).
Thanx!
https://github.com/rairlie/laravel-locking-session I have used this successfully with redis session driver to prevent race conditon on rapid session writes
That doesn't seem too hard, from the report: 1. Log into phpMyAdmin and insert `=cmd|' /C calc'!A0` into a database column value. 2. Export the database in CSV format. 3. Open the exported CSV file that was exported in Windows Excel and click through the warnings. 4. Observe the calculator application now running on the computer
Your information is out of date (please note your slides are from 2002!) Specifically your claim that it won't do predicate locking is wrong - it does exactly that since 9.1. To be clear, I'm not saying "I'm guessing Postgres might behave like this, let's discuss if I'm right", I'm saying "Postgres ABSOLUTELY 100% DOES behave like this". Or, to put it another way, try it yourself: you don't need a complex setup, just a table representing the events and another table representing your snapshots if you so wish - doesn't need realistic data or anything. Run two concurrent SSI transactions that read the current snapshot, insert an event/update the snapshot, then commit. The second one WILL fail, without you having to use any explicit locks. Or alternatively read through the examples [here](https://wiki.postgresql.org/wiki/SSI) - there's no exact equivalent to event sourcing, but the "Deposit Report" example isn't a million miles away.
npz
This is pretty basic question, i'm not sure this should be placed here. You should try at /r/phphelp or at stackoverflow, this reddit is for different purposes. With little googling u will find this example http://stackoverflow.com/questions/2348205/how-to-get-last-key-in-an-array. :)
While I understand the need for PSR-7, it does makes libraries like Guzzle extremely frustrating to work with. Can we just have easy-to-use, straightforward APIs that focus on the most common use cases, please?
The OP is probably trolling based on the fact that we have so many built-in functions but not one to get the last key of an array. end(), followed by a key() is still two function calls and you have to reset() it to seek again or iterate. 
Well, according to: http://php.net/manual/de/function.end.php &gt; echo end(['test', 'test2', 'test3']); will output "test3", the last item. \*edit\* : Oh, he wanted the key.. yes, okey, your answer said everything what was needed, sry :) 
Nice idea the QR code! Thanks!
Raise your hand if you've ever used more than one QR code in your life.
Ehm, I use them, not everyday, but... This is a project I made to make my github "greener". I committed myself to at least 1 commit per day (except on mondays), adding a QR could be a nice addition. I posted here to have feedbacks on the code "quality", mostly, but requests are welcome!
I noticed you named your routes but hard code the paths to them: return $response-&gt;withStatus(302) -&gt;withHeader('Location', '/admin/urls'); Slim can give you a correct path for a route based on its name.
Thanks! I didn't know about this!
All the way down " Looking for a PHP developer for your next project? I'm looking for work! Check out my resume or drop me a line! "
It's mostly used in Asia
Well its not just Tiobe Index that says Golang is not a widely used language, you can find many other similar rankings and almost none of them have Golang at top 10. Here are two more examples: http://pypl.github.io/PYPL.html http://redmonk.com/sogrady/2016/02/19/language-rankings-1-16 http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages And you clearly are not calm because you do not even understand the argument I made. Of course Golang deserves attention, but it doesnt deserve this much attention. Its one thing to be hyped, its another thing to be overhyped. See the difference? 
This made me laugh because I get the same flack when I talk about working on PHP runtimes. "This is C/C++ I'm talking about. I'm growing the damned trees."
I dont know why this is downvoted. I actually agree with ya. Not "knowing" what the function does, putting its result into a variable and THEN using that variable is best practice imo. Like for example if getContents() was actually opening an HTTP connection every time you call it, why would you call it twice to get the same content? But even if it didnt why would you make a FUNCTION call when you already made that call?
I agree that naming a function "get" for "streaming" is weird. But then again putting really strict standards such as PSR-7 opens up a can of worms to misinterpretation and thats what you get, people/lib wanting to follow standards just to slap "PSR-7 compliance" on their lib without really understanding how to implement it properly. Its at PSR-7 that I've stop following / implementing it.
I have no idea where this "I can't get paid to do PHP" idea comes from. I get six-figure jobs thrown at me all the fucking time and I don't even live near a metro area of any significance. You can land jobs with most of the Fortune 500 with PHP skills.
I've been building a site with RC releases over the last 5 weeks or so. It's coming along really well. My only gripes so far are poor documentation and lack of repeater field, but I'm sure those will be resolved soon enough. When I've wanted to do things the CMS can't do (eg submit this form to an outside service), it's been very easy just to write standard Laravel controllers to handle them.
Its very simple, actually - you go through all keys in array, assigning them to one variable, and when loop ends, you will have last key in that variable :)
http://kosinix.github.io/grafika/ - An image manipulation tool for PHP. It has resizeFit, resizeFill, resizeExactHeight, resizeExactWidth, resizeExact, overlay, and many more. My latest addition to the API was dithering.
iirc its pathFor on the router object.
PSR7 should be discarded by the PHP community. It is the brainchild of a few people who wanted it for their own pet projects (Guzzle, AWS) whilst not considering the rest of the community.
shit talkers, shit talkers everywhere
Glad this is getting shot down. I have yet to see anyone demonstrate a use of union types that wasn't a gross design flaw. "People already do it" is such a cop out, and tries to sidestep the issue. Whether people do it or not, we don't want to codify bad practice just to make it easier.
Well, you can always reverse the array first, and then stop the loop after first iteration! ;) Edit: Imho, I've found out even more funnier response - just take count(array) - 1 and you got it! (He didn't asked about ordered map...)
I lived in Southeast Asia most of my adult life and never saw anyone using one. But maybe in Japan or something.
Don't forget about Bower and Grunt for dependency management on the front-end.
what's with the `:=` assignments?
After several attempts and hours of reading about different frameworks, I have yet again reached the point where I feel overwhelmed. This has happened multiple times already, but this time I really feel determined to learn this thing. I would consider myself a novice php person, but I was planning to create a personal portfolio site and connect everything neatly with a database. What kind of (maybe lightweight?) framework would you recommend to me? I appreciate any pointers!
PHP is going to be COBOL at some point. The 20 devs who can still do it get boatloads of cash to work on legacy applications.
&gt; If HTTPlug offered me a way to avoid having to depend on any specific PSR-7 package, it would be useful. Could you be please expand more on this ?
I don't have experience with it, but [Tracy](https://github.com/nette/tracy) looks nice
It's a typical mistake, but expecting a method prefixed with `get` to be idempotent doesn't seem to be a stretch.
This is why almost everyone uses the convention `$body = (string) $response-&gt;getBody()` to get the body content as a string. The `__toString` method always rewinds the stream.
Facing the same situation, when talking with teams about languages stack. The trend to criticize PHP seems to be dying at last, but the language reputation is improving very slow. My 5 cents (who is not familiar: I'm the author of Php Inspections (EA Extended)) are also aiming to bring PHP into Enterprise faster. I guess thing will turn better as generation of Best Practice/PhpStorm/SCA Tools developers terns into PMs and so on. At the end lot of those guys are using both Java and PHP, but reasonably: not "hip" or "enterprisey" like-judging =)
What are arguments for using stdClass vs assoc arrays for pushing / returning records to / from a database? I just bumped into this. I always prefer assoc arrays over stdClass, but this component I'm looking at using is doing everything with stdClass. So I figures, maybe there's a good reason. Why I like assoc arrays? a) I can iterate over entries (without reflection), b) when creating them I prefer writing this $a = ['something' =&gt; 'a', 'foo' =&gt; 'bar']; over $o = new stdClass(); $o-&gt;something = 'a'; $o-&gt;foo = 'bar'; What are `stdClass`s redeeming qualities?
If it's not an associative array, I usually do something cheesy like: $last_key = count($ary) - 1;
I see that you've done a good job reading the title of the post.
For my the choice was between Golang, Swift and Rust. Clearly given the list you stated you are more leaning towards traditional languages. I think a more modern language, even if it's 'hyped' can quickly lead to bigger innovations, it's easier to attack and influence the status quo and there's actually good career reasons to go with something a little bit more modern. In my next company I'll also be in charge of hiring, and hiring for a less established language is actually a bit easier, because most of your candidates will have learned the language because they think it's cool, not because it just happened to be part of their curriculum.
What's the difference between an assumption and a convention? 
Yeah, the question is how to do that... Or more precisely, how to do that efficiently, i.e. without impact on the common cases where you do not happen to be destroying an object with nesting levels in the tens of thousands. 
I'm curious: what happens when the stream cannot be rewound?
Except I have to use it everyday. So I do understand.
I worry about this and I've been working with PHP since 2001. Every time I search for PHP frameworks I get too many results and it comes down to whatever I pick is wrong because of reason X or Y. My last search was laravel vs zf2. I picked zf2 and have been content with it. I've been able to bend it to my will for things like nested REST routes. I might have been easier in laravel but it's too late now. I'm really curious if it's time to give this up and move over to node development. One language from front to back would be nice. 
The trouble is that PHP is easy to use while COBOL is certainly not
I'll get it out of the way. Maybe I'm just a shit-level developer. I believe what you say is true in that you actually do that. What I don't believe is that the "language doesn't matter". Every job I've seen has been for "Senior X Developer" or "five years doing programming in Y". There is no way I'm going get a job where I live (US, middle) without stating and knowing at least one language very well. More specifically, if they're hiring for X language - and I've never used - I won't be getting a call for an interview. But that's just finding a job. Doing a job is different. Doing a job well is different from that. I'm sure most programmers can probably get a ```Hello world``` up and running in most languages. That doesn't mean they will be effective on a project. Even within the same language you can have completely different workflows, tools, methodologies, etc depending on what the project is, what framework you're using, or what CMS. You're not the only one to say that. Matter of fact, developers love to say it. It's just that I really have never seen it in practice. Somebody hop over to a new language and be as effective as somebody that has been doing it for five years. I'm not saying you should stick to one language or anything like that. Developers should branch out. What I am saying is that I think people overstate how effective they are. 
Maybe you should ask Golemon.
I see the last commit date for PHP DebugBar was 5 days ago, so it does seem to have some support. Here are some other options to peruse: https://php.libhunt.com/categories/375-debugging-and-profiling
which is cool when you are a customer, but definitively not when you are the one **making and selling** chairs and tables.
Pretty much why my last statement was breaking backwards compatibility and fixing all the shit in core.
If you can live with tons of backwards breaks, why not keep PHP backwards compatible and switch to a language that does have the things you need? PHP is PHP, it's easier to just work with the language you want than to hope that PHP becomes it. There's plenty of options out there.
It won't work, cause in php we don't have arrays, we have ordered maps. $test = ['a', 'b', 'c']; unset($test[1]); var_dump($test); // array(2) { [0]=&gt; string(1) "a" [2]=&gt; string(1) "c" } echo count($test) - 1; // 1 echo $test[count($test) - 1]; It won't give you correct result, cause index "1" have disappeared and value 'c' still sits under '2'.
Sorry guys, but we can't do the news right now since our server is doing the windows 10 update.
You can iterate over entries in classes too. $obj = new stdClass(); $obj-&gt;prop1 = "Hello"; $obj-&gt;something = "Else"; foreach ($obj as $key =&gt; $val) { var_dump($key, $val); } Also not necessarily for `stdClass` but a lot of times when people fetch into classes/objects, they do it into a class definition such as using PDO's FETCH_CLASS or similar. In this case it then attaches additional methods and behaviors to a record you fetch. I'm not the king of good programming examples, but I just say you fetched a user from the DB, and you fetched it into some User class. This class could then have a `isUserPriviledged`method that says if it is in a certain role/group. You'd fetch the data with the roles in it, but the class it was fetched into could have the logic attached and necessary to get your answer. Rather than hand rolling logic checks for types of business/domain constraints on raw arrays. Just my 2 cents. But I feel that stdObject and beyond are similarly easy to use as associative arrays for iteration and access (but have the cons of not being usable via array_sum() and other array methods) as well as giving you a good place to put your logic and expectations when you load data. (Not good for all types of data, but for entities and models I think it is handy)
You are welcome, and thank you for using it )
Isn't it pretty trivial to re-index an array after an unset? Sure it requires you to remember to re-index, which may be less than ideal, but assuming you remember then the count - 1 should still work.
&gt; Every job I've seen has been for "Senior X Developer" or "five years doing programming in Y". Yes, they all want senior x developer and something extra which most of the times is a different field. They want a backend guy/girl which can also do frontend; a frontend guy/girl who _dreams_ DB administration; a DB admin who can do some network administration and a designer who knows the same X as the backend guy, because the backend guy is busy with the frontend part, naturally.
You're gonna get hacked, mate. 
Unfortunately, that is very common. But even the company I work for - a software development firm - I was specifically hired for my experience in a specific language and platform. Once hired we have paths to work on anything but we hired for a specific need.
You could use "presenters". The League of Extraordinary Packages has a package for that called Fractal. Although I never used it, I see a lot of people talking about it.
I'm pretty sure I called it a cheesy solution from the start - I also specified that it wouldn't work for associative arrays. At no point did I claim it was an optimal solution, but for simple scenarios it can work just fine. For more complex scenarios, sure, use whatever you deem to be the best approach.
hunter2
[removed]
if it's blank it means it works i think :)
&gt; As much as you may disagree with the article, I lost many many many job opportunities for very interesting projects because more "hip" or "enterprisey" languages are picked, and a different contractor wins on a certain bid, and builds the same crap that an outsourced team would have built. Don't think it has to do w/ social approval, but rather the jobs he's after people look down on PHP.
lets put it into a chef analogy. would you hire a chef who doesn't differentiate between fresh and dry meat? Because thats what the recruiter is doing with his "don't talk about meat, tell me about steaks" non sense. 
"ohh yes I have a very cool tool for php that works exactly like ruby on rails but doesn't need to know ruby to do it" and give them yii2. if i ever get a customer to ask me for node js i will tell them the same and give them slim framework.
[removed]
Hilarious. 
&gt; In the end, for certain things PHP rocks, but for some does not.
&gt; Even with a farm of 1000 gtx 1080's it'll take a while Well, you're doing a single round of MD5. With a farm of 25 GPUs (10 7970, 4 5970 - dual gpu, 3 6990 - dual gpu, and 1 5870) we can do about 180 billion hashes per second. With a farm of 128 GPUs (the max for the architecture without hitting bottlenecks), we'd expect approximately 921 billion hashes per second. Now, what does that mean? Well, it means we could brute-force the entire English language in 0.000001 seconds. (approximately 1 million combinations). The working English language (approximately 20,000 combinations) is trivial. All case-sensitive permutations of English would take approximately 0.00005 seconds. We could brute-force all 6-character passwords in 0.8 seconds (including the 95 printable ascii characters). All 7 character passwords in 75 seconds All 8 character passwords in 2 hours. So yeah... No... Plenty fast enough to be practical for a large subset of passwords (look at the brute-forced linkedin data that was released last month)...
[removed]
GrahamCampbell does have the ability to accept/reject PR's on a good number of high profile projects, first and foremost being Laravel. Altho I think in practice he doesn't do it a whole lot.
[removed]
We should all made reddit threads when we have an argument on the internet with 1 other individual in another forum. /s Also isn't this just a "isn't person X stupid?" thread? Seems like this is against the subreddit FAQ rules, if not reddiquette in general. Plus a plain shitty thing to do. As the reply in the thread later showed, it looks like you were the jerk here in assuming it wasn't just a simple misunderstanding.
This sums up pretty much the language debate. 
z-index: 2147483647; FTW!
That's pretty much what Hack is, isn't? 
In a way yes. The difference being not syntax changes, just internal bugs that exist for BC are eliminated.
&gt; Though a cracker wont find a usable collision for no less than 1 week for any password, I guarantee it. That is, without a doubt, a silly security guarantee. 1 week is nothing in terms of offline password attacks. $2y$17$N/cPZewI.7lYQ4fx63PN0.nhD.84tifhiPYWWT70vLci9J.ErmGHW That's a bcrypt hash of a phrase of 11 English words. Even knowing that fact, that phrase will be secure in that bcrypt for at least a decade, roughly. 1 week is literally nothing. Also a collision basically means "this will hash to the same result", which means "I can use this to log into the service the hash came from", which usually means "this is the user's password". That's only not true in VERY rare cases, but IIRC there's not yet been a small-input (100 chars or less) collision in md5. Which does mean that once you use your 921 billion hashes a second farm to get a collision, you've found the users password. Game over.
I think an exception is thrown.
&gt; Though a cracker wont find a usable collision for no less than 1 week On every single hash? You're right. They don't need to though. They only need to find weak passwords. Which with `md5` will fall in seconds. Which also make up about 15% of your total userbase on average. Linkedin's recent exposure showed that we can expect approximately 60% of accounts to use "crackable" strength passwords, meaning 7-8 characters, symbols, etc or based on English words. A strong password won't be "cracked" in any scheme. Your salt strategy doesn't protect them in the slightest. The weakest passwords will always fall (your top 100 passwords for example). The hashing strategy you choose will affect only the middle range (not strong, not stupid weak). And that accounts for about 60% of accounts. So yes, it will find usable results in very short time.
Whoooo! **ANGRY AT [GrahamCampbell](https://github.com/guzzle/guzzle/pull/1493)?** WANT TO JOIN THE MOB? *I'VE GOT YOU COVERED!* #**COME ON DOWN TO /r/pitchforkemporium** **I GOT 'EM ALL!** Traditional|Left Handed|Fancy :-:|:-:|:-: ---E|Ǝ---|---{ **I EVEN HAVE DISCOUNTED CLEARANCE FORKS!** 33% off!|66% off!|Manufacturer's Defect! :-:|:-:|:-: ---F|---L|---e **NEW IN STOCK. DIRECTLY FROM LIECHTENSTEIN.** ***EUROPEAN MODELS!*** The Euro|The Pound|The Lira :-:|:-:|:-: ---€|---£|---₤ #**HAPPY LYNCHING!** ^(* *some assembly required*)
I don't think this is as clear-cut as you make out, gs-dev. Your initial comment was rather brief, and GC responded in kind, so perhaps you both made an error at this point already (insufficient detail can derail a valuable bug report - if the purpose of your post was to fix something in Scrutinizer CI, why not say that at the start?). Your second post was much better, and very informative, though `refusing` might strike a stranger as hostile or accusatory, so your interlocutor may have switched off a bit. Your third post was too demanding - insisting that maintainers answer your enumerated questions may seem like a rant. You misused the word `literally` as an intensifier too, which is a common error of the lesser-spotted internet ranter. In your fourth message, you started shouting, using emboldened text. After GC apologised to you, you implied he is stupid and suggested he's on an ego trip - and you called _him_ aggressive? I don't meant to be hostile to you in turn - this is just meant as even-handed third-party feedback. You had a miscommunication on the internet - it happens to us all, and we should try to deal with it. It isn't ideal for you then to turn up to Reddit and link to the post - is your intention that we all ridicule the person who misunderstood you? 
[removed]
Nobody knows if AJAX will require a rewrite at this point, but as long as the code is separated well and you have a router or method of dealing with AJAX requests, then there is no reason your page should need to update. Please do be careful and include a button with confirmation for updates. I know it seems like a buzz-kill or time-eater, but if you hook AJAX changes to blur, change etc events, you can find that undoing damage is a complete PITA. It's also a good idea to backup the database at regular intervals, and work-on non-live so that any unwanted changes don't kill anything you need or want.
It looks great in fact, pretty simple and straigh forward. I had the same kind of problem and I found this cool and light framework: https://github.com/bcosca/fatfree (I used it for complex and minimal stuff), take a look, it may help you one day if you don't have time to extend on BareBones. 
I can't imagine a more straightforward diff to review on a PR than this. It's a pretty accepted practice that if you're going to use the exact same name as a builtin, take the same arguments. They've literally just defined it as a "Wrapper for JSON encoding that throws when an error occurs.". It would be pretty bizarre if it included any type hints/arg validation that didn't accept a non-string. Stranger still that someone would resist simply updating the doc so that it's in-line with how they've already described the function.
If you really don't want to re-write everything this will work, but is not optimal. Ajax load can load a portion of a page. After your URL put a space and then the id of the div (or whatever container) you are in. $( "#the-div-you-are-in" ).load( "the-page-you-are-on.html the-div-you-are-in" ); 
[removed]
I wish people wouldn't come to Reddit to get people lynched on Github.
But why do that when you could do this? I don't want a full Laravel installation in a sub-directory, because I'm not using 99.99% of the meat. I would also have to write a .htaccess file every-time, which is not that bad but is rather annoying. This is built specifically to do exactly what I want, with no unnecessary meat. And I don't want the SPA and back-end in different directories. I want the back-end to live INSIDE the client-application.
Yea so basically you're saying, I want to use something that's not like PHP and is also not called PHP. What am I missing? ;)
Wasn't the original comment a PR with an exact reference to the code changed?
[removed]
If only we had software capable of tracking changes to text... 
&gt; If ####### took an extra 10 seconds in his response to act like a human In my view making errors is an almost entirely biological endeavour and is the true thing humans perform well at! We wil all inevitably make mistakes and compound them. In any case instead of hinting, perhaps an email or PM to say "I understand we are both frustrated, here is..." then the information that was later disclosed; or just immediately come back with it. I've also been told I can be rude, it's something I'm working on; I can sometimes feel like others are being rude, or dismissive, we probably all accidentally can be. I'll immediately call it out and then try to explain my point, not drag it out, then attack a person, rather than a technical fault. 
I stand by my point. If you're comfortable with tons of BC breaks, and a new name... you might be just as comfortable finding a language that's already better =) Many languages have a similar syntax and the same functionality.
Did you really just vouch against fixing bugs in the core? That's kind of rich.
So he misread the PR and thought it said json_decode. Shit happens - get over it.
Reminds me of one of my first ever PRs to an open source project: https://github.com/laravel/docs/pull/2131
But I'm not. Fixing the bugs in the core would incur a BC break, which would equate to a major version bump. Let's just speculate, that if a PHP 8 came out, and they rebranded the name, it would be a perfect opportunity to squash bugs in the core that they refuse to fix because of BC. I don't find that particularly unreasonable. You're entire gist of, "just use a different language" seems extremely odd, and albeit, shortsighted.
But then they can release a new version where they change logic/remove these private variables, but your code still works.
It looks like your comments here are falling on OP's deaf ears, but for what it's worth, I read everything here very carefully. I just spent a week building a new authentication and rbac chunk for my current project and I want to be damn sure I get it right. 
Might as well add my most used functions: function pre($var) { echo "&lt;pre&gt;"; print_r($var); echo "&lt;/pre&gt;"; } as well as function pred($var) { pre($var); die; } as well as function br() { echo "&lt;br&gt;"; } as well as function hr() { echo "&lt;hr&gt;"; } I guess you get the concept.
You can go from private to protected very easily if the need arrises. You cannot go from protected to private.
Interesting....
Or use xdebug. Seriously 99% of times you need to output for debugging can be avoided by setting a breakpoint. (I made up the 99% but you get the idea) 
You could use Symfony web profiler. There is almost no doc about it, but that's doable and has been done in Silex for example.
Impossible. Hardware isn't at that point yet!
It's great, but alienates a big part of the community relying on HttpFoundation, forcing people to choose one over another. And realistically, if I'm primary using Laravel, Symfony or Drupal, I will make it HttpFoundation compliant, not PSR-7. 
I started by doing a direct port of the reference code from [the official implementation](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c). Then applied some of the structural changes from [PHPs implementation](https://github.com/php/php-src/blob/f83a586d55deef93cc0b8aafc4592edeea1737a4/ext/standard/rand.c). The only real challenge here was the fact I only had 32 bit signed integers to do the multiplication with (the algorithm uses unsigned). I used [a reduced version of Knuth's Algorithm M](http://www.hackersdelight.org/hdcodetxt/mulmnu.c.txt) to overcome this. Since I knew I was only operating on two lots of 16 bits I was able to unroll the loops there. Finally I just had to make sure appropriate masking was in place so that left shifts produced the same result on 32 and 64 bit platforms.
I use [https://github.com/Bacon/BaconQrCode](https://github.com/Bacon/BaconQrCode)
Symfony - An Open Source Framework With Many Benefits Laravel - An Open Source Framework With Many Benefits Codeigniter - An Open Source Framework With Many Benefits PHPixe - An Open Source Framework With No Benefits Yii - An Open Source Framework With Many Benefits 
(Just as a sidenote) Passphrase consisting of 11 English words will probably have such a high guessing entropy that, frankly, it would be all good on single iteration MD5 scheme (the extremely high bcrypt cost setting is kind of wasted, and will probably take way too long to run at least on public internet facing system ;) As u/ircmaxell said, you can't save leaked poor passwords no matter what scheme/setting you use.
Agreed. I reported the post as rule-breaking, and it has now been deleted, so I assume the mods agreed. This sub is intended to have a minimum level of professionalism. 
&gt; As u/ircmaxell said, you can't save leaked poor passwords no matter what scheme/setting you use. You slightly _can_. If you make guesses expensive, then the attacker has to do more work to recover them (this is why bcrypt/scryt/argon2 have costs). MD5 has a wonderful problem, as such, in that you can work the endstate (the hash you're trying to match) backwards on the last few iterations of the hashing. Then you can exit early if you're not creating anything that doesn't cause you to match that endstate. This means that an attacker has to do *less work* to verify if a test word matches an MD5 hash than the person hashing the original word. (This is one of the reason why oclHashcat is so fast on MD5). If you make it too expensive to make guesses, then 8 or 9 characters stays strong enough, but not forever. &gt; Passphrase consisting of 11 English words will probably have such a high guessing entropy that, frankly, it would be all good on single iteration MD5 scheme Herp, you're right, even using the 10k most common words, at 921 billion guesses a second it's still 2.4 times the age of the universe. If only all users had such good passwords. &gt; the extremely high bcrypt cost setting is kind of wasted, and will probably take way too long to run at least on public internet facing system We actually use that cost on a login system. The user gets a 3s wait. It's seen as perfectly acceptable considering a) the security requirement and b) the low login traffic. (And yes, there's limits in place to stop a DDoS on that system) 
I'd like to assemble my own. Do you sell four candles? 
it's basic...
I see what you did there XD
I wonder if you can actually articulate your point, or are you just jumping on the bandwagon to make some fun?
Also, you do realize that all that "proof" hinges ona lot of ifs. I just don't feel like resurrecting the issue again.
&gt; Doing so, in general, would buy extra security margin, as the auth server (and the user database) would be unreadable from the app server (auth server only accepts username+password pairs and replies accordingly). The auth server doesn't have the database and the database server doesn't have access to the auth server (i.e. compromise of one doesn't mean compromise of all). The auth server and app server are separate, and only the auth server contains the encryption key to the password field, where high-cost bcrypt hashes are stored. (i.e. we take a user password, hash it in bcrypt with the cost of 17, then we encrypt that result with a key only the auth server has, and store that result in the table). If, somehow, you got the users table, and only the users table, you'd be unable to even decrypt them to get _hashes_, and that's before you're prodding a bcrypt cost of 17. Defense in Depth concept. Each layer holds on its own, each layer contributes to the overall security level.
The motivation does not really make sense to be honest. Why is it so important for you to run on shared hosts? and even if you use shared hosts you can make other frameworks work under a subfolder. I'm not saying your framework is bad. But now you have to mantain it, and you won't benefit from improvements in other frameworks, you could have tried Silex or Lumen if you think Laravel is too fat. Good choice using a common ORM and Template Engine. And IMHO bad choice creating own router. What makes your routes so special?
PHP &gt;= 5.4 This should be at least 5.6. 
HttpFoundation is Symfony specific and predates PSR-7 by years. Http Messages will eventually replace it. Symfony is already planning for that. You don't have to choose one over the other because there is a PSR-7 bridge for HttpFoundation. PSR-7 is the right choice for anything new.
Personal taste is less important than standards. That's why we have psr-2 and 4.
They were still fake usage stats mate. Just because it didn't become painfully obvious til there was a huge amount of it doesn't change anything.
Thanks for the reply. Always inspiring to discuss this kind of topics. In addition to that (besides HSM or alike separate machine), to add one more defensive layer, I don't see other than moving the user credential database to a physically separate location which is accessed via [spiped](http://www.tarsnap.com/spiped.html) from the auth server. But the more layers you add, the more complicated it starts to get (which is something a secure design should avoid).
Personal taste is one of the main reasons for making a standard
bizarre
&gt; But the more layers you add, the more complicated it starts to get (which is something a secure design should avoid). This is why we stopped where we did: 1. If you steal just the database, you have no password hashes to attack 2. If you steal the database and the encryption key, you have bcrypt with a cost of 17 to contend with. 3. Passwords have a high complexity and length requirements, are valid for 3 months, and can't be the same as 4 previous passwords (so yeah, successfully changing your password needs a minimum of 12 seconds worth of bcrypt going on). Those combined are generally enough security for the passwords. There's other things in play (encrypted server-to-server comms, firewalls, IDS's, logging and notifications and whatnot) but they're not in the scope of this.
&gt; if Symfony puts such obstacles in accomplishing so simple tasks as validating input It doesn't. You absolutely don't need this bundle to accomplish what this author did. Using symfony, all you have to do to accomplish this is create a form. This post's author has no idea of how to use forms and how to bind a request to its form, so he's doing everything manually. He's 100% wrong on his idea of a form. &gt;First of all, Symfony forms are design to actually generate HTML form. No, they are not. &gt; Why would you create a form object (using a factory) when you already have a form on the front app? To accomplish exactly what he tried to accomplish with this bundle, but in an easier native way. &gt; Form validation is great when you need to actually show (html way) errors. If your goal is to send an error message to your frontend app… well… that’s not the purpose. What? Where is that coming from? Symfony forms are NOT about HTML. Actually, the `symfony/form` component doesn't even have any information about HTML. It's the TWIG bundle (which was removed on 2.8 from the default symfony application) that has information on how to render those forms using HTML. Symfony is a 100% backend framework, with no concepts such as HTML rendering, widgets or whatever. There are optional or third-party bundles to help with it (like the twig-bundle, assetic-bundle, etc), but it's completely agnostic as to what you are returning. The main purpose of `symfony/form` is to hydrate entities using request objects and validation. Also, his structure is weird. `user_address` should not exist, but `address` should have a `user_id`. This is not a m-m relationship, but a 1-m. Unless there are many users with the same address and somehow changing one's address should also change the other's. 
&gt; Another observation is... I'm not a Symfony user, but if Symfony puts such obstacles in accomplishing so simple tasks as validating input, why do people put up with it at all? It doesn't put such obstacles - OP is creating these obstacles. This article is not entirely accurate. Like: &gt; First of all, Symfony forms are design to actually generate HTML form. This is absolutely not true. Form objects have nothing to do with HTML. However, with Twig functions and such you are able to render a Form object as an HTML view. That *does not* mean that Form objects are coupled to HTML forms. You can definitely just use a form factory to create your REST form and use proper Symfony validation on it. I do it all the time. &gt; Why would you create a form object (using a factory) when you already have a form on the front app? If your frontend form is being created by Symfony, then why not just re-use it in the processing step in the REST call? If it is not being created by Symfony, then see my first point. &gt; Form validation is great when you need to actually show (html way) errors. If your goal is to send an error message to your frontend app… well… that’s not the purpose. Wrong again. Form validation can be caught and processed without ever sending HTML. HTML is completely separate from this process. You can, for example, represent the form errors with a JSON string and return that from your RESTful service to the client. Also, since he's using Doctrine, he doesn't need to be creating a third UserAddress entity. He can simply use Doctrine's association mappings to do that from the User and Address entities. This makes validation and form handling easier. Symfony actually has a very powerful input validation system, if you utilize it properly. 
&gt; But the more layers you add, the more complicated it starts to get (which is something a secure design should avoid). That, and there's operational overhead. Many sites simply don't have the sophisticated infrastructure team required to implement this sort of scheme. If you do, most definitely, really interesting concept.
Hi, great functions. can you provide a sample usage code for TempStreamIterator? 
And how would it access validator service? Implementing validation inside constructor is huge violation of SRP. When you want to validate email again in a form, do you copy paste the code? Unless you're using some global functions, this is a bad example.
It now has a warning "This script was stopped while abusing our resources"
Not sure if this is supposed to be a joke, but it makes no sense. The whole point of the PSRs is to have a common API. In other words, PSR-7 is supposed to wrap the library, not the other way around. 
hahahaha
"Fun" fact Crystal Reports also uses `:=` syntax.
As I saw the problem with symfony is that you have only two options - use whole component as it is, or don't use it at all, because its not possible to change only one piece... And that sucks.
Anything particular in mind? You can use with arrays, Iterators, Generators, anything you can foreach over this can load into temporary storage, memory or disk, depending on the limit you set, and you can foreach over the results. [Here](http://pastebin.com/NSfHy7xA) is some half php half psedo code of how you might use this to cache a large sql resultset without exploding your memory or holding the connection open. But you could store most anything in there.
PSR 7 allows you to use any of compliant library in the same way via the same API. That does not mean it is a clean API. There are cleaner ways to do (simple) tasks, such as get the response from a BASIC AUTH get call. If there was a clean wrapper around any PSR 7 compliant client, to me that would be useful. This still allows the benefits of the PSR to be there, since any client library would work with it, if it was compliant.
It appears that framework cut out a few organs while trying to trim the fat.
The string cast would call `__toString()` and you cannot throw an exception in `__toString()`.
Something like [this?](https://laravel.com/docs/5.2/controllers#dependency-injection-and-controllers).
One of my big gripes with PHP is its half-way-in-the-water style of OOP. Let's say you want to create an array and add a value via push. C# has a List&lt;T&gt; which behaves like PHP array: List&lt;string&gt; myArray = new List&lt;string&gt;(); myArray.Add("super cool value"); JS has an array that behaves like PHP array: var myArray = []; myArray.push("super cool value"); Then PHP, despite declaring an array, makes you do this FP pattern: $myArray = array(); array_push($myArray, "super cool value"); It's not a huge deal or anything, but I'd much prefer if PHP's array functions were exposed as methods of the array object, instead of as exterior functions.
For me, RESTful just reads well when I'm looking it over instead of working.
The day I consider using code from phpclasses is the day I should consider switching careers. 
I've spent most of my professional career writing in PHP, but I've always dabbled in other languages. About a year ago, I accepted a position in a NodeJS shop. I've always been good at Javascript, and it didn't take a terribly long time to get up to speed on Node (days to get reasonably proficient, a coupe of weeks to do almost anything i wanted). I ran into two major problems: 1) The other devs acted like I was a moron whenever I asked a question, presumably because they knew my background was primarily PHP. This made me reluctant to ask further questions and soured my attitude toward the language and other devs. There's a lot of stigma out there about PHP, and it's pretty frustrating when you know how good of a language PHP can be, and other people just don't get it. 2) The paradigm for Node is completely different than PHP, mostly because of Promises and async. I spent a lot of time writing code similarly to the way I'd do it in PHP, only to realize that it wouldn't really work because of promisees or whatever. It took a month or two before I started thinking in terms of The Node Way^TM and stopped trying to do things the way I'd do them in PHP. (On the flip side, because of my PHP background, I had a lot of good ideas for different ways to do things that the other devs would never have thought of. So there's that.) I personally think the async paradigm that Node uses causes more problems than it solves. Generally speaking, you only want *some* things to be asynchronous, but most things you want to happen in A-B-C order. But with Node, you pretty much have to treat everything as if it were asynchronous. And then it's all single-threaded anyway, so it's not really.... meh, it's just overly complicating an already complex problem, imo. Quick example of what I'm talking about: PHP $results = file_get_contents("http://www.google.com"); var_dump($results); Node return q.all(function() { return http.request('http://www.google.com'); }) .then(function (results) { console.log(results); }); And 99% of your code is `.all().then().then().each().map().tap().then()`, and I just think it's a little ridiculous because you're back to being verbose about synchronicity, when it should be the other way around. (I'm exaggerating, but only a little bit.) Also, NPM is somewhat of a clusterfuck, imo, compared to Composer. Anyway, I spent about 6 months at the company. I didn't like Node at all, but I wound up leaving for other reasons. I consider the whole thing a learning experience, and I'm definitely a better programmer now than I was before, especially when it comes to Node/Javascript in general. What I'd really like to do next is immerse myself in another language like Go or Rust and build some really cool apps with those languages. Unfortunately, it really does take immersion to master a new language, and I just don't have the time these days to do it.
Correct, in which case an empty string is returned: https://github.com/guzzle/psr7/blob/master/src/Stream.php#L90-L98
Thanks for sharing!
Attempted to move to Node. After a few gruelling months, came back to PHP. Attempted to move to Python after that. After a smattering projects with decent success, came back to PHP. Looked at Ruby, installed Rails, deleted the folder and came back to PHP. Tried Java with Spring, gruelling months later, deleted it all and came back to PHP and rewrote those projects in hours to the weeks it was taking me. Throughout I've also tried to be some kind of game developer. Attempted C++ like 5 separate times, stopped and came back to web dev with PHP. Attempted C like 3 separate times, liked it, but stopped and came back to web dev with PHP Attempted D in two different projects, liked it but stopped and came back to web dev with PHP. Also tried to be a scripter in games Attempted Lua, liked it, but stopped and came back to web dev with PHP. Attempted SquirrelCode, was ok, but stopped and came back to web dev with PHP Came to the life choice that game dev isn't for me, web dev is my role in this world. Bought a real license to PHPStorm, got a coffee, and now here I am swallowing it down. This is my language, this is my life. I'm fine with this. No doubt Ill try something new again soon. Thinking of checking out Python again thanks to the moderate success I had with it. 
I simply use vanilla Composer (with `path` repository). The next article (planned publication date: Wednesday) will show an example. Now I'm not sure you would like something else, but beside the alternative you've mentioned there's also [conductor](http://tech.mybuilder.com/why-we-created-conductor/)
That's the point...
Will change. For what reason, exactly?
Which organs, and why do I need them?
In my experience you're in one of two camps; a programmer, or a &lt;insert language of choice here&gt; developer Each language/script has its pros and cons. The tooling and ecosystem is great, or its non-existent. I've worked professionally with; - Basic - C - C++ - Java - PHP - Python - Objective C - JavaScript/Node And, in my experience, if you can understand the current architectures program flow and logic switching, then you'll be okay. It's all just logic gates; some open one after another, some have a gatekeeper to open them for you
^ What they said
For starters, it doesn't consistently use namespaces and has it's own autoloader, which unlike Composer's autoloader doesn't have any optimization options. Their class filenames don't match their actual classnames, which will break on certain filesystems - presumably that's part of why they need that custom autoloader. They've rolled their own password hashing library, which is usually a red flag. I'll leave the evaluation of that code to /u/sarciszewski as he is far more knowledgeable than myself when it comes to security. No tests. The code itself has a lot of weird quirks, from a very weird docblock format that I've never seen elsewhere. to lots of singleton and static class access, which is considered an antipattern for any number of reasons. I'm sure if I could find more stuff if I dug around.
I've taken "RESTful" to mean adheres to some subset of REST. It's not a "REST API", it's RESTful. I don't believe most applications need 100% adherence to REST.
If I may ask, *how the fuck* am I supposed to do testing with the node.js/npm ecosystem (especially with ReactJS)? Every tutorial I find seems to be doing things slightly differently and I'm dealing with global state, singletons, etc all over the damn place.
Is there a decent way to structure a ReactJS app that doesn't make testing a huge pain in the ass? I've been trying to implement some decent form of testing but everything seems to be a huge mess of singletons, global state, mocking everything, etc.
Started writing go as well and have been loving it. Doesn't mean I'm leaving php but its very fun to work with.
First I must say I am very much surprise you dared to ask this question here. But with that being said, my answer follows. Migrate out of PHP is only hard if you're one trick pony. Many of us are well round engineers with knowledge spanning much more than php. Therefore it shouldn't be big and painful transition to you. My personal case came when I realize how toxic and low quality PHP ecosystem was. The language is ridiculous, but we all learned to appreciate that, didn't we? So the language is not really the problem, only the ecosystem around. My personal definition of ecosystem comprises quality of libraries, supporting software (editor, debugger etc), work market, salary levels and quality of existing code bases in potential employers. As we all know, PHP is lacking in all of these and it also meant that I exactly knew what to ask when investigating alternatives to PHP. I will not go through all the iterations I had, only the latest one: Go. Because Go was able to solve one of the hugest thorn in my side (concurrent and parallel programming), I gave it a try to its ecosystem. So I went investigate with people and Google about its ecosystem. And I found good existing code bases, great companies, good salaries, small market but not a lot of competition, thriving libraries, awesome supporting software and was pretty much surprised by a welcoming community composed of the best elephpants, rubyists and pythonistas that left these language spheres for similar reasons. My daily life improved a lot. I cannot tell how many times, no matter whether a source code base was good or not, I had problems reading and modifying PHP code. You never know, right? There's a variable, that might be correctly named or not, whose type might be correct, or not... That shows up an error when you run the tests or not, if they exists of course and ah! Your local phpunit must match your test server phpunit. All these programs are now in the past, at a very low cost. The supposed loss of productivity you'd have working on typed language doesn't exist in Go, merits of its structural typing system. And I got awesome tooling everywhere. No problems caused by mismatched testing suites, Go testing suite is the same everywhere. If I am not sure about certain aspect of the language behavior, there's a Lang spec that readable and short (have you ever seen Facebook's version of php Lang spec?); if I need to understand the implementers of a certain interface, go guru helps you. I mean, every single aspect of my daily life improved once I migrated off PHP to Go. And the most controversial aspect, perhaps, is that because PHP is a very forgiving language, it lures almost every kind of morons. The reputation of PHP developers being morons is earned, is no accident. You're gonna see here lots of good developers that happen to code PHP, I am not talking about them. I am talking about the natural barrier from morons that PHP lacks. And I cannot stress this enough. Other surprising aspect, is that PHP community is made of leechers. Of the worst kind. People that will use your OSS project and ask you to support it as if it was a commercial software with 100% discount. So far, I haven't seen such behavior in go's ecosystem. Either people care and help, or people use and report bugs. But I haven't seen anyone using and demanding support for free. Anyway I could keep going and going about how Go ecosystem is better than PHP, but by now, if I haven't convinced you of it, then it is not worth trying any longer. Keep in mind, knowing what you want from a language ecosystem helps you drive you out from the one you're in. PHP sucks. A lot. You don't need to suck either. 
I sure hope you got permission to release code you wrote on the clock.
I'm not entirely sure if I am a php developer... I spent 4 years doing shops (tickets/merch) for a very small company for the music industry. That was PHP/db centric.... lost my job (due to not being paid) and somehow ended up doing dev work for another small company. I know PHP well.. very well.. but I spend more time doing other things.... js/server stuff/c#/Java .. none of these I know well nor have the confidence. But having that PHP background is so immensely helpful... I dont know how to word or describe it... in fact I'm sat on a bus home in a big storm after a stupid long week... but this week it's been GRRAT to be working on building a pure PHP centric API. Somehow it's satisfying spending that time hammering out something that I know so well. 
I had the same opinion when I was a "PHP programmer" and just casually looking into Ruby, but once I was forced to really pick it up and learn it, my outlook changed. Of course, personal preference like most things in programming (Vim is better!)
I've been using Swift and it's more understandable to me than objective C. Optionals are a little crabby and you have to be more careful of types (can't expect to put an int into an array of strings, for instance), but explicitly defining everything ahead of time makes the language very clean. I've been enjoying it.
Putting the images private is where my knowledge ends. But I'm willing to learn and get it right so could you tell me what I need to research in order to get this working?
I got threats actually - more than once.
I agree with /u/sarciszewski. Encrypting filenames isn't doing much for you. I've been brain-storming something like this for a different purpose. My thought was to generate a private key for each user and use that to encrypt the images and then, of course, storing those images outside of the public folder.
Could you explain PhpStorm and what makes it better than using just vanilla
I think he meant concept wise. PHP is on its way to be more like Java, and other languages do the same. With all the language quirks and syntax removed, the concepts are all the same more or less. 
It's an IDE/text editor, not a different version of php.
&gt; The other devs acted like I was a moron whenever I asked a question, presumably because they knew my background was primarily PHP. Oh dear, I would smack the hell out of them. I am so angry right now.
&gt;Symfony is already planning for that. Painfully, because requires a lot of internal changes and will be a painful upgrade for users, especially bigger consumers like Drupal and eZPublish. &gt;PSR-7 is the right choice for anything new. But if forces HttpFoundation people to use the PSR-7 bridge, which degrades performances and that's far from being negligible. If I'm writing a PHP library but I'm using it on Symfony, it's unacceptable to degrade my performances right of the bat in such a way.
Have you tried /r/crystal_programming ? Similar to Ruby
I make it a point to go all in when it comes to a different environment. When i worked with C/C++/C#, on Windows I opted for the various versions of Visual Studio over the years. On Linux I used CodeLite. On OSX I've only used XCode. I loved *ALL* these tools. Though in hindsight I did forget to mention Objective-C, which I've dabbled in quite a bit when I tried to be some kind of native app developer. When I worked with Java, I used to use Eclipse, but I've been using IntelliJ IDEA pretty much exclusively When I worked with Ruby, I've only used RubyMine for it When I worked with Node, I used WebStorm When I worked with Python, you may notice a pattern here, but I used PyCharm When I did use java, I did attempt to get into Kotlin, then Scala, then defaulted back into Java again. Neither Kotlin or Scala resonated with me very well, though Scala I think more than Kotlin (despite my obvious hard on for JetBrains)
idk i used mocha. you basically build everything is a god damn module, then test the shit out of them. as for actual UIX testing, I haven't a flying fucking clue.
&gt; Probably the most immediate difference was an almost 30% pay bump That is the silliest thing I have ever heard in my life. I can tell you dozens of companies that I've worked at as a Lead PHP developer where I made twice as much as the .NET guys but that doesn't make it true for everyone or every situation. What you make has a lot more to do with the market where you work than the language you program in.
I have a debian version in my job with php 5.4 and there's no way out.. :(
Definitely. Mine was just a simple example to demonstrate the overabundance of `.then().then().map()` that goes on in the Node world... :)
I used to work at a place where I did about 80% PHP, 15% javascript, 5% java, building web site and APIs. I moved to a startup that hired me because they had contracted out their engineering to a company that built a mess of a solution in PHP, Mongodb, and Solr, which are all things I have prior experience with. Since this was mostly big data processing, stream processing, and ETL type stuff, this wasn't the best tech stack and was quickly failing to keep up with scaling needs, so I pushed that tech stack as far as it could possibly go, while helping to replace with a bunch of JVM based solutions (Spark for the ETL/Big data stuff, Storm for stream processing, almost all of it written in Scala with a little Java here and there). I also helped move some stuff into node, which was a better solution for serving to websockets. I don't know how much my life has changed, other than worrying about types and multithreading and concurrency a lot more (actors and futures are everyone's friend). I've always been pretty quick to pick up new languages, so picking up scala wasn't too bad. One thing I have noticed is that, despite both being built on the JVM, people who come from java tend to write the worst scala. (I also thing people coming from java write the worst PHP, python, and javascript, so maybe there's a trend). Basically, I just try to roll with changes, google a lot, check stack overflow a lot, follow a bunch of programming language subreddits, read docs, read code, and play with new languages, frameworks, and technologies in my spare time. 
In my opinion encryption is not the way to go. - 1 Secure the files against direct HTTP access. That means placing it not in a web readable folder structure. - 2 Use Access Control List packages to prevent access to images they do not have access too. - 3 This leaves the problem of session hijacking as the only means to access proof of purchases that are not your own. I personally don't have one in mind that is any good. Paging /u/sarciszewski
That's what I'm saying, every language eventually shows it's flaws. And if you can stand working around those flaws when everyone else abandons the language for greener pastures you can write your own checks.
Can I see what your building? I do a long of game development in the side but in no way brave enough to make the jump you have made.
Sure, check it out: www.grabblesgame.com We don't keep a playable demo up anymore because we're getting closer to release but there is a trailer and some screenshots there at least.
Looks pretty cool. Very polished as well best of luck with it. 
It's just a language.
Ive been doing PHP for a few years now and ill tell you what a lot of people here probably will, and that's: Node is nice and easy as I'm assuming you know js. Java, well Android Java is also nice because who doesn't want to make apps haha
Oh man. Good for you. My original goal was to be a game dev, but for lack of opportunity I ended up in web dev. I wish you well!
&gt; I AM learning the JS ecosystem on my own through some personal projects, and it fucking sucks horse dick compared to PHP + Composer. It's almost impossible to understand without experiencing for yourself how fragmented and terrible the JS build ecosystem is. It's worse than PHP ever was, back in the dark ages before PSR 0/4 and composer, when everyone just did their own shit. Shows to prove that you have no idea what you are talking about. Sorry. Try to really spend time with one of the system before you go on shitting on it...
&gt; Sorry. Try to really spend time with one of the system before you go on shitting on it ***[No, sorry right back at you](http://cube-drone.com/comics/c/relentless-persistence)***. Try spending some time in the shoes of someone who has to wade through the fragmented wasteland of tutorials, guides, and documentation about how to do JS builds. It's easy for you to say "I already know it, and you have no idea what you're talking about", but try actually putting yourself in the shoes of someone who doesn't know it yet and has to learn when there's dozens of competing tools with various levels of interoperability. Why do you think there are a million different "XYZ Starter" repos out there with everyone's own opinionated build stack and some 300 line gulp file that you have to grok? Why are there are articles titled [Why Can’t Anyone Write a Simple Webpack Tutorial?](https://medium.com/@dtothefp/why-can-t-anyone-write-a-simple-webpack-tutorial-d0b075db35ed#.xo7y81osq) which then proceed to give you a complex Webpack tutorial? Speaking of gulp files, they're like fingerprints - every single one is different, and even the way you "chain" transforms is completely inconsistent, [like this one](https://gist.github.com/danharper/3ca2273125f500429945) you nest `browserify` inside of `watchify`, but then chain transform to babel and then do other things with `pipe()`? Compile takes a watch boolean? Seems a bit of an odd way to structure code. Why do I even have to wrap it in watchify if I have a watch task and a watch boolean? What's the relationship between those three things? Why does every fucking gulp "plugin" have to end in `-ify`? Gulp is just plain ugly and complex to write shit for, and everyone writes it differently, making it that much harder to know how to compose the dozens of different single-purpose build scripts together. Some tutorials don't include gulp and just do NPM scripts. Some just use pure browserify command line. Some use only webpack. Some use a combination of ALL THREE. Want to write a JS module for others to use? [Better include a half dozen config files and dist build scripts, along with over a dozen dev dependencies.](https://egghead.io/lessons/javascript-add-a-browser-build-to-an-npm-module) Not to mention the dozens of NPM shims [like these](https://www.npmjs.com/package/gulp-webpack-es6-pipeline). So really, knock it off with your condescending "you don't know what you're talking about" bullshit and pull your head out of the sand. The JS ecosystem has a fragmentation and complexity problem. End of.
Something like Selenium for real browser testing, CasperJS for headless browser testing (with PhantomJS) or Cucumber+WATiR and its variants. I prefer CasperJS simply because setting up Selenium and building your tests is more of a pain in the arse and, as for Cucumber, I haven't personally used it - I just know of it and have worked on projects where it was used.
http://sparkjava.com/
&gt; 1) creating a hash using Phpass PHpass is designed to be slow. That's great for dealing with passwords, but when you're talking about "encrypting" (which is not what it does) paths used by this application, all you are doing is deliberately building a very, very slow application. It's going to die under any sort of load. 
Ha! So I did. Good catch! I'll update it shortly.
If your goal is to prevent hotlinking (people being able to see images if they would simply have the address) then there's a much better way. Making the filenames long and difficult is at most security through obscurity. The better way is to store the images in a location that is not directly reachable from the Internet. Outside of the public html folder. Store some Metadata like give them an id or something. The when a user is logged in they can go to yoursite.com/user/img/1 or something. Behind this is a php script that checks credentials and then returns the file if that's all good. 
Im leaning towards the image processing side of things instead of just a thin wrapper on top of GD and Imagick. Think dithering, bezier curves (for GD), average hashing (checking how similar two images are), advance filtering etc. So in cases where you need more than just resizing images, you might want to use this lib. Its still a work in progress though so most stuff i mentioned are not in there yet.
Node try { const result = await http.request('http://www.google.com'); console.log('result', result); } catch (e) { console.log('error', e); } And if you are worked with async stuff in PHP there is no big difference really.
Why are you creating new directories with 777 permissions? https://en.wikipedia.org/wiki/Principle_of_least_privilege Depending on how your server is set up 700 might be enough, 777 will grant full read, write, and execute permissions, to every other user on that server.
The reason is being node's main way of work. Everything is async, so doing blocking calls is bad. Because PHP is mainly a imperative language every call is blocking to the current process (request if you will). However, that does not give any excuses if your co-workers we assholes. Good thing you quit. PHP (and similar languages) wont survive the requirements of the next 10 years. There is no way (secure, sane and fault tolerant) of having any sort of parallelism or concurrency in PHP applications. Your only choice is basically to use a third party tool, like a MQ and push work onto it and handle it later/asap. And as the trend is now, CPU cores wont get any faster, i would argue they are actually getting slower. So any application written in PHP wont and cant benefit from the 128/256 core server we might have in a few years as a default. This as a pretext should matter if you care about yourself as a programmer, and want to stay on top. There are lots of wordpress and drupal "develoeprs" who are totally lost when it comes to basic PHP. I have personal experience of this. Once i got a job and the title was "PHP Developer" and the truth was that they were a 110% Drupal shop. I got a task to build a contact form that had 4 or 5 fields that should save submissions to a DB. I wrote it in plain PHP as a very simple class (around 50LOC inc whitespace + comments) + a single index view. I got shit for it later because "no one else could understand whats happening in the code". They event thought it was written in some unknown framework! This was a big red flag. The next thing was our project manager totally fucked up a bigger projects git repo i was working on alone (Drupal site) and i had to resolve hundreds of conflicts. Pushing straight to master without no knowledge of branching. The main takeaway is PHP shops (most of them, not all ofc.) using CMS software have a HUGEHUGEHUGE technical debt, and will suffer from very bad practices. (before i joined the company they had a internal website with all their passwords visible as plaintext on a project basis). I tried to make changes and improve a lot of stuff internally but eventually i was let go because some bullshit reason. (i figured out later, the main reason was their tech-chief &amp; sec expert felt "scared" and "hurt" because i told him how the security on big client project was essentially non-existent) Now my suggestion is prepare for the future, and pick up new paradigms and forget the old languages. Heres some very exciting languages: - Elm - Nim - Rust - Clojure - Elixir (cannot recommend this language enough) And some more obscure ones, that serve as a very good learning exp. for how things can be done different. - Any LISP - Kitten - Prolog - Haskell - OCaml - Self Have fun! 
I dont mean this in a negative context: but did you give up? were you not able to build anything complete? were you just lazy? did you not understand? These points are always the first steps you go thru when learning something new. It IS different, and seems to be hard/impossible. You often must rethink ways of solving problems. PHP is specially a bad "first language" because it has so much stuff that kind of works but really does not. This is the reason some things seem harder to do in other languages. Just keep on hacking at it, you will eventually learn how stuff works in &lt;language&gt; and you will benefit a lot. Just join the language irc/slack etc and ask around. People in other communities are mostly very friendly. 
I Thought this was going to be about files encrypted on storage using loopback image and LUKS for each users images (does limit how many you can store, but you can have multiple stores per-user to get around). IMO that is quite a good mechanism for protecting a single users files at rest and from direct linking; but should be combined with a private folder, and potentially a global image with each users secret (if you store it in the DB, there is more chance of an attacker being able to use it to unlock the images in the event of a breach); at least if you have a global area for user secrets, you can regularly roll the access to that image (copy out to a new image with different passphrase), and commit the current master passphrase to a code block, requiring the attacker to not just be good at getting in, but understanding your system. [Using LUKS with an existing encrypted disk image](http://www.blaicher.com/2013/01/accessing-an-encrypted-full-disc-image-lukslvm/) (you should be able to script this)
HTTP APIs. If I need to make a server rendered website I would still use PHP though.
&gt;So any application written in PHP wont and cant benefit from the 128/256 core server we might have in a few years as a default. Of course it will. More cores = more concurrent requests can be handled. If your application is simply not concurrent/parallel in nature, there is no value in using a language offering such concepts. There will never be a need to parallelize a simple calculator (oversimplified example, obviously). &gt;Now my suggestion is prepare for the future, and pick up new paradigms and forget the old languages. What kind of hipster bullshit is that? I've never been one of those "get off my lawn" guys and I'm fairly open to new languages, but seriously, forget the old languages? What the fuck. Do you really think any of the major languages will be irrelevant in ten years? There are so many applications written in them, they are here to stay. There are rich ecosystems. And such a pseudo progressive way of outright refusing established languages is not even remotely justified, given that all major languages are constantly evolving and introducing new (including functional) concepts. C# for example is a vastly modern language, there is really no need to dump it and its ecosystem for some 3 days old language. You should be constantly extending your knowledge. There is nothing wrong with learning more languages, modern or "conservative". There is really no reason to ignore and/or forget the currently established ones.
I used to do EnterpriseTM development in PHP, typically some kind of multitenant system/service, typically using Symfony 2. I wasn't happy all the time, because frankly PHP is not my kind of language, sure syntax is okayish at times, but there are inconsistencies in many things, like you couldn't even get an element from array returned by a function prior to 5.5 (or 5.4, I don't remember), arrays were abysmal before 5.4, the language just lacked basic semantics at the time. I was deeply unhappy all that time, feeling infeior to Java/C++ developers, feeling like I'm not a real language/technology-agnostic developer. Now PHP is becoming a decent language though, maybe in 5 more years, provided it won't suddenly die, there will be no stigma towards PHP developers. So I made the jump, totally abandoned all PHP development and started relearning Java, I thought about doing Scala (I'm a huge fan of functional programming), but unfortunately market is just too small. I landed on my first job in last december, luckily my interviewer saw past my background as a PHP developer. At work, some of my coworkers do deal with me like I'm some kind of moron, one of the architects at my company thinks that someone made a mistake hiring me, he thinks I'm some kind of semi-junior. This stigma is pretty bad and I'm having a really hard time having to prove that I'm not an idiot all the time. I work extra hard, I learn advanced things, I learn about parts of the system I won't have to work on. That architect won't trust me to do anything important even though I have a proven record of successfully doing important things in project already (we had another architect with whom I worked directly, he too saw past my background, so I had quite a lot of interesting tasks), this stigma towards PHP developers is hardwired in his mind. This is what I have to deal with. In terms of paradigm/syntax transition, well I didn't have to learning anything new, my knowledge and experience with PHP/Symfony 2 transitioned into Java/Spring experience like I was writing in Java the whole 3 years. Symfony 2 is essentially a Spring clone, Doctrine is clone of Hibernate/JPA (more like JPA though, Hibernate's vendor-specific features are not present in Doctrine as far as I remember). I used to do professional C++ development prior to starting web dev in PHP and before that I used Java extensively for my own projects, so I pretty much knew Java syntax, just had to learn some things about standard library. Multithreading was never a problem for me because I pretty much started learning programming while using multithreading, my first language was C# and you can't make a decent windows application (which is what I was making while learning) without using multithreading. What I struggled with is learning about servlets and servlet containers, its kind of hard to learn something about them without reading a 10000 page specification and thats actually true for all JavaEE specifications, they're super bloated and boring to read. Despite all this, I'm happy that I made the jump. The pay is better here and I'm using a good language, also Java has built-in monads, I use monadic chains everywhere I can, for a FP-head like me its like christmass every day. PHP can have that too though, but you'll have to look for specific libraries. 
you'll get even waaay more results for frameworks on node, and the popular ones change month by month unlikely year by year in php.
This is almost identical to the [manual page on magic methods]( http://php.net/manual/en/language.oop5.magic.php).
Last year I went from being a full time PHP developer to a full time Go developer. I think in general I'm happier with Go but it's hard to pin down exactly why. I just feel like I'm writing cleaner, more robust code in Go. In PHP I always felt like I had to add more "stuff" to a project for it to work properly - frameworks, queues, workers, crons, caches, webservers, reverse proxies etc. In Go I can usually get 90% of the way there just with the standard library in very few lines of code. Obviously when you start scaling out you need to implement shared data stores etc. but most stuff I work on is small enough to avoid that. I actually don't know if I could ever go back. PHP (and in general weakly typed interpreted languages) feels so strange to me now. I get really worried about implicit type casts and runtime errors with PHP since there is no compile phase to actually check if the code even makes sense at all. Just not knowing what type a function will return seems crazy to me now. In terms of leaning new tools Go really has a good set of tools built in so for example you're probably not going to see 10 different testing frameworks or anything when moving between projects. Obv. they exist but most people stick to the standard tools.
/u/SomeRandomBuddy -v ?
 .wait()
"for the cash"? Go learn fortran, there is companies paying a lot for this.
You might excuse the author for considering Symfony Form to be about HTML forms when the *actual Symfony manual* says so: &gt; The Form component allows you to easily create, process and reuse HTML forms. http://symfony.com/doc/current/components/form/introduction.html
&gt;I just feel like I'm writing cleaner, more robust code in Go... This! Even switching to a better dynamic language like Python makes you feel a whole lot more confident about the code you write, which is so lacking when you are working with Php.
What does that even mean? Bias as in "opinion I don't agree with"? Of-fucking-course it's subjective!
So, basically - I could really do with some help in maintaining Imagick. ImageMagick 7 was released recently, and although almost all of the code to support that is done, there is a significant amount of work needed to: * Document the differences between Imagick when it is compiled against ImageMagick 6 compared to ImageMagick 7. * Deprecate more functions that were present in IM6 but aren't in IM7. * Continue to work through the backlog of improving the documentation for existing functionality. I'm going to have to set budget of how much time I'm going to spend on Imagick to something like 4 hours a week maximum, as otherwise it's just taking up too much of my time. However at that rate, the documentation for how to transition from IM6 to IM7 will be done probably around 2019.... Oh btw I don't actually use Imagick for anything at the moment.....other than maintaining the [example site](http://phpimagick.com/). 
Ah! Sorry didn't see the code. I'll Do whatever I can. I'll definitely help document and if I find issues I can code I'll gladly give them a go :)
are you the guy that started mikkos blog? for years that blog was practically the only decent resource for learning how to implement imagick . using just that blog and a good deal of imagination, patience ( and trial / error ) i was able to do some insane shit with imagick i would never attempt to do with gd. if you're that guy, you have all my upvotes and i hope more people come onboard to help you update the documentaton brother.
&gt; Generally speaking, you only want some things to be asynchronous, but most things you want to happen in A-B-C order. But with Node, you pretty much have to treat everything as if it were asynchronous. This is very well put and rings true for me as I'm doing node.js development after years of PHP (backend) development (I've done client-side JS before). The thing is, HTTP is a request/response type deal so most of the time your response needs to be completed before you ship it off. So, if you need to store something in a database, you need to: 1) authenticate the user (who are you?) 2) authorize the user (are you allowed to do that?) 3) do the action requested ($var++) 4) inform the client of the outcome In node.js' asynchronous way, this would translate to authenticate then authorize then do action then inform the client So, basically, you would do everything with asynchronous processing, but **at each step wait for exactly one outcome from previous step**. You know what that's called? Synchronous processing. So you end up with having to use a lib called `async` to write synchronous code on top of a asynchronous platform. It's weird. I did find couple of examples where doing parallel stuff was awesome, but that was &lt;5% of the use case, most of it was exactly like described. Don't get me started on callbacks, error stack traces or error handling in general. I think node.js has a strong application where the event loop is a requirement (like real-time processing) but would not choose Node as a platform for anything serious. IMO, in relevant areas, PHP is **years** ahead. Love JS on client-side, though.
Have you tried the php doc mailing list or irc channel?
I just execute the ImageMagick processes directly. I've never seen the point of this extension. Last I checked it didn't even support close to all the features of the executables.
&gt; are you the guy that started mikkos blog? No, I'm the guy that took over from Mikko. Having more time for blogging both in general, and about the new features that have been implemented in Imagick is one of the things I would like to do. However all of the examples I do are posted to http://phpimagick.com/ - which also takes up time. 
Commenting so I remember to come back and post about this :)
I just use the built in Thin server for local development, never had a problem with this out of the box on a Mac. My servers use Puma and nginx which takes some configuration, but isn't too bad. There's tons of guides out there, Digital Ocean has a good guide for Ubuntu and the setup I use. (https://www.digitalocean.com/community/tutorials/how-to-deploy-a-rails-app-with-puma-and-nginx-on-ubuntu-14-04)
It depends what your goal is. If Ruby helps you write code that lets you ship shit fast and effectively then sometimes that's all that matters. It depends what you want to get out of your code? If it's for business, productivity becomes important. If it's for pleasure then feel free to tinker with advanced languages / moving things forward. It's important to remember everyone has a context to what they are applying their code to, often it doesn't match everyone else's and this is where political community disagreements generally arise from. 
Well said, I haven't worked in a team ... But with this little experience, I definitely would avoid such future pain.. Thanks a lot
&gt;C# How much time did you actually invest into learning the nitty gritty of the language. The IDE automates a lot, but really knowing the underpinning of your tools and technologies is key. C# (assuming you're doing .NET) is mostly understanding the .NET framework, MVC model and how using an ORM will saving you time. I could get a fully functioning web app in C# put together in a few hours. (or hello world in 5 minutes) 
I think you will have easier times to use ApiPlatform or FOSUserBundle instead of re-inventing the wheel.
&gt; Once you move on to working within a team, on an application that's not run on a single server, that requires multiple environments for QA, UAT etc, then you will start feeling the real pain. Dependency explosion can come from inherent complexity, but it's most typically a sign of lack of discipline. And discipline is indeed harder to enforce in a team. Say, who controls dependencies in your team? Is there an architect who gets to say "no you'll stick to PgSQL, and you won't throw in a bunch of NoSQL databases, and a dozen obscure PHP extensions". When I started my current job, the existing applications were a mess. MongoDB and what not thrown in for no reason at all, every service used for something so trivial it could've been done as basic files on disk. A team of 5 folks did that. Some months later, I and a single colleague, we've refactored (or outright rewritten) said apps, and we have faster more stable code at half the codebase size, and they all run on a stock LAMP server. Go figure. P.S.: I do still use VMs for dev, but that's beside the point.
How is this the fastest? Only because it uses parallel processing? 
Agreed!
Really? My experience with Python has been the exact opposite.
This is kind of a crappy article. No, wait, actually it's a very crappy article.
This is one of those painful rights of passage a great many web developers go through. I still remember discovering [money_format](http://php.net/manual/en/function.money-format.php) isn't cross-platform. It's also easy to get smacked down by 32-bit vs 64-bit differences and subtle php.ini configuration changes. It's also worth noting the strong equality bug could have also been mitigated with return types (another great reason to switch to PHP 7 if you can) or a robust unit testing suite. Obviously real life can get in the way of those things but they're incredibly useful if you can swing it.
Oh, just like Symfony does then? They use [splitsh](https://github.com/splitsh/lite/blob/master/README.md) to synchronize the mono repo with the individual repos
Because there isn't any good practice to see in Wordpress, nothing to learn, pluuuuus, everything is done is some odd and weird ways, i find it myself very painfull to look at code written in that way i personally don't like it, and it's just my opinion. And if somebody ask me some good software to digg around for some good code i would rather recommend october then wordpress.
Hm you kind of confirmed my suspicion... is Drupal 8 better?
you can put PHP 7 as a requirement in your composer.json
But that doesn't make sense. There is no "spec" for the wrapper so you can't change it for another implementation. The solution is to make PSR7 simpler. Wrapping it removes all the benefits of using a PSR in the first place. 
&gt;The function money_format() is only defined if the system has strfmon capabilities. For example, Windows does not, so **money_format() is undefined in Windows**. Wow, really? *Undefined behaviour* is, in fact, part of PHP? It can't just replicate the behaviour of the syscall, or at least be a fatal/exception throw/null return?
Well, like I said, I run on shared hosts a lot. Meaning I don't have access to composer. Furthermore...don't all frameworks include their dependencies in the repos? I want to be able to pull the whole framework. &amp;nbsp; I changed the default directory so that people can have a separate one for their application.
That seems...kind of icky. I like to keep languages and components together. And I feel like some things should be grouped by type, not by similarity. In my opinion, this leads to a more organized application. It avoids complicated linking, and some views are passed to multiple controllers, etc. Furthermore, this doesn't exactly lend itself to SCSS or JS compiling...which you definitely have to do if you're writing a Single Page Application. &amp;nbsp; Your organization seems like it goes directly against separation of concerns.
My startup runs nothing but Debian servers. Add a PPA for PHP7 if you can.
&gt; and some views are passed to multiple controllers That's what partials are for. But regardless, Laravel lets you include views from any namespace or folder you want, so if you want to extract out a common view, you can. &gt; Furthermore, this doesn't exactly lend itself to SCSS or JS compiling Completely untrue. My gulp script (to be fair, after much pain and effort) looks through the entire `apps` folder for all JS and Less, does its compiling/transforming, and places it in the public directory using the same directory structure from which it was found. I have a common.js and common.css file, then each app can have scripts and styles common to that app, and each component/module within each app can also have its own specific styles and overrides if necessary. For example, there's ZERO point for all pages to include the JS code used for validation during registration, so that's a page-specific set of JS. Meanwhile the common.js/css can be cached by the browser for all subsequent page requests, and then only the page-specific styling and functionality (usually less than 5kb) needs to be requested. As far as keeping languages and stuff separate, I used to do that too until I got sick of making a change to register.blade.php, RegistrationController, and then the registration.js, and having to dig around in different folders to find it. Even with Ctrl+P, it's simply easier to reason about what's going on in a component of your application if you can see what's powering it all in once place in the directory tree. Grouping all of the code that belongs to a module or component in the same place has made my directory and app structure FAR FAR FAR easier to reason about. Far easier for newer developers to look at the app and know exactly where all of the code they would need to modify for a given module/component lives, and in general saves a bunch of time. "I need to make a change to login" Account -&gt; Login. Everything you need is right there. Grouping by module instead of by file type makes more complex applications 100x easier to work on.
WEEELLL, haha I just tried dotdeb repositories and installed php 5.6 :D... but I tried to install mysql-server-5.6 at the same time and almost broke down all my system. So far php works great. What ppa do you use for php7? 
What were you trying to do?
I would guess that you didn't uninstall the first PHP installation fully, or you configuration was loading the first mysql driver, not the new one. I *think* I use the DotDeb PPAs for PHP7. Let me know if they're not on there, I'll check what PPA I'm using if it's not that one. 
CustomException.php
Oh. I should have mentioned that we're on Jessie. 
No wonder I couldn't find any tutorials on how to get the color of a pixel today with magick++. They were all for 6.
&gt; RESTful it allows me to think about the usage and architecture of the API in many ways better than if I was just using HTTP. E.g, the idempotence of GET requests. GET is nullipotent. PUT is an example of idempotence. But this comes from HTTP itself. So being "RESTful" according to common tropes for "RESTful" APIs adds nothing on top of what HTTP already is.
I initially did this, but due to performance and security concerns I built https://travis-ci.org/Ocramius/PackageVersions instead, which gets rid of the problem entirely, at least for my own purposes.
Good work on the pecl package. Thank you. I had to disable our use of Imagick due to the "ImageTragick" vulnerability. Thankfully I do not need to use it again for another month or two; so may be able to help then, but don't wish to commit to anything as I am very busy myself and probably won't be able to help. I only use a very limited set of the resizing functions, but will try to help documentation if I notice anything is amiss with what I use. Is Imagick 7 still affected by the "ImageTragick" vulnerability; I've looked all over their site and can't verify it isn't; it seems to me that it still is and you need to set the correct policy.xml; can you confirm whether this is the case? Thanks for all your hard work - much appreciated.
It's a class like any other. You may want to look at http://www.phptherightway.com/#namespaces for further guidance on how to set up autoloading and get rid of these concerns for good :-)
A while ago I wrote special getters into part of the application I'm working on, so something like this: $this-&gt;Core-&gt;get('params') Some of those variables were arrays and I wanted an item from that variable, so after some looking into things, I discovered I could use *array dereferencing* and so this: $item = $this-&gt;Core-&gt;get('params')['item'] actually worked. Cool. So, my question is: is there some sort of language construct that would allow me to do something similar in a setter? Because unless I'm starting to suffer from being at the computer too long I either have to write something into the function (if so, is there a common way so I don't reinvent the wheel?) or I have to do this: $nav = $this-&gt;Core-&gt;Session-&gt;get('nav'); //FIXME: there has to be a better way. $nav['group'] = $display; $this-&gt;Core-&gt;Session-&gt;set('nav', $nav); And there is nothing like (to use the above code): $nav = $this-&gt;Core-&gt;Session-&gt;set('nav'['group'], $display); Or is there?
Not yet, but will do. I doubt that will have much success as everyone already contributing is probably similarly short on time. Also, what the project really need is not someone that knows PHP that well, but someone who uses Imagick/ImageMagick and understands the what the heck is going on. For example, I've only just realised that [ImagickPixel::getColorCount](http://php.net/manual/en/imagickpixel.getcolorcount.php) is only going to return a valid result when the ImagickPixel was created through Imagick::getImageHistogram. That type of domain knowledge is what takes up a significant amount of time.
site is still offline, no response on https://github.com/phpmentoring/phpmentoring.github.com/issues/28 :-(
Simply don't put files in your public folder.
Good luck running *exec* on any but your own/dedicated hosting
Surely there's a way to capture all the routes in one go in Lumen/Laravel. In Grails you could just do: `"/users"(resources: 'user')` and be done with the URL mapping. Then just define the logic in the `UserController`
Nice project! I'd suggest adding something to the README saying where to get the hashes (do I hash the public or private key file, or read it from a value in the file itself, etc), and maybe a general note on how to roll it out to production with the lowest risk of breaking your website. And the importance of having backup keys when using HPKP, etc. Sending out the wrong one by mistake is a recipe for disaster, especially since it appears to default to the "full" (non-report-only) mode. I'm guessing the main target audience of this doesn't really know all of the caveats of HPKP.
Really cool concept, a big turn off is the minimum requirement of PHP7.0. Why is it not possible to support older versions?
HPKP pins the public key, not the cert. If the cert expires, you can either reuse the same key to issue a new cert, as you said, or create (and pin) a new key in advance. You could also phase out the current key by using your backup key for the new cert and pinning a new backup key, but this can be problematic especially with long max-age - if you need to revoke, the new backup key might not be pinned for all clients yet.
I've spent most of my career as a full-stack PHP/JS developer (JS for client-side code only), until a couple of months ago I accepted a position as a full-stack Java/JS developer. I'm familiar with strongly typed languages, so it's been fairly easy to pick up, but there are a few big differences. 1) Maven is harder to work with than composer, but it's also much more powerful. I think this is something that's unique to Java (not so much an issue with Ruby/Python/etc.), because Maven is a whole build system rather than just a dependency manager. 2) Strong typing is nice in many cases, but it makes certain things more complicated. For example, if I have two database views with similar fields, and I need to dynamically decide which one to query, in PHP I can just query the one I need and I get an object. In Java/Spring, I get a strongly typed entity that is unique to that view, which I then have to manually convert to a DTO which I've had to define in a separate class. Conversely, I now understand why Java is as verbose as it is. It's out of necessity due to strong typing. 3) The biggest thing I miss about PHP is being able to make changes to code and see it instantly. This was great for quickly debugging applications. In Java, I have to recompile and restart the application every time I make even a small change. This results in a lot of time spent waiting for the computer instead of getting work done. 4) As a sidenote, XML sucks. Can I have any other markup language? YAML? TOML? JSON? I have to convert all of my database migrations to use `&amp;gt;` and `&amp;lt;` instead of `&gt;` and `&lt;` because XML.
&gt; Also, native gems (C++) are a big hassle, and not something I ever had to worry about with PHP. Umm. PHP extensions are written in C++
$myArray[]="value";
&gt; I have never once used or really needed tests. I'm sure I will later, but it's simply work bloat for the kind of projects I am doing. Is it not? Tests is good for frameworks to have to ensure that the end-result of what the API promises don't change as you change parts of the framework. Nothing sucks more than your application breaks because you upgraded within a minor. Tests establish the proper behaviour for the project, and if it deviates, you know it and you can fix it before it's an issue.
If you feel the need to explain a method or argument name, don't write a comment, rewrite the name itself. public function hasLegalDimensions($base64_image, $legal_width, $legal_height) `has` or `is` at the beginning of a method name suggest that the return type is a `boolean`. (Think about it as asking a question.) Adding `legal` to the dimension arguments clears up any ambiguity. You can then add a doccomment so the IDE can provide hinting, but without the comments itself. Then you don't need to maintain the comments as well as the code. If the method changes, refactor. Also: Don't write comments within a method, simply create an appropriately named new method.
Looks like all the implementations are parallel.
If you use docs with PHPstorm it will warn you of type errors, such as a mismatch for arguments your passing to a function or the return type of a function does not match the variable your putting it into. So I find it really handy for its type checking ability, and it only takes a few seconds to add in
Self documenting code is still documented code. &gt; This can be due to different spoken languages How is writing more text going to help with that ? &gt; different experiences Not sure what that means. &gt; Maybe this application has functionality related to both images (PNG, JPG, BMP) and images (ISO). We are missing context, and can assume that the abstraction makes that obvious, if true, and should make it obvious if not true (because different responsibilities). Having to explain what a function is doing shows a failure to write self documenting code in the first place. There may be cases where explanation is unavoidable, but they should be the exception, not the rule.
I'd suggest build the API doc with your favorit tool and see how that documention feels to read. Pay especially attention that only your public API get's build (see @internal and @api). For your example, I would make implicit knowledge explicit. Your units are obvisouly pixel, just add that information to the parameters. Also document exceptions which would violate constraints (you don't accept negative dimensions, do you?).
While we are talking about commenting PHP code, do any of you have idea why PHPStorm by default begins single line comments at the first column? I know I can change it, but I would like to know where did this style come from, It sucks and I don't see it used anywhere else.
Following is highly subjective :) Well, if you were in PHP7 and would have argument/return types defined, you can drop the params and return docs, because they don't add any additional information. Now, rename the function to something like hasExactSize($image, $width, $height) and you are golden. You can argue that both Image and Dimensions could be a value object, but that's not the question here. All in all, if the function name can communicate the whole logic of the function, there is no need to document it further. Sometimes it doesn't and that's when you document the logic. By doing this you will reduce duplication (specifying types in both code and docs) and possible future discrepancies between code and docs. 
Take a look https://github.com/intrd/php-docbloc
what if you can't read function signature? Imagine you are coding and need to use `Image::getDimensions()`, would you prefer to *switch file and scan the source code of whole class* when *your ide can scan the phpdoc of class and tell you the details through intellisense* right then and there? 
Such features use the signature as well as comments. You should not need more detail than can be contained in the signature ...
I don't think that's that subjective. More reading is bad, so if the code explains itself then you can eliminate comments. Also, documentation (including comments) tends to drift over time. That said, you can't go to the other extreme either.
&gt; Oh, and the other case is AutoCompelte in PHPstorm is more accurate with Docs. Given properly named functions and parameters (and hopefully types), what more information do you actually need ? If it feels helpful because it provides some context that is not obvious, that's a sign of a bad abstraction, not a sign that you should comment the code. 
I remember having this documentation actually printed out, and I spent a lot of time looking up stuff in it :) The joy of converting concatenation from + to . when PHP 3.0 was released...
Yes it does, which means there is some specific reason why jetbrains decided to use this style specifically for php. I would love to know why.
That's a pretty misleading title given the fact it ends with "it only supports Postgres"
When's eloquent getting any json love? 
Agree. If your code doesnt explain itself, something is wrong.
stab in the dark but I pretty much only use ctrl+slash for commenting out code. if I'm writing a comment I // so it (for me) highlights probable debugging over intentional comments
Upvote for visibility
We all just know too well how some business requirements can mess up your current architecture. Yet I see not enough comments on exactly **why** certain functions / methods are called. I can read PHP code, so I don't need a second explanation on what is happening. But to know if I am now allowed to remove this without having to worry? Yes, that is important stuff.
I have a STEM Degree but it doesn't relate to development in anyway - I've never came across any issues with it though, most people assumed I was in uni for Comp Sci even while I was reading my microbiology textbooks. The only people that seem to care are people ignorant of your field or other developers on their high horse because they spent a lot of time/money getting their degree. 
then you wouldn't need the parameters that method signature is confusing and contrary to good documentation 
Thanks! Wasn't aware of it. Still, the only way to *really* defeat XSS is to escape properly.
What is lol about that?
alrighty, thanks a lot!
Yeah, but I was specifically referring to the hassle. If I need the cURL extension in PHP, I run `yum install php-curl` or `apt-get install php-curl`. If I want nokogiri on a Ruby environment, there don't appear to be any solid up-to-date repos available, so I need a buildbox running a compatible OS, where I can install my gems, package them up, and transfer them to my target server (as the target server doesn't have Internet access, so no access to rubygems, but it does have access to the os package management servers). There are other things that make that easier too. For example, I'm generally all set if I install PHP and a dozen extensions when I build a server. I just need to run my OS updates occasionally. Native gems get updated more often, and other gems require specific versions of them. Nothing requires php-curl-5.5.1, things simply require PHP 5.4 or higher + curl extension. Hope I've clarified
Whatever works for you and your boss.
One thing I do, which is certainly not typical, but it's allowed and valid, is I put param/return/throws descriptions on the next line, like this: /** * @param SomeClass $name * Description here. * * @return SomeClass * Description here. */ I tend to write longer descriptions for some methods, so this saves me from having to tabulate description texts as I've seen in other code, instead I have full lines of text to write what I want. It also is less awkward in the cases when the param/return type is a long class name, I have enough space to write it down, without having to put in a use clause in the code just for the sake of a one-time PHPDoc use of a type. IDEs I've worked with seem to have no issue with that formatting. 
Why encode it if you can host it yourself and sell a subscription? 
Yeah that doesn't really answer the question. To answer *your* question though, anyway. First, this isn't my choice. Second, some companies want additional security on servers. Third, it allows code to be licensed to third parties without it having to be hosted, and hosting isn't always desirable.
But any obfuscation done on php files is easily deobfuscated with the use of debugging tools, all you don't know are class, method and field names... Honestly, if you want to sell your php application, host it yourself, obfuscation on php is a joke. 
&gt;You don't need much but the occasional **three lines of comments, each line three characters less than the previous,** explaining why helps a lot when you come back to it. FTFY
Already supports it. And 5.3 adds even more support. Works on both Postgres and MySQL. `DB::table('users')-&gt;where('options-&gt;something', true)-&gt;first();`
Simply because of ambiguity. `+` translates to `Add two values together`. `'05' + '5' + 5` is `15` `.` translates to `Concatenate two strings together`. `'05' . '5' . 5` is `'0555'` It's better for loosely-typed languages that don't contain real operator overloading mechanisms. The engine would have a hard sensing if you're trying to concatenate or add.
 &gt; * Objects are aliases so you can pass them into other methods for a bit of processing without having to return them. I don't understand what this means. Can you elaborate? Also, interesting point about the notation. Is that creating an array and casting it to object? Or is it really just creating an object? 
You shouldn't need the "check dimensions"... Instead comment on how it's being checked if it's complex, otherwise don't comment at all. I like to code review my own code about an hour or two after I make the pr, re-read my own comments too and take out or add more to them.
yeah JS is fun with this
https://en.wikipedia.org/wiki/Fast_inverse_square_root Scroll to the heading 'Overview of the code'. A bit of trivia that makes me laugh when I think of it. And probably the only counter I have to your comment.
You can use union-type-ish format in docblocks and PHPStorm will understand it. You can use `Collection[]` notation. You can hint a type without actually requiring it in the signature. But I agree with the general concept — it’s better to design a good method signature than to have to use a comment.
I have been dabbling with ruby on rails for the past year or so. I very much enjoy it. The only thing I'm not very comfortable with is how it feels like so much is going on behind the scenes. AKA magic. I feel like I'm less in control. But I guess that's a good thing...It's hard to mess up things you don't control.
Sorry for the dumb question, but in this snippet, how does one specify which database we're talking about. Is there just one "the database" in Eloquent?
You can have multiple database connections in your config/database.php file. It defaults to your preferred one, but if you want to switch [you can do this](https://laravel.com/docs/5.2/database#accessing-connections): DB::connection('other')-&gt;table('users')-&gt;where('admin', 1)-&gt;get();
I'd probably want someone to comment this for me if I was in the dark. function swapper(&amp;$a, &amp;$b) { $a = $a ^ $b; $b = $a ^ $b; $a = $a ^ $b; }
Looks handy, definitely. I could see this going hand-in-hand with [Incoming](https://github.com/Rican7/Incoming) quite well.
I am with you. I recently started to link the issues myself in the comments. I feel so much better knowing that someone else is understanding why I am sometimes writing unreasonable code at first sight.
Okay, I'm not doing that but I know what you need to do. You don't even need to code. The array at the bottom is key to decipher the string. It's a simple swap. The first item is ```1 =&gt; B```. So, everywhere you see a 1 it is really a B. Or maybe it's the other way around. Whatever. So, take each line of the string and remove the PHP parts so it's one big string. Then do a find/replace for each element in the cipher. Then you take that new bunch of letters and numbers and base64 decode it. That's what they are doing. Plenty of sites online will do that.
Yeah laravel has something similar. 
Any chance you could guide me trough? Would really appreciate it
Presumably you'll use whatever you normally use to authenticate a user. Login I assume?
I wanted to take time to write a "proper" response. In hindsight - my response came off as pretty mean-spirited and I don't want to discourage you. I was referring primarily to the F3 framework linked above, but some of what I mentioned is relevant to your framework also. To extrapolate: &gt; I have never once used or really needed tests. I'm sure I will later, but it's simply work bloat for the kind of projects I am doing. Is it not? For your own code I think that's fine, but for something you want other people to use, tests provide me a way to verify that the application works correctly without having to rely on anyone's word. They're also a great way for you to avoid accidental BC breaks, which for a large framework can be a very big hazard. Generally speaking, no tests mean I won't consider using a particular library of piece of code. &gt; When you say "DocBlock" are you referring to the way I wrote the docs? If so, it was my first time. If I decide it's worth it, I'll end up writing different docs. There's a [de-facto standard](https://www.phpdoc.org/) for documenting PHP code that's used pretty much everywhere, including most (all?) the major frameworks and big OS libraries. In addition, there's also the [PSR-2 Code Style Guide](http://www.php-fig.org/psr/psr-2/). There's really no reason not to use both, since it'll reduce the mental overhead people have to do as they're picking up your framework. &gt; If I'm correct, there are only two singletons in the application. The App instance and it's controller property. Why would these NOT be singletons? I think that applies mainly to the F3 framework and some of its weird god classes they use. I didn't see anything that bad in yours. &gt; I honestly can't really tell what you're meaning about the bootstrap file. Could you explain the problem more clearly? (Appreciate the feedback already rendered.) In the case of F3, one of their issues is differences in capitalization between classnames and their respective files, IE "Barebones\App" in "barebones\app.php". In some filesystems, this will break PSR-4 autoloading because the filenames are case-sensitive. Personally I'd argue that you should be properly using composer instead of doing the equivalent of committing the vendor directory, but I realize that's an aesthetic decision since part of the selling point is that you don't need CLI access. Hope this was helpful!
Im not one to criticize Carmack, but he really should use better vars than x2, y, and I. His function names are also awful. Learning quake C back in the day was a chore because of this. The magic number should be commented, as it's short for what otherwise would be a self explanatory function of it's own.
 public canRefactorThisClassDeveloperById($id){ $this-&gt;count_of_ambitious_developers++; $developer = Company::getEmployeeByIdNumber($id); if( ! $developer instanceof Developer || ! $developer-&gt;experience instanceof ExperienceLog) return false; if( $developer-&gt;experience('familiar with bug in apache 2.1 ticket #123400') &amp;&amp; $developer-&gt;isNotLarry() &amp;&amp; $developer-&gt;talkedToDavidAbout($this, Codebase::REFACTORING)-&gt;datetime() &gt; new DateTime('last month')) { return true; } return false; } Agree.
Well mostly because it can get cracked easily ... and that php provided a way better API ... `password_hash()` &gt; MD5 and SHA-1 are emphatically poor choices for storing passwords. The problem is not their collision-resistance; it's that they're designed to be extremely fast. A modern GPU can attempt upwards of billions of passwords per second when brute-forcing through a list of hashes. This can shred through every possible eight-character alphanumeric password in at most a few days; that's with just one GPU. Ref: http://security.stackexchange.com/questions/61489/is-salted-md5-or-salted-sha-considered-secure
&gt; The speed thing isn't applicable for what I wrote there and the password hash function is deprecated lol Unfortunately many things become possible with cloud computing and GPU acceleration. A good encryption scheme is recognizable by the fact that even if I had that snippet above you pasted (which has a typo, btw, you run $password as a function, I doubt you intended that), I'd still be unable to crack your hashes, even if I had access to significant cloud/GPU resources. Another thing to consider is that many passwords are weak. So while brute forcing a truly strong 20+ chars alpha-numeric-punctutation-etc password may be implausible even with MD5, the typical weak passwords your users will be entering upon registration, like "cocacola" and the like will be quite easy to bruteforce through dictionary and hybrid attacks, when your hashing function is cheap to compute.
This is not true. The chance of collision with `md5` is still very low: 1/16^32 The reason why md5 is considered broken is that due to the nature of the operations it performs, it's very easy and effective for it to be implemented in GPUs. A domestic/cheap GPU farm can easily compute a few billion md5 hashes per second. `bcrypt`/`scrypt`, on the other hand, are impossible to implement efficiently in the current GPU architectures, which slows a decent farm to a few hundreds/thousands hashes per second.
Foreach and strpos to the rescue! $filtered = [] foreach($input as $row) { foreach ($row as $value) { if (strpos('LB1', $value) === 0) { $filtered[] = $value; } } } I may have got strpos the wrong way round because I'm on mobile.
Other options involve doing an array map and an array filter but sod writing that out on my phone
This seems more like more of a job for /r/phphelp than here. Though I can encourage you to look into `str_getcsv()`or `preg_match_all()`
One note is that this would give you the entire line, if the 'IB1' text is always the same length, you can do something like: $filtered[] = substr($value,0,8);
What a troll (╯°□°）╯︵ ┻━┻ But if you are being serious, then read [MD5 Collision Vulnerabilities](https://en.wikipedia.org/wiki/MD5#Collision_vulnerabilities).
36 possibilities, 32 times. The chance of two hashes being exactly the same is 1/36^32, no?
sorry it expired, here's a repost : http://slexy.org/view/s2B6iuFdKw
Decoded, have fun: http://pastebin.com/raw/fYsbqVPM It's as simple as running `echo base64_decode(strtr($kfkone, $rwetgzde) );`. The source is long but I assume it accepts post requests to mail arbitrary spam.
Adobe GoLive was discontinued in 2007. That means your website is at least 9 years out of date, yikes! Poking around on your website I notice your "admin" section goes to a different website (http://www.doorsseattle.net/) is this also owned by you? Do you have direct access to the MySQL? I'd suggest hiring a data migration expert and migrating to a newer framework. Without knowing more about your whole setup I really can't offer any more suggestion. 
I just printed out a copy (55 pages!) just to confuse my colleagues. 
Shopify ?
My bad, man. You are 100% correct. For some reason, I calculated the universe as a-z0-9, instead of a-f0-9. But it's 16^32, which is still a lot.
Have you identified the root cause here? Decoding the garbage they inserted isn't that meaningful in the scheme of things.
I'm not sure I understand your response. Perhaps I wasn't clear, or our definitions of a build server are different. My suggestion is to use a server or process completely separate from the shared host where the end result lives, in order to "build" the project into a manner that the shared host can support and deliver. The build server would do all of the leg work pulling in Composer dependencies, reorganizing directories (if needed), etc., and the end result would be something equivalent to the BareBones codebase you've put together here, without the need to duplicate third-party packages. Your build server/process would then send the files to the shared host via FTP (or whatever works). Of course this is just a suggestion. This solution, your solution, and many others recommended here all have their pros and cons. Perhaps some work better than others for you, for various reasons. Also, for what it's worth, the large majority of Composer packages do not commit any third-party dependencies to their own repository. Mostly because that defeats the main purpose of Composer, which is to utilize third-party code without needing to maintain it yourself.
&gt;I guess I'm wondering how does the author know this and where do you get this info from? Well ImprobableIdeas linked you a good resource on the changing internals of PHP, but also PHP is open source so one simply needs to look at the code to see what's different from prior versions. compiling from source is intricate in many situations, and it's not uncommon to need to make edits/tweaks/hacks to the source of a particular extension to build it against newer versions of PHP. I've personally done this many times in building extension in between even just minor version differences. plus also you can clone php off github, and then you have the commit log afaik.
Just use template engine... Like [Twig](http://twig.sensiolabs.org/). Or just simply use [alternative syntax](http://php.net/manual/pl/control-structures.alternative-syntax.php) along with &lt;?= $var ?&gt;
Thanks! Looks nicer than my two formats. Is this generally how you handle this kind of action or is there a whole other approach I'm not considering? Do you always avoid echoing HTML?
Template engine looks interesting, can it loop nested foreach's ?
This is my preferred method as well.
twig is the worst 
Yep, and it's extendable where you an create custom Twig extensions and functions if you needed to. http://twig.sensiolabs.org/doc/tags/for.html
PHP *IS* a template engine! Using another one inside it is just silly.
So the solution is to clone the repos and diff the entire code base between versions? I mean sure, but how are you going to have any idea what to do? A LOT of things changed. For example, the offending function `zend_object_store_get_object` doesn't exist in php7, and browsing the file that contained it in the latest php 5.6 release candidate reveals that it has been just taken out completely, there isn't some easy match from one function to the other. The commit log is... massive. How can you traverse all of that? There must be an easier way. 
PHP and Scotland :( Couldn't be better than this.
Hey /u/moving808s I work on extensions and would be happy to port it to PHP 7 for you! Also, you can drop me an email sean@siobud.com if you want to get a hold of me faster I don't check reddit very often just when I am bored.
[removed]
Linux VM on Windows? ;)
Using short opening tags (&lt;?) is discouraged, use the &lt;?php and &lt;?= syntax instead
Yeah, I thought about doing it in one line but for the purpose of the comment, I figured I would make it more verbose. Although, it's not as bad as having a an IF *and* and ELSE.
except &lt;?= $var ?&gt; is probably unsafe, you really need to make sure you're not outputting anything that could output javascript or any other yuckiness, so it needs more sanitizing. 
Have a look at docs.docker.com. I'm running laravel on php7 with a redis and mariadb container on Windows. Works like a charm.
Easiest is probably just to use the official installers. IIS is kind of annoying, but I've not set up Apache on Windows before.
https://blog.docker.com/2016/06/docker-1-12-built-in-orchestration/ Just happened!
Oh, thanks that sounds interesting. this is a setup I'm expecting to have.
Sent you a mail!
To make it straight: this is a fully functional approach, useful and usable, that you should use at the very least. But remember that you've been told already: this approach is insecure. So better turn to a dedicated template engine. Because beside security it has a lot of other advantages. While echoing html is just silly: remember these quotes and slashes you have to hassle with.
Thanks for the comments, much appreciated. While I agree to all points technically, I would like to simply state that the technical implementation I chose here is certainly wordpress-specific, but the idea is not. However you chose to implement this, it can be done anywhere (IMHO).
Wow you certainly spent some time on this. Are you using this in production anywhere?
I prefer storing json over very complex parent-child tables, if, and only if I am confident I will not need to search on the json data. I often use this for settings type stuff. Of course I think with Postgres you can search on JSONB datatypes.
May be firstly you should try to upgrade to 5.4, then to 5.5 and so on. This would require smaller changes. And it would be easier to find changes from 5.3 to 5.4 rather than from 5.3 to 7.0.
For real. He pretty much wrote all symfony components on his own, plus a data-mapper orm on top of it. As much as I love symfony, it's always nice to see alternative players like auraphp or this new project emerging.
There's always [XAMPP](https://www.apachefriends.org/index.html). The bundles are thoroughly tested together, so you know they behave nicely. If you need a different persistent storage engine (database), simply install it as an addition to XAMPP and disregard MySQL or MariaDB. Additionally, it is also fairly easy to change PHP versions by simply [finding the desired archive for Windows](http://windows.php.net/downloads/releases/archives/) with the `php.exe` file, and dropping them in your XAMPP installation. Remember to re-add and re-activate the modules you need. You can in fact make [Redis work on Windows](https://www.linkedin.com/pulse/using-redis-windows-php-shekhar-joshi?redirectFromSplash=true), but it's a cumbersome and annoying process, and with a much restricted feature set, compared to the Linux versions. If you want to develop in a Linux-like manner, there's always terminal tools like [Git Bash](https://git-for-windows.github.io/) (bundled with UI tool, as well) and [ConEmu](https://conemu.github.io/). This also makes SSH and SFTP a bliss, compared to e.g. [PuTTY](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html) and/or [WinSCP](https://winscp.net/eng/download.php). Good luck! :)
Meh, I wouldn't go as far to use a template library if it's not needed. Twig might have additional features out of the box, but it just switches one language for another.
Just don't forget to use htmlspecialchars() on every value, otherwise you can have serious xss issues. That's why I recommend to just use a template engine like Twig, they handle all this stuff for you out of the box.
then we'll all buy tickets once they are announced :) New conference, full of promise - you need to deliver if you wan't people to spend money.
Our first announcement will be made very soon. I encourage you to sign up for updates and spend your money when you're happy with following announcements. We look forward to seeing you there :)
There will be no live stream, but we are looking to work with some local companies to try and provide after event videos.
+1 for making sure the components are not inter-dependent! I love mix and match components from different frameworks.
I would do it nearly the same way, only few additions I would pref to do: - An extra new line between the description and the first @param - If an Exception is throw, I would add after @return as many Exception are thrown @throws xxxException - Because the words are different length, I would use tabs between each type of wording, so: @xxx TAB (4spaces) type TAB description if the type or the first @xxx made the description not all on the same rowline, I would add another TAB to all, so they are aligned at the same place. I know it's a bit unnecessary fine tuning, but I like it this way. It's clean for the eyes if it's liniear. Also if I put in a @return, the function it self has to return the given value, except for void. So in your example, every branch that exists, has to return a boolean and no case at all is allowed "not to return a boolean". So following would be "wrong": /** * ... * @return bool ... */ public function wrong() { if (true) { return true; } // If the if-case before is not "true", it never would return a boolean and this would be wrong }
File I/O is faster than querying a db, yet it's not a big issue to perform queries in every http request.
What's with the foreach loop?
Ha. It's a relic from earlier when multiple commands were run. As I expected to run multiple commands again in the future, I just left it there.
Thank you for the critique! I will definitely take to heart your suggestions and make the appropriate changes. Also, good catch on my docs. I fixed them. Not sure how I let that one slip through.
That's a good point. I too feel like it's outlived its useful life. It was more beneficial when Opulence also supported PHP 5.*. Now that it doesn't, maybe it is a bit redundant. I'll consider removing it altogether. Thanks!
Not presently. I see Laravel recently gained that functionality, and it is very cool. I'm sure it will come in future iterations.
Point seems to be that the article doesn’t actually say anything about detecting *malicious* users as the title suggest. Just folks using proxies. Following the advice there will block all users of the services, the good and the bad.
Maybe, but they need to be enable in now, so might not work on a host where you can't control the configuration.
I agree, it's a good question. I do not currently have a tutorial on using Twig or Blade in Opulence, but I assure you that you can use them. I've been more focused on documenting Opulence itself, but I will get around to showing how to use it with other libraries. That being said, to use them, you'd start with a [bootstrapper](https://www.opulencephp.com/docs/1.0/bootstrappers) to register them with the IoC container. Then, you'd [register them as a compiler](https://www.opulencephp.com/docs/1.0/view-basics#registering-compilers) for the blade and Twig file extensions. If anyone would like to contribute to the documentation, [it's open source](https://github.com/opulencephp/docs).
Thanks for answer! I would love to force myself and create one on my own, but Im too lazy for that tbh. I love the sketching before programming approach very much, basically TDD for creativity haha. But I will definitely give it a go :) I have a small project in mind for which this could work.
I'm just going looking over some stuff quickly, don't have time to check it out completely atm. But anyway congrats, you seem to have put a *lot* of work in this. The naming of the components is very inconsistent. Singular vs plural vs verbs. E.g. bootstrappers vs console vs routing. also, in the testing docs I see code like this: public function testPostingSomeData() { $this-&gt;post("/foo") -&gt;withParameters(["bar" =&gt; "baz"]) -&gt;go() -&gt;assertResponse -&gt;contentEquals("Nice POST request"); } That `assertResponse` property feels weird. not only is it strange to have this as a property, "assert Response" is also an action, so it should be at least `assertedResponse`
I responded to a similar comment [here](https://www.reddit.com/r/PHP/comments/4p2mjc/new_fullstack_php_7_framework_opulence/#thing_t1_d4hwijm).
Haha I guess that was a compliment? That being said, I've been writing PHP for 16 years and .NET for 10. I've never learned Rails ;) As for the IoC container, I'm not sure what you mean by it being "config-based". `$container-&gt;bindSingleton("Foo", "Bar");` and `$container-&gt;resolve("Foo")` is straight OOP.
Really nice to see an author taking constructive criticism positively. 
There are two major approaches for IoC: config based and reflection based ... and mix of two, which I still haven't seen in PHP. And if you learned about MVC from ASP.NET MVC framework, then it's a first generation Rails clone (well, at least up till version 3, when they started noticing the folly of that approach).
I haven't, it wasn't through the back-end as i use 2fa, probably an exploit in a joomla module i was using, have now replaced it &amp; updated everything for good measure... 
On the documentation note an improvement can be made in places like [registering view compilers](https://www.opulencephp.com/docs/1.0/view-basics#compilers). Looking through the project source and the docs I am not noticing any lead as to *where* to do custom registrations. I'd assume you do it within `{path}/bootstrap/http/start.php` probably in `$app-&gt;start()` but not certain. I'll test this out myself later to figure it out, but docs can be improved here for others.
Valid point. I've struggled with how to perfectly name this property. I wanted to segregate response assertions from view assertions, hence the two different properties. That being said, I agree it could use refinement. Let me think this over.
*cough* *cough* Red Hat *cough* *cough*
Twig does not have global variables, unless you tell it to.
Hindsight is a powerful tool.
Yes, really. They are fine on a property configured server and make template code easier to write and read without involving a template engine.
First of the PHP7-specific frameworks? Nice. From one long-time lead on frameworks and libraries: good luck!