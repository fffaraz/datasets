&gt; fanboys of X language point out PHP's weaknesses and ask what has PHP achieved Nobody asks this. People talk shit about PHP often, but no one thinks that it isn't used for anything. Nobody thinks software can't be built with it, either, so it makes no sense to rattle off a list of successful projects in it. You're basically coming up with a bunch of strawman arguments and knocking them down one by one. When people criticize the language, they aren't saying you can't do anything with it. Your comments about Python and Ruby also make no sense. Some casual googling should reveal several large well-known projects built using them. Hint: you're posting on one now. I can agree that a lot of the newest generation of programmers only go after the new and shiny stuff and forget that programming languages are just tools, but the way you're arguing (big sites are built with it!!) is something that should only impress non-technical users. And your comments about anonymous functions just make you seem out of touch with the field.
&gt;I'm torn on this, returning null for a non-existing key position in an associated array seems I think you're misunderstanding, the change isn't about non-existent keys, it's about non-existent arrays. The notice is thrown if you try and use the array access syntax on variables that aren't arrays or can't be accessed like an array. Their examples are equivalent to `null[0]` and `42['foo']`.
Like everything else, the "flavor" of MySQL you pick depends on a number of factors. Saying everybody should ditch Oracle MySQL simply because of Oracle is incredibly ignorant. Having worked in the MySQL team at Oracle for many years, I can tell you that the engineering and product teams are passionate about MySQL. Many people are still there from the pre-Sun days as well, though there's a lot of new blood too. Oracle's pricing is pretty well in-line with other enterprise support offerings. I do agree that more plugins could be made available to the community edition, but most of those aren't that useful for smaller deployments anyway. Oracle pours a lot into MySQL, and leaves the business unit largely autonomous. Yes, Oracle mishandled a number of open-source assets from Sun, but MySQL was not one of them.
MySQL is very much open-source.
You are completely right sorry, lost my marbles for a moment.
Because when upgrading the packages in Ubuntu they encountered many issues when using Postgresql, meanwhile the MariaDB/MySQL ones had a simple upgrade script that worked perfectly, and data corruption, disk writes, they made a post about this in their blog &amp;#x200B; [https://eng.uber.com/mysql-migration/](https://eng.uber.com/mysql-migration/) &amp;#x200B; Maintaining software isn't a thing of just installing something because it has X feature, you have to take EVERYTHING into consideration
That's funny. The very first program I taught my latest batch of apprentices was how to automatically log into wordpress.com using Codeception and Selenium. Tests are the easiest practical way to get newbies into helping your org. And it's super fast to learn, too.
&gt; Having worked in the MySQL team at Oracle for many years, I can tell you that the engineering and product teams are passionate about MySQL. Many people are still there from the pre-Sun days as well, though there's a lot of new blood too. You know, I actually believe you. I do. I can see the developers being passionate about MySQL. However, I really don't care, and here is why: When you're dealing with a product, you're dealing with its owners. Not the designers, not the IT who supports its infrastructure, not even the developers - the owners. You may be as passionate about it as you like, your opinion isn't worth shit when the big guys from above make yet another anti-customer decision. On the other hand, the developers of MariaDB are also passionate about their product, but here's the thing - they are not Oracle. MariaDB is developed by the MariaDB Foundation (not to be confused with [MariaDB Corporation](https://mariadb.com/), one of the main sponsors for the foundation), which is a non-profit [governed by representatives of the main sponsors, and also the founder of MySQL and MariaDB](https://mariadb.org/about/board/). I put my trust in those guys over Oracle any day of the week, any week of this century. And, if you (or at least the other readers) agree that by using a platform you choose to support its ecosystem, and contribute to its longevity (and by association - the decreased market share of its competitors), then it's pretty clear that unless some of MySQLs niche features satisfy your exact need, supporting MariaDB is almost always the right choice.
Used both, MySQL is better
Unless you're using `utf8mb4` everywhere, then you're just Yet Another MySQL Noob and don't know what the fuck you're either talking about or missing.
As recently as 2017, I could have sworn MySQL didn't have spatial features. It's why we went Postgres.
Anonymous functions have been in PHP for exactly ten years!~! Since 30 June 2009. You fucking imbecile! GTFO!
I don't quite understand "testing a PHPUnit extension..." are your tests written in PHPUnit? Couldn't you use `expectException()`? ```php public function testThatShouldFail() { $this-&gt;expectException(Some\Exception::class); $this-&gt;yourstuff-&gt;failAndThrowSomeException(); } ``` The code expected to throw an exception needs to be called after `expectException()` More info: https://thephp.cc/news/2016/02/questioning-phpunit-best-practices
`if ((int) $_GET['page'] === 1) { // this will never be true }`
Doctrine ORM has a similar functionality so you can enjoy this as well even in MySQL
I truly agree with what you said. Not just with databases also when it comes to programming language that some ignorant says python are better programming compare to everything else. but not unless you try out yourself then you can experience what are the benefits it has apart from everything else.
millennials are killing the eval in production industry
Make that 7.1, I think 7.0 was EOL same time as 5.6.
I'll add better explain query, range types, materialized views and postgis
I was just going to say No.... But the article was a pretty succinct read.
I have worked with both MySQL (5.6) and PostgreSQL (9.4). I'm more satisfied PG. &amp;#x200B; Pro of PG: &amp;#x200B; 1. JSON(b) support 2. transactional DDL 3. Rich data types (array, hstore) and index methods which support those data types. 4. No nonsense \`utf8\` and \`utf8mb4\` encodings ðŸ˜„. (Things could easily go wrong if you join columns of different encodings.) 5. better explain tools ( \`EXPLAIN ANALYSE\` will save your ass if the data set is highly biased) 6. length of \`text\` type is unlimited. &amp;#x200B; There're some minor inconvenience in PG. (E.G. you cannot execute other statements with \`CREATE INDEX CONCURRENTLY\`). And PG's permission model is more complex compared to MySQL. However, if you make the change, you'll get used to it. &amp;#x200B; Disclaimer: I don't write PHP. ðŸ˜„
You can do that in mysql too
You are correct, websites do not need much js. However, problem is in the name. We are not building websites anymore for the most part. We are building web apps. And the difference is that instead of serving pages to be browsed we are serving applications which attempt to mimic native application interactivity and options it provides. That's the goal of the web in general. To replace native apps. And there is no stopping here.
Asking if PHP is dead is a stupid and pointless question.
Mysql isnt free anymore? At least in java, you need a license from oracle to use the connector to mysql
I personally use Postgre, mostly because I am used to it more. But yeah, both are decent. It's also a lot about what you need to do, I often need to use MSSQL, MySQL, text files, whatever. If there's no need for you to swap to postgre, I wouldn't swap, in the end both are pretty similar. You can just try postgre out tho, maybe you will like it more. Also for postgre if you want a decent GUI I suggest using DBeaver instead of standard pgadmin 4.
If you're using an ORM like Laravel Eloquent where switching would be seemless, is it worth it for the better indexes and fulltext search?
No
I'm using \`utf8mb4\` everywhere.
Thanks :)
I have. I worked with MySQL, Percona and MariaDB.
Exactly. Liking something spans to all areas of human life. If a person likes something, let's say a programming language - that's usually tied to their mentality and they can be expressive using that particular language. Being able to express your thoughts and ideas is what's important. It's **way** less difficult to make it faster afterwards. That's why I never read language comparisons, it's always biased or faulty.
You can, but every DDL statement in mysql cause an [implicit commit](https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html), so you can't rollback
&gt;I see a lot of people dumping a link to that site the moment somebody mentions "php tutorial" and albeit a good resource it is mostly utterly useless for beginners. Interesting. I've not been a beginner for a long time so maybe I'm blinkered, what is the article/book missing that a beginner needs? It seems to tick all the boxes right from dev environment set-up/installation, all the way to deployment.
I agree with every word you said. It's always biased and faulty if someone said this is far superior than others that exists.
&gt;I was just going to say No.... But the article was a pretty succinct read. I was ready to roll my eyes at the normal blog spam then but this isn't a *bad* article at all. Just a shame about the clickbaity title.
&gt;**i often encounter error where changes made does not reflect to the public (it reflects on my development environment when i clear my cache), i would like to know how you manage this. my current dev env, is atom and mamp server.** There are probably 2 things to note here: 1. It sounds like your issue is caching with frontend items and the issue isn't PHP related at all. To solve this you can implement something called cache busting which is simply appending a version on to the end of your file names this forcing the server to serve a fresh copy of that file. 2. The fact you have totally different environments locally on dev and remotely on your development server is an age-old problem "it worked on my machine" thankfully this has been solved in a number of ways. By far the easiest is to use Docker, this will allow you to build everything you need for your project inside a container, then you can run that container everywhere it needs to run, dev, testing and live.
The article does not answer the question asked in the title - what future awaits PHP in about 5 years? Will the scope of application and popularity increase after versions 7.4 and 8?
Imagine yourself at the point of an absolute beginner, having never written a line of PHP (maybe all you've ever done is \_some\_ HTML and you're learning late at night in your bedroom because your job sucks and you want to get into a programming career). Someone gives you the link to [https://phptherightway.com](https://phptherightway.com). There's a lot of links and sections on that page, but you decide to begin at the most logical point, and you click 'getting started'. All of a sudden you're given a load of choices about macports, compiling from source, homebrew, etc, without any first-step guidance on how to choose which option to use. Then you get into a section about needing to find and set \`DocumentRoot\`, which then talks about unit tests and third-party libraries. You somehow manage to get through that and get PHP running and scroll down to the section on 'langauge highlights'. (remember, this is all in the 'welcome' section which is where a beginner is going to start). The first thing you're presented with is 'PHP has a very complete set of object-oriented programming features including support for classes, abstract classes, interfaces, inheritance, constructors, cloning, exceptions, and more.', and immediately underneath an introduction to 'functional programming'. It's all very bewildering if you don't even know what a variable is yet! I think [https://phptherightway.com](https://phptherightway.com) is a great resource for people who already have programming knowledge (either coming to PHP from another language or for people who've already spent some time hacking together some scripts in PHP), but from an absolute beginner's perspective it'd be an extremely daunting and frustrating task to read and digest it all.
Not if this question is a clickbait to promote a shitty online course.
Nothing to see here. Report and move on.
Do you know [https://cloudcraft.co/](https://cloudcraft.co/)? Is like a strategy game and calculates the costs.
thanks for sharing very helpful post.
This is an interesting project. Thank you for sharing.
That's where we fundamentally disagree. Especially that the goal of the web was to replace native programs. That's just a side-effect of its free and open nature. So again: If you want to build the next Gmail, indulge yourself in JS. Outside of that, you should use web tech the way it was intended: to deliver documents. Just my 2 cents.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
When I see the font I straightaway know this is just another trashy website. Sigh.
Transactional DDL alone is enough of a reason to prefer Postgres over MySQL (IMHO).
You realize you are telling me something's wrong and you don't tell me what? You add 10M per day (so I guess you multiply it by 30 for the form), then you add a page size (what is it?) and a response time (what is it?) and you are surprised by the result: what is it? And what do you pay today? Does that include the database and the assets? How are you hosting your app? Are you using Lambda already? Help me understand :)
I was trying to switch to PostgreSQL, but my application is to deeply coupled with the MySQL to the extent that migration would require rewriting some parts of application. If you can use MySQL 8.0, then there are less incentives to move to PostgreSQL unless you need better Full Text Search (which in my opinion is crap in MySQL) or the array types. MySQL 8.0 has already JSON support and CTE Recursive queries, that made a hell lot of difference to me. Historically PostgreSQL has much better track of record being a mature DB made for enterprises, it was always ahead of MySQL. Nowadays that distance is not that big. &amp;#x200B; For a standard web app I would use MySQL, unless you want to learn PostgreSQL.
Check GENERATED / STORED in MySQL.
So most companies do not retrain devs fit a new tool? MySQL didn't even have windowing function till 8th edition! Of course MySQL-only php devs don't know SQL.
You can't. Every DDL statement forced immediate commit. MySQL won't complaint either. Dunno if that changed in 8th edition
Hm Okay, I use mariadb server and access it with pdo and MySQLi, no problems within the last year.
I was thinking about the fact that for full-text search (which I heavily use in pg) have two types of indexes: GIN and GIST. It's nice to have more than one option so you can use the solution that works best for your workload.
For fulltext search I'd say yes.
Thanks for the info!
This is awful. Don't do it.
Great project! I wonder if one could use gtk-rs using this extension?
is this what you mean? &amp;#x200B; $handle2 = fopen(textFile, "w"); fwrite ($handle2,$output); fclose($handle2);
Try /r/phphelp
It is written : PHP Warning: fwrite expects parameter 1 to be resource, boolean given in /home/m/Documents/exemple/bb.php on line 31
It's not really relevant what the goal was. It is what we make it out to be. That's not to say that websites do not have a niche, it's doing quite fine really. Hence rise of static site generators. However, the platform itself is headed towards open platform for applications. And I would argue that's where we are moving for past decade. It's not chaotic, it's just rapid development towards providing open, accessible software through browsers.
sorry I missed the $ fopen($textFile, "w");
Except it doesn't include Concrete.
Thank you it works.
The only problem will be library portability. If you run `composer require vendor/c-lib-extension` on Linux, Windows, and Mac, what will happen on each?
Any sort of decent built-in support for concurrent and parallel programming.
I would like to see generics
My approach would be similar. Scheduled jobs in the DB, but I would keep multiple continuously running processes with something like supervisor, so you can scale up and down any time you want, instead of just a cron job. So, a single cron job that queues up jobs continuously, and there would be multiple workers that picks off and process the jobs in parallel. This way you arenâ€™t blocked by large jobs and can scale easily. This is really the extent of my knowledge in this domain, so if somebody had a better idea, it would be great to hear it.
Constantly releasing performance improvements.
I know people are trying to use GUI with Wasm (see Qt, [https://wiki.qt.io/Qt\_for\_WebAssembly](https://wiki.qt.io/Qt_for_WebAssembly)), and it runs in the browser. I'm sure it's possible to do the same for non-Web hosts. `php-ext-wasm` supports WASI, so I don't see any obvious blockers.
Lets be realistic, generics is in no way ready for PHP 8. There is an RFC but so far its been nothing but a 'feature request', no actual C code has been written. For PHP 8, I would expect to see Scalar Objects and Async/Awaits, I feel these two are at least more feasible at this point technically.
Generics and scalar objects. As far as I remember, PHP 8 does not yet have a headline code feature, it would be great if it could be generics. Headline implementation feature is pretty much certain to be JIT.
Please don't litter PHP with Async/Await. I had enough of that crap with node already.
Why not? This feature exists in C# and .NET languages too and it was great to work with it, much easier and cleaner to work with than long and complicated code for coroutines.
Ok that's good but where is the benefit in comparison to OpenShift, Heroku, AWS Beanstalk, Cloud Foundry etc.?
The blog post explains it better, but basically: *"It is the best way to host your Symfony applications \[...\] It tightly integrates with Symfony's best practices and development workflow to give you the tools to develop locally with comfort and deploy with confidence."* &amp;#x200B; So, for PHP developers using Symfony, it may be something to be considered.
With projects like this and FFI on the horizon, I feel like we are in the advent of a php revolution!
The ability to create extensions from PHP, instead of C.
While evaluating PG against MySQL don't forget the awesome PG extensions made available by community [https://pgxn.org/](https://pgxn.org/)
That Jesse Phillips guy is a complete moron!!!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
ddarrko, I can accomplish substantially cleaner mocks using anonymous classes. See: https://github.com/phpexpertsinc/MoneyType/blob/master/tests/MoneyTest.php#L48 ``` public static function buildMockCalcStrategy(): MoneyCalculationStrategy { return new class('asdf') implements MoneyCalculationStrategy { public function __toString(): string { return '0'; } public function getWithFullPrecision(): string { return '1'; } // ... } } ```
Genuine question, what's the benefits of server-side Wasm ?
This would be great.
no. n/a. n/a.
No, it WILL be great, it's not a feature I'm hoping for - we're getting it. Resources: https://wiki.php.net/rfc/ffi Project with working FFI implementation: https://github.com/ircmaxell/php-compiler (shoutout to Anthony, you're one of the best)
mb_string to be part of the core
Hi Let me re-phrase: - I run about 60 dual/quad CPU servers in a data center (DB and so on) - One small piece of what runs on those can use lambada functions (runs on demand, usually off, but huge spikes), so I was looking for how much would it cost/if it's worth to move it over (instead of adding 2 HA servers on stand by for it) - Between other things, I came across your calculator here. I added the stats in your calculator, and came up more than when I pay monthly for all 60 servers. Your AWS Lambda costs seems ok, but the API Gateway seems way way to much (bandwidth?). If those numbers are real, not sure why anyone with some traffic would chose it, since I paid ~98$ CAD for the bandwidth last month on this service and yours come up to almost 9000$ Ok, yes, prices are different in different places, but I got a project in Angola, Africa where we pay 1k USD for the up-link with bigger capacity than this would need, and you can't compare Africa to North america when it comes to internet prices...
You can use any programs that compile to WebAssembly inside PHP. Basic example: You need performance? Write a program in Rust or AssemblyScript, and run it inside PHP directly.
If you're someone who's working with CLI, then Swoole already exists. If you're working with PHP purely from web context, then question poses itself - why? What's what you don't have already and what are you having problems with?
I did. People don't care but I care. The \d, \l, etc.. is not worth it though, more of a set back memorizing those things. But I get by with googling what flag I need for psql. Other hurdle is remembering how to log into psql command: `psql -U postgres`, the flag have to be uppercase U. Taking a break and coming back to a project with postgresql can have a little bit of down time remembering the work flow. The workflow for mysql is much better but I think it's less secure by default? I only care in so far as PostgreSQL have better features, more active, and perhaps one day I may use PostGIS. The workflow is a small annoyance if you don't work with postgreSQL often.
Generics... plz...
Why would it be? Like, what was the thought process that led to this question?
OK I read it. All I read was a bunch of fancy cloud-speak meant to confuse the lesser aware developer. Look, design your own Docker stack and use AWS Beanstalk, OpenShift, Cloud Foundry, Google Cloud Platform or my favorite, Digital Ocean.
I said built-in support, where i don't have to depend on external code from a 3rd-party library/app/extension, regardless if i am in cli or web(i know about pthreads/pcntl, but i need something more lightweight, coroutines maybe... anyway). &amp;#x200B; As for why i would need it in web? Well, simplest thing would be when sending a contact email, i would just process that after the request has ended. Surely that can be done via queues, but would be much better if we didn't depend on such a heavy component for such a simple task.
Depends entirely on how you're using it, like most things.
Well it can be, if you allow your users to enter arbitrary URLs and then show them the output. The attack vectors are varied but generally along the lines of people getting access to things they would not normally have access too. For example you couldnâ€™t execute Webservice endpoints against AS services on an EC2 instance, or fetch content behind your firewall. Likewise file:///etc/passed is a URL (not an amazingly helpful one). Alternatives, well... solutions: * donâ€™t allow arbitrary URL entry * validate anything that people put in * be careful about how you display content that you fetch from remote sources
That's exciting!
Since the code is executed for every HTTP Request, how do you deal with the compilation latency ?
Transactional DDL/schema changes save lives.
Another consideration between MySQL and MariaDB (prefer PostgreSQL myself though) is that if there is a feature that Oracle thinks it can monetize by not building it as part of MySQL, it can choose to externalize it or put it into a non-open source option. MariaDB has no motivation to do it that way.
If developer is using it to only post data to a known url (and url doesn't come from website user), and that url is trustworthy, is it safe to assume that curl os safe? I know safe is a relative term, but still..
Generally speaking, yes. Just make sure you trust the source of the data and that it canâ€™t be used to exploit the remote somehow.
One of our seniors told us that curl is a security threat, and also asked us a question: Who uses cURL in 2019? Hence, the question..
I guess this begs the question of whether or not the compilation latency is eliminated if the file containing the program is preloaded using the upcoming functionality in 7.4.
I agree. However it's nice *something* is happening in the PHP world. Sometimes it seems the world has left PHP behind somehow.
Performance without needing more resources? I kinda expect to have to relearn PHP at this rate. How much of a difference is it going to be to 7?
&gt; but i need something more lightweight, coroutines maybe... anyway). You already have generators. You can create coroutines. &amp;#x200B; &gt; Well, simplest thing would be when sending a contact email, i would just process that after the request has ended. I understand where you're coming from. Technically, we'd end up with a built-in queue. However, this can be achieved without cooperative multitasking or queues. It's trivial and it does come with a downside, but it exists. The function you're after is [https://php.net/fastcgi\_finish\_request](https://php.net/fastcgi_finish_request) &amp;#x200B; If you're using Laravel or Symfony - these frameworks use the mentioned function (if available) to provide the terminate method to middleware.
Thanks..... Any alternatives you can think of, that, under the same circumstances mentioned earlier, can be considered safer that curl?
https://dev.mysql.com/doc/refman/8.0/en/atomic-ddl.html This is no longer true for 8.0+
Switching usually isn't a practical option once you're at scale.
cURL is only a security threat in PHP if the code surrounding it is poorly written. And plenty of people/projects use cURL in 2019 as it's a robust, reliable, and well documented way of doing things. Hell, as a quick example Guzzle uses cURL: https://github.com/guzzle/guzzle/tree/master/src/Handler
Not much, if any. It'll run faster, you'll get some shiny tools like JIT (and preloading in 7.4), but syntactically and feature-wise - there should be no breaking changes that forces you to re-learn PHP.
As you noted, while there are ways, there's also some limitations/tradeoffs/etc. This is what i would expect to avoid with built-in support.
You haven't answered the question.
I'm not a robot so I'm not compelled to view world through the prism of true or false, hence I *don't have to* answer in a linear fashion ;)
This is why I left mysql: 1. https://bugs.mysql.com/bug.php?id=11472 Triggers not executing during foreign key updates or deletes. This bug is 14 years old and has nipped me more than once. 2. https://dev.mysql.com/doc/refman/8.0/en/commit.html - See section where it explains sometimes transactions get "half committed" without an error (this happens in a variety of circumstances). 3. https://about.gitlab.com/2019/06/27/removing-mysql-support/ Various reasons pointed out here in gitlab about inconsistencies between ISO 9075 standard sql and mysql. #2 has costed me a job due to loss of data.
Hidden gems...I learned something new today. That may come in handy!
Oh man. I had no idea. I've been blaming Laravel for not rolling back failed migrations. The more I learn about MySQL the more I miss PostgreSQL.
Whatâ€™s the value-add on top of platform.sh? Why would I use symfonycloud instead of that?
You can compare http://www.sql-workbench.eu/dbms_comparison.html
There's tight integration with the Symfony ecosystem and quite a lot of custom features built on-top. I was part of the beta and absolutely love it. Excellent infrastructure at your fingertips - you basically just define few additional config files, push, and voilÃ  your project is live.
That's my point. 95% of shit companies and people make is nowhere near the scale required for this to actually make a difference. And you almost never go from "poor startup" to enormous scale overnight. So write your shit, and if it starts to take off, then make your choices for the future of your growing software. A ton of shit will change between launch and massive scale anyways. My overall point is that many people spend their time sweating these details when they should just be writing code. If you make it big, you'll have plenty of things to worry about and hopefully the money/resources to make it work.
Woohoo
Agree! Thanks a lot :) Also, guzzle( &gt; 17k stars) does validate the safety of curl
\+1 for performance!
Was coming here to post that article -- it has great details on differences between the two, esp about replication
PHP is not C#. I'd like to keep PHP simple. Async code is not the norm and is cognitive heavy. There's already Swoole for that in PHP.
OK. But what are the custom features? Presume ecosystem means blackfire / sec advisories? Could really do with a control panel tour video (as could platform.sh as it happens). I donâ€™t really do the console stuff. Im in the market for something like this, could be quite good!
This has nothing to do with PHP, take it to some general webdev or JS subs.
PostgreSQL is Oracleless . That one feature make is worth it.
PHP is not C#, PHP is not Java, PHP is not python, etc. So what? Its an evolving and improving language, it does not become C# just because it may use/borrow a feature from it. Actually Async Code is the norm and nothing heavy cognitively, how would you do it with Swoole then? From what I've seen with it, Id rather just use Async.
Scalar objects, goes one way to sort out the function name mess.
Video recording with Selenium is quite easy when connecting via VNC... &amp;#x200B; Yes, it does not come out of the box, but the given docker images already have VNC: it is up to the consumer to provide the scope of test (reads: start/end of the video recording).
Enums [https://wiki.php.net/rfc/enum](https://wiki.php.net/rfc/enum)
I'm a big fan of Postgres and have been using it (an mysql too, albeit less) for 10 years or so. Back then pg was much better than mysql, now a days it seems there isn't much of a difference. Especially from a developers pov, there might be some features they don't share. Custom types, hstores &amp; the pubsub mechanism in PG come to mind, but it might well be mysql has somethings like that too now? (I havent used mysql 8) One thing I know mysql has always had over pg is the different storage engines, innodb vs myisam. iirc Uber used pg for a fast key-value store, but the engine didn't handle it well _because_ it is not meant for such a use. Myisam has less relational guarantees etc and can handle such a workload better. There is plenty of discussion on that to be found. I'd say it is probably not worth switching unless you have very specific requirements/issues. That being said, if you are using some kind of database abstraction or orm, it should be trivial to switch. As a sysadmin there still are some notable difference with how to operate it, especially with regards to replication, backups/PITR etc. But that doesn't affect you as a developer much if at all.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Preloaded immutable state
I would love to see scalar objects. Nikic wrote an [extension](https://github.com/nikic/scalar_objects) a while ago, maybe this could be incorporated in the core?
&gt; Who uses cURL in 2019? From https://curl.haxx.se/: "[curl] is the internet transfer backbone for thousands of software applications affecting *billions of humans* daily." (Emphasis in original)
Why?
&gt; Actually Async Code is the norm It's not. 99.99%+ of code is synchronous and THANK GOD it's like that because async isn't easy nor required most of the times.
libuv integration to support async/await, generics and scalar objects
Its just your opinion, for me and some other developers, Async is easy or at least, easier and more intuitive than Swoole. Even if Async/Await is introduced to PHP, you can still have fun with Swoole if this is your preferred way of writing parallel code. No one forces you to use Async, but it provides a much better option for the others like myself.
Theoretically less painful than compiling the library natively on the server.
You should stick a note to HR that your company is looking for a new senior.
youre right. wget/wput is so much better /s
You can already do that...
I wonder what you backend software is. Is it puppeteer with a headless browser stack or is it a selenium grid? &amp;#x200B; But endtest is shit. Only to say it again for seo purposes. endtest is shit.
You have a point, yet I think itâ€™s misleading. The two DBs are different on fundamental levels. Choosing one or the other has immediate and long lasting consequences. But as you say both do their job for 95% of the use cases, and will excel in their own niches. Also switching a running project is 99% a no-go. Itâ€™s just pain and suffering. If someone has a specific case that is more painful than hell, sure theyâ€™ll do the switch, but they wouldnâ€™t be asking the question anyway. Having used both a lot, Iâ€™ll vouch for Postgres on any new project, even considering the effort to relearn a lot (the CLI, the engine specifics, the tooling, some syntax, a lot of stuff that was allowed under MySQL that doesnâ€™t fly in pg, etc)
It doesn't matter if async is less complex than Swoole. My point is asynchronous code is a rare requirement that adds complexity and PHP's beauty is simplicity. If you add Async/Await to PHP then libs and team members will abuse it and you'll have to deal with needless async code weather you like it or not.
Enum, language based annotations (start by #, @ or C++ style), overloads (w/ operators would be nice)
Its easier with ffmpeg + headless chrome.
I'm still hoping for named parameters. It would be useful since PHP doesn't support overloading and sometimes you'll end up with functions and methods with a few optional parameters.
Still praying for core supported async/await.
My hope is for an extended security support version. The short EOLs of the 7 series is beginning to be quite expensive for companies.
&gt; Anyone made the jump from MySQL to PostreSQL? I made the switch over a decade ago, although to be honest I still have a few MySQL servers around from legacy projects. My reasons for switching were due to very technical requirements, and a growing concern with regards to Oracle inside our company. I'll leave out the Oracle bashing, since mariadb exists, and stick to the technical. &gt; I've heard lots of people say MySQL ain't that great. I haven't kept up to speed as much with MySQL features and issues as I have with PostgreSQL. Back when I switched proper support for foreign key constraints was wonky at best to the point where anyone could break it, and I had found several issues with replication at the time that were a major concern for me and required constant vigilance. I'm sure that as time passed many of the bugs have been ironed out, and most of my concerns from back then have been mitigated. Back then one of the major concerns with PostgreSQL vs MySQL was that MySQL in general was the faster of the two, but PostgreSQL at the time was generally the more consistent behaviour-wise of the two. PostgreSQL also required more maintenance, but this has somewhat been mitigated nowadays with autovacuuming and how it works. &gt; I've never used anything else so I wouldn't know if that's true or not. In truth, you should look at the requirements of what you're going to be doing with it. See what features are a must and evaluate their availability and functionality in both. If you're starting a new project it's the ideal moment to make that list of requirements, and do some reading and testing. &gt; from MySQL to PostgreSQL with respect to PHP web applications? I can't speak for PHP, but over the years I've been working with various environments, ranging from Java to Python to a bunch of shell scripts and perl code glued together with all the hopes and desires of the world, and in general the RDBMS has rarely been the problem. You'll get trade in a few quircks for another set of quircks, and management is a little different. &gt; Was it worth it? For me it became pretty much a requirements after a while. I deal with a bunch of GIS data and the PostGIS extension takes the pain out of most tasks you can think of in that field. With MySQL it always became a lot of hacking and working around issues. &gt; Was it hard? On projects from scratch I'd argue that the hardest part was more of a people problem than a technical one. Some things that wouldn't throw an error in MySQL would end up throwing one in PostgreSQL, and this sometimes confused developers. After a few months people adapted and I had to do less babysitting. Nowadays a lot of projects abstract the database behind an ORM, think SqlAlchemy for Python or Hibernate for Java, I'm sure PHP has a few ORM systems, so generally people get less and less involved with the minutiae of the backend RDBMS and focus more on code. I tend to do the whole RDBMS stuff together with someone else, and work out the ORM mappings so other devs can focus on working with those classes. On legacy projects I've often opted to not switch because there would be major refactoring across various codebases (especially if there's no ORM involved) and that costs real money (and we're not even talking about the downtime cost then). It's really up to your company to decide if migrating and refactoring and the cost that goes with it is worth what you might gain. At some point the whole exercise starts burning manhours and money, and the gains don't measure up to that, so it's not worth it. Better to let the thing go through it's natural lifecycle and fizzle out at that point. Just keep a good maintenance cycle going, and think 5 years into the future (if you can, nobody has a crystal ball). &gt; What were the biggest hurdles? From an operations point of view, master-slave in hot-standby failover and verifying that it all stayed consistent as advertised in the manual (it did, and has done so for the past 10 years without any major incidents, but verifying that it does what it says it does on the tin makes you sleep well at night). It's become a lot easier since then, but nowadays my company has started moving new projects towards AWS, where you don't have to deal with all that except "tick the box and hand over the money". Properly estimating and improving performance were a big hurdle initially but once you're going down that road you'll spend so much quality time with the extensive manual that you'll start to know the thing inside out. None of the projects I did with MySQL ever needed to scale to what I've been doing with PostgreSQL so I can't really compare either. My best advice would be: consider the featureset of both, and if you've got a new thing coming your way try both options with lots of fake data and see whichever works and performs for you best under a load that represents what you'd typically see. FWIW, ever since I've started with PostgreSQL there's nothing left I'd explicitly pick MySQL for, while due to the whole GIS thing, the opposite doesn't apply: MySQL no longer offers me anything in my work that I'd pick it for over PostgreSQL. YMMV. Look at your own use-case, and evaluate. I'm currently using PostgreSQL in a setting where there have been ~150,000 concurrent users knocking on a set of webservers and it happily did its thing (full disclosure: those 150K users often hit a cache before they got any data directly from postgresql, at which point we cached that, and so on and so on, LRU style invalidating the cache over time, with fairly predictable queries). None of this involved PHP, but we're talking RDBMS shop here anyway.
Neat project. How does the project manage to not require Rust? I ask because still see `Cargo.lock` and `Cargo.toml` in src.
That it doesn't break all my stuff.
Scalar objects please !
Why? Stupid developers can still do stupid designs and choices even when constricted, even while wearing a belt *and* suspenders.
&gt; Digital Ocean Yes and deploying via docker-compose in production. I did not expect anything else
I have never thought to use anonymous classes. It is an interesting approach. I wonder about the benefits though. Do you have any concrete examples of how this approach is beneficial for you. &amp;#x200B; I like that I can require functions to be called (or not called) - this can be achieved I guess using counters but at some point I am basically just writing my own pseudo-mocking library. &amp;#x200B; ps I think you commented on the post as well on [dev.to](https://dev.to) ! thanks for the feedback &amp;#x200B; pps - nice codebases on your phpexpertsinc
\+1 for generics. There are some people making the case for simply supporting the syntax but not actually doing anything with it at runtime and just let the IDE and CI tools check it. I still don't know how I feel about that, but it would be something.
That's a good point, but so is MariaDB, for people who want or have to remain on MySQL.
Yeah, but being decent and dragged down by the engine on joins ain't helping chief
Possibly, but I test on all browsers :)
Are the people working on it having persistent (across requests) storage for the compilation output? e.g. like the PCRE extension does?
Generics, enums, annotations
Generics
Since MySQL added CTEs, Window Functions and JSON support I find no major reason to prefer PostgreSQL over MySQL. But a few years ago, those were the reasons why I switched to PG.
I switched a few months ago. Biggest reason is better types in the client and better error messages. The php mysql client gives you not-bad errors OR integers-not-converted-to-strings (depending on the prepared statements option), you can't have both. Worst part was adapting a few non-standard functions to the PG equivalent and updating to the different quote style for db entities. Performance seems a lot better in my integration tests, although I merged index and table creation as part of the migration.
For why you might not want to use MySQL: ["Do Not Pass This Way Again"](https://grimoire.ca/mysql/choose-something-else)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
With videos? I want to see that :O
I heard in a recent podcast FFI might be pushed back to 8.0. But again like you say, not a headline code feature. I would lose my shit if we could get scalar objects and generics.
Well the same could be achieved with docblocks, so I dont see the benefit of supporting the syntax until full support is ready.
(facepalm) Newer SQL versions aren't for progressively more noobish developers. They increase expressiveness and/or power of SQL.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You can have persistent resources, so that you donâ€™t need to compile the module every time. See the Module constructor.
Cargo files are kept for debugging or development only. The extension is in the src/ directory.
Great but a mistake right in the title. Event Sourcing is a pattern, not an architecture. Architecture implies your entire domain is using it, which is almost always a mistake.
Associated array destruction
&gt; https://bugs.mysql.com/bug.php?id=11472 being fair, Uber was having lots of trouble updating some rows a lot. the MVCC of postgres (that actually is very useful in most of cases), was costing them a lot in write amplification. Honestly I expected uber to rapidly updated data outside MVCC and thus postgres, probably in a redis. but they simply regressed to mysql
you got to know uber moved: mysql -&gt; postgres -&gt; mysql so based in their existent code, there was a lot of bias pro-mysql
write amplification was the technical cause, more data here: https://old.reddit.com/r/PHP/comments/cdgxxu/anyone_made_the_jump_from_mysql_to_postresql_it/etxjdl9/
From top of my mind: MVCC, Transactional DDL, PostGIS and concurrent indexing
Is `echo` a threat? Try this in your code `echo \`ls -lahahaha\`` [panic-mode] Wow... You can execute bash with echo? Yup. Let's ban all instances of `echo` in our codebase!!!! [/panic-mode]
Transactional DDL, PostGIS and very good MVCC
I have defended Postgres many times in this thread, but there was one time I got in the Mysql side. you get a huge table let's say 1m rows, you start thousands of workers updating many rows at random and in blocks (i.e. each block updating let's say 100 rows at a time) Mysql worked and Postgres got stuck. later I learned there is a way to specify postgres in which order to realize an update to avoid deadlocks (even having MVCC) This was like 4 years ago. honestly I would have to reinstall both of them and run the test again, but that time mysql worked without a lot of fuss and postgres got many deadlocks. Maybe I made my benchmark wrong, any experiences like that? (P.S. daily user of Postgres here, love it and been using it for 10 years)
According to: http://blog.dumper.io/showdown-mysql-8-vs-postgresql-10/ "Surprisingly enough, it turns out that the general perception still holds; MySQL works best for online transactions, and PostgreSQL works best for append only, analytical processes such as data warehousing." Not that I agree (I haven't read the full article), but maybe you should
Definitely want Annotations and Overloads would be fantastic too. Named parameters would be also viable in the event overloads wouldn't be done.
This. Guess the seniour has &lt; 5years experience and/or does not know much about programming in general. Curl? Wtf...
The story has some worthwhile followups: https://www.2ndquadrant.com/en/blog/thoughts-on-ubers-list-of-postgres-limitations/ https://thebuild.com/presentations/uber-perconalive-2017.pdf
Fixed the link for you: https://curl.haxx.se
The first couple of paragraphs are really dogmatic and are putting the reader on the spot. It demotivated me to read beyond the first chapter and scanning the rest of the article. Not because I fit the profile of what is being shamed, but because it wasn't a pleasant read and the dogmatic nature convinced me it wasn't going to address the topic from more than one angle. Patterns should be tools, not shoe horns. How to use tools should be open to interpretation of the reader. Giving guidelines and a proper use case, maybe a concrete example, are that of an enlightening article.
Would be great to have a proper standard for an event loop so we no longer have like 4 competing, incompatible standards like we do now.
Is this something like structs in C?
OK thanks for the info. First of all I have edited the form so that CloudFront costs $0 if you don't serve assets (i.e. for APIs). That doesn't change the API Gateway pricing though, but still it's much saner. Now I've tried to replicate. With 10M a day, that means 300M a month. I've counted 200ms. That means around $1k for AWS Lambda. Now with a 3kb average response size, it's $1k for API Gateway. That's nowhere near $9k which is weird. To get to $9k it means you have 300Kb average response size, which is huge. Is that correct? (hey maybe it is, just want to make sure it's not a mistake). That means 90Tb of data transfer every month. I did a more exact calculation for 90Tb using [detailed prices here](https://aws.amazon.com/ec2/pricing/on-demand/) and it comes up to $7800 (I don't get into those details in my calculator). Now that being said, and considering there is no mistake, ALB is a much much cheaper option for APIs/websites at scale. With your example [I did a simulation](https://aws.amazon.com/elasticloadbalancing/pricing/) (10M daily, 300kb average, 115rps, 2Gb/hour, etc.) and the total was $228/month. Sounds much better. I should eventually add ALB into the calculator, but that would be much more work. Maybe I can add a warning though. I hope that helps anyway!
Do deployments have the same behavior than platform.sh?
They're all BC with previous 7.x releases. Even the 5.6 to 7.0 change only broke things that had been long deprecated anyway. The way I see it, it should be simple to keep up with PHP upgrades if done one at a time or even a couple of point releases at a time. The real pain sets in when a company stays on an old version of PHP for a long time and is then forced to contend with a massive upgrade of several releases. (e.g. the Wordpress world this year, which is long overdue for upgrading.)
MySQL SERIALIZEABLE is not really SERIALIZEABLE while Postgres is as far as I can tell. Assume you have id be an auto incremented column. The following will work as expected in Postgres (possibly failing, but it wonâ€™t silently do something nasty) while it may return a record committed by another tx in MySQL. INSERT INTO TB (col) VALUES (42); SELECT * FROM TB WHERE ID IN (SELECT MAX(ID) FROM TB); COMMIT; The problem is that MySQL does not put any sort of lock on the end of the table. While this isnâ€™t the best way to get the ID of what you just inserted, itâ€™s probably the only way to do so without relying on your database driver.
Not really, enums are immutable, final collections.
Better docs, this is abnormal to find solutions from dusty 10 years comments. More CLI stuffs. Some really working bindings for system's UI's, php-ui, GTK, glade, anything really. **Built-in** login sytem easy to use with strong cryptography, jwt or something. Built-in SSL websockets bindings, easy to deploy.
Enums, Generics, Traits with Interfaces
No. This will be used at all sauces and will clog up more than give.
Just use IDE?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Sounds about right, had 120tb about of transfer, on a 1gbs uplink. I pay 450$ cad for 2 of them ( for high availability ) Sone API replies can get to 1Mb.. average about 250-300k. Could seems expensive...
This is better supported with a standard interface. I don't really need to care how my event loop is implemented, so long as the API is standardized. It could even remain backward-compatible.
I'm using an IDE but I would still prefer to write something like this: htmlspecialchars($string, double_encode: false); instead of this: htmlspecialchars ($string, ENT_COMPAT | ENT_HTML401, ini_get("default_charset"), false);
I saw an RFC with no updates for this from 2016. It'd be a massive game-changer, that's for sure. So much of PHP is defining collection types or iterators, so while you can type the single values you put in them, it's extremely limiting not being able to say what your generator/promise/array/custom collection returns. Imagine `makePies(iterable $ingredients): Generator` vs `makePies(iterable&lt;BakingIngredient&gt; $ingredients): Generator&lt;Pie&gt;`
What
It is? It's just not enabled by default?
Yikes, learning PHP right now. Had no idea overloading wasn't a thing. I started with C#, but there seems to be a lot of unnecessary confusion regarding development options, so I'm leaning towards PHP now. I don't like the PHP syntax as much and the lack of restrictions, but the community seems to be more open armed and easier to dive into with it being open source. I'll likely revisit C# at some point for items outside of web development.
too much websauce
It's an okay system with TypeScript, which is a superset of the language designed to do literally nothing but be checked at compile-time and removed from the JavaScript you build. That's something of a special case, since ecmascript is here to stay and there are many different runtimes to support, but in PHP you're in control of the runtime and could easily add types as a new version. Since PHP is also a scripting language, you'd certainly get many of the advantages to generic types from your tooling without it needing to have any say at runtime. In languages that compile to machine code (e.g. Rust), you care much more about the generic types since they'll make the compiled code much more efficient (e.g. you can predict how much memory you'll need to allocate more accurately, or ignore certain variables/properties completely if you know they'll never be used). Those things don't matter much in PHP. Now I have seen projects to compile TypeScript (usually to wasm), because if you can type than you can add your primitives (like unsigned-8-bit-integer instead of just a variable), which means you could define a subset that's compilable. No reason we couldn't eventually have a fast, compiled subset of PHP. It could even make client-side PHP that runs faster than JS, since you could compile to WASM without having to carry over the whole PHP runtime like you do now. It could keep PHP relevant as more and more processing goes client side or distributed.
Even after so many years in php, I forget this on nearly every instance I setup.
I've switched multiple production projects between database types due to licensing or changing platforms without any issues. Can you cite some examples of a situation where choosing one over another significantly hurt a company or project?
&gt; simplicity I disagree that PHP's beauty is simplicity, at least from the language feature's aspect. The best thing about PHP is that its by far the easiest to deploy. The language itself has continued to evolve and become more powerful with features. Yes adding async/await introduces a little bit of complexity, but you can say the same about most other things like namespace, trait, closure, etc, and yet they make it to the core of PHP. Perhaps asynchronous code is a rare requirement for you, but it can be essential for other developers. Again no one forces you to use async/await if you dont want to use it, or your project does not need it. But it will make the lives of other developers vastly more enjoyable.
- automate migration - try it for a week - collect data for your specific use case - decide based on data, not personal unrelated opinions
We all lean over and inspect Davidâ€™s card and Price quietly says, â€œThatâ€™s *really* nice.â€ A brief spasm of jealousy courses through me when I notice the elegance of the color and the classy type. I clench my fist as Van Patten says, smugly, â€œEggshell with Romalian type...â€ He turns to me. â€œWhat do you think?â€ â€œNice,â€ I croak, but manage to nod, as the busboy brings four fresh Bellinis. ___ ^(*Bot. Ask me what was on the Patty Winters Show this morning.* |) [^(Opt out)](https://www.reddit.com/message/compose/?to=botrickbateman&amp;subject=Opt%20out)
&gt; Perhaps asynchronous code is a rare requirement for you No, it's a rare requirement in general, not just for me. Even more so in PHP use cases. Where do you get this idea that asynchronous code is common?
Talking about a dozen of PHP projects that were developped and maintained 2~3 years on MySQL Switching DB would have had impact on: - optimized queries: On any significant pain points we wrote DB specific queries to get better results than what the ORM would make. These queries would need to be rewritten and retested, and as they were core parts itâ€™s a PITA in itself. - specific behaviors: we werenâ€™t on strict mode on MySQL, and weâ€™d have to find each and every part where it breaks when thereâ€™s hundreds of columns. - tooling: all the scripts and tools we used to manage backups, data sampling for the dev environements, replication, schema migration management, monitoring and alerting tools etc. need to be revisited - pooling profiles, infra optimisations: we used pgbouncer in front of postgres, and on the project we tested we didnâ€™t get the same performance profiles. We would have needed to get deeper down on what causes the difference, and adjust in consequence There must be stuff I am forgetting, I think it boils down to how much is invested in optimization. The more it is, the more painful it becomes to switch to something else. If youâ€™re used to switch a lot, I think it also helps a avoiding anything specific from the start, and keep tooling and stack management as generic as possible. But to be honest, I think itâ€™s way easier to stick to mostly open source and/or well maintained platform/tools and not have any obligation to switch at any point. What were the specific issues you had with licensing ?
I have no precise pricing to give at the moment. But expect an expert with rock solid credentials to charge you at least 1000$ per day. And reading through 75K lines of code will certainly take more than a day, even a week. So I definetely think itâ€™s not worth it.
It's a cool project and all, but I don't think we need a post on reddit for every minor version release.
I was under the impression that it is platform.sh underneath (not necessarily a bad thing), but what I canâ€™t tell without signing up is how divergent it actually is. Is all the value add in the console client? Or have they got some more secret sauce going on?
They didn't say it would cause significant harm, but it's pretty obvious that the database you _do_ choose can have significant impacts on your project's architecture and design. How large were the databases you moved and how many people are on your team? It's obviously not impossible to do, but one of our databases was 26TB and moving it would've been an annoying effort for our small team (not to mention lost time to work on critical tasks) so we wouldn't even think about this unless we absolutely had to. Uber semi-recently (3 years ago) actually migrated from PostgreSQL to MySQL and their write-up explains their reasoning: https://eng.uber.com/mysql-migration/
Bad bot
Tens of thousands of dollars for a code review of 75,000 lines. Of course, chances are the bit you need to complain about is a tiny fraction of that, but it would still take a certain amount of time to locate it without prior knowledge. I'm afraid you're out $70 and the more time you spend on it, the more you lose.
Have you wasted more then $69.69 worth of your time already? will it waste more than $69.69 worth of your time in the future?
[removed]
JIT optimization for long-running apps (Swoole, ReactPHP etc) and machine learning (PHPML).
I don't suppose there's a credit card anywhere in the loop? You might have better odds with a chargeback at that point. To be honest, if this thing doesn't work at all there should be complaints all over the net about it. It *sounds* like it just doesn't work for you. What's the plugin's name, out of curiosity?
Right, just like C++ inevitably increases expressiveness and power of programming? Throw more features in, and use more features to solve the problem, and it automatically becomes better? I think the desire for more (and modern) conformance is something that mostly, more than anything else, only scratches a specific itch in someone's idea of the perfect platform, rather than helping to become the perfect tool.
the plugin is mycred, and the base plugin works. It's the premium addons that are lacking badly. They are lacking so badly that the developers took the demos down off their own websites and the documentation is severely lacking. When I pointed this out to paypal they responded with the message that I should pay a professional to evaluate the software in detail.
Immutable/read-only public attributes.
Ouch. And not in Europe or America so good luck hitting them over the head with consumer protection laws... all I can do is commiserate. Taking the demos down is... telling.
Not telling enough for the geniuses over at Paypal it seems.
eio/php-uv in core
An enum is basically a type-safe integer value. enum Color { Red, Blue, Green } fun draw(color: Color) { ... }
What if we add some preprocessing gnocci to soak up the sauce?
Mehhh, just slows me down. I guess I'm the opposite, I don't trust any developer that leans on a debugger crutch to solve their issues. Teach a kid how to var dump and they will eat for life! Teach em how to xdebug, and they will squirm, slowly. Only time Ill enable it is if I'm trying to walk through some overly abstract 3rd party lib, jumping all over the place in Enterprise javaesque fashion, which doesn't happen often...I'll John Henry any one out there any day.
if 99.99%+ of your code is synchronous, you could just ignore the async/await functionality if it was added... It's almost like it wouldn't impact you...
It wouldn't take a day to see that it's crap - but it'd sure as hell cost more than $70.
Deprecation
 75,000 lines for a fucking PHP plugin? What does it do wtf
Wow. I hadn't seen that one before and I think it would be great. It seems pretty well thought out. I wonder why it hasn't moved since 2015 (or been edited since 2017)?
What would be a good example case that this would be good for? Sorry, I am kinda new to PHP
Since you seem to be a bit in the know on this...I'm wondering if you can enlighten me. Before I did more RTFM and learned Imagick better, I was considering building a PHP Gifsicle extension. The goal being a more secure way to utilize Gifsicle in PHP without using the commonly disabled shell_exec (and family) functions. Long story short, I first tried using Zephir and just straight up using PHP. However even the compiled extension still utilized the disabled methods. It made enough sense when I ran into the issue - but for some reason I had expected the compiler to translate the PHP function to a lower level abstract that didn't rely on the interanl PHP method. So the question is, will the future of FFI and project's like Anthony's help circumvent the "problem" I discovered?
When have upgrades broken all your stuff?
Native asynchronous capabilities that rivals swoole php.
Pretty much the same reasons as above here, but with the addition of: 1. LISTEN/NOTIFY for triggering/listening to data change events 2. PostGIS extension for geospatial workloads 3. Materialized views 4. Row level security My roots were in MySQL/MSSQL, but doing more geospatial/event driven work these days tends to push me toward PG every time.
Especially these days
Nice!!
Sounds like a wordpress theme meant to cook your dinner, automatically assemble a car and launch a rocket to mars. Because why not.
I tossed this as a proposal for an RFC, but there was conflicting alternatives. Would be nice to have immutable structs.
How about tail recursion?
Real annotations.
&gt; How much is it going to cost me to get someone to go through no less than 75,000 lines of code to find out why this doesn't work and explain it in words paypal can understand. I'll do it for $45,000. /s
Man!! You should be on the php-internals team with this great code! [completely serious!]
Job security?
Did you validate the results? When you say MySQL "worked", did it just ignore possible deadlock conditions, or did it correctly observe the semantics of the test?
Is that just very clean pseudocode, or an actual language?
This is very similar to Rust, except `fun` would be `fn`
-1 for generics. They make for some messy and hard to follow code.
I even submitted a bug (to percona, didn't bother with maria) which basically has been ignored for years. [https://jira.percona.com/browse/PS-3414](https://jira.percona.com/browse/PS-3414)
Without deep-diving into the subject..compiled vs interpreted.
1. Named parameters 2. Or method overloading 3. Enums 4. Scalar-fucking-objects I would also add "standardizing the language", but I doubt that after all this years they ever will swap haystack-needle to needle-haystack where needed. Or rename str\_action to straction or vice versa. Hopefully scalar objects could alleviate this issue, so I'm hoping for that with all my heart.
Of all code, not just mine. And I already stated what would happen if async/await is added to PHP. If you read above you'll see how it will impact everyone negatively...
&gt; Of all code, not just mine. I'm curious how you came to that conclusion. Can you point me to your data? I'd love to read it. &gt; And I already stated what would happen if async/await is added to PHP. Can you point me specifically to your conclusion which illustrates how adding async/await to PHP will negatively impact people who don't use it?
Mostly adding bloat? Certainly unpopular opinion but I'd honestly rather the language be removing things than adding things. Learn some things from Go, namely restraint.
Data? How about all PHP code to date? &gt; I'd love to read it. Start here: https://github.com/symfony/symfony Or here: https://github.com/laravel/laravel Don't forget all their dependencies. &gt; Can you point me specifically to your conclusion which illustrates how adding async/await to PHP will negatively impact people who don't use it? I already did above. For a developer you need to practice reading and comprehension: &gt; If you add Async/Await to PHP then libs and team members will abuse it and you'll have to deal with needless async code whether you like it or not.
&gt; Data? How about all PHP code to date? Data which backs up your assertion that 99.999% of _all code_ is synchronous. &gt; I already did above. For a developer you need to practice reading and comprehension: No I just reject your fear mongering as poorly informed dribble.
Why do you call it a rare requirement? From what I've known in the web development in general, its quite common for some use cases, as you can see in async database access in ASP.NET and async IO in Node.JS. Perhaps its uncommon in PHP, but thats because PHP lacks native support for Async/Await so the developers who need this feature have moved on to other platforms that support it. Python and Rust have also added Async support in their recent versions, and its not without reasons. PHP is already behind many programming languages for Async support, its about time to bring it up in PHP 8 so we can keep up with the other mainstream languages.
100% of PHP code doesn't have async/await. If that's not data for you then I don't know what are you doing on an engineering field. And you actually asked something which I already answered. If you agree with said answer is an entire different story. I'm blocking this unproductive conversation and wont be notified or able to see any response because your arguments are rather obnoxious and your reading skills are poor. I hope you put more effort when reviewing teammates codebase. But mostly because you're boring.
Click "Show filters panel", enable "swoole" on the right side, click "Apply changes" at the bottom, and you'll see somewhat different picture: https://www.techempower.com/benchmarks/#section=data-r18&amp;hw=ph&amp;test=db&amp;l=zik071-f
Awesome I have never heard of swoole. Why is it so much faster than raw?
yeah thats actually one important reason to make scalar objects, alongside with the more cleaner OO interface. The mess in PHP function names is impossible to clean up due to the issue with backward compatibility. Introducing scalar objects with standardized and consistent method names will be a neat solution to this problem, as the old messy functions still exist and work, but developers will gradually move onto scalar objects and follow best practices.
From their website: "It is written in C language without 3rd party libraries as PHP extension." Framework itself is a PHP extension written in C, actual business logic is written in PHP, and also there is no web-server etc., and thus no overhead on that part.
MySQL will do you just fine for most use cases. The moment you start to need any of the following - Postgres should be on your list: - Massive Multitenant - Tables of 10M+ rows - Searching or Joining of Massive tables to smaller tables This is the main argument for an ORM in my opinion - it is a complete pain in the hole to migrate across but we have found that is has doubled our performance immediately and we haven't even started implementing the features we moved to Postgres for (Partitioning, Clustering etc)
The more PHP will be as friendly to functions as JS is, the more it'll become fun to play with
Make it supportable for machine learning and artificial intelligence..
1. use any of the `-debug` images at https://github.com/SeleniumHQ/docker-selenium/tree/3.141.59-selenium#docker-images-for-selenium-standalone-server-hub-and-node-configurations-with-chrome-and-firefox 2. make a `record-selenium.sh` script that does `exec flvrec.py -P /selenium-password.txt -o "/recordings/$FILE" hostname-of-selenium.docker.service 5900` 3. In your test suite, start/stop the `record-selenium.sh` when you start/stop a test, and control it via `$FILE` That's it.
Iâ€™d do it for a couple grand. Any proficient developer should be able to diagnose where and how the code is breaking. Alternatively, use crypto, email money transfers or plain old chequeâ€™s for payments. Email a code, whichever route you choose.
\&gt;Spread operator in arrays \&gt;null coalescing assignment operator \&gt;FFI Good
The important thing: it does not start all the php interpret for each requests (as php-fpm does). It reuses the instance to manage lots of requests.
I (my team) did and it was one of the most best single things we did in recent years, not kidding. Note that this was ~2 years ago and pre MySQL 8.0. My team is small (back then 2 1/2 backend guys) and the most single PITA I remember was adding new columns online. Nowadays with PgSQL it sounds ridiculous, because adding a column is instant in practice (unless you want a default value =&gt; different story), but back then with MySQL we had to plan downtimes because it would lock up the big tables for long. And back then our biggest table wasn't even _that_ bigâ€¦ I always knew here are tools like pt-online-schema-change but let's be honest: if I have to choose between such a tool/workaround and a DB which supports it out of the box, the answer is clear to me. It simply should not matter if the table you add a column to is 5GB or 500GB. Also, features regarding indices. Partial indices are absolutely critical if you've massive tables and want to get the most out of it but only need it for a subset. Same for indices using functions. TBH not sure if MySQL would have supported it, we only started to explore more advanced SQL features _after_ MySQL because more so often you would hit dead ends or problems/bugs, unexpected behaviour. I also remember that creating indices online wasn't as easy as I would have wished for. Yes, it's supported but what I remember it had like a million edge cases and you would have a hard time figuring out that upfront until you run the query. Absolutely frighting. In PgSQL, problem solved: just run it with the keyword `CONCURRENTLY` and, if it would not be supported, it would simply tell you. No guessing here. Advanced usage of CTE or windowing functions, features like LEAD/LAG =&gt; absolutely critical if you "go complex" with the data you want to aggregate and show in a fraction of a second. I also have to say that the docs for PgSQL simply felt much better. Clearer to understand. MySQL has TONS of docs, no doubt. Put the ones from PgSQL feel much more poignant. Types Nowadays I think they're on par, but back then `JSONB` was already a thing and the first we started to use and it's really useful to have this kind of support for certain features. Also a proper `BOOLEAN`, no more `tinyint(1)`. UTF8 Every time I read a`utf8mb4` I've to cringe. And to this day you can have issues with the charset because of the multitude of levels of settings in MySQL. Or, in my case: MariaDB: I recently had to jump in and import a MariaDB dump. OF COURSE the charset was fucked up. I was a bit away from MySQL/MariaDB already but I was pretty sure that I got the command line correct. What was the problem? The technical charset in the dump was correct but the META DATA in the dump file was not. No idea how you can even produce stuff like this, but the fix was to _edit that one line in the SQL dump manually_ and then it would work. Think about this for a second. Never ever you'll have this issue with PgSQL, so much I can guarantee. Performance. When we benchmarked and tested PgSQL, the performance characteristics were much more stable/reproducible. MySQL felt like hit and miss. I remember one query working well and _out of the blue_ it's performance dropped and we had to add a special "force index" keyword to it. In all the years I've never seen this with PgSQL. Which brings me to the query planner. Not sure what MySQL 8 has nowadays but the `EXPLAIN` back then was _laughable_ at best compared what you got with `EXPLAIN (ANALYSE, BUFFERS)` in PgSQL. The amount of detail is incredible and you can really _see_ under the hood. Of course it's more complex and it takes time to digest this. We did not jump out of hype to PgSQL. We slowly started introducing it for some parts of the application to get a feel for it. We had multiple workshops and an expert on-site a few times to deal with more complex issues. In the end the migration was planned / tested over a span of ~3 months and took ~6-8 hours AFAICS. Everything we invested was worth it because it lead us into an incredible stable future. "Back then" we constantly had to keep an eye on "that thing" (MySQL) regarding monitoring, slow queries, etc. It felt like a constant battle. Of course after all the preparation, the training, after the fact we were MUCH more knowledgeable and I would not doubt we would have a better experience with MySQL too know. However the more knowledge we gained about the SQL possibilities, even more so we were drawn to PgSQL when you realize how much more it can do and also did for us. No downsides to PgSQL? As with MySQL, there are things you _need_ to be aware. My list isn't long but what I know of: - I prefer `BIGINTEGER` for keys and FK because I don't ever want to come near the (google it) "transaction ID wraparound" problem anywhere in my life - VACUUMING is an art of it's own and it's the price you pay for all the other wonderful things. Either you master the multi-tude levels of tuning this or you resort back to tools like https://github.com/reorg/pg_repack - Collations depend on the system (contrast to MysqL &lt; 8, not sure nowadays, which has them built-in). If your systems collations change, your indices might get broken and not work correctly =&gt; you need to recreate such affected indices =&gt; surely not a fun thing TL;DR: Given the right people, preparation, business case: totally worth it.
It's hard to believe JS is friendly now. It used to be the most confusing language ever. It's come such a long way.
I feel like every week there is a post here about 7.4.
Numerous books and articles have been written on ways to properly use JS, but that's not the point here. I find it delightful to treat functions as first-class citizens, something i'd have loved to reproduce in PHP.
I hope itâ€™s not as insane as JS though.
All languages have books on how to use them. But JS until recently has was very non-sensical compared to traditional languages. Now it's a pleasure to work in. But anyone who used it 10 years ago knows how painful it was.
I agree with you. My point was to say that even though JS has a lot of dirty background (due to the lack of flexibility of the web, how ironic) that makes changes hard to apply, but books have been written about how to ignore them and get only with the best parts.
I'll shamelessly drop this here: https://stitcher.io/blog/new-in-php-74
&gt; friendly to functions as JS is Can you unpack that a bit? I'm not sure I'm getting what you're saying.
Switching from 5.6 to 7.2 wasn't a particularly smooth experience, for a number of reasons. It's left me reticent to upgrade again in the near future!
Sure. Depends on whatâ€™s requested by the dispute.
That's cool and all, but isn't C# achieving that performance out of the box? I looked over Swoole and feel like it's great, however, it also reminds me of hip-hop. I could've done gymnastics back in the PHP 5 days to get my application to run with hip hop, or I could just focus on other optimizations (database layer and database i/o) while PHP core catches up. If you focused your time on clean code, unit tests, and reasonable optimizations while PHP core caught up. You'd be in a better position today than having done that work the hip hop. I think if I wait for PHP 8 or 9. I'll get Swoole performance without doing a bunch of tricks. In the meantime, I can focus on other areas. With that said, there are likely some edge case scenarios where Swoole makes sense. For the stuff I work on, it does not, given all the other improvements I can make.
if you won't notice any real difference and one scales better than the other, then the answer to the OP's question is the one that scales better.
I'm not a Swoole advocate, just pointed out that linked report was incomplete. Your points are valid, but let's not forget that not every site qualifies as High Load. Performance is not the only characteristic that is important, otherwise asm would win.
rand\_emoji(), rand\_image()
When have you had to relearn PHP? I started in PHP 4 and I don't think I've had to do any radical relearning going to 5 or to 7. Stuff has been added sure, but no huge learning curves for me personally. Why do you expect to relearn? Just curious.
It may be the interface isn't showing this because I'm on mobile, which isn't a good reason not to, but I don't see versions used anywhere. How then can we take any of these benchmarks seriously? PHP 7.0, 7.1, 7.2 and 7.3 have all shown significant improvements over PHP 5 and even within 5 all minor versions differ wildly in terms of performance. Same goes for Symfony that had tremendous improvements on response time in recent releases, by switching out how they resolve routing, using regular expressions. Given the difference between "php" and "php-5" I assume this isn't a benchmark based on recent versions at all.
I should've stopped at, isn't C# achieving that performance out of the box? Which is an actual question, the rest was just me ranting.
The one thing that annoys the shit out of me about PostgreSQL is that you cannot easily adjust the column orders. It is a dumb thing for sure since you rarely look at the column orders. But isn't it nice to order them in a logical manner? Does it not irk your OCD when you have to append a column after created and last_modified? Does it not seem silly that they won't just add the damn feature in already. Why? Because it's not part of the SQL standard? That is my only gripe with PostgreSQL. I did a project in it once to see what all the fuss was about. Its nice, but not much different for what I do than MySQL and the column ordering thing bugged me.
The goddamn short open tag. Such an unnecessary thing to get rid of
annotations, generics, overloading, named parameters and the glorious return of the short open tag
Buy what were the reasons? Everything that could cause breakage should be documented, and very reasonable
Did I read that right. Short open tags are deprecated? Oh man, that's going to be a huge clean up job when they're finally removed. What's the reasoning behind this? They do make for cleaner looking template files when pure PHP is used for render the markup.
I think it's best that casting always gets you a result of the type you cast to rather than null.
Their use have been discouraged for quite some time. I think the reasoning behind this was because of possible conflicts with XML.
I know nothing about C#, but can you really say .Net Core is something that is available with C# out of the box? I mean, isn't it a framework you need to install etc., same as with any framework for any other language? Or maybe I misunderstand your point?
Note that `&lt;?='output'?&gt;` isn't removed.
Thanks for clarifying that! That makes a lot more sense.
What makes it official?
How do I enter into the fun draw?
Which was thoroughly debunked as barely anyone uses XML anymore outside of insane asylums.
What is wrong with the short open tag? It's much nicer to do an if/else or foreach in the template.
Just clickbait title.
Funfact: That code won't work on modern PHP versions. And the tutorial teaches bad practices.
Not OP, but IMO: It's really nice to work with functions in JS nowadays. The arrow functions are really well done. The scope is well thought out, the `this` context makes a lot more sense. And the syntax is just super easy and helpful. Probably the need for asynchronous actions and massive amounts of callbacks inspired the arrow functions to be what they are. And currently PHP doesn't really do asynchronous, and callbacks are cumbersome. (It's actually one of the reasons why my next projects won't be in PHP anymore.)
I guess templating in general is losing favor. The only time I still use PHP to generate HTML is to generate PDFs. Everything else is just REST apis (or graphql) with templating done on the FE.
&gt; 5 reasons why Bear CMS is more secure than your average CMS Okay, I'll take the bait. 1. https://github.com/bearcms/bearframework-addon/blob/23f24ca84208913900d52ec01fcb33adcf964614/classes/BearCMS/Internal/TempClientData.php 2. https://github.com/ivopetkov/encryption-bearframework-addon/blob/4d431d91d88a74a08c1b3f5fdb2a4813222778bf/classes/Encryption.php#L40-L75 Keyless MD5 is a rather poor HMAC substitute. Using `!==` instead of `!hash_equals()` also doesn't inspire confidence. Using unauthenticated AES-256-CBC (I don't consider keyless MD5 an integrity check, since there's no secrets an attacker wouldn't possess) isn't what I'd expect from a product billing itself as "more secure" than anything else. It's more of the same security flaws I'd expect from average PHP CMS projects. &gt; Keeping the CMS code on our servers allows ... Wait, you're keeping CMS code on your servers? I didn't see any sort of digital signature verification code anywhere in your framework. If someone pops your servers, do they get unfettered RCE access to all of your clients' websites for free? This doesn't sound like a good security engineering decision to me. But what do I know?
Typed properties is \*much\* better !
I'm not really sure where to start with this. It looks like a beginner's tutorial written by a beginner! You assume that XAMPP is pre-installed by the reader with no introduction to it, you have passwords stored in plaintext, there's no real explanation about what any of the code does or database design considerations, you're vulnerable to sql injection attacks, there are spelling mistakes littered throughout, there's no thought toward separating logic from presentation, you have functions called `myFunction()`, your formatting is all over the place (looks like you were hoping to add some `&lt;table&gt;` elements in your code snippets but they've half-rendered in your page content instead), your 'Hide, Shrink, Copy Code' buttons don't work, you have some variable called `$bool` for no apparent reason, you're deleting records by passing in an `id` via `GET`, the code in some of the snippets is different from the code in the associated screenshots, etc... And then at the bottom there's some link ("As I mentioned earlier, Iâ€™ll be uploading the finished product. Click here") to some site where you can buy more tutorials. Are you charging for this!? I mean, it's cool that you've had a go at it, but you still have a lot to learn and I don't think you can expect to earn any money from it just yet. Although I've just seen that the GitHub repo with the code was last updated 5 years ago, but the 'tutorial' was published today ðŸ¤”
There is no Discord server for PHP as of yet. That's why i'm calling it 'official' I might also just remove the word, as 'PHP Discord server' sounds better indeed
I knew I'd find you here with a title like this ;)
&gt; Did I read that right. Short open tags are deprecated? Oh man, that's going to be a huge clean up job when they're finally removed. It can be automated through the tokenizer, so maybe a huge commit, but not a huge clean-up job.
Syntatic sugar that would replace a lot of boilerplate in value objects. class MyObject { private $var1; private $var2; public function __construct($var1, $var2) { $this-&gt;var1 = $var1; $this-&gt;var2 = $var2; } public function var1() { return $this-&gt;var1; } public function var2() { return $this-&gt;var2; } } becomes class MyObject { public readonly $var1; public readonly $var2; public function __construct($var1, $var2) { $this-&gt;var1 = $var1; $this-&gt;var2 = $var2; } }
Part of the FE is still on the server. FE != client-side. And if you want any SEO, you need that server FE.
Actually we already had one announced earlier: [https://discord.gg/dhCfbM3](https://discord.gg/dhCfbM3)
That's not even remotely close to true.
Annotations for me https://wiki.php.net/rfc/annotations_v2 This would open up a whole lot for meta-programming, without hacking the way around with docblocks.
If you've been using the short open tag the last several years, you've been doing something wrong. It's been disabled by default for quite a while and highly discouraged. You'd have to manually enable it in the config to use it, which makes your code far less portable.
Day rate where I am for a senior level developer is around Â£350-Â£400, I think you need to eat the cost of the plugin before you lose any more time (also money) over it, and find a different solution.
Why create extensions from PHP? Because it's easier and faster to write PHP code that calls functions defined in shared objects than creating an extension which you have to compile, install, configure and enable. Personally, I've a lot of use case for FFI due to the nature of what I do daily. Recently, I had to interact with a smartcard reader but PHP lacks libusb bindings so I had to resort to using node.js for the feature. With FFI, I could write my own bindings fast, from PHP userland. That's why.
It's pseudo code. A php-version would look very similar except for the trailing type hints: enum Color { Red, Green, Blue } function draw(Color color) { ... }
Yeah, but thats not a discord thats specifically about PHP.
Could you unblock this article
These "official" servers do much more harm than any good. Run by newbies, these servers only spread wild rumos and superstitions, effectively teaching long-dead and obsoleted XX century-like PHP.
The big question IMHO is: Does management realize that something significant and costly needs to done in order to keep the system running and open for improvement? If they don't that would be a problem to say the least.
1) Yes, that one sucks. Luckily, there are ways around it. In an ideal world, that bug wouldn't exist. 2) You're deliberately ambiguous about it. The commit also depends on the operating system / hardware and storage engine as well. Who's to say you haven't had a faulty disk controller? You made it sound as if it RANDOMLY doesn't commit data - in which case - the software wouldn't be as popular or used, and the issue would be known. It's on the level of Chernobyl disaster to have an RDBMS that's lacking D in ACID. I usually don't believe stories that aren't backed up. Also, you lost a job because of a MySQL bug? I believe there's more to the story but this seems like a case of inexperienced person (at a time) chewing more than he can bite. I've never had unpredictable data loss (so far, and it's been some 20 years) so excuse me for not believing this 1% of the story, which I believe is long. 3) All vendors are inconsistent with SQL standard. SQL is the language that has more exceptions than rules in implementation. Gitlab guys were unable to code a simple feature, what most of the internet did back in 2001 with MySQL, so they went with Postgres which lets you do this via syntactic sugar (that's not bad, that's excellent, +1 for Postgres). This is what happens when you're spoonfed and when you don't really know how data structures should be modeled. Issue lies with developers not being competent to make the feature work universally, there's no inherent MySQL fault there. Oddly enough, you didn't link Uber's article on ditching Postgres for MySQL. Let me do it for you: https://eng.uber.com/mysql-migration/ Reasons you mentioned - without substantial proof (that's not provided) - aren't valid.
I wish this were true. XML is definitely dying, thankfully, but plenty of new systems still have to talk to older XML only systems out there.
Nothing wrong with a monolith as long as it meets the needs of the business. Really though, with the tiny amount of information provided, no-one on here can provide any meaningful opinion on how (or even if) you should go about refactoring your specific application. What can at least be reliably recommended, is first going and carpet bombing your application with doc-blocks and type hints as best you can. There are tools such as PHPStorm that can allow you to automatically refactor code, move classes, namespaces, rename things etc, but to be able to do so, it must first know where they're used. There's not much an IDE can do with this: ```php function doSomething($obj) { $obj-&gt;hello(); } ``` This however, a decent IDE will allow you to identify the use of the class, check its methods, move / rename the entire class, or its methods: ```php function doSomething(MyObject $obj) { $obj-&gt;hello(); } ```
The seo part hasn't been a thing for years now. Google is perfectly capable of understanding javascript sites.
&gt; https://dev.mysql.com/doc/refman/8.0/en/commit.html - See section where it explains sometimes transactions get "half committed" without an error (this happens in a variety of circumstances). &gt; What section?
I'm management ha! That's the joke! I've moved up the ladder now and head up Operations as Director (it's not a massive business but the growth rate is insane right now) but Technical still falls under my remit. Time isn't really the issue it's what the best approach is. If the best approach is we do minimal support for the primary application and spend 3-6 months refactoring everything so be it.
Js for backend personally too confusing and not funny at all
With C you can manually accomplish pretty much all what C++ gives you. With C++ you just have the best buddy compiler to show you where you may have commited logical errors. SQL without CTE can not do what SQL with CTEs can do. Same for transactions. Same for window functions. Same for X,Y,Z. Do you even know what's in the new SQL? Do you even know how many times you wrote PHP code that would be sooooo much simpler - yes, simpler - if only expressed in SQL.
Using FFI would mean that you call functions that are defined in a shared object after compiling Gifsicle. What you did was call an executable, regardless of creating an extension with Zephir - since there's no code to look at, that's my guess. What you would do with FFI is call Gifsicle's functions directly, without speaking to executable first. I can see more than a few of those functions in the Gifsicle's repo, so it would be possible to hook into it directly from PHP without using shell / calling an executable. The easiest way to grasp what FFI will do for us is to refer to Anthony's blog post and this snippet in particular: https://blog.ircmaxell.com/2019/04/compilers-ffi.html#FFIMe In short, yes, it would help circumvent the issue you stumbled upon. We'd simply get more tools to use without having to go through the pain and suffering of building an extension first.
Yea I knew this was a crap opinion piece when I was writing it! But is is a good point, most of our newer code (last 4 years) is Docblocked well, maybe this would be a good starting point though going through the old code and docblocking / namespacing / packaging it.
Ok that's good news then. I don't know if that's feasible for you but I would think about 1. Create acceptance tests that do not tie into the code but test the app from a user's perspective ([https://codeception.com/docs/01-Introduction](https://codeception.com/docs/01-Introduction)) 2. Then painstakingly refactor the app one step at a time and see to it that the acceptance tests do not break. That's basically how I would approach this.
Fuck that's brilliant approach for testing, I never knew you could do that! Worth this post just for that!
&gt;Docblocks can provide information that PHP itself cannot:/\*\* \* @param MyObject\[\] $objs \*/ function doSomething(array $objs) { $objs\[0\]-&gt;hello(); } I dont know why people use \`Object\[\]\` notation. I prever C the style notation which is still valid \`array&lt;MyObject&gt;\`
&gt; dont know why people use `Object[]` notation. Because it's the recommended style for phpdoc - https://docs.phpdoc.org/guides/types.html Also, in C++, you might define a array-like object as std::vector&lt;Object&gt;, but defining an array itself (i.e. pointer arithmetic) is int[]. Even if we get generics in PHP, it's still up in the air that 'array' itself would be usable as a template.
Using proc_open() without through a shell sounds nice.
This is low effort, no undertanding list :/ &amp;#x200B; * [Automatic closure and space (&amp; effort) efficient code representation with arrow functions](https://wiki.php.net/rfc/arrow_functions_v2) * [Covariant return types (we can type a return after a subclass), and contravariant argument types (we can type an argument after superclass)](https://wiki.php.net/rfc/covariant-returns-and-contravariant-parameters) * [Spread operator in array expressions (value that can be placed on the right side of assignment operator)](https://wiki.php.net/rfc/spread_operator_for_array)
Why do we need discord if we already have plenty of slack communities regarding PHP running?
Functions are first-class in PHP. You can pass along functions as arguments, return them, etc. Arrow functions "just" add implicit closure and skinnier syntax.
Which part of JS arrow function implementation is problematic in your opinion?
Want a good advise?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
That's fundamental change to how one can use OOP in PHP. Thus it will take time to design new code to use this functionality (or refactor old code by DRYing it). &amp;#x200B; First two listed entries can be used right away piecemean or can be refactored towards automatically (e.g. with rector)
I would also point out Rector for automated refactorings.
I've been considering Lumen for my next project instead of Symfony. I don't like the look of Eloquent models tho - too much magic for my tastes. How did you land on Lumen?
As others mentioned acceptance tests is one way to refactor. Also I would like to introduce you a thing called "Majestic Modular Monoliths". Axel Fontaine created a talk ([you can read it here](https://speakerdeck.com/axelfontaine/majestic-modular-monoliths)) where he talks about an approach in between monoliths and microservices. The point of this is to make the change iterative instead of a jump. [Slide 37](https://speakerdeck.com/axelfontaine/majestic-modular-monoliths?slide=37) and [slide 47](https://speakerdeck.com/axelfontaine/majestic-modular-monoliths?slide=47) are the most important in my opinion as they show how is it achievable.
You can already have Enums as implemented in that RFC, just use subtyping. class EnumFamilyName {} class VariantA extends EnumFamilyName {} So I would be against. It's pure syntatic sugar. It would be different on the other hand if some of possible extensions from that RFC would became part of it. &amp;#x200B; Exhaustive checks in switch, ADTs, Enums from Hack. That would be worthwhile.
yes please. tell me.
There is not standard for generics for docblocks apart from some specific edge cases. Thus each type checker for php uses their own. &amp;#x200B; On top of that "generics" is not a single dimensional space of solutions. There are mutualy incompatible solutions. If one of them would gain blessing of core PHP team that would simplify everybodys life.
Don't even try your fucking spam here
I think you don't understand the meaning of "official".
Polymorphism is a must have. We can only strive to make it as powerfull and as efficient as humanly possible.
I instinctively checked this post submitter name twice just to make sure I didn't write it... Depending on the business need, I sometime do a refactoring, but it's not that nice as it adds some new "paradigm" to the code base. I decided to rewrite the application "from scratch" in a modular way. Basically A "portal" will give access to different modules. One these module is the actual ERP. With time, features will be "peeled off" from the ERP and added as independent modules to the "Portal". I just finished rewriting our ERP (custom) login to use oauth SSO instead for that purpose. in the end, only the core of the erp shall remain. Cleaning or rewriting it should be much easier. In addition, writing the portal and some of the satellite features (like remote presence cameras) with the new technology will allow our freshly creating team to get up to speed. And if anything goes wrong, I can still revert to the existing ERP functionality. Finally, Integrating with external applications/teams will be smoother too. As usual budget and schedule is tight, while data migration is the real monster lurking under surface.
This saved me a click, thank you.
A post about new versions of PHP? In MY /r/php? It's more likely than you'd think.
It understands them fine; it will, however, score slower-loading sites worse.
Hereâ€™s one I wish for but have never seen mentioned: syntactic sugar for getters and setters. Something like Rubyâ€™s attr_accessor or C#â€™s get, set would help decrease cognitive load of a class
More realtime features and better asynchronous support.
You don't have to use Eloquent, I was using my own framework but maintaining it became to demanding and I needed something very light weight and minimalist
Horses for courses. I want PHP to run on my paid for web-server which happens to be in another continent without specifying much about it so I can move it if required hence interpreted is good even if it costs speed. C# (well C/C++ is my preference) runs on my desktop so compiled is better there.
this is not spam
And I would like to thank you for joining in :) &amp;#x200B; Appreciate your comments on md5, hash\_equals and the cipher used. I'll verify if AES-GCM is a valid option because this code is running on the clients' machines and portability is one of the goals. I don't think the code you've pointed out is less secure in its current form (because of the use cases), but I agree that the suggested improvements are a best practice. &amp;#x200B; Yep, the CMS code is on our servers, and we instruct the client servers what data to change (when editing the title of a blog post for example). The interesting thing is that we send these instructions only when the client server has requested us (and authenticated). This is the flow: \- The client says: give me the HTML code for the blog post settings. \- Our server says: here is the HTML code. \- The client says: here is a POST request containing the user-submitted data. \- Our server says: write "{....}" to "blogposts/post1.json". &amp;#x200B; We do not have access to the clients' websites and if one of our servers gets compromised the damage will be minimal because of the workflow described above. This does not mean that we should not take care of our equipment and encourage (and help) customers to back up their data.
please tell me. how can i posts here.? doesn't look like spam.? because, i didn't spamming.
I meant "See that good pipeline stuff with videos you got there" but i guess you wont show it.
Correct me if I am wrong. - the site belongs to a Hindustan-based company selling software services. - the article is a random choice of buzzwords applicable to web design any day a week. - not that random though. rather a carefully picked keywords to be indexed by Google Now tell me straight in the face it is not a spam.
Genuine question, why would I use this over something like a Symfony micro-install?
1. Not PHP related in the slightest (off topic) 2. Link to a company website (shilling) 3. Clickbait style title (final nail in the coffin)
1st of all. this is not hindustan based company. and yes this site belong to selling services.but i want that. people visits my website. i want traffic to my website. so i think this is not spamming. because i didn't use bad words or i didn't personal attack. according to the rules.
If you were doing any code (OOP or not) with variables or properties that can change type, you are writing fundamentally wrong, very unstable code. Typed properties is a must have, it will enable even more powerful and precise static checking analysis, and uncover many bug way before they happen in production.
I would start refactoring the small stuff. Long methods, complicated if/else statements. and work up from there to bigger stuff. Have you ever read Refactoring my Martin Fowler? Its is a great resource for something like this. He spends a lot of time talking about "Code Smells" and small steps you can take to make code better. My first job was supporting a lot of older applications that the company had built in house. They were mainly copied and pasted programs from many online tuturoials and books that were duct taped together into giant SPAs. That book helped me get a hold of how to slowly improve the code base.
Hannibal voice: Why are you booing me? I'm right.
So you cannot tell the difference between abuse and spam. How cute.
Angular universal is my answer to seo. Also, as other suggest, search engines know
There's this book from Martin fowler about refactoring that might help you get started
Interesting answer, but that runs on Node.JS. If you use PHP just for APIs, it's... I mean honestly you're not quite using PHP's strengths here in that case. But if it works, it works.
Iâ€™m curious how much of a performance hit the types properties will have, heard about it by the PHP author, have to make sure I donâ€™t have any loops that assign on $this :D
&gt; Maybe I'm waffling and this is probably too open a question without the right details but after a year of trying to plan out the best approach I need more opinions rather than my own. Might I suggest my book on [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp) ? It details a step-by-step process to transform your legacy PHP application into an organized, modern, testable application. (You don't have to take my word for it that it works; here's [a review from SitePoint](http://www.sitepoint.com/modernizing-legacy-applications-php-review/).) Regardless, good luck!
Wrong. It scans some sites using an older JS runtime, and many "modern" apps that target modern browsers won't work on it. Also Google has limited ability to interact with your site, given it's not an AI, it's just a program that invokes event handlers and the like.
&gt; I'll be honest, 95% of people/companies won't notice any real difference. I would be cautious there, as PostgreSQL has more capabilities in OLAP workflows (better windowing, plugins for column-DB, etc.) So I would say that some of the shops could see that some queries would be easier to read/work with.
Maybe he's talking about scope?
Heck, it can even be automated with the `sed` command :D
I wouldn't recommend that, because blind text-replace without parsing it as a PHP opens the possibility of corruping your code. Imagine you have some inline code containing "&lt;?" in a string for some reason. Maybe it's part of a password or god knows what.
After some reading today indeed it happens to be true. But it feels awkward.
But then arrow functions have nothing to do with scoping rules.
I'm all about micro services. So usually my back end rest api is php, because that's what I know and can build stuff in pretty quickly. I usually use angular to deal with the client side, and in the rare case I do need any seo optimizations (my use cases usually don't need it) then I'll use angular universal as a separate service. You're probably right that I'm not using php to its strengths, tho it's usually quite fast and no matter how I use it, I will need client side stuff for PWA. angular is my framework of choice atm which makes all templating stuff of php redundant.
\- 1) Does it earn money? \- 2) Do you need it to earn money in 5 years? \- 3) Do you need to extend it to earn money? \- 4) How efficient would be refactoring with regard to questions 1-3) \- 5) How would pattern refactoring help? \- 6) How would AST refactoring help?
Who the fuck still uses Yii?
Are you possibly confusing `&lt;?= ... =&gt;` with `&lt;? code(); ?&gt;`? Because it's the 2nd one that's being removed, not the first.
&gt; so i think this is not spamming. *Proceeds to post the same link to two other subs* It's your site, you've not contributed to the sub previously, *it's not even related to programming, let alone PHP*, this is entirely self promoting garbage.
I agree with this approach as well and have used it for the same kind of situation. There is a book called Working Effectively With Legacy Code by Michael Feathers that goes into this process in detail. It gives a number of strategies for how to mentally organize a system like this and identify pinch points in the code that can be the start/ends of your tests.
I kinda enjoyed writing simple API using hapi.js. Not sure how fun would it be to use on something large though.
ok relax. i delete this post.
Laravel. No, Symfony. Wait, no, Cake. Or Yii. CodeIgniter? Hmm, actually Zend. OK, I'm back to Symfony. Use Symfony.
I don't see why you would use anything except Symfony or Laravel.
They don't *use* it. They just spam the names to lure unsuspecting visitors from Google. Disgusting.
Time to learn a lesson: being the best technology doesn't make the winner For example, see DOS/Windows
\&gt; Yii PHP framework was created based on PHP 5. It is a perfect option for creating an online store or a corporate website. It does not have the old PHP base, thus it works much faster, than other competitors. how can it not have "the old PHP base", when PHP 5 is no longer supported?
I feel like there is a sub-reddit for that... oh wait. /s
https://gist.github.com/sxss/acfdce73976f219a6695 ?
Don't forget the first implementation cycle of JIT!!
If someone else has tried it on another Host OS (Linux, Windows 10, macOS) and succeeded, I'd very much like to hear from you in the comments either here or on GitHub âœŒï¸.
You have codeigniter on the image, but not on the review. Also, what about cake?
Method Overloading
I cannot, sadly - will hopefully put it out there as a library one day.
I prefer array&lt;T&gt; because its much simplier for nestest arrays. As well as, you may have a set size for the array, you can do array&lt;T, 5&gt; which tells what ever is inspecting your code, the array should be 5 size and will tell iyou if you try to access soemthing out side that size. If you want nested arrays, array&lt;array&lt;T&gt;, 2&gt;
Note I am not saying "over", I just think PHP deserves more attention as it has now. There are really good things about it.
Yeah but seriously, is it time to just switch to JS? It's pretty good on the server side as well.
Yes, a full refactor is an awesome idea. However, do not get caught in the trap of a full rewrite. Instead, refactor piece by piece to modernize to where you want to get. Yes, refactoring versus rewrite can appear to take longer. However, that is typically not the case, and helps prevent the loss of business logic as well as reduce new bugs as you go.
&gt;https://gist.github.com/sxss/acfdce73976f219a6695 Thanks, I know how to do it over curl but is there a way to make php completely over tor without adjusting any options? Otherwise yes, curl seems to be the only option as for now.
Shamelessly? OP copied your list verbatim and didn't bother crediting you &gt;.&lt;
- The client says: give me the HTML code for the blog post settings. - Your server says: here is the HTML code. - Your server gets compromised - The client says: give me the HTML code for the blog post settings. - Your server says: here is the HTML code + some ads + coin miner JS
Point 4.... Empatwhat-now?
Nowadays, with the exception of a few use cases, most scripting languages can be used interchangeably and it comes down to personal preference and team productivity. Ruby, Python, JS, and PHP are all decent in their modern iterations. For the individual I expect it comes down to whichever was introduced first i.e. if you learned Ruby (on Rails) then you'd default to that over Django/Laravel/Express
Refactoring is (always) better than a complete rewrite. If youre gonna have a lot of new devs that is the chance to see a lot of code and actually domain logic.
IMHO: 1 - Freeze all new features for this old application. No more new patches of unshrunk on old garment; 2 - Focus on rewriting a new app, using new - but solid - practices and tools; 3 - Please, please please DO REVIEW all business logic and use DDD to cover all your processes; 4 - and most important: have all cons of maintaining new features (for the old app) on the tip of your tongue as your manager will always ask you why you're doing things from scratch (and your manager will need to justify the investment to the Director/CEO). The thing is: companies waste money when they love their legacy code so bad. And best of luck to you! You'll need it!
I find all the different ways of creating functions in JS and the rules that go along w/ it to be confusing. Granted, it's not my full-time job. I imagine if it were then it would be much more memorable, but as someone who dips in and out of it I find it very confusing.
When IDEs get support for it itâ€™ll be great. Until then PHPDoc is the standard.
I consider it a compliment ðŸ‘
With the project being several years old and the underlying PHP version powering the application unsupported, I would recommend that you first visit the idea of migrating the app to 7.x. There is no sense in refactoring an application if you do not plan to support the latest stable technologies in my opinion. If the app is too trouble some to migrate, (lots of deprecations, issues with dependancies, I would consider rewriting it all together. Start with the core, then break the app down feature by feature. New features that you can create can support the legacy app through micro services if needed. If your application isn't too far off compatibility wise I would work to correct those issues, migrate the app to a new version of PHP and then work to refactor the existing features as you can. Start with your current bottle neck and then break it out Your issue with hiring devs is going to be the legacy PHP version coupled with the fact that your application is not where it should be standard wise. No body wants to come into that mess.
During a code review, we found a bug within a for loop. Basically, the code looked like this: $a = array(); for ($i = 0; $i &lt; $a; $i++) { ... } Obviously, it should have been `$i &lt; count($a)`. But the part I don't understand is the fact that it always returns true, thus making the loop infinite. How that?
I have some success in similar scenarios by doing sort of a phased improvement. Phase 1 - Bring it all up to php 7.x Phase 2 - Convert the database layer to doctrine (or something) Phase 3 - Decouple the your Content/HTML/CSS/Javascript (squash inline styles, base your front end logic on classes) Phase 4 - Keeping both SOLID and DRY principals in mind start squashing duplicate code Phase 5 - Still not happy now you can do a total rewrite based on something organized and somewhat sane.
Ye im butthurt about the second one. I only use (used?) them for templating and the full tag just feels like bloat in that scenario. Php itself is a fine templating language :P To me its like if twig deprecated {{ }} in favor of {{twig }}. Im gonna try to do more react type templating going forward, so its not a big issue, but some older projects are gonna have some ugly templates if theyre ever updated. Its a bc breaking change which the creator of php voted against. End rant lol
PHPStorm supports it
I do think so for quite a lot of projects. But when it comes to web-only apps, PHP has a strong history of very successful CMS (Drupal, Magento, Wordpress) and Frameworks (Symfony, Laravel, Zend). JS might be huge, but I failed to find this kind of structure that all very popular languages have (such as RoR, Django, Phoenix). Eventually one will emerge one day.
Just a reply telling you about my experience: We've been on the same situation years ago. The CEO didn't approve the new app, to replace the old one which was developed like 10 years ago. As the app came into the market, our customers started to ask new features and report bugs. Developers then started to work on customers demands, but we got into a point that *every new feature created could literally crash the entire application*, even using the TDD approach to new features, lots of regression testing and all that stuff. We were wasting money through the window. When the app starts failing because of a new feature (and/or a bug correction attempt), we had to mobilize all our developers into helping solving the issue. Also, our customers started to look at other apps in the market, to solve their problems. Then we had no option than to freeze the old app and start developing a new one.
There are people. I had an interview maybe two years ago and the test was to build a Yii site (to test how quickly I learn something) and there wasn't much help out there, but one channel mad mostly Israelis.
Yes
&gt;You assume that XAMPP is pre-installed Even before that assumption, he presumes you're on Windows.
Empty array evaluates as true. *array = true;* *0 = false;* &amp;#x200B; **false &lt; true** *or* **0 &lt; 1**
I'm guessing because array() instantiates an array and you're checking it against 0 is asking whether it exists or not, and it does because you instantiated it, so it returns true, which you are comparing to a number, and true is equivalent to 1 and 1 is greater than 0.
Thanks for your thoughts on that. From my perspective, JS OOP still falls short, and `this` is confusing as it appears mutable (if it's in a function It refers to the instance of the function the invoked function was called on, or defaults to the window object. PHP's short closures seem more sensible to me, but that's just personal. JS type juggling kills me, but PHP gives me typed methods now. Small Go microservices for async plays super sweetly with PHP, while keeping all the advantages of server-side rendering. I'm guessing these perspectives are probably based around what your typical application is. I am most often writing institutional apps for laboratories, so the priorities are pretty different for the application from say, a social media app.
I'm just looking forward to not needing a getter and a setter for every goddamned property anymore.
Most notably the drop of support for memcache in favour of memcached. Seems small but it was a headache to switch, as we use memcache(d) for sharing session data across our little cluster. Also session blocking suddenly became a problem where it hadn't been before.
an empty array cast to boolean converts to false. var\_dump((boolean)array()); // outputs: bool(false) [https://3v4l.org/vheee](https://3v4l.org/vheee)
It depends on which goal you want to achieve with your setter: * if your goal is just to enforce the property type, yes, you wouldn't need it anymore, * if your goal is to keep the object internals encapsulated, case in which you'd prefer the private or protected visibility over the public one, you will still need it, * if your goal is to achieve immutable objets, you wouldn't need any setter anymore, but it'd need to have the immutability at the language level to get around getters.
No, JIT will only come in PHP 8.
The answer makes about as much sense as the question.
I did say for EVERY property, not ANY property :P There are definitely places to use them, I'm just looking forward to not needing them just for type safety.
well... Now I'm confused!
I've been at this for many years now and have worked on bringing forward at least one ancient and spaghetti-filled PHP app. I do freelance and am trying to build up an agency with a partner, but could use part-time work to counterweight the swings that generates. If you're interested, PM me. I'm on [GitHub](https://github.com/mcordingley/) if you want to see the things I've done for fun and I can talk about work projects.
A monolith is not inherently bad, at all. Working with legacy code is no fun, but a rewrite (which is what it sounds like youâ€™re referring to RE: â€œwhole refactorâ€) will be advised against upfront. Adopting iterative development and refactoring processes, there are ways to modernize your legacy codebase, which will leave you with a much more maintainable codebase and provide a much easier path for piecing apart microservices/an easier rewrite - should you then require it. That being said, this isnâ€™t an easy process with any defined set of rules. However, if you would be interested, my company offers these and many more services that might be of interest to you. If youâ€™d like to setup a consultation please reach out here and we can discuss further!
If you go to the documentation page of [Comparison Operators](https://www.php.net/manual/en/language.operators.comparison.php) and scroll down to "Comparison with Various Types" you will find that when compairing anything with an array the array is always "greater".
See my comment. (If you are lazy: https://www.php.net/manual/en/language.operators.comparison.php )
[Direct link without scrolling](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.types)
Just a guess, but I believe they are being coerced to strings and then compared. I made a simple cast and comparison example and string is the only one that coerced like that: Demo: [https://3v4l.org/9AXs3](https://3v4l.org/9AXs3) &lt;?php error_reporting(0); echo "------------\n"; echo "0:\n\n"; var_dump((int) 0); var_dump((bool) 0); var_dump((float) 0); var_dump((string) 0); var_dump((array) 0); var_dump((object) 0); echo "------------\n"; echo "array():\n\n"; var_dump((int) array()); var_dump((bool) array()); var_dump((float) array()); var_dump((string) array()); var_dump((array) array()); var_dump((object) array()); echo "------------\n"; echo "Compare:\n\n"; var_dump( ((int) 0) &lt; ((int) array()) ); var_dump( ((bool) 0) &lt; ((bool) array()) ); var_dump( ((float) 0) &lt; ((float) array()) ); var_dump( ((string) 0) &lt; ((string) array()) ); var_dump( ((array) 0) &lt; ((array) array()) ); var_dump( ((object) 0) &lt; ((object) array()) ); Outputs: ------------ 0: int(0) bool(false) float(0) string(1) "0" array(1) { [0]=&gt; int(0) } object(stdClass)#1 (1) { ["scalar"]=&gt; int(0) } ------------ array(): int(0) bool(false) float(0) string(5) "Array" array(0) { } object(stdClass)#1 (0) { } ------------ Compare: bool(false) bool(false) bool(false) bool(true) // &lt;--------- String, only one that coerces to true. bool(false) bool(false)
Thanks. (I am from mobile so ...)
Install Laragon https://laragon.org/ Open HeidiSQL &gt; create database
It supports the doc block format but does not infer types for code completion. https://blog.jetbrains.com/phpstorm/2018/09/phpstorm-2018-3-eap-183-2635-12/
I love this sentence: &gt; We wonâ€™t be using any frameworks to keep things simple.
No. I used MySQL and started with Postgresql for a number of niche features like the binary string type, which has a simple and clear API, for specific projects. I basically always use MySQL (or some variant). Postgresql never provided any extra value, outside of the specific features.
I'm really glad I had this opportunity to read a list of new stuff in PHP 7.4 for about sixth time.
Did you ever refactor it?
We had a pretty shitty software 2 years ago. (4 years dev time since then) and it was really shitty but we decided to refactor since a rewrite of all that logic would cost to much testing afterwards. We didnt go all the way to doctrine and the other symfony components but we were going this way. It was a heavy "sprint" for 4 months to refactor all the old codebase to a clean structure with some more folders, some base classes usw... But then we got to a point were the whole model structure was good enough that some random other guy in the company implemented doctrine in one hour because it was so similar that there was no big change anymore. After that you can go forward with every new feature. You just have to upgrade your base to "common practices" and then replace the components. Beside that you and your mates will read a lot and will ask questions about the logic errors in the code/domain.
I think FFI will be more important since this is the gateway to all the stuff python has and php not.
Of all the 5 points listed on the post 4 are marketing and a single one is actually related to security.
I follow your point. I just thought about how our software would look today if we got the js from today like 20 years ago. This would be a maintainer hell.
Thanks! I bought that book. I keep running into these monolithic apps, but I'm not yet comfortable to just list out my refactoring workflow off the top of my head.
I am guessing the arrow functions in PHP must just just sugar though. Since there is no window object I don't think $this can be used outside of an object. But kind of cool that it can make switching between the languages a little easier. These days you kind of have to know javascript. Would be cool if PHP also started implementing prototyping. It's a cool concept.
Especially these days
We migrated to 7 ages ago, we don't have alot of external dependencies so PHPstorm took alot of the work of doing this for us! Took less than 2 hours if I remember right!
Omg. no prototypes would kill php. Besides you shouldnt have both. js classes are based on prototypes and this is soooo dangerous. And pretty shitty.
do you know what public is?
Fair points Session blocking is required for data integrity iirc, but I can imagine it being a pain.. On the other hand though, its relatively easy to write a session handler by yourself. I ran into it myself as well and basically made a memcached store for it. I always used memcached (not memcache, because since long ago I recall reading it being less good) so I can't really complain there. Upgrades will always cause some obsolete things to disappear, but IMHO, the upgrades from PHP5 to PHP7 has been sweet and soft in comparison to other web development languages that jumped versions.
PHP is no template language anymore.
Dont use php as template language. It was developed for that 20 years ago. Since then this "feature" hasnt got any love. you can do that if your pages look like 1999 but not if you want to make templating cool stuff painfree.
Also while going through this approach, start backfilling some tests to verify that the code you are implementing isn't breaking things.
As this post notes, this isnâ€™t perfect, at all. Iâ€™d be interested in comments on edge cases that are not properly handled.
That's not compatible with the RFC.
Yeah, and I acknowledge that memcache was obsolete, but it still worked fine! For us anyway. Happily, once up and running, memcached has been fine also. And you are right, the speed increases and many of the other updates have made the pain worthwhile.
Wow, you missed a few posts about the new features of 7.4.
Well, if you have systems that you know are obsolete, then you know what to expect when you jump versions :) But yeah, you're absolutely right about the speed increases, its very very much worth it.
do people buy this? .\_\_.
Do you know what type safety is?
Aaah damn, I thought the proposal for 7.4 went through.
Why do your customers like to stay in a safe harbor with their blogposts? Are they that crucial? As small company i would use the free wordpress hosting for this.
Python has it.
PHP would be full of stack overflows and other bugs because of me! Yay! Anyways, don't worry, I will stop posting non sense.
amex, paypal still sending me emails like: Dear Magyar-hunor Tamas ðŸ˜­
 This is dangerous, as you are now potentially telling people their name is not actually their name. You link to the [Falsehoods Programmers Believe About Names](https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/) in the article itself, but I would still like to point out number 12: Peopleâ€™s names are case sensitive. and number 13: Peopleâ€™s names are case insensitive. Trying to capitalise names based on what _you_ believe to be correct does not guarantee it actually is correct. Telling someone called â€œJack MCKâ€ they are actually called â€œJack McKâ€ would be incorrect, but would be the result this script gives you. Serving them a page with their name incorrectly capitalised can be hurtful, especially because they did enter it correctly themselves.
Thatâ€™s indeed whatâ€™s also said in the article itself. It notes that you might just use the snippet for suggesting a normalized format, letting a user decide which form is correct.
But why assume it's incorrect in the first place? You would still be telling them "hey I believe your name is incorrect, do you actually know how to spell your own name?".
Related resource: https://www.w3.org/International/questions/qa-personal-names
When looking at real-world cases it occurs quite often that people enter a full-lowercase name for instance. I don't believe there's anything wrong with hinting different casing.
&gt; PHP right now. Had no idea overloading wasn't a thing. I started with C#, https://www.php.net/manual/en/language.oop5.overloading.php
Awesome resource, thanks for sharing!
If you're thinking about migrating simply because someone said there's a better tool, but you don't have any identifiable reason to do so, you're not ready to migrate.
I actually agree with the life cycling of PHP 7.x. It was one of the major complaints about the language. It didn't progress fast enough and became stagnent. PHP is so easy to just follow the "set it and forget it mentality." It's the reason there are SAAS apps being developed in PHP 5.x. Looking at you Magento. Wordpress only recently bumped their requirements from the 5.x branch. Its a reason why versioning exists and should be utilized. As a SAAS app evolves, it shouldn't be held back by a legacy PHP version because companies do not want to update their apps to a new PHP version. The application in question should not be held back because developers refuse to refactor their code base. It should simply just break compatibly at a certain version. As apps progress and dependancies increase their version requirements, less and less antique code will remain and new standard will be utilized sooner. Additionally I do not buy the its "expensive for companies to maintain argument." Developers should be consistently refactoring and evaluating different parts of the applications as they add features. Its part of the development process and should be understood by the PO as tech debt. Additionally there are linters, static analyzers and other tools that assist in transitioning versions. ASFAIK outside of PHP 7.3, there were not any breaking changes outside of deprecation warnings. I can be wrong here. This does not just extend to PHP. App ecosystems such as Android and iOS require specific language versioning. For instance, Apple will reject an app written in a swift version that is no longer supported.
Thank you for the kind response!
this is the kind of hack the rfc would hopefully get away from. we have other solutions but a real enum would be better in most cases.
typed arrays. phpdoc helps but real enforcement would be great
Not sure what you mean by "scaling". Postgre seems to scale vertically a lot better. However, there is so much vertical scaling available until you need to scale horizontally. So for vertical scaling, I would put less risky alter table queries or more efficient complex queries which might prove to be quite risky for lets say MySQL database. It also provides more features. However, when push comes to shove, you might find out that it's a lot easier to set up Percona MariaDB cluster than Postgre cluster and ensure that it works reliably.
How is this about PHP? It sounds like you have to ask them, not Reddit.
I'm making the switch, but not for any real objective reason. I despise Oracle as a corporation, and I'm starting to move away from utilizing any software that they own. It's not a great reason, but it's a reason nonetheless.
I recently overhauled a 5 year old PHP app that had similarly not used best practices. It had a minimal but useful automated test suite though and could not have completed the overhaul without it. I would advise you to not even attempt this project without first having automated tests in place for the core business logic of the app.
Is it a problem because you dislike how the names are presented to the user in the frontend or does it have functional consequences?
That's a stub, not a mock.
Thank you very much for this answer. Missed that part in the docs.
Calling it "dangerous" is a bit over dramatic.
Googlebot has been using the latest Chrome release for a few months now. It can handle everything a normal browser can. https://webmasters.googleblog.com/2019/05/the-new-evergreen-googlebot.html
The problem isn't just what a browser can handle, but also what a human can handle. Your browser can't browse sites by itself alone.
Doesn't make your statements any less wrong. It's completely fine to rely on SPAs and client-site rendering these days in regards to SEO.
You're not thinking through what I'm telling you very carefully, are you.
Scalar objects. Also a run mode where internal type checks are disabled completely for code, and the developer can use external static analysis tooling to validate type safety AOT. I guess that would boost speeds a bit. Would require code to be written in a certain way though, no mixed or anything similar silly stuff. And a YUUUGE disclaimer in documentation is needed as well. Enums and generics would be neat as well, but difficult to add I presume.
&gt; Patterns should be tools, not shoe horns I've fallen into this trap countless times. I need to remember and keep telling myself this.
&gt;Of all the 5 points listed on the post 4 are marketing and a single one is actually related to security. It's just somewhat disappointing. Which one is only one one related to security in your opinion?
IMO itâ€™s safer (not to mention easier) to just let them see their name in lowercase. It looks ugly to me but nobody should be surprised by seeing their name as they typed it.
We rewrote our API when it was small, it took a few months and was worth it going from Code Igniter 2 and bad code to CakePHP 3 and better code. We rewrote our CRM going from CI2 to Cake3 and it took us 2 years because it was not a core company focus. That was not worth it. We took short cuts to get it done when it became clear it was not a priority. In the future, I will look at the strangler approach mentioned here: https://martinfowler.com/bliki/StranglerFigApplication.html You could take that as building micro-services to handle things and calling them from the OG App or just building a monolith service to call from the OG App. Eventually, your new "thing" will be handling everything. At that point, you can redo the UI and the OG is gone. It's an idea. I never want to go through what I went through trying to get our CRM rewritten. It was a dark time in this company, development got really angry at other departments from diverting our focus. To be clear I budgeted 3-4 months to rewrite the CRM and it took two years, not because our estimate was wrong, but because of how often we were pulled off. In some cases, it made sense to pull us off for revenue/profit needs, but in most cases, it did not. But that is just a window into our then dysfunctional organization. We are a bit more functional today.
What can you be doing instead of refractoring this?
There is no control panel - everything happens in the command line.
Check out [https://symfony.com/doc/master/cloud/intro.html](https://symfony.com/doc/master/cloud/intro.html) and [https://platform.sh/stacks/symfony/](https://platform.sh/stacks/symfony/) for more details.
How about we change the title to: top 100 questions nobody ever asked in an interview?
Well it seems good for beginners which may never touched in PHP.
100 questions proving you read the PHP documentation. Quality of code just isnâ€™t that important. &lt;/s&gt;
It is not even near to good.
&gt;Version 7.1 or 7.2 is the recommended version of PHP. This article needs an update on this answer. [https://www.php.net/supported-versions.php](https://www.php.net/supported-versions.php)
 &gt;**5) What is the actually used PHP version?** &gt; &gt;Version 7.1 or 7.2 is the recommended version of PHP. &amp;#x200B; i guess you failed your own interview. 5.6 is used more than 7.2 i guess. Sad but true.
With such a title one can tell the content is an outdated and harmful bullshit, that noobs been copying from each other for ages. Having not a faintest idea what do those answers mean. &gt; What does PEAR stand for? An obsoleted repository for PHP libraries, not used anymore &gt; What is the actually used PHP version? 7.3, you retard &gt; What is the main difference between PHP 4 and PHP 5? Nobody fucking cares for 10 years already &gt; it is possible to pass pieces of information from HTML to PHP. It is not. &gt; What is needed to be able to use image function? WAT? &gt; What is the function mysql_pconnect() useful for? This function doesn't exist for a long time &gt; How can we access the data sent through the URL with the POST method? **With $_GET again not $_POST** &gt; How do I escape data before storing it in the database? OMFG *addslashes!* &gt; How can we automatically escape incoming data? OMFG *Magic quotes!* &gt; What is the most convenient hashing method to be used to hash passwords? password_hash() you retard ...and so on. People promoting their shitty service with such articles do an enormous harm to the ecosystem.
\&gt; People promoting their shitty service with such articles do an enormous harm to the ecosystem Couldn't agree more, these articles are terrible.
Anybody who hasn't tried serverless PHP with [https://bref.sh](https://bref.sh) yet should give it a go! Even if you're already using [https://stackery.io](https://stackery.io), have a play with Bref :P
I've seen this bouncing around at the minute and it seems like a cool idea. I'm gonna give this a go at some point.
&gt;Might I suggest my book on Modernizing Legacy Applications in PHP? Genuine purchaser here. The majority of my (PHP) career has been spent refactoring old codebases so I have a lot of hands-on experience in this field and I still found Pauls book helpful. I read it cover to cover once and now basically use the index page as a template when converting old apps. Defiantly worth the purchase if you're not lucky enough to work on greenfield projects all the time like me.
I know a lot of people who don't use slack but use Discord, it's just giving different people different options, just like anything else in life. &amp;#x200B; That's like saying why do we have slack communities regarding PHP when we have subreddits, gitter chatrooms, SO chatrooms.
i have done countless interviews... Never ever have i asked ANY of these questions, not for a junior, medior or senior position. All you gotta do is get a general feeling about the person, ask them to complete an assignment, go over the code they made in another interview and then make a decision. If anyone was thinking about using any of these questions... DON'T
This awesome tool [https://github.com/krakjoe/tombs](https://github.com/krakjoe/tombs) is written by /u/krakjoe . Thanks to him for his great work!
This script has few problems. &amp;#x200B; 1. If name contains non-English letters, they will remain unchanged even if they are in first place of the work. 2. If there is "Mc" in the middle of the world, it will still be upper-cased.
&gt;I'm just looking forward to not needing them just for type safety I get that, I'd even go further, I'm looking forward not writing type unsafe code anymore at all !
FFI is a nice addition, but it greatly depend upon your business. If you don't need to do CPU intensive tasks or don't need any kind of external tool, FFI is just yet another unsafe/non explicit code nightmare. For example, I mostly write business oriented software for which the database is always much more important that anything else, FFI is useless to me. But I agree, FFI will pave the road of using millions of already existing external libraries for tons of use cases.
In JS arrow function are closures not bound to the object scope they were spawned (i.e. not inheriting from `this`) but they are still coupled to the scope. It's actually one additional weird scope rule: functions are bound to the scope and the object, arrow functions are only bound to the scope. Different scoping rule :)
Not much different than: \- use shared hosting for your site \- the hosting gets compromised \- some ads + coin miner JS ... or ... \- use managed website service \- it gets compromised \- some ads + coin miner JS I think you will agree that there are many people that do not take care of their websites and having someone to take care of 80% of the codebase (by providing it as a service) can be beneficial.
Your response does not appear to address the concern regarding RCE.
Like all the cool stuff e.g. keras tensorflow
After some more thought, I realized I was wrong. Defining property of enums is their closed nature. We define X values for an enum, and that's it. Inheritance tree on the other hand can always be extended further. &amp;#x200B; On the other hand inheritance tree can take on more responsibilities (aka "replace conditionals with polymorphism" refactoring), so I still think Enums should have some extra properties (not implemented by this rfc) to make them worthwhile.
Care to elaborate?
I can only imagine how many cases of default: throw new \Exception("Should not get here"); will be found.
Indeed.
To quote Greg Young "CQRS/ES is NOT a top level Architecture"
This may be of help: [https://www.youtube.com/watch?v=5QIpzNPVDaY&amp;t=3042s](https://www.youtube.com/watch?v=5QIpzNPVDaY&amp;t=3042s) &amp;#x200B; Similar issue. * Larger enterprisy app (but unlike your ERP they do seam to be scalling up and up and up) * High maintainance costs * Dilema of refactoring/rewriting/rearchitecturing &amp;#x200B; They went with microservices, and you can see how much it costed them. Maybe that will give you some estimate how much effort does microservices require to be usefull as an architecture.
I am late to the party, but what I'd really want is a way of adding simple annotations for static analysers that would allow me to write stuff like ``` function f(@param:array&lt;string,DateTime&gt; $dates) { @var:int $x = 12; } ``` The `/** */` stuff is clunky, especially in lambdas.
Thanks for your comment. Other readers understood that I am referring to an architectural pattern. As in PoEAA. I'll update the title if it bothers more readers, so far I only got positive comments and a bunch of "thank yous". I work very hard to write these articles/tutorials and share them with folks for free. So I tend to ignore folks which don't appreciate this and comment on "terms".
Thanks for your comment! &amp;#x200B; Top level? Sorry, which line are you referring to?
I agree with Greg so does my article. Not sure which part you think says otherwise? Thanks for your insight :)
Thank you for your feedback! &amp;#x200B; I think you need to read the paragraph after that. I'm not shaming anyone. These things must be taken in context. Reading the article gives context, reading a single paragraph does not. &amp;#x200B; This article is part of a series of articles in which I'm literally building a project with you and readers like you. I cannot describe how to build an entire system in one article :) &amp;#x200B; It would be very helpful to link your website and a tutorial in which you managed all of this one. I will learn from it. I'm sure. &amp;#x200B; Looking forward to it :)
Look under "Use in Type Declarations".
&gt; additianal Something something, your mother Trebek.
Yes, but not every site needs to be a complex SPA. Sometimes you just want to render some HTML and have a static site with a bit of dynamic content here and there. The short open tags `&lt;?` (not the ASP % variant) weren't harming anyone leaving them available and optional by default. Also imagine being the ass that deprecates that feature. Who is going to pay to alter all the existing sites out there to remove it now and add `&lt;?php`? So unnecessary.
A free alternative to a useless service. I've never seen in my life any reason to use a PHP encoder other than to flatter one's ego (thinking their code is unique and wanted by everyone) or to hide the terrible quality code from a customer. And I've never seen a customer that wouldn't dump at last the encoded version in favor of a code that they can patch and fix freely.
Just to point out a few issues with the site. Footer links don't go anywhere, GitHub link goes to the root of GitHub, there's a typo of `$php_blot` in the screenshots, various typos on each page. Where is the source on GitHub, I'd like to take a look? ðŸ™‚
Thanks...
Lean more, spelling mistake..
I will fix it soon.. Thanks for your feedback.
&gt;peemissions [cue mission impossible music]
Thanks. Fixed. This is what I get for typing on mobile keyboard.
From Ghidra... void zif_bolt_decrypt(long lParm1,undefined8 *puParm2) { undefined uVar1; uint uVar2; int iVar3; undefined8 uVar4; long lVar5; undefined4 *puVar6; int *__ptr; int *__ptr_00; int *__s; char cVar7; long lVar8; int iVar9; undefined8 local_58 [2]; void *local_48; ulong local_40; iVar3 = zend_parse_parameters((ulong)*(uint *)(lParm1 + 0x2c),&amp;DAT_00101361,local_58); if (iVar3 == -1) { *(undefined4 *)(puParm2 + 1) = 1; return; } uVar4 = _php_stream_open_wrapper_ex(local_58[0],&amp;DAT_00101364,0x12); _php_stream_seek(uVar4,0,2); lVar5 = _php_stream_tell(uVar4); _php_stream_seek(uVar4,0,0); puVar6 = (undefined4 *)_emalloc(lVar5 + 0x20U &amp; 0xfffffffffffffff8); *(long *)(puVar6 + 4) = lVar5; *puVar6 = 1; puVar6[1] = 6; *(undefined8 *)(puVar6 + 2) = 0; __ptr = (int *)_php_stream_copy_to_mem(uVar4,lVar5,0); __s = __ptr + 6; iVar3 = strpos(__s,"##!!!##",0); memset(__s,0x20,(long)(iVar3 + 7)); __ptr_00 = (int *)_emalloc(local_40 + 0x20 &amp; 0xfffffffffffffff8); *__ptr_00 = 1; __ptr_00[1] = 6; *(undefined8 *)(__ptr_00 + 2) = 0; *(ulong *)(__ptr_00 + 4) = local_40; memcpy(__ptr_00 + 6,local_48,local_40); *(undefined *)((long)__ptr_00 + local_40 + 0x18) = 0; if (local_40 &lt; 2) { puVar6 = (undefined4 *)_emalloc_48(); *puVar6 = 1; *(undefined8 *)(puVar6 + 6) = 0x6f63207265746e45; puVar6[1] = 6; *(undefined8 *)(puVar6 + 2) = 0; *(undefined8 *)(puVar6 + 4) = 0x16; *(undefined8 *)(puVar6 + 8) = 0x6f62207463657272; puVar6[10] = 0x6b20746c; *(undefined2 *)(puVar6 + 0xb) = 0x7965; *(undefined *)((long)puVar6 + 0x2e) = 0; *(undefined4 **)puParm2 = puVar6; *(undefined4 *)(puParm2 + 1) = 0x106; } else { uVar1 = *(undefined *)((long)__ptr_00 + 0x19); uVar4 = *(undefined8 *)(__ptr + 4); *(undefined *)((long)__ptr_00 + 0x19) = *(undefined *)((long)__ptr_00 + local_40 + 0x17); *(undefined *)((long)__ptr_00 + local_40 + 0x17) = uVar1; __s = (int *)php_base64_decode_ex(__s,uVar4,0); if (((__ptr[1] &amp; 0x40U) == 0) &amp;&amp; (iVar3 = *__ptr, *__ptr = iVar3 + -1, iVar3 + -1 == 0)) { if ((__ptr[1] &amp; 0x80U) == 0) { _efree(); } else { free(__ptr); } } uVar4 = *(undefined8 *)(__s + 4); __ptr = (int *)_emalloc(); *__ptr = 1; __ptr[1] = 6; *(undefined8 *)(__ptr + 2) = 0; *(undefined8 *)(__ptr + 4) = uVar4; lVar5 = *(long *)(__s + 4); if (lVar5 == 0) { iVar3 = 0; } else { iVar9 = (int)local_40 + -1; lVar8 = 0; do { cVar7 = *(char *)((long)__s + lVar8 + 0x18); *(char *)((long)__ptr + lVar8 + 0x18) = cVar7; iVar3 = iVar9; if (-1 &lt; iVar9) { do { cVar7 = cVar7 - *(char *)((long)__ptr_00 + (long)iVar3 + 0x18); iVar3 = iVar3 + -1; } while (-1 &lt; iVar3); *(char *)((long)__ptr + lVar8 + 0x18) = cVar7; } lVar8 = lVar8 + 1; iVar3 = (int)lVar8; } while (lVar8 != lVar5); } uVar2 = __s[1]; *(undefined *)((long)__ptr + (long)iVar3 + 0x18) = 0; if (((uVar2 &amp; 0x40) == 0) &amp;&amp; (iVar3 = *__s, *__s = iVar3 + -1, iVar3 + -1 == 0)) { if ((uVar2 &amp; 0x80) == 0) { _efree(); } else { free(__s); } } if (((__ptr_00[1] &amp; 0x40U) == 0) &amp;&amp; (iVar3 = *__ptr_00, *__ptr_00 = iVar3 + -1, iVar3 + -1 == 0) ) { if ((__ptr_00[1] &amp; 0x80U) == 0) { _efree(); } else { free(__ptr_00); } } zend_eval_string(__ptr + 6,0,local_58[0]); if (((__ptr[1] &amp; 0x40U) == 0) &amp;&amp; (iVar3 = *__ptr, *__ptr = iVar3 + -1, iVar3 + -1 == 0)) { if ((__ptr[1] &amp; 0x80U) != 0) { free(__ptr); return; } _efree(); } } return; }
Not too familiar with OAuth, but I think what youâ€™re looking for are scopes.
This is not my code... Lol.
No, it's what your `.so` decompiles to in Ghidra. Hence, "From Ghidra..." I don't see any hooks into an encryption algorithm, so it looks like you rolled your own.
Pretty sure you meant to respond to /u/johmanx10?
How does this compare to [https://github.com/scheb/tombstone](https://github.com/scheb/tombstone)
You're confusing authentication with authorization. OAuth does authentication. RBAC does authorization.
"Lean more" :-((
Sorry... I will fix it soon.
Are class in python genuine classes or, like in JS, some kind of sugar over a prototype based ? I don't understand how a language can have both, like implemented in the language.
They simply extend a master class that has static functions in it.
I'm just guessing here, but the package above requires manual action - you add markers to functions/methods you suspect are never called, vs /u/krakjoe's package which does that detection automatically.
Very cool, definitely installing it on all my production servers
Perfect! That led me to this issue which explains how the OAuth server can return scope (list of permissions) along with the token: https://github.com/thephpleague/oauth2-server/issues/793
There is also [https://github.com/SolidWorx/Burial](https://github.com/SolidWorx/Burial) which can automatically remove dead code from a project based on the results from Tombs
I too though oauth wouldn't be useful for authorisation but figured it wouldn't hurt asking. Turns out that OAuth can return list of user permission as the scope. See here: https://github.com/thephpleague/oauth2-server/issues/793
 switch (true): case ($something instanceOf VariantA): .. case ($something instanceOf VariantB): &amp;#x200B; [https://blog.liplex.de/switch-with-instanceof-in-php/](https://blog.liplex.de/switch-with-instanceof-in-php/)
Fixed...
It's quite easy to fall into that trap. With experience comes the abillity to detect this earlier on each time, until finally you are able to prevent yourself and others from making this mistake. It's also fine to make mistakes, so long as you recognize them and are able to live with them or fix them later on. Have fun at getting better at this. Also have fun with blatantly going with your gut. As with everything, it depends if something will be useful in a given context. It might be beneficial to properly think things through and design (part of) your solution up front, or it might be beneficial to just go with your gut for now and see what sticks and what needs fixing. It is often underestimated how easily we waste time on being undecisive. If there are two equally fine approaches, or two equally bad approaches, just flip a coin, go with it, make a mistake and learn from it, or pick the right one and learn from that.
\&gt; I think you need to read the paragraph after that. I think not. Before making that comment, I read the first chapter, the last chapter, scanned the article and plucked some parts here and there to see if the language changed. \&gt; , reading a single paragraph does not. Which is not what I've done. That would make my comment unfair and ungrounded. \&gt; This article is part of a series of articles ... I cannot describe how to build an entire system in one article :) That is besides the point and does not excuse or motivate the used language. \&gt; It would be very helpful to link your website and a tutorial ... It has been quite a while since I wrote something public. My work is primarily proprietary. I refrain from writing regular public content, as I hope to be particular about not generating noise articles. Beyond that the language used in your comment here, is a good example of what I dislike about your writing: \&gt; ... in which you managed all of this one. To me, that reads like you are trying to set someone up for a trap, or at the very least want to be passive aggressive in making a point about disagreeing with me. \&gt; I will learn from it. I'm sure. I'm not so sure about where you found that confidence, because I've done really poorly at displaying any pedigree in this matter, if that is somehow what my previous comments made come across. &amp;#x200B; Look, your article is most likely insightful to someone looking for a guide or reference on the subject matter and I applaud you for writing it. It is not written to my taste and I have no need to read it, because I really need to familiarize myself with the subject matter. What I was pointing out, were a couple of ways in which I personally disliked the writing and a guideline you can test your writing on - whether the subject is approached from enough angles, so as not to present it as a singular truth. &amp;#x200B; Good luck with the rest of the series and your public writing.
A refactored wordpress would be impressiv
&gt;So I tend to ignore folks which don't appreciate this and comment on "terms". This attitude right here is why you shouldn't be writing anything at all. How hard you work and the fact that it's free is irrelevant. "Terms" matter. Your language matters. That's how words work. Nobody expects you to be Hemingway, but you don't get to write about a technical subject and then start sniveling about how *you worked so hard* so you'll just ignore everyone who points out the flaws in your language. If you take the time to share your material on the web - free or not - then you owe it to your potential readers to use the correct terminology, otherwise you're just spreading misinformation. Get over it, get over yourself, and get better.
The fact that most of the replies to your comment are ignorant people getting downvoted may be indicative of the general MySQL userbase
Still can't do DDL changes in a transaction, meaning that migrations can fail in the middle, leaving your DB in an inconsistent state, which is very very bad.
I am so happy that you made this. Fuck all of the haters. 90% of them aren't Makers like you, anyway.
&gt; CQRS/ES is NOT a top level Architecture It would be great to get more context than simply a photo posted to Twitter, but this is all I got. [https://twitter.com/tcoopman/status/693109380238163968](https://twitter.com/tcoopman/status/693109380238163968)
I'll tell you what, I have a few composer packages that have &gt; 10,000 installs. I list them on my resume and I've gotten hired just because the teams have used one or more them.
Agreed - build useful stuff, share it, and list it on the portfolio/resume. If people end up using it like your situation all the better - if it's useful but not very used no sweat! At the end of the day just building stuff that is useful, well thought out and properly structured is great if you're willing to make it open source.
refactored and backwards compatible****
It is not my decryption algorithm. Please try to crack my algorithm, if you can. You can download sample encrypted PHP code and key from phpbolt.com
No. Any refactor of Wordpress should do away with Automattic's misguided ideals about backwards compatibility and start following semver. The only thing that should remain from the Wordpress Core is their UI. That's it. The rest is hot garbage and needs to die in a barn fire.
Thanks for the downvote. I hear you and agree from an idealogical standpoint. However much of the value in WP is the Plugins it has. Ignoring that just means making a project that not a lot of people will use. Any major refactor of WordPress needs to account for the ecosystem of plugins that keep people using it. Sure some of it needs to die and fall the the wayside, but not all of it.
Please take them up on their offer. I trust your work and would love to see a blog post about pwning this tool.
I could probably just replace the `zend_eval_string` with a call to print to STDOUT and decompile the code.
&gt;However much of the value in WP is the Plugins it has. Ignoring that just means making a project that not a lot of people will use. Also disagree here. Its plugin ecosystem is pretty much the primary reason why it's such a clusterfuck. Anybody who would want to jump on board with authoring plugins for a new Wordpress Core should follow a far more stringent workflow and be held to a much higher standard. Now granted: I'm taking a pretty dogmatic stance to this, and it's almost a certainty that my thinking is highly impractical. It may end up creating more barriers than needed, or it might even take FAR too long than what's acceptable. But personally, I would sooner have laymen and beginners turned away from it than have someone's server compromised by a history of terrible decisions. Reversed the downvote because you're not entirely suggesting what I thought you were.
&gt; I've been blaming Laravel for not rolling back failed migrations &gt; The more I learn about MySQL the more I miss PostgreSQL. at which point you'll start blaming yourself? if you put ALTER TABLE ..... into migration and it fails... nothing will happen
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
OAuth does authorization, not authentication. It allows you to access something but it doesn't necessarily check who you are.
Awesome. Gonna have to try this out soon. My boss has been on a dead code hunt, I think this'll help a ton.
A classic BBS? Probably PHPBB for free and IPB for paid. There are hundreds out there but those two get the most support.
in our days, phpBB is still a good solution?
They're literally all complete garbage, so it doesn't really matter. vBulletin or IPB are probably the "best". Maybe SMF if you want free.
The admin accounts one. Although I would assume all (popular) CMS'es do what is described there. &gt;Less code needed to run the website Doesn't mean it is more secure. It simply means it has less code (and probably less features). &gt;Fewer updates are needed Unrelated to security &gt;Faster CMS related updates Talks about features and UI improvements instead of security. &gt;No (private) information is stored or logged That's privacy, not security.
I appreciate that you were willing to hear me out more at the very least. There are a lot of things about WP that I like and probably even more that I would disagree with. I just feel that in the short and mid term, WP has value because of the community, plugins and themes. It's a trifecta that would be hard to break up without loosing the main value behind them collectively. In the long term though I would probably agree with most of what you're saying TBH. I think it'd be one of the best routes for everyone. There just needs to be a gradual implementation strategy though as to not risk disrupting the momentum behind it. Otherwise what you'd be creating wouldn't be WP at all in any way shape or form. So it'd be hard to make a big impact on the PHP community as a whole. IMO, trying to fix the issues you're addressing need to be done in a way that the community will come along for the ride - instead of creating [yet another competitor](https://xkcd.com/927/).
&gt; [BOO THIS MAN!](https://www.youtube.com/watch?v=DwBebtcx-Y0&amp;t=51) But seriously, vBulletin all the way.
Maybing showing my age a bit but I'd never trust vBulletin on my servers.
Forums in general aren't a good solution, and frankly out of those that *do* fit the modern web, I haven't seen any that actually run on PHP. Flarum might work, though it's newer and doesn't have much support.
I mean, I don't necessarily disagree with you here. Mid 2000s I operated a vBulletin forum as a developer with ~60-70k users and it was a pain in the ass all the way. But at the end of the day you can't beat the customization. I was able to create many forum modifications with very little issue or knowledge simply because I knew PHP.
On a side note, if a completely different project was the route forward I think - being idealist - the PSR process is helping the community get there. From my experience with Laravel, the community there has just as active of a 'plugin' ecosystem via composer and the fact that more standards have made it easy to write framework specific wrappers for common features. So I guess what I'm getting at - maybe a novel way to improve things would be some sort of WP drop-in replacement software. Something like taking the idea of Bedrock from roots.io to the next level. ---- Alpha the target would be comparability with WP plugins and themes - with a more modern/clean/standard core. Beta would be refactoring Plugin support related code to be what a modern system should feel like and wiring the plugin code to the replacements and only allowing them to be used with native WP plugins. Full Release would then be adding novel features and benefits to the new plugin system. Hopefully incentivising some of the WP community to jump ship. Since if they make native {insert project name} plugins they get cool new features, instead of relying on the compatibility layer. Drastically improving theme stuff should probably be integrated too. But frankly projects like sage from roots.io can do a decent job with that as is. So maybe there's just room to expand from there.
Ah, I just mean the frequency of security vulnerabilities. It always felt like vBulletin got more exploits than anything.
Oh, absolutely! The plugin and modding community was thriving so much that it introduced a ton of vulnerabilities over time.
Avoid SMF. The code is a literal dumpster fire and makes wordpress look amazing in places.
Yeah. But they're all dumpster fires.
mybb
I'm not really sure what you're getting at. Yes, since MySQL has this limitation you have to careful about how and when you execute a series of DDL commands.
Why would you consider that a better solution than actual enums?
[Flarum](https://flarum.org/) perhaps?
I like flarum.
Fuck you haters. -10ing my positive comment! Fuck off, the whole lot of you!
Punbb
Whatever "best" means to you, simple means "best" to me. &amp;#x200B; [https://mylittleforum.net/](https://mylittleforum.net/)
Xenforo or IP.B for paid, and MyBB/PHPBB for free. I prefer xenforo over IP.B.
Iâ€™m still waiting for someone to post an ionCube decrypter. ðŸ˜‚ Damn clients that use a billing system that uses it forever makes my life difficult.
:D
You realize almost nobody uses this? Use statements are a language implementation detail and you should just use an IDE which manages them for you. For example in PhpStorm the `use` section is hidden completely by default.
 [https://vanillaforums.com/en/software/](https://vanillaforums.com/en/software/) I tried it about 2 years ago it seemed pretty good
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&lt;button type="button" class="button" onClick="fnIntTotal()"&gt;Internal Total =&lt;/button&gt; &lt;script&gt; function fnIntTotal(){ var a = document.getElementById('txt\_Lab').value; var b = document.getElementById('txt\_Sample').value; var c = document.getElementById('txt\_Wastage').value; var total = parseInt(a || 0) + parseInt(b || 0) + parseInt(c || 0); document.getElementById('inttotal').innerHTML=total; document.getElementById('inttotal').value=total; if (isNaN(a) || isNaN(b) || isNaN(c)) { document.getElementById('inttotal').style.display="inline-block"; document.getElementById("inttotal").style.color = "red"; document.getElementById('inttotal').innerHTML="Enter a valid Number"; } else { document.getElementById("inttotal").style.color = "green"; } } &lt;/script&gt; &lt;label id='inttotal' name='inttotal' &gt;&lt;/label&gt;
When somebody asks for help regarding his old Model-T Ford, would you reply that "almost nobody drives those"?
Damn this is deep
Hm I personally don't like the nested ones. It adds a lot of distraction where you can't just read one, but have to think about it. With PSR-12 in review there is one limitation coming to it, that the sub part must not be longer than two parts. And I think that is a good choice. Personally, as mentioned, I don't like this grouped statement at all. [https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide.md#3-declare-statements-namespace-and-import-statements](https://github.com/php-fig/fig-standards/blob/master/proposed/extended-coding-style-guide.md#3-declare-statements-namespace-and-import-statements)
Thanks for your response. Regarding the distraction you mention, a similar thing occurs in Laravel when you use 'route groups', rather than type out each route in full. I suppose some people prefer one way, and others the other.
Shouldn't this be on /r/phphelp?
You should check out /r/phphelp
It is your comment which is rude.
There's probably some PHP work subs that are more appropriate for this.
This was considered in the original RFC, but ultimately dropped - so not very likely to come back, I think?
50 blogs â€½ I can barely keep up with my email...
It's you again. Trying to promote your PHP learning course [when you have not a fucking idea what PHP is](https://www.reddit.com/r/PHP/comments/ceow1d/top_100_php_interview_questions_and_answers/).
Yes. The real dev scene is so small people are likely to know you before they even knowed they know you.
Hilarious, thank you
Dude your comment on the other thread made my day. Really. Im crying almost lmao.1 &amp;#x200B; Its 7.3 you retard! Hahah :D
phpBB is still actively developed and Invision Power Board has always been my favourite, but this isn't free - but it is VERY good. &amp;#x200B; However, if you're thinking of starting a forum, or rather a community - perhaps you might want to use something a bit more modern. &amp;#x200B; In this day and age forums tend to be a bit of a graveyard/archive of old stuff. You actually might get more users with a facebook group/community page
[removed]
And that users who runs PHP 5 then complain that PHP is bad, slow, old...
Reeeeeeeeeeee
Oh yeah sure we'll upgrade As soon as the client pays for it, which they won't
Surely you know at least one such user?
I use nested uses and find them quite handy. Phpstorm can group them also.
I try to always group similar `use` statements. Dunno how I feel about nested nested uses, because mostly I prefer to group only the last segment of the FQCN.
An endless source of clickbaity blogposts. Nothing new, going to change nothing, but always a lot of upvotes.
Link returns a 404. Sounds interesting though
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie), [13](https://www.reddit.com/user/carnati_si_varza) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Are there really any security risks in 5.6? Not theoretical risks, real risks.
Perhaps more useful And agnostic post from the Source https://www.php.net/supported-versions.php
I disagree. They are still great for specific situations.
Why? It works.
Why are they garbage?
You could say the same about PHP...
&gt;Oh they will pay for it. If not for the update then for the aftermath not updating will lead to.
I think it's great that you have discussed this serious issue here. For the plugin environment there could be a migration plugin made which could be used for some deprecation time. After that even the old plugin shit can be removed.
https://www.youtube.com/watch?v=LDW0QWie21s
It's bad if our servers got compromised. While we clean them, some websites that are currently being edited by their administrators can be affected. All other websites (not currently using the CMS tools) will be fine. In this case, we have the ability to deploy a fix in a couple of minutes/hours and disable the CMS access. &amp;#x200B; If we give you the whole CMS code (like many popular open-source CMSes do) and a vulnerability is found, we'll need a lot more time to distribute the fix. You may have heard about many hacked websites running an older CMS version.
In europe with the gdpr you could just sell them the upgrade mandatory. Simple as fuck
*cries in 5.3*
Same...
This doesn't belong here.
I would like to make things clearer by giving some examples. &amp;#x200B; \&gt;Less code needed to run the website Let's say you run an open-source CMS that renders the website and provides you the editing capabilities (the popular case). Then the file *admin-site-settings-form.php* is running on your server. It will be bad if there is a vulnerability here because it can give you access to the database, other files, etc. It may take a long time for the CMS vendor and yourself to deploy a fix. In Bear CMS case, this file is run on our servers. We can detect a problem and deploy a fix in minutes. So, less code is better &amp;#x200B; \&gt; Fewer updates are needed The recent Cloudflare outage is a good example ([https://blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-2019/](https://blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-2019/)). The interesting part is: *A protection that would have helped prevent excessive CPU use by a regular expression was removed by mistake during a refactoring of the WAF weeks priorâ€”a refactoring that was part of making the WAF use less CPU.* So, fewer updates on the client code are better. &amp;#x200B; \&gt; Faster CMS related updates I've touched on that in the first point. We can fix a CMS issue much faster. &amp;#x200B; \&gt; No (private) information is stored or logged Agree, not directly related to security. But if you use a hosted CMS platform and they got compromised, your username and password, your IP, etc. can leak. Bad things can follow. So I believe, storing no client-related information is better. We expect that from our VPN providers, right?
There are active critical vulnerabilities in extensions that are often bundled with PHP 5.6, including [database drivers](https://bugs.php.net/bug.php?id=77967) and the [EXIF extension](https://nvd.nist.gov/vuln/detail/CVE-2019-11035) so if you're using the official PHP binaries that are packaged with OS distributions you may be vulnerable. You will also be vulnerable to any critical issues that are discovered in the PHP core, which could happen at any time. However if you're using the [Sury repository](https://deb.sury.org/), the version of PHP 5.6 that is included is [actively maintained by Microsoft](https://github.com/microsoft/php-src), with security backports from currently supported versions as well as patches for vulnerabilities that are discovered that only effect 5.6. There is no guarantee for how long this support will continue, but it will likely be several years at a minimum. With all that said, upgrading to the latest release of PHP 7 should be an immediate priority for any business still running on PHP 5. We carry out a lot of migrations and even on very complex codebases (thousands of tightly interwoven spaghetti files), they tend to be manageable, especially with [static analysis](https://github.com/phan/phan), automated [refactoring tools](https://github.com/rectorphp/rector) and acceptance testing.
Speaking of fucks; guess who gives none.
They already are paying for the extended time it takes for something to be implemented in these aging systems. The cost of having to train young new devs in architecture that was already EOL when they were in high school.
If you like it simple maybe have a look at FluxBB. Whatever you do: stay away from phpBB. t is just outdated code and concept, even in most recent version.
 [https://dev.to/endtest/puppeteer-vs-selenium-1938](https://dev.to/endtest/puppeteer-vs-selenium-1938)
They should finally clean up the boolean comparison mess. Example: The according to PHP the string "null" is equal to the integer 0. Which is factually wrong, because an integer and a string are two different things.
Dont stream files via PHP. Each download will "block" a process (be it a PHP-FPM process or an apache process). How often do you add / modify the files served via this system? It'd be better to generate RewriteRules on-the-fly. You could either serve these rules via a .htaccess (apache only) or update the vhost config and reload apache/nginx. This way your webserver will handle everything (including caching, which your implementation misses direly) and you wont block an FPM process.
Then they cant work with anybody else since they cant sign their data protection contracts. (Or they do it illegaly)
Sorry, I have no gain from this. Just thought I'd share it here for PHP Devs in the same location. I'll remove it if it breaks the rules?
Sorry, I have no gain from this. Just thought I'd share it here for PHP Devs in the same location. I'll remove it if it breaks the rules?
Thanks :) I was asking, which part of the article says or sounds like it says that ES is a top-level arch? BTW: I agree with both yourself and Greg.
It's a great tutorial and to be fair much better than the regular vscode setups. But honestly people, spend a little money on PHPStorm.
Yea, Vs-code is great, but once I tried PhpStorm it's very hard to go back.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie), [13](https://www.reddit.com/user/carnati_si_varza) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Step 1: Purchase PHPStorm
the best engine is create a private subreddit
The new versions of phpstorm getting really really good. But you can waste your time trying to clone the behavior.
Just because PHPStorm is the best option for you doesn't mean it's the best option for everyone. There's people like me that do a lot more than just PHP and using VSCode is nice because it means I'm comfortable which means I'm efficient. Also, some people may just not have the money to spend, you don't know their situation.
&gt; I feel like I am losing the object-orientated nature that I really benefited from before. Rather than operating with $object-&gt;doThisAction($arg1, $arg2); I'm having to pass the object to these actions as a parameter: $action($object, $arg1, $arg2); [they all use __invoke]. That seems fine to me. Sometimes OOP isn't the right answer. What else do you feel like you were gaining from it besides a tiny bit less typing? As far as your options go, I don't see why #3 is that bad. In fact, I'm not a huge fan of __invoke() anyway. Are your actions testable? What kind of things are your actions doing with the models? Are they mutating the models?
Why though? I've been using VSCode for years and actual VS for my C# projects, I see 0 reasons to pay for a PHP IDE (of all things). VSCode does everything I want, with some setup. Plus it runs better, at least on my machine. XDebug integrates well, WSL terminal integrates well. With the extensions in this tutorial it becomes a really good and minimalistic IDE. I've become so efficient in installing VSCode that it takes me less than 5 minutes on a new machine that's including the download of VSCode itself.
&gt; people like me that do a lot more than just PHP But have you actually _tried_ PhpStorm? Do you know the advantages it gives? What's stopping you from using two IDEs/editors one for backend and one for frontend? &gt; means I'm comfortable which means I'm efficient Who's stopping you from getting comfortable with PhpStorm? Sure it will take some time, but doesn't every professional need to spend time learning their tools? &gt; Also, some people may just not have the money to spend If you're in a professional setting, the price is peanuts for a company. Also: the time won by using a proper IDE means your company actually gained money by spending it on PhpStorm
Money aside, there are IntelliJ products for pretty much every major language. I use Phpstorm for PHP, RubyMine for Ruby, CLion for C etc. Super cohesive experience between them.
My friend uses vscode and i was helping him with something, and intictavlt i was trying to go to a function defonition, and it wasnt working. Little did did i know, vscode cant do this.
The GitHub link on the website links just to the GitHub homepage, should it be linking here: [https://github.com/arshidkv12/phpBolt](https://github.com/arshidkv12/phpBolt)? Where is the extension code?
I guess this one: https://github.com/arshidkv12/phpBolt
Terrible architecture, usually have some sort of database shenanigans which don't use parameter bindings, crappy plugin systems that require manually modifying the core code, constant vulnerabilities found, etc. None of them use modern best practices. They're all old as fuck.
Sorry... Extension code is closed source. Because it has no security, if it is open source.
&gt;This man speaks the truth. Ioncube has very little to no use case in a productive environment. Any alternative, free or not, will also fall into that trap.
I have tried PHPStorm, and I'm not telling anyone to not use it. What I am saying is that this gate keeping around what IDE/Editor you use is ridiculous. What is stopping me from getting comfortable with another IDE is time. probably 60% of my developments is Powershell, BASH, and any other related files I'd need for that (XML, dat, INI, etc.) Then the last 40% is PHP, HTML, CSS, JS. So why learn a completely new IDE for maybe 10% of my work load? Yes, I agree in some companies the cost is minimal. But I've also worked for some great companies that didn't even have enough money to buy the correct cables for a computer setup, you had to scrounge for them.
You should check out the Settings Sync add-on if you haven't already! It's made my time to get VSCode setup basically nothing now. Also, seems like there's a ton of gate keeping here about what DE people use because I commented above about VSCode and people aren't liking it too much.
That's great to hear that it's getting better and that it works for you. I don't do much complied programming (Mostly Powershell, BASH, related dat, ini, XML editing) so keeping all my development in VSCode is much easier of a workflow for me. I've also tried the Intellij ecosystem and personally didn't like it, probably because I was already too used to VSCode. I'm not trying to say that people shouldn't use PHPStorm, or that they should switch. What I am saying is there's more options other than just PHPStorm and people should use what they like and what works for them.
I only write PHP 25% of the time and JS the rest. I used to use PHPStorm, but VSCode is so much better for the JS work that I just started living with how bad VSCode handles PHP. So any improvement to that app for PHP are much appreciated.
Cracked. ``` // unbolt.c #include &lt;stdio.h&gt; int zend_eval_string(const char *str, void *retval_ptr, const char *string_name) { printf(str); return 0; } ``` `gcc -shared -fPIC -o unbolt.dylib unbolt.c` ``` # cat index.php &lt;?php /** * define('PHP_BOLT_KEY', 'kyc7fh'); We want give key to client */ define('PHP_BOLT_KEY', 'kyc7fh'); bolt_decrypt( __FILE__ , PHP_BOLT_KEY); return 0; ##!!!##i4psiIu8tLxssa+0u2xztLG4uLtsw7u+uLBzh2w= # DYLD_INSERT_LIBRARIES=unbolt.dylib DYLD_FORCE_FLAT_NAMESPACE=1 php index.php ?&gt; &lt;?php echo 'hello world'; # It was a fun Friday morning exercise.
Thank you. If you have any link about it, I would very much appreciate it.
Good call! I took the same approach after seeing the call table. Worked like a champ.
I already gave source code here... lol
Yeah, but where's the fun in that? "lol"
VScode kubernetes/helm integration is immense. Not Php specific ofc, but I'd really like pHPstToRM to catch up on that.
We offer a Wordpress plugin/theme combination that consumes our API. Since Wordpress is sometimes running on strange configurations we've added a debug-page which lists some settings (installed extensions, running plugins etc. etc.) and gives the customers the ability to send this data to us via e-mail so that we can check where something might go awry. &amp;#x200B; The record holder sent his debug info about six months ago. He was still running PHP 5.2.3 or something like that.
PHPStorm is a true IDE however, whereas vscode is basically a text editor with all the IDE functionality baked into mostly third party plugins (this is not the case for TS however). There's a ton of stuff that can't be done in terms of how well PHPStorm (or Pycharm or whatever) actually understands the code you're writing. Just to name one thing, refactorings, is simply impossible to do with vscode to the level intellij can get to. Once you know how to use any intellij IDE properly there's no way back. That said I do use both - vscode is an extremely powerful editor with advanced functionality I use all the time. Just not for actually writing code.
What are the credentials for the demo system? Would like to have a little nose around first without setting it up locally.
I've found PhpStorm's support for JS and TS to be pretty good. What exactly is VSCode so much better at?
This is not an answer to my question but I understand your desire to share this information
I hear you, but I don't think any of these are healthy reasons not to master the best tools possible to be a professional developer. PS, I wrote about this topic a while back: https://stitcher.io/blog/craftsmen-know-their-tools
While I agree that you shouldn't stream files via PHP, dynamic RewriteRules are a bit overkill, especially if you're using nginx. My favourite solution is to use [X-Accel-Redirect](https://www.nginx.com/resources/wiki/start/topics/examples/xsendfile/) with nginx (X-Sendfile in Apache), but you achieve something more similar to your approach by using nginx's [http_secure_link module](http://nginx.org/en/docs/http/ngx_http_secure_link_module.html), with built-in support for link expiry.
I prefer Atom with a few php plugins.
I don't know about dat, but PhpStorm handles PS ([plugin](https://plugins.jetbrains.com/plugin/10249-powershell)), Bash ([plugin](https://plugins.jetbrains.com/plugin/4230-bashsupport)), INI and XML just fine.
Same here, I do a ton of frontend and node backend work and know vscode well. There are a few things that vscode does better, but storm comes ahead for me in most things that matter.
Crack following file. https://raw.githubusercontent.com/arshidkv12/phpBolt/master/fun/crack-it.php
``` ?&gt; &lt;?php while(true){ echo 'Start !!'; break; } echo 'Crack now - Just for fun'; ``` Next? "lol"
That's a good post, thank you.
Most of the actions on the model are manipulating that model (or other models) in some other way. It feels a bit... odd, not to have the responsible class encapsulating the actions to perform on it, but I've spent the past few days re-working a bunch of stuff and I have to admit I'm liking how much I've thinned out the models themselves - For the main part of the code, I've reduced them to nothing more than basic lookups, and all of the manipulation logic has been moved to single action service classes.
Yeah. Vscode it's nice, but for sure, when you do PHP seriously, you don't want an editor, when you tried a IDE.
Almost all people who say PHP is bad are still using PHP 5 or PHP 5 was last version they tried.
VSCode absolutely can do it, as this article mentions. If you're working with PHP in VSCode you should be using the PHP Intelephense extension which supports this and much more. I use PHPStorm 90% of the time, but use VSCode as my main text editor, so have it configured for PHP.
Thanks... But I will fix it soon by converting to byte code.
I totally understand that point about using the right tool for the job. And in other parts of my life, I definitely follow that mantra rather than using what's comfortable. However, I'm not a professional PHP developer (I just support a single, simple website that uses PHP) and so using VSCode gets the job done. I'm sure if that project grows in not just code but time, I'll look to PHPStorm to streamline it. But right now the total upkeep on that site is 0 hours a month in PHP.
That good to know. To be fair I switched away from PHPStorm about 2 years ago and honestly my overhead has changed so much since then I don't see the point in paying for it since PHP is such a small portion of my work.
PHPStorm, is worth the money. Hacking editors into IDEs with plugins always just makes you spend time fucking about with your environment instead of developing - this plugins stops working, that plugin needs updating, but the other plugin depends on plugin Z thats now deprecated. &amp;#x200B; Waste of time. Buy PHPStorm - I resisted it for years!
You're making a lot of assumptions about my use of IDEs. I've used them in the past for complied programming, Java, C++, C#, etc. I had to use plenty of IDEs for those and I used the "right tool" for the job. Sure there's tons of features of that PHPStorm has that could be useful if I invested the time to learn them. But as I have said in past posts, PHP accounts for maybe 10% of my workload and I only support a single, simple, PHP website at the moment. So it makes no sense for me to jump ship and learn a whole new system when I can be just as efficient for my needs with VSCode. I also said in a previous post, sure if my single site becomes more time consuming and grows in users &amp; codebase, I'll probably look elsewhere. But as it stands it's just not worth the time investment.
I wouldn't use anything but VSCode for PowerShell, mostly because it's the same argument that everyone here is making to use PHPStorm "right tool for the job" in the PHP Context. VSCode is also the eventual successor to the PowerShell ISE, making it the preferred "tool" for that use case.
Seems too complex-looking to me - you'll spend more time organising your use than you will implementing the function that uses the class in the first place. Not to mention it will take you a minute or so to parse it in your brain when you look at it.
Ah, then these weren't IntelliJ IDEs? I use a few for different languages and they all work the same, the only learning curve to switching to Goland if you already know PHPStorm is language specific stuff.
Check out the documentation. Everything is in there. If you need additional help join in Telegram group ;)
Fair play.
I'm not sure what kind of plugins you use but I've never had a plugin stop working because of updates. VSCode specifically already updates quietly in the background and then just asks you to restart the program when it's done.
So you don't. Quite expected. Now from your fantasies to the facts. - The only people who say PHP is bad a those who never used PHP at all. - PHP5 is neither slow or bad. Facebook had millions of users using PHP5 before switching to hack. PHP gained its popularity and dominance during version 5. Many sites are still working using version 5 with no problem. PHP7 is better, but PHP5 is not that evil and despised as you imagine this. It is just obsoleted. - no sensible person would willingly use PHP5 and complain it is old or buggy
In all fairness, I was actually referring to my previous experience with Atom plugins, I haven't ever given VSCode the chance, because of Atom and I now use PHPStorm. &amp;#x200B; Lots of Atom plugins depended on one another or other plugins that were written by different authors, especially the PHP IDE type ones. I couldn't get a single "go-to definition" plugin working without a ridiculous amount of configuration. Why waste your time, just buy phpstorm and give some credit to the people that make it their business to sort these IDE problems for us, so we can develop.
Just out of curiosity, what do your composer packages do?
No, C++ Was Microsoft Visual Studio and Code::Blocks, Java was Eclipse, and C# was Microsoft Visual Studio and Code::Blocks as well. I know Intellij has IDEs for these but I don't program in them anymore and when I did it was for college courses so we had to use what was provided.
Fair do's.
&gt; What exactly is VS Code so much better at? Being FOSS is the biggest thing for me.
Also, there is a thing called LTS. Although for creating the new code it's better to use the newest version, for the existing application that is not under development it is actually better to use the same version as long as possible. And actual complains would come not from using the old version but from the transition to the new one.
This subreddit is very biased toward PHPStorm and I keep asking why and usually other VSCode guys reply to me. Weird! It's almost like when you go to the movies on a shitty film but you tell your friends it was cool because you paid for it. That's the vibe I'm getting at least.
&gt; There's a ton of stuff that can't be done in terms of how well PHPStorm (or Pycharm or Goland or whatever) actually understands the code you're writing. Whatever you are smoking, give me some.
If there isn't already a "bytecode to PHP code" decompiler, give a motivated reverse engineer a weekend or two and an adequate supply of their beverage of choice, and one will materialize.
Haha agreed! I'm not bashing PHPStorm, I'm sure it's amazing and if I ever need to do a bunch of heavy PHP development, I'm sure I'll use it. But for people like me at least that do light PHP development, VSCode is great.
Sublime Text is also a good IDE for PHP with some plugins. Taylor Otwell, laravel creator, uses Sublime Text: https://medium.com/@taylorotwell/how-i-work-october-2018-edition-e66a09931e7f (I am a VS code user with Sublime Text key bindings because I switched from Sublime to VS Code)
I thought Atom died out, lol. It's super heavy on my system, just like PHPStorm. VSCode runs like a breeze. The plugins seem to be standalone, at least I've never had issues with sftp,gitlens and the php related plugins. Apparently VSCode has an extension that syncs all your plugins across all your devices. Neat.
Okay, I'm not gonna go into details on the quality of the examples and I will try to mention some constructive criticism. &amp;#x200B; Why do you need the `file_url` table? You could just build urls like `d.php?expire=&lt;expiration timestamp&gt;&amp;file_id=&lt;file id&gt;&amp;sha1=&lt;SHA1 of the url&gt;`. You generate an SHA1 token for `d.php?expire=&lt;expiration timestamp&gt;&amp;file_id=&lt;file id&gt;` and then add it to the url and then on request you just remove it from the url (I recommend to rebuild the url on the backend and sort the query parameters alphabetically). &amp;#x200B; As others mentioned supporting X-Send file can be beneficial for large files. Your server will start to throttle when `MaxRequestWorkers` (or similar property depending on you web server) will be reached. However in some cases it can be beneficial to serve files via PHP for example if you want to run a script after the file is finished - log, update statistics or delete file. &amp;#x200B; Accept range headers so a lost connection can be continued. &amp;#x200B; If you don't want to reinvent the wheel use Symfony's `BinaryFileResponse` as many current PHP framework is Symfony based. Of course for a tutorial it is better to explain things instead of saying use this. &amp;#x200B; Separate the view from the code. At least do your logic on the top of the file and only use variables and their properties/methods in your views.
Neither has anything on PHPStorm, though. For better or worse.
For what it's worth I fully agree with you. Why does anyone care which editor / IDE I happen to use? I've used "everything" from Borland c++ to eclipse to Netbeans, sublime, atom, PHPstorm and I'm sure a few others. I often use vim when working in bash ... My daily choice happens to be VS code. I just like it, feel comfortable with the shortcuts and I don't need to be seventeen percent more productive, because x, y, z. I've tried PHPstorm multiple times and never felt comfortable with it. I don't know why and I don't think it's even worth a discussion or an argument. Maybe I don't like or don't remember some shortcuts and don't want to spend time learning another IDE, when I already have a tool that does everything I need. Use whatever works for you and what you feel comfortable with using. IMHO, there should be no other criteria for choosing your personal dev setup. Given all the awesome choices we have today it's not worth the time to go into lengthy arguments about what is "better".
Thanks for the valuable explanation.
Agreed. Sounds like a fun project. &amp;#x200B; To OP: The whole security thing is a 'best effort' practice anyway. If you're looking to pitch this, then you'd be better off pitching it to VPs or higher people in the org chart (those are the ones I see who usually think their code is sprinkled with magical bits of fairy dust). The engineering talent on this subreddit knows exactly what it takes to circumvent those measures and how big of a waste of time it is. &amp;#x200B; Personally, if I pay a fairly large licensing fee to a project that is going to sit in the same memory space, server space, etc as my system, I'm a bit more insistent that we have access to the code.
That's definitely the point I'm trying to make. I just don't like the gate-keeping that this community and others seem to have around what development environment people use. I'm the same way, probably used half a doze to a dozen different editors and IDEs combined (including VIM in CLI too) and settled on VSCode because it was easy to work cross-platform and comfortable when I needed to pick something new up.
 use Name\\Something\\Blue; use Name\\Something\\Red; use Name\\SomethingElse\\Yellow; or bust.
That really is not how security works.
If anything, step 1 should be downloading the trial. Then decide if it's worth the money. For many people it isn't.
I do heavy development every other month and VScode is doing fine. You go ahead and try to set up sftp upload on save in PHPStorm. Good luck. I mean it has sync, it has a shortcut for remote upload, but on save? 3 PHPStorm guys went through my firm, nobody managed to do it. So they were constantly pressing Ctrl+S and whatever they had bound for remote upload.
If you're changing the internal state of the model, I don't see why that shouldn't be a method on the model. If you're using the model to do something else (send an email based on a User model, saving the model to your database, etc), then it makes sense that these should happen outside your model.
Sublime Text is NOT an IDE and anyone who thinks so is a fucking moron (*) (*) Unless Sublime Text now has [half as good as PhpStorm's] autocomplete *and* the ability to utilize xdebug breakpoints and Step Into.
I havent even used 5% of what php storm has to offer, and it still by far is my favourite ide.
Want to know what pays the price of PhpStorm at least 2x a year for me? It's Local History. I can't tell you how many times I've lost HOURS, sometimes DAYS, of work just to recover it via Local History. I've never used another editor that has the capability to find individual changesets and even entire files and directories.
Spotted the zealot.
PHP 5 was slow compared to some other languages. If I'm correct, this is one of the reasons why Facebook created Hack. It really wasn't so bad. It got many new features and users during PHP 5, but then there were some newer and sometimes faster alternatives available (mainly Python and Node.js). But PHP 7 is a lot faster and with more features. So there is no reason why not use it. &amp;#x200B; Also, regarding LTS support. PHP 5 had very long support period. First PHP 5 was released almost 14 years ago and last PHP 5.6 was supported until 2019. PHP 7 was released in 2015 so users had almost 4 years to migrate. That's a lot of time. And PHP 5 currently has many vulnerability this will not be fixed. So even if websites currently works with PHP 5, it is very good to update it to PHP 7. It will become a lot faster and more secure.
I really don't get "spend money on this". I work with Java and I know IntelliJ is better but, for my work, it doesn't pay it. Eclipse does everything I need very well. It's not the best but it does everything fine. When I worked with PHP and Ruby n Rails I was happy with Atom, even knowing Jetbrains has a IDE for Rails and PHP.
JetBrains IDEs just unbeatable (except for C++ Development)
Hey I have a question regarding php, since you have 20 years of experience would you recommend starting with php, then going into a framework like laravel or full stack js , right now i can' t decide between php w/ laravel or mern. The javascript guys tend to be very fanatical so I wanted a different perspective from a seasoned php developer.
Why? To make it unreadable?
MySQL powers up some of the larges data deployments and far outpacing Postgres in sheer install base - that means there is a lot of knowledge on the subject matter available just by goggling your issues. I 'm not comparing MySQL to PostgreSQL in terms of features, simply the sheer install base. Its a lot easier to find help with MySQL that Postgres. Also "MySQL not great" does not seem like a quantified reason to migrate to diff DBMS. In either case both MySQL and Postgres will be obsolete in near future by distributed databases - TiDB, CockrocahDB, Trafodion etc...
Here, you are mostly correct. But your first comment about some imaginary people is not.
No one drives a Model-T because it's antiquated shit.
You don't have to buy it, you can use the EAP version for free. However, I recommend buying it to support the developers. I'm a proud "All Products Pack" owner for two years now. &gt;The Early Access Program (EAP) provides free access to pre-release builds of our products \[...\] &amp;#x200B; Other than that VSCode is quite versatile and I would recommend trying it out.
I am only focus on the idea of dynamic url generation, of course there are a lot of packages like symfony BinaryFileResponse but the title of the tutorial says that pure PHP and to let the users understand the process behind the scenes. The file_url table can be beneficial as a history of downloads and to know how many downloads about specific file. Another thing you mentioned about to separate the code from the view, again i am not focus on MVC pattern, everyone can implement this code on his own way and his own framework after he understand it perfectly.
Oh yes, this is it. &amp;#x200B; It's one of those things you don't know you need, until you need it. Being able to right click the project root and go to certain "checkpoints" such as when you committed, or when you accidentally hard reset your branch is a life saver.
can you show this with an example?
I use PHP Storm for work because my company provides it for me on the laptop, but I run VS Code on my home machine. I find Code to much less cumbersome, easier to customize, and more versatile when I work in other languages. After some experimentation with extensions, I've managed to duplicate most, if not all of the PHP Storm functionality in VS Code.
&gt;PHPStorm, is worth the money. Hacking editors into IDEs with plugins I wonder if he knows PHPStorm was originally just a plugin for Intellij? In fact, almost all their 'dedicated' editors started as plugins in Intellij.
You are exactly correct.
Why?
Fair points. As I mentioned &gt;for a tutorial it is better to explain things instead of saying use this (As counter argument I could say that you also added jQuery as a dependency but sure the tutorials point is the URL generation.) When I said "separation" I did not necessarily meant MVC nor MVVM. I only meant that maybe put the logic on the top of the PHP file or maybe add a link to an other tutorial with a disclaimer. My only concern that I know how some people follow these tutorials (sadly I was one of them). That is why it is better to hide some best practices in your tutorials. For example if you only want to show how you can serve protected information do not start with download, just with a protected web page. File download introduces a lot of other "variables".
Obvious blogspam is obvious
I really saw some articles about complaining about some weird things that were fixed in PHP 7. &amp;#x200B; But let me correct my original comment a little bit: Most people who complains about PHP only saw legacy PHP 5 or earlier code which isn't good for today's standards.
I want to add text but Reddit did not given me textarea it given me irl section so that I have added link.
&gt; You will also be vulnerable to any critical issues that are discovered in the PHP core, which could happen at any time. Which is not a real risk. Same can be said of 7. &gt; Beyond PHP itself, many userland dependencies no longer support PHP 5 and so any vulnerabilities found in those are unlikely to be fixed. So nope. &gt; Continuing to use it presents an ongoing liability issue that will need to be dealt with at some point and the further away that gets, the more complex a migration may be Not between 5 and 7. Lots of words, nothing substantive. SMH
Step 1) Dont touch that thing ... Step 1.1) Make your own framework or use Symfony or laravel.
You post only to promote your own blog. This is called excessive self promotion or blogspam and isnâ€™t welcome
Should I delete this post?
yes
Just one use statement per line, no grouping nor anything like that, please! &amp;#x200B; Parser complexity is already skyrocketing :-(
Interesting. Does it work even if you use `versions` directory with symlinks? We release a new version every day.
Then just don't use it?
I can see why some will find this useful. I would rather either use a Makefile, optionally combined with a concrete Composer plugin or Composer script.
Itâ€™s in the deployment settings, under options. CTRL-S, will upload all changed files to the remote deployment server. It can even check to make sure the remote file hasnâ€™t been changed before the upload, and then gives you the option to merge, or skip.
Most of them work and have very few bugs. The end user doesn't give a shit about the code architecture.
Sure, they work. But they're full of shitty security practices which is why there are forum breaches all the damn time.
thanks
I fixed this issue. Please check phpBolt.net/bolt.so It is Mac 64 bit - PHP 7.1
well take this simple advice : I was told recently at my internship because I asked the same thing. 1. Php is 85 % of the web 2. if you are not in a tech bubble you probably wont find anyone using mern 3. Worpdress / CMS's = where its at for serving any smal to mdeium buisness needs. 4. php also has frameworks... In case you want to earn money go with wordpress + php ... Though I would suspect that REACT might become more and more relevant in the wordpress space... its already starting with the new gutenberg editor. For every react job , there are like thousands wordpress / php jobs:
Hey, MedyGames, just a quick heads-up: **buisness** is actually spelled **business**. You can remember it by **begins with busi-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
[free](https://marketplace.visualstudio.com/items?itemName=xyz.local-history)
I couldn't setup xdebug on vs code. Docs sucks at showing step by step. I've managed to get it run with php storm tho
They were asking about how its handling of JS/TS was better but well done, I suppose.
Sublime Text is an editor. Always was, always will be. Shoving plugins up its arse does not make it an IDE.
I think these numbers are skewed. The version numbers are from sites that ARE leaking their version information. If we make the assumption that the sites that are NOT leaking their version information are being maintained by people who are more on top of things in terms of security and performance, it may also be a safe assumption that most of those sites we can't see the version information for are using stable releases.
seriously, if you code php for living there is no other option. I'm started using it just 9 months ago and I should do it years ago
Bizarre number of arguments about PHPstorm aside, I'd actually just like to thank the author for this post. The plugins mentioned are really useful and will make day to day PHP dev much smoother. Few more that I personally really enjoy (although not for PHP specifically) are gitlens, vscode-docker and if you are working with laravel or lumen I'd say laravel snippets and/or blade snippets can be pretty useful, although I kinda stopped using them lately. "Align" plugin deserves an honorable mention.
Most of the free ones feel insanely outdated, so you might be better off with something paid. One free one I kind of like is [https://www.elkarte.net/](https://www.elkarte.net/) which is a somewhat more modern fork of SMF. It's not that popular though.
Ok, going along with that analogy: yet you still want to drive the Model T which has no starter or safety features. You suggest adding a balloon on the steering wheel refusing to accept airbags.
We tried that but it creates conflicts more times than not grouping them. Thatâ€™s why i personally think thereâ€™s nothing wrong with single ones especially that you donâ€™t manage them.
At the risk of being downvoted further, I don't consider closed-source software to begin with, so in the end it really doesn't matter how much "better" PHPStorm may be at this or that; it doesn't enter into consideration because it fails the very first step.
As someone who's tried to write a parser for this, f this
Great job on your accomplishments! If you wish to expand on it you can look at moving it to a framework. It will take a lot of the repetitive load off your hands.
didn't know it was a plugin but i knew it was based on it. good to know
I agree on using the framework. If I were to make it today, I will use a framework, but unfortunately, I don't have any plans to expand it. Thank you :)
Just played around with VS Code for a bit. Here's some problems I noticed (I'm sure some of those could be fixed by installing plugins or changing settings): No file templates when creating new files? In PhpStorm, I get a nice list of options - PHP Class (automatically adds `&lt;?php` tag, `namespace` declaration, `class` declaration), HTML File (adds a basic HTML skeleton) and custom stuff like my Vue TypeScript Component template, which generates a skeleton Vue component with a `&lt;script lang="ts"&gt;` tag and uses [vue-class-component](https://github.com/vuejs/vue-class-component) + [vue-property-decorator](https://github.com/kaorun343/vue-property-decorator). File templates use [Apache Velocity](https://velocity.apache.org/), so using variables, conditionals etc. is no problem. I'll create dozens of files on a productive day, so this is a really important feature for me. I found the [File Templates](https://marketplace.visualstudio.com/items?itemName=brpaz.file-templates) plugin, but it seems very limited; simple variables only, no UI for editing templates, separate menu item instead of integrated into the file creation. Meh. Code generation in general isn't very good. Hitting Ctrl-Space seems to just bring up a list of every PHP constant, function, keyword and whatnot in existence. It's not context-aware at all. For example, when I place the cursor inside an empty class declaration and hit Ctrl-Space in PhpStorm, it *knows* there's only a handful of valid options in this context. VS Code either just spits out *hundreds* of useless choices or doesn't show anything at all. I also couldn't make Snippets work as well as Live Templates, but maybe that's just me. In PhpStorm, I type "pf", hit Tab and it generates a `public function`. How would I do this in VS Code? Also, how do I override or implement methods (Ctrl-O/Ctrl-I in PhpStorm)? Refactoring doesn't work at all? F2 does nothing and Ctrl-F2 is just a simple string-based find-and-replace. Extracting methods or variables doesn't even seem to exist. Code analysis is terrible even with Intelephense. It gets confused about types all the time, for example. Finding files (Ctrl-P) works OK, but finding classes doesn't exist? Couldn't find a way to jump to implementations of an interface, uses of a trait etc. Finding references works OK, but it's pretty slow. Honestly, this is all pretty basic stuff I use every day and I can't work without it. I guess my TLDR review of VS Code is: It's an OK text editor, but it's not an IDE (at least not for PHP).
Just because something works doesn't mean it should be used lol.
No kidding, still amusing that it works though.
nice catch
If your company agrees (and mine does) you can use their licence on your home machine. The only restriction is that you don't use both machines simultaneously. https://sales.jetbrains.com/hc/en-gb/articles/206544349-Can-I-use-a-commercial-license-purchased-by-my-company-at-home-
Even if that were the case, if he actually asked how to add a balloon, then airbags would be off-topic and not answering the actual question. Yours is the stereotypical Stackoverflow response: Q: "How can I do X?" A: "Why would you want to do X? You should be doing Y!"
Itâ€™s all to avoid XY problem. Thatâ€™s exactly why a lot of basic SO questions are answered like that: http://xyproblem.info
I love love love MyBB.
Well, I think it's very rude and egotistical to assume you know the correct solution to someone else's problem, rather than answer a question related to their own perceived solution.
Still doesn't address how your system can prevent RCE in the first place.
Agreed, from an academic standpoint this is hilarious, but if I ever saw this in the wild I'd probably cut my wrists.
When it's ready.
Why not git?
nice try
Thanks! I considered this, I would have gone for it but I genuinely look forward to my work sessions using VS Code - my team lead is almost convinced to begin recommending it to the other devs.
Thanks for the help I really appreciate it !!!!!!!!! One more question would you suggest learning html, javascript, php and mysql then learn laravel later on or go straight into laravel from php ?
2021
I normally use git for this, but still I've had Local History save my ass a couple times after I accidentally did `git reset --hard` at the wrong time thinking I already had the changes committed. It's nice to have a fail safe. Also, using it for the history SQL queries. I really wish there was a way IntelliJ products to log ALL SQL queries into a text file somewhere, because once you spend 20 minutes writing a complicated query and don't save it but then a year later you need to get the same information again, it's pretty frustrating.
I'm assuming late 2020. 7.4 is going to be the last 7.x release, and 8.0 development has already started.
This is what Iâ€™d bet on, given how releases are currently planned. Unless thereâ€™s an unexpected 7.5 release due to some technical oddity, it feels like a fairly safe bet.
Exceptional
I actually donâ€™t want it in 2020, rather hope it will take 2-3 more years. As it stands now, PHP 8 does not have any major new features except for JIT. If you pay attention to PHP RFC, youâ€™d realize that there ainâ€™t any remotely exciting new things being discussed so far. The generic and annotation RFC is still in early draft, the async and scalar objects RFC does not even exist. Itâ€™s highly unlikely any of these above useful features will be implemented within a year, and if PHP 8 is released in 2020 it will mostly just be PHP 7.4 + JIT. Is this good enough for a major release? Looks more like PHP 7.5 to me instead of PHP 8.
I definitely would like to see a "holy crap" style feature addition. I'm happy with any sort of advancement, though. I'm not sure what's more important to the internals team: a regular release schedule, or a knock-em-dead feature. Along those lines, 7.0 didn't really have a developer-usable feature that was anywhere along the terms of generics or scalar objects. It had insane performance benefits, and many useful but smaller features.
Actually PHP 7 did have major new features alongside of its performance improvement, unless you forgot the amazing things like scalar/return type hunting, anonymous classes, group use, null coalescing operator etc. If you have paid attention to the PHP RFC, you would not be able to find anything comparable to any of these that is actively in discussion and soon to be in voting phase. The best you can dig out are the ones in early draft like generics and annotations, and none of these look like they will be ready to implement within a year.
I'm convinced the people who built Jurassic Park were PHP developers. &gt; Your scientists were so preoccupied with whether or not they could, they didnâ€™t stop to think if they should.
I think there is no other way to look at these unless they are leaking their version info. Any other suggestion to find the right numbers available from your side ?
I purchased and love Sublime Text. Super lightweight. Also I do multiple scripting languages so I can use it not just for PHP
Finally
The advice /u/MedyGames gave is good, pretty close to everything I was gunna say. &gt; would you recommend starting with php If you're new to programming, PHP is quite easy to learn because the language is fairly forgiving, and it has by far the best documentation, especially because many people getting into PHP came from frontend/design backgrounds. However the default "forgiving" nature of PHP also means that it's very easy to write buggy code and deploy it into production. I highly recommend you turn on "error exceptions" from the start so that your code stops immediately and tells you when there's a problem, like trying to use an undefined variable. Then again, you have to learn JS anyway, so on top of this, just learning Node is less stuff to learn than a whole other language. Also most common small webdev jobs you might be working on in a web dev/design agency, or as a small time contractor are likely to be built using WordPress or a simlar CMS written in PHP. Node.js is less common for small brochure-ware websites, although it will slowly become more common. WordPress, despite all its flaws is still going to be around for a long time though. I hate many things about it, but I still use it for all small websites seeing there's so many themes and plugins etc. No need to reinvent the wheel for small sites. And also "better the devil you know"... WordPress is very "standard", and all the solutions you need are likely already online somewhere. &gt; laravel If you're going to pick a PHP framework, this is probably the best option these days. &gt; full stack js As mentioned in my original comment, this is what I'm using now for all my own projects... these are large long-term projects though. &gt; The javascript guys tend to be very fanatical Haha yep, although this applies to programming in general. We tend to have strong opinions about things, and often they're biased towards things we have experience with, and we talk about how things we have less experience with "aren't needed" - I know I've been guilty of this many times myself. It could be worse in Node because it's a newer language, and I would guess that the average age of a person who only knows Node to be younger than those who only know PHP. And pragmatism is something that gets better with age I reckon. &gt; mern Don't waste your time with NoSQL, at least in the beginning. It has its uses for certain kinds of data... but for 99% of projects, if there is only **one** database, it should probably be SQL. NoSQL is more relevant to chucking things into a [data lake](https://en.wikipedia.org/wiki/Data_lake) and then properly structuring them later on. It makes more sense on projects that have two databases: a properly structured and reliable one (SQL), and then the data lake / figure it out later / caching systems etc. Both postgres and mysql these days however make pretty good NoSQL databases anyway, seeing they support JSON now. Similarly to the node-devs-are-younger thing I mentioned above, Mongo and NoSQL rose around the same time as Node, that's really the only reason you see them "together" in guides etc. And for at least a lot of the devs with only a few years experience... they liked it because it was easier to just throw things into compared to actually having to learn to structure your SQL schema properly, and do migrations. Yes easier at start, but if you'll be running a long term project, and/or data integrity is important, that "easy to get started" nosql database very likely becomes an unmaintainable mess. Similar to the PHP errors thing I mentioned above, you want strictness from the start... that's way easier than cleaning up a clusterfuck with missing/broken data that nobody can really figure out later on. The whole "Node goes well with NoSQL" thing is slowly dying off. If you look for them on the web, you'll see many stories of companies realising it was a mistake, and then switching back to SQL. Definitely take some time to learn SQL as much as you. I left it too late... For like 15 years I wrote all sorts of code that wasn't necessary in PHP, which would have been much cleaner to simply write a few SQL queries for, layered using "SQL VIEWs". That's how I do things these days, and it's much easier, simpler to debug, and also much more re-usable. If somebody is telling you that NoSQL/Mongo is a good one-and-only database for all typical small webdev projects, it's probably because they never bothered learning SQL properly. **PHP vs Node** One important factor in your choice between learning PHP or Node for the backend might be what kind of work do you **want** to do, and also, what kind of work do you think you are most **likely** to find your way into... not necessarily the same thing, so think about both. Broadly there's two types of webdev jobs: * a) Working for a webdev agency or as a freelancer on multiple sites for your/your employer's clients. Most work will be PHP here. * b) Working full on time on a single internal system, maybe a startup/SaaS or similar. While PHP is still common enough here, there will be a higher ratio of Node compared to (a) above. Also more likely to be making use of React or Vue -vs- still using jquery (a). What kind of job are you looking for, or likely to get?
I'm broke and only write any php about once a week and only get paid for writing php (or anything else) about 4 times a year.
Another who can't read. I already explained that we dont live in a vacuum and language bloat reach you wether you like it or not either through libs or teammates. Since you can't read, I wont bother replying. Blocked and ignore as well.
Just a quirk about the ways of PHP. The only reason variables typically can't have spaces and quotes is that by the lexer definition these are not recognized. Your code bypass it. But I guess you can even use an object as a variable name at this point, anything with a __toString() might do
If you can sneak it past the lexer into the symbol table the rest of the system will deal with it quite happily. extract() can perform a similar trick.
They already merged and deployed this monstrosity years ago. The php internals guys, nearly none of them have ever managed a team of, you know, actual PHP developers. In fact, about 75% of them have not actively and professionally coded in PHP itself in the last 5 years. Less than 20% of them have been PHP team leads in the last 5 years. No, they live in C.
You can use similar methods with variables named using numbers. Including doing simple math operations. I had an idea a while ago to use this method for obfuscation but never did anything with it [https://3v4l.org/bi1QN](https://3v4l.org/bi1QN) &lt;?php ${10} = "Foo\n"; echo ${8 + 2}; echo ${5 * 2}; echo ${3 * 3 + 1}; Outputs: &gt;Foo &gt; &gt;Foo &gt; &gt;Foo
&gt; scalar/return type hunting, anonymous classes, group use, null coalescing operator etc How are those amazing? They are nice to haves for sure.
My favorite new thing to screw with other people is using emoji's for function names and variables. This is valid too: `&lt;?php` `$ðŸ¤“ = "NERD\r\n";` `function ðŸ”’() { echo "lock function"; }` `echo $ðŸ¤“;` `ðŸ”’();`
If PHP devs were building Jurassic Park, they would be starting with a cow costumed as a camel, trying to make it look like a T-Rex but ending up with an Emu that can drink more shots than anyone you have ever seen
Stop being such a drama queen
I hope I never have to work with you
But why shouldn't they? I mean, it's not like they went the extra distance to include those things, they just didn't explicitly prevent them. And why should they? Responsible developers can just not use them.
Well aware that the feature is already merged: the amount of complexity added to tooling I maintain rised a lot because of that.
Or you could use a phar?
&gt; Or you could use a phar? Can you use that for a web application? Apache does not handle that well or does it?
It would cause the apocalypse.
Die
&gt; can you use that for a web application? Yes https://www.php.net/manual/en/phar.webphar.php#refsect1-phar.webphar-examples &gt; How does Apache handle a phar file? It handles it fine. It just needs AddType
Oh my wizard
Interesting :)))
What a phenomenally bad idea
Exit
Look up the COBOL ALTER statement for true mind-fuckery. I cut my programming teeth in commercial environments on COBOL and in all the shops I worked in use of ALTER was essentially a sackable offence.
It's better to not restrict developers... I can't think of a valid reason anyone would actually use spaces or quotes in their vars, but it's good to know that one *could*.
I just stumbled across this yesterday and now I see a post about this here today. Nice!
Need to try these out. Thanks for sharing!
I get it, but the last thing we should be doing is encouraging people to obfuscate their server-side code.
[https://github.com/appaydin/gclib](https://github.com/appaydin/gclib)
i dont know
Thats a good mixed api.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
sleep
Break;
Oh god, I wonder if anyone has done some complext logic for variable names &gt;.&lt;
They're only possible through variable variables and expression variables, though, both of which shouldn't be in the language at all (for a myriad of good reasons).
you are not likely to work with frameworks right from the get-go if you are a new dev... so focus on the basics first before frameworks... Also the tricky parts are not the basics , but everything around what the company uses... I find myself adding things to the curriculum like OOP, namespaces , composer , GIT (not github) . Random things like how to import a database... I felt like dumbfounded at some of these because I never used it ... But then you realize the professional world is very different from what tutorial world teaches .... Dont focus on frameworks at all . Focus on the basics , then apply and learn that framework on the job. Chances are that you wasted your time sincecompany uses smth diffferent ... the basics dont change though.
How about variable object properties?? `$val = $myObj-&gt;{$prop};`
And what are those reasons? Not for not using them, but for them not existing at all.
Lossless? As opposed to...?
As opposed to incomplete, broken or riddled with uncertainties and side effects because of lossy compression. But yeah, just a marketing word that holds no value. It's like saying: 100% interpretable as PHP or Opcode ready.
Very interesting, &amp;#x200B; $var = "truen't"; $function = function () { return $var; }; $$function() = "This doesnt work"; ${$function()} = "This does work";
You can't separate the two concepts. Assuming we're talking about development in general, reasons for "responsible developers" not using them **are** reasons for them not existing at all. We should all aspire to be responsible developers, after all. There will always be features that are only situationally useful. For example, heredocs. I would probably go out on a limb and say that most developers don't use heredocs regularly, and some large percentage have probably never used them at all. But there's a big difference between a feature being useful and just not commonly used versus a feature being irresponsible and inadvisable to use in any context. Heredocs are an example of the former, and so there is no problem with them being in the language, even if most developers never use them at all. But variable variables and expression variables are an example of the latter, and they simply shouldn't exist. As for _why_ they're irresponsible, there's a whole slew of material on the topic around the internet if you're curious. Making the code in question impossible to statically analyze is one good reason. Making it extremely hard to read and follow is another. The list of reasons is a mile long, and no matter what use-case you think you've found for variable variables or expression variables, there will _always_ be an objectively better way to solve the problem.
What is `$prop` and where does it come from? Why don't you know what it is? What if it ends up being something that doesn't exist (logic issue)? What if it ends up being something that shouldn't otherwise be accessible (security issue)? What if it ends up being null? What if it ends up being a property that returns a different type than you're expecting? The "what if" list goes on and on here. Code like your example can always be rewritten without expression variables, and it will be more readable, more analyzable, and more reliable as a result. There's really only one reason people write code like this: they're attempting to be "clever". But "clever" code is rarely (if ever) _good_ code.
This technique is often used in obfuscation attempts (hacked PHP sites). It is good to understand how they work.
Most obfuscating scripts are lossy and try to make the code unreadable.
&gt;https://www.php.net/manual/en/phar.webphar.php#refsect1-phar.webphar-examples Interesting stuff.. TIL!
Looks interesting. Can't seem to find any tests though? How have you found Swoole to work with. I'm doing some work with Lumen currently. What's the main advantage to Swoole, requests per second performance I'm guessing?
You answered your own question.
So if they are lossy, how would their functionality be guaranteed? All I can think of is building an AST, returning that to code and then compress it. That way you lose documentation and unwanted whitespace. But otherwise, how would you apply lossy compression?
There's akways someone complaining about missing tests. It's open source. Feel free to add them yourself.
Wow, you sure showed me I guess.
It's not generally a good idea to backfill your tests imho. Generally I look for tests to learn more about how the code works when I'm browsing a repo. I generally won't use a package myself unless it has automated tests. It's an indication for me that problems may lie ahead.
Here are three effective types of obfuscation that can be applied: - Rename Obfuscation - String Encryption - Control Flow Obfuscation source: https://www.preemptive.com/obfuscation
I'm not sure I understand you. Are you suggesting security by obscurity?
Imagine the uncertainty of an untested system had some visual quality to it. Like, if it was a kind of green slime. Then, looking at something without tests we would think; "oh, I don't like how full of green slime that is". Perhaps we'd even be moved to let someone know (who maybe didn't realise how much the green slime messes up a system) that there's a bit of green slime on their thing. Like; "you maybe want to wipe some of that green slime off your system, so you don't wake up to an outage and a lot of lost money. It really gets stuck in the gears..." Now, imagine someone saying; "Hey! Stop warning them about the green slime and wipe it off yourself."
Structures like Lumen, Symfony need Http server. PHP-FPM is inadequate and very slow in this regard. Swoole or ReactPHP's built-in web servers are very fast. The reason is async work. You can do this with Lumen, but you'll need a server to run PHP.
I care about the tests, but I don't have much time right now.
"I care about the tests, but I don't have much time right now." ~basically every nontechnical project manager...
Continue
Omg please stop programming.
ðŸ‘
I've deployed a few Lambdas with Bref on production, AMA if you have questions
Or Lumen
Except it's not that innocent, since "you maybe want to wipe some of that green slime off your system, so you don't wake up to an outage and a lot of lost money" is actually usually a lot more like "I would never even consider using your free thing because it has green slime on it, despite the fact that it's free and you're completely open to allowing me to wipe all the slime off it that I want to." Well, that, and there's also the fact that those same supposed Good Samaritans don't really care where you put the green slime after its wiped off, how you wipe it off in the first place, or what else is covering your thing. All that matters is to them is that no green slime is visible, which is completely and utterly superficial and meaningless.
Awesome! I'm always looking for case studies to share with those curious about AWS Lambda. Would you have any information to post in https://github.com/brefphp/bref/issues/267? E.g. whether you built websites/APIs/workers, what's the average response time, if you saved money migrating from EC2, which frameworks and AWS services you are using, etc.
I was just playing around with something similar on Tuesday.... Variables that have "\[ \]" brackets in their name. &lt;?php $object = new stdClass; // variable has "[]" in its name $property = 'var[]'; $object-&gt;$property = [0,1,2]; $object-&gt;var = [3,4,5]; // object now contains a property called "var[]" var_dump($object); // removing "var" doesn't remove "var[]" unset($object-&gt;var); var_dump($object); // you have to explicitly remove "Recruiter[]" which is only possible through a variable reference unset($object-&gt;$property); var_dump($object);
You can also use [non-breaking spaces, for example in tests](https://mnapoli.fr/using-non-breakable-spaces-in-test-method-names/). I've been using this technique for a few years now and it is really awesome.
Instead of object, type hint StdClass, which is the root object everything extends in PHP's inheritance structure. It will match every instantiated object.
How do you plan to place the Debugger in? AST, tokens...?
Why not use instant upgrades with Rector?
You could create proxy classes kind of like Doctrine ORM. Every class in your system would get a proxy class that extends / decorates your originals and includes the metric gathering. The problem with that is you still need to update where all of your classes are instantiated. If you use a container and/or factories, that might not be *too* big a deal. Still a lot of updates. Maybe a service like [https://blackfire.io/](https://blackfire.io/) would be a better solution?
It's too late in the evening for me to try and wade my way out of the horrible green slime mess I've created. ðŸ˜…
That part doesn't appear to be the problem, rather it's trying to wrap the `OtherClass` in a debugger object, which doesn't satisfy `doSomething()`'s typehint.
It's a Laravel project. I can swap it on the Laravel Container easily. I could even make it work if I had one debugger per interface. I'm just trying to avoid the boring work of writing one wrapper per interface that I want to swap.
The instantiation is definitely the easiest part as I'm using Laravel container. I also don't want to swap everything at once, just on-demand, which makes the instantiation even easier. I'm not familiar with Doctrine or how it does the proxy class. Can you recommend a more specific reading on the subject so that I can try to use it?
https://github.com/Ocramius/ProxyManager might be what you are looking for..
https://ocramius.github.io/blog/zf2-and-symfony-service-proxies-with-doctrine-proxies/ They're similar to what your `Debugger` class is doing, but specifically meant to proxy to individual parents instead of any object.
I see. For boring work use AST. If you could give me clear step-by-step manual what you need, I can create a Rector rule that does what you need.
Do you think your little analoge makes you look smart? Because I said it's open source and if you want tests. Write it yourself. Point being that this guy owes you nothing. And if you want something implemented in an open source project you do it yourself. Instead of demanding tests everywhere like you people do.
Objects do not automatically extend from stdclass. There is an `object` typehint as of 7.2 that will do what youâ€™re describing however.
Well TIL!
 function __get($prop) { if (logic goes here) { return $this-&gt;{$something}; } return null; }
This article says how to do it. Basically remote xDebug sessions integrate flawlessly. I even go th extra mile of launching my PHP through WSL via \`php artisan serve\` which is basically \`php -S\` and when I want a debug session VSCode just hooks into it and provides debug data inside VSCode with breakpoint support and whatnot.
&gt; Removing the type-hints are not an option, specially because these wrappers wouldn't stay in production for too long, it would be used shortly and then removed. That sounds like a perfect use-case for removing the typehints, IMO. As part of the debugger removal process, add them back in. Ideally you could do the entire thing on a branch so you can revert it as a whole when you're done. An interface really is the only "correct" solution here, both on a technical and pragmatic level. If both union types and generics were in the language, maybe. But I don't believe you can have a meaningful one and still get away with the `__call` approach. If you're going to rely on magic, just go all-in and make sure you can kill it all with fire when you're done.
probably the associvity of $$
Right. As I said, this "clever" code suffers all the aforementioned problems, and so will any code in which you use the class that this is defined in.
Ok. That's enough reddit for today.
This is basically just phar but for a single file?
I see your point and it's a strong one. I guess I wanted to have the cake and eat it too. I was hoping to be able to write a generic Debugger that I could easily bind in the container whenever I wanted. The MetricCollector would be a wrapper around AWS X-Ray and the Logger PSR, simultaneously, giving a powerful observability when running PHP on AWS Lambda. Having a call to X-ray before start and after a method finish would give easy metric on how long it takes to execute a segment of the code. The need to remove type-hint would make my job possible now, but I wouldn't accomplish a long-term library that could help me get metrics on several projects.
&gt;didn't know it was a plugin It started as a plugin, you can still get the PHP plugin for Intellij but it's behind the huge paywall of the ultimate edition. Most of their dedicated editors start as plugins and then when they become popular jetbrains turns them into a separate product and pulls the plugins from the free version of Intellij. So you either have to purchase the dedicated product or pay the Intellij ultimate license to get that language support.
Sure, I'll give it a try
I created a video on Swoole some time back. https://youtu.be/atHmkjdcf6o
Create a scheduled task with Task Scheduler.
You could use â€œsvranyâ€... let me dig it up and Iâ€™ll get back to you with an updated comment with instructions if I can find them.
Thanks, I'il watch.
Can't relate. I find that PHPStorm is a lot smarter about javascript than VSCode is. Perhaps for typescript it's somewhat up to par. Otherwise, no. I've played with VSCode for a while and found it pretty lacking even in things which I accept as basic now. And I do PHP to JS perhaps 20 / 80. I still keep it around for quick file editing like .inis or yamls as VSCode is fast too boot up (although clogs up pretty quick if you work with multiple windows, much like chrome does).
Or you can buy IntelliJ and have all other other main IDE's as a plugin within it.
What the person was referring to is language context aware intellisense rather than lexical scope aware intellisense when compared to generic editors like VSCode or Sublime. Yes you can shove plugins in those, however plugins do not disable base functionality of the editors, so you end up with jank rather than accurate suggestions.
If you donâ€™t have time to write tests, then you donâ€™t have time to write a trustworthy production application. Source: most people make this mistake at least once in there career. The earlier the better.
 sc create "PHP7" binpath= "C:\www\php-7.3.4-nts-Win32-VC15-x64\php-cgi.exe -b 127.0.0.1:9999" Should do it.
On a couple of our servers, we have two instances of Apache running at the same time. One for our production sites and the other for an internal resource monitor. You can set up a directory like: C:\ServerApp\Apache and C:\ServerApp\PHP In the C:\ServerApp\Apache\Conf\httpd.conf, configure it to listen only port 9999 and set up the PHP extension. Then, you can create a service by running the following command: "C:\ServerApp\Apache\bin\httpd.exe" -k install -n "Apache - Small Server App" -f "C:\ServerApp\Apache\Conf\httpd.conf" This will create a standalone Windows Service called "Apache - Small Server App", using the binaries and configuration files located in C:\ServerApp\Apache
NSSM can do it, I'm using it and it runs flawlessly.
That did not work for me, has it worked for you?
I just run PHP under Apache (it runs as a service) and that is probably the best way to go. Also might be more accurate to your production environment.
Yes. I've had more success with the NSSM though: https://nssm.cc/
Part of the answer is that the PCI compliance requirements set by payment processors have a lot conditions that canâ€™t be met by something like this. Typically theyâ€™ll want an outside host to handle payment transactions that would live on a different server. If you look at platforms such as XCart and others, they have all evolved into creating entirely separate products for the interface between your cart and the processor.
If â€œat your service â€œ still exists itâ€™s a GUI version of SC
If that's the problem, wouldn't Omnipay run into the same issues since it supports token billing?
TBH, I really donâ€™t know. It has been a couple of years since I was involved in that part of the industry. When I was involved with XCart (I know, I know...), they had their X-Payment system that did everything you were asking. It was proprietary though and you couldnâ€™t host it yourself.
What confuses me most is probably best represented using Stripe. Typically, you'd use Stripe Elements on the JS side and when the user enters their card details, that sends you a payment agreement token, say "tok\_12345". You then use that token to either conduct a nonrecurring payment or recurring payment through the Stripe PHP API with the correct metadata. There would seem to be no difference from the perspective of PCI compliance to the end user between nonrecurring and recurring payments - save that you can upgrade the product that a user is subscribed to and therefore charge them more - and Laravel Cashier exists and is executed locally. &amp;#x200B; Other payment processors that support subscriptions tend to behave in the same way, where there is not really any difference from a security perspective compared to the case with Stripe. Which is why I'm kind of skeptical about PCI compliance being the reason, but maybe it is, I don't know.
This exactly. Payment is an important-enough thing to most companies (capable of having something _worth_ open-sourcing) that they generally don't have time to open-source their whole entire implementation. Open sourcing something so comprehensive generally comes with a lot of overhead that those teams don't want to deal with.
It is because of compliance like Vacman85 said. Having recurrent payments requires the PSP/Aggregator to tokenize your card data once and then use it again which means safe storage, what the industry calls COF, short for Credentials On File. If doing MO/TO or E-commerce them you must comply with that. When you make "charges on demand" you just request the data each time so the payments provider don't have to store it but rather just send it directly to the Acquiring bank. SOURCE: I'm a technical lead on a payments processor company.
&gt;It is because of compliance like Vacman85 said. Having recurrent payments requires the PSP/Aggregator to tokenize your card data once and then use it again which means safe storage, what the industry calls COF, short for Credentials On File Stripe, PayPal and Apple Pay (as mentioned by the OP) all support recurring payments. It's the payment processor that stores the credit cards - not the end user. Maybe the PHP-FIG should develop a PSR standard for payment processing...
&gt;It is because of compliance like Vacman85 said. Having recurrent payments requires the PSP/Aggregator to tokenize your card data once and then use it again which means safe storage, what the industry calls COF, short for Credentials On File Stripe, PayPal and Apple Pay (as mentioned by the OP) all support recurring payments. It's the payment processor that stores the credit cards - not the end user. Maybe the PHP-FIG should develop a PSR standard for payment processing...
I never said that the end user stores the data. The PSP is the one that needs to store it if they want to do recurring and that requires compliance.
How is Stripe -&gt; 3rd Party -&gt; You any safer than Stripe -&gt; You unless the 3rd Party cuts out features that Stripe supports such as changing which subscription the user is subscribed to? It's not like you keep their credit card on file in the Stripe -&gt; You case - you end up with a customer ID and subscription ID that you can reference, and a card ID/fingerprint as well if you wish although that doesn't tell you what the card number is.
It makes sense in that having a 3rd party does abstract out a lot of stuff for you. Problem is when the 3rd party doesn't support popular options like Apple Pay, and then you're left rolling your own all over again and having to mix it in with everything else being on the 3rd party. I guess I'm just surprised that we have Payum and Omnipay and all that nice stuff for abstracting out nonrecurring payments but there doesn't seem to be an equivalent for recurring payments - though recurring payments are definitely a much bigger task with a greater risk of damage if bugs happen due to the recurring nature of the problem, as you could miss webhook/IPN messages if things went wrong, leading to an incorrect state.
The PSPs the OP mentions _do_ support it tho. The fact that they provide it and that they're too big to fly under the radar strongly implies that they are PCI compliant
Why not use IIS? The php manager is pretty sweet, which allows you to switch or upgrade versions + add/enable/disable extensions quite simply.
Because too many businesses use recurring payments in the sneakiest way possible. If you build a payment implementation where you can send in payments with a 'recurring' flag that you can set to TRUE you're going to end up dealing with a lot of people wanting to cancel that or get refunds. I used to work for a shady dating website, buy tons of banner ads, thousands click those banners, hundreds start the payment flow, tens start the payment process, a few complete the payment, now hope they don't notice that you're taking a few bucks each month. Meanwhile all female profiles are fake. We were constantly removing payment methods and adding new ones because they all stopped doing recurring payments after a while, exactly because of the shady shit we were pulling.
Run a docker stack on that dirty machine. Thats sounds totally not production ready.
I found something that works, using a Powershell script to run php and nginx in a "hidden" mode, from here: https://stackoverflow.com/questions/10061191/add-nginx-exe-as-windows-system-service-like-apache/39802422#39802422 They used this PS script: $fcgiPort = "127.0.0.1:9000" $PHPini = "c:\php\php.ini" $ErrorActionPreference = "SilentlyContinue" function restart { Push-Location /nginx Stop-Process -Force -Name nginx Start-Process ./nginx.exe -WindowStyle Hidden Stop-Process -Force -Name php-cgi Start-Process "c:\php\php-cgi.exe" -ArgumentList ("-b" + $fcgiPort + " -c " + $PHPini) -WindowStyle Hidden Pop-Location } restart
Let's say you bite the bullet and rewrite it. Here's the most important question: how do you ensure your "modern" rewrite doesn't end up "disgusting" and "an ever time consuming issue"? If you plan on answering "by following PSR-1, 2, using Composer, and adding unit tests" then you really shouldn't start a rewrite yet.
Heads up, this one can't deal with reference arguments and return results. Those are rare, but still.
How about just enabling profiling (XHR, X-debug) for some of your requests. Because that's what it does.
I'm not zealous about type-hints in PHP, but I don't understand how your proposal helps here.
&gt; StdClass &gt; stdclass God damn it, it's written "stdClass"! :P
One of those days, Ocramius. Straight to the moon.
I've never seen PhpStorm group them so far.
&gt; You realize almost nobody uses this? What puzzles me is why did the core team not realize it, before they implemented that feature.
Have you tried braintree?
dunno if it can do it automatically (probably not), but if you put a cursor to the namespaced section you want to group by and press cmd + i, it will group them
/me runs through the codebase, clicking CTRL+i and making spurious commits.
This week, from the god-damn-it-why department.
&gt; That way you lose documentation RIP annotations.
For the record you don't even need the AddType. Just have an index.php and the rest of the app can be in a PHAR included into it.
&gt; Itâ€™s highly unlikely any of these above useful features will be implemented within a year, and if PHP 8 is released in 2020 it will mostly just be PHP 7.4 + JIT. Is this good enough for a major release? That's... a really weird argument. You want to hold off PHP 8 so it accumulates more features worthy of a major release, instead of getting these features gradually over the same period? Why? PHP is a language, for programming. It's not an MCU movie.
I second Braintree, it's one of the easiest payment integrations I've ever done, great support, excellent, well-documented library.
Check out Drupal Commerce License Recurring.
Bc its an API not a library. There are plenty of reacurring payment APIs that you can integrate into your app.
The lightweight approach would probably be to use the recurring features in a very vendor-heavy way (start it up, get all info on demand via API whenever you or the user needs it). Store as little as possible on your side. &amp;#x200B; If you're going to keep recurring order data yourself and have full control over retries etc, token billing with cron-jobs is the way to go. You need to be careful and build a very testable system so stuff won't go wrong, and that you'll catch any problems when it inevitably does. Also add cron-jobs that check "yesterday's billings" so that you'll be alerted if something doesn't work correctly. It's not really "hard", you just need to be thorough. &amp;#x200B; The fact that token billing is so vendor specific is probably the reason why it's hard to abstract enough to build high-level libraries that support multiple vendors well enough.
Your skepticism is correct. PCI compliance isn't relevant.